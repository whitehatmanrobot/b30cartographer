                 &u.recvInfo,
                            recvLength,
                            IoStatus);
            }
            else
                res = FALSE;

        }
        break;

    case IOCTL_AFD_RECEIVE_DATAGRAM:
    case IOCTL_AFD_RECEIVE_MESSAGE:
        {
            AFD_RECV_MESSAGE_INFO   msgInfo;
            ULONG   recvLength;

            if (endpoint->DisableFastIoRecv ||
                   !IS_DGRAM_ENDPOINT(endpoint) ||
                    ((endpoint->State != AfdEndpointStateBound ) &&
                        (endpoint->State != AfdEndpointStateConnected)) ) {
                return FALSE;
            }
            try {
                if (IoControlCode==IOCTL_AFD_RECEIVE_MESSAGE) {
    #ifdef _WIN64
                    if (IoIs32bitProcess (NULL)) {
                        PAFD_RECV_MESSAGE_INFO32    msgInfo32;
                        //
                        // If the input structure isn't large enough, return error.
                        //

                        if( InputBufferLength < sizeof(*msgInfo32) ) {
                            // Fast io can't handle error returns
                            // if call is overlapped (completion port)
                            // IoStatus->Status = STATUS_INVALID_PARAMETER;
                            res = FALSE;
                            break;
                        }


                        //
                        // Validate the input structure if it comes from the user mode
                        // application
                        //

                        if (previousMode != KernelMode ) {
                            ProbeForReadSmallStructure (InputBuffer,
                                            sizeof (*msgInfo32),
                                            PROBE_ALIGNMENT32 (AFD_RECV_MESSAGE_INFO32));
                        }

                        msgInfo32 = InputBuffer;


                        //
                        // Make local copies of the embeded pointer and parameters
                        // that we will be using more than once in case malicios
                        // application attempts to change them while we are
                        // validating
                        //
                        msgInfo.ControlBuffer = UlongToPtr(msgInfo32->ControlBuffer);
                        msgInfo.ControlLength = UlongToPtr(msgInfo32->ControlLength);
                        msgInfo.MsgFlags = UlongToPtr(msgInfo32->MsgFlags);
                    }
                    else
    #endif // _WIN64
                    {

                        if( InputBufferLength < sizeof(msgInfo) ) {
                            // Fast io can't handle error returns
                            // if call is overlapped (completion port)
                            // IoStatus->Status = STATUS_INVALID_PARAMETER;
                            res = FALSE;
                            break;
                        }

                        //
                        // Capture the input structure.
                        //


                        //
                        // Validate the input structure if it comes from the user mode
                        // application
                        //

                        if (previousMode != KernelMode ) {
                            ProbeForReadSmallStructure (InputBuffer,
                                            sizeof (msgInfo),
                                            PROBE_ALIGNMENT (AFD_RECV_MESSAGE_INFO));
                        }
                        msgInfo = *(PAFD_RECV_MESSAGE_INFO)InputBuffer;
                    }
                    if (previousMode != KernelMode ) {

                        ProbeForWriteUlong (msgInfo.MsgFlags);
                        ProbeForWriteUlong (msgInfo.ControlLength);
                        //
                        // Checking of recvInfo->Address is postponed till
                        // we know the length of the address.
                        //

                    }
                }
                else 
                {
                    msgInfo.ControlBuffer = NULL;
                    msgInfo.ControlLength = NULL;
                    msgInfo.MsgFlags = NULL;
                }
#ifdef _WIN64
                if (IoIs32bitProcess (NULL)) {
                    PAFD_RECV_DATAGRAM_INFO32    recvInfo32;
                    LPWSABUF32          tempArray;
                    ULONG               i;
                    

                    //
                    // If the input structure isn't large enough, return error.
                    //

                    if( InputBufferLength < sizeof(*recvInfo32) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }


                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode ) {
                        ProbeForReadSmallStructure (InputBuffer,
                                        sizeof (*recvInfo32),
                                        PROBE_ALIGNMENT32 (AFD_RECV_DATAGRAM_INFO32));
                    }

                    recvInfo32 = InputBuffer;


                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //
                    tempArray = UlongToPtr(recvInfo32->BufferArray);
                    msgInfo.dgi.BufferCount = recvInfo32->BufferCount;
                    msgInfo.dgi.AfdFlags = recvInfo32->AfdFlags;
                    msgInfo.dgi.TdiFlags = recvInfo32->TdiFlags;
                    msgInfo.dgi.Address = UlongToPtr(recvInfo32->Address);
                    msgInfo.dgi.AddressLength = UlongToPtr(recvInfo32->AddressLength);

                    //
                    // If fast IO is not possible or this is not a normal receive.
                    // bail.
                    //
                    if( (msgInfo.dgi.AfdFlags & AFD_NO_FAST_IO) != 0 ||
                            msgInfo.dgi.TdiFlags != TDI_RECEIVE_NORMAL ||
                            ( (msgInfo.dgi.Address == NULL) ^ 
                                (msgInfo.dgi.AddressLength == NULL) ) ) {
                        res = FALSE;
                        break;
                    }

                    //
                    // Validate all the pointers that app gave to us and
                    // calculate the length of the send buffer.
                    // Buffers in the array will be validated in the
                    // process of copying
                    //

                    if ((tempArray == NULL) ||
                            (msgInfo.dgi.BufferCount == 0) ||
                            // Check for integer overflow (disabled by compiler)
                            (msgInfo.dgi.BufferCount>(MAXULONG/sizeof (WSABUF32))) ) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead(
                            tempArray,                                  // Address
                            // Note check for overflow above (should actually be
                            // done here by the compiler generating code
                            // that causes exception on integer overflow)
                            msgInfo.dgi.BufferCount * sizeof (WSABUF32), // Length
                            PROBE_ALIGNMENT (WSABUF32)                 // Alignment
                            );
                    }

                    if (msgInfo.dgi.BufferCount>sizeof(localArray)/sizeof(localArray[0])) {
                        try {
                            pArray = AFD_ALLOCATE_POOL_WITH_QUOTA (
                                            NonPagedPool,
                                            sizeof (WSABUF)*msgInfo.dgi.BufferCount,
                                            AFD_TEMPORARY_POOL_TAG);
                            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets 
                            // POOL_RAISE_IF_ALLOCATION_FAILURE flag
                            ASSERT (pArray!=NULL);
                        }
                        except (EXCEPTION_EXECUTE_HANDLER) {
                            // Fast io can't handle error returns
                            // if call is overlapped (completion port)
                            // IoStatus->Status = GetExceptionCode ();
                            pArray = localArray;
                            res = FALSE;
                            break;
                        }
                    }

                    for (i=0; i<msgInfo.dgi.BufferCount; i++) {
                        pArray[i].buf = UlongToPtr(tempArray[i].buf);
                        pArray[i].len = tempArray[i].len;
                    }

                    msgInfo.dgi.BufferArray = pArray;

                }
                else
#endif // _WIN64
                {

                    //
                    // If the input structure isn't large enough, return error.
                    //

                    if( InputBufferLength < sizeof(AFD_RECV_DATAGRAM_INFO) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }

                    //
                    // Capture the input structure.
                    //


                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode ) {
                        ProbeForReadSmallStructure (InputBuffer,
                                        sizeof (AFD_RECV_DATAGRAM_INFO),
                                        PROBE_ALIGNMENT (AFD_RECV_DATAGRAM_INFO));
                    }

                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //

                    msgInfo.dgi = *(PAFD_RECV_DATAGRAM_INFO)InputBuffer;

                    //
                    // If fast IO is disabled or this is not a simple
                    // recv, fail
                    //

                    if( (msgInfo.dgi.AfdFlags & AFD_NO_FAST_IO) != 0 ||
                            msgInfo.dgi.TdiFlags != TDI_RECEIVE_NORMAL ||
                            ( (msgInfo.dgi.Address == NULL) ^ 
                                (msgInfo.dgi.AddressLength == NULL) ) ) {
                        res = FALSE;
                        break;
                    }

                    //
                    // Validate all the pointers that app gave to us.
                    // and calculate total recv length.
                    // Buffers in the array will be validated in the
                    // process of copying
                    //

                    if ((msgInfo.dgi.BufferArray == NULL) ||
                            (msgInfo.dgi.BufferCount == 0) ||
                            // Check for integer overflow (disabled by compiler)
                            (msgInfo.dgi.BufferCount>(MAXULONG/sizeof (WSABUF))) ) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead(
                            msgInfo.dgi.BufferArray,                       // Address
                            // Note check for overflow above (should actually be
                            // done here by the compiler generating code
                            // that causes exception on integer overflow)
                            msgInfo.dgi.BufferCount * sizeof (WSABUF),    // Length
                            PROBE_ALIGNMENT(WSABUF)                     // Alignment
                            );
                    }
                }

                recvLength = AfdCalcBufferArrayByteLength(
                                     msgInfo.dgi.BufferArray,
                                     msgInfo.dgi.BufferCount
                                     );

                if (previousMode != KernelMode ) {
                    if (msgInfo.dgi.AddressLength!=NULL) {
                        ProbeForWriteUlong (msgInfo.dgi.AddressLength);
                    }
                    //
                    // Checking of recvInfo->Address is postponed till
                    // we know the length of the address.
                    //

                }


            } except( AFD_EXCEPTION_FILTER_NO_STATUS() ) {

                // Fast io can't handle error returns
                // if call is overlapped (completion port)
                // IoStatus->Status = GetExceptionCode ();
                res = FALSE;
                break;

            }

            //
            // Attempt to perform fast IO on the endpoint.
            //

            res = AfdFastDatagramReceive(
                       endpoint,
                       &msgInfo,
                       recvLength,
                       IoStatus
                       );

        }
        break;

    case IOCTL_AFD_SEND:
        {
            union {
                AFD_SEND_INFO           sendInfo;
                AFD_SEND_DATAGRAM_INFO  sendInfoDg;
            } u;
            ULONG   sendLength;

            //
            // Check the validity of the union above.
            //
            C_ASSERT (FIELD_OFFSET (AFD_SEND_DATAGRAM_INFO, BufferArray)
                        == FIELD_OFFSET (AFD_SEND_INFO, BufferArray));
            C_ASSERT (FIELD_OFFSET (AFD_SEND_DATAGRAM_INFO, BufferCount)
                        == FIELD_OFFSET (AFD_SEND_INFO, BufferCount));
            C_ASSERT (FIELD_OFFSET (AFD_SEND_DATAGRAM_INFO, AfdFlags)
                        == FIELD_OFFSET (AFD_SEND_INFO, AfdFlags));

            //
            // If fast IO send is disabled
            //      or the endpoint is shut down in any way
            //      or the endpoint isn't connected yet
            //      or the TDI provider for this endpoint supports bufferring,
            // we do not want to do fast IO on it
            //
            if (endpoint->DisableFastIoSend ||
                    endpoint->DisconnectMode != 0 ||
                    endpoint->State != AfdEndpointStateConnected ||
                    IS_TDI_BUFFERRING(endpoint) ) {
                return FALSE;
            }



            try {

#ifdef _WIN64
                if (IoIs32bitProcess (NULL)) {
                    PAFD_SEND_INFO32    sendInfo32;
                    LPWSABUF32          tempArray;
                    ULONG               i;
                    

                    //
                    // If the input structure isn't large enough, return error.
                    //

                    if( InputBufferLength < sizeof(*sendInfo32) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }


                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode ) {
                        ProbeForReadSmallStructure (InputBuffer,
                                        sizeof (*sendInfo32),
                                        PROBE_ALIGNMENT32 (AFD_SEND_INFO32));
                    }

                    sendInfo32 = InputBuffer;


                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //
                    tempArray = UlongToPtr(sendInfo32->BufferArray);
                    u.sendInfo.BufferCount = sendInfo32->BufferCount;
                    u.sendInfo.AfdFlags = sendInfo32->AfdFlags;
                    u.sendInfo.TdiFlags = sendInfo32->TdiFlags;

                    //
                    // If fast IO is not possible or this is not a normal receive.
                    // bail.
                    //
                    if( (u.sendInfo.AfdFlags & AFD_NO_FAST_IO) ||
                        u.sendInfo.TdiFlags != 0 ) {
                        res = FALSE;
                        break;
                    }

                    //
                    // Validate all the pointers that app gave to us and
                    // calculate the length of the send buffer.
                    // Buffers in the array will be validated in the
                    // process of copying
                    //

                    if ((tempArray == NULL) ||
                            (u.sendInfo.BufferCount == 0) ||
                            // Check for integer overflow (disabled by compiler)
                            (u.sendInfo.BufferCount>(MAXULONG/sizeof (WSABUF32))) ) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead(
                            tempArray,                                  // Address
                            // Note check for overflow above (should actually be
                            // done here by the compiler generating code
                            // that causes exception on integer overflow)
                            u.sendInfo.BufferCount * sizeof (WSABUF32),   // Length
                            PROBE_ALIGNMENT32(WSABUF32)                     // Alignment
                            );
                    }

                    if (u.sendInfo.BufferCount>sizeof(localArray)/sizeof(localArray[0])) {
                        try {
                            pArray = AFD_ALLOCATE_POOL_WITH_QUOTA (
                                            NonPagedPool,
                                            sizeof (WSABUF)*u.sendInfo.BufferCount,
                                            AFD_TEMPORARY_POOL_TAG);
                            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets 
                            // POOL_RAISE_IF_ALLOCATION_FAILURE flag
                            ASSERT (pArray!=NULL);
                        }
                        except (EXCEPTION_EXECUTE_HANDLER) {
                            // Fast io can't handle error returns
                            // if call is overlapped (completion port)
                            // IoStatus->Status = GetExceptionCode ();
                            pArray = localArray;
                            res = FALSE;
                            break;
                        }
                    }

                    for (i=0; i<u.sendInfo.BufferCount; i++) {
                        pArray[i].buf = UlongToPtr(tempArray[i].buf);
                        pArray[i].len = tempArray[i].len;
                    }

                    u.sendInfo.BufferArray = pArray;

                }
                else
#endif // _WIN64
                {
                    //
                    // If the input structure isn't large enough, return error.
                    //

                    if( InputBufferLength < sizeof(u.sendInfo) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }

                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode) {
                        ProbeForReadSmallStructure (InputBuffer,
                                sizeof (u.sendInfo),
                                PROBE_ALIGNMENT(AFD_SEND_INFO));
                    }

                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //
                    u.sendInfo = *((PAFD_SEND_INFO)InputBuffer);

                    if( (u.sendInfo.AfdFlags & AFD_NO_FAST_IO) != 0 ||
                            u.sendInfo.TdiFlags != 0 ) {
                        res = FALSE;
                        break;
                    }

                    if ((u.sendInfo.BufferArray == NULL) ||
                            (u.sendInfo.BufferCount == 0) ||
                            // Check for integer overflow (disabled by compiler)
                            (u.sendInfo.BufferCount>(MAXULONG/sizeof (WSABUF))) ) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead(
                            u.sendInfo.BufferArray,                     // Address
                            // Note check for overflow above (should actually be
                            // done here by the compiler generating code
                            // that causes exception on integer overflow)
                            u.sendInfo.BufferCount * sizeof (WSABUF),   // Length
                            PROBE_ALIGNMENT(WSABUF)                     // Alignment
                            );
                    }

                }
                sendLength = AfdCalcBufferArrayByteLength(
                                     u.sendInfo.BufferArray,
                                     u.sendInfo.BufferCount
                                     );

            } except( AFD_EXCEPTION_FILTER_NO_STATUS() ) {

                // Fast io can't handle error returns
                // if call is overlapped (completion port)
                // IoStatus->Status = GetExceptionCode ();
                res = FALSE;
                break;
            }

            if (IS_DGRAM_ENDPOINT (endpoint)) {
                u.sendInfoDg.TdiConnInfo.RemoteAddress = NULL;
                u.sendInfoDg.TdiConnInfo.RemoteAddressLength = 0;
                res = AfdFastDatagramSend (
                            endpoint, 
                            &u.sendInfoDg, 
                            sendLength,
                            IoStatus);
            }
            else if (IS_VC_ENDPOINT (endpoint)) {
                res = AfdFastConnectionSend (
                            endpoint, 
                            &u.sendInfo,
                            sendLength,
                            IoStatus);
            }
            else
                res = FALSE;
        }

        break;
    case IOCTL_AFD_SEND_DATAGRAM:
        {
            AFD_SEND_DATAGRAM_INFO  sendInfo;
            ULONG   sendLength;


            if (endpoint->DisableFastIoSend ||
                    !IS_DGRAM_ENDPOINT(endpoint) ||
                    ((endpoint->State != AfdEndpointStateBound ) &&
                        (endpoint->State != AfdEndpointStateConnected)) ) {
                res = FALSE;
                break;
            }

            try {

#ifdef _WIN64
                if (IoIs32bitProcess (NULL)) {
                    PAFD_SEND_DATAGRAM_INFO32    sendInfo32;
                    LPWSABUF32          tempArray;
                    ULONG               i;
                    

                    //
                    // If the input structure isn't large enough, return error.
                    //

                    if( InputBufferLength < sizeof(*sendInfo32) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }


                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode ) {
                        ProbeForReadSmallStructure (InputBuffer,
                                        sizeof (*sendInfo32),
                                        PROBE_ALIGNMENT32(AFD_SEND_DATAGRAM_INFO32));
                    }

                    sendInfo32 = InputBuffer;


                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //
                    tempArray = UlongToPtr(sendInfo32->BufferArray);
                    sendInfo.BufferCount = sendInfo32->BufferCount;
                    sendInfo.AfdFlags = sendInfo32->AfdFlags;
                    sendInfo.TdiConnInfo.RemoteAddress = UlongToPtr(sendInfo32->TdiConnInfo.RemoteAddress);
                    sendInfo.TdiConnInfo.RemoteAddressLength = sendInfo32->TdiConnInfo.RemoteAddressLength;

                    //
                    // If fast IO is not possible bail.
                    //
                    if(sendInfo.AfdFlags & AFD_NO_FAST_IO) {
                        res = FALSE;
                        break;
                    }

                    //
                    // Validate all the pointers that app gave to us and
                    // calculate the length of the send buffer.
                    // Buffers in the array will be validated in the
                    // process of copying
                    //

                    if ((tempArray == NULL) ||
                            (sendInfo.BufferCount == 0) ||
                            // Check for integer overflow (disabled by compiler)
                            (sendInfo.BufferCount>(MAXULONG/sizeof (WSABUF32))) ) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead(
                            tempArray,                                  // Address
                            // Note check for overflow above (should actually be
                            // done here by the compiler generating code
                            // that causes exception on integer overflow)
                            sendInfo.BufferCount * sizeof (WSABUF32), // Length
                            PROBE_ALIGNMENT32(WSABUF32)           // Alignment
                            );
                    }

                    if (sendInfo.BufferCount>sizeof(localArray)/sizeof(localArray[0])) {
                        try {
                            pArray = AFD_ALLOCATE_POOL_WITH_QUOTA (
                                            NonPagedPool,
                                            sizeof (WSABUF)*sendInfo.BufferCount,
                                            AFD_TEMPORARY_POOL_TAG);
                            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets 
                            // POOL_RAISE_IF_ALLOCATION_FAILURE flag
                            ASSERT (pArray!=NULL);
                        }
                        except (EXCEPTION_EXECUTE_HANDLER) {
                            // Fast io can't handle error returns
                            // if call is overlapped (completion port)
                            // IoStatus->Status = GetExceptionCode ();
                            pArray = localArray;
                            res = FALSE;
                            break;
                        }
                    }

                    for (i=0; i<sendInfo.BufferCount; i++) {
                        pArray[i].buf = UlongToPtr(tempArray[i].buf);
                        pArray[i].len = tempArray[i].len;
                    }

                    sendInfo.BufferArray = pArray;

                }
                else
#endif // _WIN64
                {
                    //
                    // If the input structure isn't large enough, bail on fast IO.
                    //

                    if( InputBufferLength < sizeof(sendInfo) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }


                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode) {
                        ProbeForReadSmallStructure (InputBuffer,
                                sizeof (sendInfo),
                                PROBE_ALIGNMENT(AFD_SEND_DATAGRAM_INFO));

                    }

                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //

                    sendInfo = *((PAFD_SEND_DATAGRAM_INFO)InputBuffer);
                    //
                    // If fast IO is disabled, bail
                    //

                    if( (sendInfo.AfdFlags & AFD_NO_FAST_IO) != 0) {
                        res = FALSE;
                        break;
                    }

                    //
                    // Validate all the pointers that app gave to us
                    // and calculate total send length
                    // Buffers in the array will be validated in the
                    // process of copying
                    //

                    if ((sendInfo.BufferArray == NULL) ||
                            (sendInfo.BufferCount == 0) ||
                            // Check for integer overflow (disabled by compiler)
                            (sendInfo.BufferCount>(MAXULONG/sizeof (WSABUF))) ) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead(
                            sendInfo.BufferArray,                       // Address
                            // Note check for overflow above (should actually be
                            // done here by the compiler generating code
                            // that causes exception on integer overflow)
                            sendInfo.BufferCount * sizeof (WSABUF),     // Length
                            PROBE_ALIGNMENT(WSABUF)                     // Alignment
                            );
                    }
                }

                sendLength = AfdCalcBufferArrayByteLength(
                                 sendInfo.BufferArray,
                                 sendInfo.BufferCount
                                 );

                if (previousMode != KernelMode ) {
                    ProbeForRead (
                        sendInfo.TdiConnInfo.RemoteAddress,         // Address
                        sendInfo.TdiConnInfo.RemoteAddressLength,   // Length,
                        sizeof (UCHAR)                              // Aligment
                        );
                }

            } except( AFD_EXCEPTION_FILTER_NO_STATUS() ) {

                // Fast io can't handle error returns
                // if call is overlapped (completion port)
                // IoStatus->Status = GetExceptionCode ();
                res = FALSE;
                break;
            }
            //
            // Attempt to perform fast IO on the endpoint.
            //

            res = AfdFastDatagramSend(
                       endpoint,
                       &sendInfo,
                       sendLength,
                       IoStatus
                       );

        }

        break;

    case IOCTL_AFD_TRANSMIT_FILE:
        {

            AFD_TRANSMIT_FILE_INFO userTransmitInfo;
            try {

#ifdef _WIN64
                if (IoIs32bitProcess (NULL)) {
                    PAFD_TRANSMIT_FILE_INFO32 userTransmitInfo32;
                    if ( InputBufferLength < sizeof(AFD_TRANSMIT_FILE_INFO32) ) {
                        return FALSE;
                    }

                    if (previousMode != KernelMode) {
                        ProbeForReadSmallStructure (InputBuffer,
                                        sizeof (*userTransmitInfo32),
                                        PROBE_ALIGNMENT32(AFD_TRANSMIT_FILE_INFO32));
                    }

                    userTransmitInfo32 = InputBuffer;
                    userTransmitInfo.Offset = userTransmitInfo32->Offset;
                    userTransmitInfo.WriteLength = userTransmitInfo32->WriteLength;
                    userTransmitInfo.SendPacketLength = userTransmitInfo32->SendPacketLength;
                    userTransmitInfo.FileHandle = userTransmitInfo32->FileHandle;
                    userTransmitInfo.Head = UlongToPtr(userTransmitInfo32->Head);
                    userTransmitInfo.HeadLength = userTransmitInfo32->HeadLength;
                    userTransmitInfo.Tail = UlongToPtr(userTransmitInfo32->Tail);
                    userTransmitInfo.TailLength = userTransmitInfo32->TailLength;
                    userTransmitInfo.Flags = userTransmitInfo32->Flags;


                    if (previousMode != KernelMode) {
                        if (userTransmitInfo.HeadLength>0)
                            ProbeForRead (userTransmitInfo.Head,
                                            userTransmitInfo.HeadLength,
                                            sizeof (UCHAR));
                        if (userTransmitInfo.TailLength>0)
                            ProbeForRead (userTransmitInfo.Tail,
                                            userTransmitInfo.TailLength,
                                            sizeof (UCHAR));
                    }

                }
                else
#endif // _WIN64
                {
                    if ( InputBufferLength < sizeof(AFD_TRANSMIT_FILE_INFO) ) {
                        return FALSE;
                    }

                    if (previousMode != KernelMode) {
                        ProbeForReadSmallStructure (InputBuffer,
                                        sizeof (userTransmitInfo),
                                        PROBE_ALIGNMENT(AFD_TRANSMIT_FILE_INFO));
                        userTransmitInfo = *((PAFD_TRANSMIT_FILE_INFO)InputBuffer);
                        if (userTransmitInfo.HeadLength>0)
                            ProbeForRead (userTransmitInfo.Head,
                                            userTransmitInfo.HeadLength,
                                            sizeof (UCHAR));
                        if (userTransmitInfo.TailLength>0)
                            ProbeForRead (userTransmitInfo.Tail,
                                            userTransmitInfo.TailLength,
                                            sizeof (UCHAR));
                    }
                    else {
                        userTransmitInfo = *((PAFD_TRANSMIT_FILE_INFO)InputBuffer);
                    }
                }

            } except( AFD_EXCEPTION_FILTER_NO_STATUS() ) {

                res = FALSE;
                break;
            }

            res = AfdFastTransmitFile (endpoint,
                                        &userTransmitInfo,
                                        IoStatus);

        }

        return res;

    default:
        request = _AFD_REQUEST(IoControlCode);
        if( request < AFD_NUM_IOCTLS &&
                AfdIoctlTable[request] == IoControlCode &&
                AfdImmediateCallDispatch[request]!=NULL) {

            proc = AfdImmediateCallDispatch[request];
            IoStatus->Status = (*proc) (
                        FileObject,
                        IoControlCode,
                        previousMode,
                        InputBuffer,
                        InputBufferLength,
                        OutputBuffer,
                        OutputBufferLength,
                        &IoStatus->Information
                        );

            ASSERT (IoStatus->Status!=STATUS_PENDING);
            res = TRUE;
        }
        else {
            res = FALSE;
        }
        break;
    }

#ifdef _WIN64

    if (pArray!=localArray) {
        AFD_FREE_POOL (pArray, AFD_TEMPORARY_POOL_TAG);
    }
#endif

    return res;
}


BOOLEAN
AfdFastConnectionSend (
    IN PAFD_ENDPOINT    endpoint,
    IN PAFD_SEND_INFO   sendInfo,
    IN ULONG            sendLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
{
    PAFD_BUFFER afdBuffer;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    NTSTATUS status;

    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth );

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    connection = AFD_CONNECTION_FROM_ENDPOINT (endpoint);

    if (connection==NULL) {
        //
        // connection might have been cleaned up by transmit file.
        //
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        return FALSE;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );

    //
    // If the connection has been aborted, then we don't want to try
    // fast IO on it.
    //

    if ( connection->CleanupBegun || connection->Aborted ) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        return FALSE;
    }


    //
    // Determine whether we can do fast IO with this send.  In order
    // to perform fast IO, there must be no other sends pended on this
    // connection and there must be enough space left for bufferring
    // the requested amount of data.
    //

    if ( AfdShouldSendBlock( endpoint, connection, sendLength ) ) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        //
        // If this is a nonblocking endpoint, fail the request here and
        // save going through the regular path.
        //

        if ( endpoint->NonBlocking && !( sendInfo->AfdFlags & AFD_OVERLAPPED ) ) {
            // Fast io can't handle error returns
            // if call is overlapped (completion port), but we know
            // that it is not overlapped
            IoStatus->Status = STATUS_DEVICE_NOT_READY;
            return TRUE;
        }

        return FALSE;
    }

    //
    // Add a reference to the connection object since the send
    // request will complete asynchronously.
    //

    REFERENCE_CONNECTION( connection );
    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

    IF_DEBUG(FAST_IO) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdFastConnectionSend: attempting fast IO on endp %p, conn %p\n",
                endpoint, connection));
    }

    //
    // Next get an AFD buffer structure that contains an IRP and a
    // buffer to hold the data.
    //

    afdBuffer = AfdGetBuffer( endpoint, sendLength, 0, connection->OwningProcess );

    if ( afdBuffer == NULL) {
        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
        connection->VcBufferredSendBytes -= sendLength;
        connection->VcBufferredSendCount -= 1;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        DEREFERENCE_CONNECTION (connection);

        return FALSE;
    }


    //
    // We have to rebuild the MDL in the AFD buffer structure to
    // represent exactly the number of bytes we're going to be
    // sending.
    //

    afdBuffer->Mdl->ByteCount = sendLength;

    //
    // Remember the connection in the AFD buffer structure.  We need
    // this in order to access the connection in the restart routine.
    //

    afdBuffer->Context = connection;

    //
    // Copy the user's data into the AFD buffer.
    //

    if( sendLength > 0 ) {

        try {

            AfdCopyBufferArrayToBuffer(
                afdBuffer->Buffer,
                sendLength,
                sendInfo->BufferArray,
                sendInfo->BufferCount
                );

        } except( AFD_EXCEPTION_FILTER_NO_STATUS() ) {

            afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;
            AfdReturnBuffer( &afdBuffer->Header, connection->OwningProcess );
            AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
            connection->VcBufferredSendBytes -= sendLength;
            connection->VcBufferredSendCount -= 1;
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            DEREFERENCE_CONNECTION (connection);
            // Fast io can't handle error returns
            // if call is overlapped (completion port)
            // IoStatus->Status = GetExceptionCode ();
            return FALSE;
        }
    }

    //
    // Use the IRP in the AFD buffer structure to give to the TDI
    // provider.  Build the TDI send request.
    //

    TdiBuildSend(
        afdBuffer->Irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartBufferSend,
        afdBuffer,
        afdBuffer->Mdl,
        0,
        sendLength
        );

    if (endpoint->Irp==NULL || 
            !AfdEnqueueTpSendIrp (endpoint, afdBuffer->Irp, TRUE)) {
        //
        // Call the transport to actually perform the send.
        //

        status = IoCallDriver (
                     connection->DeviceObject,
                     afdBuffer->Irp
                     );
    }
    else {
        status = STATUS_PENDING;
    }

    //
    // Complete the user's IRP as appropriate.  Note that we change the
    // status code from what was returned by the TDI provider into
    // STATUS_SUCCESS.  This is because we don't want to complete
    // the IRP with STATUS_PENDING etc.
    //

    if ( NT_SUCCESS(status) ) {
        IoStatus->Information = sendLength;
        IoStatus->Status = STATUS_SUCCESS;
        return TRUE;
    }

    //
    // The call failed for some reason.  Fail fast IO.
    //

    return FALSE;
}



BOOLEAN
AfdFastConnectionReceive (
    IN PAFD_ENDPOINT    endpoint,
    IN PAFD_RECV_INFO   recvInfo,
    IN ULONG            recvLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
{
    PLIST_ENTRY listEntry;
    ULONG totalOffset, partialLength;
    PAFD_BUFFER_HEADER  afdBuffer, partialAfdBuffer=NULL;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    LIST_ENTRY bufferListHead;
    BOOLEAN retryReceive = FALSE; // Retry receive if additional data
                                  // was indicated by the transport and buffered
                                  // while we were copying current batch.

    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth );
    IoStatus->Status = STATUS_SUCCESS;
    IoStatus->Information = 0;

Retry:

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    connection = AFD_CONNECTION_FROM_ENDPOINT (endpoint);
    if (connection==NULL) {
        //
        // connection might have been cleaned up by transmit file.
        //
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        //
        // If we have already copied something before retrying,
        // return success, next receive will report the error.
        //
        return retryReceive;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );

    IF_DEBUG(FAST_IO) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdFastConnectionReceive: attempting fast IO on endp %p, conn %p\n",
                endpoint, connection));
    }


    //
    // Determine whether we'll be able to perform fast IO.  In order
    // to do fast IO, there must be some bufferred data on the
    // connection, there must not be any pended receives on the
    // connection, and there must not be any bufferred expedited
    // data on the connection.  This last requirement is for
    // the sake of simplicity only.
    //

    if ( !IsListEmpty( &connection->VcReceiveIrpListHead ) ||
             connection->VcBufferredExpeditedCount != 0 ||
             connection->DisconnectIndicated ||
             connection->Aborted) {
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        //
        // If we have already copied something before retrying,
        // return success, next receive will report the error.
        //
        return retryReceive;
    }

    if (connection->VcBufferredReceiveCount == 0) {
        ASSERT( IsListEmpty( &connection->VcReceiveBufferListHead ) );

        //
        // If this is a nonblocking endpoint, fail the request here and
        // save going through the regular path.
        if (!retryReceive &&
                endpoint->NonBlocking &&
                !(recvInfo->AfdFlags & AFD_OVERLAPPED)) {
            endpoint->EventsActive &= ~AFD_POLL_RECEIVE;

            IF_DEBUG(EVENT_SELECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFastConnectionReceive: Endp %p, Active %lx\n",
                    endpoint,
                    endpoint->EventsActive
                    ));
            }

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            IoStatus->Status = STATUS_DEVICE_NOT_READY;

            return TRUE;
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        //
        // If we have already copied something before retrying,
        // return success, next receive will report the error.
        //
        return retryReceive;
    }

    ASSERT( !IsListEmpty( &connection->VcReceiveBufferListHead ) );

    //
    // Get a pointer to the first bufferred AFD buffer structure on
    // the connection.
    //

    afdBuffer = CONTAINING_RECORD(
                    connection->VcReceiveBufferListHead.Flink,
                    AFD_BUFFER_HEADER,
                    BufferListEntry
                    );

    ASSERT( !afdBuffer->ExpeditedData );

    //
    // For message endpoints if the buffer contains a partial message 
    // or doesn't fit into the buffer, bail out.  
    // We don't want the added complexity of handling
    // partial messages in the fast path.
    //

    if ( IS_MESSAGE_ENDPOINT(endpoint) &&
            (afdBuffer->PartialMessage || afdBuffer->DataLength>recvLength)) {
        //
        // We shouldn't be retry-ing for message oriented endpoint
        // since we only allow fast path if complete message is available.
        //
        ASSERT (retryReceive == FALSE);

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        return FALSE;
    }

    //
    // Remeber current offset before we update
    // information field (it is not 0 if we are
    // re-trying).
    //
    totalOffset = (ULONG)IoStatus->Information;


    InitializeListHead( &bufferListHead );

    //
    // Reference the connection object so it doen't go away
    // until we return the buffer.
    //
    REFERENCE_CONNECTION (connection);

    //
    // Loop getting AFD buffers that will fill in the user's
    // buffer with as much data as will fit, or else with a
    // single buffer if this is not a stream endpoint.  We don't
    // actually do the copy within this loop because this loop
    // must occur while holding a lock, and we cannot hold a
    // lock while copying the data into the user's buffer
    // because the user's buffer is not locked and we cannot
    // take a page fault at raised IRQL.
    //

    AFD_W4_INIT partialLength = 0;

    while (IoStatus->Information<recvLength) {
        ASSERT( connection->VcBufferredReceiveBytes >= afdBuffer->DataLength );
        ASSERT( connection->VcBufferredReceiveCount > 0 );

        if (recvLength-IoStatus->Information>=afdBuffer->DataLength) {
            //
            // If we can copy the whole buffer, remove it from the connection's list of
            // buffers and place it on our local list of buffers.
            //

            RemoveEntryList( &afdBuffer->BufferListEntry );
            InsertTailList( &bufferListHead, &afdBuffer->BufferListEntry );
            
            //
            // Update the count of bytes on the connection.
            //

            connection->VcBufferredReceiveBytes -= afdBuffer->DataLength;
            connection->VcBufferredReceiveCount -= 1;
            IoStatus->Information += afdBuffer->DataLength;


            //
            // If this is a stream endpoint and more buffers are available,
            // try to fit the next one it as well..
            //

            if (!IS_MESSAGE_ENDPOINT(endpoint) &&
                    !IsListEmpty( &connection->VcReceiveBufferListHead ) ) {

                afdBuffer = CONTAINING_RECORD(
                            connection->VcReceiveBufferListHead.Flink,
                            AFD_BUFFER_HEADER,
                            BufferListEntry
                            );

                ASSERT( !afdBuffer->ExpeditedData );
                continue;
            }
        }
        else {
            //
            // Copy just a part of the buffer that fits and
            // increment its reference count so it doesn't get
            // destroyed until we done copying.
            //
            ASSERT (!IS_MESSAGE_ENDPOINT (endpoint));

            partialLength = recvLength-(ULONG)IoStatus->Information;
            partialAfdBuffer = afdBuffer;
            partialAfdBuffer->DataLength -= partialLength;
            partialAfdBuffer->DataOffset += partialLength;
            InterlockedIncrement (&partialAfdBuffer->RefCount);
            connection->VcBufferredReceiveBytes -= partialLength;
            IoStatus->Information = recvLength;
        }

        break;
    }


    endpoint->EventsActive &= ~AFD_POLL_RECEIVE;

    if( !IsListEmpty( &connection->VcReceiveBufferListHead )) {

        AfdIndicateEventSelectEvent(
            endpoint,
            AFD_POLL_RECEIVE,
            STATUS_SUCCESS
            );

        retryReceive = FALSE;
    }
    else {
        //
        // We got all the data buffered. It is possible
        // that while we are copying data, more gets indicated
        // by the transport since we copy at passive level
        // and indication occur at DPC (or even on another processor).
        // We'll check again after copying, so we return as much data
        // as possible to the application (to improve performance).
        // For message oriented transports we can only
        // deliver one message at a time and we shouldn't be on the fast path
        // if we do not have a complete message.
        // If application has EventSelect outstanding we can't copy more data 
        // as well since it would receive a signal during indication to come 
        // back because we just re-enabled receive event and we would 
        // have already consumed the data.  We are not concerned with the case
        // when application calls EventSelect while we are in this routine 
        // because signaling is not guaranteed to be multithread safe (e.g.
        // if EventSelect comes right before we take the spinlock in the 
        // beginning of this routine, application will get false signal as well).
        //
        // Select and AsyncSelect are not a concern as well because they cannot
        // be outstanding (should have been completed when the initial piece of data 
        // arrived).  If new data comes in the middle of the receive processing above
        // there should be no select or AsyncSelect to signal (unless it was issued
        // from another thread which we don't handle anyway).  After this receive
        // call completes, the application can get select re-issued or msafd will
        // re-enable AsyncSelect and they will work correctly.
        //
        retryReceive = (BOOLEAN) (IoStatus->Information<recvLength && 
                        !IS_MESSAGE_ENDPOINT (endpoint) &&
                        (endpoint->EventsEnabled & AFD_POLL_RECEIVE)==0);

        //
        // Disable fast IO path to avoid performance penalty
        // of unneccessarily going through it.
        //
        if (!endpoint->NonBlocking)
            endpoint->DisableFastIoRecv = TRUE;
    }

    //
    // If there is indicated but unreceived data in the TDI provider,
    // and we have available buffer space, fire off an IRP to receive
    // the data.
    //

    if ( connection->VcReceiveBytesInTransport > 0

         &&

         connection->VcBufferredReceiveBytes <
           connection->MaxBufferredReceiveBytes

           ) {

        ULONG bytesToReceive;
        PAFD_BUFFER newAfdBuffer;

        ASSERT (connection->RcvInitiated==FALSE);

        //
        // Remember the count of data that we're going to receive,
        // then reset the fields in the connection where we keep
        // track of how much data is available in the transport.
        // We reset it here before releasing the lock so that
        // another thread doesn't try to receive the data at the
        // same time as us.
        //

        if ( connection->VcReceiveBytesInTransport > AfdLargeBufferSize ) {
            bytesToReceive = connection->VcReceiveBytesInTransport;
        } else {
            bytesToReceive = AfdLargeBufferSize;
        }

        //
        // Get an AFD buffer structure to hold the data.
        //

        newAfdBuffer = AfdGetBuffer( endpoint, bytesToReceive, 0,
                                connection->OwningProcess );
        if ( newAfdBuffer == NULL ) {
            //
            // If we were unable to get a buffer, just remember
            // that we still have data in transport
            //

            if (connection->VcBufferredReceiveBytes == 0 &&
                    !connection->OnLRList) {
                //
                // Since we do not have any data buffered, application
                // is not notified and will never call with recv.
                // We will have to put this on low resource list
                // and attempt to allocate memory and pull the data
                // later.
                //
                connection->OnLRList = TRUE;
                REFERENCE_CONNECTION (connection);
                AfdLRListAddItem (&connection->LRListItem, AfdLRRepostReceive);
            }
            else {
                UPDATE_CONN (connection);
            }
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        } else {

            connection->VcReceiveBytesInTransport = 0;
            connection->RcvInitiated = TRUE;
            ASSERT (InterlockedDecrement (&connection->VcReceiveIrpsInTransport)==-1);

            //
            // We need to remember the connection in the AFD buffer
            // because we'll need to access it in the completion
            // routine.
            //

            newAfdBuffer->Context = connection;

            //
            // Acquire connection reference to be released in completion routine
            //

            REFERENCE_CONNECTION (connection);

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            //
            // Finish building the receive IRP to give to the TDI provider.
            //

            TdiBuildReceive(
                newAfdBuffer->Irp,
                connection->DeviceObject,
                connection->FileObject,
                AfdRestartBufferReceive,
                newAfdBuffer,
                newAfdBuffer->Mdl,
                TDI_RECEIVE_NORMAL,
                (CLONG)bytesToReceive
                );

            //
            // Hand off the IRP to the TDI provider.
            //

            (VOID)IoCallDriver(
                     connection->DeviceObject,
                     newAfdBuffer->Irp
                     );
        }

    } else {

       AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    //
    // We have in a local list all the data we'll use for this
    // IO.  Start copying data to the user buffer.
    //

    while ( !IsListEmpty( &bufferListHead ) ) {

        //
        // Take the first buffer from the list.
        //

        listEntry = RemoveHeadList( &bufferListHead );
        afdBuffer = CONTAINING_RECORD(
                        listEntry,
                        AFD_BUFFER_HEADER,
                        BufferListEntry
                        );
        DEBUG afdBuffer->BufferListEntry.Flink = NULL;

        if( afdBuffer->DataLength > 0 ) {

            ASSERTMSG (
                "NIC Driver freed the packet before it was returned!!!",
                !afdBuffer->NdisPacket ||
                    (MmIsAddressValid (afdBuffer->Context) &&
                     MmIsAddressValid (MmGetSystemAddressForMdl (afdBuffer->Mdl))) );
            try {

                //
                // Copy the data in the buffer to the user buffer.
                //

                AfdCopyMdlChainToBufferArray(
                    recvInfo->BufferArray,
                    totalOffset,
                    recvInfo->BufferCount,
                    afdBuffer->Mdl,
                    afdBuffer->DataOffset,
                    afdBuffer->DataLength
                    );

            } except( AFD_EXCEPTION_FILTER_NO_STATUS() ) {

                //
                // If an exception is hit, there is the possibility of
                // data corruption.  However, it is nearly impossible to
                // avoid this in all cases, so just throw out the
                // remainder of the data that we would have copied to
                // the user buffer.
                //

                if (afdBuffer->RefCount==1 || // Can't change once off the list
                        InterlockedDecrement (&afdBuffer->RefCount)==0) {
                    AfdReturnBuffer( afdBuffer, connection->OwningProcess );
                }

                while ( !IsListEmpty( &bufferListHead ) ) {
                    listEntry = RemoveHeadList( &bufferListHead );
                    afdBuffer = CONTAINING_RECORD(
                                    listEntry,
                                    AFD_BUFFER_HEADER,
                                    BufferListEntry
                                    );
                    DEBUG afdBuffer->BufferListEntry.Flink = NULL;
                    if (afdBuffer->RefCount==1 || // Can't change once off the list
                            InterlockedDecrement (&afdBuffer->RefCount)==0) {
                        AfdReturnBuffer( afdBuffer, connection->OwningProcess );
                    }
                }

                //
                // We'll have to abort since there is a possibility of data corruption.
                // Shame on application for giving us bogus buffers.
                //
                (VOID)AfdBeginAbort (connection);

                DEREFERENCE_CONNECTION (connection);

                // Fast io can't handle error returns
                // if call is overlapped (completion port)
                // IoStatus->Status = GetExceptionCode ();
                return FALSE;
            }

            totalOffset += afdBuffer->DataLength;
        }

        //
        // We're done with the AFD buffer.
        //

        if (afdBuffer->RefCount==1 || // Can't change once off the list
                InterlockedDecrement (&afdBuffer->RefCount)==0) {
            AfdReturnBuffer( afdBuffer, connection->OwningProcess );
        }
    }

    //
    // Copy any partial buffers
    //
    if (partialAfdBuffer) {
        ASSERT (partialLength>0);
        ASSERTMSG (
            "NIC Driver freed the packet before it was returned!!!",
            !partialAfdBuffer->NdisPacket ||
                (MmIsAddressValid (partialAfdBuffer->Context) &&
                 MmIsAddressValid (MmGetSystemAddressForMdl (partialAfdBuffer->Mdl))) );
        try {

            //
            // Copy the data in the buffer to the user buffer.
            //

            AfdCopyMdlChainToBufferArray(
                recvInfo->BufferArray,
                totalOffset,
                recvInfo->BufferCount,
                partialAfdBuffer->Mdl,
                partialAfdBuffer->DataOffset-partialLength,
                partialLength
                );

        } except( AFD_EXCEPTION_FILTER_NO_STATUS() ) {
            if (InterlockedDecrement (&partialAfdBuffer->RefCount)==0) {
                ASSERT (partialAfdBuffer->BufferListEntry.Flink == NULL);
                AfdReturnBuffer( partialAfdBuffer, connection->OwningProcess );
            }
            //
            // We'll have to abort since there is a possibility of data corruption.
            // Shame on application for giving us bogus buffers.
            //
            (VOID)AfdBeginAbort (connection);

            DEREFERENCE_CONNECTION (connection);

            // Fast io can't handle error returns
            // if call is overlapped (completion port)
            // IoStatus->Status = GetExceptionCode ();
            return FALSE;
        }

        if (InterlockedDecrement (&partialAfdBuffer->RefCount)==0) {
            ASSERT (partialAfdBuffer->BufferListEntry.Flink == NULL);
            AfdReturnBuffer( partialAfdBuffer, connection->OwningProcess );
        }

        totalOffset += partialLength;
    }

    ASSERT (IoStatus->Information==totalOffset);


    //
    // If more data is available, we need to retry and attempt to completely
    // fill application's buffer.
    //

    if (retryReceive && (endpoint->EventsActive & AFD_POLL_RECEIVE)) {
        ASSERT (IoStatus->Information<recvLength && !IS_MESSAGE_ENDPOINT (endpoint));
        DEREFERENCE_CONNECTION2 (connection, "Fast retry receive 0x%lX bytes", (ULONG)IoStatus->Information);
        goto Retry;
    }
    else {
        //
        // Release the reference needed to return the buffer(s).
        //
        DEREFERENCE_CONNECTION2 (connection, "Fast receive 0x%lX bytes", (ULONG)IoStatus->Information);
    }

    ASSERT( IoStatus->Information <= recvLength );
    ASSERT (IoStatus->Status == STATUS_SUCCESS);
    return TRUE;
}



BOOLEAN
AfdFastDatagramSend (
    IN PAFD_ENDPOINT            endpoint,
    IN PAFD_SEND_DATAGRAM_INFO  sendInfo,
    IN ULONG                    sendLength,
    OUT PIO_STATUS_BLOCK        IoStatus
    )
{
        
    PAFD_BUFFER afdBuffer = NULL;
    NTSTATUS status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // If this is a send for more than the threshold number of
    // bytes, don't use the fast path.  We don't allow larger sends
    // in the fast path because of the extra data copy it entails,
    // which is more expensive for large buffers.  For smaller
    // buffers, however, the cost of the copy is small compared to
    // the IO system overhead of the slow path.
    //
    // We also copy and return for non-blocking endpoints regardless
    // of the size.  That's what we are supposed to do according
    // to the spec.
    //

    if ( !endpoint->NonBlocking && sendLength > AfdFastSendDatagramThreshold ) {
        return FALSE;
    }

    //
    // If we already buffered to many sends, go the long way.
    //

    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    if ( endpoint->DgBufferredSendBytes >=
             endpoint->Common.Datagram.MaxBufferredSendBytes &&
         endpoint->DgBufferredSendBytes>0) {

        if ( endpoint->NonBlocking && !( sendInfo->AfdFlags & AFD_OVERLAPPED ) ) {
            endpoint->EventsActive &= ~AFD_POLL_SEND;
            endpoint->EnableSendEvent = TRUE;

            IF_DEBUG(EVENT_SELECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFastIoDeviceControl: Endp %p, Active %lX\n",
                    endpoint,
                    endpoint->EventsActive
                    ));
            }
        }
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        
        //
        // If this is a nonblocking endpoint, fail the request here and
        // save going through the regular path.(check for non-blocking is
        // below, otherwise status code is ignored).
        //

        status = STATUS_DEVICE_NOT_READY;
        goto errorset;
    }

    endpoint->DgBufferredSendBytes += sendLength;

    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

    IF_DEBUG(FAST_IO) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFastDatagramSend: attempting fast IO on endp %p\n",
                     endpoint));
    }


    //
    // Get an AFD buffer to use for the request.  We'll copy the
    // user's data to the AFD buffer then submit the IRP in the AFD
    // buffer to the TDI provider.

    if ((sendInfo->TdiConnInfo.RemoteAddressLength==0) &&
            !IS_TDI_DGRAM_CONNECTION(endpoint)) {
    retry:
        AFD_W4_INIT status = STATUS_SUCCESS;
        try {
            //
            // Get an AFD buffer to use for the request.  We'll copy the
            // user to the AFD buffer then submit the IRP in the AFD
            // buffer to the TDI provider.
            //

            afdBuffer = AfdGetBufferRaiseOnFailure(
                            endpoint,
                            sendLength,
                            endpoint->Common.Datagram.RemoteAddressLength,
                            endpoint->OwningProcess
                            );
        }
        except (AFD_EXCEPTION_FILTER (status)) {
            ASSERT (NT_ERROR (status));
            goto exit;
        }

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // If the endpoint is not connected, fail.
        //

        if ( endpoint->State != AfdEndpointStateConnected ) {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            AfdReturnBuffer (&afdBuffer->Header, endpoint->OwningProcess);
            status = STATUS_INVALID_CONNECTION;
            goto exit;
        }

        if (afdBuffer->AllocatedAddressLength <
               endpoint->Common.Datagram.RemoteAddressLength ) {
            //
            // Apparently connection address length has changed
            // on us while we were allocating the buffer.
            // This is extremely unlikely (even if endpoint got
            // connected to a different address, the length is unlikely
            // to change), but we must handle this, just try again.
            //
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            AfdReturnBuffer (&afdBuffer->Header, endpoint->OwningProcess);
            goto retry;
        }
        //
        // Copy the address to the AFD buffer.
        //

        RtlCopyMemory(
            afdBuffer->TdiInfo.RemoteAddress,
            endpoint->Common.Datagram.RemoteAddress,
            endpoint->Common.Datagram.RemoteAddressLength
            );

        afdBuffer->TdiInfo.RemoteAddressLength = endpoint->Common.Datagram.RemoteAddressLength;

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }
    else {
        AFD_W4_INIT status = STATUS_SUCCESS;
        try {
            afdBuffer = AfdGetBufferRaiseOnFailure( 
                                        endpoint, 
                                        sendLength, 
                                        sendInfo->TdiConnInfo.RemoteAddressLength,
                                        endpoint->OwningProcess);
            //
            // Copy address if necessary.
            //
            if (sendInfo->TdiConnInfo.RemoteAddressLength!=0) {
                RtlCopyMemory(
                    afdBuffer->TdiInfo.RemoteAddress,
                    sendInfo->TdiConnInfo.RemoteAddress,
                    sendInfo->TdiConnInfo.RemoteAddressLength
                    );

                //
                // Validate internal consistency of the transport address structure.
                // Note that we HAVE to do this after copying since the malicious
                // application can change the content of the buffer on us any time
                // and our check will be bypassed.
                //
                if ((((PTRANSPORT_ADDRESS)afdBuffer->TdiInfo.RemoteAddress)->TAAddressCount!=1) ||
                        (LONG)sendInfo->TdiConnInfo.RemoteAddressLength<
                            FIELD_OFFSET (TRANSPORT_ADDRESS,
                                Address[0].Address[((PTRANSPORT_ADDRESS)afdBuffer->TdiInfo.RemoteAddress)->Address[0].AddressLength])) {
                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }
            }
        } except( AFD_EXCEPTION_FILTER (status) ) {
            ASSERT (NT_ERROR (status));
            if (afdBuffer!=NULL) {
                AfdReturnBuffer( &afdBuffer->Header, endpoint->OwningProcess );
            }
            goto exit;
        }

        afdBuffer->TdiInfo.RemoteAddressLength = sendInfo->TdiConnInfo.RemoteAddressLength;
    }

    //
    // Copy the  output buffer to the AFD buffer.
    //

    AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
    try {

        AfdCopyBufferArrayToBuffer(
            afdBuffer->Buffer,
            sendLength,
            sendInfo->BufferArray,
            sendInfo->BufferCount
            );

        //
        // Store the length of the data and the address we're going to
        // send.
        //
        afdBuffer->DataLength = sendLength;

    } except( AFD_EXCEPTION_FILTER (status) ) {

        ASSERT (NT_ERROR (status));
        AfdReturnBuffer( &afdBuffer->Header, endpoint->OwningProcess );
        goto exit;
    }


    if (IS_TDI_DGRAM_CONNECTION(endpoint)
            && (afdBuffer->TdiInfo.RemoteAddressLength==0)) {
        TdiBuildSend(
                afdBuffer->Irp,
                endpoint->AddressDeviceObject,
                endpoint->AddressFileObject,
                AfdRestartFastDatagramSend,
                afdBuffer,
                afdBuffer->Irp->MdlAddress,
                0,
                sendLength
                );
    }
    else {
        //
        // Set up the input TDI information to point to the destination
        // address.
        //

        afdBuffer->TdiInfo.Options = NULL;
        afdBuffer->TdiInfo.OptionsLength = 0;
        afdBuffer->TdiInfo.UserData = NULL;
        afdBuffer->TdiInfo.UserDataLength = 0;


        //
        // Initialize the IRP in the AFD buffer to do a fast datagram send.
        //

        TdiBuildSendDatagram(
            afdBuffer->Irp,
            endpoint->AddressDeviceObject,
            endpoint->AddressFileObject,
            AfdRestartFastDatagramSend,
            afdBuffer,
            afdBuffer->Irp->MdlAddress,
            sendLength,
            &afdBuffer->TdiInfo
            );
    }

    //
    // Change the MDL in the AFD buffer to specify only the number
    // of bytes we're actually sending.  This is a requirement of TDI--
    // the MDL chain cannot describe a longer buffer than the send
    // request.
    //

    afdBuffer->Mdl->ByteCount = sendLength;

    //
    // Reference the endpoint so that it does not go away until the send
    // completes.  This is necessary to ensure that a send which takes a
    // very long time and lasts longer than the process will not cause a
    // crash when the send datragram finally completes.
    //

    REFERENCE_ENDPOINT2( endpoint, "AfdFastDatagramSend, length: 0x%lX", sendLength );

    //
    // Set the context to NULL initially so that if the IRP is completed
    // by the stack before IoCallDriver returns, the completion routine
    // does not free the buffer (and IRP in it) and we can figure out
    // what the final status of the operation was and report it to the
    // application
    //

    afdBuffer->Context = NULL;

    // Check if there are outstanding TPackets IRP and
    // delay sending to ensure in-order delivery.
    // We do not need to hold the lock while checking
    // because we do not need to maintain order if
    // application does not wait for send call to return
    // before sumbitting TPackets IRP.
    // Of course, we will hold the lock while enqueuing IRP
    //
    if (endpoint->Irp==NULL || 
            !AfdEnqueueTpSendIrp (endpoint, afdBuffer->Irp, TRUE)) {
        //
        // Give the IRP to the TDI provider.  If the request fails
        // immediately, then fail fast IO.  If the request fails later on,
        // there's nothing we can do about it.
        //
        status = IoCallDriver(
                     endpoint->AddressDeviceObject,
                     afdBuffer->Irp
                     );
    }
    else {
        status = STATUS_PENDING;
    }

    //
    // Check if completion routine has already been called and we
    // can figure out what the final status is
    //
    if (InterlockedCompareExchangePointer (
            &afdBuffer->Context,
            endpoint,
            NULL)!=NULL) {
        BOOLEAN indicateSendEvent;
        //
        // Completion routine has been called, pick the final status
        // and dereference the endpoint and free the buffer
        //
        status = afdBuffer->Irp->IoStatus.Status;

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        endpoint->DgBufferredSendBytes -= sendLength;
        if (endpoint->DgBufferredSendBytes <
                endpoint->Common.Datagram.MaxBufferredSendBytes ||
                endpoint->DgBufferredSendBytes==0) {
            indicateSendEvent = TRUE;
            AfdIndicateEventSelectEvent (endpoint, AFD_POLL_SEND, STATUS_SUCCESS);
        }
        else {
            indicateSendEvent = FALSE;
        }
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        if (indicateSendEvent) {
            AfdIndicatePollEvent (endpoint, AFD_POLL_SEND, STATUS_SUCCESS);
        }

        AfdReturnBuffer (&afdBuffer->Header, endpoint->OwningProcess);

        DEREFERENCE_ENDPOINT2 (endpoint, "AfdFastDatagramSend-inline completion, status: 0x%lX", status );
    }
    //else Completion routine has not been called, we set the pointer
    // to the endpoint in the buffer context, so it can derefernce it
    // and knows to free the buffer
    //

    if ( NT_SUCCESS(status) ) {
        IoStatus->Information = sendLength;
        IoStatus->Status = STATUS_SUCCESS;
        return TRUE;
    } else {
        goto errorset;
    }

exit:
    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    endpoint->DgBufferredSendBytes -= sendLength;
    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

errorset:
    // Fast io can't handle error returns
    // if call is overlapped (completion port), 
    if ( endpoint->NonBlocking && !( sendInfo->AfdFlags & AFD_OVERLAPPED ) ) {
        // We know that it is not overlapped
        IoStatus->Status = status;
        return TRUE;
    }
    else {
        return FALSE;
    }
} // AfdFastDatagramSend


NTSTATUS
AfdRestartFastDatagramSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PAFD_BUFFER afdBuffer;
    PAFD_ENDPOINT endpoint;
    ULONG   sendLength;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    UNREFERENCED_PARAMETER (DeviceObject);

    afdBuffer = Context;
    ASSERT (IS_VALID_AFD_BUFFER (afdBuffer));
#if DBG
    ASSERT( afdBuffer->Irp == Irp );
#else
    UNREFERENCED_PARAMETER (Irp);
#endif

    //
    // Reset the AFD buffer structure.
    //

    sendLength = afdBuffer->Mdl->ByteCount;
    ASSERT (afdBuffer->DataLength==sendLength);
    afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;


    //
    // If call succeeded, transport should have sent the number of bytes requested
    //
    ASSERT (Irp->IoStatus.Status!=STATUS_SUCCESS || 
                Irp->IoStatus.Information==sendLength);
    //
    // Find the endpoint used for this request if
    // the IoCallDriver call has completed already
    //

    endpoint = InterlockedCompareExchangePointer (&afdBuffer->Context,
                                            (PVOID)-1,
                                            NULL);
    if (endpoint!=NULL) {
        BOOLEAN     indicateSendEvent;
#if REFERENCE_DEBUG
        NTSTATUS    status;
#endif
        //
        // IoCallDriver has completed, free the buffer and
        // dereference endpoint here
        //
        ASSERT( IS_DGRAM_ENDPOINT(endpoint) );


        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        endpoint->DgBufferredSendBytes -= sendLength;
        if (endpoint->DgBufferredSendBytes <
                endpoint->Common.Datagram.MaxBufferredSendBytes ||
                endpoint->DgBufferredSendBytes==0)  {
            AfdIndicateEventSelectEvent (endpoint, AFD_POLL_SEND, STATUS_SUCCESS);
            indicateSendEvent = TRUE;
        }
        else
            indicateSendEvent = FALSE;
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        if (indicateSendEvent) {
            AfdIndicatePollEvent (endpoint, AFD_POLL_SEND, STATUS_SUCCESS);
        }
        //
        // Get rid of the reference we put on the endpoint when we started
        // this I/O.
        //

#if REFERENCE_DEBUG
        status = Irp->IoStatus.Status;
#endif
        AfdReturnBuffer( &afdBuffer->Header, endpoint->OwningProcess );

        DEREFERENCE_ENDPOINT2 (endpoint, "AfdRestartFastDatagramSend, status: 0x%lX", status );

    }
    // else IoCallDriver is not done yet, it will free the buffer
    // and endpoint when done (it will look at final status and
    // report it to the application).

    //
    // Tell the IO system to stop processing this IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // AfdRestartFastSendDatagram



BOOLEAN
AfdFastDatagramReceive (
    IN PAFD_ENDPOINT            endpoint,
    IN PAFD_RECV_MESSAGE_INFO   msgInfo,
    IN ULONG                    recvLength,
    OUT PIO_STATUS_BLOCK        IoStatus
    )
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY listEntry;
    PAFD_BUFFER_HEADER afdBuffer;
    PTRANSPORT_ADDRESS tdiAddress;
    ULONG length;



    IF_DEBUG(FAST_IO) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFastDatagramReceive: attempting fast IO on endp %p\n",
                    endpoint));
    }

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );


    //
    // If there are no datagrams available to be received, don't
    // bother with the fast path.
    //
    if ( !ARE_DATAGRAMS_ON_ENDPOINT( endpoint ) ) {

        //
        // If this is a nonblocking endpoint, fail the request here and
        // save going through the regular path.
        //

        if ( endpoint->NonBlocking && !( msgInfo->dgi.AfdFlags & AFD_OVERLAPPED ) ) {
            endpoint->EventsActive &= ~AFD_POLL_RECEIVE;

            IF_DEBUG(EVENT_SELECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFastDatagramReceive: Endp %p, Active %lX\n",
                    endpoint,
                    endpoint->EventsActive
                    ));
            }

            // Fast io can't handle error returns
            // if call is overlapped (completion port), but we know here
            // that call is not overlapped
            IoStatus->Status = STATUS_DEVICE_NOT_READY;
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            return TRUE;
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        return FALSE;
    }

    //
    // There is at least one datagram bufferred on the endpoint.  Use it
    // for this receive.
    //

    listEntry = RemoveHeadList( &endpoint->ReceiveDatagramBufferListHead );
    afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );

    //
    // If the datagram is too large or it is an error indication
    // fail fast IO.
    //

    if ( (afdBuffer->DataLength > recvLength) || 
            !NT_SUCCESS (afdBuffer->Status)) {
        InsertHeadList(
            &endpoint->ReceiveDatagramBufferListHead,
            &afdBuffer->BufferListEntry
            );
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        return FALSE;
    }

    //
    // Update counts of bufferred datagrams and bytes on the endpoint.
    //

    endpoint->DgBufferredReceiveCount--;
    endpoint->DgBufferredReceiveBytes -= afdBuffer->DataLength;

    //
    // Release the lock and copy the datagram into the user buffer.  We
    // can't continue to hold the lock, because it is not legal to take
    // an exception at raised IRQL.  Releasing the lock may result in a
    // misordered datagram if there is an exception in copying to the
    // user's buffer, but that is the application's fault for giving us a bogus
    // pointer.  Besides, datagram order is not guaranteed.
    //

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    try {

        if (afdBuffer->DataLength>0) {
            AfdCopyMdlChainToBufferArray(
                msgInfo->dgi.BufferArray,
                0,
                msgInfo->dgi.BufferCount,
                afdBuffer->Mdl,
                0,
                afdBuffer->DataLength
                );
        }

        //
        // If we need to return the source address, copy it to the
        // user's output buffer.
        //

        if ( msgInfo->dgi.Address != NULL ) {

            tdiAddress = afdBuffer->TdiInfo.RemoteAddress;

            length = tdiAddress->Address[0].AddressLength +
                sizeof(u_short);    // sa_family

            if( *msgInfo->dgi.AddressLength < length ) {

                ExRaiseAccessViolation();

            }

            if (ExGetPreviousMode ()!=KernelMode) {
                ProbeForWrite (msgInfo->dgi.Address,
                                length,
                                sizeof (UCHAR));
            }

            RtlCopyMemory(
                msgInfo->dgi.Address,
                &tdiAddress->Address[0].AddressType,
                length
                );

            *msgInfo->dgi.AddressLength = length;
        }

        if (msgInfo->ControlLength!=NULL) {
            if (afdBuffer->DatagramFlags & TDI_RECEIVE_CONTROL_INFO &&
                    afdBuffer->DataOffset>0) {
                PAFD_BUFFER buf = CONTAINING_RECORD (afdBuffer, AFD_BUFFER, Header);
                ASSERT (msgInfo->MsgFlags!=NULL);
                ASSERT (buf->BufferLength != AfdBufferTagSize);
                length = buf->DataOffset;
#ifdef _WIN64
                if (IoIs32bitProcess (NULL)) {
                    length = AfdComputeCMSGLength32 (
                                        (PUCHAR)buf->Buffer+afdBuffer->DataLength,
                                        length);

                    if (length>*msgInfo->ControlLength) {
                        ExRaiseAccessViolation ();
                    }
                    if (ExGetPreviousMode ()!=KernelMode) {
                        ProbeForWrite (msgInfo->ControlBuffer,
                                        length,
                                        sizeof (UCHAR));
                    }
                    AfdCopyCMSGBuffer32 (
                                        msgInfo->ControlBuffer,
                                        (PUCHAR)buf->Buffer+afdBuffer->DataLength,
                                        length);
                }
                else
#endif // _WIN64
                {
                    if (length>*msgInfo->ControlLength) {
                        ExRaiseAccessViolation ();
                    }

                    if (ExGetPreviousMode ()!=KernelMode) {
                        ProbeForWrite (msgInfo->ControlBuffer,
                                        length,
                                        sizeof (UCHAR));
                    }

                    RtlCopyMemory(
                        msgInfo->ControlBuffer,
                        (PUCHAR)buf->Buffer+afdBuffer->DataLength,
                        length
                        );
                }

            }
            else {
                length = 0;
            }

            *msgInfo->ControlLength = length;
        }

        if (msgInfo->MsgFlags!=NULL) {
            ULONG flags =  0;
            if (afdBuffer->DatagramFlags & TDI_RECEIVE_BROADCAST)
                flags |= MSG_BCAST;
            if (afdBuffer->DatagramFlags & TDI_RECEIVE_MULTICAST)
                flags |= MSG_MCAST;
            *msgInfo->MsgFlags = flags;
        }

        IoStatus->Information = afdBuffer->DataLength;
        IoStatus->Status = STATUS_SUCCESS;

    } except( AFD_EXCEPTION_FILTER_NO_STATUS() ) {

        //
        // Put the buffer back on the endpoint's list.
        //

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        InsertHeadList(
            &endpoint->ReceiveDatagramBufferListHead,
            &afdBuffer->BufferListEntry
            );

        endpoint->DgBufferredReceiveCount++;
        endpoint->DgBufferredReceiveBytes += afdBuffer->DataLength;

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        // Fast io can't handle error returns
        // if call is overlapped (completion port)
        // IoStatus->Status = GetExceptionCode ();
        return FALSE;
    }

    //
    // Clear the receive data active bit. If there's more data
    // available, set the corresponding event.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    endpoint->EventsActive &= ~AFD_POLL_RECEIVE;

    if( ARE_DATAGRAMS_ON_ENDPOINT( endpoint ) ) {

        AfdIndicateEventSelectEvent(
            endpoint,
            AFD_POLL_RECEIVE,
            STATUS_SUCCESS
            );

    }
    else {
        //
        // Disable fast IO path to avoid performance penalty
        // of going through it.
        //
        if (!endpoint->NonBlocking)
            endpoint->DisableFastIoRecv = TRUE;
    }

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // The fast IO worked!  Clean up and return to the user.
    //

    AfdReturnBuffer( afdBuffer, endpoint->OwningProcess );

    ASSERT (IoStatus->Status == STATUS_SUCCESS);
    return TRUE;

} // AfdFastDatagramReceive


BOOLEAN
AfdShouldSendBlock (
    IN PAFD_ENDPOINT Endpoint,
    IN PAFD_CONNECTION Connection,
    IN ULONG SendLength
    )

/*++

Routine Description:

    Determines whether a nonblocking send can be performed on the
    connection, and if the send is possible, updates the connection's
    send tracking information.

Arguments:

    Endpoint - the AFD endpoint for the send.

    Connection - the AFD connection for the send.

    SendLength - the number of bytes that the caller wants to send.

Return Value:

    TRUE if the there is not too much data on the endpoint to perform
    the send; FALSE otherwise.

Note:
    This routine assumes that endpoint spinlock is held when calling it.

--*/

{

    //
    // Determine whether we can do fast IO with this send.  In order
    // to perform fast IO, there must be no other sends pended on this
    // connection and there must be enough space left for bufferring
    // the requested amount of data.
    //


    if ( !IsListEmpty( &Connection->VcSendIrpListHead )

         ||

         Connection->VcBufferredSendBytes >= Connection->MaxBufferredSendBytes
         ) {

        //
        // If this is a nonblocking endpoint, fail the request here and
        // save going through the regular path.
        //

        if ( Endpoint->NonBlocking ) {
            Endpoint->EventsActive &= ~AFD_POLL_SEND;
            Endpoint->EnableSendEvent = TRUE;

            IF_DEBUG(EVENT_SELECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFastIoDeviceControl: Endp %p, Active %lX\n",
                    Endpoint,
                    Endpoint->EventsActive
                    ));
            }
        }

        return TRUE;
    }

    //
    // Update count of send bytes pending on the connection.
    //

    Connection->VcBufferredSendBytes += SendLength;
    Connection->VcBufferredSendCount += 1;

    //
    // Indicate to the caller that it is OK to proceed with the send.
    //

    return FALSE;

} // AfdShouldSendBlock
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\listen.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    listen.c

Abstract:

    This module contains the handling for IOCTL_AFD_START_LISTEN
    and IOCTL_AFD_WAIT_FOR_LISTEN.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:
    Vadim Eydelman (vadime)
            1998-1999 Delayed accept support, SuperAccept optimizations

--*/

#include "afdp.h"

VOID
AfdCancelWaitForListen (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
AfdRestartAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

PAFD_CONNECT_DATA_BUFFERS
CopyConnectDataBuffers (
    IN PAFD_CONNECT_DATA_BUFFERS OriginalConnectDataBuffers
    );

BOOLEAN
CopySingleConnectDataBuffer (
    IN PAFD_CONNECT_DATA_INFO InConnectDataInfo,
    OUT PAFD_CONNECT_DATA_INFO OutConnectDataInfo
    );


NTSTATUS
AfdRestartDelayedAcceptListen (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdServiceWaitForListen (
    PIRP            Irp,
    PAFD_CONNECTION Connection,
    PAFD_LOCK_QUEUE_HANDLE LockHandle
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdStartListen )
#pragma alloc_text( PAGEAFD, AfdWaitForListen )
#pragma alloc_text( PAGEAFD, AfdServiceWaitForListen )
#pragma alloc_text( PAGEAFD, AfdCancelWaitForListen )
#pragma alloc_text( PAGEAFD, AfdConnectEventHandler )
#pragma alloc_text( PAGEAFD, AfdRestartAccept )
#pragma alloc_text( PAGEAFD, CopyConnectDataBuffers )
#pragma alloc_text( PAGEAFD, CopySingleConnectDataBuffer )
#pragma alloc_text( PAGEAFD, AfdDelayedAcceptListen )
#pragma alloc_text( PAGEAFD, AfdRestartDelayedAcceptListen )
#endif


//
// Macros to make the super accept restart code more maintainable.
//

#define AfdRestartSuperAcceptInfo   DeviceIoControl
#define AfdMdlAddress               Type3InputBuffer
#define AfdAcceptFileObject         Type3InputBuffer
#define AfdReceiveDataLength        OutputBufferLength
#define AfdRemoteAddressLength      InputBufferLength
#define AfdLocalAddressLength       IoControlCode



NTSTATUS
AfdStartListen (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )

/*++

Routine Description:

    This routine handles the IOCTL_AFD_START_LISTEN IRP, which starts
    listening for connections on an AFD endpoint.

Arguments:

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    ULONG i;
    NTSTATUS status;
    AFD_LISTEN_INFO afdListenInfo;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    USHORT  remoteAddressLength, remoteAddressOffset;

    UNREFERENCED_PARAMETER (IoctlCode);
    UNREFERENCED_PARAMETER (OutputBuffer);
    UNREFERENCED_PARAMETER (OutputBufferLength);
    //
    // Nothing to return.
    //

    *Information = 0;

    //
    // Set up local variables.
    //

    endpoint = FileObject->FsContext;

    if (InputBufferLength< sizeof (afdListenInfo)) {
        status = STATUS_INVALID_PARAMETER;
        goto error_exit;
    }

    AFD_W4_INIT status = STATUS_SUCCESS;
    try {
        //
        // Validate the input structure if it comes from the user mode
        // application
        //

        if (RequestorMode != KernelMode ) {
            ProbeForReadSmallStructure (InputBuffer,
                            sizeof (afdListenInfo),
                            PROBE_ALIGNMENT(AFD_LISTEN_INFO));
        }

        //
        // Make local copies of the embeded pointer and parameters
        // that we will be using more than once in case malicios
        // application attempts to change them while we are
        // validating
        //

        afdListenInfo = *((PAFD_LISTEN_INFO)InputBuffer);

    } except( AFD_EXCEPTION_FILTER(status) ) {
        ASSERT (NT_ERROR (status));
        goto error_exit;
    }

    //
    // Check for if the caller is unaware of the SAN
    // provider activation and report the error.
    //
    if (!afdListenInfo.SanActive && AfdSanServiceHelper!=NULL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AFD: Process %p is being told to enable SAN on listen\n",
                    PsGetCurrentProcessId ()));
        status = STATUS_INVALID_PARAMETER_12;
        goto error_exit;
    }

    //
    //
    // Make sure that the backlog argument is within the legal range.
    // If it is out of range, just set it to the closest in-range
    // value--this duplicates BSD 4.3 behavior.  Note that NT Workstation
    // is tuned to have a lower backlog limit in order to conserve
    // resources on that product type.
    // (moved here from msafd.dll)
    //

    if (MmIsThisAnNtAsSystem ()) {
        if (afdListenInfo.MaximumConnectionQueue>AFD_MAXIMUM_BACKLOG_NTS)
            afdListenInfo.MaximumConnectionQueue = AFD_MAXIMUM_BACKLOG_NTS;
    }
    else {
        if (afdListenInfo.MaximumConnectionQueue>AFD_MAXIMUM_BACKLOG_NTW)
            afdListenInfo.MaximumConnectionQueue = AFD_MAXIMUM_BACKLOG_NTW;
    }

    if (afdListenInfo.MaximumConnectionQueue<AFD_MINIMUM_BACKLOG)
        afdListenInfo.MaximumConnectionQueue = AFD_MINIMUM_BACKLOG;

    if (!AFD_START_STATE_CHANGE (endpoint, endpoint->State)) {
        status = STATUS_INVALID_PARAMETER;
        goto error_exit;
    }

    //
    // Verify the type of the structure we are dealing with
    //
    if ( endpoint->Type != AfdBlockTypeEndpoint &&
        endpoint->Type != AfdBlockTypeVcConnecting) {
        status = STATUS_INVALID_PARAMETER;
        goto error_exit_state_change;
    }

    //
    // Make sure that the endpoint is in the correct state.
    //

    if ( ((endpoint->State != AfdEndpointStateBound) &&
                (endpoint->State != AfdEndpointStateConnected ||
                    !endpoint->afdC_Root)) ||
            endpoint->Listening ||
            (afdListenInfo.UseDelayedAcceptance &&
                !IS_TDI_DELAYED_ACCEPTANCE(endpoint))) {
        status = STATUS_INVALID_PARAMETER;
        goto error_exit_state_change;
    }

    //
    // Prevent imortant fields of endpoint common union from being
    // trashed in case of failure.
    //
    remoteAddressOffset = endpoint->Common.VirtualCircuit.RemoteSocketAddressOffset;
    remoteAddressLength = endpoint->Common.VirtualCircuit.RemoteSocketAddressLength;


    //
    // Initialize lists which are specific to listening endpoints.
    //

    InitializeListHead( &endpoint->Common.VcListening.UnacceptedConnectionListHead );
    InitializeListHead( &endpoint->Common.VcListening.ReturnedConnectionListHead );
    InitializeListHead( &endpoint->Common.VcListening.ListeningIrpListHead );


    ExInitializeSListHead (&endpoint->Common.VcListening.PreacceptedConnectionsListHead );

    endpoint->Common.VcListening.FailedConnectionAdds = 0;
    endpoint->Common.VcListening.Sequence = 0;
    endpoint->Common.VcListening.BacklogReplenishActive = FALSE;


    //
    // Initialize extra connection limit to that of backlog
    // We will adjust if more AcceptEx requests are enqueued.
    //
    endpoint->Common.VcListening.MaxExtraConnections = (USHORT)afdListenInfo.MaximumConnectionQueue;

    //
    // Initialize the tracking data for implementing dynamic backlog.
    //

    endpoint->Common.VcListening.TdiAcceptPendingCount = 0;

    if( AfdEnableDynamicBacklog &&
        (LONG)afdListenInfo.MaximumConnectionQueue > AfdMinimumDynamicBacklog ) {
        endpoint->Common.VcListening.EnableDynamicBacklog = TRUE;
    } else {
        endpoint->Common.VcListening.EnableDynamicBacklog = FALSE;
    }

    //
    // Set the type and state of the endpoint to listening.
    //
    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    if (afdListenInfo.UseDelayedAcceptance) {
        endpoint->DelayedAcceptance = TRUE;
        InitializeListHead (&endpoint->Common.VcListening.ListenConnectionListHead);
    }
    else {
        ExInitializeSListHead (&endpoint->Common.VcListening.FreeConnectionListHead );
    }
    endpoint->Listening = TRUE;
    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
    endpoint->Type |= AfdBlockTypeVcListening;

    //
    // Open a pool of connections on the specified endpoint.  The
    // connect indication handler will use these connections when
    // connect indications come in.
    //

    for ( i = 0; i < afdListenInfo.MaximumConnectionQueue; i++ ) {

        status = AfdAddFreeConnection( endpoint );

        if ( !NT_SUCCESS(status) ) {
            goto error_exit_deinit;
        }
    }

    if (!IS_DELAYED_ACCEPTANCE_ENDPOINT(endpoint)) {
        //
        // Set up a connect indication handler on the specified endpoint.
        //

        status = AfdSetEventHandler(
                     endpoint->AddressFileObject,
                     TDI_EVENT_CONNECT,
                     (PVOID)AfdConnectEventHandler,
                     endpoint
                     );

        if ( !NT_SUCCESS(status) ) {
            goto error_exit_deinit;
        }
    }

    AFD_END_STATE_CHANGE (endpoint);

    //
    // We're done, return to the app.
    //

    return STATUS_SUCCESS;

error_exit_deinit:

    AfdFreeQueuedConnections (endpoint);

    //
    // Reset the type and state of the endpoint.
    //

    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    endpoint->Listening = FALSE;
    endpoint->DelayedAcceptance = FALSE;
    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
    endpoint->Common.VirtualCircuit.RemoteSocketAddressOffset = remoteAddressOffset;
    endpoint->Common.VirtualCircuit.RemoteSocketAddressLength = remoteAddressLength;
    endpoint->Type &= (~(AfdBlockTypeVcListening&(~AfdBlockTypeEndpoint)));

error_exit_state_change:
    AFD_END_STATE_CHANGE (endpoint);

error_exit:
    return status;

} // AfdStartListen


NTSTATUS
FASTCALL
AfdWaitForListen (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine handles the IOCTL_AFD_WAIT_FOR_LISTEN IRP, which either
    immediately passes back to the caller a completed connection or
    waits for a connection attempt.

Arguments:

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PAFD_LISTEN_RESPONSE_INFO listenResponse;
    NTSTATUS status;

    //
    // Set up local variables.
    //

    endpoint = IrpSp->FileObject->FsContext;

    //
    // If the IRP comes from the app, check input data
    // (our internal super accept IRP sets MajorFunction to
    // internal device control - app can never do this)
    //

    if (IrpSp->MajorFunction != IRP_MJ_INTERNAL_DEVICE_CONTROL) {

        //
        // Irp should at least be able to hold the header of trasport address
        //

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                (ULONG)FIELD_OFFSET(AFD_LISTEN_RESPONSE_INFO, RemoteAddress.Address[0].Address)) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        listenResponse = Irp->AssociatedIrp.SystemBuffer;

    }

    //
    // Check if there is already an unaccepted connection on the
    // endpoint.  If there isn't, then we must wait until a connect
    // attempt arrives before completing this IRP.
    //
    // Note that we hold the AfdSpinLock with doing this checking;
    // this is necessary to synchronize with our indication handler.
    // Also, we need to validate that the endpoint is in the listening
    // state because it could be closed and recycled otherwise.
    //

    AfdAcquireSpinLock(&endpoint->SpinLock, &lockHandle);

    //
    // Make sure that the endpoint is in the correct state.
    //

    if (!endpoint->Listening) {
        AfdReleaseSpinLock(&endpoint->SpinLock, &lockHandle);
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    connection = AfdGetUnacceptedConnection(endpoint);

    if (connection == NULL) {

        //
        // Check if endpoint was cleaned-up and cancel the request.
        //
        if (endpoint->EndpointCleanedUp) {
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
            status = STATUS_CANCELLED;
            if (IrpSp->MajorFunction==IRP_MJ_INTERNAL_DEVICE_CONTROL) {
                AfdCleanupSuperAccept (Irp, status);
                if (Irp->Cancel) {
                    KIRQL cancelIrql;
                    //
                    // Need to sycn with cancel routine which may
                    // have been called from AfdCleanup for accepting
                    // endpoint
                    //
                    IoAcquireCancelSpinLock (&cancelIrql);
                    IoReleaseCancelSpinLock (cancelIrql);
                }
            }
            goto complete;
        }

        //
        // There were no outstanding unaccepted connections.  Set up the
        // cancel routine in the IRP.  
        //

        IoSetCancelRoutine( Irp, AfdCancelWaitForListen );

        //
        // If the IRP has already been canceled, just complete the request.
        //

        if ( Irp->Cancel ) {

            //
            // Indicate to cancel routine that IRP is not on the list
            //
            Irp->Tail.Overlay.ListEntry.Flink = NULL;

            //
            // The IRP has already been canceled.  Just return
            // STATUS_CANCELLED.
            //

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
         
            status = STATUS_CANCELLED;
            
            if (IrpSp->MajorFunction==IRP_MJ_INTERNAL_DEVICE_CONTROL) {
                AfdCleanupSuperAccept (Irp, status);
            }

            if (IoSetCancelRoutine( Irp, NULL ) == NULL) {
                KIRQL cancelIrql;

                //
                // If the cancel routine was NULL then cancel routine
                // may be running.  Wait on the cancel spinlock until
                // the cancel routine is done.
                //
                // Note: The cancel routine will not find the IRP
                // since it is not in the list.
                //
                
                IoAcquireCancelSpinLock( &cancelIrql );
                IoReleaseCancelSpinLock( cancelIrql );

            }

            goto complete;
        }

        //
        // Put this IRP on the endpoint's list of listening IRPs and
        // return pending.  Note the irp may be canceled after this;
        // however, the cancel routine will be called and will cancel
        // the irp after the AfdSpinLock is released. 
        //

        IoMarkIrpPending( Irp );

        if( IrpSp->MajorFunction==IRP_MJ_INTERNAL_DEVICE_CONTROL ||
                IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                    IOCTL_AFD_WAIT_FOR_LISTEN_LIFO ) {

            InsertHeadList(
                &endpoint->Common.VcListening.ListeningIrpListHead,
                &Irp->Tail.Overlay.ListEntry
                );

        } else {

            InsertTailList(
                &endpoint->Common.VcListening.ListeningIrpListHead,
                &Irp->Tail.Overlay.ListEntry
                );

        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        return STATUS_PENDING;
    }

    //
    // Call the routine to service the request.
    //
    ASSERT( connection->Type == AfdBlockTypeConnection );
    status = AfdServiceWaitForListen (Irp, connection, &lockHandle);
    if (NT_SUCCESS (status)) {
        //
        // In case of success, this routine completes the Irp
        // and releases the listening endpoint spinlock.
        //
        return status;
    }

    //
    // Failure (remote address buffer to small or endpoint cleaned up)
    //
    ASSERT (status!=STATUS_PENDING);

    //
    // Put connection back to the unaccepted queue.
    //
    InsertHeadList(
        &endpoint->Common.VcListening.UnacceptedConnectionListHead,
        &connection->ListEntry
        );


    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    if (Irp->Cancel) {
        KIRQL cancelIrql;
        //
        // Need to sycn with cancel routine which may
        // have been called from AfdCleanup for accepting
        // endpoint
        //
        IoAcquireCancelSpinLock (&cancelIrql);
        IoReleaseCancelSpinLock (cancelIrql);
    }



complete:
    //
    // Complete the IRP.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdWaitForListen


VOID
AfdCancelWaitForListen (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Cancels a wait for listen IRP that is pended in AFD.

Arguments:

    DeviceObject - not used.

    Irp - the IRP to cancel.

Return Value:

    None.

--*/
{
    PAFD_ENDPOINT       endpoint;
    PIO_STACK_LOCATION  irpSp;
    AFD_LOCK_QUEUE_HANDLE  lockHandle;

    UNREFERENCED_PARAMETER (DeviceObject);

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    endpoint = irpSp->FileObject->FsContext;
    ASSERT ( endpoint->Type==AfdBlockTypeVcListening ||
                endpoint->Type==AfdBlockTypeVcBoth );

    IF_DEBUG(LISTEN) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdCancelWaitForListen: called on IRP %p, endpoint %p\n",
                    Irp, endpoint ));
    }

    //
    // While holding the AFD spin lock, search all listening endpoints
    // for this IRP.
    //

    ASSERT (KeGetCurrentIrql ()==DISPATCH_LEVEL);
    AfdAcquireSpinLockAtDpcLevel( &endpoint->SpinLock, &lockHandle );
    if (Irp->Tail.Overlay.ListEntry.Flink!=NULL) {
        //
        // The Irp is still in the list, remove it
        //
        RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
        //
        // Complete the IRP with STATUS_CANCELLED and return.
        //
        if (irpSp->MajorFunction==IRP_MJ_INTERNAL_DEVICE_CONTROL) {
            //
            // Special case for super accept IRP in the listening queue.
            //
            AfdCleanupSuperAccept (Irp, STATUS_CANCELLED);
        }
        else {
            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;
        }
        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
        IoReleaseCancelSpinLock( Irp->CancelIrql );



        IoCompleteRequest( Irp, AfdPriorityBoost );
    }
    else {
        //
        // The Irp was not in the list, bail
        //
        AfdReleaseSpinLockFromDpcLevel( &endpoint->SpinLock, &lockHandle );
        IoReleaseCancelSpinLock( Irp->CancelIrql );
    }

    return;

} // AfdCancelWaitForListen


NTSTATUS
AfdConnectEventHandler (
    IN PVOID TdiEventContext,
    IN int RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN int UserDataLength,
    IN PVOID UserData,
    IN int OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    )

/*++

Routine Description:

    This is the connect event handler for listening AFD endpoints.
    It attempts to get a connection, and if successful checks whether
    there are outstanding IOCTL_WAIT_FOR_LISTEN IRPs.  If so, the
    first one is completed; if not, the connection is queued in a list of
    available, unaccepted but connected connection objects.

Arguments:

    TdiEventContext - the endpoint on which the connect attempt occurred.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    PAFD_CONNECTION connection;
    PAFD_ENDPOINT endpoint;
    PIRP irp;
    PDEVICE_OBJECT deviceObject;
    PFILE_OBJECT fileObject;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;
    PTDI_CONNECTION_INFORMATION requestConnectionInformation;
    NTSTATUS status;
    BOOLEAN result;


    AfdRecordConnectionIndications ();

    IF_DEBUG(LISTEN) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdConnectEventHandler: called on endpoint %p\n",
                    TdiEventContext ));
    }

    //
    // Reference the endpoint so that it doesn't go away beneath us.
    //

    endpoint = TdiEventContext;
    ASSERT( endpoint != NULL );

    CHECK_REFERENCE_ENDPOINT (endpoint, result);
    if (!result) {
        AfdRecordConnectionsDropped ();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT( endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth );

    //
    // If the endpoint is closing, refuse to accept the connection.
    //

    if ( endpoint->State == AfdEndpointStateClosing ||
         endpoint->EndpointCleanedUp ) {

        DEREFERENCE_ENDPOINT (endpoint);
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                    "AfdConnectEventHandler: Rejecting because endpoint %p is closing.\n",
                    endpoint));

        AfdRecordConnectionsDropped ();
        return STATUS_INSUFFICIENT_RESOURCES;

    }


    //
    // If there are connect data buffers on the listening endpoint,
    // create equivalent buffers that we'll use for the connection.
    //

    connectDataBuffers = NULL;

    if( endpoint->Common.VirtualCircuit.ConnectDataBuffers != NULL ) {

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Recheck under the lock to avoid taking it in most
        // common case.
        //

        if( endpoint->Common.VirtualCircuit.ConnectDataBuffers != NULL ) {
            connectDataBuffers = CopyConnectDataBuffers(
                                     endpoint->Common.VirtualCircuit.ConnectDataBuffers
                                     );

            if( connectDataBuffers == NULL ) {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                DEREFERENCE_ENDPOINT( endpoint );
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                            "AfdConnectEventHandler:"
                            "Rejecting because connect data buffer could not be allocated (endp %p).\n",
                            endpoint));

                AfdRecordConnectionsDropped ();
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    //
    // If we got connect data and/or options, save them on the connection.
    //

    if( UserData != NULL && UserDataLength > 0 ) {

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
        status = AfdSaveReceivedConnectData(
                     &connectDataBuffers,
                     IOCTL_AFD_SET_CONNECT_DATA,
                     UserData,
                     UserDataLength
                     );

        if( !NT_SUCCESS(status) ) {

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            DEREFERENCE_ENDPOINT( endpoint );
            if ( connectDataBuffers != NULL ) {
                AfdFreeConnectDataBuffers( connectDataBuffers );
            }
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                        "AfdConnectEventHandler:"
                        "Rejecting because user data buffer could not be allocated (endp %p).\n",
                        endpoint));

            AfdRecordConnectionsDropped ();
            return status;

        }
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    }

    if( Options != NULL && OptionsLength > 0 ) {

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
        status = AfdSaveReceivedConnectData(
                     &connectDataBuffers,
                     IOCTL_AFD_SET_CONNECT_OPTIONS,
                     Options,
                     OptionsLength
                     );

        if( !NT_SUCCESS(status) ) {

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            DEREFERENCE_ENDPOINT( endpoint );
            if ( connectDataBuffers != NULL ) {
                AfdFreeConnectDataBuffers( connectDataBuffers );
            }
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                        "AfdConnectEventHandler:"
                        "Rejecting because option buffer could not be allocated (endp %p).\n",
                        endpoint));

            AfdRecordConnectionsDropped ();
            return status;

        }
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    }

    if( connectDataBuffers != NULL ) {

        //
        // We allocated extra space at the end of the connect data
        // buffers structure.  We'll use this for the
        // TDI_CONNECTION_INFORMATION structure that holds response
        // connect data and options.  Not pretty, but the fastest
        // and easiest way to accomplish this.
        //

        requestConnectionInformation =
            &connectDataBuffers->RequestConnectionInfo;

        RtlZeroMemory(
            requestConnectionInformation,
            sizeof(*requestConnectionInformation)
            );

        requestConnectionInformation->UserData =
            connectDataBuffers->SendConnectData.Buffer;
        requestConnectionInformation->UserDataLength =
            connectDataBuffers->SendConnectData.BufferLength;
        requestConnectionInformation->Options =
            connectDataBuffers->SendConnectOptions.Buffer;
        requestConnectionInformation->OptionsLength =
            connectDataBuffers->SendConnectOptions.BufferLength;

    } else {

        requestConnectionInformation = NULL;

    }

    //
    // Enforce dynamic backlog if enabled.
    //

    if( endpoint->Common.VcListening.EnableDynamicBacklog ) {

        LONG freeCount;
        LONG acceptCount;
        LONG failedCount;

        //
        // If the free connection count has dropped below the configured
        // minimum, the number of "quasi-free" connections is less than
        // the configured maximum, and we haven't already queued enough
        // requests to take us past the maximum, then add new free
        // connections to the endpoint. "Quasi-free" is defined as the
        // sum of the free connection count and the count of pending TDI
        // accepts.
        //

        freeCount = (ULONG)ExQueryDepthSList (&endpoint->Common.VcListening.FreeConnectionListHead);
        acceptCount = endpoint->Common.VcListening.TdiAcceptPendingCount;
        failedCount = endpoint->Common.VcListening.FailedConnectionAdds;

        if( freeCount < AfdMinimumDynamicBacklog &&
            ( freeCount + acceptCount ) < AfdMaximumDynamicBacklog &&
            failedCount < AfdMaximumDynamicBacklog ) {

            InterlockedExchangeAdd(
                &endpoint->Common.VcListening.FailedConnectionAdds,
                AfdMaximumDynamicBacklog
                );

            AfdInitiateListenBacklogReplenish( endpoint );

        }

    }

    //
    // Attempt to get a pre-allocated connection object to handle the
    // connection.
    //

    while ((connection = AfdGetFreeConnection( endpoint, &irp ))!=NULL) {

        IF_DEBUG(LISTEN) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdConnectEventHandler: using connection %p\n",
                        connection ));
        }

        ASSERT( connection->Type == AfdBlockTypeConnection );
        ASSERT( connection->Endpoint==NULL);

        //
        // Get the address of the target device object.
        //

        fileObject = connection->FileObject;
        ASSERT( fileObject != NULL );
        deviceObject = connection->DeviceObject;

        // We will need to store the remote address in the connection.  If the
        // connection object already has a remote address block that is
        // sufficient, use it.  Otherwise, allocate a new one.
        //

        if ( connection->RemoteAddress != NULL &&
                 connection->RemoteAddressLength < (ULONG)RemoteAddressLength ) {

            AFD_RETURN_REMOTE_ADDRESS(
                connection->RemoteAddress,
                connection->RemoteAddressLength
                );
            connection->RemoteAddress = NULL;
        }

        if ( connection->RemoteAddress == NULL ) {

            connection->RemoteAddress = AFD_ALLOCATE_REMOTE_ADDRESS(RemoteAddressLength);
            if (connection->RemoteAddress==NULL) {
                //
                // Out of memory, free the connection (to make more available memory
                // for the next allocation attempt) and continue searching.
                //
                //
                if (irp!=NULL) {
                    //
                    // Clean-up and complete the IRP.
                    //
                    AfdCleanupSuperAccept (irp, STATUS_CANCELLED);
                    if (irp->Cancel) {
                        KIRQL cancelIrql;
                        //
                        // Need to sycn with cancel routine which may
                        // have been called from AfdCleanup for accepting
                        // endpoint
                        //
                        IoAcquireCancelSpinLock (&cancelIrql);
                        IoReleaseCancelSpinLock (cancelIrql);
                    }
                    IoCompleteRequest (irp, AfdPriorityBoost);
                }
                //
                // We will need to replace the connection
                // we freed to maintain the backlog
                //
                InterlockedIncrement (
                    &endpoint->Common.VcListening.FailedConnectionAdds);
                DEREFERENCE_CONNECTION (connection);
                continue;
            }
        }

        connection->RemoteAddressLength = RemoteAddressLength;
        //
        // Check if this is a "preaccepted connection for which
        // we already have an associated endpoint and super
        // accept irp
        //
        if (irp!=NULL) {
            PIO_STACK_LOCATION irpSp;
            PAFD_ENDPOINT   acceptEndpoint;
            PFILE_OBJECT    acceptFileObject;

            irpSp = IoGetCurrentIrpStackLocation (irp);
            acceptFileObject = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdAcceptFileObject;
            acceptEndpoint = acceptFileObject->FsContext;
            ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));
            ASSERT (irp->Tail.Overlay.DriverContext[0] == connection);

            //
            // Check if super accept Irp has enough space for
            // the remote address
            //
            if( (ULONG)RemoteAddressLength <=
                    irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength ) {
                //
                // Check if we have enough system PTE's to map
                // the buffer.
                //
                status = AfdMapMdlChain (irp->MdlAddress);
                if( NT_SUCCESS (status) ) {
                    //
                    // Allocate MDL for local address query if requested
                    //
                    if ((irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength==0) ||
                            (IoAllocateMdl ((PUCHAR)irp->UserBuffer+irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength,
                                        irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                                        TRUE,
                                        FALSE,
                                        irp)!=NULL)){
                        //
                        // Copy the remote address to user buffer
                        //
#ifndef i386
                        if (acceptEndpoint->Common.VcConnecting.FixAddressAlignment) {
                            USHORT addressLength = 
                                    ((PTRANSPORT_ADDRESS)RemoteAddress)->Address[0].AddressLength
                                    + sizeof (USHORT);
                            USHORT UNALIGNED *pAddrLength = (PVOID)
                                        ((PUCHAR)MmGetSystemAddressForMdl (irp->MdlAddress)
                                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength
                                         - sizeof (USHORT));
                            RtlMoveMemory (
                                        (PUCHAR)MmGetSystemAddressForMdl (irp->MdlAddress)
                                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                                         &((PTRANSPORT_ADDRESS)RemoteAddress)->Address[0].AddressType,
                                         addressLength);
                            *pAddrLength = addressLength;
                        }
                        else
#endif
                        {
                            RtlMoveMemory (
                                        (PUCHAR)MmGetSystemAddressForMdl (irp->MdlAddress)
                                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                                         RemoteAddress,
                                         RemoteAddressLength);
                        }
                        AfdAcquireSpinLock (&acceptEndpoint->SpinLock, &lockHandle);

                        ASSERT (acceptEndpoint->Irp==irp);

                        //
                        // Save the reference we added in the beginning of this
                        // routine
                        //
                        connection->Endpoint = endpoint;

                        //
                        // Setup the accept endpoint to match parameters
                        // of the listening endpoint from which connection
                        // is accepted (also check if accept endpoint
                        // has not been cleaned up).
                        //
                        status = AfdSetupAcceptEndpoint (endpoint, acceptEndpoint, connection);
                        if (status==STATUS_SUCCESS) {

                            //
                            // Should have been cleaned up.
                            //
                            ASSERT (acceptEndpoint->Irp == NULL);

                            AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);

                            irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress =
                                    irp->MdlAddress;
                            irp->MdlAddress = NULL;

                            TdiBuildAccept(
                                irp,
                                deviceObject,
                                fileObject,
                                AfdRestartSuperAccept,
                                acceptFileObject,
                                requestConnectionInformation,
                                NULL
                                );

                            AfdRecordConnectionsPreaccepted ();
                            break;
                        }
                        else { // if (AfdSetupAcceptEndpoint==STATUS_SUCCESS)
                            AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
                            connection->Endpoint = NULL;
                        }
                    } // if (IoAllocateMdl!=NULL)
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                } // if (NT_SUCCESS (AfdMapMdlChain (irp->MdlAddress))
            }
            else { // if (RemoteAddressLength <= irpSp->...AfdRemoteAddressLength)
                status = STATUS_BUFFER_TOO_SMALL;
            }

            //
            // Clean-up and complete the IRP.
            //
            AfdCleanupSuperAccept (irp, status);
            if (irp->Cancel) {
                KIRQL cancelIrql;
                //
                // Need to sycn with cancel routine which may
                // have been called from AfdCleanup for accepting
                // endpoint
                //
                IoAcquireCancelSpinLock (&cancelIrql);
                IoReleaseCancelSpinLock (cancelIrql);
            }
            IoCompleteRequest (irp, AfdPriorityBoost);
            
            //
            // This connection has already been diassociated from endpoint.
            // If backlog is below the level we need, put it on the free
            // list, otherwise, get rid of it.
            //

            ASSERT (connection->Endpoint==NULL);
            if (endpoint->Common.VcListening.FailedConnectionAdds>=0 &&
                    status!=STATUS_INSUFFICIENT_RESOURCES &&
                    ExQueryDepthSList (&endpoint->Common.VcListening.FreeConnectionListHead)<AFD_MAXIMUM_FREE_CONNECTIONS) {
                InterlockedPushEntrySList (
                                &endpoint->Common.VcListening.FreeConnectionListHead,
                                &connection->SListEntry);
            }
            else {
                InterlockedIncrement (&endpoint->Common.VcListening.FailedConnectionAdds);
                DEREFERENCE_CONNECTION (connection);
            }

        }
        else {

            //
            // Allocate an IRP. 
            //

            irp = IoAllocateIrp( (CCHAR)(deviceObject->StackSize), FALSE );

            if ( irp != NULL ) {

                //
                // Save the address endpoint pointer in the connection.
                //

                connection->Endpoint = endpoint;

                //
                // Initialize the IRP for an accept operation.
                //

                irp->RequestorMode = KernelMode;
                irp->Tail.Overlay.Thread = PsGetCurrentThread();
                irp->Tail.Overlay.OriginalFileObject = fileObject;

                TdiBuildAccept(
                    irp,
                    deviceObject,
                    fileObject,
                    AfdRestartAccept,
                    connection,
                    requestConnectionInformation,
                    NULL
                    );
                AfdRecordConnectionsAccepted ();
                break;
            }
            else {
                //
                // Free the connection in attempt to release some
                // memory for the system.
                //
                ASSERT (connection->Endpoint==NULL);
                DEREFERENCE_CONNECTION (connection);

                //
                // We will need to replace the connection
                // we freed to maintain the backlog
                //

                InterlockedIncrement (
                    &endpoint->Common.VcListening.FailedConnectionAdds);
            }
        }
    }

    //
    // If we found connection to use for accept
    //
    if (connection!=NULL) {

        //
        // Complete IRP setup.
        //

        IoSetNextIrpStackLocation( irp );

        //
        // Set the return IRP so the transport processes this accept IRP.
        //

        *AcceptIrp = irp;

        //
        // Set up the connection context as a pointer to the connection block
        // we're going to use for this connect request.  This allows the
        // TDI provider to which connection object to use.
        //

        *ConnectionContext = (CONNECTION_CONTEXT)connection;

        //
        // Save a pointer to the connect data buffers, if any.
        //

        connection->ConnectDataBuffers = connectDataBuffers;

        //
        // Set the block state of this connection.
        //

        connection->State = AfdConnectionStateUnaccepted;

        RtlMoveMemory(
            connection->RemoteAddress,
            RemoteAddress,
            RemoteAddressLength
            );


        AFD_VERIFY_ADDRESS (connection, RemoteAddress);

        //
        // Add an additional reference to the connection.  This prevents
        // the connection from being closed until the disconnect event
        // handler is called.
        //

        AfdAddConnectedReference( connection );

        //
        // Add a reference for the TDI accept IRP that is now pending
        // because if the connection disconnects prior to completion
        // it will deallocate prior to our completion routine completing.
        //

        REFERENCE_CONNECTION( connection );

        //
        // Remember that we have another TDI accept pending on this endpoint.
        //

        InterlockedIncrement(
            &endpoint->Common.VcListening.TdiAcceptPendingCount
            );


        //
        // Indicate to the TDI provider that we allocated a connection to
        // service this connect attempt.
        //

        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    else {


        if ( connectDataBuffers != NULL ) {
            AfdFreeConnectDataBuffers( connectDataBuffers );
        }

        //
        // If there have been failed connection additions, kick off
        // a request to an executive worker thread to attempt to add
        // some additional free connections.
        //

        if ( endpoint->Common.VcListening.FailedConnectionAdds > 0 ) {
            AfdInitiateListenBacklogReplenish( endpoint );
        }

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                  "AfdConnectEventHandler:"
                  "Rejecting because there are no free connection objects on endp %p.\n"
                  "                       "
                  "free %ld, pending %ld, failed %ld\n",
                  endpoint,
                  ExQueryDepthSList (&endpoint->Common.VcListening.FreeConnectionListHead),
                  endpoint->Common.VcListening.TdiAcceptPendingCount,
                  endpoint->Common.VcListening.FailedConnectionAdds));
        AfdRecordConnectionsDropped ();

        DEREFERENCE_ENDPOINT( endpoint );

        return STATUS_INSUFFICIENT_RESOURCES;
    }

} // AfdConnectEventHandler


NTSTATUS
AfdDelayedAcceptListen (
    PAFD_ENDPOINT   Endpoint,
    PAFD_CONNECTION Connection
    )
/*++

Routine Description:
    
    Posts a listen IRP on Endpoints that support delayed acceptance
    and thus cannot use connect event handler.
Arguments:

    Endpoint - listen endpoint
    Connection - connection object to accept connection on
Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/
{
    PIRP irp;
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;
    PTDI_CONNECTION_INFORMATION returnConnectionInformation;
    PTDI_CONNECTION_INFORMATION requestConnectionInformation;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // Allocate listen IRP
    //
    irp = IoAllocateIrp ((CCHAR)Connection->DeviceObject->StackSize, FALSE);
    if (irp==NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( Connection->RemoteAddress == NULL ) {

        Connection->RemoteAddress = AFD_ALLOCATE_REMOTE_ADDRESS(Endpoint->LocalAddressLength);
        if (Connection->RemoteAddress==NULL) {
            IoFreeIrp (irp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        Connection->RemoteAddressLength = Endpoint->LocalAddressLength;
    }


    //
    // Copy connect data buffers to accept connect data in
    //

    AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );
    if( Endpoint->Common.VirtualCircuit.ConnectDataBuffers != NULL ) {

        connectDataBuffers = CopyConnectDataBuffers(
                                 Endpoint->Common.VirtualCircuit.ConnectDataBuffers
                                 );

        if( connectDataBuffers == NULL ) {
            AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
            IoFreeIrp (irp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {
        connectDataBuffers = AFD_ALLOCATE_POOL(
                         NonPagedPool,
                         sizeof(*connectDataBuffers),
                         AFD_CONNECT_DATA_POOL_TAG
                         );

        if ( connectDataBuffers == NULL ) {
            //
            // If listening endpoint did not have connect data buffers,
            // we cannot handle delayed connection acceptance
            //
            AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
            IoFreeIrp (irp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlZeroMemory(
            connectDataBuffers,
            sizeof(*connectDataBuffers)
            );

    }

    Connection->ConnectDataBuffers = connectDataBuffers;

    //
    // Setup listen request parameters and sumbit it.
    // From this point on the cleanup will be handled by the
    // IRP's completion routine.
    //

    requestConnectionInformation =
        &connectDataBuffers->RequestConnectionInfo;
    
    RtlZeroMemory(
        requestConnectionInformation,
        sizeof(*requestConnectionInformation)
        );

    connectDataBuffers->Flags = TDI_QUERY_ACCEPT;
    
    returnConnectionInformation =
        &connectDataBuffers->ReturnConnectionInfo;

    RtlZeroMemory(
        returnConnectionInformation,
        sizeof(*returnConnectionInformation)
        );

    returnConnectionInformation->RemoteAddress = 
        Connection->RemoteAddress;
    returnConnectionInformation->RemoteAddressLength = 
        Connection->RemoteAddressLength;

    returnConnectionInformation->UserData =
        connectDataBuffers->ReceiveConnectData.Buffer;
    returnConnectionInformation->UserDataLength =
        connectDataBuffers->ReceiveConnectData.BufferLength;
    returnConnectionInformation->Options =
        connectDataBuffers->ReceiveConnectOptions.Buffer;
    returnConnectionInformation->OptionsLength =
        connectDataBuffers->ReceiveConnectOptions.BufferLength;

    //
    // Assign connection to listening endpoint and insert it
    // in the list of listen connecitons
    //
    REFERENCE_ENDPOINT (Endpoint);
    Connection->Endpoint = Endpoint;
    Connection->ListenIrp = irp;

    InsertTailList (&Endpoint->Common.VcListening.ListenConnectionListHead,
                        &Connection->ListEntry);

    AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );


    TdiBuildListen (
            irp, 
            Connection->DeviceObject,
            Connection->FileObject,
            AfdRestartDelayedAcceptListen,
            Connection,
            TDI_QUERY_ACCEPT,
            requestConnectionInformation,
            returnConnectionInformation
            );


    IoCallDriver (Connection->DeviceObject, irp);

    return STATUS_PENDING;
}




NTSTATUS
AfdRestartDelayedAcceptListen (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the restart routine for listening AFD endpoints on transports
    that implement delayed connection acceptance.

Arguments:

    
Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    PAFD_CONNECTION connection;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY listEntry;
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;
    NTSTATUS    status;

    UNREFERENCED_PARAMETER (DeviceObject);

    AfdRecordConnectionIndications ();

    connection = Context;

    endpoint = connection->Endpoint;
    ASSERT( endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth );


    IF_DEBUG(LISTEN) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartListen: called on endpoint %p, status-%lx\n",
                    endpoint, Irp->IoStatus.Status ));
    }

    if (InterlockedExchangePointer ((PVOID *)&connection->ListenIrp, NULL)==NULL) {
        KIRQL cancelIrql;
        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        IoAcquireCancelSpinLock (&cancelIrql);
        IoReleaseCancelSpinLock (cancelIrql);
    }
    else {
        //
        // Remove connection from listen list.
        //
        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        RemoveEntryList (&connection->ListEntry);
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    status = Irp->IoStatus.Status;
    IoFreeIrp (Irp);


    if (!NT_SUCCESS (status)) {
        DEREFERENCE_CONNECTION (connection);
        //
        // We will need to replace the connection
        // we freed to maintain the backlog
        //
        InterlockedIncrement (
            &endpoint->Common.VcListening.FailedConnectionAdds);
        goto Exit;
    }
    
    //
    // Add an additional reference to the connection.  This prevents
    // the connection from being closed until the disconnect event
    // handler is called.
    //

    AfdAddConnectedReference( connection );


    //
    // If the endpoint is closing, refuse to accept the connection.
    //

    if (endpoint->State == AfdEndpointStateClosing ||
            endpoint->EndpointCleanedUp ) {

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                    "AfdRestartListen:"
                    "Rejecting because endpoint %p is closing.\n",
                    endpoint));
        goto ErrorExit;
    }



    //
    // Enforce dynamic backlog if enabled.
    //

    if( endpoint->Common.VcListening.EnableDynamicBacklog ) {

        LONG freeCount;
        LONG acceptCount;
        LONG failedCount;

        //
        // If the free connection count has dropped below the configured
        // minimum, the number of "quasi-free" connections is less than
        // the configured maximum, and we haven't already queued enough
        // requests to take us past the maximum, then add new free
        // connections to the endpoint. "Quasi-free" is defined as the
        // sum of the free connection count and the count of pending TDI
        // accepts.
        //

        freeCount = (ULONG)ExQueryDepthSList (&endpoint->Common.VcListening.FreeConnectionListHead);
        acceptCount = endpoint->Common.VcListening.TdiAcceptPendingCount;
        failedCount = endpoint->Common.VcListening.FailedConnectionAdds;

        if( freeCount < AfdMinimumDynamicBacklog &&
            ( freeCount + acceptCount ) < AfdMaximumDynamicBacklog &&
            failedCount < AfdMaximumDynamicBacklog ) {

            InterlockedExchangeAdd(
                &endpoint->Common.VcListening.FailedConnectionAdds,
                AfdMaximumDynamicBacklog
                );

            AfdInitiateListenBacklogReplenish( endpoint );

        }

    }

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    connectDataBuffers = connection->ConnectDataBuffers;
    ASSERT (connectDataBuffers!=NULL);

    //
    // Save the remote address
    //
    if (connection->RemoteAddress != 
            connectDataBuffers->ReturnConnectionInfo.RemoteAddress) {
        //
        // Transport did not use buffer in our request but allocated
        // one of its own, we will need to copy it.
        //

        //
        // Allocate buffer is not already done or unsufficient space.
        //
        if ( connection->RemoteAddress != NULL &&
                 connection->RemoteAddressLength < (ULONG)connectDataBuffers->ReturnConnectionInfo.RemoteAddressLength ) {

            AFD_RETURN_REMOTE_ADDRESS(
                connection->RemoteAddress,
                connection->RemoteAddressLength
                );
            connection->RemoteAddress = NULL;
        }

        if ( connection->RemoteAddress == NULL ) {

            connection->RemoteAddress = AFD_ALLOCATE_REMOTE_ADDRESS(
                        connectDataBuffers->ReturnConnectionInfo.RemoteAddressLength);
            if (connection->RemoteAddress==NULL) {
                connection->RemoteAddressLength = 0;

                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                            "AfdRestartListen:"
                            "Rejecting because not enough resources for remote address.\n",
                            endpoint));
                goto ErrorExit;
            }
        }

        connection->RemoteAddressLength = connectDataBuffers->ReturnConnectionInfo.RemoteAddressLength;

        RtlMoveMemory(
            connection->RemoteAddress,
            connectDataBuffers->ReturnConnectionInfo.RemoteAddress,
            connectDataBuffers->ReturnConnectionInfo.RemoteAddressLength
            );

    }
    else {
        //
        // They used our buffer which is the one in the connection object
        //
        ASSERT (connection->RemoteAddressLength>=(ULONG)connectDataBuffers->ReturnConnectionInfo.RemoteAddressLength);
        connection->RemoteAddressLength = connectDataBuffers->ReturnConnectionInfo.RemoteAddressLength;
    }


    //
    // If we got connect data and/or options, save them on the connection.
    //

    if( connectDataBuffers->ReturnConnectionInfo.UserData != NULL && 
            connectDataBuffers->ReturnConnectionInfo.UserDataLength > 0 ) {


        status = AfdSaveReceivedConnectData(
                     &connectDataBuffers,
                     IOCTL_AFD_SET_CONNECT_DATA,
                     connectDataBuffers->ReturnConnectionInfo.UserData,
                     connectDataBuffers->ReturnConnectionInfo.UserDataLength
                     );
        if (!NT_SUCCESS (status)) {
            goto ErrorExit;
        }
    }

    if( connectDataBuffers->ReturnConnectionInfo.Options != NULL &&
            connectDataBuffers->ReturnConnectionInfo.OptionsLength > 0 ) {

        status = AfdSaveReceivedConnectData(
                     &connectDataBuffers,
                     IOCTL_AFD_SET_CONNECT_OPTIONS,
                     connectDataBuffers->ReturnConnectionInfo.Options,
                     connectDataBuffers->ReturnConnectionInfo.OptionsLength
                     );

        if (!NT_SUCCESS (status)) {
            goto ErrorExit;
        }
    }


    //
    // Set the block state of this connection.
    //

    connection->State = AfdConnectionStateUnaccepted;

    //
    // Complete IRPs until we find the one that has enough space
    // for the remote address.
    //

    while (!IsListEmpty( &endpoint->Common.VcListening.ListeningIrpListHead ) ) {
        PIRP waitForListenIrp;
        //
        // Take the first IRP off the listening list.
        //

        listEntry = RemoveHeadList(
                        &endpoint->Common.VcListening.ListeningIrpListHead
                        );

        listEntry->Flink = NULL;

        //
        // Get a pointer to the current IRP, and get a pointer to the
        // current stack lockation.
        //

        waitForListenIrp = CONTAINING_RECORD(
                               listEntry,
                               IRP,
                               Tail.Overlay.ListEntry
                               );

        IF_DEBUG(LISTEN) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdRestartAccept: completing IRP %p\n",
                        waitForListenIrp ));
        }

        //
        // Call routine to service the IRP
        //
        status = AfdServiceWaitForListen (waitForListenIrp, connection, &lockHandle);
        if (NT_SUCCESS (status)) {
            //
            // On success this routine completes the IRP and releases
            // the endpoint spinlock
            // Return STATUS_MORE_PROCESSING_REQUIRED since we
            // already freed the IRP
            //
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        //
        // Failure (unsufficient space for remote address buffer)
        //

        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        //
        // Synchronize with cancel routine if it is running
        //
        if (IoSetCancelRoutine (waitForListenIrp, NULL)==NULL) {
            KIRQL cancelIrql;
            //
            // The cancel routine won't find the IRP on the list
            // Just make sure it completes before we complete the IRP.
            //
            IoAcquireCancelSpinLock (&cancelIrql);
            IoReleaseCancelSpinLock (cancelIrql);
        }
        IoCompleteRequest (waitForListenIrp, AfdPriorityBoost);
        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    //
    // At this point, we still hold the AFD spinlock.
    // and we could find matching listen request.
    // Put the connection on unaccepted list.
    //


    InsertTailList(
        &endpoint->Common.VcListening.UnacceptedConnectionListHead,
        &connection->ListEntry
        );

    AfdIndicateEventSelectEvent(
        endpoint,
        AFD_POLL_ACCEPT,
        STATUS_SUCCESS
        );

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // If there are outstanding polls waiting for a connection on this
    // endpoint, complete them.
    //

    AfdIndicatePollEvent(
        endpoint,
        AFD_POLL_ACCEPT,
        STATUS_SUCCESS
        );

    //
    // If there have been failed connection additions, kick off
    // a request to an executive worker thread to attempt to add
    // some additional free connections.
    //

    if ( endpoint->Common.VcListening.FailedConnectionAdds > 0 ) {
        AfdInitiateListenBacklogReplenish( endpoint );
    }

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP (we already freed it above).
    //

    goto Exit;;

ErrorExit:

    AfdRecordConnectionsDropped ();

    AfdAbortConnection (connection);
    //
    // We will need to replace the connection
    // we aborted to maintain the backlog
    //
    InterlockedIncrement (
        &endpoint->Common.VcListening.FailedConnectionAdds);
Exit:
    

    return STATUS_MORE_PROCESSING_REQUIRED;
} // AfdRestartListen


NTSTATUS
AfdRestartAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This is the restart routine for accept IRP that we passed back
    to the transport in connection indication handler.
    Super accept IRPs use a different restart routine.

Arguments:

    
Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/


{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY listEntry;
    LIST_ENTRY  irpList;
    NTSTATUS    status;

    UNREFERENCED_PARAMETER (DeviceObject);

    connection = Context;
    ASSERT( connection != NULL );
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint != NULL );
    ASSERT( endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth );

    UPDATE_CONN2( connection, "Restart accept, status: 0x%lX", Irp->IoStatus.Status );


    IF_DEBUG(ACCEPT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartAccept: accept completed, status = %X, "
                    "endpoint = %p, connection = %p\n",
                    Irp->IoStatus.Status, endpoint,
                    connection ));
    }

    //
    // Remember that a TDI accept has completed on this endpoint.
    //

    InterlockedDecrement(
        &endpoint->Common.VcListening.TdiAcceptPendingCount
        );

    //
    // If the accept failed, treat it like an abortive disconnect.
    // This way the application still gets a new endpoint, but it gets
    // told about the reset.
    //

    if ( !NT_SUCCESS(Irp->IoStatus.Status) ) {
        AfdDisconnectEventHandler(
            NULL,
            connection,
            0,
            NULL,
            0,
            NULL,
            TDI_DISCONNECT_ABORT
            );
    }


    //
    // Free the IRP now since it is no longer needed.
    //

    IoFreeIrp( Irp );

    //
    // Remember the time that the connection started.
    //

    connection->ConnectTime = KeQueryInterruptTime();

    //
    // Check whether the endpoint has been cleaned up yet.  If so, just
    // throw out this connection, since it cannot be accepted any more.
    // Also, this closes a hole between the endpoint being cleaned up
    // and all the connections that reference it being deleted.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    if ( endpoint->EndpointCleanedUp ) {

        //
        // First release the locks.
        //

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Abort the connection.
        //

        AfdAbortConnection( connection );

        //
        // Remove the TDI accept IRP reference to the connection.
        //

        DEREFERENCE_CONNECTION( connection );

        //
        // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
        // will stop working on the IRP.
        //

        return STATUS_MORE_PROCESSING_REQUIRED;

    }

    InitializeListHead (&irpList);

    while (1) {

        PIRP waitForListenIrp;

        //
        // First try to service an AcceptEx request
        //

        if (AfdServiceSuperAccept (endpoint, connection, &lockHandle, &irpList)) {
            //
            // This routine releases the spinlock and completes the
            // IRP
            goto CompleteIrps;
        
        }

        //
        // Complete IRPs until we find the one that has enough space
        // for the remote address.
        //
        if (IsListEmpty( &endpoint->Common.VcListening.ListeningIrpListHead ) ) {
            break;
        }



        //
        // Take the first IRP off the listening list.
        //

        listEntry = RemoveHeadList(
                        &endpoint->Common.VcListening.ListeningIrpListHead
                        );

        listEntry->Flink = NULL;

        //
        // Get a pointer to the current IRP, and get a pointer to the
        // current stack lockation.
        //

        waitForListenIrp = CONTAINING_RECORD(
                               listEntry,
                               IRP,
                               Tail.Overlay.ListEntry
                               );

        IF_DEBUG(LISTEN) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdRestartAccept: completing IRP %p\n",
                        waitForListenIrp ));
        }

        status = AfdServiceWaitForListen (waitForListenIrp, connection, &lockHandle);
        if (NT_SUCCESS (status)) {
            //
            // On Success service routine completes the IRP and
            // releases endpoint spinlock
            //
            goto CompleteIrps;
        }
        
        //
        // Could not use the IRP, complete it with error
        //

        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        //
        // Reset cancel routine
        //

        if (IoSetCancelRoutine (waitForListenIrp, NULL)==NULL) {
            KIRQL cancelIrql;
            //
            // It is running already, it won't find the IRP in the
            // list, just let it complete
            //
            IoAcquireCancelSpinLock (&cancelIrql);
            IoReleaseCancelSpinLock (cancelIrql);
        }
        IoCompleteRequest (waitForListenIrp, AfdPriorityBoost);

        //
        // Continue searching for IRP
        //

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);

    }

    //
    // At this point, we still hold the AFD spinlock.
    // and we could find matching listen request.
    // Put the connection on unaccepted list.
    //


    InsertTailList(
        &endpoint->Common.VcListening.UnacceptedConnectionListHead,
        &connection->ListEntry
        );

    AfdIndicateEventSelectEvent(
        endpoint,
        AFD_POLL_ACCEPT,
        STATUS_SUCCESS
        );
    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // If there are outstanding polls waiting for a connection on this
    // endpoint, complete them.
    //

    AfdIndicatePollEvent(
        endpoint,
        AFD_POLL_ACCEPT,
        STATUS_SUCCESS
        );

CompleteIrps:
    //
    // Complete previously failed accept irps if any.
    //
    while (!IsListEmpty (&irpList)) {
        PIRP    irp;
        irp = CONTAINING_RECORD (irpList.Flink, IRP, Tail.Overlay.ListEntry);
        RemoveEntryList (&irp->Tail.Overlay.ListEntry);
        IoCompleteRequest (irp, AfdPriorityBoost);
    }

    //
    // Remove the TDI accept IRP reference to the connection.
    //

    DEREFERENCE_CONNECTION( connection );

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // AfdRestartAccept


PAFD_CONNECT_DATA_BUFFERS
CopyConnectDataBuffers (
    IN PAFD_CONNECT_DATA_BUFFERS OriginalConnectDataBuffers
    )
{
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;

    connectDataBuffers = AFD_ALLOCATE_POOL(
                             NonPagedPool,
                             sizeof(*connectDataBuffers),
                             AFD_CONNECT_DATA_POOL_TAG
                             );

    if ( connectDataBuffers == NULL ) {
        return NULL;
    }

    RtlZeroMemory( connectDataBuffers, sizeof(*connectDataBuffers) );

    if ( !CopySingleConnectDataBuffer(
              &OriginalConnectDataBuffers->SendConnectData,
              &connectDataBuffers->SendConnectData ) ) {
        AfdFreeConnectDataBuffers( connectDataBuffers );
        return NULL;
    }

    if ( !CopySingleConnectDataBuffer(
              &OriginalConnectDataBuffers->SendConnectOptions,
              &connectDataBuffers->SendConnectOptions ) ) {
        AfdFreeConnectDataBuffers( connectDataBuffers );
        return NULL;
    }

    if ( !CopySingleConnectDataBuffer(
              &OriginalConnectDataBuffers->ReceiveConnectData,
              &connectDataBuffers->ReceiveConnectData ) ) {
        AfdFreeConnectDataBuffers( connectDataBuffers );
        return NULL;
    }

    if ( !CopySingleConnectDataBuffer(
              &OriginalConnectDataBuffers->ReceiveConnectOptions,
              &connectDataBuffers->ReceiveConnectOptions ) ) {
        AfdFreeConnectDataBuffers( connectDataBuffers );
        return NULL;
    }

    if ( !CopySingleConnectDataBuffer(
              &OriginalConnectDataBuffers->SendDisconnectData,
              &connectDataBuffers->SendDisconnectData ) ) {
        AfdFreeConnectDataBuffers( connectDataBuffers );
        return NULL;
    }

    if ( !CopySingleConnectDataBuffer(
              &OriginalConnectDataBuffers->SendDisconnectOptions,
              &connectDataBuffers->SendDisconnectOptions ) ) {
        AfdFreeConnectDataBuffers( connectDataBuffers );
        return NULL;
    }

    if ( !CopySingleConnectDataBuffer(
              &OriginalConnectDataBuffers->ReceiveDisconnectData,
              &connectDataBuffers->ReceiveDisconnectData ) ) {
        AfdFreeConnectDataBuffers( connectDataBuffers );
        return NULL;
    }

    if ( !CopySingleConnectDataBuffer(
              &OriginalConnectDataBuffers->ReceiveDisconnectOptions,
              &connectDataBuffers->ReceiveDisconnectOptions ) ) {
        AfdFreeConnectDataBuffers( connectDataBuffers );
        return NULL;
    }

    return connectDataBuffers;

} // CopyConnectDataBuffers


BOOLEAN
CopySingleConnectDataBuffer (
    IN PAFD_CONNECT_DATA_INFO InConnectDataInfo,
    OUT PAFD_CONNECT_DATA_INFO OutConnectDataInfo
    )
{

    if ( InConnectDataInfo->Buffer != NULL &&
             InConnectDataInfo->BufferLength != 0 ) {

        OutConnectDataInfo->BufferLength = InConnectDataInfo->BufferLength;

        OutConnectDataInfo->Buffer = AFD_ALLOCATE_POOL(
                                         NonPagedPool,
                                         OutConnectDataInfo->BufferLength,
                                         AFD_CONNECT_DATA_POOL_TAG
                                         );

        if ( OutConnectDataInfo->Buffer == NULL ) {
            return FALSE;
        }

        RtlCopyMemory(
            OutConnectDataInfo->Buffer,
            InConnectDataInfo->Buffer,
            InConnectDataInfo->BufferLength
            );

    } else {

        OutConnectDataInfo->Buffer = NULL;
        OutConnectDataInfo->BufferLength = 0;
    }

    return TRUE;

} // CopySingleConnectDataBuffer


NTSTATUS
AfdServiceWaitForListen (
    PIRP            Irp,
    PAFD_CONNECTION Connection,
    PAFD_LOCK_QUEUE_HANDLE LockHandle
    )
/*++

Routine Description:

    This routine verifies and completes the wait for listen
    or super accept IRP in wait for listen queue.
Arguments:

    Irp - wait for listen or super accept IRP
    Connection - connection to be accepted
    LockHandle - IRQL at which endpoint spinlock was taken
    
Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    NTSTATUS    status;
    PAFD_ENDPOINT   listenEndpoint;
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    listenEndpoint = irpSp->FileObject->FsContext;

    ASSERT( Connection->State == AfdConnectionStateUnaccepted );

    if (irpSp->MajorFunction==IRP_MJ_INTERNAL_DEVICE_CONTROL) {
        //
        // This is super accept IRP
        //
        PFILE_OBJECT  acceptFileObject;
        PAFD_ENDPOINT acceptEndpoint;

        //
        // Verify the lengh of the remote address buffer
        // and map it.
        //
        if (Connection->RemoteAddressLength>
                irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength) {
        
            status = STATUS_BUFFER_TOO_SMALL;

        }
        //
        // Check if we have enough system PTE's to map
        // the buffer.
        //
        else if ((status = AfdMapMdlChain (Irp->MdlAddress)),
                    !NT_SUCCESS (status)) {
            NOTHING;
        }
        else if (Connection->SanConnection) {
            acceptFileObject = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdAcceptFileObject;
            acceptEndpoint = acceptFileObject->FsContext;

            status = AfdSanAcceptCore (Irp, acceptFileObject, Connection, LockHandle);
            if (status==STATUS_PENDING) {
                //
                // Accept IRP is pending waiting for Switch
                // completion notification
                //
                return STATUS_SUCCESS;
            }

            //
            // Continue to cleanup code
            //
            ASSERT (NT_ERROR (status));

        }
        //
        // Allocate MDL for local address query if requested
        //
        else if ((irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength>0) &&
            (IoAllocateMdl ((PUCHAR)Irp->UserBuffer+irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength,
                            irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                            TRUE,
                            FALSE,
                            Irp)==NULL)){
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else {

            acceptFileObject = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdAcceptFileObject;
            acceptEndpoint = acceptFileObject->FsContext;

            //
            // Copy over the address information to the user's buffer.
            //
#ifndef i386
            if (acceptEndpoint->Common.VcConnecting.FixAddressAlignment) {
                USHORT addressLength = 
                        Connection->RemoteAddress->Address[0].AddressLength
                        + sizeof (USHORT);
                USHORT UNALIGNED *pAddrLength = (PVOID)
                            ((PUCHAR)MmGetSystemAddressForMdl (Irp->MdlAddress)
                             + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                             + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                             + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength
                             - sizeof (USHORT));
                RtlMoveMemory (
                            (PUCHAR)MmGetSystemAddressForMdl (Irp->MdlAddress)
                             + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                             + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                             &Connection->RemoteAddress->Address[0].AddressType,
                             addressLength);
                *pAddrLength = addressLength;
            }
            else
#endif
            {
                RtlMoveMemory (
                            (PUCHAR)MmGetSystemAddressForMdl (Irp->MdlAddress)
                             + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                             + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                             Connection->RemoteAddress,
                             Connection->RemoteAddressLength);
            }

            //
            // Perform core accept operations
            //
            status = AfdAcceptCore (Irp, acceptEndpoint, Connection);
            if (NT_SUCCESS (status)) {
                AfdReleaseSpinLock (&listenEndpoint->SpinLock, LockHandle);
                //
                // Synchronize with cancel routine.
                //
                if (IoSetCancelRoutine (Irp, NULL)==NULL) {
                    KIRQL cancelIrql;
                    //
                    // Cancel routine is running. Let it complete
                    // before doing anything else to the IRP.
                    // Note that we may end up passing cancelled IRP
                    // to the transport which should cancel it right away
                    // and destroy the connection.
                    // (we could potentially do the same in-line without
                    // calling the transport, but why - transport has
                    // to handle this anyway if it needs to pend
                    // the IRP)
                    //
                    IoAcquireCancelSpinLock (&cancelIrql);
                    IoReleaseCancelSpinLock (cancelIrql);
                }

                if (status!=STATUS_PENDING) {
                    //
                    // Make irp look like it is completed by the
                    // transport.
                    //
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress = Irp->MdlAddress;
                    Irp->MdlAddress = NULL;
                    irpSp->FileObject = acceptFileObject;

                    //
                    // Restart super accept
                    //
                    AfdRestartSuperAcceptListen (Irp, Connection);

                    status = STATUS_SUCCESS;
                }
                else {
                    //
                    // Status pending is only returned for endpoint
                    // with delayed acceptance enabled.
                    // As this is a super accept IRP, we automatically
                    // accept this connection.
                    //
                    ASSERT (IS_DELAYED_ACCEPTANCE_ENDPOINT (listenEndpoint));
                    //
                    // Remember that a TDI accept has started on this endpoint.
                    //
                    InterlockedIncrement(
                        &listenEndpoint->Common.VcListening.TdiAcceptPendingCount
                        );
                    irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress = Irp->MdlAddress;
                    Irp->MdlAddress = NULL;
                    IoSetCompletionRoutine(
                            Irp,
                            AfdRestartDelayedSuperAccept,
                            acceptFileObject,
                            TRUE,
                            TRUE,
                            TRUE
                            );

                    AfdIoCallDriver (
                            acceptEndpoint,
                            Connection->DeviceObject,
                            Irp
                            );

                    status = STATUS_PENDING;
                }

                return status;
            }
        }
        //
        // Some kind of failure, cleanup super accept IRP
        //

        AfdCleanupSuperAccept (Irp, status);

    }
    else {
        //
        // Regular wait for listen IRP
        //
        PAFD_LISTEN_RESPONSE_INFO listenResponse;

        listenResponse = Irp->AssociatedIrp.SystemBuffer;


        if( (ULONG)FIELD_OFFSET (AFD_LISTEN_RESPONSE_INFO, RemoteAddress)+
                        Connection->RemoteAddressLength >
                irpSp->Parameters.DeviceIoControl.OutputBufferLength ) {

            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Status = status;
        }
        else {
            do {
                Connection->Sequence = ++listenEndpoint->Common.VcListening.Sequence;
            }
            while (Connection->Sequence==0);

            //
            // There was a connection to use.  Set up the return buffer.
            //

            listenResponse->Sequence = Connection->Sequence;

            RtlMoveMemory(
                &listenResponse->RemoteAddress,
                Connection->RemoteAddress,
                Connection->RemoteAddressLength
                );

            Irp->IoStatus.Information =
                sizeof(*listenResponse) - sizeof(TRANSPORT_ADDRESS) +
                    Connection->RemoteAddressLength;

            //
            // Place the connection we're going to use on the endpoint's list of
            // returned connections.
            //

            InsertTailList(
                &listenEndpoint->Common.VcListening.ReturnedConnectionListHead,
                &Connection->ListEntry
                );

            //
            // Indicate in the state of this connection that it has been
            // returned to the user.
            //

            Connection->State = AfdConnectionStateReturned;
            status = STATUS_SUCCESS;
            AfdReleaseSpinLock (&listenEndpoint->SpinLock, LockHandle);
            //
            // Synchronize with cancel routine.
            //
            if ((IoSetCancelRoutine (Irp, NULL)==NULL) && Irp->Cancel) {
                KIRQL cancelIrql;
                IoAcquireCancelSpinLock (&cancelIrql);
                IoReleaseCancelSpinLock (cancelIrql);
            }
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest (Irp, AfdPriorityBoost);
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\pnp.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module contains the PnP and PM routines

Author:

    Vadim Eydelman (vadime)    Apr-1997

Revision History:

--*/

#include "afdp.h"

NTSTATUS
AfdPassQueryDeviceRelation (
    IN PFILE_OBJECT         FileObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpSp
    );

NTSTATUS
AfdRestartQueryDeviceRelation (
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp, 
    IN PVOID Context 
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdPnpPower )
#pragma alloc_text( PAGE, AfdPassQueryDeviceRelation )
#pragma alloc_text( PAGEAFD, AfdRestartQueryDeviceRelation )
#endif

NTSTATUS
FASTCALL
AfdPnpPower (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the dispatch routine for PNP_POWER irp

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAGED_CODE( );


    switch (IrpSp->MinorFunction) {

        //
        // We only support target device relation query
        //

    case IRP_MN_QUERY_DEVICE_RELATIONS:
        if (IrpSp->Parameters.QueryDeviceRelations.Type==TargetDeviceRelation) {

            NTSTATUS status;
            PAFD_ENDPOINT   endpoint;
            PAFD_CONNECTION connection;
            //
            // Set up local variables.
            //

            endpoint = IrpSp->FileObject->FsContext;
            ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
                //
                // Dispatch to correct TDI object of underlying transport
                // driver depedning on endpoint type
                //

            switch (endpoint->Type) {
            case AfdBlockTypeVcConnecting:
            case AfdBlockTypeVcBoth:
                connection = AfdGetConnectionReferenceFromEndpoint (endpoint);
                if  (connection!=NULL) {
                    status = AfdPassQueryDeviceRelation (connection->FileObject,
                                                Irp, IrpSp);
                    DEREFERENCE_CONNECTION (connection);
                    return status;
                }
                // fall through to try address handle if we have one.
            case AfdBlockTypeVcListening:
            case AfdBlockTypeDatagram:
                if (endpoint->State==AfdEndpointStateBound ||
                        endpoint->State==AfdEndpointStateConnected) {
                    return AfdPassQueryDeviceRelation (endpoint->AddressFileObject, 
                                                    Irp, IrpSp);
                }
                // fall through to fail
            case AfdBlockTypeHelper:
            case AfdBlockTypeEndpoint:
            case AfdBlockTypeSanHelper:
            case AfdBlockTypeSanEndpoint:
                break;
            default:
                ASSERT (!"Unknown endpoint type!");
                break;
            }
        }
    default:
        break;
    }
    
    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    //
    // We do not support the rest
    //

    return STATUS_INVALID_DEVICE_REQUEST;
}

NTSTATUS
AfdPassQueryDeviceRelation (
    IN PFILE_OBJECT         FileObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpSp
    )

/*++

Routine Description:

    This is the dispatch routine for PNP_POWER irp

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PIO_STACK_LOCATION  nextIrpSp;

    PAGED_CODE ();

    nextIrpSp = IoGetNextIrpStackLocation( Irp );

    *nextIrpSp = *IrpSp;

    //
    // Reference file object so it does not go away until this 
    // IRP completes
    //

    ObReferenceObject (FileObject);
    nextIrpSp->FileObject = FileObject;
    

    IoSetCompletionRoutine(
        Irp,
        AfdRestartQueryDeviceRelation,
        FileObject,
        TRUE,
        TRUE,
        TRUE
        );

#ifdef _AFD_VARIABLE_STACK_
    return AfdCallDriverStackIncrease ( IoGetRelatedDeviceObject( FileObject ), Irp );
#else // _AFD_VARIABLE_STACK_
    return IoCallDriver ( IoGetRelatedDeviceObject( FileObject ), Irp );
#endif

}

NTSTATUS
AfdRestartQueryDeviceRelation (
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp, 
    IN PVOID Context 
    ) 
{
    PFILE_OBJECT    fileObject = Context;

    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (Irp);
    //
    // Dereference file object that we referenced when calling the
    // lower driver
    //

    ObDereferenceObject (fileObject);

    //
    // Tell IO system to continue with IRP completion
    //
    return STATUS_SUCCESS;
}


#include <tdiinfo.h>
#include <ntddip.h>
#include <ntddip6.h>
#include <ntddtcp.h>
#include <ipinfo.h>

typedef struct _AFD_PROTOCOL {
    USHORT       AddressType;
    USHORT       AddressLength;
    LPWSTR       NetworkLayerDeviceName;
    LPWSTR       TransportLayerDeviceName;
    ULONG        RtChangeIoctl;
    ULONG        RtChangeDataSize;
    LONG         RoutingQueryRefCount;
    HANDLE       DeviceHandle;
    PFILE_OBJECT FileObject;
} AFD_PROTOCOL, *PAFD_PROTOCOL;

PAFD_PROTOCOL
AfdGetProtocolInfo(
    IN  USHORT AddressType
    );

NTSTATUS
AfdOpenDevice (
    LPWSTR      DeviceNameStr,
    HANDLE      *Handle,
    PFILE_OBJECT *FileObject
    );


NTSTATUS
AfdGetRoutingQueryReference (
    IN PAFD_PROTOCOL    Protocol
    );

VOID
AfdDereferenceRoutingQuery (
    PAFD_PROTOCOL Protocol
    );

NTSTATUS
AfdTcpQueueRoutingChangeRequest (
    IN PAFD_ENDPOINT        Endpoint,
    IN PIRP                 Irp,
    IN BOOLEAN              Overlapped
    );

NTSTATUS
AfdTcpRestartRoutingChange (
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp, 
    IN PVOID Context 
    );

NTSTATUS
AfdTcpSignalRoutingChange (
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp, 
    IN PVOID Context 
    );

NTSTATUS
AfdTcpRoutingQuery (
    PTA_ADDRESS Dest,
    PTA_ADDRESS Intf
    );

NTSTATUS
AfdTcp6RoutingQuery (
    PTA_ADDRESS Dest,
    PTA_ADDRESS Intf
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE,    AfdOpenDevice )
#pragma alloc_text( PAGE,    AfdRoutingInterfaceQuery )
#pragma alloc_text( PAGE,    AfdTcpRoutingQuery )
#pragma alloc_text( PAGE,    AfdTcp6RoutingQuery )
#pragma alloc_text( PAGE,    AfdGetRoutingQueryReference )
#pragma alloc_text( PAGE,    AfdDereferenceRoutingQuery )
#pragma alloc_text( PAGE,    AfdGetProtocolInfo )
#pragma alloc_text( PAGEAFD, AfdTcpQueueRoutingChangeRequest )
#pragma alloc_text( PAGEAFD, AfdTcpRestartRoutingChange )
#pragma alloc_text( PAGEAFD, AfdTcpSignalRoutingChange )
#pragma alloc_text( PAGEAFD, AfdCleanupRoutingChange )
#endif

AFD_PROTOCOL Ip = { TDI_ADDRESS_TYPE_IP,  TDI_ADDRESS_LENGTH_IP,  
                    DD_IP_DEVICE_NAME, DD_TCP_DEVICE_NAME, 
                    IOCTL_IP_RTCHANGE_NOTIFY_REQUEST, 
                    sizeof(IPNotifyData), 0, NULL, NULL };
AFD_PROTOCOL Ip6= { TDI_ADDRESS_TYPE_IP6, TDI_ADDRESS_LENGTH_IP6, 
                    DD_IPV6_DEVICE_NAME, DD_TCPV6_DEVICE_NAME, 
                    IOCTL_IPV6_RTCHANGE_NOTIFY_REQUEST, 
                    sizeof(IPV6_RTCHANGE_NOTIFY_REQUEST), 0, NULL, NULL };

const char ZeroString[16] = { 0 };

PAFD_PROTOCOL
AfdGetProtocolInfo(
    IN  USHORT AddressType
    )
{
    switch (AddressType) {
    case TDI_ADDRESS_TYPE_IP:  return &Ip;
    case TDI_ADDRESS_TYPE_IP6: return &Ip6;
    default:                   return NULL;
    }
}


NTSTATUS
AfdRoutingInterfaceQuery (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
/*++

Routine Description:

    Processes routing query request.  Protocol independent portion.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
    CHAR                   addrBuffer[AFD_MAX_FAST_TRANSPORT_ADDRESS];
    PTRANSPORT_ADDRESS     tempAddr;
    NTSTATUS               status;

    UNREFERENCED_PARAMETER (IoctlCode);
#if !DBG
    UNREFERENCED_PARAMETER (FileObject);
#endif
    PAGED_CODE ();

    //
    // Initialize locals for proper cleanup.
    //

    *Information = 0;
    tempAddr = (PTRANSPORT_ADDRESS)addrBuffer;

    //
    // Validate input parameters
    //

    if( InputBufferLength < sizeof(*tempAddr) ) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdRoutingInterfaceQuery: Endp: %p - invalid input buffer (%p-%d).\n",
                    FileObject->FsContext, InputBuffer, InputBufferLength));
        status = STATUS_INVALID_PARAMETER;
        goto Complete;
    }


    try {
        //
        // Copy input address into the local (or allocated from pool) buffer
        //
        if (InputBufferLength>sizeof (addrBuffer)) {
            tempAddr = AFD_ALLOCATE_POOL_WITH_QUOTA (PagedPool,
                                InputBufferLength,
                                AFD_ROUTING_QUERY_POOL_TAG);
            
            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE
        }

        //
        // Validate user mode pointers
        //
        if (RequestorMode!=KernelMode) {
            ProbeForRead (InputBuffer,
                            InputBufferLength,
                            sizeof (CHAR));
        }
        RtlCopyMemory (tempAddr,
                        InputBuffer,
                        InputBufferLength);

        //
        // Validate the internal consistency of the transport address AFTER
        // copying it into the internal buffer to prevent malicious app from
        // changing it on the fly while we are checking.
        //
        if (tempAddr->TAAddressCount!=1 ||
                InputBufferLength <
                    (ULONG)FIELD_OFFSET (TRANSPORT_ADDRESS,
                        Address[0].Address[tempAddr->Address[0].AddressLength])) {
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode ();
        goto Complete;
    }

    //
    // PROBLEM.  We only support IP for now
    //

    switch (tempAddr->Address[0].AddressType) {
    case TDI_ADDRESS_TYPE_IP:
        status = AfdTcpRoutingQuery (&tempAddr->Address[0], &tempAddr->Address[0]);
        break;
    case TDI_ADDRESS_TYPE_IP6:
        status = AfdTcp6RoutingQuery (&tempAddr->Address[0], &tempAddr->Address[0]);
        break;
    default:
        status = STATUS_NOT_SUPPORTED;
        goto Complete;
    }


    //
    // Convert output to socket address if we succeeded.
    //
    if (NT_SUCCESS (status)) {
        //
        // Conversion to sockaddr requires extra bytes for address family
        // in addition to TDI_ADDRESS
        //
        if ((tempAddr->Address[0].AddressLength+sizeof(u_short)
                                             <= OutputBufferLength)) {
            try {
                //
                // Validate user mode pointers
                //
                if (RequestorMode!=KernelMode) {
                    ProbeForWrite (OutputBuffer,
                                    OutputBufferLength,
                                    sizeof (CHAR));
                }
                //
                // Copy the data from the type on which corresponds
                // to the socket address.
                //
                RtlCopyMemory (
                    OutputBuffer,
                    &tempAddr->Address[0].AddressType,
                    tempAddr->Address[0].AddressLength+sizeof(u_short));
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode ();
                goto Complete;
            }
        }
        else {
            //
            // Output buffer is not big enough, return warning
            // and the required buffer size.
            //
            status = STATUS_BUFFER_OVERFLOW;
        }
        *Information = tempAddr->Address[0].AddressLength+sizeof(u_short);
    }


Complete:

    //
    // Free address buffer if we allocated one.
    //
    if (tempAddr!=(PTRANSPORT_ADDRESS)addrBuffer) {
        AFD_FREE_POOL (tempAddr, AFD_ROUTING_QUERY_POOL_TAG);
    }

    return status;
} //AfdRoutingInterfaceQuery

NTSTATUS
FASTCALL
AfdRoutingInterfaceChange (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    Processes routing change IRP

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
    PTRANSPORT_ADDRESS     destAddr;
    NTSTATUS        status;
    PAFD_ENDPOINT   endpoint;
    BOOLEAN         overlapped;
    AFD_TRANSPORT_IOCTL_INFO    ioctlInfo;

    PAGED_CODE ();

    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRoutingInterfaceChange: Endp: %p, buf: %p, inlen: %ld, outlen: %ld.\n",
                    IrpSp->FileObject->FsContext,
                    Irp->AssociatedIrp.SystemBuffer,
                    IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength));
    }
    

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        PAFD_TRANSPORT_IOCTL_INFO32 ioctlInfo32;
        ioctlInfo32 = Irp->AssociatedIrp.SystemBuffer;
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (*ioctlInfo32)) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
        ioctlInfo.Handle = ioctlInfo32->Handle;
        ioctlInfo.InputBuffer = UlongToPtr(ioctlInfo32->InputBuffer);
        ioctlInfo.InputBufferLength = ioctlInfo32->InputBufferLength;
        ioctlInfo.IoControlCode = ioctlInfo32->IoControlCode;
        ioctlInfo.AfdFlags = ioctlInfo32->AfdFlags;
        ioctlInfo.PollEvent = ioctlInfo32->PollEvent;
    }
    else
#endif // _WIN64
    {
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (ioctlInfo)) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
        ioctlInfo = *((PAFD_TRANSPORT_IOCTL_INFO)Irp->AssociatedIrp.SystemBuffer);
    }
    
    //
    // Setup locals
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    
    //
    // Check if request is overlapped
    //

    overlapped = (BOOLEAN)((ioctlInfo.AfdFlags & AFD_OVERLAPPED)!=0);

    //
    // Validate input parameters
    //
    AFD_W4_INIT status = STATUS_SUCCESS;
    try {
        ULONG   sysBufferLength;
        sysBufferLength = max (
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                            IrpSp->Parameters.DeviceIoControl.OutputBufferLength);

        if (Irp->RequestorMode != KernelMode) {
            ProbeForRead(
                ioctlInfo.InputBuffer,
                ioctlInfo.InputBufferLength,
                sizeof(UCHAR)
                );
        }

        if (ioctlInfo.InputBufferLength>sysBufferLength){
            PVOID   newSystemBuffer;
            //
            // Don't use AFD allocation routine on this as we are substituting
            // system buffer
            //
            newSystemBuffer = ExAllocatePoolWithQuotaTag (
                                    NonPagedPool|POOL_RAISE_IF_ALLOCATION_FAILURE,
                                    ioctlInfo.InputBufferLength,
                                    AFD_SYSTEM_BUFFER_POOL_TAG
                                    );
            if (newSystemBuffer==NULL) {
                ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
            }
            ExFreePool (Irp->AssociatedIrp.SystemBuffer);
            Irp->AssociatedIrp.SystemBuffer = newSystemBuffer;
        }

        //
        // Copy application data to the system buffer
        //

        RtlCopyMemory (Irp->AssociatedIrp.SystemBuffer,
                        ioctlInfo.InputBuffer,
                        ioctlInfo.InputBufferLength);

    }
    except( AFD_EXCEPTION_FILTER (status) ) {
        ASSERT (NT_ERROR (status));
        goto complete;
    }

    destAddr = Irp->AssociatedIrp.SystemBuffer;

    if(ioctlInfo.InputBufferLength <
                sizeof(*destAddr) ||
            ioctlInfo.InputBufferLength <
                (ULONG)FIELD_OFFSET (TRANSPORT_ADDRESS,
                            Address[0].Address[destAddr->Address[0].AddressLength])
            ) {

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdRoutingInterfaceChange: Endp: %p - invalid parameter.\n",
                    IrpSp->FileObject->FsContext));
        status = STATUS_INVALID_PARAMETER;
        goto complete;

    }

    //
    // PROBLEM We only support IP for now
    //

    if (destAddr->Address[0].AddressType!=TDI_ADDRESS_TYPE_IP &&
        destAddr->Address[0].AddressType!=TDI_ADDRESS_TYPE_IP6) {
        status = STATUS_NOT_SUPPORTED;
        goto complete;
    }


    //
    // Reset the poll bit
    //

    endpoint->EventsActive &= ~AFD_POLL_ROUTING_IF_CHANGE;

    return AfdTcpQueueRoutingChangeRequest (endpoint, Irp, overlapped);

complete:
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, AfdPriorityBoost);

    return status;

} // AfdRoutingInterfaceChange


NTSTATUS
AfdOpenDevice (
    LPWSTR      DeviceNameStr,
    HANDLE      *Handle,
    PFILE_OBJECT *FileObject
    )
/*++

Routine Description:

    Opens specified device driver (control channel) and returns handle and
    file object

Arguments:

    DeviceNameStr - device to open.

    Handle - returned handle.

    FileObject - returned file object.
Return Value:

    NTSTATUS -- Indicates whether the device was opened OK

--*/
{
    NTSTATUS            status;
    UNICODE_STRING      DeviceName;
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     iosb;

    PAGED_CODE( );


    RtlInitUnicodeString(&DeviceName, DeviceNameStr);

    //
    // We ask to create a kernel handle which is 
    // the handle in the context of the system process
    // so that application cannot close it on us while
    // we are creating and referencing it.
    //

    InitializeObjectAttributes(
        &objectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,       // attributes
        NULL,
        NULL
        );


    status = IoCreateFile(
                 Handle,
                 MAXIMUM_ALLOWED,
                 &objectAttributes,
                 &iosb,                          // returned status information.
                 0,                              // block size (unused).
                 0,                              // file attributes.
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_CREATE,                    // create disposition.
                 0,                              // create options.
                 NULL,                           // eaInfo
                 0,                              // eaLength
                 CreateFileTypeNone,             // CreateFileType
                 NULL,                           // ExtraCreateParameters
                 IO_NO_PARAMETER_CHECKING        // Options
                    | IO_FORCE_ACCESS_CHECK
                 );

    if (NT_SUCCESS (status)) {
        status = ObReferenceObjectByHandle (
                     *Handle,
                     0L,
                     *IoFileObjectType,
                     KernelMode,
                     (PVOID *)FileObject,
                     NULL
                     );
        if (!NT_SUCCESS (status)) {
            ZwClose (*Handle);
            *Handle = NULL;
        }
    }


    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdOpenDevice: Opened %ls, handle: %p, file: %p, status: %lx.\n",
                    DeviceNameStr, *Handle, *FileObject, status));
    }
    return status;

} // AfdOpenDevice


VOID
AfdDereferenceRoutingQuery (
    PAFD_PROTOCOL Protocol
    )
{

    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(AfdResource, TRUE);

    ASSERT(Protocol->RoutingQueryRefCount > 0);
    ASSERT(Protocol->DeviceHandle != NULL);

    if (InterlockedDecrement(&Protocol->RoutingQueryRefCount) == 0) {

        HANDLE DeviceHandle = Protocol->DeviceHandle;
        PFILE_OBJECT FileObject = Protocol->FileObject;

        Protocol->DeviceHandle = NULL;
        Protocol->FileObject = NULL;

        ExReleaseResourceLite(AfdResource);
        KeLeaveCriticalRegion();

        ObDereferenceObject(FileObject);

        //
        // Do this in the context of system process so that it does not
        // get closed when applications exit
        //

        ZwClose(DeviceHandle);

    } else {

        ExReleaseResourceLite(AfdResource);
        KeLeaveCriticalRegion();

    }

} // AfdDereferenceRoutingQuery


NTSTATUS
AfdTcp6RoutingQuery (
    PTA_ADDRESS Dest,
    PTA_ADDRESS Intf
    )
/*++

Routine Description:

    Submits routing query request to TCP6

Arguments:

    Dest      - destination to query

    Intf      - interface through which destination can be reached.

Return Value:

    NTSTATUS -- Indicates whether operation succeded

--*/
{
    NTSTATUS            status;
    TDIObjectID         *lpObject;
    CHAR                byBuffer[FIELD_OFFSET(TCP_REQUEST_QUERY_INFORMATION_EX,
                                  Context) + sizeof(TDI_ADDRESS_IP6)];
    TCP_REQUEST_QUERY_INFORMATION_EX *ptrqiBuffer = (TCP_REQUEST_QUERY_INFORMATION_EX *) byBuffer;
    IP6RouteEntry       routeEntry;
    IO_STATUS_BLOCK     iosb;
    KEVENT              event;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;
    HANDLE              tcpDeviceHandle;
    PFILE_OBJECT        tcpFileObject;
    PDEVICE_OBJECT      tcpDeviceObject;

    PAGED_CODE ();

    if (Dest->AddressLength<TDI_ADDRESS_LENGTH_IP6) {
        KdPrintEx ((DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdTcp6RoutingQuery: Destination address buffer too small.\n"));
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Open TCP6 driver.
    //

    status = AfdOpenDevice (DD_TCPV6_DEVICE_NAME, &tcpDeviceHandle, &tcpFileObject);
    if (!NT_SUCCESS (status)) {
        return status;
    }
    tcpDeviceObject = IoGetRelatedDeviceObject ( tcpFileObject );


    //
    // Setup the query
    //

    RtlCopyMemory( (PVOID)ptrqiBuffer->Context, Dest->Address, 
                   TDI_ADDRESS_LENGTH_IP6);

    lpObject = &ptrqiBuffer->ID;
    lpObject->toi_id =  IP6_GET_BEST_ROUTE_ID;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_entity.tei_entity = CL_NL_ENTITY;
    lpObject->toi_entity.tei_instance = 0;


    KeInitializeEvent (&event, NotificationEvent, FALSE);

    //
    // Build and setup the IRP and call the driver
    //

    irp = IoBuildDeviceIoControlRequest (
                       IOCTL_TCP_QUERY_INFORMATION_EX, //Control
                       tcpDeviceObject,         // Device
                       ptrqiBuffer,             // Input buffer
                       sizeof(byBuffer),        // Input buffer size
                       &routeEntry,             // Output buffer
                       sizeof(routeEntry),      // Output buffer size
                       FALSE,                   // Internal ?
                       &event,                  // Event
                       &iosb                    // Status block
                       );
    if (irp==NULL) {
        IF_DEBUG(ROUTING_QUERY) {
            KdPrintEx ((DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdTcp6RoutingQuery: Could not allocate IRP.\n"));
        }
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto complete;
    }

    irpSp = IoGetNextIrpStackLocation (irp);
    irpSp->FileObject = tcpFileObject;

    status = IoCallDriver (tcpDeviceObject, irp);

    if (status==STATUS_PENDING) {
        status = KeWaitForSingleObject(
                   &event,
                   Executive,
                   KernelMode,
                   FALSE,       // Alertable
                   NULL);       // Timeout
    }

    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx ((DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdTcp6RoutingQuery: IP6_GET_BEST_ROUTE_ID - status: %lx.\n",
                    status));
    }

    if (!NT_SUCCESS (status)) {
        goto complete;
    }

    if (!NT_SUCCESS (iosb.Status)) {
        status = iosb.Status;
        goto complete;
    }

    // Fill in IPv6 address
    Intf->AddressType = TDI_ADDRESS_TYPE_IP6;
    Intf->AddressLength = TDI_ADDRESS_LENGTH_IP6;
    RtlCopyMemory( ((PTDI_ADDRESS_IP6)Intf->Address)->sin6_addr,
                   &routeEntry.ire_Source,
                   sizeof(routeEntry.ire_Source) );
    ((PTDI_ADDRESS_IP6)Intf->Address)->sin6_flowinfo = 0;
    ((PTDI_ADDRESS_IP6)Intf->Address)->sin6_port = 0;
    ((PTDI_ADDRESS_IP6)Intf->Address)->sin6_scope_id = routeEntry.ire_ScopeId;
    status = STATUS_SUCCESS;

complete:
    ObDereferenceObject (tcpFileObject);
    ZwClose (tcpDeviceHandle);

    return status;
}

NTSTATUS
AfdTcpRoutingQuery (
    PTA_ADDRESS Dest,
    PTA_ADDRESS Intf
    )
/*++

Routine Description:

    Submits routing query request to TCP

Arguments:

    Dest      - destination to query
    
    Intf      - interface through which destination can be reached.

Return Value:

    NTSTATUS -- Indicates whether operation succeded

--*/
{
    NTSTATUS            status;
    TDIObjectID         *lpObject;
    TCP_REQUEST_QUERY_INFORMATION_EX trqiBuffer;
    ULONG               *pIpAddr;
    ULONG               ipSource;
    IO_STATUS_BLOCK     iosb;
    KEVENT              event;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;
    HANDLE              tcpDeviceHandle;
    PFILE_OBJECT        tcpFileObject;
    PDEVICE_OBJECT      tcpDeviceObject;

    PAGED_CODE ();

    if (Dest->AddressLength<TDI_ADDRESS_LENGTH_IP) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdTcpRoutingQuery: Destination address buffer too small.\n"));
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Open TCP driver.
    //

    status = AfdOpenDevice (DD_TCP_DEVICE_NAME, &tcpDeviceHandle, &tcpFileObject);
    if (!NT_SUCCESS (status)) {
        return status;
    }
    tcpDeviceObject = IoGetRelatedDeviceObject ( tcpFileObject );


    //
    // Setup the query
    //

    RtlZeroMemory (&trqiBuffer, sizeof (trqiBuffer));

    pIpAddr = (ULONG *)trqiBuffer.Context;
    *pIpAddr = ((PTDI_ADDRESS_IP)Dest->Address)->in_addr;

    lpObject = &trqiBuffer.ID;
    lpObject->toi_id = IP_GET_BEST_SOURCE;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_entity.tei_entity = CL_NL_ENTITY;
    lpObject->toi_entity.tei_instance = 0;


    KeInitializeEvent (&event, NotificationEvent, FALSE);

    //
    // Build and setup the IRP and call the driver
    //

    irp = IoBuildDeviceIoControlRequest (
                       IOCTL_TCP_QUERY_INFORMATION_EX, //Control
                       tcpDeviceObject,         // Device
                       &trqiBuffer,             // Input buffer
                       sizeof(trqiBuffer),      // Input buffer size
                       &ipSource,               // Output buffer
                       sizeof(ipSource),        // Output buffer size
                       FALSE,                   // Internal ?
                       &event,                  // Event
                       &iosb                    // Status block
                       );
    if (irp==NULL) {
        IF_DEBUG (ROUTING_QUERY) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdTcpRoutingQuery: Could not allocate IRP.\n"));
        }
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto complete;
    }

    irpSp = IoGetNextIrpStackLocation (irp);
    irpSp->FileObject = tcpFileObject;

    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTcpRoutingQuery: Quering for route to %lx.\n",
                    ((PTDI_ADDRESS_IP)Dest->Address)->in_addr));
    }
    
    status = IoCallDriver (tcpDeviceObject, irp);

    if (status==STATUS_PENDING) {
        status = KeWaitForSingleObject(
                   &event,
                   Executive,
                   KernelMode,
                   FALSE,       // Alertable
                   NULL);       // Timeout
    }

    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTcpRoutingQuery: IP_GET_BEST_SOURCE - status: %lx.\n",
                    status));
    }

    if (!NT_SUCCESS (status)) {
        goto complete;
    }

    if (!NT_SUCCESS (iosb.Status)) {
        status = iosb.Status;
        goto complete;
    }

    Intf->AddressType = TDI_ADDRESS_TYPE_IP;
    Intf->AddressLength = TDI_ADDRESS_LENGTH_IP;
    ((PTDI_ADDRESS_IP)Intf->Address)->in_addr = ipSource;
    ((PTDI_ADDRESS_IP)Intf->Address)->sin_port = 0;
    RtlFillMemory (((PTDI_ADDRESS_IP)Intf->Address)->sin_zero,
                sizeof (((PTDI_ADDRESS_IP)Intf->Address)->sin_zero), 0);
    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTcpRoutingQuery: Found interface %lx.\n",
                    ((PTDI_ADDRESS_IP)Intf->Address)->in_addr));
    }
    status = STATUS_SUCCESS;


complete:
    ObDereferenceObject (tcpFileObject);
    ZwClose (tcpDeviceHandle);

    return status;
} // AfdTcpRoutingQuery


NTSTATUS
AfdGetRoutingQueryReference (
    PAFD_PROTOCOL Protocol
    )
/*++

Routine Description:

    Initializes routing query if necessary and references it

Arguments:

    None

Return Value:

    NTSTATUS -- Indicates whether operation succeded

--*/
{

//    KAPC_STATE          apcState;
    HANDLE              DeviceHandle;
    PFILE_OBJECT        FileObject;
    NTSTATUS            status;


    status = AfdOpenDevice (Protocol->NetworkLayerDeviceName, &DeviceHandle, &FileObject);
    if (NT_SUCCESS (status)) {

        //
        // Make sure the thread in which we execute cannot get
        // suspeneded in APC while we own the global resource.
        //
        KeEnterCriticalRegion ();
        ExAcquireResourceExclusiveLite ( AfdResource, TRUE);
        if (Protocol->DeviceHandle==NULL) {
            Protocol->DeviceHandle = DeviceHandle;
            Protocol->FileObject = FileObject;
            ASSERT (Protocol->RoutingQueryRefCount==0);
            Protocol->RoutingQueryRefCount = 1;
            ExReleaseResourceLite( AfdResource );
            KeLeaveCriticalRegion ();
        }
        else {
            ASSERT (Protocol->RoutingQueryRefCount>0);
            InterlockedIncrement (&Protocol->RoutingQueryRefCount);

            ExReleaseResourceLite( AfdResource );
            KeLeaveCriticalRegion ();

            ObDereferenceObject (FileObject);
            status = ZwClose (DeviceHandle);
            ASSERT (status==STATUS_SUCCESS);
        }
    }
    else {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdGetRoutingQueryReference: Network layer device open failed, status: %lx.\n",
                    status));
    }

    return status;
} // AfdGetRoutingQueryReference


NTSTATUS
AfdTcpQueueRoutingChangeRequest (
    IN PAFD_ENDPOINT        Endpoint,
    IN PIRP                 Irp,
    BOOLEAN                 Overlapped
    )
/*++

Routine Description:

    Submits routing change request to TCP

Arguments:
    
    Endpoint    - endpoint on which request is issued

    Irp         - the request

    Overlapped  - whether request is overlapped (and thus should be
                    pended event on non-blocking socket)


Return Value:

    NTSTATUS -- Indicates whether operation succeded

--*/
{
    PTRANSPORT_ADDRESS    destAddr;
    NTSTATUS        status;
    PFILE_OBJECT    fileObject;
    PDEVICE_OBJECT  deviceObject;
    PIO_STACK_LOCATION irpSp;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    struct Notify {
        ROUTING_NOTIFY Ctx;
        char           Data[1];
    } * notify;
    PIRP            irp;
    PIO_COMPLETION_ROUTINE compRoutine;
    PAFD_PROTOCOL   Protocol;

    //
    // Set locals for easy cleanup.
    //
    notify = NULL;
    irp = NULL;

    destAddr = Irp->AssociatedIrp.SystemBuffer;

    Protocol = AfdGetProtocolInfo(destAddr->Address[0].AddressType);
    if (Protocol == NULL) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    if (destAddr->Address[0].AddressLength < Protocol->AddressLength) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdTcpQueueRoutingChangeRequest: Destination buffer too small.\n"));
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    //
    // Allocate context structures to keep IRP in the endpoint list in
    // case the latter gets closed and we need to cancel the IRP.
    // Also allocate buffer for passing data to IP
    //

    try {
        notify = AFD_ALLOCATE_POOL_WITH_QUOTA (NonPagedPool,
                FIELD_OFFSET(struct Notify, Data[Protocol->RtChangeDataSize]),
                AFD_ROUTING_QUERY_POOL_TAG);
        // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode ();
        notify = NULL;
        goto complete;
    }

    //
    // Open IP driver if necessary
    //

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    
    //
    // Check if endpoint was cleaned-up and cancel the request.
    //

    if (Endpoint->EndpointCleanedUp) {

        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
        status = STATUS_CANCELLED;
        goto complete;

    }

    if (Endpoint->RoutingQueryReferenced) {

        //
        // Since this endpoint already has a reference to the routing query
        // protocol structure, we do not need to add another since we hold
        // the endpoint spinlock and the only time the reference is
        // decremented is at endpoint cleanup.  Similarly, we should not
        // decrement the reference in the error path.
        //

        if (((Protocol->AddressType == TDI_ADDRESS_TYPE_IP) && Endpoint->RoutingQueryIPv6) ||
            ((Protocol->AddressType == TDI_ADDRESS_TYPE_IP6) && !Endpoint->RoutingQueryIPv6)) {

            //
            // Another thread referenced routing query for a different
            // protocol family - we can't support both of the at the
            // same time.
            //

            AfdReleaseSpinLock(&Endpoint->SpinLock, &lockHandle);
            status = STATUS_INVALID_PARAMETER;
            goto complete;

        }

        ASSERT(Protocol->DeviceHandle != NULL);
        ASSERT(Protocol->FileObject != NULL);
        ASSERT(Protocol->RoutingQueryRefCount > 0);
        
    } else {

        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);

        status = AfdGetRoutingQueryReference(Protocol);
        if (!NT_SUCCESS(status))
            goto complete;
        ASSERT(Protocol->DeviceHandle != NULL);

        AfdAcquireSpinLock(&Endpoint->SpinLock, &lockHandle);

        if (Endpoint->EndpointCleanedUp) {

            //
            // Endpoint was cleaned-up while we were
            // referencing routing query. Release the reference.
            //

            AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
            AfdDereferenceRoutingQuery(Protocol);
            status = STATUS_CANCELLED;
            goto complete;

        }

        if (Endpoint->RoutingQueryReferenced) {

            //
            // Another thread referenced routing query for this endpoint.
            //

            LONG result;

            if ((Protocol->AddressType==TDI_ADDRESS_TYPE_IP && Endpoint->RoutingQueryIPv6) ||
                (Protocol->AddressType==TDI_ADDRESS_TYPE_IP6 && !Endpoint->RoutingQueryIPv6)) {

                //
                // Another thread referenced routing query for a different
                // protocol family - we can't support both of the at the
                // same time.
                //

                AfdReleaseSpinLock(&Endpoint->SpinLock, &lockHandle);
                AfdDereferenceRoutingQuery(Protocol);
                status = STATUS_INVALID_PARAMETER;
                goto complete;

            }

            //
            // Since we know that that other's thread reference cannot
            // go away while we are holding spinlock, we can simply
            // decrement the reference count and be sure that it
            // won't go all the way to 0.
            //

            result = InterlockedDecrement(&Protocol->RoutingQueryRefCount);
            ASSERT(result > 0);

        } else {

            Endpoint->RoutingQueryReferenced = TRUE;
            if (Protocol->AddressType == TDI_ADDRESS_TYPE_IP6)
                Endpoint->RoutingQueryIPv6 = TRUE;

        } // if (Endpoint->RoutingQueryReferenced)

    } // if (Endpoint->RoutingQueryReferenced)

    fileObject = Protocol->FileObject;
    deviceObject = IoGetRelatedDeviceObject(fileObject);

    if (Endpoint->NonBlocking && !Overlapped) {

        //
        // For non-blocking socket and non-overlapped requests
        // we shall post the query using new IRP,
        // so even if thread in which rhe request
        // is originated by user exits, our request to IP does not get
        // cancelled and we will still signal the event.
        //

        irp = IoAllocateIrp (deviceObject->StackSize, TRUE);
        if (irp==NULL) {
            AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete;
        }


        //
        // Save the endpoint reference in notify context.
        //
        REFERENCE_ENDPOINT (Endpoint);
        notify->Ctx.NotifyContext = Endpoint;

        //
        // Setup completion routine so we can remove the IRP
        // from the endpoint list and free it.
        //
        compRoutine = AfdTcpSignalRoutingChange;

    }
    else {

        //
        // Blocking endpoint: just pass the original request on to the IP
        //
        irp = Irp;

        //
        // Save the original system buffer of the IRP, so we can restore
        // it when TCP completes it
        //

        notify->Ctx.NotifyContext = Irp->AssociatedIrp.SystemBuffer;

        //
        // Setup completion routine so we can restore the IRP and remove it
        // from the endpoint list
        //

        compRoutine = AfdTcpRestartRoutingChange;

    }

    //
    // Insert notification into the endpoint list
    //

    InsertTailList (&Endpoint->RoutingNotifications, &notify->Ctx.NotifyListLink);

    AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);

    //
    // Save pointer to IRP in notify structure
    //
    notify->Ctx.NotifyIrp = irp;

    //
    // Setup IP notification request
    //

    switch(Protocol->AddressType) {
    case TDI_ADDRESS_TYPE_IP:
        {
            IPNotifyData *data = (IPNotifyData *)notify->Data;
            data->Version = 0;
            data->Add = ((PTDI_ADDRESS_IP)destAddr->Address[0].Address)->in_addr;
            break;
        }
    case TDI_ADDRESS_TYPE_IP6:
        {
            IPV6_RTCHANGE_NOTIFY_REQUEST *data = (IPV6_RTCHANGE_NOTIFY_REQUEST *)notify->Data;
            data->Flags = 0;
            data->ScopeId = ((PTDI_ADDRESS_IP6)destAddr->Address[0].Address)->sin6_scope_id;
            if (RtlEqualMemory(((PTDI_ADDRESS_IP6)destAddr->Address[0].Address)->sin6_addr, ZeroString, 16)) {
                data->PrefixLength = 0;
            } 
            else {
                data->PrefixLength = 128;
            }
            RtlCopyMemory(
                &data->Prefix, 
                ((PTDI_ADDRESS_IP6)destAddr->Address[0].Address)->sin6_addr,
                16);
            break;
        }
    default:
        __assume (0);
    }

    //
    // Setup IRP stack location to forward IRP to IP
    // Must be METHOD_BUFFERED or we are not setting it up correctly
    //

    ASSERT ( (Protocol->RtChangeIoctl & 0x03)==METHOD_BUFFERED );
    irp->AssociatedIrp.SystemBuffer = notify->Data;

    irpSp = IoGetNextIrpStackLocation (irp);
    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = 0;
    irpSp->Flags = 0;
    irpSp->Control = 0;
    irpSp->FileObject = fileObject;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = Protocol->RtChangeDataSize;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.IoControlCode = Protocol->RtChangeIoctl;
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
    IoSetCompletionRoutine( irp, compRoutine, notify, TRUE, TRUE, TRUE );


    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTcpQueueRoutingChangeRequest: Passing Irp %p to IP\n",
                    irp));
    }

    if (irp==Irp) {
        //
        // Just pass the request through to the driver and return what it
        // returns
        //
        return AfdIoCallDriver (Endpoint, deviceObject, irp);
    }

    IoCallDriver (deviceObject, irp);

    status = STATUS_DEVICE_NOT_READY; // To be converted to WSAEWOULDBLOCK
    notify = NULL;  // So it doesn't get freed below.



    //
    // Error cases
    //

complete:
    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTcpQueueRoutingChangeRequest: completing with status: %lx\n",
                    status));
    }
    if (notify!=NULL) {
        AFD_FREE_POOL (notify, AFD_ROUTING_QUERY_POOL_TAG);
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;
} //AfdTcpQueueRoutingChangeRequest

NTSTATUS
AfdTcpRestartRoutingChange (
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp, 
    IN PVOID Context 
    )
/*++

Routine Description:

    Completion routing for routing change IRP forwarded to IP

Arguments:
    
    DeviceObject    - must be our device object

    Irp             - the request to be completed

    Context         - completion context


Return Value:

    NTSTATUS -- Indicates to the system what to do next with the IRP

--*/
{
    PROUTING_NOTIFY notifyCtx = Context;
    PAFD_ENDPOINT   endpoint = IoGetCurrentIrpStackLocation (Irp)->FileObject->FsContext;

    UNREFERENCED_PARAMETER (DeviceObject);
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTcpRestartRoutingChange: Irp: %p, status: %lx, info: %ld.\n",
                    Irp, Irp->IoStatus.Status, Irp->IoStatus.Information));
    }


    //
    // Check if IRP is still on the endpoint's list and remove if it is
    //

    if (InterlockedExchangePointer ((PVOID *)&notifyCtx->NotifyIrp, NULL)!=NULL) {
        AFD_LOCK_QUEUE_HANDLE lockHandle;
        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        RemoveEntryList (&notifyCtx->NotifyListLink);
        AfdIndicateEventSelectEvent (endpoint, 
                            AFD_POLL_ROUTING_IF_CHANGE, 
                            Irp->IoStatus.Status);
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Indicate event as the endpoint is still active
        //

        AfdIndicatePollEvent (endpoint, 
                            AFD_POLL_ROUTING_IF_CHANGE, 
                            Irp->IoStatus.Status);
    }

    //
    // If pending has be returned for this IRP then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }

    //
    // Restore the IRP to its previous glory and free allocated context structure
    //

    Irp->AssociatedIrp.SystemBuffer = notifyCtx->NotifyContext;
    AfdCompleteOutstandingIrp (endpoint, Irp);

    AFD_FREE_POOL (notifyCtx, AFD_ROUTING_QUERY_POOL_TAG);
    return STATUS_SUCCESS;
}


NTSTATUS
AfdTcpSignalRoutingChange (
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp, 
    IN PVOID Context 
    )
/*++

Routine Description:

    Completion routing for routing change IRP submitted to IP

Arguments:
    
    DeviceObject    - must be our device object

    Irp             - the request to be completed

    Context         - completion context


Return Value:

    NTSTATUS -- Indicates to the system what to do next with the IRP

--*/
{
    PROUTING_NOTIFY notifyCtx = Context;
    PAFD_ENDPOINT   endpoint = notifyCtx->NotifyContext;

    UNREFERENCED_PARAMETER (DeviceObject);
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTcpSignalRoutingChange: Irp: %p, status: %lx, info: %ld.\n",
                    Irp, Irp->IoStatus.Status, Irp->IoStatus.Information));
    }


    //
    // Check if IRP is still on the endpoint's list and remove if it is
    //

    if (InterlockedExchangePointer ((PVOID *)&notifyCtx->NotifyIrp, NULL)!=NULL) {
        AFD_LOCK_QUEUE_HANDLE lockHandle;

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        RemoveEntryList (&notifyCtx->NotifyListLink);
        AfdIndicateEventSelectEvent (endpoint, 
                            AFD_POLL_ROUTING_IF_CHANGE, 
                            Irp->IoStatus.Status);
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Indicate event as the endpoint is still active
        //

        AfdIndicatePollEvent (endpoint, 
                            AFD_POLL_ROUTING_IF_CHANGE, 
                            Irp->IoStatus.Status);
    }

    //
    // Release previously acquired endpoint reference
    //

    DEREFERENCE_ENDPOINT (endpoint);

    //
    // Free allocated irp and context structure
    //

    IoFreeIrp (Irp);
    AFD_FREE_POOL (notifyCtx, AFD_ROUTING_QUERY_POOL_TAG);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
AfdCleanupRoutingChange (
    PAFD_ENDPOINT   Endpoint
    )
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    KIRQL cancelIrql;
    USHORT addressType;
    PLIST_ENTRY listEntry;
    PAFD_PROTOCOL protocol;
   
    //
    // If there are pending routing notifications on endpoint, cancel them.
    // We must hold both cancel and endpoint spinlocks to make
    // sure that IRP is not completed as we are cancelling it
    //

    IoAcquireCancelSpinLock( &cancelIrql );
    AfdAcquireSpinLockAtDpcLevel( &Endpoint->SpinLock, &lockHandle );

    //
    // Can only have one cleanup call per endpoint
    // So this should be set.
    //
    ASSERT (Endpoint->RoutingQueryReferenced);
    Endpoint->RoutingQueryReferenced = FALSE;
    if (Endpoint->RoutingQueryIPv6) {
        Endpoint->RoutingQueryIPv6 = FALSE;
        addressType = TDI_ADDRESS_TYPE_IP6;
    }
    else {
        addressType = TDI_ADDRESS_TYPE_IP;
    }

    listEntry = Endpoint->RoutingNotifications.Flink;
    while (listEntry!=&Endpoint->RoutingNotifications) {
        PIRP            notifyIrp;
        PROUTING_NOTIFY notifyCtx = CONTAINING_RECORD (listEntry,
                                                        ROUTING_NOTIFY,
                                                        NotifyListLink);
        listEntry = listEntry->Flink;

        //
        // Check if IRP has not been completed yet
        //

        notifyIrp = (PIRP)InterlockedExchangePointer ((PVOID *)&notifyCtx->NotifyIrp, NULL);
        if (notifyIrp!=NULL) {

            //
            // Remove it from the list and call cancel routing while still
            // holding cancel spinlock
            //

            RemoveEntryList (&notifyCtx->NotifyListLink);
            AfdReleaseSpinLockFromDpcLevel ( &Endpoint->SpinLock, &lockHandle);
            notifyIrp->CancelIrql = cancelIrql;
            AfdCancelIrp (notifyIrp);

            //
            // Reacquire cancel and endpoint spinlocks
            //

            IoAcquireCancelSpinLock( &cancelIrql );
            AfdAcquireSpinLockAtDpcLevel( &Endpoint->SpinLock, &lockHandle );
        }
    }

    AfdReleaseSpinLockFromDpcLevel ( &Endpoint->SpinLock, &lockHandle);
    IoReleaseCancelSpinLock( cancelIrql );
    
    protocol = AfdGetProtocolInfo(addressType);
    ASSERT(protocol != NULL);
    AfdDereferenceRoutingQuery(protocol);

}

VOID
AfdCancelAddressListChange (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
AfdCleanupAddressListChange (
    PAFD_ENDPOINT           Endpoint,
    PAFD_REQUEST_CONTEXT    RequestCtx
    );

NTSTATUS
AfdInitializeAddressList (VOID);

VOID
AfdAddAddressHandler ( 
    IN PTA_ADDRESS NetworkAddress,
    IN PUNICODE_STRING  DeviceName,
    IN PTDI_PNP_CONTEXT Context
    );

VOID
AfdDelAddressHandler ( 
    IN PTA_ADDRESS NetworkAddress,
    IN PUNICODE_STRING  DeviceName,
    IN PTDI_PNP_CONTEXT Context
    );

VOID
AfdProcessAddressChangeList (
    USHORT              AddressType,
    PUNICODE_STRING     DeviceName
    );

NTSTATUS
AfdPnPPowerChange(
    IN PUNICODE_STRING DeviceName,
    IN PNET_PNP_EVENT PowerEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
    );

VOID
AfdReturnNicsPackets (
    PVOID   Pdo
    );

BOOLEAN
AfdHasHeldPacketsFromNic (
    PAFD_CONNECTION Connection,
    PVOID           Pdo
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE,    AfdAddressListQuery )
#pragma alloc_text( PAGEAFD, AfdAddressListChange )
#pragma alloc_text( PAGEAFD, AfdCancelAddressListChange )
#pragma alloc_text( PAGE,    AfdInitializeAddressList )
#pragma alloc_text( PAGE,    AfdDeregisterPnPHandlers )
#pragma alloc_text( PAGE,    AfdAddAddressHandler )
#pragma alloc_text( PAGE,    AfdDelAddressHandler )
#pragma alloc_text( PAGEAFD, AfdProcessAddressChangeList )
#pragma alloc_text( PAGE,    AfdPnPPowerChange )
#pragma alloc_text( PAGEAFD, AfdReturnNicsPackets )
#pragma alloc_text( PAGEAFD, AfdHasHeldPacketsFromNic )
#endif

//
// Cache the device being brought down as a result of
// removal or power down event, so we do not scan our endpoints
// unnecessarily when more than one transport propagates device down
// event for the same device to us.
//
PVOID     AfdLastRemovedPdo = NULL;
ULONGLONG AfdLastRemoveTime = 0i64;

NTSTATUS
AfdAddressListQuery (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
/*++

Routine Description:

    Processes address list query IRP

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
    NTSTATUS            status;
    PLIST_ENTRY         listEntry;
    PTRANSPORT_ADDRESS  addressList;
    PAFD_ENDPOINT       endpoint;
    PUCHAR              addressBuf;
    ULONG               dataLen;
    PAFD_ADDRESS_ENTRY  addressEntry;
    USHORT              addressType;

    UNREFERENCED_PARAMETER (IoctlCode);
    PAGED_CODE ();

    *Information = 0;
    status = STATUS_SUCCESS;

    IF_DEBUG (ADDRESS_LIST) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAddressListQuery: Endp: %p, buf: %p, inlen: %ld, outlen: %ld.\n",
                    FileObject->FsContext,
                    OutputBuffer,
                    InputBufferLength,
                    OutputBufferLength));
    }

    //
    // Validate input parameters
    //

    if( InputBufferLength < sizeof(USHORT) ||
            OutputBufferLength < FIELD_OFFSET (TRANSPORT_ADDRESS, Address)
            ) {

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdAddressListQuery: Endp: %p - invalid parameter.\n",
                    FileObject->FsContext));
        return STATUS_INVALID_PARAMETER;
    }

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    try {
        if (RequestorMode!=KernelMode) {
            ProbeForReadSmallStructure (InputBuffer,
                            sizeof (addressType),
                            sizeof (USHORT));
            ProbeForWrite (OutputBuffer,
                            OutputBufferLength,
                            sizeof (ULONG));
        }

        addressType = *((PUSHORT)InputBuffer);

        addressList = OutputBuffer;
        addressBuf = (PUCHAR)OutputBuffer;
        dataLen = FIELD_OFFSET (TRANSPORT_ADDRESS, Address);
        addressList->TAAddressCount = 0;
    }
    except (AFD_EXCEPTION_FILTER (status)) {
        ASSERT (NT_ERROR (status));
        return status;
    }

    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceSharedLite( AfdResource, TRUE );

    //
    // Setup address handlers with TDI if not already done
    //
    if (AfdBindingHandle==NULL) {
        ExReleaseResourceLite( AfdResource );

        ExAcquireResourceExclusiveLite( AfdResource, TRUE );

        if (AfdBindingHandle==NULL) {
            status = AfdInitializeAddressList ();
            if (!NT_SUCCESS (status)) {
                ExReleaseResourceLite (AfdResource);
                KeLeaveCriticalRegion ();
                return status;
            }
        }
        else
            status = STATUS_SUCCESS;
        
        ASSERT (AfdBindingHandle!=NULL);
    }

    ExAcquireResourceSharedLite( AfdAddressListLock, TRUE );
    ExReleaseResourceLite( AfdResource );

    //
    // Walk the address list and pick up the addresses of matching protocol
    // family
    //

    listEntry = AfdAddressEntryList.Flink;
    while (listEntry!=&AfdAddressEntryList) {
        addressEntry = CONTAINING_RECORD (listEntry, AFD_ADDRESS_ENTRY, AddressListLink);
        listEntry = listEntry->Flink;

        //
        // Found a match ?
        //

        if ((addressEntry->Address.AddressType==addressType)
                    //
                    // Special check for Netbios addresses because
                    // we have separate protocols for each lana/device
                    //
                 && ((addressType!=TDI_ADDRESS_TYPE_NETBIOS)
                        || endpoint->TransportInfo==NULL
                        || RtlEqualUnicodeString (
                                &addressEntry->DeviceName,
                                &endpoint->TransportInfo->TransportDeviceName,
                                TRUE))) {
            ULONG   addressLength = FIELD_OFFSET (TA_ADDRESS,
                        Address[addressEntry->Address.AddressLength]);
            AFD_W4_INIT ASSERT (status==STATUS_SUCCESS || status==STATUS_BUFFER_OVERFLOW);
            try {

                //
                // Copy address to the output buffer if it is not full
                //

                if (status==STATUS_SUCCESS) {
                    if (dataLen+addressLength<=OutputBufferLength) {
                        RtlCopyMemory (&addressBuf[dataLen], 
                                            &addressEntry->Address, 
                                            addressLength);
                        IF_DEBUG (ADDRESS_LIST) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdAddressListQuery: Adding address of type: %d, length: %d.\n",
                                addressEntry->Address.AddressType,
                                addressEntry->Address.AddressLength));
                        }
                    }
                    else {
                        //
                        // End of buffer reached.  Set error code so we do not
                        // attempt to copy more data
                        //
                        IF_DEBUG (ADDRESS_LIST) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                        "AfdAddressListQuery: Buffer is full.\n"));
                        }
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }

                //
                // Count the addresses and total buffer length whether we copied
                // them or not to the output buffer
                //

                addressList->TAAddressCount += 1;
                dataLen += addressLength;
            }
            except (AFD_EXCEPTION_FILTER (status)) {
                ASSERT (NT_ERROR (status));
                dataLen = 0;
                break;
            }
        }
    }
    ExReleaseResourceLite (AfdAddressListLock);
    KeLeaveCriticalRegion ();

    //
    // Return total number of copied/required bytes in the buffer and status
    //

    IF_DEBUG (ADDRESS_LIST) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAddressListQuery: Address count: %ld, total buffer size: %ld.\n",
                    addressList->TAAddressCount, dataLen));
    }
    *Information = dataLen;

    return status;
} //AfdAddressListQuery



//
// Context structure allocated for non-blocking address list change IOCTLs
//

typedef struct _AFD_NBCHANGE_CONTEXT {
    AFD_REQUEST_CONTEXT Context;        // Context to keep track of request
    AFD_ADDRESS_CHANGE  Change;         // Address change parameters
} AFD_NBCHANGE_CONTEXT, *PAFD_NBCHANGE_CONTEXT;


NTSTATUS
FASTCALL
AfdAddressListChange (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    Processes address list change IRP

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
    NTSTATUS                    status = STATUS_PENDING;
    USHORT                      addressType;
    PAFD_ADDRESS_CHANGE         change;
    PAFD_REQUEST_CONTEXT        requestCtx;
    PAFD_ENDPOINT               endpoint;
    AFD_LOCK_QUEUE_HANDLE          addressLockHandle, endpointLockHandle;
    KIRQL                       oldIrql;
    BOOLEAN                     overlapped;
    AFD_TRANSPORT_IOCTL_INFO    ioctlInfo;

    IF_DEBUG (ADDRESS_LIST) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAddressListChange: Endp: %p, buf: %p, inlen: %ld, outlen: %ld.\n",
                    IrpSp->FileObject->FsContext,
                    Irp->AssociatedIrp.SystemBuffer,
                    IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength));
    }

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Validate input parameters
    //

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        PAFD_TRANSPORT_IOCTL_INFO32 ioctlInfo32;
        ioctlInfo32 = Irp->AssociatedIrp.SystemBuffer;
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (*ioctlInfo32)) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
        ioctlInfo.Handle = ioctlInfo32->Handle;
        ioctlInfo.InputBuffer = UlongToPtr(ioctlInfo32->InputBuffer);
        ioctlInfo.InputBufferLength = ioctlInfo32->InputBufferLength;
        ioctlInfo.IoControlCode = ioctlInfo32->IoControlCode;
        ioctlInfo.AfdFlags = ioctlInfo32->AfdFlags;
        ioctlInfo.PollEvent = ioctlInfo32->PollEvent;
    }
    else
#endif // _WIN64
    {

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (ioctlInfo)) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        //
        // Just copy the buffer verified by the IO system
        //

        ioctlInfo = *((PAFD_TRANSPORT_IOCTL_INFO)
                        Irp->AssociatedIrp.SystemBuffer);
    }

    if( ioctlInfo.InputBufferLength < sizeof(USHORT)) {

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdAddressListChange: Endp: %p - invalid parameter.\n",
                    IrpSp->FileObject->FsContext));
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    try {
        if (Irp->RequestorMode != KernelMode) {
                ProbeForRead(
                    ioctlInfo.InputBuffer,
                    ioctlInfo.InputBufferLength,
                    sizeof (USHORT)
                    );
            }

        addressType = *((PUSHORT)ioctlInfo.InputBuffer);
    }
    except( AFD_EXCEPTION_FILTER (status) ) {
        ASSERT (NT_ERROR (status));
        goto complete;
    }

    //
    // Check if request is overlapped
    //

    overlapped = (BOOLEAN)((ioctlInfo.AfdFlags & AFD_OVERLAPPED)!=0);

    //
    // Reset the poll bit
    //

    endpoint->EventsActive &= ~AFD_POLL_ADDRESS_LIST_CHANGE;

    //
    // Setup address handlers with TDI if not already done
    //

    if (AfdBindingHandle==NULL) {
        //
        // Make sure the thread in which we execute cannot get
        // suspeneded in APC while we own the global resource.
        //
        KeEnterCriticalRegion ();
        ExAcquireResourceExclusiveLite( AfdResource, TRUE );

        if (AfdBindingHandle==NULL)
            status = AfdInitializeAddressList ();
        else
            status = STATUS_SUCCESS;

        ExReleaseResourceLite (AfdResource);
        KeLeaveCriticalRegion ();

        if (!NT_SUCCESS (status)) {
            goto complete;
        }
    }

    //
    // Setup locals
    //

    if (endpoint->NonBlocking && !overlapped) {
        PAFD_NBCHANGE_CONTEXT   nbCtx;
        //
        // If endpoint is non-blocking and request is not overlapped,
        // we'll have to complete it right away and remeber that we
        // need to set event when address list changes
        //


        //
        // Allocate context to keep track of this request
        //

        try {
            nbCtx = AFD_ALLOCATE_POOL_WITH_QUOTA (NonPagedPool,
                            sizeof(AFD_NBCHANGE_CONTEXT),
                            AFD_ADDRESS_CHANGE_POOL_TAG);
            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE
        }
        except (AFD_EXCEPTION_FILTER (status)) {
            ASSERT (NT_ERROR (status));
            nbCtx = NULL;
            IF_DEBUG(ROUTING_QUERY) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdAddressListChange: Endp: %p - can't allocate change strucure.\n",
                        IrpSp->FileObject->FsContext));
            }
            goto complete;
        }

        requestCtx = &nbCtx->Context;
        change = &nbCtx->Change;

        change->Endpoint = endpoint;
        change->NonBlocking = TRUE;
        status = STATUS_DEVICE_NOT_READY;
    }
    else {

        C_ASSERT (sizeof (IrpSp->Parameters.Others)>=sizeof (*requestCtx));
        C_ASSERT (sizeof (Irp->Tail.Overlay.DriverContext)>=sizeof (*change));

        requestCtx = (PAFD_REQUEST_CONTEXT)&IrpSp->Parameters.Others;

        change = (PAFD_ADDRESS_CHANGE)Irp->Tail.Overlay.DriverContext;
        change->NonBlocking = FALSE;
        change->Irp = Irp;

    }

    //
    // Remeber the endpoint and address type for the request
    //

    change->AddressType = addressType;
    requestCtx->CleanupRoutine = AfdCleanupAddressListChange;
    requestCtx->Context = change;

    //
    // Insert change notification into the list
    //
    KeRaiseIrql (DISPATCH_LEVEL, &oldIrql);
    AfdAcquireSpinLockAtDpcLevel (&AfdAddressChangeLock, &addressLockHandle);

    //
    // While holding the address change spinlock acquire endpoint
    // spinlock so if notification occurs, neither structure can
    // be deallocated or IRP completed while we are queuing
    // it to endpoint list
    //
    AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &endpointLockHandle);


    //
    // Check if endpoint was cleaned-up and cancel the request.
    //

    if (endpoint->EndpointCleanedUp) {
        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
        AfdReleaseSpinLockFromDpcLevel (&AfdAddressChangeLock, &addressLockHandle);
        KeLowerIrql (oldIrql);

        if (change->NonBlocking) {
            AFD_FREE_POOL (CONTAINING_RECORD (
                                          requestCtx,
                                          AFD_NBCHANGE_CONTEXT,
                                          Context),
                           AFD_ADDRESS_CHANGE_POOL_TAG);
        }

        status = STATUS_CANCELLED;
        goto complete;
    }

    //
    // If request is non-blocking, check if we have another non-blocking
    // request on the same endpoint. If so, we do not need to have
    // two request structures in the list waiting to signal.
    //
    if (change->NonBlocking) {
        PLIST_ENTRY listEntry = endpoint->RequestList.Flink;
        while (listEntry!=&endpoint->RequestList) {
            PAFD_REQUEST_CONTEXT    req = CONTAINING_RECORD (
                                            listEntry,
                                            AFD_REQUEST_CONTEXT,
                                            EndpointListLink);
            listEntry = listEntry->Flink;
            if (req->CleanupRoutine==AfdCleanupAddressListChange) {
                PAFD_ADDRESS_CHANGE chg = req->Context;
                if (chg->NonBlocking) {
                    AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
                    AfdReleaseSpinLockFromDpcLevel (&AfdAddressChangeLock, &addressLockHandle);
                    KeLowerIrql (oldIrql);
                    AFD_FREE_POOL (CONTAINING_RECORD (
                                            requestCtx,
                                            AFD_NBCHANGE_CONTEXT,
                                            Context),
                                    AFD_ADDRESS_CHANGE_POOL_TAG);
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                "AfdAddressListChange: Endp: %p - non-blocking request already pending.\n",
                                IrpSp->FileObject->FsContext));
                    ASSERT (status == STATUS_DEVICE_NOT_READY);
                    goto complete;
                }
            }
        }
    }

    InsertTailList (&AfdAddressChangeList, &change->ChangeListLink);
    AfdReleaseSpinLockFromDpcLevel (&AfdAddressChangeLock, &addressLockHandle);
    InsertTailList (&endpoint->RequestList, &requestCtx->EndpointListLink);
    if (!change->NonBlocking) {

        //
        // Set cancel routine
        //

        IoSetCancelRoutine( Irp, AfdCancelAddressListChange );
        if ( !Irp->Cancel || IoSetCancelRoutine( Irp, NULL ) == NULL) {
            IoMarkIrpPending (Irp);
            //
            // Either there was no cancel or cancel routine has
            // been invoked already
            //
            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
            KeLowerIrql (oldIrql);

            IF_DEBUG (ADDRESS_LIST) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdAddressListChange: Queued change IRP: %p on endp: %p .\n",
                            Irp, endpoint));
            }

            return STATUS_PENDING;
        }
        else {
            RemoveEntryList (&requestCtx->EndpointListLink);
            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
            KeLowerIrql (oldIrql);
            goto complete;
        }
    }
    else {
        ASSERT (status==STATUS_DEVICE_NOT_READY);
    }
    AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
    KeLowerIrql (oldIrql);

complete:

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    IF_DEBUG (ADDRESS_LIST) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAddressListChange: Completing IRP: %ld on endp: %p with status: %lx .\n",
                    Irp, IrpSp->FileObject->FsContext, status));
    }
    IoCompleteRequest( Irp, 0 );

    return status;
}

VOID
AfdCancelAddressListChange (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Cancel routine for pending address list change IRP

Arguments:
    
    DeviceObject    - must be our device object

    Irp             - the request to be cancelled


Return Value:

    None

--*/
{
    AFD_LOCK_QUEUE_HANDLE      lockHandle;
    PAFD_ADDRESS_CHANGE     change;
    PAFD_REQUEST_CONTEXT    requestCtx;
    PAFD_ENDPOINT           endpoint;
    PIO_STACK_LOCATION      irpSp;

    UNREFERENCED_PARAMETER (DeviceObject);
    //
    // We do not use cancel spinlock to manage address list queue, so
    // we can release it right away
    //

    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    // Get the request context and remove it from the queue if not
    // already removed.
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    endpoint = irpSp->FileObject->FsContext;
    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));

    requestCtx = (PAFD_REQUEST_CONTEXT)&irpSp->Parameters.DeviceIoControl;
    change = requestCtx->Context;
    ASSERT (change==(PAFD_ADDRESS_CHANGE)Irp->Tail.Overlay.DriverContext);
    ASSERT (change->NonBlocking==FALSE);

    AfdAcquireSpinLock (&AfdAddressChangeLock, &lockHandle);
    if (change->ChangeListLink.Flink!=NULL) {
        RemoveEntryList (&change->ChangeListLink);
        change->ChangeListLink.Flink = NULL;
    }
    AfdReleaseSpinLock (&AfdAddressChangeLock, &lockHandle);

    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    if (AfdIsRequestInQueue (requestCtx)) {
        //
        // Context is still in the list, just remove it so
        // noone can see it anymore and complete the IRP
        //
        RemoveEntryList (&requestCtx->EndpointListLink);
    }
    else if (!AfdIsRequestCompleted (requestCtx)) {
        //
        // During endpoint cleanup, this context was removed from the
        // list and cleanup routine is about to be called, don't
        // free this IRP until cleanup routine is called
        // Also, indicate to the cleanup routine that we are done
        // with this IRP and it can free it.
        //
        AfdMarkRequestCompleted (requestCtx);
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        return;
    }

    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    IF_DEBUG (ADDRESS_LIST) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdCancelAddressListChange: Cancelled IRP: %p on endp: %p .\n",
                    Irp, endpoint));
    }
}

BOOLEAN
AfdCleanupAddressListChange (
    PAFD_ENDPOINT           Endpoint,
    PAFD_REQUEST_CONTEXT    RequestCtx
    )
{
    AFD_LOCK_QUEUE_HANDLE      lockHandle;
    PAFD_ADDRESS_CHANGE     change;

    change = RequestCtx->Context;

    //
    // In no case IRP and request structure
    // could have been freed until we mark it as completed as
    // the caller of this routine should have marked the request
    // as being cancelled
    //
    ASSERT (RequestCtx->EndpointListLink.Flink==NULL);

    AfdAcquireSpinLock (&AfdAddressChangeLock, &lockHandle);
    if (change->ChangeListLink.Flink!=NULL) {
        RemoveEntryList (&change->ChangeListLink);
        change->ChangeListLink.Flink = NULL;
    }
    AfdReleaseSpinLock (&AfdAddressChangeLock, &lockHandle);

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    //
    // The processing routine has either already initiated completion
    // of this request and marked it as completed what it saw that the request is
    // no longer on the endpoint queue, or the processing routine will
    // never see the request since we removed it from the processing list.
    // However, it is possible that blocking request is being cancelled in another
    // thread as we cleaning up, so we need to sync with the cancel routine.
    //
    if (AfdIsRequestCompleted (RequestCtx) ||   
            change->NonBlocking ||              
            IoSetCancelRoutine (change->Irp, NULL)!=NULL) {
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
        if (change->NonBlocking) {
            ASSERT (CONTAINING_RECORD (RequestCtx,
                                        AFD_NBCHANGE_CONTEXT,
                                        Context)
                        ==CONTAINING_RECORD (change,
                                        AFD_NBCHANGE_CONTEXT,
                                        Change));
            ASSERT (Endpoint == change->Endpoint);
            AFD_FREE_POOL (CONTAINING_RECORD (RequestCtx,
                                                AFD_NBCHANGE_CONTEXT,
                                                Context),
                            AFD_ADDRESS_CHANGE_POOL_TAG);
        }
        else {
            PIRP    irp = change->Irp;
            ASSERT (change==(PAFD_ADDRESS_CHANGE)irp->Tail.Overlay.DriverContext);
            ASSERT (Endpoint == IoGetCurrentIrpStackLocation (irp)->FileObject->FsContext);
            ASSERT (RequestCtx == (PAFD_REQUEST_CONTEXT)
                &IoGetCurrentIrpStackLocation (irp)->Parameters.DeviceIoControl);
            irp->IoStatus.Status = STATUS_CANCELLED;
            irp->IoStatus.Information = 0;
            IoCompleteRequest (irp, IO_NO_INCREMENT);
        }
        return TRUE;
    }
    else {

        //
        // AFD has not completed the request before returning
        // from cancel routine, mark the request to indicate
        // that we are done with it and cancel routine
        // can free it
        //

        AfdMarkRequestCompleted (RequestCtx);
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);

        return FALSE;
    }

}


NTSTATUS
AfdInitializeAddressList (VOID)
/*++

Routine Description:

    Register address handler routinges with TDI

Arguments:
    
    None


Return Value:

    NTSTATUS -- Indicates whether registration succeded

--*/

{
    NTSTATUS                    status;
    TDI_CLIENT_INTERFACE_INFO   info;
    UNICODE_STRING              afdName;
    
    PAGED_CODE ();

    //
    // Do basic initialization if we haven't done this before.
    //

    if (AfdAddressListLock == NULL) {

        //
        // Initialize spinlock that protects address change list.
        //

        AfdInitializeSpinLock(&AfdAddressChangeLock);

        //
        // Allocate and initialize resource that protects address list
        //

        AfdAddressListLock = AFD_ALLOCATE_POOL_PRIORITY(
                                 NonPagedPool,
                                 sizeof(*AfdAddressListLock),
                                 AFD_RESOURCE_POOL_TAG,
                                 HighPoolPriority
                                 );

        if (AfdAddressListLock == NULL)
            return (STATUS_INSUFFICIENT_RESOURCES);

        ExInitializeResourceLite(AfdAddressListLock);

        //
        // Initialize our lists
        //

        InitializeListHead(&AfdAddressEntryList);
        InitializeListHead(&AfdAddressChangeList);

    }

    if (AfdTdiPnPHandlerLock == NULL) {

        AfdTdiPnPHandlerLock = AFD_ALLOCATE_POOL_PRIORITY(
                                   NonPagedPool,
                                   sizeof(*AfdTdiPnPHandlerLock),
                                   AFD_RESOURCE_POOL_TAG,
                                   HighPoolPriority
                                   );

        if (AfdTdiPnPHandlerLock == NULL)
            return (STATUS_INSUFFICIENT_RESOURCES);

        ExInitializeResourceLite(AfdTdiPnPHandlerLock);

    }

    //
    // Setup the TDI request structure
    //

    RtlZeroMemory (&info, sizeof (info));
    RtlInitUnicodeString(&afdName, L"AFD");
#ifdef TDI_CURRENT_VERSION
    info.TdiVersion = TDI_CURRENT_VERSION;
#else
    info.MajorTdiVersion = 2;
    info.MinorTdiVersion = 0;
#endif
    info.Unused = 0;
    info.ClientName = &afdName;
    info.BindingHandler = NULL;
    info.AddAddressHandlerV2 = AfdAddAddressHandler;
    info.DelAddressHandlerV2 = AfdDelAddressHandler;
    info.PnPPowerHandler = AfdPnPPowerChange;

    //
    // Register handlers with TDI.
    // Note, it should be safe to hold AfdResource while registering
    // with TDI as it won't have any reason to callback into us.
    // However, we need AfdTdiPnPHandlerLock to protect AfdBindingHandle
    // between registering and deregistering as we can't hold AfdResource
    // while deregistering handlers with TDI because it can callback
    // into us and deadlock.
    //

    ExAcquireResourceExclusiveLite(AfdTdiPnPHandlerLock, TRUE);
    status = TdiRegisterPnPHandlers(&info, sizeof(info), &AfdBindingHandle);
    ExReleaseResourceLite(AfdTdiPnPHandlerLock);

    if (!NT_SUCCESS (status)) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                    "AfdInitializeAddressList: Failed to register PnP handlers: %lx .\n",
                    status));
        return status;
    }

    return STATUS_SUCCESS;
}


VOID
AfdDeregisterPnPHandlers (
    PVOID   Param
    )
{

    UNREFERENCED_PARAMETER(Param);
    ASSERT(AfdAddressListLock == NULL ||
           ExIsResourceAcquiredSharedLite(AfdAddressListLock) == 0 ||
           ExIsResourceAcquiredExclusiveLite(AfdAddressListLock));

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(AfdResource, TRUE);

    //
    // Free address list and associated structures
    //

    if (AfdBindingHandle) {

        HANDLE bindingHandle;
        
        ASSERT(AfdTdiPnPHandlerLock != NULL);
        ExAcquireResourceExclusiveLite(AfdTdiPnPHandlerLock, TRUE);

        bindingHandle = AfdBindingHandle;
        AfdBindingHandle = NULL;

        ExReleaseResourceLite(AfdResource);

        TdiDeregisterPnPHandlers(bindingHandle);

        ExReleaseResourceLite(AfdTdiPnPHandlerLock);

        //
        // RACE CONDITION!
        //

        ExAcquireResourceExclusiveLite(AfdResource, TRUE);
        ASSERT(AfdAddressListLock != NULL);
        ExAcquireResourceExclusiveLite(AfdAddressListLock, TRUE);

        while (!IsListEmpty(&AfdAddressEntryList)) {

            PAFD_ADDRESS_ENTRY addressEntry;
            PLIST_ENTRY listEntry;

            listEntry = RemoveHeadList(&AfdAddressEntryList);
            addressEntry = CONTAINING_RECORD(
                                listEntry,
                                AFD_ADDRESS_ENTRY,
                                AddressListLink
                                );

            AFD_FREE_POOL(
                addressEntry,
                AFD_TRANSPORT_ADDRESS_POOL_TAG
                );

        }

        //
        // Don't call if endpoint list is empty, since the driver
        // may be paged out.  There should be no-one to notify anyway
        // if there are no sockets there.
        //

        if (!IsListEmpty (&AfdEndpointListHead)) {
        
            //
            // Call routine to notify all the clients
            //

            ASSERT(!IsListEmpty(&AfdTransportInfoListHead));
            ASSERT(AfdLoaded);

            AfdProcessAddressChangeList(TDI_ADDRESS_TYPE_UNSPEC, NULL);

        }

        ExReleaseResourceLite(AfdAddressListLock);

    }

    ExReleaseResourceLite(AfdResource);
    KeLeaveCriticalRegion();

}


VOID
AfdAddAddressHandler ( 
    IN PTA_ADDRESS NetworkAddress,
    IN PUNICODE_STRING  DeviceName,
    IN PTDI_PNP_CONTEXT Context
    )
/*++

Routine Description:

    TDI add address handler

Arguments:
    
    NetworkAddress  - new network address available on the system

    Context1        - name of the device to which address belongs

    Context2        - PDO to which address belongs


Return Value:

    None

--*/
{
    PAFD_ADDRESS_ENTRY addrEntry;
    PAGED_CODE ();

    UNREFERENCED_PARAMETER (Context);
    //
    // Clear the cached last removed PDO when we get address add notification
    // since PDO can now be reused for something else.
    //
    AfdLastRemovedPdo = NULL;

    if (DeviceName==NULL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                  "AfdAddAddressHandler: "
                  "NO DEVICE NAME SUPPLIED when adding address of type %d., IGNORING IT!!!\n",
                  NetworkAddress->AddressType));
        return;
    }

    //
    // Allocate memory to keep address in our list
    // Note since the address information usually gets
    // populated during boot and not used right away, we
    // make it a "cold" allocation.  The flag has no effect
    // after system is booted.
    //

    addrEntry = AFD_ALLOCATE_POOL_PRIORITY (PagedPool|POOL_COLD_ALLOCATION,
                        ALIGN_UP(FIELD_OFFSET (AFD_ADDRESS_ENTRY,
                                Address.Address[NetworkAddress->AddressLength]),
                                WCHAR)
                            +DeviceName->MaximumLength,
                        AFD_TRANSPORT_ADDRESS_POOL_TAG,
                        HighPoolPriority);

    if (addrEntry!=NULL) {

        //
        // Insert new address in the list
        //

        RtlCopyMemory (&addrEntry->Address, NetworkAddress, 
                        FIELD_OFFSET (TA_ADDRESS,
                            Address[NetworkAddress->AddressLength]));

        addrEntry->DeviceName.MaximumLength = DeviceName->MaximumLength;
        addrEntry->DeviceName.Buffer = 
            ALIGN_UP_POINTER(&addrEntry->Address.Address[NetworkAddress->AddressLength],
                           WCHAR);
        RtlCopyUnicodeString (&addrEntry->DeviceName, DeviceName);


        //
        // We shouldn't be calling into TDI while having resource
        // acquired in shared mode because it can cause a deadloclk
        // rigth here as TDI reenters us and we need to acquire the
        // resource exclusive
        //

        ASSERT ( ExIsResourceAcquiredSharedLite ( AfdAddressListLock )==0
                  || ExIsResourceAcquiredExclusiveLite( AfdAddressListLock ));

        //
        // Make sure the thread in which we execute cannot get
        // suspeneded in APC while we own the global resource.
        //
        KeEnterCriticalRegion ();

        //
        // Acquire AfdResource since we will be checking if there are endpoints in
        // the list to decide whether to call non-pageable routine.
        //
        ExAcquireResourceSharedLite (AfdResource, TRUE);
        ExAcquireResourceExclusiveLite( AfdAddressListLock, TRUE );

        InsertTailList (&AfdAddressEntryList, &addrEntry->AddressListLink);

        //
        // Don't call if endpoint list is empty, since the driver
        // may be paged out.  There should be no-one to notify anyway
        // if there are no sockets there.
        //
        if (!IsListEmpty (&AfdEndpointListHead)) {
            //
            // Call routine to notify all the clietns
            //

            ASSERT (!IsListEmpty (&AfdTransportInfoListHead));
            ASSERT (AfdLoaded);

            AfdProcessAddressChangeList (NetworkAddress->AddressType, DeviceName);
        }

        ExReleaseResourceLite (AfdAddressListLock);
        ExReleaseResourceLite (AfdResource);
        KeLeaveCriticalRegion ();
    }
    else {
        //
        // Failed allocation - queue work item to deregister PnP
        // handlers and notify all apps.
        // When apps come back will re-register and our list will
        // get re-populated, or we'll fail the app's call(s);
        //
        AfdQueueWorkItem (&AfdDeregisterPnPHandlers, &AfdPnPDeregisterWorker);
    }

    IF_DEBUG (ADDRESS_LIST) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAddAddressHandler: Type: %d, length: %d, device: %*ls .\n",
                    NetworkAddress->AddressType,
                    NetworkAddress->AddressLength,
                    DeviceName->Length/2,
                    DeviceName->Buffer));
    }
}

VOID
AfdDelAddressHandler ( 
    IN PTA_ADDRESS NetworkAddress,
    IN PUNICODE_STRING DeviceName,
    IN PTDI_PNP_CONTEXT Context
    )
/*++

Routine Description:

    TDI delete address handler

Arguments:
    
    NetworkAddress  - network address that is no longer available on the system

    Context1        - name of the device to which address belongs

    Context2        - PDO to which address belongs


Return Value:

    None

--*/
{
    PAFD_ADDRESS_ENTRY  addrEntry;
    PLIST_ENTRY         listEntry;

    UNREFERENCED_PARAMETER (Context);
    PAGED_CODE ();

    if (DeviceName==NULL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                    "AfdDelAddressHandler: "
                    "NO DEVICE NAME SUPPLIED when deleting address of type %d.\n",
                    NetworkAddress->AddressType));
        return;
    }


    //
    // We shouldn't be calling into TDI while having resource
    // acquired in shared mode because it can cause a deadloclk
    // rigth here as TDI reenters us and we need to acquire the
    // resource exclusive
    //

    ASSERT ( ExIsResourceAcquiredSharedLite ( AfdAddressListLock )==0
                || ExIsResourceAcquiredExclusiveLite( AfdAddressListLock ));
    
    //
    // Find address in our list
    //

    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    //
    // Acquire AfdResource since we will be checking if there are endpoints in
    // the list to decide whether to call non-pageable routine.
    //
    ExAcquireResourceSharedLite (AfdResource, TRUE);
    ExAcquireResourceExclusiveLite( AfdAddressListLock, TRUE );
    listEntry = AfdAddressEntryList.Flink;
    while (listEntry!=&AfdAddressEntryList) {
        addrEntry = CONTAINING_RECORD (listEntry, AFD_ADDRESS_ENTRY, AddressListLink);
        listEntry = listEntry->Flink;
        if (RtlEqualMemory (&addrEntry->Address, NetworkAddress,
                    FIELD_OFFSET (TA_ADDRESS,
                    Address[NetworkAddress->AddressLength]))
                && RtlEqualUnicodeString (&addrEntry->DeviceName,
                                            DeviceName,
                                            TRUE)) {

            //
            // Remove it and notify the clients
            //

            RemoveEntryList (&addrEntry->AddressListLink);
            //
            // Don't call if endpoint list is empty, since the driver
            // may be paged out.  There should be no-one to notify anyway
            // if there are no sockets there.
            //
            if (!IsListEmpty (&AfdEndpointListHead)) {

                ASSERT (!IsListEmpty (&AfdTransportInfoListHead));
                ASSERT (AfdLoaded);

                AfdProcessAddressChangeList (NetworkAddress->AddressType, DeviceName);
            }

            ExReleaseResourceLite (AfdAddressListLock);
            ExReleaseResourceLite (AfdResource);
            KeLeaveCriticalRegion ();
            AFD_FREE_POOL (addrEntry, AFD_TRANSPORT_ADDRESS_POOL_TAG);
            IF_DEBUG (ADDRESS_LIST) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdDelAddressHandler: Type: %d, length: %d, device: %*ls .\n",
                            NetworkAddress->AddressType,
                            NetworkAddress->AddressLength,
                            DeviceName->Length/2,
                            DeviceName->Buffer));
            }
            return;
        }
    }
    ExReleaseResourceLite (AfdAddressListLock);
    ExReleaseResourceLite (AfdResource);
    KeLeaveCriticalRegion ();
    ASSERT (!"AfdDelAddressHandler: Could not find matching entry");
}

VOID
AfdProcessAddressChangeList (
    USHORT          AddressType,
    PUNICODE_STRING DeviceName
    )
/*++

Routine Description:

    Notifuis all interested clients of address arrival/deletion

Arguments:
    
    AddressType     - type of the address that arrived/ was deleted

    DeviceName      - name of the device to which address belongs

Return Value:

    None

--*/
{
    AFD_LOCK_QUEUE_HANDLE      lockHandle;
    PLIST_ENTRY             listEntry;
    LIST_ENTRY              completedChangeList;
    PAFD_ADDRESS_CHANGE     change;
    PAFD_REQUEST_CONTEXT    requestCtx;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpSp;
    PAFD_ENDPOINT           endpoint;
    PAFD_TRANSPORT_INFO     transportInfo;

    // ASSERT ((AddressType!=TDI_ADDRESS_TYPE_NETBIOS) || (DeviceName!=NULL));
    //
    // Special check for Netbios addresses because
    // we have separate protocols for each lana/device
    //
    transportInfo = NULL;
    if ((AddressType==TDI_ADDRESS_TYPE_NETBIOS) && (DeviceName!=NULL)) {
        BOOLEAN found = FALSE;
        for ( listEntry = AfdTransportInfoListHead.Flink;
              listEntry != &AfdTransportInfoListHead;
              listEntry = listEntry->Flink ) {
            transportInfo = CONTAINING_RECORD(
                                listEntry,
                                AFD_TRANSPORT_INFO,
                                TransportInfoListEntry
                                );
            if (RtlEqualUnicodeString (
                                    DeviceName,                           
                                    &transportInfo->TransportDeviceName,
                                    TRUE)) {
                found = TRUE;
                break;
            }
        }
        if (!found)
            return;
    }

    //
    // Create local list to process notifications after spinlock is released
    //

    InitializeListHead (&completedChangeList);

    //
    // Walk the list and move matching notifications to the local list
    //

    AfdAcquireSpinLock (&AfdAddressChangeLock, &lockHandle);
    listEntry = AfdAddressChangeList.Flink;
    while (listEntry!=&AfdAddressChangeList) {
        change = CONTAINING_RECORD (listEntry, 
                                AFD_ADDRESS_CHANGE,
                                ChangeListLink);
        if (change->NonBlocking) {
            endpoint = change->Endpoint;
            requestCtx = &CONTAINING_RECORD (change,
                                AFD_NBCHANGE_CONTEXT,
                                Change)->Context;
            AFD_W4_INIT irp = NULL;
            ASSERT (requestCtx->Context==change);
        }
        else {
            irp = change->Irp;
            irpSp = IoGetCurrentIrpStackLocation (irp);
            requestCtx = (PAFD_REQUEST_CONTEXT)&irpSp->Parameters.DeviceIoControl;
            endpoint = irpSp->FileObject->FsContext;
            ASSERT (change==(PAFD_ADDRESS_CHANGE)irp->Tail.Overlay.DriverContext);
        }

        listEntry = listEntry->Flink;
        if (((change->AddressType==AddressType) || (AddressType==TDI_ADDRESS_TYPE_UNSPEC))
                //
                // Special check for Netbios addresses because
                // we have separate protocols for each lana/device
                //
                && ((transportInfo==NULL)
                             || (transportInfo==endpoint->TransportInfo)) ) {
            AFD_LOCK_QUEUE_HANDLE lockHandle2;

            RemoveEntryList (&change->ChangeListLink);
            change->ChangeListLink.Flink = NULL;
            //
            // If request is already canceled, let cancel routine complete it
            //
            if (!change->NonBlocking && IoSetCancelRoutine (irp, NULL)==NULL) {
                continue;
            }

            AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &lockHandle2);
            if (AfdIsRequestInQueue (requestCtx)) {
                //
                // Context is still in the list, just remove it so
                // no-one can see it anymore and complete
                //
                RemoveEntryList (&requestCtx->EndpointListLink);
                InsertTailList (&completedChangeList,
                                    &change->ChangeListLink);
                if (change->NonBlocking) {
                    AfdIndicateEventSelectEvent (change->Endpoint, 
                                        AFD_POLL_ADDRESS_LIST_CHANGE, 
                                        STATUS_SUCCESS);
                }
            }
            else if (!AfdIsRequestCompleted (requestCtx)) {
                //
                // During endpoint cleanup, this context was removed from the
                // list and cleanup routine is about to be called, don't
                // free this IRP until cleanup routine is called
                // Also, indicate to the cleanup routine that we are done
                // with this IRP and it can free it.
                //
                AfdMarkRequestCompleted (requestCtx);
            }

            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle2);
        }
    }
    AfdReleaseSpinLock (&AfdAddressChangeLock, &lockHandle);

    //
    // Signal interested clients and complete IRPs as necessary
    //

    while (!IsListEmpty (&completedChangeList)) {
        listEntry = RemoveHeadList (&completedChangeList);
        change = CONTAINING_RECORD (listEntry, 
                                AFD_ADDRESS_CHANGE,
                                ChangeListLink);
        if (change->NonBlocking) {
            IF_DEBUG (ADDRESS_LIST) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdProcessAddressChangeList: Signalling address list change on endpoint %p .\n",
                            change->Endpoint));
            }
            AfdIndicatePollEvent (change->Endpoint, 
                                AFD_POLL_ADDRESS_LIST_CHANGE, 
                                STATUS_SUCCESS);
            AFD_FREE_POOL (CONTAINING_RECORD (change,
                                                AFD_NBCHANGE_CONTEXT,
                                                Change),
                            AFD_ADDRESS_CHANGE_POOL_TAG);
        }
        else {
            irp = change->Irp;
            irp->IoStatus.Status = STATUS_SUCCESS;
            irp->IoStatus.Information = 0;
            IF_DEBUG (ADDRESS_LIST) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdProcessAddressChangeList: Completing change IRP: %p  with status: 0 .\n",
                            irp));
            }
            IoCompleteRequest (irp, AfdPriorityBoost);
        }
    }
}


BOOLEAN
AfdHasHeldPacketsFromNic (
    PAFD_CONNECTION Connection,
    PVOID           Pdo
    )
{
    PLIST_ENTRY le;
    //
    // Scan the list of buffers and check with TDI/NDIS
    // if packet belongs to a given card
    //
    if (!IsListEmpty( &Connection->VcReceiveBufferListHead ) ) {
        le = Connection->VcReceiveBufferListHead.Flink;
        while ( le!=&Connection->VcReceiveBufferListHead ) {
            PAFD_BUFFER afdBuffer;
            afdBuffer = CONTAINING_RECORD( le, AFD_BUFFER, BufferListEntry );
            if ((afdBuffer->BufferLength==AfdBufferTagSize) &&
                    afdBuffer->NdisPacket &&
                    TdiMatchPdoWithChainedReceiveContext (afdBuffer->Context, Pdo)) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                            "AFD: Aborting connection %p due to held packet %p at power down on nic %p\n",
                            Connection,
                            afdBuffer->Context,
                            Pdo));
                return TRUE;
            }
            le = le->Flink;
        }
    }
    return FALSE;
}

VOID
AfdReturnNicsPackets (
    PVOID   Pdo
    )
{
    KIRQL           oldIrql;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY     listEntry, le;
    LIST_ENTRY      connList;

    //
    // Don't scan twice for the same PDO if this event
    // is less than 3 sec apart from previous.
    // Several transports bound to the same NIC may indicate
    // the set power event to us
    //
    if ((AfdLastRemovedPdo!=Pdo) || 
        ((KeQueryInterruptTime()-AfdLastRemoveTime)>30000000i64)) {

        //
        // Scan the list of endpoints and find packets
        // that belong to the NIC.
        //
        KeEnterCriticalRegion ();
        ExAcquireResourceExclusiveLite (AfdResource, TRUE);

        if (!IsListEmpty (&AfdEndpointListHead)) {
            KeRaiseIrql (DISPATCH_LEVEL, &oldIrql);

            listEntry = AfdEndpointListHead.Flink;
            while (listEntry!=&AfdEndpointListHead) {
                PAFD_CONNECTION connection;
                PAFD_ENDPOINT   endpoint = CONTAINING_RECORD (
                                                listEntry,
                                                AFD_ENDPOINT,
                                                GlobalEndpointListEntry);
                listEntry = listEntry->Flink;
                switch (endpoint->Type) {
                case AfdBlockTypeDatagram:
                    //
                    // Afd currently does not support buffer
                    // ownership on datagram sockets.
                    //
                    // If such support is added, we will need to
                    // add code here to return all the buffers
                    // owned by the netcards.
                    //
                    break;
            
                case AfdBlockTypeVcConnecting:
                    //
                    // Drop all of the connections that have unreturned packets.
                    //
                    AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &lockHandle);
                    connection = AFD_CONNECTION_FROM_ENDPOINT (endpoint);
                    if (endpoint->State==AfdEndpointStateConnected && 
                            !IS_TDI_BUFFERRING(endpoint) &&
                            connection!=NULL &&
                            AfdHasHeldPacketsFromNic (connection, Pdo)) {
                        REFERENCE_CONNECTION (connection);
                        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
                        AfdBeginAbort (connection);
                        AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &lockHandle);
                        //
                        // Make sure we do not have any buffered data
                        // (could have just checked for netcard owned
                        // buffers, but connection is going down anyway
                        // - save memory).
                        //
                        connection->VcBufferredReceiveBytes = 0;
                        connection->VcBufferredReceiveCount = 0;
                        connection->VcBufferredExpeditedBytes = 0;
                        connection->VcBufferredExpeditedCount = 0;
                        connection->VcReceiveBytesInTransport = 0;
                        while ( !IsListEmpty( &connection->VcReceiveBufferListHead ) ) {
                            PAFD_BUFFER_HEADER afdBuffer;
                            le = RemoveHeadList( &connection->VcReceiveBufferListHead );
                            afdBuffer = CONTAINING_RECORD( le, AFD_BUFFER_HEADER, BufferListEntry );

                            DEBUG afdBuffer->BufferListEntry.Flink = NULL;
                            if (afdBuffer->RefCount==1 || // Can't change once off the list
                                    InterlockedDecrement (&afdBuffer->RefCount)==0) {
                                afdBuffer->ExpeditedData = FALSE;
                                AfdReturnBuffer( afdBuffer, connection->OwningProcess );
                            }
                        }
                        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
                        DEREFERENCE_CONNECTION (connection);
                    }
                    else {
                        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
                    }
                    break;
                case AfdBlockTypeVcBoth:
                case AfdBlockTypeVcListening:
                    if (IS_TDI_BUFFERRING (endpoint))
                        break;

                    //
                    // Drop all unaccepted and/or returned connections that have
                    // unreturned packets.
                    //
                    InitializeListHead (&connList);
                    AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &lockHandle);
                    le = endpoint->Common.VcListening.UnacceptedConnectionListHead.Flink;
                    while ( le!=&endpoint->Common.VcListening.UnacceptedConnectionListHead ) {
                        connection = CONTAINING_RECORD (le, AFD_CONNECTION, ListEntry);
                        ASSERT( connection->Endpoint == endpoint );
                        le = le->Flink;
                        if (AfdHasHeldPacketsFromNic (connection, Pdo)) {
                            RemoveEntryList (&connection->ListEntry);
                            InsertTailList (&connList, &connection->ListEntry);
                            InterlockedIncrement (&endpoint->Common.VcListening.FailedConnectionAdds);
                        }
                    }

                    le = endpoint->Common.VcListening.ReturnedConnectionListHead.Flink;
                    while ( le!=&endpoint->Common.VcListening.ReturnedConnectionListHead ) {
                        connection = CONTAINING_RECORD (le, AFD_CONNECTION, ListEntry);
                        ASSERT( connection->Endpoint == endpoint );
                        le = le->Flink;
                        if (AfdHasHeldPacketsFromNic (connection, Pdo)) {
                            RemoveEntryList (&connection->ListEntry);
                            InsertTailList (&connList, &connection->ListEntry);
                            InterlockedIncrement (&endpoint->Common.VcListening.FailedConnectionAdds);
                        }
                    }
                    AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
                    while (!IsListEmpty (&connList)) {
                        le = RemoveHeadList (&connList);
                        connection = CONTAINING_RECORD (le, AFD_CONNECTION, ListEntry);
                        AfdAbortConnection( connection );
                    }

                    if ( endpoint->Common.VcListening.FailedConnectionAdds > 0 ) {
                        AfdInitiateListenBacklogReplenish( endpoint );
                    }
                    break;
                }
            }
            KeLowerIrql (oldIrql);
        }

        ExReleaseResourceLite (AfdResource);
        KeLeaveCriticalRegion ();
    }
    AfdLastRemovedPdo = Pdo;
    AfdLastRemoveTime = KeQueryInterruptTime ();
}


NTSTATUS
AfdPnPPowerChange(
    IN PUNICODE_STRING DeviceName,
    IN PNET_PNP_EVENT PowerEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
    )
{
    UNREFERENCED_PARAMETER (DeviceName);
    PAGED_CODE ();
    switch (PowerEvent->NetEvent) {
    case NetEventSetPower: {
        NET_DEVICE_POWER_STATE powerState = 
                *((PNET_DEVICE_POWER_STATE)PowerEvent->Buffer);
        ASSERT (PowerEvent->BufferLength>=sizeof (NET_DEVICE_POWER_STATE));

        switch (powerState) {
        case NetDeviceStateD0:
            //
            // Clear the cached last removed PDO when we get Power UP notification
            // since PDO can now be reused for something else.
            //
            AfdLastRemovedPdo = NULL;
            goto DoNothing;
        default:
            ASSERTMSG ("NIC enters unknown power state", FALSE);
        case NetDeviceStateD1:
        case NetDeviceStateD2:
        case NetDeviceStateD3:
        case NetDeviceStateUnspecified:
            //
            // Break to execute PDO matching code
            //
            break;
        }
        break;
    }
    case NetEventQueryRemoveDevice:
        //
        // Break to execute PDO matching code
        //
        break;
    case NetEventCancelRemoveDevice:
        //
        // Clear the cached last removed PDO when we get Power UP notification
        // since PDO can now be removed again.
        //
        AfdLastRemovedPdo = NULL;
        goto DoNothing;
    default:
        goto DoNothing;
    }

    //
    // When power is removed or device is disabled, we need to release all
    // packets that we may own.
    // We can only do this for transports that give us
    // PDO, so NDIS can match the packet to the device.
    // Note that PDO is usually the second context argument (first one is
    // usually the device name), but we check the first one too since
    // the TDI spec isn't crystal clear on this (it just says: for example TCP
    // usually <does the above>).
    //
    if ((Context2!=NULL) &&
            (Context2->ContextType==TDI_PNP_CONTEXT_TYPE_PDO) &&
            (Context2->ContextSize==sizeof (PVOID)) ){
        AfdReturnNicsPackets (*((PVOID UNALIGNED *)&Context2->ContextData));
    }
    else if ((Context1!=NULL) &&
            (Context1->ContextType==TDI_PNP_CONTEXT_TYPE_PDO) &&
            (Context1->ContextSize==sizeof (PVOID)) ) {
        AfdReturnNicsPackets (*((PVOID UNALIGNED *)&Context1->ContextData));
    }

DoNothing:

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\misc.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module contains the miscellaneous AFD routines.

Author:

    David Treadwell (davidtr)    13-Nov-1992

Revision History:

    Vadim Eydelman (vadime) 1998-1999 Misc changes

--*/

#include "afdp.h"
#define TL_INSTANCE 0
#include <ipexport.h>
#include <tdiinfo.h>
#include <tcpinfo.h>
#include <ntddtcp.h>


VOID
AfdDoWork (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

NTSTATUS
AfdRestartDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
AfdUnlockDriver (
    IN PVOID Context
    );


BOOLEAN
AfdCompareAddresses(
    IN PTRANSPORT_ADDRESS Address1,
    IN ULONG Address1Length,
    IN PTRANSPORT_ADDRESS Address2,
    IN ULONG Address2Length
    );

NTSTATUS
AfdCompleteTransportIoctl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdCompleteNBTransportIoctl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
AfdCleanupTransportIoctl (
    PAFD_ENDPOINT           Endpoint,
    PAFD_REQUEST_CONTEXT    RequestCtx
    );

BOOLEAN
AfdCleanupNBTransportIoctl (
    PAFD_ENDPOINT           Endpoint,
    PAFD_REQUEST_CONTEXT    RequestCtx
    );

#ifdef _WIN64
NTSTATUS
AfdQueryHandles32 (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );
NTSTATUS
AfdSetQos32(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );
NTSTATUS
AfdGetQos32(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdNoOperation32(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );
#endif

VOID
AfdLRListTimeout (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
AfdProcessLRList (
    PVOID   Param
    );

VOID
AfdLRStartTimer (
    VOID
    );

#ifdef _AFD_VARIABLE_STACK_
VOID
AfdCancelStackIncreaseIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
AfdRestartStackIncreaseIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

PIRP
AfdGetStackIncreaseIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
#endif //_AFD_VARIABLE_STACK_

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdCalcBufferArrayByteLength )
#pragma alloc_text( PAGE, AfdCopyBufferArrayToBuffer )
#pragma alloc_text( PAGE, AfdCopyBufferToBufferArray )
#pragma alloc_text( PAGE, AfdCopyMdlChainToBufferArray )
#pragma alloc_text( PAGEAFD, AfdMapMdlChain )
#pragma alloc_text( PAGEAFD, AfdCopyMdlChainToMdlChain )
#pragma alloc_text( PAGEAFD, AfdAdvanceMdlChain )
#pragma alloc_text( PAGEAFD, AfdAllocateMdlChain )
#pragma alloc_text( PAGE, AfdQueryHandles )
#pragma alloc_text( PAGE, AfdGetInformation )
#pragma alloc_text( PAGEAFD, AfdSetInformation )
#pragma alloc_text( PAGE, AfdSetSecurity )
#pragma alloc_text( PAGE, AfdGetSecurity )
#pragma alloc_text( PAGE, AfdSetInLineMode )
#pragma alloc_text( PAGE, AfdGetContext )
#pragma alloc_text( PAGE, AfdGetRemoteAddress )
#pragma alloc_text( PAGE, AfdSetContext )
#pragma alloc_text( PAGE, AfdIssueDeviceControl )
#pragma alloc_text( PAGE, AfdSetEventHandler )
#pragma alloc_text( PAGE, AfdInsertNewEndpointInList )
#pragma alloc_text( PAGE, AfdRemoveEndpointFromList )
#pragma alloc_text( PAGE, AfdQueryProviderInfo )
#pragma alloc_text( PAGE, AfdLockEndpointContext )
#pragma alloc_text( PAGE, AfdUnlockEndpointContext )
#pragma alloc_text( PAGEAFD, AfdCompleteIrpList )
#pragma alloc_text( PAGEAFD, AfdErrorEventHandler )
#pragma alloc_text( PAGEAFD, AfdErrorExEventHandler )
//#pragma alloc_text( PAGEAFD, AfdRestartDeviceControl ) // can't ever be paged!
#pragma alloc_text( PAGEAFD, AfdGetConnectData )
#pragma alloc_text( PAGEAFD, AfdSetConnectData )
#pragma alloc_text( PAGEAFD, AfdFreeConnectDataBuffers )
#pragma alloc_text( PAGEAFD, AfdSaveReceivedConnectData )
// The routines below can be called when no endpoints are in the list
//#pragma alloc_text( PAGEAFD, AfdDoWork )
//#pragma alloc_text( PAGEAFD, AfdQueueWorkItem )
#pragma alloc_text( PAGEAFD, AfdGetWorkerByRoutine )

#pragma alloc_text( PAGE, AfdProcessLRList)
#pragma alloc_text( PAGEAFD, AfdLRListTimeout)
#pragma alloc_text( PAGEAFD, AfdLRStartTimer)
#pragma alloc_text( PAGEAFD, AfdLRListAddItem)

// Re-enable paging of the routines below when
// KeFlushQueuedDpcs is exported from kernel.
//#pragma alloc_text( PAGEAFD, AfdTrimLookaside)
//#pragma alloc_text( PAGEAFD, AfdCheckLookasideLists)

#if DBG
#pragma alloc_text( PAGEAFD, AfdRecordOutstandingIrpDebug )
#endif
#pragma alloc_text( PAGE, AfdExceptionFilter )
#pragma alloc_text( PAGEAFD, AfdSetQos )
#pragma alloc_text( PAGE, AfdGetQos )
#pragma alloc_text( PAGE, AfdNoOperation )
#pragma alloc_text (PAGE, AfdValidateStatus)
#pragma alloc_text( PAGEAFD, AfdValidateGroup )
#pragma alloc_text( PAGEAFD, AfdCompareAddresses )
#pragma alloc_text( PAGEAFD, AfdGetUnacceptedConnectData )
#pragma alloc_text( PAGE, AfdDoTransportIoctl )
#pragma alloc_text( PAGEAFD, AfdCancelIrp )
#ifdef _WIN64
#pragma alloc_text( PAGEAFD, AfdAllocateMdlChain32 )
#pragma alloc_text( PAGEAFD, AfdSetQos32 )
#pragma alloc_text( PAGE, AfdGetQos32 )
#pragma alloc_text( PAGE, AfdNoOperation32 )
#endif

#ifdef _AFD_VARIABLE_STACK_
#pragma alloc_text( PAGE, AfdFixTransportEntryPointsForBigStackSize )
#pragma alloc_text( PAGEAFD, AfdCallDriverStackIncrease)
#pragma alloc_text( PAGEAFD, AfdGetStackIncreaseIrpAndRecordIt)
#pragma alloc_text( PAGEAFD, AfdGetStackIncreaseIrp)
#pragma alloc_text( PAGEAFD, AfdCancelStackIncreaseIrp)
#pragma alloc_text( PAGEAFD, AfdRestartStackIncreaseIrp)
#endif // _AFD_VARIABLE_STACK_
#endif


VOID
AfdCompleteIrpList (
    IN PLIST_ENTRY IrpListHead,
    IN PAFD_ENDPOINT Endpoint,
    IN NTSTATUS Status,
    IN PAFD_IRP_CLEANUP_ROUTINE CleanupRoutine OPTIONAL
    )

/*++

Routine Description:

    Completes a list of IRPs with the specified status.

Arguments:

    IrpListHead - the head of the list of IRPs to complete.

    Endpoint - an endpoint which lock which protects the list of IRPs.

    Status - the status to use for completing the IRPs.

    CleanupRoutine - a pointer to an optional IRP cleanup routine called
        before the IRP is completed.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listEntry;
    PIRP irp;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );

    while ( !IsListEmpty( IrpListHead ) ) {

        //
        // Remove the first IRP from the list, get a pointer to
        // the IRP and reset the cancel routine in the IRP.  The
        // IRP is no longer cancellable.
        //

        listEntry = RemoveHeadList( IrpListHead );
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

        if ( IoSetCancelRoutine( irp, NULL ) == NULL ) {

            //
            // This IRP is about to be canceled.  Look for another in the
            // list.  Set the Flink to NULL so the cancel routine knows
            // it is not on the list.
            //

            irp->Tail.Overlay.ListEntry.Flink = NULL;
            continue;
        }

        //
        // If we have a cleanup routine, call it.
        //

        if( CleanupRoutine != NULL ) {

            if (!(CleanupRoutine)( irp )) {
                //
                // Cleanup routine indicated that IRP should not
                // be completed.
                //
                continue;
            }

        }

        //
        // We must release the locks in order to actually
        // complete the IRP.  It is OK to release these locks
        // because we don't maintain any absolute pointer into
        // the list; the loop termination condition is just
        // whether the list is completely empty.
        //

        AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );

        //
        // Complete the IRP.
        //

        irp->IoStatus.Status = Status;
        irp->IoStatus.Information = 0;

        IoCompleteRequest( irp, AfdPriorityBoost );

        //
        // Reacquire the locks and continue completing IRPs.
        //

        AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );
    }

    AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );

    return;

} // AfdCompleteIrpList


NTSTATUS
AfdErrorEventHandler (
    IN PVOID TdiEventContext,
    IN NTSTATUS Status
    )
{
    PAFD_ENDPOINT   endpoint = TdiEventContext;
    BOOLEAN result;

    CHECK_REFERENCE_ENDPOINT (endpoint, result);
    if (!result)
        return STATUS_SUCCESS;

    switch (Status) {
    case STATUS_PORT_UNREACHABLE:
        AfdErrorExEventHandler (TdiEventContext, Status, NULL);
        break;
    default:
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                    "AfdErrorEventHandler called for endpoint %p\n",
                    endpoint ));

    }

    DEREFERENCE_ENDPOINT (endpoint);
    return STATUS_SUCCESS;
}


NTSTATUS
AfdErrorExEventHandler (
    IN PVOID TdiEventContext,
    IN NTSTATUS Status,
    IN PVOID Context
    )
{
    PAFD_ENDPOINT   endpoint = TdiEventContext;
    BOOLEAN result;

    CHECK_REFERENCE_ENDPOINT (endpoint, result);
    if (!result)
        return STATUS_SUCCESS;

    switch (Status) {
    case STATUS_PORT_UNREACHABLE:
        //
        // UDP uses error ex handler to report ICMP rejects
        //
        if (IS_DGRAM_ENDPOINT (endpoint) && 
                !endpoint->Common.Datagram.DisablePUError) {
            AFD_LOCK_QUEUE_HANDLE lockHandle;
            PLIST_ENTRY     listEntry;
            PIRP            irp = NULL;
            PTRANSPORT_ADDRESS  sourceAddress = Context;
            int             sourceAddressLength;
            PAFD_BUFFER_TAG afdBuffer;

            if (sourceAddress!=NULL) {
                sourceAddressLength =
                    FIELD_OFFSET(TRANSPORT_ADDRESS,
                                 Address[0].Address[sourceAddress->Address[0].AddressLength]);
            }
            else
                sourceAddressLength = 0;

            AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
            //
            // First try to fail any of the receive IRPs
            //
            while (!IsListEmpty (&endpoint->ReceiveDatagramIrpListHead)) {
                listEntry = RemoveHeadList( &endpoint->ReceiveDatagramIrpListHead );

                //
                // Get a pointer to the IRP and reset the cancel routine in
                // the IRP.  The IRP is no longer cancellable.
                //

                irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
    
                if ( IoSetCancelRoutine( irp, NULL ) != NULL ) {
                    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
                    irp->IoStatus.Status = Status;
                    irp->IoStatus.Information = 0;
                    AfdSetupReceiveDatagramIrp (irp, NULL, 0, NULL, 0,
                                    sourceAddress,
                                    sourceAddressLength,
                                    0
                                    );

                    IoCompleteRequest( irp, AfdPriorityBoost );
                    goto Exit;
                }
                else {

                    //
                    // This IRP is about to be canceled.  Look for another in the
                    // list.  Set the Flink to NULL so the cancel routine knows
                    // it is not on the list.
                    //

                    irp->Tail.Overlay.ListEntry.Flink = NULL;
                    irp = NULL;
                }
            }

            ASSERT (irp==NULL);
            //
            // See if there are any PEEK IRPs
            //
            while (!IsListEmpty (&endpoint->PeekDatagramIrpListHead)) {
                listEntry = RemoveHeadList( &endpoint->PeekDatagramIrpListHead );

                //
                // Get a pointer to the IRP and reset the cancel routine in
                // the IRP.  The IRP is no longer cancellable.
                //

                irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
    
                if ( IoSetCancelRoutine( irp, NULL ) != NULL ) {
                    break;
                }
                else {

                    //
                    // This IRP is about to be canceled.  Look for another in the
                    // list.  Set the Flink to NULL so the cancel routine knows
                    // it is not on the list.
                    //

                    irp->Tail.Overlay.ListEntry.Flink = NULL;
                    irp = NULL;
                }

            }

            //
            // If we can buffer this indication, do it
            //

            if (endpoint->DgBufferredReceiveBytes <
                    endpoint->Common.Datagram.MaxBufferredReceiveBytes &&
                    (endpoint->DgBufferredReceiveBytes>0 ||
                        (endpoint->DgBufferredReceiveCount*sizeof (AFD_BUFFER_TAG)) <
                            endpoint->Common.Datagram.MaxBufferredReceiveBytes) ) {
                afdBuffer = AfdGetBufferTag( sourceAddressLength, endpoint->OwningProcess );
                if ( afdBuffer != NULL) {

                    //
                    // Save the status do distinguish this from
                    // normal datagram IRP
                    //
                    afdBuffer->Status = Status;
                    afdBuffer->DataLength = 0;
                    afdBuffer->DatagramFlags = 0;
                    afdBuffer->DataOffset = 0;
                    RtlCopyMemory(
                        afdBuffer->TdiInfo.RemoteAddress,
                        sourceAddress,
                        sourceAddressLength
                        );
                    afdBuffer->TdiInfo.RemoteAddressLength = sourceAddressLength;

                    //
                    // Place the buffer on this endpoint's list of bufferred datagrams
                    // and update the counts of datagrams and datagram bytes on the
                    // endpoint.
                    //

                    InsertTailList(
                        &endpoint->ReceiveDatagramBufferListHead,
                        &afdBuffer->BufferListEntry
                        );

                    endpoint->DgBufferredReceiveCount++;

                    //
                    // All done.  Release the lock and tell the provider that we
                    // took all the data.
                    //
                    AfdIndicateEventSelectEvent(
                        endpoint,
                        AFD_POLL_RECEIVE,
                        STATUS_SUCCESS
                        );
                    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                    //
                    // Indicate that it is possible to receive on the endpoint now.
                    //

                    AfdIndicatePollEvent(
                        endpoint,
                        AFD_POLL_RECEIVE,
                        STATUS_SUCCESS
                        );
                }
                else {
                    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                }
            }
            else {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }

            //
            // If there was a peek IRP on the endpoint, complete it now.
            //

            if ( irp != NULL ) {
                irp->IoStatus.Status = Status;
                irp->IoStatus.Information = 0;
                AfdSetupReceiveDatagramIrp (irp, NULL, 0, NULL, 0,
                                sourceAddress,
                                sourceAddressLength,
                                0
                                );
                IoCompleteRequest( irp, AfdPriorityBoost  );
            }
        }
        break;
    }

Exit:
    DEREFERENCE_ENDPOINT (endpoint);
    return STATUS_SUCCESS;

} // AfdErrorEventHandler


VOID
AfdInsertNewEndpointInList (
    IN PAFD_ENDPOINT Endpoint
    )

/*++

Routine Description:

    Inserts a new endpoint in the global list of AFD endpoints.  If this
    is the first endpoint, then this routine does various allocations to
    prepare AFD for usage.

Arguments:

    Endpoint - the endpoint being added.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Acquire a lock which prevents other threads from performing this
    // operation.
    //
    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );

    InterlockedIncrement(
        &AfdEndpointsOpened
        );

    //
    // If the list of endpoints is empty, do some allocations.
    //

    if ( IsListEmpty( &AfdEndpointListHead ) ) {

        //
        // Tell MM to revert to normal paging semantics.
        //

        if (!AfdLoaded) {
            MmResetDriverPaging( (PVOID)DriverEntry );
            AfdLoaded = (PKEVENT)1;
        }

        //
        // Lock down the AFD section that cannot be pagable if any
        // sockets are open.
        //

        ASSERT( AfdDiscardableCodeHandle == NULL );

        AfdDiscardableCodeHandle = MmLockPagableCodeSection( (PVOID)AfdGetBufferFast );
        ASSERT( AfdDiscardableCodeHandle != NULL );

        //
        // Add extra reference to afd device object so that the
        // driver cannot be unloaded while at least one endpoint
        // is in the list.
        //
        ObReferenceObject (AfdDeviceObject);

        //
        // Setup 30 sec timer to flush lookaside lists
        // if too many items are there for too long.
        //
        KeInitializeTimer (&AfdLookasideLists->Timer);
        KeInitializeDpc (&AfdLookasideLists->Dpc, AfdCheckLookasideLists, AfdLookasideLists);
        {
            LARGE_INTEGER   dueTime;
            dueTime.QuadPart = -(30*1000*1000*10);
            KeSetTimerEx (&AfdLookasideLists->Timer,
                            dueTime,
                            30*1000,
                            &AfdLookasideLists->Dpc);
        }

    }
    ASSERT (AfdLoaded==(PKEVENT)1);

    //
    // Add the endpoint to the list(s).
    //

    InsertHeadList(
        &AfdEndpointListHead,
        &Endpoint->GlobalEndpointListEntry
        );

    if( Endpoint->GroupType == GroupTypeConstrained ) {
        InsertHeadList(
            &AfdConstrainedEndpointListHead,
            &Endpoint->ConstrainedEndpointListEntry
            );
    }

    //
    // Release the lock and return.
    //

    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();

    return;

} // AfdInsertNewEndpointInList


VOID
AfdRemoveEndpointFromList (
    IN PAFD_ENDPOINT Endpoint
    )

/*++

Routine Description:

    Removes a new endpoint from the global list of AFD endpoints.  If
    this is the last endpoint in the list, then this routine does
    various deallocations to save resource utilization.

Arguments:

    Endpoint - the endpoint being removed.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Acquire a lock which prevents other threads from performing this
    // operation.
    //

    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );

    InterlockedIncrement(
        &AfdEndpointsClosed
        );

    //
    // Remove the endpoint from the list(s).
    //

    RemoveEntryList(
        &Endpoint->GlobalEndpointListEntry
        );

    if( Endpoint->GroupType == GroupTypeConstrained ) {
        RemoveEntryList(
            &Endpoint->ConstrainedEndpointListEntry
            );
    }

    //
    // If the list of endpoints is now empty, do some deallocations.
    //

    if ( IsListEmpty( &AfdEndpointListHead ) ) {

        //
        // Stop the timer that scans lookaside lists.
        //
        KeCancelTimer (&AfdLookasideLists->Timer);

        //
        // Make sure DPC is completed since we may need to reinitialize
        // it after we exit this routine and new endpoint is created again.
        //
        KeRemoveQueueDpc (&AfdLookasideLists->Dpc);

        //
        // Make sure that DPC routine has actually completed before
        // unlocking code section where this routine resides.
        //
        // Not exported from kernel - so don't put the routine
        // into the discardable code section until it is.
        //
        // KeFlushQueuedDpcs ();

        //
        // We don't need PnP stuff anymore.
        //

        AfdDeregisterPnPHandlers (NULL);

        //
        // Unlock the AFD section that can be pagable when no sockets
        // are open.
        //

        ASSERT( IsListEmpty( &AfdConstrainedEndpointListHead ) );
        ASSERT( AfdDiscardableCodeHandle != NULL );

        MmUnlockPagableImageSection( AfdDiscardableCodeHandle );

        AfdDiscardableCodeHandle = NULL;

        //
        // Queue off an executive worker thread to unlock AFD.  We do
        // this using special hacks in the AFD worker thread code so
        // that we don't need to acuire a spin lock after the unlock.
        //

        AfdQueueWorkItem( AfdUnlockDriver, &AfdUnloadWorker );
    }

    //
    // Release the lock and return.
    //

    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();

    return;

} // AfdRemoveEndpointFromList


VOID
AfdUnlockDriver (
    IN PVOID Context
    )
{
    UNREFERENCED_PARAMETER (Context);
    //
    // Acquire a lock which prevents other threads from performing this
    // operation.
    //
    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );

    //
    // Test whether the endpoint list remains empty.  If it is still
    // empty, we can proceed with unlocking the driver.  If a new
    // endpoint has been placed on the list, then do not make AFD
    // pagable.
    //

    if ( IsListEmpty( &AfdEndpointListHead ) ) {

        //
        // Tell MM that it can page all of AFD as it desires.
        //
        if (AfdLoaded!=NULL && AfdLoaded!=(PKEVENT)1) {
            KeSetEvent (AfdLoaded, AfdPriorityBoost, FALSE);
        }
        else {
            MmPageEntireDriver( (PVOID)DriverEntry );
        }

        AfdLoaded = NULL;

    }

    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();

} // AfdUnlockDriver


NTSTATUS
AfdQueryHandles (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )

/*++

Routine Description:

    Returns information about the TDI handles corresponding to an AFD
    endpoint.  NULL is returned for either the connection handle or the
    address handle (or both) if the endpoint does not have that particular
    object.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    AFD_HANDLE_INFO handleInfo;
    ULONG getHandleInfo;
    NTSTATUS status;

    UNREFERENCED_PARAMETER (IoctlCode);
    PAGED_CODE( );

    //
    // Set up local pointers.
    //

    *Information = 0;
    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Make sure that the input and output buffers are large enough.
    //

#ifdef _WIN64
    if (IoIs32bitProcess (NULL)) {
        if ( InputBufferLength < sizeof(getHandleInfo) ||
                OutputBufferLength < sizeof(AFD_HANDLE_INFO32) ) {
            return STATUS_BUFFER_TOO_SMALL;
        }
    }
    else
#endif
    {
        if ( InputBufferLength < sizeof(getHandleInfo) ||
                OutputBufferLength < sizeof(handleInfo) ) {
            return STATUS_BUFFER_TOO_SMALL;
        }
    }

    AFD_W4_INIT status = STATUS_SUCCESS;
    try {
        //
        // Validate the input structure if it comes from the user mode
        // application
        //

        if (RequestorMode != KernelMode ) {
            ProbeForReadSmallStructure (InputBuffer,
                            sizeof (getHandleInfo),
                            PROBE_ALIGNMENT(ULONG));
        }

        //
        // Make local copies of the embeded pointer and parameters
        // that we will be using more than once in case malicios
        // application attempts to change them while we are
        // validating
        //

        getHandleInfo = *((PULONG)InputBuffer);

    } except( AFD_EXCEPTION_FILTER (status) ) {
        ASSERT (NT_ERROR (status));
        return status;
    }

    //
    // If no handle information or invalid handle information was
    // requested, fail.
    //

    if ( (getHandleInfo &
             ~(AFD_QUERY_ADDRESS_HANDLE | AFD_QUERY_CONNECTION_HANDLE)) != 0 ||
         getHandleInfo == 0 ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Initialize the output buffer.
    //

    handleInfo.TdiAddressHandle = NULL;
    handleInfo.TdiConnectionHandle = NULL;

    //
    // If the caller requested a TDI address handle and we have an
    // address handle for this endpoint, dupe the address handle to the
    // user process.
    //

    if ( (getHandleInfo & AFD_QUERY_ADDRESS_HANDLE) != 0 &&
             (endpoint->State == AfdEndpointStateBound ||
                endpoint->State == AfdEndpointStateConnected) &&
             endpoint->AddressFileObject != NULL ) {

        // If transport does not support new TDI_SERVICE_FORCE_ACCESS_CHECK_FLAG
        // we get the maximum possible access for the handle so that helper
        // DLL can do what it wants with it.  Of course this compromises the
        // security, but we can't enforce it without the transport cooperation.
        status = ObOpenObjectByPointer(
                     endpoint->AddressFileObject,
                     OBJ_CASE_INSENSITIVE,
                     NULL,
                     MAXIMUM_ALLOWED,
                     *IoFileObjectType,
                     (KPROCESSOR_MODE)((endpoint->TdiServiceFlags&TDI_SERVICE_FORCE_ACCESS_CHECK)
                        ? RequestorMode
                        : KernelMode),
                     &handleInfo.TdiAddressHandle
                     );
        if ( !NT_SUCCESS(status) ) {
            return status;
        }
    }

    //
    // If the caller requested a TDI connection handle and we have a
    // connection handle for this endpoint, dupe the connection handle
    // to the user process.  Note that we can have a connection and
    // TDI handle when endpoint is in process of being connected.
    // We should not return the connection handle until enpoint is
    // fully connected or it may go away while we are trying to
    // reference it if connection fails (bug 93096)
    //

    if ( (getHandleInfo & AFD_QUERY_CONNECTION_HANDLE) != 0 &&
             (endpoint->Type & AfdBlockTypeVcConnecting) == AfdBlockTypeVcConnecting &&
             endpoint->State == AfdEndpointStateConnected &&
             ((connection=AfdGetConnectionReferenceFromEndpoint (endpoint))!=NULL)) {

        ASSERT( connection->Type == AfdBlockTypeConnection );
        ASSERT( connection->FileObject != NULL );

        // If transport does not support new TDI_SERVICE_FORCE_ACCESS_CHECK_FLAG
        // we get the maximum possible access for the handle so that helper
        // DLL can do what it wants with it.  Of course this compromises the
        // security, but we can't enforce it without the transport cooperation.

        status = ObOpenObjectByPointer(
                     connection->FileObject,
                     OBJ_CASE_INSENSITIVE,
                     NULL,
                     MAXIMUM_ALLOWED,
                     *IoFileObjectType,
                     (KPROCESSOR_MODE)((endpoint->TdiServiceFlags & TDI_SERVICE_FORCE_ACCESS_CHECK)
                        ? RequestorMode
                        : KernelMode),
                     &handleInfo.TdiConnectionHandle
                     );

        DEREFERENCE_CONNECTION (connection);

        if ( !NT_SUCCESS(status) ) {
            if ( handleInfo.TdiAddressHandle != NULL ) {
                //
                // Call ObCloseHandle directly (instead of ZwClose) to be able
                // to set PreviousMode. ZwClose goes thru TRAP which always
                // results in PreviousMode==KernelMode which will cause
                // bugcheck if app managed to close this handle between our
                // creating it and now
                //
                ObCloseHandle( handleInfo.TdiAddressHandle, RequestorMode );
            }
            return status;
        }
    }

    AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            if (RequestorMode!=KernelMode) {
                ProbeForWrite (OutputBuffer,
                                sizeof (AFD_HANDLE_INFO32),
                                PROBE_ALIGNMENT32 (AFD_HANDLE_INFO32));
            }
            ((PAFD_HANDLE_INFO32)OutputBuffer)->TdiAddressHandle = 
                (VOID *  POINTER_32)HandleToUlong(handleInfo.TdiAddressHandle);
            ((PAFD_HANDLE_INFO32)OutputBuffer)->TdiConnectionHandle = 
                (VOID *  POINTER_32)HandleToUlong(handleInfo.TdiConnectionHandle);
            *Information = sizeof (AFD_HANDLE_INFO32);
        }
        else
#endif
        {
            if (RequestorMode!=KernelMode) {
                ProbeAndWriteStructure (((PAFD_HANDLE_INFO)OutputBuffer),
                                            handleInfo, 
                                            AFD_HANDLE_INFO);
            }
            else {
                *((PAFD_HANDLE_INFO)OutputBuffer) = handleInfo;
            }
            *Information = sizeof (handleInfo);
        }

    } except( AFD_EXCEPTION_FILTER (status) ) {
        ASSERT (NT_ERROR (status));

        if ( handleInfo.TdiAddressHandle != NULL ) {
            //
            // Call ObCloseHandle directly (instead of ZwClose) to be able
            // to set PreviousMode. ZwClose goes thru TRAP which always
            // results in PreviousMode==KernelMode which will cause
            // bugcheck if app managed to close this handle between our
            // creating it and now
            //
            ObCloseHandle( handleInfo.TdiAddressHandle, RequestorMode );
        }
        if ( handleInfo.TdiConnectionHandle != NULL ) {
            //
            // Call ObCloseHandle directly (instead of ZwClose) to be able
            // to set PreviousMode. ZwClose goes thru TRAP which always
            // results in PreviousMode==KernelMode which will cause
            // bugcheck if app managed to close this handle between our
            // creating it and now
            //
            ObCloseHandle( handleInfo.TdiConnectionHandle, RequestorMode );
        }
        return status;
    }

    return STATUS_SUCCESS;

} // AfdQueryHandles


NTSTATUS
AfdGetInformation (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )

/*++

Routine Description:

    Gets information in the endpoint.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    AFD_INFORMATION afdInfo;
    NTSTATUS status;
    LONGLONG currentTime;
    LONGLONG connectTime;

    UNREFERENCED_PARAMETER (IoctlCode);
    PAGED_CODE( );

    //
    // Initialize number of bytes returned to zero.
    //

    *Information = 0;

    //
    // Initialize local variables.
    //

    endpoint = FileObject->FsContext;
    ASSERT(IS_AFD_ENDPOINT_TYPE(endpoint));
    if (endpoint->Type==AfdBlockTypeHelper ||
            endpoint->Type==AfdBlockTypeSanHelper)
        return STATUS_INVALID_PARAMETER;

    RtlZeroMemory(&afdInfo, sizeof(afdInfo));
    status = STATUS_SUCCESS;

    //
    // Make sure that the input and output buffers are large enough.
    //

#ifdef _WIN64
    {
        C_ASSERT(sizeof(AFD_INFORMATION) == sizeof(AFD_INFORMATION32));
    }
#endif

    if ((InputBufferLength < sizeof(afdInfo)) ||
        (OutputBufferLength < sizeof(afdInfo))) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    AFD_W4_INIT ASSERT(status == STATUS_SUCCESS);

    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (afdInfo),
                                PROBE_ALIGNMENT32(AFD_INFORMATION32));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            afdInfo.InformationType = ((PAFD_INFORMATION32)InputBuffer)->InformationType;
        }
        else
#endif _WIN64 
        {
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (afdInfo),
                                PROBE_ALIGNMENT(AFD_INFORMATION));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            afdInfo.InformationType = ((PAFD_INFORMATION)InputBuffer)->InformationType;
        }

    } except( AFD_EXCEPTION_FILTER (status) ) {
        ASSERT (NT_ERROR (status));
        return status;
    }

    //
    // Set up appropriate information in the endpoint.
    //

    switch ( afdInfo.InformationType ) {

    case AFD_MAX_PATH_SEND_SIZE:
        if (InputBufferLength>sizeof (afdInfo) &&
                (endpoint->State==AfdEndpointStateBound || endpoint->State==AfdEndpointStateConnected)) {
            TDI_REQUEST_KERNEL_QUERY_INFORMATION kernelQueryInfo;
            TDI_CONNECTION_INFORMATION connectionInfo;
            PMDL    mdl;
            InputBuffer = (PUCHAR)InputBuffer+sizeof (afdInfo);
            InputBufferLength -= sizeof (afdInfo);
            mdl = IoAllocateMdl(
                            InputBuffer,        // VirtualAddress
                            InputBufferLength,  // Length
                            FALSE,              // SecondaryBuffer
                            TRUE,               // ChargeQuota
                            NULL                // Irp
                            );
            if (mdl!=NULL) {

                AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
                try {
                    MmProbeAndLockPages(
                        mdl,                        // MemoryDescriptorList
                        RequestorMode,              // AccessMode
                        IoWriteAccess              // Operation
                        );
                    status = STATUS_SUCCESS;
                }
                except (AFD_EXCEPTION_FILTER (status)) {
                    ASSERT(NT_ERROR (status));
                }
                if (NT_SUCCESS (status)) {
                    connectionInfo.RemoteAddress = MmGetSystemAddressForMdlSafe (mdl, LowPagePriority);
                    if (connectionInfo.RemoteAddress!=NULL) {
                        connectionInfo.RemoteAddressLength = InputBufferLength;
                        //
                        // Set up a query to the TDI provider to obtain the largest
                        // datagram that can be sent to a particular address.
                        //

                        kernelQueryInfo.QueryType = TDI_QUERY_MAX_DATAGRAM_INFO;
                        kernelQueryInfo.RequestConnectionInformation = &connectionInfo;

                        connectionInfo.UserDataLength = 0;
                        connectionInfo.UserData = NULL;
                        connectionInfo.OptionsLength = 0;
                        connectionInfo.Options = NULL;

                        //
                        // Ask the TDI provider for the information.
                        //

                        status = AfdIssueDeviceControl(
                                     endpoint->AddressFileObject,
                                     &kernelQueryInfo,
                                     sizeof(kernelQueryInfo),
                                     &afdInfo.Information.Ulong,
                                     sizeof(afdInfo.Information.Ulong),
                                     TDI_QUERY_INFORMATION
                                     );
                    }
                    else
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    MmUnlockPages (mdl);
                }
                IoFreeMdl (mdl);
            }
            else
                status = STATUS_INSUFFICIENT_RESOURCES;
            //
            // If the request succeeds, use this information.  Otherwise,
            // fall through and use the transport's global information.
            // This is done because not all transports support this
            // particular TDI request, and for those which do not the
            // global information is a reasonable approximation.
            //

            if ( NT_SUCCESS(status) ) {
                break;
            }
        }


    case AFD_MAX_SEND_SIZE:
        {
            //
            // With PnP some provider info fields can change over time.
            // so we query them each time we are asked.
            //
            TDI_PROVIDER_INFO   providerInfo;
            status = AfdQueryProviderInfo (
                        &endpoint->TransportInfo->TransportDeviceName,
#ifdef _AFD_VARIABLE_STACK_
                        NULL,
#endif //_AFD_VARIABLE_STACK_
                        &providerInfo);

            if (NT_SUCCESS (status)) {
                //
                // Return the MaxSendSize or MaxDatagramSendSize from the
                // TDI_PROVIDER_INFO based on whether or not this is a datagram
                // endpoint.
                //

                if ( IS_DGRAM_ENDPOINT(endpoint) ) {
                    afdInfo.Information.Ulong = providerInfo.MaxDatagramSize;
                } else {
                    afdInfo.Information.Ulong = providerInfo.MaxSendSize;
                }
            }

        }
        break;

    case AFD_SENDS_PENDING:

        //
        // If this is an endpoint on a bufferring transport, no sends
        // are pending in AFD.  If it is on a nonbufferring transport,
        // return the count of sends pended in AFD.
        //

        if ( IS_TDI_BUFFERRING(endpoint) || 
                (endpoint->Type & AfdBlockTypeVcConnecting) != AfdBlockTypeVcConnecting ||
                endpoint->State != AfdEndpointStateConnected ||
                ((connection=AfdGetConnectionReferenceFromEndpoint (endpoint))==NULL)) {
            afdInfo.Information.Ulong = 0;
        } else {
            afdInfo.Information.Ulong = connection->VcBufferredSendCount;
            DEREFERENCE_CONNECTION (connection);
        }

        break;

    case AFD_RECEIVE_WINDOW_SIZE:

        //
        // Return the default receive window.
        //

        afdInfo.Information.Ulong = AfdReceiveWindowSize;
        break;

    case AFD_SEND_WINDOW_SIZE:

        //
        // Return the default send window.
        //

        afdInfo.Information.Ulong = AfdSendWindowSize;
        break;

    case AFD_CONNECT_TIME:

        //
        // If the endpoint is not yet connected, return -1.  Otherwise,
        // calculate the number of seconds that the connection has been
        // active.
        //

        if ( endpoint->State != AfdEndpointStateConnected ||
                 IS_DGRAM_ENDPOINT (endpoint) ||
                 (connection=AfdGetConnectionReferenceFromEndpoint( endpoint ))==NULL) {

            afdInfo.Information.Ulong = 0xFFFFFFFF;

        } else {

            ASSERT( connection->Type == AfdBlockTypeConnection );

            //
            // Calculate how long the connection has been active by
            // subtracting the time at which the connection started from
            // the current time.  Note that we convert the units of the
            // time value from 100s of nanoseconds to seconds.
            //

            currentTime = KeQueryInterruptTime ();

            connectTime = (currentTime - connection->ConnectTime);
            connectTime /= 10*1000*1000;

            //
            // We can safely convert this to a ULONG because it takes
            // 127 years to overflow a ULONG counting seconds.  The
            // bizarre conversion to a LARGE_INTEGER is required to
            // prevent the compiler from optimizing out the full 64-bit
            // division above.  Without this, the compiler would do only
            // a 32-bit division and lose some information.
            //

            //afdInfo->Information.Ulong = (ULONG)connectTime;
            afdInfo.Information.Ulong = ((PLARGE_INTEGER)&connectTime)->LowPart;

            DEREFERENCE_CONNECTION (connection);
        }

        break;

    case AFD_GROUP_ID_AND_TYPE : {

            PAFD_GROUP_INFO groupInfo;

            groupInfo = (PAFD_GROUP_INFO)&afdInfo.Information.LargeInteger;

            //
            // Return the endpoint's group ID and group type.
            //

            groupInfo->GroupID = endpoint->GroupID;
            groupInfo->GroupType = endpoint->GroupType;

        }
        break;

    default:

        return STATUS_INVALID_PARAMETER;
    }


    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForWrite (OutputBuffer,
                                sizeof (afdInfo),
                                PROBE_ALIGNMENT32(AFD_INFORMATION32));
            }

            //
            // Copy parameters back to application's memory
            //

            RtlMoveMemory(InputBuffer,
                            &afdInfo,
                            sizeof (afdInfo));
        }
        else
#endif _WIN64 
        {
            //
            // Validate the output structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeAndWriteStructure (((PAFD_INFORMATION)OutputBuffer),
                                                afdInfo,
                                                AFD_INFORMATION);
            }
            else {
                //
                // Copy parameters back to application's memory
                //
                *((PAFD_INFORMATION)OutputBuffer) = afdInfo;
            }
        }

    } except( AFD_EXCEPTION_FILTER (status) ) {
        ASSERT (NT_ERROR (status));
        return status;
    }

    *Information = sizeof(afdInfo);

    return STATUS_SUCCESS;

} // AfdGetInformation


NTSTATUS
AfdSetInformation (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )

/*++

Routine Description:

    Sets information in the endpoint.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    AFD_INFORMATION afdInfo;
    NTSTATUS status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    UNREFERENCED_PARAMETER (IoctlCode);
    UNREFERENCED_PARAMETER (OutputBuffer);
    UNREFERENCED_PARAMETER (OutputBufferLength);

    //
    // Nothing to return.
    //

    *Information = 0;

    //
    // Initialize locals for cleanup.
    //

    connection = NULL;
    status = STATUS_SUCCESS;

    //
    // Set up local pointers.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    if (endpoint->Type==AfdBlockTypeHelper ||
            endpoint->Type==AfdBlockTypeSanHelper)
        return STATUS_INVALID_PARAMETER;

    //
    // Make sure that the input buffer is large enough.
    //

#ifdef _WIN64
    {
        C_ASSERT (sizeof (AFD_INFORMATION)==sizeof (AFD_INFORMATION32));
    }
#endif

    if ( InputBufferLength < sizeof(afdInfo) ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (afdInfo),
                                PROBE_ALIGNMENT32(AFD_INFORMATION32));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            RtlMoveMemory (&afdInfo, InputBuffer, sizeof (afdInfo));
        }
        else
#endif _WIN64 
        {
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (afdInfo),
                                PROBE_ALIGNMENT(AFD_INFORMATION));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            afdInfo = *((PAFD_INFORMATION)InputBuffer);
        }

    } except( AFD_EXCEPTION_FILTER (status) ) {
        ASSERT (NT_ERROR (status));
        return status;
    }

    //
    // Set up appropriate information in the endpoint.
    //

    switch ( afdInfo.InformationType ) {

    case AFD_NONBLOCKING_MODE:

        //
        // Set the blocking mode of the endpoint.  If TRUE, send and receive
        // calls on the endpoint will fail if they cannot be completed
        // immediately.
        //

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        endpoint->NonBlocking = (afdInfo.Information.Boolean!=FALSE);
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        break;

    case AFD_CIRCULAR_QUEUEING:

        //
        // Enables circular queuing on the endpoint.
        //

        if( !IS_DGRAM_ENDPOINT( endpoint ) ) {

            status =  STATUS_INVALID_PARAMETER;
            goto Cleanup;

        }

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        endpoint->Common.Datagram.CircularQueueing = (afdInfo.Information.Boolean!=FALSE);
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        break;

     case AFD_REPORT_PORT_UNREACHABLE:

        //
        // Enables reporting PORT_UNREACHABLE to the app.
        //

        if( !IS_DGRAM_ENDPOINT( endpoint ) ) {

            status =  STATUS_INVALID_PARAMETER;
            goto Cleanup;

        }

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        endpoint->Common.Datagram.DisablePUError = (afdInfo.Information.Boolean==FALSE);
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        break;

    case AFD_INLINE_MODE:

        //
        // Set the inline mode of the endpoint.  If TRUE, a receive for
        // normal data will be completed with either normal data or
        // expedited data.  If the endpoint is connected, we need to
        // tell the TDI provider that the endpoint is inline so that it
        // delivers data to us in order.  If the endpoint is not yet
        // connected, then we will set the inline mode when we create
        // the TDI connection object.
        //

        if ( (endpoint->Type & AfdBlockTypeVcConnecting) == AfdBlockTypeVcConnecting ) {
            connection = AfdGetConnectionReferenceFromEndpoint( endpoint );
            if (connection!=NULL) {
                status = AfdSetInLineMode(
                             connection,
                             afdInfo.Information.Boolean
                             );
                if ( !NT_SUCCESS(status) ) {
                    goto Cleanup;
                }
            }
        }

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        endpoint->InLine = (afdInfo.Information.Boolean!=FALSE);
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        break;

    case AFD_RECEIVE_WINDOW_SIZE:
    case AFD_SEND_WINDOW_SIZE: {

        PCLONG maxBytes;

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        //
        // First determine where the appropriate limits are stored in the
        // connection or endpoint.  We do this so that we can use common
        // code to charge quota and set the new counters.
        //

        if ( (endpoint->Type & AfdBlockTypeVcConnecting) == AfdBlockTypeVcConnecting &&
                endpoint->State == AfdEndpointStateConnected &&
                endpoint->Common.VcConnecting.Connection!=NULL ) {

            if ( afdInfo.InformationType == AFD_SEND_WINDOW_SIZE ) {
                maxBytes = &endpoint->Common.VcConnecting.Connection->MaxBufferredSendBytes;
            } else {
                maxBytes = &endpoint->Common.VcConnecting.Connection->MaxBufferredReceiveBytes;
            }

        } else if ( IS_DGRAM_ENDPOINT(endpoint) ) {

            if ( afdInfo.InformationType == AFD_SEND_WINDOW_SIZE ) {
                maxBytes = &endpoint->Common.Datagram.MaxBufferredSendBytes;
            } else {
                maxBytes = &endpoint->Common.Datagram.MaxBufferredReceiveBytes;
            }


        } else if (IS_SAN_ENDPOINT (endpoint) ) {
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
            status = STATUS_SUCCESS;
            goto Cleanup;
        }
        else {
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
            status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Make sure that we always allow at least one message to be
        // bufferred on an endpoint.
        //


        if ( afdInfo.Information.Ulong == 0 ) {

            //
            // Don't allow the max receive bytes to go to zero, but
            // max send bytes IS allowed to go to zero because it has
            // special meaning: specifically, do not buffer sends.
            //

            if ( afdInfo.InformationType == AFD_RECEIVE_WINDOW_SIZE ) {
                afdInfo.Information.Ulong = 1;
            }
            else {
                ASSERT (afdInfo.InformationType == AFD_SEND_WINDOW_SIZE);
                endpoint->DisableFastIoSend = TRUE;
            }
        }
        else {
            if( afdInfo.InformationType == AFD_SEND_WINDOW_SIZE ) {
                endpoint->DisableFastIoSend = FALSE;
            }
        }

        //
        // Set up the new information in the AFD internal structure.
        //

        *maxBytes = (CLONG)afdInfo.Information.Ulong;
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        break;
    }

    default:

        status = STATUS_INVALID_PARAMETER;
    }

Cleanup:
    if (connection!=NULL) {
        DEREFERENCE_CONNECTION (connection);
    }

    return status;

} // AfdSetInformation


NTSTATUS
AfdSetSecurity (
    IN  PAFD_ENDPOINT           Endpoint,
    IN  SECURITY_INFORMATION    SecurityInformation,
    IN  PSECURITY_DESCRIPTOR    SecurityDescriptor
    )
{
    NTSTATUS                status;
    PSECURITY_DESCRIPTOR    newSd, oldSd, cachedSd;
    
    PAGED_CODE ();

    ASSERT(Endpoint->TransportInfo ||
           Endpoint->Type==AfdBlockTypeHelper ||
           Endpoint->Type==AfdBlockTypeSanHelper);

    if (Endpoint->TransportInfo &&
        Endpoint->TransportInfo->InfoValid) {
        //
        // Transport has already been loaded
        // ensure we have up to date flags
        //
        Endpoint->TdiServiceFlags = Endpoint->TransportInfo->ProviderInfo.ServiceFlags;
        if (!IS_TDI_ADDRESS_SECURITY (Endpoint)) {
            //
            // SD is not supported by the transport -> bail.
            // IO manager will still succeed the request and
            // will assume a World descriptor (as it does for FAT).
            //
            status = STATUS_INVALID_DEVICE_REQUEST;
            goto complete;
        }
    }
    else {
        //
        // We do not know yet if we can support this feature, fail it.
        //
        status = STATUS_NOT_IMPLEMENTED;
        goto complete;
    }

    //
    // Protect SD setting with state change lock.
    //
    if (!AFD_START_STATE_CHANGE (Endpoint, AfdEndpointStateOpen)) {
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto complete;
    }


    if (Endpoint->State!=AfdEndpointStateOpen) {
        //
        // We may want to call transport if endpoint state
        // is bound or connected.
        //
        status = STATUS_NOT_IMPLEMENTED;
        goto complete_state_change;
    }

    //
    //  Call the security routine to do the actual set
    //

    newSd = oldSd = Endpoint->SecurityDescriptor;
    if (newSd==NULL) {
        ACCESS_STATE    accessState;
        AUX_ACCESS_DATA auxData;
        status = SeCreateAccessState (&accessState, 
                                        &auxData,
                                        GENERIC_ALL, 
                                        IoGetFileObjectGenericMapping());
        if (NT_SUCCESS (status)) {
            SeLockSubjectContext (&accessState.SubjectSecurityContext);
            status = SeAssignSecurity (
                NULL,                                       // Parent SD - not used
                SecurityDescriptor,
                &newSd,
                FALSE,
                &accessState.SubjectSecurityContext,
                IoGetFileObjectGenericMapping(),
                PagedPool);
            SeUnlockSubjectContext (&accessState.SubjectSecurityContext);
            SeDeleteAccessState (&accessState);
        }
    }
    else {

        status = SeSetSecurityDescriptorInfo( NULL,
                                              &SecurityInformation,
                                              SecurityDescriptor,
                                              &newSd,
                                              PagedPool,
                                              IoGetFileObjectGenericMapping() );
    }

    if (NT_SUCCESS(status)) {
        status = ObLogSecurityDescriptor (newSd,
                                          &cachedSd,
                                          1);
        ExFreePool (newSd);
        if (NT_SUCCESS(status)) {
            Endpoint->SecurityDescriptor = cachedSd;
            if (oldSd!=NULL) {
                ObDereferenceSecurityDescriptor( oldSd, 1 );
            }
        }
    }

complete_state_change:
    AFD_END_STATE_CHANGE (Endpoint);

complete:
    return status;
}


NTSTATUS
AfdGetSecurity (
    IN  PAFD_ENDPOINT           Endpoint,
    IN  SECURITY_INFORMATION    SecurityInformation,
    IN  ULONG                   BufferLength,
    OUT PVOID                   Buffer,
    OUT PSIZE_T                 DataLength
    )
{
    NTSTATUS                status;
    PSECURITY_DESCRIPTOR    sd;
    PAGED_CODE ();

    ASSERT(Endpoint->TransportInfo ||
           Endpoint->Type==AfdBlockTypeHelper ||
           Endpoint->Type==AfdBlockTypeSanHelper);

    if (Endpoint->TransportInfo &&
        Endpoint->TransportInfo->InfoValid) {
        //
        // Transport has already been loaded
        // ensure we have up to date flags
        //
        Endpoint->TdiServiceFlags = Endpoint->TransportInfo->ProviderInfo.ServiceFlags;
        if (!IS_TDI_ADDRESS_SECURITY (Endpoint)) {
            //
            // SD is not supported by the transport -> bail.
            // IO manager will still succeed the request and
            // will return a World descriptor (as it does for FAT).
            //
            status = STATUS_INVALID_DEVICE_REQUEST;
            goto complete;
        }
    }
    else {
        //
        // We do not know yet if we can support this feature -> bail.
        // IO manager will still succeed the request and
        // will return a World descriptor (as it does for FAT).
        //
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto complete;
    }

    if (!AFD_PREVENT_STATE_CHANGE (Endpoint)) {
        //
        // IO manager will still succeed the request and
        // will return a World descriptor (as it does for FAT).
        //
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto complete;
    }

    if (Endpoint->State!=AfdEndpointStateOpen) {
        //
        // IO manager will still succeed the request and
        // will return a World descriptor (as it does for FAT).
        //
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto complete_state_change;
    }

    sd = Endpoint->SecurityDescriptor;
    if (sd==NULL) {
        ACCESS_STATE    accessState;
        AUX_ACCESS_DATA auxData;
        status = SeCreateAccessState (&accessState, 
                                        &auxData,
                                        GENERIC_ALL, 
                                        IoGetFileObjectGenericMapping());
        if (!NT_SUCCESS (status)) {
            goto complete_state_change;
        }
        SeLockSubjectContext (&accessState.SubjectSecurityContext);
        status = SeAssignSecurity (
            NULL,                                       // Parent SD - not used
            NULL,
            &sd,
            FALSE,
            &accessState.SubjectSecurityContext,
            IoGetFileObjectGenericMapping(),
            PagedPool);
        SeUnlockSubjectContext (&accessState.SubjectSecurityContext);
        SeDeleteAccessState (&accessState);
    }

    //
    //  Call the security routine to do the actual query
    //

    status = SeQuerySecurityDescriptorInfo( &SecurityInformation,
                                            Buffer,
                                            &BufferLength,
                                            &sd );

    if (status == STATUS_BUFFER_TOO_SMALL ) {
        *DataLength = BufferLength;
        status = STATUS_BUFFER_OVERFLOW;
    }

    if (sd!=Endpoint->SecurityDescriptor) {
        ExFreePool (sd);
    }

complete_state_change:
    AFD_REALLOW_STATE_CHANGE (Endpoint);

complete:
    return status;
}


NTSTATUS
AfdSetInLineMode (
    IN PAFD_CONNECTION Connection,
    IN BOOLEAN InLine
    )

/*++

Routine Description:

    Sets a connection to be in inline mode.  In inline mode, urgent data
    is delivered in the order in which it is received.  We must tell the
    TDI provider about this so that it indicates data in the proper
    order.

Arguments:

    Connection - the AFD connection to set as inline.

    InLine - TRUE to enable inline mode, FALSE to disable inline mode.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully
        performed.

--*/

{
    //
    // Since TCP does not implement this correctly, do everything in AFD!!!
    // Background:
    //  When this options is enabled, TCP indicates all the data as normal
    //  data, so we end up mixing it together which is against the spec.
    //  Also, since TCP stops reporting expedited data, SIOATMARK fails
    //  to report presence of OOB data altogether.
    //  When handling OOB data completely inside AFD we can only run into
    //  one problem:  if AFD runs out of its receive buffer for the socket
    //  and refuses to accept more data from TCP so that TCP buffers it
    //  within itself, any OOB data arriving at this point can be indicated
    //  out of order (not inline).
    //
    // Well, this appears to be even worse. Some apps (SQL) send more than
    // one byte of OOB data, TCP can only send one, so it sends everything
    // but the last byte as normal and the last one as OOB.  It then turns
    // around and indicates the OOB (last byte) first which breaks the
    // ordering required by OOBINLINE.
    // In the end, we are broken one way or the other, so keep the things
    // the way they were for number of years and wait for TCP to fix. 
    NTSTATUS status;
    PTCP_REQUEST_SET_INFORMATION_EX setInfoEx;
    TCPSocketOption *option;
    UCHAR buffer[sizeof(*setInfoEx) + sizeof(*option)];
    IO_STATUS_BLOCK ioStatusBlock;
    KEVENT event;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE( );

    //
    // Initialize the TDI information buffers.
    //

    setInfoEx = (PTCP_REQUEST_SET_INFORMATION_EX)buffer;

    setInfoEx->ID.toi_entity.tei_entity = CO_TL_ENTITY;
    setInfoEx->ID.toi_entity.tei_instance = TL_INSTANCE;
    setInfoEx->ID.toi_class = INFO_CLASS_PROTOCOL;
    setInfoEx->ID.toi_type = INFO_TYPE_CONNECTION;
    setInfoEx->ID.toi_id = TCP_SOCKET_OOBINLINE;
    setInfoEx->BufferSize = sizeof(*option);

    option = (TCPSocketOption *)&setInfoEx->Buffer;
    option->tso_value = InLine;



    //
    // Initialize the kernel event that will signal I/O completion.
    //

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Build TDI set information IRP.
    //

    irp = IoBuildDeviceIoControlRequest (
                    IOCTL_TCP_SET_INFORMATION_EX,
                    Connection->DeviceObject,
                    setInfoEx,
                    sizeof(*setInfoEx) + setInfoEx->BufferSize,
                    NULL,
                    0,
                    FALSE,  // InternalDeviceIoControl
                    &event,
                    &ioStatusBlock);
    if (irp==NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irpSp = IoGetNextIrpStackLocation (irp);
    irpSp->FileObject = Connection->FileObject;

    //
    // Call the driver.
    //
    status = IoCallDriver (Connection->DeviceObject, irp);

    //
    // Must be at below APC level or this IRP will never get fully completed.
    //
    ASSERT (KeGetCurrentIrql ()<APC_LEVEL);

    //
    // If necessary, wait for the I/O to complete.
    //

    if ( status == STATUS_PENDING ) {
        status = KeWaitForSingleObject( (PVOID)&event, Executive, KernelMode,  FALSE, NULL );
        ASSERT (status==STATUS_SUCCESS);
    }
    else {
        //
        // The IRP must have been completed then and event set.
        //
        if (NT_ERROR (status) || KeReadStateEvent (&event))
            ;
        else {
            DbgPrint ("************************************************\n");
            DbgPrint ("*AFD: IoCallDriver returned STATUS_SUCCESS,"
                        " but event in the IRP (%p) is NOT signalled!!!\n",
                        irp);
            DbgPrint ("************************************************\n");
            DbgBreakPoint ();
        }
    }

    //
    // If the request was successfully completed, get the final I/O status.
    //

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }


    //
    // Since this option is only supported for TCP/IP, always return success.
    //

    return STATUS_SUCCESS;

} // AfdSetInLineMode

NTSTATUS
AfdUnbind (
    IN PAFD_ENDPOINT Endpoint
    )

/*++

Routine Description:

    Releases the address while connections are still outstanding on it.

Arguments:

    Listening endpoint to unbind.
Return Value:

    NTSTATUS -- Indicates whether the request was successfully
        performed.

--*/

{
#ifdef AO_OPTION_UNBIND
    NTSTATUS status;
    PTCP_REQUEST_SET_INFORMATION_EX setInfoEx;
    UCHAR buffer[sizeof(*setInfoEx)+sizeof (BOOLEAN)];
    IO_STATUS_BLOCK ioStatusBlock;
    KEVENT event;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE( );

    //
    // Initialize the TDI information buffers.
    //

    setInfoEx = (PTCP_REQUEST_SET_INFORMATION_EX)buffer;

    setInfoEx->ID.toi_entity.tei_entity = CO_TL_ENTITY;
    setInfoEx->ID.toi_entity.tei_instance = TL_INSTANCE;
    setInfoEx->ID.toi_class = INFO_CLASS_PROTOCOL;
    setInfoEx->ID.toi_type = INFO_TYPE_ADDRESS_OBJECT;
    setInfoEx->ID.toi_id = AO_OPTION_UNBIND;
    setInfoEx->BufferSize = sizeof (BOOLEAN);

    *((BOOLEAN *)&setInfoEx->Buffer) = TRUE;



    //
    // Initialize the kernel event that will signal I/O completion.
    //

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Build TDI set information IRP.
    //

    irp = IoBuildDeviceIoControlRequest (
                    IOCTL_TCP_SET_INFORMATION_EX,
                    Endpoint->AddressDeviceObject,
                    setInfoEx,
                    sizeof(*setInfoEx) + setInfoEx->BufferSize,
                    NULL,
                    0,
                    FALSE,  // InternalDeviceIoControl
                    &event,
                    &ioStatusBlock);
    if (irp==NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irpSp = IoGetNextIrpStackLocation (irp);
    irpSp->FileObject = Endpoint->AddressFileObject;

    //
    // Call the driver.
    //
    status = IoCallDriver (Endpoint->AddressDeviceObject, irp);

    //
    // Must be at below APC level or this IRP will never get fully completed.
    //
    ASSERT (KeGetCurrentIrql ()<APC_LEVEL);

    //
    // If necessary, wait for the I/O to complete.
    //

    if ( status == STATUS_PENDING ) {
        status = KeWaitForSingleObject( (PVOID)&event, Executive, KernelMode,  FALSE, NULL );
        ASSERT (status==STATUS_SUCCESS);
    }
    else {
        //
        // The IRP must have been completed then and event set.
        //
        if (NT_ERROR (status) || KeReadStateEvent (&event))
            ;
        else {
            DbgPrint ("************************************************\n");
            DbgPrint ("*AFD: IoCallDriver returned STATUS_SUCCESS,"
                        " but event in the IRP (%p) is NOT signalled!!!\n",
                        irp);
            DbgPrint ("************************************************\n");
            DbgBreakPoint ();
        }
    }

    //
    // If the request was successfully completed, get the final I/O status.
    //

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }
#else
    UNREFERENCED_PARAMETER (Endpoint);
#endif // AO_OPTION_UNBIND

    //
    // Since this option is only supported for TCP/IP, always return success.
    //

    return STATUS_SUCCESS;

} // AfdUnbind

//
// The locking mechanism idea below is stolen from ntos\ex\handle.c
//

PVOID
AfdLockEndpointContext (
    PAFD_ENDPOINT   Endpoint
    )
{
    PVOID   context;
    PAGED_CODE ();


    //
    // We now use this lock in APC, protect from being
    // interrupted by the APC by disallowing them when we
    // are holding the lock.
    //
    KeEnterCriticalRegion ();
    while (1) {
        context = Endpoint->Context;
        //
        // See if someone else is manipulating the context.
        //
        if ((context==AFD_CONTEXT_BUSY) ||
                (context==AFD_CONTEXT_WAITING)) {
            //
            // If this has not changed while we were checking,
            // tell the current owner that we are waiting (if not
            // already told) and wait for a few miliseconds.
            //
            if (InterlockedCompareExchangePointer (
                    (PVOID *)&Endpoint->Context,
                    AFD_CONTEXT_WAITING,
                    context)==context) {
                NTSTATUS        status;
                LARGE_INTEGER afd10Milliseconds = {(ULONG)(-10 * 1000 * 10), -1};
                
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                            "AfdLockEndpointContext: Waiting for endp %p\n",
                            Endpoint));

                KeLeaveCriticalRegion ();

                status = KeWaitForSingleObject( (PVOID)&AfdContextWaitEvent,
                                                        Executive,
                                                        KernelMode,  
                                                        FALSE,
                                                        &afd10Milliseconds);
                KeEnterCriticalRegion ();
            }
            else {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                            "AfdLockEndpointContext: ICEP contention on %p\n",
                            Endpoint));
            }
            //
            // Try again.
            //
        }
        else {
            //
            // Context is not owned, try to get the ownership
            //
            if (InterlockedCompareExchangePointer (
                    (PVOID *)&Endpoint->Context,
                    AFD_CONTEXT_BUSY,
                    context)==context) {
                //
                // We now own the context, return it.
                //
                break;
            }
            //
            // Try again.
            //
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                        "AfdLockEndpointContext: ICEP contention on %p\n",
                        Endpoint));
            
        }
    }

    return context;
}

VOID
AfdUnlockEndpointContext (
    PAFD_ENDPOINT   Endpoint,
    PVOID           Context
    )
{
    PAGED_CODE ();

    ASSERT ((Context!=AFD_CONTEXT_BUSY) && (Context!=AFD_CONTEXT_WAITING));

    //
    // Set the new context pointer and see what the old value was.
    //
    Context = InterlockedExchangePointer ((PVOID)&Endpoint->Context, Context);
    if (Context==AFD_CONTEXT_WAITING) {
        LONG    prevState;
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdUnlockEndpointContext: Unwaiting endp %p\n", Endpoint));
        //
        // Someone was waiting, tell them to go get it now.
        //
        prevState = KePulseEvent (&AfdContextWaitEvent, 
                                    AfdPriorityBoost,
                                    FALSE
                                    );
        ASSERT (prevState==0);
    }
    else {
        //
        // Better be busy or someone has changed it on us.
        //
        ASSERT (Context==AFD_CONTEXT_BUSY);
    }
    KeLeaveCriticalRegion ();

}

    

NTSTATUS
AfdGetContext (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
{
    PAFD_ENDPOINT endpoint;
    PVOID         context;
    NTSTATUS      status;

    UNREFERENCED_PARAMETER (IoctlCode);
    UNREFERENCED_PARAMETER (InputBuffer);
    UNREFERENCED_PARAMETER (InputBufferLength);
    PAGED_CODE( );

    //
    // Set up local pointers.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    *Information = 0;



    context = AfdLockEndpointContext (endpoint);

    //
    // Make sure that the output buffer is large enough to hold all the
    // context information for this socket.
    //

    //
    // If there is no context, return nothing.
    //

    if ( context == NULL ) {
        status = STATUS_INVALID_PARAMETER;
    }

    //
    // Return the context information we have stored for this endpoint.
    //

    else {
        //
        // If application buffer is too small, just
        // copy whatever fits in and return the error code.
        //
        if ( OutputBufferLength < endpoint->ContextLength ) {
            status = STATUS_BUFFER_OVERFLOW;
        }
        else {
            OutputBufferLength = endpoint->ContextLength;
            if (IS_SAN_ENDPOINT (endpoint)) {
                //
                // Indicate to the caller that it may also need to
                // acqiure the control of the endpoint and
                // fetch san specific information.
                //
                status = STATUS_MORE_ENTRIES;
            }
            else {
                status = STATUS_SUCCESS;
            }
        }

        try {


            //
            // Validate the output structure if it comes from the user mode
            // application
            //
            if (RequestorMode != KernelMode ) {
                ProbeForWrite (OutputBuffer,
                                OutputBufferLength,
                                sizeof (UCHAR));
            }



            //
            // Copy parameters back to application's memory
            //

            RtlCopyMemory(
                OutputBuffer,
                context,
                OutputBufferLength
                );

            *Information = endpoint->ContextLength;

        } except( AFD_EXCEPTION_FILTER (status) ) {
            ASSERT (NT_ERROR (status));
        }
    }

    AfdUnlockEndpointContext (endpoint, context);

    return status;

} // AfdGetContext


NTSTATUS
AfdGetRemoteAddress (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
{
    PAFD_ENDPOINT endpoint;
    PVOID       context;
    NTSTATUS    status;

    UNREFERENCED_PARAMETER (IoctlCode);
    UNREFERENCED_PARAMETER (InputBuffer);
    UNREFERENCED_PARAMETER (InputBufferLength);
    PAGED_CODE( );

    //
    // Set up local pointers.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    *Information = 0;

    context = AfdLockEndpointContext (endpoint);
    //
    // If there is no context or endpoint is of wrong type state or
    // context information has been changed below the original size,
    // return error.
    //

    if ( context == NULL ||
            endpoint->Type!=AfdBlockTypeVcConnecting ||
            endpoint->State!= AfdEndpointStateConnected ||
            ((CLONG)(endpoint->Common.VcConnecting.RemoteSocketAddressOffset+
                endpoint->Common.VcConnecting.RemoteSocketAddressLength)) >
                    endpoint->ContextLength
            ) {
        status = STATUS_INVALID_CONNECTION;
    }
    else {

        if (OutputBufferLength<endpoint->Common.VcConnecting.RemoteSocketAddressLength) {
            status = STATUS_BUFFER_OVERFLOW;
        }
        else {
            OutputBufferLength = endpoint->Common.VcConnecting.RemoteSocketAddressLength;
            status = STATUS_SUCCESS;
        }

        try {

            //
            // Validate the output structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForWrite (OutputBuffer,
                                OutputBufferLength,
                                sizeof (UCHAR));
            }

            //
            // Copy parameters to application's memory
            //

            RtlCopyMemory(
                OutputBuffer,
                (PUCHAR)context+endpoint->Common.VcConnecting.RemoteSocketAddressOffset,
                endpoint->Common.VcConnecting.RemoteSocketAddressLength
                );

            *Information = endpoint->ContextLength;


        } except( AFD_EXCEPTION_FILTER (status) ) {
            ASSERT (NT_ERROR (status));
        }
    }

    AfdUnlockEndpointContext (endpoint, context);

    return status;

} // AfdGetRemoteAddress


NTSTATUS
AfdSetContext (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
{
    PAFD_ENDPOINT endpoint;
    PVOID context;
    NTSTATUS status;

    UNREFERENCED_PARAMETER (IoctlCode);
    PAGED_CODE( );

    //
    // Set up local pointers.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    status = STATUS_SUCCESS;
    *Information = 0;

    context = AfdLockEndpointContext (endpoint);
    try {

        //
        // Validate the input structure if it comes from the user mode
        // application
        //

        if (RequestorMode != KernelMode ) {
            ProbeForRead (InputBuffer,
                            InputBufferLength,
                            sizeof (UCHAR));

            if (OutputBuffer!=NULL) {
                //
                // Validate that output buffer is completely inside
                // of the input buffer and offsets are inside of supported ranges.
                //
                if ((PUCHAR)OutputBuffer<(PUCHAR)InputBuffer ||
                        (PUCHAR)OutputBuffer-(PUCHAR)InputBuffer>MAXUSHORT ||
                        OutputBufferLength>MAXUSHORT ||
                        OutputBufferLength>InputBufferLength ||
                        (ULONG)((PUCHAR)OutputBuffer-(PUCHAR)InputBuffer)>
                            InputBufferLength-OutputBufferLength) {
                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }
            }
        }

        //
        // If the context buffer is too small, allocate a new context 
        // buffer from paged pool.
        //

        if ( endpoint->ContextLength < InputBufferLength ) {

            PVOID newContext;


            //
            // Allocate a new context buffer.
            // Note since the socket context usually gets
            // populated on socket creation during boot and not used 
            // right away (untill socket state is chaged), we
            // make it a "cold" allocation.  The flag has no effect
            // after system is booted.

            newContext = AFD_ALLOCATE_POOL_WITH_QUOTA(
                                 PagedPool|POOL_COLD_ALLOCATION,
                                 InputBufferLength,
                                 AFD_CONTEXT_POOL_TAG
                                 );

            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE flag
            ASSERT ( newContext != NULL );

            //
            // Free the old context buffer, if there was one.
            //

            if ( context != NULL ) {

                AFD_FREE_POOL(
                    context,
                    AFD_CONTEXT_POOL_TAG
                    );

            }

            context = newContext;
        }

        //
        // Store the passed-in context buffer.
        //

        endpoint->ContextLength = InputBufferLength;

        RtlCopyMemory(
            context,
            InputBuffer,
            InputBufferLength
            );
        //
        // Save pointer to remote socket address which we fill
        // at the time of AcceptEx processing.
        //
        if (OutputBuffer!=NULL) {
            if (AFD_START_STATE_CHANGE (endpoint, AfdEndpointStateOpen)) {
                if (endpoint->Type==AfdBlockTypeEndpoint &&
                        endpoint->State==AfdEndpointStateOpen) {
                    endpoint->Common.VcConnecting.RemoteSocketAddressOffset =
                                (USHORT) ((PUCHAR)OutputBuffer-(PUCHAR)InputBuffer);
                    endpoint->Common.VcConnecting.RemoteSocketAddressLength =
                                (USHORT) OutputBufferLength;
                }
                AFD_END_STATE_CHANGE (endpoint);
            }
        }
    }
    except (AFD_EXCEPTION_FILTER (status)) {
        ASSERT (NT_ERROR (status));
    }

    AfdUnlockEndpointContext (endpoint, context);
    return status;

} // AfdSetContext


NTSTATUS
AfdSetEventHandler (
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID EventContext
    )

/*++

Routine Description:

    Sets up a TDI indication handler on a connection or address object
    (depending on the file handle).  This is done synchronously, which
    shouldn't usually be an issue since TDI providers can usually complete
    indication handler setups immediately.

Arguments:

    FileObject - a pointer to the file object for an open connection or
        address object.

    EventType - the event for which the indication handler should be
        called.

    EventHandler - the routine to call when tghe specified event occurs.

    EventContext - context which is passed to the indication routine.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    TDI_REQUEST_KERNEL_SET_EVENT parameters;

    PAGED_CODE( );

    parameters.EventType = EventType;
    parameters.EventHandler = EventHandler;
    parameters.EventContext = EventContext;

    return AfdIssueDeviceControl(
               FileObject,
               &parameters,
               sizeof(parameters),
               NULL,
               0,
               TDI_SET_EVENT_HANDLER
               );

} // AfdSetEventHandler


NTSTATUS
AfdIssueDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN PVOID IrpParameters,
    IN ULONG IrpParametersLength,
    IN PVOID MdlBuffer,
    IN ULONG MdlBufferLength,
    IN UCHAR MinorFunction
    )

/*++

Routine Description:

    Issues a device control returst to a TDI provider and waits for the
    request to complete.


Arguments:

    FileObject - a pointer to the file object corresponding to a TDI
        handle

    IrpParameters - information to write to the parameters section of the
        stack location of the IRP.

    IrpParametersLength - length of the parameter information.  Cannot be
        greater than 16.

    MdlBuffer - if non-NULL, a buffer of nonpaged pool to be mapped
        into an MDL and placed in the MdlAddress field of the IRP.

    MdlBufferLength - the size of the buffer pointed to by MdlBuffer.

    MinorFunction - the minor function code for the request.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatusBlock;
    PDEVICE_OBJECT deviceObject;
    PMDL mdl;

    PAGED_CODE( );

    //
    // Initialize the kernel event that will signal I/O completion.
    //

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Attempt to allocate and initialize the I/O Request Packet (IRP)
    // for this operation.
    //

    deviceObject = IoGetRelatedDeviceObject ( FileObject );

    DEBUG ioStatusBlock.Status = STATUS_UNSUCCESSFUL;
    DEBUG ioStatusBlock.Information = (ULONG)-1;

    //
    // If an MDL buffer was specified, get an MDL, and map the buffer
    //

    if ( MdlBuffer != NULL ) {

        mdl = IoAllocateMdl(
                  MdlBuffer,
                  MdlBufferLength,
                  FALSE,
                  FALSE,
                  NULL
                  );
        if ( mdl == NULL ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        MmBuildMdlForNonPagedPool( mdl );

    } else {

        mdl = NULL;
    }

    irp = TdiBuildInternalDeviceControlIrp (
                MinorFunction,
                deviceObject,
                FileObject,
                &event,
                &ioStatusBlock
                );

    if ( irp == NULL ) {
        if (mdl!=NULL) {
            IoFreeMdl (mdl);
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Install MDL (if any) in the IRP.
    //
    irp->MdlAddress = mdl;

    //
    // Put the file object pointer in the stack location.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    ASSERT (irpSp->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL);
    irpSp->MinorFunction = MinorFunction;
    irpSp->FileObject = FileObject;

    //
    // Fill in the service-dependent parameters for the request.
    //

    ASSERT( IrpParametersLength <= sizeof(irpSp->Parameters) );
    RtlCopyMemory( &irpSp->Parameters, IrpParameters, IrpParametersLength );


    //
    // Set up a completion routine which we'll use to free the MDL
    // allocated previously.
    //

    IoSetCompletionRoutine( irp, AfdRestartDeviceControl, NULL, TRUE, TRUE, TRUE );

    status = IoCallDriver( deviceObject, irp );

    //
    // Must be at below APC level or this IRP will never get fully completed.
    //
    ASSERT (KeGetCurrentIrql ()<APC_LEVEL);

    //
    // If necessary, wait for the I/O to complete.
    //

    if ( status == STATUS_PENDING ) {
        status = KeWaitForSingleObject( (PVOID)&event, Executive, KernelMode,  FALSE, NULL );
        ASSERT (status==STATUS_SUCCESS);
    }
    else {
        //
        // The IRP must have been completed then and event set.
        //
        if (NT_ERROR (status) || KeReadStateEvent (&event))
            ;
        else {
            DbgPrint ("************************************************\n");
            DbgPrint ("*AFD: IoCallDriver returned STATUS_SUCCESS,"
                        " but event in the IRP (%p) is NOT signalled!!!\n",
                        irp);
            DbgPrint ("************************************************\n");
            DbgBreakPoint ();
        }
    }

    //
    // If the request was successfully completed, get the final I/O status.
    //

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }

    return status;

} // AfdIssueDeviceControl


NTSTATUS
AfdRestartDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (Context);
    //
    // N.B.  This routine can never be demand paged because it can be
    // called before any endpoints have been placed on the global
    // list--see AfdAllocateEndpoint() and it's call to
    // AfdGetTransportInfo().
    //

    //
    // If there was an MDL in the IRP, free it and reset the pointer to
    // NULL.  The IO system can't handle a nonpaged pool MDL being freed
    // in an IRP, which is why we do it here.
    //

    if ( Irp->MdlAddress != NULL ) {
        IoFreeMdl( Irp->MdlAddress );
        Irp->MdlAddress = NULL;
    }

    return STATUS_SUCCESS;

} // AfdRestartDeviceControl


NTSTATUS
AfdGetConnectData (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;
    PAFD_CONNECT_DATA_INFO connectDataInfo;
    AFD_UNACCEPTED_CONNECT_DATA_INFO connectInfo;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PMDL    mdl;
    NTSTATUS status;
    UCHAR   localBuffer[AFD_FAST_CONNECT_DATA_SIZE];

    //
    // Set up local pointers.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    mdl = NULL;
    status = STATUS_SUCCESS;
    *Information = 0;

    try {
        if (InputBufferLength>0) {
            if (InputBufferLength<sizeof(connectInfo)) {
                status = STATUS_INVALID_PARAMETER;
                goto exit;
            }
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (connectInfo),
                                PROBE_ALIGNMENT(AFD_UNACCEPTED_CONNECT_DATA_INFO));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            connectInfo = *((PAFD_UNACCEPTED_CONNECT_DATA_INFO)InputBuffer);
  
            if (connectInfo.LengthOnly &&
                    OutputBufferLength<sizeof (connectInfo)) {
                status = STATUS_INVALID_PARAMETER;
                goto exit;
            }
        }
        else {
            AFD_W4_INIT connectInfo.Sequence = 0;
            AFD_W4_INIT connectInfo.LengthOnly = 0;
        }

        if (OutputBufferLength>0) {
            if (OutputBufferLength>sizeof (localBuffer)) {
                mdl = IoAllocateMdl(
                                OutputBuffer,       // VirtualAddress
                                OutputBufferLength, // Length
                                FALSE,              // SecondaryBuffer
                                TRUE,               // ChargeQuota
                                NULL                // Irp
                                );
                if (mdl==NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto exit;
                }

                MmProbeAndLockPages(
                    mdl,                        // MemoryDescriptorList
                    RequestorMode,              // AccessMode
                    IoWriteAccess               // Operation
                    );
                OutputBuffer = MmGetSystemAddressForMdlSafe(mdl, LowPagePriority);
                if (OutputBuffer==NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto exit;
                }
            }
            else {
                if (RequestorMode!=KernelMode) {
                    ProbeForWrite (OutputBuffer,
                                    OutputBufferLength,
                                    sizeof (UCHAR));
                }
            }
        }

    } except( AFD_EXCEPTION_FILTER (status) ) {
        ASSERT (NT_ERROR (status));
        goto exit;
    }

    //
    // If there is a connection on this endpoint, use the data buffers
    // on the connection.  Otherwise, use the data buffers from the
    // endpoint.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );


    if (InputBufferLength>0) {
        if ((endpoint->Type & AfdBlockTypeVcListening)==AfdBlockTypeVcListening) {
            connection = AfdFindReturnedConnection(
                         endpoint,
                         connectInfo.Sequence
                         );
        }
        else
            connection = NULL;

        if( connection == NULL ) {

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            status = STATUS_INVALID_PARAMETER;
            goto exit;
        }
        connectDataBuffers = connection->ConnectDataBuffers;
    }
    else if ( (connection= AFD_CONNECTION_FROM_ENDPOINT (endpoint)) != NULL ) {
        connectDataBuffers = connection->ConnectDataBuffers;
    } else if (IS_VC_ENDPOINT (endpoint)) {
        connectDataBuffers = endpoint->Common.VirtualCircuit.ConnectDataBuffers;
    }
    else {
        connectDataBuffers = NULL;
    }

    //
    // If there are no connect data buffers on the endpoint, complete
    // the IRP with no bytes.
    //

    if ( connectDataBuffers == NULL ) {
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        status = STATUS_SUCCESS;
        goto exit;
    }

    //
    // Determine what sort of data we're handling and where it should
    // come from.
    //

    switch ( IoctlCode ) {

    case IOCTL_AFD_GET_CONNECT_DATA:
        connectDataInfo = &connectDataBuffers->ReceiveConnectData;
        break;

    case IOCTL_AFD_GET_CONNECT_OPTIONS:
        connectDataInfo = &connectDataBuffers->ReceiveConnectOptions;
        break;

    case IOCTL_AFD_GET_DISCONNECT_DATA:
        connectDataInfo = &connectDataBuffers->ReceiveDisconnectData;
        break;

    case IOCTL_AFD_GET_DISCONNECT_OPTIONS:
        connectDataInfo = &connectDataBuffers->ReceiveDisconnectOptions;
        break;

    default:
        ASSERT(!"Unknown GET_CONNECT_DATA IOCTL!");
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    if ((InputBufferLength>0) && connectInfo.LengthOnly) {

        connectInfo.ConnectDataLength = connectDataInfo->BufferLength;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        try {
            RtlCopyMemory (OutputBuffer,
                            &connectInfo,
                            sizeof (connectInfo));
            *Information = sizeof (connectInfo);
        }
        except (AFD_EXCEPTION_FILTER (status)) {
            ASSERT (NT_ERROR (status));
        }
        goto exit;
    }

    //
    // If there is none of the requested data type, again complete
    // the IRP with no bytes.
    //

    if ( connectDataInfo->Buffer == NULL ||
             connectDataInfo->BufferLength == 0 ) {
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        *Information = 0;
        goto exit;
    }

    //
    // If the output buffer is too small, fail.
    //

    if ( OutputBufferLength < connectDataInfo->BufferLength ) {
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        status = STATUS_BUFFER_TOO_SMALL;
        goto exit;
    }

    
    //
    // Copy over the buffer and return the number of bytes copied.
    //

    RtlCopyMemory(
        mdl ? OutputBuffer : localBuffer,
        connectDataInfo->Buffer,
        connectDataInfo->BufferLength
        );

    *Information = connectDataInfo->BufferLength;

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    if (mdl==NULL) {
        AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
        try {
            RtlCopyMemory (OutputBuffer,
                            localBuffer,
                            *Information);
        }
        except (AFD_EXCEPTION_FILTER (status)) {
            ASSERT (NT_ERROR (status));
            *Information = 0;
        }
    }

exit:

    if (mdl!=NULL) {
        if (mdl->MdlFlags & MDL_PAGES_LOCKED) {
            MmUnlockPages (mdl);
        }
        IoFreeMdl (mdl);
    }

    return status;

} // AfdGetConnectData


NTSTATUS
AfdSetConnectData (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;
    PAFD_CONNECT_DATA_BUFFERS * connectDataBuffersTarget;
    PAFD_CONNECT_DATA_INFO connectDataInfo;
    AFD_UNACCEPTED_CONNECT_DATA_INFO connectInfo;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    BOOLEAN size = FALSE;
    PMDL    mdl;
    NTSTATUS status;
    UCHAR   localBuffer[AFD_FAST_CONNECT_DATA_SIZE];

    //
    // Set up local pointers.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    mdl = NULL;
    status = STATUS_SUCCESS;
    *Information = 0;

    if (!IS_VC_ENDPOINT (endpoint)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
    try {
        if (InputBufferLength>0) {
            if (InputBufferLength<sizeof(connectInfo)) {
                status = STATUS_INVALID_PARAMETER;
                goto exit;
            }
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (connectInfo),
                                PROBE_ALIGNMENT(AFD_UNACCEPTED_CONNECT_DATA_INFO));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            connectInfo = *((PAFD_UNACCEPTED_CONNECT_DATA_INFO)InputBuffer);

        }
        else {
            AFD_W4_INIT connectInfo.Sequence = 0;
            AFD_W4_INIT connectInfo.LengthOnly = 0;
        }

        if (OutputBufferLength>0) {
            if (OutputBufferLength>sizeof (localBuffer)) {
                mdl = IoAllocateMdl(
                                OutputBuffer,       // VirtualAddress
                                OutputBufferLength, // Length
                                FALSE,              // SecondaryBuffer
                                TRUE,               // ChargeQuota
                                NULL                // Irp
                                );
                if (mdl==NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto exit;
                }

                MmProbeAndLockPages(
                    mdl,                        // MemoryDescriptorList
                    RequestorMode,              // AccessMode
                    IoReadAccess               // Operation
                    );
                OutputBuffer = MmGetSystemAddressForMdlSafe(mdl, LowPagePriority);
                if (OutputBuffer==NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto exit;
                }
            }
            else {
                if (RequestorMode!=KernelMode) {
                    ProbeForRead (OutputBuffer,
                                    OutputBufferLength,
                                    sizeof (UCHAR));
                    RtlCopyMemory (localBuffer,
                                        OutputBuffer,
                                        OutputBufferLength);
                    OutputBuffer = localBuffer;
                }
            }
        }
    } except( AFD_EXCEPTION_FILTER (status) ) {
        ASSERT (NT_ERROR (status));
        goto exit;
    }


    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // If there is a connect outstanding on this endpoint or if it
    // has already been shut down, fail this request.  This prevents
    // the connect code from accessing buffers which may be freed soon.
    //

    if( endpoint->StateChangeInProgress ||
        ((endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) != 0 )) {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    if (InputBufferLength>0) {
        if ((endpoint->Type & AfdBlockTypeVcListening)==AfdBlockTypeVcListening) {
            connection = AfdFindReturnedConnection(
                         endpoint,
                         connectInfo.Sequence
                         );
        }
        else
            connection = NULL;

        if( connection == NULL ) {

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            status = STATUS_INVALID_PARAMETER;
            goto exit;
        }
        connectDataBuffersTarget = &connection->ConnectDataBuffers;
    }
    else if ( (connection= AFD_CONNECTION_FROM_ENDPOINT (endpoint)) != NULL ) {
        connectDataBuffersTarget = &connection->ConnectDataBuffers;
    } else {
        connectDataBuffersTarget = &endpoint->Common.VirtualCircuit.ConnectDataBuffers;
    }


    connectDataBuffers = *connectDataBuffersTarget;

    if( connectDataBuffers == NULL ) {

        try {

            connectDataBuffers = AFD_ALLOCATE_POOL_WITH_QUOTA(
                                     NonPagedPool,
                                     sizeof(*connectDataBuffers),
                                     AFD_CONNECT_DATA_POOL_TAG
                                     );

            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE flag
            ASSERT ( connectDataBuffers != NULL );
            *connectDataBuffersTarget = connectDataBuffers;

        } except( EXCEPTION_EXECUTE_HANDLER ) {
            status = GetExceptionCode ();
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            goto exit;
        }


        RtlZeroMemory(
            connectDataBuffers,
            sizeof(*connectDataBuffers)
            );

    }

    //
    // Determine what sort of data we're handling and where it should
    // go.
    //

    switch( IoctlCode ) {

    case IOCTL_AFD_SET_CONNECT_DATA:
        connectDataInfo = &connectDataBuffers->SendConnectData;
        break;

    case IOCTL_AFD_SET_CONNECT_OPTIONS:
        connectDataInfo = &connectDataBuffers->SendConnectOptions;
        break;

    case IOCTL_AFD_SET_DISCONNECT_DATA:
        connectDataInfo = &connectDataBuffers->SendDisconnectData;
        break;

    case IOCTL_AFD_SET_DISCONNECT_OPTIONS:
        connectDataInfo = &connectDataBuffers->SendDisconnectOptions;
        break;

    case IOCTL_AFD_SIZE_CONNECT_DATA:
        connectDataInfo = &connectDataBuffers->ReceiveConnectData;
        size = TRUE;
        break;

    case IOCTL_AFD_SIZE_CONNECT_OPTIONS:
        connectDataInfo = &connectDataBuffers->ReceiveConnectOptions;
        size = TRUE;
        break;

    case IOCTL_AFD_SIZE_DISCONNECT_DATA:
        connectDataInfo = &connectDataBuffers->ReceiveDisconnectData;
        size = TRUE;
        break;

    case IOCTL_AFD_SIZE_DISCONNECT_OPTIONS:
        connectDataInfo = &connectDataBuffers->ReceiveDisconnectOptions;
        size = TRUE;
        break;

    default:
        ASSERT (!"Unsupported set connect data code");
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }


    //
    // Determine the buffer size based on whether we're setting a buffer
    // into which data will be received, in which case the size is
    // in the four bytes of input buffer, or setting a buffer which we're
    // going to send, in which case the size is the length of the input
    // buffer.
    //

    if( size ) {

        if( OutputBufferLength < sizeof(ULONG) ) {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            status = STATUS_INVALID_PARAMETER;
            goto exit;
        }
        OutputBufferLength = *(ULONG UNALIGNED *)OutputBuffer;
    }

    //
    // If there's not currently a buffer of the requested type, or there is
    // such a buffer and it's smaller than the requested size, free it
    // and allocate a new one.
    //

    if( connectDataInfo->Buffer == NULL ||
        connectDataInfo->BufferLength < OutputBufferLength ) {

        if( connectDataInfo->Buffer != NULL ) {

            AFD_FREE_POOL(
                connectDataInfo->Buffer,
                AFD_CONNECT_DATA_POOL_TAG
                );

        }

        connectDataInfo->Buffer = NULL;
        connectDataInfo->BufferLength = 0;

        if (OutputBufferLength>0) {
            try {

                connectDataInfo->Buffer = AFD_ALLOCATE_POOL_WITH_QUOTA(
                                              NonPagedPool,
                                              OutputBufferLength,
                                              AFD_CONNECT_DATA_POOL_TAG
                                              );

                // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE flag
                ASSERT ( connectDataInfo->Buffer != NULL );
            } except( EXCEPTION_EXECUTE_HANDLER ) {

                status = GetExceptionCode ();
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                goto exit;

            }


            RtlZeroMemory(
                connectDataInfo->Buffer,
                OutputBufferLength
                );
        }
    }

    //
    // If this wasn't simply a "size" request, copy the data into the buffer.
    //

    if( !size ) {

        RtlCopyMemory(
            connectDataInfo->Buffer,
            OutputBuffer,
            OutputBufferLength
            );

    }

    connectDataInfo->BufferLength = OutputBufferLength;

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

exit:
    if (mdl!=NULL) {
        if (mdl->MdlFlags & MDL_PAGES_LOCKED) {
            MmUnlockPages (mdl);
        }
        IoFreeMdl (mdl);
    }

    return status;

} // AfdSetConnectData


NTSTATUS
AfdSaveReceivedConnectData (
    IN OUT PAFD_CONNECT_DATA_BUFFERS * DataBuffers,
    IN ULONG IoControlCode,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This helper routine stores the specified *received* connect/disconnect
    data/options on the specified endpoint/connection.

    N.B. This routine MUST be called with endpoint SpinLock held!

    N.B. Unlike AfdSetConnectData(), this routine cannot allocate the
         AFD_CONNECT_DATA_BUFFERS structure with quota, as it may be
         called from AfdDisconnectEventHandler() in an unknown thread
         context.

Arguments:

    DataBuffers -Points to a pointer to the connect data buffers structure.
        If the value pointed to by DataBuffers is NULL, then a new structure
        is allocated, otherwise the existing structure is used.

    IoControlCode - Specifies the type of data to save.

    Buffer - Points to the buffer containing the data.

    BufferLength - The length of Buffer.

Return Value:

    NTSTATUS - The completion status.

--*/

{
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;
    PAFD_CONNECT_DATA_INFO connectDataInfo;

    ASSERT( KeGetCurrentIrql() >= DISPATCH_LEVEL );

    //
    // If there's no connect data buffer structure, allocate one now.
    //

    connectDataBuffers = *DataBuffers;

    if( connectDataBuffers == NULL ) {

        connectDataBuffers = AFD_ALLOCATE_POOL(
                                 NonPagedPool,
                                 sizeof(*connectDataBuffers),
                                 AFD_CONNECT_DATA_POOL_TAG
                                 );

        if( connectDataBuffers == NULL ) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        RtlZeroMemory(
            connectDataBuffers,
            sizeof(*connectDataBuffers)
            );

        *DataBuffers = connectDataBuffers;

    }

    //
    // Determine what sort of data we're handling and where it should
    // go.
    //

    switch( IoControlCode ) {

    case IOCTL_AFD_SET_CONNECT_DATA:
        connectDataInfo = &connectDataBuffers->ReceiveConnectData;
        break;

    case IOCTL_AFD_SET_CONNECT_OPTIONS:
        connectDataInfo = &connectDataBuffers->ReceiveConnectOptions;
        break;

    case IOCTL_AFD_SET_DISCONNECT_DATA:
        connectDataInfo = &connectDataBuffers->ReceiveDisconnectData;
        break;

    case IOCTL_AFD_SET_DISCONNECT_OPTIONS:
        connectDataInfo = &connectDataBuffers->ReceiveDisconnectOptions;
        break;

    default:
        ASSERT (!"Unsupported save received connect data code");
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If the buffer in the connect structure matches the one
    // passed in, must be the same buffer we passed in the request.
    // Just adjust the length.
    //

    if (connectDataInfo->Buffer==Buffer) {
        ASSERT (connectDataInfo->BufferLength>=BufferLength);
        connectDataInfo->BufferLength = BufferLength;
        return STATUS_SUCCESS;
    }

    //
    // If there was previously a buffer of the requested type, free it.
    //

    if( connectDataInfo->Buffer != NULL ) {

        AFD_FREE_POOL(
            connectDataInfo->Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );

        connectDataInfo->Buffer = NULL;

    }

    //
    // Allocate a new buffer for the data and copy in the data we're to
    // send.
    //

    connectDataInfo->Buffer = AFD_ALLOCATE_POOL(
                                  NonPagedPool,
                                  BufferLength,
                                  AFD_CONNECT_DATA_POOL_TAG
                                  );

    if( connectDataInfo->Buffer == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    RtlCopyMemory(
        connectDataInfo->Buffer,
        Buffer,
        BufferLength
        );

    connectDataInfo->BufferLength = BufferLength;
    return STATUS_SUCCESS;

} // AfdSaveReceivedConnectData


VOID
AfdFreeConnectDataBuffers (
    IN PAFD_CONNECT_DATA_BUFFERS ConnectDataBuffers
    )
{
    if ( ConnectDataBuffers->SendConnectData.Buffer != NULL ) {
        AFD_FREE_POOL(
            ConnectDataBuffers->SendConnectData.Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );
    }

    if ( ConnectDataBuffers->ReceiveConnectData.Buffer != NULL ) {
        AFD_FREE_POOL(
            ConnectDataBuffers->ReceiveConnectData.Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );
    }

    if ( ConnectDataBuffers->SendConnectOptions.Buffer != NULL ) {
        AFD_FREE_POOL(
            ConnectDataBuffers->SendConnectOptions.Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );
    }

    if ( ConnectDataBuffers->ReceiveConnectOptions.Buffer != NULL ) {
        AFD_FREE_POOL(
            ConnectDataBuffers->ReceiveConnectOptions.Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );
    }

    if ( ConnectDataBuffers->SendDisconnectData.Buffer != NULL ) {
        AFD_FREE_POOL(
            ConnectDataBuffers->SendDisconnectData.Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );
    }

    if ( ConnectDataBuffers->ReceiveDisconnectData.Buffer != NULL ) {
        AFD_FREE_POOL(
            ConnectDataBuffers->ReceiveDisconnectData.Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );
    }

    if ( ConnectDataBuffers->SendDisconnectOptions.Buffer != NULL ) {
        AFD_FREE_POOL(
            ConnectDataBuffers->SendDisconnectOptions.Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );
    }

    if ( ConnectDataBuffers->ReceiveDisconnectOptions.Buffer != NULL ) {
        AFD_FREE_POOL(
            ConnectDataBuffers->ReceiveDisconnectOptions.Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );
    }

    AFD_FREE_POOL(
        ConnectDataBuffers,
        AFD_CONNECT_DATA_POOL_TAG
        );

    return;

} // AfdFreeConnectDataBuffers



VOID
AfdQueueWorkItem (
    IN PWORKER_THREAD_ROUTINE AfdWorkerRoutine,
    IN PAFD_WORK_ITEM AfdWorkItem
    )
{
    KIRQL oldIrql;

    ASSERT( AfdWorkerRoutine != NULL );
    ASSERT( AfdWorkItem != NULL );

    AfdWorkItem->AfdWorkerRoutine = AfdWorkerRoutine;

    //
    // Insert the work item at the tail of AFD's list of work itrems.
    //

    oldIrql = KeAcquireQueuedSpinLock( LockQueueAfdWorkQueueLock );

    InsertTailList( &AfdWorkQueueListHead, &AfdWorkItem->WorkItemListEntry );

    AfdRecordAfdWorkItemsQueued();

    //
    // If there is no executive worker thread working on AFD work, fire
    // off an executive worker thread to start servicing the list.
    //

    if ( !AfdWorkThreadRunning ) {

        //
        // Remember that the work thread is running and release the
        // lock.  Note that we must release the lock before queuing the
        // work because the worker thread may unlock AFD and we can't
        // hold a lock when AFD is unlocked.
        //

        AfdRecordExWorkItemsQueued();

        AfdWorkThreadRunning = TRUE;
        KeReleaseQueuedSpinLock( LockQueueAfdWorkQueueLock, oldIrql );

        IoQueueWorkItem (AfdWorkQueueItem,
                            AfdDoWork,
                            DelayedWorkQueue,
                            NULL);

    } else {

        KeReleaseQueuedSpinLock( LockQueueAfdWorkQueueLock, oldIrql );
    }

    return;

} // AfdQueueWorkItem


VOID
AfdDoWork (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    PAFD_WORK_ITEM afdWorkItem;
    PLIST_ENTRY listEntry;
    KIRQL oldIrql;
    PWORKER_THREAD_ROUTINE workerRoutine;

    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (Context);
    ASSERT( AfdWorkThreadRunning );

    //
    // Empty the queue of AFD work items.
    //

    oldIrql = KeAcquireQueuedSpinLock( LockQueueAfdWorkQueueLock );

    AfdRecordWorkerEnter();
    AfdRecordAfdWorkerThread( PsGetCurrentThread() );

    while ( !IsListEmpty( &AfdWorkQueueListHead ) ) {

        //
        // Take the first item from the queue and find the address
        // of the AFD work item structure.
        //

        listEntry = RemoveHeadList( &AfdWorkQueueListHead );
        afdWorkItem = CONTAINING_RECORD(
                          listEntry,
                          AFD_WORK_ITEM,
                          WorkItemListEntry
                          );

        AfdRecordAfdWorkItemsProcessed();

        //
        // Capture the worker thread routine from the item.
        //

        workerRoutine = afdWorkItem->AfdWorkerRoutine;

        //
        // If this work item is going to unlock AFD, then remember that
        // the worker thread is no longer running.  This closes the
        // window where AFD gets unloaded at the same time as new work
        // comes in and gets put on the work queue.  Note that we
        // must reset this boolean BEFORE releasing the spin lock.
        //

        if( workerRoutine == AfdUnlockDriver ) {

            AfdWorkThreadRunning = FALSE;

            AfdRecordAfdWorkerThread( NULL );
            AfdRecordWorkerLeave();

        }

        //
        // Release the lock and then call the AFD worker routine.
        //

        KeReleaseQueuedSpinLock( LockQueueAfdWorkQueueLock, oldIrql );

        workerRoutine( afdWorkItem );

        //
        // If the purpose of this work item was to unload AFD, then
        // we know that there is no more work to do and we CANNOT
        // acquire a spin lock.  Quit servicing the list and return.

        if( workerRoutine == AfdUnlockDriver ) {
            return;
        }

        //
        // Reacquire the spin lock and continue servicing the list.
        //

        oldIrql = KeAcquireQueuedSpinLock( LockQueueAfdWorkQueueLock );
    }

    //
    // Remember that we're no longer servicing the list and release the
    // spin lock.
    //

    AfdRecordAfdWorkerThread( NULL );
    AfdRecordWorkerLeave();

    AfdWorkThreadRunning = FALSE;
    KeReleaseQueuedSpinLock( LockQueueAfdWorkQueueLock, oldIrql );

} // AfdDoWork




PAFD_WORK_ITEM
AfdGetWorkerByRoutine (
    PWORKER_THREAD_ROUTINE  Routine
    ) {
    KIRQL       oldIrql;
    PLIST_ENTRY listEntry;

    oldIrql = KeAcquireQueuedSpinLock( LockQueueAfdWorkQueueLock );
    listEntry = AfdWorkQueueListHead.Flink;
    while (listEntry!=&AfdWorkQueueListHead) {
        PAFD_WORK_ITEM afdWorkItem = CONTAINING_RECORD(
                                          listEntry,
                                          AFD_WORK_ITEM,
                                          WorkItemListEntry
                                          );
        if (afdWorkItem->AfdWorkerRoutine==Routine) {
            RemoveEntryList (&afdWorkItem->WorkItemListEntry);
            KeReleaseQueuedSpinLock( LockQueueAfdWorkQueueLock, oldIrql );
            return afdWorkItem;
        }
        else
            listEntry = listEntry->Flink;
    }
    KeReleaseQueuedSpinLock( LockQueueAfdWorkQueueLock, oldIrql );
    return NULL;
} // AfdGetWorkerByRoutine


#if DBG

typedef struct _AFD_OUTSTANDING_IRP {
    LIST_ENTRY OutstandingIrpListEntry;
    PIRP OutstandingIrp;
    PCHAR FileName;
    ULONG LineNumber;
} AFD_OUTSTANDING_IRP, *PAFD_OUTSTANDING_IRP;


BOOLEAN
AfdRecordOutstandingIrpDebug (
    IN PAFD_ENDPOINT Endpoint,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PCHAR FileName,
    IN ULONG LineNumber
    )
{
    PAFD_OUTSTANDING_IRP outstandingIrp;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    UNREFERENCED_PARAMETER (DeviceObject);
    //
    // Get an outstanding IRP structure to hold the IRP.
    //

    outstandingIrp = AFD_ALLOCATE_POOL_PRIORITY (
                         NonPagedPool,
                         sizeof(AFD_OUTSTANDING_IRP),
                         AFD_DEBUG_POOL_TAG,
                         NormalPoolPriority
                         );

    if ( outstandingIrp == NULL ) {
        //
        // Because our completion routine will try to
        // find this IRP anyway and check for completion
        // we use the stack space to put it in the list.
        // The completion routine will just remove this
        // element from the list without attempting to free it.
        //
        AFD_OUTSTANDING_IRP OutstandingIrp;

        OutstandingIrp.OutstandingIrp = Irp;
        OutstandingIrp.FileName = NULL; // To let completion
                                        // routine know that this
                                        // is not an allocated element
        OutstandingIrp.LineNumber = 0;

        AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );
        InsertTailList(
            &Endpoint->OutstandingIrpListHead,
            &OutstandingIrp.OutstandingIrpListEntry
            );
        Endpoint->OutstandingIrpCount++;
        AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
        
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdRecordOutstandingIrp: Could not track Irp %p on endpoint %p, failing it.\n",
                    Irp, Endpoint));
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoSetNextIrpStackLocation( Irp );
        IoCompleteRequest( Irp, AfdPriorityBoost );
        return FALSE;
    }

    //
    // Initialize the structure and place it on the endpoint's list of
    // outstanding IRPs.
    //

    outstandingIrp->OutstandingIrp = Irp;
    outstandingIrp->FileName = FileName;
    outstandingIrp->LineNumber = LineNumber;

    AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );
    InsertHeadList(
        &Endpoint->OutstandingIrpListHead,
        &outstandingIrp->OutstandingIrpListEntry
        );
    Endpoint->OutstandingIrpCount++;
    AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );

    return TRUE;
} // AfdRecordOutstandingIrpDebug


VOID
AfdCompleteOutstandingIrpDebug (
    IN PAFD_ENDPOINT Endpoint,
    IN PIRP Irp
    )
{
    PAFD_OUTSTANDING_IRP outstandingIrp;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY listEntry;

    //
    // First find the IRP on the endpoint's list of outstanding IRPs.
    //

    AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );

    for ( listEntry = Endpoint->OutstandingIrpListHead.Flink;
          listEntry != &Endpoint->OutstandingIrpListHead;
          listEntry = listEntry->Flink ) {

        outstandingIrp = CONTAINING_RECORD(
                             listEntry,
                             AFD_OUTSTANDING_IRP,
                             OutstandingIrpListEntry
                             );
        if ( outstandingIrp->OutstandingIrp == Irp ) {
            RemoveEntryList( listEntry );
            ASSERT( Endpoint->OutstandingIrpCount != 0 );
            Endpoint->OutstandingIrpCount--;
            AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
            if (outstandingIrp->FileName!=NULL) {
                AFD_FREE_POOL(
                    outstandingIrp,
                    AFD_DEBUG_POOL_TAG
                    );
            }
            return;
        }
    }

    //
    // The corresponding outstanding IRP structure was not found.  This
    // should never happen unless an allocate for an outstanding IRP
    // structure failed above.
    //

    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                "AfdCompleteOutstandingIrp: Irp %p not found on endpoint %p\n",
                Irp, Endpoint ));

    ASSERT( Endpoint->OutstandingIrpCount != 0 );

    Endpoint->OutstandingIrpCount--;

    AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );

    return;

} // AfdCompleteOutstandingIrpDebug
#endif




#if REFERENCE_DEBUG
AFD_QSPIN_LOCK          AfdLocationTableLock;
PAFD_REFERENCE_LOCATION AfdLocationTable;
SIZE_T                  AfdLocationTableSize;
LONG                    AfdLocationId;

LONG
AfdFindReferenceLocation (
    IN  PCHAR   Format,
    OUT PLONG   LocationId
    )
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PVOID   ignore;

    AfdAcquireSpinLock (&AfdLocationTableLock, &lockHandle);
    if (*LocationId==0) {
        if (AfdLocationId >= (LONG)(AfdLocationTableSize/sizeof(AfdLocationTable[0]))) {
            PAFD_REFERENCE_LOCATION newTable;
            newTable = ExAllocatePoolWithTag (NonPagedPool,
                                AfdLocationTableSize+PAGE_SIZE,
                                AFD_DEBUG_POOL_TAG);
            if (newTable!=NULL) {
                if (AfdLocationTable!=NULL) {
                    RtlCopyMemory (newTable, AfdLocationTable, AfdLocationTableSize);
                    ExFreePoolWithTag (AfdLocationTable, AFD_DEBUG_POOL_TAG);
                }
                AfdLocationTable = newTable;
                AfdLocationTableSize += PAGE_SIZE;
            }
            else {
                goto Unlock;
            }
        }

        AfdLocationTable[AfdLocationId].Format = Format;
        RtlGetCallersAddress (&AfdLocationTable[AfdLocationId].Address, &ignore);

        *LocationId = ++AfdLocationId;
    }
Unlock:
    AfdReleaseSpinLock (&AfdLocationTableLock, &lockHandle);
    return *LocationId;
}

#endif


#if DBG || REFERENCE_DEBUG

VOID
AfdInitializeDebugData (
    VOID
    )
{
    AfdInitializeSpinLock (&AfdLocationTableLock);

} // AfdInitializeDebugData

VOID
AfdFreeDebugData (
    VOID
    )
{
    if (AfdLocationTable!=NULL) {
        ExFreePoolWithTag (AfdLocationTable, AFD_DEBUG_POOL_TAG);
        AfdLocationTable = NULL;
    }

} // AfdFreeDebugData
#endif

#if DBG

LONG AfdTotalAllocations = 0;
LONG AfdTotalFrees = 0;
LARGE_INTEGER AfdTotalBytesAllocated;
LARGE_INTEGER AfdTotalBytesFreed;



PVOID
AfdAllocatePool (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PCHAR FileName,
    IN ULONG LineNumber,
    IN BOOLEAN WithQuota,
    IN EX_POOL_PRIORITY Priority
    )
{

    PVOID            memBlock;
    PAFD_POOL_HEADER header;
    SIZE_T           allocBytes;

    //
    // Check for overflow first.
    //
    if (NumberOfBytes+sizeof (*header)<=NumberOfBytes) {
        if (WithQuota) {
            ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
        }
        return NULL;
    }

    if (NumberOfBytes+sizeof (*header)>=PAGE_SIZE) {
        allocBytes = NumberOfBytes;
        if (allocBytes<PAGE_SIZE)
            allocBytes = PAGE_SIZE;
    }
    else {
        allocBytes = NumberOfBytes+sizeof (*header);
    }


    if ( WithQuota ) {
        ASSERT (PoolType == (NonPagedPool|POOL_RAISE_IF_ALLOCATION_FAILURE) ||
                    PoolType == (PagedPool|POOL_RAISE_IF_ALLOCATION_FAILURE) ||
                    PoolType == (PagedPool|POOL_RAISE_IF_ALLOCATION_FAILURE|POOL_COLD_ALLOCATION));
        memBlock = ExAllocatePoolWithQuotaTag(
                     PoolType,
                     allocBytes,
                     Tag
                     );
        ASSERT (memBlock!=NULL);
    } else {
        ASSERT( PoolType == NonPagedPool ||
                PoolType == NonPagedPoolMustSucceed ||
                PoolType == PagedPool ||
                PoolType == (PagedPool|POOL_COLD_ALLOCATION));
        memBlock = ExAllocatePoolWithTagPriority(
                 PoolType,
                 allocBytes,
                 Tag,
                 Priority
                 );
        if ( memBlock == NULL ) {
            return NULL;
        }
    }


    if (allocBytes<PAGE_SIZE) {
        header = memBlock;
        memBlock = header+1;
        header->FileName = FileName;
        header->LineNumber = LineNumber;
        header->Size = NumberOfBytes;
        header->InUse = PoolType;

    }
    else {
        NumberOfBytes = PAGE_SIZE;
        ASSERT (PAGE_ALIGN(memBlock)==memBlock);
    }

    ExInterlockedAddLargeStatistic(
        &AfdTotalBytesAllocated,
        (CLONG)NumberOfBytes
        );
    InterlockedIncrement(
        &AfdTotalAllocations
        );

    return memBlock;

} // AfdAllocatePool

#define AFD_POOL_DEBUG  0
#if AFD_POOL_DEBUG
#define MAX_LRU_POOL_BLOCKS 256
PVOID   AfdLRUPoolBlocks[MAX_LRU_POOL_BLOCKS];
LONG    AfdLRUPoolIndex = -1;
#endif  // AFD_POOL_DEBUG


VOID
AfdFreePool (
    IN PVOID Pointer,
    IN ULONG Tag
    )
{

    ULONG   PoolType;
    ULONG   numberOfBytes;

    ASSERT (((ULONG_PTR)Pointer & (MEMORY_ALLOCATION_ALIGNMENT-1))==0);

    if (PAGE_ALIGN (Pointer)==Pointer) {
        numberOfBytes = PAGE_SIZE;
    }
    else {
        PAFD_POOL_HEADER header;
        Pointer = ((PAFD_POOL_HEADER)Pointer) - 1;
        header = Pointer;
        ASSERT (header->Size>0);
        PoolType = InterlockedExchange (&header->InUse, -1);
        ASSERT( PoolType == NonPagedPool ||
                PoolType == NonPagedPoolMustSucceed ||
                PoolType == PagedPool ||
                PoolType == (NonPagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE) ||
                PoolType == (PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE) ||
                PoolType == (PagedPool | POOL_COLD_ALLOCATION) ||
                PoolType == (PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE | POOL_COLD_ALLOCATION));
        numberOfBytes = (CLONG)header->Size;
    }

    ExInterlockedAddLargeStatistic(
        &AfdTotalBytesFreed,
        numberOfBytes
        );

    InterlockedIncrement(
        &AfdTotalFrees
        );

#if AFD_POOL_DEBUG
    {
        LONG idx = InterlockedIncrement (&AfdLRUPoolIndex)%MAX_LRU_POOL_BLOCKS;
        RtlFillMemoryUlong (
                    Pointer,
                    (numberOfBytes+3)&(~3),
                    Tag);
        if (PoolType!=PagedPool) {
            ULONG  size;
            Pointer = InterlockedExchangePointer (
                                &AfdLRUPoolBlocks[idx],
                                Pointer);
            if (Pointer==NULL)
                return;

            if (PAGE_ALIGN(Pointer)==Pointer)
                numberOfBytes = PAGE_SIZE;
            else {
                PAFD_HEADER header;
                header = (PAFD_POOL_HEADER)Pointer - 1;
                Tag = *((PULONG)Pointer);
                numberOfBytes = (CLONG)(header->Size+3)&(~3);
            }
            size = RtlCompareMemoryUlong (Pointer, numberOfBytes, Tag);
            if (size!=numberOfBytes) {
                DbgPrint ("Block %p is modified at %p after it was freed.\n",
                            Pointer, (PUCHAR)Pointer+size);
                DbgBreakPoint ();
            }

        }
    }
#endif AFD_POOL_DEBUG

    MyFreePoolWithTag(
        Pointer,
        Tag
        );

} // AfdFreePool

#ifdef AFDDBG_QUOTA

typedef struct _AFD_QUOTA_HASH {
    PSZ    Type;
    LONG   TotalAmount;
} AFD_QUOTA_HASH, *PAFD_QUOTA_HASH;

#define AFD_QUOTA_HASH_SIZE 31
AFD_QUOTA_HASH  AfdQuotaHash[AFD_QUOTA_HASH_SIZE];
PEPROCESS   AfdQuotaProcess;



typedef struct {
    union {
        ULONG Bytes;
        struct {
            UCHAR Reserved[3];
            UCHAR Sign;
        } ;
    } ;
    UCHAR Location[12];
    PVOID Block;
    PVOID Process;
    PVOID Reserved2[2];
} QUOTA_HISTORY, *PQUOTA_HISTORY;
#define QUOTA_HISTORY_LENGTH 512
QUOTA_HISTORY AfdQuotaHistory[QUOTA_HISTORY_LENGTH];
LONG AfdQuotaHistoryIndex = 0;

VOID
AfdRecordQuotaHistory(
    IN PEPROCESS Process,
    IN LONG Bytes,
    IN PSZ Type,
    IN PVOID Block
    )
{

    LONG index;
    PQUOTA_HISTORY history;

    index = InterlockedIncrement( &AfdQuotaHistoryIndex );
    index &= QUOTA_HISTORY_LENGTH - 1;
    history = &AfdQuotaHistory[index];

    history->Bytes = Bytes;
    history->Sign = Bytes < 0 ? '-' : '+';
    RtlCopyMemory( history->Location, Type, 12 );
    history->Block = Block;
    history->Process = Process;

    index = (ULONG_PTR)Type % AFD_QUOTA_HASH_SIZE;
    if (AfdQuotaHash[index].Type!=Type) {
        if (InterlockedCompareExchangePointer (
                        (PVOID *)&AfdQuotaHash[index].Type,
                        Type,
                        NULL)!=NULL) {
            AfdQuotaHash[index].Type = (PVOID)-1;
        }
    }
    InterlockedExchangeAdd (&AfdQuotaHash[index].TotalAmount, Bytes);
} // AfdRecordQuotaHistory
#endif
#endif


PMDL
AfdAdvanceMdlChain(
    IN PMDL Mdl,
    IN ULONG Offset
    )

/*++

Routine Description:

    Accepts a pointer to an existing MDL chain and offsets that chain
    by a specified number of bytes.  This may involve the creation
    of a partial MDL for the first entry in the new chain.

Arguments:

    Mdl - Pointer to the MDL chain to advance.

    Offset - The number of bytes to offset the chain.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    //
    // Sanity check.
    //

    ASSERT( Mdl != NULL );
    ASSERT( Offset > 0 );

    //
    // Scan past any fully completed MDLs.
    //

    while ( Offset > MmGetMdlByteCount( Mdl ) ) {
        PMDL    prev = Mdl;

        Offset -= MmGetMdlByteCount( Mdl );
        ASSERT( Mdl->Next != NULL );
        Mdl = Mdl->Next;
        prev->Next = NULL;
        MmUnlockPages (prev);
        IoFreeMdl (prev);

    }

    //
    // Tautology of the day: Offset will either be zero (meaning that
    // we've advanced to a clean boundary between MDLs) or non-zero
    // (meaning we need to now build a partial MDL).
    //

    if ( Offset > 0 ) {

        NTSTATUS status;

        //
        // Use new MM routine.
        // This saves us use of MustSucceed pool since the routine
        // below is guaranteed to succeed (as it should because
        // we already have the whole range locked and possibly mapped
        // and there should be no problem extracting part of it within
        // the same MDL).
        //

        status = MmAdvanceMdl (Mdl, Offset);
        ASSERT (status==STATUS_SUCCESS);
    }

    return Mdl;

} // AfdAdvanceMdlChain


NTSTATUS
AfdAllocateMdlChain(
    IN PIRP Irp,
    IN LPWSABUF BufferArray,
    IN ULONG BufferCount,
    IN LOCK_OPERATION Operation,
    OUT PULONG TotalByteCount
    )

/*++

Routine Description:

    Allocates a MDL chain describing the WSABUF array and attaches
    the chain to the specified IRP.

Arguments:

    Irp - The IRP that will receive the MDL chain.

    BufferArray - Points to an array of WSABUF structures describing
        the user's buffers.

    BufferCount - Contains the number of WSABUF structures in the
        array.

    Operation - Specifies the type of operation being performed (either
        IoReadAccess or IoWriteAccess).

    TotalByteCount - Will receive the total number of BYTEs described
        by the WSABUF array.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    NTSTATUS status;
    PMDL currentMdl;
    PMDL * chainTarget;
    KPROCESSOR_MODE previousMode;
    ULONG totalLength;
    PVOID bufferPointer;
    ULONG bufferLength;

    //
    //  Sanity check.
    //

    ASSERT( Irp != NULL );
    ASSERT( Irp->MdlAddress == NULL );
    ASSERT( ( Operation == IoReadAccess ) || ( Operation == IoWriteAccess ) );
    ASSERT( TotalByteCount != NULL );

    //
    //  Get the previous processor mode.
    //

    previousMode = Irp->RequestorMode;

    //
    //  Get into a known state.
    //

    status = STATUS_SUCCESS;
    currentMdl = NULL;
    chainTarget = &Irp->MdlAddress;
    totalLength = 0;

    //
    //  Walk the array of WSABUF structures, creating the MDLs and
    //  probing & locking the pages.
    //

    try {

        if( previousMode != KernelMode ) {

            if ((BufferArray==NULL) || 
                    (BufferCount==0) ||
                    (BufferCount>(MAXULONG/sizeof (WSABUF)))) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }

            //
            //  Probe the WSABUF array.
            //

            ProbeForRead(
                BufferArray,                            // Address
                BufferCount * sizeof(WSABUF),           // Length
                PROBE_ALIGNMENT(WSABUF)                 // Alignment
                );

        }
        else {
            ASSERT( BufferArray != NULL );
            ASSERT( BufferCount > 0 );
        }

        //
        //  Scan the array.
        //

        for ( ; BufferCount>0; BufferCount--, BufferArray++) {

            bufferPointer = BufferArray->buf;
            bufferLength = BufferArray->len;

            if (bufferLength > 0) {

                //
                // Check for integer overflow.
                //

                C_ASSERT(sizeof(totalLength) == sizeof(MAXULONG));
                if ((MAXULONG - totalLength) < bufferLength) {
                    status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                //  Create a new MDL.
                //

                currentMdl = IoAllocateMdl(
                                bufferPointer,      // VirtualAddress
                                bufferLength,       // Length
                                FALSE,              // SecondaryBuffer
                                TRUE,               // ChargeQuota
                                NULL                // Irp
                                );

                if (currentMdl != NULL) {

                    //
                    //  Lock the pages.  This will raise an exception
                    //  if the operation fails.
                    //

                    MmProbeAndLockPages(
                        currentMdl,                 // MemoryDescriptorList
                        previousMode,               // AccessMode
                        Operation                   // Operation
                        );

                    //
                    //  Chain the MDL onto the IRP.  In theory, we could
                    //  do this by passing the IRP into IoAllocateMdl(),
                    //  but IoAllocateMdl() does a linear scan on the MDL
                    //  chain to find the last one in the chain.
                    //
                    //  We can do much better.
                    //

                    *chainTarget = currentMdl;
                    chainTarget = &currentMdl->Next;


                } else {

                    //
                    //  Cannot allocate new MDL, return appropriate error.
                    //

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;

                }

                //
                //  Update the total byte counter.
                //

                totalLength += bufferLength;

            }

        }

        //
        //  Ensure the MDL chain is NULL terminated.
        //

        ASSERT(*chainTarget == NULL);

    } except(AFD_EXCEPTION_FILTER(status)) {

        ASSERT(NT_ERROR(status));

        //
        //  currentMdl will only be non-NULL at this point if an MDL
        //  has been created, but MmProbeAndLockPages() raised an
        //  exception.  If this is true, then free the MDL.
        //  Also account for the case when currentMdl has been linked
        //  onto the chain and exception occured when accesing next user
        //  buffer.
        //

        if ((currentMdl != NULL) && (chainTarget != &currentMdl->Next))
            IoFreeMdl(currentMdl);

    }

    //
    //  Return the total buffer count.
    //

    *TotalByteCount = totalLength;

    return status;

} // AfdAllocateMdlChain


#ifdef _WIN64
NTSTATUS
AfdAllocateMdlChain32(
    IN PIRP Irp,
    IN LPWSABUF32 BufferArray,
    IN ULONG BufferCount,
    IN LOCK_OPERATION Operation,
    OUT PULONG TotalByteCount
    )

/*++

Routine Description:

    Allocates a MDL chain describing the WSABUF array and attaches
    the chain to the specified IRP.

Arguments:

    Irp - The IRP that will receive the MDL chain.

    BufferArray - Points to an array of WSABUF structures describing
        the user's buffers.

    BufferCount - Contains the number of WSABUF structures in the
        array.

    Operation - Specifies the type of operation being performed (either
        IoReadAccess or IoWriteAccess).

    TotalByteCount - Will receive the total number of BYTEs described
        by the WSABUF array.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    NTSTATUS status;
    PMDL currentMdl;
    PMDL * chainTarget;
    KPROCESSOR_MODE previousMode;
    ULONG totalLength;
    PVOID bufferPointer;
    ULONG bufferLength;

    //
    //  Sanity check.
    //

    ASSERT( Irp != NULL );
    ASSERT( Irp->MdlAddress == NULL );
    ASSERT( ( Operation == IoReadAccess ) || ( Operation == IoWriteAccess ) );
    ASSERT( TotalByteCount != NULL );

    //
    //  Get the previous processor mode.
    //

    previousMode = Irp->RequestorMode;

    //
    //  Get into a known state.
    //

    status = STATUS_SUCCESS;
    currentMdl = NULL;
    chainTarget = &Irp->MdlAddress;
    totalLength = 0;

    //
    //  Walk the array of WSABUF structures, creating the MDLs and
    //  probing & locking the pages.
    //

    try {

        if( previousMode != KernelMode ) {

            if ((BufferArray==NULL) || 
                    (BufferCount==0) ||
                    (BufferCount>(MAXULONG/sizeof (WSABUF32)))) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }

            //
            //  Probe the WSABUF array.
            //

            ProbeForRead(
                BufferArray,                            // Address
                BufferCount * sizeof(WSABUF32),         // Length
                PROBE_ALIGNMENT32(WSABUF32)             // Alignment
                );

        }
        else {
            ASSERT( BufferArray != NULL );
            ASSERT( BufferCount > 0 );
        }

        //
        //  Scan the array.
        //

        for ( ; BufferCount>0; BufferCount--, BufferArray++) {

            bufferPointer = UlongToPtr(BufferArray->buf);
            bufferLength = BufferArray->len;

            if (bufferLength > 0) {

                //
                // Check for integer overflow.
                //

                C_ASSERT(sizeof(totalLength) == sizeof(MAXULONG));
                if ((MAXULONG - totalLength) < bufferLength) {
                    status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                //  Create a new MDL.
                //

                currentMdl = IoAllocateMdl(
                                bufferPointer,      // VirtualAddress
                                bufferLength,       // Length
                                FALSE,              // SecondaryBuffer
                                TRUE,               // ChargeQuota
                                NULL                // Irp
                                );

                if (currentMdl != NULL) {

                    //
                    //  Lock the pages.  This will raise an exception
                    //  if the operation fails.
                    //

                    MmProbeAndLockPages(
                        currentMdl,                 // MemoryDescriptorList
                        previousMode,               // AccessMode
                        Operation                   // Operation
                        );

                    //
                    //  Chain the MDL onto the IRP.  In theory, we could
                    //  do this by passing the IRP into IoAllocateMdl(),
                    //  but IoAllocateMdl() does a linear scan on the MDL
                    //  chain to find the last one in the chain.
                    //
                    //  We can do much better.
                    //

                    *chainTarget = currentMdl;
                    chainTarget = &currentMdl->Next;


                } else {

                    //
                    //  Cannot allocate new MDL, return appropriate error.
                    //

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;

                }

                //
                //  Update the total byte counter.
                //

                totalLength += bufferLength;

            }

        }

        //
        //  Ensure the MDL chain is NULL terminated.
        //

        ASSERT(*chainTarget == NULL);

    } except(AFD_EXCEPTION_FILTER(status)) {

        ASSERT(NT_ERROR(status));

        //
        //  currentMdl will only be non-NULL at this point if an MDL
        //  has been created, but MmProbeAndLockPages() raised an
        //  exception.  If this is true, then free the MDL.
        //  Also account for the case when currentMdl has been linked
        //  onto the chain and exception occured when accesing next user
        //  buffer.
        //

        if ((currentMdl != NULL) && (chainTarget != &currentMdl->Next))
            IoFreeMdl(currentMdl);

    }

    //
    //  Return the total buffer count.
    //

    *TotalByteCount = totalLength;

    return status;

} // AfdAllocateMdlChain32
#endif //_WIN64


VOID
AfdDestroyMdlChain (
    IN PIRP Irp
    )

/*++

Routine Description:

    Unlocks & frees the MDLs in the MDL chain attached to the given IRP.

Arguments:

    Irp - The IRP that owns the MDL chain to destroy.

Return Value:

    None.

--*/

{

    PMDL mdl;
    PMDL nextMdl;

    mdl = Irp->MdlAddress;
    Irp->MdlAddress = NULL;

    while( mdl != NULL ) {

        nextMdl = mdl->Next;
        MmUnlockPages( mdl );
        IoFreeMdl( mdl );
        mdl = nextMdl;

    }

} // AfdDestroyMdlChain


ULONG
AfdCalcBufferArrayByteLength(
    IN LPWSABUF         BufferArray,
    IN ULONG            BufferCount
    )

/*++

Routine Description:

    Calculates the total size (in bytes) of the buffers described by the
    specified WSABUF array.

Arguments:

    BufferArray - Points to an array of WSABUF structures.

    BufferCount - The number of entries in BufferArray.

Return Value:

    ULONG - The total size (in bytes) of the buffers described by the
        WSABUF array. Will raise an exception & return -1 if the total
        size is obviously too large.

--*/

{

    LARGE_INTEGER totalLength;

    PAGED_CODE( );

    //
    // Sanity check.
    //

    ASSERT( BufferArray != NULL );
    ASSERT( BufferCount > 0 );
    ASSERT( BufferCount <= (MAXULONG/sizeof (WSABUF)));


    //
    // Scan the array & sum the lengths.
    //

    totalLength.QuadPart = 0;

    while( BufferCount-- ) {

        totalLength.QuadPart += (LONGLONG)BufferArray->len;
        BufferArray++;

    }

    if( totalLength.HighPart != 0 ||
        ( totalLength.LowPart & 0x80000000 ) != 0 ) {
        ExRaiseAccessViolation();
    }

    return totalLength.LowPart;

} // AfdCalcBufferArrayByteLength


ULONG
AfdCopyBufferArrayToBuffer(
    IN PVOID Destination,
    IN ULONG DestinationLength,
    IN LPWSABUF BufferArray,
    IN ULONG BufferCount
    )

/*++

Routine Description:

    Copies data from a WSABUF array to a linear buffer.

Arguments:

    Destination - Points to the linear destination of the data.

    DestinationLength - The length of Destination.

    BufferArray - Points to an array of WSABUF structures describing the
        source for the copy.

    BufferCount - The number of entries in BufferArray.

Return Value:

    ULONG - The number of bytes copied.

--*/

{

    PVOID destinationStart;
    ULONG bytesToCopy;

    PAGED_CODE( );

    //
    // Sanity check.
    //

    ASSERT( Destination != NULL );
    ASSERT( BufferArray != NULL );
    ASSERT( BufferCount > 0 );

    //
    // Remember this so we can calc number of bytes copied.
    //

    destinationStart = Destination;

    //
    // Scan the array & copy to the linear buffer.
    //

    while( BufferCount-- && DestinationLength > 0 ) {
        WSABUF  Buffer = *BufferArray++;

        bytesToCopy = min( DestinationLength, Buffer.len );

        if( ExGetPreviousMode() != KernelMode ) {

            ProbeForRead(
                Buffer.buf,                             // Address
                bytesToCopy,                            // Length
                sizeof(UCHAR)                           // Alignment
                );

        }

        RtlCopyMemory(
            Destination,
            Buffer.buf,
            bytesToCopy
            );

        Destination = (PCHAR)Destination + bytesToCopy;
        DestinationLength -= bytesToCopy;

    }

    //
    // Return number of bytes copied.
    //

    return (ULONG)((PUCHAR)Destination - (PUCHAR)destinationStart);

} // AfdCopyBufferArrayToBuffer


ULONG
AfdCopyBufferToBufferArray(
    IN LPWSABUF BufferArray,
    IN ULONG Offset,
    IN ULONG BufferCount,
    IN PVOID Source,
    IN ULONG SourceLength
    )

/*++

Routine Description:

    Copies data from a linear buffer to a WSABUF array.

Arguments:

    BufferArray - Points to an array of WSABUF structures describing the
        destination for the copy.

    Offset - An offset within the buffer array at which the data should
        be copied.

    BufferCount - The number of entries in BufferArray.

    Source - Points to the linear source of the data.

    SourceLength - The length of Source.

Return Value:

    ULONG - The number of bytes copied.

--*/

{

    PVOID sourceStart;
    ULONG bytesToCopy;
    WSABUF buffer;

    PAGED_CODE( );

    //
    // Sanity check.
    //

    ASSERT( BufferArray != NULL );
    ASSERT( BufferCount > 0 );
    ASSERT( Source != NULL );
    ASSERT( SourceLength > 0 );

    //
    // Remember this so we can return the number of bytes copied.
    //

    sourceStart = Source;

    //
    // Handle the offset if one was specified.
    //

    if( Offset > 0 ) {

        //
        // Skip whole entries if necessary.
        //

        while( BufferCount-- > 0 ) {
            buffer = *BufferArray++;
            if (Offset < buffer.len) {
                //
                // If we have buffers left, fix up the buffer pointer
                // and length to keep the loop below fast.
                //


                buffer.buf += Offset;
                buffer.len -= Offset;

                //
                // We have already copied buffer array element, so jump
                // to the body of the loop to avoid doing this again (this
                // is not a mere optimization, but protection from application
                // that plays tricks on us by changing content of the buffer
                // array while we are looking at it).
                //
                goto DoCopy;
            }
            Offset -= buffer.len;

        }

        return 0;
    }

    //
    // Scan the array & copy from the linear buffer.
    //

    while( BufferCount-->0 && SourceLength > 0 ) {
        buffer = *BufferArray++;

    DoCopy:

        bytesToCopy = min( SourceLength, buffer.len );

        if( ExGetPreviousMode() != KernelMode ) {

            ProbeForWrite(
                buffer.buf,                             // Address
                bytesToCopy,                            // Length
                sizeof(UCHAR)                           // Alignment
                );

        }

        RtlCopyMemory(
            buffer.buf,
            Source,
            bytesToCopy
            );

        Source = (PCHAR)Source + bytesToCopy;
        SourceLength -= bytesToCopy;

    }

    //
    // Return number of bytes copied.
    //

    return (ULONG)((PUCHAR)Source - (PUCHAR)sourceStart);

} // AfdCopyBufferToBufferArray


ULONG
AfdCopyMdlChainToBufferArray(
    IN LPWSABUF BufferArray,
    IN ULONG BufferOffset,
    IN ULONG BufferCount,
    IN PMDL  SourceMdl,
    IN ULONG SourceOffset,
    IN ULONG SourceLength
    )

/*++

Routine Description:

    Copies data from a MDL chain to a WSABUF array.

Arguments:

    BufferArray - Points to an array of WSABUF structures describing the
        destination for the copy.

    BufferOffset - An offset within the buffer array at which the data should
        be copied.

    BufferCount - The number of entries in BufferArray.

    Source - Points to the MDL chain with data

    SourceOffset - An offset within the MDL chain from which the data should
        be copied.

    SourceLength - The length of Source.

Return Value:

    ULONG - The number of bytes copied.

--*/

{

    ULONG bytesCopied;
    ULONG bytesToCopy, len;
    WSABUF buffer;

    PAGED_CODE( );

    //
    // Assume we can copy everything.
    //

    bytesCopied = SourceLength;

    //
    // Sanity check.
    //

    ASSERT( BufferArray != NULL );
    ASSERT( BufferCount > 0 );
    ASSERT( SourceMdl != NULL );
    ASSERT( SourceLength>0 );

    //
    // Skip offset into the MDL chain
    //
    while (SourceOffset>=MmGetMdlByteCount (SourceMdl)) {
        SourceOffset -= MmGetMdlByteCount (SourceMdl);
        SourceMdl = SourceMdl->Next;
    }

    //
    // Handle buffer array offset if specified
    //
    if (BufferOffset>0) {
        //
        // Skip whole entries.
        //

        while( BufferCount-- > 0) {
            buffer = *BufferArray++;
            if (BufferOffset < buffer.len) {
                //
                // We have buffers left, fix up the buffer pointer
                // and length to keep the loop below fast.
                //

                ASSERT (BufferOffset < buffer.len);
                buffer.buf += BufferOffset;
                buffer.len -= BufferOffset;

                //
                // We have already copied buffer array element, so jump
                // to the body of the loop to avoid doing this again (this
                // is not a mere optimization, but protection from application
                // that plays tricks on us by changing content of the buffer
                // array while we are looking at it).
                //

                goto DoCopy;
            }

            BufferOffset -= buffer.len;
        }

        return 0;
    }


    //
    // Scan the array & copy from the mdl chain.
    //

    while (SourceLength>0 && BufferCount-->0) {
        buffer = *BufferArray++;

    DoCopy:
        bytesToCopy = min( SourceLength, buffer.len );

        if( ExGetPreviousMode() != KernelMode ) {

            ProbeForWrite(
                buffer.buf,                             // Address
                bytesToCopy,                            // Length
                sizeof(UCHAR)                           // Alignment
                );

        }

        //
        // Update source length for data we are going to copy
        //
        SourceLength -= bytesToCopy;

        //
        // Copy full source MDLs
        //
        while (bytesToCopy>0 &&
                (bytesToCopy>=(len=MmGetMdlByteCount (SourceMdl)-SourceOffset))) {
            ASSERT (SourceMdl->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL));
            RtlCopyMemory (buffer.buf,
                            (PUCHAR)MmGetSystemAddressForMdl(SourceMdl)+SourceOffset,
                            len);
            bytesToCopy -= len;
            buffer.buf += len;
            SourceMdl = SourceMdl->Next;
            SourceOffset = 0;
        }

        //
        // Copy partial source MDL if space remains.
        //
        if (bytesToCopy>0) {
            ASSERT (bytesToCopy<MmGetMdlByteCount (SourceMdl)-SourceOffset);
            ASSERT (SourceMdl->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL));
            RtlCopyMemory (buffer.buf,
                            (PUCHAR)MmGetSystemAddressForMdl (SourceMdl)+SourceOffset,
                            bytesToCopy
                            );
            SourceOffset += bytesToCopy;
        }

    }

    //
    // Return number of bytes copied except for those we couldn't.
    //

    return bytesCopied-SourceLength;

} // AfdCopyMdlChainToBufferArray


NTSTATUS
AfdCopyMdlChainToBufferAvoidMapping(
    IN PMDL     SrcMdl,
    IN ULONG    SrcOffset,
    IN ULONG    SrcLength,
    IN PUCHAR   Dst,
    IN ULONG    DstSize
    )

/*++

Routine Description:

    Copies data from a MDL chain to a buffer and avoids mapping
    MDLs to system space if possible.

Arguments:

    Dst - Points to destination for the copy.

    DstSize - Size of the buffer

    Source - Points to the MDL chain with data

    SourceOffset - An offset within the MDL chain from which the data should
        be copied.

    SourceLength - The length of Source.

Return Value:

    NTSTATUS - success if everything was copied OK
    STATUS_INSUFFICIENT_RESOURCES - mapping failed

--*/

{

    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       bytesToCopy;
    PUCHAR      DstEnd = Dst+DstSize;

    PAGED_CODE( );


    //
    // Sanity check.
    //

    ASSERT( Dst != NULL );
    ASSERT( DstSize > 0 );
    ASSERT( SrcMdl != NULL );
    ASSERT( SrcLength>0 );

    //
    // Skip offset into the MDL chain
    //
    while (SrcOffset>=MmGetMdlByteCount (SrcMdl)) {
        SrcOffset -= MmGetMdlByteCount (SrcMdl);
        SrcMdl = SrcMdl->Next;
    }

    while (Dst<DstEnd) {
        //
        // Determine how much we can copy and m
        // ake sure not to exceed limits.
        //
        bytesToCopy = MmGetMdlByteCount(SrcMdl)-SrcOffset;
        ASSERT (bytesToCopy<=(ULONG)(DstEnd-Dst));
        if (bytesToCopy>SrcLength) {
            bytesToCopy = SrcLength;
        }

        if (SrcMdl->Process==IoGetCurrentProcess ()) {
            //
            // If we are in the context of the same process that
            // MDL was created for, copy using VAs.
            //
            AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
            try {
                RtlCopyMemory (
                    Dst,
                    (PUCHAR)MmGetMdlVirtualAddress (SrcMdl)+SrcOffset,
                    bytesToCopy
                    );
            }
            except (AFD_EXCEPTION_FILTER (status)) {
                ASSERT (NT_ERROR (status));
                return status;
            }
        }
        else {
            //
            // Otherwise, map MDL into the system space.
            //
            PCHAR src = MmGetSystemAddressForMdlSafe (SrcMdl, LowPagePriority);
            if (!src)
                return STATUS_INSUFFICIENT_RESOURCES;

            RtlCopyMemory (
                    Dst,
                    src+SrcOffset,
                    bytesToCopy
                    );

        }

        //
        // Update source length for data we are going to copy
        //
        SrcLength -= bytesToCopy;
        if (SrcLength==0)
            return STATUS_SUCCESS;
        SrcMdl = SrcMdl->Next;
        SrcOffset = 0;

        Dst += bytesToCopy;
    }

    return STATUS_BUFFER_OVERFLOW;

} // AfdCopyMdlChainToBufferAvoidMapping

NTSTATUS
AfdMapMdlChain (
    PMDL    MdlChain
    )
/*++

Routine Description:

    Makes sure that eveyr MDL in the chains is mapped into
    the system address space.

Arguments:

    MdlChain - Destination MDL.


Return Value:
    STATUS_SUCCESS - MDL chain is fully mapped
    STATUS_INSUFFICIENT_RESOURCES - at least one MDL could not be mapped

--*/
{
    while (MdlChain!=NULL) {
        if (MmGetSystemAddressForMdlSafe(MdlChain, LowPagePriority)==NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        MdlChain = MdlChain->Next;
    }
    return STATUS_SUCCESS;
} // AfdMapMdlChain


NTSTATUS
AfdCopyMdlChainToMdlChain (
    PMDL    DstMdl,
    ULONG   DstOffset,
    PMDL    SrcMdl,
    ULONG   SrcOffset,
    ULONG   SrcLength,
    PULONG  BytesCopied
    )
/*++

Routine Description:

    Copies data from an MDL chain to an MDL chain.

Arguments:

    DstMdl - Destination MDL.

    DstOffset - Offset withih the destination MDL.

    SrcMdl - Source MDL.

    SrcOffset - Offset within the source.

    SrcLength - lenght of the data in the source chain

    BytesCopied - points to variable that received total number
                    of bytes actually copied

Return Value:
    STATUS_SUCCESS - all of the source data was copied
    STATUS_BUFFER_OVERFLOW - destination MDL was not long enough
                    to hold all of the source data.

--*/
{
    ULONG   bytesToCopy = 0, len;
    PUCHAR  dst;

    ASSERT( SrcMdl != NULL );
    ASSERT( DstMdl != NULL );

    //
    // Assume we can copy everything.
    //
    *BytesCopied = SrcLength;

    //
    // Skip full MDLs in source.
    //
    while ((SrcMdl!=NULL) && (SrcOffset>=MmGetMdlByteCount (SrcMdl))) {
        SrcOffset -= MmGetMdlByteCount (SrcMdl);
        SrcMdl = SrcMdl->Next;
    }

    //
    // Skip full MDLs in destination
    //
    while ((DstMdl!=NULL) && (DstOffset>=MmGetMdlByteCount (DstMdl))) {
        DstOffset -= MmGetMdlByteCount (DstMdl);
        DstMdl = DstMdl->Next;
    }

    //
    // Handle remaining destination offset separately to simplify the main loop.
    //
    if (DstOffset>0) {
        dst = MmGetSystemAddressForMdlSafe (DstMdl, LowPagePriority);
        if (dst==NULL)
            return STATUS_INSUFFICIENT_RESOURCES;
        dst += DstOffset;
        bytesToCopy = MmGetMdlByteCount(DstMdl)-DstOffset;
        goto DoCopy;
    }

    //
    // For each MDL in destination copy source MDLs
    // while source data and free space in destination remain
    //
    while ((SrcLength>0) && (DstMdl!=NULL)) {
        dst = MmGetSystemAddressForMdlSafe (DstMdl, LowPagePriority);
        if (dst==NULL)
            return STATUS_INSUFFICIENT_RESOURCES;
        bytesToCopy = MmGetMdlByteCount(DstMdl);
    DoCopy:

        bytesToCopy = min (SrcLength, bytesToCopy);

        //
        // Adjust source length
        //
        SrcLength -= bytesToCopy;

        //
        // Copy full source MDLs
        //
        while (bytesToCopy>0 &&
                (bytesToCopy>=(len=MmGetMdlByteCount (SrcMdl)-SrcOffset))) {
            ASSERT (SrcMdl->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL));
            RtlCopyMemory (dst,
                            (PUCHAR)MmGetSystemAddressForMdl(SrcMdl)+SrcOffset,
                            len);
            bytesToCopy -= len;
            dst += len;
            SrcMdl = SrcMdl->Next;
            SrcOffset = 0;
        }


        //
        // Copy partial source MDL if space remains
        //
        if (bytesToCopy>0) {
            ASSERT (bytesToCopy<MmGetMdlByteCount (SrcMdl)-SrcOffset);
            ASSERT (SrcMdl->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL));
            RtlCopyMemory (dst,
                            (PUCHAR)MmGetSystemAddressForMdl (SrcMdl)+SrcOffset,
                            bytesToCopy
                            );
            SrcOffset += bytesToCopy;
        }


        //
        // Advance to next MDL in destination
        //
        DstMdl = DstMdl->Next;
        
    }

    //
    // If we copied everything, return success
    //
    if (SrcLength==0) {
        return STATUS_SUCCESS;
    }
    else {
        //
        // Otherwise, adjust for number of bytes not copied
        // and return destination overflow
        //
        *BytesCopied -= SrcLength;
        return STATUS_BUFFER_OVERFLOW;
    }

}



#if DBG

VOID
AfdAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{

    if( AfdUsePrivateAssert ) {

        DbgPrint(
            "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
            Message
                ? Message
                : "",
            FailedAssertion,
            FileName,
            LineNumber
            );

        DbgBreakPoint();

    } else {

        RtlAssert(
            FailedAssertion,
            FileName,
            LineNumber,
            Message
            );

    }

}   // AfdAssert
#endif  // DBG


NTSTATUS
FASTCALL
AfdSetQos(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine sets the QOS for the given endpoint. Note that, since
    we don't really (yet) support QOS, we just ignore the incoming
    data and issue a AFD_POLL_QOS or AFD_POLL_GROUP_QOS event as
    appropriate.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{

    PAFD_ENDPOINT endpoint;
    PAFD_QOS_INFO qosInfo;
    NTSTATUS    status = STATUS_SUCCESS;

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        status = AfdSetQos32 (Irp, IrpSp);
        goto Complete;
    }
#endif
    //
    // Set up local pointers.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    qosInfo = Irp->AssociatedIrp.SystemBuffer;

    //
    // Make sure that the input buffer is large enough.
    //

    if( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(*qosInfo) ) {

        status = STATUS_BUFFER_TOO_SMALL;
        goto Complete;

    }

    //
    // If the incoming data doesn't match the default QOS,
    // indicate the appropriate event.
    //

    if( !RtlEqualMemory(
            &qosInfo->Qos,
            &AfdDefaultQos,
            sizeof(QOS)
            ) ) {
        AFD_LOCK_QUEUE_HANDLE lockHandle;
        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        AfdIndicateEventSelectEvent(
            endpoint,
            qosInfo->GroupQos
                ? AFD_POLL_GROUP_QOS
                : AFD_POLL_QOS,
            STATUS_SUCCESS
            );
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        AfdIndicatePollEvent(
            endpoint,
            qosInfo->GroupQos
                ? AFD_POLL_GROUP_QOS
                : AFD_POLL_QOS,
            STATUS_SUCCESS
            );

    }

Complete:
    //
    // Complete the IRP.
    //

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

}   // AfdSetQos


NTSTATUS
FASTCALL
AfdGetQos(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine gets the QOS for the given endpoint.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{

    PAFD_ENDPOINT endpoint;
    PAFD_QOS_INFO qosInfo;
    NTSTATUS    status = STATUS_SUCCESS;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        status = AfdGetQos32 (Irp, IrpSp);
        goto Complete;
    }
#endif

    //
    // Set up local pointers.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    qosInfo = Irp->AssociatedIrp.SystemBuffer;

    //
    // Make sure that the output buffer is large enough.
    //

    if( IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(*qosInfo) ) {

        status = STATUS_BUFFER_TOO_SMALL;
        goto Complete;

    }

    //
    // Just return the default data.
    //

    RtlCopyMemory(
        &qosInfo->Qos,
        &AfdDefaultQos,
        sizeof(QOS)
        );
    Irp->IoStatus.Information = sizeof(*qosInfo);

    Irp->IoStatus.Information = sizeof(*qosInfo);

Complete:
    //
    // Complete the IRP.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );
    return status;

}   // AfdGetQos


#ifdef _WIN64
NTSTATUS
AfdSetQos32(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine sets the QOS for the given endpoint. Note that, since
    we don't really (yet) support QOS, we just ignore the incoming
    data and issue a AFD_POLL_QOS or AFD_POLL_GROUP_QOS event as
    appropriate.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{

    PAFD_ENDPOINT endpoint;
    PAFD_QOS_INFO32 qosInfo;

    //
    // Set up local pointers.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    qosInfo = Irp->AssociatedIrp.SystemBuffer;

    //
    // Make sure that the input buffer is large enough.
    //

    if( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(*qosInfo) ) {

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    // If the incoming data doesn't match the default QOS,
    // indicate the appropriate event.
    //

    if( !RtlEqualMemory(
            &qosInfo->Qos,
            &AfdDefaultQos32,
            sizeof(QOS32)
            ) ) {

        AFD_LOCK_QUEUE_HANDLE lockHandle;
        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        AfdIndicateEventSelectEvent(
            endpoint,
            qosInfo->GroupQos
                ? AFD_POLL_GROUP_QOS
                : AFD_POLL_QOS,
            STATUS_SUCCESS
            );
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        AfdIndicatePollEvent(
            endpoint,
            qosInfo->GroupQos
                ? AFD_POLL_GROUP_QOS
                : AFD_POLL_QOS,
            STATUS_SUCCESS
            );

    }

    //
    // Complete the IRP.
    //

    Irp->IoStatus.Information = 0;
    return STATUS_SUCCESS;

}   // AfdSetQos


NTSTATUS
AfdGetQos32(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine gets the QOS for the given endpoint.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{

    PAFD_ENDPOINT endpoint;
    PAFD_QOS_INFO32 qosInfo;

    PAGED_CODE();

    //
    // Set up local pointers.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    qosInfo = Irp->AssociatedIrp.SystemBuffer;

    //
    // Make sure that the output buffer is large enough.
    //

    if( IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(*qosInfo) ) {

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    // Just return the default data.
    //

    RtlCopyMemory(
        &qosInfo->Qos,
        &AfdDefaultQos32,
        sizeof(QOS32)
        );

    //
    // Complete the IRP.
    //

    Irp->IoStatus.Information = sizeof(*qosInfo);
    return STATUS_SUCCESS;

}   // AfdGetQos32
#endif // _WIN64

NTSTATUS
AfdValidateStatus (
    NTSTATUS    Status
    )
{
    PAGED_CODE ();
    //
    // Validate the status code.
    // It must match the status code conversion algorithm in msafd.
    //
    switch (Status) {
    case STATUS_SUCCESS:
        // return NO_ERROR;

    case STATUS_INVALID_HANDLE:
    case STATUS_OBJECT_TYPE_MISMATCH:
        // return WSAENOTSOCK;

    case STATUS_INSUFFICIENT_RESOURCES:
    case STATUS_PAGEFILE_QUOTA:
    case STATUS_COMMITMENT_LIMIT:
    case STATUS_WORKING_SET_QUOTA:
    case STATUS_NO_MEMORY:
    case STATUS_CONFLICTING_ADDRESSES:
    case STATUS_QUOTA_EXCEEDED:
    case STATUS_TOO_MANY_PAGING_FILES:
    case STATUS_REMOTE_RESOURCES:
    case STATUS_TOO_MANY_ADDRESSES:
        // return WSAENOBUFS;

    case STATUS_SHARING_VIOLATION:
    case STATUS_ADDRESS_ALREADY_EXISTS:
        // return WSAEADDRINUSE;

    case STATUS_LINK_TIMEOUT:
    case STATUS_IO_TIMEOUT:
    case STATUS_TIMEOUT:
        // return WSAETIMEDOUT;

    case STATUS_GRACEFUL_DISCONNECT:
        // return WSAEDISCON;

    case STATUS_REMOTE_DISCONNECT:
    case STATUS_CONNECTION_RESET:
    case STATUS_LINK_FAILED:
    case STATUS_CONNECTION_DISCONNECTED:
    case STATUS_PORT_UNREACHABLE:
        // return WSAECONNRESET;

    case STATUS_LOCAL_DISCONNECT:
    case STATUS_TRANSACTION_ABORTED:
    case STATUS_CONNECTION_ABORTED:
        // return WSAECONNABORTED;

    case STATUS_BAD_NETWORK_PATH:
    case STATUS_NETWORK_UNREACHABLE:
    case STATUS_PROTOCOL_UNREACHABLE:
        // return WSAENETUNREACH;

    case STATUS_HOST_UNREACHABLE:
        // return WSAEHOSTUNREACH;
    case STATUS_HOST_DOWN:
        // return WSAEHOSTDOWN;

    case STATUS_CANCELLED:
    case STATUS_REQUEST_ABORTED:
        // return WSAEINTR;

    case STATUS_BUFFER_OVERFLOW:
    case STATUS_INVALID_BUFFER_SIZE:
        // return WSAEMSGSIZE;

    case STATUS_BUFFER_TOO_SMALL:
    case STATUS_ACCESS_VIOLATION:
        // return WSAEFAULT;

    // case STATUS_DEVICE_NOT_READY:
    // case STATUS_REQUEST_NOT_ACCEPTED:
        // return WSAEWOULDBLOCK;

    case STATUS_INVALID_NETWORK_RESPONSE:
    case STATUS_NETWORK_BUSY:
    case STATUS_NO_SUCH_DEVICE:
    case STATUS_NO_SUCH_FILE:
    case STATUS_OBJECT_PATH_NOT_FOUND:
    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_UNEXPECTED_NETWORK_ERROR:
        // return WSAENETDOWN;

    case STATUS_INVALID_CONNECTION:
        // return WSAENOTCONN;

    case STATUS_REMOTE_NOT_LISTENING:
    case STATUS_CONNECTION_REFUSED:
        // return WSAECONNREFUSED;

    case STATUS_PIPE_DISCONNECTED:
        // return WSAESHUTDOWN;

    case STATUS_INVALID_ADDRESS:
    case STATUS_INVALID_ADDRESS_COMPONENT:
        // return WSAEADDRNOTAVAIL;

    case STATUS_NOT_SUPPORTED:
    case STATUS_NOT_IMPLEMENTED:
        // return WSAEOPNOTSUPP;

    case STATUS_ACCESS_DENIED:
        // return WSAEACCES;
    case STATUS_CONNECTION_ACTIVE:
        // return WSAEISCONN;
        break;
    case STATUS_UNSUCCESSFUL:
    case STATUS_INVALID_PARAMETER:
    case STATUS_ADDRESS_CLOSED:
    case STATUS_CONNECTION_INVALID:
    case STATUS_ADDRESS_ALREADY_ASSOCIATED:
    case STATUS_ADDRESS_NOT_ASSOCIATED:
    case STATUS_INVALID_DEVICE_STATE:
    case STATUS_INVALID_DEVICE_REQUEST:
        // return WSAEINVAL;
        break;
    default:
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdValidateStatus: Unsupported status code %lx, converting to %lx(INVALID_PARAMETER)\n",
                    Status,
                    STATUS_INVALID_PARAMETER));
        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    return Status;
}


NTSTATUS
FASTCALL
AfdNoOperation(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine does nothing but complete the IRP.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{

    PAFD_ENDPOINT endpoint;
    NTSTATUS      status;

    PAGED_CODE();

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        status = AfdNoOperation32 (Irp, IrpSp);
        goto Complete;
    }
#endif
    //
    // Set up local pointers.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Assume success
    //

    status = STATUS_SUCCESS;

    if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength
            >= sizeof (IO_STATUS_BLOCK)) {
        try {
            if (Irp->RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                sizeof (IO_STATUS_BLOCK),
                                PROBE_ALIGNMENT(IO_STATUS_BLOCK))
            }

            //
            // Copy the status block
            //
            Irp->IoStatus
                = *((PIO_STATUS_BLOCK)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);
            Irp->IoStatus.Status = AfdValidateStatus (Irp->IoStatus.Status);
        }
        except (AFD_EXCEPTION_FILTER (status)) {
            ASSERT (NT_ERROR (status));
            //
            // Fail the call, no completion notification
            // should be delivered via async IO.
            //
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
        }
    }
    else {
        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
    }

#ifdef _WIN64
Complete:
#endif
        
    if (status==STATUS_SUCCESS && Irp->IoStatus.Status!=STATUS_SUCCESS) {
        //
        // Make sure we deliver error via async IO
        // operation instead of just failing this call itself.
        //
        IoMarkIrpPending (Irp);
        status = STATUS_PENDING;
    }
    else {
        ASSERT (status==Irp->IoStatus.Status);
    }

    IoCompleteRequest( Irp, AfdPriorityBoost );
    return status;

}   // AfdNoOperation


#ifdef _WIN64
NTSTATUS
AfdNoOperation32(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine does nothing but complete the IRP.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{

    PAFD_ENDPOINT endpoint;
    NTSTATUS      status;

    PAGED_CODE();

    //
    // Set up local pointers.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Assume success
    //
    status = STATUS_SUCCESS;
    if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength
            >= sizeof (IO_STATUS_BLOCK32)) {
        try {
            if (Irp->RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                sizeof (IO_STATUS_BLOCK32),
                                PROBE_ALIGNMENT32(IO_STATUS_BLOCK32))
            }

            Irp->IoStatus.Status 
                = ((PIO_STATUS_BLOCK32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->Status;
            Irp->IoStatus.Information 
                = ((PIO_STATUS_BLOCK32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->Information;
            //
            // Validate the status code.
            // It must match the status code conversion algorithm in msafd.
            //
            Irp->IoStatus.Status = AfdValidateStatus (Irp->IoStatus.Status);
        }
        except (AFD_EXCEPTION_FILTER (status)) {
            ASSERT (NT_ERROR (status));
            //
            // Fail the call, no completion notification
            // should be delivered via async IO.
            //
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
        }
    }
    else {
        Irp->IoStatus.Status  = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
    }

    return status;

}   // AfdNoOperation32
#endif //_WIN64

NTSTATUS
FASTCALL
AfdValidateGroup(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine examines a group ID. If the ID is for a "constrained"
    group, then all endpoints are scanned to validate the given address
    is consistent with the constrained group.


Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{

    PAFD_ENDPOINT endpoint;
    PAFD_ENDPOINT compareEndpoint;
    PAFD_CONNECTION connection;
    PLIST_ENTRY listEntry;
    PAFD_VALIDATE_GROUP_INFO validateInfo;
    AFD_GROUP_TYPE groupType;
    PTRANSPORT_ADDRESS requestAddress;
    ULONG requestAddressLength;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    BOOLEAN result;
    LONG groupId;
    NTSTATUS status = STATUS_SUCCESS;

    //
    // Set up local pointers.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    validateInfo = Irp->AssociatedIrp.SystemBuffer;

    //
    // Make sure that the input buffer is large enough.
    //

    if( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(*validateInfo) ) {

        status = STATUS_BUFFER_TOO_SMALL;
        goto Complete;

    }

    if( validateInfo->RemoteAddress.TAAddressCount != 1 ) {

        status = STATUS_INVALID_PARAMETER;
        goto Complete;

    }

    if( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            ( sizeof(*validateInfo) -
                  sizeof(TRANSPORT_ADDRESS) +
                  validateInfo->RemoteAddress.Address[0].AddressLength ) ) {

        status = STATUS_BUFFER_TOO_SMALL;
        goto Complete;

    }

    //
    // Start by referencing the group so it doesn't go away unexpectedly.
    // This will also validate the group ID, and give us the group type.
    //

    groupId = validateInfo->GroupID;

    if( !AfdReferenceGroup( groupId, &groupType ) ) {

        status = STATUS_INVALID_PARAMETER;
        goto Complete;

    }

    //
    // If it's not a constrained group ID, we can just complete the IRP
    // successfully right now.
    //

    if( groupType != GroupTypeConstrained ) {

        AfdDereferenceGroup( validateInfo->GroupID );

        Irp->IoStatus.Information = 0;
        status = STATUS_SUCCESS;
        goto Complete;

    }

    //
    // Calculate the size of the incoming TDI address.
    //

    requestAddress = &validateInfo->RemoteAddress;

    requestAddressLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength -
        sizeof(AFD_VALIDATE_GROUP_INFO) +
        sizeof(TRANSPORT_ADDRESS);

    //
    // OK, it's a constrained group. Scan the list of constrained endpoints,
    // find those that are either datagram endpoints or have associated
    // connections, and validate the remote addresses.
    //

    result = TRUE;

    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceSharedLite( AfdResource, TRUE );

    for( listEntry = AfdConstrainedEndpointListHead.Flink ;
         listEntry != &AfdConstrainedEndpointListHead ;
         listEntry = listEntry->Flink ) {

        compareEndpoint = CONTAINING_RECORD(
                              listEntry,
                              AFD_ENDPOINT,
                              ConstrainedEndpointListEntry
                              );

        ASSERT( IS_AFD_ENDPOINT_TYPE( compareEndpoint ) );
        ASSERT( compareEndpoint->GroupType == GroupTypeConstrained );

        //
        // Skip this endpoint if the group IDs don't match.
        //

        if( groupId != compareEndpoint->GroupID ) {

            continue;

        }

        //
        // If this is a datagram endpoint, check it's remote address.
        //

        if( IS_DGRAM_ENDPOINT( compareEndpoint ) ) {

            AfdAcquireSpinLock( &compareEndpoint->SpinLock, &lockHandle );

            if( compareEndpoint->Common.Datagram.RemoteAddress != NULL ) {

                result = AfdCompareAddresses(
                             compareEndpoint->Common.Datagram.RemoteAddress,
                             compareEndpoint->Common.Datagram.RemoteAddressLength,
                             requestAddress,
                             requestAddressLength
                             );

            }

            AfdReleaseSpinLock( &compareEndpoint->SpinLock, &lockHandle );

            if( !result ) {
                break;
            }

        } else {

            //
            // Not a datagram. If it's a connected endpoint, still has
            // a connection object, and that object has a remote address,
            // then compare the addresses.
            //

            AfdAcquireSpinLock( &compareEndpoint->SpinLock, &lockHandle );

            connection = AFD_CONNECTION_FROM_ENDPOINT( compareEndpoint );

            if( compareEndpoint->State == AfdEndpointStateConnected &&
                connection != NULL ) {

                REFERENCE_CONNECTION( connection );

                if( connection->RemoteAddress != NULL ) {

                    result = AfdCompareAddresses(
                                 connection->RemoteAddress,
                                 connection->RemoteAddressLength,
                                 requestAddress,
                                 requestAddressLength
                                 );

                }

                AfdReleaseSpinLock( &compareEndpoint->SpinLock, &lockHandle );

                DEREFERENCE_CONNECTION( connection );

                if( !result ) {
                    break;
                }

            } else {

                AfdReleaseSpinLock( &compareEndpoint->SpinLock, &lockHandle );

            }

        }

    }

    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();
    AfdDereferenceGroup( validateInfo->GroupID );

    if( !result ) {
        status = STATUS_INVALID_PARAMETER;
    }

Complete:

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

}   // AfdValidateGroup

BOOLEAN
AfdCompareAddresses(
    IN PTRANSPORT_ADDRESS Address1,
    IN ULONG Address1Length,
    IN PTRANSPORT_ADDRESS Address2,
    IN ULONG Address2Length
    )

/*++

Routine Description:

    This routine compares two addresses in a special way to support
    constrained socket groups. This routine will return TRUE if the
    two addresses represent the same "interface". By "interface", I
    mean something like an IP address or an IPX address. Note that for
    some address types (such as IP) certain portions of the address
    should be ignored (such as the port).

    I really hate hard-coded knowledge of "select" address types, but
    there's no easy way around it. Ideally, this should be the protocol
    driver's responsibility. We could really use a standard "compare
    these addresses" IOCTL in TDI.

Arguments:

    Address1 - The first address.

    Address1Length - The length of Address1.

    Address2 - The second address.

    Address2Length - The length of Address2.

Return Value:

    BOOLEAN - TRUE if the addresses reference the same interface, FALSE
        otherwise.

--*/

{

    USHORT addressType;

    if (Address1Length!=Address2Length)
        return FALSE;

    if (Address1Length<(ULONG)FIELD_OFFSET (TRANSPORT_ADDRESS,Address[0].Address)) {
        return FALSE;
    }
    addressType = Address1->Address[0].AddressType;

    if( addressType != Address2->Address[0].AddressType ) {

        //
        // If they're not the same address type, they can't be the
        // same address...
        //

        return FALSE;

    }

    //
    // Special case a few addresses.
    //

    switch( addressType ) {

    case TDI_ADDRESS_TYPE_IP : {

            TDI_ADDRESS_IP UNALIGNED * ip1;
            TDI_ADDRESS_IP UNALIGNED * ip2;

            ip1 = (PVOID)&Address1->Address[0].Address[0];
            ip2 = (PVOID)&Address2->Address[0].Address[0];

            //
            // IP addresses. Compare the address portion (ignoring
            // the port).
            //

            if( (Address1Length>=(ULONG)FIELD_OFFSET (TA_IP_ADDRESS, Address[0].Address[0].sin_zero)) &&
                (ip1->in_addr == ip2->in_addr) ) {
                return TRUE;
            }

        }
        return FALSE;

    case TDI_ADDRESS_TYPE_IP6 : {

            TDI_ADDRESS_IP6 UNALIGNED * ip1;
            TDI_ADDRESS_IP6 UNALIGNED * ip2;

            ip1 = (PVOID)&Address1->Address[0].Address;
            ip2 = (PVOID)&Address2->Address[0].Address;

            //
            // IPv6 addresses. Compare the address portion (ignoring
            // the port and flow info).
            //

            if( (Address1Length>=sizeof (TA_IP6_ADDRESS)) &&
                RtlEqualMemory(ip1->sin6_addr,
                               ip2->sin6_addr,
                               sizeof (ip1->sin6_addr)) ) {
                return TRUE;
            }

        }
        return FALSE;
    case TDI_ADDRESS_TYPE_IPX : {

            TDI_ADDRESS_IPX UNALIGNED * ipx1;
            TDI_ADDRESS_IPX UNALIGNED * ipx2;

            ipx1 = (PVOID)&Address1->Address[0].Address[0];
            ipx2 = (PVOID)&Address2->Address[0].Address[0];

            //
            // IPX addresses. Compare the network and node addresses.
            //

            if( (Address1Length>=sizeof (TA_IPX_ADDRESS)) &&
                ipx1->NetworkAddress == ipx2->NetworkAddress &&
                RtlEqualMemory(
                    ipx1->NodeAddress,
                    ipx2->NodeAddress,
                    sizeof(ipx1->NodeAddress)
                    ) ) {
                return TRUE;
            }

        }
        return FALSE;

    case TDI_ADDRESS_TYPE_APPLETALK : {

            TDI_ADDRESS_APPLETALK UNALIGNED * atalk1;
            TDI_ADDRESS_APPLETALK UNALIGNED * atalk2;

            atalk1 = (PVOID)&Address1->Address[0].Address[0];
            atalk2 = (PVOID)&Address2->Address[0].Address[0];

            //
            // APPLETALK address. Compare the network and node
            // addresses.
            //

            if( (Address1Length>=sizeof (TA_APPLETALK_ADDRESS)) &&
                (atalk1->Network == atalk2->Network) &&
                (atalk1->Node == atalk2->Node) ) {
                return TRUE;
            }

        }
        return FALSE;

    case TDI_ADDRESS_TYPE_VNS : {

            TDI_ADDRESS_VNS UNALIGNED * vns1;
            TDI_ADDRESS_VNS UNALIGNED * vns2;

            vns1 = (PVOID)&Address1->Address[0].Address[0];
            vns2 = (PVOID)&Address2->Address[0].Address[0];

            //
            // VNS addresses. Compare the network and subnet addresses.
            //

            if( (Address1Length>=sizeof (TA_VNS_ADDRESS)) &&
                RtlEqualMemory(
                    vns1->net_address,
                    vns2->net_address,
                    sizeof(vns1->net_address)
                    ) &&
                RtlEqualMemory(
                    vns1->subnet_addr,
                    vns2->subnet_addr,
                    sizeof(vns1->subnet_addr)
                    ) ) {
                return TRUE;
            }

        }
        return FALSE;

    default :

        //
        // Unknown address type. Do a simple memory compare.
        //

        return (BOOLEAN)RtlEqualMemory(
                            Address1,
                            Address2,
                            Address2Length
                            );

    }

}   // AfdCompareAddresses

NTSTATUS
AfdGetUnacceptedConnectData (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
{

    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;
    AFD_UNACCEPTED_CONNECT_DATA_INFO connectInfo;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    ULONG dataLength;
    PMDL  mdl;
    NTSTATUS status;
    UCHAR   localBuffer[AFD_FAST_CONNECT_DATA_SIZE];

    UNREFERENCED_PARAMETER (IoctlCode);
    //
    // Set up local pointers.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    status = STATUS_SUCCESS;
    mdl = NULL;
    *Information = 0;

    //
    // Validate the request.
    //

    if( !endpoint->Listening ||
            InputBufferLength < sizeof(connectInfo) ) {

        return STATUS_INVALID_PARAMETER;

    }

    try {
        //
        // Validate the input structure if it comes from the user mode
        // application
        //

        if (RequestorMode != KernelMode ) {
            ProbeForReadSmallStructure (InputBuffer,
                            sizeof (connectInfo),
                            PROBE_ALIGNMENT(AFD_UNACCEPTED_CONNECT_DATA_INFO));
        }

        //
        // Make local copies of the embeded pointer and parameters
        // that we will be using more than once in case malicios
        // application attempts to change them while we are
        // validating
        //

        connectInfo = *((PAFD_UNACCEPTED_CONNECT_DATA_INFO)InputBuffer);

        if (connectInfo.LengthOnly &&
                OutputBufferLength<sizeof (connectInfo)) {
            status = STATUS_INVALID_PARAMETER;
            goto exit;
        }

        if (OutputBufferLength>0) {
            if (OutputBufferLength>sizeof (localBuffer)) {
                mdl = IoAllocateMdl(
                                OutputBuffer,       // VirtualAddress
                                OutputBufferLength, // Length
                                FALSE,              // SecondaryBuffer
                                TRUE,               // ChargeQuota
                                NULL                // Irp
                                );
                if (mdl==NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto exit;
                }

                MmProbeAndLockPages(
                    mdl,                        // MemoryDescriptorList
                    RequestorMode,              // AccessMode
                    IoWriteAccess               // Operation
                    );
                OutputBuffer = MmGetSystemAddressForMdlSafe(mdl, LowPagePriority);
                if (OutputBuffer==NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto exit;
                }
            }
            else {
                if (RequestorMode!=KernelMode) {
                    ProbeForWrite (OutputBuffer,
                                    OutputBufferLength,
                                    sizeof (UCHAR));
                }
            }
        }

    } except( AFD_EXCEPTION_FILTER (status) ) {
        ASSERT (NT_ERROR (status));
        goto exit;
    }

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Find the specified connection.
    //

    connection = AfdFindReturnedConnection(
                     endpoint,
                     connectInfo.Sequence
                     );

    if( connection == NULL ) {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        status = STATUS_INVALID_PARAMETER;
        goto exit;

    }

    //
    // Determine the length of any received connect data.
    //

    dataLength = 0;
    connectDataBuffers = connection->ConnectDataBuffers;

    if( connectDataBuffers != NULL &&
        connectDataBuffers->ReceiveConnectData.Buffer != NULL ) {

        dataLength = connectDataBuffers->ReceiveConnectData.BufferLength;

    }

    //
    // If the caller is just interested in the data length, return it.
    //

    if( connectInfo.LengthOnly ) {

        connectInfo.ConnectDataLength = dataLength;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
        try {
            RtlCopyMemory (OutputBuffer,
                            &connectInfo,
                            sizeof (connectInfo));
            *Information = sizeof (connectInfo);
        }
        except (AFD_EXCEPTION_FILTER (status)) {
            ASSERT (NT_ERROR (status));
        }
        goto exit;
    }

    //
    // If there is no connect data, complete the IRP with no bytes.
    //

    if( dataLength == 0 ) {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        goto exit;
    }

    //
    // If the output buffer is too small, fail.
    //

    if( OutputBufferLength < dataLength ) {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        status = STATUS_BUFFER_TOO_SMALL;
        goto exit;
    }

    RtlCopyMemory(
        mdl ? OutputBuffer : localBuffer,
        connectDataBuffers->ReceiveConnectData.Buffer,
        dataLength
        );

    *Information = dataLength;

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    if (mdl==NULL) {
        AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
        try {
            RtlCopyMemory (OutputBuffer,
                            localBuffer,
                            *Information);
        }
        except (AFD_EXCEPTION_FILTER (status)) {
            ASSERT (NT_ERROR (status));
            *Information = 0;
        }
    }

exit:

    if (mdl!=NULL) {
        if (mdl->MdlFlags & MDL_PAGES_LOCKED) {
            MmUnlockPages (mdl);
        }
        IoFreeMdl (mdl);
    }

    return status;

}   // AfdGetUnacceptedConnectData

#ifdef _WIN64
ULONG
AfdComputeCMSGLength32 (
    PVOID   ControlBuffer,
    ULONG   ControlLength
    )
{
    ULONG   length = 0;

    ASSERT (ControlLength>=sizeof (TDI_CMSGHDR));

    while (ControlLength>=sizeof (TDI_CMSGHDR)) {
        PTDI_CMSGHDR    hdr;

        hdr = ControlBuffer;
        
        //
        // Data comes from the trusted kernel mode driver source.
        //
        ASSERT (ControlLength >= TDI_CMSGHDR_ALIGN((hdr)->cmsg_len));
        ControlLength -= (ULONG)TDI_CMSGHDR_ALIGN((hdr)->cmsg_len);
        ControlBuffer = (PUCHAR)ControlBuffer +
                        TDI_CMSGHDR_ALIGN((hdr)->cmsg_len);

        length += (ULONG)TDI_CMSGHDR_ALIGN32(
                            (hdr)->cmsg_len -
                                TDI_CMSGDATA_ALIGN (sizeof (TDI_CMSGHDR)) +
                                TDI_CMSGDATA_ALIGN32(sizeof(TDI_CMSGHDR32)) );

    }

    ASSERT (ControlLength==0);

    return length;
}

VOID
AfdCopyCMSGBuffer32 (
    PVOID   Dst,
    PVOID   ControlBuffer,
    ULONG   CopyLength
    )
{
    while (CopyLength>=sizeof (TDI_CMSGHDR32)) {
        PTDI_CMSGHDR    hdr;
        PTDI_CMSGHDR32  hdr32;

        hdr = ControlBuffer;
        hdr32 = Dst;

        hdr32->cmsg_len = (ULONG)( (hdr)->cmsg_len -
                                TDI_CMSGDATA_ALIGN (sizeof (TDI_CMSGHDR)) +
                                TDI_CMSGDATA_ALIGN32(sizeof(TDI_CMSGHDR32)) );
        hdr32->cmsg_level = hdr->cmsg_level;
        hdr32->cmsg_type = hdr->cmsg_type;

        if (CopyLength<(ULONG)TDI_CMSGHDR_ALIGN32(hdr32->cmsg_len))
            break;

        CopyLength -= (ULONG)TDI_CMSGHDR_ALIGN32(hdr32->cmsg_len);

        RtlMoveMemory ((PUCHAR)hdr32+TDI_CMSGDATA_ALIGN32(sizeof(TDI_CMSGHDR32)),
                            (PUCHAR)hdr+TDI_CMSGDATA_ALIGN(sizeof(TDI_CMSGHDR)),
                            hdr32->cmsg_len-TDI_CMSGDATA_ALIGN32(sizeof(TDI_CMSGHDR32)));
        
        ControlBuffer = (PUCHAR)ControlBuffer +
                        TDI_CMSGHDR_ALIGN((hdr)->cmsg_len);

        Dst = (PUCHAR)Dst + TDI_CMSGHDR_ALIGN32((hdr32)->cmsg_len);
    }

}
#endif //_WIN64

//
// This is currently not used by helper dlls.
// Commented out because of security concerns
//
#if NOT_YET
//
// Context structure allocated for non-blocking IOCTLs
//

typedef struct _AFD_NBIOCTL_CONTEXT {
    AFD_REQUEST_CONTEXT Context;        // Context to keep track of request
    ULONG               PollEvent;      // Poll event to signal upon completion
    // IRP              Irp;            // Irp to queue transport
    // PCHAR            SystemBuffer;   // Input buffer if method!=3
} AFD_NBIOCTL_CONTEXT, *PAFD_NBIOCTL_CONTEXT;



NTSTATUS
FASTCALL
AfdDoTransportIoctl (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    Passes the request from the helper DLL to the TDI transport
    driver.  In oreder to let the IO system properly complete asynchronous
    IOCTL issued by the helper DLL, it should come on the socket handle
    (afd endpoint object), and then afd redirects it to the transport
    driver on the handle that herlper DLL specifies (normally address,
    connection, or control channel handle)

Arguments:
    
    Irp

    IrpSp

Return Value:

    NTSTATUS

--*/

{
    PAFD_ENDPOINT               endpoint;
    AFD_TRANSPORT_IOCTL_INFO    ioctlInfo;
    PFILE_OBJECT                fileObject;
    PDEVICE_OBJECT              deviceObject;
    ULONG                       method;
    PIRP                        newIrp;
    PIO_STACK_LOCATION          nextSp;
    PAFD_REQUEST_CONTEXT        requestCtx;
    NTSTATUS                    status;

    PAGED_CODE ();

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));

    method = IrpSp->Parameters.DeviceIoControl.IoControlCode & 3;

    if (method==METHOD_NEITHER) {

        //
        // We have to manually verify input buffer
        //

        AFD_W4_INIT status = STATUS_SUCCESS;
        try {
#ifdef _WIN64
            if (IoIs32bitProcess (Irp)) {
                PAFD_TRANSPORT_IOCTL_INFO32 ioctlInfo32;
                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (*ioctlInfo32)) {
                    status = STATUS_INVALID_PARAMETER;
                    goto Complete;
                }
                ioctlInfo32 = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                if( Irp->RequestorMode != KernelMode ) {
                    ProbeForReadSmallStructure(
                        ioctlInfo32,
                        sizeof(*ioctlInfo32),
                        PROBE_ALIGNEMENT(AFD_TRANSPORT_IOCTL_INFO32)
                        );
                }
                ioctlInfo.Handle = ioctlInfo32->Handle;
                ioctlInfo.InputBuffer = ioctlInfo32->InputBuffer;
                ioctlInfo.InputBufferLength = ioctlInfo32->InputBufferLength;
                ioctlInfo.IoControlCode = ioctlInfo32->IoControlCode;
                ioctlInfo.AfdFlags = ioctlInfo32->AfdFlags;
                ioctlInfo.PollEvent = ioctlInfo32->PollEvent;
            }
            else
#endif // _WIN64
            {
                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (ioctlInfo)) {
                    status = STATUS_INVALID_PARAMETER;
                    goto Complete;
                }

                if( Irp->RequestorMode != KernelMode ) {
                    ProbeForReadSmallStructure(
                        IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                        sizeof(ioctlInfo),
                        PROBE_ALIGNMENT(AFD_TRANSPORT_IOCTL_INFO)
                        );
                }
                ioctlInfo = *((PAFD_TRANSPORT_IOCTL_INFO)
                                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);
            }
        } except( AFD_EXCEPTION_FILTER (status) ) {

            ASSERT (NT_ERROR (status));
            //
            //  Exception accessing input structure.
            //

            goto Complete;
        }
    }
    else {

#ifdef _WIN64
        if (IoIs32bitProcess (Irp)) {
            PAFD_TRANSPORT_IOCTL_INFO32 ioctlInfo32;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (*ioctlInfo32)) {
                status = STATUS_INVALID_PARAMETER;
                goto Complete;
            }

            ioctlInfo32 = Irp->AssociatedIrp.SystemBuffer;
            ioctlInfo.Handle = ioctlInfo32->Handle;
            ioctlInfo.InputBuffer = ioctlInfo32->InputBuffer;
            ioctlInfo.InputBufferLength = ioctlInfo32->InputBufferLength;
            ioctlInfo.IoControlCode = ioctlInfo32->IoControlCode;
            ioctlInfo.AfdFlags = ioctlInfo32->AfdFlags;
            ioctlInfo.PollEvent = ioctlInfo32->PollEvent;
        }
        else
#endif // _WIN64
        {
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (ioctlInfo)) {
                status = STATUS_INVALID_PARAMETER;
                goto Complete;
            }

            //
            // Just copy the buffer verified by the IO system
            //

            ioctlInfo = *((PAFD_TRANSPORT_IOCTL_INFO)
                            Irp->AssociatedIrp.SystemBuffer);
        }

    }


    //
    // We rely as much as we can on the IO system to process
    // IOCTL parameters for us. For this we have to make
    // sure that method of AFD and helper DLL IOCTLs
    // are the same, otherwise, someone can play tricks with
    // buffer verification on us.
    //
    // If endpoint is non-blocking and request is not overlapped
    // helper DLL MUST specify an event to check before queueing
    // the request/signal upon its completion
    //

    if ((method!=(ioctlInfo.IoControlCode & 3))
            || (endpoint->NonBlocking 
                && !(ioctlInfo.AfdFlags & AFD_OVERLAPPED)
                && !ioctlInfo.PollEvent)
                ) {
        status = STATUS_INVALID_PARAMETER;
        goto Complete;
    }


    //
    // Make sure application has access to handle
    // and get object reference
    //

    status = ObReferenceObjectByHandle(
         ioctlInfo.Handle,
         (ioctlInfo.IoControlCode >> 14) & 3,   // DesiredAccess
         *IoFileObjectType,                     // Must be a file object
         Irp->RequestorMode,
         (PVOID *)&fileObject,
         NULL
         );

    if (NT_SUCCESS(status)) {
        
        //
        // Get the device object of the driver to which we send the IRP
        //

        deviceObject = IoGetRelatedDeviceObject (fileObject);

        //
        // If this is a non-blocking endpoint and IO is not overlapped
        // and the specified event is not signalled,
        // we'll have complete the helper DLL IRP with
        // STATUS_DEVICE_NOT_READY (translates to WSAEWOUDLBLOCK)
        // and queue another IRP to the transport so that
        // the specified event can be completed when IRP is completed
        //

        if (endpoint->NonBlocking 
                && !(ioctlInfo.AfdFlags & AFD_OVERLAPPED)
                && !(ioctlInfo.PollEvent & endpoint->EventsActive)) {

            PAFD_NBIOCTL_CONTEXT    nbIoctlCtx;
            USHORT                  irpSize;
            ULONG                   allocSize;

            irpSize = IoSizeOfIrp (deviceObject->StackSize);
            
            //
            // Compute the block size and check for overflow
            //
            allocSize = sizeof (*nbIoctlCtx) + irpSize + ioctlInfo.InputBufferLength;
            if (allocSize < ioctlInfo.InputBufferLength ||
                    allocSize < irpSize) {
                status = STATUS_INVALID_PARAMETER;
                ObDereferenceObject (fileObject);
                goto Complete;
            }

            //
            // Allocate an IRP and associated strucutures
            // 

            try {
                nbIoctlCtx = AFD_ALLOCATE_POOL_WITH_QUOTA (
                                NonPagedPool,
                                allocSize,
                                AFD_TRANSPORT_IRP_POOL_TAG
                                );
                            
                // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE flag
                ASSERT (nbIoctlCtx!=NULL);
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode ();
                ObDereferenceObject (fileObject);
                goto Complete;
            }

            //
            // Initialize context structures
            //

            requestCtx = &nbIoctlCtx->Context;
            requestCtx->CleanupRoutine = AfdCleanupNBTransportIoctl;
            nbIoctlCtx->PollEvent = ioctlInfo.PollEvent;

            //
            // Initialize IRP itself
            //

            newIrp = (PIRP)(nbIoctlCtx+1);
            IoInitializeIrp( newIrp, irpSize, deviceObject->StackSize);
            newIrp->RequestorMode = KernelMode;
            newIrp->Tail.Overlay.AuxiliaryBuffer = NULL;
            newIrp->Tail.Overlay.OriginalFileObject = IrpSp->FileObject;

            nextSp = IoGetNextIrpStackLocation (newIrp);

            if ((ioctlInfo.InputBuffer!=NULL)
                    &&  (ioctlInfo.InputBufferLength>0)) {

                //
                // If helper DLL specified input buffer
                // we'll have to make a copy of it in case
                // driver really pends the IRP while we complete the
                // helper DLL IRP an system frees the input buffer
                //

                PVOID   newBuffer;

                newBuffer = (PUCHAR)newIrp+IoSizeOfIrp(deviceObject->StackSize);
                AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
                try {
                    if (Irp->RequestorMode != KernelMode) {
                        ProbeForRead(
                            ioctlInfo.InputBuffer,
                            ioctlInfo.InputBufferLength,
                            sizeof(UCHAR)
                            );
                    }
                    RtlCopyMemory (newBuffer,
                                    ioctlInfo.InputBuffer,
                                    ioctlInfo.InputBufferLength);
                } except( AFD_EXCEPTION_FILTER (status) ) {

                    ASSERT (NT_ERROR (status));
                    //
                    //  Exception accessing input structure.
                    //

                    AFD_FREE_POOL (nbIoctlCtx, AFD_TRANSPORT_IRP_POOL_TAG);
                    ObDereferenceObject (fileObject);
                    goto Complete;

                }

                //
                // Store new buffer parameters in appropriate places
                // in the IRP depending on the method
                //

                if (method==METHOD_NEITHER) {
                    nextSp->Parameters.DeviceIoControl.Type3InputBuffer = newBuffer;
                    newIrp->AssociatedIrp.SystemBuffer = NULL;
                }
                else {
                    nextSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
                    newIrp->AssociatedIrp.SystemBuffer = newBuffer;
                }
                nextSp->Parameters.DeviceIoControl.InputBufferLength =
                        ioctlInfo.InputBufferLength;
            }
            else {

                //
                // No input buffer, clear correspoinding entries
                //

                nextSp->Parameters.DeviceIoControl.InputBufferLength = 0;
                nextSp->Parameters.DeviceIoControl.Type3InputBuffer =  NULL;
                newIrp->AssociatedIrp.SystemBuffer = NULL;

            }

            //
            // NOTE: We do not allow output buffer parameters on 
            // non-blocking calls because the output buffer is deallocated 
            // when we complete helper DLL IRP
            //
            //      Done during IRP initialization (IoInitializeIrp)
            // newIrp->MdlAddress = NULL;
            // newIrp->UserBuffer = NULL;
            // nextSp->Parameters.DeviceIoControl.OutputBufferLength = 0;

            IoSetCompletionRoutine( newIrp, AfdCompleteNBTransportIoctl,
                                        nbIoctlCtx,
                                        TRUE, TRUE, TRUE );
        }
        else {

            //
            // Blocking call, reuse the application's IRP
            //

            newIrp = Irp;
            nextSp = IoGetNextIrpStackLocation (Irp);
            nextSp->Parameters.DeviceIoControl.OutputBufferLength = 
                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength;


            if ((ioctlInfo.InputBuffer!=NULL)
                    && (ioctlInfo.InputBufferLength>0)) {

                //
                // If application wants to pass input buffer to transport,
                // we'll have to copy it to the system buffer allocated with
                // Irp
                //

                if (method!=METHOD_NEITHER) {
                    ULONG   sysBufferLength;
                    if (method==METHOD_BUFFERED) {
                        sysBufferLength = max (
                                            IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                            IrpSp->Parameters.DeviceIoControl.OutputBufferLength);
                    }
                    else {
                        sysBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                    }


                    //
                    // Methods 0-2 use system buffer to pass input 
                    // parameters and we need to reuse original system buffer
                    // Make sure it has enough space for this purpose
                    //

                    AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
                    try {
                        if (Irp->RequestorMode != KernelMode) {
                            ProbeForRead(
                                ioctlInfo.InputBuffer,
                                ioctlInfo.InputBufferLength,
                                sizeof(UCHAR)
                                );
                        }

                        if (ioctlInfo.InputBufferLength>sysBufferLength){
                            PVOID   newSystemBuffer;
                            newSystemBuffer = ExAllocatePoolWithQuotaTag (
                                                    NonPagedPool|POOL_RAISE_IF_ALLOCATION_FAILURE,
                                                    ioctlInfo.InputBufferLength,
                                                    AFD_SYSTEM_BUFFER_POOL_TAG
                                                    );
                            if (newSystemBuffer==NULL) {
                                ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
                            }
                            ExFreePool (Irp->AssociatedIrp.SystemBuffer);
                            Irp->AssociatedIrp.SystemBuffer = newSystemBuffer;
                        }

                        //
                        // Copy application data to the system buffer
                        //

                        RtlCopyMemory (Irp->AssociatedIrp.SystemBuffer,
                                        ioctlInfo.InputBuffer,
                                        ioctlInfo.InputBufferLength);

                    }
                    except( AFD_EXCEPTION_FILTER (status) ) {
                        ASSERT (NT_ERROR (status));
                        ObDereferenceObject (fileObject);
                        goto Complete;

                    }
                    nextSp->Parameters.DeviceIoControl.Type3InputBuffer =  NULL;
                }
                else {

                    //
                    // METHOD_NEITHER, just pass whatever application
                    // passed to use, the driver should handle it
                    // appropriately.
                    //
                    // This is of course a potentialy security breach
                    // if transport driver is buggy
                    //

                    nextSp->Parameters.DeviceIoControl.Type3InputBuffer
                                    = ioctlInfo.InputBuffer;
                }
                nextSp->Parameters.DeviceIoControl.InputBufferLength
                                            = ioctlInfo.InputBufferLength;

            }
            else {

                //
                // No input buffer, clear correspoiding parameters
                // Note that we can't clean system buffer as
                // it has to be deallocated on completion
                //

                nextSp->Parameters.DeviceIoControl.Type3InputBuffer =  NULL;
                nextSp->Parameters.DeviceIoControl.InputBufferLength = 0;
            }



            //
            // We reuse our stack location parameters area for context
            //

            requestCtx = (PAFD_REQUEST_CONTEXT)&IrpSp->Parameters.DeviceIoControl;
            requestCtx->CleanupRoutine = AfdCleanupTransportIoctl;

            IoSetCompletionRoutine( newIrp, AfdCompleteTransportIoctl,
                                            requestCtx, TRUE, TRUE, TRUE );
        }

        //
        // Set the rest of IRP fields.
        //

        nextSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        nextSp->FileObject = fileObject;
        nextSp->Parameters.DeviceIoControl.IoControlCode = ioctlInfo.IoControlCode;


        //
        // Insert context into the endpoint list so we can cancel
        // the IRP when endpoint is being closed and reference endpoint
        // so it does not go away until this IRP is completed
        //

        requestCtx->Context = newIrp;
        REFERENCE_ENDPOINT (endpoint);
        AfdEnqueueRequest(endpoint,requestCtx);

        //
        // Finally call the transport driver
        // 

        status = IoCallDriver (deviceObject, newIrp);

        //
        // We no longer need our private reference to the file object
        // IO system will take care of keeping this reference while our IRP
        // is there
        //

        ObDereferenceObject (fileObject);

        //
        // If we used helper DLL IRP, just return whatever transport
        // driver returned to us
        //

        if (newIrp==Irp)
            return status;

        //
        // If driver pended or immediately completed non-blocking call,
        // make sure helper DLL gets WSAEWOULDBLOCK. It will have to
        // call again whenever the driver completes the IRP and corresponding
        // event is set (if driver completed the IRP, event is set already).
        //

        if (NT_SUCCESS (status))
            status = STATUS_DEVICE_NOT_READY;
    }

    //
    // Complete the application request in case of processing failure or
    // non-blocking call
    //
Complete:

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;
}

NTSTATUS
AfdCompleteTransportIoctl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Called to complete transport driver IOCTL for blocking endpoints

Arguments:
    

Return Value:

    STATUS_SUCCESS - IO system should finish IRP processing
    STATUS_MORE_PROCESSING_REQUIRED - we are not yet done (we are actually
                                    in the middle of cancelling)

--*/
{
    PAFD_ENDPOINT       endpoint = Irp->Tail.Overlay.OriginalFileObject->FsContext;
    PAFD_REQUEST_CONTEXT requestCtx = Context;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    NTSTATUS        status = STATUS_SUCCESS;

    //
    // We used Parameters structure in our stack location for context
    //
    ASSERT (&(IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl)
                    ==Context);

    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // We use list entry fields to synchronize with cleanup/cancel
    // routine assuming that as long as the entry is in the list
    // both Flink and Blink fields cannot be NULL. (using these
    // fields for synchronization allows us to cut down on
    // cancel spinlock usage)
    //

    if (AfdIsRequestInQueue(requestCtx)) {

        //
        // Context is still in the list, just remove it so
        // noone can see it anymore
        //

        RemoveEntryList (&requestCtx->EndpointListLink);
    }
    else if (AfdIsRequestCompleted(requestCtx)) {

        //
        // During endpoint cleanup, this context was removed from the
        // list and cancel routine is about to be called, don't let
        // IO system free this IRP until cancel routine is called
        // Also, indicate to the cancel routine that we are done
        // with this IRP and it can complete it.
        //

        AfdMarkRequestCompleted (requestCtx);
        status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Release reference added when we posted this IRP
    //
    DEREFERENCE_ENDPOINT (endpoint);

    return status;
}
    
NTSTATUS
AfdCompleteNBTransportIoctl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Called to complete transport driver IOCTL for non-blocking endpoints

Arguments:
    

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - we handle releasing resources
                                    for this IRP ourselves

--*/
{
    PAFD_ENDPOINT        endpoint = Irp->Tail.Overlay.OriginalFileObject->FsContext;
    PAFD_NBIOCTL_CONTEXT nbIoctlCtx = Context;
    PAFD_REQUEST_CONTEXT requestCtx = &nbIoctlCtx->Context;
    AFD_LOCK_QUEUE_HANDLE   lockHandle;


    //
    // The irp should be a part of our notify structure
    //

    ASSERT (Irp==(PIRP)(nbIoctlCtx+1));
    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));



    //
    // First indicate the event reported by the driver
    //

    ASSERT (nbIoctlCtx->PollEvent!=0);
    AfdIndicatePollEvent (endpoint, 1<<nbIoctlCtx->PollEvent, Irp->IoStatus.Status);

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
    AfdIndicateEventSelectEvent (endpoint, 1<<nbIoctlCtx->PollEvent, Irp->IoStatus.Status);

    //
    // We use list entry fields to synchronize with cleanup/cancel
    // routine assuming that as long as the entry is in the list
    // both Flink and Blink fields cannot be NULL. (using these
    // fields for synchronization allows us to cut down on
    // cancel spinlock usage)
    //

    if (AfdIsRequestInQueue(requestCtx)) {
        //
        // Context is still in the list, just remove it so
        // noone can see it anymore and free the structure
        //

        RemoveEntryList (&requestCtx->EndpointListLink);
        AFD_FREE_POOL (nbIoctlCtx, AFD_TRANSPORT_IRP_POOL_TAG);
    }
    else if (AfdIsRequestCompleted (requestCtx)) {

        //
        // During endpoint cleanup, this context was removed from the
        // list and cancel routine is about to be called, don't
        // free this IRP until cancel routine is called
        // Also, indicate to the cancel routine that we are done
        // with this IRP and it can free it.
        //

        AfdMarkRequestCompleted (requestCtx);
    }
    else {
        //
        // Cancel routine has completed processing this request, free it
        //
        AFD_FREE_POOL (nbIoctlCtx, AFD_TRANSPORT_IRP_POOL_TAG);
    }
    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Release reference added when we posted this IRP
    //

    DEREFERENCE_ENDPOINT (endpoint);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


BOOLEAN
AfdCleanupTransportIoctl (
    PAFD_ENDPOINT           Endpoint,
    PAFD_REQUEST_CONTEXT    RequestCtx
    )
/*++

Routine Description:

    Cancels outstanding transport IOCTL during endpoint cleanup
    Used for blocking requests.

Arguments:
    
    Endpoint    -   endpoint on which IOCTL was issued

    RequestCtx   -  context associated with the request

Return Value:

    TRUE    - request has been completed
    FALSE   - request is still in driver's queue

--*/
{
    PIRP    Irp = RequestCtx->Context;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // First attempt to cancel the IRP, if it is already completed
    // this is just a no-op.  In no case IRP and request structure
    // could have been freed until we mark it as completed as
    // the caller of this routine should have marked the request
    // as being cancelled
    //

    ASSERT (RequestCtx->EndpointListLink.Flink==NULL);

    IoCancelIrp (Irp);

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    if (AfdIsRequestCompleted (RequestCtx)) {
        //
        // Driver has initiated the completion of the request 
        // as we were cancelling it.
        // "Complete the completion"
        //
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

        return TRUE;
    }
    else {

        //
        // Driver has not completed the request before returning
        // from cancel routine, mark the request to indicate
        // that we are done with it and completion routine
        // can free it
        //

        AfdMarkRequestCompleted (RequestCtx);
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
        return FALSE;
    }

}

BOOLEAN
AfdCleanupNBTransportIoctl (
    PAFD_ENDPOINT           Endpoint,
    PAFD_REQUEST_CONTEXT    RequestCtx
    ) 
/*++

Routine Description:

    Cancels outstanding transport IOCTL during endpoint cleanup
    Used for non-blocking requests

Arguments:
    
    Endpoint    -   endpoint on which IOCTL was issued

    RequestCtx   -  context associated with the request

Return Value:

    TRUE    - request has been completed
    FALSE   - request is still in driver's queue

--*/
{
    PIRP    Irp = RequestCtx->Context;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // The IRP should be a part of the context block, verify.
    //
    ASSERT (Irp==(PIRP)(CONTAINING_RECORD (RequestCtx, AFD_NBIOCTL_CONTEXT, Context)+1));

    //
    // First attempt to cancel the IRP, if it is already completed
    // this is just a no-op.  In no case IRP and request structure
    // could have been freed until we mark it as completed as
    // the caller of this routine should have marked the request
    // as being cancelled
    //

    ASSERT (RequestCtx->EndpointListLink.Flink==NULL);

    IoCancelIrp (Irp);
    

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    if (AfdIsRequestCompleted (RequestCtx)) {
        //
        // Driver has initiated the completion of the request 
        // as we were cancelling it.
        // Free the context structure.
        //
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
        AFD_FREE_POOL (
            CONTAINING_RECORD (RequestCtx, AFD_NBIOCTL_CONTEXT, Context),
            AFD_TRANSPORT_IRP_POOL_TAG);

        return TRUE;
    }
    else {

        //
        // Driver has not completed the request before returning
        // from cancel routine, mark the request to indicate
        // that we are done with it and completion routine
        // can free it
        //

        AfdMarkRequestCompleted (RequestCtx);
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);

        return FALSE;
    }

}
#endif // NOT_YET


NTSTATUS
AfdQueryProviderInfo (
    IN  PUNICODE_STRING TransportDeviceName,
#ifdef _AFD_VARIABLE_STACK_
    OUT CCHAR *StackSize OPTIONAL,
#endif //_AFD_VARIABLE_STACK
    OUT PTDI_PROVIDER_INFO ProviderInfo
    )

/*++

Routine Description:

    Returns a provider information structure corresponding to the
    specified TDI transport provider.

Arguments:

    TransportDeviceName - the name of the TDI transport provider.
    ProviderInfo    - buffer to place provider info into

Return Value:

    STATUS_SUCCESS  - returned transport info is valid.
    STATUS_OBJECT_NAME_NOT_FOUND - transport's device is not available yet

--*/
{
    NTSTATUS status;
    HANDLE controlChannel;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    TDI_REQUEST_KERNEL_QUERY_INFORMATION kernelQueryInfo;


    PAGED_CODE ();

    //
    // Set up the IRP stack location information to query the TDI
    // provider information.
    //

    kernelQueryInfo.QueryType = TDI_QUERY_PROVIDER_INFORMATION;
    kernelQueryInfo.RequestConnectionInformation = NULL;

    //
    // Open a control channel to the TDI provider.
    // We ask to create a kernel handle which is 
    // the handle in the context of the system process
    // so that application cannot close it on us while
    // we are creating and referencing it.
    //

    InitializeObjectAttributes(
        &objectAttributes,
        TransportDeviceName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,       // attributes
        NULL,
        NULL
        );

    status = IoCreateFile(
                 &controlChannel,
                 MAXIMUM_ALLOWED,
                 &objectAttributes,
                 &iosb,                          // returned status information.
                 0,                              // block size (unused).
                 0,                              // file attributes.
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_CREATE,                    // create disposition.
                 0,                              // create options.
                 NULL,                           // eaInfo
                 0,                              // eaLength
                 CreateFileTypeNone,             // CreateFileType
                 NULL,                           // ExtraCreateParameters
                 IO_FORCE_ACCESS_CHECK           // Options
                    | IO_NO_PARAMETER_CHECKING
                 );
    if ( NT_SUCCESS(status) ) {

        PFILE_OBJECT    controlObject;

        status = ObReferenceObjectByHandle (
                 controlChannel,                            // Handle
                 MAXIMUM_ALLOWED,                           // DesiredAccess
                 *IoFileObjectType,                         // ObjectType
                 KernelMode,                                // AccessMode
                 (PVOID *)&controlObject,                   // Object,
                 NULL                                       // HandleInformation
                 );

        if (NT_SUCCESS (status)) {

#ifdef _AFD_VARIABLE_STACK_
            if (ARGUMENT_PRESENT (StackSize)) {
                *StackSize = IoGetRelatedDeviceObject (controlObject)->StackSize;
            }
#endif // _AFD_VARIABLE_STACK_

            //
            // Get the TDI provider information for the transport.
            //

            status = AfdIssueDeviceControl(
                         controlObject,
                         &kernelQueryInfo,
                         sizeof(kernelQueryInfo),
                         ProviderInfo,
                         sizeof(*ProviderInfo),
                         TDI_QUERY_INFORMATION
                         );

            ObDereferenceObject (controlObject);
        }

        ZwClose( controlChannel );
    }

    if (!NT_SUCCESS (status)) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                    "AfdQueryProviderInfo:"
                    "Transport %*ls failed provider info query with status %lx.\n",
                    TransportDeviceName->Length/2, TransportDeviceName->Buffer, status));
    }

    return status;
}



BOOLEAN
AfdCancelIrp (
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked to cancel an individual I/O Request Packet.
    It is similiar to IoCancelIrp() except that it *must* be called with
    the cancel spin lock held.  This routine exists because of the
    synchronization requirements of the cancellation/completion of
    transmit IRPs.

Arguments:

    Irp - Supplies a pointer to the IRP to be cancelled.  The CancelIrql
        field of the IRP must have been correctly initialized with the
        IRQL from the cancel spin lock acquisition.


Return Value:

    The function value is TRUE if the IRP was in a cancellable state (it
    had a cancel routine), else FALSE is returned.

Notes:

    It is assumed that the caller has taken the necessary action to ensure
    that the packet cannot be fully completed before invoking this routine.

--*/

{
    PDRIVER_CANCEL cancelRoutine;

    //
    // Make sure that the cancel spin lock is held.
    //

    ASSERT( KeGetCurrentIrql( ) == DISPATCH_LEVEL );

    //
    // Set the cancel flag in the IRP.
    //

    Irp->Cancel = TRUE;

    //
    // Obtain the address of the cancel routine, and if one was specified,
    // invoke it.
    //

    cancelRoutine = IoSetCancelRoutine( Irp, NULL );
    if (cancelRoutine) {
        if (Irp->CurrentLocation > (CCHAR) (Irp->StackCount + 1)) {
            KeBugCheckEx( CANCEL_STATE_IN_COMPLETED_IRP, (ULONG_PTR) Irp, 0, 0, 0 );
        }
        cancelRoutine( Irp->Tail.Overlay.CurrentStackLocation->DeviceObject,
                       Irp );
        //
        // The cancel spinlock should have been released by the cancel routine.
        //

        return(TRUE);

    } else {

        //
        // There was no cancel routine, so release the cancel spinlock and
        // return indicating the Irp was not currently cancelable.
        //

        IoReleaseCancelSpinLock( Irp->CancelIrql );

        return(FALSE);
    }

} // AfdCancelIrp


VOID
AfdTrimLookaside (
    PNPAGED_LOOKASIDE_LIST  Lookaside
    )
{
    PVOID   entry;
#if DBG
    LONG count = 0;
#endif

    while (ExQueryDepthSList (&(Lookaside->L.ListHead))>Lookaside->L.Depth*2) {
        entry = InterlockedPopEntrySList(
                                &Lookaside->L.ListHead);
        if (entry) {
#if DBG
            count++;
#endif
            (Lookaside->L.Free)(entry);
        }
        else {
            break;
        }
    }
#if DBG
    if (count>0) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AFD: Flushed %d items from lookaside list @ %p\n",
                     count, Lookaside));
    }
#endif
}


VOID
AfdCheckLookasideLists (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    LONG i;
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

#if DBG
    ASSERT (Dpc==&AfdLookasideLists->Dpc);
    ASSERT (DeferredContext==AfdLookasideLists);
#else
    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (DeferredContext);
#endif
    for (i=0; i<AFD_NUM_LOOKASIDE_LISTS; i++) {
        if (ExQueryDepthSList (&(AfdLookasideLists->List[i].L.ListHead)) >
                                AfdLookasideLists->List[i].L.Depth*2) {
            if (AfdLookasideLists->TrimFlags & (1<<i)) {
                AfdTrimLookaside (&AfdLookasideLists->List[i]);
                AfdLookasideLists->TrimFlags &= (~(1<<i));
            }
            else {
                AfdLookasideLists->TrimFlags |= (1<<i);
            }
        }
        else if (AfdLookasideLists->TrimFlags & (1<<i)) {
            AfdLookasideLists->TrimFlags &= (~(1<<i));
        }
    }
}



VOID
AfdLRListAddItem (
    PAFD_LR_LIST_ITEM  Item,
    PAFD_LR_LIST_ROUTINE Routine
    )
/*++

    Adds item to low resource list and starts low resource timer if not already
    started.
Arguments:

    Item   - item to add
    Routine  - routine to execute when timeout expires.

Return Value:
    None

Notes:

--*/

{
    LONG    count;
    Item->Routine = Routine;
    InterlockedPushEntrySList (
                &AfdLRList,
                &Item->SListLink);

    count = InterlockedIncrement (&AfdLRListCount);
    ASSERT (count>0);
    if (count==1) {
        AfdLRStartTimer ();
    }
}


VOID
AfdLRListTimeout (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

    DPC routine for low resource list timer
    Simply schedules worker thread - do not want to do low resource processing at DPC
--*/
{
    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (DeferredContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);
    AfdQueueWorkItem (AfdProcessLRList, &AfdLRListWorker);
}

VOID
AfdProcessLRList (
    PVOID   Param
    )
/*++

Routine Description:

    Processeses  items on low resource list and reschedules processing
    if unprocessed items remain (still failing to buffer data due to 
    low resource condition)

Arguments:

    None
Return Value:

    None
Notes:

--*/
{
    PSLIST_ENTRY  localList, entry;
    LONG    count = 0;

    UNREFERENCED_PARAMETER (Param);
    PAGED_CODE ();

    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                "AFD: Processing low resource list: %ld entries\n",
                AfdLRListCount));

    //
    // Flush the list
    //
    localList = InterlockedFlushSList (&AfdLRList);


    //
    // Reverse it to preserve order of processing (FIFO).
    //
    entry = NULL;
    while (localList!=NULL) {
        PSLIST_ENTRY  next;
        next = localList->Next;
        localList->Next = entry;
        entry = localList;
        localList = next;
    }

    localList = entry; 
    while (localList!=NULL) {
        PAFD_LR_LIST_ITEM   item;
        entry = localList;
        localList = localList->Next;
        item = CONTAINING_RECORD (entry, AFD_LR_LIST_ITEM, SListLink);

        //
        // Try to restart receive processing on connection where buffer allocation failed
        //
        if (item->Routine (item)) {
            //
            // Success, decrement number of items outstanding,
            // and note current number of items.  If we did not empty
            // the list, we'll have to restart the timer.
            //
            count = InterlockedDecrement (&AfdLRListCount);
            ASSERT (count>=0);
        }
        else {
            //
            // Failure, put it back on the list.  Note, that we have at list one
            // item there and thus have to restart the timer again.
            //
            InterlockedPushEntrySList (&AfdLRList, &item->SListLink);
            count = 1;
        }
    }

    if (count!=0) {
        //
        // We did not empty the list, so restart the timer.
        //
        AfdLRStartTimer ();
    }
}


VOID
AfdLRStartTimer (
    VOID
    )
/*++

Routine Description:

    Start low resource timer to retry receive operation on connections
    that could not buffer data due to low reaource condition.
Arguments:

    None
Return Value:

    None
Notes:

--*/

{
    LARGE_INTEGER   timeout;
    BOOLEAN         res;
    timeout.QuadPart = -50000000i64;     // 5 seconds

#if DBG
    {
        TIME_FIELDS timeFields;
        LARGE_INTEGER currentTime;
        LARGE_INTEGER localTime;

        KeQuerySystemTime (&currentTime);
        currentTime.QuadPart -= timeout.QuadPart;
        ExSystemTimeToLocalTime (&currentTime, &localTime);
        RtlTimeToTimeFields (&localTime, &timeFields);
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AFD: Scheduling low resource timer for %2.2d:%2.2d:%2.2d\n",
                    timeFields.Hour,
                    timeFields.Minute,
                    timeFields.Second));
    }
#endif

    KeInitializeDpc(
        &AfdLRListDpc,
        AfdLRListTimeout,
        &AfdLRList
        );

    KeInitializeTimer( &AfdLRListTimer );

    res = KeSetTimer(
                &AfdLRListTimer,
                timeout,
                &AfdLRListDpc
                );
    ASSERT (res==FALSE);

}

#ifdef _AFD_VARIABLE_STACK_

VOID
AfdFixTransportEntryPointsForBigStackSize (
    IN OUT PAFD_TRANSPORT_INFO  TransportInfo,
    IN CCHAR                    StackSize
    )
{
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );
    
    TransportInfo->StackSize = StackSize;
    if (TransportInfo->StackSize>AfdTdiStackSize) {
        if (TransportInfo->StackSize>AfdMaxStackSize) {
            AfdMaxStackSize = TransportInfo->StackSize;
        }
        TransportInfo->GetBuffer = AfdGetBufferWithMaxStackSize;
        TransportInfo->GetTpInfo = AfdGetTpInfoWithMaxStackSize;
        TransportInfo->CallDriver = AfdCallDriverStackIncrease;
    }
    
    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();
}

VOID
AfdCancelStackIncreaseIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIRP    newIrp;

    UNREFERENCED_PARAMETER (DeviceObject);
    
    newIrp = (PIRP)Irp->IoStatus.Information;
    newIrp->Cancel = TRUE;
    newIrp->CancelIrql = Irp->CancelIrql;
    AfdCancelIrp (newIrp);
}

NTSTATUS
AfdRestartStackIncreaseIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIRP    oldIrp = Context;
    UNREFERENCED_PARAMETER (DeviceObject);
    if (IoSetCancelRoutine (oldIrp, NULL)==NULL) {
        KIRQL   oldIrql;
        IoAcquireCancelSpinLock (&oldIrql);
        IoReleaseCancelSpinLock (oldIrql);
    }
    oldIrp->IoStatus = Irp->IoStatus;
    IoCompleteRequest (oldIrp, AfdPriorityBoost);
    IoFreeIrp (Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


PIRP
AfdGetStackIncreaseIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIRP    newIrp;
    newIrp = IoAllocateIrp (DeviceObject->StackSize, FALSE);
    if (newIrp!=NULL) {
        *IoGetNextIrpStackLocation (newIrp) = *IoGetCurrentIrpStackLocation (Irp);
        IoSetCompletionRoutine (newIrp, AfdRestartStackIncreaseIrp, Irp, TRUE, TRUE, TRUE);
        newIrp->MdlAddress = Irp->MdlAddress;
        newIrp->Tail.Overlay.Thread = Irp->Tail.Overlay.Thread;
        Irp->IoStatus.Information = (ULONG_PTR)newIrp;

        IoSetCancelRoutine (Irp, AfdCancelStackIncreaseIrp);
        newIrp->Cancel = Irp->Cancel;
    }
    return newIrp;
}


NTSTATUS
FASTCALL
AfdCallDriverStackIncrease (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{

    if (Irp->CurrentLocation <= DeviceObject->StackSize) {
        PIRP    newIrp;

        IoSetNextIrpStackLocation (Irp);
        newIrp = AfdGetStackIncreaseIrp (DeviceObject, Irp);
        if (newIrp!=NULL) {
            IoMarkIrpPending (Irp);
            IoCallDriver (DeviceObject, newIrp);
            return STATUS_PENDING;
        }
        else {
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest (Irp, AfdPriorityBoost);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {
        return IoCallDriver (DeviceObject, Irp);
    }
}

PIRP
AfdGetStackIncreaseIrpAndRecordIt (
    IN PAFD_ENDPOINT Endpoint,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
#if DBG
                    ,
    IN PCHAR File,
    IN ULONG Line
#endif
    )
{
#if DBG
    if (AfdRecordOutstandingIrpDebug (Endpoint, DeviceObject, Irp, File, Line))
#else
    if (AfdRecordOutstandingIrp(Endpoint,DeviceObject,Irp))
#endif
    {
        PIRP    newIrp;
        IoSetNextIrpStackLocation (Irp);
        newIrp = AfdGetStackIncreaseIrp (DeviceObject, Irp);
        if (newIrp!=NULL) {
            return newIrp;
        }
        AfdCompleteOutstandingIrp (Endpoint, Irp);
    }
    return NULL;
}

#endif // _AFD_VARIABLE_STACK_

#ifdef _AFD_VERIFY_DATA_

VOID
AfdVerifyBuffer (
    PAFD_CONNECTION Connection,
    PVOID           Buffer,
    ULONG           Length
    )
{

    if (Connection->VerifySequenceNumber!=0) {
        PUCHAR  start, end;
        ULONGLONG   seq;

        for (start=Buffer,
                end = (PUCHAR)Buffer+Length,
                seq = Connection->VerifySequenceNumber-1;
                            start<end;
                            seq++, start++) {
            ULONG num = (ULONG)(seq/4);
            ULONG byte = (ULONG)(seq%4);

            if (*start!=(UCHAR)(num>>(byte*8))) {
                DbgPrint ("AfdVerifyBuffer: Data sequence number mismatch on connection %p:\n"
                          "     data buffer-%p, offset-%lx, expected-%2.2lx, got-%2.2lx.\n",
                          Connection,
                          Buffer,
                          start-(PUCHAR)Buffer,
                          (UCHAR)(num>>(byte*8)),
                          *start);

                DbgBreakPoint ();
                //
                // Disable verification to continue.
                //
                Connection->VerifySequenceNumber = 0;
                return;
            }
        }
        Connection->VerifySequenceNumber = seq+1;
    }
}

VOID
AfdVerifyMdl (
    PAFD_CONNECTION Connection,
    PMDL            Mdl,
    ULONG           Offset,
    ULONG           Length
    ) {
    if (Connection->VerifySequenceNumber!=0) {
        while (Mdl!=NULL) {
            if (Offset>=MmGetMdlByteCount (Mdl)) {
                Offset-=MmGetMdlByteCount (Mdl);
            }
            else if (Length<=MmGetMdlByteCount (Mdl)-Offset) {
                AfdVerifyBuffer (Connection,
                    (PUCHAR)MmGetSystemAddressForMdl (Mdl)+Offset,
                    Length);
                break;
            }
            else {
                AfdVerifyBuffer (Connection,
                    (PUCHAR)MmGetSystemAddressForMdl (Mdl)+Offset,
                    MmGetMdlByteCount (Mdl)-Offset
                    );
                Length-=(MmGetMdlByteCount (Mdl)-Offset);
                Offset = 0;
            }
            Mdl = Mdl->Next;
        }
    }
}

ULONG   AfdVerifyType = 0;
ULONG   AfdVerifyPort = 0;
PEPROCESS AfdVerifyProcess = NULL;

VOID
AfdVerifyAddress (
    PAFD_CONNECTION Connection,
    PTRANSPORT_ADDRESS Address
    )
{
    Connection->VerifySequenceNumber = 0;

    if ((AfdVerifyPort==0) ||
            ((AfdVerifyProcess!=NULL) &&
                (AfdVerifyProcess!=Connection->OwningProcess)) ||
            ((AfdVerifyType!=0) &&
                (AfdVerifyType!=(USHORT)Address->Address[0].AddressType))
                ) {
        return;
    }

    switch (Address->Address[0].AddressType) {
    case TDI_ADDRESS_TYPE_IP : {

            TDI_ADDRESS_IP UNALIGNED * ip;

            ip = (PVOID)&Address->Address[0].Address[0];
            if (ip->sin_port!=(USHORT)AfdVerifyPort) {
                return;
            }
        }
        break;

    case TDI_ADDRESS_TYPE_IPX : {

            TDI_ADDRESS_IPX UNALIGNED * ipx;

            ipx = (PVOID)&Address->Address[0].Address[0];
            if (ipx->Socket!=(USHORT)AfdVerifyPort) {
                return;
            }
        }
        break;

    case TDI_ADDRESS_TYPE_APPLETALK : {

            TDI_ADDRESS_APPLETALK UNALIGNED * atalk;

            atalk = (PVOID)&Address->Address[0].Address[0];
            if (atalk->Socket!=(UCHAR)AfdVerifyPort) {
                return;
            }
        }
        break;

    default:
        if (AfdVerifyType==0)
            return;
        DbgPrint ("AfdVerifyAddress: connection-%8.8lx, addres-%8.8lx\n",
                    Connection, Address);
        DbgBreakPoint ();

    }

    Connection->VerifySequenceNumber = 1;
}
#endif // _AFD_VERIFY_DATA_

LONG
AfdExceptionFilter(
#if DBG
    IN  PCHAR SourceFile,
    IN  LONG LineNumber,
#endif
    IN  PEXCEPTION_POINTERS ExceptionPointers,
    OUT PNTSTATUS           ExceptionCode OPTIONAL
    )
{


    PAGED_CODE ();

    //
    // Return exception code and translate alignment warnings into 
    // alignment errors if requested.
    //

    if (ExceptionCode) {
        *ExceptionCode = ExceptionPointers->ExceptionRecord->ExceptionCode;
        if (*ExceptionCode == STATUS_DATATYPE_MISALIGNMENT) {
            *ExceptionCode = STATUS_DATATYPE_MISALIGNMENT_ERROR;
        }
    }

#if DBG
    //
    // Protect ourselves in case the process is totally messed up.
    //

    try {

        PCHAR fileName;
        //
        // Strip off the path from the source file.
        //

        fileName = strrchr( SourceFile, '\\' );

        if( fileName == NULL ) {
            fileName = SourceFile;
        } else {
            fileName++;
        }

        //
        // Whine about the exception.
        //

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
            "AfdExceptionFilter: exception %08lx @ %08lx, caught in %s:%d\n",
            ExceptionPointers->ExceptionRecord->ExceptionCode,
            ExceptionPointers->ExceptionRecord->ExceptionAddress,
            fileName,
            LineNumber
            ));

    }
    except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // Not much we can do here...
        //

        NOTHING;

    }
#endif //DBG

    return EXCEPTION_EXECUTE_HANDLER;

}   // AfdExceptionFilter

#if DBG
LONG
AfdApcExceptionFilter(
    PEXCEPTION_POINTERS ExceptionPointers,
    PCHAR SourceFile,
    LONG LineNumber
    )
{

    PCHAR fileName;

    PAGED_CODE ();

    //
    // Protect ourselves in case the process is totally messed up.
    //

    try {

        //
        // Strip off the path from the source file.
        //

        fileName = strrchr( SourceFile, '\\' );

        if( fileName == NULL ) {
            fileName = SourceFile;
        } else {
            fileName++;
        }

        //
        // Whine about the exception.
        //

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
            "AfdApcExceptionFilter: exception %08lx, exr:%p cxr:%p, caught in %s:%d\n",
            ExceptionPointers->ExceptionRecord->ExceptionCode,
            ExceptionPointers->ExceptionRecord,
            ExceptionPointers->ContextRecord,
            fileName,
            LineNumber
            ));
        DbgBreakPoint ();

    }
    except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // Not much we can do here...
        //

        NOTHING;

    }

    return EXCEPTION_CONTINUE_SEARCH;

}   // AfdApcExceptionFilter
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\recvdg.c ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    recvdg.c

Abstract:

    This module contains routines for handling data receive for datagram
    endpoints.

Author:

    David Treadwell (davidtr)    7-Oct-1993

Revision History:

--*/

#include "afdp.h"

NTSTATUS
AfdRestartReceiveDatagramWithUserIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartBufferReceiveDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdReceiveDatagram )
#pragma alloc_text( PAGEAFD, AfdReceiveDatagramEventHandler )
#pragma alloc_text( PAGEAFD, AfdSetupReceiveDatagramIrp )
#pragma alloc_text( PAGEAFD, AfdRestartBufferReceiveDatagram )
#pragma alloc_text( PAGEAFD, AfdRestartReceiveDatagramWithUserIrp )
#pragma alloc_text( PAGEAFD, AfdCancelReceiveDatagram )
#pragma alloc_text( PAGEAFD, AfdCleanupReceiveDatagramIrp )
#endif

//
// Macros to make the receive datagram code more maintainable.
//

#define AfdRecvDatagramInfo         Others

#define AfdRecvAddressMdl           Argument1
#define AfdRecvAddressLenMdl        Argument2
#define AfdRecvControlLenMdl        Argument3
#define AfdRecvFlagsMdl             Argument4
#define AfdRecvMsgControlMdl        Tail.Overlay.DriverContext[0]
#define AfdRecvLength               Tail.Overlay.DriverContext[1]
#define AfdRecvDgIndStatus          DeviceIoControl.OutputBufferLength


NTSTATUS
FASTCALL
AfdReceiveDatagram (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT endpoint;
    PLIST_ENTRY listEntry;
    BOOLEAN peek;
    PAFD_BUFFER_HEADER afdBuffer;
    ULONG recvFlags;
    ULONG afdFlags;
    ULONG recvLength;
    PVOID addressPointer;
    PMDL addressMdl;
    PULONG addressLengthPointer;
    ULONG addressLength;
    PMDL lengthMdl;
    PVOID controlPointer;
    PMDL controlMdl;
    ULONG controlLength;
    PULONG controlLengthPointer;
    PMDL controlLengthMdl;
    PULONG flagsPointer;
    PMDL flagsMdl;
    ULONG   bufferCount;

    //
    // Set up some local variables.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_DGRAM_ENDPOINT(endpoint) );


    Irp->IoStatus.Information = 0;

    addressMdl = NULL;
    lengthMdl = NULL;
    controlMdl = NULL;
    flagsMdl = NULL;
    controlLengthMdl = NULL;

    if (!IS_DGRAM_ENDPOINT(endpoint)) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }
    //
    // If receive has been shut down or the endpoint aborted, fail.
    //
    // !!! Do we care if datagram endpoints get aborted?
    //

    if ( (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) ) {
        status = STATUS_PIPE_DISCONNECTED;
        goto complete;
    }


    //
    // Make sure that the endpoint is in the correct state.
    //

    if ( endpoint->State != AfdEndpointStateBound &&
         endpoint->State != AfdEndpointStateConnected) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    //
    // Do some special processing based on whether this is a receive
    // datagram IRP, a receive IRP, or a read IRP.
    //

    if ( IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL ) {
        if ( IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                                    IOCTL_AFD_RECEIVE_MESSAGE) {
#ifdef _WIN64
            if (IoIs32bitProcess (Irp)) {
                PAFD_RECV_MESSAGE_INFO32 msgInfo32;
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                        sizeof(*msgInfo32) ) {
                    status = STATUS_INVALID_PARAMETER;
                    goto complete;
                }
                AFD_W4_INIT status = STATUS_SUCCESS;
                try {
                    msgInfo32 = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                    if( Irp->RequestorMode != KernelMode ) {

                        ProbeForReadSmallStructure(
                            msgInfo32,
                            sizeof(*msgInfo32),
                            PROBE_ALIGNMENT32 (AFD_RECV_MESSAGE_INFO32)
                            );
                    }

                    controlPointer = UlongToPtr(msgInfo32->ControlBuffer);
                    controlLengthPointer = UlongToPtr(msgInfo32->ControlLength);
                    flagsPointer = UlongToPtr(msgInfo32->MsgFlags);

                }
                except (AFD_EXCEPTION_FILTER (status)) {
                    ASSERT (NT_ERROR (status));
                    goto complete;
                }
            }
            else 
#endif _WIN64
            {
                PAFD_RECV_MESSAGE_INFO msgInfo;
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                        sizeof(*msgInfo) ) {
                    status = STATUS_INVALID_PARAMETER;
                    goto complete;
                }

                AFD_W4_INIT status = STATUS_SUCCESS;
                try {
                    msgInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                    if( Irp->RequestorMode != KernelMode ) {

                        ProbeForReadSmallStructure(
                            msgInfo,
                            sizeof(*msgInfo),
                            PROBE_ALIGNMENT (AFD_RECV_MESSAGE_INFO)
                            );

                    }
                    controlPointer = msgInfo->ControlBuffer;
                    controlLengthPointer = msgInfo->ControlLength;
                    flagsPointer = msgInfo->MsgFlags;
                }
                except (AFD_EXCEPTION_FILTER (status)) {
                    ASSERT (NT_ERROR (status));
                    goto complete;
                }
            }

            AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
            try {
                //
                // Create a MDL describing the length buffer, then probe it
                // for write access.
                //

                flagsMdl = IoAllocateMdl(
                                 flagsPointer,              // VirtualAddress
                                 sizeof(*flagsPointer),     // Length
                                 FALSE,                     // SecondaryBuffer
                                 TRUE,                      // ChargeQuota
                                 NULL                       // Irp
                                 );

                if( flagsMdl == NULL ) {

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto complete;

                }

                MmProbeAndLockPages(
                    flagsMdl,                               // MemoryDescriptorList
                    Irp->RequestorMode,                     // AccessMode
                    IoWriteAccess                           // Operation
                    );


                controlLengthMdl = IoAllocateMdl(
                                 controlLengthPointer,      // VirtualAddress
                                 sizeof(*controlLengthPointer),// Length
                                 FALSE,                     // SecondaryBuffer
                                 TRUE,                      // ChargeQuota
                                 NULL                       // Irp
                                 );

                if( controlLengthMdl == NULL ) {

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto complete;

                }

                MmProbeAndLockPages(
                    controlLengthMdl,                       // MemoryDescriptorList
                    Irp->RequestorMode,                     // AccessMode
                    IoWriteAccess                           // Operation
                    );


                controlLength = *controlLengthPointer;
                if (controlLength!=0) {
                    //
                    // Create a MDL describing the control buffer, then probe
                    // it for write access.
                    //

                    controlMdl = IoAllocateMdl(
                                     controlPointer,            // VirtualAddress
                                     controlLength,             // Length
                                     FALSE,                     // SecondaryBuffer
                                     TRUE,                      // ChargeQuota
                                     NULL                       // Irp
                                     );

                    if( controlMdl == NULL ) {

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto complete;

                    }

                    MmProbeAndLockPages(
                        controlMdl,                             // MemoryDescriptorList
                        Irp->RequestorMode,                     // AccessMode
                        IoWriteAccess                           // Operation
                        );
                }

            } except( AFD_EXCEPTION_FILTER (status) ) {
                ASSERT (NT_ERROR (status));
                goto complete;

            }
            //
            // Change the control code to continue processing of the regular
            // RecvFrom parameters.
            //
            IrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_AFD_RECEIVE_DATAGRAM;
        }

        if ( IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                                    IOCTL_AFD_RECEIVE_DATAGRAM) {
#ifdef _WIN64
            if (IoIs32bitProcess (Irp)) {
                PAFD_RECV_DATAGRAM_INFO32 recvInfo32;
                LPWSABUF32 bufferArray32;

                //
                // Grab the parameters from the input structure.
                //

                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                        sizeof(*recvInfo32) ) {

                    AFD_W4_INIT status = STATUS_SUCCESS;
                    try {

                        //
                        // Validate the input structure if it comes from the user mode 
                        // application
                        //

                        recvInfo32 = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                        if( Irp->RequestorMode != KernelMode ) {

                            ProbeForReadSmallStructure(
                                recvInfo32,
                                sizeof(*recvInfo32),
                                PROBE_ALIGNMENT32(AFD_RECV_DATAGRAM_INFO32)
                                );

                        }

                        //
                        // Make local copies of the embeded pointer and parameters
                        // that we will be using more than once in case malicios
                        // application attempts to change them while we are
                        // validating
                        //

                        recvFlags = recvInfo32->TdiFlags;
                        afdFlags = recvInfo32->AfdFlags;
                        bufferArray32 = UlongToPtr(recvInfo32->BufferArray);
                        bufferCount = recvInfo32->BufferCount;
                        addressPointer = UlongToPtr(recvInfo32->Address);
                        addressLengthPointer = UlongToPtr(recvInfo32->AddressLength);


                        //
                        // Validate the WSABUF parameters.
                        //

                        if ( bufferArray32 != NULL &&
                            bufferCount > 0 ) {

                            //
                            // Create the MDL chain describing the WSABUF array.
                            // This will also validate the buffer array and individual
                            // buffers
                            //

                            status = AfdAllocateMdlChain32(
                                         Irp,       // Requestor mode passed along
                                         bufferArray32,
                                         bufferCount,
                                         IoWriteAccess,
                                         &recvLength
                                         );
                            if (!NT_SUCCESS (status)) {
                                goto complete;
                            }

                        } else {
                            //
                            // Zero-length input buffer. This is OK for datagrams.
                            //
                            ASSERT( Irp->MdlAddress == NULL );
                            status = STATUS_SUCCESS;
                            recvLength = 0;
                        }

                    } except ( AFD_EXCEPTION_FILTER (status) ) {
                        ASSERT (NT_ERROR (status));
                        //
                        // Exception accessing input structure.
                        //
                        goto complete;
                    }

                } else {
                    //
                    // Invalid input buffer length.
                    //
                    status = STATUS_INVALID_PARAMETER;
                    goto complete;
                }
            }
            else
#endif _WIN64
            {
                PAFD_RECV_DATAGRAM_INFO recvInfo;
                LPWSABUF bufferArray;

                //
                // Grab the parameters from the input structure.
                //

                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                        sizeof(*recvInfo) ) {

                    AFD_W4_INIT status = STATUS_SUCCESS;
                    try {

                        //
                        // Validate the input structure if it comes from the user mode 
                        // application
                        //

                        recvInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                        if( Irp->RequestorMode != KernelMode ) {

                            ProbeForReadSmallStructure(
                                recvInfo,
                                sizeof(*recvInfo),
                                PROBE_ALIGNMENT(AFD_RECV_DATAGRAM_INFO)
                                );

                        }

                        //
                        // Make local copies of the embeded pointer and parameters
                        // that we will be using more than once in case malicios
                        // application attempts to change them while we are
                        // validating
                        //

                        recvFlags = recvInfo->TdiFlags;
                        afdFlags = recvInfo->AfdFlags;
                        bufferArray = recvInfo->BufferArray;
                        bufferCount = recvInfo->BufferCount;
                        addressPointer = recvInfo->Address;
                        addressLengthPointer = recvInfo->AddressLength;


                        //
                        // Validate the WSABUF parameters.
                        //

                        if ( bufferArray != NULL &&
                            bufferCount > 0 ) {

                            //
                            // Create the MDL chain describing the WSABUF array.
                            // This will also validate the buffer array and individual
                            // buffers
                            //

                            status = AfdAllocateMdlChain(
                                         Irp,       // Requestor mode passed along
                                         bufferArray,
                                         bufferCount,
                                         IoWriteAccess,
                                         &recvLength
                                         );
                            if (!NT_SUCCESS (status)) {
                                goto complete;
                            }

                        } else {

                            //
                            // Zero-length input buffer. This is OK for datagrams.
                            //

                            ASSERT( Irp->MdlAddress == NULL );
                            recvLength = 0;
                            status = STATUS_SUCCESS;

                        }

                    } except ( AFD_EXCEPTION_FILTER (status) ) {
                        ASSERT (NT_ERROR (status));
                        //
                        // Exception accessing input structure.
                        //
                        goto complete;
                    }

                } else {
                    //
                    // Invalid input buffer length.
                    //

                    status = STATUS_INVALID_PARAMETER;
                    goto complete;
                }
            }


            //
            // Validate the receive flags.
            //

            if( ( recvFlags & TDI_RECEIVE_EITHER ) != TDI_RECEIVE_NORMAL ) {
                status = STATUS_NOT_SUPPORTED;
                goto complete;
            }

            peek = (BOOLEAN)( (recvFlags & TDI_RECEIVE_PEEK) != 0 );
            //
            // If only one of addressPointer or addressLength are NULL, then
            // fail the request.
            //

            if( (addressPointer == NULL) ^ (addressLengthPointer == NULL) ) {

                status = STATUS_INVALID_PARAMETER;
                goto complete;

            }
            //
            // If the user wants the source address from the receive datagram,
            // then create MDLs for the address & address length, then probe
            // and lock the MDLs.
            //

            if( addressPointer != NULL ) {

                ASSERT( addressLengthPointer != NULL );

                AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
                try {

                    //
                    // Create a MDL describing the length buffer, then probe it
                    // for write access.
                    //

                    lengthMdl = IoAllocateMdl(
                                     addressLengthPointer,      // VirtualAddress
                                     sizeof(*addressLengthPointer),// Length
                                     FALSE,                     // SecondaryBuffer
                                     TRUE,                      // ChargeQuota
                                     NULL                       // Irp
                                     );

                    if( lengthMdl == NULL ) {

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto complete;

                    }

                    MmProbeAndLockPages(
                        lengthMdl,                              // MemoryDescriptorList
                        Irp->RequestorMode,                     // AccessMode
                        IoWriteAccess                           // Operation
                        );

                    //
                    // Save length to a local so that malicious app
                    // cannot break us by modifying the value in the middle of
                    // us processing it below here. Also, we can use this pointer now
                    // since we probed it above.
                    //
                    addressLength = *addressLengthPointer;


                    //
                    // Bomb off if the user is trying to do something bad, like
                    // specify a zero-length address, or one that's unreasonably
                    // huge. Here, we define "unreasonably huge" as MAXUSHORT
                    // or greater because TDI address length field is USHORT.
                    //

                    if( addressLength == 0 ||
                        addressLength >= MAXUSHORT ) {

                        status = STATUS_INVALID_PARAMETER;
                        goto complete;

                    }

                    //
                    // Create a MDL describing the address buffer, then probe
                    // it for write access.
                    //

                    addressMdl = IoAllocateMdl(
                                     addressPointer,            // VirtualAddress
                                     addressLength,             // Length
                                     FALSE,                     // SecondaryBuffer
                                     TRUE,                      // ChargeQuota
                                     NULL                       // Irp
                                     );

                    if( addressMdl == NULL ) {

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto complete;

                    }

                    MmProbeAndLockPages(
                        addressMdl,                             // MemoryDescriptorList
                        Irp->RequestorMode,                     // AccessMode
                        IoWriteAccess                           // Operation
                        );

                } except( AFD_EXCEPTION_FILTER (status) ) {

                    ASSERT (NT_ERROR (status));
                    goto complete;

                }

                ASSERT( addressMdl != NULL );
                ASSERT( lengthMdl != NULL );

            } else {

                ASSERT( addressMdl == NULL );
                ASSERT( lengthMdl == NULL );

            }


        } else {

            ASSERT( (Irp->Flags & IRP_INPUT_OPERATION) == 0 );


            //
            // Grab the input parameters from the IRP.
            //

            ASSERT( IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                        IOCTL_AFD_RECEIVE );

            recvFlags = ((PAFD_RECV_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->TdiFlags;
            afdFlags = ((PAFD_RECV_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->AfdFlags;
            recvLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

            //
            // It is illegal to attempt to receive expedited data on a
            // datagram endpoint.
            //

            if ( (recvFlags & TDI_RECEIVE_EXPEDITED) != 0 ) {
                status = STATUS_NOT_SUPPORTED;
                goto complete;
            }

            ASSERT( ( recvFlags & TDI_RECEIVE_EITHER ) == TDI_RECEIVE_NORMAL );

            peek = (BOOLEAN)( (recvFlags & TDI_RECEIVE_PEEK) != 0 );

        }
    } else {

        //
        // This must be a read IRP.  There are no special options
        // for a read IRP.
        //

        ASSERT( IrpSp->MajorFunction == IRP_MJ_READ );

        recvFlags = TDI_RECEIVE_NORMAL;
        afdFlags = AFD_OVERLAPPED;
        recvLength = IrpSp->Parameters.Read.Length;
        peek = FALSE;
    }

    //
    // Save the address & length MDLs in the current IRP stack location.
    // These will be used later in SetupReceiveDatagramIrp().  Note that
    // they should either both be NULL or both be non-NULL.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if endpoint was cleaned-up and cancel the request.
    //
    if (endpoint->EndpointCleanedUp) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = STATUS_CANCELLED;
        goto complete;
    }

    ASSERT( !( ( addressMdl == NULL ) ^ ( lengthMdl == NULL ) ) );

    IrpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressMdl = addressMdl;
    IrpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressLenMdl = lengthMdl;
    IrpSp->Parameters.AfdRecvDatagramInfo.AfdRecvControlLenMdl = controlLengthMdl;
    IrpSp->Parameters.AfdRecvDatagramInfo.AfdRecvFlagsMdl = flagsMdl;
    Irp->AfdRecvMsgControlMdl = controlMdl;
    Irp->AfdRecvLength = UlongToPtr (recvLength);


    //
    // Determine whether there are any datagrams already bufferred on
    // this endpoint.  If there is a bufferred datagram, we'll use it to
    // complete the IRP.
    //
    if ( ARE_DATAGRAMS_ON_ENDPOINT(endpoint) ) {


        //
        // There is at least one datagram bufferred on the endpoint.
        // Use it for this receive.
        //

        ASSERT( !IsListEmpty( &endpoint->ReceiveDatagramBufferListHead ) );

        listEntry = endpoint->ReceiveDatagramBufferListHead.Flink;
        afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );

        //
        // Prepare the user's IRP for completion.
        //

        if (NT_SUCCESS(afdBuffer->Status)) {
            PAFD_BUFFER buf = CONTAINING_RECORD (afdBuffer, AFD_BUFFER, Header);
            ASSERT (afdBuffer->BufferLength!=AfdBufferTagSize);
            status = AfdSetupReceiveDatagramIrp (
                         Irp,
                         buf->Buffer,
                         buf->DataLength,
                         (PUCHAR)buf->Buffer+afdBuffer->DataLength,
                         buf->DataOffset,
                         buf->TdiInfo.RemoteAddress,
                         buf->TdiInfo.RemoteAddressLength,
                         buf->DatagramFlags
                         );
        }
        else {
            //
            // This is error report from the transport
            // (ICMP_PORT_UNREACHEABLE)
            //
            Irp->IoStatus.Status = afdBuffer->Status;
            ASSERT (afdBuffer->DataLength==0);
            Irp->IoStatus.Information = 0;
            status = AfdSetupReceiveDatagramIrp (
                         Irp,
                         NULL, 0,
                         NULL, 0,
                         afdBuffer->TdiInfo.RemoteAddress,
                         afdBuffer->TdiInfo.RemoteAddressLength,
                         0
                         );
        }

        //
        // If this wasn't a peek IRP, remove the buffer from the endpoint's
        // list of bufferred datagrams.
        //

        if ( !peek ) {

            RemoveHeadList( &endpoint->ReceiveDatagramBufferListHead );

            //
            // Update the counts of bytes and datagrams on the endpoint.
            //

            endpoint->DgBufferredReceiveCount--;
            endpoint->DgBufferredReceiveBytes -= afdBuffer->DataLength;
            endpoint->EventsActive &= ~AFD_POLL_RECEIVE;

            IF_DEBUG(EVENT_SELECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdReceiveDatagram: Endp %p, Active %lx\n",
                    endpoint,
                    endpoint->EventsActive
                    ));
            }

            if( ARE_DATAGRAMS_ON_ENDPOINT(endpoint)) {

                AfdIndicateEventSelectEvent(
                    endpoint,
                    AFD_POLL_RECEIVE,
                    STATUS_SUCCESS
                    );

            }
            else {
                //
                // Disable fast IO path to avoid performance penalty
                // of unneccessarily going through it.
                //
                if (!endpoint->NonBlocking)
                    endpoint->DisableFastIoRecv = TRUE;
            }
        }

        //
        // We've set up all return information.  Clean up and complete
        // the IRP.
        //

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        if ( !peek ) {
            AfdReturnBuffer( afdBuffer, endpoint->OwningProcess );
        }

        UPDATE_ENDPOINT2 (endpoint,
            "AfdReceiveDatagram, completing with error/bytes: 0x%lX",
                NT_SUCCESS (Irp->IoStatus.Status)
                    ? (ULONG)Irp->IoStatus.Information
                    : (ULONG)Irp->IoStatus.Status);

        IoCompleteRequest( Irp, 0 );

        return status;
    }

    //
    // There were no datagrams bufferred on the endpoint.  If this is a
    // nonblocking endpoint and the request was a normal receive (as
    // opposed to a read IRP), fail the request.  We don't fail reads
    // under the asumption that if the application is doing reads they
    // don't want nonblocking behavior.
    //

    if ( endpoint->NonBlocking && !( afdFlags & AFD_OVERLAPPED ) ) {

        endpoint->EventsActive &= ~AFD_POLL_RECEIVE;

        IF_DEBUG(EVENT_SELECT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdReceiveDatagram: Endp %p, Active %lx\n",
                endpoint,
                endpoint->EventsActive
                ));
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        status = STATUS_DEVICE_NOT_READY;
        goto complete;
    }

    //
    // We'll have to pend the IRP.  Place the IRP on the appropriate IRP
    // list in the endpoint.
    //

    if ( peek ) {
        InsertTailList(
            &endpoint->PeekDatagramIrpListHead,
            &Irp->Tail.Overlay.ListEntry
            );
    } else {
        InsertTailList(
            &endpoint->ReceiveDatagramIrpListHead,
            &Irp->Tail.Overlay.ListEntry
            );
    }

    //
    // Set up the cancellation routine in the IRP.  If the IRP has already
    // been cancelled, just call the cancellation routine here.
    //

    IoSetCancelRoutine( Irp, AfdCancelReceiveDatagram );

    if ( Irp->Cancel ) {

        RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
        if (IoSetCancelRoutine( Irp, NULL ) != NULL) {
    
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        
            status = STATUS_CANCELLED;
            goto complete;
        }
        //
        // The cancel routine will run and complete the irp.
        // Set Flink to NULL so it knows that IRP is not on the list.
        //
        Irp->Tail.Overlay.ListEntry.Flink = NULL;
    
    }

    IoMarkIrpPending( Irp );

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    return STATUS_PENDING;

complete:

    ASSERT( !NT_SUCCESS(status) );

    if( addressMdl != NULL ) {
        if( (addressMdl->MdlFlags & MDL_PAGES_LOCKED) != 0 ) {
            MmUnlockPages( addressMdl );
        }
        IoFreeMdl( addressMdl );
    }

    if( lengthMdl != NULL ) {
        if( (lengthMdl->MdlFlags & MDL_PAGES_LOCKED) != 0 ) {
            MmUnlockPages( lengthMdl );
        }
        IoFreeMdl( lengthMdl );
    }

    if (controlMdl != NULL) {
        if( (controlMdl->MdlFlags & MDL_PAGES_LOCKED) != 0 ) {
            MmUnlockPages( controlMdl );
        }
        IoFreeMdl( controlMdl );
    }

    if (controlLengthMdl != NULL) {
        if( (controlLengthMdl->MdlFlags & MDL_PAGES_LOCKED) != 0 ) {
            MmUnlockPages( controlLengthMdl );
        }
        IoFreeMdl( controlLengthMdl );
    }

    if (flagsMdl != NULL) {
        if( (flagsMdl->MdlFlags & MDL_PAGES_LOCKED) != 0 ) {
            MmUnlockPages( flagsMdl );
        }
        IoFreeMdl( flagsMdl );
    }

    UPDATE_ENDPOINT2 (endpoint,
        "AfdReceiveDatagram, completing with error 0x%lX",
         (ULONG)Irp->IoStatus.Status);

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, 0 );

    return status;

} // AfdReceiveDatagram



NTSTATUS
AfdReceiveDatagramEventHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )

/*++

Routine Description:

    Handles receive datagram events for nonbufferring transports.

Arguments:


Return Value:


--*/

{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT endpoint;
    PAFD_BUFFER afdBuffer;
    BOOLEAN result;

    //
    // Reference the endpoint so that it doesn't go away beneath us.
    //

    endpoint = TdiEventContext;
    ASSERT( endpoint != NULL );

    CHECK_REFERENCE_ENDPOINT (endpoint, result);
    if (!result)
        return STATUS_INSUFFICIENT_RESOURCES;
    
    ASSERT( IS_DGRAM_ENDPOINT(endpoint) );

#if AFD_PERF_DBG
    if ( BytesAvailable == BytesIndicated ) {
        AfdFullReceiveDatagramIndications++;
    } else {
        AfdPartialReceiveDatagramIndications++;
    }
#endif

    //
    // If this endpoint is connected and the datagram is for a different
    // address than the one the endpoint is connected to, drop the
    // datagram.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    if ( (endpoint->State == AfdEndpointStateConnected &&
            !endpoint->Common.Datagram.HalfConnect &&
            !AfdAreTransportAddressesEqual(
               endpoint->Common.Datagram.RemoteAddress,
               endpoint->Common.Datagram.RemoteAddressLength,
               SourceAddress,
               SourceAddressLength,
               TRUE ))) {
        endpoint->Common.Datagram.AddressDrop = TRUE;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        *BytesTaken = BytesAvailable;
        DEREFERENCE_ENDPOINT (endpoint);
        return STATUS_SUCCESS;
    }

    //
    // Check whether there are any IRPs waiting on the endpoint.  If
    // there is such an IRP, use it to receive the datagram.
    //

    while ( !IsListEmpty( &endpoint->ReceiveDatagramIrpListHead ) ) {
        PLIST_ENTRY listEntry;
        PIRP    irp;

        ASSERT( *BytesTaken == 0 );
        ASSERT( endpoint->DgBufferredReceiveCount == 0 );
        ASSERT( endpoint->DgBufferredReceiveBytes == 0 );

        listEntry = RemoveHeadList( &endpoint->ReceiveDatagramIrpListHead );

        //
        // Get a pointer to the IRP and reset the cancel routine in
        // the IRP.  The IRP is no longer cancellable.
        //

        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        
        if ( IoSetCancelRoutine( irp, NULL ) == NULL ) {

            //
            // This IRP is about to be canceled.  Look for another in the
            // list.  Set the Flink to NULL so the cancel routine knows
            // it is not on the list.
            //

            irp->Tail.Overlay.ListEntry.Flink = NULL;
            continue;
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Copy the datagram and source address to the IRP.  This
        // prepares the IRP to be completed.
        //
        // !!! do we need a special version of this routine to
        //     handle special RtlCopyMemory, like for
        //     TdiCopyLookaheadBuffer?
        //

        if( BytesIndicated == BytesAvailable ||
            irp->MdlAddress == NULL ) {

            //
            // Set BytesTaken to indicate that we've taken all the
            // data.  We do it here because we already have
            // BytesAvailable in a register, which probably won't
            // be true after making function calls.
            //

            *BytesTaken = BytesAvailable;

            //
            // If the entire datagram is being indicated to us here, just
            // copy the information to the MDL in the IRP and return.
            //
            // Note that we'll also take the entire datagram if the user
            // has pended a zero-byte datagram receive (detectable as a
            // NULL Irp->MdlAddress). We'll eat the datagram and fall
            // through to AfdSetupReceiveDatagramIrp(), which will store
            // an error status in the IRP since the user's buffer is
            // insufficient to hold the datagram.
            //
            (VOID)AfdSetupReceiveDatagramIrp (
                      irp,
                      Tsdu,
                      BytesAvailable,
                      Options,
                      OptionsLength,
                      SourceAddress,
                      SourceAddressLength,
                      ReceiveDatagramFlags
                      );

            DEREFERENCE_ENDPOINT2 (endpoint,
                "AfdReceiveDatagramEventHandler, completing with error/bytes: 0x%lX",
                    NT_SUCCESS (irp->IoStatus.Status)
                        ? (ULONG)irp->IoStatus.Information
                        : (ULONG)irp->IoStatus.Status);
            //
            // Complete the IRP.  We've already set BytesTaken
            // to tell the provider that we have taken all the data.
            //

            IoCompleteRequest( irp, AfdPriorityBoost );

            return STATUS_SUCCESS;
        }
        else {
            PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation (irp);
            //
            // Otherwise, just copy the address and options.
            // and remember the error code if any.
            //
            irpSp->Parameters.AfdRecvDgIndStatus = 
                AfdSetupReceiveDatagramIrp (
                      irp,
                      NULL,
                      BytesAvailable,
                      Options,
                      OptionsLength,
                      SourceAddress,
                      SourceAddressLength,
                      ReceiveDatagramFlags
                      );

            TdiBuildReceiveDatagram(
                irp,
                endpoint->AddressDeviceObject,
                endpoint->AddressFileObject,
                AfdRestartReceiveDatagramWithUserIrp,
                endpoint,
                irp->MdlAddress,
                BytesAvailable,
                NULL,
                NULL,
                0
                );

#ifdef _AFD_VARIABLE_STACK_
            if ((irp=AfdCheckStackSizeAndRecordOutstandingIrp (
                            endpoint,
                            endpoint->AddressDeviceObject,
                            irp))!=NULL) {
#else // _AFD_VARIABLE_STACK_
           if (AfdRecordOutstandingIrp (endpoint, endpoint->AddressDeviceObject, irp)) {
#endif // _AFD_VARIABLE_STACK_
                //
                // Make the next stack location current.  Normally IoCallDriver would
                // do this, but since we're bypassing that, we do it directly.
                //

                IoSetNextIrpStackLocation( irp );

                *IoRequestPacket = irp;
                *BytesTaken = 0;

                return STATUS_MORE_PROCESSING_REQUIRED;
            }
            else {
                return STATUS_SUCCESS;
            }
        }
    } 

    //
    // There were no IRPs available to take the datagram, so we'll have
    // to buffer it.  First make sure that we're not over the limit
    // of bufferring that we can do.  If we're over the limit, toss
    // this datagram.
    //

    if (( (endpoint->DgBufferredReceiveBytes >=
             endpoint->Common.Datagram.MaxBufferredReceiveBytes) ||
          (endpoint->DgBufferredReceiveBytes==0 &&                        
                (endpoint->DgBufferredReceiveCount*sizeof (AFD_BUFFER_TAG)) >=
                            endpoint->Common.Datagram.MaxBufferredReceiveBytes) )
                            ) {

        //
        // If circular queueing is not enabled, then just drop the
        // datagram on the floor.
        //
        endpoint->Common.Datagram.BufferDrop = TRUE;
        if( !endpoint->Common.Datagram.CircularQueueing ) {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            *BytesTaken = BytesAvailable;
            DEREFERENCE_ENDPOINT (endpoint);
            return STATUS_SUCCESS;

        }

        //
        // Circular queueing is enabled, so drop packets at the head of
        // the receive queue until we're below the receive limit.
        //

        while( endpoint->DgBufferredReceiveBytes >=
             endpoint->Common.Datagram.MaxBufferredReceiveBytes ||
            (endpoint->DgBufferredReceiveBytes==0 &&                        
                (endpoint->DgBufferredReceiveCount*sizeof (AFD_BUFFER_TAG)) >=
                            endpoint->Common.Datagram.MaxBufferredReceiveBytes) ) {
            PLIST_ENTRY listEntry;
            PAFD_BUFFER_HEADER afdBufferHdr;
            endpoint->DgBufferredReceiveCount--;
            listEntry = RemoveHeadList( &endpoint->ReceiveDatagramBufferListHead );

            afdBufferHdr = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );
            endpoint->DgBufferredReceiveBytes -= afdBufferHdr->DataLength;
            AfdReturnBuffer( afdBufferHdr, endpoint->OwningProcess );

        }

        //
        // Proceed to accept the incoming packet.
        //

    }

    //
    // We're able to buffer the datagram.  Now acquire a buffer of
    // appropriate size.
    //

    afdBuffer = AfdGetBuffer (
                    endpoint,
                    BytesAvailable
                    + ((ReceiveDatagramFlags & TDI_RECEIVE_CONTROL_INFO) 
                        ? OptionsLength 
                        : 0),
                    SourceAddressLength,
                    endpoint->OwningProcess );

    if (afdBuffer==NULL) {
        endpoint->Common.Datagram.ResourceDrop = TRUE;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        *BytesTaken = BytesAvailable;
        DEREFERENCE_ENDPOINT (endpoint);
        return STATUS_SUCCESS;
    }

    //
    // Store the address of the sender of the datagram.
    //

    RtlCopyMemory(
        afdBuffer->TdiInfo.RemoteAddress,
        SourceAddress,
        SourceAddressLength
        );

    afdBuffer->TdiInfo.RemoteAddressLength = SourceAddressLength;


    //
    // Store what transport is supposed to return to us.
    //
    afdBuffer->DataLength = BytesAvailable;

    //
    // Note the receive flags.
    afdBuffer->DatagramFlags = ReceiveDatagramFlags;

    //
    // Copy control info into the buffer after the data and
    // store the length as data offset
    //
    if (ReceiveDatagramFlags & TDI_RECEIVE_CONTROL_INFO) {
        RtlMoveMemory (
                (PUCHAR)afdBuffer->Buffer+BytesAvailable, 
                Options,
                OptionsLength);
        afdBuffer->DataOffset = OptionsLength;
    }
    else {
        afdBuffer->DataOffset = 0;
    }

    //
    // If the entire datagram is being indicated to us, just copy it
    // here.
    //

    if ( BytesIndicated == BytesAvailable ) {
        PIRP    irp;
        //
        // If there is a peek IRP on the endpoint, remove it from the
        // list and prepare to complete it.  We can't complete it now
        // because we hold a spin lock.
        //

        irp = NULL;

        while ( !IsListEmpty( &endpoint->PeekDatagramIrpListHead ) ) {
            PLIST_ENTRY listEntry;

            //
            // Remove the first peek IRP from the list and get a pointer
            // to it.
            //

            listEntry = RemoveHeadList( &endpoint->PeekDatagramIrpListHead );
            irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

            //
            // Reset the cancel routine in the IRP.  The IRP is no
            // longer cancellable, since we're about to complete it.
            //

            if ( IoSetCancelRoutine( irp, NULL ) == NULL ) {

                //
                // This IRP is about to be canceled.  Look for another in the
                // list.  Set the Flink to NULL so the cancel routine knows
                // it is not on the list.
                //
    
                irp->Tail.Overlay.ListEntry.Flink = NULL;
                irp = NULL;
                continue;
            }

            break;
        }

        //
        // Use the special function to copy the data instead of
        // RtlCopyMemory in case the data is coming from a special place
        // (DMA, etc.) which cannot work with RtlCopyMemory.
        //


        TdiCopyLookaheadData(
            afdBuffer->Buffer,
            Tsdu,
            BytesAvailable,
            ReceiveDatagramFlags
            );


        //
        // Store the results in the IRP as though it is completed
        // by the transport.
        //

        afdBuffer->Irp->IoStatus.Status = STATUS_SUCCESS;
        afdBuffer->Irp->IoStatus.Information = BytesAvailable;


        //
        // Store success status do distinguish this from
        // ICMP rejects reported by ErrorEventHandler(Ex).
        //

        afdBuffer->Status = STATUS_SUCCESS;


        //
        // Place the buffer on this endpoint's list of bufferred datagrams
        // and update the counts of datagrams and datagram bytes on the
        // endpoint.
        //

        InsertTailList(
            &endpoint->ReceiveDatagramBufferListHead,
            &afdBuffer->BufferListEntry
            );

        endpoint->DgBufferredReceiveCount++;
        endpoint->DgBufferredReceiveBytes += BytesAvailable;

        //
        // Reenable FAST IO on the endpoint to allow quick
        // copying of buffered data.
        //
        endpoint->DisableFastIoRecv = FALSE;

        //
        // All done.  Release the lock and tell the provider that we
        // took all the data.
        //

        AfdIndicateEventSelectEvent(
            endpoint,
            AFD_POLL_RECEIVE,
            STATUS_SUCCESS
            );

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Indicate that it is possible to receive on the endpoint now.
        //

        AfdIndicatePollEvent(
            endpoint,
            AFD_POLL_RECEIVE,
            STATUS_SUCCESS
            );

        //
        // If there was a peek IRP on the endpoint, complete it now.
        //

        if ( irp != NULL ) {
            //
            // Copy the datagram and source address to the IRP.  This
            // prepares the IRP to be completed.
            //

            (VOID)AfdSetupReceiveDatagramIrp (
                      irp,
                      Tsdu,
                      BytesAvailable,
                      Options,
                      OptionsLength,
                      SourceAddress,
                      SourceAddressLength,
                      ReceiveDatagramFlags
                      );

            IoCompleteRequest( irp, AfdPriorityBoost  );
        }

        *BytesTaken = BytesAvailable;

        DEREFERENCE_ENDPOINT (endpoint);
        return STATUS_SUCCESS;
    }
    else {

        //
        // We'll have to format up an IRP and give it to the provider to
        // handle.  We don't need any locks to do this--the restart routine
        // will check whether new receive datagram IRPs were pended on the
        // endpoint.
        //

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );


        //
        // We need to remember the endpoint in the AFD buffer because we'll
        // need to access it in the completion routine.
        //

        afdBuffer->Context = endpoint;

        ASSERT (afdBuffer->Irp->MdlAddress==afdBuffer->Mdl);
        TdiBuildReceiveDatagram(
            afdBuffer->Irp,
            endpoint->AddressDeviceObject,
            endpoint->AddressFileObject,
            AfdRestartBufferReceiveDatagram,
            afdBuffer,
            afdBuffer->Irp->MdlAddress,
            BytesAvailable,
            NULL,
            NULL,
            0
            );


        //
        // Make the next stack location current.  Normally IoCallDriver would
        // do this, but since we're bypassing that, we do it directly.
        //

        IoSetNextIrpStackLocation( afdBuffer->Irp );

        *IoRequestPacket = afdBuffer->Irp;
        *BytesTaken = 0;

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

} // AfdReceiveDatagramEventHandler

NTSTATUS
AfdRestartReceiveDatagramWithUserIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Handles completion of datagram receives that were started
    in the datagram indication handler and application IRP was
    available for direct transfer.

Arguments:

    DeviceObject - not used.

    Irp - the IRP that is completing.

    Context - referenced endpoint pointer.

Return Value:

    STATUS_SUCCESS to indicate that IO completion should continue.

--*/

{
    PAFD_ENDPOINT   endpoint = Context;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation (Irp);
    NTSTATUS    indStatus = irpSp->Parameters.AfdRecvDgIndStatus;

    UNREFERENCED_PARAMETER (DeviceObject);
    ASSERT( IS_DGRAM_ENDPOINT(endpoint) );

    AfdCompleteOutstandingIrp (endpoint, Irp);

    //
    // Pick the worst status
    //
    if ((Irp->IoStatus.Status==STATUS_SUCCESS) ||
        (!NT_ERROR (Irp->IoStatus.Status) && NT_ERROR(indStatus)) ||
        (NT_SUCCESS (Irp->IoStatus.Status) && !NT_SUCCESS (indStatus)) ) {
        Irp->IoStatus.Status = indStatus;
    }

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    DEREFERENCE_ENDPOINT2 (endpoint, 
                "AfdRestartReceiveDatagramWithUserIrp, error/bytes 0x%lX",
                NT_SUCCESS (Irp->IoStatus.Status) 
                    ? (ULONG)Irp->IoStatus.Information
                    : (ULONG)Irp->IoStatus.Status);
    return STATUS_SUCCESS;
    
}


NTSTATUS
AfdRestartBufferReceiveDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Handles completion of bufferred datagram receives that were started
    in the datagram indication handler.

Arguments:

    DeviceObject - not used.

    Irp - the IRP that is completing.

    Context - AfdBuffer structure.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED to indicate to the IO system that we
    own the IRP and the IO system should stop processing the it.

--*/

{
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_BUFFER afdBuffer;
    PIRP pendedIrp;

    UNREFERENCED_PARAMETER (DeviceObject);
    ASSERT( NT_SUCCESS(Irp->IoStatus.Status) );

    afdBuffer = Context;
    ASSERT (IS_VALID_AFD_BUFFER (afdBuffer));
    ASSERT (afdBuffer->DataOffset==0 ||
                (afdBuffer->DatagramFlags & TDI_RECEIVE_CONTROL_INFO));

    endpoint = afdBuffer->Context;
    ASSERT( IS_DGRAM_ENDPOINT(endpoint) );



    //
    // If the IO failed, then just return the AFD buffer to our buffer
    // pool.
    //

    if ( !NT_SUCCESS(Irp->IoStatus.Status) ) {
        AfdReturnBuffer( &afdBuffer->Header, endpoint->OwningProcess );
        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
        endpoint->Common.Datagram.ErrorDrop = TRUE;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        DEREFERENCE_ENDPOINT2 (endpoint, 
            "AfdRestartBufferReceiveDatagram, status: 0x%lX",
            Irp->IoStatus.Status);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    // Make sure transport did not lie to us in indication handler.
    //
    ASSERT (afdBuffer->DataLength == (ULONG)Irp->IoStatus.Information);



    //
    // If there are any pended IRPs on the endpoint, complete as
    // appropriate with the new information.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    while ( !IsListEmpty( &endpoint->ReceiveDatagramIrpListHead ) ) {
        PLIST_ENTRY listEntry;

        //
        // There was a pended receive datagram IRP.  Remove it from the
        // head of the list.
        //

        listEntry = RemoveHeadList( &endpoint->ReceiveDatagramIrpListHead );

        //
        // Get a pointer to the IRP and reset the cancel routine in
        // the IRP.  The IRP is no longer cancellable.
        //

        pendedIrp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

        //
        // Reset the cancel routine in the IRP.  The IRP is no
        // longer cancellable, since we're about to complete it.
        //

        if ( IoSetCancelRoutine( pendedIrp, NULL ) == NULL ) {

            //
            // This IRP is about to be canceled.  Look for another in the
            // list.  Set the Flink to NULL so the cancel routine knows
            // it is not on the list.
            //

            pendedIrp->Tail.Overlay.ListEntry.Flink = NULL;
            pendedIrp = NULL;
            continue;
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Set up the user's IRP for completion.
        //

        (VOID)AfdSetupReceiveDatagramIrp (
                  pendedIrp,
                  afdBuffer->Buffer,
                  afdBuffer->DataLength,
                  (PUCHAR)afdBuffer->Buffer+afdBuffer->DataLength, 
                  afdBuffer->DataOffset,
                  afdBuffer->TdiInfo.RemoteAddress,
                  afdBuffer->TdiInfo.RemoteAddressLength,
                  afdBuffer->DatagramFlags
                  );

        //
        // Complete the user's IRP, free the AFD buffer we used for
        // the request, and tell the IO system that we're done
        // processing this request.
        //

        AfdReturnBuffer( &afdBuffer->Header, endpoint->OwningProcess );

        DEREFERENCE_ENDPOINT2 (endpoint, 
            "AfdRestartBufferReceiveDatagram, completing IRP with 0x%lX bytes",
            (ULONG)pendedIrp->IoStatus.Information);

        IoCompleteRequest( pendedIrp, AfdPriorityBoost );

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    // If there are any pended peek IRPs on the endpoint, complete
    // one with this datagram.
    //

    pendedIrp = NULL;

    while ( !IsListEmpty( &endpoint->PeekDatagramIrpListHead ) ) {
        PLIST_ENTRY listEntry;

        //
        // There was a pended peek receive datagram IRP.  Remove it from
        // the head of the list.
        //

        listEntry = RemoveHeadList( &endpoint->PeekDatagramIrpListHead );

        //
        // Get a pointer to the IRP and reset the cancel routine in
        // the IRP.  The IRP is no longer cancellable.
        //

        pendedIrp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

        //
        // Reset the cancel routine in the IRP.  The IRP is no
        // longer cancellable, since we're about to complete it.
        //

        if ( IoSetCancelRoutine( pendedIrp, NULL ) == NULL ) {


            //
            // This IRP is about to be canceled.  Look for another in the
            // list.  Set the Flink to NULL so the cancel routine knows
            // it is not on the list.
            //

            pendedIrp->Tail.Overlay.ListEntry.Flink = NULL;
            pendedIrp = NULL;
            continue;
        }

        //
        // Set up the user's IRP for completion.
        //

        (VOID)AfdSetupReceiveDatagramIrp (
                  pendedIrp,
                  afdBuffer->Buffer,
                  afdBuffer->DataLength,
                  (PUCHAR)afdBuffer->Buffer+afdBuffer->DataLength, 
                  afdBuffer->DataOffset,
                  afdBuffer->TdiInfo.RemoteAddress,
                  afdBuffer->TdiInfo.RemoteAddressLength,
                  afdBuffer->DatagramFlags
                  );

        //
        // Don't complete the pended peek IRP yet, since we still hold
        // locks.  Wait until it is safe to release the locks.
        //

        break;
    }

    //
    // Store success status do distinguish this from
    // ICMP rejects reported by ErrorEventHandler(Ex).
    //

    afdBuffer->Status = STATUS_SUCCESS;

    //
    // Place the datagram at the end of the endpoint's list of bufferred
    // datagrams, and update counts of datagrams on the endpoint.
    //

    InsertTailList(
        &endpoint->ReceiveDatagramBufferListHead,
        &afdBuffer->BufferListEntry
        );

    endpoint->DgBufferredReceiveCount++;
    endpoint->DgBufferredReceiveBytes += afdBuffer->DataLength;

    //
    // Reenable FAST IO on the endpoint to allow quick
    // copying of buffered data.
    //
    endpoint->DisableFastIoRecv = FALSE;

    //
    // Release locks and indicate that there are bufferred datagrams
    // on the endpoint.
    //

    AfdIndicateEventSelectEvent(
        endpoint,
        AFD_POLL_RECEIVE,
        STATUS_SUCCESS
        );

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    AfdIndicatePollEvent(
        endpoint,
        AFD_POLL_RECEIVE,
        STATUS_SUCCESS
        );

    //
    // If there was a pended peek IRP to complete, complete it now.
    //

    if ( pendedIrp != NULL ) {
        IoCompleteRequest( pendedIrp, 2 );
    }

    //
    // Tell the IO system to stop processing this IRP, since we now own
    // it as part of the AFD buffer.
    //

    DEREFERENCE_ENDPOINT (endpoint);

    return STATUS_MORE_PROCESSING_REQUIRED;

} // AfdRestartBufferReceiveDatagram


VOID
AfdCancelReceiveDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Cancels a receive datagram IRP that is pended in AFD.

Arguments:

    DeviceObject - not used.

    Irp - the IRP to cancel.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    UNREFERENCED_PARAMETER (DeviceObject);
    //
    // Get the endpoint pointer from our IRP stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    endpoint = irpSp->FileObject->FsContext;

    ASSERT( IS_DGRAM_ENDPOINT(endpoint) );

    //
    // Remove the IRP from the endpoint's IRP list, synchronizing with
    // the endpoint lock which protects the lists.  Note that the
    // IRP *must* be on one of the endpoint's lists or the Flink is NULL
    // if we are getting called here--anybody that removes the IRP from
    // the list must reset the cancel routine to NULL and set the
    // Flink to NULL before releasing the endpoint spin lock.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    if (Irp->Tail.Overlay.ListEntry.Flink != NULL) {

        RemoveEntryList( &Irp->Tail.Overlay.ListEntry );

    }

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Free any MDL chains attached to the IRP stack location.
    //

    AfdCleanupReceiveDatagramIrp( Irp );

    //
    // Release the cancel spin lock and complete the IRP with a
    // cancellation status code.
    //

    IoReleaseCancelSpinLock( Irp->CancelIrql );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_CANCELLED;

    IoCompleteRequest( Irp, AfdPriorityBoost );

    return;

} // AfdCancelReceiveDatagram


BOOLEAN
AfdCleanupReceiveDatagramIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    Performs any cleanup specific to receive datagram IRPs.

Arguments:

    Irp - the IRP to cleanup.

Return Value:

    TRUE - complete IRP, FALSE - leave alone.

Notes:

    This routine may be called at raised IRQL from AfdCompleteIrpList().

--*/

{
    PIO_STACK_LOCATION irpSp;
    PMDL mdl;

    //
    // Get the endpoint pointer from our IRP stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Free any MDL chains attached to the IRP stack location.
    //

    mdl = (PMDL)irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressMdl;

    if( mdl != NULL ) {
        irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressMdl = NULL;
        MmUnlockPages( mdl );
        IoFreeMdl( mdl );
    }

    mdl = (PMDL)irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressLenMdl;

    if( mdl != NULL ) {
        irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressLenMdl = NULL;
        MmUnlockPages( mdl );
        IoFreeMdl( mdl );
    }

    mdl = (PMDL)irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvControlLenMdl;

    if( mdl != NULL ) {
        irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvControlLenMdl = NULL;
        MmUnlockPages( mdl );
        IoFreeMdl( mdl );
    }

    mdl = (PMDL)irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvFlagsMdl;

    if( mdl != NULL ) {
        irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvFlagsMdl = NULL;
        MmUnlockPages( mdl );
        IoFreeMdl( mdl );
    }

    mdl = (PMDL)Irp->AfdRecvMsgControlMdl;

    if( mdl != NULL ) {
        Irp->AfdRecvMsgControlMdl = NULL;
        MmUnlockPages( mdl );
        IoFreeMdl( mdl );
    }
    return TRUE;

} // AfdCleanupReceiveDatagramIrp


NTSTATUS
AfdSetupReceiveDatagramIrp (
    IN PIRP Irp,
    IN PVOID DatagramBuffer OPTIONAL,
    IN ULONG DatagramLength,
    IN PVOID ControlBuffer OPTIONAL,
    IN ULONG ControlLength,
    IN PVOID SourceAddress OPTIONAL,
    IN ULONG SourceAddressLength,
    IN ULONG TdiReceiveFlags
    )

/*++

Routine Description:

    Copies the datagram to the MDL in the IRP and the datagram sender's
    address to the appropriate place in the system buffer.

Arguments:

    Irp - the IRP to prepare for completion.

    DatagramBuffer - datagram to copy into the IRP.  If NULL, then
        there is no need to copy the datagram to the IRP's MDL, the
        datagram has already been copied there.

    DatagramLength - the length of the datagram to copy.

    SourceAddress - address of the sender of the datagram.

    SourceAddressLength - length of the source address.

Return Value:

    NTSTATUS - The status code placed into the IRP.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN dataOverflow = FALSE;
    BOOLEAN controlOverflow = FALSE;

    //
    // To determine how to complete setting up the IRP for completion,
    // figure out whether this IRP was for regular datagram information,
    // in which case we need to return an address, or for data only, in
    // which case we will not return the source address.  NtReadFile()
    // and recv() on connected datagram sockets will result in the
    // latter type of IRP.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // If necessary, copy the datagram in the buffer to the MDL in the
    // user's IRP.  If there is no MDL in the buffer, then fail if the
    // datagram is larger than 0 bytes.
    //

    if ( ARGUMENT_PRESENT( DatagramBuffer ) ) {
        ULONG bytesCopied = 0;

        if ( Irp->MdlAddress == NULL ) {

            if ( DatagramLength != 0 ) {
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                status = STATUS_SUCCESS;
            }

        } else {

            status = AfdMapMdlChain (Irp->MdlAddress);
            if (NT_SUCCESS (status)) {
                status = TdiCopyBufferToMdl(
                         DatagramBuffer,
                         0,
                         DatagramLength,
                         Irp->MdlAddress,
                         0,
                         &bytesCopied
                         );
            }
        }

        Irp->IoStatus.Information = bytesCopied;

    } else {

        //
        // The information was already copied to the MDL chain in the
        // IRP.  Just remember the IO status block so we can do the
        // right thing with it later.
        //

        status = Irp->IoStatus.Status;
        if (DatagramLength>PtrToUlong (Irp->AfdRecvLength)) {
            status = STATUS_BUFFER_OVERFLOW;
        }
    }

    if (status==STATUS_BUFFER_OVERFLOW) {
        dataOverflow = TRUE;
    }


    if( irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressMdl != NULL ) {
        PMDL    addressMdl = irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressMdl;
        PMDL    addressLenMdl = irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressLenMdl;

        irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressMdl = NULL;
        irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressLenMdl = NULL;

        ASSERT( addressMdl->Next == NULL );
        ASSERT( ( addressMdl->MdlFlags & MDL_PAGES_LOCKED ) != 0 );
        ASSERT( MmGetMdlByteCount (addressMdl) > 0 );

        ASSERT( addressLenMdl != NULL );
        ASSERT( addressLenMdl->Next == NULL );
        ASSERT( ( addressLenMdl->MdlFlags & MDL_PAGES_LOCKED ) != 0 );
        ASSERT( MmGetMdlByteCount (addressLenMdl)==sizeof (ULONG) );

        if ((NT_SUCCESS (status) || 
                    status==STATUS_BUFFER_OVERFLOW || 
                    status==STATUS_PORT_UNREACHABLE) &&
                ARGUMENT_PRESENT (SourceAddress)) {
            PVOID   dst;
            PTRANSPORT_ADDRESS tdiAddress;

            //
            // Extract the real SOCKADDR structure from the TDI address.
            // This duplicates MSAFD.DLL's SockBuildSockaddr() function.
            //

            C_ASSERT( sizeof(tdiAddress->Address[0].AddressType) == sizeof(u_short) );
            C_ASSERT( FIELD_OFFSET( TA_ADDRESS, AddressLength ) == 0 );
            C_ASSERT( FIELD_OFFSET( TA_ADDRESS, AddressType ) == sizeof(USHORT) );
            C_ASSERT( FIELD_OFFSET( TRANSPORT_ADDRESS, Address ) == sizeof(int) );

            tdiAddress = SourceAddress;

            ASSERT( SourceAddressLength >=
                        (tdiAddress->Address[0].AddressLength + sizeof(u_short)) );

            SourceAddressLength = tdiAddress->Address[0].AddressLength +
                                      sizeof(u_short);  // sa_family
            SourceAddress = &tdiAddress->Address[0].AddressType;

            //
            // Copy the address to the user's buffer, then unlock and
            // free the MDL describing the user's buffer.
            //

            if (SourceAddressLength>MmGetMdlByteCount (addressMdl)) {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else {
                dst = MmGetSystemAddressForMdlSafe (addressMdl, LowPagePriority);
                if (dst!=NULL) {
                    PULONG   dstU;
                    RtlMoveMemory (dst, SourceAddress, SourceAddressLength);

                    //
                    // Copy succeeded, return the length as well.
                    //

                    dstU = MmGetSystemAddressForMdlSafe (addressLenMdl, LowPagePriority);
                    if (dstU!=NULL) {
                        *dstU = SourceAddressLength;
                    }
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }

        MmUnlockPages( addressMdl );
        IoFreeMdl( addressMdl );

        MmUnlockPages( addressLenMdl );
        IoFreeMdl( addressLenMdl );

    } else {

        ASSERT( irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressLenMdl == NULL );

    }

    if (irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvControlLenMdl!=NULL) {
        PMDL controlMdl = Irp->AfdRecvMsgControlMdl;
        PMDL controlLenMdl = irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvControlLenMdl;

        Irp->AfdRecvMsgControlMdl = NULL;
        irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvControlLenMdl = NULL;

        ASSERT( irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvFlagsMdl != NULL );
        ASSERT( ( controlLenMdl->MdlFlags & MDL_PAGES_LOCKED ) != 0 );
        ASSERT( MmGetMdlByteCount (controlLenMdl) == sizeof (ULONG) );

        //
        // We still need to NULL the length even if no control data was delivered.
        //
        if (!NT_ERROR (status)) {
            PULONG  dstU;
            dstU = MmGetSystemAddressForMdlSafe (controlLenMdl, LowPagePriority);
            if (dstU!=NULL) {
                if ((TdiReceiveFlags & TDI_RECEIVE_CONTROL_INFO)==0) {
                    ControlLength = 0;
                }
#ifdef _WIN64
                else if (IoIs32bitProcess (Irp)) {
                    ControlLength = AfdComputeCMSGLength32 (
                                        ControlBuffer,
                                        ControlLength);
                }
#endif //_WIN64

                *dstU = ControlLength;
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        //
        // Ignore control data in case of error or if flag indicating
        // that data is in proper format is not set.
        //
        if (!NT_ERROR (status) && ControlLength!=0) {

            if (controlMdl==NULL) {
                controlOverflow = TRUE;
                status = STATUS_BUFFER_OVERFLOW;
            }
            else {
                PVOID dst;
                //
                // Copy control info if app needs them (WSARecvMsg).
                //
                if (ControlLength>MmGetMdlByteCount (controlMdl)) {
                    ControlLength = MmGetMdlByteCount (controlMdl);
                    controlOverflow = TRUE;
                    status = STATUS_BUFFER_OVERFLOW;
                }

                dst = MmGetSystemAddressForMdlSafe (controlMdl, LowPagePriority);
                if (dst!=NULL) {
#ifdef _WIN64
                    if (IoIs32bitProcess (Irp)) {
                        AfdCopyCMSGBuffer32 (dst, ControlBuffer, ControlLength);
                    }
                    else
#endif //_WIN64
                    {
                        RtlMoveMemory (dst, ControlBuffer, ControlLength);
                    }

                }
                else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }


        if (controlMdl!=NULL) {
            ASSERT( controlMdl->Next == NULL );
            ASSERT( ( controlMdl->MdlFlags & MDL_PAGES_LOCKED ) != 0 );
            ASSERT( MmGetMdlByteCount (controlMdl) > 0 );
            MmUnlockPages (controlMdl);
            IoFreeMdl (controlMdl);
        }

        MmUnlockPages (controlLenMdl);
        IoFreeMdl (controlLenMdl);
    }
    else {
        ASSERT (Irp->AfdRecvMsgControlMdl==NULL);
    }

    if (irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvFlagsMdl!=NULL) {
        PMDL flagsMdl = irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvFlagsMdl;

        irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvFlagsMdl = NULL;

        ASSERT( flagsMdl->Next == NULL );
        ASSERT( ( flagsMdl->MdlFlags & MDL_PAGES_LOCKED ) != 0 );
        ASSERT( MmGetMdlByteCount (flagsMdl)==sizeof (ULONG) );

        if (!NT_ERROR (status)) {
            PULONG   dst;

            dst = MmGetSystemAddressForMdlSafe (flagsMdl, LowPagePriority);
            if (dst!=NULL) {
                ULONG flags = 0;
                if (TdiReceiveFlags & TDI_RECEIVE_BROADCAST)
                    flags |= MSG_BCAST;
                if (TdiReceiveFlags & TDI_RECEIVE_MULTICAST)
                    flags |= MSG_MCAST;
                if (dataOverflow)
                    flags |= MSG_TRUNC;
                if (controlOverflow)
                    flags |= MSG_CTRUNC;

                *dst = flags;
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        MmUnlockPages (flagsMdl);
        IoFreeMdl (flagsMdl);
    }

    //
    // Set up the IRP for completion.
    //

    Irp->IoStatus.Status = status;

    return status;

} // AfdSetupReceiveDatagramIrp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\receive.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    receive.c

Abstract:

    This module contains the code for passing on receive IRPs to
    TDI providers.

Author:

    David Treadwell (davidtr)    13-Mar-1992

Revision History:
    Vadim Eydelman (vadime)
        1998-1999 Minimal NT5.0 changes (keep in sync with rest)

--*/

#include "afdp.h"

NTSTATUS
AfdRestartReceive (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdReceive )
#pragma alloc_text( PAGEAFD, AfdRestartReceive )
#pragma alloc_text( PAGEAFD, AfdReceiveEventHandler )
#pragma alloc_text( PAGEAFD, AfdReceiveExpeditedEventHandler )
#pragma alloc_text( PAGEAFD, AfdQueryReceiveInformation )
#endif


NTSTATUS
FASTCALL
AfdReceive (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PTDI_REQUEST_RECEIVE receiveRequest = NULL;
    BOOLEAN peek;
    LARGE_INTEGER bytesExpected;
    BOOLEAN isDataOnConnection;
    BOOLEAN isExpeditedDataOnConnection;
    ULONG recvFlags;
    ULONG afdFlags;
    ULONG recvLength;
    ULONG   bufferCount;

    //
    // Make sure that the endpoint is in the correct state.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Datagram endpoints can be received on event if they are just bound
    // Connection oriented endpoints must be connected.
    //
    if ( (endpoint->State != AfdEndpointStateConnected ) &&
        (!IS_DGRAM_ENDPOINT(endpoint) || (endpoint->State!= AfdEndpointStateBound))) {
        if (IS_DGRAM_ENDPOINT(endpoint))
            status = STATUS_INVALID_PARAMETER;
        else
            status = STATUS_INVALID_CONNECTION;
        goto complete;
    }

    //
    // If receive has been shut down or the endpoint aborted, fail.
    //

    if ( (endpoint->DisconnectMode & AFD_ABORTIVE_DISCONNECT) ) {
        status = STATUS_LOCAL_DISCONNECT;
        goto complete;
    }

    if ( (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) ) {
        status = STATUS_PIPE_DISCONNECTED;
        goto complete;
    }

    //
    // If this is an IOCTL_AFD_RECEIVE, then grab the parameters from the
    // supplied AFD_RECV_INFO structure, build an MDL chain describing
    // the WSABUF array, and attach the MDL chain to the IRP.
    //
    // If this is an IRP_MJ_READ IRP, just grab the length from the IRP
    // and set the flags to zero.
    //

    if ( IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL ) {

#ifdef _WIN64
        if (IoIs32bitProcess (Irp)) {
            PAFD_RECV_INFO32 recvInfo32;
            LPWSABUF32 bufferArray32;

           if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                    sizeof(*recvInfo32) ) {

                AFD_W4_INIT status = STATUS_SUCCESS;
                try {

                    //
                    // Validate the input structure if it comes from the user mode 
                    // application
                    //

                    recvInfo32 = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                    if( Irp->RequestorMode != KernelMode ) {
                        ProbeForReadSmallStructure(
                            recvInfo32,
                            sizeof(*recvInfo32),
                            PROBE_ALIGNMENT32(AFD_RECV_INFO32)
                            );

                    }

                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //

                    recvFlags = recvInfo32->TdiFlags;
                    afdFlags = recvInfo32->AfdFlags;
                    bufferArray32 = UlongToPtr(recvInfo32->BufferArray);
                    bufferCount = recvInfo32->BufferCount;

                    //
                    // Validate the receive flags & WSABUF parameters.
                    // Note that either TDI_RECEIVE_NORMAL or
                    // TDI_RECEIVE_EXPEDITED (but not both) must be set
                    // in the receive flags. And expedited can only
                    // be set if transport supports expedited data and
                    // endpoint is not set to inline mode.
                    //

                    if ( ( recvFlags & TDI_RECEIVE_EITHER ) == 0 ||
                         ( recvFlags & TDI_RECEIVE_EITHER ) == TDI_RECEIVE_EITHER
                         ) {

                        //
                        // Invalid receive flags
                        //

                        status = STATUS_INVALID_PARAMETER;
                        goto complete;
                    }
                    else if (( recvFlags & TDI_RECEIVE_EXPEDITED) != 0 &&
                                (!IS_TDI_EXPEDITED( endpoint )
                                || endpoint->InLine )) {

                        if (endpoint->InLine) {
                            //
                            // Endpoint set inline, OOB data is reported as
                            // normal.
                            //
                            status = STATUS_INVALID_PARAMETER;
                        }
                        else {
                            //
                            // Transport does not support expedited data
                            //

                            status = STATUS_NOT_SUPPORTED;
                        }
                        goto complete;

                    }
                    else {

                        //
                        // Create the MDL chain describing the WSABUF array.
                        // This will also validate the buffer array and individual
                        // buffers
                        //

                        AFD_W4_INIT recvLength = 0;
                        status = AfdAllocateMdlChain32(
                                     Irp,       // Requestor mode passed along
                                     bufferArray32,
                                     bufferCount,
                                     IoWriteAccess,
                                     &recvLength
                                     );
                        if (!NT_SUCCESS (status)) {
                            goto complete;
                        }
                    }

                } except ( AFD_EXCEPTION_FILTER (status) ) {
                    ASSERT (NT_ERROR (status));
                    //
                    // Exception accessing input structure.
                    //
                    goto complete;
                }

            } else {
                //
                // Invalid input buffer length.
                //
                status = STATUS_INVALID_PARAMETER;
                goto complete;
            }
        }
        else
#endif // _WIN64
        {
            PAFD_RECV_INFO recvInfo;
            LPWSABUF bufferArray;

            //
            // Sanity check.
            //

            ASSERT( IrpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_RECEIVE );

            if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                    sizeof(*recvInfo) ) {


                AFD_W4_INIT status = STATUS_SUCCESS;
                try {

                    //
                    // Validate the input structure if it comes from the user mode 
                    // application
                    //

                    recvInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                    if( Irp->RequestorMode != KernelMode ) {
                        ProbeForReadSmallStructure(
                            recvInfo,
                            sizeof(*recvInfo),
                            PROBE_ALIGNMENT(AFD_RECV_INFO)
                            );

                    }

                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //

                    recvFlags = recvInfo->TdiFlags;
                    afdFlags = recvInfo->AfdFlags;
                    bufferArray = recvInfo->BufferArray;
                    bufferCount = recvInfo->BufferCount;

                    //
                    // Validate the receive flags & WSABUF parameters.
                    // Note that either TDI_RECEIVE_NORMAL or
                    // TDI_RECEIVE_EXPEDITED (but not both) must be set
                    // in the receive flags. And expedited can only
                    // be set if transport supports expedited data and
                    // endpoint is not set to inline mode.
                    //

                    if ( ( recvFlags & TDI_RECEIVE_EITHER ) == 0 ||
                         ( recvFlags & TDI_RECEIVE_EITHER ) == TDI_RECEIVE_EITHER
                         ) {

                        //
                        // Invalid receive flags
                        //

                        status = STATUS_INVALID_PARAMETER;
                        goto complete;
                    }
                    else if (( recvFlags & TDI_RECEIVE_EXPEDITED) != 0 &&
                                (!IS_TDI_EXPEDITED( endpoint )
                                || endpoint->InLine )) {

                        if (endpoint->InLine) {
                            //
                            // Endpoint set inline, OOB data is reported as
                            // normal.
                            //
                            status = STATUS_INVALID_PARAMETER;
                        }
                        else {
                            //
                            // Transport does not support expedited data
                            //

                            status = STATUS_NOT_SUPPORTED;
                        }
                        goto complete;

                    }
                    else {

                        //
                        // Create the MDL chain describing the WSABUF array.
                        // This will also validate the buffer array and individual
                        // buffers
                        //
                        
                        AFD_W4_INIT recvLength = 0;
                        status = AfdAllocateMdlChain(
                                     Irp,       // Requestor mode passed along
                                     bufferArray,
                                     bufferCount,
                                     IoWriteAccess,
                                     &recvLength
                                     );
                        if( !NT_SUCCESS(status) ) {
                            goto complete;
                        }

                    }

                } except ( AFD_EXCEPTION_FILTER (status) ) {
                    ASSERT (NT_ERROR (status));
                    //
                    // Exception accessing input structure.
                    //
                    goto complete;
                }

            } else {
                //
                // Invalid input buffer length.
                //
                status = STATUS_INVALID_PARAMETER;
                goto complete;
            }
        }

        if (IS_SAN_ENDPOINT(endpoint)) {
            IrpSp->MajorFunction = IRP_MJ_READ;
            IrpSp->Parameters.Read.Length = recvLength;
            return AfdSanRedirectRequest (Irp, IrpSp);
        }

    } else {

        ASSERT( IrpSp->MajorFunction == IRP_MJ_READ );

        recvFlags = TDI_RECEIVE_NORMAL;
        afdFlags = AFD_OVERLAPPED;
        recvLength = IrpSp->Parameters.Read.Length;

        ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Read.Length ) ==
                FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.OutputBufferLength ) );

    }


    //
    // If this is a datagram endpoint, format up a receive datagram request
    // and pass it on to the TDI provider.
    //

    if ( IS_DGRAM_ENDPOINT(endpoint) ) {
        AFD_RECV_INFO recvInfo;
        recvInfo.TdiFlags = recvFlags;
        recvInfo.AfdFlags = afdFlags;
        IrpSp->Parameters.DeviceIoControl.InputBufferLength = recvLength;
        IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = &recvInfo;
        return AfdReceiveDatagram( Irp, IrpSp);
    }

    //
    // If this is an endpoint on a nonbufferring transport, use another
    // routine to handle the request.
    //

    if ( !IS_TDI_BUFFERRING(endpoint) ) {
        return AfdBReceive( Irp, IrpSp, recvFlags, afdFlags, recvLength );
    }

    //
    // Allocate a buffer for the receive request structure.
    //

    try {
        receiveRequest = AFD_ALLOCATE_POOL_WITH_QUOTA (
                         NonPagedPool,
                         sizeof(TDI_REQUEST_RECEIVE),
                         AFD_TDI_POOL_TAG
                         );
        // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode ();
        goto complete;
    }


    //
    // Set up the receive request structure.
    //

    RtlZeroMemory(
        receiveRequest,
        sizeof(*receiveRequest)
        );

    receiveRequest->ReceiveFlags = (USHORT)recvFlags;

    //
    // If this endpoint is set up for inline reception of expedited data,
    // change the receive flags to use either normal or expedited data.
    //

    if ( endpoint->InLine ) {
        receiveRequest->ReceiveFlags |= TDI_RECEIVE_EITHER;
    }

    //
    // Determine whether this is a request to just peek at the data.
    //

    peek = (BOOLEAN)( (receiveRequest->ReceiveFlags & TDI_RECEIVE_PEEK) != 0 );

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if endpoint was cleaned-up and cancel the request.
    //
    if (endpoint->EndpointCleanedUp) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = STATUS_CANCELLED;
        goto complete;
    }

    connection = AFD_CONNECTION_FROM_ENDPOINT (endpoint);
    if (connection==NULL) {
        //
        // connection might have been cleaned up by transmit file.
        //
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = STATUS_INVALID_CONNECTION;
        goto complete;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );

    isDataOnConnection = (BOOLEAN)IS_DATA_ON_CONNECTION( connection );
    isExpeditedDataOnConnection = (BOOLEAN)IS_EXPEDITED_DATA_ON_CONNECTION( connection );

    if ( endpoint->InLine ) {

        //
        // If the endpoint is nonblocking, check whether the receive can
        // be performed immediately.  Note that if the endpoint is set
        // up for inline reception of expedited data we don't fail just
        // yet--there may be expedited data available to be read.
        //

        if ( endpoint->NonBlocking && !( afdFlags & AFD_OVERLAPPED ) ) {

            if ( !isDataOnConnection &&
                     !isExpeditedDataOnConnection &&
                     !connection->Aborted &&
                     !connection->DisconnectIndicated ) {

                IF_DEBUG(RECEIVE) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdReceive: failing nonblocking IL receive, ind %ld, "
                                "taken %ld, out %ld\n",
                                connection->Common.Bufferring.ReceiveBytesIndicated.LowPart,
                                connection->Common.Bufferring.ReceiveBytesTaken.LowPart,
                                connection->Common.Bufferring.ReceiveBytesOutstanding.LowPart ));
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "    EXP ind %ld, taken %ld, out %ld\n",
                                connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.LowPart,
                                connection->Common.Bufferring.ReceiveExpeditedBytesTaken.LowPart,
                                connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.LowPart ));
                }

                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                status = STATUS_DEVICE_NOT_READY;
                goto complete;
            }
        }

        //
        // If this is a nonblocking endpoint for a message-oriented
        // transport, limit the number of bytes that can be received to the
        // amount that has been indicated.  This prevents the receive
        // from blocking in the case where only part of a message has been
        // received.
        //

        if ( IS_MESSAGE_ENDPOINT(endpoint) && endpoint->NonBlocking ) {

            LARGE_INTEGER expBytesExpected;

            bytesExpected.QuadPart =
                connection->Common.Bufferring.ReceiveBytesIndicated.QuadPart -
                    (connection->Common.Bufferring.ReceiveBytesTaken.QuadPart +
                     connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart);
            ASSERT( bytesExpected.HighPart == 0 );

            expBytesExpected.QuadPart =
                connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.QuadPart -
                    (connection->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart +
                     connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart);
            ASSERT( expBytesExpected.HighPart == 0 );

            IF_DEBUG(RECEIVE) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdReceive: %lx normal bytes expected, %ld exp bytes expected",
                            bytesExpected.LowPart, expBytesExpected.LowPart ));
            }

            //
            // If expedited data exists on the connection, use the lower
            // count between the available expedited and normal receive
            // data.
            //

            if ( (isExpeditedDataOnConnection &&
                     bytesExpected.LowPart > expBytesExpected.LowPart) ||
                 !isDataOnConnection ) {
                bytesExpected = expBytesExpected;
            }

            //
            // If the request is for more bytes than are available, cut back
            // the number of bytes requested to what we know is actually
            // available.
            //

            if ( recvLength > bytesExpected.LowPart ) {
                recvLength = bytesExpected.LowPart;
            }
        }

        //
        // Increment the count of posted receive bytes outstanding.
        // This count is used for polling and nonblocking receives.
        // Note that we do not increment this count if this is only
        // a PEEK receive, since peeks do not actually take any data
        // they should not affect whether data is available to be read
        // on the endpoint.
        //

        IF_DEBUG(RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdReceive: conn %p for %ld bytes, ind %ld, "
                        "taken %ld, out %ld %s\n",
                        connection,
                        recvLength,
                        connection->Common.Bufferring.ReceiveBytesIndicated.LowPart,
                        connection->Common.Bufferring.ReceiveBytesTaken.LowPart,
                        connection->Common.Bufferring.ReceiveBytesOutstanding.LowPart,
                        peek ? "PEEK" : "" ));
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "    EXP ind %ld, taken %ld, out %ld\n",
                        connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.LowPart,
                        connection->Common.Bufferring.ReceiveExpeditedBytesTaken.LowPart,
                        connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.LowPart ));
        }

        if ( !peek ) {

            connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart =
                connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart +
                    recvLength;

            connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart =
                connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart +
                    recvLength;
        }
    }

    if ( !endpoint->InLine &&
             (receiveRequest->ReceiveFlags & TDI_RECEIVE_NORMAL) != 0 ) {

        //
        // If the endpoint is nonblocking, check whether the receive can
        // be performed immediately.
        //

        if ( endpoint->NonBlocking && !( afdFlags & AFD_OVERLAPPED ) ) {

            if ( !isDataOnConnection &&
                     !connection->Aborted &&
                     !connection->DisconnectIndicated ) {

                IF_DEBUG(RECEIVE) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdReceive: failing nonblocking receive, ind %ld, "
                                "taken %ld, out %ld\n",
                                connection->Common.Bufferring.ReceiveBytesIndicated.LowPart,
                                connection->Common.Bufferring.ReceiveBytesTaken.LowPart,
                                connection->Common.Bufferring.ReceiveBytesOutstanding.LowPart ));
                }

                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                status = STATUS_DEVICE_NOT_READY;
                goto complete;
            }
        }

        //
        // If this is a nonblocking endpoint for a message-oriented
        // transport, limit the number of bytes that can be received to the
        // amount that has been indicated.  This prevents the receive
        // from blocking in the case where only part of a message has been
        // received.
        //

        if ( IS_MESSAGE_ENDPOINT(endpoint) && endpoint->NonBlocking ) {

            bytesExpected.QuadPart =
                connection->Common.Bufferring.ReceiveBytesIndicated.QuadPart -
                    (connection->Common.Bufferring.ReceiveBytesTaken.QuadPart +
                     connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart);

            ASSERT( bytesExpected.HighPart == 0 );

            //
            // If the request is for more bytes than are available, cut back
            // the number of bytes requested to what we know is actually
            // available.
            //

            if ( recvLength > bytesExpected.LowPart ) {
                recvLength = bytesExpected.LowPart;
            }
        }

        //
        // Increment the count of posted receive bytes outstanding.
        // This count is used for polling and nonblocking receives.
        // Note that we do not increment this count if this is only
        // a PEEK receive, since peeks do not actually take any data
        // they should not affect whether data is available to be read
        // on the endpoint.
        //

        IF_DEBUG(RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdReceive: conn %p for %ld bytes, ind %ld, "
                        "taken %ld, out %ld %s\n",
                        connection,
                        recvLength,
                        connection->Common.Bufferring.ReceiveBytesIndicated.LowPart,
                        connection->Common.Bufferring.ReceiveBytesTaken.LowPart,
                        connection->Common.Bufferring.ReceiveBytesOutstanding.LowPart,
                        peek ? "PEEK" : "" ));
        }

        if ( !peek ) {

            connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart =
                connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart +
                    recvLength;
        }
    }

    if ( !endpoint->InLine &&
             (receiveRequest->ReceiveFlags & TDI_RECEIVE_EXPEDITED) != 0 ) {

        if ( endpoint->NonBlocking && !( afdFlags & AFD_OVERLAPPED ) &&
                 !isExpeditedDataOnConnection &&
                 !connection->Aborted &&
                 !connection->DisconnectIndicated ) {

            IF_DEBUG(RECEIVE) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdReceive: failing nonblocking EXP receive, ind %ld, "
                            "taken %ld, out %ld\n",
                            connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.LowPart,
                            connection->Common.Bufferring.ReceiveExpeditedBytesTaken.LowPart,
                            connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.LowPart ));
            }

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            status = STATUS_DEVICE_NOT_READY;
            goto complete;
        }

        //
        // If this is a nonblocking endpoint for a message-oriented
        // transport, limit the number of bytes that can be received to the
        // amount that has been indicated.  This prevents the receive
        // from blocking in the case where only part of a message has been
        // received.
        //

        if ( IS_MESSAGE_ENDPOINT(endpoint) &&
                 endpoint->NonBlocking &&
                 IS_EXPEDITED_DATA_ON_CONNECTION( connection ) ) {

            bytesExpected.QuadPart =
                connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.QuadPart -
                    (connection->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart +
                     connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart);

            ASSERT( bytesExpected.HighPart == 0 );
            ASSERT( bytesExpected.LowPart != 0 );

            //
            // If the request is for more bytes than are available, cut back
            // the number of bytes requested to what we know is actually
            // available.
            //

            if ( recvLength > bytesExpected.LowPart ) {
                recvLength = bytesExpected.LowPart;
            }
        }

        //
        // Increment the count of posted expedited receive bytes
        // outstanding.  This count is used for polling and nonblocking
        // receives.  Note that we do not increment this count if this
        // is only a PEEK receive.
        //

        IF_DEBUG(RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdReceive: conn %p for %ld bytes, ind %ld, "
                        "taken %ld, out %ld EXP %s\n",
                        connection,
                        recvLength,
                        connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.LowPart,
                        connection->Common.Bufferring.ReceiveExpeditedBytesTaken.LowPart,
                        connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.LowPart,
                        peek ? "PEEK" : "" ));
        }

        if ( !peek ) {

            connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart =
                connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart +
                    recvLength;
        }
    }

    //
    // Reference the connection so it can't go away
    // even if transmit file tries to clean it up
    //
    REFERENCE_CONNECTION (connection);

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Build the TDI receive request.
    //

    TdiBuildReceive(
        Irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartReceive,
        connection,
        Irp->MdlAddress,
        receiveRequest->ReceiveFlags,
        recvLength
        );

    //
    // Save a pointer to the receive request structure so that we
    // can free it in our restart routine.
    //

    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = receiveRequest;
    IrpSp->Parameters.DeviceIoControl.OutputBufferLength = recvLength;


    //
    // Call the transport to actually perform the connect operation.
    //

    return AfdIoCallDriver( endpoint, connection->DeviceObject, Irp );

complete:

    if ( receiveRequest!=NULL ) {
        AFD_FREE_POOL(
            receiveRequest,
            AFD_TDI_POOL_TAG
            );
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdReceive


NTSTATUS
AfdRestartReceive (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PIO_STACK_LOCATION irpSp;
    LARGE_INTEGER actualBytes;
    LARGE_INTEGER requestedBytes;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    ULONG receiveFlags;
    ULONG eventMask;
    BOOLEAN expedited;
    PTDI_REQUEST_RECEIVE receiveRequest;

    UNREFERENCED_PARAMETER (DeviceObject);
    connection = Context;
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth );
    ASSERT( IS_TDI_BUFFERRING(endpoint) );

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    AfdCompleteOutstandingIrp( endpoint, Irp );

    actualBytes.QuadPart = Irp->IoStatus.Information;
    requestedBytes.QuadPart = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Determine whether we received normal or expedited data.
    //

    receiveRequest = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    receiveFlags = receiveRequest->ReceiveFlags;

    if ( Irp->IoStatus.Status == STATUS_RECEIVE_EXPEDITED ||
         Irp->IoStatus.Status == STATUS_RECEIVE_PARTIAL_EXPEDITED ) {
        expedited = TRUE;
    } else {
        expedited = FALSE;
    }

    //
    // Free the receive request structure.
    //

    AFD_FREE_POOL(
        receiveRequest,
        AFD_TDI_POOL_TAG
        );

    //
    // If this was a PEEK receive, don't update the counts of received
    // data, just return.
    //

    if ( (receiveFlags & TDI_RECEIVE_PEEK) != 0 ) {

        IF_DEBUG(RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdRestartReceive: IRP %p, endpoint %p, conn %p, "
                        "status %X\n",
                        Irp, endpoint, endpoint->Common.VcConnecting.Connection,
                        Irp->IoStatus.Status ));
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "    %s data, PEEKed only.\n",
                        expedited ? "expedited" : "normal" ));
        }

        DEREFERENCE_CONNECTION (connection);
        return STATUS_SUCCESS;
    }

    //
    // Update the count of bytes actually received on the connection.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    if( expedited ) {
        eventMask = endpoint->InLine
                        ? (ULONG)~AFD_POLL_RECEIVE
                        : (ULONG)~AFD_POLL_RECEIVE_EXPEDITED;
    } else {
        eventMask = (ULONG)~AFD_POLL_RECEIVE;
    }

    endpoint->EventsActive &= eventMask;

    IF_DEBUG(EVENT_SELECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdReceive: Endp %p, Active %lx\n",
            endpoint,
            endpoint->EventsActive
            ));
    }


    if ( !expedited ) {

        if ( actualBytes.LowPart == 0 ) {
            ASSERT( actualBytes.HighPart == 0 );
            connection->VcZeroByteReceiveIndicated = FALSE;
        } else {
            connection->Common.Bufferring.ReceiveBytesTaken.QuadPart =
                actualBytes.QuadPart +
                connection->Common.Bufferring.ReceiveBytesTaken.QuadPart;
        }

        //
        // If the number taken exceeds the number indicated, then this
        // receive got some unindicated bytes because the receive was
        // posted when the indication arrived.  If this is the case, set
        // the amount indicated equal to the amount received.
        //

        if ( connection->Common.Bufferring.ReceiveBytesTaken.QuadPart >
                 connection->Common.Bufferring.ReceiveBytesIndicated.QuadPart ) {

            connection->Common.Bufferring.ReceiveBytesIndicated =
                connection->Common.Bufferring.ReceiveBytesTaken;
        }

        //
        // Decrement the count of outstanding receive bytes on this connection
        // by the receive size that was requested.
        //

        connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart =
                connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart -
                requestedBytes.QuadPart;

        //
        // If the endpoint is inline, decrement the count of outstanding
        // expedited bytes.
        //

        if ( endpoint->InLine ) {
            connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart =
                connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart -
                requestedBytes.QuadPart;
        }

        if( connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart > 0 ||
            ( endpoint->InLine &&
              connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart > 0 ) ) {

            AfdIndicateEventSelectEvent(
                endpoint,
                AFD_POLL_RECEIVE,
                STATUS_SUCCESS
                );

        }

        IF_DEBUG(RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdRestartReceive: IRP %p, endpoint %p, conn %p, "
                        "status %lx\n",
                        Irp, endpoint, connection,
                        Irp->IoStatus.Status ));
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "    req. bytes %ld, actual %ld, ind %ld, "
                        " taken %ld, out %ld\n",
                        requestedBytes.LowPart, actualBytes.LowPart,
                        connection->Common.Bufferring.ReceiveBytesIndicated.LowPart,
                        connection->Common.Bufferring.ReceiveBytesTaken.LowPart,
                        connection->Common.Bufferring.ReceiveBytesOutstanding.LowPart
                        ));
        }

    } else {

        connection->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart =
            actualBytes.QuadPart +
            connection->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart;

        //
        // If the number taken exceeds the number indicated, then this
        // receive got some unindicated bytes because the receive was
        // posted when the indication arrived.  If this is the case, set
        // the amount indicated equal to the amount received.
        //

        if ( connection->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart >
                 connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.QuadPart ) {

            connection->Common.Bufferring.ReceiveExpeditedBytesIndicated =
                connection->Common.Bufferring.ReceiveExpeditedBytesTaken;
        }

        //
        // Decrement the count of outstanding receive bytes on this connection
        // by the receive size that was requested.
        //

        ASSERT( connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.LowPart > 0 ||
                    connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.HighPart > 0 ||
                    requestedBytes.LowPart == 0 );

        connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart =
            connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart -
            requestedBytes.QuadPart;

        //
        // If the endpoint is inline, decrement the count of outstanding
        // normal bytes.
        //

        if ( endpoint->InLine ) {

            connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart =
                connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart -
                requestedBytes.QuadPart;

            if( connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart > 0 ||
                connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart > 0 ) {

                AfdIndicateEventSelectEvent(
                    endpoint,
                    AFD_POLL_RECEIVE,
                    STATUS_SUCCESS
                    );

            }

        } else {

            if( connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart > 0 ) {

                AfdIndicateEventSelectEvent(
                    endpoint,
                    AFD_POLL_RECEIVE_EXPEDITED,
                    STATUS_SUCCESS
                    );

            }

        }

        IF_DEBUG(RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdRestartReceive: (exp) IRP %p, endpoint %p, conn %p, "
                        "status %X\n",
                        Irp, endpoint, connection,
                        Irp->IoStatus.Status ));
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "    req. bytes %ld, actual %ld, ind %ld, "
                        " taken %ld, out %ld\n",
                        requestedBytes.LowPart, actualBytes.LowPart,
                        connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.LowPart,
                        connection->Common.Bufferring.ReceiveExpeditedBytesTaken.LowPart,
                        connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.LowPart
                        ));
        }

    }

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // We are not signaling select here because no new data was added and
    // unlike EventSelect we do NOT need to indicate again on receive
    // completion if some data remains buffered.
    //

    DEREFERENCE_CONNECTION (connection);

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    return STATUS_SUCCESS;

} // AfdRestartReceive


NTSTATUS
AfdReceiveEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )
{
    PAFD_CONNECTION connection;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    BOOLEAN result;

    UNREFERENCED_PARAMETER (TdiEventContext);
    UNREFERENCED_PARAMETER (ReceiveFlags);
    UNREFERENCED_PARAMETER (BytesIndicated);
    UNREFERENCED_PARAMETER (Tsdu);
    UNREFERENCED_PARAMETER (IoRequestPacket);

    connection = (PAFD_CONNECTION)ConnectionContext;
    ASSERT( connection != NULL );

    CHECK_REFERENCE_CONNECTION (connection,result);
    if (!result) {
        return STATUS_DATA_NOT_ACCEPTED;
    }
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint != NULL );

    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth);
    ASSERT( !connection->DisconnectIndicated );
    ASSERT( !connection->Aborted );
    ASSERT( IS_TDI_BUFFERRING(endpoint) );

    //
    // Bump the count of bytes indicated on the connection to account for
    // the bytes indicated by this event.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if connection was accepted and use accept endpoint instead
    // of the listening.  Note that accept cannot happen while we are
    // holding listening endpoint spinlock, nor can endpoint change after
    // the accept, so it is safe to release listening spinlock if
    // we discover that endpoint was accepted.
    //
    if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
            && (connection->Endpoint != endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        endpoint = connection->Endpoint;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
        ASSERT( !IS_TDI_BUFFERRING(endpoint) );
        ASSERT(  !IS_VC_ENDPOINT (endpoint) );

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    if ( BytesAvailable == 0 ) {

        connection->VcZeroByteReceiveIndicated = TRUE;

    } else {

        connection->Common.Bufferring.ReceiveBytesIndicated.QuadPart =
            connection->Common.Bufferring.ReceiveBytesIndicated.QuadPart +
                BytesAvailable;
    }

    IF_DEBUG(RECEIVE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdReceiveEventHandler: conn %p, bytes %ld, "
                    "ind %ld, taken %ld, out %ld\n",
                    connection, BytesAvailable,
                    connection->Common.Bufferring.ReceiveBytesIndicated.LowPart,
                    connection->Common.Bufferring.ReceiveBytesTaken.LowPart,
                    connection->Common.Bufferring.ReceiveBytesOutstanding.LowPart ));
    }

    //
    // If the receive side of the endpoint has been shut down, tell the
    // provider that we took all the data and reset the connection.
    // Also, account for these bytes in our count of bytes taken from
    // the transport.
    //

    if (  (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) != 0 ) {

#if DBG
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdReceiveEventHandler: receive shutdown, "
                    "%ld bytes, aborting endp %p\n",
                    BytesAvailable, endpoint ));
#endif

        connection->Common.Bufferring.ReceiveBytesTaken.QuadPart =
            connection->Common.Bufferring.ReceiveBytesTaken.QuadPart +
                BytesAvailable;

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        *BytesTaken = BytesAvailable;

        //
        // Abort the connection.  Note that if the abort attempt fails
        // we can't do anything about it.
        //

        (VOID)AfdBeginAbort( connection );

        DEREFERENCE_CONNECTION (connection);
        return STATUS_SUCCESS;

    } else {

        // Make sure connection was accepted/connected to prevent
        // indication on listening endpoint
        //
        
        if (connection->State==AfdConnectionStateConnected) {
            ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
            AfdIndicateEventSelectEvent(
                endpoint,
                AFD_POLL_RECEIVE,
                STATUS_SUCCESS
                );
        }
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Note to the TDI provider that we didn't take any of the data here.
        //
        // !!! needs bufferring for non-bufferring transports!

        *BytesTaken = 0;

        //
        // If there are any outstanding poll IRPs for this endpoint/
        // event, complete them.
        //
        // Make sure connection was accepted/connected to prevent
        // indication on listening endpoint
        //
        
        if (connection->State==AfdConnectionStateConnected) {
            ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
            AfdIndicatePollEvent(
                endpoint,
                AFD_POLL_RECEIVE,
                STATUS_SUCCESS
                );
        }

        DEREFERENCE_CONNECTION (connection);
        return STATUS_DATA_NOT_ACCEPTED;
    }

} // AfdReceiveEventHandler


NTSTATUS
AfdReceiveExpeditedEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )
{
    PAFD_CONNECTION connection;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    BOOLEAN result;

    UNREFERENCED_PARAMETER (TdiEventContext);
    UNREFERENCED_PARAMETER (ReceiveFlags);
    UNREFERENCED_PARAMETER (BytesIndicated);
    UNREFERENCED_PARAMETER (Tsdu);
    UNREFERENCED_PARAMETER (IoRequestPacket);

    connection = (PAFD_CONNECTION)ConnectionContext;
    ASSERT( connection != NULL );

    CHECK_REFERENCE_CONNECTION (connection, result);
    if (!result) {
        return STATUS_DATA_NOT_ACCEPTED;
    }
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint != NULL );


    //
    // Bump the count of bytes indicated on the connection to account for
    // the expedited bytes indicated by this event.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if connection was accepted and use accept endpoint instead
    // of the listening.  Note that accept cannot happen while we are
    // holding listening endpoint spinlock, nor can endpoint change after
    // the accept, so it is safe to release listening spinlock if
    // we discover that endpoint was accepted.
    //
    if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
            && (connection->Endpoint != endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        endpoint = connection->Endpoint;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
        ASSERT( !IS_TDI_BUFFERRING(endpoint) );
        ASSERT(  !IS_VC_ENDPOINT (endpoint) );

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.QuadPart =
        connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.QuadPart +
            BytesAvailable;

    IF_DEBUG(RECEIVE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdReceiveExpeditedEventHandler: conn %p, bytes %ld, "
                    "ind %ld, taken %ld, out %ld, offset %ld\n",
                    connection, BytesAvailable,
                    connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.LowPart,
                    connection->Common.Bufferring.ReceiveExpeditedBytesTaken.LowPart,
                    connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.LowPart ));
    }

    //
    // If the receive side of the endpoint has been shut down, tell
    // the provider that we took all the data.  Also, account for these
    // bytes in our count of bytes taken from the transport.
    //
    //

    if ( (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) != 0 ) {

        IF_DEBUG(RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdReceiveExpeditedEventHandler: receive shutdown, "
                        "%ld bytes dropped.\n", BytesAvailable ));
        }

        connection->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart =
            connection->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart +
                BytesAvailable;

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        *BytesTaken = BytesAvailable;

        //
        // Abort the connection.  Note that if the abort attempt fails
        // we can't do anything about it.
        //

        (VOID)AfdBeginAbort( connection );

    } else {

        if (connection->State==AfdConnectionStateConnected) {
            ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
            AfdIndicateEventSelectEvent(
                endpoint,
                endpoint->InLine
                    ? AFD_POLL_RECEIVE
                    : AFD_POLL_RECEIVE_EXPEDITED,
                STATUS_SUCCESS
                );
        }
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Note to the TDI provider that we didn't take any of the data here.
        //
        // !!! needs bufferring for non-bufferring transports!

        *BytesTaken = 0;

        //
        // If there are any outstanding poll IRPs for this endpoint/
        // event, complete them.  Indicate this data as normal data if
        // this endpoint is set up for inline reception of expedited
        // data.
        //

        // Make sure connection was accepted/connected to prevent
        // indication on listening endpoint
        //
        
        if (connection->State==AfdConnectionStateConnected) {
            ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
            AfdIndicatePollEvent(
                endpoint,
                endpoint->InLine
                    ? AFD_POLL_RECEIVE
                    : AFD_POLL_RECEIVE_EXPEDITED,
                STATUS_SUCCESS
                );
        }
    }

    DEREFERENCE_CONNECTION (connection);
    return STATUS_DATA_NOT_ACCEPTED;

} // AfdReceiveExpeditedEventHandler


NTSTATUS
AfdQueryReceiveInformation (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
{
    AFD_RECEIVE_INFORMATION receiveInformation;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    LARGE_INTEGER result;
    PAFD_CONNECTION connection;
    NTSTATUS status;

    UNREFERENCED_PARAMETER (IoctlCode);
    UNREFERENCED_PARAMETER (InputBuffer);
    UNREFERENCED_PARAMETER (InputBufferLength);
    *Information = 0;

    //
    // Make sure that the output buffer is large enough.
    //

    if ( OutputBufferLength < sizeof(receiveInformation) ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // If this endpoint has a connection block, use the connection block's
    // information, else use the information from the endpoint itself.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    connection = AFD_CONNECTION_FROM_ENDPOINT( endpoint );

    if ( connection != NULL ) {

        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
                endpoint->Type == AfdBlockTypeVcBoth );
        ASSERT( connection->Type == AfdBlockTypeConnection );

        if ( !IS_TDI_BUFFERRING(endpoint) ) {

            receiveInformation.BytesAvailable =
                connection->VcBufferredReceiveBytes;
            receiveInformation.ExpeditedBytesAvailable =
                connection->VcBufferredExpeditedBytes;

        } else {

            //
            // Determine the number of bytes available to be read.
            //

            result.QuadPart =
                connection->Common.Bufferring.ReceiveBytesIndicated.QuadPart -
                    (connection->Common.Bufferring.ReceiveBytesTaken.QuadPart +
                     connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart);

            ASSERT( result.HighPart == 0 );

            receiveInformation.BytesAvailable = result.LowPart;

            //
            // Determine the number of expedited bytes available to be read.
            //

            result.QuadPart =
                connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.QuadPart -
                    (connection->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart +
                     connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart);

            ASSERT( result.HighPart == 0 );

            receiveInformation.ExpeditedBytesAvailable = result.LowPart;
        }

    } else {

        //
        // Determine the number of bytes available to be read.
        //

        if ( IS_DGRAM_ENDPOINT(endpoint) ) {

            //
            // Return the amount of bytes of datagrams that are
            // bufferred on the endpoint.
            //

            if (endpoint->DgBufferredReceiveBytes>0) {
                receiveInformation.BytesAvailable = endpoint->DgBufferredReceiveBytes;
            }
            else { // Report one byte to the application to prompt it to
                   // read the data if zero-sized datagrams are available.
                receiveInformation.BytesAvailable = endpoint->DgBufferredReceiveCount>0 ? 1 : 0;
            }

        } else {

            //
            // This is an unconnected endpoint, hence no bytes are
            // available to be read.
            //

            receiveInformation.BytesAvailable = 0;
        }

        //
        // Whether this is a datagram endpoint or just unconnected,
        // there are no expedited bytes available.
        //

        receiveInformation.ExpeditedBytesAvailable = 0;
    }

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    AFD_W4_INIT status = STATUS_SUCCESS;
    try {
        //
        // Validate the output structure if it comes from the user mode
        // application
        //

        if (RequestorMode != KernelMode ) {
            ProbeAndWriteStructure (((PAFD_RECEIVE_INFORMATION)OutputBuffer),
                                        receiveInformation,
                                        AFD_RECEIVE_INFORMATION);
        }
        else {
            //
            // Copy parameters back to application's memory
            //
            *((PAFD_RECEIVE_INFORMATION)OutputBuffer) = receiveInformation;
        }

    } except( AFD_EXCEPTION_FILTER (status) ) {
        ASSERT (NT_ERROR (status));
        return status;
    }

    *Information = sizeof(AFD_RECEIVE_INFORMATION);
    return STATUS_SUCCESS;

} // AfdQueryReceiveInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\recvvc.c ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    recvvc.c

Abstract:

    This module contains routines for handling data receive for connection-
    oriented endpoints on non-buffering TDI transports.

Author:

    David Treadwell (davidtr)    21-Oct-1993

Revision History:
    Vadim Eydelman (vadime)
        1998-1999 NT5.0 low-memory tolerance and perf changes

--*/

#include "afdp.h"

VOID
AfdCancelReceive (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PIRP
AfdGetPendedReceiveIrp (
    IN PAFD_CONNECTION Connection,
    IN BOOLEAN Expedited
    );

NTSTATUS
AfdRestartBufferReceiveWithUserIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


ULONG
AfdBFillPendingIrps (
    PAFD_CONNECTION     Connection,
    PMDL                Mdl,
    ULONG               DataOffset,
    ULONG               DataLength,
    ULONG               Flags,
    PLIST_ENTRY         CompleteIrpListHead
    );

#define AFD_RECEIVE_STREAM  0x80000000
C_ASSERT (AFD_RECEIVE_STREAM!=TDI_RECEIVE_ENTIRE_MESSAGE);
C_ASSERT (AFD_RECEIVE_STREAM!=TDI_RECEIVE_EXPEDITED);

#define AFD_RECEIVE_CHAINED 0x40000000
C_ASSERT (AFD_RECEIVE_CHAINED!=TDI_RECEIVE_ENTIRE_MESSAGE);
C_ASSERT (AFD_RECEIVE_CHAINED!=TDI_RECEIVE_EXPEDITED);


PAFD_BUFFER_HEADER
AfdGetReceiveBuffer (
    IN PAFD_CONNECTION Connection,
    IN ULONG ReceiveFlags,
    IN PAFD_BUFFER_HEADER StartingAfdBuffer OPTIONAL
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdBReceive )
#pragma alloc_text( PAGEAFD, AfdBReceiveEventHandler )
#pragma alloc_text( PAGEAFD, AfdBReceiveExpeditedEventHandler )
#pragma alloc_text( PAGEAFD, AfdCancelReceive )
#pragma alloc_text( PAGEAFD, AfdGetPendedReceiveIrp )
#pragma alloc_text( PAGEAFD, AfdGetReceiveBuffer )
#pragma alloc_text( PAGEAFD, AfdRestartBufferReceive )
#pragma alloc_text( PAGEAFD, AfdRestartBufferReceiveWithUserIrp )
#pragma alloc_text( PAGEAFD, AfdLRRepostReceive)
#pragma alloc_text( PAGEAFD, AfdBChainedReceiveEventHandler )
#pragma alloc_text( PAGEAFD, AfdBFillPendingIrps )
#endif


//
// Macros to make the send restart code more maintainable.
//

#define AfdRestartRecvInfo  DeviceIoControl
#define AfdRecvFlags        IoControlCode
#define AfdOriginalLength   OutputBufferLength
#define AfdCurrentLength    InputBufferLength
#define AfdAdjustedLength   Type3InputBuffer



NTSTATUS
AfdBReceive (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG RecvFlags,
    IN ULONG AfdFlags,
    IN ULONG RecvLength
    )
{
    NTSTATUS status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    ULONG bytesReceived;
    BOOLEAN peek;
    PAFD_BUFFER_HEADER afdBuffer;
    BOOLEAN completeMessage;
    BOOLEAN partialReceivePossible;
    PAFD_BUFFER newAfdBuffer;

    //
    // Set up some local variables.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth );
    connection = NULL;

    //
    // Determine if this is a peek operation.
    //

    ASSERT( ( RecvFlags & TDI_RECEIVE_EITHER ) != 0 );
    ASSERT( ( RecvFlags & TDI_RECEIVE_EITHER ) != TDI_RECEIVE_EITHER );

    peek = (BOOLEAN)(( RecvFlags & TDI_RECEIVE_PEEK ) != 0);

    //
    // Determine whether it is legal to complete this receive with a
    // partial message.
    //

    if ( !IS_MESSAGE_ENDPOINT(endpoint)) {

        partialReceivePossible = TRUE;

    } else {

        if ( (RecvFlags & TDI_RECEIVE_PARTIAL) != 0 ) {
            partialReceivePossible = TRUE;
        } else {
            partialReceivePossible = FALSE;
        }
    }

    //
    // Reset the InputBufferLength field of our stack location.  We'll
    // use this to keep track of how much data we've placed into the IRP
    // so far.
    //

    IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength = 0;
    Irp->IoStatus.Information = 0;

    //
    // If this is an inline endpoint, then either type of receive data
    // can be used to satisfy this receive.
    //

    if ( endpoint->InLine ) {
        RecvFlags |= TDI_RECEIVE_EITHER;
    }

    newAfdBuffer = NULL;
    //
    // Try to get data already bufferred on the connection to satisfy
    // this receive.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if endpoint was cleaned-up and cancel the request.
    //
    if (endpoint->EndpointCleanedUp) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = STATUS_CANCELLED;
        goto complete;
    }

    connection = AFD_CONNECTION_FROM_ENDPOINT (endpoint);
    if (connection==NULL) {
        //
        // connection might have been cleaned up by transmit file.
        //
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = STATUS_INVALID_CONNECTION;
        goto complete;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );

    //
    // Check whether the remote end has aborted the connection, in which
    // case we should complete the receive.
    //

    if ( connection->Aborted ) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = STATUS_CONNECTION_RESET;
        goto complete;
    }

    if( RecvFlags & TDI_RECEIVE_EXPEDITED ) {
        endpoint->EventsActive &= ~AFD_POLL_RECEIVE_EXPEDITED;
    }

    if( RecvFlags & TDI_RECEIVE_NORMAL ) {
        endpoint->EventsActive &= ~AFD_POLL_RECEIVE;
    }

    IF_DEBUG(EVENT_SELECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdBReceive: Endp %p, Active %lx\n",
            endpoint,
            endpoint->EventsActive
            ));
    }

    afdBuffer = AfdGetReceiveBuffer( connection, RecvFlags, NULL);

    while ( afdBuffer != NULL ) {

        //
        // Copy the data to the MDL in the IRP.  
        //


        if ( Irp->MdlAddress != NULL ) {

            if (IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength==0) {
                //
                // First time through the loop - make sure we can map the 
                // entire buffer. We can't afford failing on second entry
                // to the loop as we may loose the data we copied on
                // the first path.
                //
                status = AfdMapMdlChain (Irp->MdlAddress);
                if (!NT_SUCCESS (status)) {
                    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
                    goto complete;
                }
            }

            ASSERTMSG (
                "NIC Driver freed the packet before it was returned!!!",
                !afdBuffer->NdisPacket ||
                    (MmIsAddressValid (afdBuffer->Context) &&
                     MmIsAddressValid (MmGetSystemAddressForMdl (afdBuffer->Mdl))) );

            status = AfdCopyMdlChainToMdlChain (
                        Irp->MdlAddress,
                        IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength,
                        afdBuffer->Mdl,
                        afdBuffer->DataOffset,
                        afdBuffer->DataLength,
                        &bytesReceived
                        );

        } else {

            if ( afdBuffer->DataLength == 0 ) {
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_OVERFLOW;
            }

            bytesReceived = 0;
        }

        ASSERT( status == STATUS_SUCCESS || status == STATUS_BUFFER_OVERFLOW );

        ASSERT( afdBuffer->PartialMessage == TRUE || afdBuffer->PartialMessage == FALSE );

        completeMessage = !afdBuffer->PartialMessage;

        //
        // If this wasn't a peek IRP, update information on the
        // connection based on whether the entire buffer of data was
        // taken.
        //

        if ( !peek ) {

            //
            // If all the data in the buffer was taken, remove the buffer
            // from the connection's list and return it to the buffer pool.
            //

            if (status == STATUS_SUCCESS) {

                ASSERT(afdBuffer->DataLength == bytesReceived);

                //
                // Update the counts of bytes bufferred on the connection.
                //

                if ( afdBuffer->ExpeditedData ) {

                    ASSERT( connection->VcBufferredExpeditedBytes >= bytesReceived );
                    ASSERT( connection->VcBufferredExpeditedCount > 0 );

                    connection->VcBufferredExpeditedBytes -= bytesReceived;
                    connection->VcBufferredExpeditedCount -= 1;

                    afdBuffer->ExpeditedData = FALSE;

                } else {

                    ASSERT( connection->VcBufferredReceiveBytes >= bytesReceived );
                    ASSERT( connection->VcBufferredReceiveCount > 0 );

                    connection->VcBufferredReceiveBytes -= bytesReceived;
                    connection->VcBufferredReceiveCount -= 1;
                }

                RemoveEntryList( &afdBuffer->BufferListEntry );
                DEBUG afdBuffer->BufferListEntry.Flink = NULL;
                if (afdBuffer->RefCount==1 || // Can't change once off the list
                        InterlockedDecrement (&afdBuffer->RefCount)==0) {
                    AfdReturnBuffer( afdBuffer, connection->OwningProcess );
                }

                //
                // Reset the afdBuffer local so that we know that the
                // buffer is gone.
                //

                afdBuffer = NULL;

            } else {

                //
                // Update the counts of bytes bufferred on the connection.
                //

                if ( afdBuffer->ExpeditedData ) {
                    ASSERT( connection->VcBufferredExpeditedBytes >= bytesReceived );
                    connection->VcBufferredExpeditedBytes -= bytesReceived;
                } else {
                    ASSERT( connection->VcBufferredReceiveBytes >= bytesReceived );
                    connection->VcBufferredReceiveBytes -= bytesReceived;
                }

                //
                // Not all of the buffer's data was taken. Update the
                // counters in the AFD buffer structure to reflect the
                // amount of data that was actually received.
                //
                ASSERT(afdBuffer->DataLength > bytesReceived);

                afdBuffer->DataOffset += bytesReceived;
                afdBuffer->DataLength -= bytesReceived;

                ASSERT( afdBuffer->BufferLength==AfdBufferTagSize
                        || afdBuffer->DataOffset < afdBuffer->BufferLength );
            }

            //
            // If there is indicated but unreceived data in the TDI
            // provider, and we have available buffer space, fire off an
            // IRP to receive the data.
            //

            if ( connection->VcReceiveBytesInTransport > 0

                 &&

                 connection->VcBufferredReceiveBytes <
                   connection->MaxBufferredReceiveBytes

                     ) {

                ULONG bytesToReceive;
                ASSERT (connection->RcvInitiated==FALSE);
                //
                // Remember the count of data that we're going to
                // receive, then reset the fields in the connection
                // where we keep track of how much data is available in
                // the transport.  We reset it here before releasing the
                // lock so that another thread doesn't try to receive
                // the data at the same time as us.
                //

                if ( connection->VcReceiveBytesInTransport > AfdLargeBufferSize ) {
                    bytesToReceive = connection->VcReceiveBytesInTransport;
                } else {
                    bytesToReceive = AfdLargeBufferSize;
                }

                //
                // Get an AFD buffer structure to hold the data.
                //

                ASSERT (newAfdBuffer==NULL);
                newAfdBuffer = AfdGetBuffer( 
                                        endpoint,
                                        bytesToReceive, 0,
                                        connection->OwningProcess );
                if ( newAfdBuffer != NULL) {

                    connection->VcReceiveBytesInTransport = 0;
                    connection->RcvInitiated = TRUE;
                    ASSERT (InterlockedDecrement (&connection->VcReceiveIrpsInTransport)==-1);

                    //
                    // We need to remember the connection in the AFD buffer
                    // because we'll need to access it in the completion
                    // routine.
                    //

                    newAfdBuffer->Context = connection;

                    //
                    // Acquire connection reference to be released in completion routine
                    //

                    REFERENCE_CONNECTION (connection);

                    //
                    // Finish building the receive IRP to give to the TDI
                    // provider.
                    //

                    TdiBuildReceive(
                        newAfdBuffer->Irp,
                        connection->DeviceObject,
                        connection->FileObject,
                        AfdRestartBufferReceive,
                        newAfdBuffer,
                        newAfdBuffer->Mdl,
                        TDI_RECEIVE_NORMAL,
                        bytesToReceive
                        );

                    //
                    // Wait to hand off the IRP until we can safely release
                    // the endpoint lock.
                    //
                }
                else {
                    if (connection->VcBufferredReceiveBytes == 0 &&
                            !connection->OnLRList) {
                        //
                        // Since we do not have any data buffered, application
                        // is not notified and will never call with recv.
                        // We will have to put this on low resource list
                        // and attempt to allocate memory and pull the data
                        // later.
                        //
                        connection->OnLRList = TRUE;
                        REFERENCE_CONNECTION (connection);
                        AfdLRListAddItem (&connection->LRListItem, AfdLRRepostReceive);
                    }
                }
            }
        }


        //
        // Update the count of bytes we've received so far into the IRP,
        // and see if we can get another buffer of data to continue.
        //

        IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength += bytesReceived;
        afdBuffer = AfdGetReceiveBuffer( connection, RecvFlags, afdBuffer );

        //
        // We've set up all return information.  If we got a full
        // message OR if we can complete with a partial message OR if
        // the IRP is full of data, clean up and complete the IRP.
        //

        if ( IS_MESSAGE_ENDPOINT (endpoint) && completeMessage 

                    ||

                status == STATUS_BUFFER_OVERFLOW 

                    || 

                (partialReceivePossible 
                        && 
                    ((RecvLength==IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength)
                            ||
                        (afdBuffer==NULL))
                     )
                    ) {

            if( RecvFlags & TDI_RECEIVE_NORMAL ) {
                if (IS_DATA_ON_CONNECTION( connection )) {

                    ASSERT (endpoint->DisableFastIoRecv==FALSE);

                    AfdIndicateEventSelectEvent(
                        endpoint,
                        AFD_POLL_RECEIVE,
                        STATUS_SUCCESS
                        );

                }
                else {
                    //
                    // Disable fast IO path to avoid performance penalty
                    // of unneccessarily going through it.
                    //
                    if (!endpoint->NonBlocking)
                        endpoint->DisableFastIoRecv = TRUE;
                }
            }

            if( ( RecvFlags & TDI_RECEIVE_EXPEDITED ) &&
                IS_EXPEDITED_DATA_ON_CONNECTION( connection ) ) {

                AfdIndicateEventSelectEvent(
                    endpoint,
                    endpoint->InLine
                        ? AFD_POLL_RECEIVE
                        : AFD_POLL_RECEIVE_EXPEDITED,
                    STATUS_SUCCESS
                    );

            }

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            //
            // For stream type endpoints, it does not make sense to return
            // STATUS_BUFFER_OVERFLOW.  That status is only sensible for
            // message-oriented transports for which we convert it
            // to partial receive status to properly set the flags
            //

            if ( !IS_MESSAGE_ENDPOINT(endpoint) ) {
                status = STATUS_SUCCESS;
            }
            else if (status==STATUS_BUFFER_OVERFLOW || !completeMessage) {
                if (RecvFlags & TDI_RECEIVE_EXPEDITED)
                    status = STATUS_RECEIVE_PARTIAL_EXPEDITED;
                else
                    status = STATUS_RECEIVE_PARTIAL;
            }

            Irp->IoStatus.Information = IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;


            UPDATE_CONN2 (connection, "Irp receive, 0x%lX bytes", (ULONG)Irp->IoStatus.Information);
            goto complete;
        }
    }


    //
    // We should have copied all buffered data of appropriate type
    // to the apps's buffer.
    //
    ASSERT ((!(RecvFlags & TDI_RECEIVE_NORMAL) || (connection->VcBufferredReceiveBytes == 0)) &&
            (!(RecvFlags & TDI_RECEIVE_EXPEDITED) || (connection->VcBufferredExpeditedBytes == 0)));

    //
    // There must be some more space in the buffer if we are here
    // or it could also be a 0-byte recv.
    //
    ASSERT ((RecvLength>IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength)
                || (RecvLength==0));
    //
    // Also, if we could complete with partial data we should have done so.
    //
    ASSERT (IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength==0 ||
                !partialReceivePossible);
                
    
    //
    // We'll have to pend the IRP.  Remember the receive flags in the
    // IoControlCode field of our IO stack location and make sure
    // we have the length field set (it is no longer done by the IO
    // system because we use METHOD_NEITHER and WSABUFs to pass recv
    // parameters). Initialize adjusted length in case we need to advance
    // the MDL to receive next part of the message
    //

    IrpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags = RecvFlags;
    IrpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength = RecvLength;
    IrpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength = (PVOID)0;


    //
    // If there was no data bufferred on the endpoint and the connection
    // has been disconnected by the remote end, complete the receive
    // with 0 bytes read if this is a stream endpoint, or a failure
    // code if this is a message endpoint.
    //

    if ( IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength == 0 &&
             connection->DisconnectIndicated ) {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        ASSERT (newAfdBuffer==NULL);

        if ( !IS_MESSAGE_ENDPOINT(endpoint) ) {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_GRACEFUL_DISCONNECT;
        }

        goto complete;
    }

    //
    // If this is a nonblocking endpoint and the request was a normal
    // receive (as opposed to a read IRP), fail the request.  We don't
    // fail reads under the asumption that if the application is doing
    // reads they don't want nonblocking behavior.
    //

    if ( IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength == 0 &&
             endpoint->NonBlocking && !( AfdFlags & AFD_OVERLAPPED ) ) {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        ASSERT (newAfdBuffer==NULL);

        status = STATUS_DEVICE_NOT_READY;
        goto complete;
    }

    //
    // Place the IRP on the connection's list of pended receive IRPs and
    // mark the IRP ad pended.
    //

    InsertTailList(
        &connection->VcReceiveIrpListHead,
        &Irp->Tail.Overlay.ListEntry
        );

    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Set up the cancellation routine in the IRP.  If the IRP has already
    // been cancelled, just call the cancellation routine here.
    //

    IoSetCancelRoutine( Irp, AfdCancelReceive );

    if ( Irp->Cancel ) {


        RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
        if (IoSetCancelRoutine( Irp, NULL ) != NULL) {

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            if (IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength == 0 ||
                    endpoint->EndpointCleanedUp) {
                status = STATUS_CANCELLED;
                goto complete;
            }
            else {
                //
                // We cannot set STATUS_CANCELLED
                // since we loose data already placed in the IRP.
                //
                Irp->IoStatus.Information = IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
                UPDATE_CONN2(connection, "Cancelled receive, 0x%lX bytes", (ULONG)Irp->IoStatus.Information);
                status = STATUS_SUCCESS;
                goto complete;
            }
        }
        else {

            //
            // This IRP is about to be canceled.  Set the Flink to NULL 
            // so the cancel routine knows it is not on the list.
            Irp->Tail.Overlay.ListEntry.Flink = NULL;
        }

        //
        // The cancel routine will run and complete the irp.
        //

    }

    IoMarkIrpPending( Irp );

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // If there was data bufferred in the transport, fire off the IRP to
    // receive it.  We have to wait until here because it is not legal
    // to do an IoCallDriver() while holding a spin lock.
    //

    if ( newAfdBuffer != NULL ) {
        (VOID)IoCallDriver( connection->DeviceObject, newAfdBuffer->Irp );
    }

    return STATUS_PENDING;

complete:
    //
    // If there was data bufferred in the transport, fire off
    // the IRP to receive it.
    //

    if ( newAfdBuffer != NULL ) {
        (VOID)IoCallDriver( connection->DeviceObject, newAfdBuffer->Irp );
    }


    Irp->IoStatus.Status = status;

    if (!NT_SUCCESS (status)) {
        UPDATE_CONN2 (connection, "Receive failed, status: 0x%lX", Irp->IoStatus.Status);
    }

    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdBReceive




NTSTATUS
AfdBChainedReceiveEventHandler(
    IN PVOID  TdiEventContext,
    IN CONNECTION_CONTEXT  ConnectionContext,
    IN ULONG  ReceiveFlags,
    IN ULONG  ReceiveLength,
    IN ULONG  StartingOffset,
    IN PMDL   Tsdu,
    IN PVOID  TsduDescriptor
    )
/*++

Routine Description:

    Handles chained receive events for nonbufferring transports.

Arguments:


Return Value:


--*/
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT   endpoint;
    PAFD_CONNECTION connection;
    PAFD_BUFFER_TAG afdBufferTag;
    LIST_ENTRY      completeIrpListHead;
    PIRP            irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS        status;
    ULONG           offset;
    BOOLEAN         result;

    UNREFERENCED_PARAMETER (TdiEventContext);
#if DBG
    {
        PMDL    tstMdl = Tsdu;
        ULONG   count = 0;
        while (tstMdl) {
            count += MmGetMdlByteCount (tstMdl);
            tstMdl = tstMdl->Next;
        }
        ASSERT (count>=StartingOffset+ReceiveLength);
    }
#endif

    connection = (PAFD_CONNECTION)ConnectionContext;
    ASSERT( connection != NULL );

    CHECK_REFERENCE_CONNECTION2 (connection,"AfdBChainedReceiveEventHandler, receive length: 0x%lX", ReceiveLength, result );
    if (!result) {
        return STATUS_DATA_NOT_ACCEPTED;
    }
    ASSERT( connection->Type == AfdBlockTypeConnection );
    ASSERT( !connection->DisconnectIndicated );

    endpoint = connection->Endpoint;
    if (endpoint==NULL) {
        //
        // Indication after connection reuse, ignore.
        //
        DEREFERENCE_CONNECTION (connection);
        return STATUS_DATA_NOT_ACCEPTED;
    }

    ASSERT( !IS_TDI_BUFFERRING(endpoint) );


#if AFD_PERF_DBG
    AfdFullReceiveIndications++;
#endif
    IF_DEBUG (RECEIVE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdBChainedReceiveEventHandler>>: Connection %p, TdsuDescr: %p, Length: %ld.\n",
                connection, TsduDescriptor, ReceiveLength));
    }


    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Do following ASSERT check under lock
    //
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth );

    //
    // Check if connection was accepted and use accept endpoint instead
    // of the listening.  Note that accept cannot happen while we are
    // holding listening endpoint spinlock, nor can endpoint change after
    // the accept, so it is safe to release listening spinlock if
    // we discover that endpoint was accepted.
    //
    if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
            && (connection->Endpoint != endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        endpoint = connection->Endpoint;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
        ASSERT( !IS_TDI_BUFFERRING(endpoint) );
        ASSERT(  IS_VC_ENDPOINT (endpoint) );

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    //
    // If the receive side of the endpoint has been shut down, tell the
    // provider that we took all the data and reset the connection.
    // Same if we are shutting down.
    //

    if ((endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) != 0 ||
         endpoint->EndpointCleanedUp ) {

        IF_DEBUG (RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdBChainedReceiveEventHandler: receive shutdown, "
                    "%ld bytes, aborting endp %p\n",
                        ReceiveLength, endpoint ));
        }

        //
        // Abort the connection.  Note that if the abort attempt fails
        // we can't do anything about it.
        //

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        (VOID)AfdBeginAbort( connection );

        DEREFERENCE_CONNECTION (connection);
        return STATUS_SUCCESS;
    }

    if (ReceiveFlags & TDI_RECEIVE_EXPEDITED) {
        //
        // We're being indicated with expedited data.  Buffer it and
        // complete any pended IRPs in the restart routine.  We always
        // buffer expedited data to save complexity and because expedited
        // data is not an important performance case.
        //
        // !!! do we need to perform flow control with expedited data?
        //
        PAFD_BUFFER afdBuffer;
        if (connection->VcBufferredExpeditedCount==MAXUSHORT ||
            (afdBuffer=AfdGetBuffer (endpoint, ReceiveLength, 0, connection->OwningProcess))==NULL) {
            //
            // If we couldn't get a buffer, abort the connection.  This is
            // pretty brutal, but the only alternative is to attempt to
            // receive the data sometime later, which is very complicated to
            // implement.
            //

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            (VOID)AfdBeginAbort( connection );

            DEREFERENCE_CONNECTION (connection);
            return STATUS_SUCCESS;
        }

        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = TdiCopyMdlToBuffer (Tsdu,
                                    StartingOffset, 
                                    afdBuffer->Buffer,
                                    0,
                                    afdBuffer->BufferLength,
                                    &ReceiveLength);
        ASSERT (status==STATUS_SUCCESS);
        //
        // We need to remember the connection in the AFD buffer because
        // we'll need to access it in the completion routine.
        //

        afdBuffer->Context = connection;

        //
        // Remember the type of data that we're receiving.
        //

        afdBuffer->ExpeditedData = TRUE;
        afdBuffer->PartialMessage = (BOOLEAN)((ReceiveFlags & TDI_RECEIVE_ENTIRE_MESSAGE) == 0);

        afdBuffer->Irp->IoStatus.Status = status;
        afdBuffer->Irp->IoStatus.Information = ReceiveLength;
        status = AfdRestartBufferReceive (AfdDeviceObject, afdBuffer->Irp, afdBuffer);
        ASSERT (status==STATUS_MORE_PROCESSING_REQUIRED);

        return STATUS_SUCCESS;
    }

    if (connection->RcvInitiated) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AFD: Indication with outstanding receive on connection %p, 0x%x bytes\n",
                    connection, ReceiveLength));
        //
        // We have initiated receive to the transport.
        // Let the transport find and complete it first
        // to preserve ordering.
        //
        connection->VcReceiveBytesInTransport = ReceiveLength;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        DEREFERENCE_CONNECTION (connection);
        return STATUS_DATA_NOT_ACCEPTED;

    }

    //
    // If we are indicated data, we need to reset our record
    // of amount of data buffered by the transport.
    //
    connection->VcReceiveBytesInTransport = 0;

RetryReceive:
    InitializeListHead( &completeIrpListHead );
    offset = AfdBFillPendingIrps (
                                connection,
                                Tsdu,
                                StartingOffset,
                                ReceiveLength,
                                (ReceiveFlags & TDI_RECEIVE_ENTIRE_MESSAGE) |
                                    AFD_RECEIVE_CHAINED |
                                    (!IS_MESSAGE_ENDPOINT(endpoint) ? 
                                        AFD_RECEIVE_STREAM : 0),
                                &completeIrpListHead
                                );

    if (offset==(ULONG)-1) {

        //
        // If the IRP had more space than in this packet and this
        // was not set a complete message, we will pass the IRP to
        // the transport and refuse the indicated data (the transport
        // can fill the rest of the IRP).
        //

        //
        // This receive indication cannot be expedited or a complete message
        // becuase it does not make sense to pass the IRP back in such
        // cases.
        //

        ASSERT (!IsListEmpty (&completeIrpListHead));
        ASSERT ((ReceiveFlags & 
            (TDI_RECEIVE_EXPEDITED|TDI_RECEIVE_ENTIRE_MESSAGE))==0);
        ASSERT (!AfdIgnorePushBitOnReceives);

        irp = CONTAINING_RECORD (completeIrpListHead.Flink,
                                            IRP,
                                            Tail.Overlay.ListEntry);
        irpSp = IoGetCurrentIrpStackLocation (irp);
        ASSERT (irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength-
                    irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength >
                    ReceiveLength);

        //
        // Reference connection (to be released in restart routine).
        // Keep reference added in the beginning of this routine.
        // REFERENCE_CONNECTION (connection);

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Note that we have outstanding user IRP in transport.
        //
        ASSERT (InterlockedIncrement (&connection->VcReceiveIrpsInTransport)==1);

        //
        // IRP is already partially filled.
        //

        if (irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength>0) {


            irp->MdlAddress = AfdAdvanceMdlChain (
                            irp->MdlAddress,
                            irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength
                                - PtrToUlong(irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength)
                            );

            ASSERT (irp->MdlAddress!=NULL);
            //
            // Remeber the length by which we adjusted MDL, so we know where
            // to start next time.
            //
            irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength =
                    UlongToPtr(irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength);

        }
        //
        // Build the receive IRP to give to the TDI provider.
        //

        TdiBuildReceive(
            irp,
            connection->DeviceObject,
            connection->FileObject,
            AfdRestartBufferReceiveWithUserIrp,
            connection,
            irp->MdlAddress,
            irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags & TDI_RECEIVE_EITHER,
            irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength -
                irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength
            );

#ifdef _AFD_VARIABLE_STACK_
        if ((irp=AfdCheckStackSizeAndRecordOutstandingIrp (
                        endpoint, 
                        connection->DeviceObject, 
                        irp))!=NULL) {
#else //_AFD_VARIABLE_STACK_
       if (AfdRecordOutstandingIrp (endpoint, connection->DeviceObject, irp)) {
#endif // _AFD_VARIABLE_STACK_
            (VOID)IoCallDriver(connection->DeviceObject, irp );
        }
        else {
            //
            // On debug build or in case that transport driver needed more stack locations that were
            // available, AFD might have completed this IRP if it could not allocate
            // new IRP and/or tracking structure.  In this case the transport does not 
            // get a call and as the result does not restart indications.  Also, the data
            // already placed in the IRP gets lost.
            //
            // To avoid this, we retry the indication ourselves.
            //
            CHECK_REFERENCE_CONNECTION (connection, result);
            if (result) {
                AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
                goto RetryReceive;
            }
        }
        return STATUS_DATA_NOT_ACCEPTED;
    }

    ASSERT (offset-StartingOffset<=ReceiveLength);
    
    //
    // If there is any data left, place the buffer at the end of the
    // connection's list of bufferred data and update counts of data on
    // the connection.
    //
    if (ReceiveLength > offset-StartingOffset) {

        //
        // If offset is not zero we should not have had anything buffered.
        //
        ASSERT (offset==StartingOffset || connection->VcBufferredReceiveCount==0);

        if ( offset>StartingOffset ||
                (connection->VcBufferredReceiveBytes <=
                        connection->MaxBufferredReceiveBytes &&
                    connection->VcBufferredReceiveCount<MAXUSHORT) ){
            //
            // We should attempt to buffer the data.
            //
            afdBufferTag = AfdGetBufferTag (0, connection->OwningProcess);
        }
        else {
            ASSERT (offset==StartingOffset);
            //
            // We are over the limit, don't take the data.
            //
            afdBufferTag = NULL;
        }

        if (afdBufferTag!=NULL) {
            AFD_VERIFY_MDL (connection, Tsdu, StartingOffset, ReceiveLength);
            afdBufferTag->Mdl = Tsdu;
            afdBufferTag->DataLength = ReceiveLength - (offset-StartingOffset);
            afdBufferTag->DataOffset = offset;
            afdBufferTag->RefCount = 1;
            afdBufferTag->Context = TsduDescriptor;
            afdBufferTag->NdisPacket = TRUE;
            afdBufferTag->PartialMessage = (BOOLEAN)((ReceiveFlags & TDI_RECEIVE_ENTIRE_MESSAGE) == 0);
            InsertTailList(
                &connection->VcReceiveBufferListHead,
                &afdBufferTag->BufferListEntry
                );

            connection->VcBufferredReceiveBytes += afdBufferTag->DataLength;
            ASSERT (connection->VcBufferredReceiveCount<MAXUSHORT);
            connection->VcBufferredReceiveCount += 1;

            endpoint->DisableFastIoRecv = FALSE;
            // Make sure connection was accepted/connected to prevent
            // indication on listening endpoint
            //

            if (connection->State==AfdConnectionStateConnected) {
                ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
                AfdIndicateEventSelectEvent(
                    endpoint,
                    AFD_POLL_RECEIVE,
                    STATUS_SUCCESS
                    );
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                AfdIndicatePollEvent(
                    endpoint,
                    AFD_POLL_RECEIVE,
                    STATUS_SUCCESS
                    );
            }
            else {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }
            status = STATUS_PENDING;
        }
        else {
            if (offset==StartingOffset) {
                //
                // If no IRPs were pending on the endpoint just remember the 
                // amount of data that is available.  When application
                // reposts the receive, we'll actually pull this data.
                //

                connection->VcReceiveBytesInTransport += ReceiveLength;

                if (connection->VcBufferredReceiveBytes == 0 &&
                        !connection->OnLRList) {
                    //
                    // Since we do not have any data buffered, application
                    // is not notified and will never call with recv.
                    // We will have to put this on low resource list
                    // and attempt to allocate memory and pull the data
                    // later.
                    //
                    connection->OnLRList = TRUE;
                    REFERENCE_CONNECTION (connection);
                    AfdLRListAddItem (&connection->LRListItem, AfdLRRepostReceive);
                }
                else {
                    UPDATE_CONN (connection);
                }
            }
            else {
                PLIST_ENTRY listEntry;

                //
                // We need to put back the IRPs that we were going to complete
                //
                listEntry = completeIrpListHead.Blink;
                while ( listEntry!=&completeIrpListHead ) {
                    irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
                    listEntry = listEntry->Blink;

                    // Set up the cancellation routine back in the IRP. 
                    //

                    IoSetCancelRoutine( irp, AfdCancelReceive );

                    if ( !irp->Cancel ) {

                        RemoveEntryList (&irp->Tail.Overlay.ListEntry);
                        InsertHeadList (&connection->VcReceiveIrpListHead,
                                            &irp->Tail.Overlay.ListEntry);
                    }
                    else if (IoSetCancelRoutine( irp, NULL ) != NULL) {
                        //
                        // The cancel routine was never called.
                        // Have to handle cancellation here, just let the
                        // IRP remain in completed list and set the
                        // status appropriately keeping in mind that
                        // we cannot complete IRP as cancelled if it
                        // already has some data in it.
                        //
                        irpSp = IoGetCurrentIrpStackLocation (irp);
                        if (irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength!=0) {
                            ASSERT (!endpoint->EndpointCleanedUp); // checked above.
                            irp->IoStatus.Status = STATUS_SUCCESS;
                            irp->IoStatus.Information = irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
                        }
                        else {
                            irp->IoStatus.Status = STATUS_CANCELLED;
                        }

                    }
                    else {
                        RemoveEntryList (&irp->Tail.Overlay.ListEntry);
            
                        //
                        // The cancel routine is about to be run.
                        // Set the Flink to NULL so the cancel routine knows
                        // it is not on the list 
                        //

                        irp->Tail.Overlay.ListEntry.Flink = NULL;
                    }
                }

                UPDATE_CONN (connection);
            }

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            status = STATUS_DATA_NOT_ACCEPTED;
        }
    }
    else {
        AFD_VERIFY_MDL (connection, Tsdu, StartingOffset, offset-StartingOffset);
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        status = STATUS_SUCCESS;
    }

    while ( !IsListEmpty( &completeIrpListHead ) ) {
        PLIST_ENTRY listEntry;
        listEntry = RemoveHeadList( &completeIrpListHead );
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        irpSp = IoGetCurrentIrpStackLocation (irp);
        //
        // Copy the data into the IRP if it is not errored out and
        // we accepted the data.
        //
        if (status!=STATUS_DATA_NOT_ACCEPTED && !NT_ERROR (irp->IoStatus.Status)) {
            ULONG bytesCopied;
            if (irp->MdlAddress!=NULL) {
#if DBG
                NTSTATUS    status1 =
#endif
                AfdCopyMdlChainToMdlChain(
                             irp->MdlAddress,
                             irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength
                                - PtrToUlong(irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength),
                             Tsdu,
                             StartingOffset,
                             ReceiveLength,
                             &bytesCopied
                             );
                ASSERT (status1==STATUS_SUCCESS ||
                            status1==STATUS_BUFFER_OVERFLOW);

                ASSERT (irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength-
                            irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength>=bytesCopied);
                irp->IoStatus.Information =
                    irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength + bytesCopied;
            }
            else {
                bytesCopied = 0;
                ASSERT (irp->IoStatus.Information == 0);
                ASSERT (irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength==0);
                ASSERT (irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength==0);
            }

            if ((irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags& TDI_RECEIVE_PEEK) == 0) {
                StartingOffset += bytesCopied;
                ReceiveLength -= bytesCopied;
            }
        }
        else {
            //
            // Either we failing the irp or we already filled in some data
            // or this irp was for 0 bytes to begin with in which case
            // we just succeed it.
            //
            ASSERT (NT_ERROR (irp->IoStatus.Status) ||
                    irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength!=0||
                    irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength==0);
        }

        IF_DEBUG (RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdBChainedReceiveEventHandler: endpoint: %p, completing IRP: %p, status %lx, info: %ld.\n",
                        endpoint,
                        irp, 
                        irp->IoStatus.Status,
                        irp->IoStatus.Information));
        }
        UPDATE_CONN2(connection, "Completing chained receive with error/bytes read: 0x%lX",
                            (!NT_ERROR(irp->IoStatus.Status)
                                    ? (ULONG)irp->IoStatus.Information
                                    : (ULONG)irp->IoStatus.Status));
        IoCompleteRequest( irp, AfdPriorityBoost );
    }


    DEREFERENCE_CONNECTION (connection);
    IF_DEBUG (RECEIVE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdBChainedReceiveEventHandler<<: %ld\n", status));
    }

    return status;
}




NTSTATUS
AfdBReceiveEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )

/*++

Routine Description:

    Handles receive events for nonbufferring transports.

Arguments:


Return Value:


--*/

{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT   endpoint;
    PAFD_CONNECTION connection;
    PAFD_BUFFER     afdBuffer;
    PIRP            irp;
    PLIST_ENTRY     listEntry;
    ULONG           requiredAfdBufferSize;
    NTSTATUS        status;
    ULONG           receiveLength;
    BOOLEAN         expedited;
    BOOLEAN         completeMessage, result;

    UNREFERENCED_PARAMETER (TdiEventContext);
    DEBUG receiveLength = 0xFFFFFFFF;

    connection = (PAFD_CONNECTION)ConnectionContext;
    ASSERT( connection != NULL );

    CHECK_REFERENCE_CONNECTION2 (connection,"AfdBReceiveEventHandler, bytes available: 0x%lX", BytesAvailable, result );
    if (!result) {
        return STATUS_DATA_NOT_ACCEPTED;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );
    ASSERT( !connection->DisconnectIndicated );

    endpoint = connection->Endpoint;
    if (endpoint==NULL) {
        //
        // Indication after connection reuse, ignore.
        //
        DEREFERENCE_CONNECTION (connection);
        return STATUS_DATA_NOT_ACCEPTED;
    }

    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth );

    ASSERT( !IS_TDI_BUFFERRING(endpoint) );
    ASSERT( IS_VC_ENDPOINT (endpoint) );

    *BytesTaken = 0;

#if AFD_PERF_DBG
    if ( BytesAvailable == BytesIndicated ) {
        AfdFullReceiveIndications++;
    } else {
        AfdPartialReceiveIndications++;
    }
#endif

    //
    // Figure out whether this is a receive indication for normal
    // or expedited data, and whether this is a complete message.
    //

    expedited = (BOOLEAN)( (ReceiveFlags & TDI_RECEIVE_EXPEDITED) != 0 );

    completeMessage = (BOOLEAN)((ReceiveFlags & TDI_RECEIVE_ENTIRE_MESSAGE) != 0);

    //
    // If the receive side of the endpoint has been shut down, tell the
    // provider that we took all the data and reset the connection.
    // Also, account for these bytes in our count of bytes taken from
    // the transport.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if connection was accepted and use accept endpoint instead
    // of the listening.  Note that accept cannot happen while we are
    // holding listening endpoint spinlock, nor can endpoint change after
    // the accept and while connection is referenced, so it is safe to 
    // release listening spinlock if we discover that endpoint was accepted.
    //
    if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
            && (connection->Endpoint != endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        endpoint = connection->Endpoint;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
        ASSERT( !IS_TDI_BUFFERRING(endpoint) );
        ASSERT(  IS_VC_ENDPOINT (endpoint) );

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }


    if ( (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) != 0 ||
         endpoint->EndpointCleanedUp ) {

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdBReceiveEventHandler: receive shutdown, "
                    "%ld bytes, aborting endp %p\n",
                    BytesAvailable, endpoint ));

        *BytesTaken = BytesAvailable;

        //
        // Abort the connection.  Note that if the abort attempt fails
        // we can't do anything about it.
        //

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        (VOID)AfdBeginAbort( connection );

        DEREFERENCE_CONNECTION (connection);
        return STATUS_SUCCESS;
    }

    //
    // Check whether there are any IRPs waiting on the connection.  If
    // there is such an IRP and normal data is being indicated, use the
    // IRP to receive the data.
    //


    if ( !expedited ) {

        if (connection->RcvInitiated) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                        "AFD: Indication with outstanding receive on connection %p, 0x%x bytes available\n",
                        connection, BytesAvailable));
            //
            // We have initiated receive to the transport.
            // Let the transport find and complete it first
            // to preserve ordering.
            //
            connection->VcReceiveBytesInTransport = BytesAvailable;
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            DEREFERENCE_CONNECTION (connection);
            return STATUS_DATA_NOT_ACCEPTED;

        }

        //
        // If we are indicated data, we need to reset our record
        // of amount of data buffered by the transport.
        //
        connection->VcReceiveBytesInTransport = 0;

        while (!IsListEmpty( &connection->VcReceiveIrpListHead )) {
            PIO_STACK_LOCATION irpSp;

            ASSERT( *BytesTaken == 0 );

            listEntry = RemoveHeadList( &connection->VcReceiveIrpListHead );

            //
            // Get a pointer to the IRP and our stack location in it
            //

            irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

            irpSp = IoGetCurrentIrpStackLocation( irp );

            receiveLength = irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength-
                                irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
            //
            // If the IRP is not large enough to hold the available data, or
            // if it is a peek or expedited (exclusively, not both normal and 
            // expedited) receive IRP,  then we'll just buffer the
            // data manually and complete the IRP in the receive completion
            // routine.
            //

            if ( (receiveLength>=BytesAvailable) &&
                ((irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags
                        & TDI_RECEIVE_PEEK) == 0) &&
                  ((irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags
                        & TDI_RECEIVE_NORMAL) != 0)) {

                if ( IoSetCancelRoutine( irp, NULL ) == NULL ) {

                    //
                    // This IRP is about to be canceled.  Look for another in the
                    // list.  Set the Flink to NULL so the cancel routine knows
                    // it is not on the list.
                    //

                    irp->Tail.Overlay.ListEntry.Flink = NULL;
                    continue;
                }

                //
                // If all of the data was indicated to us here AND this is a
                // complete message in and of itself, then just copy the
                // data to the IRP and complete the IRP.
                //

                if ( completeMessage &&
                        (BytesIndicated == BytesAvailable)) {

                    AFD_VERIFY_BUFFER (connection, Tsdu, BytesAvailable);


                    //
                    // The IRP is off the endpoint's list and is no longer
                    // cancellable.  We can release the locks we hold.
                    //

                    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                    //
                    // Copy the data to the IRP.
                    //

                    if ( irp->MdlAddress != NULL ) {

                        status = AfdMapMdlChain (irp->MdlAddress);
                        if (NT_SUCCESS (status)) {
                            status = TdiCopyBufferToMdl(
                                         Tsdu,
                                         0,
                                         BytesAvailable,
                                         irp->MdlAddress,
                                         irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength
                                            - PtrToUlong(irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength),
                                         &receiveLength
                                         );
                            irp->IoStatus.Information =
                                receiveLength + irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
                            ASSERT (status == STATUS_SUCCESS);
                        }
                        else {
                            irp->IoStatus.Status = status;
                            irp->IoStatus.Information = 0;

                            UPDATE_CONN(connection);
                            IoCompleteRequest (irp, AfdPriorityBoost);
                            AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
                            continue;
                        }
                    } else {
                        ASSERT (irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength==0);
                        ASSERT ( BytesAvailable == 0 );
                        irp->IoStatus.Information = irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
                    }

                    //
                    // We have already set up the status field of the IRP
                    // when we pended the IRP, so there's no need to
                    // set it again here.
                    //
                    ASSERT( irp->IoStatus.Status == STATUS_SUCCESS );

                    //
                    // Complete the IRP.
                    //

                    IF_DEBUG (RECEIVE) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                    "AfdBReceiveEventHandler: endpoint: %p, completing IRP: %p, status %lx, info: %ld.\n",
                                    endpoint,
                                    irp, 
                                    irp->IoStatus.Status,
                                    irp->IoStatus.Information));
                    }
                    UPDATE_CONN2(connection, "Completing receive with error/bytes: 0x%lX",
                                            (!NT_ERROR(irp->IoStatus.Status)
                                                ? (ULONG)irp->IoStatus.Information
                                                : (ULONG)irp->IoStatus.Status));
                    IoCompleteRequest( irp, AfdPriorityBoost );

                    DEREFERENCE_CONNECTION (connection);
                    //
                    // Set BytesTaken  to tell the provider that we have taken all the data.
                    //

                    *BytesTaken = BytesAvailable;
                    return STATUS_SUCCESS;
                }

                //
                // Some of the data was not indicated, so remember that we
                // want to pass back this IRP to the TDI provider.  Passing
                // back this IRP directly is good because it avoids having
                // to copy the data from one of our buffers into the user's
                // buffer.
                //
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                ASSERT (InterlockedIncrement (&connection->VcReceiveIrpsInTransport)==1);

                requiredAfdBufferSize = 0;

                if (AfdIgnorePushBitOnReceives ||
                        IS_TDI_MESSAGE_MODE(endpoint)) {
                    receiveLength = BytesAvailable;
                }

                if (irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength>0) {
                    irp->MdlAddress = AfdAdvanceMdlChain (irp->MdlAddress,
                        irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength
                        -PtrToUlong(irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength)
                        );
                    ASSERT (irp->MdlAddress!=NULL);
                    irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength =
                            UlongToPtr(irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength);
                }

                TdiBuildReceive(
                    irp,
                    connection->DeviceObject,
                    connection->FileObject,
                    AfdRestartBufferReceiveWithUserIrp,
                    connection,
                    irp->MdlAddress,
                    ReceiveFlags & TDI_RECEIVE_EITHER,
                    receiveLength
                    );
#ifdef _AFD_VARIABLE_STACK_
                if ((irp=AfdCheckStackSizeAndRecordOutstandingIrp (
                                    endpoint,
                                    connection->DeviceObject,
                                    irp))!=NULL) {
#else // _AFD_VARIABLE_STACK_
                if (AfdRecordOutstandingIrp (endpoint,
                                    connection->DeviceObject,
                                    irp)) {

#endif // _AFD_VARIABLE_STACK_
                    //
                    // Make the next stack location current.  Normally IoCallDriver would
                    // do this, but since we're bypassing that, we do it directly.
                    //

                    IoSetNextIrpStackLocation( irp );

                    *IoRequestPacket = irp;
                    ASSERT (*BytesTaken == 0);

                    //
                    // Keep connection reference to be released in IRP completion routine
                    //

                    return STATUS_MORE_PROCESSING_REQUIRED;
                }
                else {

                    //
                    // Could not allocate substitute IRP or tracking info
                    // The IRP has aready been completed, go and try another one.
                    // Add extra reference to the connection to compensate for
                    // the one released in the completion routine.
                    //

                    CHECK_REFERENCE_CONNECTION (connection,result);
                    if (result) {
                        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
                        continue;
                    }
                    else
                        return STATUS_DATA_NOT_ACCEPTED;
                }
            }


            //
            // The first pended IRP is too tiny to hold all the
            // available data or else it is a peek or expedited receive
            // IRP.  Put the IRP back on the head of the list and buffer
            // the data and complete the IRP in the restart routine.
            //


            InsertHeadList(
                &connection->VcReceiveIrpListHead,
                &irp->Tail.Overlay.ListEntry
                );
            break;
        }

        //
        // Check whether we've already bufferred the maximum amount of
        // data that we'll allow ourselves to buffer for this
        // connection.  If we're at the limit, then we need to exert
        // back pressure by not accepting this indicated data (flow
        // control).
        //
        // Note that we have no flow control mechanisms for expedited
        // data.  We always accept any expedited data that is indicated
        // to us.
        //

        if ( connection->VcBufferredReceiveBytes >=
               connection->MaxBufferredReceiveBytes ||
               connection->VcBufferredReceiveCount==MAXUSHORT
                 ) {

            //
            // Just remember the amount of data that is available.  When
            // buffer space frees up, we'll actually receive this data.
            //

            connection->VcReceiveBytesInTransport += BytesAvailable;

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            DEREFERENCE_CONNECTION (connection);
            return STATUS_DATA_NOT_ACCEPTED;
        }

        // There were no prepended IRPs, we'll have to buffer the data
        // here in AFD.  If all of the available data is being indicated
        // to us AND this is a complete message, just copy the data
        // here.
        //


        if ( completeMessage && 
                BytesIndicated == BytesAvailable  && 
                IsListEmpty (&connection->VcReceiveIrpListHead)) {
            afdBuffer = AfdGetBuffer( endpoint, BytesAvailable, 0,
                                        connection->OwningProcess );
            if (afdBuffer!=NULL) {

                AFD_VERIFY_BUFFER (connection, Tsdu, BytesAvailable);
                //
                // Use the special function to copy the data instead of
                // RtlCopyMemory in case the data is coming from a special
                // place (DMA, etc.) which cannot work with RtlCopyMemory.
                //

                TdiCopyLookaheadData(
                    afdBuffer->Buffer,
                    Tsdu,
                    BytesAvailable,
                    ReceiveFlags
                    );

                //
                // Store the data length and set the offset to 0.
                //

                afdBuffer->DataLength = BytesAvailable;
                afdBuffer->DataOffset = 0;
                afdBuffer->RefCount = 1;

                afdBuffer->PartialMessage = FALSE;

                //
                // Place the buffer on this connection's list of bufferred data
                // and update the count of data bytes on the connection.
                //

                InsertTailList(
                    &connection->VcReceiveBufferListHead,
                    &afdBuffer->BufferListEntry
                    );

                connection->VcBufferredReceiveBytes += BytesAvailable;
                ASSERT (connection->VcBufferredReceiveCount<MAXUSHORT);
                connection->VcBufferredReceiveCount += 1;

                //
                // All done.  Release the lock and tell the provider that we
                // took all the data.
                //

                *BytesTaken = BytesAvailable;

                //
                // Indicate that it is possible to receive on the endpoint now.
                //

                endpoint->DisableFastIoRecv = FALSE;

                // Make sure connection was accepted/connected to prevent
                // indication on listening endpoint
                //

                if (connection->State==AfdConnectionStateConnected) {
                    ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
                    AfdIndicateEventSelectEvent(
                        endpoint,
                        AFD_POLL_RECEIVE,
                        STATUS_SUCCESS
                        );
                    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                    AfdIndicatePollEvent(
                        endpoint,
                        AFD_POLL_RECEIVE,
                        STATUS_SUCCESS
                        );
                }
                else {
                    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                }

                DEREFERENCE_CONNECTION (connection);
                return STATUS_SUCCESS;
            }
        }
        else {

            //
            // There were no prepended IRPs and not all of the data was
            // indicated to us.  We'll have to buffer it by handing an IRP
            // back to the TDI privider.
            //
            // Note that in this case we sometimes hand a large buffer to
            // the TDI provider.  We do this so that it can hold off
            // completion of our IRP until it gets EOM or the buffer is
            // filled.  This reduces the number of receive indications that
            // the TDI provider has to perform and also reduces the number
            // of kernel/user transitions the application will perform
            // because we'll tend to complete receives with larger amounts
            // of data.
            //
            // We do not hand back a "large" AFD buffer if the indicated data
            // is greater than the large buffer size or if the TDI provider
            // is message mode.  The reason for not giving big buffers back
            // to message providers is that they will hold on to the buffer
            // until a full message is received and this would be incorrect
            // behavior on a SOCK_STREAM.
            //


            if ( AfdLargeBufferSize >= BytesAvailable &&
                    !AfdIgnorePushBitOnReceives &&
                    !IS_TDI_MESSAGE_MODE(endpoint) ) {
                requiredAfdBufferSize = AfdLargeBufferSize;
                receiveLength = AfdLargeBufferSize;
            } else {
                requiredAfdBufferSize = BytesAvailable;
                receiveLength = BytesAvailable;
            }

            //
            // We're able to buffer the data.  First acquire a buffer of
            // appropriate size.
            //

            afdBuffer = AfdGetBuffer( endpoint, requiredAfdBufferSize, 0,
                                            connection->OwningProcess );
            if ( afdBuffer != NULL ) {
                //
                // Note that we posted our own receive IRP to transport,
                // so that user IRPs do not get forwarded there
                //
                ASSERT (InterlockedDecrement (&connection->VcReceiveIrpsInTransport)==-1);
                goto FormatReceive;
            }
        }

        // We failed to allocate the buffer.
        // Just remember the amount of data that is available.  When
        // buffer space frees up, we'll actually receive this data.
        //

        connection->VcReceiveBytesInTransport += BytesAvailable;

        if (connection->VcBufferredReceiveBytes == 0 &&
                !connection->OnLRList) {
            //
            // Since we do not have any data buffered, application
            // is not notified and will never call with recv.
            // We will have to put this on low resource list
            // and attempt to allocate memory and pull the data
            // later.
            //
            connection->OnLRList = TRUE;
            REFERENCE_CONNECTION (connection);
            AfdLRListAddItem (&connection->LRListItem, AfdLRRepostReceive);
        }
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    
        DEREFERENCE_CONNECTION (connection);
        return STATUS_DATA_NOT_ACCEPTED;

    } else {

        //
        // We're being indicated with expedited data.  Buffer it and
        // complete any pended IRPs in the restart routine.  We always
        // buffer expedited data to save complexity and because expedited
        // data is not an important performance case.
        //
        // !!! do we need to perform flow control with expedited data?
        //

        requiredAfdBufferSize = BytesAvailable;
        receiveLength = BytesAvailable;
        //
        // We're able to buffer the data.  First acquire a buffer of
        // appropriate size.
        //

        if ( connection->VcBufferredExpeditedCount==MAXUSHORT ||
                (afdBuffer=AfdGetBuffer (endpoint, requiredAfdBufferSize, 0,
                                        connection->OwningProcess))== NULL ) {
            // If we couldn't get a buffer, abort the connection.  This is
            // pretty brutal, but the only alternative is to attempt to
            // receive the data sometime later, which is very complicated to
            // implement.
            //

            AfdBeginAbort( connection );

            *BytesTaken = BytesAvailable;
    
            DEREFERENCE_CONNECTION (connection);
            return STATUS_SUCCESS;
        }
    }

FormatReceive:

    //
    // We'll have to format up an IRP and give it to the provider to
    // handle.  We don't need any locks to do this--the restart routine
    // will check whether new receive IRPs were pended on the endpoint.
    //

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    ASSERT (afdBuffer!=NULL);

    //
    // Use the IRP in the AFD buffer if appropriate.  If userIrp is
    // TRUE, then the local variable irp will already point to the
    // user's IRP which we'll use for this IO.
    //

    irp = afdBuffer->Irp;
    ASSERT( afdBuffer->Mdl == irp->MdlAddress );

    //
    // We need to remember the connection in the AFD buffer because
    // we'll need to access it in the completion routine.
    //

    afdBuffer->Context = connection;

    //
    // Remember the type of data that we're receiving.
    //

    afdBuffer->ExpeditedData = expedited;
    afdBuffer->PartialMessage = !completeMessage;

    TdiBuildReceive(
        irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartBufferReceive,
        afdBuffer,
        irp->MdlAddress,
        ReceiveFlags & TDI_RECEIVE_EITHER,
        receiveLength
        );


    //
    // Finish building the receive IRP to give to the TDI provider.
    //

    ASSERT( receiveLength != 0xFFFFFFFF );


    //
    // Make the next stack location current.  Normally IoCallDriver would
    // do this, but since we're bypassing that, we do it directly.
    //

    IoSetNextIrpStackLocation( irp );

    *IoRequestPacket = irp;
    ASSERT (*BytesTaken == 0);

    //
    // Keep connection reference to be released in IRP completion routine
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // AfdBReceiveEventHandler


NTSTATUS
AfdBReceiveExpeditedEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )

/*++

Routine Description:

    Handles receive expedited events for nonbufferring transports.

Arguments:


Return Value:


--*/

{
    return AfdBReceiveEventHandler (
               TdiEventContext,
               ConnectionContext,
               ReceiveFlags | TDI_RECEIVE_EXPEDITED,
               BytesIndicated,
               BytesAvailable,
               BytesTaken,
               Tsdu,
               IoRequestPacket
               );

} // AfdBReceiveExpeditedEventHandler


NTSTATUS
AfdRestartBufferReceiveWithUserIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Handles completion of bufferred receives that were started in the
    receive indication handler or receive routine with application
    IRP passed directly to the transport.

Arguments:

    DeviceObject - not used.

    Irp - the IRP that is completing.

    Context - connection on which we receive the data

Return Value:

    STATUS_SUCCESS if user IRP is completed,
    STATUS_MORE_PROCESSING_REQUIRED if we can't complete it.
--*/

{
    PAFD_ENDPOINT   endpoint;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PIO_STACK_LOCATION  irpSp;


    UNREFERENCED_PARAMETER (DeviceObject);
    //
    // The IRP being completed is actually a user's IRP, set it up
    // for completion and allow IO completion to finish.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    
    connection = Context;
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth);
    ASSERT( IS_VC_ENDPOINT(endpoint) );
    ASSERT( !IS_TDI_BUFFERRING(endpoint) );

    AfdCompleteOutstandingIrp (endpoint, Irp);

    //
    // We could not have any buffered data if we are completing user
    // IRP
    //
    ASSERT( !(irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags&TDI_RECEIVE_NORMAL)
                || !IS_DATA_ON_CONNECTION( connection ));

    ASSERT( !(irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags&TDI_RECEIVE_EXPEDITED)
                || !IS_EXPEDITED_DATA_ON_CONNECTION( connection ));

    AFD_VERIFY_MDL (connection, Irp->MdlAddress, 0, Irp->IoStatus.Information);

    ASSERT (InterlockedDecrement (&connection->VcReceiveIrpsInTransport)>=0);


    //
    // If pending has be returned for this IRP then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }


    UPDATE_CONN2 (connection, "Completing user receive with error/bytes: 0x%lX", 
                 !NT_ERROR (Irp->IoStatus.Status)
                     ? (ULONG)Irp->IoStatus.Information
                     : (ULONG)Irp->IoStatus.Status);

    if (connection->RcvInitiated) {
        //
        // Completion of receive initiated by AFD in low memory
        // conditions (as opposed to IRP returned to the
        // transport in the indication handler).
        //
        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        connection->RcvInitiated = FALSE;
        ASSERT (connection->OnLRList == FALSE);
        ASSERT (connection->VcBufferredReceiveBytes==0);
        if (!NT_ERROR (Irp->IoStatus.Status)) {
            ASSERT (connection->VcReceiveBytesInTransport>0 || connection->Aborted);
            if (connection->VcReceiveBytesInTransport > Irp->IoStatus.Information) {
                connection->VcReceiveBytesInTransport -= (ULONG)Irp->IoStatus.Information;
            }
            else {
                connection->VcReceiveBytesInTransport = 0;
            }
        }
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AFD: Completing LR initiated user receive on connection %p, bytes/error: 0x%lx, 0x%x remains\n",
                    connection,
                    NT_SUCCESS (Irp->IoStatus.Status)
                        ? (ULONG)Irp->IoStatus.Information
                        : Irp->IoStatus.Status,
                    connection->VcReceiveBytesInTransport));
        //
        // We need to keep retreiving data from the transport
        // if we know there is still something in there.
        //
        if (connection->VcReceiveBytesInTransport>0 &&
                !connection->Aborted &&
                !connection->DisconnectIndicated &&
                (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) == 0 &&
                !endpoint->EndpointCleanedUp &&
                !connection->OnLRList) {
            connection->OnLRList = TRUE;
            REFERENCE_CONNECTION (connection);
            AfdLRListAddItem (&connection->LRListItem, AfdLRRepostReceive);
        }
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    //
    // If transport cancelled the IRP and we already had some data
    // in it, do not complete with STATUS_CANCELLED since this will
    // result in data loss.
    //

    if (Irp->IoStatus.Status==STATUS_CANCELLED &&
            irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength>0 &&
            !endpoint->EndpointCleanedUp) {
        Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
    }
    else if (!NT_ERROR (Irp->IoStatus.Status)) {
        Irp->IoStatus.Information += irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
    }

    if (Irp->IoStatus.Status==STATUS_BUFFER_OVERFLOW ||
            Irp->IoStatus.Status == STATUS_RECEIVE_PARTIAL ||
            Irp->IoStatus.Status == STATUS_RECEIVE_PARTIAL_EXPEDITED) {
        if (!IS_MESSAGE_ENDPOINT(endpoint)) {
            //
            // For stream endpoint partial message does not make
            // sense (unless this is the special hack for transports that
            // terminate the connection when we cancel IRPs), ignore it.
            //
            Irp->IoStatus.Status = STATUS_SUCCESS;
        }
        else if ((Irp->IoStatus.Information
                    <irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength) &&
                ((irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags & TDI_RECEIVE_PARTIAL) == 0 )) {
            NTSTATUS        status = STATUS_MORE_PROCESSING_REQUIRED;


            AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);


            //
            // Reset the status to success if we need to complete the IRP
            // This is not entirely correct for message endpoints since
            // we should not be completing the IRP unless we received the
            // entire message.  However, the only way this can happen is
            // when the part of the message was received as IRP is cancelled
            // and the only other this we possibly do is to try to copy data
            // in our own buffer and reinsert it back to the queue.
            //

            Irp->IoStatus.Status = STATUS_SUCCESS;

            //
            // Set up the cancellation routine back in the IRP. 
            //

            IoSetCancelRoutine( Irp, AfdCancelReceive );

            if ( Irp->Cancel ) {

                if (IoSetCancelRoutine( Irp, NULL ) != NULL) {

                    //
                    // Completion routine has not been reset,
                    // let the system complete the IRP on return
                    //
                    status = STATUS_SUCCESS;

                }
                else {
                
                    //
                    // The cancel routine is about to be run.
                    // Set the Flink to NULL so the cancel routine knows
                    // it is not on the list and tell the system
                    // not to touch the irp
                    //

                    Irp->Tail.Overlay.ListEntry.Flink = NULL;
                }
            }
            else {
                //
                // Reinset IRP back in the list if partial completion 
                // is impossible and tell the system not to touch it
                //
                irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength = (ULONG)Irp->IoStatus.Information;
        
                InsertHeadList (&connection->VcReceiveIrpListHead,
                                    &Irp->Tail.Overlay.ListEntry);
            }

            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
            //
            // Release connection reference acquired when we handed IRP to transport
            //
            DEREFERENCE_CONNECTION (connection);

            return status;
        }
    }


    IF_DEBUG (RECEIVE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartBufferReceiveWithUserIrp: endpoint: %p, letting IRP: %p, status %lx, info: %ld.\n",
                    endpoint,
                    Irp, 
                    Irp->IoStatus.Status,
                    Irp->IoStatus.Information));
    }

    //
    // Release connection reference acquired when we handed IRP to transport
    //
    DEREFERENCE_CONNECTION (connection);

    //
    // Tell the IO system that it is OK to continue with IO
    // completion.
    //
    return STATUS_SUCCESS;
} //AfdRestartBufferReceiveWithUserIrp


NTSTATUS
AfdRestartBufferReceive (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Handles completion of bufferred receives that were started in the
    receive indication handler or AfdBReceive using Afds buffer and 
    associated IRP.

Arguments:

    DeviceObject - not used.

    Irp - the IRP that is completing.

    Context - AfdBuffer in which we receive the data.

Return Value:

    NTSTATUS - this is our IRP, so we always return
    STATUS_MORE_PROCESSING_REQUIRED to indicate to the IO system that we
    own the IRP and the IO system should stop processing the it.

--*/

{
    PAFD_ENDPOINT   endpoint;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_BUFFER     afdBuffer;
    PLIST_ENTRY     listEntry;
    LIST_ENTRY      completeIrpListHead;
    PIRP            userIrp;
    BOOLEAN         expedited;
    NTSTATUS        irpStatus;

    UNREFERENCED_PARAMETER (DeviceObject);

    afdBuffer = Context;
    ASSERT (IS_VALID_AFD_BUFFER (afdBuffer));


    irpStatus = Irp->IoStatus.Status;

    //
    // We treat STATUS_BUFFER_OVERFLOW just like STATUS_RECEIVE_PARTIAL.
    //

    if ( irpStatus == STATUS_BUFFER_OVERFLOW )
        irpStatus = STATUS_RECEIVE_PARTIAL;

    connection = afdBuffer->Context;
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth );

    ASSERT( !IS_TDI_BUFFERRING(endpoint) );
    ASSERT( IS_VC_ENDPOINT (endpoint) );


    if ( !NT_SUCCESS(irpStatus) ) {

        afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;
        AfdReturnBuffer( &afdBuffer->Header, connection->OwningProcess );

        if (connection->RcvInitiated) {
            AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
            connection->RcvInitiated = FALSE;
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        }
        (VOID)AfdBeginAbort (connection);
        DEREFERENCE_CONNECTION (connection);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    AFD_VERIFY_MDL (connection, Irp->MdlAddress, 0, Irp->IoStatus.Information);

    //
    // Remember the length of the received data.
    //

    afdBuffer->DataLength = (ULONG)Irp->IoStatus.Information;


    //
    // Initialize the local list we'll use to complete any receive IRPs.
    // We use a list like this because we may need to complete multiple
    // IRPs and we usually cannot complete IRPs at any random point due
    // to any locks we might hold.
    //

    InitializeListHead( &completeIrpListHead );


    //
    // If there are any pended IRPs on the connection, complete as
    // appropriate with the new information.  Note that we'll try to
    // complete as many pended IRPs as possible with this new buffer of
    // data.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if connection was accepted and use accept endpoint instead
    // of the listening.  Note that accept cannot happen while we are
    // holding listening endpoint spinlock, nor can endpoint change after
    // the accept and while connections is referenced, so it is safe to
    // release listening spinlock if we discover that endpoint was accepted.
    //
    if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
            && (connection->Endpoint != endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        endpoint = connection->Endpoint;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
        ASSERT( !IS_TDI_BUFFERRING(endpoint) );
        ASSERT(  IS_VC_ENDPOINT (endpoint) );

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    if (connection->RcvInitiated) {
        connection->RcvInitiated = FALSE;
        ASSERT (afdBuffer->ExpeditedData == FALSE);
        ASSERT (connection->OnLRList == FALSE);
        if (connection->VcReceiveBytesInTransport > afdBuffer->DataLength) {
            connection->VcReceiveBytesInTransport -= afdBuffer->DataLength;
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                        "AFD: Completing LR initiated AFD receive on connection %p, bytes: 0x%lx, 0x%x remains\n",
                        connection,
                        afdBuffer->DataLength,
                        connection->VcReceiveBytesInTransport));
        }
        else {
            connection->VcReceiveBytesInTransport = 0;
        }
    }

    expedited = afdBuffer->ExpeditedData;

    //
    // Note that there are no more of our own receive IRPs in transport
    // and we can start forwarding application IRPs if necessary.
    //
    ASSERT (expedited || InterlockedIncrement (&connection->VcReceiveIrpsInTransport)==0);


    afdBuffer->DataOffset = AfdBFillPendingIrps (
                                connection,
                                afdBuffer->Mdl,
                                0,
                                afdBuffer->DataLength,
                                (expedited ? TDI_RECEIVE_EXPEDITED : 0) |
                                    ((irpStatus==STATUS_SUCCESS) ? TDI_RECEIVE_ENTIRE_MESSAGE : 0) |
                                    (!IS_MESSAGE_ENDPOINT(endpoint) ? AFD_RECEIVE_STREAM : 0),
                                &completeIrpListHead
                                );
    ASSERT (afdBuffer->DataOffset<=afdBuffer->DataLength);
    afdBuffer->DataLength -= afdBuffer->DataOffset;
    //
    // If there is any data left, place the buffer at the end of the
    // connection's list of bufferred data and update counts of data on
    // the connection.
    //
    if (afdBuffer->DataLength>0) {

        afdBuffer->RefCount = 1;
        InsertTailList(
            &connection->VcReceiveBufferListHead,
            &afdBuffer->BufferListEntry
            );

        if ( expedited ) {
            connection->VcBufferredExpeditedBytes += afdBuffer->DataLength;
            ASSERT (connection->VcBufferredExpeditedCount<MAXUSHORT);
            connection->VcBufferredExpeditedCount += 1;
        } else {
            connection->VcBufferredReceiveBytes += afdBuffer->DataLength;
            ASSERT (connection->VcBufferredReceiveCount<MAXUSHORT);
            connection->VcBufferredReceiveCount += 1;
        }

        //
        // Remember whether we got a full or partial receive in the
        // AFD buffer.
        //

        if ( irpStatus == STATUS_RECEIVE_PARTIAL ||
                 irpStatus == STATUS_RECEIVE_PARTIAL_EXPEDITED ) {
            afdBuffer->PartialMessage = TRUE;
        } else {
            afdBuffer->PartialMessage = FALSE;
        }
        
        //
        // We queued the buffer and thus we can't use it after releasing
        // the spinlock.  This will also signify the fact that we do not
        // need to free the buffer.
        //
        afdBuffer = NULL;

        if (connection->State==AfdConnectionStateConnected) {
            endpoint->DisableFastIoRecv = FALSE;
            if ( expedited && !endpoint->InLine ) {

                AfdIndicateEventSelectEvent(
                    endpoint,
                    AFD_POLL_RECEIVE_EXPEDITED,
                    STATUS_SUCCESS
                    );

            } else {

                AfdIndicateEventSelectEvent(
                    endpoint,
                    AFD_POLL_RECEIVE,
                    STATUS_SUCCESS
                    );
            }
        }
    }
    else if (connection->VcReceiveBytesInTransport>0 &&
            !connection->Aborted && 
            !connection->DisconnectIndicated &&
            (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) == 0 &&
            !endpoint->EndpointCleanedUp &&
            !connection->OnLRList) {
        //
        // More data even after buffer completed.
        // We must be completed an LR initiated small receive.
        // Continue LR processing.
        //
        connection->OnLRList = TRUE;
        REFERENCE_CONNECTION (connection);
        AfdLRListAddItem (&connection->LRListItem, AfdLRRepostReceive);
    }


    //
    // Release locks and indicate that there is bufferred data on the
    // endpoint.
    //

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // If there was leftover data (we queued the buffer), complete polls 
    // as necessary.  Indicate expedited data if the endpoint is not 
    // InLine and expedited data was received; otherwise, indicate normal data.
    //

    if ( afdBuffer==NULL ) {

        // Make sure connection was accepted/connected to prevent
        // indication on listening endpoint
        //
        
        if (connection->State==AfdConnectionStateConnected) {
            ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
            if ( expedited && !endpoint->InLine ) {

                AfdIndicatePollEvent(
                    endpoint,
                    AFD_POLL_RECEIVE_EXPEDITED,
                    STATUS_SUCCESS
                    );

            } else {

                AfdIndicatePollEvent(
                    endpoint,
                    AFD_POLL_RECEIVE,
                    STATUS_SUCCESS
                    );
            }
        }

    }
    else {
        ASSERT (afdBuffer->DataLength==0);
        afdBuffer->ExpeditedData = FALSE;
        AfdReturnBuffer (&afdBuffer->Header, connection->OwningProcess);
    }

    //
    // Complete IRPs as necessary.
    //

    while ( !IsListEmpty( &completeIrpListHead ) ) {
        listEntry = RemoveHeadList( &completeIrpListHead );
        userIrp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

        IF_DEBUG (RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdRestartBufferReceive: endpoint: %p, completing IRP: %p, status %lx, info: %ld.\n",
                        endpoint,
                        userIrp, 
                        userIrp->IoStatus.Status,
                        userIrp->IoStatus.Information));
        }
        UPDATE_CONN2(connection, "Completing buffered receive with error/bytes: 0x%lX",
                            (!NT_ERROR(userIrp->IoStatus.Status)
                                    ? (ULONG)userIrp->IoStatus.Information
                                    : (ULONG)userIrp->IoStatus.Status));
        IoCompleteRequest( userIrp, AfdPriorityBoost );
    }

    //
    // Release connection reference acquired when we handed IRP to transport
    //

    DEREFERENCE_CONNECTION (connection);
    
    //
    // Tell the IO system to stop processing the AFD IRP, since we now
    // own it as part of the AFD buffer.
    //
    return STATUS_MORE_PROCESSING_REQUIRED;

} // AfdRestartBufferReceive


ULONG
AfdBFillPendingIrps (
    PAFD_CONNECTION     Connection,
    PMDL                Mdl,
    ULONG               DataOffset,
    ULONG               DataLength,
    ULONG               Flags,
    PLIST_ENTRY         CompleteIrpListHead
    ) {
    PIRP            userIrp;
    NTSTATUS        status;
    BOOLEAN         expedited = (BOOLEAN)((Flags & TDI_RECEIVE_EXPEDITED)!=0);

    while ((DataLength>0)
            && (userIrp = AfdGetPendedReceiveIrp(
                               Connection,
                               expedited )) != NULL ) {
        PIO_STACK_LOCATION irpSp;
        ULONG receiveFlags;
        ULONG spaceInIrp;
        ULONG bytesCopied=(ULONG)-1;
        BOOLEAN peek;
        BOOLEAN partialReceivePossible;
        if ( IoSetCancelRoutine( userIrp, NULL ) == NULL ) {

            //
            // This IRP is about to be canceled.  Look for another in the
            // list.  Set the Flink to NULL so the cancel routine knows
            // it is not on the list.
            //

            userIrp->Tail.Overlay.ListEntry.Flink = NULL;
            continue;
        }
        //
        // Set up some locals.
        //

        irpSp = IoGetCurrentIrpStackLocation( userIrp );

        receiveFlags = (ULONG)irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags;
        spaceInIrp = irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength-
                                    irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
        peek = (BOOLEAN)( (receiveFlags & TDI_RECEIVE_PEEK) != 0 );

        if ( (Flags & AFD_RECEIVE_STREAM) ||
                 (receiveFlags & TDI_RECEIVE_PARTIAL) != 0 ) {
            partialReceivePossible = TRUE;
        } else {
            partialReceivePossible = FALSE;
        }

        //
        // If we were not indicated a entire message and the first
        // IRP has more space, do not take the data, instead pass
        // it back to the transport to wait for a push bit and fill
        // as much as possible.  Non-chained receive handles this case
        // outside of this routine.
        // Note that endpoint must be of stream type or the IRP
        // should not allow partial receive.
        // Also, peek and expedited receive are not eligible for this
        // performance optimization.
        //

        if (!peek &&
                (Flags & AFD_RECEIVE_CHAINED) && 
                ((Flags & (TDI_RECEIVE_EXPEDITED|TDI_RECEIVE_ENTIRE_MESSAGE))==0) &&
                ((Flags & AFD_RECEIVE_STREAM) || ((receiveFlags & TDI_RECEIVE_PARTIAL)==0)) &&
                (DataLength<spaceInIrp) &&
                IsListEmpty (CompleteIrpListHead) &&
                !AfdIgnorePushBitOnReceives) {

            InsertTailList (CompleteIrpListHead, &userIrp->Tail.Overlay.ListEntry);
            return (ULONG)-1;
        }
        //
        // Copy data to the user's IRP.
        //

        if ( userIrp->MdlAddress != NULL ) {

            status = AfdMapMdlChain (userIrp->MdlAddress);
            if (NT_SUCCESS (status)) {
                if (Flags & AFD_RECEIVE_CHAINED) {
                    status = (DataLength<=spaceInIrp)
                            ? STATUS_SUCCESS
                            : STATUS_BUFFER_OVERFLOW;
                }
                else {
                    status = AfdCopyMdlChainToMdlChain(
                                 userIrp->MdlAddress,
                                 irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength
                                    - PtrToUlong(irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength),
                                 Mdl,
                                 DataOffset,
                                 DataLength,
                                 &bytesCopied
                                 );
                    userIrp->IoStatus.Information =
                        irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength + bytesCopied;
                }
            }
            else {
                ASSERT (irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength==0);
                userIrp->IoStatus.Status = status;
                userIrp->IoStatus.Information = 0;
                //
                // Add the IRP to the list of IRPs we'll need to complete once we
                // can release locks.
                //

                InsertTailList(
                    CompleteIrpListHead,
                    &userIrp->Tail.Overlay.ListEntry
                    );
                continue;
            }

        } else {

            status = STATUS_BUFFER_OVERFLOW;
            userIrp->IoStatus.Information = 0;
        }
        ASSERT( status == STATUS_SUCCESS || status == STATUS_BUFFER_OVERFLOW );

        //
        // For stream type endpoints, it does not make sense to return
        // STATUS_BUFFER_OVERFLOW.  That status is only sensible for
        // message-oriented transports.  We have already set up the
        // status field of the IRP when we pended it, so we don't
        // need to do it again here.
        //

        if ( Flags & AFD_RECEIVE_STREAM ) {
            ASSERT( userIrp->IoStatus.Status == STATUS_SUCCESS );
        } else {
            userIrp->IoStatus.Status = status;
        }

        //
        // We can complete the IRP under any of the following
        // conditions:
        //
        //    - the buffer contains a complete message of data.
        //
        //    - it is OK to complete the IRP with a partial message.
        //
        //    - the IRP is already full of data.
        //

        if ( (Flags & TDI_RECEIVE_ENTIRE_MESSAGE)

                 ||

             partialReceivePossible

                 ||

             status == STATUS_BUFFER_OVERFLOW ) {

            //
            // Convert overflow status for message endpoints
            // (either we overflowed the buffer or transport
            // indicated us incomplete message. For the latter
            // we have already decided that we can complete the
            // receive - partialReceivePossible).
            //
            if (!(Flags & AFD_RECEIVE_STREAM) &&
                    ((status==STATUS_BUFFER_OVERFLOW) ||
                        ((Flags & TDI_RECEIVE_ENTIRE_MESSAGE)==0))) {
                userIrp->IoStatus.Status = 
                            (receiveFlags & TDI_RECEIVE_EXPEDITED) 
                                ? STATUS_RECEIVE_PARTIAL_EXPEDITED
                                : STATUS_RECEIVE_PARTIAL;

            }
            //
            // Add the IRP to the list of IRPs we'll need to complete once we
            // can release locks.
            //

            InsertTailList(
                CompleteIrpListHead,
                &userIrp->Tail.Overlay.ListEntry
                );

        } else {

            //
            // Set up the cancellation routine back in the IRP.  If the IRP 
            // has already been cancelled, continue with the next one.
            //

            IoSetCancelRoutine( userIrp, AfdCancelReceive );

            if ( userIrp->Cancel ) {


                if (IoSetCancelRoutine( userIrp, NULL ) != NULL) {

                    //
                    // Completion routine has not been reset,
                    // we have to complete it ourselves, so add it
                    // to our completion list.
                    //

                    if (irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength==0 ||
                            Connection->Endpoint->EndpointCleanedUp) {
                        userIrp->IoStatus.Status = STATUS_CANCELLED;
                    }
                    else {
                        //
                        // We cannot set STATUS_CANCELLED
                        // since we loose data already placed in the IRP.
                        //
                        userIrp->IoStatus.Information = irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
                        userIrp->IoStatus.Status = STATUS_SUCCESS;
                    }

                    InsertTailList(
                        CompleteIrpListHead,
                        &userIrp->Tail.Overlay.ListEntry
                        );
                }
                else {
                    
                    //
                    // The cancel routine is about to be run.
                    // Set the Flink to NULL so the cancel routine knows
                    // it is not on the list.
                    //

                    userIrp->Tail.Overlay.ListEntry.Flink = NULL;
                }
                continue;
            }
            else {

                if (Flags & AFD_RECEIVE_CHAINED) {
                    status = AfdCopyMdlChainToMdlChain(
                                 userIrp->MdlAddress,
                                 irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength
                                    - PtrToUlong(irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength),
                                 Mdl,
                                 DataOffset,
                                 DataLength,
                                 &bytesCopied
                                 );

                }
                ASSERT (status==STATUS_SUCCESS);
                ASSERT (bytesCopied<=spaceInIrp);
            
                //
                // Update the count of data placed into the IRP thus far.
                //

                irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength += bytesCopied;

                //
                // Put the IRP back on the connection's list of pended IRPs.
                //

                InsertHeadList(
                    &Connection->VcReceiveIrpListHead,
                    &userIrp->Tail.Overlay.ListEntry
                    );
            }
        }
        //
        // If the IRP was not a peek IRP, update the AFD buffer
        // accordingly.  If it was a peek IRP then the data should be
        // reread, so keep it around.
        //

        if ( !peek ) {

            //
            // If we copied all of the data from the buffer to the IRP,
            // free the AFD buffer structure.
            //

            if ( status == STATUS_SUCCESS ) {

                DataOffset += DataLength;
                DataLength = 0;

            } else {

                //
                // There is more data left in the buffer.  Update counts in
                // the AFD buffer structure.
                //

                ASSERT(DataLength > spaceInIrp);

                DataOffset += spaceInIrp;
                DataLength -= spaceInIrp;

            }
        }
        if (Connection->VcReceiveIrpListHead.Flink
                    ==&userIrp->Tail.Overlay.ListEntry)

            //
            // We reinserted IRP back on pending list, so
            // stop processing this buffer for now.
            //
            // !!! This could cause a problem if there is a regular
            //     receive pended behind a peek IRP!  But that is a
            //     pretty unlikely scenario.
            //

            break;
    }

    return DataOffset;
}





VOID
AfdCancelReceive (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Cancels a receive IRP that is pended in AFD.

Arguments:

    DeviceObject - not used.

    Irp - the IRP to cancel.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    UNREFERENCED_PARAMETER (DeviceObject);
    //
    // Get the endpoint pointer from our IRP stack location and the
    // connection pointer from the endpoint.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    endpoint = irpSp->FileObject->FsContext;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth );


    //
    // Remove the IRP from the endpoint's IRP list, synchronizing with
    // the endpoint lock which protects the lists.  Note that the
    // IRP *must* be on one of the endpoint's lists or the Flink is NULL
    // if we are getting called here--anybody that removes the IRP from
    // the list must reset the cancel routine to NULL and set the
    // Flink to NULL before releasing the endpoint spin lock.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    if ( Irp->Tail.Overlay.ListEntry.Flink != NULL ) {
        RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
    }

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Release the cancel spin lock and complete the IRP with a
    // cancellation status code.
    //

    IoReleaseCancelSpinLock( Irp->CancelIrql );

    if (irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength==0 ||
            endpoint->EndpointCleanedUp) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        UPDATE_CONN(endpoint->Common.VcConnecting.Connection);
    }
    else {
        //
        // There was some data in the IRP, do not complete with
        // STATUS_CANCELLED, since this will result in data loss
        //
        Irp->IoStatus.Information = irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        UPDATE_CONN2 (endpoint->Common.VcConnecting.Connection, 
                            "Completing cancelled irp with 0x%lX bytes",
                            (ULONG)Irp->IoStatus.Information);
    }

    IoCompleteRequest( Irp, AfdPriorityBoost );

    return;

} // AfdCancelReceive


PAFD_BUFFER_HEADER
AfdGetReceiveBuffer (
    IN PAFD_CONNECTION Connection,
    IN ULONG ReceiveFlags,
    IN PAFD_BUFFER_HEADER StartingAfdBuffer OPTIONAL
    )

/*++

Routine Description:

    Returns a pointer to a receive data buffer that contains the
    appropriate type of data.  Note that this routine DOES NOT remove
    the buffer structure from the list it is on.

    This routine MUST be called with the connection's endpoint lock
    held!

Arguments:

    Connection - a pointer to the connection to search for data.

    ReceiveFlags - the type of receive data to look for.

    StartingAfdBuffer - if non-NULL, start looking for a buffer AFTER
        this buffer.

Return Value:

    PAFD_BUFFER - a pointer to an AFD buffer of the appropriate data type,
        or NULL if there was no appropriate buffer on the connection.

--*/

{
    PLIST_ENTRY listEntry;
    PAFD_BUFFER_HEADER afdBuffer;

    ASSERT( KeGetCurrentIrql( ) == DISPATCH_LEVEL );

    //
    // Start with the first AFD buffer on the connection.
    //

    listEntry = Connection->VcReceiveBufferListHead.Flink;
    afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );

    //
    // If a starting AFD buffer was specified, walk past that buffer in
    // the connection list.
    //

    if ( ARGUMENT_PRESENT( StartingAfdBuffer ) ) {

        while ( TRUE ) {

            if ( afdBuffer == StartingAfdBuffer ) {
                listEntry = listEntry->Flink;
                afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );
                //
                // Don't mix expedited and non-expedited data.
                //
                if (afdBuffer->ExpeditedData!=StartingAfdBuffer->ExpeditedData)
                    return NULL;
                break;
            }

            listEntry = listEntry->Flink;
            afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );

            ASSERT( listEntry != &Connection->VcReceiveBufferListHead );
        }
    }

    //
    // Act based on the type of data we're trying to get.
    //

    switch ( ReceiveFlags & TDI_RECEIVE_EITHER ) {

    case TDI_RECEIVE_NORMAL:

        //
        // Walk the connection's list of data buffers until we find the
        // first data buffer that is of the appropriate type.
        //

        while ( listEntry != &Connection->VcReceiveBufferListHead &&
                    afdBuffer->ExpeditedData ) {

            listEntry = afdBuffer->BufferListEntry.Flink;
            afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );
        }

        if ( listEntry != &Connection->VcReceiveBufferListHead ) {
            return afdBuffer;
        } else {
            return NULL;
        }

    case TDI_RECEIVE_EITHER :

        //
        // Just return the first buffer, if there is one.
        //

        if ( listEntry != &Connection->VcReceiveBufferListHead ) {
            return afdBuffer;
        } else {
            return NULL;
        }

    case TDI_RECEIVE_EXPEDITED:

        if ( Connection->VcBufferredExpeditedCount == 0 ) {
            return NULL;
        }

        //
        // Walk the connection's list of data buffers until we find the
        // first data buffer that is of the appropriate type.
        //

        while ( listEntry != &Connection->VcReceiveBufferListHead &&
                    !afdBuffer->ExpeditedData ) {

            listEntry = afdBuffer->BufferListEntry.Flink;
            afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );
        }

        if ( listEntry != &Connection->VcReceiveBufferListHead ) {
            return afdBuffer;
        } else {
            return NULL;
        }

    default:

        ASSERT( !"Invalid ReceiveFlags" );
        return NULL;
    }

} // AfdGetReceiveBuffer


PIRP
AfdGetPendedReceiveIrp (
    IN PAFD_CONNECTION Connection,
    IN BOOLEAN Expedited
    )

/*++

Routine Description:

    Removes a receive IRP from the connection's list of receive IRPs.
    Only returns an IRP which is valid for the specified type of
    data, normal or expedited.  If there are no IRPs pended or only
    IRPs of the wrong type, returns NULL.

    This routine MUST be called with the connection's endpoint lock
    held!

Arguments:

    Connection - a pointer to the connection to search for an IRP.

    Expedited - TRUE if this routine should return a receive IRP which
        can receive expedited data.

Return Value:

    PIRP - a pointer to an IRP which can receive data of the specified
        type.  The IRP IS removed from the connection's list of pended
        receive IRPs.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG receiveFlags;
    PLIST_ENTRY listEntry;

    ASSERT( KeGetCurrentIrql( ) == DISPATCH_LEVEL );

    //
    // Walk the list of pended receive IRPs looking for one which can
    // be completed with the specified type of data.
    //

    for ( listEntry = Connection->VcReceiveIrpListHead.Flink;
          listEntry != &Connection->VcReceiveIrpListHead;
          listEntry = listEntry->Flink ) {

        //
        // Get a pointer to the IRP and our stack location in the IRP.
        //

        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        irpSp = IoGetCurrentIrpStackLocation( irp );

        //
        // Determine whether this IRP can receive the data type we need.
        //

        receiveFlags = irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags;
        receiveFlags &= TDI_RECEIVE_EITHER;
        ASSERT( receiveFlags != 0 );

        if ( receiveFlags == TDI_RECEIVE_NORMAL && !Expedited ) {

            //
            // We have a normal receive and normal data.  Remove this
            // IRP from the connection's list and return it.
            //

            RemoveEntryList( listEntry );
            return irp;
        }

        if ( receiveFlags == TDI_RECEIVE_EITHER ) {

            //
            // This is an "either" receive.  It can take the data
            // regardless of the data type.
            //

            RemoveEntryList( listEntry );
            return irp;
        }

        if ( receiveFlags == TDI_RECEIVE_EXPEDITED && Expedited ) {

            //
            // We have an expedited receive and expedited data.  Remove
            // this IRP from the connection's list and return it.
            //

            RemoveEntryList( listEntry );
            return irp;
        }

        //
        // This IRP did not meet our criteria.  Continue scanning the
        // connection's list of pended IRPs for a good IRP.
        //
    }

    //
    // There were no IRPs which could be completed with the specified
    // type of data.
    //

    return NULL;

} // AfdGetPendedReceiveIrp



BOOLEAN
AfdLRRepostReceive (
    PAFD_LR_LIST_ITEM Item
    )
/*++

Routine Description:

    Attempts to restart receive on a connection where AFD returned
    STATUS_DATA_NO_ACCEPTED to the transport due to low resource condition.

Arguments:

    Connection - connection of interest

Return Value:
    TRUE    - was able to restart receives (or connection is gone)
    FALSE   - still problem with resources

--*/
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT   endpoint;
    PAFD_CONNECTION connection;
    PAFD_BUFFER     afdBuffer;
    ULONG           receiveLength;

    connection = CONTAINING_RECORD (Item, AFD_CONNECTION, LRListItem);
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth );


    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);

    ASSERT (connection->OnLRList == TRUE);

    //
    // Check if connection was accepted and use accept endpoint instead
    // of the listening.  Note that accept cannot happen while we are
    // holding listening endpoint spinlock, nor can endpoint change after
    // the accept, so it is safe to release listening spinlock if
    // we discover that endpoint was accepted.
    //
    if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
            && (connection->Endpoint != endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        endpoint = connection->Endpoint;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
        ASSERT( !IS_TDI_BUFFERRING(endpoint) );
        ASSERT(  IS_VC_ENDPOINT (endpoint) );

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    //
    // Check if connection is still alive.
    //

    if (connection->Aborted || 
        connection->DisconnectIndicated ||
        ((endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) != 0) ||
        endpoint->EndpointCleanedUp ||
        (connection->VcReceiveBytesInTransport == 0) ||
        (connection->VcBufferredReceiveBytes >= connection->MaxBufferredReceiveBytes)) {

        connection->OnLRList = FALSE;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        DEREFERENCE_CONNECTION (connection);
        return TRUE;

    }


    ASSERT (connection->RcvInitiated==FALSE);
    receiveLength = connection->VcReceiveBytesInTransport;
    //
    // Attempt to allocate receive buffer for the amount that the
    // transport indicated to us last.
    //
    afdBuffer = AfdGetBuffer (endpoint, receiveLength, 0, connection->OwningProcess);
    if (afdBuffer!=NULL) {
        connection->VcReceiveBytesInTransport = 0;
    }
    else {
        //
        // Try smaller buffer if we can.
        //
        if (connection->VcReceiveBytesInTransport>AfdSmallBufferSize &&
                !IS_MESSAGE_ENDPOINT (endpoint)) {
            receiveLength = AfdSmallBufferSize;
            afdBuffer = AfdGetBuffer (endpoint, receiveLength, 0, connection->OwningProcess);
        }

        if (afdBuffer!=NULL) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                        "AFD: Initiating small LR recieve on connection %p, bytes: 0x%lx, 0x%x remains\n",
                        connection,
                        receiveLength,
                        connection->VcReceiveBytesInTransport));
        }
        else {

            //
            // Try use application IRPs
            //

            while (!IsListEmpty(&connection->VcReceiveIrpListHead)) {

                PIRP        irp;
                PIO_STACK_LOCATION irpSp;
                
                //
                // Get a pointer to the IRP and our stack location in it
                //

                irp = CONTAINING_RECORD( connection->VcReceiveIrpListHead.Flink,
                                         IRP,
                                         Tail.Overlay.ListEntry );

                irpSp = IoGetCurrentIrpStackLocation( irp );

                receiveLength = irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength-
                                    irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
                //
                // If the IRP is not large enough to hold the available data, or
                // if it is a peek or expedited (exclusively, not both normal and 
                // expedited) receive IRP,  then we'll just buffer the
                // data manually and complete the IRP in the receive completion
                // routine.
                //

                if ( (receiveLength>=connection->VcReceiveBytesInTransport ||
                        !IS_MESSAGE_ENDPOINT (endpoint) ||
                        (irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags
                            & TDI_RECEIVE_PARTIAL) != 0 ) &&
                     ((irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags
                            & TDI_RECEIVE_PEEK) == 0) &&
                     ((irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags
                            & TDI_RECEIVE_NORMAL) != 0)) {

                    connection->OnLRList = FALSE;
                    connection->RcvInitiated = TRUE;

                    RemoveEntryList(&irp->Tail.Overlay.ListEntry);
                    if (IoSetCancelRoutine(irp, NULL) == NULL) {

                        //
                        // This IRP is about to be canceled.  Look for another in the
                        // list.  Set the Flink to NULL so the cancel routine knows
                        // it is not on the list.
                        //

                        irp->Tail.Overlay.ListEntry.Flink = NULL;
                        continue;

                    }

                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                "AFD: Initiating user LR recieve on connection %p, bytes: 0x%lx, 0x%x remains\n",
                                connection,
                                receiveLength,
                                connection->VcReceiveBytesInTransport));

                    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                    ASSERT (InterlockedIncrement (&connection->VcReceiveIrpsInTransport)==1);

                    if (irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength>0) {
                        irp->MdlAddress = AfdAdvanceMdlChain (irp->MdlAddress,
                            irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength
                            -PtrToUlong(irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength)
                            );
                        ASSERT (irp->MdlAddress!=NULL);
                        irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength =
                                UlongToPtr(irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength);
                    }

                    TdiBuildReceive(
                        irp,
                        connection->DeviceObject,
                        connection->FileObject,
                        AfdRestartBufferReceiveWithUserIrp,
                        connection,
                        irp->MdlAddress,
                        irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags & TDI_RECEIVE_EITHER,
                        receiveLength
                        );

#ifdef _AFD_VARIABLE_STACK_
                    if ((irp=AfdCheckStackSizeAndRecordOutstandingIrp (
                                    endpoint,
                                    connection->DeviceObject,
                                    irp))!=NULL) {
#else //_AFD_VARIABLE_STACK_
                    if (AfdRecordOutstandingIrp (
                                    endpoint,
                                    connection->DeviceObject,
                                    irp)) {
#endif //_AFD_VARIABLE_STACK_

                        IoCallDriver (connection->DeviceObject, irp);
                        return TRUE;

                    } else {

                        //
                        // Could not allocate substitute IRP or tracking info.
                        // This connection is referenced by its position on the LRList,
                        // and the completion routine will be invoked as the IRP is
                        // completed by AfdRecordOutstandingIrpDebug().  Because we're
                        // not actually off the LRList yet, we need to add an extra
                        // reference to the connection to compensate.  The IRP is
                        // completed by AfdRecordOutstandingIrpDebug().
                        //

                        REFERENCE_CONNECTION(connection);

                        //
                        // We're going to loop around and try another user IRP.
                        //

                        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
                        connection->OnLRList = TRUE;
                        ASSERT (connection->RcvInitiated == FALSE); // reset in completion routine.

                    }

                } else {

                    //
                    // We can't use the first user IRP either, no more options to recover.
                    //

                    break;

                }

            } // while (!IsListEmpty(&connection->VcReceiveIrpListHead))

            //
            //  The caller will automatically put this connection back on LR list
            //

            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
            UPDATE_CONN (connection);
            return FALSE;

        }
        
    }


    //
    // Finish building the receive IRP to give to the TDI
    // provider.
    //

    TdiBuildReceive(
        afdBuffer->Irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartBufferReceive,
        afdBuffer,
        afdBuffer->Mdl,
        TDI_RECEIVE_NORMAL,
        receiveLength
        );

    //
    // Acquire connection reference to be released in completion routine
    // We already have one by virtue of being here

    // REFERENCE_CONNECTION (connection);
    UPDATE_CONN2 (connection, "Reposting LR receive for 0x%lX bytes",
                                receiveLength);

    ASSERT (InterlockedDecrement (&connection->VcReceiveIrpsInTransport)==-1);

    //
    // We need to remember the connection in the AFD buffer
    // because we'll need to access it in the completion
    // routine.
    //

    afdBuffer->Context = connection;
    connection->OnLRList = FALSE;
    connection->RcvInitiated = TRUE;

    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

    IoCallDriver (connection->DeviceObject, afdBuffer->Irp);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\poll.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    poll.c

Abstract:

    Contains AfdPoll to handle IOCTL_AFD_POLL and code to process
    and signal poll events.

Author:

    David Treadwell (davidtr)    4-Apr-1992

Revision History:
    Vadim Eydelman (vadime)
        1998-1999 NT5.0 Optimizations and 32/64 support

--*/

#include "afdp.h"

VOID
AfdCancelPoll (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
AfdFreePollInfo (
    IN PAFD_POLL_INFO_INTERNAL PollInfoInternal
    );

VOID
AfdTimeoutPoll (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

#ifdef _WIN64
NTSTATUS
AfdPoll32 (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );
#endif

VOID
AfdSanPollApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    );

VOID
AfdSanPollApcRundownRoutine (
    IN struct _KAPC *Apc
    );

VOID
AfdCompleteOldPollIrp (
    IN PIRP                    Irp,
    IN PAFD_POLL_INFO_INTERNAL PollInfo
    );

ULONG
AfdCheckPollEvents (
    IN PAFD_ENDPOINT Endpoint,
    IN ULONG PollEventMask,
    OUT NTSTATUS *Status
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdPoll )
#ifdef _WIN64
#pragma alloc_text( PAGEAFD, AfdPoll32 )
#endif
#pragma alloc_text( PAGEAFD, AfdCancelPoll )
#pragma alloc_text( PAGEAFD, AfdFreePollInfo )
#pragma alloc_text( PAGEAFD, AfdTimeoutPoll )
#pragma alloc_text( PAGEAFD, AfdCheckPollEvents )
#pragma alloc_text( PAGEAFD, AfdCompleteOldPollIrp )
#pragma alloc_text( PAGEAFD, AfdIndicatePollEventReal )
#pragma alloc_text( PAGE, AfdSanPollApcKernelRoutine )
#pragma alloc_text( PAGE, AfdSanPollApcRundownRoutine )
#endif


NTSTATUS
FASTCALL
AfdPoll (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PAFD_POLL_INFO pollInfo;
    PAFD_POLL_HANDLE_INFO pollHandleInfo;
    PAFD_POLL_INFO_INTERNAL pollInfoInternal;
    PAFD_POLL_INFO_INTERNAL freePollInfo = NULL;
    PAFD_POLL_ENDPOINT_INFO pollEndpointInfo;
    ULONG i;
    AFD_LOCK_QUEUE_HANDLE pollLockHandle, endpointLockHandle;
    PIRP oldIrp = NULL;

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        return AfdPoll32 (Irp, IrpSp);
    }
#endif
    //
    // Set up locals.
    //

    pollInfo = Irp->AssociatedIrp.SystemBuffer;
    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength<
                (ULONG)FIELD_OFFSET (AFD_POLL_INFO, Handles[0])) ||
            (pollInfo->NumberOfHandles < 1) ||
            ((IrpSp->Parameters.DeviceIoControl.InputBufferLength -
                        FIELD_OFFSET (AFD_POLL_INFO, Handles[0]))/
                sizeof(pollInfo->Handles[0]) < pollInfo->NumberOfHandles) ||
            (IrpSp->Parameters.DeviceIoControl.OutputBufferLength<
                IrpSp->Parameters.DeviceIoControl.InputBufferLength)) {

        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    //
    // A Unique poll must specify infinite timeout
    //
    if (pollInfo->Unique &&
        pollInfo->Timeout.HighPart != 0x7FFFFFFF) {
        
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }


    IF_DEBUG(POLL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdPoll: poll IRP %p, IrpSp %p, handles %ld, "
                    "TO %lx,%lx\n",
                      Irp, IrpSp,
                      pollInfo->NumberOfHandles,
                      pollInfo->Timeout.HighPart, pollInfo->Timeout.LowPart ));
    }

    Irp->IoStatus.Information = 0;

    //
    // Determine how large the internal poll information structure will
    // be and allocate space for it from nonpaged pool.  It must be
    // nonpaged since this will be accesses in event handlers.
    //

    try {
        pollInfoInternal = AFD_ALLOCATE_POOL_WITH_QUOTA (
                           NonPagedPool,
                           FIELD_OFFSET (AFD_POLL_INFO_INTERNAL,
                                    EndpointInfo[pollInfo->NumberOfHandles]),
                           AFD_POLL_POOL_TAG
                           );
        // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode ();
        pollInfoInternal = NULL;
        goto complete;
    }

    //
    // Initialize the internal information buffer.
    //

    pollInfoInternal->Irp = Irp;
    pollInfoInternal->NumberOfEndpoints = 0;
    pollInfoInternal->Unique = pollInfo->Unique;
    pollInfoInternal->SanPoll = FALSE;
    pollHandleInfo = pollInfo->Handles;
    pollEndpointInfo = pollInfoInternal->EndpointInfo;

    for ( i = 0; i < pollInfo->NumberOfHandles; i++ ) {

        status = ObReferenceObjectByHandle(
                    pollHandleInfo->Handle,
                    (IrpSp->Parameters.DeviceIoControl.IoControlCode>>14) & 3,
                                                // DesiredAccess
                    *IoFileObjectType,
                    Irp->RequestorMode,
                    (PVOID *)&pollEndpointInfo->FileObject,
                    NULL
                    );

        if ( !NT_SUCCESS(status) ) {
            AfdFreePollInfo( pollInfoInternal );
            goto complete;
        }

        //
        // Make sure that this is an AFD endpoint and not some other
        // random file handle.
        //

        if ( pollEndpointInfo->FileObject->DeviceObject != AfdDeviceObject ) {

            //
            // Dereference last referenced object
            // The rest will be dereferenced in AfdFreePollInfo
            // as determined by NumberOfEndpoints counter which
            // is incremented below.
            //
            ObDereferenceObject( pollEndpointInfo->FileObject );
            status = STATUS_INVALID_HANDLE;
            AfdFreePollInfo( pollInfoInternal );
            goto complete;
        }


        pollEndpointInfo->PollEvents = pollHandleInfo->PollEvents;
        pollEndpointInfo->Handle = pollHandleInfo->Handle;
        pollEndpointInfo->Endpoint = pollEndpointInfo->FileObject->FsContext;

        if (IS_SAN_ENDPOINT (pollEndpointInfo->Endpoint)) {
            ASSERT (pollEndpointInfo->Endpoint->State==AfdEndpointStateConnected);
            status = AfdSanPollBegin (pollEndpointInfo->Endpoint,
                                            pollEndpointInfo->PollEvents);
            if (!NT_SUCCESS (status)) {
                //
                // Dereference last referenced object
                // The rest will be dereferenced in AfdFreePollInfo
                // as determined by NumberOfEndpoints counter which
                // is incremented below.
                // Don't call AfdSanPollEnd() as we're not sure what
                // AfdSanPollBegin() managed to update before failing.
                // At worst, switch will start calling us with all events.
                //
                ObDereferenceObject( pollEndpointInfo->FileObject );
                AfdFreePollInfo (pollInfoInternal);
                goto complete;
            }
            
            pollEndpointInfo->PollEvents |= AFD_POLL_SANCOUNTS_UPDATED;
            pollInfoInternal->SanPoll = TRUE;
        }

        ASSERT( InterlockedIncrement( &pollEndpointInfo->Endpoint->ObReferenceBias ) > 0 );

        IF_DEBUG(POLL) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdPoll: event %lx, endp %p, conn %p, handle %p, "
                        "info %p\n",
                        pollEndpointInfo->PollEvents,
                        pollEndpointInfo->Endpoint,
                        AFD_CONNECTION_FROM_ENDPOINT( pollEndpointInfo->Endpoint ),
                        pollEndpointInfo->Handle,
                        pollEndpointInfo ));
        }

        REFERENCE_ENDPOINT2( pollEndpointInfo->Endpoint, "Poll for 0x%x", pollEndpointInfo->PollEvents );

        //
        // Increment pointers in the poll info structures.
        //

        pollHandleInfo++;
        pollEndpointInfo++;
        pollInfoInternal->NumberOfEndpoints++;
    }

restart_poll:

    //
    // Hold the AFD spin lock while we check for endpoints that already
    // satisfy a condition to synchronize between this operation and
    // a call to AfdIndicatePollEvent.  We release the spin lock
    // after all the endpoints have been checked and the internal
    // poll info structure is on the global list so AfdIndicatePollEvent
    // can find it if necessary.
    //

    AfdAcquireSpinLock( &AfdPollListLock, &pollLockHandle );

    //
    // We're done with the input structure provided by the caller.  Now
    // walk through the internal structure and determine whether any of
    // the specified endpoints are ready for the specified condition.
    //

    pollInfo->NumberOfHandles = 0;

    pollHandleInfo = pollInfo->Handles;
    pollEndpointInfo = pollInfoInternal->EndpointInfo;

    for ( i = 0; i < pollInfoInternal->NumberOfEndpoints; i++ ) {

        PAFD_ENDPOINT endpoint;

        endpoint = pollEndpointInfo->Endpoint;
        ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

        AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &endpointLockHandle);

        //
        // Remember that there has been a poll on this endpoint.  This flag
        // allows us to optimize AfdIndicatePollEvent() for endpoints that have
        // never been polled, which is a common case.
        //

        endpoint->PollCalled = TRUE;

        pollHandleInfo->PollEvents = AfdCheckPollEvents (
                                            endpoint,
                                            pollEndpointInfo->PollEvents,
                                            &pollHandleInfo->Status
                                            );
        if (pollHandleInfo->PollEvents) {
            //
            // If the handle had a current event that was requested, update
            // the count of handles in the output buffer and increment the
            // pointer to the output buffer.
            //
            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
            UPDATE_ENDPOINT2 (endpoint, "Poll events satisfied inline: 0x%lX",
                                        pollHandleInfo->PollEvents);
            pollHandleInfo->Handle = pollEndpointInfo->Handle;
            pollInfo->NumberOfHandles++;
            pollHandleInfo++;
        }
        else if (IS_SAN_ENDPOINT (endpoint) &&
                 (pollEndpointInfo->PollEvents & AFD_POLL_SANCOUNTS_UPDATED)==0 &&
                 pollInfo->NumberOfHandles==0) {
            //
            // OOPS, endpoint has been converted too SAN while we were looping,
            // need to release the spinlock, update switch counts, and restart
            // the loop.  We don't do this is we are about to return anyway.
            //
            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
            AfdReleaseSpinLock (&AfdPollListLock, &pollLockHandle);

            ASSERT (endpoint->State==AfdEndpointStateConnected);
            status = AfdSanPollBegin (endpoint,
                                            pollEndpointInfo->PollEvents);
            if (!NT_SUCCESS (status)) {
                AfdFreePollInfo (pollInfoInternal);
                goto complete;
            }
            
            pollEndpointInfo->PollEvents |= AFD_POLL_SANCOUNTS_UPDATED;
            pollInfoInternal->SanPoll = TRUE;
            goto restart_poll;
        }
        else {
            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
        }

        pollEndpointInfo++;
    }

    //
    // If this is a unique poll, determine whether there is another
    // unique poll on this endpoint.  If there is an existing unique
    // poll, cancel it.  This request will supercede the existing
    // request.
    //

    if ( pollInfo->Unique ) {

        PLIST_ENTRY listEntry;

        for ( listEntry = AfdPollListHead.Flink;
              listEntry != &AfdPollListHead;
              listEntry = listEntry->Flink ) {

            PAFD_POLL_INFO_INTERNAL testInfo;

            testInfo = CONTAINING_RECORD(
                           listEntry,
                           AFD_POLL_INFO_INTERNAL,
                           PollListEntry
                           );

            if ( testInfo->Unique &&
                 testInfo->EndpointInfo[0].FileObject ==
                     pollInfoInternal->EndpointInfo[0].FileObject ) {

                IF_DEBUG(POLL) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdPoll: found existing unique poll IRP %p "
                                "for file object %p, context %p, cancelling.\n",
                                testInfo->Irp,
                                testInfo->EndpointInfo[0].FileObject,
                                testInfo ));
                }

                //
                // Cancel the IRP manually rather than calling
                // AfdCancelPoll because we already hold the
                // AfdSpinLock, we can't acquire it recursively, and we
                // don't want to release it.  Remove the poll structure
                // from the global list.
                //

                RemoveEntryList( &testInfo->PollListEntry );

                //
                // No timer to cancel for Unique poll
                //

                ASSERT ( testInfo->TimerStarted == FALSE ); 

                //
                // Complete the IRP with STATUS_CANCELLED as the status.
                //

                testInfo->Irp->IoStatus.Information = 0;
                testInfo->Irp->IoStatus.Status = STATUS_CANCELLED;

                oldIrp = testInfo->Irp;

                //
                // Remember the poll info structure so that we'll free
                // before we exit.  We cannot free it now because we're
                // holding the AfdSpinLock.
                //

                freePollInfo = testInfo;

                //
                // There should be only one outstanding unique poll IRP
                // on any given file object, so quit looking for another
                // now that we've found one.
                //

                break;
            }
        }
    }
    //
    // If we found any endpoints that are ready, free the poll information
    // structure and complete the request.
    //

    if ( pollInfo->NumberOfHandles > 0 ) {

        AfdReleaseSpinLock( &AfdPollListLock, &pollLockHandle );
        AfdFreePollInfo( pollInfoInternal );

        Irp->IoStatus.Information = (PUCHAR)pollHandleInfo - (PUCHAR)pollInfo;
        status = STATUS_SUCCESS;
        goto complete;
    }

    if ( pollInfo->Timeout.QuadPart == 0 ) {
        //
        // A timeout equal to 0 was specified; free the internal
        // structure and complete the request with no endpoints in the
        // output buffer.
        //

        IF_DEBUG(POLL) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdPoll: zero timeout on poll IRP %p and no "
                        "current events--completing.\n", Irp ));
        }

        AfdReleaseSpinLock( &AfdPollListLock, &pollLockHandle );
        AfdFreePollInfo( pollInfoInternal );

        Irp->IoStatus.Information = (PUCHAR)pollHandleInfo - (PUCHAR)pollInfo;
        status = STATUS_SUCCESS;
        goto complete;
    }

    //
    // Set up a cancel routine in the IRP so that the IRP will be
    // completed correctly if it gets canceled.  Also check whether the
    // IRP has already been canceled.
    //

    IoSetCancelRoutine( Irp, AfdCancelPoll );

    if ( Irp->Cancel ) {

        //
        // The IRP has already been canceled.  Free the internal
        // poll information structure and complete the IRP.
        //

        AfdReleaseSpinLock( &AfdPollListLock, &pollLockHandle );

        if (IoSetCancelRoutine( Irp, NULL ) == NULL) {
            KIRQL cancelIrql;

            //
            // If the cancel routine was NULL then cancel routine
            // may be running.  Wait on the cancel spinlock until
            // the cancel routine is done.
            //
            // Note: The cancel routine will not find the IRP
            // since it is not in the list.
            //
        
            IoAcquireCancelSpinLock( &cancelIrql );
            IoReleaseCancelSpinLock( cancelIrql );

        }

        AfdFreePollInfo( pollInfoInternal );

        status = STATUS_CANCELLED;
        goto complete;

    }

    IF_DEBUG(POLL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdPoll: no current events for poll IRP %p, "
                    "info %p\n", Irp, pollInfoInternal ));
    }

    //
    // Set up the information field of the IO status block to indicate
    // that an output buffer with no handles should be returned.
    // AfdIndicatePollEvent will modify this if necessary.
    //

    Irp->IoStatus.Information = (PUCHAR)pollHandleInfo - (PUCHAR)pollInfo;

    //
    // Put a pointer to the internal poll info struct into the IRP
    // so that the cancel routine can find it.
    //

    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pollInfoInternal;

    //
    // Place the internal poll info struct on the global list.
    //

    InsertTailList( &AfdPollListHead, &pollInfoInternal->PollListEntry );

    //
    // If the timeout is infinite, then don't set up a timer and
    // DPC.  Otherwise, set up a timer so we can timeout the poll
    // request if appropriate.
    //

    if ( pollInfo->Timeout.HighPart != 0x7FFFFFFF ) {

        pollInfoInternal->TimerStarted = TRUE;

        KeInitializeDpc(
            &pollInfoInternal->Dpc,
            AfdTimeoutPoll,
            pollInfoInternal
            );

        KeInitializeTimer( &pollInfoInternal->Timer );

        KeSetTimer(
            &pollInfoInternal->Timer,
            pollInfo->Timeout,
            &pollInfoInternal->Dpc
            );

    } else {

        pollInfoInternal->TimerStarted = FALSE;
    }

    //
    // Mark the IRP pending and release the spin locks.  At this
    // point the IRP may get completed or cancelled.
    //

    IoMarkIrpPending( Irp );

    AfdReleaseSpinLock( &AfdPollListLock, &pollLockHandle );

    //
    //  Complete any old poll irps.
    //

    if ( oldIrp != NULL ) {
        AfdCompleteOldPollIrp (oldIrp, freePollInfo);
    }

    //
    // Return pending.  The IRP will be completed when an appropriate
    // event is indicated by the TDI provider, when the timeout is hit,
    // or when the IRP is cancelled.
    //

    return STATUS_PENDING;

complete:

    //
    //  Complete any old poll irps.
    //

    if ( oldIrp != NULL ) {

        AfdCompleteOldPollIrp (oldIrp, freePollInfo);
    }

    Irp->IoStatus.Status = status;

    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdPoll

#ifdef _WIN64

NTSTATUS
AfdPoll32 (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PAFD_POLL_INFO32 pollInfo;
    PAFD_POLL_HANDLE_INFO32 pollHandleInfo;
    PAFD_POLL_INFO_INTERNAL pollInfoInternal;
    PAFD_POLL_INFO_INTERNAL freePollInfo = NULL;
    PAFD_POLL_ENDPOINT_INFO pollEndpointInfo;
    ULONG i;
    AFD_LOCK_QUEUE_HANDLE pollLockHandle, endpointLockHandle;
    PIRP oldIrp = NULL;

    //
    // Set up locals.
    //

    pollInfo = Irp->AssociatedIrp.SystemBuffer;
    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength<
                (ULONG)FIELD_OFFSET (AFD_POLL_INFO32, Handles[0])) ||
            ((IrpSp->Parameters.DeviceIoControl.InputBufferLength -
                        FIELD_OFFSET (AFD_POLL_INFO32, Handles[0]))/
                sizeof(pollInfo->Handles[0]) < pollInfo->NumberOfHandles) ||
            (IrpSp->Parameters.DeviceIoControl.OutputBufferLength<
                IrpSp->Parameters.DeviceIoControl.InputBufferLength)) {

        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    //
    // A Unique poll must specify infinite timeout
    //

    if (pollInfo->Unique &&
        pollInfo->Timeout.HighPart != 0x7FFFFFFF) {
        
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }


    IF_DEBUG(POLL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdPoll32: poll IRP %p, IrpSp %p, handles %ld, "
                    "TO %lx,%lx\n",
                    Irp, IrpSp,
                    pollInfo->NumberOfHandles,
                    pollInfo->Timeout.HighPart, pollInfo->Timeout.LowPart ));
    }

    Irp->IoStatus.Information = 0;

    //
    // Determine how large the internal poll information structure will
    // be and allocate space for it from nonpaged pool.  It must be
    // nonpaged since this will be accesses in event handlers.
    //

    try {
        pollInfoInternal = AFD_ALLOCATE_POOL_WITH_QUOTA(
                           NonPagedPool,
                           FIELD_OFFSET (AFD_POLL_INFO_INTERNAL,
                                EndpointInfo[pollInfo->NumberOfHandles]),
                           AFD_POLL_POOL_TAG
                           );
        // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode ();
        pollInfoInternal = NULL;
        goto complete;
    }

    //
    // Initialize the internal information buffer.
    //

    pollInfoInternal->Irp = Irp;
    pollInfoInternal->NumberOfEndpoints = 0;
    pollInfoInternal->Unique = pollInfo->Unique;
    pollInfoInternal->SanPoll = FALSE;

    pollHandleInfo = pollInfo->Handles;
    pollEndpointInfo = pollInfoInternal->EndpointInfo;

    for ( i = 0; i < pollInfo->NumberOfHandles; i++ ) {

        status = ObReferenceObjectByHandle(
                    pollHandleInfo->Handle,
                    (IrpSp->Parameters.DeviceIoControl.IoControlCode>>14) & 3,
                                                // DesiredAccess
                    *IoFileObjectType,
                    Irp->RequestorMode,
                    (PVOID *)&pollEndpointInfo->FileObject,
                    NULL
                    );

        if ( !NT_SUCCESS(status) ) {
            AfdFreePollInfo( pollInfoInternal );
            goto complete;
        }

        //
        // Make sure that this is an AFD endpoint and not some other
        // random file handle.
        //

        if ( pollEndpointInfo->FileObject->DeviceObject != AfdDeviceObject ) {

            //
            // Dereference last referenced object
            // The rest will be dereferenced in AfdFreePollInfo
            // as determined by NumberOfEndpoints counter which
            // is incremented below.
            //
            ObDereferenceObject( pollEndpointInfo->FileObject );
            status = STATUS_INVALID_HANDLE;
            AfdFreePollInfo( pollInfoInternal );
            goto complete;
        }

        pollEndpointInfo->PollEvents = pollHandleInfo->PollEvents;
        pollEndpointInfo->Handle = pollHandleInfo->Handle;
        pollEndpointInfo->Endpoint = pollEndpointInfo->FileObject->FsContext;

        ASSERT( InterlockedIncrement( &pollEndpointInfo->Endpoint->ObReferenceBias ) > 0 );

        IF_DEBUG(POLL) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdPoll32: event %lx, endp %p, conn %p, handle %p, "
                        "info %p\n",
                        pollEndpointInfo->PollEvents,
                        pollEndpointInfo->Endpoint,
                        AFD_CONNECTION_FROM_ENDPOINT( pollEndpointInfo->Endpoint ),
                        pollEndpointInfo->Handle,
                        pollEndpointInfo ));
        }

        REFERENCE_ENDPOINT2( pollEndpointInfo->Endpoint, "Poll for 0x%x", pollEndpointInfo->PollEvents );

        //
        // Increment pointers in the poll info structures.
        //

        pollHandleInfo++;
        pollEndpointInfo++;
        pollInfoInternal->NumberOfEndpoints++;
    }

restart_poll:
    //
    // Hold the AFD spin lock while we check for endpoints that already
    // satisfy a condition to synchronize between this operation and
    // a call to AfdIndicatePollEvent.  We release the spin lock
    // after all the endpoints have been checked and the internal
    // poll info structure is on the global list so AfdIndicatePollEvent
    // can find it if necessary.
    //

    AfdAcquireSpinLock( &AfdPollListLock, &pollLockHandle );


    //
    // We're done with the input structure provided by the caller.  Now
    // walk through the internal structure and determine whether any of
    // the specified endpoints are ready for the specified condition.
    //

    pollInfo->NumberOfHandles = 0;

    pollHandleInfo = pollInfo->Handles;
    pollEndpointInfo = pollInfoInternal->EndpointInfo;

    for ( i = 0; i < pollInfoInternal->NumberOfEndpoints; i++ ) {

        PAFD_ENDPOINT endpoint;

        endpoint = pollEndpointInfo->Endpoint;
        ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

        AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &endpointLockHandle);

        //
        // Remember that there has been a poll on this endpoint.  This flag
        // allows us to optimize AfdIndicatePollEvent() for endpoints that have
        // never been polled, which is a common case.
        //

        endpoint->PollCalled = TRUE;

        pollHandleInfo->PollEvents = AfdCheckPollEvents (
                                            endpoint,
                                            pollEndpointInfo->PollEvents,
                                            &status
                                            );
        if (pollHandleInfo->PollEvents) {
            //
            // If the handle had a current event that was requested, update
            // the count of handles in the output buffer and increment the
            // pointer to the output buffer.
            //
            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
            UPDATE_ENDPOINT2 (endpoint, "Poll events satisfied inline:0x%lX",
                                        pollHandleInfo->PollEvents);
            pollHandleInfo->Handle = (VOID *  POINTER_32)pollEndpointInfo->Handle;
            pollHandleInfo->Status = status;
            pollInfo->NumberOfHandles++;
            pollHandleInfo++;
        }
        else if (IS_SAN_ENDPOINT (endpoint) &&
                 (pollEndpointInfo->PollEvents & AFD_POLL_SANCOUNTS_UPDATED)==0 &&
                 pollInfo->NumberOfHandles==0) {
            //
            // OOPS, endpoint has been converted too SAN while we were looping,
            // need to release the spinlock, update switch counts, and restart
            // the loop.  We don't do this is we are about to return anyway.
            //
            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
            AfdReleaseSpinLock (&AfdPollListLock, &pollLockHandle);

            ASSERT (endpoint->State==AfdEndpointStateConnected);
            status = AfdSanPollBegin (endpoint,
                                            pollEndpointInfo->PollEvents);
            if (!NT_SUCCESS (status)) {
                AfdFreePollInfo (pollInfoInternal);
                goto complete;
            }
            
            pollEndpointInfo->PollEvents |= AFD_POLL_SANCOUNTS_UPDATED;
            pollInfoInternal->SanPoll = TRUE;

            goto restart_poll;
        }
        else {
            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
        }

        pollEndpointInfo++;
    }

    //
    // If this is a unique poll, determine whether there is another
    // unique poll on this endpoint.  If there is an existing unique
    // poll, cancel it.  This request will supercede the existing
    // request.
    //

    if ( pollInfo->Unique ) {

        PLIST_ENTRY listEntry;

        for ( listEntry = AfdPollListHead.Flink;
              listEntry != &AfdPollListHead;
              listEntry = listEntry->Flink ) {

            PAFD_POLL_INFO_INTERNAL testInfo;

            testInfo = CONTAINING_RECORD(
                           listEntry,
                           AFD_POLL_INFO_INTERNAL,
                           PollListEntry
                           );

            if ( testInfo->Unique &&
                 testInfo->EndpointInfo[0].FileObject ==
                     pollInfoInternal->EndpointInfo[0].FileObject ) {

                IF_DEBUG(POLL) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdPoll32: found existing unique poll IRP %p "
                                "for file object %p, context %p, cancelling.\n",
                                testInfo->Irp,
                                testInfo->EndpointInfo[0].FileObject,
                                testInfo ));
                }

                //
                // Cancel the IRP manually rather than calling
                // AfdCancelPoll because we already hold the
                // AfdSpinLock, we can't acquire it recursively, and we
                // don't want to release it.  Remove the poll structure
                // from the global list.
                //

                RemoveEntryList( &testInfo->PollListEntry );

                //
                // No timer to cancel for Unique poll
                //

                ASSERT ( testInfo->TimerStarted == FALSE ); 

                //
                // Complete the IRP with STATUS_CANCELLED as the status.
                //

                testInfo->Irp->IoStatus.Information = 0;
                testInfo->Irp->IoStatus.Status = STATUS_CANCELLED;

                oldIrp = testInfo->Irp;

                //
                // Remember the poll info structure so that we'll free
                // before we exit.  We cannot free it now because we're
                // holding the AfdSpinLock.  
                //

                freePollInfo = testInfo;

                //
                // There should be only one outstanding unique poll IRP
                // on any given file object, so quit looking for another
                // now that we've found one.
                //

                break;
            }
        }
    }

    //
    // If we found any endpoints that are ready, free the poll information
    // structure and complete the request.
    //

    if ( pollInfo->NumberOfHandles > 0 ) {

        AfdReleaseSpinLock( &AfdPollListLock, &pollLockHandle );
        AfdFreePollInfo( pollInfoInternal );

        Irp->IoStatus.Information = (PUCHAR)pollHandleInfo - (PUCHAR)pollInfo;
        status = STATUS_SUCCESS;
        goto complete;
    }

    if ( pollInfo->Timeout.QuadPart == 0 ) {
        //
        // A timeout equal to 0 was specified; free the internal
        // structure and complete the request with no endpoints in the
        // output buffer.
        //

        IF_DEBUG(POLL) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdPoll32: zero timeout on poll IRP %p and no "
                        "current events--completing.\n", Irp ));
        }

        AfdReleaseSpinLock( &AfdPollListLock, &pollLockHandle );
        AfdFreePollInfo( pollInfoInternal );

        Irp->IoStatus.Information = (PUCHAR)pollHandleInfo - (PUCHAR)pollInfo;
        status = STATUS_SUCCESS;
        goto complete;
    }

    //
    // Set up a cancel routine in the IRP so that the IRP will be
    // completed correctly if it gets canceled.  Also check whether the
    // IRP has already been canceled.
    //

    IoSetCancelRoutine( Irp, AfdCancelPoll );

    if ( Irp->Cancel ) {

        //
        // The IRP has already been canceled.  Free the internal
        // poll information structure and complete the IRP.
        //

        AfdReleaseSpinLock( &AfdPollListLock, &pollLockHandle );

        if (IoSetCancelRoutine( Irp, NULL ) == NULL) {
            KIRQL cancelIrql;

            //
            // If the cancel routine was NULL then cancel routine
            // may be running.  Wait on the cancel spinlock until
            // the cancel routine is done.
            //
            // Note: The cancel routine will not find the IRP
            // since it is not in the list.
            //
            
            IoAcquireCancelSpinLock( &cancelIrql );
            IoReleaseCancelSpinLock( cancelIrql );

        }

        AfdFreePollInfo( pollInfoInternal );

        status = STATUS_CANCELLED;
        goto complete;

    }
    IF_DEBUG(POLL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdPoll32: no current events for poll IRP %p, "
                    "info %p\n", Irp, pollInfoInternal ));
    }

    //
    // Set up the information field of the IO status block to indicate
    // that an output buffer with no handles should be returned.
    // AfdIndicatePollEvent will modify this if necessary.
    //

    Irp->IoStatus.Information = (PUCHAR)pollHandleInfo - (PUCHAR)pollInfo;

    //
    // Put a pointer to the internal poll info struct into the IRP
    // so that the cancel routine can find it.
    //

    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pollInfoInternal;

    //
    // Place the internal poll info struct on the global list.
    //

    InsertTailList( &AfdPollListHead, &pollInfoInternal->PollListEntry );

    //
    // If the timeout is infinite, then don't set up a timer and
    // DPC.  Otherwise, set up a timer so we can timeout the poll
    // request if appropriate.
    //

    if ( pollInfo->Timeout.HighPart != 0x7FFFFFFF ) {

        pollInfoInternal->TimerStarted = TRUE;

        KeInitializeDpc(
            &pollInfoInternal->Dpc,
            AfdTimeoutPoll,
            pollInfoInternal
            );

        KeInitializeTimer( &pollInfoInternal->Timer );

        KeSetTimer(
            &pollInfoInternal->Timer,
            pollInfo->Timeout,
            &pollInfoInternal->Dpc
            );

    } else {

        pollInfoInternal->TimerStarted = FALSE;
    }

    //
    // Mark the IRP pending and release the spin locks.  At this
    // point the IRP may get completed or cancelled.
    //

    IoMarkIrpPending( Irp );

    AfdReleaseSpinLock( &AfdPollListLock, &pollLockHandle );

    //
    //  Complete any old poll irps.
    //

    if ( oldIrp != NULL ) {

        AfdCompleteOldPollIrp (oldIrp, freePollInfo);
    }

    //
    // Return pending.  The IRP will be completed when an appropriate
    // event is indicated by the TDI provider, when the timeout is hit,
    // or when the IRP is cancelled.
    //

    return STATUS_PENDING;

complete:

    //
    //  Complete any old poll irps.
    //

    if ( oldIrp != NULL ) {

        AfdCompleteOldPollIrp (oldIrp, freePollInfo);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdPoll32
#endif //_WIN64


VOID
AfdCancelPoll (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PAFD_POLL_INFO_INTERNAL pollInfoInternal;
    PLIST_ENTRY listEntry;
    BOOLEAN found = FALSE;
    BOOLEAN timerCancelSucceeded;
    PIO_STACK_LOCATION irpSp;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    UNREFERENCED_PARAMETER (DeviceObject);
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    pollInfoInternal =
        (PAFD_POLL_INFO_INTERNAL)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    IF_DEBUG(POLL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdCancelPoll called for IRP %p\n", Irp ));
    }

    //
    // Get the AFD spin lock and attempt to find the poll structure on
    // the list of outstanding polls.
    // Note the afdspinlock must be acquired befor the cancel spinlock
    // is released so that the pollInfoInternal does not get reused
    // before we have had a chance to look at the queue.
    //

    AfdAcquireSpinLockAtDpcLevel( &AfdPollListLock, &lockHandle);

    for ( listEntry = AfdPollListHead.Flink;
          listEntry != &AfdPollListHead;
          listEntry = listEntry->Flink ) {

        PAFD_POLL_INFO_INTERNAL testInfo;

        testInfo = CONTAINING_RECORD(
                       listEntry,
                       AFD_POLL_INFO_INTERNAL,
                       PollListEntry
                       );

        if ( testInfo == pollInfoInternal ) {
            found = TRUE;
            break;
        }
    }

    //
    // If we didn't find the poll structure on the list, then the
    // indication handler got called prior to the spinlock acquisition
    // above and it is already off the list.  Just return and do
    // nothing, as the indication handler completed the IRP.
    //

    if ( !found ) {
        AfdReleaseSpinLockFromDpcLevel( &AfdPollListLock, &lockHandle);
        IoReleaseCancelSpinLock( Irp->CancelIrql );
    
        IF_DEBUG(POLL) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdCancelPoll: poll info %p not found on list.\n",
                        pollInfoInternal ));
        }
        return;
    }

    //
    // Remove the poll structure from the global list.
    //

    IF_DEBUG(POLL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdCancelPoll: poll info %p found on list, completing.\n",
                    pollInfoInternal ));
    }

    RemoveEntryList( &pollInfoInternal->PollListEntry );

    //
    // Cancel the timer and reset the IRP pointer in the internal
    // poll information structure.  NULLing the IRP field
    // prevents the timer routine from completing the IRP.
    //

    if ( pollInfoInternal->TimerStarted ) {
        timerCancelSucceeded = KeCancelTimer( &pollInfoInternal->Timer );
    } else {
        timerCancelSucceeded = TRUE;
    }

    //
    // Complete the IRP with STATUS_CANCELLED as the status.
    //

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_CANCELLED;

    AfdReleaseSpinLockFromDpcLevel( &AfdPollListLock, &lockHandle);
    IoReleaseCancelSpinLock( Irp->CancelIrql );
    
    if (timerCancelSucceeded) {
        if (pollInfoInternal->SanPoll && 
                (Irp->CancelIrql>APC_LEVEL ||
                    (Irp->Tail.Overlay.Thread!=PsGetCurrentThread ()))) {
            KeInitializeApc (&pollInfoInternal->Apc,
                                PsGetThreadTcb (Irp->Tail.Overlay.Thread),
                                Irp->ApcEnvironment,
                                AfdSanPollApcKernelRoutine,
                                AfdSanPollApcRundownRoutine,
                                (PKNORMAL_ROUTINE)-1,
                                KernelMode,
                                NULL);
            if (KeInsertQueueApc (&pollInfoInternal->Apc,
                                    pollInfoInternal,
                                    Irp,
                                    AfdPriorityBoost)) {
                return ;
            }
            else {
                pollInfoInternal->SanPoll = FALSE;
            }
        }

        //
        // Free the poll information structure if the cancel succeeded.  If
        // the cancel of the timer did not succeed, then the timer is
        // already running and the timer DPC will free the internal
        // poll info.
        //

        AfdFreePollInfo( pollInfoInternal );
        IoCompleteRequest( Irp, AfdPriorityBoost );
    }

    return;

} // AfdCancelPoll


VOID
AfdFreePollInfo (
    IN PAFD_POLL_INFO_INTERNAL PollInfoInternal
    )
{
    ULONG i;
    PAFD_POLL_ENDPOINT_INFO pollEndpointInfo;

    IF_DEBUG(POLL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFreePollInfo: freeing info struct at %p\n",
                    PollInfoInternal ));
    }

    // *** Note that this routine does not remove the poll information
    //     structure from the global list--that is the responsibility
    //     of the caller!

    //
    // Walk the list of endpoints in the poll information structure and
    // dereference each one.
    //

    pollEndpointInfo = PollInfoInternal->EndpointInfo;

    for ( i = 0; i < PollInfoInternal->NumberOfEndpoints; i++ ) {
        ASSERT( InterlockedDecrement( &pollEndpointInfo->Endpoint->ObReferenceBias ) >= 0 );

        if (PollInfoInternal->SanPoll) {
            ASSERT (PollInfoInternal->Irp!=NULL);
            ASSERT (PsGetCurrentThread ()==PollInfoInternal->Irp->Tail.Overlay.Thread);
            if (pollEndpointInfo->PollEvents & AFD_POLL_SANCOUNTS_UPDATED) {
                ASSERT (IS_SAN_ENDPOINT (pollEndpointInfo->Endpoint));
                AfdSanPollEnd (pollEndpointInfo->Endpoint,
                                    pollEndpointInfo->PollEvents);
            }
        }

        DEREFERENCE_ENDPOINT( pollEndpointInfo->Endpoint );
        ObDereferenceObject( pollEndpointInfo->FileObject );
        pollEndpointInfo++;
    }

    //
    // Free the structure itself and return.
    //

    AFD_FREE_POOL(
        PollInfoInternal,
        AFD_POLL_POOL_TAG
        );

    return;

} // AfdFreePollInfo


VOID
AfdCompleteOldPollIrp (
    IN PIRP                    Irp,
    IN PAFD_POLL_INFO_INTERNAL PollInfo
    )
{
    if (IoSetCancelRoutine( Irp, NULL ) == NULL) {
        KIRQL cancelIrql;

        //
        // If the cancel routine was NULL then cancel routine
        // may be running.  Wait on the cancel spinlock until
        // the cancel routine is done.
        //
        // Note: The cancel routine will not find the IRP
        // since it is not in the list.
        //
        
        IoAcquireCancelSpinLock( &cancelIrql );
        ASSERT( Irp->Cancel );
        IoReleaseCancelSpinLock( cancelIrql );

    }

    if (PollInfo!=NULL) {
        if (PollInfo->SanPoll && 
                (Irp->Tail.Overlay.Thread!=PsGetCurrentThread ())) {
            KeInitializeApc (&PollInfo->Apc,
                            PsGetThreadTcb (Irp->Tail.Overlay.Thread),
                            Irp->ApcEnvironment,
                            AfdSanPollApcKernelRoutine,
                            AfdSanPollApcRundownRoutine,
                            (PKNORMAL_ROUTINE)-1,
                            KernelMode,
                            NULL);
            if (KeInsertQueueApc (&PollInfo->Apc,
                                PollInfo,
                                Irp,
                                AfdPriorityBoost)) {
                //
                // IRP will be completed in APC
                //
                return ;
            }
            else {
                PollInfo->SanPoll = FALSE;
            }
        }

        AfdFreePollInfo( PollInfo );
    }
    IoCompleteRequest( Irp, AfdPriorityBoost );
}


VOID
AfdIndicatePollEventReal (
    IN PAFD_ENDPOINT Endpoint,
    IN ULONG PollEventMask,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    Called to complete polls with a specific event or events.

Arguments:

    Endpoint - the endpoint on which the action occurred.

    PollEventMask - the mask of the events which occurred.

    Status - the status of the event, if any.

Return Value:

    None.

--*/

{
    LIST_ENTRY completePollListHead;
    PLIST_ENTRY listEntry;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_POLL_INFO_INTERNAL pollInfoInternal;
    union {
        PAFD_POLL_INFO PollInfo;
        PAFD_POLL_INFO32 PollInfo32;
    } u;
#define pollInfo    u.PollInfo
#define pollInfo32  u.PollInfo32
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    ASSERT (PollEventMask!=0);
    ASSERT (((~((1<<AFD_NUM_POLL_EVENTS)-1)) & PollEventMask)==0);

    //
    // Note that AFD_POLL_ABORT implies AFD_POLL_SEND.
    //
    if( PollEventMask & AFD_POLL_ABORT ) {
        PollEventMask |= AFD_POLL_SEND;
    }

    //
    // Initialize the list of poll info structures that we'll be
    // completing for this event.
    //

    InitializeListHead( &completePollListHead );

    //
    // Walk the global list of polls, searching for any the are waiting
    // for the specified event on the specified endpoint.
    //

    AfdAcquireSpinLock( &AfdPollListLock, &lockHandle );

    for ( listEntry = AfdPollListHead.Flink;
          listEntry != &AfdPollListHead;
          listEntry = listEntry->Flink ) {

        PAFD_POLL_ENDPOINT_INFO pollEndpointInfo;
        ULONG i;
        ULONG foundCount = 0;

        pollInfoInternal = CONTAINING_RECORD(
                               listEntry,
                               AFD_POLL_INFO_INTERNAL,
                               PollListEntry
                               );

        pollInfo = pollInfoInternal->Irp->AssociatedIrp.SystemBuffer;

        irp = pollInfoInternal->Irp;
        irpSp = IoGetCurrentIrpStackLocation( irp );

        IF_DEBUG(POLL) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdIndicatePollEvent: pollInfoInt %p "
                        "IRP %p pollInfo %p event mask %lx status %lx\n",
                        pollInfoInternal, irp, pollInfo,
                        PollEventMask, Status ));
        }

        //
        // Walk the poll structure looking for matching endpoints.
        //

        pollEndpointInfo = pollInfoInternal->EndpointInfo;

        for ( i = 0; i < pollInfoInternal->NumberOfEndpoints; i++ ) {

            IF_DEBUG(POLL) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdIndicatePollEvent: pollEndpointInfo = %p, "
                            "comparing %p, %p\n",
                            pollEndpointInfo, pollEndpointInfo->Endpoint,
                            Endpoint ));
            }

            //
            // Update the counts for the polls that were issued before
            // the endpoint was converted to SAN.
            //
            if (Endpoint==pollEndpointInfo->Endpoint &&
                    IS_SAN_ENDPOINT (Endpoint) && 
                    !(pollEndpointInfo->PollEvents & AFD_POLL_SANCOUNTS_UPDATED) &&
                    Endpoint->Common.SanEndp.LocalContext!=NULL) {
                AfdSanPollUpdate (Endpoint, pollEndpointInfo->PollEvents);
                pollEndpointInfo->PollEvents |= AFD_POLL_SANCOUNTS_UPDATED;
            }

            //
            // Regardless of whether the caller requested to be told about
            // local closes, we'll complete the IRP if an endpoint
            // is being closed.  When they close an endpoint, all IO on
            // the endpoint must be completed.
            //

            if ( Endpoint == pollEndpointInfo->Endpoint &&
                     ( (PollEventMask & pollEndpointInfo->PollEvents) != 0
                       ||
                       (PollEventMask & AFD_POLL_LOCAL_CLOSE) ) ) {

                //
                // Revalidate under the lock that event is still present
                // (except for AFD_POLL_ADDRESS_LIST_CHANGE which never gets
                // OR'd into Endpoint->EventsActive)
                // It is possible that once we released endpoint lock to
                // acquire poll list lock, application made a call that
                // reset the event (e.g. consumed the data and receive event
                // is no longer valid).  If after invalidating the event
                // application also managed to submit another select, we
                // can produce a false signal.
                //
                AFD_LOCK_QUEUE_HANDLE endpointLockHandle;
                ULONG   events;
             
                AfdAcquireSpinLockAtDpcLevel (&Endpoint->SpinLock, &endpointLockHandle);
                events = AfdCheckPollEvents (
                                Endpoint,
                                pollEndpointInfo->PollEvents,
                                &Status) | (PollEventMask & AFD_POLL_LOCAL_CLOSE)
                                         | (PollEventMask & AFD_POLL_ADDRESS_LIST_CHANGE);
                AfdReleaseSpinLockFromDpcLevel (&Endpoint->SpinLock, &endpointLockHandle);
                if (events) {
                    UPDATE_ENDPOINT2 (Endpoint, "Poll events satisfied in indication: 0x%lX", events);

#ifdef _WIN64
                    if (IoIs32bitProcess (irp)) {
                        ASSERT( pollInfo32->NumberOfHandles == foundCount );

                        IF_DEBUG(POLL) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                        "AfdIndicatePollEvent32: endpoint %p found "
                                        " for event %lx\n",
                                        pollEndpointInfo->Endpoint, PollEventMask ));
                        }

                        pollInfo32->NumberOfHandles++;

                        pollInfo32->Handles[foundCount].Handle = (VOID *  POINTER_32)pollEndpointInfo->Handle;
                        pollInfo32->Handles[foundCount].PollEvents = events;
                        pollInfo32->Handles[foundCount].Status = Status;

                    }
                    else
#endif // _WIN64
                    {
                        ASSERT( pollInfo->NumberOfHandles == foundCount );

                        IF_DEBUG(POLL) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                        "AfdIndicatePollEvent: endpoint %p found "
                                        " for event %lx\n",
                                          pollEndpointInfo->Endpoint, PollEventMask ));
                        }

                        pollInfo->NumberOfHandles++;

                        pollInfo->Handles[foundCount].Handle = pollEndpointInfo->Handle;
                        pollInfo->Handles[foundCount].PollEvents = events;
                        pollInfo->Handles[foundCount].Status = Status;

                    }
                    foundCount++;
                }
            }

            pollEndpointInfo++;
        }

        //
        // If we found any matching endpoints, remove the poll information
        // structure from the global list, complete the IRP, and free the
        // poll information structure.
        //

        if ( foundCount != 0 ) {

            BOOLEAN timerCancelSucceeded;

            //
            // We need to release the spin lock to call AfdFreePollInfo,
            // since it calls AfdDereferenceEndpoint which in turn needs
            // to acquire the spin lock, and recursive spin lock
            // acquisitions result in deadlock.  However, we can't
            // release the lock of else the state of the poll list could
            // change, e.g.  the next entry could get freed.  Remove
            // this entry from the global list and place it on a local
            // list.  We'll complete all the poll IRPs after walking
            // the entire list.
            //

            RemoveEntryList( &pollInfoInternal->PollListEntry );

            //
            // Set up the IRP for completion now, since we have all needed
            // information here.
            //

#ifdef _WIN64
            if (IoIs32bitProcess (irp)) {
                irp->IoStatus.Information =
                    (PUCHAR)&pollInfo32->Handles[foundCount] - (PUCHAR)pollInfo32;
            }
            else
#endif 
            {
                irp->IoStatus.Information =
                    (PUCHAR)&pollInfo->Handles[foundCount] - (PUCHAR)pollInfo;
            }

            irp->IoStatus.Status = STATUS_SUCCESS;
            //
            // Cancel the timer on the poll so that it does not fire.
            //

            if ( pollInfoInternal->TimerStarted ) {
                timerCancelSucceeded = KeCancelTimer( &pollInfoInternal->Timer );
            } else {
                timerCancelSucceeded = TRUE;
            }

            //
            // If the cancel of the timer failed, then we don't want to
            // free this structure since the timer routine is running.
            // Let the timer routine free the structure.
            //

            if ( timerCancelSucceeded ) {
                InsertTailList(
                    &completePollListHead,
                    &irp->Tail.Overlay.ListEntry
                    );

            }

        }
    }

    AfdReleaseSpinLock( &AfdPollListLock, &lockHandle );

    //
    // Now walk the list of polls we need to actually complete.  Free
    // the poll info structures as we go.
    //

    while ( !IsListEmpty( &completePollListHead ) ) {

        listEntry = RemoveHeadList( &completePollListHead );
        ASSERT( listEntry != &completePollListHead );

        irp = CONTAINING_RECORD(
                  listEntry,
                  IRP,
                  Tail.Overlay.ListEntry
                  );
        irpSp = IoGetCurrentIrpStackLocation( irp );

        pollInfoInternal =
            irpSp->Parameters.DeviceIoControl.Type3InputBuffer;


        if (IoSetCancelRoutine( irp, NULL ) == NULL) {
            KIRQL cancelIrql;
    
            //
            // If the cancel routine was NULL then cancel routine
            // may be running.  Wait on the cancel spinlock until
            // the cancel routine is done.
            //
            // Note: The cancel routine will not find the IRP
            // since it is not in the list.
            //
            
            IoAcquireCancelSpinLock( &cancelIrql );
            ASSERT( irp->Cancel );
            IoReleaseCancelSpinLock( cancelIrql );
    
        }
    
        if (pollInfoInternal->SanPoll && 
                ((irp->Tail.Overlay.Thread!=PsGetCurrentThread ()) ||
                        (KeGetCurrentIrql() > APC_LEVEL)) ) {
            KeInitializeApc (&pollInfoInternal->Apc,
                                PsGetThreadTcb (irp->Tail.Overlay.Thread),
                                irp->ApcEnvironment,
                                AfdSanPollApcKernelRoutine,
                                AfdSanPollApcRundownRoutine,
                                (PKNORMAL_ROUTINE)-1,
                                KernelMode,
                                NULL);
            if (KeInsertQueueApc (&pollInfoInternal->Apc,
                                    pollInfoInternal,
                                    irp,
                                    AfdPriorityBoost)) {
                continue ;
            }
            else {
                pollInfoInternal->SanPoll = FALSE;
            }
        }

    
        //
        // Free the poll info structure.
        //

        AfdFreePollInfo( pollInfoInternal );

        IoCompleteRequest( irp, AfdPriorityBoost );

    }

    return;

} // AfdIndicatePollEvent


ULONG
AfdCheckPollEvents (
    IN PAFD_ENDPOINT Endpoint,
    IN ULONG PollEventMask,
    OUT NTSTATUS *Status
    )

/*++

Routine Description:

    Checks the state of the endpoint to see if given events can be satisfied

Arguments:

    Endpoint - the endpoint to check

    PollEventMask - the mask of the events to check for
                    

    Status - the status for the events being signalled.

Return Value:

    Mask of the events being signalled.

--*/

{
    ULONG   events;
    PAFD_CONNECTION connection = AFD_CONNECTION_FROM_ENDPOINT (Endpoint);
    ASSERT( connection == NULL || connection->Type == AfdBlockTypeConnection );
    
    events = 0;
    *Status = STATUS_SUCCESS;

    if (IS_SAN_ENDPOINT (Endpoint)) {
        if (Endpoint->Common.SanEndp.SelectEventsActive & PollEventMask) {

            events = PollEventMask & Endpoint->Common.SanEndp.SelectEventsActive;
        }
    }
    else {

        //
        // Check each possible event and, if it is being polled, whether
        // the endpoint is ready for that event.  If the endpoint is
        // ready, write information about the endpoint into the output
        // buffer.
        //

        if ( (PollEventMask & AFD_POLL_RECEIVE) != 0 ) {

            //
            // For most endpoints, a receive poll is completed when
            // data arrived that does not have a posted receive.
            //
            // If the endpoint is set up for inline reception of
            // expedited data, then any expedited data should
            // be indicated as normal data.
            //

            if ( (IS_DGRAM_ENDPOINT(Endpoint) &&
                     ARE_DATAGRAMS_ON_ENDPOINT( Endpoint )) ||
                 (connection != NULL &&
                     (  IS_DATA_ON_CONNECTION( connection ) ||
                        (Endpoint->InLine &&
                            IS_EXPEDITED_DATA_ON_CONNECTION( connection )) ) ) ) {
                events |= AFD_POLL_RECEIVE;
            }
        }

        if ( (PollEventMask & AFD_POLL_RECEIVE_EXPEDITED) != 0 ) {

            //
            // If the endpoint is set up for inline reception of
            // expedited data, do not indicate as expedited data.
            //

            if ( connection != NULL && !Endpoint->InLine &&
                     IS_EXPEDITED_DATA_ON_CONNECTION( connection ) ) {
                events |= AFD_POLL_RECEIVE_EXPEDITED;
            }
        }

        if ( (PollEventMask & AFD_POLL_SEND) != 0 ) {

            //
            // For unconnected non-datagram endpoints, a send poll
            // should complete when a connect operation completes.
            // Therefore, if this is an non-datagram endpoint which is
            // not connected, do not complete the poll until the connect
            // completes.
            //

            //
            // For nonbufferring VC
            // endpoints, check whether a blocking error has
            // occurred.  If so, it will not be possible to do a
            // nonblocking send until a send possible indication
            // arrives.
            //
            // For bufferring endpoints (TDI provider does not
            // buffer), check whether we have too much send data
            // outstanding.
            //

            if ( (IS_DGRAM_ENDPOINT(Endpoint) &&
                       (Endpoint->DgBufferredSendBytes <
                           Endpoint->Common.Datagram.MaxBufferredSendBytes ||
                        Endpoint->DgBufferredSendBytes == 0))  ||

                 (  (connection!=NULL) &&
                      
                    (Endpoint->State == AfdEndpointStateConnected) &&

                    (
                        (IS_TDI_BUFFERRING(Endpoint) &&
                           connection->VcNonBlockingSendPossible ) ||

                        ( !IS_TDI_BUFFERRING(Endpoint) &&
                           (connection->VcBufferredSendBytes <
                               connection->MaxBufferredSendBytes ||
                            connection->VcBufferredSendBytes == 0)) ||

                        connection->Aborted ) ) ) {
                events |= AFD_POLL_SEND;
            }
        }

        if ( (PollEventMask & AFD_POLL_ACCEPT) != 0 ) {

            if ( (Endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening &&
                     !IsListEmpty( &Endpoint->Common.VcListening.UnacceptedConnectionListHead ) ) {
                events |= AFD_POLL_ACCEPT;
            }
        }

        if ( (PollEventMask & AFD_POLL_CONNECT) != 0 ) {

            //
            // If the endpoint is now connected, complete this event.
            //

            if ( Endpoint->State == AfdEndpointStateConnected ) {

                ASSERT( NT_SUCCESS(Endpoint->EventStatus[AFD_POLL_CONNECT_FAIL_BIT]) );
                events |= AFD_POLL_CONNECT;
            }
        }

        if ( (PollEventMask & AFD_POLL_CONNECT_FAIL) != 0 ) {

            //
            // This is a poll to see whether a connect has failed
            // recently.  The connect status must indicate an error.
            //

            if ( Endpoint->State == AfdEndpointStateBound &&
                    !NT_SUCCESS(Endpoint->EventStatus[AFD_POLL_CONNECT_FAIL_BIT]) ) {

                events |= AFD_POLL_CONNECT_FAIL;
                *Status = Endpoint->EventStatus[AFD_POLL_CONNECT_FAIL_BIT];
            }
        }

        if ( (PollEventMask & AFD_POLL_DISCONNECT) != 0 ) {

            if ( connection != NULL && connection->DisconnectIndicated ) {
                events |= AFD_POLL_DISCONNECT;
            }
        }

        if ( (PollEventMask & AFD_POLL_ABORT) != 0 ) {

            if ( connection != NULL && connection->Aborted ) {
                events |= AFD_POLL_ABORT;
            }
        }
    }

    return events;
}


VOID
AfdTimeoutPoll (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PAFD_POLL_INFO_INTERNAL pollInfoInternal = DeferredContext;
    PIRP irp;
    PLIST_ENTRY listEntry;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);
    //
    // Get the AFD spin lock and attempt to find the poll structure on
    // the list of outstanding polls.
    //

    AfdAcquireSpinLock( &AfdPollListLock, &lockHandle );

    for ( listEntry = AfdPollListHead.Flink;
          listEntry != &AfdPollListHead;
          listEntry = listEntry->Flink ) {

        PAFD_POLL_INFO_INTERNAL testInfo;

        testInfo = CONTAINING_RECORD(
                       listEntry,
                       AFD_POLL_INFO_INTERNAL,
                       PollListEntry
                       );

        if ( testInfo == pollInfoInternal ) {
            //
            // Remove the poll structure from the global list.
            //

            IF_DEBUG(POLL) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,                            "AfdTimeoutPoll: poll info %p found on list, completing.\n",
                            pollInfoInternal ));
            }

            RemoveEntryList( &pollInfoInternal->PollListEntry );
            break;
        }
    }

    ASSERT( pollInfoInternal->TimerStarted );

    //
    // If we didn't find the poll structure on the list, then the
    // indication handler got called prior to the spinlock acquisition
    // above and it is already off the list.  It must have setup
    // the IRP completion code already.
    //
    // We must free the internal information structure in this case,
    // since the indication handler will not free it.  The indication
    // handler cannot free the structure because the structure contains
    // the timer object, which must remain intact until this routine
    // is entered.
    //

    //
    // The IRP should not have been completed at this point.
    //

    ASSERT( pollInfoInternal->Irp != NULL );
    irp = pollInfoInternal->Irp;

    //
    // Remove the poll structure from the global list.
    //

    IF_DEBUG(POLL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTimeoutPoll: poll info %p found on list, completing.\n",
                    pollInfoInternal ));
    }

    AfdReleaseSpinLock( &AfdPollListLock, &lockHandle );

    //
    // Complete the IRP pointed to in the poll structure.  The
    // Information field has already been set up by AfdPoll, as well as
    // the output buffer.
    //

    if (IoSetCancelRoutine( irp, NULL ) == NULL) {
        KIRQL cancelIrql;

        //
        // If the cancel routine was NULL then cancel routine
        // may be running.  Wait on the cancel spinlock until
        // the cancel routine is done.
        //
        // Note: The cancel routine will not find the IRP
        // since it is not in the list.
        //
        
        IoAcquireCancelSpinLock( &cancelIrql );
        ASSERT( irp->Cancel );
        IoReleaseCancelSpinLock( cancelIrql );

    }

    if (pollInfoInternal->SanPoll) {
        KeInitializeApc (&pollInfoInternal->Apc,
                            PsGetThreadTcb (irp->Tail.Overlay.Thread),
                            irp->ApcEnvironment,
                            AfdSanPollApcKernelRoutine,
                            AfdSanPollApcRundownRoutine,
                            (PKNORMAL_ROUTINE)-1,
                            KernelMode,
                            NULL);
        if (KeInsertQueueApc (&pollInfoInternal->Apc,
                                pollInfoInternal,
                                irp,
                                AfdPriorityBoost)) {
            return;
        }
        else {
            pollInfoInternal->SanPoll = FALSE;
        }
    }

    IoCompleteRequest( irp, AfdPriorityBoost );

    //
    // Free the poll information structure.
    //

    AfdFreePollInfo( pollInfoInternal );

    return;

} // AfdTimeoutPoll

VOID
AfdSanPollApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    )
/*++

Routine Description:

  Special kernel apc routine. Executed in the context of
  the target thread at APC_LEVEL

Arguments:
    NormalRoutine  - pointer containing address of normal routine (it will
                    be NULL for special kernel APC and not NULL for normal
                    kernel APC)

    SystemArgument1 - pointer to the address of worker routine to execute
    SyetemArgument2 - pointer to the argument to pass to worker routine

Return Value:

    None.

--*/
{
    PAFD_POLL_INFO_INTERNAL     pollInfoInternal;
    PIRP                        irp;
    
    UNREFERENCED_PARAMETER (Apc);
    UNREFERENCED_PARAMETER (NormalContext);
    PAGED_CODE ();

    pollInfoInternal = *SystemArgument1;
    irp =  *SystemArgument2;
    ASSERT (pollInfoInternal->Irp==irp);

    //
    // Normal APC, but we are requested to run in its special
    // routine which avoids raising and lowering IRQL
    //

    ASSERT (*NormalRoutine==(PKNORMAL_ROUTINE)-1);
    *NormalRoutine = NULL;
    AfdFreePollInfo (pollInfoInternal);
    IoCompleteRequest (irp, IO_NO_INCREMENT);
}

VOID
AfdSanPollApcRundownRoutine (
    IN struct _KAPC *Apc
    )
/*++

Routine Description:

  APC rundown routine. Executed if APC cannot be delivered for
  some reason (thread exiting).

Arguments:

    Apc     - APC structure

Return Value:

    None.

--*/
{
    PAFD_POLL_INFO_INTERNAL     pollInfoInternal;
    PIRP                        irp;

    PAGED_CODE ();

    pollInfoInternal = Apc->SystemArgument1;
    irp =  Apc->SystemArgument2;
    ASSERT (pollInfoInternal->Irp==irp);

    AfdFreePollInfo (pollInfoInternal);
    IoCompleteRequest (irp, IO_NO_INCREMENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\sources.inc ===
TARGETNAME=afd
TARGETPATH=obj
TARGETTYPE=DRIVER

C_DEFINES=$(C_DEFINES) -DNT -D_NTDRIVER_
SOURCES_USED=..\sources.inc

PRECOMPILED_INCLUDE=..\afdp.h
PRECOMPILED_PCH=afdp.pch
PRECOMPILED_OBJ=afdp.obj

TARGETLIBS=$(DDK_LIB_PATH)\tdi.lib

INCLUDES=..\;$(BASE_INC_PATH)

MSC_WARNING_LEVEL=/W4 /WX
C_DEFINES=$(C_DEFINES) -D_AFD_W4_

SOURCES=\
    ..\accept.c     \
    ..\afd.rc       \
    ..\afddata.c    \
    ..\bind.c       \
    ..\blkconn.c    \
    ..\blkendp.c    \
    ..\buffer.c     \
    ..\close.c      \
    ..\connect.c    \
    ..\create.c     \
    ..\disconn.c    \
    ..\dispatch.c   \
    ..\eventsel.c   \
    ..\fastio.c     \
    ..\group.c      \
    ..\init.c       \
    ..\listen.c     \
    ..\misc.c       \
    ..\pnp.c        \
    ..\poll.c       \
    ..\receive.c    \
    ..\recvdg.c     \
    ..\recvvc.c     \
    ..\send.c       \
    ..\tpackets.c   \
    ..\san.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\san.c ===
/*+

Copyright (c) 1989  Microsoft Corporation

Module Name:

    san.c

Abstract:

    Contains routines for SAN switch support

Author:

    Vadim Eydelman (VadimE)    1-Jul-1998

Revision History:

--*/

#include "afdp.h"

VOID
AfdSanCancelConnect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
AfdSanCancelRequest (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PIRP
AfdSanDequeueRequest (
    PAFD_ENDPOINT   SanEndpoint,
    PVOID           RequestCtx
    );

VOID
AfdSanInitEndpoint (
    PAFD_ENDPOINT   SanHlprEndpoint,
    PFILE_OBJECT    SanFile,
    PAFD_SWITCH_CONTEXT SwitchContext
    );

NTSTATUS
AfdSanNotifyRequest (
    PAFD_ENDPOINT   SanEndpoint,
    PVOID           RequestCtx,
    NTSTATUS        Status,
    ULONG_PTR       Information
    );

NTSTATUS
AfdSanReferenceSwitchSocketByHandle (
    IN HANDLE              SocketHandle,
    IN ACCESS_MASK         DesiredAccess,
    IN KPROCESSOR_MODE     RequestorMode,
    IN PAFD_ENDPOINT       SanHlprEndpoint,
    IN PAFD_SWITCH_CONTEXT SwitchContext OPTIONAL,
    OUT PFILE_OBJECT       *FileObject
    );

NTSTATUS
AfdSanDupEndpointIntoServiceProcess (
    PFILE_OBJECT    SanFileObject,
    PVOID           SavedContext,
    ULONG           ContextLength
    );

NTSTATUS
AfdSanSetAskDupeToServiceState (
    PAFD_ENDPOINT   SanEndpoint
    );

BOOLEAN
AfdSanSetDupingToServiceState (
    PAFD_ENDPOINT   SanEndpoint
    );

BOOLEAN
AfdSanReferenceEndpointObject (
    PAFD_ENDPOINT   Endpoint
    );

NTSTATUS
AfdSanFindSwitchSocketByProcessContext (
    IN NTSTATUS             Status,
    IN PAFD_ENDPOINT        SanHlprEndpoint,
    IN PAFD_SWITCH_CONTEXT  SwitchContext,
    OUT PFILE_OBJECT        *FileObject
    );

VOID
AfdSanProcessAddrListForProviderChange (
    PAFD_ENDPOINT   SpecificEndpoint
    );

NTSTATUS
AfdSanGetCompletionObjectTypePointer (
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE,AfdSanCreateHelper) 
#pragma alloc_text (PAGE,AfdSanCleanupHelper) 
#pragma alloc_text (PAGE,AfdSanCleanupEndpoint) 
#pragma alloc_text (PAGE,AfdSanReferenceSwitchSocketByHandle) 
#pragma alloc_text (PAGE,AfdSanFindSwitchSocketByProcessContext) 
#pragma alloc_text (PAGESAN,AfdSanReferenceEndpointObject) 
#pragma alloc_text (PAGE,AfdSanDupEndpointIntoServiceProcess) 
#pragma alloc_text (PAGESAN,AfdSanSetAskDupeToServiceState) 
#pragma alloc_text (PAGESAN,AfdSanSetDupingToServiceState) 
#pragma alloc_text (PAGESAN,AfdSanFastCementEndpoint) 
#pragma alloc_text (PAGESAN,AfdSanFastSetEvents) 
#pragma alloc_text (PAGESAN,AfdSanFastResetEvents) 
#pragma alloc_text (PAGESAN,AfdSanAcceptCore)
#pragma alloc_text (PAGESAN,AfdSanConnectHandler)
#pragma alloc_text (PAGESAN,AfdSanReleaseConnection)
#pragma alloc_text (PAGESAN,AfdSanFastCompleteAccept) 
#pragma alloc_text (PAGESAN,AfdSanCancelAccept) 
#pragma alloc_text (PAGESAN,AfdSanCancelConnect) 
#pragma alloc_text (PAGESAN,AfdSanRedirectRequest)
#pragma alloc_text (PAGESAN,AfdSanFastCompleteRequest)
#pragma alloc_text (PAGE, AfdSanFastCompleteIo)
#pragma alloc_text (PAGESAN,AfdSanDequeueRequest)
#pragma alloc_text (PAGESAN,AfdSanCancelRequest)
#pragma alloc_text (PAGESAN,AfdSanFastRefreshEndpoint)
#pragma alloc_text (PAGE, AfdSanFastGetPhysicalAddr)
#pragma alloc_text (PAGE, AfdSanFastGetServicePid)
#pragma alloc_text (PAGE, AfdSanFastSetServiceProcess)
#pragma alloc_text (PAGE, AfdSanFastProviderChange)
#pragma alloc_text (PAGE, AfdSanAddrListChange)
#pragma alloc_text (PAGESAN, AfdSanProcessAddrListForProviderChange)
#pragma alloc_text (PAGE, AfdSanFastUnlockAll)
#pragma alloc_text (PAGE, AfdSanPollBegin)
#pragma alloc_text (PAGE, AfdSanPollEnd)
#pragma alloc_text (PAGESAN, AfdSanPollUpdate)
#pragma alloc_text (PAGE, AfdSanPollMerge)
#pragma alloc_text (PAGE, AfdSanFastTransferCtx)
#pragma alloc_text (PAGESAN, AfdSanAcquireContext)
#pragma alloc_text (PAGESAN, AfdSanInitEndpoint)
#pragma alloc_text (PAGE, AfdSanNotifyRequest)
#pragma alloc_text (PAGESAN, AfdSanRestartRequestProcessing)
#pragma alloc_text (PAGE, AfdSanGetCompletionObjectTypePointer)
#pragma alloc_text (PAGESAN, AfdSanAbortConnection)
#endif

//
// Dispatch level routines - external SAN entry points.
//

NTSTATUS
AfdSanCreateHelper (
    PIRP                        Irp,
    PFILE_FULL_EA_INFORMATION   EaBuffer,
    PAFD_ENDPOINT               *Endpoint
    )
/*++

Routine Description:

    Allocates and initializes SAN helper endpoint for communication between switch
    and AFD.

Arguments:
    Irp     - Create IRP
    EaBuffer - Create IRP Ea buffer (AFD_SWITCH_OPEN_PACKET structure)
                    CompletionPort  - completion port to reflect kernel calls to switch
                    CompletionEvent - event to identify overlapped IO triggered by the
                                        switch as opposed to the application
    Endpoint - buffer to place created endpoint pointer.

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_ACCESS_VIOLATION - incorrect input buffer size.
    other - failed to access port/event object or allocation failure..
--*/
{
    NTSTATUS    status;
    HANDLE      port, event;
    PVOID       ioCompletionPort;
    PVOID       ioCompletionEvent;

    if ( !MmIsThisAnNtAsSystem () ) {
#ifndef DONT_CHECK_FOR_DTC
        return STATUS_NOT_SUPPORTED;
#else
        DbgPrint ("AFD: Temporarily allowing SAN support on non-server build\n");
#endif //DONT_CHECK_FOR_DTC
    }
#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        PAFD_SWITCH_OPEN_PACKET32   openPacket32;

        if (EaBuffer->EaValueLength<sizeof (*openPacket32)) {
            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanCreateHelper: Invalid switch open packet size.\n"));
            }
            return STATUS_ACCESS_VIOLATION;
        }
        openPacket32 = (PAFD_SWITCH_OPEN_PACKET32)(EaBuffer->EaName +
                                        EaBuffer->EaNameLength + 1);
        event = openPacket32->CompletionEvent;
        port = openPacket32->CompletionPort;
    }
    else
#endif //_WIN64
    {
        PAFD_SWITCH_OPEN_PACKET   openPacket;
        if (EaBuffer->EaValueLength<sizeof (*openPacket)) {
            IF_DEBUG (SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanCreateHelper: Invalid switch open packet size.\n"));
            }
            return STATUS_ACCESS_VIOLATION;
        }
        openPacket = (PAFD_SWITCH_OPEN_PACKET)(EaBuffer->EaName +
                                    EaBuffer->EaNameLength + 1);
        event = openPacket->CompletionEvent;
        port = openPacket->CompletionPort;
    }


    if (IoCompletionObjectType==NULL) {
        status = AfdSanGetCompletionObjectTypePointer ();
        if (!NT_SUCCESS (status)) {
            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                        "AfdSanCreateHelper: Could not get completion OT:%lx\n",
                        status));
            }
            return status;
        }
    }
    //
    // Get references to completion port and event
    //

    status = ObReferenceObjectByHandle (
                port,
                IO_COMPLETION_ALL_ACCESS,
                IoCompletionObjectType,
                Irp->RequestorMode,
                &ioCompletionPort,
                NULL
                );
    if (!NT_SUCCESS (status)) {
        IF_DEBUG (SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanCreateHelper: Could not reference completion port (%p).\n",
                        status));
        }
        return status;
    }

                    
    status = ObReferenceObjectByHandle (
                event,
                EVENT_ALL_ACCESS,
                *ExEventObjectType,
                Irp->RequestorMode,
                &ioCompletionEvent,
                NULL
                );
    if (!NT_SUCCESS (status)) {
        ObDereferenceObject (ioCompletionPort);
        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanCreateHelper: Could not reference completion event (%p).\n",
                        status));
        }
        return status;
    }


    //
    // Allocate an AFD "helper" endpoint.
    //

    status = AfdAllocateEndpoint(
                 Endpoint,
                 NULL,
                 0
                 );

    if( !NT_SUCCESS(status) ) {
        ObDereferenceObject (ioCompletionPort);
        ObDereferenceObject (ioCompletionEvent);
        return status;
    }
    (*Endpoint)->Type = AfdBlockTypeSanHelper;
    (*Endpoint)->Common.SanHlpr.IoCompletionPort = ioCompletionPort;
    (*Endpoint)->Common.SanHlpr.IoCompletionEvent = ioCompletionEvent;
    (*Endpoint)->Common.SanHlpr.Plsn = 0;
    (*Endpoint)->Common.SanHlpr.PendingRequests = 0;

    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );
    if (AfdSanCodeHandle==NULL) {
        AfdSanCodeHandle = MmLockPagableCodeSection( (PVOID)AfdSanFastCementEndpoint );
        ASSERT( AfdDiscardableCodeHandle != NULL );

        InitializeListHead (&AfdSanHelperList);
    }

    InsertTailList (&AfdSanHelperList, &(*Endpoint)->Common.SanHlpr.SanListLink);
    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();
    //
    // HACKHACK.  Force IO subsystem to call us when last handle to the file is closed
    // in any given process.
    //
    IoGetCurrentIrpStackLocation (Irp)->FileObject->LockOperation = TRUE;
    return STATUS_SUCCESS;
}


NTSTATUS
AfdSanFastCementEndpoint (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
/*++

Routine Description:

    Changes the endpoint type to SAN to indicate that
    it is used for support of user mode SAN providers
    Associates switch context with the endpoint.

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_CEMENT_SAN)
    RequestorMode   - mode of the caller
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONTEXT_INFO)
                            SocketHandle    - handle of the endpoint being changed to SAN
                            SwitchContext   - switch context associated with the endpoint
    InputBufferLength - sizeof(AFD_SWITCH_CONTEXT_INFO)
    OutputBuffer    - unused
    OutputBufferLength - unused
    Information     - pointer for buffer to place return information into, unused
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint or switch socket is of incorrect type
    STATUS_INVALID_PARAMETER - input buffer is of incorrect size
    other - failed when attempting to access switch socket, input buffer, or switch context.
--*/

{
    NTSTATUS    status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PFILE_OBJECT    sanFileObject;
    AFD_SWITCH_CONTEXT_INFO contextInfo;
    PAFD_ENDPOINT   sanEndpoint, sanHlprEndpoint;
    PVOID       context;

    UNREFERENCED_PARAMETER (OutputBuffer);
    UNREFERENCED_PARAMETER (OutputBufferLength);
    *Information = 0;

    AFD_W4_INIT status = STATUS_SUCCESS;
    try {

#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            PAFD_SWITCH_CONTEXT_INFO32  contextInfo32;
            if (InputBufferLength<sizeof (*contextInfo32)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (*contextInfo32),
                                PROBE_ALIGNMENT32 (AFD_SWITCH_CONTEXT_INFO32));
            }
            contextInfo32 = InputBuffer;
            contextInfo.SocketHandle = contextInfo32->SocketHandle;
            contextInfo.SwitchContext = UlongToPtr(contextInfo32->SwitchContext);
        }
        else
#endif _WIN64
        {

            if (InputBufferLength<sizeof (contextInfo)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }

            if (RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (contextInfo),
                                PROBE_ALIGNMENT (AFD_SWITCH_CONTEXT_INFO));
            }

            contextInfo = *((PAFD_SWITCH_CONTEXT_INFO)InputBuffer);
        }

        if (contextInfo.SwitchContext==NULL) {
            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AFD: Switch context is NULL in AfdSanFastCementEndpoint\n"));
            }
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }

        if (RequestorMode!=KernelMode) {
            ProbeForWrite (contextInfo.SwitchContext,
                            sizeof (*contextInfo.SwitchContext),
                            PROBE_ALIGNMENT (AFD_SWITCH_CONTEXT));
        }
    }
    except (AFD_EXCEPTION_FILTER (status)) {
        ASSERT (NT_ERROR (status));
        return status;
    }

    sanHlprEndpoint = FileObject->FsContext;
    ASSERT (IS_SAN_HELPER (sanHlprEndpoint));
    status = AfdSanReferenceSwitchSocketByHandle (
                            contextInfo.SocketHandle,
                            (IoctlCode>>14)&3,
                            RequestorMode,
                            sanHlprEndpoint,
                            NULL,
                            &sanFileObject
                            );
    if (!NT_SUCCESS (status)) {
        return status;
    }

    sanEndpoint = sanFileObject->FsContext;

    IF_DEBUG(SAN_SWITCH) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFastCementSanEndpoint: endp-%p, hlpr-%p.\n",
                    sanEndpoint, sanHlprEndpoint));
    }

    //
    // Make sure that san endpoint is in the state where it can
    // be given to the san provider.
    //
    if (AFD_PREVENT_STATE_CHANGE (sanEndpoint)) {       // Prevents state change
        context = AfdLockEndpointContext (sanEndpoint); // Locks out select
        AfdAcquireSpinLock (&sanEndpoint->SpinLock, &lockHandle); // Locks out cleanup
                                                        // from looking at partially
                                                        // initialized data.
        if (!sanEndpoint->EndpointCleanedUp &&
             (sanEndpoint->Type==AfdBlockTypeEndpoint) &&
             (sanEndpoint->State==AfdEndpointStateBound) ) {
            AFD_SWITCH_CONTEXT  localContext = {0,0,0,0};

            AfdSanInitEndpoint (sanHlprEndpoint, sanFileObject, contextInfo.SwitchContext);

            sanEndpoint->DisableFastIoSend = TRUE;
            sanEndpoint->DisableFastIoRecv = TRUE;
            sanEndpoint->EnableSendEvent = TRUE;
            sanEndpoint->Common.SanEndp.SelectEventsActive = AFD_POLL_SEND;
            sanEndpoint->State = AfdEndpointStateConnected;
            sanEndpoint->Common.SanEndp.LocalContext = &localContext;
            AfdIndicateEventSelectEvent (sanEndpoint, AFD_POLL_CONNECT|AFD_POLL_SEND, STATUS_SUCCESS);
            AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
            AfdIndicatePollEvent (sanEndpoint, AFD_POLL_CONNECT|AFD_POLL_SEND, STATUS_SUCCESS);
            status = AfdSanPollMerge (sanEndpoint, &localContext);
            sanEndpoint->Common.SanEndp.LocalContext = NULL;

        }
        else {
            AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
            status = STATUS_INVALID_HANDLE;
        }
        AfdUnlockEndpointContext (sanEndpoint, context);
        AFD_REALLOW_STATE_CHANGE (sanEndpoint);
    }
    else {
        status = STATUS_INVALID_HANDLE;
    }


    UPDATE_ENDPOINT2 (sanEndpoint, "AfdSanFastCementEndpoint, status: 0x%lX", status);
    ObDereferenceObject (sanFileObject);
    return status;
}

NTSTATUS
AfdSanFastSetEvents (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
/*++

Routine Description:

    Sets the poll event on the san endpoint to report
    to the application via various forms of the select

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_SET_EVENTS)
    RequestorMode   - mode of the caller
    InputBuffer     - input parameters for the operation (AFD_SWITCH_EVENT_INFO)
                            SocketHandle    - handle of the endpoint being changed to SAN
                            EventBit        - event bit to set
                            Status          - associated status (for AFD_POLL_EVENT_CONNECT_FAIL)
    InputBufferLength - sizeof(AFD_SWITCH_EVENT_INFO)
    OutputBuffer    - unused
    OutputBufferLength - unused
    Information     - pointer for buffer to place return information into, unused
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint or switch socket is of incorrect type
    STATUS_INVALID_PARAMETER - input buffer is of incorrect size, invalid event bit.
    other - failed when attempting to access switch socket, input buffer, or switch context.
--*/
{
    NTSTATUS status;
    PFILE_OBJECT    sanFileObject;
    AFD_SWITCH_EVENT_INFO eventInfo;
    PAFD_ENDPOINT   sanEndpoint, sanHlprEndpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    UNREFERENCED_PARAMETER (OutputBuffer);
    UNREFERENCED_PARAMETER (OutputBufferLength);
    *Information = 0;

    AFD_W4_INIT status = STATUS_SUCCESS;
    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            PAFD_SWITCH_EVENT_INFO32  eventInfo32;
            if (InputBufferLength<sizeof (*eventInfo32)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (*eventInfo32),
                                PROBE_ALIGNMENT32 (AFD_SWITCH_EVENT_INFO32));
            }
            eventInfo32 = InputBuffer;
            eventInfo.SocketHandle = eventInfo32->SocketHandle;
            eventInfo.SwitchContext = UlongToPtr(eventInfo32->SwitchContext);
            eventInfo.EventBit = eventInfo32->EventBit;
            eventInfo.Status = eventInfo32->Status;
        }
        else
#endif _WIN64
        {
            if (InputBufferLength<sizeof (eventInfo)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }

            if (RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (eventInfo),
                                PROBE_ALIGNMENT (AFD_SWITCH_EVENT_INFO));
            }

            eventInfo = *((PAFD_SWITCH_EVENT_INFO)InputBuffer);
        }
    }
    except (AFD_EXCEPTION_FILTER (status)) {
        ASSERT (NT_ERROR (status));
        return status;
    }

    if (eventInfo.EventBit >= AFD_NUM_POLL_EVENTS) {
        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AFD: Invalid EventBit=%d passed to AfdSanFastSetEvents\n", 
                        eventInfo.EventBit));
        }
        return STATUS_INVALID_PARAMETER;
    }

    eventInfo.Status = AfdValidateStatus (eventInfo.Status);

    //
    // If event is connect failure, then context should not exist.
    // If event is not connect failure, context should exist.
    //
    if ((eventInfo.EventBit==AFD_POLL_CONNECT_FAIL_BIT) ^
            (eventInfo.SwitchContext==NULL)) {
        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AFD: AfdSanFastSetEvents-bit:%ld, context:%p inconsistent\n", 
                        eventInfo.EventBit,
                        eventInfo.SwitchContext));
        }
        return STATUS_INVALID_PARAMETER;
    }
        

    sanHlprEndpoint = FileObject->FsContext;
    ASSERT (IS_SAN_HELPER (sanHlprEndpoint));
    status = AfdSanReferenceSwitchSocketByHandle (
                            eventInfo.SocketHandle,
                            (IoctlCode>>14)&3,
                            RequestorMode,
                            sanHlprEndpoint,
                            eventInfo.SwitchContext,
                            &sanFileObject
                            );
    if (!NT_SUCCESS (status)) {
        return status;
    }

    sanEndpoint = sanFileObject->FsContext;

    //
    // Prevent endpoint reuse
    //
    if (!AFD_PREVENT_STATE_CHANGE (sanEndpoint)) {
        status = STATUS_INVALID_HANDLE;
        goto complete;
    }

    if (sanEndpoint->State==AfdEndpointStateConnected ||
            (eventInfo.EventBit==AFD_POLL_CONNECT_FAIL_BIT &&
            sanEndpoint->State==AfdEndpointStateBound) ) {
            


        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdFastSetSanEvents: endp-%p, bit-%lx, status-%lx.\n",
                        sanEndpoint, eventInfo.EventBit, eventInfo.Status));
        }

        try {
            LONG currentEvents, newEvents;

            //
            // Update our event record. Make sure endpoint is connected, otherwise
            // sanEndpoint->Common.SanEndp.SwitchContext will not be valid
            //
            if (sanEndpoint->State==AfdEndpointStateConnected) {
                do {
                    currentEvents = *((LONG volatile *)&sanEndpoint->Common.SanEndp.SelectEventsActive);
                    newEvents = *((LONG volatile *)&sanEndpoint->Common.SanEndp.SwitchContext->EventsActive);
                }
                while (InterlockedCompareExchange (
                            (PLONG)&sanEndpoint->Common.SanEndp.SelectEventsActive,
                            newEvents,
                            currentEvents)!=currentEvents);
            }
        }
        except (AFD_EXCEPTION_FILTER (status)) {
            ASSERT (NT_ERROR (status));
            goto complete_state_change;
        }

        //
        // Signal the event.
        //
        AfdAcquireSpinLock (&sanEndpoint->SpinLock, &lockHandle);
        AfdIndicateEventSelectEvent (sanEndpoint, 1<<eventInfo.EventBit, eventInfo.Status);
        AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
        AfdIndicatePollEvent (sanEndpoint, 1<<eventInfo.EventBit, eventInfo.Status);
        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_INVALID_HANDLE;
    }

complete_state_change:
    AFD_REALLOW_STATE_CHANGE (sanEndpoint);

complete:
    UPDATE_ENDPOINT2 (sanEndpoint, 
                        "AfdFastSetEvents, event/status: 0x%lX",
                        NT_SUCCESS (status) ? eventInfo.EventBit : status);
    ObDereferenceObject (sanFileObject);
    return status;
}

NTSTATUS
AfdSanFastResetEvents (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
/*++

Routine Description:

    Resets the poll event on the san endpoint so that it is no
    longer reported to the application via various forms of the select

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_RESET_EVENTS)
    RequestorMode   - mode of the caller
    InputBuffer     - input parameters for the operation (AFD_SWITCH_EVENT_INFO)
                            SocketHandle    - handle of the endpoint being changed to SAN
                            EventBit        - event bit to reset
                            Status          - associated status (ignored)
    InputBufferLength - sizeof(AFD_SWITCH_EVENT_INFO)
    OutputBuffer    - unused
    OutputBufferLength - unused
    Information     - pointer for buffer to place return information into, unused
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint or switch socket is of incorrect type
    STATUS_INVALID_PARAMETER - input buffer is of incorrect size, invalid event bit.
    other - failed when attempting to access switch socket, input buffer, or switch context.

--*/
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    NTSTATUS    status;
    PFILE_OBJECT    sanFileObject;
    AFD_SWITCH_EVENT_INFO eventInfo;
    PAFD_ENDPOINT   sanEndpoint, sanHlprEndpoint;

    UNREFERENCED_PARAMETER (OutputBuffer);
    UNREFERENCED_PARAMETER (OutputBufferLength);

    *Information = 0;

    AFD_W4_INIT status = STATUS_SUCCESS;
    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            PAFD_SWITCH_EVENT_INFO32  eventInfo32;
            if (InputBufferLength<sizeof (*eventInfo32)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (*eventInfo32),
                                PROBE_ALIGNMENT32 (AFD_SWITCH_EVENT_INFO32));
            }
            eventInfo32 = InputBuffer;
            eventInfo.SocketHandle = eventInfo32->SocketHandle;
            eventInfo.SwitchContext = UlongToPtr(eventInfo32->SwitchContext);
            eventInfo.EventBit = eventInfo32->EventBit;
            eventInfo.Status = eventInfo32->Status;
        }
        else
#endif _WIN64
        {
            if (InputBufferLength<sizeof (eventInfo)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }

            if (RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (eventInfo),
                                PROBE_ALIGNMENT (AFD_SWITCH_EVENT_INFO));
            }

            eventInfo = *((PAFD_SWITCH_EVENT_INFO)InputBuffer);
        }
    }
    except (AFD_EXCEPTION_FILTER (status)) {
        ASSERT (NT_ERROR (status));
        return status;
    }

    if (eventInfo.EventBit >= AFD_NUM_POLL_EVENTS) {
        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AFD: Invalid EventBit=%d passed to AfdSanFastResetEvents\n", 
                        eventInfo.EventBit));
        }
        return STATUS_INVALID_PARAMETER;
    }

    if (eventInfo.SwitchContext==NULL) {
        KdPrint (("AFD: Switch context is NULL in AfdSanFastResetEvents\n"));
        return STATUS_INVALID_PARAMETER;
    }

    sanHlprEndpoint = FileObject->FsContext;
    ASSERT (IS_SAN_HELPER (sanHlprEndpoint));
    status = AfdSanReferenceSwitchSocketByHandle (
                            eventInfo.SocketHandle,
                            (IoctlCode>>14)&3,
                            RequestorMode,
                            sanHlprEndpoint,
                            eventInfo.SwitchContext,
                            &sanFileObject
                            );
    if (!NT_SUCCESS (status)) {
        return status;
    }
    sanEndpoint = sanFileObject->FsContext;

    //
    // Prevent endpoint reuse
    //
    if (!AFD_PREVENT_STATE_CHANGE (sanEndpoint)) {
        status = STATUS_INVALID_HANDLE;
        goto complete;
    }

    if (!IS_SAN_ENDPOINT (sanEndpoint)) {
        goto complete_state_change;
    }

    IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdFastResetSanEvents: endp-%p, bit-%lx, status-%lx.\n",
                        sanEndpoint, eventInfo.EventBit, eventInfo.Status));
    }

    try {
        LONG currentEvents, newEvents;

        //
        // Update our event record.
        //
        do {
            currentEvents = *((LONG volatile *)&sanEndpoint->Common.SanEndp.SelectEventsActive);
            newEvents = *((LONG volatile *)&sanEndpoint->Common.SanEndp.SwitchContext->EventsActive);
        }
        while (InterlockedCompareExchange (
                    (PLONG)&sanEndpoint->Common.SanEndp.SelectEventsActive,
                    newEvents,
                    currentEvents)!=currentEvents);
    }
    except (AFD_EXCEPTION_FILTER (status)) {
        ASSERT (NT_ERROR (status));
        goto complete_state_change;
    }

    AfdAcquireSpinLock (&sanEndpoint->SpinLock, &lockHandle);
    //
    // Reset EventSelect mask
    sanEndpoint->EventsActive &= (~ (1<<(eventInfo.EventBit)));
    if (eventInfo.EventBit == AFD_POLL_SEND_BIT)
        sanEndpoint->EnableSendEvent = TRUE;
    AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
    status = STATUS_SUCCESS;

complete_state_change:
    AFD_REALLOW_STATE_CHANGE (sanEndpoint);

complete:
    UPDATE_ENDPOINT2 (sanEndpoint,
                        "AfdFastResetEvents, event/status: 0x%lX",
                        NT_SUCCESS (status) ? eventInfo.EventBit : status);
    ObDereferenceObject (sanFileObject);
    return status;
}

//
// Macros to make the super accept restart code more maintainable.
//

#define AfdRestartSuperAcceptInfo   DeviceIoControl

// Used while IRP is in AFD queue (otherwise AfdAcceptFileObject
// is stored as completion routine context).
#define AfdAcceptFileObject         Type3InputBuffer
// Used when IRP is passed to the transport (otherwise MdlAddress
// is stored in the IRP itself).
#define AfdMdlAddress               Type3InputBuffer

#define AfdReceiveDataLength        OutputBufferLength
#define AfdRemoteAddressLength      InputBufferLength
#define AfdLocalAddressLength       IoControlCode

NTSTATUS
FASTCALL
AfdSanConnectHandler (
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp
    )
/*++

Routine Description:

    Implements connect indication from SAN provider.
    Picks up the accept from the listening endpoint queue
    or queues the IRP an signals the application to come
    down with an accept.

Arguments:

    Irp  - SAN connect IRP
    IrpSp -  stack location

Return Value:
    NTSTATUS

--*/
{
    NTSTATUS    status;
    PAFD_SWITCH_CONNECT_INFO connectInfo;
    union {
#ifdef _WIN64
        PAFD_SWITCH_ACCEPT_INFO32 acceptInfo32;
#endif //_WIN64
        PAFD_SWITCH_ACCEPT_INFO acceptInfo;
    } u;
    PFILE_OBJECT  listenFileObject;
    PAFD_ENDPOINT sanHlprEndpoint;
    PAFD_ENDPOINT listenEndpoint;
    PAFD_CONNECTION connection;
    ULONG   RemoteAddressLength;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PIRP    acceptIrp;
    PTA_ADDRESS localAddress;

    listenFileObject = NULL;

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        PAFD_SWITCH_CONNECT_INFO      newSystemBuffer;
        PAFD_SWITCH_CONNECT_INFO32    oldSystemBuffer = Irp->AssociatedIrp.SystemBuffer;
        ULONG                         newLength;

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                     sizeof(*oldSystemBuffer) ) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        newLength = (sizeof(*newSystemBuffer) - sizeof(*oldSystemBuffer));
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength > (MAXULONG - newLength)) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
        newLength += IrpSp->Parameters.DeviceIoControl.InputBufferLength;

        try {
            newSystemBuffer = ExAllocatePoolWithQuotaTag (
                                    NonPagedPool|POOL_RAISE_IF_ALLOCATION_FAILURE,
                                    newLength,
                                    AFD_SYSTEM_BUFFER_POOL_TAG);
                                                
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode ();
            goto complete;
        }

        newSystemBuffer->ListenHandle = oldSystemBuffer->ListenHandle;
        newSystemBuffer->SwitchContext = UlongToPtr(oldSystemBuffer->SwitchContext);
        RtlMoveMemory (&newSystemBuffer->RemoteAddress,
                        &oldSystemBuffer->RemoteAddress,
                        IrpSp->Parameters.DeviceIoControl.InputBufferLength-
                            FIELD_OFFSET (AFD_SWITCH_CONNECT_INFO32, RemoteAddress));

        ExFreePool (Irp->AssociatedIrp.SystemBuffer);
        Irp->AssociatedIrp.SystemBuffer = newSystemBuffer;
        IrpSp->Parameters.DeviceIoControl.InputBufferLength = newLength;
    }
#endif // _WIN64


    //
    // Set up local variables.
    //


    sanHlprEndpoint = IrpSp->FileObject->FsContext;
    ASSERT( sanHlprEndpoint->Type == AfdBlockTypeSanHelper);
    Irp->IoStatus.Information = 0;
    connectInfo = Irp->AssociatedIrp.SystemBuffer;

    //
    // Verify input parameters
    //
    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                                    sizeof (*connectInfo) ||
            connectInfo->RemoteAddress.TAAddressCount!=2 ||    // Must have local and remote addresses
            (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                FIELD_OFFSET (AFD_SWITCH_CONNECT_INFO,
                    RemoteAddress.Address[0].Address[
                        connectInfo->RemoteAddress.Address[0].AddressLength])+sizeof(TA_ADDRESS))) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                        sizeof (*u.acceptInfo32)) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
    }
    else
#endif // _WIN64
    {
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                        sizeof (*u.acceptInfo)) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
    }

    RemoteAddressLength = FIELD_OFFSET (TRANSPORT_ADDRESS, Address[0].Address[
                                connectInfo->RemoteAddress.Address[0].AddressLength]);
    localAddress = (PTA_ADDRESS)
            &(connectInfo->RemoteAddress.Address[0].Address[
                    connectInfo->RemoteAddress.Address[0].AddressLength]);
    if (&localAddress->Address[localAddress->AddressLength]-(PUCHAR)Irp->AssociatedIrp.SystemBuffer>
            (LONG)IrpSp->Parameters.DeviceIoControl.InputBufferLength) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    if (!IS_SAN_HELPER(sanHlprEndpoint) ||
          sanHlprEndpoint->OwningProcess!=IoGetCurrentProcess ()) {
        status = STATUS_INVALID_HANDLE;
        goto complete;
    }

    try {
        if (connectInfo->SwitchContext == NULL) {
            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AFD: Switch context is NULL in AfdSanConnectHandler\n"));
            }
            ExRaiseStatus(STATUS_INVALID_PARAMETER);
        }
        if (Irp->RequestorMode != KernelMode) {
            ProbeForWrite(connectInfo->SwitchContext,
                          sizeof(*connectInfo->SwitchContext),
                          PROBE_ALIGNMENT(AFD_SWITCH_CONTEXT));
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        goto complete;
    }

    //
    // We will separate addresses, so change the count
    //
    connectInfo->RemoteAddress.TAAddressCount = 1;
    
#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        u.acceptInfo32 = MmGetMdlVirtualAddress (Irp->MdlAddress);
        ASSERT (u.acceptInfo32!=NULL);
        ASSERT (MmGetMdlByteCount (Irp->MdlAddress)>=sizeof (*u.acceptInfo32));
    }
    else
#endif // _WIN64
    {   
        u.acceptInfo = MmGetMdlVirtualAddress (Irp->MdlAddress);
        ASSERT (u.acceptInfo!=NULL);
        ASSERT (MmGetMdlByteCount (Irp->MdlAddress)>=sizeof (*u.acceptInfo));
    }

    //
    // Get the listening file object and verify its type and state
    //
    status = ObReferenceObjectByHandle (
                connectInfo->ListenHandle,
                (IrpSp->Parameters.DeviceIoControl.IoControlCode >> 14) & 3,   // DesiredAccess
                *IoFileObjectType,
                Irp->RequestorMode,
                (PVOID)&listenFileObject,
                NULL);
    if (!NT_SUCCESS (status)) {
        goto complete;
    }

    if (IoGetRelatedDeviceObject (listenFileObject)!=AfdDeviceObject) {
        status = STATUS_INVALID_HANDLE;
        goto complete;
    }

    listenEndpoint = listenFileObject->FsContext;
    if ( !listenEndpoint->Listening ||
            listenEndpoint->State == AfdEndpointStateClosing ||
            listenEndpoint->EndpointCleanedUp ) {
        status = STATUS_INVALID_HANDLE;
        goto complete;
    }


    IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanConnectHandler: endp-%p, irp-%p.\n", 
                        listenEndpoint,
                        Irp));
    }


    if (!IS_DELAYED_ACCEPTANCE_ENDPOINT (listenEndpoint)) {
        //
        // Keep getting accept IRPs/connection structures till
        // we find one that can be used to satisfy connect indication
        // or queue it.
        //
        while ((connection = AfdGetFreeConnection( listenEndpoint, &acceptIrp ))!=NULL
                            && acceptIrp!=NULL) {
            PAFD_ENDPOINT           acceptEndpoint;
            PFILE_OBJECT            acceptFileObject;
            PIO_STACK_LOCATION      irpSp;

            IF_DEBUG(LISTEN) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdSanConnectHandler: using connection %lx\n",
                              connection ));
            }

            ASSERT( connection->Type == AfdBlockTypeConnection );


            irpSp = IoGetCurrentIrpStackLocation (acceptIrp);
            acceptFileObject = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdAcceptFileObject;
            acceptEndpoint = acceptFileObject->FsContext;
            ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));
            ASSERT (acceptIrp->Tail.Overlay.DriverContext[0] == connection);
            ASSERT (connection->Endpoint == NULL);

            InterlockedDecrement (
                &listenEndpoint->Common.VcListening.FailedConnectionAdds);
            InterlockedPushEntrySList (
                &listenEndpoint->Common.VcListening.FreeConnectionListHead,
                &connection->SListEntry
                );
            DEBUG   connection = NULL;

            //
            // Make sure connection indication comes from current process.
            // (we do check it indirectly up above when validating the request.
            // This check is explicit).
            //
            if (IoThreadToProcess (Irp->Tail.Overlay.Thread)==IoGetCurrentProcess ()) {
                //
                // Check if super accept Irp has enough space for
                // the remote address
                //
                if( (ULONG)RemoteAddressLength <=
                        irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength ) {
                    //
                    // Check if we have enough system PTE's to map
                    // the buffer.
                    //
                    status = AfdMapMdlChain (acceptIrp->MdlAddress);
                    if( NT_SUCCESS (status) ) {
                        HANDLE  acceptHandle;
                        BOOLEAN handleDuplicated;
                        if (IoThreadToProcess (Irp->Tail.Overlay.Thread)==
                                IoThreadToProcess (acceptIrp->Tail.Overlay.Thread)) {
                            acceptHandle = acceptIrp->Tail.Overlay.DriverContext[3];
                            status = STATUS_SUCCESS;
                            handleDuplicated = FALSE;
                        }
                        else {
                            //
                            // Listen process is different than the accepting one.
                            // We need to duplicate accepting handle into the listening
                            // process so that accept can take place there and the accepting
                            // socket will later get dup-ed into the accepting process when
                            // that process performs an IO operation on it.
                            //
                            status = ObOpenObjectByPointer (
                                                    acceptFileObject,
                                                    OBJ_CASE_INSENSITIVE,
                                                    NULL,
                                                    MAXIMUM_ALLOWED,
                                                    *IoFileObjectType,
                                                    KernelMode,
                                                    &acceptHandle);
                            handleDuplicated = TRUE; // If we fail duplication above,
                                                     // this variable is not used
                                                     // so setting it to TRUE won't
                                                        // have any effect.
                        }
                        if (NT_SUCCESS (status)) {
                            AfdAcquireSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
                            if (!acceptEndpoint->EndpointCleanedUp) {
                                IoSetCancelRoutine (acceptIrp, AfdSanCancelAccept);
                                if (!acceptIrp->Cancel) {
                                    //
                                    // Copy the remote address from the connection object
                                    //
#ifndef i386
                                    if (acceptEndpoint->Common.VcConnecting.FixAddressAlignment) {
                                        USHORT addressLength = 
                                                connectInfo->RemoteAddress.Address[0].AddressLength
                                                + sizeof (USHORT);
                                        USHORT UNALIGNED *pAddrLength = (PVOID)
                                                    ((PUCHAR)MmGetSystemAddressForMdl (acceptIrp->MdlAddress)
                                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength
                                                     - sizeof (USHORT));
                                        RtlMoveMemory (
                                                    (PUCHAR)MmGetSystemAddressForMdl (acceptIrp->MdlAddress)
                                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                                                     &connectInfo->RemoteAddress.Address[0].AddressType,
                                                     addressLength);
                                        *pAddrLength = addressLength;
                                    }
                                    else
#endif
                                    {
                                        RtlMoveMemory (
                                                    (PUCHAR)MmGetSystemAddressForMdl (acceptIrp->MdlAddress)
                                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                                                     &connectInfo->RemoteAddress,
                                                     RemoteAddressLength);
                                    }

                                    if (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength>0) {
                                        TDI_ADDRESS_INFO  UNALIGNED *addressInfo = (PVOID)
                                                ((PUCHAR)MmGetSystemAddressForMdl(acceptIrp->MdlAddress)
                                                    + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength);
#ifndef i386
                                        if (acceptEndpoint->Common.VcConnecting.FixAddressAlignment) {
                                            USHORT UNALIGNED * pAddrLength = (PVOID)
                                                ((PUCHAR)addressInfo 
                                                +irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                                                -sizeof(USHORT));
                                            RtlMoveMemory (
                                                addressInfo,
                                                &localAddress->AddressType,
                                                localAddress->AddressLength+sizeof (USHORT));
                                            *pAddrLength = localAddress->AddressLength+sizeof (USHORT);
                                        }
                                        else
#endif
                                        {
                                            addressInfo->ActivityCount = 0;
                                            addressInfo->Address.TAAddressCount = 1;
                                            RtlMoveMemory (
                                                &addressInfo->Address.Address,
                                                localAddress,
                                                FIELD_OFFSET (TA_ADDRESS, Address[localAddress->AddressLength]));

                                        }
                                    }
    
                                    ASSERT (acceptEndpoint->Irp==acceptIrp);
                                    acceptEndpoint->Irp = NULL;

                                    //
                                    // Convert endpoint to SAN
                                    //
                                    AfdSanInitEndpoint (sanHlprEndpoint, acceptFileObject, connectInfo->SwitchContext);
                                    UPDATE_ENDPOINT2 (acceptEndpoint, 
                                            "AfdSanConnectHandler, accepted with bytes: 0x%d", 
                                            irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength);
                                    InsertTailList (&acceptEndpoint->Common.SanEndp.IrpList,
                                                        &acceptIrp->Tail.Overlay.ListEntry);

        
        
                                    //
                                    // Setup output for switch and complete its IRP
                                    //
                                    // Do this under protection of exception handler since application
                                    // can change protection attributes of the virtual address range
                                    // or even deallocate it.
                                    try {
#ifdef _WIN64
                                        if (IoIs32bitProcess (Irp)) {
                                            u.acceptInfo32->AcceptHandle = (VOID * POINTER_32)acceptHandle;
                                            u.acceptInfo32->ReceiveLength = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength;
                                            Irp->IoStatus.Information = sizeof (*u.acceptInfo32);
                                        }
                                        else
#endif //_WIN64
                                        {
                                            u.acceptInfo->AcceptHandle = acceptHandle;
                                            u.acceptInfo->ReceiveLength = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength;
                                            Irp->IoStatus.Information = sizeof (*u.acceptInfo);
                                        }
                                    }
                                    except (AFD_EXCEPTION_FILTER_NO_STATUS()) {
                                        //
                                        // If the app is playing with switch's virtual addresses
                                        // we can't help much - it's accept IRP will probably
                                        // just hang since the switch is not going to follow
                                        // the failed connect IRP with accept completion.
                                        //
                                    }

                                    AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
                                    AfdRecordConnectionsPreaccepted ();

                                    Irp->IoStatus.Status = STATUS_SUCCESS;
                                    IoCompleteRequest (Irp, AfdPriorityBoost);

                                    ObDereferenceObject (listenFileObject);
                                    IF_DEBUG(SAN_SWITCH) {
                                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                                    "AfdSanConnectHandler: pre-accepted, endp-%p, SuperAccept irp-%p\n",
                                                    acceptEndpoint, acceptIrp));
                                    }

                                    return STATUS_SUCCESS;
                                }
                                else { //if (!acceptIrp->Cancel
                                    if (IoSetCancelRoutine (acceptIrp, NULL)==NULL) {
                                        KIRQL cancelIrql;
                                        AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
                                        IoAcquireCancelSpinLock (&cancelIrql);
                                        IoReleaseCancelSpinLock (cancelIrql);
                                    }
                                    else {
                                        AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
                                    }
                                }
                            }
                            else { // if (!acceptEndpoint->EndpointCleanedUp)
                                AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
                                IF_DEBUG(SAN_SWITCH) {
                                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                                "AfdSanConnectHandler: accept endpoint cleanedup. endp=%lx",
                                                acceptEndpoint));
                                }
                            }
                            if (handleDuplicated) {
#if DBG
                                status =
#endif
                                    NtClose (acceptHandle);
                            }
                            ASSERT (NT_SUCCESS (status));
                            status = STATUS_CANCELLED;

                        } // if (!accept handle duplication succeeded)

                    } // if (!MDL mapping succeeded).
                }
                else {
                  status = STATUS_BUFFER_TOO_SMALL;
                }
            }
            else {
                status = STATUS_INVALID_HANDLE;
            }
            UPDATE_ENDPOINT2 (acceptEndpoint, 
                            "AfdSanConnectHandler, Superaccept failed with status: 0x%lX",
                            status);
            AfdCleanupSuperAccept (acceptIrp, status);
            IoCompleteRequest (acceptIrp, AfdPriorityBoost);
        }
    }
    else {
        //
        // We have little choice but create an extra connection
        // on the fly since regular connection are posted to
        // the transport as TDI_LISTENs.
        //

        status = AfdCreateConnection(
                     listenEndpoint->TransportInfo,
                     listenEndpoint->AddressHandle,
                     IS_TDI_BUFFERRING(listenEndpoint),
                     listenEndpoint->InLine,
                     listenEndpoint->OwningProcess,
                     &connection
                     );
        if (!NT_SUCCESS (status)) {
            goto complete;
        }

        InterlockedDecrement (
            &listenEndpoint->Common.VcListening.FailedConnectionAdds);
    }


    if (connection!=NULL) {
        LIST_ENTRY  irpList;

        ASSERT (connection->Endpoint == NULL);

        if ( connection->RemoteAddress != NULL &&
                 connection->RemoteAddressLength < (ULONG)RemoteAddressLength ) {

            AFD_RETURN_REMOTE_ADDRESS(
                connection->RemoteAddress,
                connection->RemoteAddressLength
                );
            connection->RemoteAddress = NULL;
        }

        if ( connection->RemoteAddress == NULL ) {

            connection->RemoteAddress = AFD_ALLOCATE_REMOTE_ADDRESS (RemoteAddressLength);
            if (connection->RemoteAddress==NULL) {
                AfdSanReleaseConnection (listenEndpoint, connection, TRUE);
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto complete;
            }
        }

        connection->RemoteAddressLength = RemoteAddressLength;

        RtlMoveMemory(
            connection->RemoteAddress,
            &connectInfo->RemoteAddress,
            RemoteAddressLength
            );

        //
        // We just got a connection without AcceptEx IRP
        // We'll have to queue the IRP, setup cancel routine and pend it
        //

        AfdAcquireSpinLock (&listenEndpoint->SpinLock, &lockHandle);
        //
        // Setup the connection, so cancel routine can 
        // operate on it properly.
        //
        connection->ConnectIrp = NULL;
        IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = connection;

        IoSetCancelRoutine (Irp, AfdSanCancelConnect);

        if (Irp->Cancel) {
            if (IoSetCancelRoutine (Irp, NULL)==NULL) {
                KIRQL cancelIrql;
                AfdReleaseSpinLock (&listenEndpoint->SpinLock, &lockHandle);
                //
                // Cancel routine is running, let it complete
                //
                IoAcquireCancelSpinLock (&cancelIrql);
                IoReleaseCancelSpinLock (cancelIrql);
            }
            else {
                AfdReleaseSpinLock (&listenEndpoint->SpinLock, &lockHandle);
            }

            AfdSanReleaseConnection (listenEndpoint, connection, TRUE);
            status = STATUS_CANCELLED;
            goto complete;
        }

        IoMarkIrpPending (Irp);

        connection->Endpoint = listenEndpoint;
        REFERENCE_ENDPOINT (listenEndpoint);

        connection->ConnectIrp = Irp;
        connection->SanConnection = TRUE;


        connection->State = AfdConnectionStateUnaccepted;

        InitializeListHead (&irpList);

        //
        // Try to find AcceptEx or Listen IRP to complete.
        //
        while (1) {
            PIRP    waitForListenIrp;

            if (!IS_DELAYED_ACCEPTANCE_ENDPOINT (listenEndpoint)) {
                if (AfdServiceSuperAccept (listenEndpoint, connection, &lockHandle, &irpList)) {
                    goto CompleteIrps;
                }
            }
            

            //
            // Complete listen IRPs until we find the one that has enough space
            // for the remote address.
            //
            if (IsListEmpty( &listenEndpoint->Common.VcListening.ListeningIrpListHead ) )
                break;


            //
            // Get a pointer to the current IRP, and get a pointer to the
            // current stack lockation.
            //

            waitForListenIrp = CONTAINING_RECORD(
                                   listenEndpoint->Common.VcListening.ListeningIrpListHead.Flink,
                                   IRP,
                                   Tail.Overlay.ListEntry
                                   );

            //
            // Take the first IRP off the listening list.
            //

            RemoveEntryList(
                            &waitForListenIrp->Tail.Overlay.ListEntry
                            );

            waitForListenIrp->Tail.Overlay.ListEntry.Flink = NULL;

            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdSanConnectHandler: completing IRP %lx\n",
                            waitForListenIrp ));
            }

            status = AfdServiceWaitForListen (waitForListenIrp,
                                                connection,
                                                &lockHandle);
            if (NT_SUCCESS (status)) {
                ObDereferenceObject (listenFileObject);
                return STATUS_PENDING;
            }

            //
            // Synchronize with cancel routine if it is running
            //
            if (IoSetCancelRoutine (waitForListenIrp, NULL)==NULL) {
                KIRQL cancelIrql;
                //
                // The cancel routine won't find the IRP on the list
                // Just make sure it completes before we complete the IRP.
                //
                IoAcquireCancelSpinLock (&cancelIrql);
                IoReleaseCancelSpinLock (cancelIrql);
            }
            IoCompleteRequest (waitForListenIrp, AfdPriorityBoost);
            AfdAcquireSpinLock (&listenEndpoint->SpinLock, &lockHandle);
        }

        //
        // At this point, we still hold the AFD spinlock.
        // and we could find matching listen request.
        // Put the connection on unaccepted list.
        //


        InsertTailList(
            &listenEndpoint->Common.VcListening.UnacceptedConnectionListHead,
            &connection->ListEntry
            );

        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanConnectHandler: unaccepted, conn-%p\n",
                        connection));
        }

        //
        // Listening endpoint is never a specifically SAN endpoint.
        // Poll/EventSelect events on it are handled like on a regular
        // TCP/IP endpoint - no need for special tricks like on connected/accepted
        // endpoints.
        //
        AfdIndicateEventSelectEvent(
            listenEndpoint,
            AFD_POLL_ACCEPT,
            STATUS_SUCCESS
            );
        AfdReleaseSpinLock (&listenEndpoint->SpinLock, &lockHandle);

        //
        // If there are outstanding polls waiting for a connection on this
        // endpoint, complete them.
        //

        AfdIndicatePollEvent(
            listenEndpoint,
            AFD_POLL_ACCEPT,
            STATUS_SUCCESS
                );

    CompleteIrps:
        //
        // Complete previously failed accept irps if any.
        //
        while (!IsListEmpty (&irpList)) {
            PIRP    irp;
            irp = CONTAINING_RECORD (irpList.Flink, IRP, Tail.Overlay.ListEntry);
            RemoveEntryList (&irp->Tail.Overlay.ListEntry);
            IoCompleteRequest (irp, AfdPriorityBoost);
        }
        ObDereferenceObject (listenFileObject);

        return STATUS_PENDING;
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    UPDATE_ENDPOINT2 (listenEndpoint, 
                        "AfdSanConnectHandler, accept failed with status: 0x%lX",
                        status);

complete:
 
    if (listenFileObject!=NULL) {
        ObDereferenceObject (listenFileObject);
    }
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, AfdPriorityBoost);

    return status;
}


NTSTATUS
AfdSanFastCompleteAccept (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
/*++

Routine Description:

    Completes the Accept operation initiated by the SAN provider

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_CMPL_ACCEPT)
    RequestorMode   - mode of the caller
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONTEXT_INFO)
                            SocketHandle    - handle of the accepting endpoint
                            SwitchContext   - switch context associated with the endpoint
    InputBufferLength - sizeof(AFD_SWITCH_CONTEXT_INFO)
    OutputBuffer    - data to copy into the AcceptEx receive buffer
    OutputBufferLength - size of received data
    Information     - pointer for buffer to place return information into, unused
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint or switch socket is of incorrect type
    STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
    STATIS_LOCAL_DISCONNECT - accept was aborted by the application.
    other - failed when attempting to access accept socket, input buffer, or switch context.

--*/
{
    NTSTATUS status;
    PIRP    acceptIrp;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PFILE_OBJECT    sanFileObject;
    AFD_SWITCH_CONTEXT_INFO contextInfo;
    PAFD_ENDPOINT   sanEndpoint, sanHlprEndpoint;
    PVOID   context;

    *Information = 0;

    AFD_W4_INIT status = STATUS_SUCCESS;
    try {

#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            PAFD_SWITCH_CONTEXT_INFO32  contextInfo32;
            if (InputBufferLength<sizeof (*contextInfo32)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (*contextInfo32),
                                PROBE_ALIGNMENT32 (AFD_SWITCH_CONTEXT_INFO32));
            }
            contextInfo32 = InputBuffer;
            contextInfo.SocketHandle = contextInfo32->SocketHandle;
            contextInfo.SwitchContext = UlongToPtr(contextInfo32->SwitchContext);
        }
        else
#endif _WIN64
        {

            if (InputBufferLength<sizeof (contextInfo)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }

            if (RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (contextInfo),
                                PROBE_ALIGNMENT (AFD_SWITCH_CONTEXT_INFO));
            }

            contextInfo = *((PAFD_SWITCH_CONTEXT_INFO)InputBuffer);
        }

        if (contextInfo.SwitchContext==NULL) {
            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AFD: Switch context is NULL in AfdSanFastCompleteAccept\n"));
            }
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }

        if (RequestorMode!=KernelMode) {
            ProbeForWrite (contextInfo.SwitchContext,
                            sizeof (*contextInfo.SwitchContext),
                            PROBE_ALIGNMENT (AFD_SWITCH_CONTEXT));
        }
    }
    except (AFD_EXCEPTION_FILTER (status)) {
        ASSERT (NT_ERROR (status));
        return status;
    }

    sanHlprEndpoint = FileObject->FsContext;
    ASSERT (IS_SAN_HELPER (sanHlprEndpoint));
    status = AfdSanReferenceSwitchSocketByHandle (
                            contextInfo.SocketHandle,
                            (IoctlCode>>14)&3,
                            RequestorMode,
                            sanHlprEndpoint,
                            contextInfo.SwitchContext,
                            &sanFileObject
                            );
    if (!NT_SUCCESS (status)) {
        return status;
    }
    sanEndpoint = sanFileObject->FsContext;

    //
    // Make sure that endpoints are of correct type
    //
    context = AfdLockEndpointContext (sanEndpoint);
    AfdAcquireSpinLock (&sanEndpoint->SpinLock, &lockHandle);
    if (!sanEndpoint->EndpointCleanedUp &&
         sanEndpoint->State==AfdEndpointStateOpen) {
        //
        // See if accept IRP is still there
        //
        if (!IsListEmpty (&sanEndpoint->Common.SanEndp.IrpList)) {
            AFD_SWITCH_CONTEXT  localContext = {0,0,0,0};

            acceptIrp = CONTAINING_RECORD (
                            sanEndpoint->Common.SanEndp.IrpList.Flink,
                            IRP,
                            Tail.Overlay.ListEntry);
            RemoveEntryList (&acceptIrp->Tail.Overlay.ListEntry);
            acceptIrp->Tail.Overlay.ListEntry.Flink = NULL;
            sanEndpoint->Common.SanEndp.SelectEventsActive = AFD_POLL_SEND;
            sanEndpoint->State = AfdEndpointStateConnected;
            sanEndpoint->DisableFastIoSend = TRUE;
            sanEndpoint->DisableFastIoRecv = TRUE;
            sanEndpoint->EnableSendEvent = TRUE;

            ASSERT (sanEndpoint->Common.SanEndp.LocalContext==NULL);
            sanEndpoint->Common.SanEndp.LocalContext = &localContext;
            AFD_END_STATE_CHANGE (sanEndpoint);
            AfdIndicateEventSelectEvent (sanEndpoint, AFD_POLL_SEND, STATUS_SUCCESS);
            AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
            AfdIndicatePollEvent (sanEndpoint, AFD_POLL_SEND, STATUS_SUCCESS);
            status = AfdSanPollMerge (sanEndpoint, &localContext);
            sanEndpoint->Common.SanEndp.LocalContext = NULL;

            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdFastSanCompleteAccept: endp-%p, irp-%p\n",
                            sanEndpoint,
                            acceptIrp));
            }



            if (IoSetCancelRoutine (acceptIrp, NULL)==NULL) {
                KIRQL cancelIrql;
                //
                // Irp is being cancelled, sync up with cancel routine
                //
                IoAcquireCancelSpinLock (&cancelIrql);
                IoReleaseCancelSpinLock (cancelIrql);
            }

            //
            // Copy receive data if passed and IRP has buffer for it
            //
            if ((OutputBufferLength>0) && (acceptIrp->MdlAddress!=NULL)) {
                AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
                try {
                    ULONG   bytesCopied;
                    NTSTATUS tdiStatus;
                    tdiStatus = TdiCopyBufferToMdl (
                                OutputBuffer,
                                0,
                                OutputBufferLength,
                                acceptIrp->MdlAddress,
                                0,
                                &bytesCopied);
                    ASSERT (NT_SUCCESS (tdiStatus));
                    *Information = bytesCopied;
                    acceptIrp->IoStatus.Information = bytesCopied;
                }
                except (AFD_EXCEPTION_FILTER (status)) {
                    ASSERT (NT_ERROR (status));
                    //
                    // Even if copy failed, we still have to complete
                    // the accept IRP because we have already removed
                    // cancel routine and modified endpoint state.
                    //
                }
            }
            else {
                acceptIrp->IoStatus.Information = 0;
            }

            acceptIrp->IoStatus.Status = status;
            //
            // Complete the accept IRP.
            //
            IoCompleteRequest (acceptIrp, AfdPriorityBoost);

            //
            // undo the references done in AfdAcceptCore()
            //
            ASSERT( InterlockedDecrement( &sanEndpoint->ObReferenceBias ) >= 0 );
            ObDereferenceObject (sanFileObject); 
        }
        else {
            AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
            status = STATUS_LOCAL_DISCONNECT;
        }

    }
    else {
        AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
        status = STATUS_INVALID_HANDLE;
    }
    AfdUnlockEndpointContext (sanEndpoint, context);
    

    UPDATE_ENDPOINT2 (sanEndpoint, "AfdSanFastCompletAccept, status: %lX", status);
    ObDereferenceObject (sanFileObject); // undo reference we did earlier in this routine
    return status;
}


//
// Macros to make request/context passing code readable.
//
#define AfdSanRequestInfo       Tail.Overlay
#define AfdSanRequestCtx        DriverContext[0]
#define AfdSanSwitchCtx         DriverContext[1]
#define AfdSanProcessId         DriverContext[2]
#define AfdSanHelperEndp        DriverContext[3]



NTSTATUS
FASTCALL
AfdSanRedirectRequest (
    IN PIRP    Irp,
    IN PIO_STACK_LOCATION  IrpSp
    )
/*++

Routine Description:

    Redirects file system Read/Write IRP to SAN provider

Arguments:

    Irp - the to be redirected.
    IrpSp - current stack location

Return Value:

    Status of the redirect operation.

--*/
{
    PAFD_ENDPOINT   sanEndpoint;
    NTSTATUS        status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    ULONG_PTR       requestInfo;
    ULONG           requestType;
    PVOID           requestCtx;
    BOOLEAN         postRequest;

    Irp->IoStatus.Information = 0;

    //
    // Get the endpoint and validate it.
    //
    sanEndpoint = IrpSp->FileObject->FsContext;

    //
    // Make sure Irp has not been cancelled meanwhile
    //
    AfdAcquireSpinLock (&sanEndpoint->SpinLock, &lockHandle);
    if (!IS_SAN_ENDPOINT (sanEndpoint) ||
            sanEndpoint->State!=AfdEndpointStateConnected) {
        AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
        status = STATUS_INVALID_CONNECTION;
        goto complete;
    }

    if (sanEndpoint->Common.SanEndp.CtxTransferStatus!=STATUS_PENDING &&
            sanEndpoint->Common.SanEndp.CtxTransferStatus!=STATUS_MORE_PROCESSING_REQUIRED) {
        if (!NT_SUCCESS (sanEndpoint->Common.SanEndp.CtxTransferStatus)) {
            status = sanEndpoint->Common.SanEndp.CtxTransferStatus;
            AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
            goto complete;
        }

        //
        // Get the request information based on IRP MJ code
        //
        switch (IrpSp->MajorFunction) {
        case IRP_MJ_READ:
            requestType = AFD_SWITCH_REQUEST_READ;
            requestInfo = IrpSp->Parameters.Read.Length;
            break;
        case IRP_MJ_WRITE:
            requestType = AFD_SWITCH_REQUEST_WRITE;
            requestInfo = IrpSp->Parameters.Write.Length;
            break;
        default:
            ASSERT (!"Unsupported IRP Major Function");
            status = STATUS_INVALID_DEVICE_REQUEST;
            AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
            goto complete;
        }

        //
        // Generate request context that uniquely identifies
        // it among other requests on the same endpoint.
        //
        requestCtx = AFD_SWITCH_MAKE_REQUEST_CONTEXT(
                            sanEndpoint->Common.SanEndp.RequestId,
                            requestType); 
        sanEndpoint->Common.SanEndp.RequestId += 1;

        //
        // Store the request context in the Irp and insert it into
        // the list
        //
        Irp->AfdSanRequestInfo.AfdSanRequestCtx = requestCtx;
        postRequest = TRUE;
        UPDATE_ENDPOINT2 (sanEndpoint, 
                "AfdSanRedirectRequest, pended request: 0x%lX",
                PtrToUlong (requestCtx));
    }
    else {
        postRequest = FALSE;
        AFD_W4_INIT requestInfo = 0;  // Depend on variable above, but compiler
        AFD_W4_INIT requestCtx = NULL;// does not see the connection.
        Irp->AfdSanRequestInfo.AfdSanRequestCtx = NULL;
        UPDATE_ENDPOINT2 (sanEndpoint,
                "AfdSanRedirectRequest, request suspended due to pending dup: 0x%lX",
                PtrToUlong (Irp));
    }

    IoSetCancelRoutine (Irp, AfdSanCancelRequest);
    if (Irp->Cancel) {
        //
        // Oops, let it go
        //
        Irp->Tail.Overlay.ListEntry.Flink = NULL;
        AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
        if (IoSetCancelRoutine (Irp, NULL)==NULL) {
            KIRQL cancelIrql;
            //
            // Cancel routine must be running, make sure
            // it complete before we complete the IRP
            //
            IoAcquireCancelSpinLock (&cancelIrql);
            IoReleaseCancelSpinLock (cancelIrql);
        }
        status = STATUS_CANCELLED;
        goto complete;
    }
    
    //
    // We are going to pend this IRP, mark it so
    //
    IoMarkIrpPending (Irp);

    InsertTailList (&sanEndpoint->Common.SanEndp.IrpList,
                    &Irp->Tail.Overlay.ListEntry);
    AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);

    IF_DEBUG(SAN_SWITCH) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSanRedirectRequest: endp-%p, irp-%p, context-%p\n",
                    sanEndpoint, Irp, requestCtx));
    }

    if (postRequest) {
        status = AfdSanNotifyRequest (sanEndpoint, requestCtx, STATUS_SUCCESS, requestInfo);
        if (!NT_SUCCESS (status)) {
            PIRP    irp;
            //
            // If notification failed, fail the request.
            // Note that we cannot return the failure status directly
            // as we already marked IRP as pending. Also, the IRP
            // could have been cancelled, so we have to search for
            // it in the list.
            //
            irp = AfdSanDequeueRequest (sanEndpoint, requestCtx);
            if (irp!=NULL) {
                ASSERT (irp==Irp);
                irp->IoStatus.Status = status;
                IoCompleteRequest (irp, AfdPriorityBoost);
            }
        }
    }

    return STATUS_PENDING;

complete:
    //
    // Failure before we queued the IRP, complete and return
    // status to the caller.
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, AfdPriorityBoost);
    return status;
}

NTSTATUS
AfdSanFastCompleteRequest (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
/*++

Routine Description:

    Completes the redirected read/write request processed by SAN provider

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_CMPL_ACCEPT)
    RequestorMode   - mode of the caller
    InputBuffer     - input parameters for the operation (AFD_SWITCH_REQUEST_INFO)
                        SocketHandle - SAN endpoint on which to complete the request
                        SwitchContext - switch context associated with endpoint 
                                            to validate the handle-endpoint association
                        RequestContext - value that identifies the request to complete
                        RequestStatus - status with which to complete the request (
                                        STATUS_PENDING has special meaning, request
                                        is not completed - merely data is copied)
                        DataOffset - offset in the request buffer to read/write the data
    InputBufferLength - sizeof (AFD_SWITCH_REQUEST_INFO)

    OutputBuffer - switch buffer to read/write data
    OutputBufferLength - length of the buffer
    Information     - pointer to buffer to return number of bytes copied

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper or SAN endpoint is of incorrect type
    STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
    STATUS_CANCELLED - request to be completed has already been cancelled
    other - failed when attempting to access SAN endpoint, input buffer or output buffers.
--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION  irpSp;
    PIRP    irp;
    ULONG   bytesCopied;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PFILE_OBJECT    sanFileObject;
    AFD_SWITCH_REQUEST_INFO requestInfo;
    PAFD_ENDPOINT   sanEndpoint, sanHlprEndpoint;

    *Information = 0;

    AFD_W4_INIT status = STATUS_SUCCESS;
    try {

#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            PAFD_SWITCH_REQUEST_INFO32  requestInfo32;
            if (InputBufferLength<sizeof (*requestInfo32)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (*requestInfo32),
                                PROBE_ALIGNMENT32 (AFD_SWITCH_REQUEST_INFO32));
            }
            requestInfo32 = InputBuffer;
            requestInfo.SocketHandle = requestInfo32->SocketHandle;
            requestInfo.SwitchContext = UlongToPtr(requestInfo32->SwitchContext);
            requestInfo.RequestContext = UlongToPtr(requestInfo32->RequestContext);
            requestInfo.RequestStatus = requestInfo32->RequestStatus;
            requestInfo.DataOffset = requestInfo32->DataOffset;
        }
        else
#endif _WIN64
        {

            if (InputBufferLength<sizeof (requestInfo)) {
                return STATUS_INVALID_PARAMETER;
            }

            if (RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (requestInfo),
                                PROBE_ALIGNMENT (AFD_SWITCH_REQUEST_INFO));
            }

            requestInfo = *((PAFD_SWITCH_REQUEST_INFO)InputBuffer);
        }



        if (requestInfo.SwitchContext==NULL) {
            IF_DEBUG(SAN_SWITCH) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AFD: Switch context is NULL in AfdSanFastCompleteRequest\n"));
            }
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }
    }
    except (AFD_EXCEPTION_FILTER (status)) {
        ASSERT (NT_ERROR (status));
        return status;
    }

    sanHlprEndpoint = FileObject->FsContext;
    ASSERT (IS_SAN_HELPER (sanHlprEndpoint));
    status = AfdSanReferenceSwitchSocketByHandle (
                            requestInfo.SocketHandle,
                            (IoctlCode>>14)&3,
                            RequestorMode,
                            sanHlprEndpoint,
                            requestInfo.SwitchContext,
                            &sanFileObject
                            );
    if (!NT_SUCCESS (status)) {
        return status;
    }
    sanEndpoint = sanFileObject->FsContext;



    //
    // Find and dequeue the request in question
    //
    irp = AfdSanDequeueRequest (sanEndpoint, requestInfo.RequestContext);
    if (irp!=NULL)  {
        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanFastCompleteRequest: endp-%p, irp-%p, context-%p, status-%lx\n",
                        sanEndpoint, irp,
                        requestInfo.RequestContext,
                        requestInfo.RequestStatus));
        }
        //
        // Expect the operation to succeed
        //
        AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);

        //
        // Get IRP stack location and perform data copy
        //
        irpSp = IoGetCurrentIrpStackLocation (irp);
        switch (irpSp->MajorFunction) {
        case IRP_MJ_READ:
            //
            // Read request, data is copied from switch buffer
            // to the request MDL
            //
            ASSERT (AFD_SWITCH_REQUEST_TYPE(requestInfo.RequestContext)==AFD_SWITCH_REQUEST_READ);
            if (NT_SUCCESS (requestInfo.RequestStatus)) {
                if (irp->MdlAddress!=NULL &&
                        MmGetMdlByteCount (irp->MdlAddress)>requestInfo.DataOffset) {
                    try {
                        if (RequestorMode!=KernelMode) {
                            ProbeForRead (OutputBuffer,
                                            OutputBufferLength,
                                            sizeof (UCHAR));
                        }
                        status = TdiCopyBufferToMdl (
                                    OutputBuffer,
                                    0,
                                    OutputBufferLength,
                                    irp->MdlAddress,
                                    requestInfo.DataOffset,
                                    &bytesCopied
                                    );
                        *Information = bytesCopied;
                        ASSERT (irp->IoStatus.Information==requestInfo.DataOffset);
                        irp->IoStatus.Information += bytesCopied;
                    }
                    except (AFD_EXCEPTION_FILTER (status)) {
                        ASSERT (NT_ERROR (status));
                    }
                }
                else if (irp->MdlAddress==NULL && 
                            requestInfo.DataOffset==0 &&
                            OutputBufferLength==0) {
                    ASSERT (irp->IoStatus.Information==0);
                    ASSERT (status==STATUS_SUCCESS);
                }
                else {
                    //
                    // Indicate to the switch that offset
                    // is outside of the buffer
                    //
                    status = STATUS_INVALID_PARAMETER;
                }
            }
            break;
        case IRP_MJ_WRITE:
            //
            // Write request, data is copied to switch buffer
            // from the request MDL
            //
            ASSERT (AFD_SWITCH_REQUEST_TYPE(requestInfo.RequestContext)==AFD_SWITCH_REQUEST_WRITE);
            if (NT_SUCCESS (requestInfo.RequestStatus)) {
                if (irp->MdlAddress!=NULL &&
                        MmGetMdlByteCount (irp->MdlAddress)>requestInfo.DataOffset) {
                    try {
                        if (RequestorMode!=KernelMode) {
                            ProbeForWrite (OutputBuffer,
                                            OutputBufferLength,
                                            sizeof (UCHAR));
                        }
                        status = TdiCopyMdlToBuffer (
                                        irp->MdlAddress,
                                        requestInfo.DataOffset,
                                        OutputBuffer,
                                        0,
                                        OutputBufferLength,
                                        &bytesCopied
                                        );
                        *Information = bytesCopied;
                        ASSERT (irp->IoStatus.Information==requestInfo.DataOffset);
                        irp->IoStatus.Information += bytesCopied;
                    }
                    except (AFD_EXCEPTION_FILTER (status)) {
                        ASSERT (NT_ERROR (status));
                    }
                }
                else if (irp->MdlAddress==NULL && 
                            requestInfo.DataOffset==0 &&
                            OutputBufferLength==0) {
                    ASSERT (irp->IoStatus.Information==0);
                    ASSERT (status==STATUS_SUCCESS);
                }
                else {
                    //
                    // Indicate to the switch that offset
                    // is outside of the buffer
                    //
                    status = STATUS_INVALID_PARAMETER;
                }
            }
            break;

        default:
            ASSERT (!"Unsupported IRP Major Function");
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        //
        // If switch did not ask to pend the request, complete it
        //
        if (NT_SUCCESS (status) && requestInfo.RequestStatus!=STATUS_PENDING) {
            //
            // Prepeare the request for completion
            //
            irp->IoStatus.Status = AfdValidateStatus (requestInfo.RequestStatus);
            IoCompleteRequest (irp, AfdPriorityBoost);
        }
        else {
            //
            // Otherwise, put it back into the queue
            //
            AfdAcquireSpinLock (&sanEndpoint->SpinLock, &lockHandle);
            IoSetCancelRoutine (irp, AfdSanCancelRequest);
            //
            // Of course, we need to make sure that request
            // was not cancelled while we were processing it.
            //
            if (!irp->Cancel) {
                InsertHeadList (&sanEndpoint->Common.SanEndp.IrpList,
                                    &irp->Tail.Overlay.ListEntry);
                AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
            }
            else {
                //
                // Request has already been cancelled
                //
                ASSERT (irp->Tail.Overlay.ListEntry.Flink == NULL);
                AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
                if (IoSetCancelRoutine (irp, NULL)==NULL) {
                    KIRQL cancelIrql;
                    //
                    // Cancel routine is running, synchronize with
                    // it
                    //
                    IoAcquireCancelSpinLock (&cancelIrql);
                    IoReleaseCancelSpinLock (cancelIrql);
                }
                //
                // Complete the request and indicate to the
                // switch that it was cancelled
                //
                irp->IoStatus.Status = STATUS_CANCELLED;
                IoCompleteRequest (irp, AfdPriorityBoost);
                status = STATUS_CANCELLED;
            }
        }
    }
    else {
        //
        // Could not find the request, it must have been
        // cancelled already
        //
        status = STATUS_CANCELLED;
    }

    UPDATE_ENDPOINT2 (sanEndpoint, "AfdSanFastCompleteRequest, status: 0x%lX", status);
    ObDereferenceObject (sanFileObject);
    return status;
}

NTSTATUS
AfdSanFastCompleteIo (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
/*++

Routine Description:

    Simulates async IO completion for the switch.

Arguments:
    FileObject      - SAN endpoint on which to complete the IO
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_CMPL_IO)
    RequestorMode   - mode of the caller
    InputBuffer     - input parameters for the operation (IO_STATUS_BLOCK)
                        Status - final operation status
                        Information - associated information (number of bytes 
                                        transferred to/from request buffer(s))
    InputBufferLength - sizeof (IO_STATUS_BLOCK)

    OutputBuffer - unused
    OutputBufferLength - unused
    Information     - pointer to buffer to return number of bytes transferred

Return Value:
    STATUS_INVALID_PARAMETER - input buffer is of invalid size.
    other - status of the IO operation or failure code when attempting to access input buffer.
--*/
{
    NTSTATUS    status;

#if !DBG
    UNREFERENCED_PARAMETER (FileObject);
#endif
    UNREFERENCED_PARAMETER (IoctlCode);
    UNREFERENCED_PARAMETER (OutputBuffer);
    UNREFERENCED_PARAMETER (OutputBufferLength);

    PAGED_CODE ();
#ifdef _WIN64
    if (IoIs32bitProcess (NULL)) {
        if (InputBufferLength>=sizeof (IO_STATUS_BLOCK32)) {

            // Carefully write status info
            AFD_W4_INIT status = STATUS_SUCCESS;
            try {
                if (RequestorMode!=KernelMode) {
                    ProbeForReadSmallStructure (InputBuffer,
                                    sizeof (IO_STATUS_BLOCK32),
                                    PROBE_ALIGNMENT32 (IO_STATUS_BLOCK32));
                }
                *Information = ((PIO_STATUS_BLOCK32)InputBuffer)->Information;
                status = AfdValidateStatus (((PIO_STATUS_BLOCK32)InputBuffer)->Status);
            }
            except (AFD_EXCEPTION_FILTER (status)) {
                ASSERT (NT_ERROR (status));
            }
        }
        else {
            status = STATUS_INVALID_PARAMETER;
        }
    }
    else
#endif //_WIN64
    {

        if (InputBufferLength>=sizeof (IO_STATUS_BLOCK)) {

            // Carefully write status info
            AFD_W4_INIT status = STATUS_SUCCESS;
            try {
                if (RequestorMode!=KernelMode) {
                    ProbeForReadSmallStructure (InputBuffer,
                                    sizeof (IO_STATUS_BLOCK),
                                    PROBE_ALIGNMENT (IO_STATUS_BLOCK));
                }
                *Information = ((PIO_STATUS_BLOCK)InputBuffer)->Information;
                status = AfdValidateStatus (((PIO_STATUS_BLOCK)InputBuffer)->Status);
            }
            except (AFD_EXCEPTION_FILTER (status)) {
                ASSERT (NT_ERROR (status));
            }
        }
        else {
            status = STATUS_INVALID_PARAMETER;
        }
    }

    UPDATE_ENDPOINT2 (FileObject->FsContext, "AfdSanFastCompletIo, status: 0x%lX", status);
    return status;
}

NTSTATUS
AfdSanFastRefreshEndpoint (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
/*++

Routine Description:

    Refreshes endpoint so it can be used again in AcceptEx

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_REFRESH_ENDP)
    RequestorMode   - mode of the caller
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONTEXT_INFO)
                        SocketHandle - SAN endpoint on which to referesh
                        SwitchContext - switch context associated with endpoint 
                                            to validate the handle-endpoint association
    InputBufferLength - unused
    OutputBuffer    - unused
    OutputBufferLength - unused
    Information     - pointer for buffer to place return information into, unused
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint or switch socket is of incorrect type
    other - failed when attempting to access SAN socket.
--*/
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    KIRQL              oldIrql;
    NTSTATUS    status;
    PFILE_OBJECT    sanFileObject;
    AFD_SWITCH_CONTEXT_INFO contextInfo;
    PAFD_ENDPOINT   sanEndpoint, sanHlprEndpoint;
    PVOID   context;

    UNREFERENCED_PARAMETER (OutputBuffer);
    UNREFERENCED_PARAMETER (OutputBufferLength);

    *Information = 0;

    AFD_W4_INIT status = STATUS_SUCCESS;
    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            PAFD_SWITCH_CONTEXT_INFO32  contextInfo32;
            if (InputBufferLength<sizeof (*contextInfo32)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (*contextInfo32),
                                PROBE_ALIGNMENT32 (AFD_SWITCH_CONTEXT_INFO32));
            }
            contextInfo32 = InputBuffer;
            contextInfo.SocketHandle = contextInfo32->SocketHandle;
            contextInfo.SwitchContext = UlongToPtr(contextInfo32->SwitchContext);
        }
        else
#endif _WIN64
        {

            if (InputBufferLength<sizeof (contextInfo)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }

            if (RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (contextInfo),
                                PROBE_ALIGNMENT (AFD_SWITCH_CONTEXT_INFO));
            }

            contextInfo = *((PAFD_SWITCH_CONTEXT_INFO)InputBuffer);
        }

        if (contextInfo.SwitchContext==NULL) {
            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AFD: Switch context is NULL in AfdSanFastRefereshEndpoint\n"));
            }
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }
        if (RequestorMode!=KernelMode) {
            ProbeForWrite (contextInfo.SwitchContext,
                            sizeof (*contextInfo.SwitchContext),
                            PROBE_ALIGNMENT (AFD_SWITCH_CONTEXT));
        }
    }
    except (AFD_EXCEPTION_FILTER (status)) {
        ASSERT (NT_ERROR (status));
        return status;
    }


    sanHlprEndpoint = FileObject->FsContext;
    ASSERT (IS_SAN_HELPER (sanHlprEndpoint));
    status = AfdSanReferenceSwitchSocketByHandle (
                            contextInfo.SocketHandle,
                            (IoctlCode>>14)&3,
                            RequestorMode,
                            sanHlprEndpoint,
                            contextInfo.SwitchContext,
                            &sanFileObject
                            );
    if (!NT_SUCCESS (status)) {
        return status;
    }
    sanEndpoint = sanFileObject->FsContext;

    if (!AFD_START_STATE_CHANGE (sanEndpoint, sanEndpoint->State)) {
        goto complete;
    }


    context = AfdLockEndpointContext (sanEndpoint);

    //
    // Just make sure that endpoints are of correct type
    // and in correct state
    //
    KeRaiseIrql (DISPATCH_LEVEL, &oldIrql);
    AfdAcquireSpinLockAtDpcLevel (&sanEndpoint->SpinLock, &lockHandle);
    if (!sanEndpoint->EndpointCleanedUp &&
          sanEndpoint->State==AfdEndpointStateConnected) {

        //
        // Reset the state so we can't get anymore IRPs
        //
        sanEndpoint->State = AfdEndpointStateTransmitClosing;

        //
        // Cleanup all IRPs on the endpoint.
        //

        if (!IsListEmpty (&sanEndpoint->Common.SanEndp.IrpList)) {
            PIRP    irp;
            PDRIVER_CANCEL  cancelRoutine;
            KIRQL cancelIrql;
            AfdReleaseSpinLockFromDpcLevel (&sanEndpoint->SpinLock, &lockHandle);

            //
            // Acquire cancel spinlock and endpoint spinlock in
            // this order and recheck the IRP list
            //
            IoAcquireCancelSpinLock (&cancelIrql);
            ASSERT (cancelIrql==DISPATCH_LEVEL);
            AfdAcquireSpinLockAtDpcLevel (&sanEndpoint->SpinLock, &lockHandle);

            //
            // While list is not empty attempt to cancel the IRPs
            //
            while (!IsListEmpty (&sanEndpoint->Common.SanEndp.IrpList)) {
                irp = CONTAINING_RECORD (
                        sanEndpoint->Common.SanEndp.IrpList.Flink,
                        IRP,
                        Tail.Overlay.ListEntry);
                //
                // Reset the cancel routine.
                //
                cancelRoutine = IoSetCancelRoutine (irp, NULL);
                if (cancelRoutine!=NULL) {
                    //
                    // Cancel routine was not NULL, cancel it here.
                    // If someone else attempts to complete this IRP
                    // it will have to wait at least until cancel
                    // spinlock is released, so we can release
                    // the endpoint spinlock
                    //
                    AfdReleaseSpinLockFromDpcLevel (&sanEndpoint->SpinLock, &lockHandle);
                    irp->CancelIrql = DISPATCH_LEVEL;
                    irp->Cancel = TRUE;
                    (*cancelRoutine) (AfdDeviceObject, irp);
                }
                else {
                    IoAcquireCancelSpinLock (&cancelIrql);
                    ASSERT (cancelIrql==DISPATCH_LEVEL);
                    AfdAcquireSpinLockAtDpcLevel (&sanEndpoint->SpinLock, &lockHandle);
                }
            }
            IoReleaseCancelSpinLock (DISPATCH_LEVEL);
        }


        ASSERT (sanEndpoint->Common.SanEndp.SanHlpr!=NULL);
        DEREFERENCE_ENDPOINT (sanEndpoint->Common.SanEndp.SanHlpr);

        //
        // Make sure we cleanup all the fields since they will be
        // treated as other part (VC) of the endpoint union.
        //
        RtlZeroMemory (&sanEndpoint->Common.SanEndp,
                        sizeof (sanEndpoint->Common.SanEndp));


        //
        // Reinitialize the endpoint structure.
        //

        sanEndpoint->Type = AfdBlockTypeEndpoint;
        if (sanEndpoint->AddressFileObject!=NULL) {
            //
            // This is TransmitFile after SuperConnect
            //
            sanEndpoint->State = AfdEndpointStateBound;
        }
        else {
            //
            // This is TransmitFile after SuperAccept
            //
            sanEndpoint->State = AfdEndpointStateOpen;
        }
        sanEndpoint->DisconnectMode = 0;
        sanEndpoint->EndpointStateFlags = 0;
        sanEndpoint->EventsActive = 0;

        AfdRecordEndpointsReused ();
        status = STATUS_SUCCESS;


    }
    else {
        status = STATUS_INVALID_HANDLE;
    }
    AfdReleaseSpinLockFromDpcLevel (&sanEndpoint->SpinLock, &lockHandle);
    KeLowerIrql (oldIrql);

    AfdUnlockEndpointContext (sanEndpoint, context);
    
    AFD_END_STATE_CHANGE (sanEndpoint);

complete:
    UPDATE_ENDPOINT2 (sanEndpoint, "AfdSanFastRefreshEndpoint, status: 0x%lX", status);
    ObDereferenceObject( sanFileObject );
    return status;
}


NTSTATUS
AfdSanFastGetPhysicalAddr (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
/*++

Routine Description:

    Returns physical address corresponding to provided virtual address.

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_GET_PHYSICAL_ADDR)
    RequestorMode   - mode of the caller
    InputBuffer     - user mode virtual address
    InputBufferLength - access mode
    OutputBuffer    - Buffer to place physical address into.
    OutputBufferLength - sizeof (PHYSICAL_ADDRESS)
    Information     - pointer for buffer to place the size of the return information into
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint is of incorrect type
    STATUS_INVALID_PARAMETER - invalid access mode.
    STATUS_BUFFER_TOO_SMALL - output buffer is of incorrect size.
    other - failed when attempting to access input virtual address or output buffer.
--*/
{
#ifndef TEST_RDMA_CACHE
    UNREFERENCED_PARAMETER (FileObject);
    UNREFERENCED_PARAMETER (IoctlCode);
    UNREFERENCED_PARAMETER (RequestorMode);
    UNREFERENCED_PARAMETER (InputBuffer);
    UNREFERENCED_PARAMETER (InputBufferLength);
    UNREFERENCED_PARAMETER (OutputBuffer);
    UNREFERENCED_PARAMETER (OutputBufferLength);
    UNREFERENCED_PARAMETER (Information);
    return STATUS_INVALID_PARAMETER;
#else
    NTSTATUS status;
    PVOID           Va;         // virtual address
    ULONG accessMode;
    PAFD_ENDPOINT   sanHlprEndpoint;

    PAGED_CODE ();
    *Information = 0;
    Va = InputBuffer;
    accessMode = InputBufferLength;

    if (accessMode!=MEM_READ_ACCESS &&
        accessMode!=MEM_WRITE_ACCESS) {
        return STATUS_INVALID_PARAMETER;
    }

    if (OutputBufferLength<sizeof(PHYSICAL_ADDRESS)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    sanHlprEndpoint = FileObject->FsContext;

    if (!IS_SAN_HELPER(sanHlprEndpoint) ||
                 sanHlprEndpoint->OwningProcess!=IoGetCurrentProcess ()) {
        return STATUS_INVALID_HANDLE;
    }

    AFD_W4_INIT status = STATUS_SUCCESS;
    try {
        if (RequestorMode!=KernelMode) {
            //
            // Do some verification on the app buffer. Make sure it is
            // mapped and that it is a user-mode address with appropriate
            // read or write permissions
            //
            if (accessMode == MEM_READ_ACCESS) {
                ProbeAndReadChar ((PCHAR)Va);
            }
            else {
                ProbeForWriteChar ((PCHAR)Va);
            }
        }
        //
        // Validate the output structure if it comes from the user mode
        // application
        //

        if (RequestorMode != KernelMode ) {
            ASSERT(sizeof(PHYSICAL_ADDRESS) == sizeof(QUAD));
            ProbeForWriteQuad ((PQUAD)OutputBuffer);
        }

        *(PPHYSICAL_ADDRESS)OutputBuffer = MmGetPhysicalAddress(Va);

        *Information = sizeof(PHYSICAL_ADDRESS);
        status = STATUS_SUCCESS;

    } except( AFD_EXCEPTION_FILTER (status) ) {
        ASSERT (NT_ERROR (status));
    }

    UPDATE_ENDPOINT2 (sanHlprEndpoint, "AfdSanGetPhysicalAddress, status: 0x%lX", status);
    return status;
#endif // 0
}


NTSTATUS
AfdSanFastGetServicePid (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
/*++

Routine Description:

    Returns PID of SAN service process.

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_GET_PHYSICAL_ADDR)
    RequestorMode   - mode of the caller
    InputBuffer     - NULL, ignored
    InputBufferLength - 0, ignored
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
    Information     - pointer to buffer to return pid of the SAN service process
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint is of incorrect type
--*/
{
    PAFD_ENDPOINT   sanHlprEndpoint;

    UNREFERENCED_PARAMETER (IoctlCode);
    UNREFERENCED_PARAMETER (RequestorMode);
    UNREFERENCED_PARAMETER (InputBuffer);
    UNREFERENCED_PARAMETER (InputBufferLength);
    UNREFERENCED_PARAMETER (OutputBuffer);
    UNREFERENCED_PARAMETER (OutputBufferLength);

    PAGED_CODE ();
    *Information = 0;

    sanHlprEndpoint = FileObject->FsContext;

    if (!IS_SAN_HELPER(sanHlprEndpoint) ||
                 sanHlprEndpoint->OwningProcess!=IoGetCurrentProcess ()) {
        return STATUS_INVALID_HANDLE;
    }

    *Information = (ULONG_PTR)AfdSanServicePid;
    UPDATE_ENDPOINT2 (sanHlprEndpoint,
                        "AfdSanFastGetServicePid, pid: 0x%lX", 
                        HandleToUlong (AfdSanServicePid));
    return STATUS_SUCCESS;
}

NTSTATUS
AfdSanFastSetServiceProcess (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
/*++

Routine Description:

    Set the service helper endpoint

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_GET_PHYSICAL_ADDR)
    RequestorMode   - mode of the caller
    InputBuffer     - NULL, ignored
    InputBufferLength - 0, ignored
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
    Information     - 0, ignored
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint is of incorrect type
    STATUS_ACCESS_DENIED - process is not priviliged enough to become service process.
    STATUS_ADDRESS_ALREADY_EXISTS - service process has already registered.
--*/
{
    NTSTATUS status;
    PAFD_ENDPOINT   sanHlprEndpoint;

    UNREFERENCED_PARAMETER (IoctlCode);
    UNREFERENCED_PARAMETER (RequestorMode);
    UNREFERENCED_PARAMETER (InputBuffer);
    UNREFERENCED_PARAMETER (InputBufferLength);
    UNREFERENCED_PARAMETER (OutputBuffer);
    UNREFERENCED_PARAMETER (OutputBufferLength);
    PAGED_CODE ();
    *Information = 0;

    sanHlprEndpoint = FileObject->FsContext;

    if (!IS_SAN_HELPER(sanHlprEndpoint) ||
                 sanHlprEndpoint->OwningProcess!=IoGetCurrentProcess ()) {
        return STATUS_INVALID_HANDLE;
    }

    if (!sanHlprEndpoint->AdminAccessGranted) {
        return STATUS_ACCESS_DENIED;
    }


    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );
    if (AfdSanServiceHelper==NULL) {
        AfdSanServiceHelper = sanHlprEndpoint;
        AfdSanServicePid = PsGetCurrentProcessId ();
        status = STATUS_SUCCESS;
    }
    else if (AfdSanServiceHelper==sanHlprEndpoint) {
        ASSERT (FileObject->LockOperation == TRUE);
        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_ADDRESS_ALREADY_EXISTS;
    }

    ExReleaseResourceLite (AfdResource);
    KeLeaveCriticalRegion ();
    UPDATE_ENDPOINT2 (sanHlprEndpoint, "AfdSanFastSetServiceProcess, status: 0x%lX", status);
    return status;
}

NTSTATUS
AfdSanFastProviderChange (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
/*++

Routine Description:

    Notifies interested processes of SAN provider addition/deletion/change

Arguments:
    FileObject      - SAN helper object for the service process communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_PROVIDER_CHANGE)
    RequestorMode   - mode of the caller
    InputBuffer     - NULL, ignored
    InputBufferLength - 0, ignored
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
    Information     - 0, ignored
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint is of incorrect type
    STATUS_ACCESS_DENIED - helper endpoint is not for the service process.
--*/
{
    PAFD_ENDPOINT           sanHlprEndpoint;

    UNREFERENCED_PARAMETER (IoctlCode);
    UNREFERENCED_PARAMETER (RequestorMode);
    UNREFERENCED_PARAMETER (InputBuffer);
    UNREFERENCED_PARAMETER (InputBufferLength);
    UNREFERENCED_PARAMETER (OutputBuffer);
    UNREFERENCED_PARAMETER (OutputBufferLength);

    *Information = 0;

    sanHlprEndpoint = FileObject->FsContext;

    if (!IS_SAN_HELPER(sanHlprEndpoint) ||
                 sanHlprEndpoint->OwningProcess!=IoGetCurrentProcess ()) {
        return STATUS_INVALID_HANDLE;
    }

    if (sanHlprEndpoint!=AfdSanServiceHelper) {
        return STATUS_ACCESS_DENIED;
    }

    UPDATE_ENDPOINT2 (sanHlprEndpoint,
                        "AfdSanFastProviderChange, seq num: 0x%lX",
                        AfdSanProviderListSeqNum);

    AfdSanProcessAddrListForProviderChange (NULL);

    return STATUS_SUCCESS;
}

NTSTATUS
FASTCALL
AfdSanAddrListChange (
    IN PIRP    Irp,
    IN PIO_STACK_LOCATION  IrpSp
    )
/*++

Routine Description:

    Processes address SAN list change IRP
    Notifies both of address list changes and SAN
    provider changes.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
    PAFD_ENDPOINT   sanHlprEndpoint;
    NTSTATUS        status;
    sanHlprEndpoint = IrpSp->FileObject->FsContext;

    if (IS_SAN_HELPER(sanHlprEndpoint) &&
                 sanHlprEndpoint->OwningProcess==IoGetCurrentProcess ()) {

        if (AfdSanProviderListSeqNum==0 ||
                sanHlprEndpoint->Common.SanHlpr.Plsn==AfdSanProviderListSeqNum) {
            status = AfdAddressListChange (Irp, IrpSp);
            if (AfdSanProviderListSeqNum==0 ||
                    sanHlprEndpoint->Common.SanHlpr.Plsn==AfdSanProviderListSeqNum) {
                UPDATE_ENDPOINT (sanHlprEndpoint);
            }
            else {
                AfdSanProcessAddrListForProviderChange (sanHlprEndpoint);
            }
            return status;
        }
        else {

            sanHlprEndpoint->Common.SanHlpr.Plsn = AfdSanProviderListSeqNum;
            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sanHlprEndpoint->Common.SanHlpr.Plsn;
            UPDATE_ENDPOINT2 (sanHlprEndpoint,
                                "AfdSanAddrListChange, new plsn: 0x%lX", 
                                sanHlprEndpoint->Common.SanHlpr.Plsn);
        }
    }
    else {
        status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;
        UPDATE_ENDPOINT2 (sanHlprEndpoint, "AfdSanAddrListChange invalid helper: 0x%lX", status);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, AfdPriorityBoost);

    return status;
}

NTSTATUS
FASTCALL
AfdSanAcquireContext (
    IN PIRP    Irp,
    IN PIO_STACK_LOCATION  IrpSp
    )
/*++

Routine Description:

    Requests transfer of the socket context to the current process.

Arguments:

    Irp - acquire conect IRP
    IrpSp - current stack location

Return Value:
    STATUS_PENDING   - operation was successfully enqued
--*/
{

    NTSTATUS status;
    AFD_SWITCH_ACQUIRE_CTX_INFO ctxInfo;
    PAFD_ENDPOINT   sanHlprEndpoint, sanEndpoint;
    PFILE_OBJECT sanFileObject = NULL;
    PVOID   requestCtx;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    BOOLEAN doTransfer;
    PVOID   context;



    AFD_W4_INIT status = STATUS_SUCCESS;
    try {
#ifdef _WIN64
        if (IoIs32bitProcess (Irp)) {
            PAFD_SWITCH_ACQUIRE_CTX_INFO ctxInfo32;
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (*ctxInfo32)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (Irp->RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                sizeof (*ctxInfo32),
                                PROBE_ALIGNMENT32 (AFD_SWITCH_ACQUIRE_CTX_INFO32));
            }
            ctxInfo32 = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
            ctxInfo.SocketHandle = ctxInfo32->SocketHandle;
            ctxInfo.SwitchContext = ctxInfo32->SwitchContext;
            ctxInfo.SocketCtxBuf = ctxInfo32->SocketCtxBuf;
            ctxInfo.SocketCtxBufSize = ctxInfo32->SocketCtxBufSize;
        }
        else
#endif //_WIN64
        {
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (ctxInfo)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (Irp->RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                sizeof (ctxInfo),
                                PROBE_ALIGNMENT (AFD_SWITCH_ACQUIRE_CTX_INFO));
            }

            ctxInfo = *((PAFD_SWITCH_ACQUIRE_CTX_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);
        }

        if (ctxInfo.SocketCtxBufSize < 1)
            ExRaiseStatus (STATUS_INVALID_PARAMETER);

        Irp->MdlAddress = IoAllocateMdl (ctxInfo.SocketCtxBuf,   // VirtualAddress
                            ctxInfo.SocketCtxBufSize,   // Length
                            FALSE,                      // SecondaryBuffer
                            TRUE,                       // ChargeQuota
                            NULL);                      // Irp
        if (Irp->MdlAddress==NULL) {
            ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
        }

        MmProbeAndLockPages(
            Irp->MdlAddress,            // MemoryDescriptorList
            Irp->RequestorMode,         // AccessMode
            IoWriteAccess               // Operation
            );

        
        if (MmGetSystemAddressForMdlSafe(Irp->MdlAddress, LowPagePriority)==NULL) {
            ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
        }

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength>0) {

            Irp->MdlAddress->Next = IoAllocateMdl (Irp->UserBuffer,   // VirtualAddress
                                IrpSp->Parameters.DeviceIoControl.OutputBufferLength,// Length
                                FALSE,                      // SecondaryBuffer
                                TRUE,                       // ChargeQuota
                                NULL);                      // Irp
            if (Irp->MdlAddress->Next==NULL) {
                ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
            }

            MmProbeAndLockPages(
                Irp->MdlAddress->Next,      // MemoryDescriptorList
                Irp->RequestorMode,         // AccessMode
                IoWriteAccess               // Operation
                );

        
            if (MmGetSystemAddressForMdlSafe(Irp->MdlAddress->Next, LowPagePriority)==NULL) {
                ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
            }
        }

    }
    except (AFD_EXCEPTION_FILTER (status)) {
        ASSERT (NT_ERROR (status));
        //
        // Cleanup partially processed MDLs since IO subsystem can't do it.
        //
        while (Irp->MdlAddress!=NULL) {
            PMDL    mdl = Irp->MdlAddress;
            Irp->MdlAddress = mdl->Next;
            mdl->Next = NULL;
            if (mdl->MdlFlags & MDL_PAGES_LOCKED) {
                MmUnlockPages (mdl);
            }
            IoFreeMdl (mdl);
        }
        goto complete;
    }

    status = ObReferenceObjectByHandle (
                            ctxInfo.SocketHandle,
                            (IrpSp->Parameters.DeviceIoControl.IoControlCode>>14)&3,
                            *IoFileObjectType,
                            Irp->RequestorMode,
                            (PVOID)&sanFileObject,
                            NULL
                            );
    if (!NT_SUCCESS (status)) {
        goto complete;
    }

    if (sanFileObject->DeviceObject!=AfdDeviceObject) {
        status = STATUS_INVALID_HANDLE;
        goto complete;
    }

    sanHlprEndpoint = IrpSp->FileObject->FsContext;
    sanEndpoint = sanFileObject->FsContext;



    IF_DEBUG(SAN_SWITCH) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSanFastAcquireCtx: endp-%p.\n",
                    sanEndpoint));
    }

    //
    // Just make sure that endpoints are of correct type
    //

   context = AfdLockEndpointContext (sanEndpoint); // To prevent refresh.
   if (IS_SAN_HELPER(sanHlprEndpoint) &&
            sanHlprEndpoint->OwningProcess==IoGetCurrentProcess () &&
            IS_SAN_ENDPOINT(sanEndpoint)) {

        if (sanEndpoint->Common.SanEndp.SanHlpr==AfdSanServiceHelper  &&
                sanHlprEndpoint==AfdSanServiceHelper) {
                
            //
            // This is an implicit duplication request from the service process.
            // (we already received all the data from the owning process and
            // associated sanEndpoint with the service process).
            //
 
            AfdAcquireSpinLock (&sanEndpoint->SpinLock, &lockHandle);
            //
            // Make sure endpoint is still in transferring state
            //
            if (sanEndpoint->Common.SanEndp.CtxTransferStatus!=STATUS_MORE_PROCESSING_REQUIRED) {
                AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
                status = STATUS_CANCELLED;
            }
            else if (ctxInfo.SocketCtxBufSize > sanEndpoint->Common.SanEndp.SavedContextLength ||
                        ctxInfo.SocketCtxBufSize + 
                            IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                                sanEndpoint->Common.SanEndp.SavedContextLength) {
                AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
                //
                // Switch should have queried the context size via AFD_GET_CONTEXT
                //
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else {
                PVOID   savedContext = sanEndpoint->Common.SanEndp.SavedContext;
                ULONG   savedContextLength = sanEndpoint->Common.SanEndp.SavedContextLength;
                sanEndpoint->Common.SanEndp.SavedContext = NULL;
                sanEndpoint->Common.SanEndp.SavedContextLength = 0;
                AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);


                RtlCopyMemory (
                        MmGetSystemAddressForMdl (Irp->MdlAddress),
                        savedContext,
                        ctxInfo.SocketCtxBufSize);

                if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength!=0) {
                    Irp->IoStatus.Information = 
                            savedContextLength-
                                ctxInfo.SocketCtxBufSize;
                    RtlCopyMemory (
                            MmGetSystemAddressForMdl (Irp->MdlAddress->Next),
                            (PCHAR)savedContext+ctxInfo.SocketCtxBufSize,
                            Irp->IoStatus.Information);
                }
                else {
                    Irp->IoStatus.Information = 0;
                }

                AFD_FREE_POOL (savedContext, AFD_SAN_CONTEXT_POOL_TAG);
                // sanEndpoint->Common.SanEndp.SavedContext = NULL;
                sanEndpoint->Common.SanEndp.SwitchContext = ctxInfo.SwitchContext;
                status = STATUS_SUCCESS;
                //
                // Note that we are not expecting a reply from service process
                // anymore.
                //
                InterlockedExchangeAdd (&AfdSanServiceHelper->Common.SanHlpr.PendingRequests, -2);
            }
            AfdUnlockEndpointContext (sanEndpoint, context);
            UPDATE_ENDPOINT2 (sanEndpoint, 
                                "AfdSanAcquireContext, ctx bytes copied/status: 0x%lX",
                                NT_SUCCESS (status) 
                                ? (ULONG)Irp->IoStatus.Information
                                : status);
            //
            // Complete the IRP
            //
            Irp->IoStatus.Status = status;
            IoCompleteRequest (Irp, AfdPriorityBoost);

            //
            // Restart request processing.
            //
            AfdSanRestartRequestProcessing (sanEndpoint, status);
        }
        else {

            AfdAcquireSpinLock (&sanEndpoint->SpinLock, &lockHandle);
            //
            // Make sure Irp has not been cancelled meanwhile
            //
            IoSetCancelRoutine (Irp, AfdSanCancelRequest);
            if (Irp->Cancel) {
                //
                // Oops, let it go
                //
                Irp->Tail.Overlay.ListEntry.Flink = NULL;
                AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
                if (IoSetCancelRoutine (Irp, NULL)==NULL) {
                    KIRQL cancelIrql;
                    //
                    // Cancel routine must be running, make sure
                    // it completes before we complete the IRP
                    //
                    IoAcquireCancelSpinLock (&cancelIrql);
                    IoReleaseCancelSpinLock (cancelIrql);
                }
                AfdUnlockEndpointContext (sanEndpoint, context);
                status = STATUS_CANCELLED;
                goto complete;
            }

            //
            // Check if don't already have duplication in progress.
            //
            if (sanEndpoint->Common.SanEndp.CtxTransferStatus!=STATUS_PENDING &&
                    sanEndpoint->Common.SanEndp.CtxTransferStatus!=STATUS_MORE_PROCESSING_REQUIRED) {
                if (!NT_SUCCESS (sanEndpoint->Common.SanEndp.CtxTransferStatus)) {
                    //
                    // Duplicaiton has failed previously, can't do another one.
                    //
                    status = sanEndpoint->Common.SanEndp.CtxTransferStatus;
                    Irp->Tail.Overlay.ListEntry.Flink = NULL;
                    AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
                    if (IoSetCancelRoutine (Irp, NULL)==NULL) {
                        KIRQL cancelIrql;
                        //
                        // Cancel routine must be running, make sure
                        // it completes before we complete the IRP
                        //
                        IoAcquireCancelSpinLock (&cancelIrql);
                        IoReleaseCancelSpinLock (cancelIrql);
                    }
                    AfdUnlockEndpointContext (sanEndpoint, context);
                    goto complete;
                }
                //
                // Generate request context that uniquely identifies
                // it among other requests on the same endpoint.
                //
                requestCtx = AFD_SWITCH_MAKE_REQUEST_CONTEXT(
                                    sanEndpoint->Common.SanEndp.RequestId,
                                    AFD_SWITCH_REQUEST_TFCTX); 
                sanEndpoint->Common.SanEndp.RequestId += 1;

                //
                // Store the request context in the Irp and insert it into
                // the list
                //
                Irp->AfdSanRequestInfo.AfdSanRequestCtx = requestCtx;


                sanEndpoint->Common.SanEndp.CtxTransferStatus = STATUS_PENDING;
                doTransfer = TRUE;
            }
            else {
                //
                // Another duplication in progress, this one will have to wait.
                //
                Irp->AfdSanRequestInfo.AfdSanRequestCtx = NULL;
                doTransfer = FALSE;
                AFD_W4_INIT requestCtx = NULL;  // Depends on variable above, but 
                                                // compiler does not see
                                                // the connection.
            }

            Irp->AfdSanRequestInfo.AfdSanSwitchCtx = ctxInfo.SwitchContext;
            Irp->AfdSanRequestInfo.AfdSanProcessId = PsGetCurrentProcessId();
            Irp->AfdSanRequestInfo.AfdSanHelperEndp = sanHlprEndpoint;
            //
            // We are going to pend this IRP, mark it so
            //
            IoMarkIrpPending (Irp);

            InsertTailList (&sanEndpoint->Common.SanEndp.IrpList,
                                    &Irp->Tail.Overlay.ListEntry);
            IoGetCurrentIrpStackLocation(Irp)->FileObject = sanFileObject;
            UPDATE_ENDPOINT2 (sanEndpoint,
                                "AfdSanAcquireContext, request: 0x%lX",
                                PtrToUlong (Irp->AfdSanRequestInfo.AfdSanRequestCtx));
            AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
            AfdUnlockEndpointContext (sanEndpoint, context);

            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdSanRedirectRequest: endp-%p, irp-%p, context-%p\n",
                            sanEndpoint, Irp, requestCtx));
            }

            if (doTransfer) {
                status = AfdSanNotifyRequest (sanEndpoint,
                        requestCtx, 
                        STATUS_SUCCESS,
                        (ULONG_PTR)PsGetCurrentProcessId());
                if (!NT_SUCCESS (status)) {
                    PIRP    irp;
                    //
                    // If notification failed, fail the request.
                    // Note that we cannot return the failure status directly
                    // as we already marked IRP as pending. Also, the IRP
                    // could have been cancelled, so we have to search for
                    // it in the list.
                    //
                    irp = AfdSanDequeueRequest (sanEndpoint, requestCtx);
                    if (irp!=NULL) {
                        ASSERT (irp==Irp);
                        irp->IoStatus.Status = status;
                        IoCompleteRequest (irp, AfdPriorityBoost);
                    }
                    //
                    // Restart other requests in the queue and reset context
                    // transfer status.
                    //
                    AfdSanRestartRequestProcessing (sanEndpoint, STATUS_SUCCESS);
                }
            }

            //
            // The request is in the queue or completed, we no longer need
            // object reference.
            //
            status = STATUS_PENDING;
        }

        ObDereferenceObject (sanFileObject);
        return status;
    }
    else {
        AfdUnlockEndpointContext (sanEndpoint, context);
        status = STATUS_INVALID_HANDLE;
    }

    UPDATE_ENDPOINT2 (sanEndpoint, "AfdSanAcquireContext, status: 0x%lX", status);

complete:

    if (sanFileObject!=NULL)
        ObDereferenceObject (sanFileObject);
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, AfdPriorityBoost);

    return status;
}

NTSTATUS
AfdSanFastTransferCtx (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PULONG_PTR          Information
    )
/*++

Routine Description:

    Requests AFD to transfer endpoint into another process context

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_TRANSFER_CTX)
    RequestorMode   - mode of the caller
    InputBuffer     - input parameters for the operation (AFD_SWITCH_TRANSFER_CTX_INFO)
                        SocketHandle - SAN endpoint to be transferred
                        RequestContext - value that identifies corresponding acquire request.
                        SocketCtxBuf - endpoint context buffer to copy destination process
                                            acquire request
                        SocketCtxSize - size of the buffer to copy
                        RcvBufferArray - array of buffered data to transfer to 
                                            destination process acquire request
                        RcvBufferCount - number of elements in the array.
    InputBufferLength - sizeof (AFD_SWITCH_TRANSFER_CTX_INFO)

    OutputBuffer - unused
    OutputBufferLength - unused
    Information     - pointer to buffer to return number of bytes copied
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint or switch endpoint is of incorrect type
    STATUS_INVALID_PARAMETER - invalid input buffer size.
    other - failed when attempting to access san endpoint or input buffer(s).
--*/
{
    NTSTATUS status;
    AFD_SWITCH_TRANSFER_CTX_INFO ctxInfo;
    PVOID context;
    PAFD_ENDPOINT   sanHlprEndpoint, sanEndpoint;
    PFILE_OBJECT sanFileObject;
    PIRP irp;
    PIO_STACK_LOCATION  irpSp;
#ifdef _WIN64
    WSABUF          localArray[8];
    LPWSABUF        pArray = localArray;
#endif

    PAGED_CODE ();

    *Information = 0;
    UNREFERENCED_PARAMETER (OutputBuffer);
    UNREFERENCED_PARAMETER (OutputBufferLength);

    AFD_W4_INIT status = STATUS_SUCCESS;
    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            PAFD_SWITCH_TRANSFER_CTX_INFO ctxInfo32;
            ULONG   i;
            if (InputBufferLength<sizeof (*ctxInfo32)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (*ctxInfo32),
                                PROBE_ALIGNMENT32 (AFD_SWITCH_TRANSFER_CTX_INFO32));
            }
            ctxInfo32 = InputBuffer;
            ctxInfo.SocketHandle = ctxInfo32->SocketHandle;
            ctxInfo.SwitchContext = ctxInfo32->SwitchContext;
            ctxInfo.RequestContext = ctxInfo32->RequestContext;
            ctxInfo.SocketCtxBuf = ctxInfo32->SocketCtxBuf;
            ctxInfo.SocketCtxBufSize = ctxInfo32->SocketCtxBufSize;
            ctxInfo.RcvBufferArray = ctxInfo32->RcvBufferArray;
            ctxInfo.RcvBufferCount = ctxInfo32->RcvBufferCount;
            ctxInfo.Status = ctxInfo32->Status;
            if (RequestorMode!=KernelMode) {
                if (ctxInfo.SocketCtxBufSize==0 ||
                    ctxInfo.RcvBufferCount>(MAXULONG/sizeof (WSABUF32))) {

                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }
                ProbeForRead (ctxInfo.SocketCtxBuf,
                                ctxInfo.SocketCtxBufSize,
                                sizeof (UCHAR));
                ProbeForRead (ctxInfo.RcvBufferArray,
                                sizeof (WSABUF32)*ctxInfo.RcvBufferCount,
                                PROBE_ALIGNMENT32 (WSABUF32));
            }
            if (ctxInfo.RcvBufferCount>sizeof(localArray)/sizeof(localArray[0])) {
                pArray = AFD_ALLOCATE_POOL_WITH_QUOTA (
                                NonPagedPool,
                                sizeof (WSABUF)*ctxInfo.RcvBufferCount,
                                AFD_TEMPORARY_POOL_TAG);
                // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets 
                // POOL_RAISE_IF_ALLOCATION_FAILURE flag
                ASSERT (pArray!=NULL);
            }

            for (i=0; i<ctxInfo.RcvBufferCount; i++) {
                pArray[i].buf = ctxInfo.RcvBufferArray[i].buf;
                pArray[i].len = ctxInfo.RcvBufferArray[i].len;
            }
            ctxInfo.RcvBufferArray = pArray;
        }
        else
#endif //_WIN64
        {
            if (InputBufferLength<sizeof (ctxInfo)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }

            if (RequestorMode!=KernelMode) {
                ProbeForReadSmallStructure (InputBuffer,
                                sizeof (ctxInfo),
                                PROBE_ALIGNMENT (AFD_SWITCH_TRANSFER_CTX_INFO));
            }

            ctxInfo = *((PAFD_SWITCH_TRANSFER_CTX_INFO)InputBuffer);
            if (RequestorMode!=KernelMode) {

                if (ctxInfo.SocketCtxBufSize==0 ||
                    ctxInfo.RcvBufferCount>(MAXULONG/sizeof (WSABUF))) {

                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }

                ProbeForRead (ctxInfo.SocketCtxBuf,
                                ctxInfo.SocketCtxBufSize,
                                sizeof (UCHAR));

                ProbeForRead (ctxInfo.RcvBufferArray,
                                sizeof (ctxInfo.RcvBufferArray)*ctxInfo.RcvBufferCount,
                                PROBE_ALIGNMENT (WSABUF));

            }
        }

        if (ctxInfo.SwitchContext==NULL) {
            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AFD: Switch context is NULL in AfdSanFastTransferCtx\n"));
            }
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }

    }
    except (AFD_EXCEPTION_FILTER (status)) {
        ASSERT (NT_ERROR (status));
        goto complete;
    }

    ctxInfo.Status = AfdValidateStatus (ctxInfo.Status);

    sanHlprEndpoint = FileObject->FsContext;
    ASSERT (IS_SAN_HELPER (sanHlprEndpoint));
    status = AfdSanReferenceSwitchSocketByHandle (
                            ctxInfo.SocketHandle,
                            (IoctlCode>>14)&3,
                            RequestorMode,
                            sanHlprEndpoint,
                            ctxInfo.SwitchContext,
                            &sanFileObject
                            );
    if (!NT_SUCCESS (status)) {
        goto complete;
    }

    sanEndpoint = sanFileObject->FsContext;


    IF_DEBUG(SAN_SWITCH) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSanFastTransferCtx: endp-%p.\n",
                    sanEndpoint));
    }

    if (ctxInfo.RequestContext==AFD_SWITCH_MAKE_REQUEST_CONTEXT (0, AFD_SWITCH_REQUEST_TFCTX)) {
        //
        // This is unsolicited request to transfer endpoint into 
        // the service process.
        //
        PVOID   savedContext = NULL;
        ULONG   ctxLength;

        if (NT_SUCCESS (ctxInfo.Status)) {
            //
            // Save the user mode data.
            //
            ctxLength = ctxInfo.SocketCtxBufSize;
            AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
            try {
                if (ctxInfo.RcvBufferCount>0)
                    ctxLength += AfdCalcBufferArrayByteLength(
                                    ctxInfo.RcvBufferArray,
                                        ctxInfo.RcvBufferCount);
                savedContext = AFD_ALLOCATE_POOL_WITH_QUOTA (PagedPool,
                                                    ctxLength,
                                                    AFD_SAN_CONTEXT_POOL_TAG);

                ASSERT (savedContext!=NULL);

                RtlCopyMemory (
                    savedContext,
                    ctxInfo.SocketCtxBuf,
                    ctxInfo.SocketCtxBufSize);

                if (ctxInfo.RcvBufferCount>0) {
                    AfdCopyBufferArrayToBuffer (
                                (PUCHAR)savedContext+ctxInfo.SocketCtxBufSize,
                                ctxLength-ctxInfo.SocketCtxBufSize,
                                ctxInfo.RcvBufferArray,
                                ctxInfo.RcvBufferCount);
                }

            }
            except (AFD_EXCEPTION_FILTER (status)) {
                ASSERT (NT_ERROR (status));
                goto CleanupSavedContext;
            }

            status = AfdSanDupEndpointIntoServiceProcess (sanFileObject, savedContext, ctxLength);

            if (NT_SUCCESS (status))  {
                *Information = ctxLength;
                goto complete_deref;
            }

        CleanupSavedContext:
            //
            // Something failed, free the context
            //
            if (savedContext!=NULL) {
                AFD_FREE_POOL (savedContext, AFD_SAN_CONTEXT_POOL_TAG);
            }


        }
        else { 
            //
            // The process could not satisfy implicit transfer context request
            //
            status = ctxInfo.Status;
        }
    }
    else {
        //
        // The process satisfied another process acquire request
        // Find it first.
        //
        irp = AfdSanDequeueRequest (sanEndpoint, ctxInfo.RequestContext);
        if (irp!=NULL) {
            //
            // Get IRP stack location and perform data copy
            //
            irpSp = IoGetCurrentIrpStackLocation (irp);
            if (NT_SUCCESS (ctxInfo.Status)) {
                AFD_SWITCH_CONTEXT  localContext;

                //
                // Set the initial status to success since the process
                // agreed to satisfy the transfer.
                //
                AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
                try {

                    if ( MmGetMdlByteCount(irp->MdlAddress)!=ctxInfo.SocketCtxBufSize ||
                            (ctxInfo.RcvBufferCount!=0 &&
                                irpSp->Parameters.DeviceIoControl.OutputBufferLength<
                                     AfdCalcBufferArrayByteLength(
                                            ctxInfo.RcvBufferArray,
                                            ctxInfo.RcvBufferCount)) ){
                        ExRaiseStatus (STATUS_INVALID_PARAMETER);
                    }

                    RtlCopyMemory (
                        MmGetSystemAddressForMdl (irp->MdlAddress),
                        ctxInfo.SocketCtxBuf,
                        ctxInfo.SocketCtxBufSize);

                    if (ctxInfo.RcvBufferCount>0) {
                        irp->IoStatus.Information = 
                            AfdCopyBufferArrayToBuffer (
                                    MmGetSystemAddressForMdl (irp->MdlAddress->Next),
                                    irpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                    ctxInfo.RcvBufferArray,
                                    ctxInfo.RcvBufferCount);
                    }
                    else {
                        irp->IoStatus.Information = 0;
                    }
                }
                except (AFD_EXCEPTION_FILTER (status)) {
                    goto CopyException;
                }


                //
                // Now change sanEndpoint's SanHlpr and SwitchContext to point
                // to the new address space and switch socket
                //
                context = AfdLockEndpointContext (sanEndpoint);
                if (!IS_SAN_ENDPOINT (sanEndpoint ) ||
                        sanEndpoint->Common.SanEndp.CtxTransferStatus!=STATUS_PENDING) {
                    status = STATUS_INVALID_HANDLE;
                    goto UnlockContext;
                }

                try {
                    localContext = *sanEndpoint->Common.SanEndp.SwitchContext;
                }
                except (AFD_EXCEPTION_FILTER (status)) {
                    ASSERT (NT_ERROR (status));
                    goto UnlockContext;
                }

                KeAttachProcess (PsGetProcessPcb(((PAFD_ENDPOINT)irp->AfdSanRequestInfo.AfdSanHelperEndp)->OwningProcess));
                try {
                    //
                    // Place info regarding select/eventselect events in SwitchContext
                    // of the new switch socket
                    //
                    *((PAFD_SWITCH_CONTEXT)irp->AfdSanRequestInfo.AfdSanSwitchCtx) = localContext;
                }
                except (AFD_EXCEPTION_FILTER (status)) {
                    ASSERT (NT_ERROR (status));
                    KeDetachProcess ();
                    goto UnlockContext;
                }
                KeDetachProcess ();

                sanEndpoint->Common.SanEndp.SanHlpr = irp->AfdSanRequestInfo.AfdSanHelperEndp;
                REFERENCE_ENDPOINT2 (sanEndpoint->Common.SanEndp.SanHlpr, 
                                        "Transfer TO 0x%lX",
                                        HandleToUlong (ctxInfo.SocketHandle) );
                sanEndpoint->Common.SanEndp.SwitchContext = irp->AfdSanRequestInfo.AfdSanSwitchCtx;
                //
                // Reset implicit dup flag if it was set.
                // We are satisfying explicit request for
                // duplication.
                //
                sanEndpoint->Common.SanEndp.ImplicitDup = FALSE;
                DEREFERENCE_ENDPOINT2 (sanHlprEndpoint,
                                        "Transfer FROM 0x%lX",
                                        HandleToUlong (ctxInfo.SocketHandle));
            UnlockContext:
                AfdUnlockEndpointContext (sanEndpoint, context);


            CopyException:
                //
                // Report the final status to the process
                // that wanted duplication
                //
                irp->IoStatus.Status = status;
            }
            else {
                //
                // This process could not satisfy transfer request
                // Tell other process about this.
                //
                irp->IoStatus.Status = ctxInfo.Status;
                //
                // We succeeded this process refuse to dup request
                // we should report it as success and continue processing
                // of other redirected request.  It is possible that we
                // can still succeed other duplication requests.
                //
                status = STATUS_SUCCESS;
            }

            //
            // Complete the acquuire request from another process.
            //
            IoCompleteRequest (irp, AfdPriorityBoost);
        }
        else {
            status = STATUS_INVALID_PARAMETER;
        }

    }

    //
    // Restart request processing that were pended while
    // we were processing duplication request.
    //
    AfdSanRestartRequestProcessing (sanEndpoint, status);

complete_deref:
    UPDATE_ENDPOINT2 (sanEndpoint, "AfdSanFastTransferCtx, status: 0x%lX", status);
    ObDereferenceObject (sanFileObject);

complete:
#ifdef _WIN64
    if (pArray!=localArray) {
        AFD_FREE_POOL (pArray, AFD_TEMPORARY_POOL_TAG);
    }
#endif //_WIN64
    return status;
}

BOOLEAN
AfdSanFastUnlockAll (
    IN PFILE_OBJECT     FileObject,
    IN PEPROCESS        Process,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Called by the system when last handle to the file object in closed
    in some process while other processes still have handles opened
    This is only called on files that were marked as locked at some point of time.

Arguments:
    FileObject      - file object of interest
    Process         - process which has last handle being closed
    IoStatus        - buffer to return operation status and information
    DeviceObject    - device object with which file object is associated
Return Value:

    TRUE     - operation completed OK.    

--*/
{
    PAFD_ENDPOINT   sanEndpoint;
    PVOID           context;
    
    PAGED_CODE ();

    UNREFERENCED_PARAMETER (DeviceObject);
    PAGED_CODE ();

    sanEndpoint = FileObject->FsContext;
    context = AfdLockEndpointContext (sanEndpoint);
    if (IS_SAN_ENDPOINT (sanEndpoint)) {
        ASSERT (sanEndpoint->Common.SanEndp.SanHlpr!=NULL);
        if (sanEndpoint->Common.SanEndp.SanHlpr->OwningProcess==Process) {
            NTSTATUS    status = STATUS_CANCELLED;
            //
            // Owner process is closing it.
            //
            if (sanEndpoint->Common.SanEndp.SanHlpr!=AfdSanServiceHelper) {
                NTSTATUS dupStatus;

                dupStatus = AfdSanSetAskDupeToServiceState (sanEndpoint);

                if (dupStatus == STATUS_PENDING || 
                        dupStatus == STATUS_MORE_PROCESSING_REQUIRED) {
                    //
                    // Some other process is already trying to import this socket. Let
                    // that complete
                    //
                    AfdUnlockEndpointContext (sanEndpoint, context);
                    goto Exit;
                }

                if (NT_SUCCESS (dupStatus)) {
                    PAFD_ENDPOINT   sanHlprEndpoint = sanEndpoint->Common.SanEndp.SanHlpr;
                    //
                    // Last handle in the process that owns the socket is being
                    // closed while there are handles to it in other processes.
                    // Need to transfer the context to the service process
                    //
                    if ((InterlockedExchangeAdd (&sanHlprEndpoint->Common.SanHlpr.PendingRequests, 2) & 1)==0) {
                        status = IoSetIoCompletion (
                                                    sanHlprEndpoint->Common.SanHlpr.IoCompletionPort,
                                                    sanEndpoint->Common.SanEndp.SwitchContext,
                                                    AFD_SWITCH_MAKE_REQUEST_CONTEXT (0, AFD_SWITCH_REQUEST_TFCTX),
                                                    STATUS_SUCCESS,
                                                    (ULONG_PTR)AfdSanServicePid,
                                                    FALSE           // ChargeQuota - Don't, handle is going away, no
                                                    // way for the run-away app to mount an attack
                                                    );
                        UPDATE_ENDPOINT2 (sanEndpoint, "Implicit TFCTX request, status: 0x%lX", status);
                        if (NT_SUCCESS (status)) {
                            AfdUnlockEndpointContext (sanEndpoint, context);
                            goto Exit;
                        }
                    }
                    else {
                        //
                        // Process has already exited, not much we can do.
                        //
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                                    "AFD: Process %p has exited before SAN context could be transferred out.\n",
                                    Process));
                    }
                    InterlockedExchangeAdd (&sanHlprEndpoint->Common.SanHlpr.PendingRequests, -2);
                }
            }
            AfdUnlockEndpointContext (sanEndpoint, context);
            AfdSanRestartRequestProcessing (sanEndpoint, status);
        }
        else {
            if (sanEndpoint->Common.SanEndp.ImplicitDup) {
                AfdUnlockEndpointContext (sanEndpoint, context);
                //
                // Process is exiting and the only handle is in the
                // other process where the handle was duplicated
                // impilictly (without application request, e.g.
                // cross proceess accepting socket duplicated into
                // listening process to complete the accept or socket
                // duplication into service process while waiting on 
                // other process to request ownership).
                //
                if (ObReferenceObject (FileObject)==3) { 
                    NTSTATUS    oldStatus;
                    // Why are we checking for refcount of 3?
                    // 1 - Handle in the implicit process
                    // 1 - IO manager for this call
                    // 1 - we just added
                    oldStatus = AfdSanRestartRequestProcessing (sanEndpoint, STATUS_CANCELLED);
                    if (NT_SUCCESS (oldStatus)) {
                        ASSERT (oldStatus!=STATUS_PENDING);
                        ASSERT ((ULONG_PTR)sanEndpoint->Common.SanEndp.SwitchContext<MM_USER_PROBE_ADDRESS);
                        //
                        // Notify the service process only if duplication has already
                        // completed
                        //
                        UPDATE_ENDPOINT2 (sanEndpoint, "AfdSanFastUnlockAll, posting CLSOCK", 0);
                        IoSetIoCompletion (
                            sanEndpoint->Common.SanEndp.SanHlpr->Common.SanHlpr.IoCompletionPort,
                            sanEndpoint->Common.SanEndp.SwitchContext,
                            AFD_SWITCH_MAKE_REQUEST_CONTEXT (0, AFD_SWITCH_REQUEST_CLSOC),
                            STATUS_SUCCESS,
                            (ULONG_PTR)0,
                            FALSE);         // ChargeQuota - Don't, handle is going away, no
                                            // way for the run-away app to mount an attack
                    }
                }
                ObDereferenceObject (FileObject);
            }
            else {
                AfdUnlockEndpointContext (sanEndpoint, context);
            }
        }
    }
    else if (IS_SAN_HELPER (sanEndpoint)) {
        //
        // Helper never change to it safe to release the lock.
        //
        AfdUnlockEndpointContext (sanEndpoint, context);
        //
        // The process for which helper was created is exiting
        // we need to cleanup all the endpoint that refer to this helper.
        //
        if (sanEndpoint->OwningProcess==Process) {
            AfdSanHelperCleanup (sanEndpoint);
        }
    }
    else {
        //
        // non-SAN endpoint. Someone else called NtLockFile on endpoint
        // file object ...
        //
        AfdUnlockEndpointContext (sanEndpoint, context);
    }

Exit:

    IoStatus->Status = STATUS_SUCCESS;
    IoStatus->Information = 0;
    return TRUE;
}

//
// Internal routines.
//


NTSTATUS
AfdSanAcceptCore (
    PIRP            AcceptIrp,
    PFILE_OBJECT    AcceptFileObject,
    PAFD_CONNECTION Connection,
    PAFD_LOCK_QUEUE_HANDLE LockHandle
    )
/*++

Routine Description:

    Accept the incoming SAN connection on endpoint provided

Arguments:
    AcceptIrp   - accept IRP to complete
    AcceptFileObject - file object of accepting endpoint
    Connection - pointer to connection object that represents the incoming connection
    LockHandle - IRQL at which listening endpoint spinlock was taken on entry to this routine.
    
Return Value:

    STATUS_PENDING - accept operation started OK
    STATUS_REMOTE_DISCONNECT - connection being accepted was aborted by the remote.
    STATUS_CANCELLED - accepting endpoint was closed or accept IRP cancelled
--*/
{
    PIRP            connectIrp;
    PIO_STACK_LOCATION irpSp;
    PAFD_SWITCH_CONNECT_INFO connectInfo;
    PAFD_ENDPOINT   listenEndpoint, acceptEndpoint;
    HANDLE          acceptHandle;
    ULONG           receiveLength;
    PKPROCESS       listenProcess;

    ASSERT (LockHandle->LockHandle.OldIrql < DISPATCH_LEVEL);

    irpSp = IoGetCurrentIrpStackLocation (AcceptIrp);
    listenEndpoint = irpSp->FileObject->FsContext;
    acceptEndpoint = AcceptFileObject->FsContext;

    ASSERT (Connection->SanConnection);

    //
    // Snag the connect indication IRP
    //
    connectIrp = Connection->ConnectIrp;
    ASSERT (connectIrp!=NULL);
    Connection->ConnectIrp = NULL;


    //
    // Handle EventSelect signalling
    //
    listenEndpoint->EventsActive &= ~AFD_POLL_ACCEPT;

    IF_DEBUG(EVENT_SELECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSanAcceptCore: Endp %p, Active %lx\n",
                    listenEndpoint,
                    listenEndpoint->EventsActive
                    ));
    }

    if (!IsListEmpty (&listenEndpoint->Common.VcListening.UnacceptedConnectionListHead ) ) {
        AfdIndicateEventSelectEvent(
                listenEndpoint,
                AFD_POLL_ACCEPT,
                STATUS_SUCCESS
                );
    }

    //
    // We no longer need the connection object for SAN
    // endpoint, return it
    //
    Connection->Endpoint = NULL;
    Connection->SanConnection = FALSE;
    AfdSanReleaseConnection (listenEndpoint, Connection, FALSE);
    DEREFERENCE_ENDPOINT (listenEndpoint);

    if (IoSetCancelRoutine (connectIrp, NULL)==NULL) {

        AfdReleaseSpinLock (&listenEndpoint->SpinLock, LockHandle);
        connectIrp->IoStatus.Status = STATUS_CANCELLED;
        connectIrp->IoStatus.Information = 0;
        IoCompleteRequest (connectIrp, AfdPriorityBoost);
        return STATUS_REMOTE_DISCONNECT;
    }
    AfdReleaseSpinLock (&listenEndpoint->SpinLock, LockHandle);


    //
    // Check that accept IRP and SAN connection IRP belong to the same process
    //
    if (IoThreadToProcess (AcceptIrp->Tail.Overlay.Thread)!=
                IoThreadToProcess (connectIrp->Tail.Overlay.Thread)) {
        //
        // Listen process is different than the accepting one.
        // We need to duplicate accepting handle into the listening
        // process so that accept can take place there and the accepting
        // socket will later get dup-ed into the accepting process when
        // that process performs an IO operation on it.
        //
        NTSTATUS        status;
        listenProcess = PsGetProcessPcb(IoThreadToProcess (connectIrp->Tail.Overlay.Thread));
        KeAttachProcess (listenProcess);

        status = ObOpenObjectByPointer (
                                AcceptFileObject,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                MAXIMUM_ALLOWED,
                                *IoFileObjectType,
                                KernelMode,
                                &acceptHandle);
        KeDetachProcess ();
        if (!NT_SUCCESS (status)) {
            connectIrp->IoStatus.Status = STATUS_INVALID_HANDLE;
            connectIrp->IoStatus.Information = 0;
            IoCompleteRequest (connectIrp, AfdPriorityBoost);
            return STATUS_REMOTE_DISCONNECT;
        }
    }
    else {
        acceptHandle = AcceptIrp->Tail.Overlay.DriverContext[3];
        listenProcess = NULL;
    }

    //
    // Now take care of the accept endpoint
    //
    AfdAcquireSpinLock (&acceptEndpoint->SpinLock, LockHandle);
    IoSetCancelRoutine (AcceptIrp, AfdSanCancelAccept);
    if (acceptEndpoint->EndpointCleanedUp || AcceptIrp->Cancel) {
        //
        // Endpoint was closed or IRP cancelled,
        // reset accept irp pointer and return error
        // to both application and SAN provider (to refuse
        // the connection)
        //
        AcceptIrp->Tail.Overlay.ListEntry.Flink = NULL;
        AfdReleaseSpinLock (&acceptEndpoint->SpinLock, LockHandle);
        if (listenProcess!=NULL) {
#if DBG
            NTSTATUS status;
#endif
            //
            // Destroy the handle that we created for
            // accepting socket duplication.
            //
            KeAttachProcess (listenProcess);
#if DBG
            status =
#endif
                    NtClose (acceptHandle);
            KeDetachProcess ();
            ASSERT (NT_SUCCESS (status));
        }
        connectIrp->IoStatus.Status = STATUS_CANCELLED;
        connectIrp->IoStatus.Information = 0;
        IoCompleteRequest (connectIrp, AfdPriorityBoost);

        //
        // If AcceptIrp's Cancel routine is running, let it finish.
        // Once we return, caller will complete the AcceptIrp
        //
        if (IoSetCancelRoutine (AcceptIrp, NULL)==NULL) {
            KIRQL cancelIrql;
            IoAcquireCancelSpinLock (&cancelIrql);
            IoReleaseCancelSpinLock (cancelIrql);
        }

        return STATUS_CANCELLED;
    }

    //
    // Pend the accept IRP till provider
    // completes it.  This may take quite a while,
    // which is not expected by the msafd and application,
    // but we have no choice here
    //

    IoMarkIrpPending (AcceptIrp);
    irpSp = IoGetCurrentIrpStackLocation (AcceptIrp);
    receiveLength = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength;

    connectInfo = connectIrp->AssociatedIrp.SystemBuffer;
    //
    // Remove super accept IRP from the endpoint
    //
    acceptEndpoint->Irp = NULL; 

    //
    // Convert endpoint to SAN
    //
    AfdSanInitEndpoint (IoGetCurrentIrpStackLocation (connectIrp)->FileObject->FsContext,
                            AcceptFileObject,
                            connectInfo->SwitchContext);
    
    
    if (listenProcess!=NULL) {
        //
        // Note that socket was duplicated implicitly, without application request
        //
        acceptEndpoint->Common.SanEndp.ImplicitDup = TRUE;
    }

    UPDATE_ENDPOINT2 (acceptEndpoint, "AfdSanAcceptCore, accepted with bytes: 0x%lX", receiveLength);

    InsertTailList (&acceptEndpoint->Common.SanEndp.IrpList,
                        &AcceptIrp->Tail.Overlay.ListEntry);

    if (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength>0) {
        ULONG remoteAddressLength = 
                    FIELD_OFFSET (
                        TRANSPORT_ADDRESS, 
                        Address[0].Address[
                            connectInfo->RemoteAddress.Address[0].AddressLength]);

#ifndef i386
        if (acceptEndpoint->Common.VcConnecting.FixAddressAlignment) {
            USHORT addressLength = 
                    connectInfo->RemoteAddress.Address[0].AddressLength
                    + sizeof (USHORT);
            USHORT UNALIGNED *pAddrLength = (PVOID)
                        ((PUCHAR)MmGetSystemAddressForMdl (AcceptIrp->MdlAddress)
                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength
                         - sizeof (USHORT));
            RtlMoveMemory (
                        (PUCHAR)MmGetSystemAddressForMdl (AcceptIrp->MdlAddress)
                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                         &connectInfo->RemoteAddress.Address[0].AddressType,
                         addressLength);
            *pAddrLength = addressLength;
        }
        else
#endif
        {
            RtlMoveMemory (
                        (PUCHAR)MmGetSystemAddressForMdl (AcceptIrp->MdlAddress)
                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                         &connectInfo->RemoteAddress,
                         remoteAddressLength);
        }

        if (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength>0) {
            PTA_ADDRESS localAddress = (PTA_ADDRESS)
                    &(connectInfo->RemoteAddress.Address[0].Address[
                            connectInfo->RemoteAddress.Address[0].AddressLength]);
            TDI_ADDRESS_INFO  UNALIGNED *addressInfo = (PVOID)
                    ((PUCHAR)MmGetSystemAddressForMdl(AcceptIrp->MdlAddress)
                        + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength);
#ifndef i386
            if (acceptEndpoint->Common.VcConnecting.FixAddressAlignment) {
                USHORT UNALIGNED * pAddrLength = (PVOID)
                    ((PUCHAR)addressInfo 
                    +irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                    -sizeof(USHORT));
                RtlMoveMemory (
                    addressInfo,
                    &localAddress->AddressType,
                    localAddress->AddressLength+sizeof (USHORT));
                *pAddrLength = localAddress->AddressLength+sizeof (USHORT);
            }
            else
#endif
            {
                addressInfo->ActivityCount = 0;
                addressInfo->Address.TAAddressCount = 1;
                RtlMoveMemory (
                    &addressInfo->Address.Address,
                    localAddress,
                    FIELD_OFFSET (TA_ADDRESS, Address[localAddress->AddressLength]));

            }
        }

    }
    AfdReleaseSpinLock (&acceptEndpoint->SpinLock, LockHandle);


    //
    // Setup the accept info for the provider
    //
    //
    // Do this under protection of exception handler since application
    // can change protection attributes of the virtual address range
    // or even deallocate it.  Make sure to attach to the listening
    // process if necessary.
    //
    if (listenProcess!=NULL) {
        KeAttachProcess (listenProcess);
    }
    else {
        ASSERT (IoGetCurrentProcess ()==IoThreadToProcess (connectIrp->Tail.Overlay.Thread));
    }

    try {

#ifdef _WIN64
        if (IoIs32bitProcess (connectIrp)) {
            PAFD_SWITCH_ACCEPT_INFO32 acceptInfo32;
            acceptInfo32 = MmGetMdlVirtualAddress (connectIrp->MdlAddress);
            ASSERT (acceptInfo32!=NULL);
            ASSERT (MmGetMdlByteCount (connectIrp->MdlAddress)>=sizeof (*acceptInfo32));
            acceptInfo32->AcceptHandle = (VOID * POINTER_32)acceptHandle;
            acceptInfo32->ReceiveLength = receiveLength;
            connectIrp->IoStatus.Information = sizeof (*acceptInfo32);
        }
        else
#endif _WIN64
        {
            PAFD_SWITCH_ACCEPT_INFO acceptInfo;
            acceptInfo = MmGetMdlVirtualAddress (connectIrp->MdlAddress);
            ASSERT (acceptInfo!=NULL);
            ASSERT (MmGetMdlByteCount (connectIrp->MdlAddress)>=sizeof (*acceptInfo));
            acceptInfo->AcceptHandle = acceptHandle;
            acceptInfo->ReceiveLength = receiveLength;
            connectIrp->IoStatus.Information = sizeof (*acceptInfo);
        }

        connectIrp->IoStatus.Status = (listenProcess==NULL) ? STATUS_SUCCESS : STATUS_MORE_ENTRIES;
    }
    except (AFD_EXCEPTION_FILTER (connectIrp->IoStatus.Status)) {
        //
        // If the app is playing with switch's virtual addresses
        // we can't help much - it's accept IRP will probably
        // just hang since the switch is not going to follow
        // the failed connect IRP with accept completion.
        //
    }

    if (listenProcess!=NULL) {
        KeDetachProcess ();
    }

    //
    // Complete the provider IRP.
    //
    IoCompleteRequest (connectIrp, AfdPriorityBoost);

    return STATUS_PENDING;
}


VOID
AfdSanReleaseConnection (
    PAFD_ENDPOINT   ListenEndpoint,
    PAFD_CONNECTION Connection,
    BOOLEAN CheckBacklog
    )
{
    LONG    failedAdds;
    failedAdds = InterlockedDecrement (
        &ListenEndpoint->Common.VcListening.FailedConnectionAdds);

    if (CheckBacklog || failedAdds>=0) {
        if (!IS_DELAYED_ACCEPTANCE_ENDPOINT (ListenEndpoint)) {
            InterlockedPushEntrySList (
                &ListenEndpoint->Common.VcListening.FreeConnectionListHead,
                &Connection->SListEntry
                );
            return;
        }
        else {
            NTSTATUS    status;
            status = AfdDelayedAcceptListen (ListenEndpoint, Connection);
            if (NT_SUCCESS (status)) {
                return;
            }
        }
    }

    InterlockedIncrement(
        &ListenEndpoint->Common.VcListening.FailedConnectionAdds
        );
    DEREFERENCE_CONNECTION (Connection);
}

VOID
AfdSanCancelConnect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Cancels a connection indication IRP from SAN provider

Arguments:

    DeviceObject - not used.

    Irp - the IRP to cancel.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION  irpSp;
    PAFD_CONNECTION     connection;
    PAFD_ENDPOINT       endpoint;
    AFD_LOCK_QUEUE_HANDLE  lockHandle;

    UNREFERENCED_PARAMETER (DeviceObject);

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    connection = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    ASSERT (connection->Type==AfdBlockTypeConnection);
    ASSERT (connection->SanConnection);

    endpoint = connection->Endpoint;
    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));
    ASSERT (endpoint->Listening);

    ASSERT (KeGetCurrentIrql ()==DISPATCH_LEVEL);
    AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &lockHandle);
    //
    // If IRP still there, cancel it.
    // Otherwise, it is being completed anyway.
    //
    if (connection->ConnectIrp!=NULL) {
        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanCancelConnect: endp-%p, irp-%p\n",
                        endpoint, Irp));
        }
        ASSERT (connection->ConnectIrp == Irp);
        connection->ConnectIrp = NULL;
        ASSERT (connection->Endpoint == endpoint);
        connection->Endpoint = NULL;
        connection->SanConnection = FALSE;
        ASSERT (connection->State == AfdConnectionStateUnaccepted ||
                    connection->State==AfdConnectionStateReturned);
        RemoveEntryList (&connection->ListEntry);

        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

        ASSERT ((endpoint->Type&AfdBlockTypeVcListening)==AfdBlockTypeVcListening);
        AfdSanReleaseConnection (endpoint, connection, TRUE);
        DEREFERENCE_ENDPOINT (endpoint);

        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, AfdPriorityBoost);
    }
    else {
        //
        // Irp is about to be completed.
        //
        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
        IoReleaseCancelSpinLock (Irp->CancelIrql);
    }
}

VOID
AfdSanCancelAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Cancels an accept IRP from application waiting on accept
    completion from SAN

Arguments:

    DeviceObject - not used.

    Irp - the IRP to cancel.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION  irpSp;
    PFILE_OBJECT        acceptFileObject;
    PAFD_ENDPOINT       acceptEndpoint;
    AFD_LOCK_QUEUE_HANDLE  lockHandle;

    UNREFERENCED_PARAMETER (DeviceObject);

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    acceptFileObject = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    acceptEndpoint = acceptFileObject->FsContext;
    ASSERT (acceptEndpoint->Type==AfdBlockTypeSanEndpoint);

    ASSERT (KeGetCurrentIrql()==DISPATCH_LEVEL);
    AfdAcquireSpinLockAtDpcLevel (&acceptEndpoint->SpinLock, &lockHandle);
    //
    // If IRP still there, cancel it.
    // Otherwise, it is being completed anyway.
    //
    if (Irp->Tail.Overlay.ListEntry.Flink!=NULL) {
        RemoveEntryList (&Irp->Tail.Overlay.ListEntry);

        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanCancelAccept: endp-%p, irp-%p\n",
                        acceptEndpoint, Irp));
        }
        if (!acceptEndpoint->EndpointCleanedUp) {
            ASSERT (acceptEndpoint->Common.SanEndp.SanHlpr!=NULL);
            DEREFERENCE_ENDPOINT (acceptEndpoint->Common.SanEndp.SanHlpr);


            //
            // Make sure we cleanup all the fields since they will be
            // treated as other part (VC) of the endpoint union.
            //
            RtlZeroMemory (&acceptEndpoint->Common.SanEndp,
                            sizeof (acceptEndpoint->Common.SanEndp));


            //
            // Reinitialize the endpoint structure.
            //

            acceptEndpoint->Type = AfdBlockTypeEndpoint;
            acceptEndpoint->State = AfdEndpointStateOpen;
            acceptEndpoint->DisconnectMode = 0;
            acceptEndpoint->EndpointStateFlags = 0;
        }

        AfdReleaseSpinLockFromDpcLevel (&acceptEndpoint->SpinLock, &lockHandle);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

        AFD_END_STATE_CHANGE (acceptEndpoint);


        //
        // Dereference accept file object and complete the IRP.
        //
        ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );
        ObDereferenceObject (acceptFileObject);
        
        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, AfdPriorityBoost);
    }
    else {
        //
        // Irp is about to be completed.
        //
        AfdReleaseSpinLockFromDpcLevel (&acceptEndpoint->SpinLock, &lockHandle);
        IoReleaseCancelSpinLock (Irp->CancelIrql);
    }
}


VOID
AfdSanCancelRequest (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Cancels a redirected IRP 

Arguments:

    DeviceObject - not used.

    Irp - the IRP to cancel.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION  irpSp;
    PAFD_ENDPOINT       endpoint;
    AFD_LOCK_QUEUE_HANDLE  lockHandle;

    UNREFERENCED_PARAMETER (DeviceObject);

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    endpoint = irpSp->FileObject->FsContext;
    ASSERT (endpoint->Type==AfdBlockTypeSanEndpoint);


    ASSERT (KeGetCurrentIrql ()==DISPATCH_LEVEL);
    AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &lockHandle);
    //
    // If IRP still there, cancel it.
    // Otherwise, it is being completed anyway.
    //
    if (Irp->Tail.Overlay.ListEntry.Flink!=NULL) {
        BOOLEAN needRestartProcessing = FALSE;
        RemoveEntryList (&Irp->Tail.Overlay.ListEntry);

        if (AFD_SWITCH_REQUEST_TYPE (Irp->AfdSanRequestInfo.AfdSanRequestCtx)
                        == AFD_SWITCH_REQUEST_TFCTX) {
            //
            // Request being cancelled is transfer request. We are suspending
            // other requests while processing this one, so we need to reset
            // the transfer status to allow further requests to proceed and
            // if there are some requests pending already, we need to initiate
            // them but only AFTER we informed the switch that transfer request
            // was cancelled.
            //
            ASSERT (endpoint->Common.SanEndp.CtxTransferStatus==STATUS_PENDING);
            if (!IsListEmpty (&endpoint->Common.SanEndp.IrpList)) {
                needRestartProcessing = TRUE;
            }
            else {
                endpoint->Common.SanEndp.CtxTransferStatus = STATUS_SUCCESS;
            }
        }

        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
        IoReleaseCancelSpinLock (Irp->CancelIrql);
        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanCancelRequest: endp-%p, irp-%p, context-%p\n",
                        endpoint, Irp, Irp->AfdSanRequestInfo.AfdSanRequestCtx));
        }
        
        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;

        if (Irp->AfdSanRequestInfo.AfdSanRequestCtx!=NULL) {
            //
            // Notify the switch that request was cancelled
            //

            AfdSanNotifyRequest (endpoint, Irp->AfdSanRequestInfo.AfdSanRequestCtx,
                                            STATUS_CANCELLED,
                                            0);
            if (needRestartProcessing) {
                AfdSanRestartRequestProcessing (endpoint, STATUS_SUCCESS);
            }
        }
        else {
            ASSERT (needRestartProcessing==FALSE);
        }


        IoCompleteRequest (Irp, AfdPriorityBoost);
    }
    else {
        //
        // Irp is about to be completed.
        //
        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
        IoReleaseCancelSpinLock (Irp->CancelIrql);
    }
}


NTSTATUS
AfdSanRestartRequestProcessing (
    PAFD_ENDPOINT   Endpoint,
    NTSTATUS        Status
    )
/*++

Routine Description:

    Restarts request processing after completion of the
    transfer context request.

Arguments:

    Endpoint - endpoint on which to restart request processing
    Status   - new context transfer status


Return Value:

    NTSTATUS     previous transfer status
--*/
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    NTSTATUS    oldStatus;
    
Again:
    
    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    if (!IS_SAN_ENDPOINT (Endpoint)) {
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
        return STATUS_INVALID_HANDLE;
    }

    oldStatus = Endpoint->Common.SanEndp.CtxTransferStatus;


    ASSERT (Status!=STATUS_PENDING && Status!=STATUS_MORE_PROCESSING_REQUIRED);

    //
    // The enpoint should have just finished transferring context
    // from one process to another.  The CtxTransferStatus
    // should still be pending or failure (e.g. if we jumped with
    // goto below while another thread produced a failure).
    //
    ASSERT (Endpoint->Common.SanEndp.CtxTransferStatus==STATUS_PENDING ||
                Endpoint->Common.SanEndp.CtxTransferStatus==STATUS_MORE_PROCESSING_REQUIRED ||
                !NT_SUCCESS (Endpoint->Common.SanEndp.CtxTransferStatus) ||
                !NT_SUCCESS (Status));

    if (!NT_SUCCESS (Status)) {
        PLIST_ENTRY  irpList = NULL;
        PVOID        savedContext = NULL;

        //
        // Cleanup paged pool context that we saved for the switch.
        //
        if (Endpoint->Common.SanEndp.CtxTransferStatus==STATUS_MORE_PROCESSING_REQUIRED &&
                Endpoint->Common.SanEndp.SavedContext!=NULL) {
            //
            // Save it to free when we release the spinlock - can free
            // paged pool at DPC.
            //
            ASSERT (IS_SYSTEM_ADDRESS (Endpoint->Common.SanEndp.SavedContext));
            savedContext = Endpoint->Common.SanEndp.SavedContext;
            Endpoint->Common.SanEndp.SavedContext = NULL;
            Endpoint->Common.SanEndp.SavedContextLength = 0;
        }

        //
        // Reset the status to failure and get rid of all the requests
        // after spinlock is released.
        //
        Endpoint->Common.SanEndp.CtxTransferStatus = Status;
        
        while (!IsListEmpty (&Endpoint->Common.SanEndp.IrpList)) {
            PLIST_ENTRY listEntry;
            listEntry = RemoveHeadList (&Endpoint->Common.SanEndp.IrpList);
            //
            // Mark Flink so that cancel routine knows that request is being completed.
            // Use Blink to create a singly-linked list of IRPs to complete.
            //
            listEntry->Flink = NULL;
            listEntry->Blink = irpList;
            irpList = listEntry;
        }
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);

        if (savedContext!=NULL) {
            InterlockedExchangeAdd (&Endpoint->Common.SanEndp.SanHlpr->Common.SanHlpr.PendingRequests, -2);
            AFD_FREE_POOL (savedContext, AFD_SAN_CONTEXT_POOL_TAG);
        }

        while (irpList!=NULL) {
            PIRP    irp;
            irp = CONTAINING_RECORD (irpList, IRP, Tail.Overlay.ListEntry);
            irpList = irp->Tail.Overlay.ListEntry.Blink;
            if (irp->AfdSanRequestInfo.AfdSanRequestCtx!=NULL) {
                InterlockedExchangeAdd (&Endpoint->Common.SanEndp.SanHlpr->Common.SanHlpr.PendingRequests, -2);
            }
            //
            // Check if request is being cancelled and synchronize
            // with the cancel routine if so.
            //
            if (IoSetCancelRoutine (irp, NULL)==NULL) {
                KIRQL cancelIrql;
                IoAcquireCancelSpinLock (&cancelIrql);
                IoReleaseCancelSpinLock (cancelIrql);
            }
            irp->IoStatus.Status = Status;
            irp->IoStatus.Information = 0;
            IoCompleteRequest (irp, AfdPriorityBoost);
        }
    }
    else if (Endpoint->Common.SanEndp.CtxTransferStatus==STATUS_PENDING ||
                Endpoint->Common.SanEndp.CtxTransferStatus==STATUS_MORE_PROCESSING_REQUIRED) 
    {
        PLIST_ENTRY listEntry;
        NTSTATUS    status;
        //
        // Scan the list for the request that have not been comminicated
        // to the switch.
        //
        listEntry = Endpoint->Common.SanEndp.IrpList.Flink;
        while (listEntry!=&Endpoint->Common.SanEndp.IrpList) {
            ULONG_PTR   requestInfo;
            ULONG       requestType;
            PVOID       requestCtx;
            PIRP        irp = CONTAINING_RECORD (listEntry,
                                            IRP,
                                            Tail.Overlay.ListEntry);
            listEntry = listEntry->Flink;

            //
            // The transfer was successfull, continue processing requests
            //
            if (irp->AfdSanRequestInfo.AfdSanRequestCtx==NULL) {
                //
                // This request has not been communicated to the switch.
                //
                PIO_STACK_LOCATION  irpSp;

                //
                // Create request context based on request type.
                //
                irpSp = IoGetCurrentIrpStackLocation (irp);
                switch (irpSp->MajorFunction) {
                case IRP_MJ_READ:
                    requestType = AFD_SWITCH_REQUEST_READ;
                    requestInfo = irpSp->Parameters.Read.Length;
                    break;
                case IRP_MJ_WRITE:
                    requestType = AFD_SWITCH_REQUEST_WRITE;
                    requestInfo = irpSp->Parameters.Write.Length;
                    break;
                case IRP_MJ_DEVICE_CONTROL:
                    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
                    case IOCTL_AFD_SWITCH_ACQUIRE_CTX:
                        requestType = AFD_SWITCH_REQUEST_TFCTX;
                        requestInfo = (ULONG_PTR)irp->AfdSanRequestInfo.AfdSanProcessId;
                        break;
                    default:
                        ASSERT (!"Unsupported IOCTL");
                        __assume (0);
                    }
                    break;

                default:
                    ASSERT (!"Unsupported IRP Major Function");
                    __assume (0);
                }
                requestCtx = AFD_SWITCH_MAKE_REQUEST_CONTEXT(
                                Endpoint->Common.SanEndp.RequestId,
                                requestType);
                irp->AfdSanRequestInfo.AfdSanRequestCtx = requestCtx;
                Endpoint->Common.SanEndp.RequestId += 1;
                UPDATE_ENDPOINT2 (Endpoint,
                                "AfdSanRestartRequestProcessing, restarting req: 0x%lX",
                                 PtrToUlong (requestCtx));
                AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);

                status = AfdSanNotifyRequest (Endpoint, requestCtx, STATUS_SUCCESS, requestInfo);
                if (NT_SUCCESS (status)) {
                    if (requestType==AFD_SWITCH_REQUEST_TFCTX) {

                        //
                        // If we successfully sent another context transfer request, we should
                        // stop processing until this request is completed.  The context transfer
                        // flag should remain set.
                        //
                        return oldStatus;
                    }
                }
                else {
                    PIRP    irp1;
                    //
                    // If notification failed, fail the request.  The IRP
                    // could have been cancelled, so we have to search for
                    // it in the list.
                    //
                    irp1 = AfdSanDequeueRequest (Endpoint, requestCtx);
                    if (irp1!=NULL) {
                        ASSERT (irp1==irp);
                        irp1->IoStatus.Status = status;
                        IoCompleteRequest (irp1, AfdPriorityBoost);
                    }
                }

                //
                // Reacquire the lock and continue processing from the beginning
                // as the list could have changed while spinlock was released.
                //
                goto Again;
            }
            else {
                //
                // IRP has already been forwarded to the switch, leave it alone
                //
            }
        }

        //
        // Ran till the end of the list and did not find another transfer request.
        // We can reset the flag now.
        //
        Endpoint->Common.SanEndp.CtxTransferStatus = Status;
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
    }
    else {
        //
        // This can only occur if we have already failed before and
        // there are thus should be no irps in the list.
        //
        ASSERT (IsListEmpty (&Endpoint->Common.SanEndp.IrpList));
        ASSERT (!NT_SUCCESS (Endpoint->Common.SanEndp.CtxTransferStatus));
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
    }

    return oldStatus;
}


PIRP
AfdSanDequeueRequest (
    PAFD_ENDPOINT   SanEndpoint,
    PVOID           RequestCtx
    )
/*++

Routine Description:

    Removes the request from the san endpoint list 

Arguments:

    SanEndpoint - endpoint from which to remove the request

    RequestCtx - context that identifies the request

Return Value:

    The request or NULL is not found.

--*/
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY listEntry;

    ASSERT (RequestCtx!=NULL);

    AfdAcquireSpinLock (&SanEndpoint->SpinLock, &lockHandle);
    if (!IS_SAN_ENDPOINT (SanEndpoint)) {
        AfdReleaseSpinLock (&SanEndpoint->SpinLock, &lockHandle);
        return NULL;
    }
    listEntry = SanEndpoint->Common.SanEndp.IrpList.Flink;
    //
    // Walk the list till we find the request
    //
    while (listEntry!=&SanEndpoint->Common.SanEndp.IrpList) {
        PIRP    irp = CONTAINING_RECORD (listEntry,
                                        IRP,
                                        Tail.Overlay.ListEntry);
        listEntry = listEntry->Flink;
        if (irp->AfdSanRequestInfo.AfdSanRequestCtx==RequestCtx) {
            RemoveEntryList (&irp->Tail.Overlay.ListEntry);
            irp->Tail.Overlay.ListEntry.Flink = NULL;
            AfdReleaseSpinLock (&SanEndpoint->SpinLock, &lockHandle);
            //
            // Check if request is being cancelled and synchronize
            // with the cancel routine if so.
            //
            if (IoSetCancelRoutine (irp, NULL)==NULL) {
                KIRQL cancelIrql;
                IoAcquireCancelSpinLock (&cancelIrql);
                IoReleaseCancelSpinLock (cancelIrql);
            }

            InterlockedExchangeAdd (&SanEndpoint->Common.SanEndp.SanHlpr->Common.SanHlpr.PendingRequests, -2);
            return irp;
        }
        else if (irp->AfdSanRequestInfo.AfdSanRequestCtx==NULL) {
            break;
        }
    }
    AfdReleaseSpinLock (&SanEndpoint->SpinLock, &lockHandle);
    return NULL;
}

NTSTATUS
AfdSanNotifyRequest (
    PAFD_ENDPOINT   SanEndpoint,
    PVOID           RequestCtx,
    NTSTATUS        Status,
    ULONG_PTR       Information
    )
{
    PVOID   context;
    PAFD_ENDPOINT   sanHlprEndpoint;
    NTSTATUS    status;

    PAGED_CODE ();

    context = AfdLockEndpointContext (SanEndpoint);
    if (IS_SAN_ENDPOINT (SanEndpoint)) {

        //
        // Get the san helper endpoint which we use to communicate
        // with the switch
        //
        sanHlprEndpoint = SanEndpoint->Common.SanEndp.SanHlpr;
        ASSERT (IS_SAN_HELPER (sanHlprEndpoint));

        //
        // Increment the count of outstanding requests and verify that
        // helper endpoint is still active and thus the process can
        // accept the requests.
        //
        if ((InterlockedExchangeAdd (&sanHlprEndpoint->Common.SanHlpr.PendingRequests, 2) & 1)==0) {
            ASSERT ((ULONG_PTR)SanEndpoint->Common.SanEndp.SwitchContext<MM_USER_PROBE_ADDRESS);        //
            // Notify the switch about the request.
            //
            status = IoSetIoCompletion (
                        sanHlprEndpoint->Common.SanHlpr.IoCompletionPort,// Port
                        SanEndpoint->Common.SanEndp.SwitchContext,  // Key
                        RequestCtx,                                 // ApcContext
                        Status,                                     // Status
                        Information,                                // Information
                        TRUE                                        // ChargeQuota
                        );
        }
        else {
            status = STATUS_CANCELLED;
        }
    }
    else {
        status = STATUS_INVALID_HANDLE;
    }

    AfdUnlockEndpointContext (SanEndpoint, context);
    return status;
}



NTSTATUS
AfdSanPollBegin (
    PAFD_ENDPOINT   Endpoint,
    ULONG           EventMask
    )
/*++

Routine Description:

    Records poll call so that switch knows to notify AFD to complete
    select/AsyncSelect/EventSelect requests

Arguments:

    Endpoint - endpoint to record

    EventMask - events that needs to be notified

Return Value:

    NTSTATUS - may fail to access user mode address

Note:
    This routine must be called in the context of user mode process
    that owns the endpoint
--*/
{
    LONG   currentEvents, newEvents;
    PVOID context;
    BOOLEAN attached = FALSE;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE ();
    
    context = AfdLockEndpointContext (Endpoint);
    if (IS_SAN_ENDPOINT (Endpoint)) {

        if (IoGetCurrentProcess()!=Endpoint->Common.SanEndp.SanHlpr->OwningProcess) {
            KeAttachProcess (PsGetProcessPcb(Endpoint->Common.SanEndp.SanHlpr->OwningProcess));
            attached = TRUE;
        }

        try {

            //
            // Increment appropriate counts to inform the switch that we are interested
            // in the event.
            //
            if (EventMask & AFD_POLL_RECEIVE) {
                InterlockedIncrement (&Endpoint->Common.SanEndp.SwitchContext->RcvCount);

                //
                // Inform switch that select has happened on this endpoint
                //
                Endpoint->Common.SanEndp.SwitchContext->SelectFlag = TRUE;
            }
            if (EventMask & AFD_POLL_RECEIVE_EXPEDITED) {
                InterlockedIncrement (&Endpoint->Common.SanEndp.SwitchContext->ExpCount);
            }
            if (EventMask & AFD_POLL_SEND) {
                InterlockedIncrement (&Endpoint->Common.SanEndp.SwitchContext->SndCount);
            }

            //
            // Update our event record.
            //
            do {
                currentEvents = *((LONG volatile *)&Endpoint->Common.SanEndp.SelectEventsActive);
                newEvents = *((LONG volatile *)&Endpoint->Common.SanEndp.SwitchContext->EventsActive);
            }
            while (InterlockedCompareExchange (
                        (PLONG)&Endpoint->Common.SanEndp.SelectEventsActive,
                        newEvents,
                        currentEvents)!=currentEvents);

        }
        except (AFD_EXCEPTION_FILTER (status)) {
            ASSERT (NT_ERROR (status));
        }

        if (attached) {
            KeDetachProcess ();
        }
    }

    AfdUnlockEndpointContext (Endpoint, context);

    return status;
}

VOID
AfdSanPollEnd (
    PAFD_ENDPOINT   Endpoint,
    ULONG           EventMask
    )
/*++

Routine Description:

    Records poll call completion, so that switch can avoild expensive calls to notify AFD 
    to complete select/AsyncSelect/EventSelect requests

Arguments:

    Endpoint - endpoint to record

    EventMask - events that needs to be dereferenced

Return Value:

    NTSTATUS - may fail to access user mode address

Note:
    This routine must be called in the context of user mode process
    that owns the endpoint
--*/
{
    BOOLEAN attached = FALSE;
    PVOID context;

    PAGED_CODE ();
    
    context = AfdLockEndpointContext (Endpoint);
    if (IS_SAN_ENDPOINT (Endpoint)) {

        if (IoGetCurrentProcess()!=Endpoint->Common.SanEndp.SanHlpr->OwningProcess) {
            KeAttachProcess (PsGetProcessPcb(Endpoint->Common.SanEndp.SanHlpr->OwningProcess));
            attached = TRUE;
        }

        try {

            //
            // Decrement appropriate counts to inform the switch that we are no longer interested
            // in the event.
            //
            if (EventMask & AFD_POLL_RECEIVE) {
                InterlockedDecrement (&Endpoint->Common.SanEndp.SwitchContext->RcvCount);
            }
            if (EventMask & AFD_POLL_RECEIVE_EXPEDITED) {
                InterlockedDecrement (&Endpoint->Common.SanEndp.SwitchContext->ExpCount);
            }
            if (EventMask & AFD_POLL_SEND) {
                InterlockedDecrement (&Endpoint->Common.SanEndp.SwitchContext->SndCount);
            }

        }
        except (AFD_EXCEPTION_FILTER_NO_STATUS()) {
            //
            // Not much we can do. The switch will have to call us with all the events.
            //
        }

        if (attached) {
            KeDetachProcess ();
        }
    }

    AfdUnlockEndpointContext (Endpoint, context);

}



VOID
AfdSanPollUpdate (
    PAFD_ENDPOINT   Endpoint,
    ULONG           EventMask
    )
/*++

Routine Description:

    Updates local kernel information currently outstanding polls on the
    endpoint to be later merged into information maitained by the switch

Arguments:

    Endpoint - endpoint to record

    EventMask - events that needs to be recorded

Return Value:

    None
--*/
{

    ASSERT (IS_SAN_ENDPOINT (Endpoint));
    ASSERT (KeGetCurrentIrql()==DISPATCH_LEVEL);
    ASSERT (Endpoint->Common.SanEndp.LocalContext!=NULL);

    if (EventMask & AFD_POLL_RECEIVE) {
        InterlockedIncrement (&Endpoint->Common.SanEndp.LocalContext->RcvCount);
    }
    if (EventMask & AFD_POLL_RECEIVE_EXPEDITED) {
        InterlockedIncrement (&Endpoint->Common.SanEndp.LocalContext->ExpCount);
    }
    if (EventMask & AFD_POLL_SEND) {
        InterlockedIncrement (&Endpoint->Common.SanEndp.LocalContext->SndCount);
    }
}


NTSTATUS
AfdSanPollMerge (
    PAFD_ENDPOINT       Endpoint,
    PAFD_SWITCH_CONTEXT Context
    )
/*++

Routine Description:

    Merges information about outstanding poll calls into switch counts.

Arguments:

    Endpoint - endpoint to record

    Context - outstanding select info merge in

Return Value:

    NTSTATUS - may fail to access user mode address

Note:
    This routine must be called in the context of user mode process
    that owns the endpoint
--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PAGED_CODE ();

    ASSERT (IoGetCurrentProcess()==Endpoint->Common.SanEndp.SanHlpr->OwningProcess);
    ASSERT (Endpoint->Common.SanEndp.LocalContext == Context);

    try {

        InterlockedExchangeAdd (&Endpoint->Common.SanEndp.SwitchContext->RcvCount,
                                    Context->RcvCount);
        InterlockedExchangeAdd (&Endpoint->Common.SanEndp.SwitchContext->SndCount,
                                    Context->SndCount);
        InterlockedExchangeAdd (&Endpoint->Common.SanEndp.SwitchContext->ExpCount,
                                    Context->ExpCount);
    }
    except (AFD_EXCEPTION_FILTER (status)) {
        ASSERT (NT_ERROR (status));
    }
    return status;
}


VOID
AfdSanInitEndpoint (
    PAFD_ENDPOINT   SanHlprEndpoint,
    PFILE_OBJECT    SanFileObject,
    PAFD_SWITCH_CONTEXT SwitchContext
    )
/*++

Routine Description:

    Initializes SAN endpoint structure

Arguments:

    SanHlprEndpoint - switch helper endpoint - communication channel
                        between the switch and AFD for the owner process.

    SanFile - file object for the endpoint to be initialized.

Return Value:

    None

--*/
{
    PAFD_ENDPOINT   sanEndpoint = SanFileObject->FsContext;

    ASSERT (IS_SAN_HELPER(SanHlprEndpoint));

    REFERENCE_ENDPOINT (SanHlprEndpoint);
    sanEndpoint->Common.SanEndp.SanHlpr = SanHlprEndpoint;
    
    sanEndpoint->Common.SanEndp.FileObject = SanFileObject;
    sanEndpoint->Common.SanEndp.SwitchContext = SwitchContext;
    // sanEndpoint->Common.SanEndp.SavedContext = NULL;
    sanEndpoint->Common.SanEndp.LocalContext = NULL;
    InitializeListHead (&sanEndpoint->Common.SanEndp.IrpList);
    sanEndpoint->Common.SanEndp.SelectEventsActive = 0;
    sanEndpoint->Common.SanEndp.RequestId = 1;
    sanEndpoint->Common.SanEndp.CtxTransferStatus = STATUS_SUCCESS;
    sanEndpoint->Common.SanEndp.ImplicitDup = FALSE;

    //
    // HACKHACK.  Force IO subsystem to call us when last handle to the file is closed
    // in any given process.
    //
    SanFileObject->LockOperation = TRUE;
    sanEndpoint->Type = AfdBlockTypeSanEndpoint;

}


VOID
AfdSanAbortConnection (
    PAFD_CONNECTION Connection
    )
{
    PIRP    connectIrp;
    PDRIVER_CANCEL  cancelRoutine;
    KIRQL cancelIrql;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT   endpoint = Connection->Endpoint;

    ASSERT (Connection->SanConnection==TRUE);

    //
    // Acquire cancel spinlock and endpoint spinlock in
    // this order and recheck the accept IRP
    //

    IoAcquireCancelSpinLock (&cancelIrql);
    AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &lockHandle);
    connectIrp = Connection->ConnectIrp;
    if ((connectIrp!=NULL) && 
            ((cancelRoutine=IoSetCancelRoutine (connectIrp, NULL))!=NULL)) {
        //
        // Accept IRP was still there and was not cancelled/completed
        // cancel it
        //
        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
        connectIrp->CancelIrql = cancelIrql;
        connectIrp->Cancel = TRUE;
        (*cancelRoutine) (AfdDeviceObject, connectIrp);
    }
    else {
        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
        IoReleaseCancelSpinLock (cancelIrql);
    }
}

VOID
AfdSanCleanupEndpoint (
    PAFD_ENDPOINT   Endpoint
    )

/*++

Routine Description:

    Cleans up SAN specific fields in AFD_ENDPOINT
Arguments:
    Endpoint - endpoint to cleanup

Return Value:
    None
--*/
{
    PAFD_ENDPOINT   sanHlprEndpoint;

    ASSERT (IsListEmpty (&Endpoint->Common.SanEndp.IrpList));
    ASSERT (Endpoint->Common.SanEndp.LocalContext == NULL);

    sanHlprEndpoint = Endpoint->Common.SanEndp.SanHlpr;

    ASSERT (sanHlprEndpoint!=NULL);
    ASSERT (IS_SAN_HELPER (sanHlprEndpoint));
    DEREFERENCE_ENDPOINT (sanHlprEndpoint);
    Endpoint->Common.SanEndp.SanHlpr = NULL;
}

VOID
AfdSanCleanupHelper (
    PAFD_ENDPOINT   Endpoint
    )

/*++

Routine Description:

    Cleans up SAN helper specific fields in AFD_ENDPOINT
Arguments:
    Endpoint - endpoint to cleanup

Return Value:
    None
--*/
{
    ASSERT  (Endpoint->Common.SanHlpr.IoCompletionPort!=NULL);
    ObDereferenceObject (Endpoint->Common.SanHlpr.IoCompletionPort);
    Endpoint->Common.SanHlpr.IoCompletionPort = NULL;
    ASSERT  (Endpoint->Common.SanHlpr.IoCompletionEvent!=NULL);
    ObDereferenceObject (Endpoint->Common.SanHlpr.IoCompletionEvent);
    Endpoint->Common.SanHlpr.IoCompletionEvent = NULL;
    
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );

    ASSERT (IS_SAN_HELPER (Endpoint));
    ASSERT (AfdSanServiceHelper!=Endpoint); // Should have been removed in cleanup.

    ASSERT (!IsListEmpty (&Endpoint->Common.SanHlpr.SanListLink));

    RemoveEntryList (&Endpoint->Common.SanHlpr.SanListLink);
    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();
}


VOID
AfdSanHelperCleanup (
    PAFD_ENDPOINT   SanHlprEndpoint
    )
{
    if (InterlockedIncrement (&SanHlprEndpoint->Common.SanHlpr.PendingRequests)!=1) {
        PLIST_ENTRY listEntry;
        

        //
        // Scan the endpoint list and cleanup all requests in the san endpoints
        // that refer to this helper endpoint.
        //
        KeEnterCriticalRegion ();
        ExAcquireResourceSharedLite( AfdResource, TRUE );
        listEntry = AfdEndpointListHead.Flink;
        while (listEntry!=&AfdEndpointListHead) {
            PAFD_ENDPOINT   sanEndpoint;

            sanEndpoint = CONTAINING_RECORD (listEntry, AFD_ENDPOINT, GlobalEndpointListEntry);
            if (IS_SAN_ENDPOINT (sanEndpoint) &&
                    sanEndpoint->Common.SanEndp.SanHlpr==SanHlprEndpoint &&
                    !IsListEmpty (&sanEndpoint->Common.SanEndp.IrpList)) {
                AfdSanRestartRequestProcessing (sanEndpoint, STATUS_CANCELLED);
            }
            listEntry = listEntry->Flink;
        }
        ExReleaseResourceLite( AfdResource );
        KeLeaveCriticalRegion ();
    }

    if (SanHlprEndpoint==AfdSanServiceHelper) {
        //
        // Last handle to the service helper is being closed in
        // the service process (there must be some duplicates around).
        // We can no longer count on it, clear our global.
        //
        KeEnterCriticalRegion ();
        ExAcquireResourceExclusiveLite( AfdResource, TRUE );
        //
        // Re-check under the lock.
        //
        if (SanHlprEndpoint==AfdSanServiceHelper) {
            AfdSanServiceHelper = NULL;
        }
        ExReleaseResourceLite( AfdResource );
        KeLeaveCriticalRegion ();
    }
}


BOOLEAN
AfdSanReferenceEndpointObject (
    PAFD_ENDPOINT   Endpoint
    )
/*++

Routine Description:

    Reference file object with which san endpoint is associated

Arguments:
    Endpoint    - endpoint of interest
Return Value:
    TRUE    - reference successed
    FALSE   - endpoint has already been cleaned up and its file object
                is about to be closed.
--*/
{
    BOOLEAN res = TRUE;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    if (!Endpoint->EndpointCleanedUp) {
        ObReferenceObject (Endpoint->Common.SanEndp.FileObject);
    }
    else {
        res = FALSE;
    }
    AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
    return res;
}

NTSTATUS
AfdSanReferenceSwitchSocketByHandle (
    IN HANDLE              SocketHandle,
    IN ACCESS_MASK         DesiredAccess,
    IN KPROCESSOR_MODE     RequestorMode,
    IN PAFD_ENDPOINT       SanHlprEndpoint,
    IN PAFD_SWITCH_CONTEXT SwitchContext OPTIONAL,
    OUT PFILE_OBJECT       *FileObject
    )
/*++

Routine Description:

    Finds and validates AFD endpoint based on the handle/context combination passed in
    by the switch.
Arguments:
    SocketHandle    - Socket handle being referenced
    DesiredAccess   - Required access to the object to perform operation
    RequestorMode   - Mode of the caller
    SanHlprEndpoint - helper endpoint - communication channel between AFD and switch
    SwitchContext   - context associated by the switch with the socket being referenced
    FileObject      - file object corresponding to socket handle
Return Value:
    STATUS_SUCCESS - operation succeeded
    other - failed to find/access endpoint associated with the socket handle/context
--*/
{
    NTSTATUS    status;

    if (IS_SAN_HELPER (SanHlprEndpoint) &&
            SanHlprEndpoint->OwningProcess==IoGetCurrentProcess ()) {
        status = ObReferenceObjectByHandle (
                                SocketHandle,
                                DesiredAccess,
                                *IoFileObjectType,
                                RequestorMode,
                                FileObject,
                                NULL
                                );
        if (NT_SUCCESS (status) && 
                (*FileObject)->DeviceObject==AfdDeviceObject &&
                //
                // Ether socket belongs to the current process and context matches
                // the one supplied by the switch
                //
                ((IS_SAN_ENDPOINT((PAFD_ENDPOINT)(*FileObject)->FsContext) &&
                    ((PAFD_ENDPOINT)((*FileObject)->FsContext))->Common.SanEndp.SanHlpr==SanHlprEndpoint &&
                    ((PAFD_ENDPOINT)((*FileObject)->FsContext))->Common.SanEndp.SwitchContext==SwitchContext)

                                ||
                    //
                    // Or this is just a non-SAN socket being converted to one or just
                    // used for select signalling.
                    //
                    (SwitchContext==NULL &&
                        ((PAFD_ENDPOINT)(*FileObject)->FsContext)->Type==AfdBlockTypeEndpoint)) ){
            NOTHING;
        }
        else {
            if (NT_SUCCESS (status)) {
                //
                // Undo object referencing since it doesn't match the one that switch expects
                //
                ObDereferenceObject (*FileObject);
                status = STATUS_INVALID_HANDLE;
            }

            //
            // If switch supplied the context, try to find the socket
            // in the current process that has the same one.
            //
            if (SwitchContext!=NULL) {
                status = AfdSanFindSwitchSocketByProcessContext (
                            status,
                            SanHlprEndpoint,
                            SwitchContext,
                            FileObject);
            }
        }
    }
    else
        status = STATUS_INVALID_HANDLE;

    return status;
}

NTSTATUS
AfdSanFindSwitchSocketByProcessContext (
    IN NTSTATUS             Status,
    IN PAFD_ENDPOINT        SanHlprEndpoint,
    IN PAFD_SWITCH_CONTEXT  SwitchContext,
    OUT PFILE_OBJECT        *FileObject
    )
/*++

Routine Description:

    Find SAN endpoint given its process (helper endpoint) and switch context.

Arguments:
    Status          - status returned by the ob object reference operation
                        (to be propagated to the caller in case of failure).
    SanHlprEndpoint - helper endpoint for the process to look in
    SwitchContext   - switch context associated with the endpoint
    FileObject      - returns endpont's file object if found
Return Value:
    STATUS_SUCCESS - san endpoint was found
    other - failed to find endpoint based on the switch context.
--*/
{
    PLIST_ENTRY listEntry;
    PAFD_ENDPOINT   sanEndpoint = NULL;
    HANDLE  socketHandle;
    PVOID   context;

    PAGED_CODE ();

    //
    // Walk the global endpoint list and try to find the entry 
    // that matches the switch context
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceSharedLite (AfdResource, TRUE);
    listEntry = AfdEndpointListHead.Flink;
    AFD_W4_INIT context = NULL; // Depends on variable above, but compiler does not see
                                // the connection.
    while (listEntry!=&AfdEndpointListHead) {
        sanEndpoint = CONTAINING_RECORD (listEntry, AFD_ENDPOINT, GlobalEndpointListEntry);
        context = AfdLockEndpointContext (sanEndpoint);
        if (IS_SAN_ENDPOINT (sanEndpoint) &&
                sanEndpoint->Common.SanEndp.SanHlpr==SanHlprEndpoint &&
                sanEndpoint->Common.SanEndp.SwitchContext==SwitchContext &&
            AfdSanReferenceEndpointObject (sanEndpoint)) {
            break;
        }
        AfdUnlockEndpointContext (sanEndpoint, context);
        listEntry = listEntry->Flink;
    }
    ExReleaseResourceLite (AfdResource);
    KeLeaveCriticalRegion ();

    if (listEntry==&sanEndpoint->GlobalEndpointListEntry) {

        //
        // Try to find the real handle for the switch to use in the future
        //
        *FileObject = sanEndpoint->Common.SanEndp.FileObject;
        if (ObFindHandleForObject (SanHlprEndpoint->OwningProcess,
                                            sanEndpoint->Common.SanEndp.FileObject,
                                            *IoFileObjectType,
                                            NULL,
                                            &socketHandle)) {
            UPDATE_ENDPOINT2 (sanEndpoint, 
                              "AfdSanFindSwitchSocketByProcessContext, handle: 0x%lX",
                              HandleToUlong (socketHandle));
            //
            // Notify switch of handle to be used.
            // Ignore failure, the switch will still be able to communicate via
            // slow lookup path.
            //
            IoSetIoCompletion (
                            SanHlprEndpoint->Common.SanHlpr.IoCompletionPort,
                            SwitchContext,
                            AFD_SWITCH_MAKE_REQUEST_CONTEXT (0, AFD_SWITCH_REQUEST_CHCTX),
                            STATUS_SUCCESS,
                            (ULONG_PTR)socketHandle,
                            TRUE                    // Charge quota
                            );

        }
        else {
            UPDATE_ENDPOINT2 (sanEndpoint, 
                    "AfdSanFindSwitchSocketByProcessContext, object not found from handle: 0x%lX",
                    HandleToUlong (socketHandle));
        }
        AfdUnlockEndpointContext (sanEndpoint, context);
        Status = STATUS_SUCCESS;
    }

    return Status;
}



BOOLEAN
AfdSanSetDupingToServiceState (
    PAFD_ENDPOINT   SanEndpoint
    )
/*++

Routine Description:

    Reset request pending on SAN endpoint while transfering
    context to service process.

Arguments:
    SanEndpoint - endpoint on which to reset requests.

Return Value:
    TRUE - successfully reset requests and set transfer status
    FALSE - the transfer status could not be reset
--*/
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY     listEntry;
    LONG            count = 0;
    BOOLEAN         res;

    AfdAcquireSpinLock (&SanEndpoint->SpinLock, &lockHandle);
    listEntry = SanEndpoint->Common.SanEndp.IrpList.Flink;
    while (listEntry!=&SanEndpoint->Common.SanEndp.IrpList) {
        PIRP    irp = CONTAINING_RECORD (listEntry, IRP, Tail.Overlay.ListEntry);
        if (irp->AfdSanRequestInfo.AfdSanRequestCtx!=NULL) {
            count += 2;
            irp->AfdSanRequestInfo.AfdSanRequestCtx = NULL;
        }
        listEntry = listEntry->Flink;
    }

    if (NT_SUCCESS (SanEndpoint->Common.SanEndp.CtxTransferStatus)) {
        if (SanEndpoint->Common.SanEndp.CtxTransferStatus==STATUS_PENDING)
            count += 2;
        SanEndpoint->Common.SanEndp.CtxTransferStatus = STATUS_MORE_PROCESSING_REQUIRED;
        res = TRUE;
        InterlockedExchangeAdd (
            &SanEndpoint->Common.SanEndp.SanHlpr->Common.SanHlpr.PendingRequests,
            -count);
    }
    else {
        res = FALSE;
    }

    AfdReleaseSpinLock (&SanEndpoint->SpinLock, &lockHandle);
    return res;
}

NTSTATUS
AfdSanSetAskDupeToServiceState (
    PAFD_ENDPOINT   SanEndpoint
    )
/*++

Routine Description:

    Initiates the duplication to service process by checking
    current duplication state and setting it to STATUS_PENDING
Arguments:
    SanEndpoint - endpoint on which to reset requests.

Return Value:
    Original value of CtxTransferStatus
--*/
{
    NTSTATUS status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    AfdAcquireSpinLock (&SanEndpoint->SpinLock, &lockHandle);
    status = SanEndpoint->Common.SanEndp.CtxTransferStatus;
    if (SanEndpoint->Common.SanEndp.CtxTransferStatus==STATUS_SUCCESS) {
        SanEndpoint->Common.SanEndp.CtxTransferStatus = STATUS_PENDING;
    }
    AfdReleaseSpinLock (&SanEndpoint->SpinLock, &lockHandle);
    return status;
}


NTSTATUS
AfdSanDupEndpointIntoServiceProcess (
    PFILE_OBJECT    SanFileObject,
    PVOID           SavedContext,
    ULONG           ContextLength
    )
/*++

Routine Description:

    Duplicate endpoint into the context of the service process
    and save switch context on it
Arguments:
    SanFileObject - file object being duplicated
    SaveContext   - pointer to switch context data
    ContextLength - length of the context

Return Value:
    STATUS_SUCCESS - successfully duped
    other - failed.
--*/
{
    NTSTATUS    status;
    HANDLE      handle;
    PAFD_ENDPOINT   sanEndpoint = SanFileObject->FsContext;
    PVOID   context;

    //
    // Take the lock to make sure that service helper won't
    // exit on us and take the helper endpoint with it.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceSharedLite (AfdResource, TRUE);
    if (AfdSanServiceHelper!=NULL) {

        //
        // Attach to the process and create handle for the file object.
        //

        KeAttachProcess (PsGetProcessPcb(AfdSanServiceHelper->OwningProcess));
        status = ObOpenObjectByPointer (
                                SanFileObject,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                MAXIMUM_ALLOWED,
                                *IoFileObjectType,
                                KernelMode,
                                &handle);
        KeDetachProcess ();
        if (NT_SUCCESS (status)) {
            context = AfdLockEndpointContext (sanEndpoint);

            //
            // Notify the service process that it needs to acquire endpoint context.
            //

            if (sanEndpoint->Common.SanEndp.SanHlpr!=AfdSanServiceHelper) {
                if ((InterlockedExchangeAdd (
                        &AfdSanServiceHelper->Common.SanHlpr.PendingRequests,
                        2) & 1)==0) {
                    status = IoSetIoCompletion (
                                AfdSanServiceHelper->Common.SanHlpr.IoCompletionPort,
                                NULL,
                                AFD_SWITCH_MAKE_REQUEST_CONTEXT (0,AFD_SWITCH_REQUEST_AQCTX),
                                STATUS_SUCCESS,
                                (ULONG_PTR)handle,
                                TRUE                // Charge quota
                                );
                    if (NT_SUCCESS (status)) {
                        //
                        // Check and modify the transfer status state under the 
                        // endpoint spinlock.
                        //
                        if (AfdSanSetDupingToServiceState (sanEndpoint)) {
                            UPDATE_ENDPOINT (sanEndpoint);
                            DEREFERENCE_ENDPOINT (sanEndpoint->Common.SanEndp.SanHlpr);
                            REFERENCE_ENDPOINT(AfdSanServiceHelper);
                            sanEndpoint->Common.SanEndp.SanHlpr = AfdSanServiceHelper;
                            //sanEndpoint->Common.SanEndp.SwitchContext = NULL; 
                            sanEndpoint->Common.SanEndp.SavedContext = SavedContext;
                            sanEndpoint->Common.SanEndp.SavedContextLength = ContextLength;
                            //
                            // Note that socket was duplicated implicitly without
                            // application request.
                            //
                            sanEndpoint->Common.SanEndp.ImplicitDup = TRUE;
                        }
                        else {
                            //
                            // Somehow we failed since endpoint in the wrong state
                            // already.  When service process comes back to pick
                            // it up, we will just fail the call
                            //
                            status = STATUS_CANCELLED;
                        }

                        AfdUnlockEndpointContext (sanEndpoint, context);

                        ExReleaseResourceLite (AfdResource);
                        KeLeaveCriticalRegion ();

                        return status;
                    }
                }
                else {
                    status = STATUS_CANCELLED;
                }
                InterlockedExchangeAdd (&AfdSanServiceHelper->Common.SanHlpr.PendingRequests, -2);
            }
            else {
                //
                // Endpoint is already in the service process.
                //
                status = STATUS_INVALID_PARAMETER;
            }

            AfdUnlockEndpointContext (sanEndpoint, context);

            KeAttachProcess (PsGetProcessPcb(sanEndpoint->Common.SanEndp.SanHlpr->OwningProcess));
            NtClose (handle);
            KeDetachProcess ();
        }
    }
    else {
        status = STATUS_UNSUCCESSFUL;
    }
    ExReleaseResourceLite (AfdResource);
    KeLeaveCriticalRegion ();
    return status;
}


VOID
AfdSanProcessAddrListForProviderChange (
    PAFD_ENDPOINT   SpecificEndpoint OPTIONAL
    )
/*++

Routine Description:
    Fires address list notifications for SAN helper endpoints
    to inform switch of Winsock provider list change.
Arguments:
    SpecificEndpoint - optinally indentifies specific
               helper endpoint to fire notifications for
Return Value:
    None.
--*/
{
    AFD_LOCK_QUEUE_HANDLE      lockHandle;
    PLIST_ENTRY             listEntry;
    LIST_ENTRY              completedChangeList;
    PAFD_ADDRESS_CHANGE     change;
    PAFD_REQUEST_CONTEXT    requestCtx;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpSp;
    PAFD_ENDPOINT           endpoint;
    LONG                    plsn;

    ASSERT (SpecificEndpoint==NULL || IS_SAN_HELPER (SpecificEndpoint));
    //
    // Create local list to process notifications after spinlock is released
    //

    InitializeListHead (&completedChangeList);

    //
    // Walk the list and move matching notifications to the local list
    //

    AfdAcquireSpinLock (&AfdAddressChangeLock, &lockHandle);

    if (SpecificEndpoint==NULL) {
        //
        // General notification, increment provider
        // list change sequence number.
        //
        AfdSanProviderListSeqNum += 1;
        if (AfdSanProviderListSeqNum==0) {
            AfdSanProviderListSeqNum += 1;
        }
    }

    plsn = AfdSanProviderListSeqNum;

    listEntry = AfdAddressChangeList.Flink;
    while (listEntry!=&AfdAddressChangeList) {
        change = CONTAINING_RECORD (listEntry, 
                                AFD_ADDRESS_CHANGE,
                                ChangeListLink);
        listEntry = listEntry->Flink;
        if (!change->NonBlocking) {
            irp = change->Irp;
            irpSp = IoGetCurrentIrpStackLocation (irp);
            requestCtx = (PAFD_REQUEST_CONTEXT)&irpSp->Parameters.DeviceIoControl;
            endpoint = irpSp->FileObject->FsContext;
            ASSERT (change==(PAFD_ADDRESS_CHANGE)irp->Tail.Overlay.DriverContext);

            if (IS_SAN_HELPER (endpoint) &&
                    (SpecificEndpoint==NULL ||
                        endpoint==SpecificEndpoint)) {
                AFD_LOCK_QUEUE_HANDLE endpointLockHandle;
                ASSERT (change->AddressType==TDI_ADDRESS_TYPE_IP||
                        change->AddressType==TDI_ADDRESS_TYPE_IP6);

                RemoveEntryList (&change->ChangeListLink);
                change->ChangeListLink.Flink = NULL;
                //
                // If request is already canceled, let cancel routine complete it
                //
                if (IoSetCancelRoutine (irp, NULL)==NULL) {
                    continue;
                }

                AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
                if (AfdIsRequestInQueue (requestCtx)) {
                    endpoint->Common.SanHlpr.Plsn = plsn;
                    UPDATE_ENDPOINT2 (endpoint,
                                        "AfdSanProcessAddrListForProviderChange, new plsn: 0x%lX", 
                                        plsn);
                    //
                    // Context is still in the list, just remove it so
                    // no-one can see it anymore and complete
                    //
                    RemoveEntryList (&requestCtx->EndpointListLink);
                    InsertTailList (&completedChangeList,
                                        &change->ChangeListLink);
                }
                else if (!AfdIsRequestCompleted (requestCtx)) {
                    //
                    // During endpoint cleanup, this context was removed from the
                    // list and cleanup routine is about to be called, don't
                    // free this IRP until cleanup routine is called
                    // Also, indicate to the cleanup routine that we are done
                    // with this IRP and it can free it.
                    //
                    AfdMarkRequestCompleted (requestCtx);
                }

                AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
            }
        }
    }
    AfdReleaseSpinLock (&AfdAddressChangeLock, &lockHandle);

    //
    // Signal interested clients and complete IRPs as necessary
    //

    while (!IsListEmpty (&completedChangeList)) {
        listEntry = RemoveHeadList (&completedChangeList);
        change = CONTAINING_RECORD (listEntry, 
                                AFD_ADDRESS_CHANGE,
                                ChangeListLink);
        irp = change->Irp;
        irp->IoStatus.Status = STATUS_SUCCESS;
        //
        // Assigning plsn (can't be 0) distinguishes
        // this from regular address list change
        // notification.
        //
        irp->IoStatus.Information = plsn;
        IF_DEBUG (ADDRESS_LIST) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdProcessAddressChangeList: Completing change IRP: %p  with status: 0 .\n",
                        irp));
        }
        IoCompleteRequest (irp, AfdPriorityBoost);
    }

}


NTSTATUS
AfdSanGetCompletionObjectTypePointer (
    VOID
    )
/*++

Routine Description:
    Obtains completion port object type pointer for
    completion port handle validation purposes.
    Note, that this type is not exported from kernel like
    most other types that afd uses.
Arguments:
    None.
Return Value:
    0 - success, other - could not obtain reference.
--*/
{
    NTSTATUS status;
    UNICODE_STRING  obName;
    OBJECT_ATTRIBUTES obAttr;
    HANDLE obHandle;
    PVOID obType;

    RtlInitUnicodeString (&obName, L"\\ObjectTypes\\IoCompletion");
    
    InitializeObjectAttributes(
        &obAttr,
        &obName,                    // name
        OBJ_KERNEL_HANDLE,          // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    status = ObOpenObjectByName (
        &obAttr,                    // ObjectAttributes
        NULL,                       // ObjectType
        KernelMode,                 // AccessMode
        NULL,                       // PassedAccessState
        0,                          // DesiredAccess
        NULL,                       // DesiredAccess
        &obHandle                   // Handle
        );
    if (NT_SUCCESS (status)) {
        status = ObReferenceObjectByHandle (
                    obHandle,
                    0,              // DesiredAccess
                    NULL,           // ObjectType
                    KernelMode,     // AccessMode
                    &obType,        // Object
                    NULL            // HandleInformation
                    );
        ZwClose (obHandle);
        if (NT_SUCCESS (status)) {
            //
            // Make sure we only keep one reference to the object type
            //
            if (InterlockedCompareExchangePointer (
                        (PVOID *)&IoCompletionObjectType,
                        obType,
                        NULL)!=NULL) {
                //
                // The reference we have already must be the same
                // is we just obtained - there should be only one
                // completion object type in the system!
                //
                ASSERT (obType==(PVOID)IoCompletionObjectType);
                //
                // Get rid of the extra reference
                //
                ObDereferenceObject (obType);
            }
        }
    }
    return status;
}


/*
    SAN SOCKET DUPLICATION AND REDIRECTED REQUEST PROCESSING NOTE

1. Controlling fields in SAN endpoint (AFD_ENDPOINT.Common.SanEndp).
    CtxTransferStatus:
        STATUS_SUCCESS - default, duplication never been done or succeeded;
        STATUS_PENDING - duplication in progress:
            a)some process submitted IOCTL_AFD_SWITCH_ACQUIRE_CTX request
                and AFD queued AFD_SWITCH_REQUEST_TFCTX to the owner process 
                of the endpoint; 
            b)owner process is closing its handle while other processes have 
                handles opened, so AFD queued AFD_SWITCH_REQUEST_TFCTX 
                to the owner process;
        STATUS_MORE_PROCESSING_REQUIRED - service process duplication 
            in progress - AFD queued AFD_SWITCH_REQUEST_AQCTX to the service 
            process after owner process requested duplication upon handle close;
        OTHER (failure status) - duplication failed, all redirect and context 
            transfer request should failed as well.
    ImplicitDup:
        FALSE - default, duplication never been done or last successful 
            duplication was explicit. 
        TRUE - AFD made unsolicited handle duplication:
            a)accept was called in the process that doesn't own listening 
                endpoint and AFD duplicated handle into the listening process,
            b)owner process closed the endpoint and AFD queued 
                AFD_SWITCH_REQUEST_TFCTX to it, the owner process then 
                responded with IOCTL_AFD_SWITCH_TRANSFER_CTX and AFD 
                duplicated handle into the service process (and queued 
                AFD_SWITCH_REQUEST_AQCTX); 
    IrpList:
        List of redirected or IOCTL_AFD_SWITCH_ACQUIRE_CTX requests.
    RequestId:
        Counter for generation of UNIQUE requests ID's
    SavedContext:
        Saved user mode context from IOCTL_AFD_SWITCH_TRANSFER_CTX from owner 
        process that closed its handle while switch negotiates with 
        the service process to acquire the context.
    SavedContextLength:
        Length of the context above.

CtxTransferStatus, IrpList, and RequestID are protected with endpoint spinlock
(since they control request queueing and IRP completion/cancellation).
Other fields are protected via the endpoint context lock. 

2. Controlling fields in SAN helper (AFD_ENDPOINT.Common.SanHlpr).
    PendingRequsts: number of requests submitted to the process via helper 
        as well as status of the helper (bit 1 set when helper handle was 
        closed and no new requests can be submitted).
Interlocked operations are used to access this field.  Low order bit is 
initialized to 0 and set to 1 via InterlockedIncrement when handle 
for the helper is closed in the owning process.  For each request, 
the field is incremented by 2, then the low order bit is checked
to see if handle was closed.  If so, request is failed immediately 
and counter is decremented back by 2.  Upon request completion, counter 
is decremented by 2 as well.

3. Processing of redirected requests (AfdSanRedirectRequest).
    a)CtxTransferStatus==STATUS_SUCCESS:
        set request ID and enqueue it, notify owner process (AfdSanNotifyRequest),
        if owner process is gone or notification failed, dequeue and fail 
        the request (AfdSanDequeueRequest, IoCompleteRequest);
    b)CtxTransferStatus==STATUS_PENDING||STATUS_MORE_PROCESSING_REQUIRED
        NULL request ID and enqueue it to be processed when outstanding
        duplication completes;
    c)CtxTransferStatus==OTHER (failure):
        fail the request

4. Processing of explicit IOCTL_AFD_SWITCH_ACQUIRE_CTX (generated 
by the app when it performed socket call in the process other 
than the current owner - AfdSanAcquireContext):
    a)CtxTransferStatus==STATUS_SUCCESS:
        set request ID, enqueue it, and change CtxTransferStatus 
        to STATUS_PENDING, notify owner process (AfdSanNotifyRequest),
        if owner process is gone or notification failed, dequeue (AfdSanDequeueRequest) 
        and fail the request (IoCompleteRequest), and reset CtxTransferStatus back 
        to STATUS_SUCCESS if it is still STATUS_PENDING (AfdSanRestartRequestProcessing - 
        other transfer requests can still succeed);
    b)CtxTransferStatus==STATUS_PENDING||STATUS_MORE_PROCESSING_REQUIRED
        NULL request ID and enqueue it to be processed when outstanding
        duplication completes;
    c)CtxTransferStatus==OTHER:
        fail the request

5. Processing of implicit IOCTL_AFD_SWITCH_ACQUIRE_CTX (generated 
by the service process on AFD_SWITCH_REQUEST_AQCTX notification):
    a)CtxTransferStatus==STATUS_MORE_PROCESSING_REQUIRED:
        copy the saved context and data to the request buffer,
        complete the acquire request with success,
        post all queued requests (AfdSanRestartRequestProcessing) resubmitting those 
        that have NULL id and reset CtxTransferStatus to STATUS_SUCCESS or
        failure if we failed to resumit one of them,
    b)CtxTransferStatus==OTHER:
        fail the request and mark CtxTransferStatus as STATUS_CANCELLED

6. Processing of solicited IOCTL_AFD_SWITCH_TRANSFER_CTX (generated 
by the owner process on AFD_SWITCH_REQUEST_TFCTX notification 
for a process that explicitly requested ownership)
    a)CtxTransferStatus==STATUS_PENDING:
        find corresponding IRP with AFD_SWITCH_REQUEST_TFCTX context, 
        reset CtxTransferStatus to STATUS_SUCCESS and resume request 
        processing (resubmit those that have NULL ID);
    b)CtxTransferStatus==OTHER or IRP is not found:
        fail the request and mark CtxTransferStatus as STATUS_CANCELLED.

7. Processing of unsolicited IOCTL_AFD_SWITCH_TRANSFER_CTX (generated 
by the owner process on AFD_SWITCH_REQUEST_TFCTX notification for 
a temporary holding in service process):
    a)CtxTransferStatus==STATUS_PENDING (or STATUS_SUCCESS-this is not possible
    currently since switch does not generate transfers by itself, but in
    theory we can do this for WSADuplicateHandle):
        save the context, reset CtxTransferStatus to 
        STATUS_MORE_PROCESSING_REQUIRED, reset all pending request IDs to NULL
        for re-processing, queue AFD_SWITCH_REQUEST_AQCTX to service process 
        to pick up the endpoint;  
        if anything fails, reset CtxTransferStatus to failure status and fail 
        all pending requests;
    b)CtxTransferStatus==OTHER:
        fail the request and mark CtxTransferStatus as STATUS_CANCELLED.

8. Processing of accept from the process that doesn't own listening socket.
    Duplicate the accept handle into listening process and mark the endpoint 
    with ImplicitDup flag.  Listening process will then explicitly request 
    context transfer (e.g. issue IOCTL_AFD_SWITCH_ACQUIRE_CTX).

9. Processing of owner process handle close notification while other 
processes still have handles opened (UnlockAll):
    a)CtxTransferStatus==STATUS_SUCCESS
        Set CtxTransferStatus to STATUS_PENDING and notify owner process 
        to transfer endpoint to the service process, if notification fails,
        reset CtxTransferStatus to STATUS_CANCELLED and fail all pending 
        requests.
    b)CtxTransferStatus==STATUS_PENDING
        Some other process (maybe just little while back) asked for the socket
        by explicit IOCTL_AFD_SWITCH_ACQUIRE_CTX. Let that duplication proceed.
        No need to duplicate to service process.
    c)CtxTransferStatus==OTHER
        ignore the call - endpoint is either in failed state or another 
        duplication request is already in progress.

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\send.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    send.c

Abstract:

    This module contains the code for passing on send IRPs to
    TDI providers.

Author:

    David Treadwell (davidtr)    13-Mar-1992

Revision History:

--*/

#include "afdp.h"

VOID
AfdCancelSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
AfdRestartSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartSendConnDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartSendTdiConnDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartSendDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

typedef struct _AFD_SEND_CONN_DATAGRAM_CONTEXT {
    PAFD_ENDPOINT Endpoint;
    TDI_CONNECTION_INFORMATION ConnectionInformation;
} AFD_SEND_CONN_DATAGRAM_CONTEXT, *PAFD_SEND_CONN_DATAGRAM_CONTEXT;

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdSend )
#pragma alloc_text( PAGEAFD, AfdSendDatagram )
#pragma alloc_text( PAGEAFD, AfdCancelSend )
#pragma alloc_text( PAGEAFD, AfdRestartSend )
#pragma alloc_text( PAGEAFD, AfdRestartBufferSend )
#pragma alloc_text( PAGEAFD, AfdProcessBufferSend )
#pragma alloc_text( PAGEAFD, AfdRestartSendConnDatagram )
#pragma alloc_text( PAGEAFD, AfdRestartSendTdiConnDatagram )
#pragma alloc_text( PAGEAFD, AfdRestartSendDatagram )
#pragma alloc_text( PAGEAFD, AfdSendPossibleEventHandler )
#endif

//
// Macros to make the send restart code more maintainable.
//

#define AfdRestartSendInfo  DeviceIoControl
#define AfdMdlChain         Type3InputBuffer
#define AfdSendFlags        InputBufferLength
#define AfdOriginalLength   OutputBufferLength
#define AfdCurrentLength    IoControlCode

#define AFD_SEND_MDL_HAS_NOT_BEEN_MAPPED 0x80000000


NTSTATUS
FASTCALL
AfdSend (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PAFD_ENDPOINT endpoint;
    ULONG sendLength;
    ULONG sendOffset;
    ULONG currentOffset;
    PMDL  mdl;
    PAFD_CONNECTION connection;
    PAFD_BUFFER afdBuffer;
    PEPROCESS   process;
    ULONG sendFlags;
    ULONG afdFlags;
    ULONG bufferCount;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // Make sure that the endpoint is in the correct state.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    if ( endpoint->State != AfdEndpointStateConnected) {
        status = STATUS_INVALID_CONNECTION;
        goto complete;
    }

    //
    // If send has been shut down on this endpoint, fail.  We need to be
    // careful about what error code we return here: if the connection
    // has been aborted, be sure to return the apprpriate error code.
    //

    if ( (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND) != 0 ) {

        if ( (endpoint->DisconnectMode & AFD_ABORTIVE_DISCONNECT) != 0 ) {
            status = STATUS_LOCAL_DISCONNECT;
        } else {
            status = STATUS_PIPE_DISCONNECTED;
        }

        goto complete;
    }

    //
    // Set up the IRP on the assumption that it will complete successfully.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // If this is an IOCTL_AFD_SEND, then grab the parameters from the
    // supplied AFD_SEND_INFO structure, build an MDL chain describing
    // the WSABUF array, and attach the MDL chain to the IRP.
    //
    // If this is an IRP_MJ_WRITE IRP, just grab the length from the IRP
    // and set the flags to zero.
    //

    if ( IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL ) {

#ifdef _WIN64
        if (IoIs32bitProcess (Irp)) {
            PAFD_SEND_INFO32 sendInfo32;
            LPWSABUF32 bufferArray32;

            if( IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                    sizeof(*sendInfo32) ) {

                AFD_W4_INIT status = STATUS_SUCCESS;
                try {


                    //
                    // Validate the input structure if it comes from the user mode 
                    // application
                    //

                    sendInfo32 = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                    if( Irp->RequestorMode != KernelMode ) {

                        ProbeForReadSmallStructure(
                            sendInfo32,
                            sizeof(*sendInfo32),
                            PROBE_ALIGNMENT32(AFD_SEND_INFO32)
                            );

                    }

                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //

                    sendFlags = sendInfo32->TdiFlags;
                    afdFlags = sendInfo32->AfdFlags;
                    bufferArray32 = UlongToPtr(sendInfo32->BufferArray);
                    bufferCount = sendInfo32->BufferCount;


                    //
                    // Create the MDL chain describing the WSABUF array.
                    // This will also validate the buffer array and individual
                    // buffers
                    //

                    status = AfdAllocateMdlChain32(
                                 Irp,       // Requestor mode passed along
                                 bufferArray32,
                                 bufferCount,
                                 IoReadAccess,
                                 &sendLength
                                 );

                    if (!NT_SUCCESS(status))
                        goto complete;

                } except( AFD_EXCEPTION_FILTER (status) ) {

                    ASSERT (NT_ERROR (status));
                    //
                    //  Exception accessing input structure.
                    //
                    goto complete;


                }
            } else {

                //
                // Invalid input buffer length.
                //

                status = STATUS_INVALID_PARAMETER;
                goto complete;

            }
        }
        else 
#endif _WIN64
        {
            PAFD_SEND_INFO sendInfo;
            LPWSABUF bufferArray;

            //
            // Sanity check.
            //

            ASSERT( IrpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_SEND );

            if( IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                    sizeof(*sendInfo) ) {

                AFD_W4_INIT status = STATUS_SUCCESS;
                try {


                    //
                    // Validate the input structure if it comes from the user mode 
                    // application
                    //

                    sendInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                    if( Irp->RequestorMode != KernelMode ) {

                        ProbeForReadSmallStructure(
                            sendInfo,
                            sizeof(*sendInfo),
                            PROBE_ALIGNMENT (AFD_SEND_INFO)
                            );

                    }

                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //

                    sendFlags = sendInfo->TdiFlags;
                    afdFlags = sendInfo->AfdFlags;
                    bufferArray = sendInfo->BufferArray;
                    bufferCount = sendInfo->BufferCount;


                    //
                    // Create the MDL chain describing the WSABUF array.
                    // This will also validate the buffer array and individual
                    // buffers
                    //

                    status = AfdAllocateMdlChain(
                                 Irp,       // Requestor mode passed along
                                 bufferArray,
                                 bufferCount,
                                 IoReadAccess,
                                 &sendLength
                                 );


                    if( !NT_SUCCESS(status) ) {
                        goto complete;
                    }

                } except( AFD_EXCEPTION_FILTER (status) ) {
                    ASSERT (NT_ERROR (status));

                    //
                    //  Exception accessing input structure.
                    //
                    goto complete;


                }
            } else {

                //
                // Invalid input buffer length.
                //

                status = STATUS_INVALID_PARAMETER;
                goto complete;

            }
        }

        if (IS_SAN_ENDPOINT(endpoint)) {
            IrpSp->MajorFunction = IRP_MJ_WRITE;
            IrpSp->Parameters.Write.Length = sendLength;
            return AfdSanRedirectRequest (Irp, IrpSp);
        }

    } else {

        ASSERT( IrpSp->MajorFunction == IRP_MJ_WRITE );

        sendFlags = 0;
        afdFlags = AFD_OVERLAPPED;
        sendLength = IrpSp->Parameters.Write.Length;

    }

    //
    // AfdSend() will either complete fully or will fail.
    //

    Irp->IoStatus.Information = sendLength;

    //
    // Setup for possible restart if the transport completes
    // the send partially.
    //

    IrpSp->Parameters.AfdRestartSendInfo.AfdMdlChain = Irp->MdlAddress;
    IrpSp->Parameters.AfdRestartSendInfo.AfdSendFlags = sendFlags;
    IrpSp->Parameters.AfdRestartSendInfo.AfdOriginalLength = sendLength;
    IrpSp->Parameters.AfdRestartSendInfo.AfdCurrentLength = sendLength;

    //
    // Buffer sends if the TDI provider does not buffer.
    //

    if ( IS_TDI_BUFFERRING(endpoint) &&
            endpoint->NonBlocking) {
        //
        // If this is a nonblocking endpoint, set the TDI nonblocking
        // send flag so that the request will fail if the send cannot be
        // performed immediately.
        //

        sendFlags |= TDI_SEND_NON_BLOCKING;

    }

    //
    // If this is a datagram endpoint, format up a send datagram request
    // and pass it on to the TDI provider.
    //

    if ( IS_DGRAM_ENDPOINT(endpoint) ) {
        //
        // It is illegal to send expedited data on a datagram socket.
        //

        if ( (sendFlags & TDI_SEND_EXPEDITED) != 0 ) {
            status = STATUS_NOT_SUPPORTED;
            goto complete;
        }

        if (!IS_TDI_DGRAM_CONNECTION(endpoint)) {
            PAFD_SEND_CONN_DATAGRAM_CONTEXT context;
            ULONG remoteAddressLength;


            //
            // Allocate space to hold the connection information structure
            // we'll use on input.
            //

        retry:
            remoteAddressLength = endpoint->Common.Datagram.RemoteAddressLength;

            try {
                context = AFD_ALLOCATE_POOL_WITH_QUOTA(
                          NonPagedPool,
                          sizeof(*context) + remoteAddressLength,
                          AFD_TDI_POOL_TAG
                          );

            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode ();
                context = NULL;
                goto complete;
            }

            context->Endpoint = endpoint;
            context->ConnectionInformation.UserDataLength = 0;
            context->ConnectionInformation.UserData = NULL;
            context->ConnectionInformation.OptionsLength = 0;
            context->ConnectionInformation.Options = NULL;

            AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

            if (remoteAddressLength <
                endpoint->Common.Datagram.RemoteAddressLength) {
                //
                // Apparently connection address length has changed
                // on us while we were allocating the buffer.
                // This is extremely unlikely (even if endpoint got
                // connected to a different address, the length is unlikely
                // to change), but we must handle this, just try again.
                //
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                AFD_FREE_POOL(
                    context,
                    AFD_TDI_POOL_TAG
                    );

                goto retry;
            }

            //
            // Copy the address to the context buffer.
            // endpoint->Common.Datagram.RemoteAddress can be freed
            // by someone else if endpoint lock is not held
            //

            RtlCopyMemory(
                context+1,
                endpoint->Common.Datagram.RemoteAddress,
                endpoint->Common.Datagram.RemoteAddressLength
                );
    
            context->ConnectionInformation.RemoteAddressLength =
                endpoint->Common.Datagram.RemoteAddressLength;
            context->ConnectionInformation.RemoteAddress =
                (PTRANSPORT_ADDRESS)(context+1);

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            REFERENCE_ENDPOINT2 (endpoint,"AfdSend, length: 0x%lX", sendLength);

            //
            // Build a send datagram request.
            //

            TdiBuildSendDatagram(
                Irp,
                endpoint->AddressDeviceObject,
                endpoint->AddressFileObject,
                AfdRestartSendConnDatagram,
                context,
                Irp->MdlAddress,
                sendLength,
                &context->ConnectionInformation
                );
        }
        else {
            REFERENCE_ENDPOINT2 (endpoint,"AfdSend(conn), length: 0x%lX", sendLength);
            TdiBuildSend(
                Irp,
                endpoint->AddressDeviceObject,
                endpoint->AddressFileObject,
                AfdRestartSendTdiConnDatagram,
                endpoint,
                Irp->MdlAddress,
                0,
                sendLength
                );
            //
            // Check if there are outstanding TPackets IRP and
            // delay sending to ensure in-order delivery.
            // We do not need to hold the lock while checking
            // because we do not need to maintain order if
            // application does not wait for send call to return
            // before sumbitting TPackets IRP.
            // Of course, we will hold the lock while enqueuing IRP
            //
            if (endpoint->Irp!=NULL) {
                if (AfdEnqueueTpSendIrp (endpoint, Irp, FALSE)) {
                    return STATUS_PENDING;
                }
            }
        }

        //
        // Call the transport to actually perform the send operation.
        //

        return AfdIoCallDriver(
                   endpoint,
                   endpoint->AddressDeviceObject,
                   Irp
                   );
    }

    afdBuffer = NULL;
    process = endpoint->OwningProcess;
    sendOffset = 0;

retry_buffer:
    if (!IS_TDI_BUFFERRING(endpoint) && 
            (!endpoint->DisableFastIoSend ||
                (endpoint->NonBlocking && !( afdFlags & AFD_OVERLAPPED )) ) ) {
        ULONG copyThreshold = AfdBlockingSendCopyThreshold;
        //
        // If application does a blocking send for more than 128k, we
        // copy only the last 64k and send the first part from
        // the application buffer to avoid huge overhead of allocating
        // non-paged pool and copying.
        //
        if (sendLength>=2*copyThreshold &&
                !IS_MESSAGE_ENDPOINT (endpoint) &&
                (!endpoint->NonBlocking || (afdFlags & AFD_OVERLAPPED ) ) ) {
            sendOffset += sendLength-copyThreshold;
            sendLength = copyThreshold;
        }
        //
        // Get AFD buffer structure that contains an IRP and a
        // buffer to hold the data.
        //

    retry_allocate:
        AFD_W4_INIT status = STATUS_SUCCESS;
        try {
            afdBuffer = AfdGetBufferRaiseOnFailure (
                                        endpoint,
                                        sendLength,
                                        0,
                                        process );
        }
        except (AFD_EXCEPTION_FILTER (status)) {
            ASSERT (NT_ERROR (status));
            //
            // If we failed to get the buffer, and application request
            // is larger than one page,  and it is blocking or overlapped,
            // and this is not a message-oriented socket,
            // allocate space for last page only (if we can) and send
            // the first portion from the app buffer.
            //

            if ( (sendLength>AfdBufferLengthForOnePage) &&
                    !IS_MESSAGE_ENDPOINT (endpoint) &&
                    (!endpoint->NonBlocking || (afdFlags & AFD_OVERLAPPED ) ) ) {

                sendOffset += sendLength-AfdBufferLengthForOnePage;
                sendLength = AfdBufferLengthForOnePage;
                goto retry_allocate;
            } // not qualified for partial allocation
            else {
                goto cleanup_buffer;
            }
        } // exception allocating big buffer.

        currentOffset = sendOffset;
        mdl = Irp->MdlAddress;
        if (sendOffset!=0) {
            //
            // Adjust MDL length to be in sync with IRP
            // send length parameter to not to confuse
            // the transport
            //

            while (currentOffset>MmGetMdlByteCount (mdl)) {
                currentOffset -= MmGetMdlByteCount (mdl);
                mdl = mdl->Next;
            }
        }

        if (sendLength != 0) {
            status = AfdCopyMdlChainToBufferAvoidMapping(
                mdl,
                currentOffset,
                sendLength,
                afdBuffer->Buffer,
                afdBuffer->BufferLength
                );

            if (!NT_SUCCESS (status)) {
                goto cleanup_buffer;
            }
        }
        else {
            ASSERT (IrpSp->Parameters.AfdRestartSendInfo.AfdOriginalLength == 0);
        }

    }
    else {
        AFD_W4_INIT currentOffset = 0;
        AFD_W4_INIT mdl = NULL;
    }

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    connection = AFD_CONNECTION_FROM_ENDPOINT(endpoint);

    if (connection==NULL) {
        //
        // connection might have been cleaned up by transmit file.
        //
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = STATUS_INVALID_CONNECTION;
        goto cleanup_buffer;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );

    //
    // Check whether the remote end has aborted the connection, in which
    // case we should complete the receive.
    //

    if ( connection->Aborted ) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = STATUS_CONNECTION_RESET;
        goto cleanup_buffer;
    }

    //
    // Buffer sends if the TDI provider does not buffer
    // and application did not specifically requested us not
    // to do so
    //

    if ( !IS_TDI_BUFFERRING(endpoint)) {
        if ( afdBuffer!=NULL ) {
            BOOLEAN completeSend = FALSE;
            PFILE_OBJECT fileObject = NULL;

            if (connection->OwningProcess!=process) {
                //
                // Weird case when connection and endpoint belong to
                // different processes.
                //

                process = connection->OwningProcess;
                AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
                AfdReturnBuffer (&afdBuffer->Header, process);
                afdBuffer = NULL;
                goto retry_buffer;
            }

            ASSERT( !connection->TdiBufferring );

            //
            // First make sure that we don't have too many bytes of send
            // data already outstanding and that someone else isn't already
            // in the process of completing pended send IRPs.  We can't
            // issue the send here if someone else is completing pended
            // sends because we have to preserve ordering of the sends.
            //
            // Note that we'll give the send data to the TDI provider even
            // if we have exceeded our send buffer limits, but that we don't
            // complete the user's IRP until some send buffer space has
            // freed up.  This effects flow control by blocking the user's
            // thread while ensuring that the TDI provider always has lots
            // of data available to be sent.
            //


            if ( connection->VcBufferredSendBytes >= connection->MaxBufferredSendBytes &&
                    endpoint->NonBlocking && 
                    !( afdFlags & AFD_OVERLAPPED ) &&
                    connection->VcBufferredSendBytes>0) {
                //
                // There is already as much send data bufferred on the
                // connection as is allowed.  If this is a nonblocking
                // endpoint and this is not an overlapped operation and at least
                // on byte is buferred, fail the request.
                // Note, that we have already allocated the buffer and copied data
                // and now we are dropping it.  We should only be here in some
                // really weird case when fast IO has been bypassed.
                //


                //
                // Enable the send event.
                //

                endpoint->EventsActive &= ~AFD_POLL_SEND;
                endpoint->EnableSendEvent = TRUE;

                IF_DEBUG(EVENT_SELECT) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSend: Endp %p, Active %lx\n",
                        endpoint,
                        endpoint->EventsActive
                        ));
                }

                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                status = STATUS_DEVICE_NOT_READY;
                goto cleanup_buffer;
            }

            if (sendOffset==0) {
                if ( connection->VcBufferredSendBytes >= connection->MaxBufferredSendBytes ) {

                    //
                    // Special hack to prevent completion of this IRP
                    // while we have not finished sending all the data
                    // that came with it.  If we do not do this, the
                    // app can receive completion port notificaiton in
                    // another thread and come back with another send
                    // which can get in the middle of this one.
                    //
                    Irp->Tail.Overlay.DriverContext[0] = NULL;

                    //
                    // Set up the cancellation routine in the IRP.  If the IRP
                    // has already been cancelled, just complete the IRP
                    //

                    IoSetCancelRoutine( Irp, AfdCancelSend );

                    if ( Irp->Cancel ) {

                        Irp->Tail.Overlay.ListEntry.Flink = NULL;

                        if ( IoSetCancelRoutine( Irp, NULL ) == NULL ) {
                            IoMarkIrpPending (Irp);
                            Irp->Tail.Overlay.DriverContext[0] = (PVOID)-1;
                            //
                            // The cancel routine is running and will complete the IRP
                            //
                            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                            AfdReturnBuffer (&afdBuffer->Header, process);
                            return STATUS_PENDING;
                        }

                        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                        status = STATUS_CANCELLED;
                        goto cleanup_buffer;
                    }

                    //
                    // We're going to have to pend the request here in AFD.
                    // Place the IRP on the connection's list of pended send
                    // IRPs and mark the IRP as pended.
                    //

                    InsertTailList(
                        &connection->VcSendIrpListHead,
                        &Irp->Tail.Overlay.ListEntry
                        );

                    IoMarkIrpPending( Irp );

                }
                else {
                    //
                    // We are going to complete the IRP inline
                    //
                    completeSend = TRUE;
                }

            }
            else {
                connection->VcBufferredSendBytes += sendOffset;
                connection->VcBufferredSendCount += 1;

                //
                // Special hack to prevent completion of this IRP
                // while we have not finished sending all the data
                // that came with it.  If we do not do this, the
                // app can receive completion port notificaiton in
                // another thread and come back with another send
                // which can get in the middle of this one.
                //
                fileObject = IrpSp->FileObject;
                IrpSp->FileObject = NULL;


                REFERENCE_CONNECTION2( connection, "AfdSend (split,non-buffered part), offset: 0x%lX", sendOffset );
            }

            //
            // Update count of send bytes pending on the connection.
            //

            connection->VcBufferredSendBytes += sendLength;
            connection->VcBufferredSendCount += 1;

            //
            // Reference the conneciton so it does not go away
            // until we finish with send
            //
            REFERENCE_CONNECTION2( connection, "AfdSend (buffered), length: 0x%lX", sendLength );

            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

            //
            // Remember the connection in the AFD buffer structure.  We need
            // this in order to access the connection in the restart routine.
            //

            afdBuffer->Context = connection;


            //
            // We have to rebuild the MDL in the AFD buffer structure to
            // represent exactly the number of bytes we're going to be
            // sending.
            //

            afdBuffer->Mdl->ByteCount = sendLength;


            if (sendOffset==0) {
                // Use the IRP in the AFD buffer structure to give to the TDI
                // provider.  Build the TDI send request.
                //

                TdiBuildSend(
                    afdBuffer->Irp,
                    connection->DeviceObject,
                    connection->FileObject,
                    AfdRestartBufferSend,
                    afdBuffer,
                    afdBuffer->Mdl,
                    sendFlags,
                    sendLength
                    );

                //
                // Check if there are outstanding TPackets IRP and
                // delay sending to ensure in-order delivery.
                // We do not need to hold the lock while checking
                // because we do not need to maintain order if
                // application does not wait for send call to return
                // before sumbitting TPackets IRP.
                // Of course, we will hold the lock while enqueuing IRP
                //
                if (endpoint->Irp==NULL || 
                        !AfdEnqueueTpSendIrp (endpoint, afdBuffer->Irp, TRUE)) {
                    //
                    // Call the transport to actually perform the send.
                    //

                    status = IoCallDriver(connection->DeviceObject, afdBuffer->Irp );
                }
                else {
                    status = STATUS_PENDING;
                }

                //
                // If we did not pend the Irp, complete it
                //
                if (completeSend) {
                    if (NT_SUCCESS (status)) {
                        ASSERT (Irp->IoStatus.Status == STATUS_SUCCESS);
                        ASSERT (Irp->IoStatus.Information == sendLength);
                        ASSERT ((status==STATUS_SUCCESS) || (status==STATUS_PENDING));
                        status = STATUS_SUCCESS;    // We did not mark irp as
                                                    // pending, so returning
                                                    // STATUS_PENDING (most likely
                                                    // to be status returned by the
                                                    // transport) will really confuse
                                                    // io subsystem.
                    }
                    else {
                        Irp->IoStatus.Status = status;
                        Irp->IoStatus.Information = 0;
                    }
                    UPDATE_CONN2 (connection, "AfdSend, bytes sent/status reported 0x%lX", 
                                                (NT_SUCCESS(Irp->IoStatus.Status) 
                                                            ? (ULONG)Irp->IoStatus.Information
                                                            : (ULONG)Irp->IoStatus.Status));
                    IoCompleteRequest (Irp, AfdPriorityBoost);
                }
                else {

                    //
                    // We no longer need MDL in the IRP, free it.
                    // Do this before we release the ownership
                    // in InterlockedOperation below.
                    //
                    AfdDestroyMdlChain (Irp);

                    //
                    // Complete the IRP if it was completed by the transport
                    // and kept around to let us finish posting all the data
                    // originally submitted by the app before completing it
                    //
                    ASSERT (Irp->Tail.Overlay.DriverContext[0]==NULL
                        || Irp->Tail.Overlay.DriverContext[0]==(PVOID)-1);
                    if (InterlockedExchangePointer (
                                &Irp->Tail.Overlay.DriverContext[0],
                                (PVOID)Irp)!=NULL) {
                        UPDATE_CONN2 (connection, "AfdSend, bytes sent reported 0x%lX", 
                                                    (ULONG)Irp->IoStatus.Information);
                        IoCompleteRequest (Irp, AfdPriorityBoost);
                    }

                    status = STATUS_PENDING;
                }
            }
            else {

                //
                // Save the original values to restore in
                // completion routine.
                //

                IrpSp->Parameters.AfdRestartSendInfo.AfdMdlChain = mdl->Next;
                IrpSp->Parameters.AfdRestartSendInfo.AfdCurrentLength =
                            MmGetMdlByteCount (mdl);
                
                //
                // Note if we need to unmap MDL before completing
                // the IRP if it is mapped by the transport.
                //
                if ((mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA)==0) {
                    IrpSp->Parameters.AfdRestartSendInfo.AfdSendFlags |=
                                        AFD_SEND_MDL_HAS_NOT_BEEN_MAPPED;
                }
                
                //
                // Reset the last MDL to not confuse the transport
                // with different length values in MDL and send parameters
                //
                mdl->ByteCount = currentOffset;
                mdl->Next = NULL;

                //
                // Build and pass first portion of the data with original (app)
                // IRP
                //
                TdiBuildSend(
                    Irp,
                    connection->DeviceObject,
                    connection->FileObject,
                    AfdRestartSend,
                    connection,
                    Irp->MdlAddress,
                    sendFlags,
                    sendOffset
                    );

                //
                // Check if there are outstanding TPackets IRP and
                // delay sending to ensure in-order delivery.
                // We do not need to hold the lock while checking
                // because we do not need to maintain order if
                // application does not wait for send call to return
                // before sumbitting TPackets IRP.
                // Of course, we will hold the lock while enqueuing IRP
                //
                if (endpoint->Irp==NULL || 
                        !AfdEnqueueTpSendIrp (endpoint, Irp, FALSE)) {
                    status = AfdIoCallDriver (endpoint, 
                                            connection->DeviceObject,
                                            Irp);
                }
                else {
                 
                    status = STATUS_PENDING;
                }
                // 
                // Build and pass buffered last page
                //

                TdiBuildSend(
                    afdBuffer->Irp,
                    connection->DeviceObject,
                    connection->FileObject,
                    AfdRestartBufferSend,
                    afdBuffer,
                    afdBuffer->Mdl,
                    sendFlags,
                    sendLength
                    );


                //
                // Similar check for the second part of the IRP.
                // There might be a slight problem here since we
                // can end-up interleaving sends with another thread
                //
                if (endpoint->Irp==NULL || 
                        !AfdEnqueueTpSendIrp (endpoint, afdBuffer->Irp, TRUE)) {
                    IoCallDriver(connection->DeviceObject, afdBuffer->Irp );
                }


                //
                // Complete the IRP if it was completed by the transport
                // and kept around to let us finish posting all the data
                // originally submitted by the app before completing it
                //
                ASSERT (fileObject!=NULL);
                ASSERT (IrpSp->FileObject==NULL || IrpSp->FileObject==(PFILE_OBJECT)-1);
                if (InterlockedExchangePointer (
                            (PVOID *)&IrpSp->FileObject,
                            fileObject)!=NULL) {
                    UPDATE_CONN2 (connection, "AfdSend(split), bytes sent reported 0x%lX", 
                                                (ULONG)Irp->IoStatus.Information);
                    IoCompleteRequest (Irp, AfdPriorityBoost);
                }

            }

            return status;
        }
        else {
            //
            // Count sends pended in the provider too, so
            // we do not buffer in excess and complete
            // buffered application sends before the transport
            // completes sends forwarded to it.
            //
            connection->VcBufferredSendBytes += sendLength;
            connection->VcBufferredSendCount += 1;
        }
    }
    else {
        ASSERT (afdBuffer==NULL);
    }

    //
    // Add a reference to the connection object since the send
    // request will complete asynchronously.
    //

    REFERENCE_CONNECTION2( connection, "AfdSend (non-buffered), length: 0x%lX", sendLength );

    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

    TdiBuildSend(
        Irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartSend,
        connection,
        Irp->MdlAddress,
        sendFlags,
        sendLength
        );


    //
    // Check if there are outstanding TPackets IRP and
    // delay sending to ensure in-order delivery.
    // We do not need to hold the lock while checking
    // because we do not need to maintain order if
    // application does not wait for send call to return
    // before sumbitting TPackets IRP.
    // Of course, we will hold the lock while enqueuing IRP
    //
    if (endpoint->Irp==NULL || 
            !AfdEnqueueTpSendIrp (endpoint, Irp, FALSE)) {

        //
        // Call the transport to actually perform the send.
        //
        status = AfdIoCallDriver( endpoint, connection->DeviceObject, Irp );
    }
    else {
        status = STATUS_PENDING;
    }
    return status;

cleanup_buffer:
    if (afdBuffer!=NULL) {
        AfdReturnBuffer (&afdBuffer->Header, process);
    }

complete:
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdSend


NTSTATUS
AfdRestartSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIO_STACK_LOCATION irpSp;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    NTSTATUS status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    UNREFERENCED_PARAMETER (DeviceObject);

    connection = Context;
    ASSERT( connection != NULL );
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint != NULL );
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth );

    irpSp = IoGetCurrentIrpStackLocation( Irp );


    IF_DEBUG(SEND) {
       KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdRestartSend: send completed for IRP %p, endpoint %p, "
                "status = %X\n",
                Irp, Context, Irp->IoStatus.Status ));
    }

    AfdCompleteOutstandingIrp( endpoint, Irp );

    if (IS_TDI_BUFFERRING (endpoint)) {

        ASSERT (irpSp->FileObject!=NULL);

        //
        // If the request failed indicating that the send would have blocked,
        // and the client issues a nonblocking send, remember that nonblocking
        // sends won't work until we get a send possible indication.  This
        // is required for write polls to work correctly.
        //
        // If the status code is STATUS_REQUEST_NOT_ACCEPTED, then the
        // transport does not want us to update our internal variable that
        // remembers that nonblocking sends are possible.  The transport
        // will tell us when sends are or are not possible.
        //
        // !!! should we also say that nonblocking sends are not possible if
        //     a send is completed with fewer bytes than were requested?

        if ( Irp->IoStatus.Status == STATUS_DEVICE_NOT_READY ) {

            //
            // Reenable the send event.
            //

            AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

            endpoint->EventsActive &= ~AFD_POLL_SEND;
            endpoint->EnableSendEvent = TRUE;

            IF_DEBUG(EVENT_SELECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartSend: Endp %p, Active %lx\n",
                    endpoint,
                    endpoint->EventsActive
                    ));
            }

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            connection->VcNonBlockingSendPossible = FALSE;

        }

        //
        // If this is a send IRP on a nonblocking endpoint and fewer bytes
        // were actually sent than were requested to be sent, reissue
        // another send for the remaining buffer space.
        //

        if ( !endpoint->NonBlocking && NT_SUCCESS(Irp->IoStatus.Status) &&
                 Irp->IoStatus.Information <
                     irpSp->Parameters.AfdRestartSendInfo.AfdCurrentLength ) {

            ASSERT( Irp->MdlAddress != NULL );

            //
            // Advance the MDL chain by the number of bytes actually sent.
            //

            Irp->MdlAddress = AfdAdvanceMdlChain(
                            Irp->MdlAddress,
                            (ULONG)Irp->IoStatus.Information
                            );


            //
            // Update our restart info.
            //

            irpSp->Parameters.AfdRestartSendInfo.AfdCurrentLength -=
                (ULONG)Irp->IoStatus.Information;

            //
            // Reissue the send.
            //

            TdiBuildSend(
                Irp,
                connection->FileObject->DeviceObject,
                connection->FileObject,
                AfdRestartSend,
                connection,
                Irp->MdlAddress,
                irpSp->Parameters.AfdRestartSendInfo.AfdSendFlags,
                irpSp->Parameters.AfdRestartSendInfo.AfdCurrentLength
                );

            UPDATE_CONN2 (connection, "Restarting incomplete send, bytes: 0x%lX", 
                                        (ULONG)Irp->IoStatus.Information);
            
            status = AfdIoCallDriver(
                         endpoint,
                         connection->FileObject->DeviceObject,
                         Irp
                         );

            IF_DEBUG(SEND) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdRestartSend: IoCallDriver returned %lx\n",
                                status
                                ));
                }
            }

            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        //
        // Restore the IRP to its former glory before completing it
        // unless it is a non-blocking endpoint in which case
        // we shouldn't have modified it in the first place and
        // we also want to return the actual number of bytes sent
        // by the transport.
        //

        if ( !endpoint->NonBlocking ) {
            Irp->IoStatus.Information = irpSp->Parameters.AfdRestartSendInfo.AfdOriginalLength;
        }
        //
        // Remove the reference added just before calling the transport.
        //

        DEREFERENCE_CONNECTION2( connection, "AfdRestartSend-tdib, sent/error: 0x%lX",
            (NT_SUCCESS (Irp->IoStatus.Status) 
                ? (ULONG)Irp->IoStatus.Information
                : (ULONG)Irp->IoStatus.Status));
    }
    else {

        AfdProcessBufferSend (connection, Irp);
        //
        // If we buffered last page of the send, adjust last MDL
        // and fix returned byte count if necessary
        //

        if (Irp->MdlAddress!=irpSp->Parameters.AfdRestartSendInfo.AfdMdlChain) {
            PMDL    mdl = Irp->MdlAddress;

            ASSERT (mdl!=NULL);

            while (mdl->Next!=NULL) {
                mdl = mdl->Next;
            }

            //
            // Unmap the pages that could have been mapped by
            // the transport before adjusting the MDL size back
            // so that MM does not try to unmap more than was
            // mapped by the transport.
            //

            if ((mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) &&
                    (irpSp->Parameters.AfdRestartSendInfo.AfdSendFlags &
                            AFD_SEND_MDL_HAS_NOT_BEEN_MAPPED)) {
                MmUnmapLockedPages (mdl->MappedSystemVa, mdl);
            }

            mdl->ByteCount
                 = irpSp->Parameters.AfdRestartSendInfo.AfdCurrentLength;
            mdl->Next = irpSp->Parameters.AfdRestartSendInfo.AfdMdlChain;

            //
            // Remove the reference added just before calling the transport.
            //

            DEREFERENCE_CONNECTION2( connection, "AfdRestartSend-split, sent/error: 0x%lX",
                (NT_SUCCESS (Irp->IoStatus.Status) 
                    ? (ULONG)Irp->IoStatus.Information
                    : (ULONG)Irp->IoStatus.Status));

            if (NT_SUCCESS (Irp->IoStatus.Status)) {
                //
                // Make sure that the TDI provider sent everything we requested that
                // he send.
                //
                ASSERT (Irp->IoStatus.Information+(ULONG)AfdBufferLengthForOnePage==
                            irpSp->Parameters.AfdRestartSendInfo.AfdOriginalLength ||
                        Irp->IoStatus.Information+(ULONG)AfdBlockingSendCopyThreshold==
                            irpSp->Parameters.AfdRestartSendInfo.AfdOriginalLength);
                Irp->IoStatus.Information = 
                    irpSp->Parameters.AfdRestartSendInfo.AfdOriginalLength;
            }


        }
        else {
            //
            // Remove the reference added just before calling the transport.
            //

            DEREFERENCE_CONNECTION2( connection, "AfdRestartSend, sent/error: 0x%lX",
                (NT_SUCCESS (Irp->IoStatus.Status) 
                    ? (ULONG)Irp->IoStatus.Information
                    : (ULONG)Irp->IoStatus.Status));


            //
            // Make sure that the TDI provider sent everything we requested that
            // he send.
            //

            ASSERT (!NT_SUCCESS (Irp->IoStatus.Status) ||
                     (Irp->IoStatus.Information ==
                         irpSp->Parameters.AfdRestartSendInfo.AfdOriginalLength));
        }

    }


    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    //
    // The send dispatch routine temporarily yanks the file
    // object pointer if it wants to make sure that the IRP
    // is not completed until it is fully done with it.
    //
    if (InterlockedExchangePointer (
                (PVOID *)&irpSp->FileObject,
                (PVOID)-1)==NULL) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    else
        return STATUS_SUCCESS;

} // AfdRestartSend


NTSTATUS
AfdRestartBufferSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PAFD_BUFFER afdBuffer;
    PAFD_CONNECTION connection;
#if REFERENCE_DEBUG
    IO_STATUS_BLOCK ioStatus = Irp->IoStatus;
#endif

    UNREFERENCED_PARAMETER (DeviceObject);

    afdBuffer = Context;
    ASSERT (IS_VALID_AFD_BUFFER (afdBuffer));

    connection = afdBuffer->Context;
    ASSERT( connection != NULL );
    ASSERT( connection->Type == AfdBlockTypeConnection );
    ASSERT( connection->ReferenceCount > 0 );

    //
    // Make sure that the TDI provider sent everything we requested that
    // he send.
    //

    ASSERT( !NT_SUCCESS (Irp->IoStatus.Status)
            || (Irp->IoStatus.Information == afdBuffer->Mdl->ByteCount) );

    //
    // Process the Irp (note that Irp is part of the buffer)
    //
    AfdProcessBufferSend (connection, Irp);

    //
    // Now we can free the buffer
    //

    afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;
    AfdReturnBuffer( &afdBuffer->Header, connection->OwningProcess );


    //
    // Remove the reference added just before calling the transport.
    //


    DEREFERENCE_CONNECTION2( connection, "AfdRestartBufferSend, sent/error: 0x%lX",
        (NT_SUCCESS (ioStatus.Status) 
            ? (ULONG)ioStatus.Information
            : (ULONG)ioStatus.Status));

    //
    // Tell the IO system to stop processing IO completion for this IRP.
    // becuase it belongs to our buffer structure and we do not want
    // to have it freed
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
} // AfdRestartBufferSend

VOID
AfdProcessBufferSend (
    PAFD_CONNECTION Connection,
    PIRP            Irp
    )
{
   
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY listEntry;
    PIRP irp;
    BOOLEAN sendPossible;
    PIRP disconnectIrp;
    LIST_ENTRY irpsToComplete;

    endpoint = Connection->Endpoint;
    ASSERT( endpoint != NULL );
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth);
    ASSERT( !IS_TDI_BUFFERRING(endpoint) );


    IF_DEBUG(SEND) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdProcessBufferSend: send completed for IRP %p, connection %p, "
                    "status = %X\n",
                    Irp, Connection, Irp->IoStatus.Status ));
    }

    //
    // Update the count of send bytes outstanding on the connection.
    // Note that we must do this BEFORE we check to see whether there
    // are any pended sends--otherwise, there is a timing window where
    // a new send could come in, get pended, and we would not kick
    // the sends here.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    ASSERT( Connection->VcBufferredSendBytes >= Irp->IoStatus.Information );
    ASSERT( (Connection->VcBufferredSendCount & 0x8000) == 0 );
    ASSERT( Connection->VcBufferredSendCount != 0 );

    Connection->VcBufferredSendBytes -= (ULONG)Irp->IoStatus.Information;
    Connection->VcBufferredSendCount -= 1;

    //
    // If the send failed, abort the connection.
    //

    if ( !NT_SUCCESS(Irp->IoStatus.Status) ) {

        disconnectIrp = Connection->VcDisconnectIrp;
        if ( disconnectIrp != NULL ) {
            Connection->VcDisconnectIrp = NULL;
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );


        AfdBeginAbort( Connection );

        //
        // If there was a disconnect IRP, rather than just freeing it
        // give it to the transport.  This will cause the correct cleanup
        // stuff (dereferenvce objects, free IRP and disconnect context)
        // to occur.  Note that we do this AFTER starting to abort the
        // Connection so that we do not confuse the other side.
        //

        if ( disconnectIrp != NULL ) {
            IoCallDriver( Connection->DeviceObject, disconnectIrp );
        }

        AfdDeleteConnectedReference( Connection, FALSE );

        return;
    }

    //
    // Before we release the lock on the endpoint, remember
    // if the number of bytes outstanding in the TDI provider exceeds
    // the limit.  We must grab this while holding the endpoint lock.
    //

    sendPossible = (BOOLEAN)(Connection->VcBufferredSendBytes<Connection->MaxBufferredSendBytes);

    //
    // If there are no pended sends on the connection, we're done.  Tell
    // the IO system to stop processing IO completion for this IRP.
    //

    if ( IsListEmpty( &Connection->VcSendIrpListHead ) ) {

        //
        // If there is no "special condition" on the endpoint, return
        // immediately.  We use the special condition indication so that
        // we need only a single test in the typical case.
        //

        if ( !Connection->SpecialCondition ) {

            ASSERT( Connection->TdiBufferring || Connection->VcDisconnectIrp == NULL );
            ASSERT( Connection->ConnectedReferenceAdded );

            //
            // There are no sends outstanding on the Connection, so indicate
            // that the endpoint is writable.
            //

            if (sendPossible) {
                AfdIndicateEventSelectEvent(
                    endpoint,
                    AFD_POLL_SEND,
                    STATUS_SUCCESS
                    );
            }
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            if (sendPossible) {
                AfdIndicatePollEvent(
                    endpoint,
                    AFD_POLL_SEND,
                    STATUS_SUCCESS
                    );
            }

            return;
        }


        disconnectIrp = Connection->VcDisconnectIrp;
        if ( disconnectIrp != NULL && Connection->VcBufferredSendCount == 0 ) {
            Connection->VcDisconnectIrp = NULL;
        } else {
            disconnectIrp = NULL;
            if ( sendPossible ) {
                AfdIndicateEventSelectEvent(
                    endpoint,
                    AFD_POLL_SEND,
                    STATUS_SUCCESS
                    );
            }
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // If there is a disconnect IRP, give it to the TDI provider.
        //

        if ( disconnectIrp != NULL ) {
            IoCallDriver( Connection->DeviceObject, disconnectIrp );
        }
        else if ( sendPossible ) {

            AfdIndicatePollEvent(
                endpoint,
                AFD_POLL_SEND,
                STATUS_SUCCESS
                );
        }


        //
        // If the connected reference delete is pending, attempt to
        // remove it.
        //

        AfdDeleteConnectedReference( Connection, FALSE );

    
        return;
    }

    //
    // Now loop completing as many pended sends as possible. Note that
    // in order to avoid a nasty race condition (between this thread and
    // a thread performing sends on this connection) we must build a local
    // list of IRPs to complete while holding the endpoint
    // spinlock. After that list is built then we can release the lock
    // and scan the list to actually complete the IRPs.
    //
    // We complete sends when we fall below the send bufferring limits, OR
    // when there is only a single send pended.  We want to be agressive
    // in completing the send if there is only one because we want to
    // give applications every oppurtunity to get data down to us--we
    // definitely do not want to incur excessive blocking in the
    // application.
    //

    InitializeListHead( &irpsToComplete );

    while ( (Connection->VcBufferredSendBytes <=
                 Connection->MaxBufferredSendBytes ||
             Connection->VcSendIrpListHead.Flink ==
                 Connection->VcSendIrpListHead.Blink)


            &&

            !IsListEmpty( &Connection->VcSendIrpListHead ) ) {

        //
        // Take the first pended user send IRP off the connection's
        // list of pended send IRPs.
        //

        listEntry = RemoveHeadList( &Connection->VcSendIrpListHead );
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

        //
        // Reset the cancel routine in the user IRP since we're about
        // to complete it.
        //

        if ( IoSetCancelRoutine( irp, NULL ) == NULL ) {
            //
            // This IRP is about to be canceled.  Look for another in the
            // list.  Set the Flink to NULL so the cancel routine knows
            // it is not on the list.
            //

            irp->Tail.Overlay.ListEntry.Flink = NULL;
            continue;
        }

        //
        // Append the IRP to the local list.
        //

        InsertTailList(
            &irpsToComplete,
            &irp->Tail.Overlay.ListEntry
            );

    }

    if ( sendPossible ) {

        AfdIndicateEventSelectEvent(
            endpoint,
            AFD_POLL_SEND,
            STATUS_SUCCESS
            );

    }

    //
    // Now we can release the locks and scan the local list of IRPs
    // we need to complete, and actually complete them.
    //

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    while( !IsListEmpty( &irpsToComplete ) ) {
        PIO_STACK_LOCATION irpSp;

        //
        // Remove the first item from the IRP list.
        //

        listEntry = RemoveHeadList( &irpsToComplete );
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

        //
        // Complete the user's IRP with a successful status code.  The IRP
        // should already be set up with the correct status and bytes
        // written count.
        //

        irpSp = IoGetCurrentIrpStackLocation( irp );

#if DBG
        if ( irp->IoStatus.Status == STATUS_SUCCESS ) {
            ASSERT( irp->IoStatus.Information == irpSp->Parameters.AfdRestartSendInfo.AfdOriginalLength );
        }
#endif
        //
        // The send dispatch routine puts NULL into this
        // field if it wants to make sure that the IRP
        // is not completed until it is fully done with it
        //
        if (InterlockedExchangePointer (
                    &irp->Tail.Overlay.DriverContext[0],
                    (PVOID)-1)!=NULL) {
            UPDATE_CONN2 (Connection, "AfdProcessBufferSend, bytes sent reported 0x%lX", 
                                        (ULONG)irp->IoStatus.Information);
            IoCompleteRequest( irp, AfdPriorityBoost );
        }
    }

    if ( sendPossible ) {

        AfdIndicatePollEvent(
            endpoint,
            AFD_POLL_SEND,
            STATUS_SUCCESS
            );

    }

    return;

} // AfdProcessBufferSend


NTSTATUS
AfdRestartSendConnDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PAFD_SEND_CONN_DATAGRAM_CONTEXT context = Context;
    PAFD_ENDPOINT   endpoint = context->Endpoint;

    UNREFERENCED_PARAMETER (DeviceObject);
    IF_DEBUG(SEND) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartSendConnDatagram: send conn completed for "
                    "IRP %p, endpoint %p, status = %X\n",
                    Irp, endpoint, Irp->IoStatus.Status ));
    }

    ASSERT (Irp->IoStatus.Status!=STATUS_SUCCESS ||
                Irp->IoStatus.Information
                    ==IoGetCurrentIrpStackLocation (Irp)->Parameters.AfdRestartSendInfo.AfdOriginalLength);

    //
    // Free the context structure we allocated earlier.
    //

    AfdCompleteOutstandingIrp( endpoint, Irp );
    AFD_FREE_POOL(
        context,
        AFD_TDI_POOL_TAG
        );

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    DEREFERENCE_ENDPOINT2 (endpoint, "AfdRestartSendConnDatagram, status: 0x%lX", Irp->IoStatus.Status);
    return STATUS_SUCCESS;

} // AfdRestartSendConnDatagram


NTSTATUS
AfdRestartSendTdiConnDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PAFD_ENDPOINT endpoint = Context;

    UNREFERENCED_PARAMETER (DeviceObject);
    ASSERT (Irp->IoStatus.Status!=STATUS_SUCCESS ||
                Irp->IoStatus.Information
                    ==IoGetCurrentIrpStackLocation (Irp)->Parameters.AfdRestartSendInfo.AfdOriginalLength);
    IF_DEBUG(SEND) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartSendTdiConnDatagram: send conn completed for "
                    "IRP %p, endpoint %p, status = %X\n",
                    Irp, endpoint, Irp->IoStatus.Status ));
    }

    AfdCompleteOutstandingIrp( endpoint, Irp );

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    DEREFERENCE_ENDPOINT2 (endpoint, "AfdRestartSendTdiConnDatagram, status: 0x%lX", Irp->IoStatus.Status);
    return STATUS_SUCCESS;

} // AfdRestartSendTdiConnDatagram


NTSTATUS
FASTCALL
AfdSendDatagram (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PAFD_ENDPOINT endpoint;
    PTRANSPORT_ADDRESS destinationAddress;
    ULONG destinationAddressLength;
    PAFD_BUFFER_TAG afdBuffer = NULL;
    ULONG sendLength;
    ULONG bufferCount;

    //
    // Make sure that the endpoint is in the correct state.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_DGRAM_ENDPOINT(endpoint) );


    if ( !IS_DGRAM_ENDPOINT (endpoint) ||
            ((endpoint->State != AfdEndpointStateBound )
                && (endpoint->State != AfdEndpointStateConnected)) ) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        PAFD_SEND_DATAGRAM_INFO32 sendInfo32;
        LPWSABUF32 bufferArray32;

        if( IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                sizeof(*sendInfo32) ) {

            AFD_W4_INIT status = STATUS_SUCCESS;
            try {

                //
                // Validate the input structure if it comes from the user mode 
                // application
                //

                sendInfo32 = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                if( Irp->RequestorMode != KernelMode ) {

                    ProbeForReadSmallStructure(
                        sendInfo32,
                        sizeof(*sendInfo32),
                        PROBE_ALIGNMENT32 (AFD_SEND_DATAGRAM_INFO32)
                        );

                }

                //
                // Make local copies of the embeded pointer and parameters
                // that we will be using more than once in case malicios
                // application attempts to change them while we are
                // validating
                //

                bufferArray32 = UlongToPtr(sendInfo32->BufferArray);
                bufferCount = sendInfo32->BufferCount;
                destinationAddress =
                    UlongToPtr(sendInfo32->TdiConnInfo.RemoteAddress);
                destinationAddressLength =
                    sendInfo32->TdiConnInfo.RemoteAddressLength;


                //
                // Create the MDL chain describing the WSABUF array.
                // This will also validate the buffer array and individual
                // buffers
                //

                status = AfdAllocateMdlChain32(
                             Irp,       // Requestor mode passed along
                             bufferArray32,
                             bufferCount,
                             IoReadAccess,
                             &sendLength
                             );
                if( !NT_SUCCESS(status) ) {
                    goto complete;
                }


            } except( AFD_EXCEPTION_FILTER (status) ) {

                ASSERT (NT_ERROR (status));
                //
                //  Exception accessing input structure.
                //

                goto complete;
            }
        } else {

            //
            // Invalid input buffer length.
            //

            status = STATUS_INVALID_PARAMETER;
            goto complete;

        }
    }
    else
#endif _WIN64
    {
        PAFD_SEND_DATAGRAM_INFO sendInfo;
        LPWSABUF bufferArray;
        if( IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                sizeof(*sendInfo) ) {


            AFD_W4_INIT status = STATUS_SUCCESS;
            try {


                //
                // Validate the input structure if it comes from the user mode 
                // application
                //

                sendInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                if( Irp->RequestorMode != KernelMode ) {

                    ProbeForReadSmallStructure(
                        sendInfo,
                        sizeof(*sendInfo),
                        PROBE_ALIGNMENT (AFD_SEND_DATAGRAM_INFO)
                        );

                }

                //
                // Make local copies of the embeded pointer and parameters
                // that we will be using more than once in case malicios
                // application attempts to change them while we are
                // validating
                //

                bufferArray = sendInfo->BufferArray;
                bufferCount = sendInfo->BufferCount;
                destinationAddress =
                    sendInfo->TdiConnInfo.RemoteAddress;
                destinationAddressLength =
                    sendInfo->TdiConnInfo.RemoteAddressLength;



                //
                // Create the MDL chain describing the WSABUF array.
                // This will also validate the buffer array and individual
                // buffers
                //

                status = AfdAllocateMdlChain(
                            Irp,            // Requestor mode passed along
                            bufferArray,
                            bufferCount,
                            IoReadAccess,
                            &sendLength
                            );


                if( !NT_SUCCESS(status) ) {
                    goto complete;
                }

            } except( AFD_EXCEPTION_FILTER (status) ) {

                ASSERT (NT_ERROR (status));
                //
                // Exception accessing input structure.
                //
                goto complete;
            }

        } else {

            //
            // Invalid input buffer length.
            //

            status = STATUS_INVALID_PARAMETER;
            goto complete;

        }
    }


    //
    // If send has been shut down on this endpoint, fail.
    //

    if ( (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND) ) {
        status = STATUS_PIPE_DISCONNECTED;
        goto complete;
    }

    //
    // Copy the destination address to the AFD buffer.
    //

    AFD_W4_INIT ASSERT (status == STATUS_SUCCESS);
    try {

        //
        // Get an AFD buffer to use for the request.  We need this to
        // hold the destination address for the datagram.
        //

        afdBuffer = AfdGetBufferTagRaiseOnFailure(
                                        destinationAddressLength, 
                                        endpoint->OwningProcess );
        //
        // Probe the address buffer if it comes from the user mode
        // application
        //
        if( Irp->RequestorMode != KernelMode ) {
            ProbeForRead (
                destinationAddress,
                destinationAddressLength,
                sizeof (UCHAR));
        }

        RtlCopyMemory(
            afdBuffer->TdiInfo.RemoteAddress,
            destinationAddress,
            destinationAddressLength
            );

        //
        // Validate internal consistency of the transport address structure.
        // Note that we HAVE to do this after copying since the malicious
        // application can change the content of the buffer on us any time
        // and our check will be bypassed.
        //
        if ((((PTRANSPORT_ADDRESS)afdBuffer->TdiInfo.RemoteAddress)->TAAddressCount!=1) ||
                (LONG)destinationAddressLength<
                    FIELD_OFFSET (TRANSPORT_ADDRESS,
                        Address[0].Address[((PTRANSPORT_ADDRESS)afdBuffer->TdiInfo.RemoteAddress)->Address[0].AddressLength])) {
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }

        afdBuffer->TdiInfo.RemoteAddressLength = destinationAddressLength;
        ASSERT (afdBuffer->TdiInfo.RemoteAddress !=NULL);
        afdBuffer->TdiInfo.Options = NULL;
        afdBuffer->TdiInfo.OptionsLength = 0;
        afdBuffer->TdiInfo.UserData = NULL;
        afdBuffer->TdiInfo.UserDataLength = 0;

    } except( AFD_EXCEPTION_FILTER (status) ) {

        ASSERT (NT_ERROR (status));
        if (afdBuffer!=NULL) {
            AfdReturnBuffer ( &afdBuffer->Header, endpoint->OwningProcess );
        }
        goto complete;
    }

    //
    // Build the request to send the datagram.
    //

    REFERENCE_ENDPOINT2 (endpoint,"AfdSendDatagram, length: 0x%lX", sendLength);
    afdBuffer->Context = endpoint;
#if DBG
    //
    // Store send length to check transport upon completion
    //
    IrpSp->Parameters.AfdRestartSendInfo.AfdOriginalLength = sendLength;
#endif

    TdiBuildSendDatagram(
        Irp,
        endpoint->AddressDeviceObject,
        endpoint->AddressFileObject,
        AfdRestartSendDatagram,
        afdBuffer,
        Irp->MdlAddress,
        sendLength,
        &afdBuffer->TdiInfo
        );

    IF_DEBUG(SEND) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSendDatagram: SendDGInfo at %p, len = %ld\n",
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    IrpSp->Parameters.DeviceIoControl.InputBufferLength ));
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSendDatagram: remote address at %p, len = %ld\n",
                    destinationAddress,
                    destinationAddressLength ));
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSendDatagram: output buffer length = %ld\n",
                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength ));
    }

    //
    // Call the transport to actually perform the send datagram.
    //

    return AfdIoCallDriver( endpoint, endpoint->AddressDeviceObject, Irp );

complete:

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdSendDatagram


NTSTATUS
AfdRestartSendDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PAFD_BUFFER_TAG afdBuffer;
    PAFD_ENDPOINT endpoint;

    UNREFERENCED_PARAMETER (DeviceObject);

    afdBuffer = Context;

    endpoint = afdBuffer->Context;

    ASSERT( IS_DGRAM_ENDPOINT(endpoint) );

    ASSERT (Irp->IoStatus.Status!=STATUS_SUCCESS ||
                Irp->IoStatus.Information
                    ==IoGetCurrentIrpStackLocation (Irp)->Parameters.AfdRestartSendInfo.AfdOriginalLength);
    AfdCompleteOutstandingIrp( endpoint, Irp );

    IF_DEBUG(SEND) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartSendDatagram: send datagram completed for "
                    "IRP %p, endpoint %p, status = %X\n",
                    Irp, Context, Irp->IoStatus.Status ));
    }

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    AfdReturnBuffer( &afdBuffer->Header,  endpoint->OwningProcess  );

    DEREFERENCE_ENDPOINT2 (endpoint, "AfdRestartSendDatagram, status: 0x%lX", Irp->IoStatus.Status);
    return STATUS_SUCCESS;

} // AfdRestartSendDatagram


NTSTATUS
AfdSendPossibleEventHandler (
    IN PVOID TdiEventContext,
    IN PVOID ConnectionContext,
    IN ULONG BytesAvailable
    )
{
    PAFD_CONNECTION connection;
    PAFD_ENDPOINT endpoint;
    BOOLEAN       result;

    UNREFERENCED_PARAMETER( TdiEventContext );
    UNREFERENCED_PARAMETER( BytesAvailable );

    connection = (PAFD_CONNECTION)ConnectionContext;
    ASSERT( connection != NULL );

    CHECK_REFERENCE_CONNECTION (connection, result);
    if (!result) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint != NULL );

    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    ASSERT( IS_TDI_BUFFERRING(endpoint) );
    ASSERT( connection->TdiBufferring );

    IF_DEBUG(SEND) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSendPossibleEventHandler: send possible on endpoint %p "
                    " conn %p bytes=%ld\n", endpoint, connection, BytesAvailable ));
    }

    //
    // Remember that it is now possible to do a send on this connection.
    //

    if ( BytesAvailable != 0 ) {

        connection->VcNonBlockingSendPossible = TRUE;

        //
        // Complete any outstanding poll IRPs waiting for a send poll.
        //

        // Make sure connection was accepted/connected to prevent
        // indication on listening endpoint
        //
        
        if (connection->State==AfdConnectionStateConnected) {
            AFD_LOCK_QUEUE_HANDLE   lockHandle;
            AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
            AfdIndicateEventSelectEvent(
                endpoint,
                AFD_POLL_SEND,
                STATUS_SUCCESS
                );
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

            ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
            AfdIndicatePollEvent(
                endpoint,
                AFD_POLL_SEND,
                STATUS_SUCCESS
                );
        }

    } else {

        connection->VcNonBlockingSendPossible = FALSE;
    }

    DEREFERENCE_CONNECTION (connection);
    return STATUS_SUCCESS;

} // AfdSendPossibleEventHandler


VOID
AfdCancelSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Cancels a send IRP that is pended in AFD.

Arguments:

    DeviceObject - not used.

    Irp - the IRP to cancel.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    UNREFERENCED_PARAMETER (DeviceObject);
    
    //
    // Get the endpoint pointer from our IRP stack location and the
    // connection pointer from the endpoint.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    endpoint = irpSp->FileObject->FsContext;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth );

    //
    // Remove the IRP from the endpoint's IRP list if it has not been
    // removed already
    //

    ASSERT (KeGetCurrentIrql ()==DISPATCH_LEVEL);
    AfdAcquireSpinLockAtDpcLevel ( &endpoint->SpinLock, &lockHandle);

    if ( Irp->Tail.Overlay.ListEntry.Flink != NULL ) {
        RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
    }

    //
    // Release the cancel spin lock and complete the IRP with a
    // cancellation status code.
    //

    AfdReleaseSpinLockFromDpcLevel ( &endpoint->SpinLock, &lockHandle);

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_CANCELLED;

    //
    // The send dispatch routine puts NULL into this
    // field if it wants to make sure that the IRP
    // is not completed until it is fully done with it
    //
    if (InterlockedExchangePointer (
                &Irp->Tail.Overlay.DriverContext[0],
                (PVOID)-1)!=NULL) {
        IoReleaseCancelSpinLock( Irp->CancelIrql );
        IoCompleteRequest( Irp, AfdPriorityBoost );
    }
    else {
        IoReleaseCancelSpinLock( Irp->CancelIrql );
    }
    return;
} // AfdCancelSend


BOOLEAN
AfdCleanupSendIrp (
    PIRP    Irp
    )
{
    //
    // The send dispatch routine puts NULL into this
    // field if it wants to make sure that the IRP
    // is not completed until it is fully done with it
    //
    if (InterlockedExchangePointer (
                &Irp->Tail.Overlay.DriverContext[0],
                (PVOID)-1)!=NULL) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\afdkdp.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    afdkdp.h

Abstract:

    Master header file for the AFD.SYS Kernel Debugger Extensions.

Author:

    Keith Moore (keithmo) 19-Apr-1995.

Environment:

    User Mode.

--*/


#ifndef _AFDKDP_H_
#define _AFDKDP_H_


//
//  System include files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>

#include <windows.h>
#include <ntosp.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


// This is a 64 bit aware debugger extension
#define KDEXT_64BIT
#include <wdbgexts.h>
#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API
#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT pClient, PCSTR args)


//
//  Project include files.
//

#define _NTIFS_
#include <afdp.h>

//
//  Local include files.
//

#include "cons.h"
#include "type.h"
#include "data.h"
#include "proc.h"

#ifdef __cplusplus
}
#endif


#endif  // _AFDKDP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\addr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    addr.c

Abstract:

    Implements the addr command.

Author:

    Keith Moore (keithmo) 19-Apr-1995

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop


//
// Public functions.
//

DECLARE_API( addr )

/*++

Routine Description:

    Dumps the TRANSPORT_ADDRESS structure at the specified address.

Arguments:

    None.

Return Value:

    None.

--*/

{

    UCHAR transportAddress[MAX_TRANSPORT_ADDR];
    ULONG64 address = 0;
    ULONG result;
    INT     i;
    USHORT length;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];
    PCHAR       argp;

    gClient = pClient;
    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;

    //
    // Snag the address from the command line.
    //
    while (sscanf( argp, "%s%n", expr, &i )==1) {
        if( CheckControlC() ) {
            break;
        }

        argp+=i;
        address = GetExpression (expr);

        result = GetFieldValue (address, 
                            "AFD!TRANSPORT_ADDRESS",
                            "Address[0].AddressLength",
                            length);
        if (result!=0) {
            dprintf("\naddr: Could not read length of TRANSPORT_ADDRESS @ %p, err: %ld\n",
                        address, result);
            continue;
        }

        length = (USHORT)FIELD_OFFSET (TRANSPORT_ADDRESS, Address[0].Address[length]);

        if (!ReadMemory (address,
                            transportAddress,
                            length < sizeof (transportAddress)
                                ? length
                                : sizeof (transportAddress),
                            &result)) {
            dprintf("\naddr: Could not read TRANSPORT_ADDRESS @ %p (%ld bytes)\n",
                        address, length);
            continue;
        }

        if (Options & AFDKD_BRIEF_DISPLAY) {
            dprintf ("\n%s", TransportAddressToString (
                                    (PTRANSPORT_ADDRESS)transportAddress,
                                    address));
        }
        else {
            DumpTransportAddress(
                "",
                (PTRANSPORT_ADDRESS)transportAddress,
                address
                );
        }
        if (Options & AFDKD_FIELD_DISPLAY) {
            ProcessFieldOutput (address, "AFD!TRANSPORT_ADDRESS");
        }
    }

    dprintf ("\n");

    return S_OK;

}   // addr

DECLARE_API( addrlist )

/*++

Routine Description:

    Dumps the list of addresses registered by the TDI transports,

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG64     address, listHead;
    ULONG       result;
    LIST_ENTRY64 listEntry;
    ULONG64     nextEntry;
    ULONG64     nameAddress;
    WCHAR       deviceName[MAX_PATH];
    UCHAR       transportAddress[MAX_TRANSPORT_ADDR];
    USHORT      length;
    PCHAR       argp;

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }
    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ADDRLIST_DISPLAY_HEADER);
    }

    address = listHead = GetExpression( "afd!AfdAddressEntryList" );
    if( address == 0 ) {

        dprintf( "\naddrlist: Could not find afd!AfdEndpointlistHead\n" );
        return E_INVALIDARG;

    }

    if( !ReadListEntry(
            listHead,
            &listEntry) ) {
        dprintf(
            "\naddrlist: Could not read afd!AfdAddressEntryList @ %p\n",
            listHead
            );
        return E_INVALIDARG;

    }

    nextEntry = listEntry.Flink;

    while( nextEntry != listHead ) {

        if (nextEntry==0) {
            dprintf ("\naddrlist: Flink is NULL, last entry: %p\n", address);
            break;
        }

        if( CheckControlC() ) {

            break;

        }


        address = nextEntry-AddressEntryLinkOffset;

        result = (ULONG)InitTypeRead (address, AFD!AFD_ADDRESS_ENTRY);
        if (result!=0) {
            dprintf(
                "\naddrlist: Could not read AFD_ADDRESS_ENTRY @ %p\n",
                address
                );
            break;
        }
        nextEntry = ReadField (AddressListLink.Flink);
        nameAddress = ReadField (DeviceName.Buffer);
        length = (USHORT)ReadField (DeviceName.Length);

        if (!ReadMemory (nameAddress,
                        deviceName,
                        length < sizeof (deviceName)-1
                            ? length
                            : sizeof (deviceName)-1,
                            &result)) {
            dprintf(
                "\naddrlist: Could not read DeviceName for address entry @ %p\n",
                address
                );
            continue;
        }
        deviceName[result/2+1] = 0;
        length = (USHORT)ReadField (Address.AddressLength);
        length = (USHORT)FIELD_OFFSET (TA_ADDRESS, Address[length]);
        
        if (!ReadMemory (address+AddressEntryAddressOffset,
                            transportAddress+FIELD_OFFSET(TRANSPORT_ADDRESS, Address),
                            length < sizeof (transportAddress)-FIELD_OFFSET(TRANSPORT_ADDRESS, Address)
                                ? length
                                : sizeof (transportAddress)-FIELD_OFFSET(TRANSPORT_ADDRESS, Address),
                            &result)) {
            dprintf("\naddrlist: Could not read TRANSPORT_ADDRESS for address entry @ %p (%d bytes)\n",
                        address, length);
            continue;
        }

        if (!(Options & AFDKD_CONDITIONAL) ||
                    CheckConditional (address, "AFD!AFD_ADDRESS_ENTRY") ) {
            if (Options & AFDKD_BRIEF_DISPLAY) {
                dprintf (
                    IsPtr64 ()
                        ? "\n%011.011p %-37.37ls %-32.32s"
                        : "\n%008.008p %-37.37ls %-32.32s",
                        DISP_PTR(address),
                        &deviceName[sizeof("\\Device\\")-1],
                        TransportAddressToString (
                                    (PTRANSPORT_ADDRESS)transportAddress,
                                    address + 
                                        AddressEntryAddressOffset - 
                                        FIELD_OFFSET(TRANSPORT_ADDRESS, Address))
                        );


            }
            else {
                dprintf ("\nAddress List Entry @ %p\n", address);
                dprintf ("    DeviceName =    %ls\n", deviceName);

                DumpTransportAddress(
                    "    ",
                    (PTRANSPORT_ADDRESS)transportAddress,
                    address+AddressEntryAddressOffset-FIELD_OFFSET(TRANSPORT_ADDRESS, Address)
                    );
            }
            if (Options & AFDKD_FIELD_DISPLAY) {
                ProcessFieldOutput (address, "AFD!AFD_ADDRESS_ENTRY");
            }
        }
        else
            dprintf (".");
    }
    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ADDRLIST_DISPLAY_TRAILER);
    }
    else {
        dprintf ("\n");
    }

    return S_OK;
}





DECLARE_API( tranlist )

/*++

Routine Description:

    Dumps the list of transports which have open sockets associated with them.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG64 address;
    ULONG result;
    LIST_ENTRY64 listEntry;
    ULONG64 nextEntry;
    ULONG64 listHead;
    PAFDKD_TRANSPORT_INFO transportInfo;
    PCHAR       argp;

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_TRANSPORT_DISPLAY_HEADER);
    }

    listHead = address = GetExpression( "afd!AfdTransportInfoListHead" );
    if( listHead == 0 ) {

        dprintf( "\ntranlist: Could not find afd!AfdTransportInfoListHead\n" );
        return E_INVALIDARG;

    }

    if( !ReadListEntry(
            listHead,
            &listEntry) ) {
        dprintf(
            "\ntranlist: Could not read afd!AfdTransportInfoListHead @ %p\n",
            listHead
            );
        return E_INVALIDARG;

    }

    //
    // Free the old list
    //
    while (!IsListEmpty (&TransportInfoList)) {
        PLIST_ENTRY  plistEntry;
        plistEntry = RemoveHeadList (&TransportInfoList);
        transportInfo = CONTAINING_RECORD (plistEntry,
                                AFDKD_TRANSPORT_INFO,
                                Link);
        RtlFreeHeap (RtlProcessHeap (), 0, transportInfo);
    }

    nextEntry = listEntry.Flink;

    while( nextEntry != listHead ) {


        if (nextEntry==0) {
            dprintf ("\ntranlist: Flink is NULL, last entry: %p\n", address);
            break;
        }

        if( CheckControlC() ) {

            break;

        }

        address = nextEntry-TransportInfoLinkOffset;

        result = (ULONG)InitTypeRead (address, AFD!AFD_TRANSPORT_INFO);

        if (result!=0) {
            dprintf(
                "\ntranlist: Could not read AFD_TRANSPORT_INFO @ %p\n",
                address
                );
            break;
        }
        nextEntry = ReadField (TransportInfoListEntry.Flink);

        transportInfo = ReadTransportInfo (address);
        if (transportInfo!=NULL) {
            InsertHeadList (&TransportInfoList, &transportInfo->Link);
            if (!(Options & AFDKD_CONDITIONAL) ||
                        CheckConditional (address, "AFD!AFD_TRANSPORT_INFO") ) {
                if (Options & AFDKD_BRIEF_DISPLAY) {
                    DumpTransportInfoBrief (transportInfo);
                }
                else {
                    DumpTransportInfo (transportInfo);
                }
                if (Options & AFDKD_FIELD_DISPLAY) {
                    ProcessFieldOutput (address, "AFD!AFD_TRANSPORT_INFO");
                }
            }
            else
                dprintf (".");
        }
        else
            break;
    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_TRANSPORT_DISPLAY_TRAILER);
    }
    else {
        dprintf ("\n");
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\tpackets.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    tpackets.c

Abstract:

    This module contains support for fast kernel-level file transmission
    over a socket handle.

Author:

    Vadim Eydelman (VadimE) January 1999

Revision History:

--*/

#include "afdp.h"


#if DBG
PIRP    Irp;
C_ASSERT (sizeof (AFD_TPACKETS_IRP_CTX)<=sizeof (Irp->Tail.Overlay.DriverContext));
#endif

#if DBG
ULONG
__inline
AFD_SET_TP_FLAGS (
     PIRP                        TpIrp,
     ULONG                       Flags
     )
{
    PAFD_TPACKETS_IRP_CTX   ctx = AFD_GET_TPIC(TpIrp);
    ASSERT ((ctx->StateFlags & Flags)==0);
    return InterlockedExchangeAdd ((PLONG)&(ctx)->StateFlags, Flags);
}

ULONG
__inline
AFD_CLEAR_TP_FLAGS (
     PIRP                        TpIrp,
     ULONG                       Flags
     )
{
    PAFD_TPACKETS_IRP_CTX   ctx = AFD_GET_TPIC(TpIrp);
    ASSERT ((ctx->StateFlags & Flags)==Flags);
    return InterlockedExchangeAdd ((PLONG)&(ctx)->StateFlags, 0-Flags);
}

#else

#define AFD_SET_TP_FLAGS(_i,_f)     \
    InterlockedExchangeAdd ((PLONG)&AFD_GET_TPIC(_i)->StateFlags, _f)

#define AFD_CLEAR_TP_FLAGS(_i,_f)   \
    InterlockedExchangeAdd ((PLONG)&AFD_GET_TPIC(_i)->StateFlags, 0-(_f))
#endif

//
// Reference/dereference macros for transmit info structure.
// We keep transmit IRP pending and all the elements of
// the structure till last reference to it is gone.
// Note, that reference can be added only if structure
// already has non-0 reference count.
//
#if REFERENCE_DEBUG
VOID
AfdReferenceTPackets (
    IN PIRP  Irp,
    IN LONG  LocationId,
    IN ULONG Param
    );

LONG
AfdDereferenceTPackets (
    IN PIRP  Irp,
    IN LONG  LocationId,
    IN ULONG Param
    );

VOID
AfdUpdateTPacketsTrack (
    IN PIRP  Irp,
    IN LONG  LocationId,
    IN ULONG Param
    );

#define REFERENCE_TPACKETS(_i) {                                        \
        static LONG _arl;                                               \
        AfdReferenceTPackets(_i,AFD_GET_ARL(__FILE__"(%d)+"),__LINE__); \
    }

#define DEREFERENCE_TPACKETS(_i) {                                      \
        static LONG _arl;                                               \
        if (AfdDereferenceTPackets(_i,AFD_GET_ARL(__FILE__"(%d)-"),__LINE__)==0) {\
            AfdCompleteTPackets(_i);                                    \
        };\
    }

#define DEREFERENCE_TPACKETS_R(_i,_r) {                                 \
        static LONG _arl;                                               \
        _r = AfdDereferenceTPackets(_i,AFD_GET_ARL(__FILE__"(%d)-"),__LINE__);\
    }

#define UPDATE_TPACKETS(_i) {                                           \
        static LONG _arl;                                               \
        AfdUpdateTPacketsTrack((_i),AFD_GET_ARL(__FILE__"(%d)="),__LINE__);\
    }

#define UPDATE_TPACKETS2(_i,_s,_p) {                                    \
        static LONG _arl;                                               \
        AfdUpdateTPacketsTrack((_i),AFD_GET_ARL(_s"="),_p);             \
    }
#else // REFERENCE_DEBUG

#define REFERENCE_TPACKETS(_i)                                          \
    InterlockedIncrement ((PLONG)&AFD_GET_TPIC(_i)->ReferenceCount)

#define DEREFERENCE_TPACKETS(_i)                                        \
    if (InterlockedDecrement((PLONG)&AFD_GET_TPIC(_i)->ReferenceCount)==0) {\
        AfdCompleteTPackets(_i);                                        \
    }

#define DEREFERENCE_TPACKETS_R(_i,_r) {                                 \
    _r = InterlockedDecrement((PLONG)&AFD_GET_TPIC(_i)->ReferenceCount);\
}

#define UPDATE_TPACKETS(_i)

#define UPDATE_TPACKETS2(_i,_s,_p)

#endif // REFERENCE_DEBUG

#if DBG
//
// Doesn't seem like we have a file system that does not
// support cache.  So this is here for debugging purposes.
//
ULONG   AfdUseCache=TRUE;
#define AFD_USE_CACHE(file) \
    (AfdUseCache&&(((file)->Flags&FO_CACHE_SUPPORTED)!=0))

#else   // DBG

#define AFD_USE_CACHE(file) (((file)->Flags & FO_CACHE_SUPPORTED)!=0)

#endif  // DBG


VOID
AfdTPacketsWorker (
    PVOID   Context
    );

VOID
AfdPerformTpDisconnect (
    PIRP    TpIrp
    );

NTSTATUS
AfdBuildPacketChain (
    PIRP                TpIrp,
    PAFD_BUFFER_HEADER  *Pd
    );

BOOLEAN
AfdCleanupPacketChain (
    PIRP    TpIrp,
    BOOLEAN BelowDispatch
    );

NTSTATUS
AfdTPacketsSend (
    PIRP    TpIrp,
    USHORT  SendIrp
    );

NTSTATUS
AfdRestartTPacketsSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartTPDetachedSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

USHORT
AfdTPacketsFindSendIrp (
    PIRP    TpIrp
    );

NTSTATUS
AfdTPacketsMdlRead (
    PIRP                TpIrp,
    PAFD_BUFFER_HEADER  Pd
    );

NTSTATUS
AfdRestartTPacketsMdlRead (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdMdlReadComplete (
    PFILE_OBJECT    FileObject,
    PMDL            FileMdl,
    PLARGE_INTEGER  FileOffset
    );


NTSTATUS
AfdRestartMdlReadComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
AfdLRMdlReadComplete (
    PAFD_BUFFER_HEADER  Pd
    );

BOOLEAN
AfdLRProcessFileMdlList (
    PAFD_LR_LIST_ITEM Item
    );

NTSTATUS
AfdTPacketsBufferRead (
    PIRP                TpIrp,
    PAFD_BUFFER_HEADER  Pd
    );

NTSTATUS
AfdRestartTPacketsBufferRead (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
AfdTPacketsContinueAfterRead (
    PIRP    TpIrp
    );

VOID
AfdCompleteTPackets (
    PVOID       Context
    );

VOID
AfdAbortTPackets (
    PIRP        TpIrp,
    NTSTATUS    Status
    );

VOID
AfdCancelTPackets (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
BOOLEAN
AfdTPacketsEnableSendAndDisconnect (
    PIRP TpIrp
    );
#endif // TDI_SERVICE_SEND_AND_DISCONNECT

BOOLEAN
AfdQueueTransmit (
    PIRP        Irp
    );

VOID
AfdStartNextQueuedTransmit(
    VOID
    );

BOOLEAN
AfdEnqueueTPacketsIrp (
    PAFD_ENDPOINT   Endpoint,
    PIRP            TpIrp
    );

VOID
AfdStartTPacketsWorker (
    PWORKER_THREAD_ROUTINE  WorkerRoutine,
    PIRP                    TpIrp
    );

VOID
AfdTPacketsApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    );

VOID
AfdTPacketsApcRundownRoutine (
    IN struct _KAPC *Apc
    );

VOID
AfdStartNextTPacketsIrp (
    PAFD_ENDPOINT   Endpoint,
    PIRP            TpIrp
    );

VOID
AfdSendQueuedTPSend (
    PAFD_ENDPOINT   Endpoint,
    PIRP            SendIrp
    );

BOOLEAN
AfdGetTPacketsReference (
    PIRP    Irp
    );

VOID
AfdReturnTpInfo (
    PAFD_TPACKETS_INFO_INTERNAL TpInfo
    );

PAFD_TPACKETS_INFO_INTERNAL
AfdInitializeTpInfo (
    PVOID   MemoryBlock,
    ULONG   ElementCount,
    CCHAR   StackCount
    );

#ifdef _WIN64
NTSTATUS
AfdTransmitPackets32 (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    OUT PAFD_TPACKETS_INFO_INTERNAL *TpInfo,
    OUT BOOLEAN *FileError,
    OUT ULONG   *MaxPacketSize
    );
#endif //_WIN64

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdTransmitPackets )
#ifdef _WIN64
#pragma alloc_text( PAGE, AfdTransmitPackets32 )
#endif //_WIN64
#pragma alloc_text( PAGE, AfdTPacketsWorker )
#pragma alloc_text( PAGEAFD, AfdPerformTpDisconnect )
#pragma alloc_text( PAGE, AfdBuildPacketChain )
#pragma alloc_text( PAGEAFD, AfdCleanupPacketChain )
#pragma alloc_text( PAGEAFD, AfdTPacketsSend )
#pragma alloc_text( PAGEAFD, AfdRestartTPacketsSend )
#pragma alloc_text( PAGEAFD, AfdRestartTPDetachedSend )
#pragma alloc_text( PAGEAFD, AfdTPacketsFindSendIrp)
#pragma alloc_text( PAGE, AfdTPacketsMdlRead )
#pragma alloc_text( PAGEAFD, AfdRestartTPacketsMdlRead )
#pragma alloc_text( PAGE, AfdMdlReadComplete )
#pragma alloc_text( PAGEAFD, AfdRestartMdlReadComplete )
#pragma alloc_text( PAGE, AfdLRMdlReadComplete )
#pragma alloc_text( PAGE, AfdLRProcessFileMdlList )
#pragma alloc_text( PAGE, AfdTPacketsBufferRead )
#pragma alloc_text( PAGEAFD, AfdRestartTPacketsBufferRead )
#pragma alloc_text( PAGEAFD, AfdTPacketsContinueAfterRead )
#pragma alloc_text( PAGEAFD, AfdCompleteTPackets )
#pragma alloc_text( PAGEAFD, AfdAbortTPackets )
#pragma alloc_text( PAGEAFD, AfdCancelTPackets )
#pragma alloc_text( PAGEAFD, AfdCompleteClosePendedTPackets )
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
#pragma alloc_text( PAGEAFD, AfdTPacketsEnableSendAndDisconnect )
#endif
#pragma alloc_text( PAGEAFD, AfdQueueTransmit )
#pragma alloc_text( PAGEAFD, AfdStartNextQueuedTransmit )
#pragma alloc_text( PAGEAFD, AfdStartTPacketsWorker )
#pragma alloc_text( PAGE, AfdTPacketsApcKernelRoutine )
#pragma alloc_text( PAGE, AfdTPacketsApcRundownRoutine )
#pragma alloc_text( PAGEAFD, AfdEnqueueTPacketsIrp )
#pragma alloc_text( PAGEAFD, AfdEnqueueTpSendIrp )
#pragma alloc_text( PAGEAFD, AfdSendQueuedTPSend )
#pragma alloc_text( PAGEAFD, AfdStartNextTPacketsIrp )
#pragma alloc_text( PAGEAFD, AfdGetTPacketsReference )
#if REFERENCE_DEBUG
#pragma alloc_text( PAGEAFD, AfdReferenceTPackets )
#pragma alloc_text( PAGEAFD, AfdDereferenceTPackets )
#pragma alloc_text( PAGEAFD, AfdUpdateTPacketsTrack )
#endif
#pragma alloc_text( PAGE, AfdGetTpInfoFast )
#ifdef _AFD_VARIABLE_STACK_
#pragma alloc_text( PAGE, AfdGetTpInfoWithMaxStackSize )
#pragma alloc_text( PAGE, AfdComputeTpInfoSize )
#else //_AFD_VARIABLE_STACK_
#pragma alloc_text( INIT, AfdComputeTpInfoSize )
#endif //_AFD_VARIABLE_STACK_
#pragma alloc_text( PAGEAFD, AfdReturnTpInfo )
#pragma alloc_text( PAGEAFD, AfdAllocateTpInfo )
#pragma alloc_text( PAGEAFD, AfdInitializeTpInfo )
#pragma alloc_text( PAGEAFD, AfdFreeTpInfo )
#endif



NTSTATUS
FASTCALL
AfdTransmitPackets (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Initial entrypoint for handling transmit packets IRPs.  This routine
    verifies parameters, initializes data structures to be used for
    the request, and initiates the I/O.

Arguments:

    Irp - a pointer to a transmit file IRP.

    IrpSp - Our stack location for this IRP.

Return Value:

    STATUS_PENDING if the request was initiated successfully, or a
    failure status code if there was an error.

--*/

{
    PAFD_ENDPOINT       endpoint;
    NTSTATUS            status;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = NULL;
    BOOLEAN             fileError = FALSE;
    ULONG               maxPacketSize = 0, maxSendBytes;
    PAFD_CONNECTION     connection = NULL;


    PAGED_CODE ();
    //
    // Initial request validity checks: is the endpoint connected, is
    // the input buffer large enough, etc.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Special hack to let the user mode dll know that it
    // should try SAN provider instead.
    //

    if (IS_SAN_ENDPOINT (endpoint)) {
        status = STATUS_INVALID_PARAMETER_12;
        goto complete;
    }


    //
    // The endpoint must be connected and underlying transport must support
    // TdiSend (not just TdiSendDatagram).
    //
    if ( (endpoint->Type != AfdBlockTypeVcConnecting &&
                (endpoint->Type != AfdBlockTypeDatagram ||
                        !IS_TDI_DGRAM_CONNECTION(endpoint))) ||
            endpoint->State != AfdEndpointStateConnected ) {
        status = STATUS_INVALID_CONNECTION;
        goto complete;
    }

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        status = AfdTransmitPackets32 (Irp, IrpSp, &tpInfo, &fileError, &maxPacketSize);
        if (!NT_SUCCESS (status)) {
            goto complete;
        }
    }
    else
#endif _WIN64
    {
        AFD_TPACKETS_INFO   params;
        if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                 sizeof(AFD_TPACKETS_INFO) ) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        //
        // Because we're using type 3 (neither) I/O for this IRP, the I/O
        // system does no verification on the user buffer.  Therefore, we
        // must manually check it for validity inside a try-except block.
        // We also leverage the try-except to validate and lock down the
        // head and/or tail buffers specified by the caller.
        //

        AFD_W4_INIT status = STATUS_SUCCESS;
        try {
            PFILE_OBJECT        fileObject;
            HANDLE              fileHandle;
            ULONG               lastSmallBuffer, currentLength, xLength;

            if( Irp->RequestorMode != KernelMode ) {

                //
                // Validate the control buffer.
                //

                ProbeForReadSmallStructure(
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    sizeof (AFD_TPACKETS_INFO),
                    PROBE_ALIGNMENT (AFD_TPACKETS_INFO)
                    );

            }


            params = *((PAFD_TPACKETS_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);
        
            //
            // Validate any flags specified in the request.
            //

            if ( ((params.Flags &
                     ~(AFD_TF_WRITE_BEHIND |
                                AFD_TF_DISCONNECT |
                                AFD_TF_REUSE_SOCKET |
                                AFD_TF_WORKER_KIND_MASK) )
                            != 0 )
                        ||
                 ((params.Flags & AFD_TF_WORKER_KIND_MASK) 
                            == AFD_TF_WORKER_KIND_MASK)
                        ||

                 (endpoint->Type==AfdBlockTypeDatagram &&
                     (params.Flags & (AFD_TF_DISCONNECT |
                                        AFD_TF_REUSE_SOCKET))
                            !=0) ) {
                status = STATUS_INVALID_PARAMETER;
                goto complete;
            }

            //
            // Protect from overflow
            //
            if ((params.ElementArray==NULL) || 
                    (params.ElementCount==0) ||
                    (params.ElementCount>(MAXULONG/sizeof (params.ElementArray[0])))) {
                status = STATUS_INVALID_PARAMETER;
                goto complete;
            }
            //
            // If transmit worker is not specified, use system default setting
            //
            if ((params.Flags & AFD_TF_WORKER_KIND_MASK)==AFD_TF_USE_DEFAULT_WORKER) {
                params.Flags |= AfdDefaultTransmitWorker;
            }

            //
            // Allocate tpackets info for the request
            //
            tpInfo = AfdGetTpInfo (endpoint, params.ElementCount);
            if (tpInfo==NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto complete;
            }

            tpInfo->ElementCount = 0;
                
            tpInfo->SendPacketLength = params.SendSize;
            if (tpInfo->SendPacketLength==0)
                tpInfo->SendPacketLength = AfdTransmitIoLength;
            //
            // Probe and copy/walk the array of the elements to transmit.
            //

            if( Irp->RequestorMode != KernelMode ) {
                ProbeForRead(
                    params.ElementArray,
                    sizeof (TRANSMIT_PACKETS_ELEMENT)*params.ElementCount,
                    PROBE_ALIGNMENT (TRANSMIT_PACKETS_ELEMENT)
                    );
            }

            lastSmallBuffer = 0;
            currentLength = 0;
            xLength = 0;
            tpInfo->RemainingPkts = 0;
            fileHandle = NULL;
            AFD_W4_INIT fileObject = NULL;  // Depends on variable above, but 
                                            // compiler does not see
                                            // the connection.
            for (; tpInfo->ElementCount<params.ElementCount; tpInfo->ElementCount++) {
                PAFD_TRANSMIT_PACKETS_ELEMENT  pel;
                pel = &tpInfo->ElementArray[tpInfo->ElementCount];
                pel->Flags = params.ElementArray[tpInfo->ElementCount].dwElFlags;
                if ( ((pel->Flags & (~(TP_MEMORY|TP_FILE|TP_EOP)))!=0) ||
                        ((pel->Flags & (TP_MEMORY|TP_FILE))
                                                ==(TP_MEMORY|TP_FILE)) ||
                        ((pel->Flags & (TP_MEMORY|TP_FILE))==0) ) {
                    status = STATUS_INVALID_PARAMETER;
                    goto complete;
                }

                pel->Length = params.ElementArray[tpInfo->ElementCount].cLength;
                if (pel->Flags & TP_FILE) {
                    HANDLE  hFile = params.ElementArray[tpInfo->ElementCount].hFile;


                    //
                    // Check if we already cached the file object
                    //
                    if (fileHandle==NULL || hFile!=fileHandle) {
                        //
                        // Get a referenced pointer to the file object 
                        // for the file that we're going to transmit.  This call 
                        // will fail if the file handle specified by the caller 
                        // is invalid.
                        //

                        status = ObReferenceObjectByHandle(
                                     hFile,
                                     FILE_READ_DATA,
                                     *IoFileObjectType,
                                     Irp->RequestorMode,
                                     (PVOID *)&fileObject,
                                     NULL
                                     );
                        if ( !NT_SUCCESS(status) ) {
                            fileError = TRUE;
                            goto complete;
                        }
                    }
                    else {
                        //
                        // Use our 1-element file info cache.
                        //
                        ObReferenceObject (fileObject);
                    }
                    AfdRecordFileRef();

                    //
                    // Save the file object instead of handle.
                    //
                    pel->FileObject = fileObject;

                    pel->FileOffset = params.ElementArray[
                                            tpInfo->ElementCount].nFileOffset;

                    if ( (fileObject->Flags & FO_SYNCHRONOUS_IO) &&
                             (pel->FileOffset.QuadPart == 0) ) {
                        //
                        // Use current offset if file is opened syncronously
                        // and offset is not specified.
                        //

                        pel->FileOffset = fileObject->CurrentByteOffset;
                    }

                    if ( pel->Length == 0 ) {
                        //
                        // Length was not specified, figure out the
                        // size of the entire file
                        //

                        FILE_STANDARD_INFORMATION fileInfo;
                        IO_STATUS_BLOCK ioStatusBlock;

                        status = ZwQueryInformationFile(
                                     hFile,
                                     &ioStatusBlock,
                                     &fileInfo,
                                     sizeof(fileInfo),
                                     FileStandardInformation
                                     );
                        if ( !NT_SUCCESS(status) ) {
                            //
                            // Bump element count so that file object
                            // is dereferenced in cleanup
                            //
                            tpInfo->ElementCount += 1;
                            fileError = TRUE;
                            goto complete;
                        }

                        //
                        // Make sure that offset is within the file
                        //
                        if (pel->FileOffset.QuadPart < 0
                                        ||
                            pel->FileOffset.QuadPart > fileInfo.EndOfFile.QuadPart
                                        ||
                                (fileInfo.EndOfFile.QuadPart - 
                                        pel->FileOffset.QuadPart > MAXLONG)) {
                            //
                            // Bump element count so that file object
                            // is dereferenced in cleanup
                            //
                            tpInfo->ElementCount += 1;
                            status = STATUS_INVALID_PARAMETER;
                            fileError = TRUE;
                            goto complete;

                        }
                        pel->Length = (ULONG)(fileInfo.EndOfFile.QuadPart - 
                                                    pel->FileOffset.QuadPart);
                    }
                    else if (pel->FileOffset.QuadPart<0) {
                        //
                        // Bump element count so that file object
                        // is dereferenced in cleanup
                        //
                        tpInfo->ElementCount += 1;
                        status = STATUS_INVALID_PARAMETER;
                        fileError = TRUE;
                        goto complete;

                    }
                    //
                    // Update our 1-element file information cache
                    //
                    fileHandle = hFile;

                }
                else {
                    ASSERT (pel->Flags & TP_MEMORY);
                    //
                    // For memory object just save the buffer pointer 
                    // (length is saved above), we'll probe and lock/copy
                    // the data as we send it.
                    //
                    pel->Buffer = params.ElementArray[
                                            tpInfo->ElementCount].pBuffer;
                    if (pel->Length<=AfdTPacketsCopyThreshold) {
                        if (lastSmallBuffer!=0 &&
                                (lastSmallBuffer+=pel->Length) <= AfdTPacketsCopyThreshold &&
                                (currentLength+lastSmallBuffer) <= tpInfo->SendPacketLength) {
                            (pel-1)->Flags |= TP_COMBINE;
                        }
                        else
                            lastSmallBuffer = pel->Length;
                        if (!(pel->Flags & TP_EOP))
                            goto NoBufferReset;
                    }

                }
                lastSmallBuffer = 0;

            NoBufferReset:
                if (pel->Flags & TP_EOP) {
                    currentLength = 0;
                }
                else {
                    currentLength = (currentLength+pel->Length)%tpInfo->SendPacketLength;
                }

                //
                // Compute the total number of packets that we will send.
                // This is necessary so that once we are close to the end
                // we can buffer the remaining data and stop processing
                // early.
                //
                if (tpInfo->RemainingPkts!=MAXULONG) {
                    ULONG   n;
                    ULONGLONG x;
                    //
                    // Add length of the element to data left from the 
                    // previous one.
                    //
                    x = xLength + pel->Length;

                    //
                    // Compute total number of packets pased on max packet
                    // length.
                    //
                    n = tpInfo->RemainingPkts + (ULONG)(xLength/tpInfo->SendPacketLength);

                    //
                    // Compute the length of the last incomplete packet to
                    // be combined with the next element.
                    //
                    xLength = (ULONG)(x%tpInfo->SendPacketLength);

                    //
                    // Compute the max size of the packet
                    //
                    if (x>tpInfo->SendPacketLength)
                        maxPacketSize = tpInfo->SendPacketLength; // This is absolute max.
                    else if (maxPacketSize<xLength)
                        maxPacketSize = xLength;

                    if (n>=tpInfo->RemainingPkts && n<MAXULONG) {
                        tpInfo->RemainingPkts = n;
                        if (pel->Flags & TP_EOP) {
                            if (xLength!=0 || pel->Length==0) {
                                tpInfo->RemainingPkts += 1;
                                xLength = 0;
                            }
                        }
                    }
                    else {
                        tpInfo->RemainingPkts = MAXULONG;
                    }
                }
            }

        } except( AFD_EXCEPTION_FILTER (status) ) {
            ASSERT (NT_ERROR (status));

            goto complete;
        }
        //
        // Initialize flags.
        //
        AFD_GET_TPIC(Irp)->Flags = params.Flags;

    }


    if (endpoint->Type==AfdBlockTypeVcConnecting) {

        //
        // Setting AFD_TF_REUSE_SOCKET implies that a disconnect is desired.
        // Also, setting this flag means that no more I/O is legal on the
        // endpoint until the transmit request has been completed, so
        // set up the endpoint's state so that I/O fails.
        //

        if ( (AFD_GET_TPIC(Irp)->Flags & (AFD_TF_REUSE_SOCKET|AFD_TF_DISCONNECT)) != 0 ) {
            //
            // Make sure we only execute one transmitfile transmitpackets request
            // at a time on a given endpoint with disconnect option.
            //
            if (!AFD_START_STATE_CHANGE (endpoint, endpoint->State)) {
                status = STATUS_INVALID_CONNECTION;
                goto complete;
            }

            //
            // Revalidate the state of the endpoint/connection so that
            // state change is valid (e.g. not already closing).
            //
            if ( endpoint->Type != AfdBlockTypeVcConnecting ||
                     endpoint->State != AfdEndpointStateConnected ) {
                AFD_END_STATE_CHANGE (endpoint);
                status = STATUS_INVALID_CONNECTION;
                goto complete;
            }

            if ( (AFD_GET_TPIC(Irp)->Flags & AFD_TF_REUSE_SOCKET) != 0 ) {
                AFD_GET_TPIC(Irp)->Flags |= AFD_TF_DISCONNECT;
                endpoint->State = AfdEndpointStateTransmitClosing;
            }
            //
            // Make sure we won't loose this connection.
            // until we enqueue the IRP
            //
            connection = endpoint->Common.VcConnecting.Connection;
            REFERENCE_CONNECTION (connection);
        }
        else if (!AFD_PREVENT_STATE_CHANGE (endpoint)) {
            status = STATUS_INVALID_CONNECTION;
            goto complete;
        }
        else if (endpoint->Type != AfdBlockTypeVcConnecting ||
                     endpoint->State != AfdEndpointStateConnected ) {
            AFD_REALLOW_STATE_CHANGE (endpoint);
            status = STATUS_INVALID_CONNECTION;
            goto complete;
        }
        else {
            //
            // Make sure we won't loose this connection.
            // until we enqueue the IRP
            //
            connection = endpoint->Common.VcConnecting.Connection;
            REFERENCE_CONNECTION (connection);
            AFD_REALLOW_STATE_CHANGE (endpoint);
        }

        //
        // Connection endpoint, get connection file object and device
        //
        tpInfo->TdiFileObject = connection->FileObject;
        tpInfo->TdiDeviceObject = connection->DeviceObject;
        maxSendBytes = connection->MaxBufferredSendBytes;
        UPDATE_TPACKETS2 (Irp, "Connection object handle: 0x%lX",
            HandleToUlong (endpoint->Common.VcConnecting.Connection->Handle));

    }
    else if (!AFD_PREVENT_STATE_CHANGE (endpoint)) {
        status = STATUS_INVALID_CONNECTION;
        goto complete;
    }
    else if (endpoint->Type != AfdBlockTypeDatagram ||
                 endpoint->State != AfdEndpointStateConnected ||
                 !IS_TDI_DGRAM_CONNECTION(endpoint)) {
        status = STATUS_INVALID_CONNECTION;
        AFD_REALLOW_STATE_CHANGE (endpoint);
        goto complete;
    }
    else {
        AFD_REALLOW_STATE_CHANGE (endpoint);
        //
        // Datagram endpoint, get address file object and device
        // Note that there is no danger in address or file object
        // disappearing since datagram endpoint cannot be re-used.
        //
        tpInfo->TdiFileObject = endpoint->AddressFileObject;
        tpInfo->TdiDeviceObject = endpoint->AddressDeviceObject;
        maxSendBytes = endpoint->Common.Datagram.MaxBufferredSendBytes;
        UPDATE_TPACKETS2 (Irp, "Address object handle: 0x%lX", HandleToUlong (endpoint->AddressHandle));
    }


    //
    // Compute the total number of IRPS to use based
    // on SO_SNDBUF setting and maximum packet size
    // (we do not want to buffer more than SO_SNDBUF).
    //
    {
        ULONG   irpCount;
        if (maxPacketSize==0) {
            maxPacketSize = tpInfo->SendPacketLength;
        }

        irpCount = maxSendBytes/maxPacketSize;
        if (irpCount>AFD_TP_MIN_SEND_IRPS) {
            if (irpCount>AFD_TP_MAX_SEND_IRPS) {
                tpInfo->NumSendIrps = AFD_TP_MAX_SEND_IRPS;
            }
            else {
                tpInfo->NumSendIrps = (USHORT)irpCount;
            }
        }
    }

    //
    // Save tpacket info in the IRP
    //
    Irp->AssociatedIrp.SystemBuffer = tpInfo;

    //
    // Clear the Flink in the IRP to indicate this IRP is not queued.
    // Blink is set to indicate that IRP was not counted towards
    // active maximum (so if it is completed, we do not start the next one).
    //

    Irp->Tail.Overlay.ListEntry.Flink = NULL;
    Irp->Tail.Overlay.ListEntry.Blink = (PVOID)1;

    //
    // Initialize the IRP result fields
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    // We are going to pend this IRP
    //
    IoMarkIrpPending( Irp );

    //
    // Initialize queuing and state information.
    //
    AFD_GET_TPIC(Irp)->Next = NULL;
    AFD_GET_TPIC(Irp)->ReferenceCount = 1;
    AFD_GET_TPIC(Irp)->StateFlags = AFD_TP_WORKER_SCHEDULED;

    if ((InterlockedCompareExchangePointer ((PVOID *)&endpoint->Irp,
                                                Irp,
                                                NULL)==NULL) ||
            !AfdEnqueueTPacketsIrp (endpoint, Irp)) {



        IoSetCancelRoutine( Irp, AfdCancelTPackets );

        //
        //  Check to see if this Irp has been cancelled.
        //

        if ( !endpoint->EndpointCleanedUp && !Irp->Cancel ) {
            //
            // Determine if we can really start this file transmit now. If we've
            // exceeded the configured maximum number of active TransmitFile/Packets
            // requests, then append this IRP to the TransmitFile/Packets queue 
            // and set a flag in the transmit info structure to indicate that 
            // this IRP is queued.
            //
            if( AfdMaxActiveTransmitFileCount == 0 || 
                    !AfdQueueTransmit (Irp)) {

                UPDATE_ENDPOINT (endpoint);
                //
                // Start I/O
                //
                AfdTPacketsWorker (Irp);
            }
        }
        else {
            //
            // Abort the request
            // Note that neither cancel nor endpoint cleanup can complete 
            // the IRP since we hold the reference to the tpInfo structure.
            //
            AfdAbortTPackets (Irp, STATUS_CANCELLED);
        
            //
            // Remove the initial reference and force completion.
            //
            DEREFERENCE_TPACKETS (Irp);
        }
    }

    if (connection!=NULL) {
        DEREFERENCE_CONNECTION (connection);
    }

    return STATUS_PENDING;


complete:

    //
    // Tell the caller that we encountered an error
    // when accessing file not socket.
    //
    if (fileError && IrpSp->Parameters.DeviceIoControl.OutputBufferLength>=sizeof (BOOLEAN)) {
        if (Irp->RequestorMode != KernelMode) {
            try {
                ProbeAndWriteBoolean ((BOOLEAN *)Irp->UserBuffer, TRUE);
            } except( AFD_EXCEPTION_FILTER (status) ) {
                ASSERT (NT_ERROR (status));
            }
        } else {
            *((BOOLEAN *)Irp->UserBuffer) = TRUE;
        }
    }

    ASSERT ( endpoint->Irp != Irp );

    if (tpInfo!=NULL) {
        //
        // AfdReturnTpInfo will dereference all file objects we
        // managed to reference.
        //
        AfdReturnTpInfo (tpInfo);
    }
    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTransmitPackets: Failing Irp-%p,endpoint-%p,status-%lx\n",
                    Irp,endpoint,status));
    }
    //
    // Complete the request.
    //

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, 0 );

    return status;
}

#ifdef _WIN64
NTSTATUS
AfdTransmitPackets32 (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    OUT PAFD_TPACKETS_INFO_INTERNAL *TpInfo,
    OUT BOOLEAN *FileError,
    OUT ULONG   *MaxPacketSize
    )

/*++

Routine Description:

    32-bit thunk.
    Initial entrypoint for handling transmit packets IRPs.  This routine
    verifies parameters, initializes data structures to be used for
    the request, and initiates the I/O.

Arguments:

    Irp - a pointer to a transmit file IRP.

    IrpSp - Our stack location for this IRP.

Return Value:

    STATUS_PENDING if the request was initiated successfully, or a
    failure status code if there was an error.

--*/

{
    PAFD_ENDPOINT       endpoint;
    NTSTATUS            status = STATUS_SUCCESS;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = NULL;
    AFD_TPACKETS_INFO32 params;
    ULONG               maxPacketSize;


    PAGED_CODE ();

    //
    // Initial request validity checks: is the endpoint connected, is
    // the input buffer large enough, etc.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(AFD_TPACKETS_INFO32) ) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    //
    // Because we're using type 3 (neither) I/O for this IRP, the I/O
    // system does no verification on the user buffer.  Therefore, we
    // must manually check it for validity inside a try-except block.
    // We also leverage the try-except to validate and lock down the
    // head and/or tail buffers specified by the caller.
    //

    try {
        PFILE_OBJECT        fileObject;
        HANDLE              fileHandle;
        ULONG               lastSmallBuffer, currentLength, xLength;

        if( Irp->RequestorMode != KernelMode ) {

            //
            // Validate the control buffer.
            //

            ProbeForReadSmallStructure(
                IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                sizeof (AFD_TPACKETS_INFO32),
                PROBE_ALIGNMENT32 (AFD_TPACKETS_INFO32)
                );

        }


        params = *((PAFD_TPACKETS_INFO32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);
        
        //
        // Validate any flags specified in the request.
        //

        if ( ((params.Flags &
                 ~(AFD_TF_WRITE_BEHIND |
                            AFD_TF_DISCONNECT |
                            AFD_TF_REUSE_SOCKET |
                            AFD_TF_WORKER_KIND_MASK) )
                        != 0 )
                    ||
             ((params.Flags & AFD_TF_WORKER_KIND_MASK) 
                        == AFD_TF_WORKER_KIND_MASK)
                    ||

             (endpoint->Type==AfdBlockTypeDatagram &&
                 (params.Flags & (AFD_TF_DISCONNECT |
                                    AFD_TF_REUSE_SOCKET))
                        !=0) ) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        //
        // Protect from overflow
        //
        if ((UlongToPtr(params.ElementArray)==NULL) || 
                (params.ElementCount==0) ||
                (params.ElementCount>(MAXULONG/sizeof (TRANSMIT_PACKETS_ELEMENT32)))) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        //
        // If transmit worker is not specified, use system default setting
        //
        if ((params.Flags & AFD_TF_WORKER_KIND_MASK)==AFD_TF_USE_DEFAULT_WORKER) {
            params.Flags |= AfdDefaultTransmitWorker;
        }

        //
        // Allocate tpackets info for the request
        //
        tpInfo = AfdGetTpInfo (endpoint, params.ElementCount);
        if (tpInfo==NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete;
        }

        tpInfo->ElementCount = 0;
        
        tpInfo->SendPacketLength = params.SendSize;
        if (tpInfo->SendPacketLength==0)
            tpInfo->SendPacketLength = AfdTransmitIoLength;
        //
        // Probe and copy/walk the array of the elements to transmit.
        //

        if( Irp->RequestorMode != KernelMode ) {
            ProbeForRead(
                params.ElementArray,
                sizeof (TRANSMIT_PACKETS_ELEMENT32)*params.ElementCount,
                PROBE_ALIGNMENT32 (TRANSMIT_PACKETS_ELEMENT32)
                );
        }

        lastSmallBuffer = 0;
        currentLength = 0;
        xLength = 0;
        tpInfo->RemainingPkts = 0;
        maxPacketSize = 0;
        fileHandle = NULL;
        AFD_W4_INIT fileObject = NULL;  // Depends on variable above, but compiler 
                                        // does not see the connection.
        for (; tpInfo->ElementCount<params.ElementCount; tpInfo->ElementCount++) {
            PAFD_TRANSMIT_PACKETS_ELEMENT  pel;
            pel = &tpInfo->ElementArray[tpInfo->ElementCount];
            pel->Flags = ((TRANSMIT_PACKETS_ELEMENT32*)UlongToPtr(params.ElementArray))[tpInfo->ElementCount].dwElFlags;
            if ( ((pel->Flags & (~(TP_MEMORY|TP_FILE|TP_EOP)))!=0) ||
                    ((pel->Flags & (TP_MEMORY|TP_FILE))
                                            ==(TP_MEMORY|TP_FILE)) ||
                    ((pel->Flags & (TP_MEMORY|TP_FILE))==0) ) {
                status = STATUS_INVALID_PARAMETER;
                goto complete;
            }

            pel->Length = ((TRANSMIT_PACKETS_ELEMENT*)UlongToPtr(params.ElementArray))[tpInfo->ElementCount].cLength;
            if (pel->Flags & TP_FILE) {
                HANDLE  hFile = ((TRANSMIT_PACKETS_ELEMENT32*)UlongToPtr(params.ElementArray))[tpInfo->ElementCount].hFile;


                //
                // Check if we already cached the file object
                //
                if (fileHandle==NULL || hFile!=fileHandle) {
                    //
                    // Get a referenced pointer to the file object 
                    // for the file that we're going to transmit.  This call 
                    // will fail if the file handle specified by the caller 
                    // is invalid.
                    //

                    status = ObReferenceObjectByHandle(
                                 hFile,
                                 FILE_READ_DATA,
                                 *IoFileObjectType,
                                 Irp->RequestorMode,
                                 (PVOID *)&fileObject,
                                 NULL
                                 );
                    if ( !NT_SUCCESS(status) ) {
                        *FileError = TRUE;
                        goto complete;
                    }
                }
                else {
                    //
                    // Use our 1-element file info cache.
                    //
                    ObReferenceObject (fileObject);
                }
                AfdRecordFileRef();

                //
                // Save the file object instead of handle.
                //
                pel->FileObject = fileObject;

                pel->FileOffset = ((TRANSMIT_PACKETS_ELEMENT32*)UlongToPtr(params.ElementArray))[
                                        tpInfo->ElementCount].nFileOffset;

                if ( (fileObject->Flags & FO_SYNCHRONOUS_IO) &&
                         (pel->FileOffset.QuadPart == 0) ) {
                    //
                    // Use current offset if file is opened syncronously
                    // and offset is not specified.
                    //

                    pel->FileOffset = fileObject->CurrentByteOffset;
                }

                if ( pel->Length == 0 ) {
                    //
                    // Length was not specified, figure out the
                    // size of the entire file
                    //

                    FILE_STANDARD_INFORMATION fileInfo;
                    IO_STATUS_BLOCK ioStatusBlock;

                    status = ZwQueryInformationFile(
                                 hFile,
                                 &ioStatusBlock,
                                 &fileInfo,
                                 sizeof(fileInfo),
                                 FileStandardInformation
                                 );
                    if ( !NT_SUCCESS(status) ) {
                        //
                        // Bump element count so that file object
                        // is dereferenced in cleanup
                        //
                        tpInfo->ElementCount += 1;
                        *FileError = TRUE;
                        goto complete;
                    }

                    //
                    // Make sure that offset is within the file
                    //
                    if (pel->FileOffset.QuadPart < 0
                                        ||
                            pel->FileOffset.QuadPart > fileInfo.EndOfFile.QuadPart
                                        ||
                                (fileInfo.EndOfFile.QuadPart - 
                                        pel->FileOffset.QuadPart > MAXLONG)) {
                        //
                        // Bump element count so that file object
                        // is dereferenced in cleanup
                        //
                        tpInfo->ElementCount += 1;
                        status = STATUS_INVALID_PARAMETER;
                        *FileError = TRUE;
                        goto complete;

                    }
                    pel->Length = (ULONG)(fileInfo.EndOfFile.QuadPart - 
                                                pel->FileOffset.QuadPart);
                }
                else if (pel->FileOffset.QuadPart<0) {
                    //
                    // Bump element count so that file object
                    // is dereferenced in cleanup
                    //
                    tpInfo->ElementCount += 1;
                    status = STATUS_INVALID_PARAMETER;
                    *FileError = TRUE;
                    goto complete;
                }
                //
                // Update our 1-element file information cache
                //
                fileHandle = hFile;

            }
            else {
                ASSERT (pel->Flags & TP_MEMORY);
                //
                // For memory object just save the buffer pointer 
                // (length is saved above), we'll probe and lock/copy
                // the data as we send it.
                //
                pel->Buffer = UlongToPtr(((TRANSMIT_PACKETS_ELEMENT32*)UlongToPtr(params.ElementArray))[
                                        tpInfo->ElementCount].pBuffer);

                if (pel->Length<=AfdTPacketsCopyThreshold) {
                    if (lastSmallBuffer!=0 &&
                            (lastSmallBuffer+=pel->Length) <= AfdTPacketsCopyThreshold &&
                            (currentLength+lastSmallBuffer) <= tpInfo->SendPacketLength) {
                        (pel-1)->Flags |= TP_COMBINE;
                    }
                    else
                        lastSmallBuffer = pel->Length;
                    if (!(pel->Flags & TP_EOP))
                        goto NoBufferReset;
                }

            }
            lastSmallBuffer = 0;

        NoBufferReset:
            if (pel->Flags & TP_EOP) {
                currentLength = 0;
            }
            else {
                currentLength = (currentLength+pel->Length)%tpInfo->SendPacketLength;
            }

            //
            // Compute the total number of packets that we will send.
            // This is necessary so that once we are close to the end
            // we can buffer the remaining data and stop processing
            // early.
            //
            if (tpInfo->RemainingPkts!=MAXULONG) {
                ULONG   n;
                ULONGLONG x;
                //
                // Add length of the element to data left from the 
                // previous one.
                //
                x = xLength + pel->Length;

                //
                // Compute total number of packets pased on max packet
                // length.
                //
                n = tpInfo->RemainingPkts + (ULONG)(xLength/tpInfo->SendPacketLength);

                //
                // Compute the length of the last incomplete packet to
                // be combined with the next element.
                //
                xLength = (ULONG)(x%tpInfo->SendPacketLength);

                //
                // Compute the max size of the packet
                //
                if (x>tpInfo->SendPacketLength)
                    maxPacketSize = tpInfo->SendPacketLength; // This is absolute max.
                else if (maxPacketSize<xLength)
                    maxPacketSize = xLength;

                if (n>=tpInfo->RemainingPkts && n<MAXULONG) {
                    tpInfo->RemainingPkts = n;
                    if (pel->Flags & TP_EOP) {
                        if (xLength!=0 || pel->Length==0) {
                            tpInfo->RemainingPkts += 1;
                            xLength = 0;
                        }
                    }
                }
                else {
                    tpInfo->RemainingPkts = MAXULONG;
                }
            }
        }



    } except( AFD_EXCEPTION_FILTER (status) ) {
        ASSERT (NT_ERROR (status));

        goto complete;
    }

    //
    // Initialize flags and return max packet size.
    //
    AFD_GET_TPIC(Irp)->Flags = params.Flags;
    *MaxPacketSize = maxPacketSize;

complete:

    *TpInfo = tpInfo;
    return status;
}

#endif //_WIN64


VOID
AfdTPacketsWorker (
    PVOID   Context
    )
/*++

Routine Description:

    Transmit packet engine
    Scheduled as system work item or kernel APC
Arguments:

    Context - pointer to TransmitPackets info for the request

Return Value:

    None.

--*/

{
    PIRP                         TpIrp = Context;
    PAFD_TPACKETS_INFO_INTERNAL  tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    NTSTATUS      status;
    LONG          iteration = 0;
    
    PAGED_CODE ();

#if AFD_PERF_DBG
    tpInfo->WorkersExecuted += 1;
#endif
    UPDATE_TPACKETS2 (TpIrp, "Enter TPWorker, next element: 0x%lX", tpInfo->NextElement);
    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTPacketsWorker:"
                    " Entering for endpoint-%p,tp_info-%p,elem-%d\n",
                    IoGetCurrentIrpStackLocation (TpIrp)->FileObject->FsContext,
                    tpInfo,tpInfo->NextElement));
    }

    //
    // Continue while we have more elements to transmit or something to free
    //
    do {
        PAFD_BUFFER_HEADER  pd;

        //
        // Check if we need to release packet chain that was already sent.
        //
        if ((tpInfo->HeadMdl!=NULL) && (tpInfo->TailMdl==&tpInfo->HeadMdl)) {
            AfdCleanupPacketChain (TpIrp, TRUE);
        }

        //
        // Check if we are done.
        //
        if (tpInfo->NextElement>=tpInfo->ElementCount) {
            //
            // Handle special case of using TransmitFile to just disconnect
            // (and possibly reuse) the socket.
            //
            if (tpInfo->ElementCount==0) {
                PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(TpIrp);
                PAFD_ENDPOINT endpoint = irpSp->FileObject->FsContext;
                if (AFD_GET_TPIC(TpIrp)->Flags & AFD_TF_DISCONNECT) {
                    ASSERT (endpoint->Type==AfdBlockTypeVcConnecting);
                    ASSERT (endpoint->Common.VcConnecting.Connection!=NULL);

                    AfdPerformTpDisconnect (TpIrp);
                    status = STATUS_PENDING;

                }
                else {
                    //
                    // Well, no disconnect and nothing to transmit.
                    // Why were called at all?  We'll have to handle this anyway.
                    //
                    AFD_SET_TP_FLAGS (TpIrp, AFD_TP_SENDS_POSTED);
                    if (AFD_GET_TPIC(TpIrp)->Next!=NULL) {
                        AfdStartNextTPacketsIrp (endpoint, TpIrp);
                    }
                    status = STATUS_PENDING;
                }
            }
            else {
                status = STATUS_PENDING;
            }
            break;
        }

        //
        // Start building new chain
        //

        status = AfdBuildPacketChain (TpIrp, &pd);

        if (status==STATUS_SUCCESS) {
            USHORT    sendIrp;
            //
            // New chain is ready, find and IRP to send it
            //
            sendIrp = AfdTPacketsFindSendIrp (TpIrp);

            if (sendIrp!=tpInfo->NumSendIrps) {
                //
                // Found send IRP, perform send and continue.
                //
                status = AfdTPacketsSend (TpIrp, sendIrp);
            }
            else {
                //
                // Exit worker waiting for sends to complete.
                //
                status = STATUS_PENDING;
            }
        }
        else if (status==STATUS_PENDING) {
            //
            // Need to perform a read.
            // If read complete in-line, success is returned,
            // otherwise, we'll get STATUS_PENDING or error
            //
            if (AFD_USE_CACHE (pd->FileObject)) {
                status = AfdTPacketsMdlRead (TpIrp, pd);
            }
            else {
                status = AfdTPacketsBufferRead (TpIrp, pd);
            }
        }
        //
        // Continue while everything completes in-line with success
        // Limit number of iterations if we are at APC level.
        //
    }
    while (status==STATUS_SUCCESS && iteration++<tpInfo->NumSendIrps);

    if (NT_SUCCESS (status)) {
        if (status==STATUS_SUCCESS) {
            //
            // Exceeded number of iterations.
            // Reschedule the APC. Transfer the reference to the
            // worker.
            //
            ASSERT (iteration==tpInfo->NumSendIrps+1);
            ASSERT (AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_WORKER_SCHEDULED);
            UPDATE_TPACKETS2 (TpIrp, "Rescheduling tp worker, NextElement: 0x%lX",
                                        tpInfo->NextElement);
            AfdStartTPacketsWorker (AfdTPacketsWorker, TpIrp);
            return;
        }
        else {
            ASSERT (status==STATUS_PENDING);
        }
    }
    else {
        //
        // Something failed, abort.
        //
        AfdAbortTPackets (TpIrp, status);
    }

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTPacketsWorker:"
                    " Exiting for endpoint-%p,tp_info-%p,elem-%d\n",
                    IoGetCurrentIrpStackLocation (TpIrp)->FileObject->FsContext,
                    tpInfo,tpInfo->NextElement));
    }
    //
    // Remove the reference added when we scheduled the worker.
    //
    DEREFERENCE_TPACKETS (TpIrp);
}


NTSTATUS
AfdBuildPacketChain (
    PIRP                TpIrp,
    PAFD_BUFFER_HEADER  *Pd
    )
/*++

Routine Description:

    Builds MDL chain for a packet using packet descriptors.

Arguments:

    TpIrp - transmit packets IRP
Return Value:

    STATUS_SUCCESS - packet is fully built
    STATUS_PENDING - file read is required
    other - failure.
--*/
{
    NTSTATUS    status = STATUS_MORE_PROCESSING_REQUIRED;
    BOOLEAN     attached = FALSE;
    PAFD_TPACKETS_INFO_INTERNAL        tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    PAFD_ENDPOINT   endpoint = IoGetCurrentIrpStackLocation (TpIrp)->FileObject->FsContext;
    PAFD_TRANSMIT_PACKETS_ELEMENT   combinePel = NULL;
    ULONG                           combineLen = 0;

    //
    // Either we have something built or both MDL and PD are empty
    //
    ASSERT (tpInfo->PdLength>0 || 
                ((tpInfo->HeadMdl==NULL || tpInfo->HeadMdl->ByteCount==0)
                    && (tpInfo->HeadPd==NULL || tpInfo->HeadPd->DataLength==0)) );

    //
    // Continue while we haven't got a complet packet and
    // have elements to process
    //

    while (status == STATUS_MORE_PROCESSING_REQUIRED) {

        PAFD_TRANSMIT_PACKETS_ELEMENT pel;
        ULONG length;
        PMDL mdl;

        //
        // Get next element to process
        //
        pel = &tpInfo->ElementArray[tpInfo->NextElement];

        IF_DEBUG (TRANSMIT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdBuildPacketChain: tpInfo-%p, pel:%p\n",
                        tpInfo, pel));
        }
        //
        // Snag the element length
        //

        length = pel->Length;
        if (length+tpInfo->PdLength>tpInfo->SendPacketLength) {
            //
            // We hit packet length limit, take what we can
            //
            length = tpInfo->SendPacketLength-tpInfo->PdLength;
            //
            // Indicate that we are done
            //
            status = STATUS_SUCCESS;
            IF_DEBUG (TRANSMIT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdBuildPacketChain:"
                            " tpInfo-%p, exceeded send length(%ld)\n",
                            tpInfo, tpInfo->SendPacketLength));
            }
        }
        else {
            //
            // We are finished with the current element. We will consume it
            // (or fail), go to the next one 
            //
            tpInfo->NextElement += 1;

            //
            // Check for a complete packet or manual packetization flag set 
            // by the application or just end of element array
            //
            if ((length+tpInfo->PdLength==tpInfo->SendPacketLength) || 
                            (pel->Flags & TP_EOP) || 
                            (tpInfo->NextElement>=tpInfo->ElementCount)) {
                status = STATUS_SUCCESS;
                IF_DEBUG (TRANSMIT) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdBuildPacketChain:"
                                " tpInfo-%p, full length, EOP, or last %ld\n",
                                tpInfo, tpInfo->NextElement));
                }
            }
        }

        //
        // Adjust the remaining lenght of data in the current element
        // and the length of the packet that we are building.
        //
        pel->Length -= length;
        tpInfo->PdLength += length;

        if (length == 0) {

            //
            // Only add 0-length MDL if nothing else is in the chain.
            //

            if (tpInfo->TailMdl == &tpInfo->HeadMdl) {

                tpInfo->PdNeedsPps = TRUE;  // Don't have a buffer to get an IRP from.
                mdl = IoAllocateMdl (tpInfo, 1, FALSE, FALSE, NULL);
                if (mdl==NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }
                MmBuildMdlForNonPagedPool( mdl );
                mdl->ByteCount = 0;
                IF_DEBUG (TRANSMIT) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdBuildPacketChain:"
                                " tpInfo-%p, 0-length MDL %p\n",
                                tpInfo,mdl));
                }
            
                //
                // Insert MDL into the MDL chain
                //
            
                *(tpInfo->TailMdl) = mdl;
                tpInfo->TailMdl = &(mdl->Next);

            }

        } else {

            //
            // If the chain is not empty...
            //

            if (tpInfo->TailMdl != &tpInfo->HeadMdl) {

                //
                // Check to see if we should remove any 0-length MDL.
                // If one exists, it is guaranteed to be the last and only one
                // in the chain.
                //

                mdl = (PMDL)CONTAINING_RECORD(tpInfo->TailMdl, MDL, Next);

                if (mdl->ByteCount == 0) {

                    if (tpInfo->HeadMdl == mdl) {

                        IoFreeMdl(mdl);
                        mdl = NULL;

                        tpInfo->HeadMdl = NULL;
                        tpInfo->TailMdl = &tpInfo->HeadMdl;

                    } else {

                        PMDL tempMdl = tpInfo->HeadMdl;

                        while (tempMdl->Next != NULL) {

                            if (tempMdl->Next == mdl) {

                                IoFreeMdl(mdl);
                                mdl = NULL;
                                
                                tempMdl->Next = NULL;
                                tpInfo->TailMdl = &(tempMdl->Next);
                                
                                break;

                            }

                            tempMdl = tempMdl->Next;

                        }

                    }

                    ASSERT(mdl == NULL);

                }

            } // if (tpInfo->TailMdl != &tpInfo->HeadMdl)

            if (pel->Flags & TP_MEMORY) {

                //
                // Memory block processing
                //
                if (pel->Flags & TP_MDL) {
                    tpInfo->PdNeedsPps = TRUE;  // Need to make sure that process
                                                // memory is there until send completes.
                    //
                    // This a pre-built MDL (TransmitFile header or trailer buffer)
                    //
                    if (pel->Mdl->ByteCount==length) {
                        mdl = pel->Mdl;
                        pel->Mdl = NULL;
                        IF_DEBUG (TRANSMIT) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                        "AfdBuildPacketChain:"
                                        " tpInfo-%p, pre-built mdl-%p(%lx)\n",
                                        tpInfo, mdl, mdl->ByteCount));
                        }
                    }
                    else {
                        //
                        // We can't send the whole thing at once since it is
                        // bigger than the packet lenght, build partial MDL
                        // for this - it is very unlikely scenario for header
                        // and/or trailer.
                        //
                        mdl = IoAllocateMdl (pel->Buffer, 
                                                length,
                                                FALSE,
                                                FALSE,
                                                NULL);
                        if (mdl==NULL) {
                            status = STATUS_INSUFFICIENT_RESOURCES;
                            break;
                        }
                        IoBuildPartialMdl(
                            pel->Mdl,
                            mdl,
                            pel->Buffer,
                            length
                            );
                        IF_DEBUG (TRANSMIT) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                        "AfdBuildPacketChain:"
                                        " tpInfo-%p, partial mdl %p(%lx)\n",
                                        tpInfo,mdl,mdl->ByteCount));
                        }
                    }

                } else {

                    //
                    // If we are not in the context of the process that
                    // initiated the request, we will need to attach
                    // to it to be able to access the memory.
                    //
                    if (IoGetCurrentProcess ()!=IoGetRequestorProcess (TpIrp)) {
                        ASSERT (!attached);
                        ASSERT (!KeIsAttachedProcess ());
                        ASSERT (AFD_GET_TPIC(TpIrp)->Flags & AFD_TF_USE_SYSTEM_THREAD);

                        KeAttachProcess (
                                PsGetKernelProcess(
                                    IoGetRequestorProcess (TpIrp)));
                        IF_DEBUG (TRANSMIT) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                        "AfdBuildPacketChain:"
                                        " tp_info-%p,attached to %p\n",
                                        tpInfo,PsGetKernelProcess(
                                                    IoGetRequestorProcess (TpIrp))));
                        }
                        //
                        // Set the flag so that we know to detach at exit
                        //
                        attached = TRUE;
                    }
                    
                    if (length>AfdTPacketsCopyThreshold) {
                        tpInfo->PdNeedsPps = TRUE;  // Need to make sure that process
                                                    // memory is there until send completes.
                        //
                        // Memory block is larger than our large (page) 
                        // pre-allocated buffer.
                        // It is better to probe and lock it
                        // First allocate the MDL
                        //
                        mdl = IoAllocateMdl (pel->Buffer,
                                                length,
                                                FALSE, 
                                                TRUE,
                                                NULL);
                        if (mdl==NULL) {
                            status = STATUS_INSUFFICIENT_RESOURCES;
                            break;
                        }
                        IF_DEBUG (TRANSMIT) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                        "AfdBuildPacketChain:"
                                        " tp_info-%p,big mdl-%p(%p,%lx)\n",
                                        tpInfo,mdl,pel->Buffer,length));
                        }


                        //
                        // Probe and lock app's memory
                        //
                        try {
                            MmProbeAndLockPages (mdl,
                                                TpIrp->RequestorMode,
                                                IoReadAccess
                                                );
                        }
                        except (AFD_EXCEPTION_FILTER (status)) {
                            ASSERT (NT_ERROR (status));
                            break;
                       }
                    }
                    else if (pel->Flags & TP_COMBINE) {
                        //
                        // This memory can be combined with the
                        // next piece in one buffer.
                        //
                        if (combinePel==NULL) {
                            combinePel = pel;
                            combineLen = length;
                        }
                        else {
                            combineLen += length;
                            ASSERT (combineLen<=AfdTPacketsCopyThreshold);
                        }
                        ASSERT (pel->Length==0);
                        pel->Length = length;
                        IF_DEBUG (TRANSMIT) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                        "AfdBuildPacketChain:"
                                        " tp_info-%p,small buffer (%x) to be combined with next\n",
                                        tpInfo,length));
                        }
                        continue;
                    }
                    else {
                        //
                        // 'Small' memory block, better to copy
                        // into pre-allocated (lookaside list) buffer.
                        //
                        PAFD_BUFFER afdBuffer = NULL;
                        PUCHAR  buf;
                        ULONG   bufferLen = length + (combinePel ? combineLen : 0);

                        try {
                            afdBuffer = AfdGetBufferRaiseOnFailure (
                                                        endpoint,
                                                        bufferLen, 
                                                        0,
                                                        endpoint->OwningProcess);
                            buf = afdBuffer->Buffer;
                            if (combinePel!=NULL) {
                                //
                                // See if wee need to combine previous elements
                                //
                                ASSERT (combineLen+length<=AfdTPacketsCopyThreshold);
                                ASSERT (combineLen>0);
                                while (combinePel!=pel) {
                                    if ( TpIrp->RequestorMode != KernelMode ) {
                                        //
                                        // Probe before copying
                                        //
                                        ProbeForRead (combinePel->Buffer, 
                                                        combinePel->Length,
                                                        sizeof (UCHAR));
                                    }
                                    RtlCopyMemory (buf, combinePel->Buffer, combinePel->Length);
                                    buf += combinePel->Length;
#if DBG
                                    ASSERT (combineLen >= combinePel->Length);
                                    combineLen -= combinePel->Length;
#endif
                                    combinePel++;
                                }

                                //
                                // Reset the local.
                                //
                                ASSERT (combineLen==0);
                                combinePel = NULL;
                            }

                            if ( TpIrp->RequestorMode != KernelMode ) {
                                //
                                // Probe before copying
                                //
                                ProbeForRead (pel->Buffer, 
                                                length,
                                                sizeof (UCHAR));
                            }
                            RtlCopyMemory (buf, pel->Buffer, length);
                        }
                        except (AFD_EXCEPTION_FILTER (status)) {
                            ASSERT (NT_ERROR (status));
                            if (afdBuffer!=NULL) {
                                AfdReturnBuffer (&afdBuffer->Header, 
                                                endpoint->OwningProcess);
                            }
                            break;
                        }

                        //
                        // Initialize the buffer structure so that we do not
                        // mistake it for file buffer descriptor and insert
                        // it into the packet chain
                        //
                        afdBuffer->FileObject = NULL;
                        afdBuffer->Next = NULL;
                        (*tpInfo->TailPd) = &afdBuffer->Header;
                        tpInfo->TailPd = &(afdBuffer->Next);

                        mdl = afdBuffer->Mdl;
                        //
                        // Adjust MDL length to the amount of data that we
                        // actualy sending from the buffer.
                        //
                        mdl->ByteCount = bufferLen;

                        IF_DEBUG (TRANSMIT) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                        "AfdBuildPacketChain:"
                                        " tp_info-%p,small buffer-%p(%p,%lx)\n",
                                        tpInfo,(PVOID)afdBuffer,mdl,length));
                        }
                    }
                }
                //
                // Insert MDL into the MDL chain
                //
                *(tpInfo->TailMdl) = mdl;
                tpInfo->TailMdl = &(mdl->Next);

                //
                // Advance app's buffer pointer
                //
                pel->Buffer = ((PUCHAR)pel->Buffer) + length;

            } else { // if (pel->Flags & TP_MEMORY)

                //
                // This must be a file block
                //
                ASSERT ((pel->Flags & TP_FILE)!=0);
                ASSERT (length!=0);

                if (AFD_USE_CACHE(pel->FileObject)) {

                    //
                    // Caching file system, get it from cache.
                    // We just need a buffer tag to save buffer info
                    // so we can return it back to the cache when we
                    // are done sending.
                    //
                    IO_STATUS_BLOCK ioStatus;
                    PAFD_BUFFER_TAG afdBufferTag;

                    tpInfo->PdNeedsPps = TRUE;  // Need to free the MDL back to file
                                                // system at passive/APC level

                    try {
                        afdBufferTag = AfdGetBufferTagRaiseOnFailure (
                                            0,
                                            endpoint->OwningProcess);
                    }
                    except (AFD_EXCEPTION_FILTER (status)) {
                        ASSERT (NT_ERROR (status));
                        break;
                    }

                    //
                    // Copy file parameters to the packet descriptor.
                    //
                    afdBufferTag->FileOffset = pel->FileOffset;
                    afdBufferTag->FileObject = pel->FileObject;
                    pel->FileOffset.QuadPart += length;
                    afdBufferTag->DataLength = length;

                    //
                    // Set fileMdl to NULL because FsRtlMdlRead attempts to
                    // chain the MDLs it returns off the input MDL variable.
                    //
                    afdBufferTag->Mdl = NULL;

                    //
                    // Attempt to use the fast path to get file data MDLs
                    // directly from the cache.
                    //
                    if (FsRtlMdlRead(
                                  afdBufferTag->FileObject,
                                  &afdBufferTag->FileOffset,
                                  length,
                                  0,
                                  &afdBufferTag->Mdl,
                                  &ioStatus
                                  )) {
                        if ( ioStatus.Information < length) {
                            //
                            // Could not read the whole thing, must be end of file
                            //
                            status = AfdMdlReadComplete (
                                                        afdBufferTag->FileObject,
                                                        afdBufferTag->Mdl,
                                                        &afdBufferTag->FileOffset);
                            if (NT_SUCCESS (status)) {
                                AfdReturnBuffer (&afdBufferTag->Header, 
                                                    endpoint->OwningProcess);
                            }
                            else {
                                REFERENCE_ENDPOINT (endpoint);
                                afdBufferTag->Context = endpoint;
                                AfdLRMdlReadComplete (&afdBufferTag->Header);
                            }
                            status = STATUS_END_OF_FILE;
                            break;
                        }

                        IF_DEBUG (TRANSMIT) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                        "AfdBuildPacketChain:"
                                        " tp_info-%p,file tag-%p(%p,%lx:%I64x)\n",
                                        tpInfo,afdBufferTag,afdBufferTag->Mdl,length,
                                        pel->FileOffset.QuadPart));
                        }
                        //
                        // Insert the file MDL into the chain
                        //
                        mdl = *(tpInfo->TailMdl) = afdBufferTag->Mdl;
                        while (mdl->Next!=NULL)
                            mdl = mdl->Next;
                        tpInfo->TailMdl = &mdl->Next;

                        //
                        // Insert buffer tag into the chain too.
                        //
                        afdBufferTag->Next = NULL;
                        (*tpInfo->TailPd) = &afdBufferTag->Header;
                        tpInfo->TailPd = &(afdBufferTag->Next);
                    }
                    else {
                        //
                        // File is not in the cache, return STATUS_PENDING
                        // so that the Tpacket worker knows to
                        // perform MDL read via IRP interface
                        //
                        if (status==STATUS_SUCCESS) {
                            afdBufferTag->PartialMessage = FALSE;
                        }
                        else {
                            ASSERT (status==STATUS_MORE_PROCESSING_REQUIRED);
                            afdBufferTag->PartialMessage = TRUE;
                        }
                        afdBufferTag->Next = NULL;
                        *Pd = &afdBufferTag->Header;
                        status = STATUS_PENDING;
                        break;
                    }

                } else { // if (AFD_USE_CACHE(pel->FileObject))

                    PAFD_BUFFER afdBuffer;

                    //
                    // Non-cacheable file system, need buffered read.
                    // Get the buffer first.
                    //

                    try {
                        afdBuffer = AfdGetBufferRaiseOnFailure (
                                                endpoint,
                                                length, 
                                                0,
                                                endpoint->OwningProcess);
                    }
                    except (AFD_EXCEPTION_FILTER (status)) {
                        ASSERT (NT_ERROR (status));
                        break;
                    }

                    //
                    // Copy file parameters to the packet descriptor.
                    // and return STATUS_PENDING, so that Tpacket worker knows 
                    // to issue an IRP for buffered read.
                    //
                    IF_DEBUG (TRANSMIT) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                    "AfdBuildPacketChain:"
                                    " tp_info-%p,file buffer-%p(%p,%lx:%I64x)\n",
                                    tpInfo,(PVOID)afdBuffer,afdBuffer->Mdl,length,
                                    pel->FileOffset.QuadPart));
                    }
                    afdBuffer->FileOffset = pel->FileOffset;
                    afdBuffer->FileObject = pel->FileObject;
                    pel->FileOffset.QuadPart += length;
                    afdBuffer->DataLength = length;
                    afdBuffer->Mdl->ByteCount = length;
                    afdBuffer->Next = NULL;
                    if (status==STATUS_SUCCESS) {
                        afdBuffer->PartialMessage = FALSE;
                    }
                    else {
                        ASSERT (status==STATUS_MORE_PROCESSING_REQUIRED);
                        afdBuffer->PartialMessage = TRUE;
                    }
                    *Pd = &afdBuffer->Header;
                    status = STATUS_PENDING;
                    break;

                } // if (AFD_USE_CACHE(pel->FileObject))

            } // if (pel->Flags & TP_MEMORY)

        } // if (length == 0)

    } // while (status == STATUS_MORE_PROCESSING_REQUIRED)

    if (attached) {
        //
        // If we attached to the calling, detach before exiting.
        //
        ASSERT (KeIsAttachedProcess ());
        ASSERT (AFD_GET_TPIC(TpIrp)->Flags & AFD_TF_USE_SYSTEM_THREAD);
        KeDetachProcess ();
        IF_DEBUG (TRANSMIT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdBuildPacketChain:"
                        " tp_info-%p, detached\n",
                        tpInfo));
        }
    }

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdBuildPacketChain: tp_info-%p,returning %lx\n",
                    tpInfo, status));
    }

    ASSERT (combinePel==NULL || !NT_SUCCESS (status));

    return status;
}

BOOLEAN
AfdCleanupPacketChain (
    PIRP    TpIrp,
    BOOLEAN BelowDispatch
    )
/*++

Routine Description:

    Cleans up (releases all resources in) the packet chain.

Arguments:

    TpIrp - transmit packet IRP
    BelowDispatch  - call is made below DISPATCH_LEVEL, can return MDL to file system

Return Value:

    TRUE - all packets/MDLs are freed
    FALSE - could not return MDLs to file system (when called at DISPATCH)
--*/
{

    PAFD_TPACKETS_INFO_INTERNAL tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    PAFD_BUFFER_HEADER  pd = tpInfo->HeadPd;
    PAFD_ENDPOINT endpoint = IoGetCurrentIrpStackLocation (TpIrp)->FileObject->FsContext;

    ASSERT (tpInfo->HeadMdl!=NULL);

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdCleanupPacketChain: tp_info-%p,mdl-%p,pd-%p\n",
                    tpInfo,tpInfo->HeadMdl,tpInfo->HeadPd));
    }
    //
    // Continue while we have any MDL's left
    //
    while (tpInfo->HeadMdl) {
        //
        // Advance to the next MDL
        //
        PMDL mdl;

        mdl = tpInfo->HeadMdl;
        tpInfo->HeadMdl = mdl->Next;

        if (pd!=NULL) {
            //
            // We still have descriptors in the chain to compare against.
            //

            if (mdl==pd->Mdl) {
                //
                // This MDL has associated descriptor - file or buffered memory
                // First remove this descriptor from the chain.
                //
                tpInfo->HeadPd = pd->Next;
                if (pd->FileObject!=NULL && AFD_USE_CACHE (pd->FileObject)) {

                    if (BelowDispatch) {
                        //
                        // Cached file, the descriptor is just a tag with info
                        // to return MDL to the cache, do it.
                        //
                        PAFD_BUFFER_TAG afdBufferTag = CONTAINING_RECORD (pd, AFD_BUFFER_TAG, Header);
                        ULONG   size = MmGetMdlByteCount (mdl);
                        PMDL    lastMdl = mdl;
                        NTSTATUS status;
                        //
                        // Scan MDL chain till we find the last one for this file
                        // segment.
                        //
                        IF_DEBUG (TRANSMIT) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                        "AfdCleanupPacketChain:"
                                        " tp_info-%p,file tag-%p(%p,%lx:%I64x)\n",
                                        tpInfo,afdBufferTag,mdl,afdBufferTag->DataLength,
                                        afdBufferTag->FileOffset.QuadPart));
                        }
                        while (size<pd->DataLength) {
                            size += MmGetMdlByteCount (tpInfo->HeadMdl);
                            lastMdl = tpInfo->HeadMdl;
                            tpInfo->HeadMdl = tpInfo->HeadMdl->Next;
                        }
                        lastMdl->Next = NULL;
                        ASSERT (size==pd->DataLength);
                        //
                        // Return the MDL chain to file cache
                        //
                        status = AfdMdlReadComplete (
                                        afdBufferTag->FileObject, 
                                        mdl, 
                                        &afdBufferTag->FileOffset);
                        if (NT_SUCCESS (status)) {
                            //
                            // Success free the corresponding buffer tag
                            //
                            AfdReturnBuffer (pd, endpoint->OwningProcess);
                        }
                        else {
                            //
                            // Failure, queue the descriptor to the low resource
                            // list to be processed by our global timer when
                            // (hopefully) enough memory will be available to do
                            // the work.
                            // We need to reference the endpoint since buffer tag
                            // may have been charged against the process that owns
                            // the endpoint.
                            //
                            REFERENCE_ENDPOINT (endpoint);
                            afdBufferTag->Context = endpoint;
                            AfdLRMdlReadComplete (&afdBufferTag->Header);
                        }
                    }
                    else {
                        //
                        // If we are at dispatch, we can't free MDLs to file
                        // system, return to the caller.
                        //

                        tpInfo->HeadPd = pd;
                        tpInfo->HeadMdl = mdl;

                        return FALSE;
                    }
                }
                else {
                    //
                    // Buffer with either file or memory data, just return
                    // it back to the pool.
                    //
                    PAFD_BUFFER afdBuffer = CONTAINING_RECORD (pd, AFD_BUFFER, Header);

                    IF_DEBUG (TRANSMIT) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                    "AfdCleanupPacketChain:"
                                    " tp_info-%p,file buffer-%p(%p,%lx:%I64x)\n",
                                    tpInfo,(PVOID)afdBuffer,mdl,afdBuffer->DataLength,
                                    afdBuffer->FileOffset.QuadPart));
                    }
                    afdBuffer->Mdl->Next = NULL;
                    afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;
                    AfdReturnBuffer (pd, endpoint->OwningProcess);
                }

                //
                // Move to the next descriptor in the chain.
                //
                pd = tpInfo->HeadPd;
                continue;
            }
        }

        //
        // Stand-alone MDL with memory data
        // Just unlock the pages if they were locked and return it.
        // We never lock memory in partial MDLs, only in their source MDL
        //
        IF_DEBUG (TRANSMIT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdCleanupPacketChain: tp_info-%p, mdl-%p(%p,%x,%x)\n",
                        tpInfo,mdl,
                        MmGetMdlVirtualAddress(mdl),
                        MmGetMdlByteCount (mdl),
                        mdl->MdlFlags));
        }
        mdl->Next = NULL;
        if (mdl->MdlFlags & MDL_SOURCE_IS_NONPAGED_POOL) {
            ASSERT (mdl->MappedSystemVa==(PVOID)tpInfo);
            ASSERT (mdl->ByteCount==0);
            mdl->ByteCount = 1;
        }
        else if (mdl->MdlFlags & MDL_PAGES_LOCKED &&
                !(mdl->MdlFlags & MDL_PARTIAL)) {
            MmUnlockPages (mdl);
        }
        IoFreeMdl (mdl);
    }

    ASSERT (tpInfo->TailMdl == &tpInfo->HeadMdl);
    ASSERT (tpInfo->HeadPd == NULL);
    ASSERT (tpInfo->TailPd == &tpInfo->HeadPd);

    return TRUE;
}



NTSTATUS
AfdTPacketsSend (
    PIRP    TpIrp,
    USHORT  SendIrp
    )
/*++

Routine Description:

    Takes the packets chain of the TpInfo and sends it.
    Places back the chain sent before, so it can be freed.
    If requested by the app and the last element is being sent,
    initiates the disconnect.

Arguments:

    TpIrp - transmit packet irp
    SendIrp - index of the IRP to use for this send.

Return Value:

    STATUS_SUCCESS - send was queued to the transport OK
    other - send failed
--*/
{
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation (TpIrp);
    PMDL                    tempMdl=NULL;
    PAFD_BUFFER_HEADER      tempPd=NULL;
    NTSTATUS                status = STATUS_SUCCESS;
    PIRP                    irp, sendIrp=NULL;
    PIO_COMPLETION_ROUTINE  sendCompletion = AfdRestartTPacketsSend; 

    ASSERT (AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_WORKER_SCHEDULED);

    irp = tpInfo->SendIrp[SendIrp];

    //
    // See if we can use IRP built into the AFD buffer.
    // We do this for last series of the packets only so 
    // we can effectively buffer the data and complete the
    // IRP early.
    //

    if (tpInfo->RemainingPkts!=MAXULONG) {
        tpInfo->RemainingPkts -= 1;

        //
        // The conditions are:
        //  - number of remaining packets is less then total 
        //      outstanding IRPs we can have
        //  - the packet does not need post-processing at below
        //      DPC level and/or in context of the thread/process
        //  - we actually have afd buffer to borrow the IRP.
        //

        if (tpInfo->RemainingPkts < (ULONG)tpInfo->NumSendIrps &&
                !tpInfo->PdNeedsPps &&
                tpInfo->HeadPd!=NULL) {
            
            PAFD_BUFFER afdBuffer = CONTAINING_RECORD (tpInfo->HeadPd,
                                                        AFD_BUFFER,
                                                        Header);
            PAFD_ENDPOINT endpoint = irpSp->FileObject->FsContext;

            ASSERT (afdBuffer->BufferLength!=0);
            ASSERT (afdBuffer->Irp!=NULL);
            sendIrp = afdBuffer->Irp;
            
            REFERENCE_ENDPOINT(endpoint);
            afdBuffer->Context = endpoint;

            sendCompletion = AfdRestartTPDetachedSend;

            //
            // There will be no completion flag reset - we do not have
            // to wait for this one.
            //

            AFD_CLEAR_TP_FLAGS (TpIrp, AFD_TP_SEND_COMP_PENDING(SendIrp));

        }

    }

    if (irp!=NULL) {
        //
        // Get the old data from the IRP.
        //
        ASSERT (irp->Overlay.AsynchronousParameters.UserApcRoutine==(PVOID)(ULONG_PTR)SendIrp);
        tempPd = irp->Overlay.AsynchronousParameters.UserApcContext;
        tempMdl = irp->MdlAddress;
        if (sendIrp==NULL) {
            //
            // No special send IRP, the data will be reset with
            // data to be sent
            //
            sendIrp = irp;
        }
        else {
            //
            // We are not going to use this IRP, reset data to NULL.
            //
            irp->Overlay.AsynchronousParameters.UserApcContext = NULL;
            irp->MdlAddress = NULL;
        }
    }
    else if (sendIrp==NULL) {
        //
        // We need to allocate an IRP.
        //
        ASSERT (SendIrp>=AFD_TP_MIN_SEND_IRPS);
        tpInfo->SendIrp[SendIrp] = IoAllocateIrp (tpInfo->TdiDeviceObject->StackSize, TRUE);
        if (tpInfo->SendIrp[SendIrp]==NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            AfdAbortTPackets (TpIrp, status);
            return status;
        }
        sendIrp = irp = tpInfo->SendIrp[SendIrp];
        irp->Overlay.AsynchronousParameters.UserApcRoutine=(PIO_APC_ROUTINE)(ULONG_PTR)SendIrp;
    }

    //
    // Exchange the packet and MDL chains between send IRP and
    // the tpInfo structure
    //
    sendIrp->Overlay.AsynchronousParameters.UserApcContext = tpInfo->HeadPd;

    tpInfo->HeadPd = tempPd;
    tpInfo->TailPd = &tpInfo->HeadPd;


    //
    // Build send IRP.  Used combined send and disconnect if necessary
    // and possible.
    //
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
    if ((AFD_GET_TPIC(TpIrp)->Flags & AFD_TF_DISCONNECT) &&
            (tpInfo->PdLength>0) && // Must be sending something or no S&D
            (tpInfo->NextElement>=tpInfo->ElementCount) &&
            AfdTPacketsEnableSendAndDisconnect (TpIrp)) {
        AFD_SET_TP_FLAGS (TpIrp, AFD_TP_SEND_AND_DISCONNECT);
        TdiBuildSend (sendIrp,
                tpInfo->TdiDeviceObject,
                tpInfo->TdiFileObject,
                sendCompletion,
                TpIrp,
                tpInfo->HeadMdl,
                TDI_SEND_AND_DISCONNECT,
                tpInfo->PdLength
                );
    }
    else {
        TdiBuildSend (sendIrp,
                tpInfo->TdiDeviceObject,
                tpInfo->TdiFileObject,
                sendCompletion,
                TpIrp,
                tpInfo->HeadMdl,
                0,
                tpInfo->PdLength
                );
    }

#else //TDI_SERVICE_SEND_AND_DISCONNECT

    TdiBuildSend (sendIrp,
            tpInfo->TdiDeviceObject,
            tpInfo->TdiFileObject,
            sendCompletion,
            TpIrp,
            tpInfo->HeadMdl,
            0,
            tpInfo->PdLength
            );
#endif //TDI_SERVICE_SEND_AND_DISCONNECT


    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTPacketsSend: tpInfo-%p, sending Irp: %p\n",
                    tpInfo, irp));
    }
    if (sendCompletion==AfdRestartTPacketsSend) {
        //
        // Reference the tpInfo structure so it does not go away
        // till send IRP completes and pass the IRP to the transport.
        //
        REFERENCE_TPACKETS (TpIrp);

        IoCallDriver (tpInfo->TdiDeviceObject, sendIrp);
    }
    else {
        //
        // No need to reference as we are not going to wait for
        // completion.
        //
        status = IoCallDriver (tpInfo->TdiDeviceObject, sendIrp);
        if (NT_SUCCESS (status)) {
            //
            // Change STATUS_PENDING to success not to confuse the caller
            // and add byte count under assumption of success (if it fails
            // later, connection will be dropped and we don't guarantee
            // anything for datagrams anyway).
            //
            status = STATUS_SUCCESS;
#ifdef _WIN64
            InterlockedExchangeAdd64 (
                                (PLONG64)&TpIrp->IoStatus.Information,
                                tpInfo->PdLength
                                );
#else //_WIN64
            InterlockedExchangeAdd (
                                (PLONG)&TpIrp->IoStatus.Information,
                                tpInfo->PdLength);
#endif //_WIN64
        }
        else {
            //
            // If send fails, we'll have to abort here since completion routine
            // will not have access to the TpIrp
            //
            IF_DEBUG (TRANSMIT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdTPacketsSend: tpInfo-%p, detached send failed: %lx\n",
                            tpInfo, status));
            }
            AfdAbortTPackets (TpIrp, status);
        }
    }


    //
    // Setup the chain in the tpInfo so it can be freed.
    //
    tpInfo->HeadMdl = tempMdl;
    tpInfo->TailMdl = &tpInfo->HeadMdl;
    tpInfo->PdLength = 0;
    tpInfo->PdNeedsPps = FALSE;

    if (tpInfo->NextElement>=tpInfo->ElementCount) {
        PAFD_ENDPOINT   endpoint = irpSp->FileObject->FsContext;
        if (!(AFD_GET_TPIC(TpIrp)->Flags & AFD_TF_DISCONNECT)) {
            AFD_SET_TP_FLAGS (TpIrp, AFD_TP_SENDS_POSTED);
            if (AFD_GET_TPIC (TpIrp)->Next!=NULL) {
                AfdStartNextTPacketsIrp (endpoint, TpIrp);
            }
        }
        else 
            //
            // If necessary and not using combined S&D,
            // sumbit disconnect IRP to the transport
            //
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
            if (!(AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_SEND_AND_DISCONNECT))
#endif // TDI_SERVICE_SEND_AND_DISCONNECT
        {
            ASSERT (endpoint->Type==AfdBlockTypeVcConnecting);
            ASSERT (endpoint->Common.VcConnecting.Connection!=NULL);
            AfdPerformTpDisconnect (TpIrp);
        }
    }

    //
    // Set the flag indicating to the completion routine that we are done
    //
    AFD_CLEAR_TP_FLAGS (TpIrp, AFD_TP_SEND_CALL_PENDING(SendIrp));
    UPDATE_TPACKETS2 (TpIrp, "Submitted SendIrp: 0x%lX", SendIrp);

    return status;
}


NTSTATUS
AfdRestartTPacketsSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Completion routine for TPackets send.
    Does another send if packet is ready or schedules worker
    to do the same.
Arguments:
    DeviceObject - AfdDeviceObject
    Irp          - send IRP being completed
    Context      - TpIrp

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - tell IO subsystem to stop
        processing the IRP (it is handled internally).
--*/
{
    PIRP    tpIrp;
    PAFD_TPACKETS_INFO_INTERNAL  tpInfo;
    PAFD_ENDPOINT   endpoint;
    USHORT          sendIrp;

    UNREFERENCED_PARAMETER (DeviceObject);

    tpIrp = Context;
    tpInfo = tpIrp->AssociatedIrp.SystemBuffer;
    endpoint = IoGetCurrentIrpStackLocation (tpIrp)->FileObject->FsContext;

    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Figure out which IRP is being completed.
    //
    sendIrp = (USHORT)(ULONG_PTR)Irp->Overlay.AsynchronousParameters.UserApcRoutine;
    ASSERT (tpInfo->SendIrp[sendIrp]==Irp);

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdRestartTPacketsSend: tp_info-%p,Irp-%p,status-%lx\n",
                tpInfo,
                Irp,
                Irp->IoStatus.Status
                ));
    }

    if (NT_SUCCESS (Irp->IoStatus.Status)) {
        LONG    stateFlags, newStateFlags;
        BOOLEAN needWorker;

        UPDATE_TPACKETS2 (tpIrp, "Send completed with 0x%lX bytes", 
                                    (ULONG)Irp->IoStatus.Information);
        //
        // Successfull completion, update transfer count.
        // We don't hold the spinlock, so we need to use interlocked operation.
        // Wish we have a common one for both 64 and 32 bit platforms.
        //
#ifdef _WIN64
        InterlockedExchangeAdd64 ((PLONG64)&tpIrp->IoStatus.Information,
                                    Irp->IoStatus.Information);
#else //_WIN64
        InterlockedExchangeAdd ((PLONG)&tpIrp->IoStatus.Information,
                                    Irp->IoStatus.Information);
#endif //_WIN64

        do {
            ULONG   sendMask;
            newStateFlags = stateFlags = AFD_GET_TPIC(tpIrp)->StateFlags;
            //
            // See if dispatch routine has not completed yet or
            // the request is aborted or worker is aready running
            // Or if two consequtive requests are in dispatch routines.
            //
            if (    (newStateFlags & (AFD_TP_ABORT_PENDING | 
                                      AFD_TP_WORKER_SCHEDULED |
                                      AFD_TP_SEND_CALL_PENDING(sendIrp))) ||
                    ((sendMask = (newStateFlags & AFD_TP_SEND_MASK)) &
                                     ( (sendMask>>2) |
                                       (sendMask<<(AFD_TP_MAX_SEND_IRPS*2-2)) ) )
                                       ) {

                //
                // Can't continue, just clear completion flag
                //
                newStateFlags &= ~AFD_TP_SEND_COMP_PENDING(sendIrp);
                needWorker = FALSE;
            }
            else {
                //
                // Take control over worker scheduling and
                // mark IRP as busy.
                // 
                needWorker = TRUE;
                newStateFlags |= AFD_TP_WORKER_SCHEDULED;
                if (tpInfo->HeadMdl!=NULL) {
                    newStateFlags |= AFD_TP_SEND_CALL_PENDING(sendIrp);
                }
                else {
                    newStateFlags &= ~AFD_TP_SEND_COMP_PENDING(sendIrp);
                }
            }

        }
        while (InterlockedCompareExchange (
                        (PLONG)&AFD_GET_TPIC(tpIrp)->StateFlags,
                        newStateFlags,
                        stateFlags)!=stateFlags);
        if (needWorker) {
            //
            // We can do processing here, see if there is something to send
            //
            if (tpInfo->HeadMdl) {
                //
                // Yes, do it
                //
                AfdTPacketsSend (tpIrp, sendIrp);
            }
            //
            // Start worker to prepare new stuff/free what we sent before.
            // We transfer the reference we added when we queued the request
            // to the worker.
            //
            AfdStartTPacketsWorker (AfdTPacketsWorker, tpIrp);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        else {
            //
            // Worker was already running or request aborted or dispatch
            // routine not completed yet.
            //
        }
    }
    else {
        //
        // Failure, abort the request even if dispatch did not complete.
        // We do not know if dispatch routine is going to return error status,
        // it may just return STATUS_PENDING and we then loose the error code.
        // Double abort is harmless.
        //
        AFD_CLEAR_TP_FLAGS (tpIrp, AFD_TP_SEND_COMP_PENDING(sendIrp));
        AfdAbortTPackets (tpIrp, Irp->IoStatus.Status);
    }

    //
    // Remove the reference we added when we queued the request.
    //
    DEREFERENCE_TPACKETS (tpIrp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
AfdRestartTPDetachedSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Completion routine for detached TPackets send.
    Just frees the buffers.

Arguments:
    DeviceObject - AfdDeviceObject
    Irp          - send IRP being completed
    Context      - Ignore (TpIrp is stored for debugging purposes only).

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - tell IO subsystem to stop
        processing the IRP (it is handled internally).
--*/
{
    PAFD_BUFFER     afdBuffer = Irp->Overlay.AsynchronousParameters.UserApcContext;
    PAFD_ENDPOINT   endpoint = afdBuffer->Context;

    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (Context);

    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdRestartTPDetachedSend: Irp-%p,status-%lx\n",
                Irp,
                Irp->IoStatus.Status
                ));
    }

    do {
        PAFD_BUFFER tempBuffer = afdBuffer;
        afdBuffer = CONTAINING_RECORD (afdBuffer->Next, AFD_BUFFER, Header);
        tempBuffer->Next = NULL;
        tempBuffer->Mdl->Next = NULL;
        tempBuffer->Mdl->ByteCount = tempBuffer->BufferLength;
        AfdReturnBuffer (&tempBuffer->Header, endpoint->OwningProcess);
    }
    while (afdBuffer!=NULL);
    
    DEREFERENCE_ENDPOINT(endpoint);
    return STATUS_MORE_PROCESSING_REQUIRED;

}


USHORT
AfdTPacketsFindSendIrp (
    PIRP            TpIrp
    )
/*++

Routine Description:
    Finds the send IRP that is not currently in use and marks
    it as busy
Arguments:
    TpIrp      - Transmit packets Irp

Return Value:
    0-based index of send irp or TpInfo->NumSendIrps if all IRPs are i use
--*/
{

    LONG    stateFlags, newStateFlags;
    USHORT    sendIrp;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = TpIrp->AssociatedIrp.SystemBuffer;

    ASSERT( AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_WORKER_SCHEDULED );

    do {
        newStateFlags = stateFlags = AFD_GET_TPIC(TpIrp)->StateFlags;
        if (newStateFlags & AFD_TP_ABORT_PENDING) {
            //
            // Abort is in progress, bail
            //
            sendIrp = tpInfo->NumSendIrps;
            break;
        }

        //
        // See if any send IRP is not in use
        //
        for (sendIrp=0; sendIrp<tpInfo->NumSendIrps; sendIrp++) {
            if ((newStateFlags & AFD_TP_SEND_BUSY(sendIrp))==0) {
                break;
            }
        }

        if (sendIrp!=tpInfo->NumSendIrps) {
            //
            // Found send IRP, mark it as busy
            //
            newStateFlags |= AFD_TP_SEND_BUSY(sendIrp);
        }
        else {
            //
            // No send IRPs, suspend the worker.
            //
            newStateFlags &= (~AFD_TP_WORKER_SCHEDULED);
        }
    }
    while (InterlockedCompareExchange (
                    (PLONG)&AFD_GET_TPIC(TpIrp)->StateFlags,
                    newStateFlags,
                    stateFlags)!=stateFlags);

    return sendIrp;
}


NTSTATUS
AfdTPacketsMdlRead (
    PIRP                TpIrp,
    PAFD_BUFFER_HEADER  Pd
    )
/*++

Routine Description:

    Performs IRP based MDL read (invoked when cache read fails).

Arguments:

    TpIrp  - transmit packet irp
    Pd     - descriptor with file parameters for the read

Return Value:

    STATUS_SUCCESS - read was completed in-line
    STATUS_PENDING - read was queued to file system driver, 
                    will complete lated
    other - read failed
--*/
{
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    PDEVICE_OBJECT          deviceObject;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpSp;

    ASSERT( AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_WORKER_SCHEDULED );

    //
    // Find the device object and allocate IRP of appropriate size
    // if current one does not fit or is not available at all.
    //
    deviceObject = IoGetRelatedDeviceObject (Pd->FileObject);
    if ((tpInfo->ReadIrp==NULL) ||
            (tpInfo->ReadIrp->StackCount<deviceObject->StackSize)) {
        if (tpInfo->ReadIrp!=NULL) {
            IoFreeIrp (tpInfo->ReadIrp);
        }

        tpInfo->ReadIrp = IoAllocateIrp (deviceObject->StackSize, FALSE);
        if (tpInfo->ReadIrp==NULL) {
            PAFD_ENDPOINT   endpoint;
            endpoint = IoGetCurrentIrpStackLocation (TpIrp)->FileObject->FsContext;
            ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
            AfdReturnBuffer (Pd, endpoint->OwningProcess);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Mark IRP as busy and set it up
    //
    AFD_SET_TP_FLAGS (TpIrp, AFD_TP_READ_BUSY);

    irp = tpInfo->ReadIrp;


    irp->MdlAddress = NULL;

    //
    // Set the synchronous flag in the IRP to tell the file system
    // that we are aware of the fact that this IRP will be completed
    // synchronously.  This means that we must supply our own thread
    // for the operation and that the disk read will occur
    // synchronously in this thread if the data is not cached.
    //

    irp->Flags |= IRP_SYNCHRONOUS_API;


    irp->Overlay.AsynchronousParameters.UserApcContext = Pd;
    //
    // Set current thread for IoSetHardErrorOrVerifyDevice.
    //
    irp->Tail.Overlay.Thread = PsGetCurrentThread ();

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->MinorFunction = IRP_MN_MDL;
    irpSp->FileObject = Pd->FileObject;
    irpSp->DeviceObject = deviceObject;

    IoSetCompletionRoutine(
        irp,
        AfdRestartTPacketsMdlRead,
        TpIrp,
        TRUE,
        TRUE,
        TRUE
        );

    ASSERT( irpSp->Parameters.Read.Key == 0 );

    //
    // Finish building the read IRP.
    //

    irpSp->Parameters.Read.Length = Pd->DataLength;
    irpSp->Parameters.Read.ByteOffset = Pd->FileOffset;
    
    REFERENCE_TPACKETS (TpIrp);
    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdTPacketsMdlRead: tp_info-%p,Irp-%p,file-%pd,offset-%I64x,length-%lx\n",
                tpInfo,
                irp,
                Pd->FileObject,
                Pd->FileOffset.QuadPart,
                Pd->DataLength));
    }

    IoCallDriver (deviceObject, irp);

    if (((AFD_CLEAR_TP_FLAGS (TpIrp, AFD_TP_READ_CALL_PENDING)
                                    & (AFD_TP_READ_COMP_PENDING|AFD_TP_ABORT_PENDING))==0) && 
                    NT_SUCCESS (irp->IoStatus.Status) &&
                    AfdTPacketsContinueAfterRead (TpIrp)) {
        //
        // Read completed successfully inline and post-processing was successfull,
        // tell the worker to go on.
        //
        UPDATE_TPACKETS2 (TpIrp, "MdlRead completed inline with 0x%lX bytes", 
                                    (ULONG)irp->IoStatus.Information);
        return STATUS_SUCCESS;
    }
    else {
        //
        // Read has not completed yet or post processing failed,
        // worker should bail and we will continue when read completes
        // or in final completion routine (AfdCompleteTPackets).
        //
        return STATUS_PENDING;
    }
}

NTSTATUS
AfdRestartTPacketsMdlRead (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Completion routine for IRP based MDL read.
    Does another send if packet is ready or schedules worker
    to do the same.
Arguments:
    DeviceObject - AfdDeviceObject
    Irp          - read IRP being completed
    Context      - TpIrp

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - tell IO subsystem to stop
        processing the IRP (it is handled internally).
--*/
{
    PIRP    tpIrp = Context;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = tpIrp->AssociatedIrp.SystemBuffer;
    PAFD_ENDPOINT   endpoint;
    PAFD_BUFFER_HEADER  pd;

    UNREFERENCED_PARAMETER (DeviceObject);

    endpoint = IoGetCurrentIrpStackLocation (tpIrp)->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    ASSERT (AFD_GET_TPIC(tpIrp)->StateFlags & AFD_TP_WORKER_SCHEDULED);
    ASSERT (tpInfo->ReadIrp == Irp);

    pd = Irp->Overlay.AsynchronousParameters.UserApcContext;


    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdRestartTPacketsMdlRead:"
                " tp_info-%p,Irp-%p,status-%lx,length-%p,mdl-%p\n",
                tpInfo,
                Irp,
                Irp->IoStatus.Status,
                Irp->IoStatus.Information,
                Irp->MdlAddress));
    }

    //
    // Insert MDL into the current chain.
    //
    if (NT_SUCCESS (Irp->IoStatus.Status)) {
        PMDL mdl = *(tpInfo->TailMdl) = Irp->MdlAddress;
        while (mdl->Next!=NULL)
            mdl = mdl->Next;        
        tpInfo->TailMdl = &mdl->Next;

        pd->Mdl = Irp->MdlAddress;


        //
        // If FS driver hits EOF, it will still return
        // success to us and we need to handle this case.
        //
        if (pd->DataLength==Irp->IoStatus.Information) {

            (*tpInfo->TailPd) = pd;
            tpInfo->TailPd = &(pd->Next);

            Irp->MdlAddress = NULL;

            if (((AFD_CLEAR_TP_FLAGS (tpIrp, AFD_TP_READ_COMP_PENDING)
                                        & (AFD_TP_READ_CALL_PENDING|AFD_TP_ABORT_PENDING))==0) &&
                        AfdTPacketsContinueAfterRead (tpIrp)) {
                //
                // Read dispatch has already returned and post-processing 
                // was successfull, schedule the worker to continue processing
                // We transfer the reference that we added when we queued the
                // read to the worker.
                //
        
                UPDATE_TPACKETS2 (tpIrp, "MdlRead completed in restart with 0x%lX bytes",
                                        (ULONG)Irp->IoStatus.Information);
                AfdStartTPacketsWorker (AfdTPacketsWorker, tpIrp);
            }
            else {
                DEREFERENCE_TPACKETS (tpIrp);
            }
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        //
        // FS driver read less than we expected.
        // We must have hit end of file.
        // Save the real packet length so we can cleanup correctly and
        // force abort with STATUS_END_OF_FILE.
        //
        Irp->IoStatus.Status = STATUS_END_OF_FILE;
        pd->DataLength = (ULONG)Irp->IoStatus.Information;
    }
    else {
        ASSERT (Irp->MdlAddress == NULL);
    }
    AFD_CLEAR_TP_FLAGS (tpIrp, AFD_TP_READ_COMP_PENDING);
    AfdAbortTPackets (tpIrp, Irp->IoStatus.Status);

    if (pd->Mdl==NULL) {
        //
        //  No MDL was returned by the file system.
        //  We can free the packed descriptor immediately.
        //
        AfdReturnBuffer (pd, endpoint->OwningProcess);
    }
    else {
        //
        // File system did return MDL to us.
        // Save the descriptor so the MDL can be
        // properly returned back to the file system
        // by the cleanup routine.
        //
        (*tpInfo->TailPd) = pd;
        tpInfo->TailPd = &(pd->Next);
    }
    DEREFERENCE_TPACKETS (tpIrp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
AfdMdlReadComplete (
    PFILE_OBJECT    FileObject,
    PMDL            FileMdl,
    PLARGE_INTEGER  FileOffset
    )
/*++

Routine Description:
    Returns MDL to the file system / cache manager

Arguments:
    FileObject  - file object from which MDL comes
    FileMdl     - MDL itself
    FileOffset  - offset in the file where MDL data begins

Return Value:

    STATUS_SUCCESS - operation completed immediately
    STATUS_PENDING - request is sumbitted to file system driver
    other - operation failed.
Notes:


--*/
{
    PIRP    irp;
    PIO_STACK_LOCATION  irpSp;
    PDEVICE_OBJECT  deviceObject;
    ASSERT (KeGetCurrentIrql()<=APC_LEVEL);

    if( FsRtlMdlReadComplete (
                        FileObject,
                        FileMdl) ) {
        return STATUS_SUCCESS;
    }

    
    //
    // Fast path failed, so create a new IRP.
    //

    deviceObject =  IoGetRelatedDeviceObject (FileObject);
    irp = IoAllocateIrp(
              deviceObject->StackSize,
              FALSE
              );

    if( irp == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Setup the IRP.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    irp->MdlAddress = FileMdl;

    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->MinorFunction = IRP_MN_MDL | IRP_MN_COMPLETE;

    irpSp->Parameters.Read.Length = 0;
    while (FileMdl!=NULL) {
        irpSp->Parameters.Read.Length += FileMdl->ByteCount;
        FileMdl = FileMdl->Next;
    }

    irpSp->Parameters.Read.ByteOffset = *FileOffset;
    
    irpSp->Parameters.Read.Key = 0;

    //
    // Reference file object so it does not go away till this
    // IRP completes
    //
    ObReferenceObject (FileObject);
    AfdRecordFileRef ();

    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    //
    // Submit the IRP
    //

    IoSetCompletionRoutine(
        irp,
        AfdRestartMdlReadComplete,
        FileObject,
        TRUE,
        TRUE,
        TRUE
        );

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdMdlReadComplete: file-%p,Irp-%p,offset-%I64x\n",
                FileObject,
                irp,
                FileOffset->QuadPart));
    }
    IoCallDriver (deviceObject, irp);

    return STATUS_PENDING;
}


NTSTATUS
AfdRestartMdlReadComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Completion routine for IRPs issued by AfdMdlReadComplete. The only
    purpose of this completion routine is to free the IRPs created by
    AfdMdlReadComplete() and release file object reference.

Arguments:

    DeviceObject - Unused.

    Irp - The completed IRP.

    Context - FileObject on which MDL is returned

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - AFD takes care of the IRP

--*/

{
    PFILE_OBJECT    FileObject = Context;
    
    UNREFERENCED_PARAMETER (DeviceObject);

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartMdlReadComplete: Irp-%p,status-%lx,length-%p\n",
                    Irp,
                    Irp->IoStatus.Status,
                    Irp->IoStatus.Information));
    }

    //
    // Dereference the file object
    //
    ObDereferenceObject (FileObject);
    AfdRecordFileDeref ();

    //
    // Free the IRP since it's no longer needed.
    //

    IoFreeIrp( Irp );

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // AfdRestartMdlReadComplete


VOID
AfdLRMdlReadComplete (
    PAFD_BUFFER_HEADER  Pd
    )
{
    if (InterlockedPushEntrySList (
                &AfdLRFileMdlList,
                (PSLIST_ENTRY)&Pd->SList)==NULL) {
        AfdLRListAddItem (&AfdLRFileMdlListItem,
                                AfdLRProcessFileMdlList);
    }
}

BOOLEAN
AfdLRProcessFileMdlList (
    PAFD_LR_LIST_ITEM   Item
    )
{
    PSLIST_ENTRY  localList;
    BOOLEAN res = TRUE;

    ASSERT (Item==&AfdLRFileMdlListItem);
    DEBUG Item->SListLink.Next = UlongToPtr(0xBAADF00D);

    localList = InterlockedFlushSList (&AfdLRFileMdlList);

    while (localList!=NULL) {
        PAFD_BUFFER_HEADER  pd;
        NTSTATUS    status;
        pd = CONTAINING_RECORD (localList, AFD_BUFFER_HEADER, SList);
        localList = localList->Next;

        if (pd->BufferLength==0) {
            PAFD_BUFFER_TAG afdBufferTag = CONTAINING_RECORD (
                                                pd,
                                                AFD_BUFFER_TAG,
                                                Header);
            PAFD_ENDPOINT   endpoint = afdBufferTag->Context;
            status = AfdMdlReadComplete (afdBufferTag->FileObject,
                                            afdBufferTag->Mdl,
                                            &afdBufferTag->FileOffset);
            if (NT_SUCCESS (status)) {
                AfdReturnBuffer (&afdBufferTag->Header, 
                                    endpoint->OwningProcess);
                DEREFERENCE_ENDPOINT (endpoint);
                continue;
            }
        }
        else {
            PAFD_BUFFER afdBuffer = CONTAINING_RECORD (
                                                pd,
                                                AFD_BUFFER,
                                                Header);
            PAFD_CONNECTION connection = afdBuffer->Context;
            status = AfdMdlReadComplete (afdBuffer->FileObject,
                                            afdBuffer->Mdl->Next,
                                            &afdBuffer->FileOffset);
            if (NT_SUCCESS (status)) {
                afdBuffer->Mdl->Next = NULL;
                afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;
                AfdReturnBuffer (&afdBuffer->Header, 
                                    connection->OwningProcess);
                DEREFERENCE_CONNECTION (connection);
                continue;
            }
        }

        if (InterlockedPushEntrySList (
                    &AfdLRFileMdlList,
                    (PSLIST_ENTRY)&pd->SList)==NULL) {
            ASSERT (Item->SListLink.Next==UlongToPtr(0xBAADF00D));
            res = FALSE;
        }
    }

    return res;
}

NTSTATUS
AfdTPacketsBufferRead (
    PIRP                TpIrp,
    PAFD_BUFFER_HEADER  Pd
    )
/*++

Routine Description:

    Performs buffered file read for file systems that do
    not support caching

Arguments:

    TpIrp  - transmit packet irp
    Pd     - descriptor with file parameters for the read

Return Value:

    STATUS_SUCCESS - read was completed in-line
    STATUS_PENDING - read was queued to file system driver, 
                    will complete lated
    other - read failed
--*/
{

    PAFD_TPACKETS_INFO_INTERNAL tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    PDEVICE_OBJECT deviceObject;
    PIRP irp;
    PAFD_BUFFER afdBuffer;
    PIO_STACK_LOCATION irpSp;

    ASSERT( AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_WORKER_SCHEDULED );

    afdBuffer = CONTAINING_RECORD (Pd, AFD_BUFFER, Header);

    //
    // Find the device object and allocate IRP of appropriate size
    // if current one does not fit or is not available at all.
    //
    deviceObject = IoGetRelatedDeviceObject (afdBuffer->FileObject);

    if ((tpInfo->ReadIrp==NULL) ||
            (tpInfo->ReadIrp->StackCount<deviceObject->StackSize)) {
        if (tpInfo->ReadIrp!=NULL) {
            IoFreeIrp (tpInfo->ReadIrp);
        }

        if (afdBuffer->Irp->StackCount<deviceObject->StackSize) {
            tpInfo->ReadIrp = IoAllocateIrp (deviceObject->StackSize, FALSE);
            if (tpInfo->ReadIrp==NULL) {
                PAFD_ENDPOINT   endpoint;
                endpoint = IoGetCurrentIrpStackLocation (TpIrp)->FileObject->FsContext;
                ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
                Pd->Mdl->ByteCount = Pd->BufferLength;
                AfdReturnBuffer (Pd, endpoint->OwningProcess);
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else {
            tpInfo->ReadIrp = afdBuffer->Irp;
        }
    }

    //
    // Mark IRP as busy and set it up
    //

    AFD_SET_TP_FLAGS (TpIrp, AFD_TP_READ_BUSY);

    irp = tpInfo->ReadIrp;


    //
    // Setup and sumbit the IRP
    //
    irp->MdlAddress = afdBuffer->Mdl;
    irp->AssociatedIrp.SystemBuffer = afdBuffer->Buffer;
    irp->UserBuffer = afdBuffer->Buffer;

    //
    // Set current thread for IoSetHardErrorOrVerifyDevice.
    //
    irp->Tail.Overlay.Thread = PsGetCurrentThread ();
    irp->Overlay.AsynchronousParameters.UserApcContext = Pd;


    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->MinorFunction = IRP_MN_NORMAL;
    irpSp->FileObject = afdBuffer->FileObject;


    irpSp->Parameters.Read.Length = Pd->DataLength;
    irpSp->Parameters.Read.ByteOffset = Pd->FileOffset;
    IoSetCompletionRoutine(
        irp,
        AfdRestartTPacketsBufferRead,
        TpIrp,
        TRUE,
        TRUE,
        TRUE
        );


    REFERENCE_TPACKETS (TpIrp);
    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTPacketsBufferRead:"
                    " Initiating read, tp_info-%p,file-%p,buffer-%p,length-%lx,offset-%I64x\n",
                    tpInfo,
                    afdBuffer->FileObject,
                    (PVOID)afdBuffer,
                    afdBuffer->DataLength,
                    afdBuffer->FileOffset.QuadPart
                    ));
    }

    IoCallDriver (deviceObject, irp);

    if (((AFD_CLEAR_TP_FLAGS (TpIrp, AFD_TP_READ_CALL_PENDING)
                                    & (AFD_TP_READ_COMP_PENDING|AFD_TP_ABORT_PENDING))==0) && 
                    NT_SUCCESS (irp->IoStatus.Status) &&
                    AfdTPacketsContinueAfterRead (TpIrp)) {
        //
        // Read completed successfully inline and post-processing was successfull,
        // tell the worker to go on.
        //
        UPDATE_TPACKETS2(TpIrp, "BufRead completed inline with 0x%lX bytes",
                         (ULONG)irp->IoStatus.Information);

        return STATUS_SUCCESS;
    }
    else {
        //
        // Read has not completed yet or post processing failed,
        // worker should bail and we will continue when read completes
        // or in final completion routine (AfdCompleteTPackets).
        //

        return STATUS_PENDING;
    }
}

NTSTATUS
AfdRestartTPacketsBufferRead (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Completion routine for buffered read.
    Does another send if packet is ready or schedules worker
    to do the same.
Arguments:
    DeviceObject - AfdDeviceObject
    Irp          - read IRP being completed
    Context      - TpIrp

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - tell IO subsystem to stop
        processing the IRP (it is handled internally).
--*/
{
    PIRP            tpIrp = Context;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = tpIrp->AssociatedIrp.SystemBuffer;
    PAFD_ENDPOINT   endpoint;
    PAFD_BUFFER     afdBuffer;
    ULONG           flags;

    UNREFERENCED_PARAMETER (DeviceObject);

    endpoint = IoGetCurrentIrpStackLocation (tpIrp)->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    ASSERT (AFD_GET_TPIC(tpIrp)->StateFlags & AFD_TP_WORKER_SCHEDULED);
    ASSERT (tpInfo->ReadIrp == Irp ||
        AFD_GET_TPIC(tpIrp)->StateFlags & AFD_TP_ABORT_PENDING);

    afdBuffer = Irp->Overlay.AsynchronousParameters.UserApcContext;


    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdRestartTPacketsBufferRead: tp_info-%p,Irp-%p,status-%lx,length-%p\n",
                tpInfo,
                Irp,
                Irp->IoStatus.Status,
                Irp->IoStatus.Information));
    }

    //
    // Insert MDL into the current chain
    // even if fs driver failed so that common
    // cleanup routine takes care of its disposal
    // together with AfdBuffer.
    //
    *(tpInfo->TailMdl) = afdBuffer->Mdl;
    tpInfo->TailMdl = &(afdBuffer->Mdl->Next);
    ASSERT (*(tpInfo->TailMdl)==NULL);

    (*tpInfo->TailPd) = &afdBuffer->Header;
    tpInfo->TailPd = &(afdBuffer->Next);
    ASSERT (*(tpInfo->TailPd)==NULL);

    flags = AFD_CLEAR_TP_FLAGS (tpIrp, AFD_TP_READ_COMP_PENDING);

    if (Irp==afdBuffer->Irp) {
        //
        // If abort is aready in progress, we need to use
        // interlocked exchange to synchronize with
        // AfdAbortTPackets which may be attempting to cancel
        // this IRP.
        //
        if (flags & AFD_TP_ABORT_PENDING) {
#if DBG
            PIRP    irp =
#endif
            InterlockedExchangePointer ((PVOID *)&tpInfo->ReadIrp, NULL);
            ASSERT (irp==Irp || irp==(PVOID)-1);
        }
        else {
            tpInfo->ReadIrp = NULL;
        }
    }

    if (NT_SUCCESS (Irp->IoStatus.Status)) {
        if (((flags & (AFD_TP_READ_CALL_PENDING|AFD_TP_ABORT_PENDING))==0) &&
                    AfdTPacketsContinueAfterRead (tpIrp)) {
            //
            // Read dispatch has already returned and post-processing 
            // was successfull, schedule the worker to continue processing
            // We transfer the reference that we added when we queued the
            // read to the worker.
            //
            UPDATE_TPACKETS2 (tpIrp, "BufRead completed in restart with %08x bytes", (ULONG)Irp->IoStatus.Information);
            AfdStartTPacketsWorker (AfdTPacketsWorker, tpIrp);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
    }
    else {
        AfdAbortTPackets (tpIrp, Irp->IoStatus.Status);
    }

    DEREFERENCE_TPACKETS (tpIrp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

BOOLEAN
AfdTPacketsContinueAfterRead (
    PIRP    TpIrp
    )
/*++

Routine Description:
    Read post-processing common for cached and non-cached case.
    Queues new send if packet is complete and send IRP is available
Arguments:
    TpInfo      - transmit packets IRP
Return Value:
    TRUE - continue processing
    FALSE - processing cannot be continued because there are no
            available send IRPs
--*/

{
    PAFD_BUFFER_HEADER  pd;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    BOOLEAN res = TRUE;

    pd = CONTAINING_RECORD (tpInfo->TailPd, AFD_BUFFER_HEADER, Next);
    if (!pd->PartialMessage) {
        USHORT    sendIrp;

        sendIrp = AfdTPacketsFindSendIrp (TpIrp);
        if (sendIrp!=tpInfo->NumSendIrps) {
            NTSTATUS    status;
            status = AfdTPacketsSend (TpIrp, sendIrp);
            res = (BOOLEAN)NT_SUCCESS (status);
        }
        else {
            res = FALSE;
        }
    }
    else {
        //
        // Need to complete the packet chain before we can send again
        //
        ASSERT (tpInfo->PdLength<tpInfo->SendPacketLength);
        pd->PartialMessage = FALSE;
        UPDATE_TPACKETS2 (TpIrp, "Continue building packet after read, cur len: 0x%lX",
                                                tpInfo->PdLength);
    }

    return res;
}


VOID
AfdCompleteTPackets (
    PVOID       Context
    )
/*++

Routine Description:
  This routine is called when all activity on transmit IRP request is completed
  and reference count drops to 0.  It cleans up remaining resources and
  completes the IRP or initiates endpoint reuse if so requested
Arguments:

    Context  - TransmitInfo associated with the request
Return Value:

    None
--*/
{

    do {
        AFD_LOCK_QUEUE_HANDLE lockHandle;
        PIRP    tpIrp = Context;
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (tpIrp);
        PAFD_TPACKETS_INFO_INTERNAL tpInfo = tpIrp->AssociatedIrp.SystemBuffer;
        PAFD_ENDPOINT   endpoint;
        PIRP    nextIrp = NULL;

        ASSERT (AFD_GET_TPIC(tpIrp)->ReferenceCount==0);
        endpoint = irpSp->FileObject->FsContext;
        ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

        ASSERT ((AFD_GET_TPIC(tpIrp)->StateFlags 
                                     & (AFD_TP_SEND_BUSY(0) |
                                        AFD_TP_SEND_BUSY(1) |
                                        AFD_TP_READ_BUSY)) == 0);


        if (tpInfo!=NULL) {
            LONG    sendIrp;
            KIRQL   currentIrql;
            currentIrql = KeGetCurrentIrql ();

            IF_DEBUG (TRANSMIT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdCompleteTPackets: tp_info-%p, irql-%x\n",
                            tpInfo, currentIrql));
            }

            UPDATE_TPACKETS2 (tpIrp, "CompleteTPackets @ irql 0x%lX", currentIrql);

            //
            // Cleanup what's in the TpInfo structure
            //
            if (tpInfo->HeadMdl!=NULL) {
                tpInfo->TailMdl = &tpInfo->HeadMdl;
                tpInfo->TailPd = &tpInfo->HeadPd;
                if (!AfdCleanupPacketChain (tpIrp, currentIrql<=APC_LEVEL)) {
                    ASSERT (currentIrql>APC_LEVEL);
                    AfdStartTPacketsWorker (AfdCompleteTPackets, tpIrp);
                    return;
                }
            }

            //
            // Cleanup what remains in IRPs
            //
            for (sendIrp=0; sendIrp<tpInfo->NumSendIrps ; sendIrp++) {
                if (tpInfo->SendIrp[sendIrp]!=NULL) {
                    if (tpInfo->SendIrp[sendIrp]->MdlAddress!=NULL) {
                        tpInfo->HeadMdl = tpInfo->SendIrp[sendIrp]->MdlAddress;
                        tpInfo->TailMdl = &tpInfo->HeadMdl;
                        tpInfo->SendIrp[sendIrp]->MdlAddress = NULL;
                        tpInfo->HeadPd = tpInfo->SendIrp[sendIrp]->Overlay.AsynchronousParameters.UserApcContext;
                        tpInfo->TailPd = &tpInfo->HeadPd;
                        tpInfo->SendIrp[sendIrp]->Overlay.AsynchronousParameters.UserApcContext = NULL;
                        if (!AfdCleanupPacketChain (tpIrp, currentIrql<=APC_LEVEL)) {
                            ASSERT (currentIrql>APC_LEVEL);
                            AfdStartTPacketsWorker (AfdCompleteTPackets, tpIrp);
                            return;
                        }

                    }
                    tpInfo->SendIrp[sendIrp]->Cancel = FALSE; // So we can reuse it.
                }
            }

            //
            // Free read IRP if we used one
            //
            if (tpInfo->ReadIrp!=NULL) {
                IoFreeIrp (tpInfo->ReadIrp);
                tpInfo->ReadIrp = NULL;
            }
        }

        ASSERT (tpIrp->Tail.Overlay.ListEntry.Flink == NULL);

        //
        // If request succeeded and reuse is required, attempt to
        // initiate it
        //

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);

        if ( NT_SUCCESS(tpIrp->IoStatus.Status) &&
             (AFD_GET_TPIC(tpIrp)->Flags & AFD_TF_REUSE_SOCKET) != 0 ) {

            PAFD_CONNECTION connection;

            IS_VC_ENDPOINT (endpoint);

            //
            // Check if we still have endpoint and connection intact
            // under the lock.  If this is not the case, we won't try
            // to reuse it (it must have been closed or aborted).
            //
            connection = endpoint->Common.VcConnecting.Connection;
            if (connection!=NULL) {

                ASSERT (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND ||
                            connection->Aborted);
                //
                // Remember that there is a transmit IRP pended on the endpoint,
                // so that when we're freeing up the connection we also complete
                // the transmit IRP.
                //

                connection->ClosePendedTransmit = TRUE;

                //
                // Since we are going to effectively close this connection,
                // remember that we have started cleanup on this connection.
                // This allows AfdDeleteConnectedReference to remove the
                // connected reference when appropriate.
                //

                connection->CleanupBegun = TRUE;

                //
                // Delete the endpoint's reference to the connection in
                // preparation for reusing this endpoint.
                //

                endpoint->Common.VcConnecting.Connection = NULL;

                //
                // This is to simplify debugging.
                // If connection is not being closed by the transport
                // we want to be able to find it in the debugger faster
                // then thru !poolfind AfdC.
                //
                endpoint->WorkItem.Context = connection;

                //
                // Save pointer to connection in case disconnect needs
                // to be aborted (thru abortive close of connection)
                //
                irpSp->Parameters.DeviceIoControl.Type3InputBuffer = connection;

                //
                // We are going to free TPackets info since we are done
                // with sends and no longer need this.
                // This will also be our indication that we are in the
                // reuse state (for the cancel routine).
                //
                tpIrp->AssociatedIrp.SystemBuffer = (PVOID)-1;
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
                if ((AFD_GET_TPIC(tpIrp)->StateFlags & AFD_TP_SEND_AND_DISCONNECT) 
                        && !connection->DisconnectIndicated
                        && !connection->Aborted) {
                    ASSERT (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND);
                    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
                    AfdDisconnectEventHandler (endpoint,
                                        connection,
                                        0, NULL, 0, NULL,
                                        TDI_DISCONNECT_RELEASE
                                        );
                    DEREFERENCE_CONNECTION2 (connection, "S&D disconnect", 0);
                }
                else
#endif
                {
                    //
                    // Attempt to remove the connected reference.
                    //

                    AfdDeleteConnectedReference( connection, TRUE );

                    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        
                    DEREFERENCE_CONNECTION2 (connection,
                                                "No S&D disconnect, flags: 0x%lX",
                                                connection->ConnectionStateFlags);
                }

                IF_DEBUG (TRANSMIT) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdCompleteTPackets: tp_info-%p, initiating reuse\n",
                                tpInfo));
                }

                if (tpInfo!=NULL) {
                    AfdReturnTpInfo (tpInfo);
                }
                //
                // DO NOT access the IRP after this point, since it may have
                // been completed inside AfdDereferenceConnection!
                //

                return;
            }

            UPDATE_ENDPOINT (endpoint);
        }

        //
        // Check if we need to start or cancel another IRP to
        // continue processing.
        //
        while (AFD_GET_TPIC(tpIrp)->Next!=NULL) {
            nextIrp = AFD_GET_TPIRP(AFD_GET_TPIC(tpIrp)->Next);
            if (endpoint->EndpointCleanedUp ||
                    (((AFD_GET_TPIC(nextIrp)->Flags & AFD_TF_DISCONNECT)==0 ||
                            nextIrp->AssociatedIrp.SystemBuffer!=NULL) &&
                        IS_VC_ENDPOINT (endpoint) &&
                        endpoint->Common.VcConnecting.Connection!=NULL &&
                        endpoint->Common.VcConnecting.Connection->Aborted) ) {
                //
                // Endpoint is being cleaned up or connection aborted,
                // we attempt to cancel next IRP so that all of them
                // are cleaned up eventually.  Exception is pure disconnect
                // IRP and endpoint is not cleaned up.
                //
                if ((AFD_GET_TPIC(nextIrp)->StateFlags & AFD_TP_QUEUED)!=0) {
                    AFD_GET_TPIC (nextIrp)->StateFlags &=~AFD_TP_QUEUED;
                    if ((AFD_GET_TPIC(nextIrp)->StateFlags & AFD_TP_SEND)!=0) {
                        AFD_GET_TPIC(tpIrp)->Next = AFD_GET_TPIC(nextIrp)->Next;
                        ASSERT (AFD_GET_TPIC(nextIrp)->ReferenceCount == 1);
                        AFD_GET_TPIC(nextIrp)->ReferenceCount = 0;
                        AFD_GET_TPIC(nextIrp)->StateFlags |= AFD_TP_ABORT_PENDING;
                        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
                        AfdSendQueuedTPSend (endpoint, nextIrp);
                        nextIrp = NULL;
                        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
                        continue;
                    }
                    nextIrp->Cancel = TRUE;
                }
                else if (AfdGetTPacketsReference (nextIrp)) {
                    nextIrp->Cancel = TRUE;
                    ASSERT ((AFD_GET_TPIC (nextIrp)->StateFlags & AFD_TP_SEND)==0);
                }
                else {
                    //
                    // The IRP must already being completed, it will
                    // start the next one if necessary.
                    //
                    ASSERT ((AFD_GET_TPIC (nextIrp)->StateFlags & AFD_TP_SEND)==0);
                    nextIrp = NULL;
                }
            }
            else if (endpoint->Irp==tpIrp && 
                        (AFD_GET_TPIC(nextIrp)->StateFlags & AFD_TP_QUEUED)!=0) {
                //
                // We have a nextIrp following the one we are completing.
                // which is still queued and haven't been started 
                // - try to start it.
                //
                AFD_GET_TPIC(nextIrp)->StateFlags &= ~AFD_TP_QUEUED;

                //
                // If we finished all the sends, we should have started
                // another IRP before.
                //
                ASSERT ((AFD_GET_TPIC(tpIrp)->StateFlags & AFD_TP_SENDS_POSTED)==0);
                //
                // If nextIrp is a plain send IRP, we need to process it inline.
                //
                if ((AFD_GET_TPIC(nextIrp)->StateFlags & AFD_TP_SEND)!=0) {
                    AFD_GET_TPIC(tpIrp)->Next = AFD_GET_TPIC(nextIrp)->Next;
                    ASSERT (AFD_GET_TPIC(nextIrp)->ReferenceCount == 1);
                    AFD_GET_TPIC(nextIrp)->ReferenceCount = 0;
                    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
                    AfdSendQueuedTPSend (endpoint, nextIrp);
                    nextIrp = NULL;
                    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
                    continue;
                }
                //
                // This IRP couldn't have been counted towards
                // active maximum.
                //
                ASSERT (nextIrp->Tail.Overlay.ListEntry.Blink == (PVOID)1);
            }
            else {
                nextIrp = NULL;
            }

            break;
        }

        //
        // Remove the IRP being completed from the list
        //
        {
            PIRP    pIrp;

            if (endpoint->Irp==tpIrp) {
                endpoint->Irp = (AFD_GET_TPIC(tpIrp)->Next!=NULL)
                                ? AFD_GET_TPIRP(AFD_GET_TPIC(tpIrp)->Next)
                                : NULL;
            }
            else {
                pIrp = endpoint->Irp;
                while (AFD_GET_TPIRP(AFD_GET_TPIC(pIrp)->Next)!=tpIrp)
                    pIrp = AFD_GET_TPIRP(AFD_GET_TPIC(pIrp)->Next);
                AFD_GET_TPIC(pIrp)->Next = AFD_GET_TPIC(tpIrp)->Next;
            }
        }

        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        if ((AFD_GET_TPIC (tpIrp)->StateFlags & AFD_TP_SEND)!=0) {
            //
            // For plain send IRP we need to simmulate send completion
            // as if it was failed by the transport driver.
            // We can only get here if send IRP was cancelled.
            //
            ASSERT (!NT_SUCCESS (tpIrp->IoStatus.Status));
            ASSERT (tpIrp->Tail.Overlay.ListEntry.Blink != NULL);
            ASSERT (AFD_GET_TPIC(tpIrp)->StateFlags & AFD_TP_ABORT_PENDING);
            ASSERT (tpInfo==NULL);
            AfdSendQueuedTPSend (endpoint, tpIrp);
        }
        else {
            BOOLEAN checkQueue;
            
            if (IoSetCancelRoutine( tpIrp, NULL ) == NULL) {
                KIRQL cancelIrql;

                //
                // The cancel routine has or is about to run. Synchonize with
                // the cancel routine by acquiring and releasing the cancel
                // and endpoint spinlocks.  The cancel routine won't touch
                // the IRP as it will see that its reference count is 0.
                //

                IoAcquireCancelSpinLock (&cancelIrql);
                ASSERT( tpIrp->Cancel );
                IoReleaseCancelSpinLock (cancelIrql);
                AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
                AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
            }

            if (AFD_GET_TPIC(tpIrp)->Flags & AFD_TF_DISCONNECT) {
                AFD_END_STATE_CHANGE (endpoint);
            }

            checkQueue = (BOOLEAN)(tpIrp->Tail.Overlay.ListEntry.Blink == NULL);

            IF_DEBUG (TRANSMIT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdCompleteTPackets: tp_info-%p, completing IRP-%p\n",
                        tpInfo, tpIrp));
            }
            if (tpInfo!=NULL) {
                tpIrp->AssociatedIrp.SystemBuffer = NULL;
                AfdReturnTpInfo (tpInfo);
            }
            else {
                ASSERT (tpIrp->AssociatedIrp.SystemBuffer==NULL);
            }


            UPDATE_ENDPOINT2 (endpoint, "Completing TP irp with status/bytes sent: 0x%lX",
                                NT_SUCCESS (tpIrp->IoStatus.Status)
                                    ? (ULONG)tpIrp->IoStatus.Information
                                    : tpIrp->IoStatus.Status);


            IoCompleteRequest( tpIrp, AfdPriorityBoost );

            //
            // If we're enforcing a maximum active TransmitFile count,
            // and this Irp was counted towards active maximum, then
            // check the list of queued TransmitFile requests and start the
            // next one.
            //

            if( (AfdMaxActiveTransmitFileCount > 0) && 
                    checkQueue ) {

                AfdStartNextQueuedTransmit();

            }
        }

        if (nextIrp!=NULL) {
            LONG    result;

            if (nextIrp->Cancel) {
                //
                // If endpoint being cleaned-up/aborted, just abort the IRP
                // an dereference it.
                //
                AfdAbortTPackets (nextIrp, STATUS_CANCELLED);
                DEREFERENCE_TPACKETS_R (nextIrp, result);
                if (result==0) {
                    //
                    // Avoid recursion, execute the completion inline.
                    //
                    Context = nextIrp;
                    continue;
                }
            }
            else if (nextIrp->AssociatedIrp.SystemBuffer!=NULL) {
                if (AfdMaxActiveTransmitFileCount==0 ||
                        !AfdQueueTransmit (nextIrp)) {
                    UPDATE_ENDPOINT (endpoint);
                    AfdStartTPacketsWorker (AfdTPacketsWorker, nextIrp);
                }
            }
            else {
                UPDATE_ENDPOINT (endpoint);
                AfdPerformTpDisconnect (nextIrp);
                DEREFERENCE_TPACKETS_R (nextIrp, result);
                if (result==0) {
                    Context = nextIrp;
                    continue;
                }
            }
        }
        break;
    }
    while (1);
}

VOID
AfdAbortTPackets (
    PIRP        TpIrp,
    NTSTATUS    Status
    )
/*++

Routine Description:
  This routine is used to stop the transmit file request in progress
  and save the status which would be reported to the app as the
  cause of failure

Arguments:

    TransmitInfo     - trasnmit info structure associated with the request
    Status           - status code for the error that caused the abort
Return Value:

    None


--*/
{
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    LONG    stateFlags, newStateFlags;
    USHORT  sendIrp;

    do {
        newStateFlags = stateFlags = AFD_GET_TPIC(TpIrp)->StateFlags;
        if (newStateFlags & AFD_TP_ABORT_PENDING) {
            return;
        }

        newStateFlags |= AFD_TP_ABORT_PENDING;
    }
    while (InterlockedCompareExchange (
                            (PLONG)&AFD_GET_TPIC(TpIrp)->StateFlags,
                            newStateFlags,
                            stateFlags)!=stateFlags);
    if (NT_SUCCESS (TpIrp->IoStatus.Status)) {
        TpIrp->IoStatus.Status = Status;
        UPDATE_TPACKETS2 (TpIrp, "Abort with status: 0x%lX", Status);
    }

    if (tpInfo!=NULL) {
        //
        // Cancel any outstanding IRPs.  It is safe to cancel IRPs even if
        // they are already completed and before they are submitted 
        // (although we try to avoid doing this unnecessarily).
        // Note that the completion pending flag can be set even
        // before the irp is allocated, so check for NULL is important.
        // However, after IRP is allocated and assigned, it is not freed
        // until transmit packets is completed.
        //

        for (sendIrp=0; sendIrp<tpInfo->NumSendIrps; sendIrp++) {
            if (tpInfo->SendIrp[sendIrp]!=NULL &&
                    AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_SEND_COMP_PENDING(sendIrp)) {
                IF_DEBUG (TRANSMIT) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdAbortTPackets: tp_info-%p, canceling send irp1-%p\n",
                                tpInfo,
                                tpInfo->SendIrp[sendIrp]));
                }
                UPDATE_TPACKETS2 (TpIrp, "Aborting send irp 0x%lX", sendIrp);
                IoCancelIrp (tpInfo->SendIrp[sendIrp]);
            }
        }

        if (AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_READ_COMP_PENDING) {
            do {
                PIRP    irp;

                //
                // Check if completion routine did not manage
                // to reset this IRP (because it was part of
                // AFD buffer structure - buffered reads case).
                //
                irp = tpInfo->ReadIrp;
                ASSERT (irp!=(PVOID)-1);
                if (irp==NULL) {
                    break;
                }

                //
                // Set this field to a "special" value so that
                // we know if we need to reset it back to previous
                // value when we are done with the IRP or if completion 
                // rouine done this already.
                //
                else if (InterlockedCompareExchangePointer (
                                    (PVOID *)&tpInfo->ReadIrp,
                                    (PVOID)-1,
                                    irp)==irp) {
                    IF_DEBUG (TRANSMIT) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                    "AfdAbortTPackets: tp_info-%p, canceling read irp-%p\n",
                                    tpInfo,
                                    irp));
                    }
                    UPDATE_TPACKETS2 (TpIrp, "Aborting read IRP", 0);
                    IoCancelIrp (irp);

                    //
                    // Reset the field to its original value
                    // unless completion routine already done this for us.
                    //
#if DBG
                    irp =
#endif
                    InterlockedCompareExchangePointer (
                                    (PVOID *)&tpInfo->ReadIrp,
                                    irp,
                                    (PVOID)-1);
                    ASSERT (irp==NULL || irp==(PVOID)-1);
                    break;
                }
            }
            while (1);
        }
    }
}

VOID
AfdCancelTPackets (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    The cancel routine for transmit packets requests.

Arguments:

    DeviceObject - ignored.

    Irp - a pointer to the transmit packets IRP to cancel.

Return Value:

    None.

--*/

{

    PIO_STACK_LOCATION irpSp;
    PAFD_ENDPOINT endpoint;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    AFD_LOCK_QUEUE_HANDLE transmitLockHandle;


    UNREFERENCED_PARAMETER (DeviceObject);
    //
    // Initialize some locals and grab the endpoint spin lock.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    endpoint = irpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    tpInfo = Irp->AssociatedIrp.SystemBuffer;

    ASSERT (KeGetCurrentIrql ()==DISPATCH_LEVEL);
    AfdAcquireSpinLockAtDpcLevel( &endpoint->SpinLock, &lockHandle);

    //
    // If this transmit IRP is on the TransmitFile queue, remove it.
    //

    AfdAcquireSpinLockAtDpcLevel( &AfdQueuedTransmitFileSpinLock,
                                                    &transmitLockHandle);

    if (!(AFD_GET_TPIC (Irp)->StateFlags & AFD_TP_SEND) &&
            Irp->Tail.Overlay.ListEntry.Flink != NULL ) {

        //
        // We can release cancel spinlock as we hold endpoint lock now.
        // and we made sure that we have IRP reference (by nature of
        // it being queued.
        //

        IoReleaseCancelSpinLock (DISPATCH_LEVEL);

        ASSERT (tpInfo!=NULL && tpInfo!=(PVOID)-1);

        RemoveEntryList( &Irp->Tail.Overlay.ListEntry );

        //
        // Reset Flink to indicate that IRP is no longer in the queue
        // Note that Blink is not reset so that completion routine knows
        // that this IRP was not counted towards active maximum and thus
        // new IRP should not be initiated when this one is being
        // completed.
        //

        Irp->Tail.Overlay.ListEntry.Flink = NULL;
        ASSERT (Irp->Tail.Overlay.ListEntry.Blink!=NULL);

        AfdReleaseSpinLockFromDpcLevel( &AfdQueuedTransmitFileSpinLock, &transmitLockHandle );
        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
        KeLowerIrql (Irp->CancelIrql);

        //
        // Although we know that there is nothing to abort, we call
        // this routine to set the status code in the IRP.
        //
        AfdAbortTPackets (Irp, STATUS_CANCELLED);

        IF_DEBUG (TRANSMIT) {
           KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdCancelTPackets: Removed from the queue, tp_info-%p, irp-%p\n",
                        tpInfo, Irp));
        }
        //
        // Remove initial reference
        //
        DEREFERENCE_TPACKETS (Irp);
    }
    else {
        KIRQL   cancelIrql = Irp->CancelIrql;

        AfdReleaseSpinLockFromDpcLevel( &AfdQueuedTransmitFileSpinLock,
                                                        &transmitLockHandle);

        

        if ((AFD_GET_TPIC(Irp)->StateFlags & AFD_TP_QUEUED)!=0 ||
                AfdGetTPacketsReference (Irp)) {
            //
            // We can release cancel spinlock as we hold endpoint lock now
            // and we made sure that we have IRP reference (queued or explicit).
            //
            IoReleaseCancelSpinLock (DISPATCH_LEVEL);

            if ((AFD_GET_TPIC(Irp)->StateFlags & AFD_TP_QUEUED)!=0) {
                AFD_CLEAR_TP_FLAGS (Irp, AFD_TP_QUEUED);
            }
            else {
                ASSERT ((AFD_GET_TPIC (Irp)->StateFlags & AFD_TP_SEND)==0);
            }
            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
            if (cancelIrql!=DISPATCH_LEVEL) {
                KeLowerIrql (cancelIrql);
            }

            //
            // Transmit is still in progress or queued, perform the abort
            //
            AfdAbortTPackets (Irp, STATUS_CANCELLED);

            //
            // Remove extra reference that we either added above or
            // the initial one in case of queued IRP.
            //
            DEREFERENCE_TPACKETS (Irp);
        }
        else if (tpInfo==(PVOID)-1) {
            //
            // Endpoint is being disconnected and reused.
            // Abort the connection and complete the  IRP 
            //
            BOOLEAN result;
            PAFD_CONNECTION connection;
            BOOLEAN checkQueue = (BOOLEAN)(Irp->Tail.Overlay.ListEntry.Blink == NULL);


            //
            // We can release cancel spinlock as we hold endpoint lock now
            // and know for the fact that reuse code hasn't been executed
            // yet (it takes endpoint spinlock and resets the SystemBuffer
            // NULL).
            //
            IoReleaseCancelSpinLock (DISPATCH_LEVEL);


            //
            // Remove the IRP being completed from the list
            // so that reuse routine won't find and complete it again
            // 

            ASSERT (AFD_GET_TPIC(Irp)->Next==NULL);
            if (endpoint->Irp==Irp) {
                endpoint->Irp = NULL;
            }
            else {
                PIRP    pIrp;
                pIrp = endpoint->Irp;
                while (AFD_GET_TPIRP(AFD_GET_TPIC(pIrp)->Next)!=Irp)
                    pIrp = AFD_GET_TPIRP(AFD_GET_TPIC(pIrp)->Next);
                AFD_GET_TPIC(pIrp)->Next = NULL;
            }

            //
            // Reset the pointer so we do not confuse the IO subsystem
            //
            Irp->AssociatedIrp.SystemBuffer = NULL;

            //
            // Abort the connection if disconnect isn't already completing
            // (check for that by checking ref count on connection. If
            // already 0, then we don't need to do anything)
            //
            // We stored a pointer to the connection in Type3InputBuffer
            // We are guaranteed that connection structure is still around
            // since this IRP is still around.
            //
            connection = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
            ASSERT(connection != NULL);

            CHECK_REFERENCE_CONNECTION (connection, result);

            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);

            if (result) {
                //
                // Abort the connection; that will trigger cleanup of any
                // other operations on this endpoint
                //
                
                AfdAbortConnection( connection ); // dereferences connection
            }

            if (Irp->CancelIrql!=DISPATCH_LEVEL) {
                KeLowerIrql (Irp->CancelIrql);
            }
            IF_DEBUG (TRANSMIT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdCancelTPackets: Completing, irp-%p\n",
                            Irp));
            }

            UPDATE_ENDPOINT (endpoint);
            Irp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest (Irp, AfdPriorityBoost);


            //
            // If we're enforcing a maximum active TransmitFile count,
            // and this Irp was counted towards active maximum, then
            // check the list of queued TransmitFile requests and start the
            // next one.
            //

            if( AfdMaxActiveTransmitFileCount > 0 && checkQueue) {

                AfdStartNextQueuedTransmit();

            }
        }
        else {
            //
            // Everything is done anyway, let go.
            //
            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
            //
            // We can release cancel spinlock as we hold endpoint lock now
            // and we made sure that we have IRP reference (queued or explicit).
            //
            IoReleaseCancelSpinLock (cancelIrql);
        }
    }

} // AfdCancelTPackets



VOID
AfdCompleteClosePendedTPackets (
    PAFD_ENDPOINT   Endpoint
    )

/*++

Routine Description:

    Completes a transmit IRP that was waiting for the connection to be
    completely disconnected.

Arguments:

    Endpoint - the endpoint on which the transmit request is pending.

Return Value:

    None.

--*/

{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PIRP tpIrp;
    BOOLEAN checkQueue;

    AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );

    //
    // First make sure that thre is really a reuse request pended on
    // this endpoint.  We do this while holding the appropriate locks
    // to close the timing window that would exist otherwise, since
    // the caller may not have had the locks when making the test.
    //

    tpIrp = Endpoint->Irp;
    while (tpIrp!=NULL && tpIrp->AssociatedIrp.SystemBuffer != (PVOID)-1) {
        tpIrp = AFD_GET_TPIRP(AFD_GET_TPIC(tpIrp)->Next);
    }

    if ( tpIrp == NULL || 
            tpIrp->AssociatedIrp.SystemBuffer != (PVOID)-1) {
        IF_DEBUG (TRANSMIT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdCompleteClosePendedTPackets: Irp is gone, endpoint-%p",
                        Endpoint));
        }
        AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
        return;
    }

    //
    // Reset the system buffer so we don't confuse the IO
    // subsystem and synchronize with the cancel routine.
    //
    tpIrp->AssociatedIrp.SystemBuffer = NULL;

    //
    // Remove the IRP being completed from the list
    //
    ASSERT (AFD_GET_TPIC(tpIrp)->Next==NULL);
    if (Endpoint->Irp==tpIrp) {
        Endpoint->Irp = NULL;
    }
    else {
        PIRP    pIrp;
        pIrp = Endpoint->Irp;
        while (AFD_GET_TPIRP(AFD_GET_TPIC(pIrp)->Next)!=tpIrp)
            pIrp = AFD_GET_TPIRP(AFD_GET_TPIC(pIrp)->Next);
        AFD_GET_TPIC(pIrp)->Next = NULL;
    }

    //
    // Make sure to refresh the endpoint BEFORE completing the transmit
    // IRP.  This is because the user-mode caller may reuse the endpoint
    // as soon as the IRP completes, and there would be a timing window
    // between reuse of the endpoint and the refresh otherwise.
    //

    AfdRefreshEndpoint( Endpoint );

    //
    // Release the lock before completing the transmit IRP--it is
    // illegal to call IoCompleteRequest while holding a spin lock.
    //

    AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
    AFD_END_STATE_CHANGE (Endpoint);

    //
    // Reset the cancel routine in the IRP before attempting to complete
    // it.
    //

    if ( IoSetCancelRoutine( tpIrp, NULL ) == NULL ) {
        KIRQL cancelIrql;
        //
        // The cancel routine has or is about to run. Synchonize with
        // the cancel routine by acquiring and releasing the cancel
        // and endpoint spinlocks.  The cancel routine won't touch
        // the IRP as it will see that tpInfo pointer was reset in the
        // IRP.
        //
        IoAcquireCancelSpinLock (&cancelIrql);
        ASSERT( tpIrp->Cancel );
        IoReleaseCancelSpinLock (cancelIrql);

    }

    ASSERT (tpIrp->IoStatus.Status==STATUS_SUCCESS);


    checkQueue = (BOOLEAN)(tpIrp->Tail.Overlay.ListEntry.Blink == NULL);

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdCompleteClosePendedTPackets: Completing irp-%p",
                    tpIrp));
    }
    //
    // Finally, we can complete the transmit request.
    //
    UPDATE_ENDPOINT(Endpoint);

    IoCompleteRequest( tpIrp, AfdPriorityBoost );

    //
    // If we're enforcing a maximum active TransmitFile count,
    // and this Irp was counted towards active maximum, then
    // check the list of queued TransmitFile requests and start the
    // next one.
    //

    if( (AfdMaxActiveTransmitFileCount > 0) &&
            checkQueue) {

        AfdStartNextQueuedTransmit();

    }

} // AfdCompleteClosePendedTPackets

#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
BOOLEAN
AfdTPacketsEnableSendAndDisconnect (
    PIRP    TpIrp
    )
/*++

Routine Description:

    Check if combined send and disconnect can be used and update
    endpoint state appropriately

Arguments:

    TpIrp    - transmit packets IRP

Return Value:

    TRUE - S&D can be used, endpoint state updated.
    FALSE - no, use normal disconnect (which updates the state by itself).

--*/
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (TpIrp);
    PAFD_ENDPOINT   endpoint;
    BOOLEAN         res = FALSE;

    endpoint = irpSp->FileObject->FsContext;
    if ( AfdUseTdiSendAndDisconnect &&
                (AFD_GET_TPIC(TpIrp)->Flags & AFD_TF_REUSE_SOCKET) &&
                (endpoint->TdiServiceFlags & TDI_SERVICE_SEND_AND_DISCONNECT)) {
        AFD_LOCK_QUEUE_HANDLE lockHandle;
        ASSERT (IS_VC_ENDPOINT (endpoint));

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        if (!(endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND) &&
                endpoint->Common.VcConnecting.Connection!=NULL &&
                endpoint->Common.VcConnecting.Connection->ConnectDataBuffers==NULL
                ) {
            endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_SEND;
            res = TRUE;
            UPDATE_TPACKETS2 (TpIrp, "Enabling S&D", 0);
        }
        else {
            UPDATE_TPACKETS2 (TpIrp, "Disabling S&D, disconnect mode: 0x%lX", 
                                            endpoint->DisconnectMode);
        }

        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
    }
    else {
        UPDATE_TPACKETS2 (TpIrp, 
                            "Not enabling S&D, flags: 0x%lX",
                            AFD_GET_TPIC(TpIrp)->Flags);
    }

    return res;
}

#endif // TDI_SERVICE_SEND_AND_DISCONNECT

BOOLEAN
AfdQueueTransmit (
    PIRP        Irp
    )
/*++

Routine Description:

    Check transmit IRP can be process immediately or needs to be put
    in the queue because of exceeded simmulteneous send limit

Arguments:

    Irp     - TransmitIrp
Return Value:

    TRUE - Irp was queued (or just completed since it was cancelled before), can't send
    FALSE - We are below the limit, go ahead and send.

--*/
{
    AFD_LOCK_QUEUE_HANDLE   lockHandle;

    AfdAcquireSpinLock (&AfdQueuedTransmitFileSpinLock, &lockHandle);

    if (Irp->Cancel) {
        ASSERT (Irp->Tail.Overlay.ListEntry.Flink==NULL);
        ASSERT (Irp->Tail.Overlay.ListEntry.Blink!=NULL);
        AfdReleaseSpinLock (&AfdQueuedTransmitFileSpinLock, &lockHandle);
        AfdAbortTPackets (Irp, STATUS_CANCELLED);
        DEREFERENCE_TPACKETS (Irp);
        return TRUE;
    }
    else if( AfdActiveTransmitFileCount >= AfdMaxActiveTransmitFileCount ) {

        InsertTailList(
            &AfdQueuedTransmitFileListHead,
            &Irp->Tail.Overlay.ListEntry
            );
        UPDATE_TPACKETS2 (Irp, "Queuing, current count: 0x%lX", AfdActiveTransmitFileCount);

        AfdReleaseSpinLock (&AfdQueuedTransmitFileSpinLock, &lockHandle);
        UPDATE_ENDPOINT (IoGetCurrentIrpStackLocation (Irp)->FileObject->FsContext);
        IF_DEBUG (TRANSMIT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdQueueTransmit: Queuing Irp-%p,endpoint-%p,tp_info-%p\n",
                        Irp,
                        IoGetCurrentIrpStackLocation (Irp)->FileObject->FsContext,
                        Irp->AssociatedIrp.SystemBuffer));
        }
        return TRUE;
    } else {

        AfdActiveTransmitFileCount++;

        ASSERT (Irp->Tail.Overlay.ListEntry.Flink==NULL);
        //
        // Mark the IRP as counted towards maximum (so we start the next
        // one when it is completed);
        //
        Irp->Tail.Overlay.ListEntry.Blink = NULL;
        AfdReleaseSpinLock (&AfdQueuedTransmitFileSpinLock, &lockHandle);
        return FALSE;
    }
}


VOID
AfdStartNextQueuedTransmit(
    VOID
    )
/*++

Routine Description:
  Starts next transmit file in the queue if the number of pending
  request drops below maximum

Arguments:

    None.

Return Value:

    None.

--*/
{

    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY listEntry;
    PIRP irp;
    PAFD_TPACKETS_INFO_INTERNAL    tpInfo;

    //
    // This should only be called if we're actually enforcing a maximum
    // TransmitFile count.
    //

    ASSERT( AfdMaxActiveTransmitFileCount > 0 );

    //
    // The TransmitFile request queue is protected by a
    // spinlock, so grab that lock before examining the queue.
    //

    AfdAcquireSpinLock( &AfdQueuedTransmitFileSpinLock, &lockHandle );

    //
    // This routine is only called after a pended TransmitFile IRP
    // completes, so account for that completion here.
    //

    ASSERT( AfdActiveTransmitFileCount > 0 );
    AfdActiveTransmitFileCount--;

    if( !IsListEmpty( &AfdQueuedTransmitFileListHead ) ) {

        //
        // Dequeue exactly one IRP from the list, then start the
        // TransmitFile.
        //

        listEntry = RemoveHeadList(
                        &AfdQueuedTransmitFileListHead
                        );

        irp = CONTAINING_RECORD(
                  listEntry,
                  IRP,
                  Tail.Overlay.ListEntry
                  );

        tpInfo = irp->AssociatedIrp.SystemBuffer;

        ASSERT( tpInfo != NULL );

        //
        // Mark this TransmitFile request as no longer queued.
        // and counted towards active maximum.
        //

        irp->Tail.Overlay.ListEntry.Flink = NULL;
        irp->Tail.Overlay.ListEntry.Blink = NULL;
        
        //
        // Adjust the count, release the spinlock, then queue the
        // TransmitFile.
        //

        AfdActiveTransmitFileCount++;
        ASSERT( AfdActiveTransmitFileCount <= AfdMaxActiveTransmitFileCount );

    
        UPDATE_TPACKETS2 (irp,"Restarting from queue, count: 0x%lX", AfdActiveTransmitFileCount);
        AfdReleaseSpinLock( &AfdQueuedTransmitFileSpinLock, &lockHandle );

        ASSERT (irp->AssociatedIrp.SystemBuffer!=NULL);
        UPDATE_ENDPOINT (IoGetCurrentIrpStackLocation (irp)->FileObject->FsContext);
        //
        // Schedule the worker for the  transmit.
        //
        AfdStartTPacketsWorker (AfdTPacketsWorker, irp);

    } else {

        //
        // Release the spinlock before returning.
        //

        AfdReleaseSpinLock( &AfdQueuedTransmitFileSpinLock, &lockHandle );
    }

}   // AfdStartNextQueuedTransmit


BOOLEAN
AfdEnqueueTPacketsIrp (
    PAFD_ENDPOINT   Endpoint,
    PIRP            TpIrp
    )
/*++

Routine Description:

    Check if transmit IRP can be process immediately or needs to be put
    in the queue because there is already an active transmit IRP on the
    endpoint.

Arguments:

    Endpoint - endpoint to check
    Irp      - TransmitIrp
Return Value:

    TRUE - Irp was queued, can't send
    FALSE - There are no other IRPs on the endpoint, can send now.

--*/
{
    AFD_LOCK_QUEUE_HANDLE   lockHandle;
    PIRP            oldIrp;
    BOOLEAN         busy = FALSE;

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    //
    // Use interlocked operation since another thread can claim the
    // spot without spinlock if it is NULL.
    // Note, that the IRP field cannot be cleared outside of spinlock 
    // or changed if it is not NULL..
    //
    oldIrp = InterlockedCompareExchangePointer (
                (PVOID *)&Endpoint->Irp,
                TpIrp,
                NULL
                );
    if (oldIrp!=NULL) {
        //
        // Scan till the end of the list.
        //
        while (AFD_GET_TPIC(oldIrp)->Next!=NULL) {
            oldIrp = AFD_GET_TPIRP(AFD_GET_TPIC(oldIrp)->Next);
        }
        //
        // Use interlocked operation to update the pointer
        // to ensure ordering of the memory accesses when we
        // check this field after setting the send flag
        //
        InterlockedExchangePointer (
                (PVOID *)&AFD_GET_TPIC (oldIrp)->Next,
                AFD_GET_TPIC(TpIrp));

        //
        // Another IRP is still pending, check if there are still more sends
        // in that IRP.
        //
        if ((AFD_GET_TPIC(oldIrp)->StateFlags & AFD_TP_SENDS_POSTED)==0) {
            IoSetCancelRoutine (TpIrp, AfdCancelTPackets);
            if (!TpIrp->Cancel && !Endpoint->EndpointCleanedUp) {
                UPDATE_ENDPOINT (Endpoint);
                AFD_GET_TPIC (TpIrp)->StateFlags |= AFD_TP_QUEUED;
                busy = TRUE;
            }
            else {
                TpIrp->Cancel = TRUE;
            }
        }
    }
    AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
    return busy;
}

VOID
AfdStartNextTPacketsIrp (
    PAFD_ENDPOINT   Endpoint,
    PIRP            TpIrp
    )
/*++

Routine Description:

    Check if there are other IRPs enqueued behind the one we about
    to finish with (perform last send) and start it.

Arguments:

    Endpoint - endpoint to check
    Irp      - TransmitIrp
Return Value:
    None.
--*/
{
    AFD_LOCK_QUEUE_HANDLE   lockHandle;

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    ASSERT (AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_SENDS_POSTED);
    while (AFD_GET_TPIC (TpIrp)->Next!=NULL) {
        PIRP    nextIrp = AFD_GET_TPIRP(AFD_GET_TPIC(TpIrp)->Next);
        if ((AFD_GET_TPIC(nextIrp)->StateFlags & AFD_TP_QUEUED)!=0) {
            //
            // Mark IRP is not queued anymore and process it.
            //
            AFD_GET_TPIC(nextIrp)->StateFlags &= ~AFD_TP_QUEUED;
            //
            // If newIrp is a plain send IRP, we need to process it inline.
            //
            if ((AFD_GET_TPIC (nextIrp)->StateFlags & AFD_TP_SEND)!=0) {
                AFD_GET_TPIC(TpIrp)->Next = AFD_GET_TPIC(nextIrp)->Next;
                ASSERT (AFD_GET_TPIC(nextIrp)->ReferenceCount==1);
                AFD_GET_TPIC(nextIrp)->ReferenceCount = 0;
                AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
                AfdSendQueuedTPSend (Endpoint, nextIrp);
                AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
            }
            else {
                AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
                //
                // This IRP couldn't have been counted towards
                // active maximum.
                //
                ASSERT (nextIrp->Tail.Overlay.ListEntry.Blink == (PVOID)1);
                if (nextIrp->AssociatedIrp.SystemBuffer!=NULL) {
                    if( AfdMaxActiveTransmitFileCount == 0 || 
                            !AfdQueueTransmit (nextIrp)) {
                        UPDATE_ENDPOINT (Endpoint);
                        //
                        // Start I/O
                        //

                        AfdStartTPacketsWorker (AfdTPacketsWorker, nextIrp);
                    }
                }
                else {
                    //
                    // We never count DisconnectEx towards active maximum.
                    // Just queue the disconnect.
                    //
                    UPDATE_ENDPOINT (Endpoint);
                    AfdPerformTpDisconnect (nextIrp);
                    DEREFERENCE_TPACKETS (nextIrp);
                }
                return ;
            }
        }
        else {
            //
            // This IRP is probably being cancelled for some reason.
            // Move to the next one.
            //
            ASSERT ((AFD_GET_TPIC(nextIrp)->StateFlags & 
                        (AFD_TP_SEND|AFD_TP_AFD_SEND))==0);
            TpIrp = nextIrp;
        }
    }
    AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
    return ;
}


BOOLEAN
AfdEnqueueTpSendIrp (
    PAFD_ENDPOINT   Endpoint,
    PIRP            SendIrp,
    BOOLEAN         AfdIrp
    )
/*++

Routine Description:

    Check if send IRP can be processed immediately or needs to be put
    in the queue because there is already an active transmit IRP on the
    endpoint.

Arguments:

    Endpoint - endpoint to check
    Irp      - SendIrp
    AfdIrp   - TRUE if IRP was allocated internally by afd
Return Value:

    TRUE - Irp was queued, can't send
    FALSE - There are no other IRPs on the endpoint, can send now.

--*/
{
    AFD_LOCK_QUEUE_HANDLE   lockHandle;
    BOOLEAN         busy = FALSE;

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    //
    // We do not have to use interlocked operation here since we
    // do not synchronize when someone submits send and tpackets
    // from two different threads concurrently.
    //
    if (!Endpoint->EndpointCleanedUp && Endpoint->Irp!=NULL) {
        PIRP            oldIrp;

        oldIrp = Endpoint->Irp;
        //
        // Scan till the end of the list.
        //
        while (AFD_GET_TPIC(oldIrp)->Next!=NULL) {
            oldIrp = AFD_GET_TPIRP(AFD_GET_TPIC(oldIrp)->Next);
        }

        //
        // Another IRP is still pending, check if there are still more sends
        // in that IRP.
        //
        if ((AFD_GET_TPIC(oldIrp)->StateFlags & AFD_TP_SENDS_POSTED)==0) {
            AFD_GET_TPIC(SendIrp)->Next = NULL;
            AFD_GET_TPIC(SendIrp)->Flags = 0;
            AFD_GET_TPIC(SendIrp)->ReferenceCount = 1;
            AFD_GET_TPIC(SendIrp)->StateFlags = AFD_TP_QUEUED| AFD_TP_SEND |
                                                (AfdIrp ? AFD_TP_AFD_SEND : 0);
            //
            // Check application IRP for cancellation.  AFD IRP can never
            // be cancelled since they don't have cancel routine installed.
            //
            if (!AfdIrp) {
                IoMarkIrpPending (SendIrp);
                IoSetCancelRoutine (SendIrp, AfdCancelTPackets);
                if (SendIrp->Cancel) {
                    //
                    // IRP was cancelled, send routine will just complete it.
                    //
                    AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
                    AfdSendQueuedTPSend (Endpoint, SendIrp);
                    return TRUE;
                }
            }
            //
            // Use interlocked operation to update the pointer
            // to ensure ordering of the memory accesses when we
            // check this field after setting the send flag
            //
            InterlockedExchangePointer (
                    (PVOID *)&AFD_GET_TPIC (oldIrp)->Next,
                    AFD_GET_TPIC(SendIrp));

            UPDATE_ENDPOINT (Endpoint);
            busy = TRUE;
        }
    }

    AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
    return busy;
}


VOID
AfdSendQueuedTPSend (
    PAFD_ENDPOINT   Endpoint,
    PIRP            SendIrp
    )
/*++

Routine Description:

    Sumbits the Send IRP in the TPackets IRP queue to the transport.
    Just completes it, if it is canceled or endpoint is cleaned up.

Arguments:

    Endpoint - endpoint to check
    SendIrp  - SendIrp
Return Value:

    None.

--*/
{
    PDRIVER_CANCEL  cancelRoutine;
    cancelRoutine = IoSetCancelRoutine (SendIrp, NULL);
    ASSERT (cancelRoutine==NULL ||
            (AFD_GET_TPIC(SendIrp)->StateFlags & AFD_TP_AFD_SEND)==0);

    if (SendIrp->Cancel ||
            Endpoint->EndpointCleanedUp || 
            (AFD_GET_TPIC(SendIrp)->StateFlags & AFD_TP_ABORT_PENDING)) {
        //
        // If IRP is being cancelled, synchronize with cancel routine
        //
        if (SendIrp->Cancel) {
            KIRQL   cancelIrql;
            AFD_LOCK_QUEUE_HANDLE   lockHandle;
            //
            // AFD IRPs cannot be cancelled - don't have cancel routine and
            // not inserted in thread lists.
            //
            ASSERT ((AFD_GET_TPIC(SendIrp)->StateFlags & AFD_TP_AFD_SEND)==0);
            IoAcquireCancelSpinLock (&cancelIrql);
            IoReleaseCancelSpinLock (cancelIrql);
            AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
            AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
        }
        SendIrp->IoStatus.Status = STATUS_CANCELLED;
        SendIrp->IoStatus.Information = 0;
        UPDATE_ENDPOINT (Endpoint);
#if DBG
        if ((AFD_GET_TPIC(SendIrp)->StateFlags &AFD_TP_AFD_SEND)==0) {
            PIO_STACK_LOCATION  irpSp = IoGetNextIrpStackLocation (SendIrp);
            if (!AfdRecordOutstandingIrpDebug (Endpoint,
                                                irpSp->DeviceObject, 
                                                SendIrp, 
                                                __FILE__, 
                                                __LINE__)) {
                return ;
            }
        }
#endif
        IoSetNextIrpStackLocation (SendIrp);
        IoCompleteRequest (SendIrp, AfdPriorityBoost);
    }
    else {
        PIO_STACK_LOCATION  irpSp = IoGetNextIrpStackLocation (SendIrp);
        UPDATE_ENDPOINT (Endpoint);
        if ((AFD_GET_TPIC(SendIrp)->StateFlags &AFD_TP_AFD_SEND)==0) {
            AfdIoCallDriver (Endpoint, irpSp->DeviceObject, SendIrp);
        }
        else {
            IoCallDriver (irpSp->DeviceObject, SendIrp);
        }
    }
}

VOID
AfdStartTPacketsWorker (
    PWORKER_THREAD_ROUTINE  WorkerRoutine,
    PIRP                    TpIrp
    )
/*++

Routine Description:

  Posts work item to be executed at IRQL above DPC_LEVEL so that
  file system can be accessed.  It uses one of three methods 
  of doing this: special kernel APC, normal kernel APC, or
  system thread (work queue item).

Arguments:

    WorkerRoutine   - routine to execute
    TransmitInfo    - associated transmit info (also parameter to 
                        the worker routine).
Return Value:

    None.

--*/
{
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = TpIrp->AssociatedIrp.SystemBuffer;
    ASSERT ((AFD_GET_TPIC(TpIrp)->StateFlags & AFD_TP_WORKER_SCHEDULED) 
                || (AFD_GET_TPIC(TpIrp)->ReferenceCount==0));

    switch (AFD_GET_TPIC(TpIrp)->Flags & AFD_TF_WORKER_KIND_MASK) {
    case AFD_TF_USE_KERNEL_APC:
        //
        // Initialize normal APC but with normal routine set
        // to special value so we know to run the worker
        // inside the special routine of normal APC and queue it
        //
        KeInitializeApc (&tpInfo->Apc,
                            PsGetThreadTcb (TpIrp->Tail.Overlay.Thread),
                            TpIrp->ApcEnvironment,
                            AfdTPacketsApcKernelRoutine,
                            AfdTPacketsApcRundownRoutine,
                            (PKNORMAL_ROUTINE)-1,
                            KernelMode,
                            NULL
                            );
        if (KeInsertQueueApc (&tpInfo->Apc,
                                (PVOID)WorkerRoutine,
                                TpIrp,
                                AfdPriorityBoost))
            return;
        //
        // If APC cannot be inserted into the queue, drop
        // to use the system worker thread
        //
        break;
    case AFD_TF_USE_SYSTEM_THREAD:
        //
        // This is the default case which is also used if everything else fails,
        // so just break out.
        //
        break;
    default:
        ASSERT (!"Uknown worker type!");
        __assume (0);
    }

    ExInitializeWorkItem (&tpInfo->WorkItem,
                                WorkerRoutine,
                                TpIrp
                                );
    ExQueueWorkItem (&tpInfo->WorkItem, DelayedWorkQueue);
}


VOID
AfdTPacketsApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    )
/*++

Routine Description:

  Special kernel apc routine. Executed in the context of
  the target thread at APC_LEVEL

Arguments:
    NormalRoutine  - pointer containing address of normal routine (it will
                    be NULL for special kernel APC and not NULL for normal
                    kernel APC)

    SystemArgument1 - pointer to the address of worker routine to execute
    SystemArgument2 - pointer to the argument to pass to worker routine

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER (NormalContext);
#if DBG
    try {
        ASSERT (CONTAINING_RECORD (Apc,AFD_TPACKETS_INFO_INTERNAL,Apc)
                    ==((PIRP)*SystemArgument2)->AssociatedIrp.SystemBuffer);
#else
        UNREFERENCED_PARAMETER (Apc);
#endif

        //
        // Normal APC, but we are requested to run in its special
        // routine which avoids raising and lowering IRQL
        //
        ASSERT (*NormalRoutine==(PKNORMAL_ROUTINE)-1);
        *NormalRoutine = NULL;
        ((PWORKER_THREAD_ROUTINE)(ULONG_PTR)*SystemArgument1) (*SystemArgument2);
#if DBG
    }
    except (AfdApcExceptionFilter (GetExceptionInformation (),
                                    __FILE__,
                                    __LINE__)) {
        DbgBreakPoint ();
    }
#endif
}


VOID
AfdTPacketsApcRundownRoutine (
    IN struct _KAPC *Apc
    )
/*++

Routine Description:

  APC rundown routine. Executed if APC cannot be delivered for
  some reason (thread exiting).
  We just fall back to system threads to execute the worker

Arguments:

    Apc     - APC structure

Return Value:

    None.

--*/
{
    PIRP    tpIrp;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo;
    PWORKER_THREAD_ROUTINE      workerRoutine;
#if DBG
    try {
#endif

    workerRoutine = (PWORKER_THREAD_ROUTINE)(ULONG_PTR)Apc->SystemArgument1;
    tpIrp = Apc->SystemArgument2;
    tpInfo = tpIrp->AssociatedIrp.SystemBuffer;

    ASSERT (tpInfo==CONTAINING_RECORD (Apc,AFD_TPACKETS_INFO_INTERNAL,Apc));

    ExInitializeWorkItem (&tpInfo->WorkItem,
                                workerRoutine,
                                tpIrp
                                );
    ExQueueWorkItem (&tpInfo->WorkItem, DelayedWorkQueue);
#if DBG
    }
    except (AfdApcExceptionFilter (GetExceptionInformation (),
                                    __FILE__,
                                    __LINE__)) {
        DbgBreakPoint ();
    }
#endif
}


BOOLEAN
AfdGetTPacketsReference (
    PIRP Irp
    )
/*++

Routine Description:

    Obtain a reference to the TPackets IRP if it is not 0.

Arguments:

    Irp - IRP to reference

Return Value:

    TRUE - succeeded
    FALSE - IRP is on the completion path, no need to reference.

--*/
{
    LONG   count;

    //
    // Only if transmit info is not completed yet, cancel all the IRPs
    // We release the spinlock while cancelling the IRP, so we need
    // to make sure that one of the cancelled IRPs won't initiate
    // completion while we trying to cancel the other IRPs
    //
    do {
        count = AFD_GET_TPIC(Irp)->ReferenceCount;
        if (count==0) {
            break;
        }
    }
    while (InterlockedCompareExchange ((PLONG)
        &AFD_GET_TPIC(Irp)->ReferenceCount,
        (count+1),
        count)!=count);

    return (BOOLEAN)(count!=0);
}

//
// Debug reference/dereference code, validates reference count
// and saves tracing information.
//
#if REFERENCE_DEBUG
VOID
AfdReferenceTPackets (
    IN PIRP  Irp,
    IN LONG  LocationId,
    IN ULONG Param
    )
{                                                     
    LONG   count; 

    do {                 
        count = AFD_GET_TPIC(Irp)->ReferenceCount;
        ASSERT (count>0);
    }                                             
    while (InterlockedCompareExchange ((PLONG)
            &AFD_GET_TPIC(Irp)->ReferenceCount,
            (count+1),
            count)!=count);

    if (Irp->AssociatedIrp.SystemBuffer) {
        AFD_UPDATE_REFERENCE_DEBUG (
                (PAFD_TPACKETS_INFO_INTERNAL)Irp->AssociatedIrp.SystemBuffer,
                count+1,
                LocationId, 
                Param);
    }

}

LONG
AfdDereferenceTPackets (
    IN PIRP  Irp,
    IN LONG  LocationId,
    IN ULONG Param
    )
{                                                     
    LONG    count;

    if (Irp->AssociatedIrp.SystemBuffer) {
        AFD_UPDATE_REFERENCE_DEBUG (
                (PAFD_TPACKETS_INFO_INTERNAL)Irp->AssociatedIrp.SystemBuffer,
                AFD_GET_TPIC(Irp)->ReferenceCount-1,
                LocationId,
                Param);
    }

    count = InterlockedDecrement ((PLONG)
                &AFD_GET_TPIC(Irp)->ReferenceCount);
    ASSERT (count>=0);                      
    return count;
}

VOID
AfdUpdateTPacketsTrack (
    IN PIRP  Irp,
    IN LONG  LocationId,
    IN ULONG Param
    )
{
    if (Irp->AssociatedIrp.SystemBuffer) {
        AFD_UPDATE_REFERENCE_DEBUG (
                (PAFD_TPACKETS_INFO_INTERNAL)Irp->AssociatedIrp.SystemBuffer,
                AFD_GET_TPIC(Irp)->ReferenceCount,
                LocationId,
                Param);
    }
}
#endif // REFERENCE_DEBUG


PAFD_TPACKETS_INFO_INTERNAL
FASTCALL
AfdGetTpInfoFast (
    ULONG   ElementCount
    )
{
    PAFD_TPACKETS_INFO_INTERNAL tpInfo;

    ASSERT (ElementCount<=(MAXULONG/sizeof (AFD_TRANSMIT_PACKETS_ELEMENT)));

    tpInfo = ExAllocateFromNPagedLookasideList(&AfdLookasideLists->TpInfoList);
    if (tpInfo!=NULL) {
        ASSERT (tpInfo->ReadIrp==NULL);
        ASSERT (tpInfo->NumSendIrps==AFD_TP_MIN_SEND_IRPS);

        tpInfo->HeadMdl = NULL;
        tpInfo->TailMdl = &tpInfo->HeadMdl;
        tpInfo->HeadPd = NULL;
        tpInfo->TailPd = &tpInfo->HeadPd;
        tpInfo->PdLength = 0;
        tpInfo->PdNeedsPps = FALSE;
        tpInfo->NextElement = 0;
        tpInfo->RemainingPkts = MAXULONG;

#if REFERENCE_DEBUG
        tpInfo->CurrentReferenceSlot = -1;
        RtlZeroMemory (&tpInfo->ReferenceDebug, 
                            sizeof (tpInfo->ReferenceDebug));
#endif
#if AFD_PERF_DBG
        tpInfo->WorkersExecuted = 0;
#endif
        if (ElementCount<=AfdDefaultTpInfoElementCount) {
            return tpInfo;
        }

        try {
            tpInfo->ElementArray =
                    AFD_ALLOCATE_POOL_WITH_QUOTA (
                        NonPagedPool,
                        ElementCount*sizeof (AFD_TRANSMIT_PACKETS_ELEMENT),
                        AFD_TRANSMIT_INFO_POOL_TAG);
            tpInfo->ArrayAllocated = TRUE;
            return tpInfo;
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
        }
        AfdReturnTpInfo (tpInfo);
    }

    return NULL;
}

#ifdef _AFD_VARIABLE_STACK_
PAFD_TPACKETS_INFO_INTERNAL
FASTCALL
AfdGetTpInfoWithMaxStackSize (
    ULONG   ElementCount
    )
{
    ULONG   size;
    PVOID   memoryBlock;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo;

    size = AfdComputeTpInfoSize (ElementCount, AfdMaxStackSize);
    if (size<ElementCount*sizeof (AFD_TRANSMIT_PACKETS_ELEMENT)) {
        return NULL;
    }

    memoryBlock = AFD_ALLOCATE_POOL (
                    NonPagedPool,
                    size,
                    AFD_TRANSMIT_INFO_POOL_TAG);

    if (memoryBlock==NULL) {
        return NULL;
    }

    tpInfo = AfdInitializeTpInfo (memoryBlock, ElementCount, AfdMaxStackSize);
    tpInfo->HeadMdl = NULL;
    tpInfo->TailMdl = &tpInfo->HeadMdl;
    tpInfo->HeadPd = NULL;
    tpInfo->TailPd = &tpInfo->HeadPd;
    tpInfo->PdLength = 0;
    tpInfo->PdNeedsPps = FALSE;
    tpInfo->NextElement = 0;
    tpInfo->RemainingPkts = MAXULONG;

#if REFERENCE_DEBUG
    tpInfo->CurrentReferenceSlot = -1;
    RtlZeroMemory (&tpInfo->ReferenceDebug, 
                        sizeof (tpInfo->ReferenceDebug));
#endif
#if AFD_PERF_DBG
    tpInfo->WorkersExecuted = 0;
#endif
    return tpInfo;
}

#endif // _AFD_VARIABLE_STACK_
VOID
AfdReturnTpInfo (
    PAFD_TPACKETS_INFO_INTERNAL TpInfo
    )
{
    ULONG   i;

    //
    // Validate that built-in send IRPs are properly deinitialized.
    //

#if DBG
    for (i=0; i<AFD_TP_MIN_SEND_IRPS; i++) {
        ASSERT (TpInfo->SendIrp[i]->MdlAddress == NULL);
        ASSERT (TpInfo->SendIrp[i]->Overlay.AsynchronousParameters.UserApcContext == NULL);
        ASSERT (TpInfo->SendIrp[i]->Cancel==FALSE);
    }
#endif

    //
    // Dispose of extra allocated IRPs.
    //
    while (TpInfo->NumSendIrps>AFD_TP_MIN_SEND_IRPS) {
        TpInfo->NumSendIrps -= 1;
        if (TpInfo->SendIrp[TpInfo->NumSendIrps]!=NULL) {
            IoFreeIrp (TpInfo->SendIrp[TpInfo->NumSendIrps]);
            TpInfo->SendIrp[TpInfo->NumSendIrps] = NULL;
        }
    }

    if (TpInfo->ReadIrp!=NULL) {
        IoFreeIrp (TpInfo->ReadIrp);
        TpInfo->ReadIrp = NULL;
    }


    //
    // Cleanup all file objects and MDLs that we may have already referenced
    //
    for (i=0; i<TpInfo->ElementCount; i++) {
        PAFD_TRANSMIT_PACKETS_ELEMENT  pel;

        pel = &TpInfo->ElementArray[i];
        if (pel->Flags & TP_FILE) {
            if (pel->FileObject!=NULL) {
                ObDereferenceObject( pel->FileObject );
                AfdRecordFileDeref();
            }
        }
        else if (pel->Flags & TP_MDL) {
            ASSERT (pel->Flags & TP_MEMORY);
            if (pel->Mdl!=NULL) {
                if (pel->Mdl->MdlFlags & MDL_PAGES_LOCKED) {
                    MmUnlockPages (pel->Mdl);
                }
                IoFreeMdl (pel->Mdl);
            }
        }
    }

    //
    // Free non-default sized array of packets if necessary.
    //
    if (TpInfo->ArrayAllocated) {
        AFD_FREE_POOL (TpInfo->ElementArray, AFD_TRANSMIT_INFO_POOL_TAG);
        TpInfo->ElementArray = ALIGN_UP_TO_TYPE_POINTER (
                        (PUCHAR)TpInfo+sizeof (AFD_TPACKETS_INFO_INTERNAL),
                        AFD_TRANSMIT_PACKETS_ELEMENT);
        TpInfo->ArrayAllocated = FALSE;
    }
    else {
        ASSERT (TpInfo->ElementCount<=AfdDefaultTpInfoElementCount);
        ASSERT (TpInfo->ElementArray == ALIGN_UP_TO_TYPE_POINTER (
                        (PUCHAR)TpInfo+sizeof (AFD_TPACKETS_INFO_INTERNAL),
                        AFD_TRANSMIT_PACKETS_ELEMENT));
    }

#if AFD_PERF_DBG
    InterlockedExchangeAdd (&AfdTPWorkersExecuted, TpInfo->WorkersExecuted);
    InterlockedIncrement (&AfdTPRequests);
#endif
#ifdef _AFD_VARIABLE_STACK_
    if (TpInfo->SendIrp[0]->StackCount==AfdTdiStackSize) {
#else  // _AFD_VARIABLE_STACK_
        ASSERT (TpInfo->SendIrp[0]->StackCount==AfdTdiStackSize);
#endif // _AFD_VARIABLE_STACK_
        ExFreeToNPagedLookasideList( &AfdLookasideLists->TpInfoList, TpInfo );
#ifdef _AFD_VARIABLE_STACK_
    }
    else {
        ASSERT (TpInfo->SendIrp[0]->StackCount>AfdTdiStackSize);
        ASSERT (TpInfo->SendIrp[0]->StackCount<=AfdMaxStackSize);
        AfdFreeTpInfo (TpInfo);
    }
#endif // _AFD_VARIABLE_STACK_
}


ULONG
AfdComputeTpInfoSize (
    ULONG   ElementCount,
    CCHAR   IrpStackCount
    )
{
    USHORT  irpSize = (USHORT)ALIGN_UP_TO_TYPE(IoSizeOfIrp (IrpStackCount), IRP);
    return 
        ALIGN_UP_TO_TYPE(
            ALIGN_UP_TO_TYPE (
                sizeof (AFD_TPACKETS_INFO_INTERNAL),
                AFD_TRANSMIT_PACKETS_ELEMENT ) +
            ElementCount*sizeof (AFD_TRANSMIT_PACKETS_ELEMENT),
            IRP ) +
        irpSize*AFD_TP_MIN_SEND_IRPS;
}

PVOID
AfdAllocateTpInfo (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    Used by the lookaside list allocation function to allocate a new
    AFD TpInfo structure.  The returned structure will be fully
    initialized.

Arguments:

    PoolType - passed to ExAllocatePoolWithTag.

    NumberOfBytes - the number of bytes required for the tp info structure

    Tag - passed to ExAllocatePoolWithTag.

Return Value:

    PVOID - a fully initialized TpInfo, or NULL if the allocation
        attempt fails.

--*/

{
    PVOID memoryBlock;
    memoryBlock = AFD_ALLOCATE_POOL (
                    PoolType,
                    NumberOfBytes,
                    Tag);

    if (memoryBlock!=NULL) {
        AfdInitializeTpInfo (memoryBlock, AfdDefaultTpInfoElementCount, AfdTdiStackSize);
    }
    return memoryBlock;
}

PAFD_TPACKETS_INFO_INTERNAL
AfdInitializeTpInfo (
    PVOID   MemoryBlock,
    ULONG   ElementCount,
    CCHAR   StackSize
    )
{
    USHORT  irpSize = IoSizeOfIrp (StackSize);
    LONG    i;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = MemoryBlock;

    RtlZeroMemory (tpInfo, sizeof (*tpInfo));

    tpInfo->ElementArray = ALIGN_UP_TO_TYPE_POINTER (
                    (PUCHAR)tpInfo+sizeof (AFD_TPACKETS_INFO_INTERNAL),
                    AFD_TRANSMIT_PACKETS_ELEMENT);

    tpInfo->NumSendIrps = AFD_TP_MIN_SEND_IRPS;
    tpInfo->SendIrp[0] = ALIGN_UP_TO_TYPE_POINTER (
                                &tpInfo->ElementArray[ElementCount],
                                IRP);
    IoInitializeIrp (tpInfo->SendIrp[0], irpSize, StackSize);
    tpInfo->SendIrp[0]->Overlay.AsynchronousParameters.UserApcRoutine = (PVOID)0;
    for (i=1; i<AFD_TP_MIN_SEND_IRPS; i++) {
        tpInfo->SendIrp[i] = ALIGN_UP_TO_TYPE_POINTER (
                                (PUCHAR)tpInfo->SendIrp[i-1]+irpSize,
                                IRP);
        IoInitializeIrp (tpInfo->SendIrp[i], irpSize, StackSize);
        tpInfo->SendIrp[i]->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE)(UINT_PTR)i;
    }

    return tpInfo;
}


VOID
NTAPI
AfdFreeTpInfo (
    PVOID   TpInfo
    )
{
    ASSERT (((PAFD_TPACKETS_INFO_INTERNAL)TpInfo)->ElementArray == ALIGN_UP_TO_TYPE_POINTER (
                    (PUCHAR)TpInfo+sizeof (AFD_TPACKETS_INFO_INTERNAL),
                    AFD_TRANSMIT_PACKETS_ELEMENT));
    AFD_FREE_POOL (TpInfo, AFD_TRANSMIT_INFO_POOL_TAG);
}




/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *            T R A N S M I T   F I L E   I M P L E M E N T A T I O N
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


NTSTATUS
AfdRestartFastTransmitSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
AfdDoMdlReadComplete (
    PVOID   Context
    );

VOID
AfdFastTransmitApcRundownRoutine (
    IN struct _KAPC *Apc
    );

VOID
AfdFastTransmitApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdFastTransmitFile )
#pragma alloc_text( PAGEAFD, AfdRestartFastTransmitSend )
#pragma alloc_text( PAGE, AfdFastTransmitApcKernelRoutine )
#pragma alloc_text( PAGE, AfdFastTransmitApcRundownRoutine )
#pragma alloc_text( PAGE, AfdDoMdlReadComplete )
#pragma alloc_text( PAGE, AfdTransmitFile )
#pragma alloc_text( PAGE, AfdSuperDisconnect )
#endif


BOOLEAN
AfdFastTransmitFile (
    IN PAFD_ENDPOINT endpoint,
    IN PAFD_TRANSMIT_FILE_INFO transmitInfo,
    OUT PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    Attempts to perform a fast TransmitFile call.  This will succeed
    only if the caller requests write behind, the file data to be sent
    is small, and the data is in the file system cache.

Arguments:

    endpoint - the endpoint of interest.

    transmitInfo - AFD_TRANSMIT_FILE_INFO structure.

    IoStatus - points to the IO status block that will be set on successful
        return from this function.

Return Value:

    TRUE if the fast path was successful; FALSE if we need to do through
    the normal path.

--*/

{
    PAFD_CONNECTION connection;
    PAFD_BUFFER afdBuffer;
    ULARGE_INTEGER sendLength;
    PFILE_OBJECT fileObject;
    BOOLEAN success;
    BOOLEAN sendCountersUpdated;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    ULONG fileWriteLength, bufferLength;
    NTSTATUS status;
    LARGE_INTEGER fileOffset;
    PMDL fileMdl;
    PIRP irp;

    //
    // If the endpoint is shut down in any way, bail out of fast IO.
    //

    if ( endpoint->DisconnectMode != 0 ||
            endpoint->Type != AfdBlockTypeVcConnecting ||
            endpoint->State != AfdEndpointStateConnected ) {
        return FALSE;
    }

    //
    // If the TDI provider for this endpoint supports bufferring,
    // don't use fast IO.
    //

    if ( IS_TDI_BUFFERRING(endpoint) ) {
        return FALSE;
    }

    //
    // Make sure that the flags are specified such that a fast-path
    // TransmitFile is reasonable.  The caller must have specified
    // the write-behind flag, but not the disconnect or reuse
    // socket flags.
    //

    if ( ((transmitInfo->Flags &
                (~(AFD_TF_WRITE_BEHIND |
                   AFD_TF_DISCONNECT |
                   AFD_TF_REUSE_SOCKET |
                   AFD_TF_WORKER_KIND_MASK))) != 0 ) ||
            ((transmitInfo->Flags & AFD_TF_WORKER_KIND_MASK)
                    == AFD_TF_WORKER_KIND_MASK) ||
            ((transmitInfo->Flags &(~AFD_TF_WORKER_KIND_MASK))
                    != AFD_TF_WRITE_BEHIND) ) {
        return FALSE;
    }

    IF_DEBUG(FAST_IO) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFastTransmitFile: attempting fast IO on endp %p, "
                    "conn %p\n", endpoint, endpoint->Common.VcConnecting.Connection));
    }


    //
    // Initialize locals so that cleanup is easier.
    //

    fileObject = NULL;
    sendCountersUpdated = FALSE;
    fileMdl = NULL;
    afdBuffer = NULL;
    AFD_W4_INIT irp = NULL; // Depends on variable above, but compiler does not see
                            // the connection.

    //
    // Calculate the length the entire send.
    //

    if (transmitInfo->FileHandle!=NULL) {
        fileWriteLength = transmitInfo->WriteLength.LowPart;
    }
    else {
        fileWriteLength = 0;
    }

    sendLength.QuadPart = (ULONGLONG)transmitInfo->HeadLength +
                            (ULONGLONG)fileWriteLength +
                            (ULONGLONG)transmitInfo->TailLength;

    //
    // Require the following for the fast path:
    //
    //    - There be no limitation on the count of simultaneous
    //      TransmitFile calls.  The fast path would work around
    //      this limit, if it exists.
    //    - The caller must specify the write length (if it specified file at all).
    //    - The write length must be less than the configured maximum.
    //    - If the entire send is larger than an AFD buffer page,
    //      we're going to use FsRtlMdlRead, so for purposes of
    //      simplicity there must be:
    //        - a head buffer, and
    //        - no tail buffer
    //    - The configured maximum will always be less than 4GB.
    //    - The head buffer, if any, fits on a single page.
    //

    if (AfdMaxActiveTransmitFileCount != 0

             ||

         (transmitInfo->FileHandle!=NULL &&
            (fileWriteLength == 0 ||
             transmitInfo->Offset.QuadPart <0 ))

             ||

         sendLength.QuadPart > AfdMaxFastTransmit

             ||

         ( sendLength.LowPart > AfdMaxFastCopyTransmit &&
               (transmitInfo->HeadLength == 0 ||
                transmitInfo->TailLength != 0 ) )

             ||

         transmitInfo->WriteLength.HighPart != 0

             ||

         transmitInfo->HeadLength > AfdBufferLengthForOnePage ) {

        return FALSE;
    }

    
    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    connection = endpoint->Common.VcConnecting.Connection;
    if (connection==NULL) {
        //
        // connection might have been cleaned up by transmit file.
        //
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        return FALSE;
    }
    ASSERT( connection->Type == AfdBlockTypeConnection );

    //
    // Determine whether there is already too much send data
    // pending on the connection.  If there is too much send
    // data, don't do the fast path.
    //

    if ( AfdShouldSendBlock( endpoint, connection, sendLength.LowPart ) ) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        goto complete;
    }
    //
    // Add a reference to the connection object since the send
    // request will complete asynchronously.
    //
    REFERENCE_CONNECTION( connection );

    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);


    //
    // AfdShouldSendBlock() updates the send counters in the AFD
    // connection object.  Remember this fact so that we can clean
    // them up if the fast path fails after this point.
    //

    sendCountersUpdated = TRUE;

    //
    // Grab an AFD buffer large enough to hold the entire send.
    //

    if (sendLength.LowPart>AfdMaxFastCopyTransmit) {
        bufferLength = transmitInfo->HeadLength;
    }
    else {
        bufferLength = sendLength.LowPart;
    }

    if (bufferLength<max (sizeof(KAPC),sizeof (WORK_QUEUE_ITEM))) {
        bufferLength = max (sizeof(KAPC),sizeof (WORK_QUEUE_ITEM));
    }

    afdBuffer = AfdGetBuffer( endpoint, bufferLength, 0,
                                    connection->OwningProcess );
    if ( afdBuffer == NULL ) {
        goto complete;
    }

    //
    // Initialize buffer fields for proper cleanup.
    //

    irp = afdBuffer->Irp;
    afdBuffer->Irp->Tail.Overlay.Thread = NULL;
    afdBuffer->FileObject = NULL;

    //
    // We use exception handler because buffers are user
    // mode pointers
    //
    try {

        //
        // Copy in the head and tail buffers, if necessary.  Note that if we
        // are goint to use MDL read, then there cannot be a tail buffer because of
        // the check at the beginning of this function.
        //

        if ( transmitInfo->HeadLength > 0 ) {
            RtlCopyMemory(
                afdBuffer->Buffer,
                transmitInfo->Head,
                transmitInfo->HeadLength
                );
        }

        if ( transmitInfo->TailLength > 0 ) {
            RtlCopyMemory(
                (PCHAR)afdBuffer->Buffer + transmitInfo->HeadLength +
                    fileWriteLength,
                transmitInfo->Tail,
                transmitInfo->TailLength
                );
        }

    } except( AFD_EXCEPTION_FILTER_NO_STATUS() ) {

        goto complete;
    }

    if (transmitInfo->FileHandle!=NULL) {
        //
        // Get a referenced pointer to the file object for the file that
        // we're going to transmit.  This call will fail if the file
        // handle specified by the caller is invalid.
        //

        status = ObReferenceObjectByHandle(
                     transmitInfo->FileHandle,
                     FILE_READ_DATA,
                     *IoFileObjectType,
                     ExGetPreviousMode (),
                     (PVOID *)&fileObject,
                     NULL
                     );
        if ( !NT_SUCCESS(status) ) {
            goto complete;
        }
        AfdRecordFileRef();

        //
        // If the file system doesn't support the fast cache manager
        // interface, bail and go through the IRP path.
        //

        if( !AFD_USE_CACHE(fileObject)) {
            goto complete;
        }

        //
        // Grab the file offset into a local so that we know that the
        // offset pointer we pass to FsRtlCopyRead is valid.
        //

        fileOffset = transmitInfo->Offset;

        if ( (fileObject->Flags & FO_SYNCHRONOUS_IO) &&
                 (fileOffset.QuadPart == 0) ) {
            //
            // Use current offset if file is opened syncronously
            // and offset is not specified.
            //

            fileOffset = fileObject->CurrentByteOffset;
        }
        //
        // Get the file data.  If the amount of file data is small, copy
        // it directly into the AFD buffer.  If it is large, get an MDL
        // chain for the data and chain it on to the AFD buffer chain.
        //

        if ( sendLength.LowPart <= AfdMaxFastCopyTransmit ) {

            success = FsRtlCopyRead(
                          fileObject,
                          &fileOffset,
                          fileWriteLength,
                          FALSE,
                          0,
                          (PCHAR)afdBuffer->Buffer + transmitInfo->HeadLength,
                          IoStatus,
                          IoGetRelatedDeviceObject( fileObject )
                          );

            //
            // We're done with the file object, so deference it now.
            //

            ObDereferenceObject( fileObject );
            AfdRecordFileDeref();
            fileObject = NULL;

            if ( !success ) {
#if AFD_PERF_DBG
                InterlockedIncrement (&AfdFastTfReadFailed);
#endif
                goto complete;
            }

        } else {

            success = FsRtlMdlRead(
                          fileObject,
                          &fileOffset,
                          fileWriteLength,
                          0,
                          &fileMdl,
                          IoStatus
                          );

            if (success) {
                //
                // Save the file object in the AFD buffer.  The send restart
                // routine will handle dereferencing the file object and
                // returning the file MDLs to the system.
                //

                afdBuffer->FileObject = fileObject;
                afdBuffer->FileOffset = fileOffset;

                //
                // If caller asked us to use kernel APC to execute the request,
                // allocate and queue the IRP to the current thread to make 
                // sure it won't go away until IRP is completed.
                //
                if ((((transmitInfo->Flags & AFD_TF_WORKER_KIND_MASK)
                                    == AFD_TF_USE_KERNEL_APC) ||
                        (((transmitInfo->Flags & AFD_TF_WORKER_KIND_MASK)
                                == AFD_TF_USE_DEFAULT_WORKER) &&
                                (AfdDefaultTransmitWorker==AFD_TF_USE_KERNEL_APC))) ) {
                    //
                    // Allocation will occur right before we call the
                    // transport, set IRP to null to trigger this.
                    // 
                    irp = NULL;
                }
            }
            else {
#if AFD_PERF_DBG
                InterlockedIncrement (&AfdFastTfReadFailed);
#endif
                goto complete;
            }
        }

        //
        // If we read less information than was requested, we must have
        // hit the end of the file.  Fail the transmit request, since
        // this can only happen if the caller requested that we send
        // more data than the file currently contains.
        //

        if ( IoStatus->Information < fileWriteLength ) {
            goto complete;
        }
     }

    //
    // We have to rebuild the MDL in the AFD buffer structure to
    // represent exactly the number of bytes we're going to be
    // sending.  If the AFD buffer has all the send data, indicate
    // that.  If we did MDL file I/O, then chain the file data on
    // to the head MDL.
    //

    if ( fileMdl == NULL ) {
        afdBuffer->Mdl->ByteCount = sendLength.LowPart;
    } else {
        afdBuffer->Mdl->ByteCount = transmitInfo->HeadLength;
        afdBuffer->Mdl->Next = fileMdl;
    }

    //
    // We can have only one transmit file operation on endpoint
    // at a time.  Treat is as a state change
    //
    if (AFD_START_STATE_CHANGE (endpoint, endpoint->State)) {

        //
        // Verify state under protection of state change flag
        //
        if (endpoint->State!=AfdEndpointStateConnected) {
            AFD_END_STATE_CHANGE (endpoint);
            goto complete;
        }

        //
        // Save connection to dereference in completion routine.
        //
        afdBuffer->Context = connection;

        if (irp==NULL) {
            //
            // Need to allocate IRP and let the io subsystem queue
            // it to the current thread, so we can run APC upon
            // IRP completion.
            //
            irp = TdiBuildInternalDeviceControlIrp (
                            TDI_SEND,
                            connection->DeviceObject,
                            connection->FileObject,
                            NULL,
                            &AfdDontCareIoStatus   // we will have our completion
                            // routine installed in the IRP which will get the
                            // status, so we do not care if IO system writes
                            // it there for us, but still must provide valid
                            // storage to avoid failure.
                            );
                    
            if (irp==NULL) {
                //
                // Could not allocate IRP, use worker threads
                //
                irp = afdBuffer->Irp;
            }
        }
        else {
            ASSERT (irp==afdBuffer->Irp);
        }

        //
        // Use the IRP in the AFD buffer structure to give to the TDI
        // provider.  Build the TDI send request.
        //

        TdiBuildSend(
            irp,
            connection->DeviceObject,
            connection->FileObject,
            AfdRestartFastTransmitSend,
            afdBuffer,
            afdBuffer->Mdl,
            0,
            sendLength.LowPart
            );

        IF_DEBUG (TRANSMIT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdFastTransmit: Starting send for endp-%p,file-%p,"
                        "afdBuffer-%p,length-%ld.\n",
                        endpoint,fileObject,(PVOID)afdBuffer,sendLength.LowPart));
        }

        //
        // Call the transport to actually perform the send.
        //

        status = IoCallDriver( connection->DeviceObject, irp );


        AFD_END_STATE_CHANGE (endpoint);

        //
        // The fast path succeeded--complete the call.  Note that we
        // change the status code from what was returned by the TDI
        // provider into STATUS_SUCCESS.  This is because we don't want
        // to complete the IRP with STATUS_PENDING etc.
        //

        if ( NT_SUCCESS(status) ) {
            IoStatus->Information = sendLength.LowPart;
            IoStatus->Status = STATUS_SUCCESS;

            return TRUE;
        }
        else {
            // The restart routine will handle cleanup
            // and we cannot duplicate cleanup in the
            // case of a failure or exception below.
            //
            return FALSE;
        }
    }

    //
    // The call failed for some reason.  Fail fast IO.
    //


complete:

    if ( fileMdl != NULL ) {
        ASSERT (afdBuffer!=NULL);
        status = AfdMdlReadComplete( fileObject, fileMdl, &fileOffset );
        if (!NT_SUCCESS (status)) {
            afdBuffer->Context = connection;
            REFERENCE_CONNECTION (connection);
            ASSERT (afdBuffer->FileObject==fileObject);
            ASSERT (afdBuffer->Mdl->Next==fileMdl);
            ASSERT (afdBuffer->FileOffset.QuadPart==fileOffset.QuadPart);
            AfdLRMdlReadComplete (&afdBuffer->Header);
            afdBuffer = NULL;
            fileObject = NULL;
        }
    }

    if ( fileObject != NULL ) {
        ObDereferenceObject( fileObject );
        AfdRecordFileDeref();
    }

    if ( afdBuffer != NULL ) {
        ASSERT ((irp==NULL) || (irp==afdBuffer->Irp));
        afdBuffer->Mdl->Next = NULL;
        afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;
        AfdReturnBuffer( &afdBuffer->Header, connection->OwningProcess );
    }

    if ( sendCountersUpdated ) {
        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
        connection->VcBufferredSendBytes -= sendLength.LowPart;
        connection->VcBufferredSendCount -= 1;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        DEREFERENCE_CONNECTION (connection);
    }

    return FALSE;

} // AfdFastTransmitFile

NTSTATUS
AfdRestartFastTransmitSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

  This is the completion routine for fast transmit send IRPs.
  It initiates the completion of the request.

Arguments:

    DeviceObject - ignored.

    Irp - the send IRP that is completing.

    Context - a pointer to the AfdBuffer structure with the buffer that
            was sent.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED which indicates to the I/O system
    that it should stop completion processing of this IRP.  User request
    has already been completed on the fast path, we just free resources here.

--*/
{
    PAFD_BUFFER     afdBuffer = Context;
    PAFD_CONNECTION connection = afdBuffer->Context;
    NTSTATUS        status = STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER (DeviceObject);
    IF_DEBUG (TRANSMIT) {
       KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartFastTransmitSend: Completing send for file-%p,"
                    "afdBuffer-%p,status-%lx.\n",
                    afdBuffer->FileObject,(PVOID)afdBuffer,Irp->IoStatus.Status));
    }

    AfdProcessBufferSend (connection, Irp);

    //
    // If file object is not NULL we need to
    // return MDL back to file system driver/cache
    //
    if (afdBuffer->FileObject!=NULL) {

        //
        // If we used a separate IRP, then
        // the caller requested that we do processing
        // inside kernel APC, otherwise, we are using
        // system worker threads.
        //
        if (afdBuffer->Irp!=Irp) {
            //
            // The IRP is owned by IO subsystem.
            // We must let it complete and free the IRP, hence
            // return STATUS_SUCCESS and remove MDL field as IO
            // subsytem cannot handle non-paged pool memory in MDL
            //
            status = STATUS_SUCCESS;
            Irp->MdlAddress = NULL;

            //
            // If IRP was not cancelled, attempt to initialize and queue APC
            // Otherwise, the thread is probably exiting and we won't be
            // able to queue apc anyway.
            //
            if (!Irp->Cancel) {
                ASSERT (afdBuffer->BufferLength>=sizeof(KAPC));
                KeInitializeApc (afdBuffer->Buffer,
                                    PsGetThreadTcb (Irp->Tail.Overlay.Thread),
                                    Irp->ApcEnvironment,
                                    AfdFastTransmitApcKernelRoutine,
                                    AfdFastTransmitApcRundownRoutine,
                                    (PKNORMAL_ROUTINE)-1,
                                    KernelMode,
                                    NULL
                                    );
                if (KeInsertQueueApc (afdBuffer->Buffer,
                                        afdBuffer,
                                        afdBuffer->FileObject,
                                        AfdPriorityBoost)) {
                    //
                    // Success, we are done.
                    //
                    goto exit;
                }
            }

            //
            // Can't queue APC, revert to system worker threads
            //
        }

        ASSERT (afdBuffer->BufferLength>=sizeof(WORK_QUEUE_ITEM));
        ExInitializeWorkItem (
                    (PWORK_QUEUE_ITEM)afdBuffer->Buffer,
                    AfdDoMdlReadComplete,
                    afdBuffer
                    );
        ExQueueWorkItem (afdBuffer->Buffer, DelayedWorkQueue);
    }
    else {

        ASSERT (afdBuffer->Irp==Irp);
        ASSERT (afdBuffer->Mdl->Next == NULL);
        afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;
        AfdReturnBuffer( &afdBuffer->Header, connection->OwningProcess );
        DEREFERENCE_CONNECTION (connection);
    }

exit:
    return status;
}

VOID
AfdFastTransmitApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    )
/*++

Routine Description:

  Special kernel apc routine. Executed in the context of
  the target thread at APC_LEVEL

Arguments:
    NormalRoutine  - pointer containing address of normal routine (it will
                    be NULL for special kernel APC and not NULL for normal
                    kernel APC)

    SystemArgument1 - pointer to the address of worker routine to execute
    SyetemArgument2 - pointer to the argument to pass to worker routine

Return Value:

    None.

--*/
{
    PAFD_BUFFER     afdBuffer;
    
    UNREFERENCED_PARAMETER (NormalContext);
    PAGED_CODE ();

    afdBuffer = *SystemArgument1;
#if DBG
    try {
        ASSERT (Apc==afdBuffer->Buffer);
        ASSERT (afdBuffer->FileObject==*SystemArgument2);
#else
        UNREFERENCED_PARAMETER (Apc);
        UNREFERENCED_PARAMETER (SystemArgument2);
#endif

    //
    // Normal APC, but we are requested to run in its special
    // routine which avoids raising and lowering IRQL
    //

    ASSERT (*NormalRoutine==(PKNORMAL_ROUTINE)-1);
    *NormalRoutine = NULL;
    AfdDoMdlReadComplete (afdBuffer);
#if DBG
    }
    except (AfdApcExceptionFilter (GetExceptionInformation (),
                                    __FILE__,
                                    __LINE__)) {
        DbgBreakPoint ();
    }
#endif
}


VOID
AfdFastTransmitApcRundownRoutine (
    IN struct _KAPC *Apc
    )
/*++

Routine Description:

  APC rundown routine. Executed if APC cannot be delivered for
  some reason (thread exiting).
  We just fall back to system threads to execute the worker

Arguments:

    Apc     - APC structure

Return Value:

    None.

--*/
{
    PAFD_BUFFER                 afdBuffer;

    PAGED_CODE ();
#if DBG
    try {
#endif
    afdBuffer = Apc->SystemArgument1;
    ASSERT (Apc==afdBuffer->Buffer);
    ASSERT (afdBuffer->FileObject==Apc->SystemArgument2);

    //
    // APC could not be run, revert to system worker thread
    //

    ExInitializeWorkItem (
                (PWORK_QUEUE_ITEM)afdBuffer->Buffer,
                AfdDoMdlReadComplete,
                afdBuffer
                );

    ExQueueWorkItem (afdBuffer->Buffer, DelayedWorkQueue);
#if DBG
    }
    except (AfdApcExceptionFilter (GetExceptionInformation (),
                                    __FILE__,
                                    __LINE__)) {
        DbgBreakPoint ();
    }
#endif
}

VOID
AfdDoMdlReadComplete (
    PVOID   Context
    )
{
    PAFD_BUFFER     afdBuffer = Context;
    PAFD_CONNECTION connection = afdBuffer->Context;
    NTSTATUS        status;

    PAGED_CODE ();

    //
    // Return mdl to the file system
    //
    status = AfdMdlReadComplete(
        afdBuffer->FileObject,
        afdBuffer->Mdl->Next,
        &afdBuffer->Irp->Overlay.AllocationSize
        );
    if (NT_SUCCESS (status)) {
        //
        // Release file object reference (the AfdMdlReadComplete makes its own
        // reference if it needs to return MDL asynchronously.
        //
        ObDereferenceObject( afdBuffer->FileObject );
        AfdRecordFileDeref();

        afdBuffer->Mdl->Next = NULL;
        afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;
        AfdReturnBuffer( &afdBuffer->Header, connection->OwningProcess );
        DEREFERENCE_CONNECTION (connection);
    }
    else {
        AfdLRMdlReadComplete (&afdBuffer->Header);
    }
}


NTSTATUS
FASTCALL
AfdTransmitFile (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Initial entrypoint for handling transmit file IRPs.  This routine
    verifies parameters, initializes data structures to be used for
    the request, and initiates the I/O.

Arguments:

    Irp - a pointer to a transmit file IRP.

    IrpSp - Our stack location for this IRP.

Return Value:

    STATUS_PENDING if the request was initiated successfully, or a
    failure status code if there was an error.

--*/

{
    PAFD_ENDPOINT endpoint;
    NTSTATUS status;
    AFD_TRANSMIT_FILE_INFO params;
    PAFD_TPACKETS_INFO_INTERNAL tpInfo = NULL;
    PAFD_TRANSMIT_PACKETS_ELEMENT  pel;
    PAFD_CONNECTION connection;
    BOOLEAN fileError = FALSE;

    PAGED_CODE ();

    //
    // Initial request validity checks: is the endpoint connected, is
    // the input buffer large enough, etc.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Special hack to let the user mode dll know that it
    // should try SAN provider instead.
    //

    if (IS_SAN_ENDPOINT (endpoint)) {
        status = STATUS_INVALID_PARAMETER_12;
        goto complete;
    }

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                 sizeof(AFD_TRANSMIT_FILE_INFO32) ) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
    }
    else
#endif _WIN64
    {
        if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                 sizeof(AFD_TRANSMIT_FILE_INFO) ) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
    }

    //
    // Because we're using type 3 (neither) I/O for this IRP, the I/O
    // system does no verification on the user buffer.  Therefore, we
    // must manually check it for validity inside a try-except block.
    // We also leverage the try-except to validate and lock down the
    // head and/or tail buffers specified by the caller.
    //

    AFD_W4_INIT status = STATUS_SUCCESS;
    try {


#ifdef _WIN64
        if (IoIs32bitProcess (Irp)) {
            PAFD_TRANSMIT_FILE_INFO32 pInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
            if( Irp->RequestorMode != KernelMode ) {

                //
                // Validate the control buffer.
                //

                ProbeForReadSmallStructure(
                    pInfo,
                    sizeof(AFD_TRANSMIT_FILE_INFO32),
                    PROBE_ALIGNMENT32 (AFD_TRANSMIT_FILE_INFO32)
                    );
            }
            params.Offset = pInfo->Offset;
            params.WriteLength = pInfo->WriteLength;
            params.SendPacketLength = pInfo->SendPacketLength;
            params.FileHandle = pInfo->FileHandle;
            params.Head = UlongToPtr(pInfo->Head);
            params.HeadLength = pInfo->HeadLength;
            params.Tail = UlongToPtr(pInfo->Tail);
            params.TailLength = pInfo->TailLength;
            params.Flags = pInfo->Flags;
        }
        else
#endif _WIN64
        {
            if( Irp->RequestorMode != KernelMode ) {
                //
                // Validate the control buffer.
                //

                ProbeForReadSmallStructure(
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    sizeof(AFD_TRANSMIT_FILE_INFO),
                    PROBE_ALIGNMENT (AFD_TRANSMIT_FILE_INFO)
                    );
            }

            params = *((PAFD_TRANSMIT_FILE_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);
        }


        
        //
        // Validate any flags specified in the request.
        // and make sure that file offset is positive (of course if file is specified)
        //

        if ( ((params.Flags &
                 ~(AFD_TF_WRITE_BEHIND | AFD_TF_DISCONNECT | AFD_TF_REUSE_SOCKET | AFD_TF_WORKER_KIND_MASK) )
                     != 0 ) ||
                ((params.Flags & AFD_TF_WORKER_KIND_MASK) == AFD_TF_WORKER_KIND_MASK) ||
                (params.FileHandle!=NULL && params.Offset.QuadPart<0)){
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        //
        // If transmit worker is not specified, use system default setting
        //
        if ((params.Flags & AFD_TF_WORKER_KIND_MASK)==AFD_TF_USE_DEFAULT_WORKER) {
            params.Flags |= AfdDefaultTransmitWorker;
        }

            
        tpInfo = AfdGetTpInfo (endpoint, 3);
        if (tpInfo==NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete;
        }

        tpInfo->ElementCount = 0;

        tpInfo->SendPacketLength = params.SendPacketLength;
        if (tpInfo->SendPacketLength==0)
            tpInfo->SendPacketLength = AfdTransmitIoLength;
        //
        // If the caller specified head and/or tail buffers, probe and
        // lock the buffers so that we have MDLs we can use to send the
        // buffers.
        //

        if ( params.HeadLength > 0 ) {
            pel = &tpInfo->ElementArray[tpInfo->ElementCount++];
            pel->Buffer = params.Head;
            pel->Length = params.HeadLength;
            pel->Flags = TP_MEMORY;

            if (params.Flags & AFD_TF_USE_SYSTEM_THREAD) {
                pel->Flags |= TP_MDL;
                pel->Mdl = IoAllocateMdl(
                                        params.Head,
                                        params.HeadLength,
                                        FALSE,         // SecondaryBuffer
                                        TRUE,          // ChargeQuota
                                        NULL           // Irp
                                        );
                if ( pel->Mdl == NULL ) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto complete;
                }

                MmProbeAndLockPages( pel->Mdl, Irp->RequestorMode, IoReadAccess );
            }
        }

        if (params.FileHandle!=NULL) {
            pel = &tpInfo->ElementArray[tpInfo->ElementCount++];
            pel->Flags = TP_FILE;
            pel->FileOffset = params.Offset;
            
            //
            // Get a referenced pointer to the file object for the file that
            // we're going to transmit.  This call will fail if the file handle
            // specified by the caller is invalid.
            //

            status = ObReferenceObjectByHandle(
                         params.FileHandle,
                         FILE_READ_DATA,
                         *IoFileObjectType,
                         Irp->RequestorMode,
                         (PVOID *)&pel->FileObject,
                         NULL
                         );
            if ( !NT_SUCCESS(status) ) {
                //
                // Unbump element count, so that uninitialied memory
                // is NOT improperly dereferenced in cleanup.
                //
                tpInfo->ElementCount -= 1;
                //
                // Tell the caller that we encountered an error
                // when accessing file not socket.
                //
                if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength>=sizeof (BOOLEAN)) {
                    if (Irp->RequestorMode != KernelMode) {
                        ProbeAndWriteBoolean ((BOOLEAN *)Irp->UserBuffer, TRUE);
                    }
                    else {
                        *((BOOLEAN *)Irp->UserBuffer) = TRUE;
                    }
                }
                goto complete;
            }

            AfdRecordFileRef();


            //
            // Use pre-allocated buffers by default when
            // file is not cached
            //
            if (params.SendPacketLength==0 && !AFD_USE_CACHE(pel->FileObject)) {
                tpInfo->SendPacketLength = AfdLargeBufferSize;
            }

            if ( (pel->FileObject->Flags & FO_SYNCHRONOUS_IO) &&
                     (pel->FileOffset.QuadPart == 0) ) {
                //
                // Use current offset if file is opened syncronously
                // and offset is not specified.
                //

                pel->FileOffset = pel->FileObject->CurrentByteOffset;
            }

            if ( params.WriteLength.QuadPart == 0 ) {
                //
                // Length was not specified, figure out the
                // size of the entire file
                //

                FILE_STANDARD_INFORMATION fileInfo;
                IO_STATUS_BLOCK ioStatusBlock;

                status = ZwQueryInformationFile(
                             params.FileHandle,
                             &ioStatusBlock,
                             &fileInfo,
                             sizeof(fileInfo),
                             FileStandardInformation
                             );
                if ( !NT_SUCCESS(status) ) {
                    fileError = TRUE;
                    goto complete;
                }

                //
                // Make sure that offset is within the file
                //
                if (pel->FileOffset.QuadPart<0 
                                ||
                        pel->FileOffset.QuadPart>fileInfo.EndOfFile.QuadPart 
                                ||
                        (fileInfo.EndOfFile.QuadPart
                                - pel->FileOffset.QuadPart>MAXLONG)) {
                    status = STATUS_INVALID_PARAMETER;
                    fileError = TRUE;
                    goto complete;

                }
                pel->Length = (ULONG)(fileInfo.EndOfFile.QuadPart - pel->FileOffset.QuadPart);
            }
            else if (params.WriteLength.QuadPart<=MAXLONG &&
                        pel->FileOffset.QuadPart>=0) {
                pel->Length = (ULONG)params.WriteLength.QuadPart;
            }
            else {
                status = STATUS_INVALID_PARAMETER;
                fileError = TRUE;
                goto complete;
            }
        }


        if ( params.TailLength > 0 ) {

            pel = &tpInfo->ElementArray[tpInfo->ElementCount++];
            pel->Buffer = params.Tail;
            pel->Length = params.TailLength;
            pel->Flags = TP_MEMORY;

            if (params.Flags & AFD_TF_USE_SYSTEM_THREAD) {
                pel->Flags |= TP_MDL;
                pel->Mdl = IoAllocateMdl(
                                        params.Tail,
                                        params.TailLength,
                                        FALSE,         // SecondaryBuffer
                                        TRUE,          // ChargeQuota
                                        NULL           // Irp
                                        );
                if ( pel->Mdl == NULL ) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto complete;
                }

                MmProbeAndLockPages( pel->Mdl, Irp->RequestorMode, IoReadAccess );
            }
        }

        AFD_GET_TPIC(Irp)->Flags = params.Flags;

    } except( AFD_EXCEPTION_FILTER (status) ) {
        ASSERT (NT_ERROR (status));
        goto complete;
    }


    //
    // If disconnect is desired, send the state change to make sure
    // we can only perform one at a time and validate the state of
    // the endpoint.
    //
    if (AFD_GET_TPIC(Irp)->Flags & (AFD_TF_REUSE_SOCKET|AFD_TF_DISCONNECT)) {
        if (!AFD_START_STATE_CHANGE (endpoint, endpoint->State)) {
            status = STATUS_INVALID_CONNECTION;
            goto complete;
        }

        if ( endpoint->Type != AfdBlockTypeVcConnecting ||
                 endpoint->State != AfdEndpointStateConnected ) {
            status = STATUS_INVALID_CONNECTION;
            goto complete_state_change;
        }
        //
        // Setting AFD_TF_REUSE_SOCKET implies that a disconnect is desired.
        // Also, setting this flag means that no more I/O is legal on the
        // endpoint until the transmit request has been completed, so
        // set up the endpoint's state so that I/O fails.
        //
        if ( (AFD_GET_TPIC(Irp)->Flags & AFD_TF_REUSE_SOCKET) != 0 ) {
            AFD_GET_TPIC(Irp)->Flags |= AFD_TF_DISCONNECT;
            endpoint->State = AfdEndpointStateTransmitClosing;
        }
        connection = endpoint->Common.VcConnecting.Connection;
        REFERENCE_CONNECTION (connection);
    }
    else {
        if (!AFD_PREVENT_STATE_CHANGE (endpoint)) {
            status = STATUS_INVALID_CONNECTION;
            goto complete;
        }
        //
        // We still need validate the state of the endpoint
        // even if we do not perform the disconnect.
        //
        if ( endpoint->Type != AfdBlockTypeVcConnecting ||
                 endpoint->State != AfdEndpointStateConnected ) {
            AFD_REALLOW_STATE_CHANGE (endpoint);
            status = STATUS_INVALID_CONNECTION;
            goto complete;
        }
        connection = endpoint->Common.VcConnecting.Connection;
        REFERENCE_CONNECTION (connection);
        AFD_REALLOW_STATE_CHANGE (endpoint);
    }


    //
    // Connection endpoint, get connection file object and device
    //
    tpInfo->TdiFileObject = connection->FileObject;
    tpInfo->TdiDeviceObject = connection->DeviceObject;

    UPDATE_TPACKETS2 (Irp, "Connection object handle: 0x%lX",
                                HandleToUlong(connection->Handle));
    //
    // Save tpacket info in the IRP
    //
    Irp->AssociatedIrp.SystemBuffer = tpInfo;

    //
    // Clear the Flink in the IRP to indicate this IRP is not queued.
    // Blink is set to indicate that IRP was not counted towards
    // active maximum (so if it is completed, we do not start the next one).
    //

    Irp->Tail.Overlay.ListEntry.Flink = NULL;
    Irp->Tail.Overlay.ListEntry.Blink = (PVOID)1;

    //
    // Initialize the IRP result fields
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    // We are going to pend this IRP
    //
    IoMarkIrpPending( Irp );

    //
    // Initialize queuing and state information.
    //
    AFD_GET_TPIC (Irp)->Next = NULL;
    AFD_GET_TPIC(Irp)->ReferenceCount = 1;
    AFD_GET_TPIC(Irp)->StateFlags = AFD_TP_WORKER_SCHEDULED;

    if ((InterlockedCompareExchangePointer ((PVOID *)&endpoint->Irp,
                                                Irp,
                                                NULL)==NULL) ||
            !AfdEnqueueTPacketsIrp (endpoint, Irp)) {


        IoSetCancelRoutine( Irp, AfdCancelTPackets );
        //
        //  Check to see if this Irp has been cancelled.
        //

        if ( !endpoint->EndpointCleanedUp && !Irp->Cancel ) {
            //
            // Determine if we can really start this file transmit now. If we've
            // exceeded the configured maximum number of active TransmitFile/Packets
            // requests, then append this IRP to the TransmitFile/Packets queue and set
            // a flag in the transmit info structure to indicate that this IRP
            // is queued.
            //

            if( AfdMaxActiveTransmitFileCount == 0 || !AfdQueueTransmit (Irp)) {
                //
                // Start I/O
                //
                UPDATE_ENDPOINT(endpoint);
                AfdTPacketsWorker (Irp);
            }

        }
        else {
            //
            // Abort the request
            // Note that neither cancel nor endpoint cleanup can complete 
            // the IRP since we hold the reference to the tpInfo structure.
            //
            AfdAbortTPackets (Irp, STATUS_CANCELLED);
        
            //
            // Remove the initial reference and force completion.
            //
            DEREFERENCE_TPACKETS (Irp);
        }
    }

    DEREFERENCE_CONNECTION (connection);
    return STATUS_PENDING;


complete_state_change:

    ASSERT ( tpInfo != NULL );
    ASSERT ( endpoint->Irp != Irp );
    AFD_END_STATE_CHANGE (endpoint);

complete:

    //
    // If necessary, tell the caller that we encountered an error
    // when accessing file not socket.
    //

    if (fileError && IrpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(BOOLEAN)) {
        if (Irp->RequestorMode != KernelMode) {
            try {
                ProbeAndWriteBoolean((BOOLEAN *)Irp->UserBuffer, TRUE);
            } except(AFD_EXCEPTION_FILTER(status)) {
                ASSERT(NT_ERROR(status));
            }
        }
        else {
            *((BOOLEAN *)Irp->UserBuffer) = TRUE;
        }
    }

    if (tpInfo!=NULL) {
        AfdReturnTpInfo (tpInfo);
    }

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTransmitPackets: Failing Irp-%p,endpoint-%p,status-%lx\n",
                    Irp,endpoint,status));
    }

    //
    // Complete the request.
    //

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, 0 );

    return status;

} // AfdTransmitFile


NTSTATUS
FASTCALL
AfdSuperDisconnect (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Initial entrypoint for handling transmit file IRPs.  This routine
    verifies parameters, initializes data structures to be used for
    the request, and initiates the I/O.

Arguments:

    Irp - a pointer to a transmit file IRP.

    IrpSp - Our stack location for this IRP.

Return Value:

    STATUS_PENDING if the request was initiated successfully, or a
    failure status code if there was an error.

--*/

{
    PAFD_ENDPOINT endpoint;
    NTSTATUS status;
    AFD_SUPER_DISCONNECT_INFO params;

    PAGED_CODE ();

    //
    // Initial request validity checks: is the endpoint connected, is
    // the input buffer large enough, etc.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Special hack to let the user mode dll know that it
    // should try SAN provider instead.
    //

    if (IS_SAN_ENDPOINT (endpoint)) {
        status = STATUS_INVALID_PARAMETER_12;
        goto complete;
    }

    //
    // Because we're using type 3 (neither) I/O for this IRP, the I/O
    // system does no verification on the user buffer.  Therefore, we
    // must manually check it for validity inside a try-except block.
    // We also leverage the try-except to validate and lock down the
    // head and/or tail buffers specified by the caller.
    //

    AFD_W4_INIT status = STATUS_SUCCESS;
    try {


#ifdef _WIN64
        if (IoIs32bitProcess (Irp)) {
            PAFD_SUPER_DISCONNECT_INFO32 pInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
            if( Irp->RequestorMode != KernelMode ) {

                //
                // Validate the control buffer.
                //

                ProbeForReadSmallStructure(
                    pInfo,
                    sizeof(AFD_SUPER_DISCONNECT_INFO32),
                    PROBE_ALIGNMENT32 (AFD_SUPER_DISCONNECT_INFO32)
                    );
            }
            params.Flags = ((PAFD_SUPER_DISCONNECT_INFO32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->Flags;
        }
        else
#endif _WIN64
        {
            if( Irp->RequestorMode != KernelMode ) {
                //
                // Validate the control buffer.
                //

                ProbeForReadSmallStructure(
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    sizeof(AFD_SUPER_DISCONNECT_INFO),
                    PROBE_ALIGNMENT (AFD_SUPER_DISCONNECT_INFO)
                    );
            }

            params = *((PAFD_SUPER_DISCONNECT_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);
        }

       
        //
        // Validate any flags specified in the request.
        // and make sure that file offset is positive (of course if file is specified)
        //

        if ( (params.Flags & (~AFD_TF_REUSE_SOCKET)) != 0 ){
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

    } except( AFD_EXCEPTION_FILTER (status) ) {
        ASSERT (NT_ERROR (status));
        goto complete;
    }

    //
    // Store disconnect parameters/flags in the IRP.
    // AFD_TF_DISCONNECT implied in the API

    AFD_GET_TPIC(Irp)->Flags = params.Flags | AFD_TF_DISCONNECT;

    if (!AFD_START_STATE_CHANGE (endpoint, endpoint->State)) {
        status = STATUS_INVALID_CONNECTION;
        goto complete;
    }



    //
    // Allow disconnect if we are in connected state or
    // in transmit closing (the previous transmit file/packets
    // with reuse must have failed) and reuse is requested.
    // The second condition still allows the application to reuse aborted 
    // or otherwise failed socket.
    //
    if (endpoint->Type == AfdBlockTypeVcConnecting &&
            (endpoint->State == AfdEndpointStateConnected ||
                (endpoint->State == AfdEndpointStateTransmitClosing &&
                    (params.Flags & AFD_TF_REUSE_SOCKET)!=0 
                ) 
             ) 
        ) {
        //
        // Setting AFD_TF_REUSE_SOCKET implies that a disconnect is desired.
        // Also, setting this flag means that no more I/O is legal on the
        // endpoint until the transmit request has been completed, so
        // set up the endpoint's state so that I/O fails.
        //

        if ( (params.Flags & AFD_TF_REUSE_SOCKET) != 0 ) {
            endpoint->State = AfdEndpointStateTransmitClosing;
        }
    }
    else {
        status = STATUS_INVALID_CONNECTION;
        goto complete_state_change;
    }




    //
    // Set tpacket info to NULL to indicate pure disconnect IRP
    //
    Irp->AssociatedIrp.SystemBuffer = NULL;

    //
    // Clear the Flink in the IRP to indicate this IRP is not queued.
    // Blink is set to indicate that IRP was not counted towards
    // active maximum (so if it is completed, we do not start the next one).
    //

    Irp->Tail.Overlay.ListEntry.Flink = NULL;
    Irp->Tail.Overlay.ListEntry.Blink = (PVOID)1;

    //
    // Initialize the IRP result fields
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    // We are going to pend this IRP
    //
    IoMarkIrpPending( Irp );

    //
    // Initialize queuing and state information.
    //
    AFD_GET_TPIC (Irp)->Next = NULL;
    AFD_GET_TPIC(Irp)->ReferenceCount = 1;
    AFD_GET_TPIC(Irp)->StateFlags = AFD_TP_WORKER_SCHEDULED;

    if ((InterlockedCompareExchangePointer ((PVOID *)&endpoint->Irp,
                                                Irp,
                                                NULL)==NULL) ||
            !AfdEnqueueTPacketsIrp (endpoint, Irp)) {


        IoSetCancelRoutine( Irp, AfdCancelTPackets );
        //
        //  Check to see if this Irp has been cancelled.
        //

        if ( !endpoint->EndpointCleanedUp && !Irp->Cancel ) {
            //
            // Start I/O
            //
            UPDATE_ENDPOINT (endpoint);
            AfdPerformTpDisconnect (Irp);
        }
        else {
            //
            // Abort the request
            // Note that neither cancel nor endpoint cleanup can complete 
            // the IRP since we hold the reference to the tpInfo structure.
            //
            AfdAbortTPackets (Irp, STATUS_CANCELLED);
        
        }

        //
        // Remove the initial reference and force completion processing.
        //

        DEREFERENCE_TPACKETS (Irp);
    }


    return STATUS_PENDING;


complete_state_change:

    ASSERT ( endpoint->Irp != Irp );
    AFD_END_STATE_CHANGE (endpoint);

complete:

    IF_DEBUG (TRANSMIT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSuperDisconnect: Failing Irp-%p,endpoint-%p,status-%lx\n",
                    Irp,endpoint,status));
    }
    //
    // Complete the request.
    //

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, 0 );

    return status;

} // AfdSuperDisconnect


VOID
AfdPerformTpDisconnect (
    PIRP    TpIrp
    )
/*++

Routine Description:

    DisconnectEx engine
Arguments:

    TpIrp - pointer to TransmitPackets Irp for the request

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation (TpIrp);
    PAFD_ENDPOINT       endpoint = irpSp->FileObject->FsContext;
    NTSTATUS            status;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    status = AfdBeginDisconnect(
              endpoint,
              NULL,
              NULL
              );

    if (NT_SUCCESS (status)) {
        IF_DEBUG (TRANSMIT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdPerformTpDisconnect: Initiated disconnect, tpIrp-%p,status-%lx\n",
                        TpIrp, status));
        }

    }
    else {
        //
        // Disconnect failed, we'll have to abort below.
        //
        IF_DEBUG (TRANSMIT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdPerformTpDisconnect: TpInfo-%p, begin discon failed: %lx\n",
                        TpIrp, status));
        }
        AfdAbortTPackets (TpIrp, status);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\cons.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    cons.h

Abstract:

    Global constant definitions for the AFD.SYS Kernel Debugger
    Extensions.

Author:

    Keith Moore (keithmo) 19-Apr-1995.

Environment:

    User Mode.

--*/


#ifndef _CONS_H_
#define _CONS_H_


#define MAX_TRANSPORT_ADDR  256
#define MAX_ADDRESS_STRING  64
#define Address00           Address[0].Address[0]
#define UC(x)               ((UINT)((x) & 0xFF))
#define NTOHS(x)            ( (UC(x) * 256) + UC((x) >> 8) )
#define NTOHL(x)            ( ( ((x))              << (8*3)) | \
							  ( ((x) & 0x0000FF00) << (8*1)) | \
							  ( ((x) & 0x00FF0000) >> (8*1)) | \
							  ( ((x))              >> (8*3)) )

#define PTR64_BITS  44
#define PTR64_MASK  ((1I64<<PTR64_BITS)-1)
#define PTR32_BITS  32
#define PTR32_MASK  ((1I64<<PTR32_BITS)-1)
#define DISP_PTR(x) (IsPtr64() ? (ULONG64)((x)&PTR64_MASK):(ULONG64)((x)&PTR32_MASK))

#define MAX_ADDRESS_EXPRESSION      256
#define MAX_FIELD_CHARS             256
#define MAX_NUM_FIELDS              32
#define MAX_FIELDS_EXPRESSION       1024
#define MAX_CONDITIONAL_EXPRESSION  1024

#define AFDKD_BRIEF_DISPLAY         0x00000001
#define AFDKD_NO_DISPLAY            0x00000002
#define AFDKD_RADDR_DISPLAY         0x00000004
#define AFDKD_FIELD_DISPLAY         0x00000008

#define AFDKD_BACKWARD_SCAN         0x00000010
#define AFDKD_ENDPOINT_SCAN         0x00000020
#define AFDKD_CONDITIONAL           0x00000040
#define AFDKD_LIST_COUNT            0x00000080

#define AFDKD_LINK_FIELD            0x00000100
#define AFDKD_LINK_AOF              0x00000200
#define AFDKD_LINK_SELF             0x00000400
#define AFDKD_LIST_TYPE             0x00000800

#define AFDKD_MSWSOCK_DISPLAY       0x00001000
#define AFDKD_SYNTCB_DISPLAY        0x00100000
#define AFDKD_TWTCB_DISPLAY         0x00200000

#define AFDKD_CPP_PREFIX            "@@"
#define AFDKD_CPP_PREFSZ            (sizeof (AFDKD_CPP_PREFIX)-1)

#define AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER32   \
"\nEndpoint Typ State  Flags     Transport LPort   Counts    Evt Pid  Con/RAdr"
// xxxxxxxx xxx xxx xxxxxxxxxxxx xxxxxxxxx xxxxx xx xx xx xx xxx xxxx xxxxxxxx

#define AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER64   \
"\nEndpoint    Typ State  Flags     Transport LPort   Counts    Evt Pid  Con/RemAddr"
// xxxxxxxxxxx xxx xxx xxxxxxxxxxxx xxxxxxxxx xxxxx xx xx xx xx xxx xxxx xxxxxxxxxxx

#define AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER     (IsPtr64()  \
            ? AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER64         \
            : AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER32)

#define AFDKD_BRIEF_ENDPOINT_DISPLAY_TRAILER \
"\nFlags: Nblock,Inline,clEaned-up,Polled,routeQuery,-fastSnd,-fastRcv,Adm.access"\
"\n     SD_rECV,SD_rEND,SD_bOTH,SD_aBORT,Listen,Circ.que,Half.conn,#-dg.drop mask"\
"\n     p,m,f-ctx xfer pending,more,failed;i-implicit dupe"\
"\nCounts: Dg/Con(bytes)-buffered snd,rcv; Lstn(cons)-free,AccEx,pending,unacc"\
"\n     SANendp-reqID, select events; SANhlpr-plsn, pending requests"\
"\n"



#define AFDKD_BRIEF_CONNECTION_DISPLAY_HEADER32 \
"\nConnectn Stat Flags  SndB-cnt RcvB-cnt Pid  Endpoint Remote Address"\
// xxxxxxxx xxx xxxxxxx xxxxx-xx xxxxx-xx xxxx xxxxxxxx xxxxxxxxxxxxxx"

#define AFDKD_BRIEF_CONNECTION_DISPLAY_HEADER64 \
"\nConnection  Stat Flags  SndB-cnt RcvB-cnt Pid  Endpoint    Remote Address"\
// xxxxxxxxxxx xxx xxxxxxx xxxxx-xx xxxxx-xx xxxx xxxxxxxxxxx xxxxxxxxxxxxxx

#define AFDKD_BRIEF_CONNECTION_DISPLAY_HEADER   (IsPtr64()  \
            ? AFDKD_BRIEF_CONNECTION_DISPLAY_HEADER64       \
            : AFDKD_BRIEF_CONNECTION_DISPLAY_HEADER32)

#define AFDKD_BRIEF_CONNECTION_DISPLAY_TRAILER \
"\nFlags: Abort-,Disc-indicated,+cRef,Special-cond,Cleaning,Tpack closing,Lr-list"\
"\n"

#define AFDKD_BRIEF_TPACKETS_DISPLAY_HEADER32 \
"\nTPackets    I    R      P      S    Endpoint   Flags             Next Elmt Mo"\
"\nAddress  Transmit Send Arr   Read   Address  App | State         Elmt Cnt. re"\
// xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxx xxxxxxxxxxxxxx xxxx xxxx xx

#define AFDKD_BRIEF_TPACKETS_DISPLAY_HEADER64 \
"\nTPackets      I    R     P     S        Endpoint      Flags             Next Elmt Mo"\
"\nAddress     Transmit    SAr   Read      Address     App | State         Elmt Cnt. re"\
// xxxxxxxxxxx xxxxxxxxxxx xxx xxxxxxxxxxx xxxxxxxxxxx xxxx xxxxxxxxxxxxxx xxxx xxxx xx

#define AFDKD_BRIEF_TPACKETS_DISPLAY_HEADER   (IsPtr64()    \
            ? AFDKD_BRIEF_TPACKETS_DISPLAY_HEADER64         \
            : AFDKD_BRIEF_TPACKETS_DISPLAY_HEADER32)


#define AFDKD_BRIEF_TPACKETS_DISPLAY_TRAILER \
"\nApp flags: b-write Behind,d-Disconnect,r-Reuse,s-system threads,a-kernel APCs"\
"\nState flags: A-Abort,W-Work,S-Sent,Q-Qued,&-s&d,0-reading,1-8-sending"\
"\n"

#define AFDKD_BRIEF_TRANFILE_DISPLAY_HEADER \
"\nTranInfo    I        R        P        S     Endpoint  Flags  Cur.Read Read"\
"\nAddress  Transmit   Send1    Send2    Read   Address          Offset   End "\
"\n"

#define AFDKD_BRIEF_TRANFILE_DISPLAY_TRAILER \
"\nFlags: A-aborting,W-work pending,H-head,R-reusing,S-S&D,1-send1,2-send2,3-read"\
"\n"

#define AFDKD_BRIEF_BUFFER_DISPLAY_HEADER32 \
"\nBuffer   Buff Data Data Context  Mdl|IRP  Flags  Remote Address"\
"\nAddress  Size Size Offs Status   Address                       "\
// xxxxxxxx xxxx xxxx xxxx xxxxxxxx xxxxxxxx xxxxxx xxxxxxxx:xxxxxxxxxxxx:xxxx

#define AFDKD_BRIEF_BUFFER_DISPLAY_HEADER64 \
"\nBuffer      Buff Data Data Context     Mdl | IRP   Flags  Remote Address"\
"\nAddress     Size Size Offs Status      Address                          "\
// xxxxxxxxxxx xxxx xxxx xxxx xxxxxxxxxxx xxxxxxxxxxx xxxxxx xxxxxxxx:xxxxxxxxxxxx:xxxx

#define AFDKD_BRIEF_BUFFER_DISPLAY_HEADER   (IsPtr64()    \
            ? AFDKD_BRIEF_BUFFER_DISPLAY_HEADER64         \
            : AFDKD_BRIEF_BUFFER_DISPLAY_HEADER32)


#define AFDKD_BRIEF_BUFFER_DISPLAY_TRAILER                  \
"\nFlags: E-expedited,P-partial,L-lookaside,N-ndis packet  "\
"\n       first: h-header,i-irp,m-mdl,b-buffer             "\
"\n"

#define AFDKD_BRIEF_POLL_DISPLAY_HEADER32 \
"\nPollInfo   IRP     Thread  (pid.tid) Expires in   Flg Hdls Array"\
// xxxxxxxx xxxxxxxx xxxxxxxx xxxx:xxxx xx:xx:xx.xxx xxx xxxx xxxxxxxx

#define AFDKD_BRIEF_POLL_DISPLAY_HEADER64 \
"\nPollInfo        IRP       Thread    (pid.tid) Expires in   Flg Hdls Array"\
// xxxxxxxxxxx xxxxxxxxxxx xxxxxxxxxxx xxxx:xxxx xx:xx:xx.xxx xxx xxxx xxxxxxxxxxx

#define AFDKD_BRIEF_POLL_DISPLAY_HEADER   (IsPtr64()    \
            ? AFDKD_BRIEF_POLL_DISPLAY_HEADER64         \
            : AFDKD_BRIEF_POLL_DISPLAY_HEADER32)


#define AFDKD_BRIEF_POLL_DISPLAY_TRAILER        \
"\nFlags: T-timer started, U-unique, S-SAN poll"\
"\n"


#define AFDKD_BRIEF_ADDRLIST_DISPLAY_HEADER32   \
"\nAddrLEnt Device Name                           Address"\
// xxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

#define AFDKD_BRIEF_ADDRLIST_DISPLAY_HEADER64   \
"\nAddrLEntry  Device Name                           Address"\
// xxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

#define AFDKD_BRIEF_ADDRLIST_DISPLAY_HEADER   (IsPtr64()\
            ? AFDKD_BRIEF_ADDRLIST_DISPLAY_HEADER64     \
            : AFDKD_BRIEF_ADDRLIST_DISPLAY_HEADER32)

#define AFDKD_BRIEF_ADDRLIST_DISPLAY_TRAILER            \
"\n"


#define AFDKD_BRIEF_TRANSPORT_DISPLAY_HEADER32  \
"\nTranInfo Device Name                    RefC Ver Max.Send MaxDg Flags"\
// xxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxx xxx xxxxxxxx xxxxx xxxxx-xxxxxxxxx

#define AFDKD_BRIEF_TRANSPORT_DISPLAY_HEADER64  \
"\nTranInfo    Device Name                    RefC Ver Max.Send MaxDg Flags"\
// xxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxx xxx xxxxxxxx xxxxx xxxxx-xxxxxxxxx

#define AFDKD_BRIEF_TRANSPORT_DISPLAY_HEADER   (IsPtr64()   \
            ? AFDKD_BRIEF_TRANSPORT_DISPLAY_HEADER64        \
            : AFDKD_BRIEF_TRANSPORT_DISPLAY_HEADER32)

#define AFDKD_BRIEF_TRANSPORT_DISPLAY_TRAILER               \
"\nFlags: Orderly release, Delayed accept, Expedited, internal Buffering,"\
"\n       Message mode, dataGram connection, Access check, s&d, diRect accept"\
"\n"

#define AFDKD_BRIEF_SOCKET_DISPLAY_HEADER32 \
"\nHandle DSOCKET  Flg Provider"\
// xxxxxx xxxxxxxx xxx xxxxxxxx-xxx...

#define AFDKD_BRIEF_SOCKET_DISPLAY_HEADER64 \
"\nHandle DSOCKET          Flg Provider"\
// xxxxxx xxxxxxxxxxxxxxxx xxx xxxxxxxxxxxxxxxx-xxx...

#define AFDKD_BRIEF_SOCKET_DISPLAY_HEADER   (IsPtr64()   \
            ? AFDKD_BRIEF_SOCKET_DISPLAY_HEADER64        \
            : AFDKD_BRIEF_SOCKET_DISPLAY_HEADER32)

#define AFDKD_BRIEF_SOCKET_DISPLAY_TRAILER              \
"\nFlags: P-created by provider, A-exposed to the app, O-overlapped"\
"\n"

#define AFDKD_BRIEF_MSWSOCK_DISPLAY_TRAILER             \
"MSAFD Flags: Listen,Bcast,Debug,Oobinline,reuseAddr,Excladdr,NBlock,Condaccept"\
"\n             sd_Snd,sd_Rcv"\
"\nSAN Flags: Flow_inited,remoteReset,Closing"\
"\n"

#define AFDKD_BRIEF_DPROV_DISPLAY_HEADER32              \
"\nProvider PF SFlags CatID Ch RefC Triple       Protocol"\
// xxxxxxxx xx xxxxxx xxxxx xx xxxx xx,x,xxxx(x) xxxxxxxxxxxxxxx

#define AFDKD_BRIEF_DPROV_DISPLAY_HEADER64              \
"\nProvider    PF SFlags CatID Ch RefC Triple       Protocol"\
// xxxxxxxxxxx xx xxxxxx xxxxx xx xxxx xx,x,xxxx(x) xxxxxxxxxxxxxxx

#define AFDKD_BRIEF_DPROV_DISPLAY_HEADER   (IsPtr64()   \
            ? AFDKD_BRIEF_DPROV_DISPLAY_HEADER64        \
            : AFDKD_BRIEF_DPROV_DISPLAY_HEADER32)

#define AFDKD_BRIEF_DPROV_DISPLAY_TRAILER               \
"\n"

#define AFDKD_BRIEF_NPROV_DISPLAY_HEADER32              \
"\nProvider NS id AF Fl RefC Display String"\
// xxxxxxxx xxxxx xx xx xxxx xxxxxxxxxxxxxxx

#define AFDKD_BRIEF_NPROV_DISPLAY_HEADER64              \
"\nProvider    NS id AF Fl RefC Display String"\
// xxxxxxxxxxx xxxxx xx xx xxxx xxxxxxxxxxxxxxx

#define AFDKD_BRIEF_NPROV_DISPLAY_HEADER   (IsPtr64()   \
            ? AFDKD_BRIEF_NPROV_DISPLAY_HEADER64        \
            : AFDKD_BRIEF_NPROV_DISPLAY_HEADER32)

#define AFDKD_BRIEF_NPROV_DISPLAY_TRAILER               \
"\nFl: Enabled,stores_Class_info"                      \
"\n"

#define AFDKD_BRIEF_TCB_DISPLAY_HEADER32 \
"\nTCB      St Flags    Client ConnCtx  PID  Source Address      Dest Addr"\
// xxxxxxxx xx xxxxxxxx xxxxxx xxxxxxxx xxxx xxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxx

#define AFDKD_BRIEF_TCB_DISPLAY_HEADER64 \
"\nTCB         St Flags    Client ConnCtx     PID  Source Address      Dest Addr"\
// xxxxxxxxxxx xx xxxxxxxx xxxxxx xxxxxxxxxxx xxxx xxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxx

#define AFDKD_BRIEF_TCB_DISPLAY_HEADER   (IsPtr64()   \
            ? AFDKD_BRIEF_TCB_DISPLAY_HEADER64        \
            : AFDKD_BRIEF_TCB_DISPLAY_HEADER32)

#define AFDKD_BRIEF_TCB_DISPLAY_TRAILER               \
"\nFlags:1-win,2-cl.opt,4-accept,8-active,10-disc,2-inDelQ,4-inRCmpl,8-inRInd,"\
"\n      100-ndRCmpl,2-ndAck,4-ndOut,8-delack,1000-pmtuP,2-bsdU,4-inDU,8-urgValid"\
"\n      10000-ndFin,2-nagle,4-inTSnd,8-flowC,100000-discPend,2-twPend,4-forceO"\
"\n      8-sndArcv,1000000-gcPend,2-keepAl,4-urgInl,8-scaleCW,10000000-finPend"\
"\n      2-finSend,4-ndRst,8-inTable"\
"\nStates: Cd-closed,Li-listen,SS-syn_sent,SR-syn_rcvd,Es-establ,F1-fin_wait_1"\
"\n        F2-fin_wait_2,CW-close_wait,Ci-closing,LA-last_ack, TW-time_wait"\
"\n"


#define AFDKD_BRIEF_TAO_DISPLAY_HEADER32 \
"\nAddrObj  Prot Flags Client Context  PID  Local Address       Ques(LAI)/RAddr"\
// xxxxxxxx xxxx xxxxx xxxxxx xxxxxxxx xxxx xxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxx

#define AFDKD_BRIEF_TAO_DISPLAY_HEADER64 \
"\nAddrObj     Prot Flags Client Context     PID  Local Address       Ques(LAI)/RAddr"\
// xxxxxxxxxxx xxxx xxxxx xxxxxx xxxxxxxxxxx xxxx xxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxx

#define AFDKD_BRIEF_TAO_DISPLAY_HEADER   (IsPtr64()   \
            ? AFDKD_BRIEF_TAO_DISPLAY_HEADER64        \
            : AFDKD_BRIEF_TAO_DISPLAY_HEADER32)

#define AFDKD_BRIEF_TAO_DISPLAY_TRAILER               \
"\nFlags: 1-del,2-opt,4-send,8-xsum,10-queued,2-oor,4-busy,8-valid,100-dhcp,2-raw"\
"\n       4-bcast,8-conudp,1000-shared,2-pktinfo,4-defer,8-cwin,10000-winset"\
"\nQues: L - listen, A - active, I - idle"\
"\n"

#define AFDKD_BRIEF_TCB6_DISPLAY_HEADER32 \
"\nTCB      St Flags    Client ConnCtx  PID  Source / Destination"\
// xxxxxxxx xx xxxxxxxx xxxxxx xxxxxxxx xxxx xxxxxxxxxxxxxxxxxxxx...
//          xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 

#define AFDKD_BRIEF_TCB6_DISPLAY_HEADER64 \
"\nTCB         St Falgs    Client ConnCtx     PID  Source / Destination"\
// xxxxxxxxxxx xx xxxxxxxx xxxxxx xxxxxxxxxxx xxxx xxxxxxxxxxxxxxxxxxxx...
//             xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 

#define AFDKD_BRIEF_TCB6_DISPLAY_HEADER   (IsPtr64()   \
            ? AFDKD_BRIEF_TCB6_DISPLAY_HEADER64        \
            : AFDKD_BRIEF_TCB6_DISPLAY_HEADER32)

#define AFDKD_BRIEF_TCB6_DISPLAY_TRAILER               \
"\nFlags:1-win,2-cl.opt,4-accept,8-active,10-disc,2-inDelQ,4-inRCmpl,8-inRInd,"\
"\n      100-ndRCmpl,2-ndAck,4-ndOut,8-delack,1000-pmtuP,2-bsdU,4-inDU,8-urgValid"\
"\n      10000-ndFin,2-nagle,4-inTSnd,8-flowC,100000-discPend,2-twPend,4-forceO"\
"\n      8-sndArcv,1000000-gcPend,2-keepAl,4-urgInl,8-accPend,10000000-finPend"\
"\n      2-finSend,4-ndRst,8-inTable"\
"\nStates: Cd-closed,Li-listen,SS-syn_sent,SR-syn_rcvd,Es-establ,F1-fin_wait_1"\
"\n        F2-fin_wait_2,CW-close_wait,Ci-closing,LA-last_ack,TW-time_wait"\
"\n"


#define AFDKD_BRIEF_TAO6_DISPLAY_HEADER32 \
"\nAddrObj  Prot Flgs Client Context  PID  Address"\
// xxxxxxxx xxxx xxxx xxxxxx xxxxxxxx xxxx xxxxxxx...

#define AFDKD_BRIEF_TAO6_DISPLAY_HEADER64 \
"\nAddrObj     Prot Flgs Client   Context     PID  Address"\
// xxxxxxxxxxx xxxx xxxx xxxxxxxx xxxxxxxxxxx xxxx xxxxxxx...

#define AFDKD_BRIEF_TAO6_DISPLAY_HEADER   (IsPtr64()   \
            ? AFDKD_BRIEF_TAO6_DISPLAY_HEADER64        \
            : AFDKD_BRIEF_TAO6_DISPLAY_HEADER32)

#define AFDKD_BRIEF_TAO6_DISPLAY_TRAILER               \
"\nFlags: 1-del,2-opt,4-send,8-,10-queued,2-oor,4-busy,8-valid,100-dhcp,2-raw"\
"\n       4-hdrInc,8-,1000-shared,2-pktinfo"\
"\n"

#endif  // _CONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\data.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    data.h

Abstract:

    Global data definitions for the AFD.SYS Kernel Debugger
    Extensions.

Author:

    Keith Moore (keithmo) 19-Apr-1995.

Environment:

    User Mode.

--*/


#ifndef _DATA_H_
#define _DATA_H_

#ifdef __cplusplus
extern "C" {
#endif
extern WINDBG_EXTENSION_APIS  ExtensionApis;
extern ULONG64                STeip;
extern ULONG64                STebp;
extern ULONG64                STesp;
extern ULONG                  SavedDebugClass, SavedDebugType;
extern ULONG                  SavedMachineType, SavedMajorVersion, SavedMinorVersion;
extern BOOLEAN                StateInitialized;
extern ULONG                  DebuggerActivationSeqN;


extern BOOL                   IsCheckedAfd;
extern BOOL                   IsReferenceDebug;
extern LIST_ENTRY             TransportInfoList;
extern ULONG                  Options;
extern ULONG                  EntityCount;
extern ULONG64                StartEndpoint;
extern ULONG64                UserProbeAddress;
extern ULONG                  TicksToMs, TickCount;
extern ULONG                  AfdBufferOverhead;
extern ULONG                  AfdStandardAddressLength;
extern ULONG                  AfdBufferTagSize;

extern LARGE_INTEGER          SystemTime, InterruptTime;

extern ULONG                  DatagramBufferListOffset,
                                DatagramRecvListOffset,
                                DatagramPeekListOffset,
                                RoutingNotifyListOffset,
                                RequestListOffset,
                                EventStatusOffset,
                                ConnectionBufferListOffset,
                                ConnectionSendListOffset,
                                ConnectionRecvListOffset,
                                UnacceptedConnListOffset,
                                ReturnedConnListOffset,
                                ListenConnListOffset,
                                FreeConnListOffset,
                                PreaccConnListOffset,
                                ListenIrpListOffset,
                                SanIrpListOffset,
                                PollEndpointInfoOffset,
                                DriverContextOffset,
                                SendIrpArrayOffset,
                                FsContextOffset;

extern ULONG                  EndpointLinkOffset,
                                ConnectionLinkOffset,
                                BufferLinkOffset,
                                AddressEntryLinkOffset,
                                TransportInfoLinkOffset,
                                AddressEntryAddressOffset;

extern ULONG                  ConnRefOffset,
                                EndpRefOffset,
                                TPackRefOffset;

extern ULONG                  RefDebugSize;

extern KDDEBUGGER_DATA64      DebuggerData;
extern CHAR                   Conditional[MAX_CONDITIONAL_EXPRESSION];
extern SYM_DUMP_PARAM         FldParam;
extern CHAR                   LinkField[MAX_FIELD_CHARS];
extern CHAR                   ListedType[MAX_FIELD_CHARS];
extern ULONG                  CppFieldEnd;
extern PDEBUG_CLIENT          gClient;
#ifdef __cplusplus
}
#endif
#endif  // _DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\conn.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    conn.c

Abstract:

    Implements the conn command.

Author:

    Keith Moore (keithmo) 19-Apr-1995

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop

BOOL
DumpConnectionCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

BOOL
FindRemotePortCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

//
//  Public functions.
//

DECLARE_API( conn )

/*++

Routine Description:

    Dumps the AFD_CONNECTION structure at the specified address.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG   result;
    INT     i;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];
    PCHAR   argp;
    ULONG64 address;

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }
    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_CONNECTION_DISPLAY_HEADER);
    }
    
    //
    // Snag the address from the command line.
    //

    if ((argp[0]==0) || (Options & AFDKD_ENDPOINT_SCAN)) {
        EnumEndpoints(
            DumpConnectionCallback,
            0
            );
        dprintf ("\nTotal connections: %ld", EntityCount);
    }
    else {
        while (sscanf( argp, "%s%n", expr, &i )==1) {

            if( CheckControlC() ) {
                break;
            }

            argp += i;
            address = GetExpression (expr);

            result = (ULONG)InitTypeRead (address, AFD!AFD_CONNECTION);
            if (result!=0) {
                dprintf ("\nconn: Could not read AFD_CONNECTION @ %p, err: %d",
                    address, result);
                break;
            }

            if (Options & AFDKD_BRIEF_DISPLAY) {
                DumpAfdConnectionBrief(
                    address
                    );
            }
            else {
                DumpAfdConnection(
                    address
                    );
            }
            if (Options & AFDKD_FIELD_DISPLAY) {
                ProcessFieldOutput (address, "AFD!AFD_CONNECTION");
            }
        }

    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_CONNECTION_DISPLAY_TRAILER);
    }
    else {
        dprintf ("\n");
    }

    return S_OK;
}   // conn


DECLARE_API( rport )

/*++

Routine Description:

    Dumps all AFD_ENDPOINT structures connected to the given port.

Arguments:

    None.

Return Value:

    None.

--*/

{

    INT i;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];
    PCHAR   argp;
    ULONG64 val;

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_CONNECTION_DISPLAY_HEADER);
    }

    //
    // Snag the port from the command line.
    //

    while (sscanf( argp, "%s%n", expr, &i)==1) {
        if( CheckControlC() ) {
            break;
        }
        argp+=i;
        val = GetExpression (expr);
        dprintf ("\nLooking for connections connected to port 0x%I64X(0d%I64d) ", val, val);
        EnumEndpoints(
            FindRemotePortCallback,
            val
            );
        dprintf ("\nTotal connections: %ld", EntityCount);
    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_CONNECTION_DISPLAY_HEADER);
    }
    else {
        dprintf ("\n");
    }

    return S_OK;
}   // rport

BOOL
DumpConnectionCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    )

/*++

Routine Description:

    EnumEndpoints() callback for dumping AFD_ENDPOINTs.

Arguments:

    Endpoint - The current AFD_ENDPOINT.

    ActualAddress - The actual address where the structure resides on the
        debugee.

    Context - The context value passed into EnumEndpoints().

Return Value:

    BOOL - TRUE if enumeration should continue, FALSE if it should be
        terminated.

--*/

{
    ULONG result;
    AFD_ENDPOINT    endpoint;
    ULONG64 connAddr;

    endpoint.Type = (USHORT)ReadField (Type);
    endpoint.State = (UCHAR)ReadField (State);
    if (((endpoint.Type & AfdBlockTypeVcConnecting)==AfdBlockTypeVcConnecting) &&
            ( (connAddr=ReadField (Common.VirtualCircuit.Connection))!=0 ||
                ((endpoint.State==AfdEndpointStateClosing || endpoint.State==AfdEndpointStateTransmitClosing) &&
                    (connAddr=ReadField(WorkItem.Context))!=0) ) ) {

        result = (ULONG)InitTypeRead (connAddr, AFD!AFD_CONNECTION);
        if (result!=0) {
            dprintf(
                "\nDumpConnectionCallback: Could not read AFD_CONNECTION @ %p, err:%d\n",
                connAddr, result
                );
            return TRUE;
        }

        if (!(Options & AFDKD_CONDITIONAL) ||
                CheckConditional (connAddr, "AFD!AFD_CONNECTION")) {
            if (Options & AFDKD_NO_DISPLAY)
                dprintf ("+");
            else  {
                if (Options & AFDKD_BRIEF_DISPLAY) {
                    DumpAfdConnectionBrief(
                        connAddr
                        );
                }
                else {
                    DumpAfdConnection(
                        connAddr
                        );
                }
                if (Options & AFDKD_FIELD_DISPLAY) {
                    ProcessFieldOutput (connAddr, "AFD!AFD_CONNECTION");
                }
            }
            EntityCount += 1;
        }
        else
            dprintf (",");
    }
    else if ((endpoint.Type & AfdBlockTypeVcListening)==AfdBlockTypeVcListening) {
        ULONG64 nextEntry;
        ULONG64 listHead;
        LIST_ENTRY64 listEntry;
        
        listHead = ActualAddress+UnacceptedConnListOffset;
        if( !ReadListEntry(
                listHead,
                &listEntry) ) {

            dprintf(
                "\nDumpConnectionCallback: Could not read UnacceptedConnectionListHead for endpoint @ %p\n",
                ActualAddress
                );
            return TRUE;

        }

        nextEntry = listEntry.Flink;
        while (nextEntry!=listHead) {
            if( CheckControlC() ) {

                break;

            }

            connAddr = nextEntry - ConnectionLinkOffset;
            result = (ULONG)InitTypeRead (connAddr, AFD!AFD_CONNECTION);
            if (result!=0) {
                dprintf(
                    "\nDumpConnectionCallback: Could not read AFD_CONNECTION @ %p, err:%d\n",
                    connAddr, result
                    );
                return TRUE;
            }
            nextEntry = ReadField (ListEntry.Flink);
            if (nextEntry==0) {
                dprintf(
                    "\nDumpConnectionCallback: ListEntry.Flink is 0 for AFD_CONNECTION @ %p, err:%d\n",
                    connAddr, result
                    );
                return TRUE;
            }

            if (!(Options & AFDKD_CONDITIONAL) ||
                    CheckConditional (connAddr, "AFD!AFD_CONNECTION")) {
                if (Options & AFDKD_NO_DISPLAY)
                    dprintf ("+");
                else  {
                    if (Options & AFDKD_BRIEF_DISPLAY) {
                        DumpAfdConnectionBrief(
                            connAddr
                            );
                    }
                    else {
                        DumpAfdConnection(
                            connAddr
                            );
                    }
                    if (Options & AFDKD_FIELD_DISPLAY) {
                        ProcessFieldOutput (connAddr, "AFD!AFD_CONNECTION");
                    }
                }
                EntityCount += 1;
            }
            else
                dprintf (",");

        }



        listHead = ActualAddress + ReturnedConnListOffset;
        if( !ReadListEntry(
                listHead,
                &listEntry) ) {

            dprintf(
                "\nDumpConnectionCallback: Could not read ReturnedConnectionListHead for endpoint @ %p\n",
                ActualAddress
                );
            return TRUE;

        }
        nextEntry = listEntry.Flink;
        while (nextEntry!=listHead) {
            if( CheckControlC() ) {

                break;

            }

            connAddr = nextEntry - ConnectionLinkOffset;
            result = (ULONG)InitTypeRead (connAddr, AFD!AFD_CONNECTION);
            if (result!=0) {
                dprintf(
                    "\nDumpConnectionCallback: Could not read AFD_CONNECTION @ %p, err:%d\n",
                    connAddr, result
                    );
                return TRUE;
            }
            nextEntry = ReadField (ListEntry.Flink);
            if (nextEntry==0) {
                dprintf(
                    "\nDumpConnectionCallback: ListEntry.Flink is 0 for AFD_CONNECTION @ %p, err:%d\n",
                    connAddr, result
                    );
                return TRUE;
            }

            if (!(Options & AFDKD_CONDITIONAL) ||
                    CheckConditional (connAddr, "AFD!AFD_CONNECTION")) {
                if (Options & AFDKD_NO_DISPLAY)
                    dprintf ("+");
                else  {
                    if (Options & AFDKD_BRIEF_DISPLAY) {
                        DumpAfdConnectionBrief(
                            connAddr
                            );
                    }
                    else {
                        DumpAfdConnection(
                            connAddr
                            );
                    }
                    if (Options & AFDKD_FIELD_DISPLAY) {
                        ProcessFieldOutput (connAddr, "AFD!AFD_CONNECTION");
                    }
                }
                EntityCount += 1;
            }
            else
                dprintf (",");
        }
    }
    else {
        dprintf (".");
    }

    return TRUE;

}   // DumpConnectionCallback


BOOLEAN
PortMatch (
    PTRANSPORT_ADDRESS  TransportAddress,
    USHORT              Port
    )
{
    PTA_IP_ADDRESS ipAddress;
    USHORT port;

    ipAddress = (PTA_IP_ADDRESS)TransportAddress;

    if( ( ipAddress->TAAddressCount != 1 ) ||
        ( ipAddress->Address[0].AddressLength < sizeof(TDI_ADDRESS_IP) ) ||
        ( ipAddress->Address[0].AddressType != TDI_ADDRESS_TYPE_IP ) ) {

        dprintf (",");
        return FALSE;

    }

    port = NTOHS(ipAddress->Address[0].Address[0].sin_port);

    return Port == port;
}


BOOL
FindRemotePortCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    )

/*++

Routine Description:

    EnumEndpoints() callback for finding AFD_CONNECTION connected to a specific
    port.

Arguments:

    Endpoint - The current AFD_ENDPOINT.

    ActualAddress - The actual address where the structure resides on the
        debugee.

    Context - The context value passed into EnumEndpoints().

Return Value:

    BOOL - TRUE if enumeration should continue, FALSE if it should be
        terminated.

--*/

{

    ULONG result;
    AFD_ENDPOINT    endpoint;
    ULONG64 connAddr;
    ULONG64 remoteAddr;
    ULONG   remoteAddrLength;
    UCHAR   transportAddress[MAX_TRANSPORT_ADDR];

    endpoint.Type = (USHORT)ReadField (Type);
    endpoint.State = (UCHAR)ReadField (State);
    if (((endpoint.Type & AfdBlockTypeVcConnecting)==AfdBlockTypeVcConnecting) &&
            ( (connAddr=ReadField (Common.VirtualCircuit.Connection))!=0 ||
                ((endpoint.State==AfdEndpointStateClosing || endpoint.State==AfdEndpointStateTransmitClosing) &&
                    (connAddr=ReadField(WorkItem.Context))!=0) ) ) {
        result = (ULONG)InitTypeRead (connAddr, AFD!AFD_CONNECTION);
        if (result!=0) {
            dprintf(
                "\nFindRemotePortCallback: Could not read AFD_CONNECTION @ %p, err:%d\n",
                connAddr, result
                );
            return TRUE;
        }

        remoteAddr = ReadField (RemoteAddress);
        remoteAddrLength = (ULONG)ReadField (RemoteAddressLength);
        if (remoteAddr!=0) {
            if (!ReadMemory (remoteAddr,
                            transportAddress,
                            remoteAddrLength<sizeof (transportAddress) 
                                ? remoteAddrLength
                                : sizeof (transportAddress),
                                &remoteAddrLength)) {
                dprintf(
                    "\nFindRemotePortCallback: Could not read remote address for connection @ %p\n",
                    connAddr
                    );
                return TRUE;
            }
        }
        else {
            ULONG64 contextAddr;
            //
            // Attempt to read user mode data stored as the context
            //
            result = GetRemoteAddressFromContext (ActualAddress,
                                            transportAddress, 
                                            sizeof (transportAddress),
                                            &contextAddr);
            if (result!=0) {
                dprintf(
                    "\nFindRemotePortCallback: Could not read remote address for connection @ %p of endpoint context @ %p err:%ld\n",
                    connAddr, contextAddr, result
                    );
                return TRUE;
            }
        }
        if (PortMatch ((PVOID)transportAddress, (USHORT)Context) &&
                (!(Options & AFDKD_CONDITIONAL) ||
                    CheckConditional (connAddr, "AFD!AFD_CONNECTION")) ) {
            if (Options & AFDKD_NO_DISPLAY)
                dprintf ("+");
            else  {
                if (Options & AFDKD_BRIEF_DISPLAY) {
                    DumpAfdConnectionBrief(
                        connAddr
                        );
                }
                else {
                    DumpAfdConnection(
                        connAddr
                        );
                }
                if (Options & AFDKD_FIELD_DISPLAY) {
                    ProcessFieldOutput (connAddr, "AFD!AFD_CONNECTION");
                }
            }
            EntityCount += 1;
        }
        else
            dprintf (",");

    }
    else if ((endpoint.Type & AfdBlockTypeVcListening)==AfdBlockTypeVcListening) {
        ULONG64 nextEntry;
        ULONG64 listHead;
        LIST_ENTRY64 listEntry;
        
        listHead = ActualAddress+ UnacceptedConnListOffset;
        if( !ReadListEntry(
                listHead,
                &listEntry) ) {

            dprintf(
                "\nFindRemotePortCallback: Could not read UnacceptedConnectionListHead for endpoint @ %p\n",
                ActualAddress
                );
            return TRUE;

        }

        nextEntry = listEntry.Flink;
        while (nextEntry!=listHead) {
            if( CheckControlC() ) {

                break;

            }

            connAddr = nextEntry - ConnectionLinkOffset;
            result = (ULONG)InitTypeRead (connAddr, AFD!AFD_CONNECTION);
            if (result!=0) {
                dprintf(
                    "\nFindRemotePortCallback: Could not read AFD_CONNECTION @ %p, err:%d\n",
                    connAddr, result
                    );
                return TRUE;
            }
            nextEntry = ReadField (ListEntry.Flink);
            if (nextEntry==0) {
                dprintf(
                    "\nFindRemotePortCallback: ListEntry.Flink is 0 for AFD_CONNECTION @ %p, err:%d\n",
                    connAddr, result
                    );
                return TRUE;
            }


            remoteAddr = ReadField (RemoteAddress);
            remoteAddrLength = (ULONG)ReadField (RemoteAddressLength);

            if (remoteAddr!=0) {
                if (!ReadMemory (remoteAddr,
                                transportAddress,
                                remoteAddrLength<sizeof (transportAddress) 
                                    ? remoteAddrLength
                                    : sizeof (transportAddress),
                                    &remoteAddrLength)) {
                    dprintf(
                        "\nFindRemotePortCallback: Could not read remote address for connection @ %p\n",
                        connAddr
                        );
                    continue;
                }
            }

            if (PortMatch ((PVOID)transportAddress, (USHORT)Context) &&
                    (!(Options & AFDKD_CONDITIONAL) ||
                        CheckConditional (connAddr, "AFD!AFD_CONNECTION")) ) {
                if (Options & AFDKD_NO_DISPLAY)
                    dprintf ("+");
                else  {
                    if (Options & AFDKD_BRIEF_DISPLAY) {
                        DumpAfdConnectionBrief(
                            connAddr
                            );
                    }
                    else {
                        DumpAfdConnection(
                            connAddr
                            );
                    }
                    if (Options & AFDKD_FIELD_DISPLAY) {
                        ProcessFieldOutput (connAddr, "AFD!AFD_CONNECTION");
                    }
                }
                EntityCount += 1;
            }
            else {
                dprintf (",");
            }
        }



        listHead = ActualAddress + ReturnedConnListOffset;
        if( !ReadListEntry(
                listHead,
                &listEntry) ) {

            dprintf(
                "\nFindRemotePortCallback: Could not read ReturnedConnectionListHead for endpoint @ %p\n",
                ActualAddress
                );
            return TRUE;

        }
        nextEntry = listEntry.Flink;
        while (nextEntry!=listHead) {
            if( CheckControlC() ) {

                break;

            }

            connAddr = nextEntry - ConnectionLinkOffset;
            result = (ULONG)InitTypeRead (connAddr, AFD!AFD_CONNECTION);
            if (result!=0) {
                dprintf(
                    "\nDumpConnectionCallback: cannot read AFD_CONNECTION @ %p, err:%d\n",
                    connAddr, result
                    );
                return TRUE;
            }
            nextEntry = ReadField (ListEntry.Flink);
            if (nextEntry==0) {
                dprintf(
                    "\nFindRemotePortCallback: ListEntry.Flink is 0 for AFD_CONNECTION @ %p, err:%d\n",
                    connAddr, result
                    );
                return TRUE;
            }

            remoteAddr = ReadField (RemoteAddress);
            remoteAddrLength = (ULONG)ReadField (RemoteAddressLength);

            if (remoteAddr!=0) {
                if (!ReadMemory (remoteAddr,
                                transportAddress,
                                remoteAddrLength<sizeof (transportAddress) 
                                    ? remoteAddrLength
                                    : sizeof (transportAddress),
                                    &remoteAddrLength)) {
                    dprintf(
                        "\nFindRemotePortCallback: Could not read remote address for connection @ %p\n",
                        connAddr
                        );
                    continue;
                }
            }

            if (PortMatch ((PVOID)transportAddress, (USHORT)Context) &&
                    (!(Options & AFDKD_CONDITIONAL) ||
                        CheckConditional (connAddr, "AFD!AFD_CONNECTION")) ) {
                if (Options & AFDKD_NO_DISPLAY)
                    dprintf ("+");
                else  {
                    if (Options & AFDKD_BRIEF_DISPLAY) {
                        DumpAfdConnectionBrief(
                            connAddr
                            );
                    }
                    else {
                        DumpAfdConnection(
                            connAddr
                            );
                    }
                    if (Options & AFDKD_FIELD_DISPLAY) {
                        ProcessFieldOutput (connAddr, "AFD!AFD_CONNECTION");
                    }
                }
                EntityCount += 1;
            }
            else {
                dprintf (",");
            }
        }
    }
    else {
        dprintf (".");
    }

    return TRUE;

}   // FindRemotePortCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\buffer.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    buffer.c

Abstract:

    Implements the buffer command.

Author:

    Keith Moore (keithmo) 15-Apr-1996

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop

BOOL
DumpBuffersCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

//
//  Public functions.
//

DECLARE_API( buff )

/*++

Routine Description:

    Dumps the AFD_BUFFER structure at the specified address.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG64 address = 0;
    ULONG   result;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];
    PCHAR   argp;
    INT     i;

    gClient = pClient;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_BUFFER_DISPLAY_HEADER);
    }
    
    if ((argp[0]==0) || (Options & AFDKD_ENDPOINT_SCAN)) {
        EnumEndpoints(
            DumpBuffersCallback,
            0
            );
        dprintf ("\nTotal buffers: %ld", EntityCount);
    }
    else {


        //
        // Snag the address from the command line.
        //
        while (sscanf( argp, "%s%n", expr, &i )==1) {
            if( CheckControlC() ) {
                break;
            }

            argp+=i;
            address = GetExpression (expr);
            result = (ULONG)InitTypeRead (address, AFD!AFD_BUFFER_HEADER);
            if (result!=0) {
                dprintf ("\nDumpAfdBuffer: Could not read AFD_BUFFER_HEADER @p, err: %ld\n",
                            address, result);
                break ;
            }

            if (Options & AFDKD_BRIEF_DISPLAY) {
                DumpAfdBufferBrief (
                    address
                    );
            }
            else {
                DumpAfdBuffer (
                    address
                    );
            }
            if (Options & AFDKD_FIELD_DISPLAY) {
                ProcessFieldOutput (address, "AFD!AFD_BUFFER");
            }
        }
    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_BUFFER_DISPLAY_TRAILER);
    }
    else {
        dprintf ("\n");
    }

    return S_OK;
}   // buffer

VOID
DumpBufferList (
    ULONG64 ListAddress,
    LPSTR   Header
    )
{
    LIST_ENTRY64 listEntry;
    ULONG64 address;
    ULONG64 nextEntry;
    ULONG result;

    if( !ReadListEntry(
            ListAddress,
            &listEntry) ) {

        dprintf(
            "\nDumpBufferList: Could not read buffer list head @ %p\n",
            ListAddress
            );
        return ;
    }

    if (listEntry.Flink==ListAddress) {
        dprintf(".");
        return ;
    }

    if (Header) {
        dprintf (Header);
    }

    nextEntry = listEntry.Flink;
    while( nextEntry != ListAddress ) {

        if (nextEntry==0) {
            dprintf(
                "\nDumpBuffersCallback: next entry is NULL for list @ %p\n",
                ListAddress
                );
            break;
        }

        if (CheckControlC ())
            break;

        address = nextEntry - BufferLinkOffset;

        result = (ULONG)InitTypeRead (address, AFD!AFD_BUFFER_HEADER);
        if (result!=0) {
            dprintf ("\nDumpBuffersCallback: Could not read AFD_BUFFER_HEADER @p, err: %ld\n",
                        address, result);
            break ;
        }

        nextEntry = ReadField (BufferListEntry.Flink);
        if (!(Options & AFDKD_CONDITIONAL) ||
                    CheckConditional (address, "AFD!AFD_BUFFER") ) {
            if (Options & AFDKD_NO_DISPLAY)
                dprintf ("+");
            else {
                if (Options & AFDKD_BRIEF_DISPLAY) {
                    DumpAfdBufferBrief (
                        address
                        );
                }
                else {
                    DumpAfdBuffer (
                        address
                        );
                }
                if (Options & AFDKD_FIELD_DISPLAY) {
                    ProcessFieldOutput (address, "AFD!AFD_BUFFER");
                }
            }
            EntityCount += 1;
        }
        else {
            dprintf (",");
        }
    }
}

ULONG
DumpBufferListCB (
    PFIELD_INFO pField,
    PVOID       UserContext
    )
{
    ULONG       result;
    CHAR        header[64];
    AFD_CONNECTION_STATE_FLAGS   flags;
    
    result = GetFieldValue (pField->address, "AFD!AFD_CONNECTION", "ConnectionStateFlags", flags);
    if ((result==0) &&
            !flags.TdiBufferring ) {
        _snprintf (header, sizeof (header)-1, "\nConnection: %I64X", pField->address);
        header[sizeof(header)-1] = 0;
        DumpBufferList (pField->address+ConnectionBufferListOffset, header);
    }

    return result;
}

BOOL
DumpBuffersCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    )
/*++

Routine Description:

    Dumps buffers for the endpoint/connection.

Arguments:

    ActualAddress - The actual address of the list

Return Value:

    ULONG - Sum of pool charged for the buffers in the list.

--*/

{
    AFD_ENDPOINT    endpoint;
    ULONG64         connAddr;
    AFD_CONNECTION_STATE_FLAGS   flags;
    CHAR            header[64];

    endpoint.Type = (USHORT)ReadField (Type);
    endpoint.State = (UCHAR)ReadField (State);
    if (endpoint.Type==AfdBlockTypeDatagram) {
        _snprintf (header, sizeof (header)-1, "\nEndpoint %I64X", ActualAddress);
        header[sizeof(header)-1] = 0;
        DumpBufferList (ActualAddress+DatagramBufferListOffset, header);
    }
    else if (((endpoint.Type & AfdBlockTypeVcConnecting)==AfdBlockTypeVcConnecting) &&
                ( (connAddr=ReadField (Common.VirtualCircuit.Connection))!=0 ||
                    ((endpoint.State==AfdEndpointStateClosing || endpoint.State==AfdEndpointStateTransmitClosing) &&
                        (connAddr=ReadField(WorkItem.Context))!=0) ) &&
                (GetFieldValue (connAddr, "AFD!AFD_CONNECTION", "ConnectionStateFlags", flags)==0) &&
                !flags.TdiBufferring ) {
        _snprintf (header, sizeof (header)-1, "\nEndpoint: %I64X, connection: %I64X", ActualAddress, connAddr);
        header[sizeof(header)-1] = 0;
        DumpBufferList (connAddr+ConnectionBufferListOffset, header);
    }
    else if ((endpoint.Type & AfdBlockTypeVcListening)==AfdBlockTypeVcListening) {
        ListType (
            "AFD!AFD_CONNECTION",                   // Type
            ActualAddress+UnacceptedConnListOffset, // Address
            1,                                      // ListByFieldAddress
            "ListLink.Flink",                       // NextPointer
            NULL,                                   // Context
            DumpBufferListCB                        // Callback
            );

        ListType (
            "AFD!AFD_CONNECTION",                   // Type
            ActualAddress+ReturnedConnListOffset,   // Address
            1,                                      // ListByFieldAddress
            "ListLink.Flink",                       // NextPointer
            NULL,                                   // Context
            DumpBufferListCB                        // Callback
            );
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\afds.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    afds.c

Abstract:

    Implements afds command

Author:

    Vadim Eydelman, March 2000

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop

#define AFDKD_TOKEN         "@$."
#define AFDKD_TOKSZ         (sizeof (AFDKD_TOKEN)-1)

ULONG
ListCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    );

//
// Public functions.
//

ULONG   LinkOffset;

DECLARE_API( afds )

/*++

Routine Description:

    Dumps afd endpoints

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG64 address;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];
    PCHAR   argp;
    INT     i;
    ULONG   result;

    gClient = pClient;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;

    if ((Options & (AFDKD_LINK_FIELD|AFDKD_LIST_TYPE)) !=
                   (AFDKD_LINK_FIELD|AFDKD_LIST_TYPE)) {
        dprintf ("\nafds: Missing link or list type specification");
        dprintf ("\nUsage:\nafds -l link -t type [options] address\n");
        return E_INVALIDARG;
    }

    if (sscanf( argp, "%s%n", expr, &i )!=1) {
        dprintf ("\nafds: Missing address specification");
        dprintf ("\nUsage:\nafds -l link  -t type [options] address\n");
        return E_INVALIDARG;
    }
    argp += i;

    address = GetExpression (expr);

    if (Options & AFDKD_LINK_SELF) {
        result = GetFieldOffset (ListedType, LinkField, &LinkOffset);
        if (result!=0) {
            dprintf ("\nafds: Cannot get offset of %s in %s, err: %ld\n",
                        LinkField, ListedType, result);
            return E_INVALIDARG;
        }
    }

    ListType (
        (Options & AFDKD_LINK_SELF)
            ? "LIST_ENTRY"
            : ListedType,           // Type
        address,                    // Address
        (Options & AFDKD_LINK_AOF) 
            ? 1
            : 0,                    // ListByFieldAddress
        (Options & AFDKD_LINK_SELF)
            ? "Flink"
            : LinkField,            // NextPointer
        ListedType,                 // Context
        ListCallback);
    dprintf ("\n");
    return S_OK;
}


ULONG
ListCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    )
{
    ULONG64 address;
    address = pField->address;
    if (Options & AFDKD_LINK_SELF) {
        address -= LinkOffset;
    }
    if (!(Options & AFDKD_CONDITIONAL) ||
            CheckConditional (address, UserContext)) {
        dprintf ("\n%s @ %p", UserContext, address);
        ProcessFieldOutput (address, UserContext);
    }
    else {
        dprintf (".");
    }
    return 0;
}

/*
{
ULONG64
GetExpressionFromType (
    ULONG64 Address,
    PCHAR   Type,
    PCHAR   Expression
    )
    CHAR    expr[MAX_CONDITIONAL_EXPRESSION];
    PCHAR   argp = Expression, pe = expr, pestop=pe+sizeof(expr)-1;
    ULONG   result;
    ULONG64 value;
    PCHAR   type = Type;
    ULONG64 address = Address;

    while  (*argp) {
        if (*argp=='@' && strncmp (argp, AFDKD_TOKEN, AFDKD_TOKSZ)==0) {
            PCHAR   end = pe;
            argp+= AFDKD_TOKSZ;
            while (isalnum (*argp) ||
                        *argp=='[' ||
                        *argp==']' ||
                        *argp=='_' ||
                        *argp=='.' || 
                        *argp=='-') {
                if (*argp=='-') {
                    if (*(argp+1)=='>') {
                        if (*(argp+2)=='(') {
                            *end = 0;
                            result = GetFieldValue (address, type, pe, value);
                            if (result!=0) {
                                dprintf ("\nCheckConditional: Can't get %s.%s at %p (err:%d)\n", type, pe, address, result);
                                return FALSE;
                            }
                            if (value==0)
                                return FALSE;
                            argp += 3;
                            type = argp;
                            while (*argp && *argp!=')') {
                                argp += 1;
                            }
                            *argp++ = 0;
                            address = value;
                            end = pe;
                            continue;
                            
                        }
                        if (end>=pestop)
                            break;
                        *end++ = *argp++;

                    }
                    else
                        break;
                }
                if (end>=pestop)
                    break;
                *end++ = *argp++;
            }
            *end = 0;
            result = GetFieldValue (address, type, pe, value);
            if (result!=0) {
                dprintf ("\nCheckConditional: Can't get %s.%s at %p (err:%d)\n", type, pe, address, result);
                return FALSE;
            }
            pe += _snprintf (pe, pestop-pe, "0x%I64X", value);
            address = Address;
            type = Type;
        }
        else {
            if (pe>=pestop)
                break;
            *pe++ = *argp++;
        }
    }
    *pe = 0;

    return GetExpression (expr);
}
*/

BOOLEAN
CheckConditional (
    ULONG64 Address,
    PCHAR   Type
    )
{
    DEBUG_VALUE val;

    if (GetExpressionFromType (Address, Type, Conditional, DEBUG_VALUE_INT64, &val)==S_OK)
        return val.I64!=0;
    else
        return FALSE;
}

VOID
ProcessFieldOutput (
    ULONG64 Address,
    PCHAR   Type
    )
{
    ULONG result;

    FldParam.addr = Address;
    FldParam.sName = Type;
    if (Options & AFDKD_NO_DISPLAY) {
        FldParam.Options |= DBG_DUMP_COMPACT_OUT;
    }

    dprintf ("\n");
    if (FldParam.nFields>0 ||
            (FldParam.nFields==0 && CppFieldEnd==0)) {
        result = Ioctl (IG_DUMP_SYMBOL_INFO, &FldParam, FldParam.size );
        if (result!=0) {
            dprintf ("\nProcessFieldOutput: IG_DUMP_SYMBOL_INFO failed, err: %ld\n", result);
        }
    }
    if (CppFieldEnd>FldParam.nFields) {
        ULONG   i;
        for (i=FldParam.nFields; i<CppFieldEnd; i++) {
            DEBUG_VALUE val;
            if (GetExpressionFromType (Address, Type, FldParam.Fields[i].fName,
                                            DEBUG_VALUE_INVALID,
                                            &val)==S_OK) {
                dprintf ("   %s = 0x%I64x(%d)\n",
                    &FldParam.Fields[i].fName[AFDKD_CPP_PREFSZ],
                    val.I64,
                    val.Type
                    );
            }
/*
            SYM_DUMP_PARAM fldParam;
            CHAR    fieldStr[MAX_FIELD_CHARS], *p;
            FIELD_INFO   field = FldParam.Fields[i];
            ULONG64 value;
            ULONG   skip = 0;
            fldParam = FldParam;
            fldParam.nFields = 1;
            fldParam.Fields = &field;
            //fldParam.Options |= DBG_DUMP_NO_PRINT;
            strncpy (fieldStr, field.fName, sizeof (fieldStr));
            field.fName = p = fieldStr;
            field.fOptions |= DBG_DUMP_FIELD_COPY_FIELD_DATA;
            field.fieldCallBack = &value;
            while ((p=strstr (p, "->("))!=NULL) {
                *p = 0;
                result = Ioctl (IG_DUMP_SYMBOL_INFO, &fldParam, fldParam.size );
                if (result!=0) {
                    dprintf ("\nProcessFieldOutput: GetFieldValue (%p,%s,%s) failed, err: %ld\n",
                                fldParam.addr,
                                fldParam.sName,
                                field.fName,
                                result);
                    goto DoneField;
                }
                fldParam.addr = value;

                p += sizeof ("->(")-1;
                fldParam.sName = p;
                p = strchr (p, ')');
                if (p==NULL) {
                    dprintf ("\nProcessFieldOutput: missing ')' in %s\n", fldParam.sName);
                    goto DoneField;
                }
                *p++ = 0;
                
                skip += 3;
                dprintf ("%*.80s%s : %I64x->(%s)\n", skip, " ", 
                            field.fName,
                            DISP_PTR(value),
                            fldParam.sName);

                field.fName = p;
                if (value==0) {
                    goto DoneField;
                }
            }
            //fldParam.Options &= (~DBG_DUMP_NO_PRINT);
            field.fOptions &= ~(DBG_DUMP_FIELD_COPY_FIELD_DATA);
            field.fieldCallBack = NULL;
            result = Ioctl (IG_DUMP_SYMBOL_INFO, &fldParam, fldParam.size );
            if (result!=0) {
                dprintf ("\nProcessFieldOutput: IG_DUMP_SYMBOL_INFO %p %s %s failed, err: %ld\n",
                            fldParam.addr,
                            fldParam.sName,
                            field.fName,
                            result);
                break;
            }

        DoneField:
            ;
*/
        }
    }
}


DECLARE_API( filefind )
/*++

Routine Description:

    Searches non-paged pool for FILE_OBJECT given its FsContext field.

Arguments:

    None.

Return Value:

    None.

--*/
{

    ULONG64 FsContext;
    ULONG64 PoolStart, PoolEnd, PoolPage;
    ULONG64 PoolExpansionStart, PoolExpansionEnd;
    ULONG   result;
    ULONG64 val;
    BOOLEAN twoPools;

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    FsContext = GetExpression (args);
    if (FsContext==0 || FsContext<UserProbeAddress) {
        return E_INVALIDARG;
    }

    if ( (result = ReadPtr (DebuggerData.MmNonPagedPoolStart, &PoolStart))!=0 ||
        (result = ReadPtr (DebuggerData.MmNonPagedPoolEnd, &PoolEnd))!=0 ) {
        dprintf ("\nfilefind - Cannot get non-paged pool limits, err: %ld\n",
                result);
        return E_INVALIDARG;
    }

    if (PoolStart + DebuggerData.MmMaximumNonPagedPoolInBytes!=PoolEnd) {
        if ( (result = GetFieldValue (0,
                            "NT!MmSizeOfNonPagedPoolInBytes",
                            NULL,
                            val))!=0 ||
             (result = GetFieldValue (0,
                            "NT!MmNonPagedPoolExpansionStart",
                            NULL,
                            PoolExpansionStart))!=0 ) {
            dprintf ("\nfilefind - Cannot get non-paged pool expansion limits, err: %ld\n",
                     result);
            return E_INVALIDARG;
        }
        PoolExpansionEnd = PoolEnd;
        PoolEnd = PoolStart + val;
        twoPools = TRUE;
    }
    else {
        twoPools = FALSE;
    }


    PoolPage = PoolStart;
    dprintf ("Searching non-paged pool %p - %p...\n", PoolStart, PoolEnd);
    while (PoolPage<PoolEnd) {
        SEARCHMEMORY Search;

        if (CheckControlC ()) {
            break;
        }

        Search.SearchAddress = PoolPage;
        Search.SearchLength = PoolEnd-PoolPage;
        Search.Pattern = &FsContext;
        Search.PatternLength = IsPtr64 () ? sizeof (ULONG64) : sizeof (ULONG);
        Search.FoundAddress = 0;

        if (Ioctl (IG_SEARCH_MEMORY, &Search, sizeof (Search)) && 
                Search.FoundAddress!=0) {
            ULONG64 fileAddr;
            fileAddr = Search.FoundAddress-FsContextOffset;
            result = (ULONG)InitTypeRead (fileAddr, NT!_FILE_OBJECT);
            if (result==0 && (CSHORT)ReadField (Type)==IO_TYPE_FILE) {
                dprintf ("File object at %p\n", fileAddr);
            }
            else {
                dprintf ("    pool search match at %p\n", Search.FoundAddress);
            }
            PoolPage = Search.FoundAddress + 
                        (IsPtr64() ? sizeof (ULONG64) : sizeof (ULONG));
        }
        else {
            if (!twoPools || PoolEnd==PoolExpansionEnd) {
                break;
            }
            else {
                dprintf ("Searching expansion non-paged pool %p - %p...\n", 
                                PoolExpansionStart, PoolExpansionEnd);
                PoolEnd = PoolExpansionEnd;
                PoolPage = PoolExpansionStart;
            }
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\afdutil.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    afdutil.c

Abstract:

    Utility functions for dumping various AFD structures.

Author:

    Keith Moore (keithmo) 19-Apr-1995

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop


//
//  Private constants.
//

//
//  Private globals.
//

PSTR WeekdayNames[] =
     {
         "Sun",
         "Mon",
         "Tue",
         "Wed",
         "Thu",
         "Fri",
         "Sat"
     };

PSTR MonthNames[] =
     {
         "",
         "Jan",
         "Feb",
         "Mar",
         "Apr",
         "May",
         "Jun",
         "Jul",
         "Aug",
         "Sep",
         "Oct",
         "Nov",
         "Dec"
     };


//
//  Private prototypes.
//

PSTR
StructureTypeToString(
    USHORT Type
    );

PSTR
StructureTypeToStringBrief (
    USHORT Type
    );

PSTR
BooleanToString(
    BOOLEAN Flag
    );

PSTR
EndpointStateToString(
    UCHAR State
    );

PSTR
EndpointStateToStringBrief(
    UCHAR State
    );

PSTR
EndpointStateFlagsToString(
    );

PSTR
EndpointTypeToString(
        ULONG TypeFlags
    );

PSTR
ConnectionStateToString(
    USHORT State
    );

PSTR
ConnectionStateToStringBrief(
    USHORT State
    );

PSTR
ConnectionStateFlagsToString(
    );

PSTR
TranfileFlagsToString(
    VOID
    );

PSTR
TPacketsFlagsToStringNet(
    ULONG   Flags,
    ULONG   StateFlags
    );

PSTR
TPacketsFlagsToStringXp(
    ULONG   Flags,
    ULONG   StateFlags
    );

VOID
DumpAfdTPacketsInfoNet(
    ULONG64 ActualAddress
    );

VOID
DumpAfdTPacketsInfoBriefNet (
    ULONG64 ActualAddress
    );

VOID
DumpAfdTPacketsInfoXp(
    ULONG64 ActualAddress
    );

VOID
DumpAfdTPacketsInfoBriefXp (
    ULONG64 ActualAddress
    );

PSTR
BufferFlagsToString(
    );

PSTR
SystemTimeToString(
    LONGLONG Value
    );

PSTR
GroupTypeToString(
    AFD_GROUP_TYPE GroupType
    );

VOID
DumpReferenceDebug(
    PAFD_REFERENCE_DEBUG ReferenceDebug,
    ULONG CurrentSlot
    );

BOOL
IsTransmitIrpBusy(
    PIRP Irp
    );

PSTR
TdiServiceFlagsToStringBrief(
    ULONG   Flags
    );


//
//  Public functions.
//

VOID
DumpAfdEndpoint(
    ULONG64 ActualAddress
    )

/*++

Routine Description:

    Dumps the specified AFD_ENDPOINT structure.

Arguments:

    ActualAddress - The actual address where the structure resides on the
        debugee.

Return Value:

    None.

--*/

{

    ULONG64         address;
    ULONG           length;
    UCHAR           transportAddress[MAX_TRANSPORT_ADDR];
    ULONG64         irp, process, pid, tinfo;
    ULONG           result;
    PAFDKD_TRANSPORT_INFO transportInfo = NULL;
    USHORT          type;
    UCHAR           state;
    LONG            stateChangeInProgress;
    ULONG           stateFlags, tdiFlags;
    ULONG           EventStatus[AFD_NUM_POLL_EVENTS];


    dprintf(
        "\nAFD_ENDPOINT @ %p:\n",
        ActualAddress
        );

    dprintf(
        "    ReferenceCount               = %ld\n",
        (ULONG)ReadField(ReferenceCount)
        );

    type=(USHORT)ReadField (Type);
    dprintf(
        "    Type                         = %04X (%s)\n",
        type,
        StructureTypeToString( type )
        );

    state=(UCHAR)ReadField (State);
    dprintf(
        "    State                        = %02X (%s)\n",
        state,
        EndpointStateToString(state)
        );

    if ((stateChangeInProgress=(ULONG)ReadField (StateChangeInProgress))!=0) {
        dprintf(
            "    State changing to            = %02X (%s)\n",
            stateChangeInProgress,
            EndpointStateToString( (UCHAR)stateChangeInProgress )
            );
    }


    tdiFlags=(ULONG)ReadField (TdiServiceFlags);
    dprintf(
        "    TdiTransportFlags            = %08lx (",
        tdiFlags
        );
    if (TDI_SERVICE_ORDERLY_RELEASE & tdiFlags)
        dprintf (" OrdRel");
    if (TDI_SERVICE_DELAYED_ACCEPTANCE & tdiFlags)
        dprintf (" DelAcc");
    if (TDI_SERVICE_EXPEDITED_DATA & tdiFlags)
        dprintf (" Expd");
    if (TDI_SERVICE_INTERNAL_BUFFERING & tdiFlags)
        dprintf (" Buff");
    if (TDI_SERVICE_MESSAGE_MODE & tdiFlags)
        dprintf (" Msg");
    if (TDI_SERVICE_DGRAM_CONNECTION & tdiFlags)
        dprintf (" DgramCon");
    if (TDI_SERVICE_FORCE_ACCESS_CHECK & tdiFlags)
        dprintf (" AccChk");
    if (TDI_SERVICE_SEND_AND_DISCONNECT & tdiFlags)
        dprintf (" S&D");
    if (TDI_SERVICE_DIRECT_ACCEPT & tdiFlags)
        dprintf (" DirAcc");
    if (TDI_SERVICE_ACCEPT_LOCAL_ADDR & tdiFlags)
        dprintf (" AccLAd");
    dprintf (" )\n");

    dprintf(
        "    StateFlags                   = %08X (",
        stateFlags = (ULONG)ReadField (EndpointStateFlags)
        );

    if (ReadField (Listening))
        dprintf (" Listn");
    if (ReadField (DelayedAcceptance))
        dprintf (" DelAcc");
    if (ReadField (NonBlocking))
        dprintf (" NBlock");
    if (ReadField (InLine))
        dprintf (" InLine");
    if (ReadField (EndpointCleanedUp))
        dprintf (" Clnd-up");
    if (ReadField (PollCalled))
        dprintf (" Polled");
    if (ReadField (RoutingQueryReferenced))
        dprintf (" RtQ");
    if (SavedMinorVersion>=2246) {
        if (ReadField (RoutingQueryIPv6))
            dprintf (" RtQ6");
    }
    if (ReadField (DisableFastIoSend))
        dprintf (" -FastSnd");
    if (ReadField (EnableSendEvent))
        dprintf (" +SndEvt");
    if (ReadField (DisableFastIoRecv))
        dprintf (" -FastRcv");
    dprintf (" )\n");


    dprintf(
        "    TransportInfo                = %p\n",
        address = ReadField (TransportInfo)
        );

    if (address!=0) {
        PLIST_ENTRY           listEntry;

        listEntry = TransportInfoList.Flink;
        while (listEntry!=&TransportInfoList) {
            transportInfo = CONTAINING_RECORD (listEntry, AFDKD_TRANSPORT_INFO, Link);
            if (transportInfo->ActualAddress==address)
                break;
            listEntry = listEntry->Flink;
        }

        if (listEntry==&TransportInfoList) {
            transportInfo = ReadTransportInfo (address);
            if (transportInfo!=NULL) {
                InsertHeadList (&TransportInfoList, &transportInfo->Link);
            }
        }

        if (transportInfo!=NULL) {
            dprintf(
                "        TransportDeviceName      = %ls\n",
                transportInfo->DeviceName
                );
        }

    }

    dprintf(
        "    AddressHandle                = %p\n",
        ReadField (AddressHandle)
        );

    dprintf(
        "    AddressFileObject            = %p\n",
        ReadField (AddressFileObject)
        );

    dprintf(
        "    AddressDeviceObject          = %p\n",
        ReadField (AddressDeviceObject)
        );

    dprintf(
        "    AdminAccessGranted           = %s\n",
        BooleanToString( (BOOLEAN)ReadField (AdminAccessGranted))
        );

    switch( type ) {

    case AfdBlockTypeVcConnecting :

        address = ReadField (Common.VirtualCircuit.Connection);
        dprintf(
            "    Connection                   = %p",
            address!=0
                ? address
                : (((state==AfdEndpointStateClosing ||
                            state==AfdEndpointStateTransmitClosing) &&
                        ((address = ReadField (WorkItem.Context))!=0))
                    ? address
                    : 0)
            );

        if (address!=0) {
            ULONG64 connAddr = address;
            if (GetFieldValue (connAddr,
                                "AFD!AFD_CONNECTION",
                                "RemoteAddress",
                                address)==0 &&
                                address!=0 &&
                    GetFieldValue (connAddr,
                                "AFD!AFD_CONNECTION",
                                "RemoteAddressLength",
                                length)==0 &&
                                length!=0 ) {

                if (ReadMemory (address,
                                transportAddress,
                                length<sizeof (transportAddress) 
                                    ? length
                                    : sizeof (transportAddress),
                                    &length)) {
                    dprintf (" (to %s)", TransportAddressToString (
                                                (PTRANSPORT_ADDRESS)transportAddress, address));
                }
                else {
                    dprintf (" (Could not read transport address @ %p)", address);
                }
            }
            else if (state==AfdEndpointStateConnected ||
                     state==AfdEndpointStateTransmitClosing) {
                ULONG64 contextAddr;
                //
                // Attempt to read user mode data stored as the context
                //
                result = GetRemoteAddressFromContext (ActualAddress,
                                                transportAddress, 
                                                sizeof (transportAddress),
                                                &contextAddr);
                if (result==0) {
                    dprintf (" (to %s)", TransportAddressToString (
                                                (PTRANSPORT_ADDRESS)transportAddress, contextAddr));
                }
                else if ((result==MEMORY_READ_ERROR) &&
                        (transportInfo!=NULL) &&
                        (_wcsicmp (transportInfo->DeviceName, L"\\Device\\TCP")==0)) {
                    ULONG64 tdiFile;
                    if ((result=GetFieldValue (connAddr, 
                                                "AFD!AFD_CONNECTION", 
                                                "FileObject", 
                                                tdiFile))==0 &&
                        (result=GetRemoteAddressFromTcp (tdiFile,
                                                transportAddress, 
                                                sizeof (transportAddress)))==0) {
                        dprintf (" (to %s)", TransportAddressToString (
                                                    (PTRANSPORT_ADDRESS)transportAddress, contextAddr));
                    }
                    else {
                        dprintf (" (Could not read transport address from endpoint context @%p (err: %ld) and TCP (err: %ld))",
                                    contextAddr, MEMORY_READ_ERROR, result);
                    }
                }
                else {
                    dprintf (" (Could not read transport address from endpoint context @ %p (err: %ld))", contextAddr, result);
                }
            }
        }
        dprintf("\n");
        dprintf(
            "    ListenEndpoint               = %p\n",
            ReadField (Common.VirtualCircuit.ListenEndpoint)
            );

        dprintf(
            "    ConnectDataBuffers           = %p\n",
            ReadField (Common.VirtualCircuit.ConnectDataBuffers)
            );
        break;

    case AfdBlockTypeVcBoth :
        dprintf(
            "    Connection                   = %p",
            address=ReadField (Common.VirtualCircuit.Connection)
            );

        if (address!=0) {
            ULONG64 connAddr = address;
            if (GetFieldValue (connAddr,
                                "AFD!AFD_CONNECTION",
                                "RemoteAddress",
                                address)==0 &&
                                address!=0 &&
                    GetFieldValue (connAddr,
                                "AFD!AFD_CONNECTION",
                                "RemoteAddressLength",
                                length)==0 &&
                                length!=0 ) {

                if (ReadMemory (address,
                                transportAddress,
                                length<sizeof (transportAddress) 
                                    ? length
                                    : sizeof (transportAddress),
                                    &length)) {
                    dprintf (" (to %s)", TransportAddressToString (
                                                (PTRANSPORT_ADDRESS)transportAddress, address));
                }
                else {
                    dprintf (" (Could not read transport address @ %p)", address);
                }
            }
            else if (state==AfdEndpointStateConnected ||
                     state==AfdEndpointStateTransmitClosing) {
                ULONG64 contextAddr;
                //
                // Attempt to read user mode data stored as the context
                //
                result = GetRemoteAddressFromContext (ActualAddress,
                                                transportAddress, 
                                                sizeof (transportAddress),
                                                &contextAddr);
                if (result==0) {
                    dprintf (" (to %s)", TransportAddressToString (
                                                (PTRANSPORT_ADDRESS)transportAddress, contextAddr));
                }
                else if ((result==MEMORY_READ_ERROR) &&
                        (transportInfo!=NULL) &&
                        (_wcsicmp (transportInfo->DeviceName, L"\\Device\\TCP")==0)) {
                    ULONG64 tdiFile;
                    if ((result=GetFieldValue (connAddr, 
                                                "AFD!AFD_CONNECTION", 
                                                "FileObject", 
                                                tdiFile))==0 &&
                        (result=GetRemoteAddressFromTcp (tdiFile,
                                                transportAddress, 
                                                sizeof (transportAddress)))==0) {
                        dprintf (" (to %s)", TransportAddressToString (
                                                    (PTRANSPORT_ADDRESS)transportAddress, contextAddr));
                    }
                    else {
                        dprintf (" (Could not read transport address from endpoint context @%p (err: %ld) and TCP (err: %ld))",
                                    contextAddr, MEMORY_READ_ERROR, result);
                    }
                }
                else {
                    dprintf (" (Could not read transport address from endpoint context @ %p)", contextAddr);
                }
            }
        }
        dprintf ("\n");
        dprintf(
            "    ConnectDataBuffers           = %p\n",
            ReadField (Common.VirtualCircuit.ConnectDataBuffers)
            );

        // Skip through to listening endpoint

    case AfdBlockTypeVcListening :

        if (ReadField(DelayedAcceptance)) {
            dprintf(
                "    ListenConnectionListHead @ %s\n",
                LIST_TO_STRING(
                    ActualAddress+ListenConnListOffset
                    )
                );

        }
        else {
            dprintf(
                "    FreeConnectionListHead       @ %p(%d)\n",
                ActualAddress + FreeConnListOffset,
                (USHORT)ReadField (Common.VirtualCircuit.Listening.FreeConnectionListHead.Depth)
                );

            dprintf(
                "    AcceptExIrpListHead          @ %p(%d)\n",
                ActualAddress + PreaccConnListOffset,
                (USHORT)ReadField (Common.VirtualCircuit.Listening.PreacceptedConnectionsListHead.Depth)
                );
        }

        dprintf(
            "    UnacceptedConnectionListHead %s\n",
            LIST_TO_STRING(
                ActualAddress + UnacceptedConnListOffset)
            );


        dprintf(
            "    ReturnedConnectionListHead   %s\n",
            LIST_TO_STRING(
                ActualAddress + ReturnedConnListOffset)
            );

        dprintf(
            "    ListeningIrpListHead         %s\n",
            LIST_TO_STRING(
                ActualAddress + ListenIrpListOffset)
            );

        dprintf(
            "    FailedConnectionAdds         = %ld\n",
            (LONG)ReadField (Common.VirtualCircuit.Listening.FailedConnectionAdds)
            );

        dprintf(
            "    TdiAcceptPendingCount        = %ld\n",
            (LONG)ReadField (Common.VirtualCircuit.Listening.TdiAcceptPendingCount)
            );


        dprintf(
            "    MaxCachedConnections         = %ld\n",
            (USHORT)ReadField (Common.VirtualCircuit.Listening.MaxExtraConnections)
            );


        dprintf(
            "    ConnectionSequenceNumber     = %ld\n",
            (LONG)ReadField (Common.VirtualCircuit.ListeningSequence)
            );


        dprintf(
            "    BacklogReplenishActive       = %s\n",
            BooleanToString (
                (BOOLEAN)ReadField (Common.VirtualCircuit.Listening.BacklogReplenishActive))
            );

        dprintf(
    
            "    EnableDynamicBacklog         = %s\n",
            BooleanToString (
                (BOOLEAN)(LONG)ReadField (Common.VirtualCircuit.Listening.EnableDynamicBacklog))
            );

        break;

    case AfdBlockTypeDatagram :

        dprintf(
            "    RemoteAddress                = %p\n",
            address = ReadField (Common.Datagram.RemoteAddress)
            );

        dprintf(
            "    RemoteAddressLength          = %lu\n",
            length=(ULONG)ReadField (Common.Datagram.RemoteAddressLength)
            );

        if( address!=0 ) {

            if (ReadMemory (address,
                            transportAddress,
                            length<sizeof (transportAddress) 
                                ? length
                                : sizeof (transportAddress),
                                &length)) {
                DumpTransportAddress(
                    "    ",
                    (PTRANSPORT_ADDRESS)transportAddress,
                    address
                    );
            }
            else {
                dprintf ("\nDumpAfdEndpoint: Could not read transport address @ %p\n", address);
            }

        }

        dprintf(
            "    ReceiveIrpListHead           %s\n",
            LIST_TO_STRING(
                ActualAddress + DatagramRecvListOffset)
            );


        dprintf(
            "    PeekIrpListHead              %s\n",
            LIST_TO_STRING(
                ActualAddress + DatagramPeekListOffset)
            );


        dprintf(
            "    ReceiveBufferListHead        %s\n",
            LIST_TO_STRING(
                ActualAddress + DatagramBufferListOffset)
            );


        dprintf(
            "    BufferredReceiveBytes        = %08lx\n",
            (ULONG)ReadField (Common.Datagram.BufferredReceiveBytes)
            );

        dprintf(
            "    BufferredReceiveCount        = %04X\n",
            (ULONG)ReadField (Common.Datagram.BufferredReceiveCount)
            );

        dprintf(
            "    MaxBufferredReceiveBytes     = %08lx\n",
            (ULONG)ReadField (Common.Datagram.MaxBufferredReceiveBytes)
            );


        dprintf(
            "    BufferredSendBytes           = %08lx\n",
            (ULONG)ReadField (Common.Datagram.BufferredSendBytes)
            );

        dprintf(
            "    MaxBufferredSendBytes        = %08lx\n",
            (ULONG)ReadField (Common.Datagram.MaxBufferredSendBytes)
            );

        dprintf(
            "    CircularQueueing             = %s\n",
            BooleanToString(
                (BOOLEAN)ReadField (Common.Datagram.CircularQueueing ))
            );

        dprintf(
            "    HalfConnect                  = %s\n",
            BooleanToString( 
                (BOOLEAN)ReadField (Common.Datagram.HalfConnect))
            );

        if (SavedMinorVersion>=2466) {
            dprintf(
                "    PacketsDropped due to          %s%s%s%s\n",
                ReadField (Common.Datagram.AddressDrop)
                        ? "source address, "
                        : "",
                ReadField (Common.Datagram.ResourceDrop)
                        ? "out of memory, "
                        : "",
                ReadField (Common.Datagram.BufferDrop)
                        ? "SO_RCVBUF setting, "
                        : "",
                ReadField (Common.Datagram.ErrorDrop)
                        ? "transport error"
                        : ""
                );
        }
        break;

    case AfdBlockTypeSanEndpoint :
        dprintf(
            "    HelperEndpoint               = %p\n",
                ReadField (Common.SanEndp.SanHlpr)
            );
        dprintf(
            "    FileObject                   = %p\n",
                ReadField (Common.SanEndp.FileObject)
            );
        dprintf(
            "    Switch/Saved Context         = %p (length: %d)\n",
                ReadField (Common.SanEndp.SwitchContext),
                (ULONG)ReadField (Common.SanEndp.SavedContextLength)
            );
        dprintf(
            "    Local Context                = %p\n",
                ReadField (Common.SanEndp.LocalContext)
            );
        dprintf(
            "    Select Events Active         = %lx\n",
                (ULONG)ReadField (Common.SanEndp.SelectEventsActive)
            );
        dprintf(
            "    Request IrpList              %s\n",
            LIST_TO_STRING(
                ActualAddress + SanIrpListOffset)
            );
        dprintf(
            "    Request ID                   = %d\n",
                (ULONG)ReadField (Common.SanEndp.RequestId)
            );
        dprintf(
            "    CtxTransferStatus            = %lx%s\n",
                (ULONG)ReadField (Common.SanEndp.CtxTransferStatus),
                ReadField (Common.SanEndp.ImplicitDup) ? " (implicit)" : ""
            );
        if (state==AfdEndpointStateConnected ||
            state==AfdEndpointStateTransmitClosing) {
            ULONG64 contextAddr;
            //
            // Attempt to read user mode data stored as the context
            //
            result = GetRemoteAddressFromContext (ActualAddress,
                                            transportAddress, 
                                            sizeof (transportAddress),
                                            &contextAddr);
            if (result==0) {
                dprintf ("    Connected to                 = %s\n",
                            TransportAddressToString (
                                    (PTRANSPORT_ADDRESS)transportAddress,
                                    contextAddr));
            }
            else {
                dprintf ("DumAfdEndpoint: Could not read transport address from endpoint context @ %p\n", contextAddr);
            }
        }
        break;

    case AfdBlockTypeSanHelper :
        dprintf(
            "    IoCompletionPort             = %p\n",
                ReadField (Common.SanHlpr.IoCompletionPort)
            );
        dprintf(
            "    IoCompletionEvent            = %p\n",
                ReadField (Common.SanHlpr.IoCompletionEvent)
            );
        dprintf(
            "    Provider list sequence       = %d\n",
                (LONG)ReadField (Common.SanHlpr.Plsn)
            );

        if (SavedMinorVersion>=3549) {
            result = (LONG)ReadField (Common.SanHlpr.PendingRequests);
            dprintf(
                "    Pending requests             = %d%s\n",
                    result >> 1,
                    (result & 1) ? " (cleaned-up)" : ""

                );
        }
        break;
    }

    dprintf(
        "    DisconnectMode               = %08lx\n",
        (ULONG)ReadField (DisconnectMode)
        );

    dprintf(
        "    OutstandingIrpCount          = %08lx\n",
        (ULONG)ReadField (OutstandingIrpCount)
        );

    dprintf(
        "    LocalAddress                 = %p\n",
        address = ReadField (LocalAddress)
        );

    dprintf(
        "    LocalAddressLength           = %08lx\n",
        length = (ULONG)ReadField (LocalAddressLength)
        );

    if (address!=0) {
        if (ReadMemory (address,
                        transportAddress,
                        length<sizeof (transportAddress) 
                            ? length
                            : sizeof (transportAddress),
                            &length)) {
            DumpTransportAddress(
                "    ",
                (PTRANSPORT_ADDRESS)transportAddress,
                address
                );
        }
        else {
            dprintf ("\nDumpAfdEndpoint: Could not read transport address @ %p\n", address);
        }
    }

    dprintf(
        "    Context                      = %p\n",
        ReadField (Context)
        );

    dprintf(
        "    ContextLength                = %08lx\n",
        (ULONG)ReadField (ContextLength)
        );

    if (SavedMinorVersion>=2419) {
        process = ReadField (OwningProcess);
    }
    else {
        process = ReadField (ProcessCharge.Process);
    }

    if (GetFieldValue (
                process,
                "NT!_EPROCESS",
                "UniqueProcessId",
                pid)!=0) {
        pid = 0;
    }

    dprintf(
        "    OwningProcess                = %p (0x%lx)\n",
        process, (ULONG)pid
        );

    if (SavedMinorVersion>=2219) {
        irp = ReadField (Irp);
        if (irp!=0) {
            if (state==AfdEndpointStateConnected ||
                    state==AfdEndpointStateTransmitClosing) {
                ULONG64 tpInfo;
                dprintf(
                    "    Transmit Irp                 = %p",
                    irp);
                result = GetFieldValue (
                                    irp,
                                    "NT!_IRP",
                                    "AssociatedIrp.SystemBuffer",
                                    tpInfo);
                if (result==0) {
                    dprintf (" (TPInfo @ %p)\n", tpInfo);
                }
                else {
                    dprintf ("\nDumpAfdEndpoint: Could not read Irp's system buffer, err: %d\n",
                        result);
                }
            }
            else if (state==AfdEndpointStateOpen) {
                dprintf(
                    "    Super Accept Irp             = %p\n",
                    irp
                    );
            }
        }
    }
    else {
        tinfo=ReadField (TransmitInfo);

        if (tinfo!=0) {
            dprintf(
                "    TransmitInfo                 = %p\n",
                tinfo
                );
        }
    }

    dprintf(
        "    RoutingNotificationList      %s\n",
        LIST_TO_STRING(
                ActualAddress + RoutingNotifyListOffset)
        );



    dprintf(
        "    RequestList                  %s\n",
        LIST_TO_STRING(
                ActualAddress + RequestListOffset)
        );


    dprintf(
        "    EventObject                  = %p\n",
        ReadField (EventObject)
        );

    dprintf(
        "    EventsEnabled                = %08lx\n",
        (ULONG)ReadField (EventsEnabled)
        );

    dprintf(
        "    EventsActive                 = %08lx\n",
        (ULONG)ReadField (EventsActive)
        );

    dprintf(
        "    EventStatus (non-zero only)  =");
    ReadMemory (ActualAddress+EventStatusOffset,
                    EventStatus,
                    sizeof (EventStatus),
                    &length);
    if (EventStatus[AFD_POLL_RECEIVE_BIT]!=0) {
        dprintf (" recv:%lx", EventStatus[AFD_POLL_RECEIVE_BIT]);
    }
    if (EventStatus[AFD_POLL_RECEIVE_EXPEDITED_BIT]!=0) {
        dprintf (" rcv exp:%lx", EventStatus[AFD_POLL_RECEIVE_EXPEDITED_BIT]);
    }
    if (EventStatus[AFD_POLL_SEND_BIT]!=0) {
        dprintf (" send:%lx", EventStatus[AFD_POLL_SEND_BIT]);
    }
    if (EventStatus[AFD_POLL_DISCONNECT_BIT]!=0) {
        dprintf (" disc:%lx", EventStatus[AFD_POLL_DISCONNECT_BIT]);
    }
    if (EventStatus[AFD_POLL_ABORT_BIT]!=0) {
        dprintf (" abort:%lx", EventStatus[AFD_POLL_ABORT_BIT]);
    }
    if (EventStatus[AFD_POLL_LOCAL_CLOSE_BIT]!=0) {
        dprintf (" close:%lx", EventStatus[AFD_POLL_LOCAL_CLOSE_BIT]);
    }
    if (EventStatus[AFD_POLL_CONNECT_BIT]!=0) {
        dprintf (" connect:%lx", EventStatus[AFD_POLL_CONNECT_BIT]);
    }
    if (EventStatus[AFD_POLL_ACCEPT_BIT]!=0) {
        dprintf (" accept:%lx", EventStatus[AFD_POLL_ACCEPT_BIT]);
    }
    if (EventStatus[AFD_POLL_CONNECT_FAIL_BIT]!=0) {
        dprintf (" con fail:%lx", EventStatus[AFD_POLL_CONNECT_FAIL_BIT]);
    }
    if (EventStatus[AFD_POLL_QOS_BIT]!=0) {
        dprintf (" qos:%lx", EventStatus[AFD_POLL_QOS_BIT]);
    }
    if (EventStatus[AFD_POLL_GROUP_QOS_BIT]!=0) {
        dprintf (" gqos:%lx", EventStatus[AFD_POLL_GROUP_QOS_BIT]);
    }
    if (EventStatus[AFD_POLL_ROUTING_IF_CHANGE_BIT]!=0) {
        dprintf (" route chng:%lx", EventStatus[AFD_POLL_ROUTING_IF_CHANGE_BIT]);
    }
    if (EventStatus[AFD_POLL_ADDRESS_LIST_CHANGE_BIT]!=0) {
        dprintf (" addr chng:%lx", EventStatus[AFD_POLL_ADDRESS_LIST_CHANGE_BIT]);
    }
    dprintf ("\n");
        
    dprintf(
        "    GroupID                      = %08lx\n",
        (ULONG)ReadField (GroupID)
        );

    dprintf(
        "    GroupType                    = %s\n",
        GroupTypeToString( (ULONG)ReadField (GroupType) )
        );

    if( IsReferenceDebug ) {
        

        dprintf(
            "    ReferenceDebug               = %p\n",
            ActualAddress + EndpRefOffset
            );

        if (SavedMinorVersion>=3554) {
            ULONGLONG refCount;
            refCount = ReadField (CurrentReferenceSlot);
            if (SystemTime.QuadPart!=0) {
                dprintf(
                    "    CurrentReferenceSlot         = %lu (@ %s)\n",
                    (ULONG)refCount & AFD_REF_MASK,
                    SystemTimeToString (
                        (((ReadField (CurrentTimeHigh)<<32) + 
                        (refCount&(~AFD_REF_MASK)))<<(13-AFD_REF_SHIFT)) +
                        SystemTime.QuadPart -
                        InterruptTime.QuadPart)
                    );
                 
            }
            else {
                dprintf(
                "    CurrentReferenceSlot         = %lu (@ %I64u ms since boot)\n",
                 (ULONG)refCount & AFD_REF_MASK,
                 (((ReadField (CurrentTimeHigh)<<32) + 
                    (refCount&(~AFD_REF_MASK)))<<(13-AFD_REF_SHIFT))/(10*1000)
                );
            }
        }
        else {
            dprintf(
                "    CurrentReferenceSlot         = %lu\n",
                 (ULONG)ReadField (CurrentReferenceSlot) & AFD_REF_MASK
            );
        }

    }

    dprintf( "\n" );

}   // DumpAfdEndpoint

VOID
DumpAfdEndpointBrief (
    ULONG64 ActualAddress
    )

/*++

Routine Description:

    Dumps the specified AFD_ENDPOINT structure in short format.

Endpoint Typ State  Flags    Transport Port    Counts    Evt Pid   Con/RAdr
xxxxxxxx xxx xxx xxxxxxxxxxxx xxxxxxxx xxxxx xx xx xx xx xxx xxxx  xxxxxxxx

Endpoint    Typ State  Flags    Transport Port    Counts    Evt Pid   Con/RemAddr
xxxxxxxxxxx xxx xxx xxxxxxxxxxxx xxxxxxxx xxxxx xx xx xx xx xxx xxxx  xxxxxxxxxxx

Arguments:
    ActualAddress - The actual address where the structure resides on the
        debugee.

Return Value:

    None.

--*/
{
    CHAR    ctrs[40];
    LPSTR   port;
    UCHAR   transportAddress[MAX_TRANSPORT_ADDR];
    UCHAR   remoteAddress[MAX_ADDRESS_STRING];
    PUCHAR  raddr;
    PAFDKD_TRANSPORT_INFO transportInfo = NULL;
    ULONG64 address, trInfoAddr, localAddr, sanSvcHlpr=0;
    ULONG   length;
    ULONG64 process, pid;
    USHORT  type;
    UCHAR   state;

    type = (USHORT)ReadField (Type);
    state = (UCHAR)ReadField (State);

    if ((trInfoAddr=ReadField (TransportInfo))!=0) {
        PLIST_ENTRY  listEntry;

        listEntry = TransportInfoList.Flink;
        while (listEntry!=&TransportInfoList) {
            transportInfo = CONTAINING_RECORD (listEntry, AFDKD_TRANSPORT_INFO, Link);
            if (transportInfo->ActualAddress==trInfoAddr)
                break;
            listEntry = listEntry->Flink;
        }

        if (listEntry==&TransportInfoList) {
            transportInfo = ReadTransportInfo (trInfoAddr);
            if (transportInfo!=NULL) {
                InsertHeadList (&TransportInfoList, &transportInfo->Link);
            }
        }
    }

    raddr = remoteAddress;
    switch (type) {
    case AfdBlockTypeDatagram :
        _snprintf (ctrs, sizeof (ctrs)-1, "%5.5x %5.5x", 
            (ULONG)ReadField (Common.Datagram.BufferredSendBytes),
            (ULONG)ReadField (Common.Datagram.BufferredReceiveBytes)
            );
        ctrs[sizeof(ctrs)-1]=0;
        address = ReadField (Common.Datagram.RemoteAddress);
        length = (ULONG)ReadField (Common.Datagram.RemoteAddressLength);
        _snprintf (remoteAddress, sizeof (remoteAddress)-1, 
                    IsPtr64 () ? "%011.011I64X" : "%008.008I64X",
                    DISP_PTR(address));
        remoteAddress[sizeof(remoteAddress)-1]=0;
        if (Options & AFDKD_RADDR_DISPLAY) {
            if (address!=0 && length!=0) {
                if (ReadMemory (address,
                                transportAddress,
                                length<sizeof (transportAddress) 
                                    ? length
                                    : sizeof (transportAddress),
                                    &length)) {
                    raddr = TransportAddressToString(
                        (PTRANSPORT_ADDRESS)transportAddress,
                        address
                        );
                }
                else {
                    _snprintf (remoteAddress, sizeof (remoteAddress)-1, 
                                "Read error @%I64X", 
                                IsPtr64 () ? address : (address & 0xFFFFFFFF));
                    remoteAddress[sizeof(remoteAddress)-1]=0;
                }
            }
            else
                raddr = "";
        }
        break;
    case AfdBlockTypeVcConnecting:
        address = ReadField (Common.VirtualCircuit.Connection);
        address = 
            address!=0
                ? address
                : (((state==AfdEndpointStateClosing ||
                            state==AfdEndpointStateTransmitClosing) &&
                        ((address = ReadField (WorkItem.Context))!=0))
                    ? address
                    : 0);
        _snprintf (remoteAddress, sizeof (remoteAddress)-1,
                    IsPtr64 () ? "%011.011I64X" : "%008.008I64X",
                    DISP_PTR(address));
        remoteAddress[sizeof(remoteAddress)-1]=0;
        if (address!=0) {
            AFD_CONNECTION_STATE_FLAGS   flags;
            ULONG sndB = 0, rcvB = 0;
            if (GetFieldValue (address,
                                "AFD!AFD_CONNECTION",
                                "ConnectionStateFlags",
                                flags)==0) {
                if (flags.TdiBufferring) {
                    ULONGLONG taken, there;
                    GetFieldValue (address,
                            "AFD!AFD_CONNECTION",
                            "Common.Bufferring.ReceiveBytesIndicated.QuadPart",
                            taken);
                    GetFieldValue (address,
                            "AFD!AFD_CONNECTION",
                            "Common.Bufferring.ReceiveBytesTaken.QuadPart",
                            there);
                    sndB = 0;
                    rcvB = (ULONG)(taken-there);
                }
                else {
                    GetFieldValue (address,
                            "AFD!AFD_CONNECTION",
                            "Common.NonBufferring.BufferredReceiveBytes",
                            rcvB);
                    GetFieldValue (address,
                            "AFD!AFD_CONNECTION",
                            "Common.NonBufferring.BufferredSendBytes",
                            sndB);
                }
                _snprintf (ctrs, sizeof (ctrs)-1, "%5.5x %5.5x", sndB, rcvB);
                ctrs[sizeof(ctrs)-1]=0;

                if (Options & AFDKD_RADDR_DISPLAY) {
                    ULONG64 connAddr = address;
                    if (GetFieldValue (connAddr,
                                        "AFD!AFD_CONNECTION",
                                        "RemoteAddress",
                                        address)==0 &&
                                        address!=0 &&
                            GetFieldValue (connAddr,
                                        "AFD!AFD_CONNECTION",
                                        "RemoteAddressLength",
                                        length)==0 &&
                                        length!=0 ) {

                        if (ReadMemory (address,
                                        transportAddress,
                                        length<sizeof (transportAddress) 
                                            ? length
                                            : sizeof (transportAddress),
                                            &length)) {
                            raddr = TransportAddressToString(
                                (PTRANSPORT_ADDRESS)transportAddress,
                                address
                                );
                        }
                        else {
                            _snprintf (remoteAddress, sizeof (remoteAddress)-1, 
                                        "Read error @%I64X", 
                                        IsPtr64 () ? address : (address & 0xFFFFFFFF));
                            remoteAddress[sizeof(remoteAddress)-1]=0;
                        }
                    }
                    else if (state==AfdEndpointStateConnected ||
                             state==AfdEndpointStateTransmitClosing) {
                        ULONG result;
                        ULONG64 contextAddr;
                        //
                        // Attempt to read user mode data stored as the context
                        //
                        result = GetRemoteAddressFromContext (ActualAddress,
                                                        transportAddress, 
                                                        sizeof (transportAddress),
                                                        &contextAddr);
                        if (result==0) {
                            raddr = TransportAddressToString(
                                (PTRANSPORT_ADDRESS)transportAddress,
                                contextAddr
                                );
                        }
                        else if ((result==MEMORY_READ_ERROR) &&
                                (transportInfo!=NULL) &&
                                (_wcsicmp (transportInfo->DeviceName, L"\\Device\\TCP")==0)) {
                            ULONG64 tdiFile;
                            if ((result=GetFieldValue (connAddr, 
                                                        "AFD!AFD_CONNECTION", 
                                                        "FileObject", 
                                                        tdiFile)==0) &&
                                (result=GetRemoteAddressFromTcp (tdiFile,
                                                        transportAddress, 
                                                        sizeof (transportAddress)))==0) {
                                raddr = TransportAddressToString (
                                                            (PTRANSPORT_ADDRESS)transportAddress, contextAddr);
                            }
                            else {
                                _snprintf (remoteAddress, sizeof (remoteAddress)-1, 
                                            "Read error %ld @ %I64X", result, 
                                            IsPtr64 () ? contextAddr : (contextAddr & 0xFFFFFFFF));
                                remoteAddress[sizeof(remoteAddress)-1]=0;;
                            }
                        }
                        else {
                            _snprintf (remoteAddress, sizeof (remoteAddress)-1, 
                                        "Read error %ld @ %I64X", result, 
                                        IsPtr64 () ? contextAddr : (contextAddr & 0xFFFFFFFF));
                            remoteAddress[sizeof(remoteAddress)-1]=0;
                        }
                    }
                }
            }
            else {
                _snprintf (ctrs, sizeof (ctrs)-1, "Read error!");
                ctrs[sizeof(ctrs)-1]=0;
            }
        }
        else {
            _snprintf (ctrs, sizeof (ctrs)-1, "           ");
            ctrs[sizeof(ctrs)-1]=0;
        }
        break;
    case AfdBlockTypeVcListening:
    case AfdBlockTypeVcBoth:
        _snprintf (remoteAddress, sizeof (remoteAddress)-1,
                    "mc:%1.1x,fd:%1.1x",
                    (USHORT)ReadField (Common.VirtualCircuit.Listening.MaxExtraConnections),
                    (LONG)ReadField (Common.VirtualCircuit.Listening.FailedConnectionAdds));
        remoteAddress[sizeof(remoteAddress)-1]=0;
        raddr = remoteAddress;
        if (ReadField (DelayedAcceptance)) {
            if (Options & AFDKD_LIST_COUNT) {
                _snprintf (ctrs, sizeof (ctrs)-1, "%2.2x %2.2x %2.2x %2.2x",
                    CountListEntries (ActualAddress+ListenConnListOffset),
                    CountListEntries (ActualAddress+ListenIrpListOffset),
                    (LONG)ReadField(Common.VirtualCircuit.Listening.TdiAcceptPendingCount),
                    CountListEntries (ActualAddress+UnacceptedConnListOffset));
                ctrs[sizeof(ctrs)-1]=0;
            }
            else {
                _snprintf (ctrs, sizeof (ctrs)-1, "%2.2s %2.2s %2.2x %2.2s",
                    ListCountEstimate (ActualAddress+ListenConnListOffset),
                    ListCountEstimate (ActualAddress+ListenIrpListOffset),
                    (LONG)ReadField(Common.VirtualCircuit.Listening.TdiAcceptPendingCount),
                    ListCountEstimate (ActualAddress+UnacceptedConnListOffset));
                ctrs[sizeof(ctrs)-1]=0;
            }
        }
        else {
            if (Options & AFDKD_LIST_COUNT) {
                _snprintf (ctrs, sizeof (ctrs)-1, "%2.2x %2.2x %2.2x %2.2x", 
                    (USHORT)ReadField (Common.VirtualCircuit.Listening.FreeConnectionListHead.Depth),
                    (USHORT)ReadField (Common.VirtualCircuit.Listening.PreacceptedConnectionsListHead.Depth),
                    (LONG)ReadField(Common.VirtualCircuit.Listening.TdiAcceptPendingCount),
                    CountListEntries (ActualAddress+UnacceptedConnListOffset));
                ctrs[sizeof(ctrs)-1]=0;
            }
            else {
                _snprintf (ctrs, sizeof (ctrs)-1, "%2.2x %2.2x %2.2x %2.2s", 
                    (USHORT)ReadField (Common.VirtualCircuit.Listening.FreeConnectionListHead.Depth),
                    (USHORT)ReadField (Common.VirtualCircuit.Listening.PreacceptedConnectionsListHead.Depth),
                    (LONG)ReadField(Common.VirtualCircuit.Listening.TdiAcceptPendingCount),
                    ListCountEstimate (ActualAddress+UnacceptedConnListOffset));
                ctrs[sizeof(ctrs)-1]=0;
            }
        }
        break;
    case AfdBlockTypeSanEndpoint:
        if (Options & AFDKD_RADDR_DISPLAY) {
            ULONG result;
            ULONG64 contextAddr;
            //
            // Attempt to read user mode data stored as the context
            //
            result = GetRemoteAddressFromContext (ActualAddress,
                                            transportAddress, 
                                            sizeof (transportAddress),
                                            &contextAddr);
            if (result==0) {
                raddr = TransportAddressToString(
                    (PTRANSPORT_ADDRESS)transportAddress,
                    contextAddr
                    );
            }
            else {
                _snprintf (remoteAddress, sizeof (remoteAddress)-1, 
                            "Read error %ld @ %I64X", result, 
                            IsPtr64 () ? contextAddr : (contextAddr & 0xFFFFFFFF));
                remoteAddress[sizeof(remoteAddress)-1]=0;
            }
        }
        else {
            _snprintf (remoteAddress, sizeof (remoteAddress)-1, 
                        IsPtr64 () ? "H:%011.011I64X" : "H:%008.008I64X",
                        DISP_PTR (ReadField (Common.SanEndp.SanHlpr)));
            remoteAddress[sizeof(remoteAddress)-1]=0;
        }
        _snprintf (ctrs,  sizeof (ctrs)-1, "%5.5x %5.5x",
                    (ULONG)ReadField (Common.SanEndp.RequestId),
                    (ULONG)ReadField (Common.SanEndp.SelectEventsActive));
        ctrs[sizeof(ctrs)-1]=0;
        break;
    case AfdBlockTypeSanHelper:
        {
            ULONG64 cPort, depth;
            cPort = ReadField (Common.SanHlpr.IoCompletionPort);
            GetFieldValue (0, "AFD!AfdSanServiceHelper", NULL, sanSvcHlpr);
            GetFieldValue (cPort, "NT!DISPATCHER_HEADER", "SignalState", depth);
            _snprintf (remoteAddress, sizeof (remoteAddress)-1,
                        IsPtr64 () ? "C:%011.011I64X(%d)" : "C:%008.008I64X(%d)",
                        DISP_PTR (cPort), (ULONG)depth);
            remoteAddress[sizeof(remoteAddress)-1]=0;
            _snprintf (ctrs, sizeof (ctrs)-1, "%5.5x %5.5x",
                        (ULONG)ReadField (Common.SanEndp.Plsn),
                        (ULONG)ReadField (Common.SanEndp.PendingRequests));
            ctrs[sizeof(ctrs)-1]=0;
        }
        break;
    case AfdBlockTypeEndpoint:
    default:
        raddr = "";
        _snprintf (ctrs, sizeof (ctrs)-1, "           ");
        ctrs[sizeof(ctrs)-1]=0;
        break;
    }

    port = "     ";
    if ((localAddr=ReadField(LocalAddress))!=0) {
        length = (ULONG)ReadField (LocalAddressLength);
        if (ReadMemory (localAddr,
                        transportAddress,
                        length<sizeof (transportAddress) 
                            ? length
                            : sizeof (transportAddress),
                            &length)) {
            port = TransportPortToString(
                (PTRANSPORT_ADDRESS)transportAddress,
                localAddr
                );
        }
        else {
            port = "error";
        }
    }

    if (SavedMinorVersion>=2419) {
        process = ReadField (OwningProcess);
    }
    else {
        process = ReadField (ProcessCharge.Process);
    }

    if (GetFieldValue (
                process,
                "NT!_EPROCESS",
                "UniqueProcessId",
                pid)!=0) {
        pid = 0;
    }


    /*            Endpoint Typ Sta StFl Tr.Inf    Lport ctrs Events PID   Con/Raddr*/
    dprintf (
        IsPtr64 ()
            ? "\n%011.011p %3s %3s %12s %-9.9ls %5.5s %11s %3.3lx %4.4x %s"
            : "\n%008.008p %3s %3s %12s %-9.9ls %5.5s %11s %3.3lx %4.4x %s",
        DISP_PTR(ActualAddress),
        StructureTypeToStringBrief (type),
        EndpointStateToStringBrief (state),
        EndpointStateFlagsToString (),
        transportInfo
            ? &transportInfo->DeviceName[sizeof("\\Device\\")-1]
            : (ActualAddress==sanSvcHlpr ? L"SVCHLPR" : L""),
        port,
        ctrs,
        (ULONG)ReadField (EventsActive),
        (ULONG)pid,
        raddr
        );
}

VOID
DumpAfdConnection(
    ULONG64 ActualAddress
    )

/*++

Routine Description:

    Dumps the specified AFD_CONNECTION structures.

Arguments:

    Connection - Points to the AFD_CONNECTION structure to dump.

    ActualAddress - The actual address where the structure resides on the
        debugee.

Return Value:

    None.

--*/

{

    ULONG64         address, endpAddr, fileObject, process, pid;
    ULONG           length;
    UCHAR           transportAddress[MAX_TRANSPORT_ADDR];
    USHORT          type, state;
    BOOLEAN         tdiBuf;

    dprintf(
        "\nAFD_CONNECTION @ %p:\n",
        ActualAddress
        );

    type = (USHORT)ReadField (Type);
    dprintf(
        "    Type                         = %04X (%s)\n",
        type,
        StructureTypeToString( type )
        );

    dprintf(
        "    ReferenceCount               = %ld\n",
        (LONG)ReadField (ReferenceCount)
        );

    state = (USHORT)ReadField (State);
    dprintf(
        "    State                        = %08X (%s)\n",
        state,
        ConnectionStateToString( state )
        );

    dprintf(
        "    StateFlags                   = %08X (",
        (ULONG)ReadField (ConnectionStateFlags)
        );

    tdiBuf = (ReadField (TdiBufferring)!=0);
    if (tdiBuf)
        dprintf (" Buf");
    if (SavedMinorVersion>=3549) {
        if (ReadField (Aborted)) {
            dprintf (" Abort%s%s",
                ReadField (AbortIndicated) ? "-ind" : "",
                ReadField (AbortFailed) ? "-fail" : "");
        }
    }
    else {
        if (ReadField (AbortedIndicated)) {
            dprintf (" AbortInd");
        }
    }
    if (ReadField (DisconnectIndicated))
        dprintf (" DscnInd");
    if (ReadField (ConnectedReferenceAdded))
        dprintf (" +CRef");
    if (ReadField (SpecialCondition))
        dprintf (" Special");
    if (ReadField (CleanupBegun))
        dprintf (" ClnBegun");
    if (ReadField (ClosePendedTransmit))
        dprintf (" ClosingTranFile");
    if (ReadField (OnLRList))
        dprintf (" LRList");
    if (ReadField (SanConnection))
        dprintf (" SAN");
    dprintf (" )\n");

    dprintf(
        "    Handle                       = %p\n",
        ReadField (Handle)
        );

    dprintf(
        "    FileObject                   = %p\n",
        fileObject=ReadField (FileObject)
        );

    if (state==AfdConnectionStateConnected) {
        ULONGLONG connectTime;
        connectTime = ReadField (ConnectTime);
        if (SystemTime.QuadPart!=0) {
            dprintf(
                "    ConnectTime                  = %s\n",
                SystemTimeToString( 
                    connectTime-
                        InterruptTime.QuadPart+
                        SystemTime.QuadPart));
            dprintf(
                "                             (now: %s)\n",
                SystemTimeToString (SystemTime.QuadPart)
                );
        }
        else {
            dprintf(
                "    ConnectTime                  = %I64x (nsec since boot)\n",
                    connectTime
                );
        }
    }
    else {
        dprintf(
            "    Accept/Listen Irp            = %p\n",
            ReadField (AcceptIrp)
            );
    }

    if( tdiBuf ) {
        dprintf(
            "    ReceiveBytesIndicated        = %I64d\n",
            ReadField( Common.Bufferring.ReceiveBytesIndicated.QuadPart )
            );

        dprintf(
            "    ReceiveBytesTaken            = %I64d\n",
            ReadField ( Common.Bufferring.ReceiveBytesTaken.QuadPart )
            );

        dprintf(
            "    ReceiveBytesOutstanding      = %I64d\n",
            ReadField( Common.Bufferring.ReceiveBytesOutstanding.QuadPart )
            );

        dprintf(
            "    ReceiveExpeditedBytesIndicated   = %I64d\n",
            ReadField( Common.Bufferring.ReceiveExpeditedBytesIndicated.QuadPart )
            );

        dprintf(
            "    ReceiveExpeditedBytesTaken       = %I64d\n",
            ReadField( Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart )
            );

        dprintf(
            "    ReceiveExpeditedBytesOutstanding = %I64d\n",
            ReadField( Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart )
            );

        dprintf(
            "    NonBlockingSendPossible      = %s\n",
            BooleanToString( (BOOLEAN)ReadField (Common.Bufferring.NonBlockingSendPossible) )
            );

        dprintf(
            "    ZeroByteReceiveIndicated     = %s\n",
            BooleanToString( (BOOLEAN)ReadField (Common.Bufferring.ZeroByteReceiveIndicated) )
            );
    }
    else {

        dprintf(
            "    ReceiveIrpListHead           %s\n",
            LIST_TO_STRING(
                ActualAddress + ConnectionRecvListOffset)
            );


        dprintf(
            "    ReceiveBufferListHead        %s\n",
            LIST_TO_STRING(
                ActualAddress + ConnectionBufferListOffset)
            );

        dprintf(
            "    SendIrpListHead              %s\n",
            LIST_TO_STRING(
                ActualAddress + ConnectionSendListOffset)
            );

        dprintf(
            "    BufferredReceiveBytes        = %lu\n",
            (ULONG)ReadField (Common.NonBufferring.BufferredReceiveBytes)
            );

        dprintf(
            "    BufferredExpeditedBytes      = %lu\n",
            (ULONG)ReadField (Common.NonBufferring.BufferredExpeditedBytes)
            );

        dprintf(
            "    BufferredReceiveCount        = %u\n",
            (USHORT)ReadField (Common.NonBufferring.BufferredReceiveCount)
            );

        dprintf(
            "    BufferredExpeditedCount      = %u\n",
            (USHORT)ReadField (Common.NonBufferring.BufferredExpeditedCount)
            );

        dprintf(
            "    ReceiveBytesInTransport      = %lu\n",
            (ULONG)ReadField (Common.NonBufferring.ReceiveBytesInTransport)
            );

        dprintf(
            "    BufferredSendBytes           = %lu\n",
            (ULONG)ReadField (Common.NonBufferring.BufferredSendBytes)
            );

        dprintf(
            "    BufferredSendCount           = %u\n",
            (USHORT)ReadField (Common.NonBufferring.BufferredSendCount)
            );

        dprintf(
            "    DisconnectIrp                = %p\n",
            ReadField (Common.NonBufferring.DisconnectIrp)
            );

        if (IsCheckedAfd ) {
            dprintf(
                "    ReceiveIrpsInTransport       = %ld\n",
                (ULONG)ReadField (Common.NonBufferring.ReceiveIrpsInTransport)
                );
        }

    }

    dprintf(
        "    Endpoint                     = %p\n",
        endpAddr = ReadField (Endpoint)
        );

    dprintf(
        "    MaxBufferredReceiveBytes     = %lu\n",
        (ULONG)ReadField (MaxBufferredReceiveBytes)
        );

    dprintf(
        "    MaxBufferredSendBytes        = %lu\n",
        (ULONG)ReadField (MaxBufferredSendBytes)
        );

    dprintf(
        "    ConnectDataBuffers           = %p\n",
        ReadField (ConnectDataBuffers)
        );

    if (SavedMinorVersion>=2419) {
        process = ReadField (OwningProcess);
    }
    else {
        process = ReadField (ProcessCharge.Process);
    }

    if (GetFieldValue (
                process,
                "NT!_EPROCESS",
                "UniqueProcessId",
                pid)!=0) {
        pid = 0;
    }

    dprintf(
        "    OwningProcess                = %p (0x%lx)\n",
        process, (ULONG)pid
        );

    dprintf(
        "    DeviceObject                 = %p\n",
        ReadField (DeviceObject)
        );

    dprintf(
        "    RemoteAddress                = %p\n",
        address = ReadField (RemoteAddress)
        );

    length = (USHORT)ReadField (RemoteAddressLength);
    dprintf(
        "    RemoteAddressLength          = %lu\n",
        length
        );

    if( address != 0 ) {

        if (ReadMemory (address,
                        transportAddress,
                        length<sizeof (transportAddress) 
                            ? length
                            : sizeof (transportAddress),
                            &length)) {
            DumpTransportAddress(
                "    ",
                (PTRANSPORT_ADDRESS)transportAddress,
                address
                );
        }
        else {
            dprintf ("\nDumpAfdConnection: Could not read transport address @ %p\n", address);
        }


    }
    else if ((state==AfdConnectionStateConnected) && (endpAddr!=0)) {
        ULONG result;
        ULONG64 contextAddr;
        //
        // Attempt to read user mode data stored as the context
        //
        result = GetRemoteAddressFromContext (endpAddr,
                                        transportAddress, 
                                        sizeof (transportAddress),
                                        &contextAddr);
        if (result==0) {
            DumpTransportAddress(
                "    ",
                (PTRANSPORT_ADDRESS)transportAddress,
                contextAddr
                );
        }
        else if (GetFieldValue (endpAddr, "AFD!AFD_ENDPOINT", 
                                "TransportInfo", address)==0
                    && address!=0) {
            PLIST_ENTRY listEntry;
            PAFDKD_TRANSPORT_INFO transportInfo = NULL;
            listEntry = TransportInfoList.Flink;
            while (listEntry!=&TransportInfoList) {
                transportInfo = CONTAINING_RECORD (listEntry, AFDKD_TRANSPORT_INFO, Link);
                if (transportInfo->ActualAddress==address)
                    break;
                listEntry = listEntry->Flink;
            }

            if (listEntry==&TransportInfoList) {
                transportInfo = ReadTransportInfo (address);
                if (transportInfo!=NULL) {
                    InsertHeadList (&TransportInfoList, &transportInfo->Link);
                }
            }

            if (transportInfo!=NULL &&
                    (_wcsicmp (transportInfo->DeviceName, L"\\Device\\TCP")==0)) {
                if ((result=GetRemoteAddressFromTcp (fileObject,
                                            transportAddress, 
                                            sizeof (transportAddress)))==0) {
                    DumpTransportAddress(
                        "    ",
                        (PTRANSPORT_ADDRESS)transportAddress,
                        fileObject
                        );
                }
                else {
                    dprintf ("\nDumpAfdConnection: Could not get remote address from tcp file @ %p err: %ld)!\n",
                        fileObject, result);
                }
            }
        }

        if (result!=0) {
            dprintf ("\nDumpAfdConnection: Could not read address info from endpoint context @ %p err: %ld)!\n",
                contextAddr, result);
        }
    }



    if( IsReferenceDebug ) {

        dprintf(
            "    ReferenceDebug               = %p\n",
            ActualAddress + ConnRefOffset
            );

        if (SavedMinorVersion>=3554) {
            ULONGLONG refCount;
            refCount = ReadField (CurrentReferenceSlot);
            if (SystemTime.QuadPart!=0) {
                dprintf(
                    "    CurrentReferenceSlot         = %lu (@ %s)\n",
                    (ULONG)refCount & AFD_REF_MASK,
                    SystemTimeToString (
                        (((ReadField (CurrentTimeHigh)<<32) + 
                            (refCount&(~AFD_REF_MASK)))<<(13-AFD_REF_SHIFT))+
                        SystemTime.QuadPart -
                        InterruptTime.QuadPart)
                    );
                 
            }
            else {
                dprintf(
                "    CurrentReferenceSlot         = %lu (@ %I64u ms since boot)\n",
                 (ULONG)refCount & AFD_REF_MASK,
                 (((ReadField (CurrentTimeHigh)<<32) + 
                    (refCount&(~AFD_REF_MASK)))<<(13-AFD_REF_SHIFT))/(10*1000)
                );
            }
        }
        else {
            dprintf(
                "    CurrentReferenceSlot         = %lu\n",
                 (ULONG)ReadField (CurrentReferenceSlot) & AFD_REF_MASK
            );
        }


    }

#ifdef _AFD_VERIFY_DATA_
    dprintf(
        "    VerifySequenceNumber         = %lx\n",
        (LONG)ReadField (VerifySequenceNumber)
        );
#endif
    dprintf( "\n" );

}   // DumpAfdConnection

VOID
DumpAfdConnectionBrief(
    ULONG64 ActualAddress
    )
/*++

Routine Description:

    Dumps the specified AFD_CONNECTION structure in short format.

Connectn Stat Flags  SndB-cnt RcvB-cnt Pid  Endpoint Remote Address"
xxxxxxxx xxx xxxxxxx xxxxx-xx xxxxx-xx xxxx xxxxxxxx xxxxxxxxxxxxxx"

Connection  Stat Flags  SndB-cnt RcvB-cnt Pid  Endpoint    Remote Address"
xxxxxxxxxxx xxx xxxxxxx xxxxx-xx xxxxx-xx xxxx xxxxxxxxxxx xxxxxxxxxxxxxx


Arguments:

    ActualAddress - The actual address where the structure resides on the
        debugee.

Return Value:

    None.

--*/
{
    CHAR            transportAddress[MAX_TRANSPORT_ADDR];
    ULONG64         address, endpAddr, pid, process;
    ULONG           length;
    LPSTR           raddr;
    USHORT          type, state;
    BOOLEAN         tdiBuf;

    type = (USHORT)ReadField (Type);
    state = (USHORT)ReadField (State);
    endpAddr = ReadField (Endpoint);
    address = ReadField (RemoteAddress);
    length = (ULONG)ReadField (RemoteAddressLength);
    tdiBuf = ReadField (TdiBufferring)!=0;

    if( address != 0 ) {
        if (ReadMemory (address,
                        transportAddress,
                        length<sizeof (transportAddress) 
                            ? length
                            : sizeof (transportAddress),
                            &length)) {
            raddr = TransportAddressToString(
                (PTRANSPORT_ADDRESS)transportAddress,
                address
                );
        }
        else {
            _snprintf (transportAddress, sizeof (transportAddress)-1,
                        "Read error @%I64X", 
                        IsPtr64 () ? address : (address & 0xFFFFFFFF));
            transportAddress[sizeof(transportAddress)-1]=0;
            raddr = transportAddress;
        }
    }
    else if ((state==AfdConnectionStateConnected) && (endpAddr!=0)) {
        ULONG result;
        ULONG64 contextAddr;
        //
        // Attempt to read user mode data stored as the context
        //
        result = GetRemoteAddressFromContext (endpAddr,
                                        transportAddress, 
                                        sizeof (transportAddress),
                                        &contextAddr);
        if (result==0) {
            raddr = TransportAddressToString(
                (PTRANSPORT_ADDRESS)transportAddress,
                contextAddr
                );
        }
        else if (GetFieldValue (endpAddr, "AFD!AFD_ENDPOINT", 
                                "TransportInfo", address)==0
                    && address!=0) {
            PLIST_ENTRY listEntry;
            PAFDKD_TRANSPORT_INFO   transportInfo = NULL;
            listEntry = TransportInfoList.Flink;
            while (listEntry!=&TransportInfoList) {
                transportInfo = CONTAINING_RECORD (listEntry, AFDKD_TRANSPORT_INFO, Link);
                if (transportInfo->ActualAddress==address)
                    break;
                listEntry = listEntry->Flink;
            }

            if (listEntry==&TransportInfoList) {
                transportInfo = ReadTransportInfo (address);
                if (transportInfo!=NULL) {
                    InsertHeadList (&TransportInfoList, &transportInfo->Link);
                }
            }

            if (transportInfo!=NULL &&
                    (_wcsicmp (transportInfo->DeviceName, L"\\Device\\TCP")==0)) {
                ULONG64     fileObject = ReadField (FileObject);
                if ((result=GetRemoteAddressFromTcp (fileObject,
                                            transportAddress, 
                                            sizeof (transportAddress)))==0) {
                    raddr = TransportAddressToString(
                        (PTRANSPORT_ADDRESS)transportAddress,
                        fileObject
                        );

                }
                else {
                    contextAddr = fileObject;
                }
            }
        }

        if (result!=0) {
            _snprintf (transportAddress, sizeof (transportAddress)-1, 
                        "Read error %ld @ %I64X", result, 
                        IsPtr64 () ? contextAddr : (contextAddr & 0xFFFFFFFF));
            transportAddress[sizeof(transportAddress)-1]=0;
            raddr = transportAddress;
        }
    }
    else {
        raddr = "";
    }

    if (SavedMinorVersion>=2419) {
        process = ReadField (OwningProcess);
    }
    else {
        process = ReadField (ProcessCharge.Process);
    }

    if (GetFieldValue (
                process,
                "NT!_EPROCESS",
                "UniqueProcessId",
                pid)!=0) {
        pid = 0;
    }

    //           Connection Sta Flg SndB        RcvB  Pid   Endpoint       RemA
    dprintf (
        IsPtr64 ()
            ? "\n%011.011p %3s %7s %5.5x-%2.2x %5.5x-%2.2x %4.4x %011.011p %-s"
            : "\n%008.008p %3s %7s %5.5x-%2.2x %5.5x-%2.2x %4.4x %008.008p %-s",
        DISP_PTR(ActualAddress),
        ConnectionStateToStringBrief (state),
        ConnectionStateFlagsToString (),
        tdiBuf
            ? (ULONG)0
            : (ULONG)ReadField (Common.NonBufferring.BufferredSendBytes),
        tdiBuf
            ? (ULONG)0
            : (ULONG)ReadField (Common.NonBufferring.BufferredSendCount),
        tdiBuf
            ? (ULONG)(ReadField (Common.Bufferring.ReceiveBytesIndicated.QuadPart)
                - ReadField (Common.Bufferring.ReceiveBytesTaken.QuadPart))
            : (ULONG)(ReadField (Common.NonBufferring.BufferredReceiveBytes)
                + ReadField (Common.NonBufferring.ReceiveBytesInTransport)),
        tdiBuf
            ? 0
            : (ULONG)ReadField (Common.NonBufferring.BufferredReceiveCount),
        (ULONG)pid,
        DISP_PTR(endpAddr),
        raddr
        );
}

VOID
DumpAfdReferenceDebug(
    ULONG64 ActualAddress,
    LONGLONG Idx
    )

/*++

Routine Description:

    Dumps the AFD_REFERENCE_DEBUG structures associated with an
    AFD_CONNECTION object.

Arguments:

    ReferenceDebug - Points to an array of AFD_REFERENCE_DEBUG structures.
        There are assumed to be AFD_MAX_REF entries in this array.

    ActualAddress - The actual address where the array resides on the
        debugee.

Return Value:

    None.

--*/

{

    ULONG i;
    ULONG result;
    CHAR filePath[MAX_PATH];
    CHAR message[256];
    ULONG64  format;
    ULONG64  address;
    ULONG64 locationTable;
    LONG64  timeLast;
    ULONG   newCount;
    ULONG   locationId;
    ULONGLONG   timeExp;
    ULONGLONG   timeDif;
    ULONGLONG   tickCount;
    ULONG   param;
    ULONGLONG   quadPart;

    
    if (RefDebugSize==0) {
        dprintf ("\nDumpAfdReferenceDebug: sizeof(AFD!AFD_REFERENCE_DEBUG) is 0!!!\n");
        return;
    }

    result = ReadPtr (GetExpression ("AFD!AfdLocationTable"),
                            &locationTable);
    if (result!=0) {
        dprintf("\nDumpAfdReferenceDebug: Could not read afd!AfdLocationTable, err: %ld\n", result);
        return;
    }


    if (SavedMinorVersion>=3554) {
        if (SystemTime.QuadPart!=0) {
            dprintf(
                "AFD_REFERENCE_DEBUG @ %p (current time: %s)\n",
                ActualAddress,
                SystemTimeToString(SystemTime.QuadPart)
                );
        }
        else {
            dprintf(
                "AFD_REFERENCE_DEBUG @ %p\n",
                ActualAddress
                );
        }
    }
    else {
        dprintf(
            "AFD_REFERENCE_DEBUG @ %p (current time: %I64d (%I64d) ms)\n",
            ActualAddress,
            ((LONGLONG)TickCount*TicksToMs)>>24,
            ((LONGLONG)(USHORT)TickCount*TicksToMs)>>24
            );
    }


    timeLast = Idx>>AFD_REF_SHIFT;

    if (SavedMinorVersion>=3554)
        Idx = (Idx-1) & AFD_REF_MASK;
    else
        Idx &= AFD_REF_MASK;
    for( i = 0 ; i < AFD_MAX_REF ; i++, Idx=(Idx-1)&AFD_REF_MASK ) {
        if( CheckControlC() ) {

            break;

        }

        result = (ULONG)InitTypeRead (ActualAddress+Idx*sizeof (AFD_REFERENCE_DEBUG),
                                        AFD!AFD_REFERENCE_DEBUG);
        if (result!=0) {
            dprintf ("\nDumpAfdReferenceDebug: Could not read AFD_REFERENCE_DEBUG @ %p(%ld), err: %ld\n",
                        ActualAddress+Idx*sizeof (AFD_REFERENCE_DEBUG), Idx, result);
            return;
        }


        quadPart = ReadField (QuadPart);
        if( quadPart==0) {

            continue;

        }
        newCount = (ULONG)ReadField (NewCount);
        locationId = (ULONG)ReadField (LocationId);
        param = (ULONG)ReadField (Param);
        if (SavedMinorVersion>=3554) {
            timeExp = ReadField (TimeExp);
            timeDif = ReadField (TimeDif);
        }
        else {
            tickCount = ReadField (TickCount);
        }

        if (GetFieldValue (locationTable+RefDebugSize*(locationId-1),
                            "AFD!AFD_REFERENCE_LOCATION",
                            "Format",
                            format)==0 &&
            GetFieldValue (locationTable+RefDebugSize*(locationId-1),
                            "AFD!AFD_REFERENCE_LOCATION",
                            "Address",
                            address)==0 &&
             (ReadMemory (format,
                          filePath,
                          sizeof (filePath),
                          &result) || 
                          (result>0 && filePath[result-1]==0))) {
            CHAR    *fileName;
            fileName = strrchr (filePath, '\\');
            if (fileName!=NULL) {
                fileName += 1;
            }
            else {
                fileName = filePath;
            }
            _snprintf (message, sizeof (message)-1, fileName, param);
            message[sizeof(message)-1]=0;
        }
        else {
            _snprintf (message, sizeof (message)-1, "%lx %lx",
                    locationId,
                    param);
            message[sizeof(message)-1]=0;
        }

        if (SavedMinorVersion>=3554) {
            if (SystemTime.QuadPart!=0) {
                dprintf ("    %3lu %s -> %ld @ %s\n",
                        (ULONG)Idx, message, newCount,
                        SystemTimeToString(
                            (timeLast<<13)+
                            SystemTime.QuadPart -
                            InterruptTime.QuadPart
                            )
                        );
            }
            else {
                dprintf ("    %3lu %s -> %ld @ %I64u ms since boot\n",
                        (ULONG)Idx, message, newCount,
                        (timeLast<<13)/(10*1000)
                        );
            }
            timeLast -= timeDif<<(timeExp*AFD_TIME_EXP_SHIFT);
        }
        else {
            dprintf ("    %3lu %s -> %ld @ %u %s\n",
                    (ULONG)Idx, message, newCount,
                    (TicksToMs!=0)
                        ? (ULONG)((tickCount*TicksToMs)>>24)
                        : (ULONG)tickCount,
                    (TicksToMs!=0) ? "ms" : ""
                    );
        }

    }

}   // DumpAfdReferenceDebug


#if GLOBAL_REFERENCE_DEBUG
BOOL
DumpAfdGlobalReferenceDebug(
    PAFD_GLOBAL_REFERENCE_DEBUG ReferenceDebug,
    ULONG64 ActualAddress,
    DWORD CurrentSlot,
    DWORD StartingSlot,
    DWORD NumEntries,
    ULONG64 CompareAddress
    )

/*++

Routine Description:

    Dumps the AFD_GLOBAL_REFERENCE_DEBUG structures.

Arguments:

    ReferenceDebug - Points to an array of AFD_GLOBAL_REFERENCE_DEBUG
        structures.  There are assumed to be MAX_GLOBAL_REFERENCE entries
        in this array.

    ActualAddress - The actual address where the array resides on the
        debugee.

    CurrentSlot - The last slot used.

    CompareAddress - If zero, then dump all records. Otherwise, only dump
        those records with a matching connection pointer.

Return Value:

    None.

--*/

{

    ULONG result;
    LPSTR fileName;
    CHAR decoration;
    CHAR filePath[MAX_PATH];
    CHAR action[16];
    BOOL foundEnd = FALSE;
    ULONG lowTick;

    if( StartingSlot == 0 ) {

        dprintf(
            "AFD_GLOBAL_REFERENCE_DEBUG @ %p, Current Slot = %lu\n",
            ActualAddress,
            CurrentSlot
            );

    }

    for( ; NumEntries > 0 ; NumEntries--, StartingSlot++, ReferenceDebug++ ) {

        if( CheckControlC() ) {

            foundEnd = TRUE;
            break;

        }

        if( ReferenceDebug->Info1 == NULL &&
            ReferenceDebug->Info2 == NULL &&
            ReferenceDebug->Action == 0 &&
            ReferenceDebug->NewCount == 0 &&
            ReferenceDebug->Connection == NULL ) {

            foundEnd = TRUE;
            break;

        }

        if( CompareAddress != 0 &&
            ReferenceDebug->Connection != (PVOID)CompareAddress ) {

            continue;

        }

        if( ReferenceDebug->Action == 0 ||
            ReferenceDebug->Action == 1 ||
            ReferenceDebug->Action == (ULONG64)-1L ) {

            _snprintf(
                action, sizeof (action),
                "%ld",
                PtrToUlong(ReferenceDebug->Action)
                );
            action[sizeof(action)-1]=0;

        } else {

            _snprintf(
                action, sizeof (action),
                "%p",
                ReferenceDebug->Action
                );
            action[sizeof(action)-1]=0;

        }

        decoration = ( StartingSlot == CurrentSlot ) ? '>' : ' ';
        lowTick = ReferenceDebug->TickCounter.LowPart;

        switch( (ULONG64)ReferenceDebug->Info1 ) {

        case 0xafdafd02 :
            dprintf(
                "%c    %3lu: %p (%8lu) Buffered Send, IRP @ %plx [%s] -> %lu\n",
                decoration,
                StartingSlot,
                (ULONG64)ReferenceDebug->Connection,
                lowTick,
                (ULONG64)ReferenceDebug->Info2,
                action,
                ReferenceDebug->NewCount
                );
            break;

        case 0xafdafd03 :
            dprintf(
                "%c    %3lu: %p (%8lu) Nonbuffered Send, IRP @ %p [%s] -> %lu\n",
                decoration,
                StartingSlot,
                (ULONG64)ReferenceDebug->Connection,
                lowTick,
                (ULONG64)ReferenceDebug->Info2,
                action,
                ReferenceDebug->NewCount
                );
            break;

        case 0xafd11100 :
        case 0xafd11101 :
            dprintf(
                "%c    %3lu: %p (%8lu) AfdRestartSend (%p), IRP @ %p [%s] -> %lu\n",
                decoration,
                StartingSlot,
                (ULONG64)ReferenceDebug->Connection,
                lowTick,
                (ULONG64)ReferenceDebug->Info1,
                (ULONG64)ReferenceDebug->Info2,
                action,
                ReferenceDebug->NewCount
                );
            break;

        case 0xafd11102 :
        case 0xafd11103 :
        case 0xafd11104 :
        case 0xafd11105 :
            dprintf(
                "%c    %3lu: %p (%8lu) AfdRestartBufferSend (%p), IRP @ %p [%s] -> %lu\n",
                decoration,
                StartingSlot,
                (ULONG64)ReferenceDebug->Connection,
                lowTick,
                (ULONG64)ReferenceDebug->Info1,
                (ULONG64)ReferenceDebug->Info2,
                action,
                ReferenceDebug->NewCount
                );
            break;

        case 0 :
            if( ReferenceDebug->Info2 == NULL ) {

                dprintf(
                    "%c    %3lu: %p (%8lu) AfdDeleteConnectedReference (%p)\n",
                    decoration,
                    StartingSlot,
                    (ULONG64)ReferenceDebug->Connection,
                    lowTick,
                    (ULONG64)ReferenceDebug->Action
                    );
                break;

            } else {

                //
                // Fall through to default case.
                //

            }

        default :
            if( ReadMemory(
                    (ULONG64)ReferenceDebug->Info1,
                    filePath,
                    sizeof(filePath),
                    &result
                    ) ) {

                fileName = strrchr( filePath, '\\' );

                if( fileName != NULL ) {

                    fileName++;

                } else {

                    fileName = filePath;

                }

            } else {

                _snprintf(
                    filePath, sizeof (filePath),
                    "%p",
                    ReferenceDebug->Info1
                    );
                filePath[sizeof(filePath)-1]=0;

                fileName = filePath;

            }

            dprintf(
                "%c    %3lu: %p (%8lu) %s:%lu [%s] -> %lu\n",
                decoration,
                StartingSlot,
                (ULONG64)ReferenceDebug->Connection,
                lowTick,
                fileName,
                PtrToUlong (ReferenceDebug->Info2),
                action,
                ReferenceDebug->NewCount
                );
            break;

        }

    }

    return foundEnd;

}   // DumpAfdGlobalReferenceDebug
#endif

VOID
DumpAfdTransmitInfo(
    ULONG64 ActualAddress
    )
{

    dprintf(
        "\nAFD_TRANSMIT_FILE_INFO_INTERNAL @ %p\n",
        ActualAddress
        );

    dprintf(
        "    Endpoint               = %p\n",
        ReadField (Endpoint)
        );

    dprintf(
        "    ReferenceCount         = %ld\n",
        (ULONG)ReadField (ReferenceCount)
        );

    dprintf(
        "    Flags                  = %08lx\n",
        (ULONG)ReadField (Flags)
        );

    dprintf(
        "    WorkerScheduled        = %s\n",
        BooleanToString( ReadField (WorkerScheduled)!=0 )
        );

    dprintf(
        "    AbortPending           = %s\n",
        BooleanToString( ReadField (AbortPending)!=0 )
        );

    dprintf(
        "    NeedSendHead           = %s\n",
        BooleanToString( ReadField (NeedSendHead)!=0 )
        );

    dprintf(
        "    ReuseInProgress        = %s\n",
        BooleanToString( ReadField (ReuseInProgress)!=0 )
        );

    dprintf(
        "    SendAndDisconnect      = %s\n",
        BooleanToString( ReadField (SendAndDisconnect)!=0 )
        );

    dprintf(
        "    SendPacketLength       = %08lx\n",
        (ULONG)ReadField (SendPacketLength)
        );

    dprintf(
        "    FileReadOffset         = %I64x\n",
        ReadField (FileReadOffset)
        );

    dprintf(
        "    FileReadEnd            = %I64x\n",
        ReadField (FileReadEnd)
        );

    dprintf(
        "    FsFileObject           = %p\n",
        ReadField (FsFileObject)
        );

    dprintf(
        "    FsDeviceObject         = %p\n",
        ReadField (FsDeviceObject)
        );

    dprintf(
        "    TdiFileObject          = %p\n",
        ReadField (TdiFileObject)
        );

    dprintf(
        "    TdiDeviceObject        = %p\n",
        ReadField (TdiDeviceObject)
        );

    dprintf(
        "    TransmitIrp            = %p\n",
        ReadField (TransmitIrp)
        );

    dprintf(
        "    SendIrp1               = %p%s\n",
        ReadField (SendIrp1),
        ReadField (Irp1Done)
            ? " (DONE)"
            : ""
        );

    dprintf(
        "    SendIrp2               = %p%s\n",
        ReadField (SendIrp2),
        ReadField (Irp2Done)
            ? " (DONE)"
            : ""
        );

    dprintf(
        "    ReadIrp                = %p%s\n",
        ReadField (ReadIrp),
        ReadField (IrpRDone)
            ? " (DONE)"
            : ""
        );

    dprintf(
        "    HeadMdl                = %p\n",
        ReadField (HeadMdl)
        );

    dprintf(
        "    TailMdl                = %p\n",
        ReadField (TailMdl)
        );

    dprintf(
        "    PreTailMdl             = %p\n",
        ReadField (PreTailMdl)
        );

    dprintf(
        "    WithTailMdl            = %p\n",
        ReadField (WithTailMdl)
        );

    dprintf(
        "    LastFileMdl/Buffer     = %p\n",
        ReadField (LastFileMdl)
        );

    if( IsReferenceDebug ) {

        dprintf(
            "    ReferenceDebug               = %p\n",
                ActualAddress+TPackRefOffset
            );

        dprintf(
            "    CurrentReferenceSlot         = %lu\n",
            (ULONG)ReadField (CurrentReferenceSlot) & AFD_REF_MASK
            );

    }
    dprintf( "\n" );

}   // DumpAfdTransmitInfo

VOID
DumpAfdTransmitInfoBrief (
    ULONG64 ActualAddress
    )
/*
"TranInfo    I        R        P        S     Endpoint  Flags  Cur.Read Read\n"
"Address  Transmit   Send1    Send2    Read   Address          Offset   End \n"
*/
{
    dprintf ("\n%p %p %p %p %p %p %s %8.8lx %8.8lx",
                ActualAddress,
                ReadField (TransmitIrp),
                ReadField (SendIrp1),
                ReadField (SendIrp2),
                ReadField (ReadIrp),
                ReadField (Endpoint),
                TranfileFlagsToString (),
                (ULONG)ReadField (FileReadOffset),
                (ULONG)ReadField (FileReadEnd));

} // DumpAfdTransmitInfoBrief

VOID
DumpAfdTPacketsInfo(
    ULONG64 ActualAddress
    )
{
    if (SavedMinorVersion>=3549) {
        DumpAfdTPacketsInfoNet (ActualAddress);
    }
    else {
        DumpAfdTPacketsInfoXp (ActualAddress);
    }
}

VOID
DumpAfdTPacketsInfoBrief(
    ULONG64 ActualAddress
    )
{
    if (SavedMinorVersion>=3549) {
        DumpAfdTPacketsInfoBriefNet (ActualAddress);
    }
    else {
        DumpAfdTPacketsInfoBriefXp (ActualAddress);
    }
}

VOID
DumpAfdTPacketsInfoNet(
    ULONG64 ActualAddress
    )
{
    ULONG64 fileAddr, endpAddr, tpInfoAddr, irpSpAddr;
    ULONG64 i;
    ULONG   Flags, StateFlags, NumSendIrps, RefCount;
    ULONG   result;


    irpSpAddr = ReadField (Tail.Overlay.CurrentStackLocation);
    tpInfoAddr = ReadField (AssociatedIrp.SystemBuffer);

    if ( (result=GetFieldValue (ActualAddress+DriverContextOffset,
                        "AFD!AFD_TPACKETS_IRP_CTX",
                        "Flags",
                        Flags)) !=0 ||
         (result=GetFieldValue (ActualAddress+DriverContextOffset,
                        "AFD!AFD_TPACKETS_IRP_CTX",
                        "StateFlags",
                        StateFlags)) !=0 ||
         (result=GetFieldValue (ActualAddress+DriverContextOffset,
                        "AFD!AFD_TPACKETS_IRP_CTX",
                        "ReferenceCount",
                        RefCount)) !=0 ) {
        dprintf(
            "\ntran: Could not read AFD_TPACKETS_IRP_CTX @ %p, err:%d\n",
            ActualAddress+DriverContextOffset, result
            );
        return;
    }

    if ( (result = GetFieldValue (irpSpAddr,
                        "NT!_IO_STACK_LOCATION",
                        "FileObject",
                        fileAddr)) !=0 ) {
        dprintf(
            "\ntran: Could not read IO_STACK_LOCATION @ %p for IRP @ %p, err:%d\n",
            irpSpAddr, ActualAddress, result
            );
        return;
    }

    result = GetFieldValue (fileAddr,
                        "NT!_FILE_OBJECT",
                        "FsContext",
                        endpAddr);
    if (result!=0) {
        dprintf(
            "\ntran: Could not read FsContext of FILE_OBJECT @ %p for IRP @ %p, err:%d\n",
            fileAddr, ActualAddress, result
            );
        return;
    }

    dprintf(
        "\nAFD_TRANSMIT_FILE_INFO_INTERNAL @ %p\n",
        tpInfoAddr
        );

    dprintf(
        "    Endpoint               = %p\n",
        endpAddr
        );

    dprintf(
        "    TransmitIrp            = %p (%d more irp(s) pending)\n",
        ActualAddress,
        CountListEntries (ActualAddress+DriverContextOffset));

    dprintf(
        "    ReferenceCount         = %ld\n",
        RefCount
        );

    dprintf(
        "    Flags                  = %08lx (",
        Flags
        );

    if (Flags & AFD_TF_WRITE_BEHIND)
        dprintf ("WrB ");
    if (Flags & AFD_TF_DISCONNECT)
        dprintf ("Dsc ");
    if (Flags & AFD_TF_REUSE_SOCKET)
        dprintf ("Reu ");
    if (Flags & AFD_TF_USE_SYSTEM_THREAD)
        dprintf ("Sys ");
    if (Flags & AFD_TF_USE_KERNEL_APC)
        dprintf ("Apc ");
    dprintf (")\n");

    dprintf(
        "    StateFlags             = %08lx (",
        StateFlags
        );
    if (StateFlags & AFD_TP_ABORT_PENDING)
        dprintf ("Abrt ");
    if (StateFlags & AFD_TP_WORKER_SCHEDULED)
        dprintf ("WrkS ");
    if (StateFlags & AFD_TP_SENDS_POSTED)
        dprintf ("Post ");
    if (StateFlags & AFD_TP_QUEUED)
        dprintf ("Qued ");
    if (StateFlags & AFD_TP_SEND)
        dprintf ("Send ");
    if (StateFlags & AFD_TP_AFD_SEND)
        dprintf ("AfdS ");
    if (StateFlags & AFD_TP_SEND_AND_DISCONNECT)
        dprintf ("S&D ");

    if (tpInfoAddr==-1) {
        dprintf(
            "Reusing)\n"
            );
    }
    else if (tpInfoAddr!=0) {

        result = (ULONG)InitTypeRead (tpInfoAddr, AFD!AFD_TPACKETS_INFO_INTERNAL);
        if (result!=0) {
            dprintf(
                "\ntran: Could not read AFD_TPACKETS_INFO_INTERNAL @ %p, err:%d\n",
                tpInfoAddr, result
                );
            return;
        }

        if (ReadField(PdNeedsPps))
            dprintf ("Pps ");
        if (ReadField(ArrayAllocated))
            dprintf ("Alloc ");
        dprintf (")\n");
        
        dprintf(
            "    SendPacketLength       = %08lx\n",
            (ULONG)ReadField (SendPacketLength)
            );

        dprintf(
            "    PdLength               = %08lx\n",
            (ULONG)ReadField (PdLength)
            );

        dprintf(
            "    NextElement            = %d\n",
            (ULONG)ReadField (NextElement)
            );

        dprintf(
            "    ElementCount           = %d\n",
            (ULONG)ReadField (ElementCount)
            );

        dprintf(
            "    ElementArray           = %p\n",
            ReadField (ElementArray)
            );

        dprintf(
            "    RemainingPkts          = %p\n",
            ReadField (RemainingPkts)
            );

        dprintf(
            "    HeadPd                 = %p\n",
            ReadField (HeadPd)
            );

        dprintf(
            "    TailPd                 = %p\n",
            ReadField (TailPd)
            );

        dprintf(
            "    HeadMdl                = %p\n",
            ReadField (HeadMdl)
            );

        dprintf(
            "    TailMdl                = %p\n",
            ReadField (TailMdl)
            );

        dprintf(
            "    TdiFileObject          = %p\n",
            ReadField (TdiFileObject)
            );

        dprintf(
            "    TdiDeviceObject        = %p\n",
            ReadField (TdiDeviceObject)
            );


        dprintf(
            "    NumSendIrps            = %08lx\n",
            NumSendIrps = (LONG)ReadField (NumSendIrps)
            );

        for (i=0; i<NumSendIrps && i<AFD_TP_MAX_SEND_IRPS; i++) {
            CHAR fieldName[16];
            if (CheckControlC ())
                break;
            _snprintf (fieldName, sizeof (fieldName)-1, "SendIrp[%1d]",i);
            fieldName[sizeof(fieldName)-1]=0;
            dprintf(
                "    %s             = %p%s\n",
                fieldName,
                GetShortField (0, fieldName, 0),
                StateFlags & AFD_TP_SEND_BUSY(i)
                    ? " (BUSY)"
                    : ""
                );
        }

        dprintf(
            "    ReadIrp                = %p%s\n",
            ReadField (ReadIrp),
            StateFlags & AFD_TP_READ_BUSY
                ? " (BUSY)"
                : ""
            );

        if( IsReferenceDebug ) {

            dprintf(
                "    ReferenceDebug         = %p\n",
                tpInfoAddr + TPackRefOffset
                );

            if (SavedMinorVersion>=3554) {
                ULONGLONG refCount;
                refCount = ReadField (CurrentReferenceSlot);
                if (SystemTime.QuadPart!=0) {
                    dprintf(
                        "    CurrentReferenceSlot         = %lu (@ %s)\n",
                        (ULONG)refCount & AFD_REF_MASK,
                        SystemTimeToString (
                            (((ReadField (CurrentTimeHigh)<<32) + 
                                (refCount&(~AFD_REF_MASK)))<<(13-AFD_REF_SHIFT))+
                                SystemTime.QuadPart -
                                InterruptTime.QuadPart
                            )
                        );
                 
                }
                else {
                    dprintf(
                    "    CurrentReferenceSlot         = %lu (@ %I64u ms since boot)\n",
                     (ULONG)refCount & AFD_REF_MASK,
                     (((ReadField (CurrentTimeHigh)<<32) + 
                        (refCount&(~AFD_REF_MASK)))<<(13-AFD_REF_SHIFT))/(10*1000)
                    );
                }
            }
            else {
                dprintf(
                    "    CurrentReferenceSlot         = %lu\n",
                     (ULONG)ReadField (CurrentReferenceSlot) & AFD_REF_MASK
                );
            }
        }
    }
    dprintf( "\n" );

}   // DumpAfdTPacketsInfoNet

VOID
DumpAfdTPacketsInfoBriefNet (
    ULONG64 ActualAddress
    )
/*
TPackets    I    R      P      S    Endpoint   Flags              Next Elmt Mo
Address  Transmit   Send     Read   Address  App | State          Elmt Cnt. re
xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxx xxxxxxxxxxxxxxc xxxx xxxx xx

TPackets      I    R     P     S        Endpoint      Flags              Next Elmt Mo
Address     Transmit    S1    Read      Address     App | State          Elmt Cnt. re
xxxxxxxxxxx xxxxxxxxxxx xxx xxxxxxxxxxx xxxxxxxxxxx xxxx xxxxxxxxxxxxxxx xxxx xxxx xx
*/
{
    ULONG64 fileAddr, endpAddr, tpInfoAddr, irpSpAddr;
    ULONG Flags, StateFlags;
    ULONG result;

    tpInfoAddr = ReadField (AssociatedIrp.SystemBuffer);
    irpSpAddr = ReadField (Tail.Overlay.CurrentStackLocation);
    if ( (result=GetFieldValue (ActualAddress+DriverContextOffset,
                        "AFD!AFD_TPACKETS_IRP_CTX",
                        "Flags",
                        Flags))!=0 ||
         (result=GetFieldValue (ActualAddress+DriverContextOffset,
                        "AFD!AFD_TPACKETS_IRP_CTX",
                        "StateFlags",
                        StateFlags))!=0 ) {
        dprintf(
            "\ntran: Could not read AFD_TPACKETS_IRP_CTX @ %p, err:%d\n",
            ActualAddress+DriverContextOffset, result
            );
        return;
    }

    if ( (result = GetFieldValue (irpSpAddr,
                        "NT!_IO_STACK_LOCATION",
                        "FileObject",
                        fileAddr))!=0 ) {
        dprintf(
            "\ntran: Could not read IO_STACK_LOCATION @ %p for IRP @ %p, err:%d\n",
            irpSpAddr, ActualAddress, result
            );
        return;
    }

    result = GetFieldValue (fileAddr,
                        "NT!_FILE_OBJECT",
                        "FsContext",
                        endpAddr);
    if (result!=0) {
        dprintf(
            "\ntran: Could not read FsContext of FILE_OBJECT @ %p for IRP @ %p, err:%d\n",
            fileAddr, ActualAddress, result
            );
        return;
    }

    if (tpInfoAddr!=0 && tpInfoAddr!=-1 ) {
        result = (ULONG)InitTypeRead (tpInfoAddr, AFD!AFD_TPACKETS_INFO_INTERNAL);
        if (result!=0) {
            dprintf(
                "\ntran: Could not read AFD_TPACKETS_INFO_INTERNAL @ %p, err:%d\n",
                tpInfoAddr, result
                );
            return;
        }

        dprintf (
            IsPtr64() 
                ? "\n%011.011p %011.011p %03.03p %011.011p %011.011p %s %4ld %4ld %2ld"
                : "\n%008.008p %008.008p %08.08p %008.008p %008.008p %s %4ld %4ld %2ld",
            DISP_PTR(tpInfoAddr),
            DISP_PTR(ActualAddress),
            IsPtr64()
                ? DISP_PTR((tpInfoAddr+SendIrpArrayOffset)&0xFFF)
                : DISP_PTR(tpInfoAddr+SendIrpArrayOffset),
            DISP_PTR(ReadField (ReadIrp)),
            DISP_PTR(endpAddr),
            TPacketsFlagsToStringNet (Flags, StateFlags),
            (ULONG)ReadField (NextElement),
            (ULONG)ReadField (ElementCount),
            CountListEntries (ActualAddress+DriverContextOffset)
            );
    }
    else {
        CHAR    *str;
        if (tpInfoAddr==0) {
            if (StateFlags & AFD_TP_SEND) {
                if (StateFlags & AFD_TP_AFD_SEND) {
                    str = "Buffered send";
                }
                else {
                    str = "Direct send";
                }
            }
            else {
                str = "Disconnect";
            }
        }
        else {
             str = "Reusing";
        }

        dprintf (
            IsPtr64() 
                ? "\n%011.011p %011.011p %-15.15s %011.011p %s %4ld %4ld %2ld"
                : "\n%008.008p %008.008p %-17.17s %008.008p %s %4ld %4ld %2ld",
            DISP_PTR(tpInfoAddr),
            DISP_PTR(ActualAddress),
            str,
            DISP_PTR(endpAddr),
            TPacketsFlagsToStringNet (Flags, StateFlags),
            0,
            0,
            CountListEntries (ActualAddress+DriverContextOffset)
            );
    }

} // DumpAfdTPacketsInfoBriefNet

VOID
DumpAfdTPacketsInfoXp(
    ULONG64 ActualAddress
    )
{
    ULONG64 fileAddr, endpAddr, tpInfoAddr, irpSpAddr;
    ULONG64 i;
    ULONG   Flags, StateFlags, NumSendIrps, RefCount;
    ULONG   result;


    irpSpAddr = ReadField (Tail.Overlay.CurrentStackLocation);
    tpInfoAddr = ReadField (AssociatedIrp.SystemBuffer);

    if ( (result=GetFieldValue (ActualAddress+DriverContextOffset,
                        "AFD!AFD_TPACKETS_IRP_CTX",
                        "StateFlags",
                        StateFlags)) !=0 ||
         (result=GetFieldValue (ActualAddress+DriverContextOffset,
                        "AFD!AFD_TPACKETS_IRP_CTX",
                        "ReferenceCount",
                        RefCount)) !=0 ) {
        dprintf(
            "\ntran: Could not read AFD_TPACKETS_IRP_CTX @ %p, err:%d\n",
            ActualAddress+DriverContextOffset, result
            );
        return;
    }

    if ( (result = GetFieldValue (irpSpAddr,
                        "NT!_IO_STACK_LOCATION",
                        "FileObject",
                        fileAddr)) !=0 ) {
        dprintf(
            "\ntran: Could not read IO_STACK_LOCATION @ %p for IRP @ %p, err:%d\n",
            irpSpAddr, ActualAddress, result
            );
        return;
    }

    if ( (result = GetFieldValue (irpSpAddr,
                        "NT!_IO_STACK_LOCATION",
                        "Parameters.DeviceIoControl.IoControlCode",
                        Flags)) !=0 ) {
        dprintf(
            "\ntran: Could not read IO_STACK_LOCATION @ %p for IRP @ %p, err:%d\n",
            irpSpAddr, ActualAddress, result
            );
        return;
    }

    result = GetFieldValue (fileAddr,
                        "NT!_FILE_OBJECT",
                        "FsContext",
                        endpAddr);
    if (result!=0) {
        dprintf(
            "\ntran: Could not read FsContext of FILE_OBJECT @ %p for IRP @ %p, err:%d\n",
            fileAddr, ActualAddress, result
            );
        return;
    }

    dprintf(
        "\nAFD_TRANSMIT_FILE_INFO_INTERNAL @ %p\n",
        tpInfoAddr
        );

    dprintf(
        "    Endpoint               = %p\n",
        endpAddr
        );

    dprintf(
        "    TransmitIrp            = %p (%d more irp(s) pending)\n",
        ActualAddress,
        CountListEntries (ActualAddress+DriverContextOffset));

    dprintf(
        "    ReferenceCount         = %ld\n",
        RefCount
        );

    dprintf(
        "    Flags                  = %08lx (",
        Flags
        );

    if (Flags & AFD_TF_WRITE_BEHIND)
        dprintf ("WrB ");
    if (Flags & AFD_TF_DISCONNECT)
        dprintf ("Dsc ");
    if (Flags & AFD_TF_REUSE_SOCKET)
        dprintf ("Reu ");
    if (Flags & AFD_TF_USE_SYSTEM_THREAD)
        dprintf ("Sys ");
    if (Flags & AFD_TF_USE_KERNEL_APC)
        dprintf ("Apc ");
    dprintf (")\n");

    dprintf(
        "    StateFlags             = %08lx (",
        StateFlags
        );
    if (StateFlags & AFD_TP_ABORT_PENDING)
        dprintf ("Abrt ");
#define AFD_TP_WORKER_SCHEDULED_XP      0x00000010
    if (StateFlags & AFD_TP_WORKER_SCHEDULED_XP)
        dprintf ("WrkS ");
#define AFD_TP_SEND_AND_DISCONNECT_XP   0x00000100
    if (StateFlags & AFD_TP_SEND_AND_DISCONNECT_XP)
        dprintf ("S&D ");

    if (tpInfoAddr==-1) {
        dprintf(
            "Reusing)\n"
            );
    }
    else if (tpInfoAddr!=0) {

        result = (ULONG)InitTypeRead (tpInfoAddr, AFD!AFD_TPACKETS_INFO_INTERNAL);
        if (result!=0) {
            dprintf(
                "\ntran: Could not read AFD_TPACKETS_INFO_INTERNAL @ %p, err:%d\n",
                tpInfoAddr, result
                );
            return;
        }

        if (ReadField(PdNeedsPps))
            dprintf ("Pps ");
        if (ReadField(ArrayAllocated))
            dprintf ("Alloc ");
        dprintf (")\n");
        
        dprintf(
            "    SendPacketLength       = %08lx\n",
            (ULONG)ReadField (SendPacketLength)
            );

        dprintf(
            "    PdLength               = %08lx\n",
            (ULONG)ReadField (PdLength)
            );

        dprintf(
            "    NextElement            = %d\n",
            (ULONG)ReadField (NextElement)
            );

        dprintf(
            "    ElementCount           = %d\n",
            (ULONG)ReadField (ElementCount)
            );

        dprintf(
            "    ElementArray           = %p\n",
            ReadField (ElementArray)
            );

        dprintf(
            "    RemainingPkts          = %p\n",
            ReadField (RemainingPkts)
            );

        dprintf(
            "    HeadPd                 = %p\n",
            ReadField (HeadPd)
            );

        dprintf(
            "    TailPd                 = %p\n",
            ReadField (TailPd)
            );

        dprintf(
            "    HeadMdl                = %p\n",
            ReadField (HeadMdl)
            );

        dprintf(
            "    TailMdl                = %p\n",
            ReadField (TailMdl)
            );

        dprintf(
            "    TdiFileObject          = %p\n",
            ReadField (TdiFileObject)
            );

        dprintf(
            "    TdiDeviceObject        = %p\n",
            ReadField (TdiDeviceObject)
            );


        dprintf(
            "    NumSendIrps            = %08lx\n",
            NumSendIrps = (LONG)ReadField (NumSendIrps)
            );

        for (i=0; i<NumSendIrps && i<AFD_TP_MAX_SEND_IRPS; i++) {
            CHAR fieldName[16];
            if (CheckControlC ())
                break;
            _snprintf (fieldName, sizeof (fieldName)-1, "SendIrp[%1d]",i);
            fieldName[sizeof(fieldName)-1]=0;
            dprintf(
                "    %s             = %p%s\n",
                fieldName,
                GetShortField (0, fieldName, 0),
                StateFlags & AFD_TP_SEND_BUSY(i)
                    ? " (BUSY)"
                    : ""
                );
        }

        dprintf(
            "    ReadIrp                = %p%s\n",
            ReadField (ReadIrp),
            StateFlags & AFD_TP_READ_BUSY
                ? " (BUSY)"
                : ""
            );

        if( IsReferenceDebug ) {

            dprintf(
                "    ReferenceDebug         = %p\n",
                tpInfoAddr + TPackRefOffset
                );

            if (SavedMinorVersion>=3554) {
                ULONGLONG refCount;
                refCount = ReadField (CurrentReferenceSlot);
                if (SystemTime.QuadPart!=0) {
                    dprintf(
                        "    CurrentReferenceSlot         = %lu (@ %s)\n",
                        (ULONG)refCount & AFD_REF_MASK,
                        SystemTimeToString (
                            (((ReadField (CurrentTimeHigh)<<32) + 
                                (refCount&(~AFD_REF_MASK)))<<(13-AFD_REF_SHIFT))+
                                SystemTime.QuadPart -
                                InterruptTime.QuadPart
                            )
                        );
                 
                }
                else {
                    dprintf(
                    "    CurrentReferenceSlot         = %lu (@ %I64u ms since boot)\n",
                     (ULONG)refCount & AFD_REF_MASK,
                     (((ReadField (CurrentTimeHigh)<<32) + 
                        (refCount&(~AFD_REF_MASK)))<<(13-AFD_REF_SHIFT))/(10*1000)
                    );
                }
            }
            else {
                dprintf(
                    "    CurrentReferenceSlot         = %lu\n",
                     (ULONG)ReadField (CurrentReferenceSlot) & AFD_REF_MASK
                );
            }
        }
    }
    dprintf( "\n" );

}   // DumpAfdTPacketsInfoXp

VOID
DumpAfdTPacketsInfoBriefXp (
    ULONG64 ActualAddress
    )
/*
TPackets    I    R      P      S    Endpoint   Flags              Next Elmt Mo
Address  Transmit   Send     Read   Address  App | State          Elmt Cnt. re
xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxx xxxxxxxxxxxxxxc xxxx xxxx xx

TPackets      I    R     P     S        Endpoint      Flags              Next Elmt Mo
Address     Transmit    S1    Read      Address     App | State          Elmt Cnt. re
xxxxxxxxxxx xxxxxxxxxxx xxx xxxxxxxxxxx xxxxxxxxxxx xxxx xxxxxxxxxxxxxxx xxxx xxxx xx
*/
{
    ULONG64 fileAddr, endpAddr, tpInfoAddr, irpSpAddr;
    ULONG Flags, StateFlags;
    ULONG result;

    tpInfoAddr = ReadField (AssociatedIrp.SystemBuffer);
    irpSpAddr = ReadField (Tail.Overlay.CurrentStackLocation);
    if ( (result=GetFieldValue (ActualAddress+DriverContextOffset,
                        "AFD!AFD_TPACKETS_IRP_CTX",
                        "StateFlags",
                        StateFlags))!=0 ) {
        dprintf(
            "\ntran: Could not read AFD_TPACKETS_IRP_CTX @ %p, err:%d\n",
            ActualAddress+DriverContextOffset, result
            );
        return;
    }

    if ( (result = GetFieldValue (irpSpAddr,
                        "NT!_IO_STACK_LOCATION",
                        "FileObject",
                        fileAddr))!=0 ) {
        dprintf(
            "\ntran: Could not read IO_STACK_LOCATION @ %p for IRP @ %p, err:%d\n",
            irpSpAddr, ActualAddress, result
            );
        return;
    }

    if ( (result = GetFieldValue (irpSpAddr,
                        "NT!_IO_STACK_LOCATION",
                        "Parameters.DeviceIoControl.IoControlCode",
                        Flags)) !=0 ) {
        dprintf(
            "\ntran: Could not read IO_STACK_LOCATION @ %p for IRP @ %p, err:%d\n",
            irpSpAddr, ActualAddress, result
            );
        return;
    }

    result = GetFieldValue (fileAddr,
                        "NT!_FILE_OBJECT",
                        "FsContext",
                        endpAddr);
    if (result!=0) {
        dprintf(
            "\ntran: Could not read FsContext of FILE_OBJECT @ %p for IRP @ %p, err:%d\n",
            fileAddr, ActualAddress, result
            );
        return;
    }

    if (tpInfoAddr!=0 && tpInfoAddr!=-1 ) {
        result = (ULONG)InitTypeRead (tpInfoAddr, AFD!AFD_TPACKETS_INFO_INTERNAL);
        if (result!=0) {
            dprintf(
                "\ntran: Could not read AFD_TPACKETS_INFO_INTERNAL @ %p, err:%d\n",
                tpInfoAddr, result
                );
            return;
        }

        dprintf (
            IsPtr64() 
                ? "\n%011.011p %011.011p %03.03p %011.011p %011.011p %s %4ld %4ld %2ld"
                : "\n%008.008p %008.008p %08.08p %008.008p %008.008p %s %4ld %4ld %2ld",
            DISP_PTR(tpInfoAddr),
            DISP_PTR(ActualAddress),
            IsPtr64()
                ? DISP_PTR((tpInfoAddr+SendIrpArrayOffset)&0xFFF)
                : DISP_PTR(tpInfoAddr+SendIrpArrayOffset),
            DISP_PTR(ReadField (ReadIrp)),
            DISP_PTR(endpAddr),
            TPacketsFlagsToStringXp (Flags, StateFlags),
            (ULONG)ReadField (NextElement),
            (ULONG)ReadField (ElementCount),
            CountListEntries (ActualAddress+DriverContextOffset)
            );
    }
    else {
        CHAR    *str;
        if (tpInfoAddr==0) {
            str = "Disconnect";
        }
        else {
             str = "Reusing";
        }

        dprintf (
            IsPtr64() 
                ? "\n%011.011p %011.011p %-15.15s %011.011p %s %4ld %4ld %2ld"
                : "\n%008.008p %008.008p %-17.17s %008.008p %s %4ld %4ld %2l",
            DISP_PTR(tpInfoAddr),
            DISP_PTR(ActualAddress),
            str,
            DISP_PTR(endpAddr),
            TPacketsFlagsToStringXp (Flags, StateFlags),
            0,
            0,
            CountListEntries (ActualAddress+DriverContextOffset)
            );
    }

} // DumpAfdTPacketsInfoBrief

VOID
DumpAfdBuffer(
    ULONG64 ActualAddress
    )
{
    ULONG   result;
    ULONG   length;
    ULONG64 mdl,irp,buf;

    dprintf(
        "AFD_BUFFER @ %p\n",
        ActualAddress
        );

    dprintf(
        "    BufferLength           = %08lx\n",
        length=(ULONG)ReadField (BufferLength)
        );

    dprintf(
        "    DataLength             = %08lx\n",
        (ULONG)ReadField (DataLength)
        );

    dprintf(
        "    DataOffset             = %08lx\n",
        (ULONG)ReadField (DataOffset)
        );

    dprintf(
        "    Context/Status         = %p/%lx\n",
        ReadField (Context), (ULONG)ReadField(Status)
        );

    dprintf(
        "    Mdl                    = %p\n",
        mdl=ReadField (Mdl)
        );

    dprintf(
        "    RemoteAddress          = %p\n",
        ReadField (TdiInfo.RemoteAddress)
        );

    dprintf(
        "    RemoteAddressLength    = %lu\n",
        (ULONG)ReadField (TdiInfo.RemoteAddressLength)
        );

    dprintf(
        "    AllocatedAddressLength = %04X\n",
        (USHORT)ReadField (AllocatedAddressLength)
        );

    dprintf(
        "    Flags                  = %04X (",
        (USHORT)ReadField(Flags)
        );

    if (ReadField (ExpeditedData))
        dprintf (" Exp");
    if (ReadField (PartialMessage))
        dprintf (" Partial");
    if (ReadField (Lookaside))
        dprintf (" Lookaside");
    if (ReadField (NdisPacket))
        dprintf (" Packet");
    dprintf (" )\n");

    if (length!=AFD_DEFAULT_TAG_BUFFER_SIZE) {
        result = (ULONG)InitTypeRead (ActualAddress, AFD!AFD_BUFFER);
        if (result!=0) {
            dprintf ("\nDumpAfdBuffer: Could not read AFD_BUFFER @p, err: %ld\n",
                        ActualAddress, result);
            return ;
        }
        dprintf(
            "    Buffer                 = %p\n",
            buf=ReadField (Buffer)
            );

        dprintf(
            "    Irp                    = %p\n",
            irp = ReadField (Irp)
            );

        if (SavedMinorVersion>=2267) {
            dprintf(
                "    Placement              ="
                );

            switch (ReadField (Placement)) {
            case AFD_PLACEMENT_HDR:
                dprintf (" Header-first\n");
                buf = ActualAddress;
                break;
            case AFD_PLACEMENT_IRP:
                dprintf (" Irp-first\n");
                buf = irp;
                break;
            case AFD_PLACEMENT_MDL:
                dprintf (" Mdl-first\n");
                buf = mdl;
                break;
            case AFD_PLACEMENT_BUFFER:
                dprintf (" Buffer-first\n");
                // buf = buf;
                break;
            }
            if (SavedMinorVersion>=2414) {
                if (ReadField (AlignmentAdjusted)) {
                    ULONG64 adj;
                    if (ReadPointer (buf - (IsPtr64 () ? 8 : 4), &adj)) {
                        dprintf(
                            "    AlignmentAdjustment    = %p\n",
                            adj
                            );
                    }
                    else {
                        dprintf(
                            "    Could not read alignment adjustment below %p\n",
                            buf);
                    }
                }
            }
        }
    }

    dprintf( "\n" );

}   // DumpAfdBuffer


VOID
DumpAfdBufferBrief(
    ULONG64 ActualAddress
    )
{
    ULONG   length;
    LPSTR   raddr;
    UCHAR   transportAddress[MAX_TRANSPORT_ADDR];
    ULONG64 address;

    address = ReadField (TdiInfo.RemoteAddress);
    length = (ULONG)ReadField (TdiInfo.RemoteAddressLength);

    if( address != 0 && length != 0) {
        if (ReadMemory (address,
                        transportAddress,
                        length<sizeof (transportAddress) 
                            ? length
                            : sizeof (transportAddress),
                            &length)) {
            raddr = TransportAddressToString(
                (PTRANSPORT_ADDRESS)transportAddress,
                address
                );
        }
        else {
            raddr = "Read error!";
        }
    }
    else {
        raddr = "";
    }


    dprintf (/*  Buffer    Size Length Offst Context   Mdl|IRP   Flags Rem Addr*/
        IsPtr64 ()
            ? "\n%011.011p %4.4x %4.4x %4.4x %011.011p %011.011p %6s %-32.32s" 
            : "\n%008.008p %4.4x %4.4x %4.4x %008.008p %008.008p %6s %-32.32s",
            DISP_PTR(ActualAddress),
            length = (ULONG)ReadField (BufferLength),
            (ULONG)ReadField (DataLength),
            (ULONG)ReadField (DataOffset),
            DISP_PTR(ReadField (Context)),
            length==0 ? DISP_PTR(ReadField (Mdl)) : DISP_PTR(ReadField (Irp)),
            BufferFlagsToString (),
            raddr
            );

}   // DumpAfdBufferBrief

ULONG
DumpAfdPollEndpointInfo (
    PFIELD_INFO pField,
    PVOID UserContext
    )
{
    ULONG64 file, endp, hndl;
    ULONG   evts;
    ULONG   err;

    if ((err=GetFieldValue (pField->address, 
                            "AFD!AFD_POLL_ENDPOINT_INFO",
                            "FileObject",
                            file))==0 &&
            (err=GetFieldValue (pField->address, 
                            "AFD!AFD_POLL_ENDPOINT_INFO",
                            "Endpoint",
                            endp))==0 &&
            (err=GetFieldValue (pField->address, 
                            "AFD!AFD_POLL_ENDPOINT_INFO",
                            "Handle",
                            hndl))==0 &&
            (err=GetFieldValue (pField->address, 
                            "AFD!AFD_POLL_ENDPOINT_INFO",
                            "PollEvents",
                            evts))==0) {
        dprintf ("        %-16p %-16p %-8x %s%s%s%s%s%s%s%s%s%s%s%s%s\n",
            file, endp, (ULONG)hndl, 
            (evts & AFD_POLL_RECEIVE) ? "rcv " : "",
            (evts & AFD_POLL_RECEIVE_EXPEDITED) ? "rce " : "",
            (evts & AFD_POLL_SEND) ? "snd " : "",
            (evts & AFD_POLL_DISCONNECT) ? "dsc " : "",
            (evts & AFD_POLL_ABORT) ? "abrt " : "",
            (evts & AFD_POLL_LOCAL_CLOSE) ? "cls " : "",
            (evts & AFD_POLL_CONNECT) ? "con " : "",
            (evts & AFD_POLL_ACCEPT) ? "acc " : "",
            (evts & AFD_POLL_CONNECT_FAIL) ? "cnf " : "",
            (evts & AFD_POLL_QOS) ? "qos " : "",
            (evts & AFD_POLL_GROUP_QOS) ? "gqs " : "",
            (evts & AFD_POLL_ROUTING_IF_CHANGE) ? "rif " : "",
            (evts & AFD_POLL_ADDRESS_LIST_CHANGE) ? "adr " : "");
    }
    else {
        dprintf ("        Failed to read endpoint info @ %p, err: %ld\n",
                            pField->address, err);
    }

    return err;
}

VOID
DumpAfdPollInfo (
    ULONG64 ActualAddress
    )
{
    ULONG   numEndpoints, err;
    ULONG64 irp,thread,pid,tid;


    dprintf ("\nAFD_POLL_INFO_INTERNAL @ %p\n", ActualAddress);

    dprintf(
        "    NumberOfEndpoints      = %08lx\n",
        numEndpoints=(ULONG)ReadField (NumberOfEndpoints)
        );

    dprintf(
        "    Irp                    = %p\n",
        irp=ReadField (Irp)
        );

    if ((err=GetFieldValue (irp, "NT!_IRP", "Tail.Overlay.Thread", thread))==0 &&
            (err=GetFieldValue (thread, "NT!_ETHREAD", "Cid.UniqueProcess", pid))==0 &&
            (err=GetFieldValue (thread, "NT!_ETHREAD", "Cid.UniqueThread", tid))==0 ){
        dprintf(
            "    Thread                 = %p (%lx.%lx)\n",
            thread, (ULONG)pid, (ULONG)tid);
    }
    else {
        dprintf(
            "   Could not get thread(tid/pid) from irp, err: %ld\n", err);
    }
        

    if (ReadField (TimerStarted)) {
        if (SystemTime.QuadPart!=0 ) {
            dprintf(
                "    Expires                @ %s (cur %s)\n",
                SystemTimeToString (ReadField (Timer.DueTime.QuadPart)-
                                                InterruptTime.QuadPart+
                                                SystemTime.QuadPart),
                SystemTimeToString (SystemTime.QuadPart));
        }
        else {
            dprintf(
                "    Expires                @ %I64x\n",
                ReadField (Timer.DueTime.QuadPart));
        }
    }

     

    dprintf(
        "    Flags                  : %s%s%s\n",
        ReadField (Unique) ? "Unique " : "",
        ReadField (TimerStarted) ? "TimerStarted " : "",
        ReadField (SanPoll) ? "SanPoll " : ""
        );
    if (numEndpoints>0) {
        FIELD_INFO flds = {
                    NULL,
                    NULL,
                    numEndpoints,
                    0,
                    0,
                    DumpAfdPollEndpointInfo};
        SYM_DUMP_PARAM sym = {
           sizeof (SYM_DUMP_PARAM), 
           "AFD!AFD_POLL_ENDPOINT_INFO",
           DBG_DUMP_NO_PRINT | DBG_DUMP_ARRAY,
           ActualAddress+PollEndpointInfoOffset,
           &flds, 
           NULL,
           NULL,
           0,
           NULL
        };    
        dprintf ( "        File Object      Endpoint         Handle   Events\n");
        Ioctl(IG_DUMP_SYMBOL_INFO, &sym, sym.size);
    }
}

VOID
DumpAfdPollInfoBrief (
    ULONG64 ActualAddress
    )
{
    ULONG64 irp, thread=0, pid=0, tid=0;
    BOOLEAN timerStarted, unique, san;
    CHAR dueTime[16];
    
    irp = ReadField (Irp);
    GetFieldValue (irp, "NT!_IRP", "Tail.Overlay.Thread", thread);
    GetFieldValue (thread, "NT!_ETHREAD", "Cid.UniqueProcess", pid);
    GetFieldValue (thread, "NT!_ETHREAD", "Cid.UniqueThread", tid);

    timerStarted = ReadField (TimerStarted)!=0;
    unique = ReadField (Unique)!=0;
    san = ReadField (SanPoll)!=0;

    if (timerStarted) {
        TIME_FIELDS timeFields;
        LARGE_INTEGER diff;
        diff.QuadPart = ReadField (Timer.DueTime.QuadPart)-InterruptTime.QuadPart;
        RtlTimeToElapsedTimeFields( &diff, &timeFields );
        _snprintf (dueTime, sizeof (dueTime)-1, "%2d:%2.2d:%2.2d.%3.3d",
                            timeFields.Day*24+timeFields.Hour,
                            timeFields.Minute,
                            timeFields.Second,
                            timeFields.Milliseconds);
        dueTime[sizeof(dueTime)-1]=0;
    }
    else {
        _snprintf (dueTime, sizeof (dueTime)-1, "NEVER       ");
        dueTime[sizeof(dueTime)-1]=0;
    }
    dprintf (//PollInfo    IRP       Thread    (pid.tid)   Expr Flags Hdls  Array
        IsPtr64 ()
            ? "\n%011.011p %011.011p %011.011p %4.4x.%4.4x %12s %1s%1s%1s %4.4x %011.011p"
            : "\n%008.008p %008.008p %008.008p %4.4x.%4.4x %12s %1s%1s%1s %4.4x %008.008p",
        DISP_PTR(ActualAddress),
        DISP_PTR(irp),
        DISP_PTR(thread),
        (ULONG)pid,
        (ULONG)tid,
        dueTime,
        timerStarted ? "T" : " ",
        unique ? "U" : " ",
        san ? "S" : " ",
        (ULONG)ReadField (NumberOfEndpoints),
        DISP_PTR (ActualAddress+PollEndpointInfoOffset));
}

ULONG
GetRemoteAddressFromContext (
    ULONG64             EndpAddr,
    PVOID               AddressBuffer,
    SIZE_T              AddressBufferLength,
    ULONG64             *ContextAddr

    )
{
    ULONG64 context;
    ULONG   result, contextLength;
    ULONG   addressOffset=0, addressLength=0;
    PTRANSPORT_ADDRESS  TaAddress = (PTRANSPORT_ADDRESS)AddressBuffer;
    ULONG   maxAddressLength = (ULONG)(AddressBufferLength - 
                             FIELD_OFFSET (TRANSPORT_ADDRESS, Address[0].AddressType));

    *ContextAddr = 0;
    if ((result=GetFieldValue (EndpAddr,
                        "AFD!AFD_ENDPOINT",
                        "Context", 
                        context))==0 &&
                context!=0 &&
            (result=GetFieldValue (EndpAddr,
                    "AFD!AFD_ENDPOINT",
                    "ContextLength", 
                    contextLength))==0 &&
                contextLength!=0) {

        //
        // Hard-coded layout of SOCK_SHARED_INFO structure in
        // msafd.  It would be better to get it from type info,
        // but msafd/mswsock symbols are not easy to load in kernel
        // mode.
        //
        #define SOCK_SHARED_INFO_LL_OFF 0x10    // Offset of LocalAddressLength field
        #define SOCK_SHARED_INFO_RL_OFF 0x14    // Offset of RemoteAddressLength field
        #define SOCK_SHARED_INFO_SIZE   0x78    // Total size of the structure.
        #define SOCK_SHARED_INFO_SIZE_OLD 0x68  // Size before GUID was added.
        ULONG   ll, rl, res;
        *ContextAddr = context;

        if (ReadMemory (context+SOCK_SHARED_INFO_LL_OFF, &ll, sizeof (ll), &res) &&
                ReadMemory (context+SOCK_SHARED_INFO_RL_OFF, &rl, sizeof (rl), &res)) {
            addressLength = rl;
            if (SavedMinorVersion>=3628) {
                addressOffset = SOCK_SHARED_INFO_SIZE +
                                ALIGN_UP_A(sizeof (ULONG), 8) +
                                ALIGN_UP_A(ll, 8);
            }
            else if (SavedMinorVersion>=2219) {
                addressOffset = SOCK_SHARED_INFO_SIZE_OLD +
                                ALIGN_UP_A(sizeof (ULONG), 8) +
                                ALIGN_UP_A(ll, 8);
            }
            else {
                addressOffset = SOCK_SHARED_INFO_SIZE_OLD + 
                                    sizeof (ULONG) + 
                                    ll;
            }
        }
        else
            return result;

        if (contextLength>=(addressOffset+addressLength) &&
                ReadMemory (context+addressOffset,
                    &TaAddress->Address[0].AddressType,
                    addressLength<maxAddressLength
                        ? addressLength 
                        : maxAddressLength,
                    &res)) {
            *ContextAddr += addressOffset;
            TaAddress->TAAddressCount = 1;
            TaAddress->Address[0].AddressLength = (USHORT)addressLength;
            return 0;
        }
        else
            result = MEMORY_READ_ERROR;
    }

    return result;
}

//
//  Private functions.
//


PSTR
StructureTypeToString(
    USHORT Type
    )

/*++

Routine Description:

    Maps an AFD structure type to a displayable string.

Arguments:

    Type - The AFD structure type to map.

Return Value:

    PSTR - Points to the displayable form of the structure type.

--*/

{

    switch( Type ) {

    case AfdBlockTypeEndpoint :
        return "Endpoint";

    case AfdBlockTypeVcConnecting :
        return "VcConnecting";

    case AfdBlockTypeVcListening :
        return "VcListening";

    case AfdBlockTypeDatagram :
        return "Datagram";

    case AfdBlockTypeConnection :
        return "Connection";

    case AfdBlockTypeHelper :
        return "Helper";

    case AfdBlockTypeVcBoth:
        return "Listening Root";

    case AfdBlockTypeSanEndpoint:
        return "San Endpoint";

    case AfdBlockTypeSanHelper:
        return "San Helper";

    }

    return "INVALID";

}   // StructureTypeToString

PSTR
StructureTypeToStringBrief (
    USHORT Type
    )

/*++

Routine Description:

    Maps an AFD structure type to a displayable string.

Arguments:

    Type - The AFD structure type to map.

Return Value:

    PSTR - Points to the displayable form of the structure type.

--*/

{

    switch( Type ) {

    case AfdBlockTypeEndpoint :
        return "Enp";

    case AfdBlockTypeVcConnecting :
        return "Vc ";

    case AfdBlockTypeVcListening :
        return "Lsn";

    case AfdBlockTypeDatagram :
        return "Dg ";

    case AfdBlockTypeConnection :
        return "Con";

    case AfdBlockTypeHelper :
        return "Hlp";

    case AfdBlockTypeVcBoth:
        return "Rot";

    case AfdBlockTypeSanEndpoint:
        return "SaE";

    case AfdBlockTypeSanHelper:
        return "SaH";
    }

    return "???";

}   // StructureTypeToString

PSTR
BooleanToString(
    BOOLEAN Flag
    )

/*++

Routine Description:

    Maps a BOOELEAN to a displayable form.

Arguments:

    Flag - The BOOLEAN to map.

Return Value:

    PSTR - Points to the displayable form of the BOOLEAN.

--*/

{

    return Flag ? "TRUE" : "FALSE";

}   // BooleanToString

PSTR
EndpointStateToString(
    UCHAR State
    )

/*++

Routine Description:

    Maps an AFD endpoint state to a displayable string.

Arguments:

    State - The AFD endpoint state to map.

Return Value:

    PSTR - Points to the displayable form of the AFD endpoint state.

--*/

{

    switch( State ) {

    case AfdEndpointStateOpen :
        return "Open";

    case AfdEndpointStateBound :
        return "Bound";

    case AfdEndpointStateConnected :
        return "Connected";

    case AfdEndpointStateCleanup :
        return "Cleanup";

    case AfdEndpointStateClosing :
        return "Closing";

    case AfdEndpointStateTransmitClosing :
        return "Transmit Closing";

    case AfdEndpointStateInvalid :
        return "Invalid";

    }

    return "INVALID";

}   // EndpointStateToString

PSTR
EndpointStateToStringBrief(
    UCHAR State
    )

/*++

Routine Description:

    Maps an AFD endpoint state to a displayable string.

Arguments:

    State - The AFD endpoint state to map.

Return Value:

    PSTR - Points to the displayable form of the AFD endpoint state.

--*/

{

    switch( State ) {

    case AfdEndpointStateOpen :
        return "Opn";

    case AfdEndpointStateBound :
        return "Bnd";

    case AfdEndpointStateConnected :
        return "Con";

    case AfdEndpointStateCleanup :
        return "Cln";

    case AfdEndpointStateClosing :
        return "Cls";

    case AfdEndpointStateTransmitClosing :
        return "TrC";

    case AfdEndpointStateInvalid :
        return "Inv";

    }

    return "???";

}   // EndpointStateToString

PSTR
EndpointStateFlagsToString(
    )

/*++

Routine Description:

    Maps an AFD endpoint state flags to a displayable string.

Arguments:

    Endpoint - The AFD endpoint which state flags to map.

Return Value:

    PSTR - Points to the displayable form of the AFD endpoint state flags.

--*/

{
    static CHAR buffer[13];

    buffer[0] = ReadField (NonBlocking) ? 'N' : ' ';
    buffer[1] = ReadField (InLine) ? 'I' : ' ';
    buffer[2] = ReadField (EndpointCleanedUp) ? 'E' : ' ';
    buffer[3] = ReadField (PollCalled) ? 'P' : ' ';
    buffer[4] = ReadField (RoutingQueryReferenced) ? 'Q' : ' ';
    buffer[5] = ReadField (DisableFastIoSend) ? 'S' : ' ';
    buffer[6] = ReadField (DisableFastIoRecv) ? 'R' : ' ';
    buffer[7] = ReadField (AdminAccessGranted) ? 'A' : ' ';
    switch (ReadField (DisconnectMode)) {
    case 0:
        buffer[8] = ' ';
        break;
    case 1:
        buffer[8] = 's';
        break;
    case 2:
        buffer[8] = 'r';
        break;
    case 3:
        buffer[8] = 'b';
        break;
    case 7:
        buffer[8] = 'a';
        break;
    default:
        buffer[8] = '?';
        break;
    }

    switch (ReadField (Type)) {
    case AfdBlockTypeDatagram:
        buffer[9]  = ReadField (Common.Datagram.CircularQueueing) ? 'C' : ' ';
        buffer[10] = ReadField (Common.Datagram.HalfConnect) ? 'H' : ' ';
        if (SavedMinorVersion>=2466) {
            buffer[11] = '0' + (CHAR)
                               ((ReadField (Common.Datagram.AddressDrop) <<0)+
                                (ReadField (Common.Datagram.ResourceDrop)<<1)+
                                (ReadField (Common.Datagram.BufferDrop)  <<2)+
                                (ReadField (Common.Datagram.ErrorDrop)   <<3));
        }
        else {
            buffer[11] = ' ';
        }
        break;
    case AfdBlockTypeSanEndpoint: {
        NTSTATUS status = (NTSTATUS)ReadField (Common.SanEndp.CtxTransferStatus);

        switch (status) {
        case STATUS_PENDING:
            buffer[9] = 'p';
            break;
        case STATUS_MORE_PROCESSING_REQUIRED:
            buffer[9] = 'm';
            break;
        default:
            if (NT_SUCCESS (status)) {
                buffer[9] = ' ';
            }
            else {
                buffer[9] = 'f';
            }
            break;
        }
        buffer[10] = ReadField (Common.SanEndp.ImplicitDup) ? 'i' : ' ';
        buffer[11] = ' ';
        break;
    }
    default:
        buffer[9]  = ReadField (Listening) ? 'L' : ' ';
        buffer[10] = ' ';
        buffer[11] = ' ';
        break;
    }
    buffer[12] = 0;

    return buffer;
}

PSTR
EndpointTypeToString(
    ULONG TypeFlags
    )

/*++

Routine Description:

    Maps an AFD_ENDPOINT_TYPE to a displayable string.

Arguments:

    Type - The AFD_ENDPOINT_TYPE to map.

Return Value:

    PSTR - Points to the displayable form of the AFD_ENDPOINT_TYPE.

--*/

{

    switch( TypeFlags ) {

    case AfdEndpointTypeStream :
        return "Stream";

    case AfdEndpointTypeDatagram :
        return "Datagram";

    case AfdEndpointTypeRaw :
        return "Raw";

    case AfdEndpointTypeSequencedPacket :
        return "SequencedPacket";

	default:
		if (TypeFlags&(~AFD_ENDPOINT_VALID_FLAGS))
			return "INVALID";
        else {
            static CHAR buffer[64];
            INT n = 0;
            buffer[0] = 0;
            if (TypeFlags & AFD_ENDPOINT_FLAG_CONNECTIONLESS)
                n += _snprintf (&buffer[n], sizeof (buffer)-1-n, "con-less ");
            if (TypeFlags & AFD_ENDPOINT_FLAG_MESSAGEMODE)
                n += _snprintf (&buffer[n], sizeof (buffer)-1-n, "msg ");
            if (TypeFlags & AFD_ENDPOINT_FLAG_RAW)
                n += _snprintf (&buffer[n], sizeof (buffer)-1-n, "raw ");
            if (TypeFlags & AFD_ENDPOINT_FLAG_MULTIPOINT)
                n += _snprintf (&buffer[n], sizeof (buffer)-1-n, "m-point ");
            if (TypeFlags & AFD_ENDPOINT_FLAG_CROOT)
                n += _snprintf (&buffer[n], sizeof (buffer)-1-n, "croot ");
            if (TypeFlags & AFD_ENDPOINT_FLAG_DROOT)
                n += _snprintf (&buffer[n], sizeof (buffer)-1-n, "droot ");
            buffer[sizeof(buffer)-1]=0;
            return buffer;
        }

    }
}   // EndpointTypeToString

PSTR
ConnectionStateToString(
    USHORT State
    )

/*++

Routine Description:

    Maps an AFD connection state to a displayable string.

Arguments:

    State - The AFD connection state to map.

Return Value:

    PSTR - Points to the displayable form of the AFD connection state.

--*/

{
    switch( State ) {

    case AfdConnectionStateFree :
        return "Free";

    case AfdConnectionStateUnaccepted :
        return "Unaccepted";

    case AfdConnectionStateReturned :
        return "Returned";

    case AfdConnectionStateConnected :
        return "Connected";

    case AfdConnectionStateClosing :
        return "Closing";

    }

    return "INVALID";

}   // ConnectionStateToString

PSTR
ConnectionStateToStringBrief(
    USHORT State
    )

/*++

Routine Description:

    Maps an AFD connection state to a displayable string.

Arguments:

    State - The AFD connection state to map.

Return Value:

    PSTR - Points to the displayable form of the AFD connection state.

--*/

{
    switch( State ) {

    case AfdConnectionStateFree :
        return "Fre";

    case AfdConnectionStateUnaccepted :
        return "UnA";

    case AfdConnectionStateReturned :
        return "Rtn";

    case AfdConnectionStateConnected :
        return "Con";

    case AfdConnectionStateClosing :
        return "Cls";

    }

    return "???";

}   // ConnectionStateToStringBrief

PSTR
ConnectionStateFlagsToString(
    )

/*++

Routine Description:

    Maps an AFD connection state flags to a displayable string.

Arguments:

    Connection - The AFD connection which state flags to map.

Return Value:

    PSTR - Points to the displayable form of the AFD connection state flags.

--*/

{
    static CHAR buffer[8];

    if (SavedMinorVersion>=3549) {
        buffer[0] =  ReadField (Aborted) ? 'A' : ' ';
        if (ReadField (AbortIndicated)) {
            buffer[0] =  'a';
        }
        else if (ReadField (AbortFailed)) {
            buffer[0] =  'f';
        }
    }
    else {
        buffer[0] =  ReadField (AbortedIndicated) ? 'A' : ' ';
    }
    buffer[1] =  ReadField (DisconnectIndicated) ? 'D' : ' ';
    buffer[2] =  ReadField (ConnectedReferenceAdded) ? 'R' : ' ';
    buffer[3] =  ReadField (SpecialCondition) ? 'S' : ' ';
    buffer[4] =  ReadField (CleanupBegun) ? 'C' : ' ';
    buffer[5] =  ReadField (ClosePendedTransmit) ? 'T' : ' ';
    buffer[6] =  ReadField (OnLRList) ? 'L' : ' ';
    buffer[7] = 0;

    return buffer;
}

PSTR
TranfileFlagsToString(
    VOID
    )

/*++

Routine Description:

    Maps an AFD transmit file info flags to a displayable string.

Arguments:

    TransmitInfo - The AFD transmit file info which flags to map.

Return Value:

    PSTR - Points to the displayable form of the AFD transmit file info flags.

--*/

{
    static CHAR buffer[9];

    buffer[0] =  (ReadField (AbortPending)) ? 'A' : ' ';
    buffer[1] =  (ReadField (WorkerScheduled)) ? 'W' : ' ';
    buffer[2] =  (ReadField (NeedSendHead)) ? 'H' : ' ';
    buffer[3] =  (ReadField (ReuseInProgress)) ? 'R' : ' ';
    buffer[4] =  (ReadField (SendAndDisconnect)) ? 'S' : ' ';
    buffer[5] =  (ReadField (Irp1Done)) ? '1' : ' ';
    buffer[6] =  (ReadField (Irp2Done)) ? '2' : ' ';
    buffer[7] =  (ReadField (IrpRDone)) ? '3' : ' ';
    buffer[8] = 0;

    return buffer;
}

PSTR
TPacketsFlagsToStringNet(
    ULONG   Flags,
    ULONG   StateFlags
    )

/*++

Routine Description:

    Maps an AFD transmit file info flags to a displayable string.

Arguments:

    TransmitInfo - The AFD transmit file info which flags to map.

Return Value:

    PSTR - Points to the displayable form of the AFD transmit file info flags.

--*/

{
    static CHAR buffer[20];

    buffer[0] =  (Flags & AFD_TF_WRITE_BEHIND) ? 'b' : ' ';
    buffer[1] =  (Flags & AFD_TF_DISCONNECT) ? 'd' : ' ';
    buffer[2] =  (Flags & AFD_TF_REUSE_SOCKET) ? 'r' : ' ';
    buffer[3] =  (Flags & AFD_TF_USE_SYSTEM_THREAD) ? 's' : 'a';
    buffer[4] = '|';
    buffer[5] =  (StateFlags & AFD_TP_ABORT_PENDING) ? 'A' : ' ';
    buffer[6] =  (StateFlags & AFD_TP_WORKER_SCHEDULED) ? 'W' : ' ';
    buffer[7] =  (StateFlags & AFD_TP_SENDS_POSTED) ? 'S' : ' ';
    buffer[8] =  (StateFlags & AFD_TP_QUEUED) ? 'Q' : ' ';
    buffer[9] =  (StateFlags & AFD_TP_READ_BUSY) ? '0' : ' ';
    buffer[10] =  (StateFlags & AFD_TP_SEND_BUSY(0)) ? '1' : ' ';
    buffer[11] =  (StateFlags & AFD_TP_SEND_BUSY(1)) ? '2' : ' ';
    buffer[12] =  (StateFlags & AFD_TP_SEND_BUSY(2)) ? '3' : ' ';
    buffer[13] =  (StateFlags & AFD_TP_SEND_BUSY(3)) ? '4' : ' ';
    buffer[14] =  (StateFlags & AFD_TP_SEND_BUSY(4)) ? '5' : ' ';
    buffer[15] =  (StateFlags & AFD_TP_SEND_BUSY(5)) ? '6' : ' ';
    buffer[16] =  (StateFlags & AFD_TP_SEND_BUSY(6)) ? '7' : ' ';
    buffer[17] =  (StateFlags & AFD_TP_SEND_BUSY(7)) ? '8' : ' ';
    buffer[18] =  (StateFlags & AFD_TP_SEND_AND_DISCONNECT) ? '&' : ' ';
    buffer[19] = 0;

    return buffer;
}

PSTR
TPacketsFlagsToStringXp(
    ULONG   Flags,
    ULONG   StateFlags
    )

/*++

Routine Description:

    Maps an AFD transmit file info flags to a displayable string.

Arguments:

    TransmitInfo - The AFD transmit file info which flags to map.

Return Value:

    PSTR - Points to the displayable form of the AFD transmit file info flags.

--*/

{
    static CHAR buffer[20];

    buffer[0] =  (Flags & AFD_TF_WRITE_BEHIND) ? 'b' : ' ';
    buffer[1] =  (Flags & AFD_TF_DISCONNECT) ? 'd' : ' ';
    buffer[2] =  (Flags & AFD_TF_REUSE_SOCKET) ? 'r' : ' ';
    buffer[3] =  (Flags & AFD_TF_USE_SYSTEM_THREAD) ? 's' : 'a';
    buffer[4] = '|';
    buffer[5] =  (StateFlags & AFD_TP_ABORT_PENDING) ? 'A' : ' ';
    buffer[6] =  (StateFlags & AFD_TP_WORKER_SCHEDULED_XP) ? 'W' : ' ';
    buffer[7] =  ' ';
    buffer[8] =  ' ';
    buffer[9] =  (StateFlags & AFD_TP_READ_BUSY) ? '0' : ' ';
    buffer[10] =  (StateFlags & AFD_TP_SEND_BUSY(0)) ? '1' : ' ';
    buffer[11] =  (StateFlags & AFD_TP_SEND_BUSY(1)) ? '2' : ' ';
    buffer[12] =  (StateFlags & AFD_TP_SEND_BUSY(2)) ? '3' : ' ';
    buffer[13] =  (StateFlags & AFD_TP_SEND_BUSY(3)) ? '4' : ' ';
    buffer[14] =  (StateFlags & AFD_TP_SEND_BUSY(4)) ? '5' : ' ';
    buffer[15] =  (StateFlags & AFD_TP_SEND_BUSY(5)) ? '6' : ' ';
    buffer[16] =  (StateFlags & AFD_TP_SEND_BUSY(6)) ? '7' : ' ';
    buffer[17] =  (StateFlags & AFD_TP_SEND_BUSY(7)) ? '8' : ' ';
    buffer[18] =  (StateFlags & AFD_TP_SEND_AND_DISCONNECT_XP) ? '&' : ' ';
    buffer[19] = 0;

    return buffer;
}

PSTR
BufferFlagsToString(
    )

/*++

Routine Description:

    Maps an AFD buffer flags to a displayable string.

Arguments:

    TransmitInfo - The AFD buffer which flags to map.

Return Value:

    PSTR - Points to the displayable form of the AFD buffer flags.

--*/

{
    static CHAR buffer[7];

    buffer[0] =  (ReadField (ExpeditedData)) ? 'E' : ' ';
    buffer[1] =  (ReadField (PartialMessage)) ? 'P' : ' ';
    buffer[2] =  (ReadField (Lookaside)) ? 'L' : ' ';
    buffer[3] =  (ReadField (NdisPacket)) ? 'N' : ' ';
    if (SavedMinorVersion>=2267) {
        UCHAR   placement = (UCHAR)ReadField (Placement);
        switch (placement) {
        case AFD_PLACEMENT_HDR:
            buffer[4] = 'h';
            break;
        case AFD_PLACEMENT_IRP:
            buffer[4] = 'i';
            break;
        case AFD_PLACEMENT_MDL:
            buffer[4] = 'm';
            break;
        case AFD_PLACEMENT_BUFFER:
            buffer[4] = 'b';
            break;
        }
        if (SavedMinorVersion>=2414) {
            buffer[5] = ReadField (AlignmentAdjusted) ? 'A' : ' ';
        }
        else
            buffer[5] = ' ';
    }
    else {
        buffer[4] = ' ';
        buffer[5] = ' ';
    }
    buffer[6] = 0;

    return buffer;
}



PSTR
SystemTimeToString(
    LONGLONG Value
    )

/*++

Routine Description:

    Maps a LONGLONG representing system time to a displayable string.

Arguments:

    Value - The LONGLONG time to map.

Return Value:

    PSTR - Points to the displayable form of the system time.

Notes:

    This routine is NOT multithread safe!

--*/

{

    static char buffer[64];
    NTSTATUS status;
    LARGE_INTEGER systemTime;
    LARGE_INTEGER localTime;
    TIME_FIELDS timeFields;

    systemTime.QuadPart = Value;

    status = RtlSystemTimeToLocalTime( &systemTime, &localTime );

    if( !NT_SUCCESS(status) ) {

		_snprintf(buffer, sizeof (buffer)-1, "%I64x", Value);
        buffer[sizeof(buffer)-1]=0;
        return buffer;

    }

    RtlTimeToTimeFields( &localTime, &timeFields );

    _snprintf(
        buffer, sizeof (buffer)-1,
        "%s %s %2d %4d %02d:%02d:%02d.%03d",
        WeekdayNames[timeFields.Weekday],
        MonthNames[timeFields.Month],
        timeFields.Day,
        timeFields.Year,
        timeFields.Hour,
        timeFields.Minute,
        timeFields.Second,
        timeFields.Milliseconds
        );
    buffer[sizeof(buffer)-1]=0;

    return buffer;

}   // SystemTimeToString



PSTR
GroupTypeToString(
    AFD_GROUP_TYPE GroupType
    )

/*++

Routine Description:

    Maps an AFD_GROUP_TYPE to a displayable string.

Arguments:

    GroupType - The AFD_GROUP_TYPE to map.

Return Value:

    PSTR - Points to the displayable form of the AFD_GROUP_TYPE.

--*/

{

    switch( GroupType ) {

    case GroupTypeNeither :
        return "Neither";

    case GroupTypeConstrained :
        return "Constrained";

    case GroupTypeUnconstrained :
        return "Unconstrained";

    }

    return "INVALID";

}   // GroupTypeToString

PSTR
ListToString (
    ULONG64 ListHead
    )
{
    static CHAR buffer[32];
    INT count = CountListEntries (ListHead);

    if (count==0) {
        _snprintf (buffer, sizeof (buffer)-1, "= EMPTY");
    }
    else {
        if (IsPtr64()) {
            _snprintf (buffer, sizeof (buffer)-1, "@ %I64X (%d)", ListHead, count);
        }
        else {
            _snprintf (buffer, sizeof (buffer)-1, "@ %X (%d)", (ULONG)ListHead, count);
        }
    }
    buffer[sizeof(buffer)-1]=0;
    return buffer;
}

PAFDKD_TRANSPORT_INFO
ReadTransportInfo (
    ULONG64   ActualAddress
    )
{

    ULONG               result, length;
    PAFDKD_TRANSPORT_INFO transportInfo;
    ULONG64             buffer;

    if( GetFieldValue(
            ActualAddress,
            "AFD!AFD_TRANSPORT_INFO",
            "TransportDeviceName.Length",
            length
            )!=0 ||
         GetFieldValue(
            ActualAddress,
            "AFD!AFD_TRANSPORT_INFO",
            "TransportDeviceName.Buffer",
            buffer
            )!=0) {

        dprintf(
            "\nReadTransportInfo: Could not read AFD_TRANSPORT_INFO @ %p\n",
            ActualAddress
            );

        return NULL;

    }

    if (length < sizeof (L"\\Device\\")-2) {
        dprintf(
            "\nReadTransportInfo: transport info (@%p) device name length (%ld) is less than sizeof (L'\\Device\\')-2\n",
            ActualAddress,
            length
            );

        return NULL;
    }


    transportInfo = RtlAllocateHeap (RtlProcessHeap (), 
                                        0,
                                        FIELD_OFFSET (AFDKD_TRANSPORT_INFO,
                                               DeviceName[length/2+1]));
    if (transportInfo==NULL) {
        dprintf(
            "\nReadTransportInfo: Could not allocate space for transport info.\n"
            );
        return NULL;
    }

    transportInfo->ActualAddress = ActualAddress;

    if (GetFieldValue (
                ActualAddress,
                "AFD!AFD_TRANSPORT_INFO",
                "ReferenceCount",
                transportInfo->ReferenceCount)!=0 ||
            GetFieldValue (
                ActualAddress,
                "AFD!AFD_TRANSPORT_INFO",
                "InfoValid",
                transportInfo->InfoValid)!=0 ||
            GetFieldValue (
                ActualAddress,
                "AFD!AFD_TRANSPORT_INFO",
                "ProviderInfo",
                transportInfo->ProviderInfo)!=0 ||
            !ReadMemory(
                buffer,
                &transportInfo->DeviceName,
                length,
                &result
                )) {

        dprintf(
            "\nReadTransportInfo: Could not read AFD_TRANSPORT_INFO @ %p\n",
            ActualAddress
            );
        RtlFreeHeap (RtlProcessHeap (), 0, transportInfo);

        return NULL;

    }

    transportInfo->DeviceName[length/2] = 0;
    return transportInfo;
}


VOID
DumpTransportInfo (
    PAFDKD_TRANSPORT_INFO TransportInfo
    )
{
    dprintf ("\nTransport Info @ %p\n", TransportInfo->ActualAddress);
    dprintf ("    TransportDeviceName           = %ls\n",
                        TransportInfo->DeviceName);
    dprintf ("    ReferenceCount                = %ld\n",
                        TransportInfo->ReferenceCount);
    if (TransportInfo->InfoValid) {
        dprintf ("    ProviderInfo:\n");
        dprintf ("        Version                   = %8.8lx\n",
                            TransportInfo->ProviderInfo.Version);
        dprintf ("        MaxSendSize               = %ld\n",
                            TransportInfo->ProviderInfo.MaxSendSize);
        dprintf ("        MaxConnectionUserData     = %ld\n",
                            TransportInfo->ProviderInfo.MaxConnectionUserData);
        dprintf ("        MaxDatagramSize           = %ld\n",
                            TransportInfo->ProviderInfo.MaxDatagramSize);
        dprintf ("        ServiceFlags              = %lx (",
                            TransportInfo->ProviderInfo.ServiceFlags);
        if (TDI_SERVICE_ORDERLY_RELEASE & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" OrdRel");
        if (TDI_SERVICE_DELAYED_ACCEPTANCE & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" DelAcc");
        if (TDI_SERVICE_EXPEDITED_DATA & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" Expd");
        if (TDI_SERVICE_INTERNAL_BUFFERING & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" Buff");
        if (TDI_SERVICE_MESSAGE_MODE & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" Msg");
        if (TDI_SERVICE_DGRAM_CONNECTION & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" DgramCon");
        if (TDI_SERVICE_FORCE_ACCESS_CHECK & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" AccChk");
        if (TDI_SERVICE_SEND_AND_DISCONNECT & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" S&D");
        if (TDI_SERVICE_DIRECT_ACCEPT & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" DirAcc");
        if (TDI_SERVICE_ACCEPT_LOCAL_ADDR & TransportInfo->ProviderInfo.ServiceFlags)
            dprintf (" AcLoAd");
        dprintf (" )\n");

        dprintf ("        MinimumLookaheadData      = %ld\n",
                            TransportInfo->ProviderInfo.MinimumLookaheadData);
        dprintf ("        MaximumLookaheadData      = %ld\n",
                            TransportInfo->ProviderInfo.MaximumLookaheadData);
        dprintf ("        NumberOfResources         = %ld\n",
                            TransportInfo->ProviderInfo.NumberOfResources);
        dprintf ("        StartTime                 = %s\n",
                            SystemTimeToString(TransportInfo->ProviderInfo.StartTime.QuadPart));
    }

}


VOID
DumpTransportInfoBrief (
    PAFDKD_TRANSPORT_INFO TransportInfo
    )
{
    dprintf (//PollInfo    IRP       Thread    (pid.tid)   Expr Flags Hdls  Array
        IsPtr64 ()
            ? "\n%011.011p %-30.30ls %4.4x %3.3x %8.8x %5.5x %5.5x %s"
            : "\n%008.008p %-30.30ls %4.4x %3.3x %8.8x %5.5x %5.5x %s",
        DISP_PTR(TransportInfo->ActualAddress),
        &TransportInfo->DeviceName[sizeof ("\\device\\")-1],
        TransportInfo->ReferenceCount,
        TransportInfo->ProviderInfo.Version,
        TransportInfo->ProviderInfo.MaxSendSize,
        TransportInfo->ProviderInfo.MaxDatagramSize,
        TransportInfo->ProviderInfo.ServiceFlags,
        TdiServiceFlagsToStringBrief (TransportInfo->ProviderInfo.ServiceFlags));

}

PSTR
TdiServiceFlagsToStringBrief(
    ULONG   Flags
    )

/*++

Routine Description:

    Maps an TDI service flags to a displayable string.

Arguments:

    Flags - flags to map

Return Value:

    PSTR - Points to the displayable form of the TDI service flags.

--*/

{
    static CHAR buffer[10];

    buffer[0] = (TDI_SERVICE_ORDERLY_RELEASE & Flags) ? 'O' : ' ',
    buffer[1] = (TDI_SERVICE_DELAYED_ACCEPTANCE & Flags) ? 'D' : ' ',
    buffer[2] = (TDI_SERVICE_EXPEDITED_DATA & Flags) ? 'E' : ' ',
    buffer[3] = (TDI_SERVICE_INTERNAL_BUFFERING & Flags) ? 'B' : ' ',
    buffer[4] = (TDI_SERVICE_MESSAGE_MODE & Flags) ? 'M' : ' ',
    buffer[5] = (TDI_SERVICE_DGRAM_CONNECTION & Flags) ? 'G' : ' ',
    buffer[6] = (TDI_SERVICE_FORCE_ACCESS_CHECK & Flags) ? 'A' : ' ',
    buffer[7] = (TDI_SERVICE_SEND_AND_DISCONNECT & Flags) ? '&' : ' ',
    buffer[8] = (TDI_SERVICE_DIRECT_ACCEPT & Flags) ? 'R' : ' ',
    buffer[9] = 0;

    return buffer;
}


INT
CountListEntries (
    ULONG64 ListHeadAddress
    )
{
    ULONG64 ptr, Next=ListHeadAddress;
    INT count = 0;
    Next = ListHeadAddress;

    while (ReadPtr (Next, &ptr)==0 && ptr!=0 && ptr!=ListHeadAddress) {
        if (CheckControlC()) {
            return -1;
        }
        count += 1;
        Next = ptr;
    }
    return count;
}

PSTR
ListCountEstimate (
    ULONG64 ListHeadAddress
    )
{
    ULONG64 next, prev;
    if (ReadPtr (ListHeadAddress, &next)!=0) {
        return "Er";
    }
    else if (next==ListHeadAddress) {
        return " 0";
    }
    else if (ReadPtr (ListHeadAddress+(IsPtr64 () ? 8 : 4), &prev)!=0) {
        return "Er";
    }
    else if (prev==next) {
        return " 1";
    }
    else {
        return ">1";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\enumendp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    enumendp.c

Abstract:

    Enumerates all AFD_ENDPOINT structures in the system.

Author:

    Keith Moore (keithmo) 19-Apr-1995

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop

ULONG EntityCount;
//
//  Public functions.
//

VOID
EnumEndpoints(
    PENUM_ENDPOINTS_CALLBACK Callback,
    ULONG64 Context
    )

/*++

Routine Description:

    Enumerates all AFD_ENDPOINT structures in the system, invoking the
    specified callback for each endpoint.

Arguments:

    Callback - Points to the callback to invoke for each AFD_ENDPOINT.

    Context - An uninterpreted context value passed to the callback
        routine.

Return Value:

    None.

--*/

{

    LIST_ENTRY64 listEntry;
    ULONG64 address;
    ULONG64 nextEntry;
    ULONG64 listHead;
    ULONG result;

    EntityCount = 0;

    listHead = GetExpression( "afd!AfdEndpointListHead" );

    if( listHead == 0 ) {

        dprintf( "\nEnumEndpoints: Could not find afd!AfdEndpointlistHead\n" );
        return;

    }

    if( !ReadListEntry(
            listHead,
            &listEntry) ) {

        dprintf(
            "\nEnumEndpoints: Could not read afd!AfdEndpointlistHead @ %p\n",
            listHead
            );
        return;

    }

    if (Options & AFDKD_ENDPOINT_SCAN) {
        nextEntry = StartEndpoint+EndpointLinkOffset;
    }
    else if (Options & AFDKD_BACKWARD_SCAN) {
        nextEntry = listEntry.Blink;
    }
    else {
        nextEntry = listEntry.Flink;
    }

    while( nextEntry != listHead ) {

        if (nextEntry==0) {
            dprintf ("\nEnumEndpoints: Flink is NULL, last endpoint: %p\n", address);
            break;
        }

        if( CheckControlC() ) {

            break;

        }

        address = nextEntry - EndpointLinkOffset;
        result = (ULONG)InitTypeRead (address, AFD!AFD_ENDPOINT);

        if( result!=0) {

            dprintf(
                "\nEnumEndpoints: Could not read AFD_ENDPOINT @ %p, err: %d\n",
                address, result
                );

            return;

        }

        if (Options & AFDKD_BACKWARD_SCAN) {
            nextEntry = ReadField (GlobalEndpointListEntry.Blink);
        }
        else {
            nextEntry = ReadField (GlobalEndpointListEntry.Flink);
        }

        if( !(Callback)( address, Context ) ) {

            break;

        }

    }

}   // EnumEndpoints
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\endp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    endp.c

Abstract:

    Implements the endp, state, port, and proc commands.

Author:

    Keith Moore (keithmo) 19-Apr-1995

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop


//
//  Private prototypes.
//

BOOL
DumpEndpointCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

BOOL
FindStateCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

BOOL
FindPortCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

BOOL
FindProcessCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

ULONG64
FindProcessByPid (
    ULONG64 Pid
    );

ULONG
FindProcessByPidCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    );

//
//  Public functions.
//

DECLARE_API( endp )

/*++

Routine Description:

    Dumps the AFD_ENDPOINT structure at the specified address, if
    given or all endpoints.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG   result;
    INT     i;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];
    PCHAR   argp;
    ULONG64 address;

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER);
    }
    
    if ((argp[0]==0) || (Options & AFDKD_ENDPOINT_SCAN)) {
        EnumEndpoints(
            DumpEndpointCallback,
            0
            );
        dprintf ("\nTotal endpoints: %ld", EntityCount);
    }
    else {

        //
        // Snag the address from the command line.
        //
        while (sscanf( argp, "%s%n", expr, &i )==1) {
            if( CheckControlC() ) {
                break;
            }

            argp+=i;
            address = GetExpression (expr);

            result = (ULONG)InitTypeRead (address, AFD!AFD_ENDPOINT);
            if (result!=0) {
                dprintf ("\nendp: Could not read AFD_ENDPOINT @ %p, err: %d\n",
                    address, result);
                break;
            }

            if (Options & AFDKD_BRIEF_DISPLAY) {
                DumpAfdEndpointBrief (
                    address
                    );
            }
            else {
                DumpAfdEndpoint (
                    address
                    );
            }
            if (Options & AFDKD_FIELD_DISPLAY) {
                ProcessFieldOutput (address, "AFD!AFD_ENDPOINT");
            }

        }

    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_TRAILER);
    }
    else {
        dprintf ("\n");
    }

    return S_OK;
}   // endp


//
//  Public functions.
//

DECLARE_API( file )

/*++

Routine Description:

    Dumps the AFD_ENDPOINT structure associated with AFD file object.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG   result;
    INT     i;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];
    PCHAR   argp;
    ULONG64 address, endpAddr;

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER);
    }
    
    //
    // Snag the address from the command line.
    //

    while (sscanf( argp, "%s%n", expr, &i )==1) {
        if( CheckControlC() ) {
            break;
        }
        argp += i;
        address = GetExpression (expr);
        result = GetFieldValue (address,
                                "NT!_FILE_OBJECT",
                                "FsContext",
                                endpAddr);
        if (result!=0) {
            dprintf ("\nfile: Could not read FILE_OBJECT @ %p, err: %d\n",
                address, result);
            break;
        }

        result = (ULONG)InitTypeRead (endpAddr, AFD!AFD_ENDPOINT);
        if (result!=0) {
            dprintf ("\nfile: Could not read AFD_ENDPOINT @ %p, err: %d\n",
                endpAddr, result);
            break;
        }

        if (Options & AFDKD_BRIEF_DISPLAY) {
            DumpAfdEndpointBrief (
                endpAddr
                );
        }
        else {
            DumpAfdEndpoint (
                endpAddr
                );
        }
        if (Options & AFDKD_FIELD_DISPLAY) {
            ProcessFieldOutput (endpAddr, "AFD!AFD_ENDPOINT");
        }

    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_TRAILER);
    }

    return S_OK;
}   // file

DECLARE_API( state )

/*++

Routine Description:

    Dumps all AFD_ENDPOINT structures in the given state.

Arguments:

    None.

Return Value:

    None.

--*/

{

    INT i;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];
    PCHAR   argp;
    ULONG64 val;

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER);
    }

    //
    // Snag the state from the command line.
    //

    while (sscanf( argp, "%s%n", expr, &i )==1) {
        if( CheckControlC() ) {
            break;
        }
        argp+=i;
        val = GetExpression (expr);
        dprintf ("\nLooking for endpoints in state 0x%I64x ", val);
        EnumEndpoints(
            FindStateCallback,
            val
            );
        dprintf ("\nTotal endpoints: %ld", EntityCount);
    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_TRAILER);
    }
    else {
        dprintf ("\n");
    }

    return S_OK;
}   // state


DECLARE_API( port )

/*++

Routine Description:

    Dumps all AFD_ENDPOINT structures bound to the given port.

Arguments:

    None.

Return Value:

    None.

--*/

{

    INT i;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];
    PCHAR   argp;
    ULONG64   val;

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER);
    }

    //
    // Snag the port from the command line.
    //

    while (sscanf( argp, "%s%n", expr, &i)==1) {
        if( CheckControlC() ) {
            break;
        }
        argp+=i;
        val = GetExpression (expr);
        dprintf ("\nLooking for endpoints bound to port 0x%I64x (0x%I64d) ", val, val);
        EnumEndpoints(
            FindPortCallback,
            val
            );
        dprintf ("\nTotal endpoints: %ld", EntityCount);
    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_TRAILER);
    }
    else {
        dprintf ("\n");
    }

    return S_OK;
}   // port



DECLARE_API( proc )

/*++

Routine Description:

    Dumps all AFD_ENDPOINT structures owned by the given process.

Arguments:

    None.

Return Value:

    None.

--*/

{

    INT i;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];
    PCHAR   argp;
    ULONG64 val;
    BOOLEAN dumpedSomething = FALSE;

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_HEADER);
    }

    //
    // Snag the process from the command line.
    //

    expr[0] = 0;
    i = 0;
    while (sscanf( argp, "%s%n", expr, &i )==1 ||
                !dumpedSomething ) {
        dumpedSomething = TRUE;
        if( CheckControlC() ) {
            break;
        }
        argp+=i;

        val = GetExpression (expr);
        if (val<UserProbeAddress) {
            if (val!=0) {
                dprintf ("\nLooking for process with id %I64x", val);
                val = FindProcessByPid (val);
                if (val==0) {
                    dprintf ("\n");
                    return E_INVALIDARG;
                }
            }
            else {
                val = GetExpression ("@$proc");
            }
        }
        dprintf ("\nLooking for endpoints in process %p", val);
        EnumEndpoints(
            FindProcessCallback,
            val
            );
        dprintf ("\nTotal endpoints: %ld", EntityCount);
    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        dprintf (AFDKD_BRIEF_ENDPOINT_DISPLAY_TRAILER);
    }
    else {
        dprintf ("\n");
    }


    return S_OK;
}   // proc


//
//  Private prototypes.
//

BOOL
DumpEndpointCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    )

/*++

Routine Description:

    EnumEndpoints() callback for dumping AFD_ENDPOINTs.

Arguments:

    Endpoint - The current AFD_ENDPOINT.

    ActualAddress - The actual address where the structure resides on the
        debugee.

    Context - The context value passed into EnumEndpoints().

Return Value:

    BOOL - TRUE if enumeration should continue, FALSE if it should be
        terminated.

--*/

{

    if (!(Options & AFDKD_CONDITIONAL) ||
                CheckConditional (ActualAddress, "AFD!AFD_ENDPOINT") ) {

        if (Options & AFDKD_NO_DISPLAY)
            dprintf ("+");
        else  {
            if (Options & AFDKD_BRIEF_DISPLAY) {
                DumpAfdEndpointBrief (
                    ActualAddress
                    );
            }
            else {
                DumpAfdEndpoint (
                    ActualAddress
                    );
            }
            if (Options & AFDKD_FIELD_DISPLAY) {
                ProcessFieldOutput (ActualAddress, "AFD!AFD_ENDPOINT");
            }
        }
        EntityCount += 1;
    }
    else
        dprintf (".");

    return TRUE;

}   // DumpEndpointCallback

BOOL
FindStateCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    )

/*++

Routine Description:

    EnumEndpoints() callback for finding AFD_ENDPOINTs in a specific state.

Arguments:

    Endpoint - The current AFD_ENDPOINT.

    ActualAddress - The actual address where the structure resides on the
        debugee.

    Context - The context value passed into EnumEndpoints().

Return Value:

    BOOL - TRUE if enumeration should continue, FALSE if it should be
        terminated.

--*/

{
    UCHAR   state = (UCHAR)Context;
    UCHAR   State;

    if (state==0x10) {
        if (ReadField (Listening)) {
            if (!(Options & AFDKD_CONDITIONAL) ||
                        CheckConditional (ActualAddress, "AFD!AFD_ENDPOINT") ) {
                if (Options & AFDKD_NO_DISPLAY)
                    dprintf ("+");
                else  {
                    if (Options & AFDKD_BRIEF_DISPLAY) {
                        DumpAfdEndpointBrief (
                            ActualAddress
                            );
                    }
                    else {
                        DumpAfdEndpoint (
                            ActualAddress
                            );
                    }
                    if (Options & AFDKD_FIELD_DISPLAY) {
                        ProcessFieldOutput (ActualAddress, "AFD!AFD_ENDPOINT");
                    }
                }
                EntityCount += 1;
            }
            else
                dprintf (".");

        }
        else {
            dprintf (".");
        }
    }
    else {

        State = (UCHAR)ReadField (State);
        if( (State == state) && !ReadField (Listening) ) {
            if (!(Options & AFDKD_CONDITIONAL) ||
                        CheckConditional (ActualAddress, "AFD!AFD_ENDPOINT") ) {
                if (Options & AFDKD_NO_DISPLAY)
                    dprintf ("+");
                else  {
                    if (Options & AFDKD_BRIEF_DISPLAY) {
                        DumpAfdEndpointBrief (
                            ActualAddress
                            );
                    }
                    else {
                        DumpAfdEndpoint (
                            ActualAddress
                            );
                    }
                    if (Options & AFDKD_FIELD_DISPLAY) {
                        ProcessFieldOutput (ActualAddress, "AFD!AFD_ENDPOINT");
                    }
                }
                EntityCount += 1;
            }
            else
                dprintf (".");

        }
        else {
            dprintf (".");
        }

    }

    return TRUE;

}   // FindStateCallback

BOOL
FindPortCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    )

/*++

Routine Description:

    EnumEndpoints() callback for finding AFD_ENDPOINT bound to a specific
    port.

Arguments:

    Endpoint - The current AFD_ENDPOINT.

    ActualAddress - The actual address where the structure resides on the
        debugee.

    Context - The context value passed into EnumEndpoints().

Return Value:

    BOOL - TRUE if enumeration should continue, FALSE if it should be
        terminated.

--*/

{

    TA_IP_ADDRESS   ipAddress;
    ULONG result;
    USHORT endpointPort;
    ULONG64 address;
    ULONG   length;

    address = ReadField (LocalAddress);
    length = (ULONG)ReadField (LocalAddressLength);


    if( ( length != sizeof(ipAddress) ) ||
        ( address == 0 ) ) {

        dprintf (".");
        return TRUE;

    }

    if( !ReadMemory(
            address,
            &ipAddress,
            sizeof(ipAddress),
            &result
            ) ) {

        dprintf(
            "\nFindPortCallback: Could not read localAddress for endpoint @ %p\n",
            address
            );

        return TRUE;

    }

    if( ( ipAddress.TAAddressCount != 1 ) ||
        ( ipAddress.Address[0].AddressLength != sizeof(TDI_ADDRESS_IP) ) ||
        ( ipAddress.Address[0].AddressType != TDI_ADDRESS_TYPE_IP ) ) {

        dprintf (".");
        return TRUE;

    }

    endpointPort = NTOHS(ipAddress.Address[0].Address[0].sin_port);

    if( endpointPort == (USHORT)Context ) {

        if (!(Options & AFDKD_CONDITIONAL) ||
                    CheckConditional (ActualAddress, "AFD!AFD_ENDPOINT") ) {
            if (Options & AFDKD_NO_DISPLAY)
                dprintf ("+");
            else  {
                if (Options & AFDKD_BRIEF_DISPLAY) {
                    DumpAfdEndpointBrief (
                        ActualAddress
                        );
                }
                else {
                    DumpAfdEndpoint (
                        ActualAddress
                        );
                }
                if (Options & AFDKD_FIELD_DISPLAY) {
                    ProcessFieldOutput (ActualAddress, "AFD!AFD_ENDPOINT");
                }
            }
            EntityCount += 1;
        }
        else
            dprintf (".");


    }
    else {
        dprintf (".");
    }


    return TRUE;

}   // FindPortCallback

BOOL
FindProcessCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    )

/*++

Routine Description:

    EnumEndpoints() callback for finding AFD_ENDPOINTs owned by a specific
    process.

Arguments:

    Endpoint - The current AFD_ENDPOINT.

    ActualAddress - The actual address where the structure resides on the
        debugee.

    Context - The context value passed into EnumEndpoints().

Return Value:

    BOOL - TRUE if enumeration should continue, FALSE if it should be
        terminated.

--*/

{

    ULONG64         process;

    if (SavedMinorVersion>=2419) {
        process = ReadField (OwningProcess);
    }
    else {
        process = ReadField (ProcessCharge.Process);
    }

    if( process == Context ) {

        if (!(Options & AFDKD_CONDITIONAL) ||
                    CheckConditional (ActualAddress, "AFD!AFD_ENDPOINT") ) {
            if (Options & AFDKD_NO_DISPLAY)
                dprintf ("+");
            else  {
                if (Options & AFDKD_BRIEF_DISPLAY) {
                    DumpAfdEndpointBrief (
                        ActualAddress
                        );
                }
                else {
                    DumpAfdEndpoint (
                        ActualAddress
                        );
                }
                if (Options & AFDKD_FIELD_DISPLAY) {
                    ProcessFieldOutput (ActualAddress, "AFD!AFD_ENDPOINT");
                }
            }
            EntityCount += 1;
        }
        else
            dprintf (".");


    }
    else {
        dprintf (".");
    }

    return TRUE;

}   // FindProcessCallback

ULONG
FindProcessByPidCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    )
{
    PULONG64    pProcess = UserContext;
    ULONG64     Pid;
    ULONG       result;

    result = GetFieldValue (
                    pField->address,
                    "NT!_EPROCESS", 
                    "UniqueProcessId",
                    Pid
                    );
    if (result==0) {
        if (Pid==*pProcess) {
            *pProcess = pField->address;
            result = 1;
        }
        else
            dprintf (".");
    }
    else {
        dprintf ("\nFindProcessByPidCallback: Could not read process @ %p, err: %ld\n",
                    pField->address, result);
        *pProcess = 0;
    }

    return result;
}

ULONG64
FindProcessByPid (
    ULONG64 Pid
    )
{
    ULONG64 Process, Start;
    if (DebuggerData.PsActiveProcessHead==0) {
        dprintf ("\nFindProcessByPid: PsActiveProcessHead is NULL!!!\n");
        return 0;
    }
    if (ReadPtr (DebuggerData.PsActiveProcessHead, &Start)!=0) {
        dprintf ("\nFindProcessByPid: Can't read PsActiveProcessHead!!!\n");
        return 0;
    }

    Process = Pid;

    ListType (
            "NT!_EPROCESS",                          // Type
            Start,                                  // Address
            1,                                      // ListByFieldAddress
            "ActiveProcessLinks.Flink",             // NextPointer
            &Process,                               // Context
            FindProcessByPidCallback
            );
    if (Process!=Pid)
        return Process;
    else
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\help.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    help.c

Abstract:

    Help for AFD.SYS Kernel Debugger Extensions.

Author:

    Keith Moore (keithmo) 19-Apr-1995

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop



//
//  Public functions.
//

DECLARE_API( help )

/*++

Routine Description:

    Displays help for the AFD.SYS Kernel Debugger Extensions.

Arguments:

    None.

Return Value:

    None.

--*/

{

    gClient = pClient;

    dprintf( "?                         - Displays this list\n" );
    dprintf( "help                      - Displays this list\n" );
    dprintf( "endp [-b[rl]|-c|-v] [-r] [-f[co] fld,...] [-s endp | endp... | -e expr]\n"
             "                       - Dumps endpoint(s)\n" );
    dprintf( "file [-b[rl]|-v] [file...] [-f[co] fld,...] \n"
             "                       - Dumps endpoint(s) associated with file object(s)\n" );
    dprintf( "port [-b[rl]|-c|-v] [-r] [-e expr] [-f[co] fld,...] [-s endp] port\n"
             "                       - Dumps endpoint(s) bound to port(s)\n" );
    dprintf( "state [-b[rl]|-c|-v] [-r] [-e expr] [-f[co] fld,...] [-s endp] state\n"
             "                       - Dumps endpoints in specific states\n" );
    dprintf( "proc [-b[rl]|-c|-v] [-r] [-e expr] [-f[co] fld,...] [-s endp] [{proc|pid}]\n"
             "                       - Dumps endpoints owned by processes\n" );
    dprintf( "conn [-b|-c|-v] [-r] [-f[co] fld,...] [-s endp | conn... | -e expr]\n"
             "                       - Dumps connections\n" );
    dprintf( "rport [-b|-c|-v] [-r] [-f[co] fld,...] [-e expr] [-s endp] port\n"
             "                       - Dumps connections to remote ports\n" );
    dprintf( "tran [-b[l]|-c|-v] [-r] [-f[co] fld,...] [-s endp | irp... | -e expr]\n"
             "                       - Dumps TransmitPackets/File info\n" );
    dprintf( "buff [-b|-c|-v] [-r] [-f[co] fld,...] [-s endp | buff... | -e expr]\n"
             "                       - Dumps buffer structure\n");
    dprintf( "poll [-b|-v] [-r] [-f[co] fld,...] [-s endp | poll... | -e expr]\n"
             "                       - Dumps poll info structure(s)\n" );
    dprintf( "addr [-b|-v] [-f[co] fld,...] addr\n"
             "                       - Dumps transport address\n" );
    dprintf( "addrlist [-b|-v] [-f[co] fld,...] [-e expr]\n"
             "                       - Dumps addresses registered by the transports\n" );
    dprintf( "tranlist [-b|-v] [-f[co] fld,...] [-e expr]\n"
             "                       - Dumps transports known to afd (have open sockets)\n" );
    dprintf( "filefind <FsContext> - Finds file object given its FsContext field value\n" );
    dprintf( "In all of the above:\n" );
    dprintf( "      -b[rl]  - use brief display (1-line per entry),\n"
             "                r - dump text representation of the remote address,\n"
             "                l - count items in linked lists (takes time),\n");
    dprintf( "      -c      - don't display entry data, just count them,\n" );
    dprintf( "      -e expr - while scanning list evaluate the <expr> and only\n"
             "                dump entry if its result is not 0, prefix <expr> with @@\n"
             "                to use debugger's C++ evaluator, @$exp represents\n"
             "                current entry being processed (e.g. @$exp-><FieldName>\n"
             "                gets field values),\n" );
    dprintf( "      -f[co] fld,... - dump additional fields of the entries specified\n"
             "                (comma separated list, no spaces), c-compact,o-no offsets\n" );
    dprintf( "      -s endp - scan list starting with this endpoint,\n" );
    dprintf( "      -r      - scan endpoint list in reverse order,\n" );
    dprintf( "      -v      - force verbose display,\n" );
    dprintf( "      endp    - AFD_ENDPOINT structure at address <endp>,\n" );
    dprintf( "      file    - FILE_OBJECT structure at address <file>,\n" );
    dprintf( "      conn    - AFD_CONNECTION structure at address <conn>,\n" );
    dprintf( "      proc    - EPROCESS structure at address <proc>,\n" );
    dprintf( "      pid     - process id,\n" );
    dprintf( "      port    - port in host byte order and current debugger base (use n 10|16 to set),\n" );
    dprintf( "      irp     - TPackets/TFile/DisconnectEx IRP at address <irp>,\n" );
    dprintf( "      buff    - AFD_BUFFER_HEADER structure at address <buff>,\n" );
    dprintf( "      poll    - AFD_POLL_INFO_INTERNAL structure at address <poll>,\n" );
    dprintf( "      addr    - TRANSPORT_ADDRESS structure at address <addr>,\n" );
    dprintf( "      state   - endpoint state, valid states are:\n" );
    dprintf( "                  1 - Open\n" );
    dprintf( "                  2 - Bound\n" );
    dprintf( "                  3 - Connected\n" );
    dprintf( "                  4 - Cleanup\n" );
    dprintf( "                  5 - Closing\n" );
    dprintf( "                  6 - TransmitClosing\n" );
    dprintf( "                  7 - Invalid\n" );
    dprintf( "                  10 - Listening.\n" );
    dprintf( "\n");
    if( IsReferenceDebug ) {
        dprintf( "cref <conn>    - Dumps connection reference debug info\n" );
        dprintf( "eref <endp>    - Dumps endpoint reference debug info\n" );
        dprintf( "tref <tpck>    - Dumps tpacket reference debug info\n" );
    }
    dprintf( "sock [-m] [-f[co] fld,...] [-e expr | Hdl] - Dumps user mode socket context(s)\n"
             "                for current address space (needs ws2help, ws2_32,\n"
             "                and %s (for -m) symbols).\n", 
             SavedMinorVersion>2195 ? "mswsock.dll" : "msafd.dll");
    dprintf( "dprov [-f[co] fld,...] [-e expr | prov] - Dumps Winsock2 protocol or catalog\n"
             "                for current address space (needs ws2_32 symbols).\n");
    dprintf( "nprov [-f[co] fld,...] [-e expr | prov] - Dumps Winsock2 namesapce or catalog\n"
             "                for current address space (needs ws2_32 symbols).\n");
    dprintf( "tcb [-w] [-y] [-f[co] fld,...] [-e expr | tcb] - Dumps TCPIP TCB or TCBTable\n"
             "                 -w dumps TWTCBTable, -y dumps SYNTCBTable.\n");
    dprintf( "tao [-f[co] fld,...] [-e expr | ao] - Dumps TCPIP AO or AOTable.\n");
    dprintf( "tcb6 [-f[co] fld,...] [-e expr | tcb6] - Dumps TCPIP6 TCB or TCBTable.\n");
    dprintf( "tao6 [-f[co] fld,...] [-e expr | ao6] - Dumps TCPIP6 AO or AOTable.\n");
    dprintf( "stats         - Dumps debug-only statistics\n" );
    dprintf( "version       - Display extension version and reload global info\n" );
#if GLOBAL_REFERENCE_DEBUG
    dprintf( "gref          - Dumps global reference debug info\n" );
#endif

    return S_OK;
}   // help


ULONG           Options;
ULONG64         StartEndpoint;
CHAR Conditional[MAX_CONDITIONAL_EXPRESSION];
CHAR FieldNames[MAX_FIELDS_EXPRESSION];
FIELD_INFO Fields[MAX_NUM_FIELDS];
SYM_DUMP_PARAM FldParam = {
                    sizeof (SYM_DUMP_PARAM),    // size
                    NULL,                       // sName
                    0,                          // Options
                    0,                          // addr
                    NULL,                       // listLink
                    NULL, NULL,                 // Context,CallbackRoutine
                    0,                          // nFields
                    Fields                      // Fields
};
CHAR LinkField[MAX_FIELD_CHARS];
CHAR ListedType[MAX_FIELD_CHARS];
ULONG CppFieldEnd;
                       

PCHAR
ProcessOptions (
    IN  PCHAR Args
    )
{
    CHAR    expr[max(MAX_FIELDS_EXPRESSION,MAX_CONDITIONAL_EXPRESSION)];
    ULONG   i;

    Options = 0;
    CppFieldEnd = 0;
    FldParam.nFields = 0;
    FldParam.Options = 0;

    while (sscanf( Args, "%s%n", expr, &i )==1) {
        Args += i;
        if (CheckControlC ())
            break;
        if (expr[0]=='-') {
            switch (expr[1]) {
            case 'B':
            case 'b':
                if ((Options & (AFDKD_NO_DISPLAY))==0) {
                    Options |= AFDKD_BRIEF_DISPLAY;
                    for (i=2; expr[i]!=0; i++) {
                        switch (expr[i]) {
                        case 'l':
                            Options |= AFDKD_LIST_COUNT;
                            break;
                        case 'r':
                            Options |= AFDKD_RADDR_DISPLAY;
                            break;
                        }
                    }
                    continue;
                }
                else {
                    dprintf ("\nProcessOptions: only one of -b or -c options can be specified.\n");
                }
                break;
            case 'C':
            case 'c':
                Options |= AFDKD_NO_DISPLAY;
                Options &= ~AFDKD_BRIEF_DISPLAY;
                continue;
            case 'E':
            case 'e':
                if (sscanf( Args, "%s%n", Conditional, &i )==1) {
                    Args += i;
                    Options |= AFDKD_CONDITIONAL;
                    continue;
                }
                else {
                    dprintf ("\nProcessOptions: -e requires an argument.\n");
                }
                break;
            case 'F':
            case 'f':
                for (i=2; expr[i]!=0; i++) {
                    switch (expr[i]) {
                    case 'c':
                        FldParam.Options |= DBG_DUMP_COMPACT_OUT;
                        break;
                    case 'o':
                        FldParam.Options |= DBG_DUMP_NO_OFFSET;
                        break;
                    }
                }
                if (sscanf( Args, "%s%n", FieldNames, &i )==1) {
                    PCHAR fld;
                    Args += i;
                    Options |= AFDKD_FIELD_DISPLAY;
                    if (strcmp (FieldNames,".")==0) {
                        FldParam.nFields = 0;
                        CppFieldEnd = 0;
                        continue;
                    }
                    for (i=FldParam.nFields, fld = strtok (FieldNames, ","); 
                                i<sizeof (Fields)/sizeof (Fields[0]) && fld!=NULL; 
                                i++, fld = strtok (NULL, ",")) {
                        Fields[i].fOptions = DBG_DUMP_FIELD_FULL_NAME;
                        if (*fld=='-') {
                            fld+=1;
                            do {
                                switch (*fld) {
                                case 'a':
                                    Fields[i].fOptions |= DBG_DUMP_FIELD_ARRAY;
                                    break;
                                case 'g':
                                    Fields[i].fOptions |= DBG_DUMP_FIELD_GUID_STRING;
                                    break;
                                case 'm':
                                    Fields[i].fOptions |= DBG_DUMP_FIELD_MULTI_STRING;
                                    break;
                                case 's':
                                    Fields[i].fOptions |= DBG_DUMP_FIELD_DEFAULT_STRING;
                                    break;
                                case 'w':
                                    Fields[i].fOptions |= DBG_DUMP_FIELD_WCHAR_STRING;
                                    break;
                                case 'y':
                                    Fields[i].fOptions &= ~DBG_DUMP_FIELD_FULL_NAME;
                                    break;
                                }
                            }
                            while (*fld++!=':');
                        }
                        Fields[i].fName = fld;
                    }
                    if (fld==NULL) {
                        if (i>0) {
                            FldParam.nFields = i;
                            CppFieldEnd = i;
                            for (i=0; i<FldParam.nFields; i++) {
                                if (strncmp (Fields[i].fName, 
                                                AFDKD_CPP_PREFIX, 
                                                AFDKD_CPP_PREFSZ)==0) {
                                    FIELD_INFO tmp = Fields[i];
                                    Fields[i] = Fields[--FldParam.nFields];
                                    Fields[FldParam.nFields] = tmp;
                                }
                            }
                            continue;
                        }
                        else {
                            dprintf("\nProcessOptions: -f requires at least one valid field name.\n");
                        }
                    }
                    else {
                        dprintf("\nProcessOptions: too many fields (>%d) for -f.\n", i);
                    }
                }
                else {
                    dprintf ("\nProcessOptions: -f requires an argument.\n");
                }
                break;
            case 'L':
            case 'l':
                for (i=2; expr[i]!=0; i++) {
                    switch (expr[i]) {
                    case 'a':
                        Options |= AFDKD_LINK_AOF;
                        break;
                    case 's':
                        Options |= AFDKD_LINK_SELF;
                        break;
                    }
                }

                if (sscanf( Args, "%s%n", LinkField, &i )==1) {
                    Args += i;
                    Options |= AFDKD_LINK_FIELD;
                    continue;
                }
                else {
                    dprintf ("\nProcessOptions: -l requires an argument.\n");
                }
                break;
            case 'M':
            case 'm':
                Options |= AFDKD_MSWSOCK_DISPLAY;
                continue;
            case 'R':
            case 'r':
                Options |= AFDKD_BACKWARD_SCAN;
                continue;
            case 'S':
            case 's':
                Options |= AFDKD_ENDPOINT_SCAN;
                if (sscanf( Args, "%s%n", expr, &i )==1) {
                    Args += i;
                    StartEndpoint = GetExpression (expr);
                    if (StartEndpoint!=0) {
                        dprintf ("ProcessOptions: StartEndpoint-%p\n", StartEndpoint);
                        continue;
                    }
                    else {
                        dprintf ("ProcessOptions: StartEndpoint (%s) evaluates to NULL\n", expr);
                    }

                }
                else {
                    dprintf ("\nProcessOptions: %s option missing required parameter.\n", expr);
                }
                break;
            case 'T':
            case 't':

                if (sscanf( Args, "%s%n", ListedType, &i )==1) {
                    Args += i;
                    Options |= AFDKD_LIST_TYPE;
                    continue;
                }
                else {
                    dprintf ("\nProcessOptions: -l requires an argument.\n");
                }
                break;
            case 'V':
            case 'v':
                Options &= ~AFDKD_BRIEF_DISPLAY;
                continue;
            case 'W':
            case 'w':
                if ((Options & (AFDKD_SYNTCB_DISPLAY))==0) {
                    Options |= AFDKD_TWTCB_DISPLAY;
                    continue;
                }
                else {
                    dprintf ("\nProcessOptions: only one of -y or -w options can be specified.\n");
                }
                break;
            case 'Y':
            case 'y':
                if ((Options & (AFDKD_TWTCB_DISPLAY))==0) {
                    Options |= AFDKD_SYNTCB_DISPLAY;
                    continue;
                }
                else {
                    dprintf ("\nProcessOptions: only one of -y or -w options can be specified.\n");
                }
                break;
            default:
                dprintf ("\nProcessOptions: Unrecognized option %s.\n", expr);
            }

            return NULL;
        }
        else {
            Args -= i;
            break;
        }
    }

    return Args;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\kdexts.cpp ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "afdkdp.h"
#pragma hdrstop

/*
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT
#include <wdbgexts.h>
#include <dbgeng.h>
*/

//
// globals
//
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG64                STeip;
ULONG64                STebp;
ULONG64                STesp;
ULONG                  SavedDebugClass, SavedDebugType;
ULONG                  SavedMachineType, SavedMajorVersion, SavedMinorVersion;
ULONG                  SavedSrvPack;
CHAR                   SavedBuildString[128];


LIST_ENTRY             TransportInfoList;
BOOL                   IsCheckedAfd;
BOOL                   IsReferenceDebug;
ULONG64                UserProbeAddress;
ULONG                  TicksToMs, TickCount;
ULONG                  AfdBufferOverhead;
ULONG                  AfdStandardAddressLength;
ULONG                  AfdBufferTagSize;
LARGE_INTEGER          SystemTime, InterruptTime;

ULONG                  DatagramBufferListOffset,
                        DatagramRecvListOffset,
                        DatagramPeekListOffset,
                        RoutingNotifyListOffset,
                        RequestListOffset,
                        EventStatusOffset,
                        ConnectionBufferListOffset,
                        ConnectionSendListOffset,
                        ConnectionRecvListOffset,
                        UnacceptedConnListOffset,
                        ReturnedConnListOffset,
                        ListenConnListOffset,
                        FreeConnListOffset,
                        PreaccConnListOffset,
                        SanIrpListOffset,
                        ListenIrpListOffset,
                        PollEndpointInfoOffset,
                        DriverContextOffset,
                        SendIrpArrayOffset,
                        FsContextOffset;

ULONG                  EndpointLinkOffset,
                        ConnectionLinkOffset,
                        BufferLinkOffset,
                        AddressEntryLinkOffset,
                        TransportInfoLinkOffset,
                        AddressEntryAddressOffset;

ULONG                  ConnRefOffset,
                        EndpRefOffset,
                        TPackRefOffset;

ULONG                  RefDebugSize;

ULONG                  AfdResult, NtResult;
BOOLEAN                KmGlobalsRead;
ULONG                  KmActivationSeqN;

BOOLEAN                StateInitialized;
ULONG                  DebuggerActivationSeqN;
KDDEBUGGER_DATA64      DebuggerData;
PDEBUG_CLIENT          gClient;

HRESULT
InitializeState (
    PDEBUG_CLIENT   Client OPTIONAL
    );

VOID
FreeTransportList (
    VOID
    );

ULONG
ReadTimeInfo (
    );

BOOLEAN
ReadKmGlobals ( 
    );

extern "C"
BOOL 
WINAPI 
DllMain (
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            FreeTransportList ();
            break;

        case DLL_PROCESS_ATTACH:
            StateInitialized = FALSE;
            InitializeListHead (&TransportInfoList);
            KmGlobalsRead = FALSE;
            NtResult = 0;
            AfdResult = 0;
            break;
    }

    return TRUE;
}




extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;


    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) == S_OK) {
        if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                                  (void **)&DebugControl)) == S_OK) {

            ExtensionApis.nSize = sizeof (ExtensionApis);
            Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis);
            DebugControl->Release();
        }
        DebugClient->Release();
    }


    StateInitialized = FALSE;
    KmGlobalsRead = FALSE;
    NtResult = 0;
    AfdResult = 0;

    return S_OK;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{

    FreeTransportList ();
    return;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument) {

    switch (Notify) {
    case DEBUG_NOTIFY_SESSION_ACTIVE:
        StateInitialized = FALSE;
        break;
    case DEBUG_NOTIFY_SESSION_ACCESSIBLE:
        if (!StateInitialized) {
            InitializeState (NULL);
        }
        DebuggerActivationSeqN += 1;
        break;
    case DEBUG_NOTIFY_SESSION_INACCESSIBLE:
        DebuggerActivationSeqN += 1;
        break;
    case DEBUG_NOTIFY_SESSION_INACTIVE:
        FreeTransportList ();
        break;
    default:
        break;
    }

    return;
}

DECLARE_API( version ) {
    PCHAR   argp;
    CHAR    srvpackstr[128];
#if DBG
    PCHAR ExtensionType = "Checked";
#else
    PCHAR ExtensionType = "Free";
#endif

    gClient = pClient;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL) {
        return E_INVALIDARG;
    }

    if (!StateInitialized) {
        InitializeState (pClient);
    }

    if (argp[0]!=0) {
        SavedMinorVersion = (USHORT)GetExpression (argp);
    }

    if (SavedSrvPack != 0) {
        _snprintf (srvpackstr, sizeof (srvpackstr)-1, " (service pack: %d)", SavedSrvPack);
        srvpackstr[sizeof(srvpackstr)-1] = 0;
    }
    else {
        srvpackstr[0] = 0;
    }


    dprintf( "%s extension dll for build %d debugging %s build %d%s. %s\n",
             ExtensionType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "checked" : 
                SavedMajorVersion == 0x0f ? "free" : "unknown",
             SavedMinorVersion,
             srvpackstr,
             SavedBuildString
           );

    if (SavedDebugClass==DEBUG_CLASS_KERNEL) {
        if (CheckKmGlobals ()) {
            dprintf( "Running %s AFD.SYS\n",
                IsCheckedAfd ? "Checked" : (IsReferenceDebug ? "Free with reference debug" : "Free")
                   );
        }
    }
    return S_OK;
}


BOOLEAN
CheckKmGlobals (
    )
{
    if (!StateInitialized) {
        KmGlobalsRead = FALSE;
        if (InitializeState (gClient)!=S_OK) {
            return FALSE;
        }
    }

    if (SavedDebugClass==DEBUG_CLASS_KERNEL) {
        if (KmGlobalsRead) {
            if (KmActivationSeqN!=DebuggerActivationSeqN) {
                if (ReadTimeInfo ()==0) {
                    KmActivationSeqN = DebuggerActivationSeqN;
                }
            }
        }
        else {
            KmGlobalsRead = ReadKmGlobals ();
        }
        return TRUE;
    }
    else {
        dprintf ("\nThis command is only available in kernel mode debugging sessions\n");
        return FALSE;
    }
}


HRESULT
GetExpressionFromType (
    IN  ULONG64 Address,
    IN  PCHAR   Type,
    IN  PCHAR   Expression,
    IN  ULONG   OutType,
    OUT PDEBUG_VALUE Value
    )
{
    CHAR    expr[MAX_ADDRESS_EXPRESSION];
    PDEBUG_CONTROL3 DebugControl;
    HRESULT Hr;
    DEBUG_VALUE ignore;
    ULONG flags;
    BOOLEAN cpp = FALSE;

    if ((Hr = gClient->QueryInterface(__uuidof(IDebugControl3),
                                              (void **)&DebugControl)) == S_OK) {

        if (strncmp (Expression, AFDKD_CPP_PREFIX, AFDKD_CPP_PREFSZ)==0) {
            if (DebugControl->GetExpressionSyntax (&flags)!=S_OK) {
                dprintf ("\nGetExpressionFromType: GetExpressionSyntax failed, hr: %x\n",
                            Hr);
            }
            if (DebugControl->SetExpressionSyntax (DEBUG_EXPR_CPLUSPLUS)!=S_OK) {
                dprintf ("\nGetExpressionFromType: SetExpressionSyntax(CPP) failed, hr: %x\n",
                            Hr);
                goto FailedCpp;
            }
            cpp = TRUE;
            _snprintf (expr, sizeof (expr)-1, "((%s*)0x%I64X)", 
                            Type,  Address);
        }
        else {
            _snprintf (expr, sizeof (expr), "0x%I64X", Address);
        }
        expr[sizeof(expr)-1] = 0;

        Hr = DebugControl->Evaluate(expr,
                                    DEBUG_VALUE_INVALID,
                                    &ignore,
                                    NULL);
        if (Hr==S_OK) {

            Hr = DebugControl->Evaluate(&Expression[AFDKD_CPP_PREFSZ],
                                        OutType,
                                        Value,
                                        NULL);
            if (Hr==S_OK) {
            }
            else {
                dprintf ("\nGetExpressionFromType: Evaluate(%s) for @$exp=0x%p failed, hr: %x\n",
                                Expression,
                                Address, 
                                Hr);
            }
        }
        else {
            dprintf ("\nGetExpressionFromType: Evaluate(%s) failed, hr: %x\n", expr, Hr);
        }

        if (cpp) {
            if (DebugControl->SetExpressionSyntax (flags)!=S_OK) {
                dprintf ("\nGetExpressionFromType: SetExpressionSyntax failed, hr: %x\n", Hr);
            }
        }

    FailedCpp:
        DebugControl->Release();
    }
    else {
        dprintf ("\nGetCppExpression: Failed to obtain debug control interface, hr: %x\n", Hr);
    }

    return Hr;
}


VOID
FreeTransportList (
    VOID
    )
{
    while (!IsListEmpty (&TransportInfoList)) {
        PLIST_ENTRY  listEntry;
        PAFDKD_TRANSPORT_INFO   transportInfo;
        listEntry = RemoveHeadList (&TransportInfoList);
        transportInfo = CONTAINING_RECORD (listEntry,
                                AFDKD_TRANSPORT_INFO,
                                Link);
        RtlFreeHeap (RtlProcessHeap (), 0, transportInfo);
    }
}

ULONG
ReadTimeInfo (
    )
{
    ULONG   result;
    ULONG64 address;
    PDEBUG_DATA_SPACES pDebugDataSpaces;
    HRESULT hr;

    TickCount = 0;
    TicksToMs = 0;
    InterruptTime.QuadPart = 0;
    SystemTime.QuadPart = 0;
    
    address = MM_SHARED_USER_DATA_VA;
    if ((hr = gClient->QueryInterface(__uuidof(IDebugDataSpaces),
                        (void **)&pDebugDataSpaces)) == S_OK) {
        if ((hr = pDebugDataSpaces->ReadDebuggerData(
                                    DEBUG_DATA_SharedUserData, &address,
                                    sizeof(address), NULL)) == S_OK) {
        }
        else {
            dprintf ("\nReadTimeInfo: Cannot get SharedUserData address, hr:%lx\n", hr);
        }
        pDebugDataSpaces->Release ();
    }
    else {
        dprintf ("\nReadTimeInfo:Cannot obtain debug data spaces interface, hr:%lx\n", hr);
    }

    if (

#if defined(_AMD64_)

                (result=GetFieldValue(address,
                            "NT!_KUSER_SHARED_DATA",
                            "TickCount",
                            TickCount))!=0 ||

#else

                (result=GetFieldValue(address,
                            "NT!_KUSER_SHARED_DATA",
                            "TickCountLow",
                            TickCount))!=0 ||

#endif

                (result=GetFieldValue(address,
                            "NT!_KUSER_SHARED_DATA",
                            "TickCountMultiplier",
                            TicksToMs))!=0 ||
                (result=GetFieldValue(address,
                            "NT!_KUSER_SHARED_DATA",
                            "InterruptTime.High1Time",
                            InterruptTime.HighPart))!=0 ||
                (result=GetFieldValue(address,
                        "NT!_KUSER_SHARED_DATA",
                        "InterruptTime.LowPart",
                        InterruptTime.LowPart))!=0 ||
                (result=GetFieldValue(address,
                        "NT!_KUSER_SHARED_DATA",
                        "SystemTime.High1Time",
                        SystemTime.HighPart))!=0 ||
                (result=GetFieldValue(MM_SHARED_USER_DATA_VA,
                        "NT!_KUSER_SHARED_DATA",
                        "SystemTime.LowPart",
                        SystemTime.LowPart))!=0 ) {
        KUSER_SHARED_DATA sharedData;
        ULONG   length;
        if (ReadMemory (address,
                            &sharedData,
                            sizeof (sharedData),
                            &length)) {

#if defined(_AMD64_)

            TickCount = sharedData.TickCount.LowPart;

#else

            if (sharedData.TickCountLowDeprecated) {
                TickCount = sharedData.TickCountLowDeprecated;
            } else {
                TickCount = sharedData.TickCount.LowPart;
            }

#endif

            TicksToMs = sharedData.TickCountMultiplier;
            InterruptTime.HighPart = sharedData.InterruptTime.High1Time;
            InterruptTime.LowPart = sharedData.InterruptTime.LowPart;
            SystemTime.HighPart = sharedData.SystemTime.High1Time;
            SystemTime.LowPart = sharedData.SystemTime.LowPart;
            result = 0;
        }
        else {
            dprintf ("\nReadTimeInfo: Could not read SHARED_USER_DATA @ %p\n",
                            address);
        }
    }

    return result;
}

BOOLEAN
ReadKmGlobals ( 
    )
{
    ULONG             result;
    ULONG64           val;
    INT               i;
    struct {
        LPSTR       Type;
        LPSTR       Field;
        PULONG      pOffset;
    } MainOffsets[] = {
        {"AFD!AFD_ENDPOINT",    "Common.Datagram.ReceiveBufferListHead",&DatagramBufferListOffset    },
        {"AFD!AFD_ENDPOINT",    "Common.Datagram.ReceiveIrpListHead",   &DatagramRecvListOffset      },
        {"AFD!AFD_ENDPOINT",    "Common.Datagram.PeekIrpListHead",      &DatagramPeekListOffset      },
        {"AFD!AFD_ENDPOINT",    "RoutingNotifications",                 &RoutingNotifyListOffset     },
        {"AFD!AFD_ENDPOINT",    "RequestList",                          &RequestListOffset           },
        {"AFD!AFD_ENDPOINT",    "EventStatus",                          &EventStatusOffset           },
        {"AFD!AFD_ENDPOINT",    "Common.VirtualCircuit.Listening.UnacceptedConnectionListHead",
                                                                        &UnacceptedConnListOffset    },
        {"AFD!AFD_ENDPOINT",    "Common.VirtualCircuit.Listening.ReturnedConnectionListHead",
                                                                        &ReturnedConnListOffset      },
        {"AFD!AFD_ENDPOINT",    "Common.VirtualCircuit.Listening.ListenConnectionListHead",
                                                                        &ListenConnListOffset        },
        {"AFD!AFD_ENDPOINT",    "Common.VirtualCircuit.Listening.FreeConnectionListHead",
                                                                        &FreeConnListOffset          },
        {"AFD!AFD_ENDPOINT",    "Common.VirtualCircuit.Listening.PreacceptedConnectionsListHead",
                                                                        &PreaccConnListOffset        },
        {"AFD!AFD_ENDPOINT",    "Common.SanEndp.IrpList",               &SanIrpListOffset            },
        {"AFD!AFD_ENDPOINT",    "Common.VirtualCircuit.Listening.ListeningIrpListHead",
                                                                        &ListenIrpListOffset         },
        {"AFD!AFD_ENDPOINT",    "GlobalEndpointListEntry",              &EndpointLinkOffset          },
        {"AFD!AFD_CONNECTION",  "Common.NonBufferring.ReceiveBufferListHead",
                                                                        &ConnectionBufferListOffset  },
        {"AFD!AFD_CONNECTION",  "Common.NonBufferring.SendIrpListHead", &ConnectionSendListOffset    },
        {"AFD!AFD_CONNECTION",  "Common.NonBufferring.ReceiveIrpListHead",
                                                                        &ConnectionRecvListOffset    },
        {"AFD!AFD_CONNECTION",  "ListEntry",                            &ConnectionLinkOffset        },
        {"AFD!AFD_POLL_INFO_INTERNAL","EndpointInfo",                   &PollEndpointInfoOffset      },
        {"AFD!AFD_ADDRESS_ENTRY","Address",                             &AddressEntryAddressOffset   },
        {"AFD!AFD_ADDRESS_ENTRY","AddressListLink",                     &AddressEntryLinkOffset      },
        {"AFD!AFD_BUFFER_HEADER","BufferListEntry",                     &BufferLinkOffset            },
        {"AFD!AFD_TRANSPORT_INFO","TransportInfoListEntry",             &TransportInfoLinkOffset     },
        {"AFD!FILE_OBJECT",     "FsContext",                            &FsContextOffset             },
        {"AFD!IRP",             "Tail.Overlay.DriverContext",           &DriverContextOffset         }
    };
    struct {
        LPSTR       Type;
        LPSTR       Field;
        PULONG      pOffset;
    } RefOffsets[] = {
        {"AFD!AFD_ENDPOINT",    "ReferenceDebug",                       &EndpRefOffset               },
        {"AFD!AFD_CONNECTION",  "ReferenceDebug",                       &ConnRefOffset               },
        {SavedMinorVersion>=2219
            ? "AFD!AFD_TPACKETS_INFO_INTERNAL"
            : "AFD!AFD_TRANSMIT_FILE_INFO_INTERNAL","ReferenceDebug",   &TPackRefOffset              }
    };

    if (!GetDebuggerData (KDBG_TAG, &DebuggerData, sizeof (DebuggerData))) {
        dprintf ("\nReadKmGlobals: could not get debugger data\n");
        NtResult = 1;
    }

    if (NtResult==0) {
        UserProbeAddress = 0;
        result = ReadPtr (DebuggerData.MmUserProbeAddress, &UserProbeAddress);
        if (result==0) {
            NtResult = 0;
        }
        else {
            if (result!=NtResult) {
                dprintf ("\nReadKmGlobals: could not read nt!MmUserProbeAddress, err: %ld\n");
                NtResult = result;
            }
        }
    }


    if (NtResult==0) {
        result = ReadTimeInfo ();
        if (result!=0) {
            if (result!=NtResult) {
                dprintf("\nReadKmGlobals: Could not read time info from USER_SHARED_DATA, err: %ld\n", result);
                NtResult = result;
            }
        }
    }

    result = GetFieldValue (0,
                            "AFD!AfdBufferOverhead",
                            NULL,
                            val);
    if (result==0) {
        AfdResult = 0;
    }
    else {
        if (result!=AfdResult) {
            dprintf("\nReadKmGlobals: Could not read afd!AfdBufferOverhead, err: %ld\n", result);
            AfdResult = result;
        }
    }
    AfdBufferOverhead = (ULONG)val;

    if (AfdResult==0) {
        //
        // Try to get a pointer to afd!AfdDebug. If we can, then we know
        // the target machine is running a checked AFD.SYS.
        //

        IsCheckedAfd = ( GetExpression( "AFD!AfdDebug" ) != 0 );
        IsReferenceDebug = ( GetExpression( "AFD!AfdReferenceEndpoint" ) != 0 );

        result = GetFieldValue (0,
                                "AFD!AfdStandardAddressLength",
                                NULL,
                                val);
        if (result!=0) {
            if (result!=AfdResult) {
                dprintf("\nReadKmGlobals: Could not read AFD!AfdStandardAddressLength, err: %ld\n", result);
                AfdResult = result;
            }
        }
        AfdStandardAddressLength = (ULONG)val;

        AfdBufferTagSize = GetTypeSize ("AFD!AFD_BUFFER_TAG");
        if (AfdBufferTagSize==0) {
            if (result!=AfdResult) {
                dprintf ("\nReadKmGlobals: Could not get sizeof (AFD_BUFFER_TAG)\n");
                AfdResult = result;
            }
        }

        for (i=0; i<sizeof (MainOffsets)/sizeof (MainOffsets[0]); i++ ) {
            result = GetFieldOffset (MainOffsets[i].Type, MainOffsets[i].Field, MainOffsets[i].pOffset);
            if (result!=0) {
                if (result!=AfdResult) {
                    dprintf ("\nReadKmGlobals: Could not get offset of %s in %s, err: %ld\n",
                                        MainOffsets[i].Field, MainOffsets[i].Type, result);
                    AfdResult = result;
                }
            }
        }

        if (IsReferenceDebug ) {
            for (i=0; i<sizeof (RefOffsets)/sizeof (RefOffsets[0]); i++ ) {
                result = GetFieldOffset (RefOffsets[i].Type, RefOffsets[i].Field, RefOffsets[i].pOffset);
                if (result!=0) {
                    if (result!=AfdResult) {
                        dprintf ("\nReadKmGlobals: Could not get offset of %s in %s, err: %ld\n",
                                            RefOffsets[i].Field, RefOffsets[i].Type, result);
                        AfdResult = result;
                    }
                }
            }
            RefDebugSize = GetTypeSize ("AFD!AFD_REFERENCE_LOCATION");
            if (RefDebugSize==0) {
                dprintf ("\nReadKmGlobals: sizeof (AFD!AFD_REFERENCE_LOCATION) is 0!!!!!\n");
            }
        }

        if (SavedMinorVersion>=2219) {
            result = GetFieldOffset ("AFD!AFD_TPACKETS_INFO_INTERNAL", "SendIrp", &SendIrpArrayOffset);
            if (result!=0) {
                dprintf ("\nReadKmGlobals: Could not get offset of %s in %s, err: %ld\n",
                                    "SendIrp", "AFD!AFD_TPACKETS_INFO_INTERNAL", result);
                if (result!=AfdResult) {
                    AfdResult = result;
                }
            }
        }
    }

    if (NtResult==0 && AfdResult==0) {
        return TRUE;
    }
    else
        return FALSE;


}

HRESULT
InitializeState (
    PDEBUG_CLIENT pClient
    )
{
    PDEBUG_CONTROL DebugControl;
    HRESULT hr;
    BOOLEAN releaseClient = FALSE;

    SavedMachineType = IMAGE_FILE_MACHINE_UNKNOWN;
    SavedDebugClass = DEBUG_CLASS_UNINITIALIZED;
    SavedDebugType = 0;
    SavedMajorVersion = 0;
    SavedMinorVersion = 0;
    SavedSrvPack = 0;
    SavedBuildString[0] = 0;

    if (pClient==NULL) {
        if ((hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&pClient)) != S_OK) {
            dprintf ("\nInitializeState: Cannot create debug client, hr:%lx\n", hr);
            return hr;
        }
        releaseClient = TRUE;
    }
    //
    // Get the architecture type.
    //

    if ((hr = pClient->QueryInterface(__uuidof(IDebugControl),
                               (void **)&DebugControl)) == S_OK) {
        
        if ((hr = DebugControl->GetActualProcessorType(&SavedMachineType)) == S_OK) {
            ULONG stringUsed, platform;

            StateInitialized = TRUE;

            if ((hr = DebugControl->GetDebuggeeType(&SavedDebugClass, &SavedDebugType)) != S_OK) {
                dprintf ("\nInitializeState: Cannot get debug class and type, hr:%lx\n", hr);
            }

            if ((hr = DebugControl->GetSystemVersion(
                                        &platform,
                                        &SavedMajorVersion, &SavedMinorVersion, 
                                        NULL, 0, NULL,
                                        &SavedSrvPack, 
                                        &SavedBuildString[0], sizeof(SavedBuildString), 
                                        &stringUsed)) != S_OK) {
                 dprintf ("\nInitializeState: Cannot get system version, hr:%lx\n", hr);
            }
        }
        else {
            dprintf ("\nInitializeState: Cannot get processor type, hr:%lx\n", hr);
        }
        DebugControl->Release();
    }
    else {
        dprintf ("\nInitializeState: Cannot obtain debug control interface, hr:%lx\n", hr);
    }

    if (releaseClient)
        pClient->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\ref.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ref.c

Abstract:

    Implements the cref, eref, and gref commands.

Author:

    Keith Moore (keithmo) 09-Dec-1995

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop


DECLARE_API( eref )

/*++

Routine Description:

    Dumps the AFD_REFERENCE_DEBUG structure at the specified address.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG64 address = 0;
    ULONG   idx;

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    //
    // Verify we're running a checked AFD.SYS.
    //

    if( !IsReferenceDebug ) {

        dprintf(
            "eref: this command only available with CHECKED or specially\n"
            "      built (with /DREFERENCE_DEBUG=1) AFD.SYS!\n"
            );

        return E_INVALIDARG;

    }

    //
    // Snag the address from the command line.
    //

    address = GetExpression (args);

    if( address == 0 ) {

        dprintf( "\nUsage: eref endpoint_address\n" );
        return E_INVALIDARG;

    }

    if (GetFieldValue (address,
             "AFD!AFD_ENDPOINT",
             "CurrentReferenceSlot",
             idx)!=0) {

        dprintf("\neref: Could not read CurrentReferenceSlot for endpoint %p\n",
                  address );
        return E_INVALIDARG;
    }

    if (SavedMinorVersion>=3554) {
        ULONG    timeHigh;
        if (GetFieldValue (address,
                 "AFD!AFD_ENDPOINT",
                 "CurrentTimeHigh",
                 timeHigh)!=0) {

            dprintf("\neref: Could not read CurrentTimeHigh for endpoint %p\n",
                      address );
            return E_INVALIDARG;
        }
        DumpAfdReferenceDebug(
            address+EndpRefOffset, (ULONGLONG)idx+((ULONGLONG)timeHigh<<32)
        );
    }
    else {
        DumpAfdReferenceDebug(
            address+EndpRefOffset, idx
        );
    }

    return S_OK;
}   // eref

DECLARE_API( cref )

/*++

Routine Description:

    Dumps the AFD_REFERENCE_DEBUG structure at the specified address.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG64 address = 0;
    ULONG   idx;

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    //
    // Verify we're running a checked AFD.SYS.
    //

    if( !IsReferenceDebug ) {

        dprintf(
            "cref: this command only available with CHECKED or specially\n"
            "      built (with /DREFERENCE_DEBUG=1) AFD.SYS!\n"
            );

        return E_INVALIDARG;

    }

    //
    // Snag the address from the command line.
    //

    address = GetExpression (args);

    if( address == 0 ) {

        dprintf( "\nUsage: cref connection_address\n" );
        return E_INVALIDARG;

    }

    if (GetFieldValue (address,
             "AFD!AFD_CONNECTION",
             "CurrentReferenceSlot",
             idx)!=0) {

        dprintf("\ncref: Could not read CurrentReferenceSlot for connection %p\n",
                  address );
        return E_INVALIDARG;
    }


    if (SavedMinorVersion>=3554) {
        ULONG   timeHigh;
        if (GetFieldValue (address,
                 "AFD!AFD_CONNECTION",
                 "CurrentTimeHigh",
                 timeHigh)!=0) {

            dprintf("\neref: Could not read CurrentTimeHigh for connection %p\n",
                      address );
            return E_INVALIDARG;
        }
        DumpAfdReferenceDebug(
            address+ConnRefOffset, (ULONGLONG)idx+((ULONGLONG)timeHigh<<32)
        );
    }
    else {
        DumpAfdReferenceDebug(
            address+ConnRefOffset, idx
        );
    }

    return S_OK;

}   // cref

DECLARE_API( tref )

/*++

Routine Description:

    Dumps the AFD_REFERENCE_DEBUG structure at the specified address.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG64 address = 0;
    ULONG   idx;

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    //
    // Verify we're running a checked AFD.SYS.
    //

    if( !IsReferenceDebug ) {

        dprintf(
            "tref: this command only available with CHECKED or specially\n"
            "      built (with /DREFERENCE_DEBUG=1) AFD.SYS!\n"
            );

        return E_INVALIDARG;

    }

    //
    // Snag the address from the command line.
    //

    address = GetExpression (args);

    if( address == 0 ) {

        dprintf( "\nUsage: tref tpacket_info_address\n" );
        return E_INVALIDARG;

    }

    if (GetFieldValue (address,
             "AFD!AFD_TPACKETS_INFO_INTERNAL",
             "CurrentReferenceSlot",
             idx)!=0) {

        dprintf("\ntref: Could not read CurrentReferenceSlot for tpInfo %p\n",
                  address );
        return E_INVALIDARG;
    }


    if (SavedMinorVersion>=3554) {
        ULONG   timeHigh;
        if (GetFieldValue (address,
                 "AFD!AFD_TPACKETS_INFO_INTERNAL",
                 "CurrentTimeHigh",
                 timeHigh)!=0) {

            dprintf("\neref: Could not read CurrentTimeHigh for tpInfo %p\n",
                      address );
            return E_INVALIDARG;
        }
        DumpAfdReferenceDebug(
            address+TPackRefOffset, (ULONGLONG)idx+((ULONGLONG)timeHigh<<32)
        );
    }
    else {
        DumpAfdReferenceDebug(
            address+TPackRefOffset, idx
        );
    }

    return S_OK;
}   // tref


DECLARE_API( gref )

/*++

Routine Description:

    Dumps the AFD_GLOBAL_REFERENCE_DEBUG structure in the system.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if GLOBAL_REFERENCE_DEBUG

    ULONG64 address;
    DWORD currentSlot;
    DWORD slot;
    ULONG result;
    ULONG64 compareAddress = 0;
    DWORD numEntries;
    DWORD maxEntries;
    DWORD entriesToRead;
    CHAR buffer[sizeof(AFD_GLOBAL_REFERENCE_DEBUG) * 64];

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    //
    // Verify we're running a checked AFD.SYS.
    //

    if( !IsCheckedAfd ) {

        dprintf(
            "gref: this command only available with CHECKED AFD.SYS!\n"
            );

        return E_INVALIDARG;

    }

    //
    // Snag the optional "connection compare" address from the command line.
    //

    sscanf( args, "%lx", &compareAddress );

    //
    // Find the global reference data.
    //

    address = GetExpression( "afd!AfdGlobalReference" );

    if( address == 0 ) {

        dprintf( "cannot find afd!AfdGlobalReference\n" );
        return E_INVALIDARG;

    }

    currentSlot = GetExpression( "afd!AfdGlobalReferenceSlot" );

    if( currentSlot == 0 ) {

        dprintf( "cannot find afd!AfdGlobalReferenceSlot\n" );
        return E_INVALIDARG;

    }

    if( !ReadMemory(
            currentSlot,
            &currentSlot,
            sizeof(currentSlot),
            &result
            ) ) {

        dprintf( "cannot read afd!AfdGlobalReferenceSlot\n" );
        return E_INVALIDARG;

    }

    if( currentSlot < MAX_GLOBAL_REFERENCE ) {

        numEntries = currentSlot;

    } else {

        numEntries = MAX_GLOBAL_REFERENCE;

    }

    //
    // Dump it all.
    //

    slot = 0;
    maxEntries = sizeof(buffer) / sizeof(AFD_GLOBAL_REFERENCE_DEBUG);
    currentSlot %= MAX_GLOBAL_REFERENCE;

    while( numEntries > 0 ) {

        entriesToRead = min( numEntries, maxEntries );

        if (CheckControlC ())
            break;

        if( !ReadMemory(
                address,
                buffer,
                entriesToRead * sizeof(AFD_GLOBAL_REFERENCE_DEBUG),
                &result
                ) ) {

            dprintf(
                "gref: cannot read AFD_GLOBAL_REFERENCE_DEBUG @ %p\n",
                address
                );

            return;

        }

        if( DumpAfdGlobalReferenceDebug(
                (PAFD_GLOBAL_REFERENCE_DEBUG)buffer,
                address,
                currentSlot,
                slot,
                entriesToRead,
                compareAddress
                ) ) {

            break;

        }

        address += entriesToRead * sizeof(AFD_GLOBAL_REFERENCE_DEBUG);
        slot += entriesToRead;
        numEntries -= entriesToRead;

    }
    
    return S_OK;

#else

    dprintf(
        "gref: not yet implemented\n"
        );

    return E_INVALIDARG;

#endif

}   // gref
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\proc.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    proc.h

Abstract:

    Global procedure declarations for the AFD.SYS Kernel Debugger
    Extensions.

Author:

    Keith Moore (keithmo) 19-Apr-1995.

Environment:

    User Mode.

--*/


#ifndef _PROC_H_
#define _PROC_H_


//
//  Functions from AFDUTIL.C.
//

VOID
DumpAfdEndpoint(
    ULONG64 ActualAddress
    );

VOID
DumpAfdEndpointBrief(
    ULONG64 ActualAddress
    );

VOID
DumpAfdConnection(
    ULONG64 ActualAddress
    );

VOID
DumpAfdConnectionBrief(
    ULONG64 ActualAddress
    );

VOID
DumpAfdReferenceDebug(
    ULONG64  ActualAddress,
    LONGLONG Idx
    );


#if GLOBAL_REFERENCE_DEBUG
BOOL
DumpAfdGlobalReferenceDebug(
    PAFD_GLOBAL_REFERENCE_DEBUG ReferenceDebug,
    ULONG64 ActualAddress,
    DWORD CurrentSlot,
    DWORD StartingSlot,
    DWORD NumEntries,
    ULONG64 CompareAddress
    );
#endif

VOID
DumpAfdTransmitInfo(
    ULONG64 ActualAddress
    );

VOID
DumpAfdTransmitInfoBrief (
    ULONG64 ActualAddress
    );

VOID
DumpAfdTPacketsInfo(
    ULONG64 ActualAddress
    );

VOID
DumpAfdTPacketsInfoBrief (
    ULONG64 ActualAddress
    );

VOID
DumpAfdBuffer(
    ULONG64 ActualAddress
    );

VOID
DumpAfdBufferBrief(
    ULONG64 ActualAddress
    );

VOID
DumpAfdPollInfo (
    ULONG64 ActualAddress
    );

VOID
DumpAfdPollInfoBrief (
    ULONG64 ActualAddress
    );

PAFDKD_TRANSPORT_INFO
ReadTransportInfo (
    ULONG64   ActualAddress
    );

VOID
DumpTransportInfo (
    PAFDKD_TRANSPORT_INFO TransportInfo
    );

VOID
DumpTransportInfoBrief (
    PAFDKD_TRANSPORT_INFO TransportInfo
    );

ULONG
GetRemoteAddressFromContext (
    ULONG64             EndpAddr,
    PVOID               AddressBuffer,
    SIZE_T              AddressBufferLength,
    ULONG64             *ContextAddr
    );

PSTR
ListToString (
    ULONG64 ListHead
    );
#define LIST_TO_STRING(_h)   ListToString(_h)
INT
CountListEntries (
    ULONG64 ListHeadAddress
    );

PSTR
ListCountEstimate (
    ULONG64 ListHeadAddress
    );

//
// Function from help.c
//

PCHAR
ProcessOptions (
    IN  PCHAR Args
    );

//
//  Functions from DBGUTIL.C.
//

PSTR
LongLongToString(
    LONGLONG Value
    );


//
//  Functions from ENUMENDP.C.
//

VOID
EnumEndpoints(
    PENUM_ENDPOINTS_CALLBACK Callback,
    ULONG64 Context
    );



//
//  Functions from TDIUTIL.C.
//

VOID
DumpTransportAddress(
    PCHAR Prefix,
    PTRANSPORT_ADDRESS Address,
    ULONG64 ActualAddress
    );

LPSTR
TransportAddressToString(
    PTRANSPORT_ADDRESS Address,
    ULONG64            ActualAddress
    );

LPSTR
TransportPortToString(
    PTRANSPORT_ADDRESS Address,
    ULONG64            ActualAddress
    );


//
//  Functions from AFDS.C.
//
BOOLEAN
CheckConditional (
    ULONG64 Address,
    PCHAR   Type
    );

VOID
ProcessFieldOutput (
    ULONG64 Address,
    PCHAR   Type
    );


//
//  Functions from TCP.C.
//
ULONG
GetRemoteAddressFromTcp (
    ULONG64             FoAddress,
    PVOID               AddressBuffer,
    SIZE_T              AddressBufferLength
    );

//
//  Functions from KDEXTS.CPP.
//
BOOLEAN
CheckKmGlobals (
    );


HRESULT
GetExpressionFromType (
    IN  ULONG64 Address,
    IN  PCHAR   Type,
    IN  PCHAR   Expression,
    IN  ULONG   OutType,
    OUT PDEBUG_VALUE Value
    );

#endif  // _PROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\poll.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    poll.c

Abstract:

    Implements the poll command

Author:

    Vadim Eydelman (vadime) 25-Oct-2000

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop


//
//  Private prototypes.
//

//
//  Public functions.
//

DECLARE_API( poll )

/*++

Routine Description:

    Dumps the AFD_POLL_INFO_INTERNAL structure 

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG   result;
    INT     i;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];
    PCHAR   argp;
    ULONG64 address;

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;

    if (argp[0]==0) {
        LIST_ENTRY64 listEntry;
        ULONG64 nextEntry;
        ULONG64 listHead;

        dprintf (AFDKD_BRIEF_POLL_DISPLAY_HEADER);
        
        listHead = GetExpression( "afd!AfdPollListHead" );
        if( listHead == 0 ) {
            dprintf( "\npoll: Could not find afd!AfdPollListHead\n" );
            return E_INVALIDARG;
        }

        if( !ReadListEntry(
                listHead,
                &listEntry) ) {
            dprintf(
                "\npoll: Could not read afd!AfdPollListHead @ %p\n",
                listHead
                );
            return E_INVALIDARG;
        }
        nextEntry = listEntry.Flink;
        address = listHead;
        while( nextEntry != listHead ) {
            if (nextEntry==0) {
                dprintf ("\npoll: Flink is NULL, last poll: %p\n", address);
                break;
            }

            if( CheckControlC() ) {
                break;
            }

            address = nextEntry;
            result = (ULONG)InitTypeRead (address, AFD!AFD_POLL_INFO_INTERNAL);
            if( result!=0) {
                dprintf(
                    "\npoll: Could not read AFD_POLL_INFO_INTERNAL @ %p, err: %d\n",
                    address, result
                    );
                return E_INVALIDARG;
            }
            nextEntry = ReadField (PollListEntry.Flink);

            if (!(Options & AFDKD_CONDITIONAL) ||
                        CheckConditional (address, "AFD!AFD_POLL_INFO_INTERNAL") ) {
                if (Options & AFDKD_BRIEF_DISPLAY) {
                    DumpAfdPollInfoBrief (address);
                }
                else {
                    DumpAfdPollInfo (address);
                }
                if (Options & AFDKD_FIELD_DISPLAY) {
                    ProcessFieldOutput (address, "AFD!AFD_POLL_INFO_INTERNAL");
                }
            }
            else
                dprintf (".");
        }
        dprintf (AFDKD_BRIEF_POLL_DISPLAY_TRAILER);
    }
    else {
        //
        // Snag the address from the command line.
        //

        while (sscanf( argp, "%s%n", expr, &i )==1) {
            if( CheckControlC() ) {
                break;
            }
            argp += i;
            address = GetExpression (expr);

            result = (ULONG)InitTypeRead (address, AFD!AFD_POLL_INFO_INTERNAL);
            if (result!=0) {
                dprintf ("\npoll: Could not read AFD_POLL_INFO_INTERNAL @ %p, err: %d\n",
                    address, result);
                break;
            }

            if (Options & AFDKD_BRIEF_DISPLAY) {
                DumpAfdPollInfoBrief (address);
            }
            else {
                DumpAfdPollInfo (address);
            }
            if (Options & AFDKD_FIELD_DISPLAY) {
                ProcessFieldOutput (address, "AFD!AFD_POLL_INFO_INTERNAL");
            }
        }
        dprintf ("\n");
    }

    return S_OK;
}   // poll
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\stats.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    stats.c

Abstract:

    Implements the stats command.

Author:

    Keith Moore (keithmo) 06-May-1996

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop


//
//  Public functions.
//

DECLARE_API( stats )

/*++

Routine Description:

    Dumps the debug-only AFD statistic counters.

Arguments:

    None.

Return Value:

    None.

--*/

{
    AFD_QUOTA_STATS quotaStats;
    AFD_HANDLE_STATS handleStats;
    AFD_QUEUE_STATS queueStats;
    AFD_CONNECTION_STATS connectionStats;
    ULONG64 address;
    ULONG result;

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    //
    // Dump the quota statistics.
    //

    address = GetExpression( "afd!AfdQuotaStats" );

    if( address == 0 ) {

        dprintf( "\nstats: Could not find afd!AfdQuotaStats\n" );

    } else {

        if( ReadMemory(
                address,
                &quotaStats,
                sizeof(quotaStats),
                &result
                ) ) {

            dprintf(
                "AfdQuotaStats:\n"
                );

            dprintf(
                "    Charged  = %I64x\n",
                quotaStats.Charged.QuadPart
                );

            dprintf(
                "    Returned = %I64x\n",
                quotaStats.Returned.QuadPart
                );

            dprintf( "\n" );

        } else {

            dprintf(
                "\nstats: Could not read afd!AfdQuotaStats @ %p\n",
                address
                );

        }

    }

    //
    // Dump the handle statistics.
    //

    address = GetExpression( "afd!AfdHandleStats" );

    if( address == 0 ) {

        dprintf( "stats: Could not find afd!AfdHandleStats\n" );

    } else {

        if( ReadMemory(
                address,
                &handleStats,
                sizeof(handleStats),
                &result
                ) ) {

            dprintf(
                "AfdHandleStats:\n"
                );

            dprintf(
                "    AddrOpened = %lu\n",
                handleStats.AddrOpened
                );

            dprintf(
                "    AddrClosed = %lu\n",
                handleStats.AddrClosed
                );

            dprintf(
                "    AddrRef    = %lu\n",
                handleStats.AddrRef
                );

            dprintf(
                "    AddrDeref  = %lu\n",
                handleStats.AddrDeref
                );

            dprintf(
                "    ConnOpened = %lu\n",
                handleStats.ConnOpened
                );

            dprintf(
                "    ConnClosed = %lu\n",
                handleStats.ConnClosed
                );

            dprintf(
                "    ConnRef    = %lu\n",
                handleStats.ConnRef
                );

            dprintf(
                "    ConnDeref  = %lu\n",
                handleStats.ConnDeref
                );

            dprintf(
                "    FileRef    = %lu\n",
                handleStats.FileRef
                );

            dprintf(
                "    FileDeref  = %lu\n",
                handleStats.FileDeref
                );

            dprintf( "\n" );

        } else {

            dprintf(
                "\nstats: Could not read afd!AfdHandleStats @ %p\n",
                address
                );

        }

    }

    //
    // Dump the queue statistics.
    //

    address = GetExpression( "afd!AfdQueueStats" );

    if( address == 0 ) {

        dprintf( "stats: Could not find afd!AfdQueueStats\n" );

    } else {

        if( ReadMemory(
                address,
                &queueStats,
                sizeof(queueStats),
                &result
                ) ) {

            dprintf(
                "AfdQueueStats:\n"
                );

            dprintf(
                "    AfdWorkItemsQueued    = %lu\n",
                queueStats.AfdWorkItemsQueued
                );

            dprintf(
                "    ExWorkItemsQueued     = %lu\n",
                queueStats.ExWorkItemsQueued
                );

            dprintf(
                "    WorkerEnter           = %lu\n",
                queueStats.WorkerEnter
                );

            dprintf(
                "    WorkerLeave           = %lu\n",
                queueStats.WorkerLeave
                );

            dprintf(
                "    AfdWorkItemsProcessed = %lu\n",
                queueStats.AfdWorkItemsProcessed
                );

            dprintf(
                "    AfdWorkerThread       = %p\n",
                (ULONG64)queueStats.AfdWorkerThread
                );

            dprintf( "\n" );

        } else {

            dprintf(
                "\nstats: Could not read afd!AfdQueueStats @ %p\n",
                address
                );

        }

    }

    //
    // Dump the queue statistics.
    //

    address = GetExpression( "afd!AfdConnectionStats" );

    if( address == 0 ) {

        dprintf( "\nstats: Could not find afd!AfdConnectionStats\n" );

    } else {

        if( ReadMemory(
                address,
                &connectionStats,
                sizeof(connectionStats),
                &result
                ) ) {

            dprintf(
                "AfdConnectionStats:\n"
                );

            dprintf(
                "    ConnectedReferencesAdded      = %lu\n",
                connectionStats.ConnectedReferencesAdded
                );

            dprintf(
                "    ConnectedReferencesDeleted    = %lu\n",
                connectionStats.ConnectedReferencesDeleted
                );

            dprintf(
                "    GracefulDisconnectsInitiated  = %lu\n",
                connectionStats.GracefulDisconnectsInitiated
                );

            dprintf(
                "    GracefulDisconnectsCompleted  = %lu\n",
                connectionStats.GracefulDisconnectsCompleted
                );

            dprintf(
                "    GracefulDisconnectIndications = %lu\n",
                connectionStats.GracefulDisconnectIndications
                );

            dprintf(
                "    AbortiveDisconnectsInitiated  = %lu\n",
                connectionStats.AbortiveDisconnectsInitiated
                );

            dprintf(
                "    AbortiveDisconnectsCompleted  = %lu\n",
                connectionStats.AbortiveDisconnectsCompleted
                );

            dprintf(
                "    AbortiveDisconnectIndications = %lu\n",
                connectionStats.AbortiveDisconnectIndications
                );

            dprintf(
                "    ConnectionIndications         = %lu\n",
                connectionStats.ConnectionIndications
                );

            dprintf(
                "    ConnectionsDropped            = %lu\n",
                connectionStats.ConnectionsDropped
                );

            dprintf(
                "    ConnectionsAccepted           = %lu\n",
                connectionStats.ConnectionsAccepted
                );

            dprintf(
                "    ConnectionsPreaccepted        = %lu\n",
                connectionStats.ConnectionsPreaccepted
                );

            dprintf(
                "    ConnectionsReused             = %lu\n",
                connectionStats.ConnectionsReused
                );


            dprintf(
                "    EndpointsReused               = %lu\n",
                connectionStats.EndpointsReused
                );


            dprintf( "\n" );

        } else {

            dprintf(
                "\nstats: Could not read afd!AfdConnectionStats @ %p\n",
                address
                );

        }

    }

    return S_OK;
}   // stats
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\tcp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    afds.c

Abstract:

    Implements tcpip commands

Author:

    Vadim Eydelman, October 2001

Environment:

    User Mode.

Revision History:

--*/
#include "afdkdp.h"
#pragma hdrstop

VOID
DumpTCBBrief (
    ULONG64 Address
    );
VOID
DumpSynTCBBrief (
    ULONG64 Address
    );
VOID
DumpTWTCBBrief (
    ULONG64 Address
    );

ULONG
TCBListCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    );
ULONG
SynTCBListCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    );
ULONG
TWTCBQueueCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    );

LONG64  TCBTable,SynTCBTable,TWQueue;
ULONG   TCBTableSize, TCBTablePartitions;
USHORT   TWTCBDelta;
ULONG   SynTCBListLinkOffset, TWTCBQueueLinkOffset;

DECLARE_API (tcb)
/*++

Routine Description:

    Dump TCP/IP TCB.

Arguments:

    None.

Return Value:

    None.

--*/
{   
    ULONG   result,i;
    PCHAR   argp;
    LONG64  address;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];

    gClient = pClient;

    if (!CheckKmGlobals (
        )) {
        return E_INVALIDARG;
    }

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;
    Options |= AFDKD_BRIEF_DISPLAY;
    
    dprintf (AFDKD_BRIEF_TCB_DISPLAY_HEADER);

    if (argp[0]==0) {
        union {
            struct {
                LONG64 next;
                LONG64 prev;
            }       *q64;
            struct {
                LONG32 next;
                LONG32 prev;
            }       *q32;
            LONG64  *p64;
            LONG32  *p32;
        } table;
        ULONG64   count;
        ULONG     size;

        result = GetFieldValue (0, "TCPIP!MaxHashTableSize", NULL, count);
        if (result!=0) {
            if (TCBTableSize==0) {
                dprintf ("\ntcb: Could not read TCPIP!MaxHashTableSize, err: %ld\n", result);
                return E_INVALIDARG;
            }
        }
        else if (count==0) {
            dprintf ("\ntcb: TCPIP!MaxHashTableSize is 0!!!\n");
            return E_INVALIDARG;
        }
        else {
            TCBTableSize = (ULONG)count;
        }

        if (Options & AFDKD_SYNTCB_DISPLAY) {
            result = GetFieldValue (0, "TCPIP!SYNTCBTable", NULL, address);
            if (result!=0) {
                if (SynTCBTable==0) {
                    dprintf ("\ntcb: Could not read TCPIP!SYNTCBTable, err: %ld\n", result);
                    return E_INVALIDARG;
                }
            }
            else if (address==0) {
                dprintf ("\ntcb: TCPIP!SYNTCBTable is NULL!!!\n");
                return E_INVALIDARG;
            }
            else
                SynTCBTable = address;

            size = (IsPtr64 () 
                        ? sizeof(table.q64[0])
                        : sizeof (table.q32[0]))*TCBTableSize;

            table.p64 = RtlAllocateHeap (RtlProcessHeap (), 0, size);
            if (table.p64==NULL) {
                dprintf ("\ntcb: Failed to allocate SYNTCBTable, size: %ld\n", size);
                return E_INVALIDARG;
            }


            if (!ReadMemory (SynTCBTable, table.p64, size, &result)) {
                RtlFreeHeap (RtlProcessHeap (), 0, table.p64);
                dprintf ("\ntcb: Failed to read TCPIP!SYNTCBTable\n");
                return E_INVALIDARG;
            }

            result = GetFieldOffset ("TCPIP!SYNTCB", "syntcb_link", &SynTCBListLinkOffset);
            if (result!=0) {
                RtlFreeHeap (RtlProcessHeap (), 0, table.p64);
                dprintf ("\ntcb: Failed to get syntcb_link offset in TCPIP!SYNTCB, err: %ld\n", result);
                return E_INVALIDARG;
            }
            for (i=0; i<TCBTableSize; i++) {
                LONG64  address2 = SynTCBTable+i*(IsPtr64() 
                                                ? sizeof(table.q64[i]) 
                                                : sizeof(table.q32[i]));
                if( CheckControlC() ) {
                    break;
                }
                address = IsPtr64() ? table.q64[i].next : table.q32[i].next;
                if (address!=address2) {
                    ListType (
                        "TCPIP!Queue",              // Type
                        address,                    // Address
                        0,                          // ListByFieldAddress
                        "q_next",                   // NextPointer
                        &address2,                  // Context
                        SynTCBListCallback);
                }
            }
        }
        else if (Options & AFDKD_TWTCB_DISPLAY) {
            result = GetFieldValue (0, "TCPIP!NumTcbTablePartitions", NULL, count);
            if (result!=0) {
                if (TCBTablePartitions==0) {
                    dprintf ("\ntcb: Could not read TCPIP!NumTcbTablePartitions, err: %ld\n", result);
                    return E_INVALIDARG;
                }
            }
            else if (count==0) {
                dprintf ("\ntcb: TCPIP!NumTcbTablePartitions is 0!!!\n");
                return E_INVALIDARG;
            }
            else {
                TCBTablePartitions = (ULONG)count;
            }

            result = GetFieldValue (0, "TCPIP!TWQueue", NULL, address);
            if (result!=0) {
                if (TWQueue==0) {
                    dprintf ("\ntcb: Could not read TCPIP!TWQueue, err: %ld\n", result);
                    return E_INVALIDARG;
                }
            }
            else if (address==0) {
                dprintf ("\ntcb: TCPIP!TWQueue is NULL!!!\n");
                return E_INVALIDARG;
            }
            else
                TWQueue = address;

            size = (IsPtr64 () 
                        ? sizeof(table.q64[0])
                        : sizeof(table.q32[0])) * TCBTablePartitions;

            table.p64 = RtlAllocateHeap (RtlProcessHeap (), 0, size);
            if (table.p64==NULL) {
                dprintf ("\ntcb: Failed to allocate TWQueue, size: %ld\n", size);
                return E_INVALIDARG;
            }

            if (!ReadMemory (TWQueue, table.p64, size, &result)) {
                RtlFreeHeap (RtlProcessHeap (), 0, table.p64);
                dprintf ("\ntcb: Failed to read TCPIP!TWQueue\n");
                return E_INVALIDARG;
            }

            result = GetFieldOffset ("TCPIP!TWTCB", "twtcb_TWQueue", &TWTCBQueueLinkOffset);
            if (result!=0) {
                RtlFreeHeap (RtlProcessHeap (), 0, table.p64);
                dprintf ("\ntcb: Failed to get twtcb_TWQueue offset in TCPIP!TWTCB, err: %ld\n", result);
                return E_INVALIDARG;
            }
            for (i=0; i<TCBTablePartitions; i++) {
                LONG64  address2 = TWQueue+i*(IsPtr64() 
                                                ? sizeof(table.q64[i]) 
                                                : sizeof(table.q32[i]));
                if( CheckControlC() ) {
                    break;
                }
                address = IsPtr64() ? table.q64[i].next : table.q32[i].next;
                if (address!=address2 ) {
                    TWTCBDelta = 0;
                    ListType (
                        "TCPIP!Queue",              // Type
                        address,                    // Address
                        0,                          // ListByFieldAddress
                        "q_next",                   // NextPointer
                        &address2,                  // Context
                        TWTCBQueueCallback);
                }
            }
        }
        else {
            result = GetFieldValue (0, "TCPIP!TCBTable", NULL, address);
            if (result!=0) {
                if (TCBTable==0) {
                    dprintf ("\ntcb: Could not read TCPIP!TCBTable, err: %ld\n", result);
                    return E_INVALIDARG;
                }
            }
            else if (address==0) {
                dprintf ("\ntcb: TCPIP!TCBTable is NULL!!!\n");
                return E_INVALIDARG;
            }
            else
                TCBTable = address;

            size = (IsPtr64 () 
                        ? sizeof(table.p64[0])
                        : sizeof(table.p32[0]))*TCBTableSize;

            table.p64 = RtlAllocateHeap (RtlProcessHeap (), 0, size);
            if (table.p64==NULL) {
                dprintf ("\ntcb: Failed to allocate SYNTCBTable, size: %ld\n", size);
                return E_INVALIDARG;
            }

            if (!ReadMemory (TCBTable, table.p64, size, &result)) {
                RtlFreeHeap (RtlProcessHeap (), 0, table.p64);
                dprintf ("\ntcb: Failed to read TCPIP!TCBTable\n");
                return E_INVALIDARG;
            }

            for (i=0; i<TCBTableSize; i++) {
                if( CheckControlC() ) {
                    break;
                }
                address = IsPtr64() ? table.p64[i] : table.p32[i];
                if (address!=0) {
                    ListType (
                        "TCPIP!TCB",                // Type
                        address,                    // Address
                        0,                          // ListByFieldAddress
                        "tcb_next",                 // NextPointer
                        argp,                       // Context
                        TCBListCallback);
                }
            }
        }
        RtlFreeHeap (RtlProcessHeap (), 0, table.p64);
    }
    else {

        //
        // Snag the address from the command line.
        //
        while (sscanf( argp, "%s%n", expr, &i )==1) {
            if( CheckControlC() ) {
                break;
            }

            argp+=i;
            address = GetExpression (expr);

            result = (ULONG)InitTypeRead (address, TCPIP!TCB);
            if (result!=0) {
                dprintf ("\nendp: Could not read TCB @ %p, err: %d\n",
                    address, result);
                break;
            }

            DumpTCBBrief (address);
            if (Options & AFDKD_FIELD_DISPLAY) {
                ProcessFieldOutput (address, "TCPIP!TCB");
            }
        }

    }

    dprintf (AFDKD_BRIEF_TCB_DISPLAY_TRAILER);

    return S_OK;
}

ULONG
TCBListCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    )
{
    ULONG result;

    if (pField->address==0)
        return 1;

    if (!(Options & AFDKD_CONDITIONAL) ||
            CheckConditional (pField->address, "TCPIP!TCB")) {
        result = (ULONG)InitTypeRead (pField->address, TCPIP!TCB);
        if (result!=0) {
            dprintf ("\nTCBListCallback: Could not read TCPIP!TCB @ %p, err: %d\n",
                pField->address, result);
        }
        DumpTCBBrief (pField->address);
        if (Options & AFDKD_FIELD_DISPLAY) {
            ProcessFieldOutput (pField->address, "TCPIP!TCB");
        }
    }
    else {
        dprintf (".");
    }
    return 0;
}

ULONG
SynTCBListCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    )
{
    ULONG result;
    ULONG64 address;

    if (pField->address==0)
        return 1;
    else if (pField->address==*(LONG64 *)UserContext)
        return 1;

    address = pField->address-SynTCBListLinkOffset;

    if (!(Options & AFDKD_CONDITIONAL) ||
            CheckConditional (address, "TCPIP!SYNTCB")) {
        result = (ULONG)InitTypeRead (address, TCPIP!SYNTCB);
        if (result!=0) {
            dprintf ("\nSynTCBListCallback: Could not read TCPIP!SYNTCB @ %p, err: %d\n",
                address, result);
        }
        DumpSynTCBBrief (address);
        if (Options & AFDKD_FIELD_DISPLAY) {
            ProcessFieldOutput (pField->address, "TCPIP!SYNTCB");
        }
    }
    else {
        dprintf (".");
    }
    return 0;
}

ULONG
TWTCBQueueCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    )
{
    ULONG result;
    ULONG64 address;
    ULONG64 delta;

    if (pField->address==0)
        return 1;
    else if (pField->address==*(LONG64 *)UserContext)
        return 1;

    address = pField->address-TWTCBQueueLinkOffset;
    result = GetFieldValue (address, "TCPIP!TWTCB", "twtcb_rexmittimer", delta);
    if (result!=0) {
        dprintf ("\nTWTCBQueueCallback: Could not read twtcb_rexmittimer of TCPIP!TWTCB @ %p, err: %d\n",
            address, result);
        return 1;
    }
    TWTCBDelta += (USHORT)delta;

    if (!(Options & AFDKD_CONDITIONAL) ||
            CheckConditional (address, "TCPIP!TWTCB")) {
        result = (ULONG)InitTypeRead (address, TCPIP!TWTCB);
        if (result!=0) {
            dprintf ("\nTCBListCallback: Could not read TCPIP!TWTCB @ %p, err: %d\n",
                    address, result);
            return 1;
        }
        DumpTWTCBBrief (address);
        if (Options & AFDKD_FIELD_DISPLAY) {
            ProcessFieldOutput (address, "TCPIP!TWTCB");
        }
    }
    else {
        dprintf (".");
    }
    return 0;
}

CHAR    *TCBStateStrings [] = {
    "Cd",
    "Li",
    "SS",
    "SR",
    "Es",
    "F1",
    "F2",
    "CW",
    "Ci",
    "LA",
    "TW"
};
#define MAX_TCB_STATE (sizeof(TCBStateStrings)/sizeof (TCBStateStrings[0]))

VOID
DumpTCBBrief (
    ULONG64 Address
    )
{
    TA_IP_ADDRESS   address;
    CHAR            src[MAX_ADDRESS_STRING], dst[MAX_ADDRESS_STRING];
    CHAR            symbol[MAX_FIELD_CHARS];
    ULONG64         offset;
    UCHAR           state;
    ULONG           flags;
    ULONG64         conn,pid,ctx;

    state = (UCHAR)ReadField (tcb_state);
    flags = (ULONG)ReadField(tcb_flags);
    GetSymbol (ReadField (tcb_rcvind), symbol, &offset);
    address.TAAddressCount = 1;
    address.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP; 
    address.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    address.Address[0].Address[0].in_addr = (ULONG)ReadField (tcb_saddr);
    address.Address[0].Address[0].sin_port = (USHORT)ReadField (tcb_sport);
    strncpy (src, TransportAddressToString ((PTRANSPORT_ADDRESS)&address, 0), sizeof (src)-1);
    src[sizeof(src)-1] = 0;

    address.Address[0].Address[0].in_addr = (ULONG)ReadField (tcb_daddr);
    address.Address[0].Address[0].sin_port = (USHORT)ReadField (tcb_dport);
    strncpy (dst, TransportAddressToString ((PTRANSPORT_ADDRESS)&address, 0), sizeof (dst)-1);
    dst[sizeof(dst)-1] = 0;
    ctx = ReadField (tcb_conncontext);
    if (SavedMinorVersion>=2219) {
        if (GetFieldValue (Address, "TCPIP!TCB", "tcb_conn", conn)!=0 ||
                GetFieldValue (conn, "TCPIP!TCPConn", "tc_owningpid", pid)!=0) {
            pid = 0;
        }
    }
    else {
        pid = 0;
    }

    /*           TCB       State  Flags Client ConnCtx   PID   Src Addr Dst Addr*/
    dprintf (
        IsPtr64 ()
            ? "\n%011.011p %-2.2s %8.8x %-6.8s %011.011p %4.4x %-19s %-s"
            : "\n%008.008p %-2.2s %8.8x %-6.8s %008.008p %4.4x %-19s %-s",
            DISP_PTR (Address),
            state<MAX_TCB_STATE ? TCBStateStrings[state] : "??",
            flags,
            strtok (symbol, "!"),
            DISP_PTR(ctx),
            (ULONG)pid,
            src,
            dst);

}

VOID
DumpSynTCBBrief (
    ULONG64 Address
    )
{
    TA_IP_ADDRESS   address;
    CHAR            src[MAX_ADDRESS_STRING], dst[MAX_ADDRESS_STRING];
    UCHAR           state;
    ULONG           flags;

    state = (UCHAR)ReadField (syntcb_state);
    flags = (ULONG)ReadField(syntcb_flags);
    address.TAAddressCount = 1;
    address.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP; 
    address.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    address.Address[0].Address[0].in_addr = (ULONG)ReadField (syntcb_saddr);
    address.Address[0].Address[0].sin_port = (USHORT)ReadField (syntcb_sport);
    strncpy (src, TransportAddressToString ((PTRANSPORT_ADDRESS)&address, 0), sizeof (src)-1);
    src[sizeof(src)-1] = 0;

    address.Address[0].Address[0].in_addr = (ULONG)ReadField (syntcb_daddr);
    address.Address[0].Address[0].sin_port = (USHORT)ReadField (syntcb_dport);
    strncpy (dst, TransportAddressToString ((PTRANSPORT_ADDRESS)&address, 0), sizeof (dst)-1);
    dst[sizeof(dst)-1] = 0;

    /*           TCB       State  Flags Client ConnCtx  PID  Src Addr Dst Addr*/
    dprintf (
        IsPtr64 ()
            ? "\n%011.011p %-2.2s %8.8x                         %-19s %-s"
            : "\n%008.008p %-2.2s %8.8x                      %-19s %-s",
            DISP_PTR (Address),
            state<MAX_TCB_STATE ? TCBStateStrings[state] : "??",
            flags,
            src,
            dst);

}

VOID
DumpTWTCBBrief (
    ULONG64 Address
    )
{
    TA_IP_ADDRESS   address;
    CHAR            src[MAX_ADDRESS_STRING], dst[MAX_ADDRESS_STRING];

    address.TAAddressCount = 1;
    address.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP; 
    address.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    address.Address[0].Address[0].in_addr = (ULONG)ReadField (twtcb_saddr);
    address.Address[0].Address[0].sin_port = (USHORT)ReadField (twtcb_sport);
    strncpy (src, TransportAddressToString ((PTRANSPORT_ADDRESS)&address, 0), sizeof (src)-1);
    src[sizeof(src)-1] = 0;

    address.Address[0].Address[0].in_addr = (ULONG)ReadField (twtcb_daddr);
    address.Address[0].Address[0].sin_port = (USHORT)ReadField (twtcb_dport);
    strncpy (dst, TransportAddressToString ((PTRANSPORT_ADDRESS)&address, 0), sizeof (dst)-1);
    dst[sizeof(dst)-1] = 0;

    /*           TCB       St Flags    Client ConnCtx  PID  Src Addr Dst Addr*/
    dprintf (
        IsPtr64 ()
            ? "\n%011.011p TW expires in %5d ticks           %-19s %-s"
            : "\n%008.008p TW expires in %5d ticks        %-19s %-s",
            DISP_PTR (Address),
            TWTCBDelta,
            src,
            dst);

}

VOID
DumpTCB6Brief (
    ULONG64 Address
    );

ULONG
TCB6ListCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    );

ULONG64 TCB6Table;
ULONG   TCB6TableSize;

DECLARE_API (tcb6)
/*++

Routine Description:

    Dump TCP/IP TCB.

Arguments:

    None.

Return Value:

    None.

--*/
{   
    ULONG   result,i;
    PCHAR   argp;
    ULONG64 address;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;
    Options |= AFDKD_BRIEF_DISPLAY;

    dprintf (AFDKD_BRIEF_TCB6_DISPLAY_HEADER);
    if (argp[0]==0) {
        union {
            ULONG64 *p64;
            ULONG   *p32;
        } table;
        ULONG64   count;
        ULONG     size;

        result = GetFieldValue (0, "TCPIP6!TCBTable", NULL, address);
        if (result!=0) {
            if (TCB6Table==0) {
                dprintf ("\ntcb6: Could not read TCPIP6!TCBTable, err: %ld\n", result);
                return E_INVALIDARG;
            }
        }
        else if (address==0) {
            dprintf ("\ntcb6: TCPIP6!TCBTable is NULL!!!\n");
            return E_INVALIDARG;
        }
        else
            TCB6Table = address;

        result = GetFieldValue (0, "TCPIP6!TcbTableSize", NULL, count);
        if (result!=0) {
            if (TCB6TableSize==0) {
                dprintf ("\ntcb6: Could not read TCPIP6!TcbTableSize, err: %ld\n", result);
                return E_INVALIDARG;
            }
        }
        else if (count==0) {
            dprintf ("\ntcb6: TCPIP6!TcbTableSize is 0!!!\n");
            return E_INVALIDARG;
        }
        else {
            TCB6TableSize = (ULONG)count;
        }

        size = (IsPtr64 () ? sizeof (ULONG64) : sizeof (ULONG))*TCB6TableSize;
        table.p64 = RtlAllocateHeap (RtlProcessHeap (), 0, size);
        if (table.p64==NULL) {
            dprintf ("\ntcb: Failed to allocate TCBTable, size: %ld\n", size);
            return E_INVALIDARG;
        }

        if (!ReadMemory (TCB6Table, table.p64, size, &result)) {
            RtlFreeHeap (RtlProcessHeap (), 0, table.p64);
            dprintf ("\ntcb: Failed to read TCBTable\n");
            return E_INVALIDARG;
        }

        for (i=0; i<TCB6TableSize; i++) {
            if( CheckControlC() ) {
                break;
            }
            address = IsPtr64() ? table.p64[i] : table.p32[i];
            if (address!=0) {
                ListType (
                    "TCPIP6!TCB",               // Type
                    address,                    // Address
                    0,                          // ListByFieldAddress
                    "tcb_next",                 // NextPointer
                    argp,                       // Context
                    TCB6ListCallback);
            }
        }
        RtlFreeHeap (RtlProcessHeap (), 0, table.p64);
    }
    else {

        //
        // Snag the address from the command line.
        //
        while (sscanf( argp, "%s%n", expr, &i )==1) {
            if( CheckControlC() ) {
                break;
            }

            argp+=i;
            address = GetExpression (expr);

            result = (ULONG)InitTypeRead (address, TCPIP6!TCB);
            if (result!=0) {
                dprintf ("\nendp: Could not read TCB @ %p, err: %d\n",
                    address, result);
                break;
            }

            DumpTCBBrief (address);
            if (Options & AFDKD_FIELD_DISPLAY) {
                ProcessFieldOutput (address, "TCPIP6!TCB");
            }
        }

    }

    dprintf (AFDKD_BRIEF_TCB6_DISPLAY_TRAILER);
    return S_OK;
}

ULONG
TCB6ListCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    )
{
    ULONG result;

    if (pField->address==0)
        return 0;

    if (!(Options & AFDKD_CONDITIONAL) ||
            CheckConditional (pField->address, "TCPIP6!TCB")) {
        result = (ULONG)InitTypeRead (pField->address, TCPIP6!TCB);
        if (result!=0) {
            dprintf ("\nTCBListCallback: Could not read TCB @ %p, err: %d\n",
                pField->address, result);
        }
        DumpTCB6Brief (pField->address);
        if (Options & AFDKD_FIELD_DISPLAY) {
            ProcessFieldOutput (pField->address, "TCPIP6!TCB");
        }
    }
    else {
        dprintf (".");
    }
    return 0;
}


VOID
DumpTCB6Brief (
    ULONG64 Address
    )
{
    TA_IP6_ADDRESS  address;
    CHAR            src[MAX_ADDRESS_STRING], dst[MAX_ADDRESS_STRING];
    CHAR            symbol[MAX_FIELD_CHARS];
    ULONG64         offset;
    UCHAR           state;
    ULONG           flags;
    ULONG64         conn,pid,ctx;

    state = (UCHAR)ReadField (tcb_state);
    flags = (ULONG)ReadField (tcb_flags);
    GetSymbol (ReadField (tcb_rcvind), symbol, &offset);
    address.TAAddressCount = 1;
    address.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP6; 
    address.Address[0].AddressType = TDI_ADDRESS_TYPE_IP6;
    GetFieldValue (Address, "TCPIP6!TCB", "tcb_saddr", address.Address[0].Address[0].sin6_addr);
    address.Address[0].Address[0].sin6_port = (USHORT)ReadField (tcb_sport);
    address.Address[0].Address[0].sin6_scope_id = (ULONG)ReadField(tcb_sscope_id);
    strncpy (src, TransportAddressToString ((PTRANSPORT_ADDRESS)&address, 0), sizeof (src)-1);
    src[sizeof(src)-1] = 0;

    GetFieldValue (Address, "TCPIP6!TCB", "tcb_daddr", address.Address[0].Address[0].sin6_addr);
    address.Address[0].Address[0].sin6_port = (USHORT)ReadField (tcb_dport);
    address.Address[0].Address[0].sin6_scope_id = (ULONG)ReadField(tcb_dscope_id);
    strncpy (dst, TransportAddressToString ((PTRANSPORT_ADDRESS)&address, 0), sizeof (dst)-1);
    dst[sizeof(dst)-1] = 0;
    ctx = ReadField (tcb_conncontext);
    if (SavedMinorVersion>=2471) {
        if (GetFieldValue (Address, "TCPIP6!TCB", "tcb_conn", conn)!=0 ||
                GetFieldValue (conn, "TCPIP6!TCPConn", "tc_owningpid", pid)!=0) {
            pid = 0;
        }
    }
    else {
        pid = 0;
    }

    /*           TCB       State  Flags Client ConnCtx   PID   Src Dst*/
    dprintf (
        IsPtr64 ()
            ? "\n%011.011p %-2.2s %8.8x %-6.8s %011.011p %4.4x %-s\n"
              "            %-s"
            : "\n%008.008p %-2.2s %8.8x %-6.8s %008.008p %4.4x %-s\n"
                 "         %-s",
            DISP_PTR (Address),
            state<MAX_TCB_STATE ? TCBStateStrings[state] : "??",
            flags,
            strtok (symbol, "!"),
            DISP_PTR(ctx),
            (ULONG)pid,
            src,
            dst);

}

VOID
DumpTAOBrief (
    ULONG64 Address
    );
ULONG
TAOListCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    );

ULONG64 AOTable;
ULONG   AOTableSize;
DECLARE_API (tao)
/*++

Routine Description:

    Dump TCP/IP Address Objects.

Arguments:

    None.

Return Value:

    None.

--*/
{   
    ULONG   result,i;
    PCHAR   argp;
    ULONG64 address;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;
    Options |= AFDKD_BRIEF_DISPLAY;

    dprintf (AFDKD_BRIEF_TAO_DISPLAY_HEADER);
    if (argp[0]==0) {
        union {
            ULONG64 *p64;
            ULONG   *p32;
        } table;
        ULONG64   count;
        ULONG     size;

        result = GetFieldValue (0, "TCPIP!AddrObjTable", NULL, address);
        if (result!=0) {
            if (AOTable==0) {
                dprintf ("\ntao: Could not read TCPIP!AddrObjTable, err: %ld\n", result);
                return E_INVALIDARG;
            }
        }
        else if (address==0) {
            dprintf ("\ntao: TCPIP!AddrObjTable is NULL!!!\n");
            return E_INVALIDARG;
        }
        else
            AOTable = address;

        result = GetFieldValue (0, "TCPIP!AddrObjTableSize", NULL, count);
        if (result!=0) {
            if (AOTableSize==0) {
                dprintf ("\ntao: Could not read TCPIP!AddrObjTableSize, err: %ld\n", result);
                return E_INVALIDARG;
            }
        }
        else if (count==0) {
            dprintf ("\ntao: TCPIP!AddrObjTableSize is 0!!!\n");
            return E_INVALIDARG;
        }
        else {
            AOTableSize = (ULONG)count;
        }

        size = (IsPtr64 () ? sizeof (ULONG64) : sizeof (ULONG))*AOTableSize;
        table.p64 = RtlAllocateHeap (RtlProcessHeap (), 0, size);
        if (table.p64==NULL) {
            dprintf ("\ntcb: Failed to allocate AOTable, size: %ld\n", size);
            return E_INVALIDARG;
        }

        if (!ReadMemory (AOTable, table.p64, size, &result)) {
            RtlFreeHeap (RtlProcessHeap (), 0, table.p64);
            dprintf ("\ntcb: Failed to read AOTable\n");
            return E_INVALIDARG;
        }

        for (i=0; i<AOTableSize; i++) {
            if( CheckControlC() ) {
                break;
            }
            address = IsPtr64() ? table.p64[i] : table.p32[i];
            if (address!=0) {
                ListType (
                    "TCPIP!AddrObj",            // Type
                    address,                    // Address
                    0,                          // ListByFieldAddress
                    "ao_next",                  // NextPointer
                    argp,                       // Context
                    TAOListCallback);
            }
        }
        RtlFreeHeap (RtlProcessHeap (), 0, table.p64);

    }
    else {
        //
        // Snag the address from the command line.
        //
        while (sscanf( argp, "%s%n", expr, &i )==1) {
            if( CheckControlC() ) {
                break;
            }

            argp+=i;
            address = GetExpression (expr);

            result = (ULONG)InitTypeRead (address, TCPIP!AddrObj);
            if (result!=0) {
                dprintf ("\ntao: Could not read AddrObj @ %p, err: %d\n",
                    address, result);
                break;
            }

            DumpTAOBrief (address);
            if (Options & AFDKD_FIELD_DISPLAY) {
                ProcessFieldOutput (address, "TCPIP!AddrObj");
            }

        }

    }

    dprintf (AFDKD_BRIEF_TAO_DISPLAY_TRAILER);
    return S_OK;
}

ULONG
TAOListCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    )
{
    ULONG result;

    if (pField->address==0)
        return 0;

    if (!(Options & AFDKD_CONDITIONAL) ||
            CheckConditional (pField->address, "TCPIP!AddrObj")) {
        result = (ULONG)InitTypeRead (pField->address, TCPIP!AddrObj);
        if (result!=0) {
            dprintf ("\nAOListCallback: Could not read AddrObj @ %p, err: %d\n",
                pField->address, result);
        }
        DumpTAOBrief (pField->address);
        if (Options & AFDKD_FIELD_DISPLAY) {
            ProcessFieldOutput (pField->address, "TCPIP!AddrObj");
        }
    }
    else {
        dprintf (".");
    }
    return 0;
}

VOID
DumpTAOBrief (
    ULONG64 Address
    )
{
    TA_IP_ADDRESS   address;
    CHAR            src[MAX_ADDRESS_STRING], dst[MAX_ADDRESS_STRING];
    CHAR            symbol[MAX_FIELD_CHARS];
    ULONG64         offset;
    ULONG64         pid, ctx = 0;
    ULONG           result;
    USHORT          prot;
    ULONG           flags, ifidx;

    address.TAAddressCount = 1;
    address.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP; 
    address.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    address.Address[0].Address[0].in_addr = (ULONG)ReadField (ao_addr);
    address.Address[0].Address[0].sin_port = (USHORT)ReadField (ao_port);
    ifidx = (ULONG)ReadField (ao_bindindex);
    if (ifidx==0 || (address.Address[0].Address[0].in_addr!=0)) { 
        strncpy (src, TransportAddressToString ((PTRANSPORT_ADDRESS)&address, 0), sizeof (src)-1);
    }
    else {
        _snprintf (src, sizeof (src)-1, "%%%d:%d", ifidx, NTOHS (address.Address[0].Address[0].sin_port));
    }
    src[sizeof(src)-1] = 0;

    prot = (USHORT)ReadField (ao_prot);
    flags = (ULONG)ReadField (ao_flags);

    if ((offset=ReadField (ao_connect))!=0) {
        ctx = ReadField (ao_conncontext);
    }
    else if ((offset=ReadField (ao_rcvdg))!=0) {
        ctx = ReadField (ao_rcvdgcontext);
    }
    else if ((offset=ReadField (ao_disconnect))!=0) {
        ctx = ReadField (ao_disconncontext);
    }
    else if ((offset=ReadField (ao_error))!=0) {
        ctx = ReadField (ao_errcontext);
    }
    else if ((offset=ReadField (ao_rcv))!=0) {
        ctx = ReadField (ao_rcvcontext);
    }
    else if ((offset=ReadField (ao_errorex))!=0) {
        ctx = ReadField (ao_errorexcontext);
    }
    else if ((offset=ReadField (ao_chainedrcv))!=0) {
        ctx = ReadField (ao_chainedrcvcontext);
    }
    else if ((offset=ReadField (ao_exprcv))!=0) {
        ctx = ReadField (ao_exprcvcontext);
    }

    if (offset!=0) {
        GetSymbol (offset, symbol, &offset);
    }
    else {
        strncpy (symbol, "???", sizeof (symbol)-1);
        symbol[sizeof(symbol)-1] = 0;
    }

    if (SavedMinorVersion>=2219) {
        pid = ReadField (ao_owningpid);
    }
    else {
        pid = 0;
    }

    offset = ReadField (ao_RemoteAddress);
    if (offset!=0) {
        if (ReadMemory (offset, &address, sizeof (address), &result)) {
            strncpy (dst, TransportAddressToString ((PTRANSPORT_ADDRESS)&address, offset), sizeof (dst)-1);

        }
        else {
            _snprintf (dst, sizeof (dst)-1, "Read err @ %I64X", offset);
        }
        dst[sizeof(dst)-1] = 0;
    }
    else {
        INT n;
        ULONG   fldoff;
        n = _snprintf (dst, sizeof (dst)-1, "%3.3x", (ULONG)ReadField (ao_listencnt));
        result = GetFieldOffset ("TCPIP!AddrObj", "ao_activeq", &fldoff);
        if (result==0) {
            if (Options & AFDKD_LIST_COUNT) {
                n+= _snprintf (&dst[n], sizeof (dst)-1-n, " %3.3x", 
                                CountListEntries (Address+fldoff));
            }
            else {
                n+= _snprintf (&dst[n], sizeof (dst)-1-n, " %3.3s", 
                                ListCountEstimate (Address+fldoff));
            }
        }
        result = GetFieldOffset ("TCPIP!AddrObj", "ao_idleq", &fldoff);
        if (result==0) {
            if (Options & AFDKD_LIST_COUNT) {
                n+= _snprintf (&dst[n], sizeof (dst)-1-n, " %3.3x", 
                                CountListEntries (Address+fldoff));
            }
            else {
                n+= _snprintf (&dst[n], sizeof (dst)-1-n, " %3.3s", 
                                ListCountEstimate (Address+fldoff));
            }
        }
        dst[sizeof(dst)-1] = 0;
    }
    /*           TCB      Prot Flags Client ConnCtx   PID   Address  Remote Address*/
    dprintf (
        IsPtr64 ()
            ? "\n%011.011p %4d %5.5x %-6.8s %011.011p %4.4x %-19s %-s"
            : "\n%008.008p %4d %5.5x %-6.8s %008.008p %4.4x %-19s %-s",
            DISP_PTR (Address),
            prot,
            flags,
            strtok (symbol, "!"),
            DISP_PTR(ctx),
            (ULONG)pid,
            src,
            dst);

}

VOID
DumpTAO6Brief (
    ULONG64 Address
    );
ULONG
TAO6ListCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    );

ULONG64 AO6Table;
ULONG   AO6TableSize;
DECLARE_API (tao6)
/*++

Routine Description:

    Dump TCP/IPv6 Address Objects.

Arguments:

    None.

Return Value:

    None.

--*/
{   
    ULONG   result,i;
    PCHAR   argp;
    ULONG64 address;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;

    Options |= AFDKD_BRIEF_DISPLAY;

    dprintf (AFDKD_BRIEF_TAO6_DISPLAY_HEADER);
    if (argp[0]==0) {
        union {
            ULONG64 *p64;
            ULONG   *p32;
        } table;
        ULONG64   count;
        ULONG     size;

        result = GetFieldValue (0, "TCPIP6!AddrObjTable", NULL, address);
        if (result!=0) {
            if (AO6Table==0) {
                dprintf ("\ntao6: Could not read TCPIP6!AddrObjTable, err: %ld\n", result);
                return E_INVALIDARG;
            }
        }
        else if (address==0) {
            dprintf ("\ntao6: TCPIP6!AddrObjTable is NULL!!!\n");
            return E_INVALIDARG;
        }
        else
            AO6Table = address;

        result = GetFieldValue (0, "TCPIP6!AddrObjTableSize", NULL, count);
        if (result!=0) {
            if (AO6TableSize==0) {
                dprintf ("\ntao6: Could not read TCPIP6!AddrObjTableSize, err: %ld\n", result);
                return E_INVALIDARG;
            }
        }
        else if (count==0) {
            dprintf ("\ntao6: TCPIP6!AddrObjTableSize is 0!!!\n");
            return E_INVALIDARG;
        }
        else {
            AO6TableSize = (ULONG)count;
        }

        size = (IsPtr64 () ? sizeof (ULONG64) : sizeof (ULONG))*AO6TableSize;
        table.p64 = RtlAllocateHeap (RtlProcessHeap (), 0, size);
        if (table.p64==NULL) {
            dprintf ("\ntcb: Failed to allocate AOTable, size: %ld\n", size);
            return E_INVALIDARG;
        }

        if (!ReadMemory (AO6Table, table.p64, size, &result)) {
            RtlFreeHeap (RtlProcessHeap (), 0, table.p64);
            dprintf ("\ntao6: Failed to read AOTable\n");
            return E_INVALIDARG;
        }

        for (i=0; i<AO6TableSize; i++) {
            if( CheckControlC() ) {
                break;
            }
            address = IsPtr64() ? table.p64[i] : table.p32[i];
            if (address!=0) {
                ListType (
                    "TCPIP6!AddrObj",           // Type
                    address,                    // Address
                    0,                          // ListByFieldAddress
                    "ao_next",                  // NextPointer
                    argp,                       // Context
                    TAO6ListCallback);
            }
        }
        RtlFreeHeap (RtlProcessHeap (), 0, table.p64);

    }
    else {
        //
        // Snag the address from the command line.
        //
        while (sscanf( argp, "%s%n", expr, &i )==1) {
            if( CheckControlC() ) {
                break;
            }

            argp+=i;
            address = GetExpression (expr);

            result = (ULONG)InitTypeRead (address, TCPIP6!AddrObj);
            if (result!=0) {
                dprintf ("\ntao6: Could not read AddrObj @ %p, err: %d\n",
                    address, result);
                break;
            }

            DumpTAO6Brief (address);
            if (Options & AFDKD_FIELD_DISPLAY) {
                ProcessFieldOutput (address, "TCPIP6!AddrObj");
            }
        }

    }

    dprintf (AFDKD_BRIEF_TAO6_DISPLAY_TRAILER);
    return S_OK;
}

ULONG
TAO6ListCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    )
{
    ULONG result;

    if (pField->address==0)
        return 0;

    if (!(Options & AFDKD_CONDITIONAL) ||
            CheckConditional (pField->address, "TCPIP6!AddrObj")) {
        result = (ULONG)InitTypeRead (pField->address, TCPIP6!AddrObj);
        if (result!=0) {
            dprintf ("\nTAO6ListCallback: Could not read AddrObj @ %p, err: %d\n",
                pField->address, result);
        }
        DumpTAO6Brief (pField->address);
        if (Options & AFDKD_FIELD_DISPLAY) {
            ProcessFieldOutput (pField->address, "TCPIP6!AddrObj");
        }
    }
    else {
        dprintf (".");
    }
    return 0;
}

VOID
DumpTAO6Brief (
    ULONG64 Address
    )
{
    TA_IP6_ADDRESS   address;
    CHAR            src[MAX_ADDRESS_STRING];
    CHAR            symbol[MAX_FIELD_CHARS];
    ULONG64         offset;
    ULONG64         pid, ctx = 0;
    USHORT          prot;
    ULONG           flags;

    address.TAAddressCount = 1;
    address.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP6; 
    address.Address[0].AddressType = TDI_ADDRESS_TYPE_IP6;
    GetFieldValue (Address, "TCPIP6!AddrObj", "ao_addr", address.Address[0].Address[0].sin6_addr);
    address.Address[0].Address[0].sin6_port = (USHORT)ReadField (ao_port);
    address.Address[0].Address[0].sin6_scope_id = (ULONG)ReadField (ao_scope_id);
    strncpy (src, TransportAddressToString ((PTRANSPORT_ADDRESS)&address, 0), sizeof (src)-1);
    src[sizeof(src)-1] = 0;

    prot = (USHORT)ReadField (ao_prot);
    flags = (ULONG)ReadField (ao_flags);

    if ((offset=ReadField (ao_connect))!=0) {
        ctx = ReadField (ao_conncontext);
    }
    else if ((offset=ReadField (ao_rcvdg))!=0) {
        ctx = ReadField (ao_rcvdgcontext);
    }
    else if ((offset=ReadField (ao_disconnect))!=0) {
        ctx = ReadField (ao_disconncontext);
    }
    else if ((offset=ReadField (ao_error))!=0) {
        ctx = ReadField (ao_errcontext);
    }
    else if ((offset=ReadField (ao_rcv))!=0) {
        ctx = ReadField (ao_rcvcontext);
    }
    else if ((offset=ReadField (ao_errorex))!=0) {
        ctx = ReadField (ao_errorexcontext);
    }
#if 0
    else if ((offset=ReadField (ao_chainedrcv))!=0) {
        ctx = ReadField (ao_chainedrcvcontext);
    }
#endif
    else if ((offset=ReadField (ao_exprcv))!=0) {
        ctx = ReadField (ao_exprcvcontext);
    }

    if (offset!=0) {
        GetSymbol (offset, symbol, &offset);
    }
    else {
        strncpy (symbol, "???", sizeof (symbol)-1);
        symbol[sizeof (symbol)-1] = 0;
    }

    if (SavedMinorVersion>=2471) {
        pid = ReadField (ao_owningpid);
    }
    else {
        pid = 0;
    }

#if 0
    offset = ReadField (ao_RemoteAddress);
    if (offset!=0) {
        if (ReadMemory (offset, &address, sizeof (address), &result)) {
            strncpy (dst, TransportAddressToString ((PTRANSPORT_ADDRESS)&address, offset), sizeof (dst)-1);
        }
        else {
            _snprintf (dst, sizeof (dst), "Read err @ %I64X", offset);
        }
        dst[sizeof(dst)-1] = 0;
    }
    else {
        dst[0] = 0;
    }
#endif
    /*           TCB       Prot Flags Client ConnCtx   PID  Addr*/
    dprintf (
        IsPtr64 ()
            ? "\n%011.011p %4d %4.4x %-6.8s %011.011p %4.4x %-s"
            : "\n%008.008p %4d %4.4x %-6.8s %008.008p %4.4x %-s",
            DISP_PTR (Address),
            prot,
            flags,
            strtok (symbol, "!"),
            DISP_PTR(ctx),
            (ULONG)pid,
            src);

}


ULONG
GetRemoteAddressFromTcp (
    ULONG64             FoAddress,
    PVOID               AddressBuffer,
    SIZE_T              AddressBufferLength
    )
{
    ULONG   result;
    ULONG64 fsContext=0, tcpConn=0, tcb=0, u64=0;
    PTA_IP_ADDRESS  ipAddress = AddressBuffer;

    if ((result=GetFieldValue (FoAddress, "NT!_FILE_OBJECT", "FsContext", fsContext))==0 &&
        (result=GetFieldValue (fsContext, "TCPIP!_TCP_CONTEXT", "Conn", tcpConn))==0 &&
        (result=GetFieldValue (tcpConn, "TCPIP!TCPConn", "tc_tcb", tcb))==0 &&
        (result=GetFieldValue (tcb, "TCPIP!TCB", "tcb_daddr", u64))==0 ) {

        ipAddress->TAAddressCount = 1;
        ipAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        ipAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
        ipAddress->Address[0].Address[0].in_addr = (ULONG)u64;
        GetFieldValue (tcb, "TCPIP!TCB", "tcb_dport", u64);
        ipAddress->Address[0].Address[0].sin_port = (USHORT)u64;
        ZeroMemory (&ipAddress->Address[0].Address[0].sin_zero, 
                        sizeof (ipAddress->Address[0].Address[0].sin_zero));
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\type.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    type.h

Abstract:

    Global type definitions for the AFD.SYS Kernel Debugger
    Extensions.

Author:

    Keith Moore (keithmo) 19-Apr-1995.

Environment:

    User Mode.

--*/


#ifndef _TYPE_H_
#define _TYPE_H_


typedef
VOID
(* PDUMP_ENDPOINT_ROUTINE)(
    ULONG64 ActualAddress
    );

typedef
VOID
(* PDUMP_CONNECTION_ROUTINE)(
    ULONG64 ActualAddress
    );

typedef
BOOL
(* PENUM_ENDPOINTS_CALLBACK)(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

typedef struct _AFDKD_TRANSPORT_INFO {
    LIST_ENTRY          Link;
    ULONG64             ActualAddress;
    LONG                ReferenceCount;
    BOOLEAN             InfoValid;
    TDI_PROVIDER_INFO   ProviderInfo;
    WCHAR               DeviceName[1];
} AFDKD_TRANSPORT_INFO, *PAFDKD_TRANSPORT_INFO;

#endif  // _TYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\tdiutil.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    tdiutil.c

Abstract:

    Utility functions for dumping various TDI structures.

Author:

    Keith Moore (keithmo) 19-Apr-1995

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop


//
//  Private prototypes.
//

PSTR
TransportAddressTypeToString(
    USHORT AddressType
    );

PSTR
NetbiosNameTypeToString(
    USHORT NetbiosNameType
    );

PSTR
NetbiosNameTypeToStringBrief(
    USHORT NetbiosNameType
    );

typedef struct in6_addr {
    union {
        UCHAR  Byte[16];
        USHORT Word[8];
    } u;
} IN6_ADDR, *PIN6_ADDR;
#define s6_bytes   u.Byte
#define s6_words   u.Word

INT
MyIp6AddressToString (
    PIN6_ADDR   Addr,
    PCHAR       S,
    INT         L
    );

//
// Remove once ATM defs are moved to tdi.h
//
#define AFD_TDI_ADDRESS_TYPE_ATM    22
#define AFD_ATM_NSAP                0
#define AFD_ATM_E164                1
#define AFD_SAP_FIELD_ABSENT        ((ULONG)0xfffffffe)
#define AFD_SAP_FIELD_ANY			((ULONG)0xffffffff)
#define AFD_SAP_FIELD_ANY_AESA_SEL	((ULONG)0xfffffffa)	// SEL is wild-carded
#define AFD_SAP_FIELD_ANY_AESA_REST	((ULONG)0xfffffffb)	// All of the address
													// except SEL, is wild-carded

typedef struct _AFD_TDI_ADDRESS_ATM {
    ULONG   AddressType;
    ULONG   NumberOfDigits;
    UCHAR   Address[20];
} AFD_TDI_ADDRESS_ATM, *PAFD_TDI_ADDRESS_ATM;



//
//  Public functions.
//


VOID
DumpTransportAddress(
    PCHAR Prefix,
    PTRANSPORT_ADDRESS Address,
    ULONG64 ActualAddress
    )

/*++

Routine Description:

    Dumps the specified TRANSPORT_ADDRESS structure.

Arguments:

    Prefix - A character string prefix to display before each line. Used
        to make things pretty.

    Address - Points to the TRANSPORT_ADDRESS to dump.

    ActualAddress - The actual address where the structure resides on the
        debugee.

Return Value:

    None.

--*/

{

    dprintf(
        "%sTRANSPORT_ADDRESS @ %p\n",
        Prefix,
        ActualAddress
        );

    dprintf(
        "%s    AddressLength   = %u\n",
        Prefix,
        Address->Address[0].AddressLength
        );

    dprintf(
        "%s    AddressType     = %u (%s)\n",
        Prefix,
        Address->Address[0].AddressType,
        TransportAddressTypeToString( Address->Address[0].AddressType )
        );

    switch( Address->Address[0].AddressType ) {

    case TDI_ADDRESS_TYPE_IP : {

        PTA_IP_ADDRESS ipAddress;

        ipAddress = (PTA_IP_ADDRESS)Address;

        dprintf(
            "%s    sin_port        = %u\n",
            Prefix,
            NTOHS(ipAddress->Address00.sin_port)
            );

        dprintf(
            "%s    in_addr         = %d.%d.%d.%d\n",
            Prefix,
            UC(ipAddress->Address00.in_addr >>  0),
            UC(ipAddress->Address00.in_addr >>  8),
            UC(ipAddress->Address00.in_addr >> 16),
            UC(ipAddress->Address00.in_addr >> 24)
            );

        }
        break;

    case TDI_ADDRESS_TYPE_IP6: {
        PTA_IP6_ADDRESS ip6Address;
        CHAR    buffer[MAX_ADDRESS_STRING];
        ip6Address = (PTA_IP6_ADDRESS)Address;
        dprintf(
            "%s    sin6_port       = %u\n",
            Prefix,
            NTOHS(ip6Address->Address00.sin6_port)
            );
        MyIp6AddressToString (
                (PIN6_ADDR)&ip6Address->Address[0].Address[0].sin6_addr, 
                buffer,
                sizeof (buffer));
        dprintf(
            "%s    sin6_addr       = %s\n",
            Prefix,
            buffer
            );
        dprintf(
            "%s    sin6_scope_id   = %u\n",
            Prefix,
            ip6Address->Address00.sin6_scope_id
            );
        }
        break;
    case TDI_ADDRESS_TYPE_IPX : {

        PTA_IPX_ADDRESS ipxAddress;

        ipxAddress = (PTA_IPX_ADDRESS)Address;

        dprintf(
            "%s    NetworkAddress  = %08.8lx\n",
            Prefix,
            ipxAddress->Address00.NetworkAddress
            );

        dprintf(
            "%s    NodeAddress     = %02.2X-%02.2X-%02.2X-%02.2X-%02.2X-%02.2X\n",
            Prefix,
            ipxAddress->Address00.NodeAddress[0],
            ipxAddress->Address00.NodeAddress[1],
            ipxAddress->Address00.NodeAddress[2],
            ipxAddress->Address00.NodeAddress[3],
            ipxAddress->Address00.NodeAddress[4],
            ipxAddress->Address00.NodeAddress[5]
            );

        dprintf(
            "%s    Socket          = %04.4X\n",
            Prefix,
            ipxAddress->Address00.Socket
            );

        }
        break;

    case TDI_ADDRESS_TYPE_NETBIOS : {

        PTA_NETBIOS_ADDRESS netbiosAddress;
        UCHAR netbiosName[16];
        INT i;

        netbiosAddress = (PTA_NETBIOS_ADDRESS)Address;

        dprintf(
            "%s    NetbiosNameType = %04.4X (%s)\n",
            Prefix,
            netbiosAddress->Address00.NetbiosNameType,
            NetbiosNameTypeToString( netbiosAddress->Address00.NetbiosNameType )
            );


        RtlCopyMemory(
            netbiosName,
            netbiosAddress->Address00.NetbiosName,
            15
            );

        netbiosName[15] = 0;

        dprintf(
            "%s    NetbiosName     = %s:0x%2.2x (%2.2X",
            Prefix,
            netbiosName,
            (UCHAR)netbiosAddress->Address00.NetbiosName[0],
            (UCHAR)netbiosAddress->Address00.NetbiosName[0]
            );

        for (i=1;i<sizeof(netbiosAddress->Address00.NetbiosName) ;i++) {
            dprintf ("-%2.2X", (UCHAR)netbiosAddress->Address00.NetbiosName[i]);
        }

        dprintf (")\n");


        }
        break;

    case TDI_ADDRESS_TYPE_NBS: // matches AF_OSI
    case TDI_ADDRESS_TYPE_OSI_TSAP : {
        PTDI_ADDRESS_OSI_TSAP   osiAddress;
        INT i;

        osiAddress = (PTDI_ADDRESS_OSI_TSAP)&Address->Address[0].Address;
        dprintf(
            "%s    Type            = %d\n",
            Prefix,
            osiAddress->tp_addr_type
            );
        i = 0;
        if (osiAddress->tp_tsel_len>0) {
            dprintf(
                "%s    Selector        = %02.2X",
                Prefix,
                osiAddress->tp_addr[i++]
                );
            for (; i<osiAddress->tp_tsel_len; i++) {
                if (CheckControlC ())
                    break;
                dprintf ("-%02.2X", osiAddress->tp_addr[i]);
            }
            dprintf ("\n");
        }

        if (osiAddress->tp_taddr_len>i) {
            INT j = i;
            dprintf(
                "%s    Address         = %02.2Xn",
                Prefix,
                osiAddress->tp_addr[j++]
                );
            for ( ; j<osiAddress->tp_taddr_len; j++) {
                if (CheckControlC ())
                    break;
                dprintf ("-%02.2X", osiAddress->tp_addr[j]);
            }
            dprintf ("(");
            for (; i<osiAddress->tp_taddr_len; i++) {
                if (CheckControlC ())
                    break;
                if (isprint (osiAddress->tp_addr[i])) {
                    dprintf ("%c", osiAddress->tp_addr[i]);
                }
                else {
                    dprintf (".");
                }
            }
            dprintf (")\n");
        }

        }
        break;

    case AFD_TDI_ADDRESS_TYPE_ATM : {
        AFD_TDI_ADDRESS_ATM   UNALIGNED *atmAddress;
        UINT i;

        atmAddress = (AFD_TDI_ADDRESS_ATM UNALIGNED *)&Address->Address[0].Address[2];
        dprintf(
            "%s    Type            = ",
            Prefix
            );
        if (atmAddress->AddressType==AFD_ATM_E164) {
            dprintf ("E164");
        }
        else {
            switch (atmAddress->AddressType) {
            case AFD_ATM_NSAP:
                dprintf ("NSAP");
                break;
            case AFD_SAP_FIELD_ABSENT:
                dprintf ("SAP_FIELD_ABSENT");
                break;
            case AFD_SAP_FIELD_ANY:
                dprintf ("SAP_FIELD_ANY");
                break;
            case AFD_SAP_FIELD_ANY_AESA_SEL:
                dprintf ("SAP_FIELD_ANY_AESA_SEL");
                break;
            case AFD_SAP_FIELD_ANY_AESA_REST:
                dprintf ("SAP_FIELD_ANY_AESA_REST");
                break;
            }
        }
        dprintf (" (%lx)\n",
            atmAddress->AddressType);

        dprintf(
            "%s    Address         = ",
            Prefix
            );
        if (atmAddress->AddressType==AFD_ATM_E164) {
            dprintf ("+");
            for (i=0; i<atmAddress->NumberOfDigits; i++) {
                if (CheckControlC ())
                    break;
                if (isdigit (atmAddress->Address[i])) {
                    dprintf ("%c",atmAddress->Address[i]);
                }
                else {
                    dprintf ("<%02.2X>", atmAddress->Address[i]);
                }
            }
        }
        else {
            for (i=0; i<atmAddress->NumberOfDigits; i++) {
                UCHAR   val;
                if (CheckControlC ())
                    break;
                val = atmAddress->Address[i]>>4;
                dprintf ("%c", (val<=9) ? val+'0' : val+('A'-10));
                val = atmAddress->Address[i]&0xF;
                dprintf ("%c", (val<=9) ? val+'0' : val+('A'-10));
            }
        }

        dprintf ("\n");

        }
        break;
    default :

        dprintf(
            "%s    Unsupported address type\n",
            Prefix
            );

        break;

    }

}   // DumpTransportAddress



INT
MyIp6AddressToString (
    PIN6_ADDR Addr,
    PCHAR     S,
    INT       L
    )
{
    int maxFirst, maxLast;
    int curFirst, curLast;
    int i;
    int endHex = 8, n = 0;

    // Check for IPv6-compatible, IPv4-mapped, and IPv4-translated
    // addresses
    if ((Addr->s6_words[0] == 0) && (Addr->s6_words[1] == 0) &&
        (Addr->s6_words[2] == 0) && (Addr->s6_words[3] == 0) &&
        (Addr->s6_words[6] != 0)) {
        if ((Addr->s6_words[4] == 0) &&
             ((Addr->s6_words[5] == 0) || (Addr->s6_words[5] == 0xffff)))
        {
            // compatible or mapped
            n += _snprintf(&S[n], L-1-n, "::%s%u.%u.%u.%u",
                           Addr->s6_words[5] == 0 ? "" : "ffff:",
                           Addr->s6_bytes[12], Addr->s6_bytes[13],
                           Addr->s6_bytes[14], Addr->s6_bytes[15]);
            S[n]=0;
            return n;
        }
        else if ((Addr->s6_words[4] == 0xffff) && (Addr->s6_words[5] == 0)) {
            // translated
            n += _snprintf(&S[n], L-1-n, "::ffff:0:%u.%u.%u.%u",
                           Addr->s6_bytes[12], Addr->s6_bytes[13],
                           Addr->s6_bytes[14], Addr->s6_bytes[15]);
            S[n]=0;
            return n;
        }
    }


    // Find largest contiguous substring of zeroes
    // A substring is [First, Last), so it's empty if First == Last.

    maxFirst = maxLast = 0;
    curFirst = curLast = 0;

    // ISATAP EUI64 starts with 00005EFE (or 02005EFE)...
    if (((Addr->s6_words[4] & 0xfffd) == 0) && (Addr->s6_words[5] == 0xfe5e)) {
        endHex = 6;
    }

    for (i = 0; i < endHex; i++) {

        if (Addr->s6_words[i] == 0) {
            // Extend current substring
            curLast = i+1;

            // Check if current is now largest
            if (curLast - curFirst > maxLast - maxFirst) {

                maxFirst = curFirst;
                maxLast = curLast;
            }
        }
        else {
            // Start a new substring
            curFirst = curLast = i+1;
        }
    }

    // Ignore a substring of length 1.
    if (maxLast - maxFirst <= 1)
        maxFirst = maxLast = 0;

        // Write colon-separated words.
        // A double-colon takes the place of the longest string of zeroes.
        // All zeroes is just "::".

    for (i = 0; i < endHex; i++) {

        // Skip over string of zeroes
        if ((maxFirst <= i) && (i < maxLast)) {

            n += _snprintf(&S[n], L-1-n, "::");
            i = maxLast-1;
            continue;
        }

        // Need colon separator if not at beginning
        if ((i != 0) && (i != maxLast))
            n += _snprintf(&S[n], L-1-n, ":");

        n += _snprintf(&S[n], L-1-n, "%x", RtlUshortByteSwap(Addr->s6_words[i]));
    }

    if (endHex < 8) {
        n += _snprintf(&S[n], L-1-n, ":%u.%u.%u.%u",
                       Addr->s6_bytes[12], Addr->s6_bytes[13],
                       Addr->s6_bytes[14], Addr->s6_bytes[15]);
    }

    S[n] = 0;
    return n;
}

LPSTR
TransportAddressToString(
    PTRANSPORT_ADDRESS Address,
    ULONG64            ActualAddress
    )

/*++

Routine Description:

    Converts specified transport address to string

Arguments:

    Address - Points to the TRANSPORT_ADDRESS to dump.

Return Value:

    None.

--*/

{
    static CHAR buffer[MAX_ADDRESS_STRING];
    INT n;

    switch( Address->Address[0].AddressType ) {

    case TDI_ADDRESS_TYPE_IP : {

        PTA_IP_ADDRESS ipAddress;

        ipAddress = (PTA_IP_ADDRESS)Address;
        _snprintf (buffer, sizeof (buffer)-1, "%d.%d.%d.%d:%d",
            UC(ipAddress->Address00.in_addr >>  0),
            UC(ipAddress->Address00.in_addr >>  8),
            UC(ipAddress->Address00.in_addr >> 16),
            UC(ipAddress->Address00.in_addr >> 24),
            NTOHS(ipAddress->Address00.sin_port)
            );
        buffer[sizeof(buffer)-1] = 0;
        }
        break;

    case TDI_ADDRESS_TYPE_IP6: {
        PTA_IP6_ADDRESS ip6Address;
        ip6Address = (PTA_IP6_ADDRESS)Address;
        n = 1;
        buffer[0] = '[';
        n += MyIp6AddressToString (
                (PIN6_ADDR)&ip6Address->Address[0].Address[0].sin6_addr, 
                &buffer[n],
                sizeof (buffer)-n);
        if (ip6Address->Address00.sin6_scope_id != 0)
            n += _snprintf(&buffer[n], sizeof (buffer)-1-n, "%%%u", ip6Address->Address00.sin6_scope_id);
        _snprintf (&buffer[n], sizeof (buffer)-1-n, "]:%d",NTOHS(ip6Address->Address00.sin6_port));
        buffer[sizeof(buffer)-1] = 0;
        }
        break;

    case TDI_ADDRESS_TYPE_IPX : {

        PTA_IPX_ADDRESS ipxAddress;

        ipxAddress = (PTA_IPX_ADDRESS)Address;
        _snprintf (buffer, sizeof (buffer)-1,
            "%8.8x:%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x:%4.4x",
            NTOHL(ipxAddress->Address00.NetworkAddress),
            ipxAddress->Address00.NodeAddress[0],
            ipxAddress->Address00.NodeAddress[1],
            ipxAddress->Address00.NodeAddress[2],
            ipxAddress->Address00.NodeAddress[3],
            ipxAddress->Address00.NodeAddress[4],
            ipxAddress->Address00.NodeAddress[5],
            NTOHS(ipxAddress->Address00.Socket)
            );
        buffer[sizeof(buffer)-1] = 0;
        }
        break;

    case TDI_ADDRESS_TYPE_NETBIOS : {

        PTA_NETBIOS_ADDRESS netbiosAddress;
        UCHAR netbiosName[16];
        INT i;
        BOOLEAN doascii = FALSE;

        netbiosAddress = (PTA_NETBIOS_ADDRESS)Address;
        for (i=0; i<15; i++) {
            if (netbiosAddress->Address00.NetbiosName[i]==0)
                break;
            else if (isprint (netbiosAddress->Address00.NetbiosName[i])) {
                doascii = TRUE;
            }
            else {
                doascii = FALSE;
                break;
            }
        }

        n = _snprintf (buffer, sizeof (buffer)-1, "%s:",
            NetbiosNameTypeToString( netbiosAddress->Address00.NetbiosNameType));

        if (doascii) {
            RtlCopyMemory(
                netbiosName,
                netbiosAddress->Address00.NetbiosName,
                15
                );
            netbiosName[15] = 0;

            _snprintf (&buffer[n], sizeof (buffer)-1-n, "%s:0x%2.2x",
                netbiosName,
                netbiosAddress->Address00.NetbiosName[15]
                );
        }
        else {
            n = 0;
            for (i=0; i<sizeof (netbiosAddress->Address00.NetbiosName); i++) {
                n += _snprintf (&buffer[n], sizeof (buffer)-1-n,
                                "%2.2x", (UCHAR)netbiosAddress->Address00.NetbiosName[i]);
            }
        }
        buffer[sizeof(buffer)-1] = 0;
        }
        break;
    case AFD_TDI_ADDRESS_TYPE_ATM : {
        AFD_TDI_ADDRESS_ATM   UNALIGNED *atmAddress;
        UINT i;

        atmAddress = (AFD_TDI_ADDRESS_ATM UNALIGNED *)&Address->Address[0].Address[2];
        n = 0;
        if (atmAddress->AddressType==AFD_ATM_E164) {
            buffer [n++]= '+';
            for (i=0; i<atmAddress->NumberOfDigits; i++) {
                if (CheckControlC ())
                    break;
                if (isdigit (atmAddress->Address[i])) {
                    n += _snprintf (&buffer[n], sizeof (buffer)-1-n, "%c",atmAddress->Address[i]);
                }
                else {
                    n += _snprintf (&buffer[n], sizeof (buffer)-1-n, "<%02.2X>", atmAddress->Address[i]);
                }
            }
        }
        else {
            for (i=0; i<atmAddress->NumberOfDigits; i++) {
                UCHAR   val;
                if (CheckControlC ())
                    break;
                val = atmAddress->Address[i]>>4;
                n += _snprintf (&buffer[n], sizeof (buffer)-1-n, "%c", (val<=9) ? val+'0' : val+('A'-10));
                val = atmAddress->Address[i]&0xF;
                n += _snprintf (&buffer[n], sizeof (buffer)-1-n, "%c", (val<=9) ? val+'0' : val+('A'-10));
            }
        }
        buffer[sizeof(buffer)-1] = 0;
        }
    default :

        _snprintf(buffer, sizeof (buffer)-1, "@ %I64x", DISP_PTR(ActualAddress));
        buffer[sizeof(buffer)-1] = 0;

        break;

    }

    return buffer;

}   // TransportAddressToString

LPSTR
TransportPortToString(
    PTRANSPORT_ADDRESS Address,
    ULONG64            ActualAddress
    )

/*++

Routine Description:

    Converts specified transport address to string

Arguments:

    Address - Points to the TRANSPORT_ADDRESS to dump.

Return Value:

    None.

--*/

{
    static CHAR buffer[8];

    switch( Address->Address[0].AddressType ) {

    case TDI_ADDRESS_TYPE_IP : {

        PTA_IP_ADDRESS ipAddress;

        ipAddress = (PTA_IP_ADDRESS)Address;
        _snprintf (buffer, sizeof (buffer)-1, "%5u",
            NTOHS(ipAddress->Address00.sin_port)
            );
        buffer[sizeof(buffer)-1] = 0;
        }
        break;

    case TDI_ADDRESS_TYPE_IP6: {
        PTA_IP6_ADDRESS ip6Address;
        ip6Address = (PTA_IP6_ADDRESS)Address;
        _snprintf (buffer, sizeof (buffer)-1, "%5u",
            NTOHS(ip6Address->Address00.sin6_port));
        buffer[sizeof(buffer)-1] = 0;
        }
        break;

    case TDI_ADDRESS_TYPE_IPX : {

        PTA_IPX_ADDRESS ipxAddress;

        ipxAddress = (PTA_IPX_ADDRESS)Address;
        _snprintf (buffer, sizeof (buffer)-1, "x%4.4x",
            NTOHS(ipxAddress->Address00.Socket)
            );
        buffer[sizeof(buffer)-1] = 0;

        }
        break;

    case TDI_ADDRESS_TYPE_NETBIOS : {

        PTA_NETBIOS_ADDRESS netbiosAddress;
        netbiosAddress = (PTA_NETBIOS_ADDRESS)Address;
        _snprintf (buffer, sizeof (buffer)-1, "x%4.4x",
            netbiosAddress->Address00.NetbiosName[15]
            );
        buffer[sizeof(buffer)-1] = 0;

        }
        break;
    default :

        _snprintf(buffer, sizeof (buffer)-1, "?????");
        buffer[sizeof(buffer)-1] = 0;

        break;

    }

    return buffer;

}   // TransportPortToString


//
//  Private functions.
//

PSTR
TransportAddressTypeToString(
    USHORT AddressType
    )

/*++

Routine Description:

    Maps a transport address type to a displayable string.

Arguments:

    AddressType - The transport address type to map.

Return Value:

    PSTR - Points to the displayable form of the tranport address type.

--*/

{

    switch( AddressType ) {

    case TDI_ADDRESS_TYPE_UNSPEC :

        return "Unspecified";

    case TDI_ADDRESS_TYPE_UNIX :

        return "Unix";

    case TDI_ADDRESS_TYPE_IP :

        return "Ip";

    case TDI_ADDRESS_TYPE_IP6 :

        return "Ip6";

    case TDI_ADDRESS_TYPE_IMPLINK :

        return "Implink";

    case TDI_ADDRESS_TYPE_PUP :

        return "Pup";

    case TDI_ADDRESS_TYPE_CHAOS :

        return "Chaos";

    case TDI_ADDRESS_TYPE_IPX :

        return "Ipx";

    case TDI_ADDRESS_TYPE_NBS :

        return "Nbs (or AF_OSI)";

    case TDI_ADDRESS_TYPE_ECMA :

        return "Ecma";

    case TDI_ADDRESS_TYPE_DATAKIT :

        return "Datakit";

    case TDI_ADDRESS_TYPE_CCITT :

        return "Ccitt";

    case TDI_ADDRESS_TYPE_SNA :

        return "Sna";

    case TDI_ADDRESS_TYPE_DECnet :

        return "Decnet";

    case TDI_ADDRESS_TYPE_DLI :

        return "Dli";

    case TDI_ADDRESS_TYPE_LAT :

        return "Lat";

    case TDI_ADDRESS_TYPE_HYLINK :

        return "Hylink";

    case TDI_ADDRESS_TYPE_APPLETALK :

        return "Appletalk";

    case TDI_ADDRESS_TYPE_NETBIOS :

        return "Netbios";

    case TDI_ADDRESS_TYPE_8022 :

        return "8022";

    case TDI_ADDRESS_TYPE_OSI_TSAP :

        return "OSI TSAP";

    case TDI_ADDRESS_TYPE_NETONE :

        return "Netone";

    case AFD_TDI_ADDRESS_TYPE_ATM :

        return "ATM";

    }

    return "UNKNOWN";

}   // TransportAddressTypeToString


PSTR
NetbiosNameTypeToStringBrief(
    USHORT NetbiosNameType
    )

/*++

Routine Description:

    Maps a NetBIOS name type to a displayable string.

Arguments:

    NetbiosNameType - The NetBIOS name type to map.

Return Value:

    PSTR - Points to the displayable form of the NetBIOS name type.

--*/

{

    switch( NetbiosNameType ) {

    case TDI_ADDRESS_NETBIOS_TYPE_UNIQUE :

        return "U";

    case TDI_ADDRESS_NETBIOS_TYPE_GROUP :

        return "G";

    case TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE :

        return "QU";

    case TDI_ADDRESS_NETBIOS_TYPE_QUICK_GROUP :

        return "QG";

    }

    return "?";

}   // NetbiosNameTypeToStringBrief


PSTR
NetbiosNameTypeToString(
    USHORT NetbiosNameType
    )

/*++

Routine Description:

    Maps a NetBIOS name type to a displayable string.

Arguments:

    NetbiosNameType - The NetBIOS name type to map.

Return Value:

    PSTR - Points to the displayable form of the NetBIOS name type.

--*/

{

    switch( NetbiosNameType ) {

    case TDI_ADDRESS_NETBIOS_TYPE_UNIQUE :

        return "Unique";

    case TDI_ADDRESS_NETBIOS_TYPE_GROUP :

        return "Group";

    case TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE :

        return "Quick Unique";

    case TDI_ADDRESS_NETBIOS_TYPE_QUICK_GROUP :

        return "Quick Group";

    }

    return "UNKNOWN";

}   // NetbiosNameTypeToString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\streams\winstrm\makefile.inc ===
$(O)\nlstxt.mc: $(PROJECT_ROOT)\inc\unixapis.mc localmsg.mc
    copy $(PROJECT_ROOT)\inc\unixapis.mc+localmsg.mc $@
    $(MC) -v -h $(O) -r $(O) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\streams\winstrm\common.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    common.h

Abstract:

    This header file is to be included by all sources in this directory.

Author:

    Eric Chin (ericc)           August  2, 1991

Revision History:

    Sam Patton (sampa)          August 13, 1991
                                added includes to get setlasterror

--*/
#ifndef _COMMON_
#define _COMMON_

//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// C Run Time Library Headers
//
#include <assert.h>
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//
// Windows headers
//
#include <windef.h>
#include <windows.h>

//
// Regular STREAMS headers
//
//
#include <crt\errno.h>
#include <poll.h>
#include <stropts.h>


//
// Additional NT STREAMS Headers
//
// ntddstrm.h defines the interface to the Stream Head driver; ntstapi.h
// defines the STREAMS APIs available on NT.
//
#include <ntddstrm.h>
#include <ntstapi.h>


//
// Private Function Prototypes
//
int
MapNtToPosixStatus(
    IN NTSTATUS   status
    );


#endif /* _COMMON_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\umode.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    umode.c

Abstract:

    Functions for USER MODE Winsock structures.

Author:

    Keith Moore (keithmo) 19-Apr-1995

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop

typedef
BOOL
(* PENUM_SOCKETS_CALLBACK)(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

VOID
EnumSockets(
    ULONG64                 TableAddr,
    PENUM_SOCKETS_CALLBACK  Callback,
    ULONG64                 Context
    );

ULONG64
FindHandleContext (
    IN  ULONG64     TableAddr,
    IN  ULONG64     Handle
    );

BOOL
DumpSocketCallback (
    ULONG64                 ActualAddress,
    ULONG64                 Context
    );

PSTR
SansockStateToString(
    VOID
	);

PSTR
SandupeStateToString(
    ULONG   State
	);

ULONG
DumpDProvCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    );

VOID
DumpDProv (
    ULONG64     Address
    );

ULONG
DumpNProvCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    );

VOID
DumpNProv (
    ULONG64     Address
    );

VOID
ReadUmGlobals (
    );

//
// Basic or often used parameters obtained from symbol parser
// or global for the process.
//
ULONG LookupTableOffset, LookupTableSize, HandleContextOffset, SzProtocolOffset;
ULONG64 Ws2_32ContextTable, MswsockContextTable, Ws2_32DProcess;
ULONG64 CurrentProcess;

DECLARE_API(sock)
/*++

Routine Description:

    Dumps User Mode socket structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    INT     i;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];
    PCHAR   argp;


    gClient = pClient;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;

    ReadUmGlobals ();

    if (Ws2_32ContextTable==0 || 
        LookupTableOffset==0 ||
        LookupTableSize==0 ||
        HandleContextOffset==0 ||
        (MswsockContextTable==0 && (Options & AFDKD_MSWSOCK_DISPLAY))) {
        return E_INVALIDARG;
    }

    dprintf (AFDKD_BRIEF_SOCKET_DISPLAY_HEADER);

    if ((argp[0]==0) || (Options & AFDKD_ENDPOINT_SCAN)) {
        EnumSockets(
            Ws2_32ContextTable,
            DumpSocketCallback,
            0
            );
    }
    else {
        //
        // Snag the handle from the command line.
        //
        while (sscanf( argp, "%s%n", expr, &i )==1) {
            ULONG64 handle, contextPtr;
            if( CheckControlC() ) {
                break;
            }

            argp+=i;
            handle = GetExpression (expr);

            contextPtr = FindHandleContext (Ws2_32ContextTable, handle);
            if (contextPtr!=0) {
                DumpSocketCallback (contextPtr, 0);
            }
        }

    }
    dprintf (AFDKD_BRIEF_SOCKET_DISPLAY_TRAILER);
    if (Options & AFDKD_MSWSOCK_DISPLAY) {
        dprintf (AFDKD_BRIEF_MSWSOCK_DISPLAY_TRAILER);
    }
    return S_OK;
}

DECLARE_API(dprov)
/*++

Routine Description:

    Dumps User Mode Winsock data providers

Arguments:

    None.

Return Value:

    None.

--*/

{
    INT     i;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];
    PCHAR   argp;
    ULONG64 address;
    ULONG   result;

    gClient = pClient;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;


    ReadUmGlobals ();

    dprintf (AFDKD_BRIEF_DPROV_DISPLAY_HEADER);

    if (argp[0]==0) {

        if (Ws2_32DProcess==0) {
            dprintf ("\ndprov: WS2_32!DPROCESS::sm_current_dprocess is NULL\n");
            return E_INVALIDARG;
        }

        result = GetFieldValue (Ws2_32DProcess, 
                                "WS2_32!DPROCESS", 
                                "m_protocol_catalog", 
                                address);
        if (result!=0) {
            dprintf ("\ndprov: Could not read protocol catalog, err: %ld\n", result);
            return E_INVALIDARG;
        }

        if (address==0) {
            dprintf ("\ndprov: Protocol catalog is NULL\n");
            return E_INVALIDARG;
        }

        result = GetFieldValue (address, 
                                "WS2_32!DCATALOG", 
                                "m_protocol_list.Flink", 
                                address);
        if (result!=0) {
            dprintf ("\ndprov: Could not read protocol catalog list Flink, err: %ld\n", result);
            return E_INVALIDARG;
        }

        if (address==0) {
            dprintf ("\ndprov: Protocol catalog list Flink is NULL\n");
            return E_INVALIDARG;
        }

        ListType (
            "WS2_32!PROTO_CATALOG_ITEM",        // Type
            address,                            // Address
            1,                                  // ListByFieldAddress
            "m_CatalogLinkage.Flink",           // NextPointer
            NULL,
            DumpDProvCallback
            );

    }
    else {
        //
        // Snag the provider from the command line.
        //
        while (sscanf( argp, "%s%n", expr, &i )==1) {
            if( CheckControlC() ) {
                break;
            }

            argp+=i;
            address = GetExpression (expr);
            result = (ULONG)InitTypeRead (address, WS2_32!PROTO_CATALOG_ITEM);
            if (result!=0) {
                dprintf ("\ndprov: Could not read WS2_32!PROTO_CATALOG_ITEM @ %p, err: %d\n",
                        address, result);
                continue;
            }

            DumpDProv (address);
            if (Options & AFDKD_FIELD_DISPLAY) {
                ProcessFieldOutput (address, "WS2_32!PROTO_CATALOG_ITEM");
            }
        }

    }
    dprintf (AFDKD_BRIEF_DPROV_DISPLAY_TRAILER);
    return S_OK;
}


DECLARE_API(nprov)
/*++

Routine Description:

    Dumps User Mode Winsock Name Space providers

Arguments:

    None.

Return Value:

    None.

--*/

{
    INT     i;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];
    PCHAR   argp;
    ULONG64 address;
    ULONG   result;

    gClient = pClient;

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;


    ReadUmGlobals ();
    dprintf (AFDKD_BRIEF_NPROV_DISPLAY_HEADER);

    if (argp[0]==0) {

        if (Ws2_32DProcess==0) {
            dprintf ("\nnprov: WS2_32!DPROCESS::sm_current_dprocess is NULL\n");
            return E_INVALIDARG;
        }

        result = GetFieldValue (Ws2_32DProcess, 
                                "WS2_32!DPROCESS", 
                                "m_namespace_catalog", 
                                address);
        if (result!=0) {
            dprintf ("\nnprov: Could not read name space catalog, err: %ld\n", result);
            return E_INVALIDARG;
        }

        if (address==0) {
            dprintf ("\nnprov: Name space catalog is NULL\n");
            return E_INVALIDARG;
        }

        result = GetFieldValue (address, 
                                "WS2_32!NSCATALOG", 
                                "m_namespace_list.Flink", 
                                address);
        if (result!=0) {
            dprintf ("\nnprov: Could not read name space catalog list Flink, err: %ld\n", result);
            return E_INVALIDARG;
        }

        if (address==0) {
            dprintf ("\nnprov: Name space catalog list Flink is NULL\n");
            return E_INVALIDARG;
        }

        ListType (
            "WS2_32!NSCATALOGENTRY",            // Type
            address,                            // Address
            1,                                  // ListByFieldAddress
            "m_CatalogLinkage.Flink",           // NextPointer
            NULL,
            DumpNProvCallback
            );

    }
    else {
        //
        // Snag the provider from the command line.
        //
        while (sscanf( argp, "%s%n", expr, &i )==1) {
            if( CheckControlC() ) {
                break;
            }

            argp+=i;
            address = GetExpression (expr);
            result = (ULONG)InitTypeRead (address, WS2_32!NSCATALOGENTRY);
            if (result!=0) {
                dprintf ("\nnprov: Could not read WS2_32!NSCATALOGENTRY @ %p, err: %d\n",
                        address, result);
                continue;
            }

            DumpNProv (address);
            if (Options & AFDKD_FIELD_DISPLAY) {
                ProcessFieldOutput (address, "WS2_32!NSCATALOGENTRY");
            }
        }

    }
    dprintf (AFDKD_BRIEF_NPROV_DISPLAY_TRAILER);

    return S_OK;
}

VOID
EnumSockets(
    ULONG64                 TableAddr,
    PENUM_SOCKETS_CALLBACK  Callback,
    ULONG64                 Context
    )

/*++

Routine Description:

    Enumerates all sockets in the socket handle table, invoking the
    specified callback for each socket.

Arguments:

    TableAddr - address of the table

    Callback - Points to the callback to invoke for each socket.

    Context - An uninterpreted context value passed to the callback
        routine.

Return Value:

    None.

--*/

{
    ULONG   result;
    ULONG   mask;
    ULONG64 lookupTableAddr;
    DWORD i,j;

    if ((result=(ULONG)InitTypeRead (
                    TableAddr, 
                    WS2HELP!_CONTEXT_TABLE))!=0) {
        dprintf(
            "\nEnumSockets: Could not read _CONTEXT_TABLE @ %p, err: %d\n",
            TableAddr, result
            );
        return;
    }
    mask = (ULONG)ReadField (HandleToIndexMask);
    lookupTableAddr = TableAddr+LookupTableOffset;

    for (i=0; i<=mask; i++, lookupTableAddr+=LookupTableSize) {
        ULONG64 hashTableAddr, contextPtrAddr;
        ULONG   numBuckets;
        if( CheckControlC() ) {
            return;
        }
        if ((result=(ULONG)InitTypeRead (
                        lookupTableAddr, 
                        WS2HELP!_CTX_LOOKUP_TABLE))!=0) {
            dprintf(
                "\nEnumSockets: Could not read _CTX_LOOKUP_TABLE @ %p, err: %d\n",
                lookupTableAddr, result
                );
            continue;
        }
        hashTableAddr = ReadField (HashTable);
        if (hashTableAddr==0) {
            continue;
        }
        result = (ULONG)InitTypeRead (hashTableAddr, WS2HELP!_CTX_HASH_TABLE);
        if( result!=0) {
            dprintf(
                "\nEnumSockets: Could not read _CTX_HASH_TABLE @ %p, err: %d\n",
                hashTableAddr, result
                );
            continue;
        }
        numBuckets = (ULONG)ReadField (NumBuckets);
        contextPtrAddr = hashTableAddr+HandleContextOffset;
        for (j=0; j<numBuckets; j++, contextPtrAddr+=IsPtr64 () ? 8 : 4) {
            ULONG64 contextPtr;

            if( CheckControlC() ) {
                return;
            }
            result = ReadPtr (contextPtrAddr, &contextPtr);
            if (result!=0) {
                dprintf(
                    "\nEnumSockets: Could not read LPWSHANDLE_CONTEXT @ %p, err: %d\n",
                    contextPtrAddr, result
                    );
            }
            else if (contextPtr==0) {
            }
            else {
                if (! (Callback) (contextPtr, Context)) {
                    return;
                }
            }
        }
    }
}   // EnumSockets


ULONG64
FindHandleContext (
    IN  ULONG64     TableAddr,
    IN  ULONG64     Handle
    )
/*++

Routine Description:

    Find the socket in the socket handle table and returns its
    associated context structure

Arguments:

    TableAddr - address of the table

    Handle - handle to find
Return Value:

    Context or NULL if not found.

--*/
{
    ULONG   result;
    ULONG   mask;
    ULONG64 lookupTableAddr;
    ULONG64 hashTableAddr,contextPtrAddr,contextPtr;
    ULONG   numBuckets;

    if ((result=(ULONG)InitTypeRead (
                    TableAddr, 
                    WS2HELP!_CONTEXT_TABLE))!=0) {
        dprintf(
            "\nFindHandleContext: Could not read _CONTEXT_TABLE @ %p, err: %d\n",
            TableAddr, result
            );
        return 0;
    }
    mask = (ULONG)ReadField (HandleToIndexMask);
    lookupTableAddr = TableAddr + 
                        LookupTableOffset +
                        LookupTableSize*((Handle>>2)&mask);

    if ((result=(ULONG)InitTypeRead (
                    lookupTableAddr, 
                    WS2HELP!_CTX_LOOKUP_TABLE))!=0) {
        dprintf(
            "\nFindHandleContext: Could not read _CTX_LOOKUP_TABLE @ %p, err: %d\n",
            lookupTableAddr, result
            );
        return 0;
    }

    hashTableAddr = ReadField (HashTable);
    if (hashTableAddr==0) {
        dprintf(
            "\nFindHandleContext: HASH table for handle %p is NULL @ %p\n",
            Handle, lookupTableAddr
            );
        return 0;
    }

    result = (ULONG)InitTypeRead (hashTableAddr, WS2HELP!_CTX_HASH_TABLE);
    if( result!=0) {
        dprintf(
            "\nFindHandleContext: Could not read _CTX_HASH_TABLE @ %p, err: %d\n",
            hashTableAddr, result
            );
        return 0;
    }

    numBuckets = (ULONG)ReadField (NumBuckets);
    if (numBuckets==0) {
        dprintf(
            "\nFindHandleContext: NumBuckets in _CTX_HASH_TABLE @ %p is 0!!!\n",
            hashTableAddr
            );
        return 0;
    }

    contextPtrAddr = hashTableAddr + 
                        HandleContextOffset +
                        (IsPtr64 () ? 8 : 4) * (Handle%numBuckets);

    result = ReadPtr (contextPtrAddr, &contextPtr);

    if (result!=0) {
        dprintf(
            "\nFindHandleContext: Could not read LPWSHANDLE_CONTEXT @ %p, err: %d\n",
            contextPtrAddr, result
            );
        return 0;
    }

    if (contextPtr==0) {
        dprintf(
            "\nFindHandleContext: LPWSHANDLE_CONTEXT is NULL for handle %p @ %p\n",
            Handle, contextPtrAddr
            );
        return 0;
    }

    return contextPtr;
}

enum {
    AFDKD_SocketStateInitializing = -1,
    AFDKD_SocketStateOpen = 0,
    AFDKD_SocketStateBound,
    AFDKD_SocketStateBoundSpecific,           // Datagram only
    AFDKD_SocketStateConnected,               // VC only
    AFDKD_SocketStateClosing
} AFDKD_SOCK_STATE;

BOOL
DumpSocketCallback (
    ULONG64                 ActualAddress,
    ULONG64                 Context
    )
/*++

Routine Description:

    Dumps ws2_32 and mswsock socket information

Arguments:

    Actual address - address of ws2_32 socket info

    Context - NOT used.

Return Value:

    TRUE to continue enumeration.

--*/
{
    ULONG   result;
    ULONG64 catItemAddress, handle, mssockAddr = 0;
    WCHAR   szProtocol[255+1]; //WSAPROTOCOL_LEN+1 in winsock2.h



    result = GetFieldValue (ActualAddress, "WS2_32!DSOCKET", "Handle", handle);
    if (result!=0) {
        dprintf(
            "\nDumpSocketCallback: Could not read socket handle from DSOCKET @ %p, err: %d\n",
            ActualAddress, result
            );
        return TRUE;
    }

    if (Options & AFDKD_CONDITIONAL) {
        BOOLEAN skip = FALSE;
        if (Options & AFDKD_MSWSOCK_DISPLAY) {
            mssockAddr = FindHandleContext (MswsockContextTable, handle);
            if (mssockAddr!=0) {
                if (SavedMinorVersion>=2213) {
                    skip = !CheckConditional (mssockAddr, "MSWSOCK!SOCKET_INFORMATION");
                }
                else {
                    skip = !CheckConditional (mssockAddr, "MSAFD!SOCKET_INFORMATION");
                }
            }
            else
                skip = TRUE;
        }
        else {
            skip = !CheckConditional (ActualAddress, "WS2_32!DSOCKET");
        }
        if (skip) {
            dprintf (".");
            return TRUE;
        }
    }

    result = (ULONG)InitTypeRead (ActualAddress, WS2_32!DSOCKET);
    if (result!=0) {
        dprintf(
            "\nDumpSocketCallback: Could not read DSOCKET @ %p, err: %d\n",
            ActualAddress, result
            );
        return TRUE;
    }

    catItemAddress = ReadField (m_catalog_item);
    if (catItemAddress!=0 && SzProtocolOffset!=0) {
        if (!ReadMemory (catItemAddress + SzProtocolOffset,
                        szProtocol,
                        sizeof (szProtocol),
                        NULL)) {
            _snwprintf (szProtocol, sizeof (szProtocol)/2, L"Could not read protocol string @ %I64X", catItemAddress+SzProtocolOffset);
        }
    }
    else {
        szProtocol[0] = 0;
    }

    dprintf ("\n%06.6p %p %c%c%c %p-%-.256ls",
                handle,
                ActualAddress,
                ReadField (m_pvd_socket) ? 'P' : ' ',
                ReadField (m_api_socket) ? 'A' : ' ',
                ReadField (m_overlapped_socket) ? 'O' : ' ',
                ReadField (m_provider),
                szProtocol);
    if (Options & AFDKD_MSWSOCK_DISPLAY) {
        ULONG64 sansockAddr, val;
        if (mssockAddr==0) {
            mssockAddr = FindHandleContext (MswsockContextTable, handle);
        }
        if (mssockAddr!=0) {
            if (SavedMinorVersion>=2213) {
                result = (ULONG)InitTypeRead (mssockAddr, MSWSOCK!SOCKET_INFORMATION);
            }
            else {
                result = (ULONG)InitTypeRead (mssockAddr, MSAFD!SOCKET_INFORMATION);
            }
            if (result!=0) {
                dprintf (
                    "\nDumpSocketCallback: Could not read SOCKET_INFORMATION @ %p\n",
                    mssockAddr);
                return TRUE;
            }

            dprintf (
                "\n    MSAFD_sock:%p", mssockAddr);
            switch (ReadField(State)) {
            case AFDKD_SocketStateInitializing:
                dprintf (",initializing");
                break;
            case AFDKD_SocketStateOpen:
                dprintf (",open");
                break;
            case AFDKD_SocketStateBound:
            case AFDKD_SocketStateBoundSpecific:
                {
                    CHAR    transportAddress[MAX_TRANSPORT_ADDR];
                    ULONG   length = (ULONG)ReadField (LocalAddressLength);
                    ULONG64 address = ReadField (LocalAddress);
                    if (ReadMemory (address,
                                        transportAddress,
                                        length<sizeof (transportAddress)
                                            ? length
                                            : sizeof (transportAddress),
                                            &length)) {
                        dprintf (",bnd:%s",
                            TransportAddressToString (
                                (PTRANSPORT_ADDRESS)(
                                    transportAddress
                                        -FIELD_OFFSET (TRANSPORT_ADDRESS, Address[0].AddressType)),
                                address));

                    }
                    else {
                        dprintf (",bnd:%p", address);
                    }
                }
                break;

            case AFDKD_SocketStateConnected:
                {
                    CHAR    transportAddress[MAX_TRANSPORT_ADDR];
                    ULONG   length = (ULONG)ReadField (LocalAddressLength);
                    ULONG64 address = ReadField (LocalAddress);
                    if (ReadMemory (address,
                                        transportAddress,
                                        length<sizeof (transportAddress)
                                            ? length
                                            : sizeof (transportAddress),
                                            &length)) {
                        dprintf (",bnd:%s",
                            TransportAddressToString (
                                (PTRANSPORT_ADDRESS)(
                                    transportAddress
                                        -FIELD_OFFSET (TRANSPORT_ADDRESS, Address[0].AddressType)),
                                address));

                    }
                    else {
                        dprintf (",bnd:%p", address);
                    }

                    length = (ULONG)ReadField (RemoteAddressLength);
                    address = ReadField (RemoteAddress);
                    if (ReadMemory (address,
                                        transportAddress,
                                        length<sizeof (transportAddress)
                                            ? length
                                            : sizeof (transportAddress),
                                            &length)) {
                        dprintf (",con:%s",
                            TransportAddressToString (
                                (PTRANSPORT_ADDRESS)(
                                    transportAddress
                                        -FIELD_OFFSET (TRANSPORT_ADDRESS, Address[0].AddressType)),
                                address));

                    }
                    else {
                        dprintf (",con:%p", address);
                    }
                }
                break;
            case AFDKD_SocketStateClosing:
                dprintf (",closing");
                break;
            default:
                dprintf (",in state %d", (ULONG)ReadField (State));
                break;
            }

            dprintf (",flags:%s%s%s%s%s%s%s%s%s%s",
                ReadField (Listening) ? "L" : "",
                ReadField (Broadcast) ? "B" : "",
                ReadField (Debug) ? "D" : "",
                ReadField (OobInline) ? "O" : "",
                ReadField (ReuseAddresses) ? "A" : "",
                ReadField (ExclusiveAddressUse) ? "E" : "",
                ReadField (NonBlocking) ? "N" : "",
                ReadField (ConditionalAccept) ? "C" : "",
                ReadField (ReceiveShutdown) ? "R" : "",
                ReadField (SendShutdown) ? "S" : ""
                );
            if (ReadField (LingerInfo.l_onoff)) {
                dprintf (",linger:%d", (ULONG)ReadField (LingerInfo.l_linger));
            }

            if ((val=ReadField (SendTimeout))!=0) {
                dprintf (",sndTO:%ld",(ULONG)val);
            }
            if ((val=ReadField (ReceiveTimeout))!=0) {
                dprintf (",rcvTO:%ld",(ULONG)val);
            }
            if ((val=ReadField (EventSelectlNetworkEvents))!=0) {
                dprintf (",eventSel:%lx",(ULONG)val);
            }
            if ((val=ReadField (AsyncSelectlEvent))!=0) {
                dprintf (",asyncSel:%lx",(ULONG)val);
            }
            if ((sansockAddr=ReadField(SanSocket))!=0) {
                BOOLEAN flowOn;
                UINT    count;
                if (SavedMinorVersion>=2213) {
                    result = (ULONG)InitTypeRead (sansockAddr, MSWSOCK!SOCK_SAN_INFORMATION);
                }
                else {
                    result = (ULONG)InitTypeRead (sansockAddr, MSAFD!SOCK_SAN_INFORMATION);
                }
                if (result!=0) {
                    dprintf (
                        "\nDumpSocketCallback: Could not read SOCK_SAN_INFORMATION @ %p\n",
                        sansockAddr);
                    return TRUE;
                }
                dprintf ("\n    SAN_sock:%p,%s,%ssndCr:%d,rcvCr:%d",
                        sansockAddr,
                        SansockStateToString (),
                        SandupeStateToString ((ULONG)ReadField(SockDupState)),
                        (ULONG)ReadField(SendCredit),
                        (ULONG)ReadField(ReceiversSendCredit));
                count = (ULONG)ReadField (ReceiveBytesBuffered);
                if (count>0) {
                    dprintf(",rcvB:%d", count);
                }
                count = (ULONG)ReadField (ExpeditedBytesBuffered);
                if (count>0) {
                    dprintf(",oobB:%d", count);
                }
                count = (ULONG)ReadField (SendBytesBuffered);
                if (count>0) {
                    dprintf(",sndB:%d", count);
                }
                flowOn = ReadField (FlowControlInitialized)!=0;
                dprintf (",flags:%s%s%s",
                    flowOn ? "F" : "",
                    ReadField (RemoteReset) ? "R" : "",
                    ReadField (IsClosing) ? "C" : "");

            }
            if (Options & AFDKD_FIELD_DISPLAY) {
                if (SavedMinorVersion>=2213) {
                    ProcessFieldOutput (mssockAddr, "MSWSOCK!SOCKET_INFORMATION");
                }
                else {
                    ProcessFieldOutput (mssockAddr, "MSAFD!SOCKET_INFORMATION");
                }
            }
        } // else Socket not in mswsock handle table
    } // else MSWSOCK display is not enabled.
    return TRUE;
}

enum {
    AFDKD_CONNECTED=1,
    AFDKD_NON_BLOCKING_IN_PROGRESS=2,
    AFDKD_BLOCKING_IN_PROGRESS=3,
    AFDKD_WAITING_FOR_FIRST_MSG=4
} AFDKD_SAN_SOCK_STATE;

typedef enum {
	AFDKD_NonBlockingConnectState = 1,
	AFDKD_ListenState = 2,
	AFDKD_AcceptInProgress = 3
} AFDKD_SAN_SOCK_STATE1;
enum {
    AFDKD_SUSPENDING_COMMUNICATION=1, // suspending all data transfers (source proc)
    AFDKD_SOCK_MIGRATED=2,            // sock now fully owned by some other proc
    AFDKD_COMM_SUSPENDED=3,           // remote peer has requested suspension
    AFDKD_IMPORTING_SOCK=4            // getting sock from source process
} AFDKD_SAN_DUPE_STATE;

PSTR
SansockStateToString(
    VOID
	)
{
    ULONG   IsConnected = (ULONG)ReadField (IsConnected);
    ULONG   State1 = (ULONG)ReadField(State1);

	if (IsConnected == AFDKD_NON_BLOCKING_IN_PROGRESS ||
		IsConnected == AFDKD_BLOCKING_IN_PROGRESS) {
		
		return "con-ing";
	}
    else if (IsConnected == AFDKD_CONNECTED) {

		return "con-ed";
	}
	else if (IsConnected == AFDKD_WAITING_FOR_FIRST_MSG) {

		return "waiting";
	}	
	else if (State1 == AFDKD_ListenState) {
		return "lsn-ing";
	}
	else if (State1 == AFDKD_AcceptInProgress) {
		return "acc-ing";
	}
	
	return "unknown state";
}

PSTR
SandupeStateToString(
    ULONG   State
	)
{
    switch (State) {
    case 0:
        return "";
    case AFDKD_SUSPENDING_COMMUNICATION:
        return "ssp-ing,";
    case AFDKD_SOCK_MIGRATED:
        return "mgr-ed,";
    case AFDKD_COMM_SUSPENDED:             
        return "ssp-ed,";
    case AFDKD_IMPORTING_SOCK:              
        return "imp-ing,";
    default:
        return "unknown dupe state,";
    }
}

ULONG
DumpDProvCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    )
{
    ULONG   result;

    if (!(Options & AFDKD_CONDITIONAL) ||
            CheckConditional (pField->address, "WS2_32!PROTO_CATALOG_ITEM")) {
        result = (ULONG)InitTypeRead (pField->address, WS2_32!PROTO_CATALOG_ITEM);
        if (result!=0) {
            dprintf ("\nDumpDProvCallback: Could not read WS2_32!PROTO_CATALOG_ITEM @ %p, err: %d\n",
                    pField->address, result);
            return 1;
        }
        DumpDProv (pField->address);
        if (Options & AFDKD_FIELD_DISPLAY) {
            ProcessFieldOutput (pField->address, "WS2_32!PROTO_CATALOG_ITEM");
        }
    }
    else {
        dprintf (".");
    }
    return 0;
}


VOID
DumpDProv (
    ULONG64     Address
    )
{
    WCHAR   szProtocol[255+1]; //WSAPROTOCOL_LEN+1 in winsock2.h
    LONG    protocol = (LONG)ReadField (m_ProtoInfo.iProtocol);
    CHAR    protoStr[16];
    if (protocol==0x80000000) {
        _snprintf (protoStr, sizeof (protoStr)-1, "-000");
    }
    else {
        _snprintf (protoStr, sizeof (protoStr)-1, "%4d", protocol);
    }
    protoStr[sizeof(protoStr)-1] = 0;
    if (!ReadMemory (Address + SzProtocolOffset,
                    szProtocol,
                    sizeof (szProtocol),
                    NULL)) {
        _snwprintf (szProtocol, sizeof (szProtocol)/2-1, L"Could not read protocol string @ %I64X", Address+SzProtocolOffset);
        szProtocol[sizeof(szProtocol)/2-1] = 0;
    }

              //  Provider PFlag SFlag CatID Ch  RefC  Tripple                       Protocol Name
    dprintf (
        IsPtr64 ()
            ? "\n%011.011p %2.2x %6.6x %5d %2d %4.4x %2d,%1d,%s(%d) %ls"
            : "\n%008.008p %2.2x %6.6x %5d %2d %4.4x %2d,%1d,%s(%d) %ls",
        Address,
        (LONG)ReadField (m_ProtoInfo.dwProviderFlags),
        (LONG)ReadField (m_ProtoInfo.dwServiceFlags1),
        (LONG)ReadField (m_ProtoInfo.dwCatalogEntryId),
        (LONG)ReadField (m_ProtoInfo.ProtocolChain.ChainLen),
        (LONG)ReadField (m_reference_count),
        (LONG)ReadField (m_ProtoInfo.iAddressFamily),
        (LONG)ReadField (m_ProtoInfo.iSocketType),
        protoStr,
        (LONG)ReadField (m_ProtoInfo.iProtocolMaxOffset),
        szProtocol);
}
        

ULONG
DumpNProvCallback (
    PFIELD_INFO pField,
    PVOID       UserContext
    )
{
    ULONG   result;

    if (!(Options & AFDKD_CONDITIONAL) ||
            CheckConditional (pField->address, "WS2_32!NSCATALOGENTRY")) {
        result = (ULONG)InitTypeRead (pField->address, WS2_32!NSCATALOGENTRY);
        if (result!=0) {
            dprintf ("\nDumpNProvCallback: Could not read WS2_32!NSCATALOGENTRY @ %p, err: %d\n",
                    pField->address, result);
            return 1;
        }
        DumpNProv (pField->address);
        if (Options & AFDKD_FIELD_DISPLAY) {
            ProcessFieldOutput (pField->address, "WS2_32!NSCATALOGENTRY");
        }
    }
    else {
        dprintf (".");
    }
    return 0;
}


VOID
DumpNProv (
    ULONG64     Address
    )
{
    WCHAR   szProtocol[255+1]; //WSAPROTOCOL_LEN+1 in winsock2.h
    ULONG64 strAddr = ReadField (m_providerDisplayString);
    if (strAddr!=0) {
        if (!ReadMemory (strAddr,
                        szProtocol,
                        sizeof (szProtocol),
                        NULL)) {
            _snwprintf (szProtocol, sizeof (szProtocol)/2-1, L"Could not read protocol string @ %I64X", strAddr);
        }
    }
    else {
        _snwprintf (szProtocol, sizeof (szProtocol)/2-1, L"NULL");
    }
    szProtocol[sizeof(szProtocol)/2-1] = 0;

              // Provider  NSid AF Fl   RefC  Display String"
    dprintf (
        IsPtr64 ()
            ? "\n%011.011p %5d %2d %s%s %4.4x %ls"
            : "\n%008.008p %5d %2d %s%s %4.4x %ls",
        Address,
        (LONG)ReadField (m_namespace_id),
        (LONG)ReadField (m_address_family),
        ReadField (m_enabled) ? "E" : " ",
        ReadField (m_stores_service_class_info) ? "C" : " ",
        (LONG)ReadField (m_reference_count),
        szProtocol);
}
        
VOID
ReadUmGlobals (
    )
/*++

Routine Description:

    Reads type info and globals of Winsock user mode DLLs

Arguments:

    None

Return Value:

    None
--*/
{
    ULONG   result;
    ULONG64 process;

    process = GetExpression ("@$proc");
    if (CurrentProcess==0 ||
            CurrentProcess!=process ||
            LookupTableOffset==0 ||
            HandleContextOffset==0 ||
            LookupTableSize==0) {
        if ((LookupTableOffset==0 &&
                (result=(ULONG)GetFieldOffset(
                        "WS2HELP!_CONTEXT_TABLE", 
                        "Tables", 
                        &LookupTableOffset))!=0) ||
            (HandleContextOffset==0 &&
                (result=(ULONG)GetFieldOffset(
                        "WS2HELP!_CTX_HASH_TABLE", 
                        "Buckets", 
                        &HandleContextOffset))!=0) ||
            (LookupTableSize==0 &&
                (LookupTableSize = GetTypeSize (
                    "WS2HELP!_CTX_LOOKUP_TABLE"))==0) ) {
            dprintf ("\nReadUmGlobals: Could not get WS2HELP.DLL type info, err:%ld\n", result);
        }
    }

    if (CurrentProcess==0 ||
            CurrentProcess!=process ||
            Ws2_32ContextTable==0 ||
            SzProtocolOffset==0 ||
            Ws2_32DProcess==0) {
        if ((Ws2_32ContextTable==0 &&
                    (result=GetFieldValue (0,
                                "WS2_32!DSOCKET__sm_context_table",
                                NULL,
                                Ws2_32ContextTable))!=0 &&
                    (result=GetFieldValue (0,
                                "WS2_32!DSOCKET::sm_context_table",
                                NULL,
                                Ws2_32ContextTable))!=0) ||
            (Ws2_32DProcess==0 &&
                    (result=GetFieldValue (0,
                                "WS2_32!DPROCESS__sm_current_dprocess",
                                NULL,
                                Ws2_32DProcess))!=0 &&
                    (result=GetFieldValue (0,
                                "WS2_32!DSOCKET::sm_current_dprocess",
                                NULL,
                                Ws2_32DProcess))!=0) ||
            (SzProtocolOffset==0 &&
                    (result=(ULONG)GetFieldOffset (
                                "WS2_32!PROTO_CATALOG_ITEM",
                                "m_ProtoInfo.szProtocol",
                                &SzProtocolOffset))!=0) ) {
            dprintf ("\nReadUmGlobals: Could not get WS2_32.DLL globals/type info, err: %ld\n", result);
        }
    }

    if (Options & AFDKD_MSWSOCK_DISPLAY) {
        if (CurrentProcess==0 ||
                CurrentProcess!=process ||
                MswsockContextTable==0) {
            if (SavedMinorVersion>=2213) {
                result=GetFieldValue (0,
                                        "MSWSOCK!SockContextTable",
                                        NULL,
                                        MswsockContextTable);
                if (result!=0) {
                    dprintf ("\nReadUmGlobals: Could not get MSWSOCK.DLL globals, err: %ld\n", result);
                }
            }
            else {
                result=GetFieldValue (0,
                                        "MSAFD!SockContextTable",
                                        NULL,
                                        MswsockContextTable);
                if (result!=0) {
                    dprintf ("\nReadUmGlobals: Could not get MSAFD.DLL globals, err: %ld\n", result);
                }
            }
        }
    }
    CurrentProcess = process;
    dprintf ("\nCurrent process: %p\n", process);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\wsp\afdsys\kdext\tranfile.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    tranfile.c

Abstract:

    Implements the tranfile command.

Author:

    Keith Moore (keithmo) 15-Apr-1996

Environment:

    User Mode.

Revision History:

--*/


#include "afdkdp.h"
#pragma hdrstop

BOOL
DumpTransmitInfoCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    );

//
//  Public functions.
//

DECLARE_API( tran )

/*++

Routine Description:

    Dumps the AFD_TRANSMIT_FILE_INFO_INTERNAL structure at the specified
    address.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG   result;
    CHAR    expr[MAX_ADDRESS_EXPRESSION];
    INT     i;
    PCHAR   argp;
    ULONG64 address;

    gClient = pClient;

    if (!CheckKmGlobals ()) {
        return E_INVALIDARG;
    }

    argp = ProcessOptions ((PCHAR)args);
    if (argp==NULL)
        return E_INVALIDARG;

    if (Options&AFDKD_BRIEF_DISPLAY) {
        if (SavedMinorVersion>=2219) {
            dprintf (AFDKD_BRIEF_TPACKETS_DISPLAY_HEADER);
        }
        else {
            dprintf (AFDKD_BRIEF_TRANFILE_DISPLAY_HEADER);
        }
    }

    if ((argp[0]==0) || (Options & AFDKD_ENDPOINT_SCAN)) {
        EnumEndpoints(
            DumpTransmitInfoCallback,
            0
            );
        dprintf ("\nTotal transmits: %ld", EntityCount);
    }
    else {
        //
        // Snag the address from the command line.
        //

        while (sscanf( argp, "%s%n", expr, &i )==1) {
            if( CheckControlC() ) {
                break;
            }
            argp += i;
            address = GetExpression (expr);
            if (SavedMinorVersion>=2219) {
                result = (ULONG)InitTypeRead (address, AFD!_IRP);
                if (result!=0) {
                    dprintf(
                        "\ntran: Could not read IRP @ %p, err:%d\n",
                        address, result
                        );

                    break;

                }

                if (Options & AFDKD_BRIEF_DISPLAY) {
                    DumpAfdTPacketsInfoBrief(
                        address
                        );
                }
                else {
                    DumpAfdTPacketsInfo(
                        address
                        );
                }
                if (Options & AFDKD_FIELD_DISPLAY) {
                    ProcessFieldOutput (address, "AFD!_IRP");
                }
            }
            else {
                result = (ULONG)InitTypeRead (address, AFD!AFD_TRANSMIT_FILE_INFO_INTERNAL);
                if (result!=0) {
                    dprintf(
                        "\ntran: Could not read transmit info @ %p, err:%d\n",
                        address, result
                        );

                    break;

                }

                if (Options & AFDKD_BRIEF_DISPLAY) {
                    DumpAfdTransmitInfoBrief(
                        address
                        );
                }
                else {
                    DumpAfdTransmitInfo(
                        address
                        );
                }
                if (Options & AFDKD_FIELD_DISPLAY) {
                    ProcessFieldOutput (address, "AFD!AFD_TRANSMIT_FILE_INFO_INTERNAL");
                }
            }
        }
    }

    if (Options&AFDKD_BRIEF_DISPLAY) {
        if (SavedMinorVersion>=2219) {
            dprintf (AFDKD_BRIEF_TPACKETS_DISPLAY_TRAILER);
        }
        else {
            dprintf (AFDKD_BRIEF_TRANFILE_DISPLAY_TRAILER);
        }
    }
    else {
        dprintf ("\n");
    }

    return S_OK;

}   // tranfile

BOOL
DumpTransmitInfoCallback(
    ULONG64 ActualAddress,
    ULONG64 Context
    )

/*++

Routine Description:

    EnumEndpoints() callback for dumping transmit info structures.

Arguments:

    Endpoint - The current AFD_ENDPOINT.

    ActualAddress - The actual address where the structure resides on the
        debugee.

    Context - The context value passed into EnumEndpoints().

Return Value:

    BOOL - TRUE if enumeration should continue, FALSE if it should be
        terminated.

--*/

{
    ULONG result;
    ULONG64 address;
    USHORT type;
    UCHAR  state;
    type = (USHORT)ReadField (Type);
    state = (UCHAR)ReadField (State);
    if (SavedMinorVersion>=2219) {
        if (type!=AfdBlockTypeEndpoint && 
                (state==AfdEndpointStateConnected ||
                 state==AfdEndpointStateTransmitClosing)) {
            address = ReadField (Irp);
        }
        else {
            address = 0;
        }

    }
    else {
        address = ReadField (TransmitInfo);
    }


    if (address!=0) {
        if (SavedMinorVersion>=2219) {
            result = (ULONG)InitTypeRead (address, AFD!_IRP);
            if (result!=0) {
                dprintf(
                    "\nDumpTransmitInfoCallback: Could not read irp @ %p, err: %ld\n",
                    address, result
                    );
                return TRUE;
            }
            if (!(Options & AFDKD_CONDITIONAL) ||
                        CheckConditional (address, "AFD!_IRP") ) {
                if (Options & AFDKD_NO_DISPLAY)
                    dprintf ("+");
                else {
                    if (Options & AFDKD_BRIEF_DISPLAY) {
                        DumpAfdTPacketsInfoBrief(
                            address
                            );
                    }
                    else {
                        DumpAfdTPacketsInfo(
                            address
                            );
                    }
                    if (Options & AFDKD_FIELD_DISPLAY) {
                        ProcessFieldOutput (address, "AFD!_IRP");
                    }
                }
                EntityCount += 1;
            }
            else
                dprintf (",");
        }
        else {
            result = (ULONG)InitTypeRead (address, AFD!AFD_TRANSMIT_FILE_INFO_INTERNAL);
            if (result!=0) {
                dprintf(
                    "\nDumpTransmitInfoCallback: Could not read transmit file info @ %p, err: %ld\n",
                    address, result
                    );
                return TRUE;
            }
            if (!(Options & AFDKD_CONDITIONAL) ||
                        CheckConditional (address, "AFD!AFD_TRANSMIT_FILE_INFO_INTERNAL") ) {
                if (Options & AFDKD_NO_DISPLAY)
                    dprintf ("+");
                else {
                    if (Options & AFDKD_BRIEF_DISPLAY) {
                        DumpAfdTransmitInfoBrief(
                            address
                            );
                    }
                    else {
                        DumpAfdTransmitInfo(
                            address
                            );
                    }
                    if (Options & AFDKD_FIELD_DISPLAY) {
                        ProcessFieldOutput (address, "AFD!AFD_TRANSMIT_FILE_INFO_INTERNAL");
                    }
                }
                EntityCount += 1;
            }
            else
                dprintf (",");
        }
    }
    else {
        dprintf (".");
    }
    return TRUE;

}   // DumpTransmitInfoCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\streams\winstrm\openstrm.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    openstrm.c

Abstract:

    This module implements the STREAMS APIs, s_open() and OpenStream().

Author:

    Sam Patton (sampa)          November, 1991
    Eric Chin (ericc)           July 17, 1992

Revision History:


--*/
#include "common.h"




HANDLE
s_open(
    IN char *path,
    IN int oflag,
    IN int ignored
    )

/*++

Routine Description:

    This function opens a stream.

Arguments:

    path        - path to the STREAMS driver
    oflag       - currently ignored.  In the future, O_NONBLOCK will be
                    relevant.
    ignored     - not used

Return Value:

    An NT handle for the stream, or INVALID_HANDLE_VALUE if unsuccessful.

--*/

{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string;
    UNICODE_STRING      uc_name_string;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    char Buffer[sizeof(FILE_FULL_EA_INFORMATION) + NORMAL_STREAM_EA_LENGTH + 1];
    NTSTATUS Status;

    RtlInitString(&name_string, path);
    RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uc_name_string,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    EaBuffer = (PFILE_FULL_EA_INFORMATION) Buffer;

    EaBuffer->NextEntryOffset = 0;
    EaBuffer->Flags = 0;
    EaBuffer->EaNameLength = NORMAL_STREAM_EA_LENGTH;
    EaBuffer->EaValueLength = 0;

    RtlMoveMemory(
        EaBuffer->EaName,
        NormalStreamEA,
        NORMAL_STREAM_EA_LENGTH + 1);

    Status =
    NtCreateFile(
        &StreamHandle,
        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_IF,
        0,
        EaBuffer,
        sizeof(FILE_FULL_EA_INFORMATION) - 1 +
            EaBuffer->EaNameLength + 1);

    RtlFreeUnicodeString(&uc_name_string);

    if (Status != STATUS_SUCCESS) {
        SetLastError(MapNtToPosixStatus(Status));
        return(INVALID_HANDLE_VALUE);
    } else {
        return(StreamHandle);
    }

} // s_open



HANDLE
OpenStream(
    IN char *AdapterName
    )

/*++

Routine Description:

    This function is used by the TCP/IP Utilities to open STREAMS drivers.

    It was exported by the winstrm.dll included in the July, 1992 PDC
    release.  Hence, it will continue to be exported by winstrm.dll.

Arguments:

    AdapterName - path of the STREAMS driver

Return Value:

    An NT handle, or INVALID_HANDLE_VALUE if unsuccessful.

--*/

{
    return( s_open(AdapterName, 2, 0) );

} // OpenStream
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\streams\winstrm\status.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    status.c

Abstract:

    This module attempts to map NT status codes to Unix error
    numbers as specified by the X/Open Transport Interface.

Author:

    Eric Chin (ericc)           August  2, 1991

Revision History:

--*/

#include "common.h"
#include <sock_err.h>

int
MapNtToPosixStatus(
    IN NTSTATUS   status
    )

/*++

Routine Description:

    This function returns a POSIX error number, given an NT status code.

Arguments:

    status    - an NT status code

Return Value:

    the corresponding POSIX error number

--*/

{
    switch (status) {
    case STATUS_INSUFFICIENT_RESOURCES:
        return(ENOSR);

    case STATUS_INVALID_PARAMETER:
        return(EINVAL);

    case STATUS_NO_SUCH_DEVICE:
        return(ENXIO);

    case STATUS_INVALID_NETWORK_RESPONSE:
        return(ENETDOWN);

    case STATUS_NETWORK_BUSY:
        return(EBUSY);

    case STATUS_ACCESS_DENIED:
        return(EACCES);

    default:
        return(EINVAL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\streams\winstrm\s_getmsg.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    s_getmsg.c

Abstract:

    This module implements the STREAMS api, getmsg().

Author:

    Eric Chin (ericc)           July 26, 1991

Revision History:

    Sam Patton (sampa)          August 13, 1991
                                changed errno to {get|set}lasterror

--*/
#include "common.h"




int
getmsg(
    IN HANDLE               fd,
    IN OUT struct strbuf   *ctrlptr OPTIONAL,
    IN OUT struct strbuf   *dataptr OPTIONAL,
    IN OUT int             *flagsp
    )

/*++

Routine Description:

    This procedure is called to receive a STREAMS message.

Arguments:

    fd        - NT file handle
    ctrlptr   - pointer to the control portion of the STREAMS message
    dataptr   - pointer to the data portion of the STREAMS message
    flagsp    - pointer to the flags argument, which may be RS_HIPRI

Return Value:

    0, MORECTL and/or MOREDATA bits set if successful, -1 otherwise.

--*/
{
    char *tmp;
    int chunksz;
    NTSTATUS status;
    PSTRM_ARGS_OUT oparm;
    IO_STATUS_BLOCK iosb;
    PGETMSG_ARGS_INOUT chunk;
    int retval;

    //
    // marshall the arguments into one contiguous chunk, laid out as:
    //
    //  typedef struct _GETMSG_ARGS_INOUT_ {
    //      int             a_retval;           //  ignored for input
    //      long            a_flags;            //  0 or RS_HIPRI
    //      struct strbuf   a_ctlbuf;           //  (required)
    //      struct strbuf   a_databuf;          //  (required)
    //      char            a_stuff[1];         //  a_ctlbuf.buf  (optional)
    //                                          //  a_databuf.buf (optional)
    //  } GETMSG_ARGS_INOUT, *PGETMSG_ARGS_INOUT;
    //
    //
    chunksz = sizeof(GETMSG_ARGS_INOUT) - 1 +
                ((ctrlptr && (ctrlptr->maxlen > 0)) ? ctrlptr->maxlen : 0) +
                ((dataptr && (dataptr->maxlen > 0)) ? dataptr->maxlen : 0);

    if (!(chunk = (PGETMSG_ARGS_INOUT) LocalAlloc(LMEM_FIXED, chunksz))) {
        SetLastError(ENOSPC);
        return(-1);
    }
    chunk->a_flags = (long) *flagsp;

    memset(&(chunk->a_ctlbuf), 0, 2 * sizeof(struct strbuf));

    if (ctrlptr) {
        chunk->a_ctlbuf = *ctrlptr;             // structure copy
    }

    if (dataptr) {
        chunk->a_databuf = *dataptr;            // structure copy
    }

    status = NtDeviceIoControlFile(
        fd,                                     // Handle
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_GETMSG,                   // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
    }

    if (status != STATUS_SUCCESS) {
        LocalFree(chunk);
        SetLastError(MapNtToPosixStatus(status));
        return(-1);
    }

//
// sampa
//

#if 0
    if (status == STATUS_PENDING)
        {
        TimeOut.LowPart = 30L;  // 30 second
        TimeOut.HighPart = 0L;
        TimeOut = RtlExtendedIntegerMultiply(TimeOut, 1000000L);
        status =
        NtWaitForSingleObject(
            fd,
            TRUE,
            NULL);
        if (status != STATUS_SUCCESS) {
            SetLastError(MapNtToPosixStatus(status));
            LocalFree((HANDLE) chunk);
            return(-1);
            }
        }
#endif

    //
    // if there was an error, the return parameters from the Stream Head
    // Driver are laid out as:
    //
    //  typedef struct _STRM_ARGS_OUT_ {        // generic return parameters
    //      int     a_retval;                   //  return value
    //      int     a_errno;                    //  errno if retval == -1
    //
    //  } STRM_ARGS_OUT, *PSTRM_ARGS_OUT;
    //
    //
    oparm = (PSTRM_ARGS_OUT) chunk;

    if (oparm->a_retval == -1) {
        SetLastError(oparm->a_errno);
        retval = oparm->a_retval;
        LocalFree(chunk);
        return(retval);
    }

    // otherwise, the return parameters from the Stream Head Driver are laid
    // out as:
    //
    //  typedef struct _GETMSG_ARGS_INOUT_ {
    //      int             a_retval;           //  ignored for input
    //      long            a_flags;            //  0 or RS_HIPRI
    //      struct strbuf   a_ctlbuf;           //  (required)
    //      struct strbuf   a_databuf;          //  (required)
    //      char            a_stuff[1];         //  a_ctlbuf.buf  (optional)
    //                                          //  a_databuf.buf (optional)
    //  } GETMSG_ARGS_INOUT, *PGETMSG_ARGS_INOUT;
    //
    //
    *flagsp = chunk->a_flags;
    tmp     = chunk->a_stuff;

    if (ctrlptr) {
        ctrlptr->len = chunk->a_ctlbuf.len;

        if (ctrlptr->len > 0) {
            assert(ctrlptr->len <= ctrlptr->maxlen);
            memcpy(ctrlptr->buf, tmp, ctrlptr->len);
            tmp += ctrlptr->len;
        }
    }

    if (dataptr) {
        dataptr->len = chunk->a_databuf.len;

        if (dataptr->len > 0) {
            assert(dataptr->len <= dataptr->maxlen);
            memcpy(dataptr->buf, tmp, dataptr->len);
        }
    }

    retval = chunk->a_retval;
    LocalFree(chunk);
    return(retval);

} // getmsg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\streams\winstrm\s_poll.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    s_poll.c

Abstract:

    This module implements the STREAMS api, poll()

Author:

    Eric Chin (ericc)           July 26, 1991

Revision History:

    Sam Patton (sampa)          August 13, 1991
                                changed errno to {get|set}lasterror

--*/
#include "common.h"


/*
 * BUGBUG
 * Confirm that the following is a sane number.
 */
#define MAX_FDS             NPOLLFILE           /* max handles to poll */




int
poll(
    IN OUT struct pollfd   *fds     OPTIONAL,
    IN unsigned int         nfds,
    IN int                  timeout
    )

/*++

Routine Description:

    This procedure is called to poll a set of stream descriptors.

Arguments:

    fds       - pointer to a array of poll structures
    nfds      - number of poll structures pointed to by fds
    timeout   - 0, INFTIM (-1), or timeout in milliseconds.

Return Value:

    no of stream descriptors selected, or -1 if failure.

--*/

{
    char *chunk;
    NTSTATUS status;
    IO_STATUS_BLOCK iosb;
    int chunksz, selected;
    struct pollfd *overlay;
    HANDLE hijack = INVALID_HANDLE_VALUE;

    if (!fds || (nfds <= 0) || (nfds > MAX_FDS)) {
        SetLastError(EINVAL);
        return(-1);
    }

    /*
     * hijack a handle to the Stream Head driver.
     *
     * BUGBUG:
     * In Unix, the user can set pollfd.fd to less than 0 to indicate that
     * the entry should be ignored.  On NT, that isn't possible:
     * INVALID_HANDLE_VALUE must be used.
     */
    for (overlay = fds; overlay < &fds[nfds]; overlay++) {
        if (overlay->fd != INVALID_HANDLE_VALUE) {
            hijack = overlay->fd;
            break;
        }
    }
    if (hijack == INVALID_HANDLE_VALUE) {
        SetLastError(EINVAL);
        return(-1);
    }

    chunksz = sizeof(nfds) + nfds * sizeof(*fds) + sizeof(timeout);

    if (!(chunk = (char *) LocalAlloc(LMEM_FIXED, chunksz))) {
        SetLastError(EAGAIN);
        return(-1);
    }

    /*
     * marshall the arguments into one contiguous chunk, laid out as:
     *
     *      nfds                    (required)
     *      timeout                 (required)
     *      struct fds[nfds]        (required)
     */
    * ((size_t *) chunk)             = nfds;
    * (int *) (chunk + sizeof(nfds)) = timeout;
    overlay                          = (struct pollfd *) (chunk +
                                            sizeof(nfds) + sizeof(timeout));

    memcpy(overlay, fds, nfds * sizeof(*fds));

    status = NtDeviceIoControlFile(
        hijack,
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_POLL,                     // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize

    if (status == STATUS_PENDING) {
        status =
        NtWaitForSingleObject(
            hijack,
            TRUE,
            NULL);
    }

    if (!NT_SUCCESS(status)) {
        SetLastError(MapNtToPosixStatus(status));
        LocalFree((HANDLE) chunk);
        return(-1);
    }

    /*
     * the Stream Head Driver marshalled the return parameters into one
     * contiguous chunk, laid out as:
     *
     *      return value            (required)
     *      errno                   (required)
     *      struct fds[nfds]        (required)
     */
    if ((selected = * (int *) chunk) == -1) {
        SetLastError(* (int *) (chunk + sizeof(nfds)));
        LocalFree((HANDLE) chunk);
        return(selected);
    }
    overlay = (struct pollfd *) (chunk + sizeof(nfds) + sizeof(timeout));

    while (nfds--) {
        fds[nfds].revents = overlay[nfds].revents;
    }
    LocalFree((HANDLE) chunk);
    return(selected);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\streams\winstrm\s_ioctl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    s_ioctl.c

Abstract:

    This module implements the s_ioctl() operation used by the
    socket library.

Author:

    Eric Chin (ericc)           July 26, 1991

Revision History:

    Sam Patton (sampa)          August 13, 1991
                                changed errno to {get|set}lasterror
--*/
#include "common.h"



//
// BUGBUG: Remove this structure when eric implements
//         neither I/O. Right now, it is needed because sockets allocates
//         the space for this structure in an ioctl call.
//

/*
 *  IOCTL structure - this structure is the format of the M_IOCTL message type.
 */
struct iocblk {
        int             ioc_cmd;        /* ioctl command type */
        unsigned short  ioc_uid;        /* effective uid of user */
        unsigned short  ioc_gid;        /* effective gid of user */
        unsigned int    ioc_id;         /* ioctl id */
        unsigned int    ioc_count;      /* count of bytes in data field */
        int             ioc_error;      /* error code */
        int             ioc_rval;       /* return value  */
};


//
// BUGBUG:
// The max amount of data that any module in the stream can return in an
// M_IOCACK message should probably be queried from the Stream Head driver.
//
#define         MAX_DATA_AMOUNT     0x1000




//
// Declaration of Local Functions
//
static int
s_debug(
    IN HANDLE               fd,
    IN OUT struct strdebug *dbgbufp
    );

static int
s_fdinsert(
    IN HANDLE               fd,
    IN struct strfdinsert  *iblk
    );

static int
s_link(
    IN HANDLE               fd,
    IN HANDLE               fd2
    );

static int
s_push(
    IN HANDLE               fd,
    IN char                *name
    );

static int
s_sioctl(
    IN HANDLE               fd,
    IN OUT struct strioctl *iocp
    );

static int
s_unlink(
    IN HANDLE   fd,
    IN int      muxid
    );






int
s_ioctl(
    IN HANDLE               fd,
    IN int                  cmd,
    IN OUT void            *arg OPTIONAL
    )

/*++

Routine Description:

    This procedure is called to perform a STREAMS ioctl() on a stream
    as defined in streamio(7) of the Unix Programmer's Guide: STREAMS.

Arguments:

    fd        - NT file handle
    command   - ioctl command code
    arg       - command-dependent arg, usually a pointer to some structure

Return Value:

    0 if successful, -1 otherwise.

--*/
{
    switch (cmd) {
        case I_STR:
            return(s_sioctl(fd, (struct strioctl *) arg));

        case I_DEBUG:
            return(s_debug(fd, (struct strdebug *) arg));

        case I_FDINSERT:
            return(s_fdinsert(fd, (struct strfdinsert *) arg));

        case I_PUSH:
            return(s_push(fd, (char *) arg));

        case I_LINK:
            return(s_link(fd, (HANDLE) arg));

        case I_UNLINK:
            return(s_unlink(fd, (int) ((ULONG_PTR)arg)));

        default:
            SetLastError(EINVAL);
            return(-1);
    }
}



static int
s_debug(
    IN HANDLE               fd,
    IN OUT struct strdebug *dbgbufp
    )

/*++

Routine Description:

    This procedure performs an I_DEBUG ioctl command on a stream.

Arguments:

    fd        - NT file handle
    dbgbufp   - pointer to a strdebug structure

Return Value:

    0 if successful, -1 otherwise.

--*/

{
    char *tmp;
    char *chunk;
    NTSTATUS status;
    int chunksz, retval;
    IO_STATUS_BLOCK iosb;

    if (dbgbufp == NULL) {
        SetLastError(EINVAL);
        return(-1);
    }
    chunksz = sizeof(int) + sizeof(struct strdebug);

    if (!(chunk = (char *) LocalAlloc(LMEM_FIXED, chunksz))) {
        SetLastError(ENOSPC);
        return(-1);
    }

    //
    // marshall the arguments into one contiguous chunk, laid out as:
    //
    //      union {
    //          struct {
    //              int               s_code;   // I_DEBUG
    //              struct strdebug   dbgbuf;
    //          } in;
    //
    //          struct {
    //              int s_retval;
    //              int s_errno;
    //          } out;
    //      };
    //
    * ((int *) chunk) = I_DEBUG;
    tmp               = chunk + sizeof(int);

    memcpy(tmp, dbgbufp, sizeof(struct strdebug));

    status = NtDeviceIoControlFile(
        fd,
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_IOCTL,                    // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize

    if (status == STATUS_PENDING) {
        status =
        NtWaitForSingleObject(
            fd,
            TRUE,
            NULL);
    }

    if (!NT_SUCCESS(status)) {
        LocalFree((HANDLE) chunk);
        SetLastError(MapNtToPosixStatus(status));
        return(-1);
    }

    //
    // the Stream Head driver returned values in one chunk, laid out as:
    //
    //      int return value        (required)
    //      int errno;              (required)
    //
    retval = * (int *) chunk;

    if (retval == -1) {
        SetLastError(* (int *) (chunk + sizeof(int)));
    }
    LocalFree((HANDLE) chunk);
    return(retval);
}



int
s_fdinsert(
    IN HANDLE               fd,
    IN struct strfdinsert  *iblk
    )

/*++

Routine Description:

    This function performs an ioctl(I_FDINSERT) on a stream, which is a
    special form of putmsg().

    This function is synchronous, in the NT sense: it blocks until the API
    completes.

Arguments:

    fd        - NT file handle
    iblk      - pointer to a strfdinsert structure

Return Value:

    0 if successful, -1 otherwise.

--*/

{
    char *tmp;
    NTSTATUS status;
    int chunksz, retval;
    IO_STATUS_BLOCK iosb;
    PSTRM_ARGS_OUT oparm;
    PPUTMSG_ARGS_IN chunk;

    if (!iblk) {
        SetLastError(EINVAL);
        return(-1);
    }
    if (iblk->ctlbuf.len <= 0) {
        SetLastError(ERANGE);
        return(-1);
    }

    //
    // iblk->databuf.len may be -1, to indicate no data buffer.
    //
    chunksz = sizeof(PUTMSG_ARGS_IN) - 1 +
                        iblk->ctlbuf.len + max(iblk->databuf.len, 0);

    if (!(chunk = (PPUTMSG_ARGS_IN) LocalAlloc(LMEM_FIXED, chunksz))) {
        SetLastError(ENOSPC);
        return(-1);
    }

    //
    // marshall the arguments into one contiguous chunk.  However, for
    // commonality with putmsg(), we rearrange the strfdinsert structure
    // as below:
    //
    //  typedef struct _PUTMSG_ARGS_IN_ {
    //      int             a_iocode;           //  I_FDINSERT
    //      long            a_flags;            //  0 | RS_HIPRI
    //      struct strbuf   a_ctlbuf;           //  (required)
    //      struct strbuf   a_databuf;          //  (required)
    //      HANDLE          a_insert.i_fildes;  //  (required)
    //      int             a_offset;           //  (optional)
    //      char            a_stuff[1];         //  s_ctlbuf.buf  (required)
    //                                          //  s_databuf.buf (optional)
    //  } PUTMSG_ARGS_IN, *PPUTMSG_ARGS_IN;
    //
    //
    chunk->a_iocode          = I_FDINSERT;
    chunk->a_flags           = iblk->flags;
    chunk->a_ctlbuf          = iblk->ctlbuf;    // structure copy
    chunk->a_databuf         = iblk->databuf;   // structure copy
    chunk->a_insert.i_fildes = iblk->fildes;
    chunk->a_offset          = iblk->offset;

    tmp = (char *) chunk->a_stuff;

    assert(iblk->ctlbuf.len > 0);
    memcpy(tmp, iblk->ctlbuf.buf, iblk->ctlbuf.len);
    tmp += iblk->ctlbuf.len;

    if (iblk->databuf.len > 0) {
        memcpy(tmp, iblk->databuf.buf, iblk->databuf.len);
    }

    ASSERT(chunksz >= sizeof(STRM_ARGS_OUT));

    status = NtDeviceIoControlFile(
        fd,                                     // Handle
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_IOCTL,                    // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
    }

    if (!NT_SUCCESS(status)) {
        LocalFree(chunk);
        SetLastError(MapNtToPosixStatus(status));
        return(-1);
    }

    //
    // the return parameters from the Stream Head Driver are laid out as:
    //
    //  typedef struct _STRM_ARGS_OUT_ {        // generic return parameters
    //      int     a_retval;                   //  return value
    //      int     a_errno;                    //  errno if retval == -1
    //
    //  } STRM_ARGS_OUT, *PSTRM_ARGS_OUT;
    //
    //
    oparm  = (PSTRM_ARGS_OUT) chunk;
    retval = oparm->a_retval;

    if (retval == -1) {
        SetLastError(oparm->a_errno);
    }
    LocalFree(chunk);
    return(retval);

} // s_fdinsert



static int
s_link(
    IN HANDLE               fd,
    IN HANDLE               fd2
    )

/*++

Routine Description:

    This procedure performs an I_LINK ioctl command on a stream.

Arguments:

    fd        - NT file handle to upstream driver
    fd2       - NT file handle to downstream driver

Return Value:

    multiplexor id number, or -1 if unsuccessful

--*/
{
    char *chunk;
    NTSTATUS status;
    int chunksz, retval;
    IO_STATUS_BLOCK iosb;

    chunksz = sizeof(int) + sizeof(HANDLE);

    if (!(chunk = (char *) LocalAlloc(LMEM_FIXED, chunksz))) {
        SetLastError(ENOSPC);
        return(-1);
    }

    //
    // marshall the arguments into one contiguous chunk, laid out as:
    //
    //      union {
    //          struct {
    //              int s_code;     // I_LINK
    //
    //              union {
    //                  HANDLE l_fd2;
    //              } s_link;
    //          } in;
    //
    //          struct {
    //              int s_retval;
    //              int s_errno;
    //          } out;
    //      };
    //
    * ((int *) chunk)               = I_LINK;
    * (PHANDLE) ((int *) chunk + 1) = fd2;

    status = NtDeviceIoControlFile(
        fd,
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_IOCTL,                    // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize

    if (status == STATUS_PENDING) {
        status =
        NtWaitForSingleObject(
            fd,
            TRUE,
            NULL);
    }

    if (!NT_SUCCESS(status)) {
        LocalFree((HANDLE) chunk);
        SetLastError(MapNtToPosixStatus(status));
        return(-1);
    }

    //
    // the Stream Head driver returned values in one chunk, laid out as:
    //
    //      union {
    //          struct {
    //              int s_code;     // I_LINK
    //
    //              union {
    //                  HANDLE l_fd2;
    //              } s_link;
    //          } in;
    //
    //          struct {
    //              int s_retval;
    //              int s_errno;
    //          } out;
    //      };
    //
    if ((retval = * (int *) chunk) == -1) {
        SetLastError(* (int *) (chunk + sizeof(int)));
    }
    LocalFree((HANDLE) chunk);
    return(retval);
}



static int
s_push(
    IN HANDLE               fd,
    IN char                *name
    )

/*++

Routine Description:

    This procedure performs an I_LINK ioctl command on a stream.

Arguments:

    fd        - NT file handle to stream
    name      - name of STREAMS module to be pushed

Return Value:

    0 if successful, -1 otherwise

--*/
{
    char *chunk;
    NTSTATUS status;
    int chunksz, retval;
    IO_STATUS_BLOCK iosb;

    chunksz = (int)(max(2 * sizeof(int), sizeof(int) + strlen(name) + 1));

    if (!(chunk = (char *) LocalAlloc(LMEM_FIXED, chunksz))) {
        SetLastError(ENOSPC);
        return(-1);
    }

    //
    // marshall the arguments into one contiguous chunk, laid out as:
    //
    //      union {
    //          struct {
    //              int s_code;     // I_PUSH
    //
    //              union {
    //                  char p_name[1];
    //              } s_push;
    //          } in;
    //
    //          struct {
    //              int s_retval;
    //              int s_errno;
    //          } out;
    //      };
    //
    * ((int *) chunk) = I_PUSH;
    strcpy(chunk + sizeof(int), name);

    status = NtDeviceIoControlFile(
        fd,
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_IOCTL,                    // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize

    if (status == STATUS_PENDING) {
        status =
        NtWaitForSingleObject(
            fd,
            TRUE,
            NULL);
    }

    if (!NT_SUCCESS(status)) {
        LocalFree((HANDLE) chunk);
        SetLastError(MapNtToPosixStatus(status));
        return(-1);
    }

    //
    // the Stream Head driver returned values in one chunk, laid out as:
    //
    //      union {
    //          struct {
    //              int s_code;     // I_LINK
    //          } in;
    //
    //          struct {
    //              int s_retval;
    //              int s_errno;
    //          } out;
    //      };
    //
    if ((retval = * (int *) chunk) == -1) {
        SetLastError(* (int *) (chunk + sizeof(int)));
    }
    LocalFree((HANDLE) chunk);
    return(retval);
}



static int
s_sioctl(
    IN HANDLE               fd,
    IN OUT struct strioctl *iocp
    )

/*++

Routine Description:

    This procedure performs an ioctl(I_STR) on a stream.

Arguments:

    fd        - NT file handle
    iocp      - pointer to a strioctl structure

Return Value:

    0 if successful, -1 otherwise.

--*/

{
    NTSTATUS status;
    int chunksz, retval;
    IO_STATUS_BLOCK iosb;
    PISTR_ARGS_INOUT chunk;

    union outparms {
        ISTR_ARGS_INOUT    o_ok;
        STRM_ARGS_OUT      o_bad;
    } *oparm;

    if (!iocp || (iocp->ic_len < 0)) {
        SetLastError(EINVAL);
        return(-1);
    }
    chunksz = sizeof(ISTR_ARGS_INOUT) + max(iocp->ic_len, MAX_DATA_AMOUNT);
    chunk   = (PISTR_ARGS_INOUT) LocalAlloc(LMEM_FIXED, chunksz);

    if (!chunk) {
        SetLastError(ENOSPC);
        return(-1);
    }

    //
    // marshall the arguments into one contiguous chunk, laid out as:
    //
    //  typedef struct _ISTR_ARGS_INOUT {           // ioctl(I_STR)
    //      int                 a_iocode;           //  I_STR
    //      struct strioctl     a_strio;            //  (required)
    //      int                 a_unused[2];        //  (required) BUGBUG
    //      char                a_stuff[1];         //  (optional)
    //
    //  } ISTR_ARGS_INOUT, *PISTR_ARGS_INOUT;
    //
    //
    // An optimizing compiler will warn that the assertion below contains
    // unreachable code.  Ignore the warning.
    //
    assert((char *) chunk->a_stuff - (char *) &(chunk->a_strio) >=
                                                        sizeof(struct iocblk));

    chunk->a_iocode = I_STR;
    memcpy(&(chunk->a_strio), iocp, sizeof(struct strioctl));

    if (iocp->ic_len >= 0) {
        memcpy(&(chunk->a_stuff), iocp->ic_dp, iocp->ic_len);
    }

    status = NtDeviceIoControlFile(
        fd,                                     // Handle
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_IOCTL,                    // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize


    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
    }

    if (!NT_SUCCESS(status)) {
        LocalFree(chunk);
        SetLastError(MapNtToPosixStatus(status));
        return(-1);
    }

    //
    // if there was an error, the return parameters from the Stream Head
    // Driver are laid out as:
    //
    //  typedef struct _STRM_ARGS_OUT_ {        // generic return parameters
    //      int     a_retval;                   //  return value
    //      int     a_errno;                    //  errno if retval == -1
    //
    //  } STRM_ARGS_OUT, *PSTRM_ARGS_OUT;
    //
    //
    oparm  = (union outparms *) chunk;
    retval = oparm->o_bad.a_retval;

    if (retval == -1) {
        SetLastError(oparm->o_bad.a_errno);
        LocalFree(chunk);
        return(retval);
    }

    //
    // if there wasn't an error, the return parameters from the Stream Head
    // Driver are laid out as:
    //
    //  typedef struct _ISTR_ARGS_INOUT {           // ioctl(I_STR)
    //      int                 a_iocode;           //  return value
    //      struct strioctl     a_strio;            //  (required)
    //      int                 a_unused[2];
    //      char                a_stuff[1];         //  (optional)
    //
    //  } ISTR_ARGS_INOUT, *PISTR_ARGS_INOUT;
    //
    // However, a_iocode now holds the return value.
    //
    //
    if (iocp && iocp->ic_dp) {
        iocp->ic_len = oparm->o_ok.a_strio.ic_len;

        if (iocp->ic_len >= 0) {
            memcpy(iocp->ic_dp, oparm->o_ok.a_stuff, iocp->ic_len);
        }
    }
    LocalFree(chunk);
    return(retval);

} // s_sioctl




static int
s_unlink(
    IN HANDLE   fd,
    IN int      muxid
    )

/*++

Routine Description:

    This procedure performs an I_UNLINK ioctl command on a stream.

Arguments:

    fd        - NT file handle to upstream driver
    muxid     - STREAMS multiplexor id of the lower stream

Return Value:

    0 on success, or -1 on failure

--*/
{
    int chunk[2];
    NTSTATUS status;
    int chunksz, retval;
    IO_STATUS_BLOCK iosb;

    //
    // marshall the arguments into one contiguous chunk, laid out as:
    //
    //      union {
    //          struct {
    //              int s_code;     // I_UNLINK
    //
    //              union {
    //                  int l_muxid;
    //              } s_unlink;
    //          } in;
    //
    //          struct {
    //              int s_retval;
    //              int s_errno;
    //          } out;
    //      };
    //
    chunk[0] = I_UNLINK;
    chunk[1] = muxid;
    chunksz  = sizeof(chunk);

    status = NtDeviceIoControlFile(
        fd,                                     // Handle
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_IOCTL,                    // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize

    if (status == STATUS_PENDING) {
        status =
        NtWaitForSingleObject(
            fd,
            TRUE,
            NULL);
    }

    if (!NT_SUCCESS(status)) {
        SetLastError(MapNtToPosixStatus(status));
        return(-1);
    }

    //
    // the Stream Head driver returned values in one chunk, laid out as:
    //
    //      union {
    //          struct {
    //              int s_code;     // I_UNLINK
    //
    //              union {
    //                  HANDLE l_fd2;
    //              } s_link;
    //          } in;
    //
    //          struct {
    //              int s_retval;
    //              int s_errno;
    //          } out;
    //      };
    //
    if ((retval = chunk[0]) == -1) {
        SetLastError(chunk[1]);
    }
    return(retval);

} // s_unlink
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\streams\winstrm\w_perror.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    w_perror.c

Abstract:

    This module implements the WSA_perror() operation used by the
    p_error function. This is a temporary workaround for beta.
    This will be replaced by NLS support for the final product.

Author:

    John Ballard (jballard)           June 15, 1992

Revision History:

    Ronald Meijer (ronaldm) NLS Enabled         Nov 26, 1992

--*/

#include <stdio.h>
#include <winsock.h>

#include "nlstxt.h"

#define MAX_MSGTABLE 255

HMODULE hWinStrm = NULL;

int WSA_perror(
char *yourmsg,
int lerrno)
{
    WCHAR perrW[MAX_MSGTABLE+1];
    CHAR perr[MAX_MSGTABLE+1];
    unsigned msglen;
    unsigned usMsgNum;

    switch (lerrno) {
        case WSAENAMETOOLONG:
            usMsgNum = IDS_WSAENAMETOOLONG;
            break;
        case WSASYSNOTREADY:
            usMsgNum = IDS_WSASYSNOTREADY;
            break;
        case WSAVERNOTSUPPORTED:
            usMsgNum = IDS_WSAVERNOTSUPPORTED;
            break;
        case WSAESHUTDOWN:
            usMsgNum = IDS_WSAESHUTDOWN;
            break;
        case WSAEINTR:
            usMsgNum = IDS_WSAEINTR;
            break;
        case WSAHOST_NOT_FOUND:
            usMsgNum = IDS_WSAHOST_NOT_FOUND;
            break;
        case WSATRY_AGAIN:
            usMsgNum = IDS_WSATRY_AGAIN;
            break;
        case WSANO_RECOVERY:
            usMsgNum = IDS_WSANO_RECOVERY;
            break;
        case WSANO_DATA:
            usMsgNum = IDS_WSANO_DATA;
            break;
        case WSAEBADF:
            usMsgNum = IDS_WSAEBADF;
            break;
        case WSAEWOULDBLOCK:
            usMsgNum = IDS_WSAEWOULDBLOCK;
            break;
        case WSAEINPROGRESS:
            usMsgNum = IDS_WSAEINPROGRESS;
            break;
        case WSAEALREADY:
            usMsgNum = IDS_WSAEALREADY;
            break;
        case WSAEFAULT:
            usMsgNum = IDS_WSAEFAULT;
            break;
        case WSAEDESTADDRREQ:
            usMsgNum = IDS_WSAEDESTADDRREQ;
            break;
        case WSAEMSGSIZE:
            usMsgNum = IDS_WSAEMSGSIZE;
            break;
        case WSAEPFNOSUPPORT:
            usMsgNum = IDS_WSAEPFNOSUPPORT;
            break;
        case WSAENOTEMPTY:
            usMsgNum = IDS_WSAENOTEMPTY;
            break;
        case WSAEPROCLIM:
            usMsgNum = IDS_WSAEPROCLIM;
            break;
        case WSAEUSERS:
            usMsgNum = IDS_WSAEUSERS;
            break;
        case WSAEDQUOT:
            usMsgNum = IDS_WSAEDQUOT;
            break;
        case WSAESTALE:
            usMsgNum = IDS_WSAESTALE;
            break;
        case WSAEINVAL:
            usMsgNum = IDS_WSAEINVAL;
            break;
        case WSAEMFILE:
            usMsgNum = IDS_WSAEMFILE;
            break;
        case WSAELOOP:
            usMsgNum = IDS_WSAELOOP;
            break;
        case WSAEREMOTE:
            usMsgNum = IDS_WSAEREMOTE;
            break;
        case WSAENOTSOCK:
            usMsgNum = IDS_WSAENOTSOCK;
            break;
        case WSAEADDRNOTAVAIL:
            usMsgNum = IDS_WSAEADDRNOTAVAIL;
            break;
        case WSAEADDRINUSE:
            usMsgNum = IDS_WSAEADDRINUSE;
            break;
        case WSAEAFNOSUPPORT:
            usMsgNum = IDS_WSAEAFNOSUPPORT;
            break;
        case WSAESOCKTNOSUPPORT:
            usMsgNum = IDS_WSAESOCKTNOSUPPORT;
            break;
        case WSAEPROTONOSUPPORT:
            usMsgNum = IDS_WSAEPROTONOSUPPORT;
            break;
        case WSAENOBUFS:
            usMsgNum = IDS_WSAENOBUFS;
            break;
        case WSAETIMEDOUT:
            usMsgNum = IDS_WSAETIMEDOUT;
            break;
        case WSAEISCONN:
            usMsgNum = IDS_WSAEISCONN;
            break;
        case WSAENOTCONN:
            usMsgNum = IDS_WSAENOTCONN;
            break;
        case WSAENOPROTOOPT:
            usMsgNum = IDS_WSAENOPROTOOPT;
            break;
        case WSAECONNRESET:
            usMsgNum = IDS_WSAECONNRESET;
            break;
        case WSAECONNABORTED:
            usMsgNum = IDS_WSAECONNABORTED;
            break;
        case WSAENETDOWN:
            usMsgNum = IDS_WSAENETDOWN;
            break;
        case WSAENETRESET:
            usMsgNum = IDS_WSAENETRESET;
            break;
        case WSAECONNREFUSED:
            usMsgNum = IDS_WSAECONNREFUSED;
            break;
        case WSAEHOSTDOWN:
            usMsgNum = IDS_WSAEHOSTDOWN;
            break;
        case WSAEHOSTUNREACH:
            usMsgNum = IDS_WSAEHOSTUNREACH;
            break;
        case WSAEPROTOTYPE:
            usMsgNum = IDS_WSAEPROTOTYPE;
            break;
        case WSAEOPNOTSUPP:
            usMsgNum = IDS_WSAEOPNOTSUPP;
            break;
        case WSAENETUNREACH:
            usMsgNum = IDS_WSAENETUNREACH;
            break;
        case WSAETOOMANYREFS:
            usMsgNum = IDS_WSAETOOMANYREFS;
            break;
        default:
            return(0);
    }

    if (hWinStrm == NULL)
	hWinStrm = GetModuleHandle( "winstrm" );

    if (!(msglen = FormatMessageW(
		       FORMAT_MESSAGE_FROM_HMODULE,
		       (LPVOID)hWinStrm,
		       usMsgNum,
		       0L,
		       perrW,
		       MAX_MSGTABLE,
		       NULL)))
        return(0);

    WideCharToMultiByte(CP_OEMCP,
                        0,
                        perrW,
                        -1,
                        perr,
                        sizeof(perr),
                        NULL,
                        NULL);
    
    fprintf(stderr, "-> %s:%s\n", yourmsg, perr);
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\streams\winstrm\s_putmsg.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    s_putmsg.c

Abstract:

    This module implements the STREAMS APIs, ioctl(I_FDINSERT) and
    putmsg().

Author:

    Eric Chin (ericc)           July 26, 1991

Revision History:

    Sam Patton (sampa)          August 13, 1991
                                changed errno to {get|set}lasterror

--*/
#include "common.h"


int
putmsg(
    IN HANDLE           fd,
    IN struct strbuf   *ctrlptr OPTIONAL,
    IN struct strbuf   *dataptr OPTIONAL,
    IN int              flags
    )

/*++

Routine Description:

    This function is called to send a STREAMS message downstream.

    This function is synchronous, in the NT sense: it blocks until the API
    completes.

Arguments:

    fd        - NT file handle
    ctrlptr   - pointer to the control portion of the STREAMS message
    dataptr   - pointer to the data portion of the STREAMS message
    flags     - 0 or RS_HIPRI

Return Value:

    0 if successful, -1 otherwise.

--*/

{
    char *tmp;
    int chunksz;
    NTSTATUS status;
    IO_STATUS_BLOCK iosb;
    PSTRM_ARGS_OUT oparm;
    PPUTMSG_ARGS_IN chunk;
    int retval;


    //
    // marshall the arguments into one contiguous chunk.  However, for
    // commonality with ioctl(I_FDINSERT), we arrange the input arguments
    // as below:
    //
    //  typedef struct _PUTMSG_ARGS_IN_ {
    //      int             a_iocode;           //  0
    //      long            a_flags;            //  0 | RS_HIPRI
    //      struct strbuf   a_ctlbuf;           //  (required)
    //      struct strbuf   a_databuf;          //  (required)
    //      HANDLE          a_insert.i_fildes;  //  -1
    //      int             a_offset;           //  0
    //      char            a_stuff[1];         //  s_ctlbuf.buf  (optional)
    //                                          //  s_databuf.buf (optional)
    //  } PUTMSG_ARGS_IN, *PPUTMSG_ARGS_IN;
    //
    //
    chunksz = sizeof(PUTMSG_ARGS_IN) - 1 +
                ((ctrlptr && (ctrlptr->len > 0)) ? ctrlptr->len : 0) +
                ((dataptr && (dataptr->len > 0)) ? dataptr->len : 0);

    if (!(chunk = (PPUTMSG_ARGS_IN) LocalAlloc(LMEM_FIXED, chunksz))) {
        SetLastError(ENOSPC);
        return(-1);
    }
    chunk->a_iocode = 0;
    chunk->a_flags  = (long) flags;

    tmp = (char *) chunk->a_stuff;

    if (ctrlptr && ctrlptr->buf && (ctrlptr->len >= 0)) {
        chunk->a_ctlbuf = *ctrlptr;                         // structure copy

        memcpy(tmp, ctrlptr->buf, ctrlptr->len);
        tmp += ctrlptr->len;
    }
    else {
        chunk->a_ctlbuf.len = -1;
    }

    if (dataptr && dataptr->buf && (dataptr->len >= 0)) {
        chunk->a_databuf = *dataptr;                        // structure copy

        memcpy(tmp, dataptr->buf, dataptr->len);
        tmp += dataptr->len;
    }
    else {
        chunk->a_databuf.len = -1;
    }
    chunk->a_insert.i_fildes = INVALID_HANDLE_VALUE;
    chunk->a_offset          = 0;

    ASSERT(chunksz >= sizeof(STRM_ARGS_OUT));

    status = NtDeviceIoControlFile(
        fd,                                     // Handle
        NULL,                                   // Event
        NULL,                                   // ApcRoutine
        NULL,                                   // ApcContext
        &iosb,                                  // IoStatusBlock
        IOCTL_STREAMS_PUTMSG,                   // IoControlCode
        (PVOID) chunk,                          // InputBuffer
        chunksz,                                // InputBufferSize
        (PVOID) chunk,                          // OutputBuffer
        chunksz);                               // OutputBufferSize

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
    }

    if (!NT_SUCCESS(status)) {
        LocalFree(chunk);
        SetLastError(MapNtToPosixStatus(status));
        return(-1);
    }

    //
    // the return parameters from the Stream Head Driver are laid out as:
    //
    //  typedef struct _STRM_ARGS_OUT_ {        // generic return parameters
    //      int     a_retval;                   //  return value
    //      int     a_errno;                    //  errno if retval == -1
    //
    //  } STRM_ARGS_OUT, *PSTRM_ARGS_OUT;
    //
    oparm  = (PSTRM_ARGS_OUT) chunk;

    if (oparm->a_retval == -1) {
        SetLastError(oparm->a_errno);
    }
    retval = oparm->a_retval;
    LocalFree(chunk);
    return(retval);

} // putmsg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\streams\winstrm\s_perror.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    s_perror.c

Abstract:

    This module implements the s_perror() operation used by the
    tcp/ip utilities. This is a temporary workaround for beta.
    This will be replaced by NLS support for the final product.

Author:

    John Ballard (jballard)           June 15, 1992

Revision History:

    Ronald Meijer (ronaldm) NLS Enabled 	Nov 26, 1992

--*/

#include <stdio.h>
#include <crt\errno.h>
#include <sock_err.h>

#include <winsock.h>
#include "nlstxt.h"
#define MAX_MSGTABLE 255

extern HMODULE hWinStrm;

extern int WSA_perror(
char *yourmsg,
int lerrno);

void
s_perror(
char *yourmsg,
int lerrno)
{
    WCHAR perrW[MAX_MSGTABLE+1];
    CHAR perr[MAX_MSGTABLE+1];
    unsigned msglen;
    unsigned usMsgNum;

    switch (lerrno) {
//        case EZERO:
//            perr = "Error 0";
//            break;
        case EPERM:
	    usMsgNum = IDS_EPERM ;
            break;
        case ENOENT:
	    usMsgNum = IDS_ENOENT ;
            break;
        case ESRCH:
	    usMsgNum = IDS_ESRCH ;
            break;
        case EINTR:
	    usMsgNum = IDS_EINTR ;
            break;
        case EIO:
	    usMsgNum = IDS_EIO ;
            break;
        case ENXIO:
	    usMsgNum = IDS_ENXIO ;
            break;
        case E2BIG:
	    usMsgNum = IDS_E2BIG ;
            break;
        case ENOEXEC:
	    usMsgNum = IDS_ENOEXEC ;
            break;
        case EBADF:
	    usMsgNum = IDS_EBADF ;
            break;
        case ECHILD:
	    usMsgNum = IDS_ECHILD ;
            break;
        case EAGAIN:
	    usMsgNum = IDS_EAGAIN ;
            break;
        case ENOMEM:
	    usMsgNum = IDS_ENOMEM ;
            break;
        case EACCES:
	    usMsgNum = IDS_EACCES ;
            break;
        case EFAULT:
	    usMsgNum = IDS_EFAULT ;
            break;
//        case ENOTBLK:
//	      perr = "Block device required";
//            break;
        case EBUSY:
	    usMsgNum = IDS_EBUSY ;
            break;
        case EEXIST:
	    usMsgNum = IDS_EEXIST ;
            break;
        case EXDEV:
	    usMsgNum = IDS_EXDEV ;
            break;
        case ENODEV:
	    usMsgNum = IDS_ENODEV ;
            break;
        case ENOTDIR:
	    usMsgNum = IDS_ENOTDIR ;
            break;
        case EISDIR:
	    usMsgNum = IDS_EISDIR ;
            break;
        case EINVAL:
	    usMsgNum = IDS_EINVAL ;
            break;
        case ENFILE:
	    usMsgNum = IDS_ENFILE ;
            break;
        case EMFILE:
	    usMsgNum = IDS_EMFILE ;
            break;
        case ENOTTY:
	    usMsgNum = IDS_EMFILE ;
            break;
//        case ETXTBSY:
//	      perr = "Text file busy";
//            break;
        case EFBIG:
	    usMsgNum = IDS_EFBIG ;
            break;
        case ENOSPC:
	    usMsgNum = IDS_ENOSPC ;
            break;
        case ESPIPE:
	    usMsgNum = IDS_ESPIPE ;
            break;
        case EROFS:
	    usMsgNum = IDS_EROFS ;
            break;
        case EMLINK:
	    usMsgNum = IDS_EMLINK ;
            break;
        case EPIPE:
	    usMsgNum = IDS_EPIPE ;
            break;
        case EDOM:
	    usMsgNum = IDS_EDOM ;
            break;
        case ERANGE:
	    usMsgNum = IDS_ERANGE ;
            break;
//        case EUCLEAN:
//	      perr = "File system not clean";
//            break;
        case EDEADLK:
	    usMsgNum = IDS_EDEADLK ;
            break;
        case ENOMSG:
	    usMsgNum = IDS_ENOMSG ;
            break;
        case EIDRM:
	    usMsgNum = IDS_EIDRM ;
            break;
        case ECHRNG:
	    usMsgNum = IDS_ECHRNG ;
            break;
        case EL2NSYNC:
	    usMsgNum = IDS_EL2NSYNC ;
            break;
        case EL3HLT:
	    usMsgNum = IDS_EL3HLT ;
            break;
        case EL3RST:
	    usMsgNum = IDS_EL3RST ;
            break;
        case ELNRNG:
	    usMsgNum = IDS_ELNRNG ;
            break;
        case EUNATCH:
	    usMsgNum = IDS_EUNATCH ;
            break;
        case ENOCSI:
	    usMsgNum = IDS_ENOCSI ;
            break;
        case EL2HLT:
	    usMsgNum = IDS_EL2HLT ;
            break;
        case EBADE:
	    usMsgNum = IDS_EBADE ;
            break;
        case EBADR:
	    usMsgNum = IDS_EBADR ;
            break;
        case EXFULL:
	    usMsgNum = IDS_EXFULL ;
            break;
        case ENOANO:
	    usMsgNum = IDS_ENOANO ;
            break;
        case EBADRQC:
	    usMsgNum = IDS_EBADRQC ;
            break;
        case EBADSLT:
	    usMsgNum = IDS_EBADSLT ;
            break;
        case EBFONT:
	    usMsgNum = IDS_EBFONT ;
            break;
        case ENOSTR:
	    usMsgNum = IDS_ENOSTR ;
            break;
        case ENODATA:
	    usMsgNum = IDS_ENODATA ;
            break;
        case ETIME:
	    usMsgNum = IDS_ETIME ;
            break;
        case ENOSR:
	    usMsgNum = IDS_ENOSR ;
            break;
        case ENONET:
	    usMsgNum = IDS_ENONET ;
            break;
        case ENOPKG:
	    usMsgNum = IDS_ENOPKG ;
            break;
        case EREMOTE:
	    usMsgNum = IDS_EREMOTE ;
            break;
        case ENOLINK:
	    usMsgNum = IDS_ENOLINK ;
            break;
        case EADV:
	    usMsgNum = IDS_EADV ;
            break;
        case ESRMNT:
	    usMsgNum = IDS_ESRMNT ;
            break;
        case ECOMM:
	    usMsgNum = IDS_ECOMM ;
            break;
        case EPROTO:
	    usMsgNum = IDS_EPROTO ;
            break;
        case EMULTIHOP:
	    usMsgNum = IDS_EMULTIHOP ;
            break;
        case ELBIN:
	    usMsgNum = IDS_ELBIN ;
            break;
        case EDOTDOT:
	    usMsgNum = IDS_EDOTDOT ;
            break;
        case EBADMSG:
	    usMsgNum = IDS_EBADMSG ;
            break;
        case ENOTUNIQ:
	    usMsgNum = IDS_ENOTUNIQ ;
            break;
        case EREMCHG:
	    usMsgNum = IDS_EREMCHG ;
            break;
        case ELIBACC:
	    usMsgNum = IDS_ELIBACC;
            break;
        case ELIBBAD:
	    usMsgNum = IDS_ELIBBAD ;
            break;
        case ELIBSCN:
	    usMsgNum = IDS_ELIBSCN ;
            break;
        case ELIBMAX:
	    usMsgNum = IDS_ELIBMAX ;
            break;
        case ELIBEXEC:
	    usMsgNum = IDS_ELIBEXEC ;
            break;
        case ENOTSOCK:
	    usMsgNum = IDS_ENOTSOCK ;
            break;
        case EADDRNOTAVAIL:
	    usMsgNum = IDS_EADDRNOTAVAIL ;
            break;
        case EADDRINUSE:
	    usMsgNum = IDS_EADDRINUSE ;
            break;
        case EAFNOSUPPORT:
	    usMsgNum = IDS_EAFNOSUPPORT ;
            break;
        case ESOCKTNOSUPPORT:
	    usMsgNum = IDS_ESOCKTNOSUPPORT ;
            break;
        case EPROTONOSUPPORT:
	    usMsgNum = IDS_EPROTONOSUPPORT ;
            break;
        case ENOBUFS:
	    usMsgNum = IDS_ENOBUFS ;
            break;
        case ETIMEDOUT:
	    usMsgNum = IDS_ETIMEDOUT ;
            break;
        case EISCONN:
	    usMsgNum = IDS_EISCONN ;
            break;
        case ENOTCONN:
	    usMsgNum = IDS_ENOTCONN ;
            break;
        case ENOPROTOOPT:
	    usMsgNum = IDS_ENOPROTOOPT ;
            break;
        case ECONNRESET:
	    usMsgNum = IDS_ECONNRESET ;
            break;
        case ECONNABORT:
	    usMsgNum = IDS_ECONNABORT ;
            break;
        case ENETDOWN:
	    usMsgNum = IDS_ENETDOWN ;
            break;
        case ECONNREFUSED:
	    usMsgNum = IDS_ECONNREFUSED ;
            break;
        case EHOSTUNREACH:
	    usMsgNum = IDS_EHOSTUNREACH ;
            break;
        case EPROTOTYPE:
	    usMsgNum = IDS_EPROTOTYPE ;
            break;
        case EOPNOTSUPP:
	    usMsgNum = IDS_EOPNOTSUPP ;
            break;
        case ESUBNET:
	    usMsgNum = IDS_ESUBNET ;
            break;
        case ENETNOLNK:
	    usMsgNum = IDS_ENETNOLNK ;
            break;
        case EBADIOCTL:
	    usMsgNum = IDS_EBADIOCTL ;
            break;
        case ERESOURCE:
	    usMsgNum = IDS_ERESOURCE ;
            break;
        case EPROTUNR:
	    usMsgNum = IDS_EPROTUNR ;
            break;
        case EPORTUNR:
	    usMsgNum = IDS_EPORTUNR ;
            break;
        case ENETUNR:
	    usMsgNum = IDS_ENETUNR ;
            break;
        case EPACKET:
	    usMsgNum = IDS_EPACKET ;
            break;
        case ETYPEREG:
	    usMsgNum = IDS_ETYPEREG ;
            break;
        case ENOTINIT:
	    usMsgNum = IDS_ENOTINIT ;
            break;
        default:
            if (WSA_perror(yourmsg, lerrno)) {
                return;
            }
	    usMsgNum = IDS_UNKNOWN ;
            break;
    }

    if (hWinStrm == NULL)
	hWinStrm = GetModuleHandle( "winstrm" );

    if (!(msglen = FormatMessageW(
		       FORMAT_MESSAGE_FROM_HMODULE,
		       (LPVOID)hWinStrm,
		       usMsgNum,
		       0L,
		       perrW,
		       MAX_MSGTABLE,
		       NULL)))
	return;

    WideCharToMultiByte(CP_OEMCP,
                        0,
                        perrW,
                        -1,
                        perr,
                        sizeof(perr),
                        NULL,
                        NULL);

    fprintf(stderr, "> %s:%s\n", yourmsg, perr);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\admin\dll\tsec.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    tsec.c

Abstract:

    A sample administration DLL

Author:



Revision History:

--*/


#include <windows.h>
#include <tapi.h>
#include <tapclntp.h>  // private\inc\tapclntp.h
#include <tlnklist.h>
#include "tsec.h"

HINSTANCE               ghInst;
LIST_ENTRY              gClientListHead;
CRITICAL_SECTION        gCritSec;
DEVICECHANGECALLBACK    glpfnLineChangeCallback = NULL;
DEVICECHANGECALLBACK    glpfnPhoneChangeCallback = NULL;


void
FreeClient(
    PMYCLIENT pClient
    );

BOOL
WINAPI
DllMain(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
#if DBG
        gdwDebugLevel = 0;
#endif

        DBGOUT((2, "DLL_PROCESS_ATTACH"));

        ghInst = hDLL;

        InitializeCriticalSection (&gCritSec);

        InitializeListHead (&gClientListHead);

        break;
    }
    case DLL_PROCESS_DETACH:
    {
         PMYCLIENT  pClient;


        //
        // Clean up client list (no need to enter crit sec since
        // process detaching)
        //

        while (!IsListEmpty (&gClientListHead))
        {
            LIST_ENTRY *pEntry = RemoveHeadList (&gClientListHead);


            pClient = CONTAINING_RECORD (pEntry, MYCLIENT, ListEntry);

            FreeClient(pClient);
        }

        DeleteCriticalSection (&gCritSec);

        break;
    }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        break;

    } // switch

    return TRUE;
}


void
FreeClient(
    PMYCLIENT pClient
    )
{
    GlobalFree (pClient->pszUserName);
    GlobalFree (pClient->pszDomainName);
    GlobalFree (pClient->pLineDeviceMap);
    GlobalFree (pClient->pPhoneDeviceMap);

    GlobalFree (pClient);

}


LONG
GetAndParseAMapping(
    LPCWSTR             pszFullName,
    LPCWSTR             pszType,
    LPTAPIPERMANENTID  *ppDevices,
    LPDWORD             pdwDevices
    )
{
    LPWSTR      pszDevices = NULL, pszHold1, pszHold2;
    DWORD       dwSize, dwReturn, dwDevices;
    DWORD       dwPermanentDeviceID;
    BOOL        bBreak = FALSE;


    dwSize = MAXDEVICESTRINGLEN;


    // get the string

    do
    {
        if (pszDevices != NULL)
        {
            dwSize *= 2;

            GlobalFree (pszDevices);
        }

        pszDevices = (LPWSTR) GlobalAlloc (GPTR, dwSize * sizeof(WCHAR));

        if (!pszDevices)
        {
            return LINEERR_NOMEM;
        }

        dwReturn = GetPrivateProfileString(
            pszFullName,
            pszType,
            SZEMPTYSTRING,
            pszDevices,
            dwSize,
            SZINIFILE
            );

        if (dwReturn == 0)
        {
            // valid case.  the user has no
            // devices, so just return 0

            GlobalFree(pszDevices);

            *pdwDevices = 0;
            *ppDevices = NULL;

            return 0;
        }

    } while (dwReturn == (dwSize - 1));


    // parse the string
    //
    // the string looks line px, x, py, y,pz, z where x,y and z are
    // tapi permanent device IDs, and px, py, and pz are the
    // permanent provider IDs for the corresponding devices.

    pszHold1 = pszDevices;
    dwDevices = 0;

    // first, count the ,s so we know how many devices there are

    while (*pszHold1 != L'\0')
    {
        if (*pszHold1 == L',')
        {
            dwDevices++;
        }
        pszHold1++;
    }

    dwDevices++;

    dwDevices /= 2;

    // alloc line mapping, this is freed later

    *ppDevices = (LPTAPIPERMANENTID) GlobalAlloc(
        GPTR,
        dwDevices * sizeof ( TAPIPERMANENTID )
        );

    if (!*ppDevices)
    {
        GlobalFree (pszDevices);
        return LINEERR_NOMEM;
    }


    pszHold1 = pszHold2 = pszDevices;
    dwDevices = 0;

    // go through string

    while (TRUE)
    {

        // wait for ,

        while ((*pszHold2 != L'\0') && *pszHold2 != L',')
        {
            pszHold2++;
        }

        if (*pszHold2 == L',')
            *pszHold2 = L'\0';
        else
        {
            bBreak = TRUE;
        }

        // save the id

        (*ppDevices)[dwDevices].dwProviderID = _wtol(pszHold1);

        // if we hit the end, break out
        // note here that this is an unmatched provider id
        // but we have inc'ed the dwdevices, so this element will be ignored

        if (bBreak)
        {
            break;
        }

        pszHold2++;
        pszHold1 = pszHold2;

        // wait for ,

        while ((*pszHold2 != L'\0') && *pszHold2 != L',')
        {
            pszHold2++;
        }

        if (*pszHold2 == L',')
        {
            *pszHold2 = L'\0';
        }
        else
        {
            bBreak = TRUE;
        }

        // save the id

        (*ppDevices)[dwDevices].dwDeviceID = _wtol(pszHold1);

        dwDevices++;

        // if we hit the end, break out

        if (bBreak)
        {
            break;
        }

        pszHold2++;
        pszHold1 = pszHold2;
    }


    *pdwDevices = dwDevices;

    GlobalFree(pszDevices);

    return 0;   // success
}


LONG
GetMappings(
    LPCWSTR             pszDomainName,
    LPCWSTR             pszUserName,
    LPTAPIPERMANENTID  *ppLineMapping,
    LPDWORD             pdwLines,
    LPTAPIPERMANENTID  *ppPhoneMapping,
    LPDWORD             pdwPhones
    )
{
    LPWSTR      pszFullName;
    DWORD       dwSize;
    LONG        lResult;


    // put the username and domain name together
    // for a full name:  domain\user
    // in the " + 2"  1 is for \ and 1 is for null terminator

    pszFullName = (LPWSTR)GlobalAlloc(
        GPTR,
        ( lstrlen(pszDomainName) + lstrlen(pszUserName) + 2 ) * sizeof(WCHAR)
        );

    if (!pszFullName)
    {
        return LINEERR_NOMEM;
    }

    // put them together

    wsprintf(
        pszFullName,
        L"%s\\%s",
        pszDomainName,
        pszUserName
        );

    if (lResult = GetAndParseAMapping(
            pszFullName,
            SZLINES,
            ppLineMapping,
            pdwLines
            ))
    {
        GlobalFree(pszFullName);
        return lResult;
    }

    if (lResult = GetAndParseAMapping(
            pszFullName,
            SZPHONES,
            ppPhoneMapping,
            pdwPhones
            ))
    {
        if (NULL != ppLineMapping)
        {
            GlobalFree (*ppLineMapping);
        }
        GlobalFree (pszFullName);
        return lResult;
    }

    GlobalFree(pszFullName);

    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_Load(
    LPDWORD                 pdwAPIVersion,
    DEVICECHANGECALLBACK    lpfnLineChangeCallback,
    DEVICECHANGECALLBACK    lpfnPhoneChangeCallback,
    DWORD                   Reserved
    )
{
    if (*pdwAPIVersion > TAPI_CURRENT_VERSION)
    {
        *pdwAPIVersion = TAPI_CURRENT_VERSION;
    }

    glpfnLineChangeCallback = lpfnLineChangeCallback;
    glpfnPhoneChangeCallback = lpfnPhoneChangeCallback;

    return 0;
}


void
CLIENTAPI
TAPICLIENT_Free(
    void
    )
{
    return;
}


LONG
CLIENTAPI
TAPICLIENT_ClientInitialize(
    LPCWSTR             pszDomainName,
    LPCWSTR             pszUserName,
    LPCWSTR             pszMachineName,
    LPHMANAGEMENTCLIENT phmClient
    )
{
    PMYCLIENT           pNewClient;
    LPTAPIPERMANENTID   pLineMapping, pPhoneMapping;
    DWORD               dwNumLines, dwNumPhones;
    LONG                lResult;


    // first, get the device mappings
    // if this fails, most likely the user
    // has access to no lines

    if (lResult = GetMappings(
            pszDomainName,
            pszUserName,
            &pLineMapping,
            &dwNumLines,
            &pPhoneMapping,
            &dwNumPhones
            ))
    {
        return lResult;
    }

    // alloc a client structure

    pNewClient = (PMYCLIENT) GlobalAlloc (GPTR, sizeof(MYCLIENT));

    if (!pNewClient)
    {
        return LINEERR_NOMEM;
    }

    // alloc space for the name

    pNewClient->pszUserName = (LPWSTR) GlobalAlloc(
        GPTR,
        (lstrlen(pszUserName) + 1) * sizeof(WCHAR)
        );
    if (!pNewClient->pszUserName)
    {
        GlobalFree(pNewClient);
        return LINEERR_NOMEM;
    }

    pNewClient->pszDomainName = (LPWSTR) GlobalAlloc(
        GPTR,
        (lstrlen(pszDomainName) +1) * sizeof(WCHAR)
        );
    if (!pNewClient->pszDomainName)
    {
        GlobalFree(pNewClient->pszUserName);
        GlobalFree(pNewClient);
        return LINEERR_NOMEM;
    }

    // initialize stuff

    lstrcpy (pNewClient->pszUserName, pszUserName);

    lstrcpy (pNewClient->pszDomainName, pszDomainName);

    pNewClient->pLineDeviceMap = pLineMapping;
    pNewClient->pPhoneDeviceMap = pPhoneMapping;
    pNewClient->dwNumLines = dwNumLines;
    pNewClient->dwNumPhones = dwNumPhones;
    pNewClient->dwKey = TSECCLIENT_KEY;

    // insert into list of clients

    EnterCriticalSection (&gCritSec);

    InsertHeadList (&gClientListHead, &pNewClient->ListEntry);

    LeaveCriticalSection (&gCritSec);

    // give TAPI the hmClient

    *phmClient = (HMANAGEMENTCLIENT)pNewClient;

    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_ClientShutdown(
    HMANAGEMENTCLIENT   hmClient
    )
{
    PMYCLIENT   pClient;


    pClient = (PMYCLIENT) hmClient;

    EnterCriticalSection (&gCritSec);

    try
    {
        if (pClient->dwKey == TSECCLIENT_KEY)
        {
            pClient->dwKey = 0;
            RemoveEntryList (&pClient->ListEntry);
        }
        else
        {
            pClient = NULL;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        pClient = NULL;
    }

    LeaveCriticalSection (&gCritSec);

    if (pClient)
    {
        FreeClient (pClient);
    }

    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_GetDeviceAccess(
    HMANAGEMENTCLIENT   hmClient,
    HTAPICLIENT         htClient,
    LPTAPIPERMANENTID   pLineDeviceMap,
    PDWORD              pdwLineDevices,
    LPTAPIPERMANENTID   pPhoneDeviceMap,
    PDWORD              pdwPhoneDevices
    )
{
    LONG        lResult;
    PMYCLIENT   pClient = (PMYCLIENT) hmClient;


    EnterCriticalSection (&gCritSec);

    try
    {
        if (pClient->dwKey != TSECCLIENT_KEY)
        {
            pClient = NULL;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        pClient = NULL;
    }

    if (pClient)
    {
        // would need to critical section this stuff
        // if we added devices dynamically

        if (*pdwLineDevices < pClient->dwNumLines)
        {
            *pdwLineDevices = pClient->dwNumLines;

            lResult = LINEERR_STRUCTURETOOSMALL;
            goto LeaveCritSec;
        }

        CopyMemory(
            pLineDeviceMap,
            pClient->pLineDeviceMap,
            pClient->dwNumLines * sizeof( TAPIPERMANENTID )
            );

        *pdwLineDevices = pClient->dwNumLines;

        if (*pdwPhoneDevices < pClient->dwNumPhones)
        {
            *pdwPhoneDevices = pClient->dwNumPhones;

            lResult = LINEERR_STRUCTURETOOSMALL;
            goto LeaveCritSec;
        }

        CopyMemory(
            pPhoneDeviceMap,
            pClient->pPhoneDeviceMap,
            pClient->dwNumPhones * sizeof( TAPIPERMANENTID )
            );

        *pdwPhoneDevices = pClient->dwNumPhones;

        pClient->htClient = htClient;

        lResult = 0;
    }
    else
    {
        lResult = LINEERR_INVALPOINTER;
    }

LeaveCritSec:

    LeaveCriticalSection (&gCritSec);

    return lResult;
}


LONG
CLIENTAPI
TAPICLIENT_LineAddToConference(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPLINECALLINFO      lpConsultCallCallInfo
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineBlindTransfer(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPWSTR              lpszDestAddress,
    LPDWORD             lpdwSize,
    LPDWORD             pdwCountryCodeOut
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineConfigDialog(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPCWSTR             lpszDeviceClass
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineDial(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               Reserved,
    LPWSTR              lpszDestAddressIn,
    LPDWORD             pdwSize,
    LPDWORD             pdwCountyCode
   )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineForward(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPLINEFORWARDLIST   lpFowardListIn,
    LPDWORD             pdwSize,
    LPLINECALLPARAMS    lpCallParamsIn,
    LPDWORD             pdwParamsSize
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineGenerateDigits(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               Reserved,
    LPCWSTR             lpszDigits
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineMakeCall(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwReserved,
    LPWSTR              lpszDestAddress,
    LPDWORD             pdwSize,
    LPDWORD             pdwCountryCode,
    LPLINECALLPARAMS    lpCallParams,
    LPDWORD             pdwCallParamsSize
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineOpen(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    lpCallParamsIn,
    LPDWORD             pdwParamsSize
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineRedirect(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPWSTR              lpszDestAddress,
    LPDWORD             pdwSize,
    LPDWORD             pdwCountryCode
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetCallData(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPVOID              lpCallData,
    LPDWORD             pdwSize
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetCallParams(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwBearerMode,
    DWORD               dwMinRate,
    DWORD               dwMaxRate,
    LPLINEDIALPARAMS    lpDialParams
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetCallPrivilege(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwCallPrivilege
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetCallTreatment(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwCallTreatment
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetCurrentLocation(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPDWORD             dwLocation
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetDevConfig(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPVOID              lpDevConfig,
    LPDWORD             pdwSize,
    LPCWSTR             lpszDeviceClass
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetLineDevStatus(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwStatusToChange,
    DWORD               fStatus
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetMediaControl(
    HMANAGEMENTCLIENT           hmClient,
    LPTAPIPERMANENTID           pID,
    LPLINEMEDIACONTROLDIGIT     const lpDigitList,
    DWORD                       dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA     const lpMediaList,
    DWORD                       dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE      const lpToneList,
    DWORD                       dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE const lpCallstateList,
    DWORD                       dwCallstateNumEntries
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetMediaMode(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwMediaModes
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetTerminal(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwTerminalModes,
    DWORD               dwTerminalID,
    BOOL                bEnable
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_LineSetTollList(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPCWSTR             lpszAddressIn,
    DWORD               dwTollListOption
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_PhoneConfigDialog(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    LPCWSTR             lpszDeviceClass
    )
{
    return 0;
}


LONG
CLIENTAPI
TAPICLIENT_PhoneOpen(
    HMANAGEMENTCLIENT   hmClient,
    LPTAPIPERMANENTID   pID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwPrivilege
    )
{
    return LINEERR_OPERATIONFAILED;
}



#if DBG
VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PUCHAR lpszFormat,
    IN ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
    if (dwDbgLevel <= gdwDebugLevel)
    {
        char    buf[128] = "TSEC: ";
        va_list ap;


        va_start(ap, lpszFormat);
        wvsprintfA (&buf[6], lpszFormat, ap);
        lstrcatA (buf, "\n");
        OutputDebugStringA (buf);
        va_end(ap);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\admin\dll\tsec.h ===
#include <windows.h>
#include "tapiclnt.h"

#define SZTELEPHONYKEY          L"\\Software\\Microsoft\\Windows\\CurrentVersion\\Telephony"

#define SZINIFILE               L"..\\TAPI\\TSEC.INI"
#define SZLINES                 L"LINES"
#define SZPHONES                L"PHONES"
#define SZEMPTYSTRING           L""
#define MAXDEVICESTRINGLEN      1000
#define TSECCLIENT_KEY          ((DWORD) 'ilCT')


typedef struct _MYCLIENT
{
    DWORD                   dwKey;
    LPWSTR                  pszUserName;
    LPWSTR                  pszDomainName;
    LPTAPIPERMANENTID       pLineDeviceMap;
    DWORD                   dwNumLines;
    LPTAPIPERMANENTID       pPhoneDeviceMap;
    DWORD                   dwNumPhones;
    HTAPICLIENT             htClient;
    LIST_ENTRY              ListEntry;

} MYCLIENT, * PMYCLIENT;



#if DBG
DWORD gdwDebugLevel = 0;
#define DBGOUT(arg) DbgPrt arg

VOID
DbgPrt(
       IN DWORD  dwDbgLevel,
       IN PUCHAR DbgMessage,
       IN ...
      );

#else
#define DBGOUT(arg)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\admin\setup\resource.h ===
//
#define IDD_DIALOG1                     101
#define IDC_NAME                        1000
#define IDC_PASSWORD                    1001
#define IDC_DISABLE                     1002
#define IDC_MAPPER                      1003
#define IDC_DLLS                        1004
#define IDC_DOMAIN                      1005
#define IDC_STATIC                      -1

#define iszMustBeAdmin                  4000
#define iszNotRunningServer             4001
#define iszRegOpenKeyFailed             4002
#define iszRegSetValueFailed            4003
#define iszOpenThreadTokenFailed        4004
#define iszGetTokenInfoFailed           4005
#define iszAllocateAndInitializeSidFailed   4006
#define iszUserNotAdmin                 4007
#define iszOpenSCManagerFailed          4009
#define iszServerDisabled               4011
#define iszServerSetup                  4012
#define iszNotClient                    4013
#define iszClientDisabled               4014
#define iszClientSetup                  4015
#define iszTapiAdminSetup               4016
#define iszChangeServerConfigFailed     4017
#define iszHelp0                        4018
#define iszHelp1                        4019
#define iszHelp2                        4020
#define iszHelp3                        4021
#define iszHelp4                        4022
#define iszHelp5                        4023
#define iszHelp6                        4024
#define iszHelp7                        4025
#define iszHelp8                        4026
#define iszHelp9                        4027
#define iszHelp10                       4028
#define iszHelpTitle                    4029
#define iszServerDisabledFailure        4030
#define iszServerSetupFailure           4031
#define iszClientDisabledFailure        4032
#define iszClientSetupFailure           4033
#define iszNoPasswordSupplied           4034
#define iszNoMapperSupplied             4035
#define iszUserNotAnAdmin				4036
#define iszOpenPolicyFailed  			4037
#define iszSetPrivilegeOnAccount		4038
#define iszRegWriteFailed				4039
#define iszOpenServiceFailed			4040
#define iszCreateMutexFailed            4041
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\admin\setup\admin.c ===
#include <windows.h>
#include <stdio.h>
#include <lm.h>
#include "resource.h"
#include <tapi.h>

#include "ntsecapi.h"

HINSTANCE       ghInstance;
HWND            ghWnd;
BOOLEAN         gfQuietMode = FALSE;
DWORD           gdwNoDSQuery = 0;
DWORD           gdwConnectionOrientedOnly = 0;

const TCHAR gszProductType[] = TEXT("ProductType");
const TCHAR gszProductTypeServer[] = TEXT("ServerNT");
const TCHAR gszProductTypeLanmanNt[] = TEXT("LANMANNT");
const TCHAR gszRegKeyNTServer[] = TEXT("System\\CurrentControlSet\\Control\\ProductOptions");
const TCHAR gszRegKeyProviders[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Providers");
const TCHAR gszRegKeyTelephony[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony");
const TCHAR gszProviderID[] = TEXT("ProviderID");
const TCHAR gszNumProviders[] = TEXT("NumProviders");
const TCHAR gszNextProviderID[] = TEXT("NextProviderID");
const TCHAR gszProviderFilename[] = TEXT("ProviderFilename");
const TCHAR gszRemoteSP[] = TEXT("RemoteSP.TSP");
const TCHAR gszProvider[] = TEXT("Provider");
const TCHAR gszServer[] = TEXT("Server");
const TCHAR gszNumServers[] = TEXT("NumServers");
const TCHAR gszConnectionOrientedOnly[] = TEXT("ConnectionOrientedOnly");
const TCHAR gszNoDSQuery[] = TEXT("NoDSQuery");

#define MAXERRORTEXTLEN         512

TCHAR gszTapiAdminSetup[MAXERRORTEXTLEN];

LPTSTR glpszFullName = NULL;
LPTSTR glpszPassword= NULL;
LPTSTR glpszMapper = NULL;
LPTSTR glpszDllList = NULL;
LPTSTR glpszRemoteServer = NULL;

BOOL
CALLBACK
DlgProc(
        HWND hwndDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam 
       );

BOOL
IsAdministrator(
               );

BOOL
DoServer(
         LPTSTR lpszServerLine
        );

BOOL
DoClient(
         LPTSTR lpszClientLine
        );


//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
UINT TAPIstrlen( const TCHAR *p )
{
    UINT nLength = 0;
    
    while ( *p )
    {
        nLength++;
        p++;
    }
    
    return nLength;
}


//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
void TAPIstrcat( TCHAR *p1,  const TCHAR *p2 )
{
    while ( *p1 )
    {
        p1++;
    }
    
    while ( *p2 )
    {
        *p1 = *p2;
        p1++;
        p2++;
    }
    
    return;
}


//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
void
ErrorStr(
         int iMsg
        )
{
    TCHAR       szError[MAXERRORTEXTLEN];

    
    if ( !gfQuietMode )
    {
        if (LoadString(
                       ghInstance,
                       iMsg,
                       szError,
                       MAXERRORTEXTLEN
                      ))
        {
        
            MessageBox(
                       NULL,
                       szError,
                       gszTapiAdminSetup,
                       MB_OK
                      );
        }
    }
    
}

void
ShowHelp()
{
    TCHAR           szError[MAXERRORTEXTLEN];
    LPTSTR          szBuffer;

    if (gfQuietMode)
    {
        return;
    }
    
    szBuffer = (LPTSTR)GlobalAlloc(
                                   GPTR,
                                   11 * MAXERRORTEXTLEN * sizeof(TCHAR)
                                  );

    if (!szBuffer)
    {
        return;
    }

    LoadString(
                   ghInstance,
                   iszHelp0,
                   szBuffer,
                   MAXERRORTEXTLEN
                  );
                  
    if (LoadString(
                   ghInstance,
                   iszHelp1,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }
    
    if (LoadString(
                   ghInstance,
                   iszHelp2,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }
    
    if (LoadString(
                   ghInstance,
                   iszHelp3,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }
    
    if (LoadString(
                   ghInstance,
                   iszHelp4,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }
    
    if (LoadString(
                   ghInstance,
                   iszHelp5,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }
    
    if (LoadString(
                   ghInstance,
                   iszHelp6,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }
    
    if (LoadString(
                   ghInstance,
                   iszHelp7,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }
    
    if (LoadString(
                   ghInstance,
                   iszHelp8,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }
    
    if (LoadString(
                   ghInstance,
                   iszHelp9,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }

    if (LoadString(
                   ghInstance,
                   iszHelp10,
                   szError,
                   MAXERRORTEXTLEN
                  ))
    {
        TAPIstrcat(
               szBuffer,
               szError
              );
    }

    LoadString(
               ghInstance,
               iszHelpTitle,
               szError,
               MAXERRORTEXTLEN
              );

    MessageBox(
               NULL,
               szBuffer,
               szError,
               MB_OK
              );

    GlobalFree (szBuffer);
}
               
LPTSTR
GetNextString(
              LPTSTR lpszIn
             )
{
    static LPTSTR      lpszLine;
    LPTSTR             lpszReturn = NULL;

    if (lpszIn)
        lpszLine = lpszIn;
    
    while (*lpszLine && (*lpszLine == L' ' || *lpszLine == L'\t'))
           lpszLine++;

    if (!*lpszLine)
        return NULL;

    lpszReturn = lpszLine;
    
    while (*lpszLine && (*lpszLine != L' ' && *lpszLine != L'\t'))
           lpszLine++;


    if (*lpszLine)
    {
        *lpszLine = '\0';
        lpszLine++;
    }

    return lpszReturn;
}


BOOL
ParseCommandLine(
                 LPTSTR lpszCommandLine
                )
{
    BOOL    bRet = FALSE;

    //
    //  Skip the first segment which is the executable itself
    //  it is either in double quotes or a string until a white
    //  space
    //
    
    if (*lpszCommandLine == TEXT('\"'))
    {
        ++lpszCommandLine;
        while (*lpszCommandLine &&
            *lpszCommandLine != TEXT('\"'))
        {
            ++lpszCommandLine;
        }
        if (*lpszCommandLine == TEXT('\"'))
        {
            ++lpszCommandLine;
        }
    }
    else
    {
        while (
            *lpszCommandLine  &&
            *lpszCommandLine != TEXT(' ') &&
            *lpszCommandLine != TEXT('\t') &&
            *lpszCommandLine != 0x0a &&
            *lpszCommandLine != 0x0d)
        {
            ++lpszCommandLine;
        }
    }

    while (*lpszCommandLine)
    {
        //
        //  Search for / or - as the start of option
        //
        while (*lpszCommandLine == TEXT(' ') ||
            *lpszCommandLine == TEXT('\t') ||
            *lpszCommandLine == 0x0a ||
            *lpszCommandLine == 0x0d)
        {
            lpszCommandLine++;
        }

        if (*lpszCommandLine != TEXT('/') &&
            *lpszCommandLine != TEXT('-'))
        {
            break;
        }
        ++lpszCommandLine;
        
        if ( (L'r' == *lpszCommandLine) ||
             (L'R' == *lpszCommandLine)
           )
        {
            ++lpszCommandLine;
            if (*lpszCommandLine == TEXT(' ') ||
                *lpszCommandLine == TEXT('\t') ||
                *lpszCommandLine == 0x0a ||
                *lpszCommandLine == 0x0d)
            {
                gdwNoDSQuery = (DWORD) TRUE;
            }
            else
            {
                break;
            }
        }
        else if ( (L'q' == *lpszCommandLine) ||
            (L'Q' == *lpszCommandLine))
        {
            ++lpszCommandLine;
            if (*lpszCommandLine == TEXT(' ') ||
                *lpszCommandLine == TEXT('\t') ||
                *lpszCommandLine == 0x0a ||
                *lpszCommandLine == 0x0d)
            {
                gfQuietMode = TRUE;
            }
            else
            {
                break;
            }
        }
        else if ((L'x' == *lpszCommandLine) ||
            (L'X' == *lpszCommandLine))
        {
            ++lpszCommandLine;
            if (*lpszCommandLine == TEXT(' ') ||
                *lpszCommandLine == TEXT('\t') ||
                *lpszCommandLine == 0x0a ||
                *lpszCommandLine == 0x0d)
            {
                gdwConnectionOrientedOnly = 1;
            }
            else
            {
                break;
            }
        }
        else if ((L'c' == *lpszCommandLine) ||
            (L'C' == *lpszCommandLine))
        {
            ++lpszCommandLine;
            if (*lpszCommandLine == TEXT(' ') ||
                *lpszCommandLine == TEXT('\t') ||
                *lpszCommandLine == 0x0a ||
                *lpszCommandLine == 0x0d)
            {
                bRet = DoClient(++lpszCommandLine);
            }
            break;
        }
        else
        {
            break;
        }
    }

    return bRet;
}


int WINAPI WinMain (HINSTANCE hInstance,
                    HINSTANCE hPrevInstance,
                    LPSTR     lpszCmdLine,
                    int       nCmdShow)
{
    LPTSTR lpszCommandLine;

    ghInstance = GetModuleHandle( NULL );

    LoadString(
               ghInstance,
               iszTapiAdminSetup,
               gszTapiAdminSetup,
               MAXERRORTEXTLEN
              );
    
    if (!IsAdministrator())
    {
        ErrorStr(iszMustBeAdmin);

        return 1;
    }

    lpszCommandLine = GetCommandLine();

    if (!lpszCommandLine)
    {
        return 2;
    }

    if (!(ParseCommandLine(
                           lpszCommandLine
                          )))
    {
        ShowHelp();
    }

    return 0;
}

BOOL
IsServer()
{
    HKEY    hKey;
    DWORD   dwDataSize;
    DWORD   dwDataType;
    TCHAR   szProductType[64];


    // check to see if this is running on NT Server
    // if so, enable the telephony server stuff
    if (ERROR_SUCCESS !=
        RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 gszRegKeyNTServer,
                 0,
                 KEY_ALL_ACCESS,
                 &hKey
                ))
    {
        return FALSE;
    }

    dwDataSize = 64;
    RegQueryValueEx(
                    hKey,
                    gszProductType,
                    0,
                    &dwDataType,
                    (LPBYTE) szProductType,
                    &dwDataSize
                   );

    RegCloseKey(
                hKey
               );

    if ((!lstrcmpi(
                  szProductType,
                  gszProductTypeServer
                 ))
        ||
        (!lstrcmpi(
                   szProductType,
                   gszProductTypeLanmanNt
                  )))
            
    {
        return TRUE;
    }

    ErrorStr(iszNotRunningServer);

    return FALSE;
}

////////////////////////////////////////////////////////////////////
//
//  Set the disableserver key to true
//
BOOL
DisableServer()
{
    HKEY        hKeyTelephony, hKey;
    DWORD       dw;
    BOOL        bRet = TRUE;

    if (RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      gszRegKeyTelephony,
                      0,
                      KEY_ALL_ACCESS,
                      &hKeyTelephony
                     ) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    if (RegCreateKeyEx(
                        hKeyTelephony,
                        TEXT("Server"),
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dw
                       ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyTelephony);
        return FALSE;
    }
        
    
    dw=1;
    
    if (RegSetValueEx(
                      hKey,
                      TEXT("DisableSharing"),
                      0,
                      REG_DWORD,
                      (LPBYTE)&dw,
                      sizeof(dw)
                     ) != ERROR_SUCCESS)
    {
        bRet = FALSE;
    }

    RegCloseKey(hKey);
    RegCloseKey(hKeyTelephony);

    return bRet;
}

//////////////////////////////////////////////////////////
//
// Determine if the currently logged on person is an admin
//
BOOL
IsAdministrator(
    )
{
    PSID                        psidAdministrators;
    BOOL                        bResult = FALSE;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;


    if (AllocateAndInitializeSid(
            &siaNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &psidAdministrators
            ))
    {
        CheckTokenMembership (NULL, psidAdministrators, &bResult);

        FreeSid (psidAdministrators);
    }

    return bResult;
}


////////////////////////////////////////////////////////////////////
//
//  Determine the name of 'Administrators' group
//
BOOL LookupAdministratorsAlias( 
                               LPWSTR Name,
                               PDWORD cchName
                              )

{ 
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    SID_NAME_USE snu;
    PSID pSid;
    WCHAR DomainName[DNLEN+1];
    DWORD cchDomainName = DNLEN;
    BOOL bSuccess = FALSE;

    //
    // Sid is the same regardless of machine, since the well-known
    // BUILTIN domain is referenced.
    //

    if(AllocateAndInitializeSid(
                                &sia,
                                2,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                DOMAIN_ALIAS_RID_ADMINS,
                                0, 0, 0, 0, 0, 0,
                                &pSid
                               ))
    {
        bSuccess = LookupAccountSidW(
                                     NULL,
                                     pSid,
                                     Name,
                                     cchName,
                                     DomainName,
                                     &cchDomainName,
                                     &snu
                                    );

        FreeSid(pSid);
    }

    return bSuccess;

} 

////////////////////////////////////////////////////////////////////
//
//  Determine if the person specified is an administrator
//
BOOL
IsUserAdministrator(
                    LPTSTR lpszFullName
                   )
{
    DWORD                     dwRead, dwTotal, x;
    NET_API_STATUS            nas;
    LPLOCALGROUP_USERS_INFO_0 pGroups = NULL;
    LPWSTR                    lpszNewFullName;
#define MAXADMINLEN     256
    WCHAR                     szAdministrators[MAXADMINLEN];


#ifndef UNICODE

    DWORD           dwSize;

    dwSize = (TAPIstrlen( lpszFullName ) + 1) * sizeof( WCHAR );

    if (!(lpszNewFullName = (LPWSTR) GlobalAlloc (GPTR, dwSize)))
    {
        return FALSE;
    }

    MultiByteToWideChar(
                        CP_ACP,
                        MB_PRECOMPOSED,
                        lpszFullName,
                        -1,
                        lpszNewFullName,
                        dwSize
                       );
#else
    
    lpszNewFullName = lpszFullName;
    
#endif

    // First, get the name of the 'Administrators' group.
    // Normally, this will be Administrators, but the use
    // can change it (also, it will be different for foreign
    // versions of NT)
    dwTotal = sizeof(szAdministrators)/sizeof(WCHAR); // reuse dwTotal
    if (!(LookupAdministratorsAlias(
                                    szAdministrators,
                                    &dwTotal
                                   )))
    {
        return FALSE;
    }

    // Next, get all the groups the user is part of
    // (directly OR indirectly) and see if administrators
    // is among them.
#define MAX_PREFERRED_LEN 4096*2        // 2 pages (or 1 on alpha)
    nas = NetUserGetLocalGroups (
                                 NULL,                  // server
                                 lpszNewFullName,       // user name
                                 0,                     // level
                                 LG_INCLUDE_INDIRECT,   // flags
                                 (PBYTE*)&pGroups,      // output buffer
                                 MAX_PREFERRED_LEN,     // preferred maximum length
                                 &dwRead,               // entries read
                                 &dwTotal               // total entries
                                );

    if (NERR_Success != nas)
    {
        return FALSE;
    }

    for (x = 0; x < dwRead; x++)
    {
        if (lstrcmpiW(
                      pGroups[x].lgrui0_name,
                      szAdministrators
                     ) == 0)
        {
            break;
        }
    }
    NetApiBufferFree ((PVOID)pGroups);
    if (x < dwRead)
    {
        return TRUE;
    }

    ErrorStr(iszUserNotAdmin);

    return FALSE;
          
}

/////////////////////////////////////////////////////////////////////
//
//  Write out server registry keys
//
BOOL
WriteRegistryKeys(
                  LPTSTR    lpszMapper,
                  LPTSTR    lpszDlls
                 )
{
    HKEY        hKeyTelephony, hKey;
    DWORD       dw;

    if (RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony"),
                      0,
                      KEY_ALL_ACCESS,
                      &hKeyTelephony
                     ) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    if (RegCreateKeyEx(
                        hKeyTelephony,
                        TEXT("Server"),
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dw
                       ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyTelephony);
        return FALSE;
    }

    dw=0;
    
    if ((RegSetValueEx(
                  hKey,
                  TEXT("DisableSharing"),
                  0,
                  REG_DWORD,
                  (LPBYTE)&dw,
                  sizeof(dw)
                 ) != ERROR_SUCCESS) ||

        (RegSetValueEx(
                       hKey,
                       TEXT("MapperDll"),
                       0,
                       REG_SZ,
//                       (LPBYTE)lpszMapper,
                       (LPBYTE)TEXT("TSEC.DLL"),
//                       (TAPIstrlen(lpszMapper)+1)*sizeof(TCHAR)
                       (TAPIstrlen(TEXT("TSEC.DLL"))+1)*sizeof(TCHAR)
                      ) != ERROR_SUCCESS))
    {
        RegCloseKey(hKey);
        RegCloseKey(hKeyTelephony);

        return FALSE;
    }
    
    if (lpszDlls)
    {
        if (RegSetValueEx(
                          hKey,
                          TEXT("ManagementDlls"),
                          0,
                          REG_SZ,
                          (LPBYTE)lpszDlls,
                          (TAPIstrlen(lpszDlls)+1)*sizeof(TCHAR)
                         ) != ERROR_SUCCESS)
        {
            RegCloseKey(hKey);
            RegCloseKey(hKeyTelephony);
            
            return FALSE;
        }
    }
    else
    {
        RegDeleteValue(
                       hKey,
                       TEXT("ManagementDlls")
                      );
    }
                       
    
    RegCloseKey(hKey);
    RegCloseKey(hKeyTelephony);

    return TRUE;
}


//////////////////////////////////////////////////////////////////
//
// Set server setting for the tapisrv service
//
BOOL
DoServiceStuff(
               LPTSTR   lpszName,
               LPTSTR   lpszPassword,
               BOOL     bServer
              )
{
    SC_HANDLE           sch, sc_tapisrv;
    BOOL                bReturn = TRUE;
    
    if (!(sch = OpenSCManager(
                              NULL,
                              NULL,
                              SC_MANAGER_ENUMERATE_SERVICE
                             )))
    {
        return FALSE;
    }


    if (!(sc_tapisrv = OpenService(
                                   sch,
                                   TEXT("TAPISRV"),
                                   SERVICE_CHANGE_CONFIG
                                  )))
    {
        CloseHandle(sch);
        
        ErrorStr(iszOpenServiceFailed);
        return FALSE;
    }

    // this sets tapisrv to start as auto, not manual
    // and set the log on as person to be the name/password passed in
    if (!(ChangeServiceConfig(
                              sc_tapisrv,
                              SERVICE_WIN32_OWN_PROCESS,
                              bServer?SERVICE_AUTO_START:SERVICE_DEMAND_START,
                              SERVICE_NO_CHANGE,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              lpszName,
                              (lpszPassword ? lpszPassword : TEXT("")),
                              NULL
                             )))
     {
        bReturn = FALSE;
     }


    CloseServiceHandle(sc_tapisrv);
    CloseServiceHandle(sch);

    return bReturn;
}

  
 
NTSTATUS
OpenPolicy(
           LPWSTR ServerName,          // machine to open policy on (Unicode)
           DWORD DesiredAccess,        // desired access to policy
           PLSA_HANDLE PolicyHandle    // resultant policy handle
          );
 
BOOL
GetAccountSid(
              LPTSTR SystemName,          // where to lookup account
              LPTSTR AccountName,         // account of interest
              PSID *Sid                   // resultant buffer containing SID
             ); 
NTSTATUS
SetPrivilegeOnAccount(
                      LSA_HANDLE PolicyHandle,    // open policy handle
                      PSID AccountSid,            // SID to grant privilege to
                      LPWSTR PrivilegeName,       // privilege to grant (Unicode)
                      BOOL bEnable                // enable or disable
                     );

void
InitLsaString(
              PLSA_UNICODE_STRING LsaString, // destination
              LPWSTR String                  // source (Unicode)
             );
 
/////////////////////////////////////////////////////
//
// grant the person the right to Log On As A Service
//
BOOL
DoRight(
        LPTSTR   AccountName,
        LPWSTR   Right,
        BOOL     bEnable
       )
{
    LSA_HANDLE      PolicyHandle;
    PSID            pSid;
    NTSTATUS        Status;
    BOOL            bReturn = FALSE;
    WCHAR           wComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD           dwSize = MAX_COMPUTERNAME_LENGTH+1;


    
    GetComputerNameW(
                     wComputerName,
                     &dwSize
                    );
    //
    // Open the policy on the target machine.
    //
    if((Status=OpenPolicy(
                wComputerName,      // target machine
                POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
                &PolicyHandle       // resultant policy handle
                )) != ERROR_SUCCESS)
    {
        ErrorStr(iszOpenPolicyFailed);
        return FALSE;
    }
 
    //
    // Obtain the SID of the user/group.
    // Note that we could target a specific machine, but we don't.
    // Specifying NULL for target machine searches for the SID in the
    // following order: well-known, Built-in and local, primary domain,
    // trusted domains.
    //
    if(GetAccountSid(
                     NULL,       // default lookup logic
                     AccountName,// account to obtain SID
                     &pSid       // buffer to allocate to contain resultant SID
                    ))
    {
        PLSA_UNICODE_STRING          rights;
        DWORD           dwcount = 0;
        //
        // We only grant the privilege if we succeeded in obtaining the
        // SID. We can actually add SIDs which cannot be looked up, but
        // looking up the SID is a good sanity check which is suitable for
        // most cases.
 
        //
        // Grant the SeServiceLogonRight to users represented by pSid.
        //

        LsaEnumerateAccountRights(
                                  PolicyHandle,
                                  pSid,
                                  &rights,
                                  &dwcount
                                 );
        if((Status=SetPrivilegeOnAccount(
                                         PolicyHandle,           // policy handle
                                         pSid,                   // SID to grant privilege
                                         Right,//L"SeServiceLogonRight", // Unicode privilege
                                         bEnable                    // enable the privilege
                                        )) == ERROR_SUCCESS)
        {
            bReturn = TRUE;
        }
        else
        {
            ErrorStr(iszSetPrivilegeOnAccount);
        }
        
    }
 
    //
    // Close the policy handle.
    //
    LsaClose(PolicyHandle);
 
    //
    // Free memory allocated for SID.
    //
    if(pSid != NULL) GlobalFree(pSid);
 
    return bReturn;
}
 
void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String
    )
{
    DWORD StringLength;
 
    if (String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }
 
    StringLength = TAPIstrlen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}
 
NTSTATUS
OpenPolicy(
    LPWSTR ServerName,
    DWORD DesiredAccess,
    PLSA_HANDLE PolicyHandle
    )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;
 
    //
    // Always initialize the object attributes to all zeroes.
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
 
    if (ServerName != NULL)
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPTSTR passed in
        //
        InitLsaString(&ServerString, ServerName);
        Server = &ServerString;
    }
 
    //
    // Attempt to open the policy.
    //
    return LsaOpenPolicy(
                         Server,
                         &ObjectAttributes,
                         DesiredAccess,
                         PolicyHandle
                        );
}
 
/*++
This function attempts to obtain a SID representing the supplied
account on the supplied system.
 
If the function succeeds, the return value is TRUE. A buffer is
allocated which contains the SID representing the supplied account.
This buffer should be freed when it is no longer needed by calling
HeapFree(GetProcessHeap(), 0, buffer)
 
If the function fails, the return value is FALSE. Call GetLastError()
to obtain extended error information.
 
Scott Field (sfield)    12-Jul-95
--*/
 
BOOL
GetAccountSid(
    LPTSTR SystemName,
    LPTSTR AccountName,
    PSID *Sid
    )
{
    LPTSTR ReferencedDomain=NULL;
    DWORD cbSid=1000;    // initial allocation attempt
    DWORD cbReferencedDomain=256; // initial allocation size
    SID_NAME_USE peUse;
    BOOL bSuccess=TRUE; // assume this function will fail
 
    //
    // initial memory allocations
    //
    if((*Sid=GlobalAlloc(
                         GPTR,
                         cbSid
                        )) == NULL)
    {
        bSuccess = FALSE;
        goto failure;
    }
 
    if((ReferencedDomain=GlobalAlloc(
                                     GPTR,
                                     cbReferencedDomain
                                    )) == NULL)
    {
        bSuccess = FALSE;
        goto failure;
    }

 
    //
    // Obtain the SID of the specified account on the specified system.
    //
    if (!LookupAccountName(
                           SystemName,         // machine to lookup account on
                           AccountName,        // account to lookup
                           *Sid,               // SID of interest
                           &cbSid,             // size of SID
                           ReferencedDomain,   // domain account was found on
                           &cbReferencedDomain,
                           &peUse
                          ))
    {
                bSuccess = FALSE;
                goto failure;
    } 

failure:
    
    if (ReferencedDomain)
    {
        GlobalFree(ReferencedDomain);
    }
 
    if(!bSuccess)
    {
        if(*Sid != NULL)
        {
            GlobalFree(*Sid);
            *Sid = NULL;
        }
    }

 
 
    return bSuccess;
}
 
NTSTATUS
SetPrivilegeOnAccount(
    LSA_HANDLE PolicyHandle,    // open policy handle
    PSID AccountSid,            // SID to grant privilege to
    LPWSTR PrivilegeName,       // privilege to grant (Unicode)
    BOOL bEnable                // enable or disable
    )
{
    LSA_UNICODE_STRING PrivilegeString;
 
    //
    // Create a LSA_UNICODE_STRING for the privilege name.
    //
    InitLsaString(&PrivilegeString, PrivilegeName);
 
    //
    // grant or revoke the privilege, accordingly
    //
    if(bEnable) {
        return LsaAddAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
    else {
        return LsaRemoveAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                FALSE,              // do not disable all rights
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
}


BOOL
DisableServerStuff()
{
    HKEY        hKeyTelephony;
    LONG        lResult;
    
    if (!IsServer())
    {
        return FALSE;
    }

    if (RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      gszRegKeyTelephony,
                      0,
                      KEY_ALL_ACCESS,
                      &hKeyTelephony
                     ) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    lResult = RegDeleteKey (hKeyTelephony, TEXT("Server"));
    RegCloseKey (hKeyTelephony);
    if (ERROR_SUCCESS != lResult)
    {
        return FALSE;
    }

    if (!(DoServiceStuff(
                         TEXT("LocalSystem"),
                         TEXT(""),
                         FALSE
                        )))
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
DoServer(
         LPTSTR lpszServerLine
        )
{
    if (!(glpszFullName = GetNextString(
                                         lpszServerLine
                                        )))
    {
        return FALSE;
    }

    if (!(lstrcmpi(
                   glpszFullName,
                   TEXT("/d")
                  )))
    {
        if (!(DisableServerStuff()))
        {
            ErrorStr(iszServerDisabledFailure);
            return FALSE;
        }

        ErrorStr(iszServerDisabled);

        return TRUE;
    }

    // dow we want a password?
    if (!(lstrcmpi(
                   glpszFullName,
                   TEXT("/n")
                  )))
    {
        // NO!
        glpszFullName = GetNextString(
                                      NULL
                                     );
        glpszPassword = NULL;
    }
    else
    {
        // yes - get the password
        if (!(glpszPassword = GetNextString(
                                            NULL
                                           )))
        {
            ErrorStr(iszNoPasswordSupplied);
            ErrorStr(iszServerSetupFailure);
            return FALSE;
        }
    }

//    if (!(glpszMapper = GetNextString(
//                                      NULL
//                                     )))
//    {
//        ErrorStr(iszNoMapperSupplied);
//        ErrorStr(iszServerSetupFailure);
//        return FALSE;
//    }

    // dll list is not mandatory
    glpszDllList = GetNextString(
                                 NULL
                                );

    if (!IsServer())
    {
        return FALSE;
    }

    if (!IsUserAdministrator(
                             glpszFullName
                            )
       )
    {
        ErrorStr(iszUserNotAnAdmin);
        goto exit_now;
    }

    if (!DoRight(
                 glpszFullName,
                 L"SeServiceLogonRight",
                 TRUE
                ))
    {
        goto exit_now;
    }


    if (!WriteRegistryKeys(
                           glpszMapper,
                           glpszDllList
                          ))
    {
        ErrorStr(iszRegWriteFailed);
        goto exit_now;
    }

    if (!DoServiceStuff(
                        glpszFullName,
                        glpszPassword,
                        TRUE
                       ))
    {
        goto exit_now;
    }

    ErrorStr(iszServerSetup);

    return TRUE;

exit_now:

    ErrorStr(iszServerSetupFailure);
    return FALSE;
}

#define MAX_KEY_LENGTH 256
DWORD RegDeleteKeyNT(HKEY hStartKey , LPCTSTR pKeyName )
{
  DWORD   dwRtn, dwSubKeyLength;
  LPTSTR  pSubKey = NULL;
  TCHAR   szSubKey[MAX_KEY_LENGTH]; // (256) this should be dynamic.
  HKEY    hKey;

  // Do not allow NULL or empty key name
  if ( pKeyName &&  lstrlen(pKeyName))
  {
     if( (dwRtn=RegOpenKeyEx(hStartKey,pKeyName,
        0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hKey )) == ERROR_SUCCESS)
     {
        while (dwRtn == ERROR_SUCCESS )
        {
           dwSubKeyLength = MAX_KEY_LENGTH;
           dwRtn=RegEnumKeyEx(
                          hKey,
                          0,       // always index zero
                          szSubKey,
                          &dwSubKeyLength,
                          NULL,
                          NULL,
                          NULL,
                          NULL
                        );

           if(dwRtn == ERROR_NO_MORE_ITEMS)
           {
              dwRtn = RegDeleteKey(hStartKey, pKeyName);
              break;
           }
           else if(dwRtn == ERROR_SUCCESS)
              dwRtn=RegDeleteKeyNT(hKey, szSubKey);
        }
        RegCloseKey(hKey);
        // Do not save return code because error
        // has already occurred
     }
  }
  else
     dwRtn = ERROR_BADKEY;

  return dwRtn;
}

BOOL
RemoveRemoteSP()
{
    HKEY        hKeyProviders, hKeyTelephony;
    DWORD       dwSize, dwCount, dwID, dwType, dwNumProviders ;
    TCHAR       szBuffer[256], szProviderName[256];
            
            
    // open providers key
    if (RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 gszRegKeyProviders,
                 0,
                 KEY_ALL_ACCESS,
                 &hKeyProviders
                ) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // open telephony key
    if (RegOpenKeyEx(
                     HKEY_LOCAL_MACHINE,
                     gszRegKeyTelephony,
                     0,
                     KEY_ALL_ACCESS,
                     &hKeyTelephony
                    ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyProviders);
        return FALSE;
    }

    dwSize = sizeof (DWORD);

    // get current num providers
    if (RegQueryValueEx(
                      hKeyProviders,
                      gszNumProviders,
                      NULL,
                      &dwType,
                      (LPBYTE)&dwNumProviders,
                      &dwSize) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyTelephony);
        RegCloseKey(hKeyProviders);

        return FALSE;
    }

    //check to see if remotesp is already installed
    //loop through all providers and compare filename
    for (dwCount = 0; dwCount < dwNumProviders; dwCount++)
    {
        wsprintf(
                 szBuffer,
                 TEXT("%s%d"),
                 gszProviderFilename,
                 dwCount
                );

        dwSize = 256;
        
        if (RegQueryValueEx(
                            hKeyProviders,
                            szBuffer,
                            NULL,
                            &dwType,
                            (LPBYTE)szProviderName,
                            &dwSize) != ERROR_SUCCESS)
        {
            continue;
        }

        // this is remotesp
        if (!lstrcmpi(
                      szProviderName,
                      gszRemoteSP
                     ))
        {

            
            wsprintf(
                     szBuffer,
                     TEXT("%s%d"),
                     gszProviderID,
                     dwCount
                    );

            dwSize = sizeof(DWORD);
            
            RegQueryValueEx(
                            hKeyProviders,
                            szBuffer,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwID,
                            &dwSize
                           );
            return (lineRemoveProvider (dwID, NULL) == S_OK);
        }
    }

    if (dwCount == dwNumProviders)
    {
        return FALSE;
    }

    return TRUE;
}
               
BOOL
WriteRemoteSPKeys(
                  LPTSTR lpszRemoteServer
                 )
{
    HKEY        hKeyProviders, hKeyTelephony = NULL, hKey;
    DWORD       dwSize, dwType, dwNumProviders, dwNextProviderID,
                dwDisp, dwCount, i;
    TCHAR       szBuffer[256], szProviderName[256]; 
#ifdef NEVER
    BOOL        fAlreadyExists = FALSE;
#endif


    // open providers key
    if (RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 gszRegKeyProviders,
                 0,
                 KEY_ALL_ACCESS,
                 &hKeyProviders
                ) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    dwSize = sizeof (DWORD);

    // get current num providers
    if (RegQueryValueEx(
                      hKeyProviders,
                      gszNumProviders,
                      NULL,
                      &dwType,
                      (LPBYTE)&dwNumProviders,
                      &dwSize) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyProviders);

        return FALSE;
    }

    //check to see if remotesp is already installed
    //loop through all providers and compare filename

    for (dwCount = 0; dwCount < dwNumProviders; dwCount++)
    {
        wsprintf(
                 szBuffer,
                 TEXT("%s%d"),
                 gszProviderFilename,
                 dwCount
                );

        dwSize = 256;
        
        if (RegQueryValueEx(
                            hKeyProviders,
                            szBuffer,
                            NULL,
                            &dwType,
                            (LPBYTE)szProviderName,
                            &dwSize) != ERROR_SUCCESS)
        {
            continue;
        }

        if (!lstrcmpi(
                      szProviderName,
                      gszRemoteSP
                     ))
        {
            // if there's a match, return TRUE
            wsprintf(
                     szBuffer,
                     TEXT("%s%d"),
                     gszProviderID,
                     dwCount
                    );

            dwSize = sizeof(DWORD);
            
            RegQueryValueEx(
                            hKeyProviders,
                            szBuffer,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwNextProviderID,
                            &dwSize
                           );

            //  first remove the provider
            if (lineRemoveProvider (dwNextProviderID, NULL))
            {
                RegCloseKey (hKeyProviders);
                return FALSE;
            }

            if (RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 gszRegKeyTelephony,
                 0,
                 KEY_ALL_ACCESS,
                 &hKeyTelephony
                ) != ERROR_SUCCESS)
            {
                return FALSE;
            }
            
            wsprintf(
                szBuffer,
                TEXT("%s%d"),
                gszProvider,
                dwNextProviderID
                );

            RegDeleteKeyNT(
                hKeyTelephony,
                szBuffer
                );

#ifdef NEVER
            wsprintf(
                     szBuffer,
                     TEXT("%s%d"),
                     gszProvider,
                     dwNextProviderID
                    );

            // open telephony key
            if (RegOpenKeyEx(
                             HKEY_LOCAL_MACHINE,
                             gszRegKeyTelephony,
                             0,
                             KEY_ALL_ACCESS,
                             &hKeyTelephony
                            ) != ERROR_SUCCESS)
            {
                return FALSE;
            }

            fAlreadyExists = TRUE;
            goto createProviderNKey;
#endif
        }
    }

    dwSize = sizeof (DWORD);

    // get next provider id
    if (RegQueryValueEx(
                        hKeyProviders,
                        gszNextProviderID,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwNextProviderID,
                        &dwSize) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyProviders);

        return FALSE;
    }


#ifdef NEVER
    // make the filename id
    wsprintf(szBuffer, TEXT("%s%d"), gszProviderFilename, dwNumProviders);

    // set the filename
    if (RegSetValueEx(
                      hKeyProviders,
                      szBuffer,
                      0,
                      REG_SZ,
                      (LPBYTE)gszRemoteSP,
                      (TAPIstrlen(gszRemoteSP)+1) * sizeof(TCHAR)
                     ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyProviders);

        return FALSE;
    }

    // make the provideid id
    wsprintf(szBuffer, TEXT("%s%d"), gszProviderID, dwNumProviders);

    // set the providerid id
    if (RegSetValueEx(
                      hKeyProviders,
                      szBuffer,
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwNextProviderID,
                      sizeof(DWORD)
                     ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyProviders);

        return FALSE;
    }

    // inc next provider id
    dwNextProviderID++;

    // set it
    if (RegSetValueEx(
                      hKeyProviders,
                      gszNextProviderID,
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwNextProviderID,
                      sizeof(DWORD)
                     ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyProviders);

        return FALSE;
    }

    // inc num providers
    dwNumProviders++;

    // set it
    if (RegSetValueEx(
                      hKeyProviders,
                      gszNumProviders,
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwNumProviders,
                      sizeof(DWORD)
                     ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyProviders);

        return FALSE;
    }

    // close this one
    RegCloseKey(hKeyProviders);
#endif  //  NEVER

    // open telephony key
    if ((hKeyTelephony == NULL) && (RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 gszRegKeyTelephony,
                 0,
                 KEY_ALL_ACCESS,
                 &hKeyTelephony
                ) != ERROR_SUCCESS))
    {
        return FALSE;
    }

    // make the provider# key
    wsprintf(szBuffer, TEXT("%s%d"), gszProvider, dwNextProviderID);

#if NEVER
createProviderNKey:

    //
    // First nuke the existing key to clear out all the old values,
    // the recreate it & add the new values
    //
    
    RegDeleteKeyNT (hKeyTelephony, szBuffer);
#endif

    if (RegCreateKeyEx(
                       hKeyTelephony,
                       szBuffer,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS,
                       NULL,
                       &hKey,
                       &dwDisp
                      ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyTelephony);

        return FALSE;
    }

    for (i = 0; lpszRemoteServer; i++)
    {
        wsprintf (szBuffer, TEXT("%s%d"), gszServer, i);

        if (RegSetValueEx(
                hKey,
                szBuffer,
                0,
                REG_SZ,
                (LPBYTE) lpszRemoteServer,
                (TAPIstrlen (lpszRemoteServer) + 1) * sizeof(TCHAR)

                ) != ERROR_SUCCESS)
        {
            RegCloseKey (hKey);
            RegCloseKey (hKeyProviders);

            return FALSE;
        }

        lpszRemoteServer = GetNextString (NULL);
    }

    if (RegSetValueEx(
            hKey,
            gszNumServers,
            0,
            REG_DWORD,
            (LPBYTE) &i,
            sizeof (i)

            ) != ERROR_SUCCESS)
    {
        RegCloseKey (hKey);
        RegCloseKey (hKeyProviders);

        return FALSE;
    }

    // set the ConnectionOrientedOnly value appropriately

    if (RegSetValueEx(
            hKey,
            gszConnectionOrientedOnly,
            0,
            REG_DWORD,
            (LPBYTE) &gdwConnectionOrientedOnly,
            sizeof(DWORD)

            ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        RegCloseKey(hKeyProviders);

        return FALSE;
    }

    //  Set NoDSQuery value appropriately
    if (RegSetValueEx(
            hKey,
            gszNoDSQuery,
            0,
            REG_DWORD,
            (LPBYTE) &gdwNoDSQuery,
            sizeof(DWORD)

            ) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        RegCloseKey(hKeyProviders);

        return FALSE;
    }

    //
    //  Add the new remotesp.tsp
    //
    lineAddProvider (gszRemoteSP, NULL, &dwNextProviderID);

    RegCloseKey (hKey);
    RegCloseKey (hKeyProviders);
    RegCloseKey(hKeyTelephony);
    
    return TRUE;
}



BOOL
DoClient(
         LPTSTR lpszClientLine
        )
{
    HANDLE  hProvidersMutex = NULL;
    BOOL    bRet = FALSE;

    glpszRemoteServer = GetNextString(
                                      lpszClientLine
                                     );

    if (!glpszRemoteServer)
    {
        goto ExitHere;
    }

    hProvidersMutex = CreateMutex (
        NULL,
        FALSE,
        TEXT("TapisrvProviderListMutex")
        );
    if (NULL == hProvidersMutex)
    {
        ErrorStr(iszCreateMutexFailed);
        goto ExitHere;
    }

    WaitForSingleObject (hProvidersMutex, INFINITE);
    
    if (!lstrcmpi(
                  glpszRemoteServer,
                  TEXT("/d")
                 ))
    {
        if (!RemoveRemoteSP())
        {
            ErrorStr(iszClientDisabledFailure);
            goto ExitHere;
        }
        else
        {
            ErrorStr(iszClientDisabled);

            bRet = TRUE;
            goto ExitHere;
        }
    }
        

    if (!WriteRemoteSPKeys(
                           glpszRemoteServer
                          ))
    {
        ErrorStr(iszClientSetupFailure);
        goto ExitHere;
    }
    else
    {
        bRet = TRUE;
    }

    ErrorStr(iszClientSetup);

ExitHere:

    if (hProvidersMutex)
    {
        ReleaseMutex (hProvidersMutex);
        CloseHandle (hProvidersMutex);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\dialer\dialhelp.h ===
//
// (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
#define IDH_DIALER_CHANGE_DIAL_HELPER    1000
#define IDH_DIALER_CHANGE_DIGITS         1001
#define IDH_DIALER_CHANGE_OPTIONS        1002
#define IDH_DIALER_CHANGE_REDIAL_BUTTON  1003
#define IDH_DIALER_DIALING_LOGNAME       1004
#define IDH_DIALER_DIALING_STATUS        1005
#define IDH_DIALER_HANGUP                1006
#define IDH_DIALER_LOG_IN                1007
#define IDH_DIALER_LOG_OUT               1008
#define IDH_DIALER_OPTIONS_ADDRESS       1009
#define IDH_DIALER_OPTIONS_LINE          1010
#define IDH_DIALER_OPTIONS_NONVOICE      1011
#define IDH_DIALER_OPTIONS_VOICE         1012
#define IDH_DIALER_PAUSE_CONTINUE        1013
#define IDH_DIALER_SPEED_CHOOSE          1014
#define IDH_DIALER_SPEED_NAME            1015
#define IDH_DIALER_SPEED_NUMBER          1016
#define IDH_DIALER_SPEED_SAVE            1017
#define IDH_DIALER_SPEED_SAVE_DIAL       1018
#define IDH_DIALER_DIAL_NUMBER           1019
#define IDH_DIALER_DIAL_SPEED_CHOOSE     1020
#define IDH_DIALER_DIAL_BUTTON           1021
#define IDH_DIALER_DIAL_KEYPAD           1022
#define IDH_DIALER_LOG                   1023
#define IDH_DIALER_OPTIONS_PROPERTIES    1024
#define IDH_DIALER_BUTTONS               1025
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\dialer\dialer.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dialer.h

Abstract:

    Header file for dialer

Author:

    Dan Knudson (DanKn)        05-Apr-1995

Revision History:

    Jeremy Horwitz (t-jereh)   30-May-1995

--*/


#define TAPI_VERSION_1_0 0x00010003
#define TAPI_VERSION_1_4 0x00010004
#define TAPI_VERSION_2_0 0x00020000
#define TAPI_VERSION_2_2 0x00020002
#define TAPI_VERSION_3_0 0x00030000
//#define TAPI_CURRENT_VERSION TAPI_VERSION_2_0
#define TAPI_CURRENT_VERSION TAPI_VERSION_3_0

#include <windows.h>
#include "tapi.h"
#include "resource.h"
#include "dialhelp.h"


#define MENU_CHOICE         1 // for Connect Using dialog...
#define INVALID_LINE        2 // if INVALID_LINE, turn off CANCEL
                              // button and add extra text...

#define MAXNUMLENGTH    64
#define MAXBUFSIZE      256
#define NSPEEDDIALS     8 // Dialer supports 8 configurable speed dial entries.
#define NLASTDIALED     20 // Dialer keeps track of the 20 last dialed numbers.

#define ERR_NONE        0
#define ERR_NOVOICELINE 1
#define ERR_LINECLOSE   2
#define ERR_NOLINES     3
#define	ERR_911WARN		4
#define ERR_NEWDEFAULT	5

#define itoa(x,y,z) _itoa(x,y,z)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\apps\dialer\dialer.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialer.c

--*/


#include "dialer.h"
#include "string.h"
#include "tchar.h"
#include "stdlib.h"
#include "shellapi.h"

#define DIALER_REGISTRY_PATH    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Dialer")
#define DIALER_REGISTRY_ROOT    HKEY_CURRENT_USER

#define    ISDIGIT(x)            (((x) - TEXT('0')) >= 0) && (((x) - TEXT('0')) <= 9)
enum NumberTypes 
{
    LOCAL_NUMBER = 7,
    EXTENDED_LOCAL_NUMBER,
    LONG_DISTANCE_NUMBER = 10,
    EXTENDED_LONG_DISTANCE_NUMBER
};


// structs
typedef struct tagLINEINFO
{
    DWORD nAddr;                    // Number of avail. addresses on the line
    BOOL  fVoiceLine;               // Is this a voice line?
    DWORD dwAPIVersion;             // API version which the line supports
    HLINE hLine;                    // line handle returned by lineOpen
    DWORD dwPermanentLineID;        // Permanent line ID retreived from devcaps
    TCHAR  szLineName[MAXBUFSIZE];  // the line's name

} LINEINFO, *LPLINEINFO;


// Global variables

// window/instance variables
HWND        ghWndMain;
HWND        ghWndDialing = NULL;
HINSTANCE   ghInst = 0;

// file name vars.
static TCHAR gszAppName[64];
static TCHAR gszINIfilename [] = TEXT("DIALER.INI";)
static TCHAR gszHELPfilename [] = TEXT("DIALER.HLP");
static TCHAR gszDialerClassName[] = TEXT("DialerClass");
TCHAR const gszNULL[] = TEXT("");

// window item variables
HLINEAPP    ghLineApp = 0;           // Dialer's usage handle (regist. w/TAPI)
HCALL       ghCall = 0;              // call handle for Dialer's call

LPTSTR       gszCurrentNumber = NULL; // number of destination of current call
LPTSTR       gszCurrentName = NULL;     // name of destination of current call

BOOL        gfRegistered;            // was lineRegisterRequestRecipient()
                                     // successful?

BOOL        gfNeedToReinit = FALSE;  // does Dialer need to re-initialize?

BOOL        gfCallRequest = FALSE;   // Does a Simple TAPI app want a call?
BOOL        gfCurrentLineAvail = TRUE; // Simple TAPI requests are only carried
                                       // out if the current chosen line is avail.
BOOL        gfMakeCallReplyPending = FALSE;

LONG        gMakeCallRequestID = 0;      // request ID returned by async TAPI fns.
LONG        gDropCallRequestID = 0;      // request ID returned by async TAPI fns.

DWORD       gnAvailDevices = 0;      // # of line devices avail. to Dialer
LINEINFO    gCurrentLineInfo;
DWORD       * gnAddr;

// global to remember where the cursor is in the edit control
DWORD       gdwStartSel;
DWORD       gdwEndSel;

DWORD       * gdwPLID;               // current line's permanent line ID
DWORD       giCurrentLine = (DWORD)-1;       // the line selected by the user
DWORD       giCurrentAddress = 0;    // the address selected by the user

// + 1 so we can work 1-based rather than 0-based (for convenience only)
// global varibles to hold the names and address of the 
TCHAR       gszSDNumber[ NSPEEDDIALS + 1 ][ TAPIMAXDESTADDRESSSIZE ] = {0};


// Function declarations

// button related functions
VOID DisableDialButtons(BOOL fDisable);
VOID FitTextToButton( HWND, INT, LPTSTR );

// Callback functions
INT_PTR CALLBACK MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DialingProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK AboutProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ConnectUsingProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK LineInUseProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SpeedDial1Proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SpeedDial2Proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
VOID CALLBACK tapiCallback ( 
                            DWORD hDevice, DWORD dwMsg,
                            DWORD dwCallbackInstance, 
                            DWORD dwParam1, DWORD dwParam2, 
                            DWORD dwParam3
                            );

// tapi related functions
VOID ManageAssistedTelephony(VOID);
VOID InitiateCall(LPCTSTR szNumber, LPCTSTR szName);

VOID DialerLineClose(VOID); 
VOID DialerCleanup(VOID);
VOID CloseTAPI(VOID);

DWORD GetLineInfo(DWORD iLine, LPLINEINFO lpLineInfo);
VOID GetLineInfoFailed (
                        DWORD iLine, LPLINEDEVCAPS lpDevCaps, 
                        LPLINEINFO lpLineInfo
                        );
LPTSTR GetAddressName(DWORD iLine, DWORD iAddress);
BOOL MakeCanonicalNumber( LPCTSTR szName, LPTSTR szCanNumber );

// misc. helper functions
VOID ReadINI(VOID);
int errString(HWND hWnd, UINT errCode, UINT uFlags);
VOID AddToRedialList(LPCTSTR szNumber);
BOOL InitializeLineBox(HWND hwndLineBox);
BOOL InitializeAddressBox(HWND hwndLineBox, HWND hwndAddressBox);
BOOL Is911 ( LPLINETRANSLATEOUTPUT lpTransOut );
VOID AmpersandCompensate( LPCTSTR lpszSrc, LPTSTR lpszDst );
VOID AmpersandDeCompensate( LPCTSTR lpszSrc, LPTSTR lpszDst );

// Dialer memory management functions
LPVOID DialerAlloc(size_t cbToAlloc);
LPVOID DialerFree(LPVOID lpMem);


// Function definitions


//***************************************************************************
//***************************************************************************
//***************************************************************************
DWORD InitializeTAPI (VOID)
{
    INT cvLine;

    DWORD iLine;
    DWORD dwPreferredPLID, dwID = (DWORD) -1;

    MSG msg;

    LPLINEINFO lpLineInfo = NULL;    // LINEINFO for each available line

    DWORD errCode;
    DWORD tc = GetTickCount();
    DWORD dwReturn = ERR_NONE;

    TCHAR szBuffer[MAXBUFSIZE];        // to read in dwPreferredPLID as a string first

    DWORD dwTapiVersion = TAPI_CURRENT_VERSION;
    LINEINITIALIZEEXPARAMS lip = {sizeof (LINEINITIALIZEEXPARAMS),
                                  sizeof (LINEINITIALIZEEXPARAMS),
                                  sizeof (LINEINITIALIZEEXPARAMS),
                                  LINEINITIALIZEEXOPTION_USEHIDDENWINDOW};

    HKEY hKey = NULL;
    DWORD dwSize;

    errCode = lineInitializeEx (
                                &ghLineApp,
                                ghInst,
                                (LINECALLBACK) tapiCallback,
                                gszAppName,
                                &gnAvailDevices,
                                &dwTapiVersion,
                                &lip
                               );
    if ( errCode == LINEERR_REINIT )
    {
        // take away dialer functionality
        EnableWindow( ghWndMain, FALSE );
        DisableDialButtons(TRUE);

        // keep trying until the user cancels
        // or we stop getting LINEERR_REINIT
        while ( ( errCode = lineInitializeEx ( 
                                            &ghLineApp,              
                                            ghInst,
                                            (LINECALLBACK)tapiCallback,
                                            gszAppName,
                                            &gnAvailDevices,
                                            &dwTapiVersion,
                                            &lip
                                            ) ) 
                 == LINEERR_REINIT )
        {
            // flush queue & yield
            while ( PeekMessage( &msg, 0, 0, 0, PM_REMOVE ) ) 
            {
                TranslateMessage( &msg );
                DispatchMessage( &msg );
            }

            // bring up the box if 5 seconds have passed since
            if(GetTickCount() > 5000 + tc)
            {
                if ( errString( ghWndMain, ikszWarningTapiReInit, MB_RETRYCANCEL )
                     == IDCANCEL )
                {
                    break;
                }
                // reset the relative counter
                tc = GetTickCount(); 
            }            
        }

        // give back dialer functionality
        DisableDialButtons( FALSE );
        EnableWindow( ghWndMain, TRUE );
    }

    if ( errCode )
    {
        dwReturn = errCode;
        goto tapiinit_exit;
    }

    RegOpenKeyEx (DIALER_REGISTRY_ROOT, DIALER_REGISTRY_PATH, 0, KEY_READ, &hKey);

    // retrieve preferred line info from INI file
    dwSize = sizeof (szBuffer);
    szBuffer[0] = 0;
    if (ERROR_SUCCESS ==
        RegQueryValueEx (hKey, TEXT("Preferred Line"), NULL, NULL, (LPBYTE)szBuffer, &dwSize))
    {
        dwPreferredPLID = (DWORD) _ttoi( szBuffer );    
    }
    else    
    {
        dwPreferredPLID = (DWORD) -1;
    }
                                        
    // -1 default - tells us if it ever gets set
    giCurrentLine = (DWORD) -1;            

    // allocate buffer for storing LINEINFO for all of the available lines
    // always allocate space for at least one line
    if ( gnAvailDevices == 0 )
    {
        gnAddr = (DWORD *) DialerAlloc( sizeof( DWORD ) );
        gdwPLID = (DWORD *) DialerAlloc( sizeof( DWORD ) );
        lpLineInfo = (LPLINEINFO) DialerAlloc( sizeof( LINEINFO ) );
    }
    else
    {
        gnAddr = (DWORD *) DialerAlloc( sizeof( DWORD ) * (int)gnAvailDevices);
        gdwPLID = (DWORD *) DialerAlloc( sizeof( DWORD ) * (int)gnAvailDevices);
        lpLineInfo = (LPLINEINFO) DialerAlloc( sizeof( LINEINFO ) * (int)gnAvailDevices );
    }

    // if no space was set aside...
    if ( lpLineInfo == NULL || gnAddr == NULL )
    {
        dwReturn = LINEERR_NOMEM;
        goto tapiinit_exit;
    }

    // fill lpLineInfo[] and open each line
    for ( iLine = 0, cvLine = 0; iLine < gnAvailDevices; ++iLine )
    {
        // skip remaining processing for this if it didn't open
        if ( GetLineInfo( iLine, &lpLineInfo[iLine] ) != ERR_NONE )
            continue; 

        gnAddr [ iLine ] = lpLineInfo[iLine].nAddr;
        gdwPLID[ iLine ] = lpLineInfo[iLine].dwPermanentLineID;

        if ( lpLineInfo[iLine].dwPermanentLineID == dwPreferredPLID )
            giCurrentLine = iLine;

        // note number of lines with Interactive voice caps.
        // used to select a preferred line by default
        if ( lpLineInfo [ iLine ].fVoiceLine )
        {
            cvLine++;
            dwID = iLine;
        }
    }

    // if we couldn't find the preferred line, 
    // try and assign one by default 
    // else bring up connect using dialog
    if (  giCurrentLine == (DWORD)-1 ) 
    {
        // check if there is only one line
        // that has interactive voice caps, 
        // make it default line
        if ( cvLine == 1 ) 
        {
            giCurrentLine = dwID;

            // if the preferred address read from the INI file
            // was different i.e we are changing setting, inform
            // the user
            if ( dwPreferredPLID != -1 )
            {
                errString( ghWndMain, ERR_NEWDEFAULT, MB_ICONEXCLAMATION | MB_OK );
            }
        }
        else
        {
            gCurrentLineInfo = lpLineInfo[0];
            if ( DialogBoxParam (
                                    ghInst,
                                    MAKEINTRESOURCE(IDD_CONNECTUSING),
                                    ghWndMain,
                                    ConnectUsingProc,
                                    INVALID_LINE
                                )
                 == -1)
            {
                dwReturn = (DWORD) -1;
            }
            else
            {
                dwReturn = ERR_NONE;
            }

            goto tapiinit_exit;
        }
    }
    gCurrentLineInfo = lpLineInfo[ giCurrentLine ];


    // select default address
    giCurrentAddress = 0;

    // get the name of the preferred address from ini file
    dwSize = sizeof (szBuffer);
    szBuffer[0] = 0;
    if (ERROR_SUCCESS ==
        RegQueryValueEx (hKey, TEXT("Preferred Address"), NULL, NULL, (LPBYTE)szBuffer, &dwSize))
    {
        giCurrentAddress = (DWORD) _ttoi( szBuffer );
        
        // if the address is invalid, set default
        if ( giCurrentAddress >= gCurrentLineInfo.nAddr )
            giCurrentAddress = 0;
    }
    

tapiinit_exit:

    if (NULL != hKey)
    {
        RegCloseKey (hKey);
    }

    if (lpLineInfo)
    {
        DialerFree(lpLineInfo);
    }
    
    return dwReturn;;
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
int WINAPI WinMain (
                    HINSTANCE hInstance,
                    HINSTANCE hPrevInstance,
                    LPSTR lpCmdLine,
                    int nCmdShow
                   )
{
    HACCEL hAccel;
    MSG msg;
    DWORD errCode;
    HANDLE hImHere;


    ghInst = GetModuleHandle( NULL );
    LoadString( ghInst, ikszAppFriendlyName, gszAppName, sizeof(gszAppName)/sizeof(TCHAR) );

    //
    // Now, let's see if we've already got an instance of ourself
    hImHere = CreateMutex(NULL, TRUE, TEXT("DialersIveBeenStartedMutex"));

    //
    // Is there another one of us already here?
    if ( ERROR_ALREADY_EXISTS == GetLastError() )
    {
        HWND        hDialerWnd;

        hDialerWnd = FindWindow(gszDialerClassName,
                                NULL);

        SetForegroundWindow(hDialerWnd);
        
       CloseHandle( hImHere );
       return 0;
    }


    {
        WNDCLASS wc;
        wc.style = CS_DBLCLKS | CS_SAVEBITS | CS_BYTEALIGNWINDOW;
        wc.lpfnWndProc = DefDlgProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = DLGWINDOWEXTRA;
        wc.hInstance = ghInst;
        wc.hIcon = LoadIcon(ghInst, MAKEINTRESOURCE(IDI_DIALER) );
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = GetStockObject (COLOR_WINDOW + 1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = gszDialerClassName;
        RegisterClass(&wc);
    }


    // create the dialog box and set it with info
    // from the .INI file
    ghWndMain = CreateDialog (
                                ghInst,
                                MAKEINTRESOURCE(IDD_DIALER),
                                (HWND)NULL,
                                MainWndProc
                             );

    ReadINI();

    ShowWindow(ghWndMain, SW_SHOW);
    UpdateWindow(ghWndMain);

    // limit text in Number field to TAPIMAXDESTADDRESSSIZE
    SendDlgItemMessage (
                        ghWndMain,
                        IDD_DCOMBO,
                        CB_LIMITTEXT,
                        (WPARAM)TAPIMAXDESTADDRESSSIZE,
                        0
                       );

    // 0 (ERR_NONE) error code registers success - otherwise terminate
    errCode = InitializeTAPI();
    if(errCode)
    {
        errString(ghWndMain, errCode, MB_APPLMODAL | MB_ICONEXCLAMATION );

        DialerCleanup();
        return errCode;
    }

    errCode = lineRegisterRequestRecipient (
                                            ghLineApp,
                                            0, // registration instance
                                            LINEREQUESTMODE_MAKECALL,
                                            TRUE
                                           );

    if(errCode)
    {
        gfRegistered = FALSE;
        errString(ghWndMain, errCode, MB_ICONEXCLAMATION | MB_OK );
    }
    else
    {
        gfRegistered = TRUE;
    }


    hAccel = LoadAccelerators(ghInst, gszAppName);

    while ( GetMessage( &msg, NULL, 0, 0 ) )
    {
        if ( ghWndMain == NULL || !IsDialogMessage( ghWndMain, &msg ) )
        {
            if(!TranslateAccelerator(ghWndMain, hAccel, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        // If: 1) Dialer is a call manager (if not, ignore requests)
        //     2) the currently chosen line is available
        //     3) there is a Simple TAPI request
        // Then: process the request
        if ( gfCurrentLineAvail && gfCallRequest )
        {
            ManageAssistedTelephony();
        }
    }


    
    DialerCleanup();

    CloseHandle( hImHere );

    return (int)msg.wParam;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
LPVOID DialerAlloc(size_t cbToAlloc)
{
    return LocalAlloc(LPTR, cbToAlloc);
}


LPVOID DialerFree(LPVOID lpMem)
{
    return LocalFree( lpMem );
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
VOID ReadINI( VOID ) 
{
    WORD cSDEntry, cLastDialed;

    POINT ptLeftTop;

    TCHAR szName[ TAPIMAXCALLEDPARTYSIZE ] = {0};
    TCHAR szTemp[ TAPIMAXCALLEDPARTYSIZE ];

    TCHAR szNum[TAPIMAXDESTADDRESSSIZE];
    TCHAR szFieldName[MAXBUFSIZE];
    TCHAR *p;

    HKEY hKey = NULL;
    DWORD dwSize;

    RegOpenKeyEx (DIALER_REGISTRY_ROOT, DIALER_REGISTRY_PATH, 0, KEY_READ, &hKey);

    // get speed dial settings from INI file
    for(cSDEntry = 1; cSDEntry <= NSPEEDDIALS; ++cSDEntry)
    {
        wsprintf(szFieldName, TEXT("Number%d"), cSDEntry);
        *szNum = 0;
        dwSize = sizeof (szNum);
        RegQueryValueEx (hKey, szFieldName, NULL, NULL, (LPBYTE)szNum, &dwSize);
        for (p = szNum; *p == TEXT(' '); p++);
        if (0 == *p)
        {
            continue;
        }
        lstrcpyn (gszSDNumber[cSDEntry], p, sizeof(gszSDNumber[cSDEntry])/sizeof(TCHAR));

        wsprintf(szFieldName, TEXT("Name%d"), cSDEntry);
        dwSize = sizeof (szName);
        RegQueryValueEx (hKey, szFieldName, NULL, NULL, (LPBYTE)szName, &dwSize);
        if (0 == *szName)
        {
            lstrcpyn( szName, gszSDNumber[ cSDEntry ], sizeof(szName)/sizeof(szName[0]) );
        }

        FitTextToButton( ghWndMain, IDD_DSPEEDDIAL1 + cSDEntry - 1, szName );

        AmpersandCompensate( szName, szTemp );
        SetDlgItemText (
                        ghWndMain,
                        IDD_DSPEEDDIAL1 + cSDEntry - 1,
                        (LPCTSTR)szTemp
                       ); // Label the speed dial button
    }

    
    // set up last dialed numbers in combo box (read from INI)
    for(cLastDialed = 1; cLastDialed <= NLASTDIALED; ++cLastDialed)
    {
        wsprintf(szFieldName, TEXT("Last dialed %d"), cLastDialed);
        dwSize = sizeof (szNum);
        szNum[0] = 0;
        RegQueryValueEx (hKey, szFieldName, NULL, NULL, (LPBYTE)szNum, &dwSize);
        if (0 != szNum[0])
        {
            SendDlgItemMessage(
                                ghWndMain,
                                IDD_DCOMBO,
                                CB_ADDSTRING,
                                0,
                                (LPARAM)(LPCTSTR)szNum
                              );
        }
    }

    // set defaults
    ptLeftTop.x = 100; 
    ptLeftTop.y = 100;

    // set the window position based on the INI data
    dwSize = sizeof (ptLeftTop);
    RegQueryValueEx (hKey, TEXT("Main Window Left/Top"), NULL, NULL, (LPBYTE)&ptLeftTop, &dwSize);
    if ( ptLeftTop.x < 0
        || ptLeftTop.x + 50 >= GetSystemMetrics(SM_CXSCREEN)
        || ptLeftTop.y < 0
        || ptLeftTop.y + 50 >= GetSystemMetrics(SM_CYSCREEN)            
       )
    {
        ptLeftTop.x = 100; // set defaults if the box is off of the screen
        ptLeftTop.y = 100; // set defaults if the box is off of the screen
    }

    SetWindowPos (
                    ghWndMain,
                    NULL,
                    ptLeftTop.x,
                    ptLeftTop.y,
                    0,
                    0,
                    SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOREDRAW | SWP_NOZORDER
                 );

    RegCloseKey (hKey);
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
VOID DisableDialButtons(BOOL fDisable)
{
    int IDD;

    // Disable/enable Dial button
    EnableWindow( GetDlgItem( ghWndMain, IDD_DDIAL ),!fDisable) ;

    // Disable/enable Speed dial buttons
    for ( IDD = IDD_DSPEEDDIAL1; IDD <= IDD_DSPEEDDIAL8; ++IDD )
    {
        EnableWindow(GetDlgItem(ghWndMain, IDD),!fDisable);
    }
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
VOID DialerCleanup(VOID)
{
    RECT rc;
    WORD cItem; // count of numbers in combo box
    DWORD cLastDialed;
    TCHAR szNumber[TAPIMAXDESTADDRESSSIZE];
    TCHAR szFieldName[MAXBUFSIZE];

    HKEY hKey = NULL;
    DWORD dwSize;

    RegCreateKeyEx (DIALER_REGISTRY_ROOT, DIALER_REGISTRY_PATH, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL);

    CloseTAPI(); // unregister and line close

    if(!IsIconic(ghWndMain)) // if the window is not minimized, record position
    {
        GetWindowRect(ghWndMain, &rc);
        RegSetValueEx (hKey,
                       TEXT("Main Window Left/Top"),
                       0,
                       REG_BINARY,
                       (LPBYTE)&rc,
                       sizeof(POINT));
    }

    cItem = (WORD)SendDlgItemMessage(ghWndMain, IDD_DCOMBO, CB_GETCOUNT, 0, 0);

    // write out last dialed numbers from combo box (write to INI)
    for(cLastDialed = 1; cLastDialed <= NLASTDIALED; ++cLastDialed)
    {
        if(cLastDialed <= cItem)
            SendDlgItemMessage(
                ghWndMain,
                IDD_DCOMBO,
                CB_GETLBTEXT,
                cLastDialed - 1, // it's a zero-based count
                (LPARAM)szNumber);

        else
            szNumber[0] = 0;

        wsprintf(szFieldName, TEXT("Last dialed %d"), cLastDialed);
        RegSetValueEx (hKey,
                       szFieldName,
                       0,
                       REG_SZ,
                       (LPBYTE)szNumber,
                       (lstrlen(szNumber)+1)*sizeof(TCHAR));
    }

    RegCloseKey (hKey);

    WinHelp(ghWndMain, gszHELPfilename, HELP_QUIT, 0); // unload help

    DestroyWindow(ghWndMain);
    ghWndMain = NULL;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
// unregister and line close
VOID CloseTAPI(VOID) 
{

    // unregister as call manager
    lineRegisterRequestRecipient (
                                    ghLineApp,
                                    0, // registration instance
                                    LINEREQUESTMODE_MAKECALL,
                                    FALSE
                                 );

    if ( gCurrentLineInfo.hLine )
    {
        lineClose ( gCurrentLineInfo.hLine );
        gfCurrentLineAvail = FALSE;
        gCurrentLineInfo.hLine = 0;
    }

    lineShutdown(ghLineApp);
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
INT_PTR CALLBACK MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static HICON hIcon;
    static const DWORD aMenuHelpIDs[] = 
    {
        IDD_DSPEEDDIALGRP,   (DWORD)-1,
        IDD_DNUMTODIAL,      IDH_DIALER_DIAL_NUMBER,
        IDD_DCOMBO,          IDH_DIALER_DIAL_NUMBER,
        IDD_DDIAL,           IDH_DIALER_DIAL_BUTTON,
        IDD_DSPEEDDIAL1,     IDH_DIALER_DIAL_SPEED_CHOOSE,
        IDD_DSPEEDDIAL2,     IDH_DIALER_DIAL_SPEED_CHOOSE,
        IDD_DSPEEDDIAL3,     IDH_DIALER_DIAL_SPEED_CHOOSE,
        IDD_DSPEEDDIAL4,     IDH_DIALER_DIAL_SPEED_CHOOSE,
        IDD_DSPEEDDIAL5,     IDH_DIALER_DIAL_SPEED_CHOOSE,
        IDD_DSPEEDDIAL6,     IDH_DIALER_DIAL_SPEED_CHOOSE,
        IDD_DSPEEDDIAL7,     IDH_DIALER_DIAL_SPEED_CHOOSE,
        IDD_DSPEEDDIAL8,     IDH_DIALER_DIAL_SPEED_CHOOSE,
        IDD_DSPEEDDIALTEXT1, IDH_DIALER_DIAL_SPEED_CHOOSE,
        IDD_DSPEEDDIALTEXT2, IDH_DIALER_DIAL_SPEED_CHOOSE,
        IDD_DSPEEDDIALTEXT3, IDH_DIALER_DIAL_SPEED_CHOOSE,
        IDD_DSPEEDDIALTEXT4, IDH_DIALER_DIAL_SPEED_CHOOSE,
        IDD_DSPEEDDIALTEXT5, IDH_DIALER_DIAL_SPEED_CHOOSE,
        IDD_DSPEEDDIALTEXT6, IDH_DIALER_DIAL_SPEED_CHOOSE,
        IDD_DSPEEDDIALTEXT7, IDH_DIALER_DIAL_SPEED_CHOOSE,
        IDD_DSPEEDDIALTEXT8, IDH_DIALER_DIAL_SPEED_CHOOSE,
        IDD_DBUTTON1,        IDH_DIALER_DIAL_KEYPAD,
        IDD_DBUTTON2,        IDH_DIALER_DIAL_KEYPAD,
        IDD_DBUTTON3,        IDH_DIALER_DIAL_KEYPAD,
        IDD_DBUTTON4,        IDH_DIALER_DIAL_KEYPAD,
        IDD_DBUTTON5,        IDH_DIALER_DIAL_KEYPAD,
        IDD_DBUTTON6,        IDH_DIALER_DIAL_KEYPAD,
        IDD_DBUTTON7,        IDH_DIALER_DIAL_KEYPAD,
        IDD_DBUTTON8,        IDH_DIALER_DIAL_KEYPAD,
        IDD_DBUTTON9,        IDH_DIALER_DIAL_KEYPAD,
        IDD_DBUTTONSTAR,     IDH_DIALER_DIAL_KEYPAD,
        IDD_DBUTTON0,        IDH_DIALER_DIAL_KEYPAD,
        IDD_DBUTTONPOUND,    IDH_DIALER_DIAL_KEYPAD,
        0,                   0
    };

        switch (msg)
        {
            case WM_INITDIALOG:
                hIcon = LoadIcon( ghInst, MAKEINTRESOURCE( IDI_DIALER ) );
                return TRUE;

            case WM_SYSCOMMAND:
                switch( (DWORD) wParam )
                {
                    case SC_CLOSE:                    
                        PostQuitMessage(0);
                }
                break;

                // processes clicks on controls when
                // context mode help is selected
            case WM_HELP: 
                WinHelp (
                         ( (LPHELPINFO) lParam)->hItemHandle,
                         gszHELPfilename,
                         HELP_WM_HELP,
                         (ULONG_PTR) aMenuHelpIDs
                        );
                return TRUE;

                // processes right-clicks on controls
            case WM_CONTEXTMENU:
                WinHelp (
                         (HWND)wParam,
                         gszHELPfilename,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)aMenuHelpIDs
                        );
                return TRUE;

            case WM_INITMENUPOPUP:
                // if edit menu
                if ( LOWORD(lParam) == 1 ) 
                {
                    UINT wEnable;

                    if ( GetParent( GetFocus() ) != GetDlgItem( ghWndMain, IDD_DCOMBO ) )
                    {
                        wEnable = MF_GRAYED;
                    }
                    else
                    {
                        LRESULT lSelect = SendDlgItemMessage (
                            ghWndMain,
                            IDD_DCOMBO,
                            CB_GETEDITSEL,
                            0,
                            0
                            );

                        if ( HIWORD( lSelect ) != LOWORD( lSelect ) )
                            wEnable = MF_ENABLED;
                        else
                            wEnable = MF_GRAYED;
                    }

                    EnableMenuItem((HMENU)wParam, IDM_EDIT_CUT, wEnable);
                    EnableMenuItem((HMENU)wParam, IDM_EDIT_COPY, wEnable);
                    EnableMenuItem((HMENU)wParam, IDM_EDIT_DELETE, wEnable);

                    // enable paste option is there is data 
                    // in the clipboard
                    if ( IsClipboardFormatAvailable( CF_TEXT ) )
                    {
                        if ( GetClipboardData ( CF_TEXT ) )
                        {
                            wEnable = MF_ENABLED;
                        }
                        else
                        {
                            wEnable = MF_GRAYED;
                        }
                    }
                    else
                    {
                        wEnable = MF_GRAYED;    
                    }

                }
                break;


            case WM_COMMAND:
            {
                TCHAR szName[TAPIMAXCALLEDPARTYSIZE] = {0};
                TCHAR szNumber[TAPIMAXDESTADDRESSSIZE] = {TEXT('\0')};

                switch( LOWORD( (DWORD)wParam ) )
                {
                    // FILE menu
                    case IDM_EXIT:
                        PostQuitMessage(0);                    
                        return TRUE;


                        // EDIT menu
                    case IDM_EDIT_CUT:
                        SendDlgItemMessage(ghWndMain, IDD_DCOMBO, WM_CUT, 0, 0);
                        return TRUE;

                    case IDM_EDIT_COPY:
                        SendDlgItemMessage(ghWndMain, IDD_DCOMBO, WM_COPY, 0, 0);
                        return TRUE;

                    case IDM_EDIT_PASTE:
                        SendDlgItemMessage(ghWndMain, IDD_DCOMBO, WM_PASTE, 0, 0);
                        return TRUE;

                    case IDM_EDIT_DELETE:
                        SendDlgItemMessage(ghWndMain, IDD_DCOMBO, WM_CLEAR, 0, 0);
                        return TRUE;

                    case IDM_EDIT_SPEEDDIAL:
                        DialogBoxParam (
                                        ghInst,
                                        MAKEINTRESOURCE(IDD_SD1),
                                        ghWndMain,
                                        SpeedDial1Proc,
                                        0
                                       );
                        SetFocus(GetDlgItem(ghWndMain, IDD_DDIAL));
                        return TRUE;

                        // TOOLS menu
                    case IDM_CONNECTUSING:
                        DialogBoxParam (
                                        ghInst,
                                        MAKEINTRESOURCE(IDD_CONNECTUSING),
                                        ghWndMain,
                                        ConnectUsingProc,
                                        MENU_CHOICE
                                       );
                        return TRUE;

                    case IDM_LOCATION:
                    {
                        TCHAR szCanNumber[ TAPIMAXDESTADDRESSSIZE ] = TEXT("");

                        // fetch the number to be dialed
                        if ( GetDlgItemText ( 
                                              ghWndMain,
                                              IDD_DCOMBO,
                                              szNumber,
                                              TAPIMAXDESTADDRESSSIZE
                                            )
                           )
                        {
                            // if a number exists, convert it to 
                            // its canonical form.
                            if ( !MakeCanonicalNumber ( szNumber, szCanNumber ) )
                            {
                                lstrcpy( szCanNumber, szNumber );
                            }
                        }

                        lineTranslateDialog (
                                             ghLineApp,
                                             0,
                                             TAPI_CURRENT_VERSION,
                                             ghWndMain,
                                             szCanNumber
                                            );
                        return TRUE;

                    }
                    // HELP menu
                    case IDM_HELP_CONTENTS:
                        WinHelp(ghWndMain, gszHELPfilename, HELP_CONTENTS, 0);
                        return TRUE;

                    case IDM_HELP_WHATSTHIS:
                        PostMessage(ghWndMain, WM_SYSCOMMAND, SC_CONTEXTHELP, 0);
                        return TRUE;

                    case IDM_ABOUT:
#ifdef SDKRELEASE
                        DialogBoxParam(
                                       ghInst,
                                       MAKEINTRESOURCE(IDD_ABOUT),
                                       ghWndMain,
                                       AboutProc,
                                       0
                                      );
#else
                        ShellAbout(
                                   ghWndMain,
                                   gszAppName,
                                   gszNULL,
                                   LoadIcon(ghInst, MAKEINTRESOURCE(IDI_DIALER))
                                  );
#endif
                        return TRUE;


                        // Accelerator processing
                    case IDM_ACCEL_NUMTODIAL:
                        if(GetActiveWindow() == ghWndMain)
                            SetFocus(GetDlgItem(ghWndMain, IDD_DCOMBO));
                        return TRUE;


                        // Buttons
                    case IDD_DDIAL:

                    {
                        DWORD cSDEntry;
                        TCHAR szSDNumber[TAPIMAXDESTADDRESSSIZE];
                        TCHAR szFieldName[MAXBUFSIZE];
                        HKEY hKey = NULL;
                        DWORD dwSize;

                        // check if number entered is dialable
                        if ( SendMessage (
                                          GetDlgItem(ghWndMain, IDD_DCOMBO),
                                          WM_GETTEXTLENGTH,
                                          0,
                                          0
                                         ) > 0 
                           )
                        {
                            // get the number to be dialed
                            GetDlgItemText (
                                            ghWndMain,
                                            IDD_DCOMBO,
                                            szNumber,
                                            TAPIMAXDESTADDRESSSIZE
                                           );

                            // check if it is a speed dial number.  
                            // If so choose the name to be displayed.
                            RegOpenKeyEx (DIALER_REGISTRY_ROOT, DIALER_REGISTRY_PATH, 0, KEY_READ, &hKey);
                            for( cSDEntry = 1; cSDEntry <= NSPEEDDIALS; ++cSDEntry)
                            {
                                wsprintf(szFieldName, TEXT("Number%d"), cSDEntry);
                                dwSize = sizeof (szSDNumber);
                                if (ERROR_SUCCESS ==
                                    RegQueryValueEx (hKey, szFieldName, NULL, NULL, (LPBYTE)szSDNumber, &dwSize))
                                {
                                    if ( lstrcmp(szSDNumber, szNumber) == 0 )
                                    {
                                        wsprintf( szFieldName, TEXT("Name%d"), cSDEntry);
                                        dwSize = sizeof (szName);
                                        RegQueryValueEx (hKey, szFieldName, NULL, NULL, (LPBYTE)szName, &dwSize);
                                        break;
                                    }
                                }
                            }
                            RegCloseKey (hKey);

                            SetFocus( GetDlgItem( ghWndMain, IDD_DDIAL ) );

                            // once the currentline has been set
                            // using the connect proc
                            // the user must hit dial again 
                            if ( giCurrentLine == (DWORD)-1 )
                            {
                                DialogBoxParam (
                                                ghInst,
                                                MAKEINTRESOURCE(IDD_CONNECTUSING),
                                                ghWndMain,
                                                ConnectUsingProc,
                                                INVALID_LINE
                                               );
                            }
                            else
                            {
                                AddToRedialList(szNumber);
                                InitiateCall(szNumber, szName);
                            }
                        }
                        return TRUE;
                    }


                    case IDD_DBUTTON1:
                    case IDD_DBUTTON2:
                    case IDD_DBUTTON3:
                    case IDD_DBUTTON4:
                    case IDD_DBUTTON5:
                    case IDD_DBUTTON6:
                    case IDD_DBUTTON7:
                    case IDD_DBUTTON8:
                    case IDD_DBUTTON9:
                    case IDD_DBUTTON0:
                    case IDD_DBUTTONSTAR:
                    case IDD_DBUTTONPOUND:
                    {
                        int     i;
                        TCHAR   szBuffer[TAPIMAXDESTADDRESSSIZE+1];

                        static const TCHAR digits[] = {
                                                       TEXT('1'),
                                                       TEXT('2'),
                                                       TEXT('3'),
                                                       TEXT('4'),
                                                       TEXT('5'),
                                                       TEXT('6'),
                                                       TEXT('7'),
                                                       TEXT('8'),
                                                       TEXT('9'),
                                                       TEXT('0'),
                                                       TEXT('*'),
                                                       TEXT('#')
                                                      };

                        i = (int)SendDlgItemMessage(ghWndMain,
                                               IDD_DCOMBO,
                                               WM_GETTEXT,
                                               (WPARAM)TAPIMAXDESTADDRESSSIZE+1,
                                               (LPARAM)szBuffer);

                        if (i < TAPIMAXDESTADDRESSSIZE)
                        {
                            MoveMemory(szBuffer+gdwStartSel+1,
                                       szBuffer+gdwEndSel,
                                       (i - ( gdwEndSel ) + 1)*sizeof(TCHAR) );

                            szBuffer[gdwStartSel] = digits[LOWORD(wParam) - IDD_DBUTTON1];

                            SendDlgItemMessage(ghWndMain,
                                               IDD_DCOMBO,
                                               WM_SETTEXT,
                                               0,
                                               (LPARAM)szBuffer);

                            gdwStartSel++;
                            gdwEndSel = gdwStartSel;
                        }

                        SetFocus(GetDlgItem(ghWndMain, IDD_DDIAL));
                        EnableWindow(GetDlgItem(ghWndMain, IDD_DDIAL), TRUE);

                        return TRUE;
                    }


                    case IDD_DCOMBO:

                        if (HIWORD(wParam) == CBN_SELENDOK)
                        {
                            EnableWindow( GetDlgItem(ghWndMain, IDD_DDIAL), TRUE );
                        }

                        if ((HIWORD(wParam) == CBN_SELENDOK) ||
                            (HIWORD(wParam) == CBN_SELENDCANCEL))
                        {

                            (DWORD)SendDlgItemMessage(ghWndMain,
                                IDD_DCOMBO,
                                CB_GETEDITSEL,
                                (WPARAM)&gdwStartSel,
                                (LPARAM)&gdwEndSel);
                            return FALSE;
                        }

                        if ( HIWORD( wParam ) == CBN_EDITCHANGE )
                        {
                            EnableWindow (
                                          GetDlgItem( ghWndMain, IDD_DDIAL ),
                                          (BOOL) GetWindowTextLength (
                                GetDlgItem (
                                            ghWndMain,
                                            IDD_DCOMBO
                                           )
                                )
                                         );
                            return TRUE;
                        }

                        break;

                    case IDD_DSPEEDDIAL1:
                    case IDD_DSPEEDDIAL2:
                    case IDD_DSPEEDDIAL3:
                    case IDD_DSPEEDDIAL4:
                    case IDD_DSPEEDDIAL5:
                    case IDD_DSPEEDDIAL6:
                    case IDD_DSPEEDDIAL7:
                    case IDD_DSPEEDDIAL8:
                    {
                        DWORD cSDEntry = LOWORD( (DWORD) wParam)  - IDD_DSPEEDDIAL1 + 1;
                        TCHAR szFieldName [MAXBUFSIZE];
                        TCHAR szNum[TAPIMAXDESTADDRESSSIZE] ={0};
                        TCHAR *p;
                        HKEY hKey = NULL;
                        DWORD dwSize;

                        // get information for the speed dial button
                        // from the INI file
                        RegOpenKeyEx (DIALER_REGISTRY_ROOT, DIALER_REGISTRY_PATH, 0, KEY_READ, &hKey);
                        wsprintf(szFieldName, TEXT("Name%d"), cSDEntry);
                        dwSize = sizeof (szName);
                        RegQueryValueEx (hKey, szFieldName, NULL, NULL, (LPBYTE)szName, &dwSize);

                        wsprintf(szFieldName, TEXT("%s%d"), TEXT("Number"), cSDEntry);
                        dwSize = sizeof (szNum);//gszSDNumber[cSDEntry]);
                        RegQueryValueEx (hKey, szFieldName, NULL, NULL, (LPBYTE)szNum, &dwSize);
                        RegCloseKey (hKey);
                        for (p = szNum; *p == TEXT(' '); p++);
                        lstrcpyn (gszSDNumber[cSDEntry], p, sizeof(gszSDNumber[cSDEntry])/sizeof(TCHAR));

                        // entry not set yet
                        if( gszSDNumber[cSDEntry][0] == 0 )
                        {
                            DialogBoxParam (
                                            ghInst,
                                            MAKEINTRESOURCE(IDD_SD2),
                                            ghWndMain,
                                            SpeedDial2Proc,
                                            MAKELPARAM(wParam,0)
                                           );
                        }
                        
                        // no line open
                        // once the currentline has been set
                        // using the connect proc
                        // the user must hit dial again 
                        else if ( giCurrentLine == (DWORD)-1)
                        {
                            DialogBoxParam (
                                            ghInst,
                                            MAKEINTRESOURCE(IDD_CONNECTUSING),
                                            ghWndMain,
                                            ConnectUsingProc,
                                            INVALID_LINE
                                           );
                        }
                        // entry is set and valid voice line is open
                        else
                        {
                            // add number to list box combo.
                            AddToRedialList( gszSDNumber[cSDEntry] );
                            InitiateCall( gszSDNumber[cSDEntry], szName );
                        }
                        break;
                    }
                } // end switch (LOWORD((DWORD)wParam)) { ... }

                break; // end case WM_COMMAND
            }

            case WM_PAINT:
            {
                PAINTSTRUCT ps;


                BeginPaint(ghWndMain, &ps);

                if(IsIconic(ghWndMain))
                    DrawIcon(ps.hdc, 0, 0, hIcon);
                else
                {
                    HBRUSH hBrush;

                    hBrush = GetSysColorBrush( COLOR_3DFACE );
                    //                FillRect(ps.hdc, &ps.rcPaint, GetStockObject(LTGRAY_BRUSH));
                    FillRect(ps.hdc, &ps.rcPaint, hBrush);
                }

                EndPaint(ghWndMain, &ps);

                return TRUE;
            }


            case WM_CTLCOLORLISTBOX:
            case WM_CTLCOLORBTN:
            case WM_CTLCOLORSTATIC:
                SetBkColor((HDC)wParam, GetSysColor(COLOR_BTNFACE));
                return (INT_PTR)GetSysColorBrush( COLOR_3DFACE );


            default:
                ;
                //            return DefDlgProc( hwnd, msg, wParam, lParam );
                //            return DefWindowProc( hwnd, msg, wParam, lParam );


        } // switch (msg) { ... }

    return FALSE;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
VOID AddToRedialList( LPCTSTR szNumber )
{
    // NLASTDIALED == 10
    WORD cNum;
    HWND hWndCombo = GetDlgItem(ghWndMain, IDD_DCOMBO);
    DWORD nMatch;

    // if valid number
    if ( szNumber[0] ) 
    {
        // if list box has entries, check if this number
        // is already present.  If so delete old entry
        cNum = (WORD) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0);
        if ( cNum != 0 )
        {
            nMatch = (int)SendMessage ( hWndCombo, CB_FINDSTRING, 0, (LPARAM)szNumber );
            if ( nMatch != CB_ERR )
            {
                SendMessage(hWndCombo, CB_DELETESTRING, nMatch, 0);
            }
            else 
            {
                // if the list is full, remove oldest
                if ( cNum == NLASTDIALED )
                {
                    SendMessage( hWndCombo, CB_DELETESTRING, NLASTDIALED - 1, 0 );
                }
            }
        }
        SendMessage(hWndCombo, CB_INSERTSTRING, 0, (LPARAM)szNumber);
        SendMessage(hWndCombo, CB_SETCURSEL, 0, 0L);
        EnableWindow ( GetDlgItem( ghWndMain, IDD_DDIAL ), TRUE ); 
    }
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
VOID InitiateCall ( LPCTSTR szNumber, LPCTSTR szName )
{
    HLINE hLine = 0;

    DWORD errCode;

    // struct size info
    DWORD dwLTPSize    = sizeof ( LINETRANSLATEOUTPUT );
    DWORD dwNameLen    = lstrlen( szName ) + 1;
    DWORD dwLCPSize    = sizeof( LINECALLPARAMS );

    LPLINETRANSLATEOUTPUT lpTransOut = NULL;
    LPLINECALLPARAMS lpLineCallParams = NULL;

    TCHAR szCanNumber[ TAPIMAXDESTADDRESSSIZE ];

    // Open a line
    errCode = lineOpen (
                        ghLineApp,
                        giCurrentLine,
                        &hLine,
                        gCurrentLineInfo.dwAPIVersion,
                        0,
                        0, 
                        LINECALLPRIVILEGE_NONE,
                        0,
                        NULL
                       );
    if (errCode)
    {
        errString ( ghWndMain, errCode, MB_ICONEXCLAMATION | MB_OK );
        goto error;
    }

    
    // call translate address before dialing
    do
    {
        lpTransOut = (LPLINETRANSLATEOUTPUT) DialerAlloc( dwLTPSize );
        if ( !lpTransOut )
        {
            errString( ghWndMain, LINEERR_NOMEM, MB_ICONSTOP | MB_OK );
            goto error;
        }
        lpTransOut-> dwTotalSize = dwLTPSize;


        if ( !MakeCanonicalNumber( szNumber, szCanNumber ) )
        {
            lstrcpy( szCanNumber, szNumber );
        }

        errCode = lineTranslateAddress (
                                        ghLineApp,
                                        giCurrentLine,
                                        gCurrentLineInfo.dwAPIVersion,
                                        szCanNumber,
                                        0,
                                        0,
                                        lpTransOut
                                       );
        if ( ((LONG)errCode) < 0 )
        {
            errString( ghWndMain, errCode, MB_ICONEXCLAMATION | MB_OK );
            goto error;
        }
        
        if ( lpTransOut-> dwNeededSize <= lpTransOut->dwTotalSize  )
        {
            // ok we are done
            break;
        }
        else
        {
            dwLTPSize = lpTransOut-> dwNeededSize;
            DialerFree ( lpTransOut );
            lpTransOut = NULL;
        }

    } while ( TRUE );

    
    // if number dialed is 911, bring up a warning
    if ( Is911( lpTransOut) )
    {
        INT nRes = errString ( ghWndMain, ERR_911WARN, MB_ICONSTOP | MB_YESNO );
        if ( nRes == IDNO )
        {
            goto error;
        }
    }

    
    // set call parameters
    dwLCPSize += dwNameLen + lpTransOut-> dwDisplayableStringSize;

    lpLineCallParams = (LPLINECALLPARAMS) DialerAlloc( dwLCPSize );
    if ( !lpLineCallParams )
    {
        errString( ghWndMain, LINEERR_NOMEM, MB_ICONSTOP | MB_OK );
        goto error;
    }

    lpLineCallParams->dwTotalSize = dwLCPSize;
    lpLineCallParams->dwBearerMode = LINEBEARERMODE_VOICE;
    lpLineCallParams->dwMediaMode = LINEMEDIAMODE_INTERACTIVEVOICE;
    lpLineCallParams->dwCallParamFlags = LINECALLPARAMFLAGS_IDLE;
    lpLineCallParams->dwAddressMode = LINEADDRESSMODE_ADDRESSID;
    lpLineCallParams->dwAddressID = giCurrentAddress;

    if ( szName[ 0 ] )
    {
        lpLineCallParams->dwCalledPartySize = dwNameLen;
        lpLineCallParams->dwCalledPartyOffset = sizeof( LINECALLPARAMS );
        lstrcpy ((LPTSTR)((char*)lpLineCallParams + sizeof(LINECALLPARAMS)),
                 szName);
    }

    lpLineCallParams-> dwDisplayableAddressSize = lpTransOut-> dwDisplayableStringSize;
    lpLineCallParams-> dwDisplayableAddressOffset = sizeof( LINECALLPARAMS ) + dwNameLen;
        
    lstrcpy (
                (LPTSTR) ((char*)lpLineCallParams + sizeof(LINECALLPARAMS) + dwNameLen),
                (LPTSTR) ((char*)lpTransOut + lpTransOut-> dwDisplayableStringOffset)
            );


    // save dialing information
    // Free old allocs.
    if ( gszCurrentName )
    {
        DialerFree ( gszCurrentName );
    }

    if ( gszCurrentNumber )
    {
        DialerFree ( gszCurrentNumber );
    }

    // save new stuff
    gszCurrentName = (LPTSTR) DialerAlloc( dwNameLen*sizeof(TCHAR) );
    if ( !gszCurrentName )
    {
        errString( ghWndMain, LINEERR_NOMEM, MB_ICONSTOP | MB_OK );
        goto error;
    }
    lstrcpy ( gszCurrentName, szName ); 

    gszCurrentNumber = (LPTSTR) DialerAlloc( lpTransOut->dwDisplayableStringSize);
    if ( !gszCurrentNumber )
    {
        errString( ghWndMain, LINEERR_NOMEM, MB_ICONSTOP | MB_OK );
        goto error;
    }
    lstrcpy ( 
             gszCurrentNumber, 
             (LPTSTR) ((char*)lpTransOut + lpTransOut-> dwDisplayableStringOffset)
            );

    gCurrentLineInfo.hLine = hLine;
    ghCall = 0;


    // finally make the call.
    gMakeCallRequestID = 0;

    gMakeCallRequestID = lineMakeCall ( 
                                        hLine, 
                                        &ghCall, 
                                        (LPTSTR) ((char*)lpTransOut + lpTransOut-> dwDialableStringOffset),
                                        0, 
                                        lpLineCallParams 
                                      );

    // async request ID 
    // - the call is going out
    if ( (LONG) gMakeCallRequestID > 0 ) 
    {
        gfCurrentLineAvail = FALSE;
        gfMakeCallReplyPending = TRUE;
        DialogBoxParam (
                        ghInst,
                        MAKEINTRESOURCE(IDD_DIALING),
                        ghWndMain,
                        DialingProc,
                        0
                       );

    }

    else 
    {
        if ( gMakeCallRequestID == LINEERR_CALLUNAVAIL ) 
        {
            DialogBoxParam (
                            ghInst,
                            MAKEINTRESOURCE(IDD_CALLFAILED),
                            ghWndMain,
                            LineInUseProc,
                            0
                           );
        }

        else
        {
            errString( ghWndMain, gMakeCallRequestID, MB_ICONEXCLAMATION | MB_OK );
        }

        DialerLineClose();
        gfCurrentLineAvail = TRUE;
    }

error :
    if ( lpLineCallParams )
    {
        DialerFree( lpLineCallParams );
    }

    if ( lpTransOut )
    {
        DialerFree( lpTransOut );
    }

    // if makecall did not succeed but line
    // was opened, close it.
    if ( ( gMakeCallRequestID <= 0 ) && ( gCurrentLineInfo.hLine ) )
    {
        DialerLineClose ();
        gfCurrentLineAvail = TRUE;
    }

    SetFocus( GetDlgItem( ghWndMain, IDD_DCOMBO ) );

    return;

}



//***************************************************************************
//***************************************************************************
//***************************************************************************
DWORD GetLineInfo ( DWORD iLine, LPLINEINFO lpLineInfo )
{
    DWORD errCode = 0;
    DWORD dwNeededSize = 0; 
    LINEEXTENSIONID ExtensionID;

    LPTSTR pszLineName = NULL; 
    LPLINEDEVCAPS lpDevCaps = NULL;

    int lineNameLen;


    errCode = lineNegotiateAPIVersion (
                                        ghLineApp,
                                        iLine,
                                        TAPI_VERSION_1_0,
                                        TAPI_CURRENT_VERSION,
                                        &( lpLineInfo->dwAPIVersion ),
                                        &ExtensionID
                                      );
    if ( errCode )
    {
        GetLineInfoFailed( iLine, lpDevCaps, lpLineInfo );
        goto error;
    }

    dwNeededSize = sizeof( LINEDEVCAPS );
    do
    {
        lpDevCaps = ( LPLINEDEVCAPS ) DialerAlloc( dwNeededSize );
        if ( !lpDevCaps )
        {
            GetLineInfoFailed( iLine, lpDevCaps, lpLineInfo );
            errCode = LINEERR_NOMEM;
            goto error;
        }

        lpDevCaps->dwTotalSize = dwNeededSize;
        errCode = lineGetDevCaps (
                                    ghLineApp,
                                    iLine,
                                    lpLineInfo->dwAPIVersion,
                                    0,
                                    lpDevCaps
                                 );
        if ( errCode )
        {
            GetLineInfoFailed( iLine, lpDevCaps, lpLineInfo );
            goto error;
        }

        if ( lpDevCaps-> dwNeededSize <= lpDevCaps-> dwTotalSize )
        {
            break;
        }

        dwNeededSize = lpDevCaps->dwNeededSize;
        DialerFree( lpDevCaps );
        lpDevCaps = NULL;

    } while ( TRUE );


    lpLineInfo->nAddr = lpDevCaps->dwNumAddresses;
    lpLineInfo->fVoiceLine =
        ( (lpDevCaps->dwMediaModes & LINEMEDIAMODE_INTERACTIVEVOICE) != 0 );

    pszLineName = (LPTSTR) DialerAlloc( MAXBUFSIZE*sizeof(TCHAR) );
    if ( !pszLineName )
    {
        errCode = LINEERR_NOMEM;
        goto error;
    }

    if ( lpDevCaps->dwLineNameSize > 0 )
    {
        lineNameLen = 1 + (lpDevCaps->dwLineNameSize / sizeof (TCHAR));
        if (lineNameLen > MAXBUFSIZE)
        {
            lstrcpyn ( 
                     pszLineName, 
                     (LPTSTR) ((char*)lpDevCaps + lpDevCaps->dwLineNameOffset),
                     MAXBUFSIZE
                    );
        }
        else
        {
            lstrcpyn (
                      pszLineName,
                      (LPTSTR) ((char*)lpDevCaps + lpDevCaps->dwLineNameOffset),
                      lineNameLen);
        }
    }
    else 
    {
        wsprintf ( pszLineName, TEXT("Line %d"), iLine );
    }


    lstrcpy( lpLineInfo->szLineName, pszLineName );
    lpLineInfo->dwPermanentLineID = lpDevCaps->dwPermanentLineID;

    
error:
    if ( lpDevCaps )
        DialerFree( lpDevCaps );

    if ( pszLineName )
        DialerFree( pszLineName );

    return errCode; 
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
VOID GetLineInfoFailed ( DWORD iLine, LPLINEDEVCAPS lpDevCaps, LPLINEINFO lpLineInfo )
{
    if ( lpDevCaps ) 
        DialerFree(lpDevCaps);

    lpLineInfo->nAddr = 0;
    lpLineInfo->fVoiceLine = FALSE;
    lpLineInfo->dwAPIVersion = 0; 
    lpLineInfo->hLine = (HLINE)0;
    lpLineInfo->dwPermanentLineID = 0;
    lpLineInfo->szLineName[0] = 0;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
LPTSTR GetAddressName(DWORD iLine, DWORD iAddress)
{
    DWORD errCode = 0;
    DWORD dwNeededSize = 0;       
    LPTSTR pszAddressName = NULL;
    LPLINEADDRESSCAPS lpAddressCaps = NULL;

    // allocate space for lineGetAddressCaps data
    dwNeededSize = sizeof( LINEADDRESSCAPS );
    
    do
    {
        lpAddressCaps = ( LPLINEADDRESSCAPS )DialerAlloc( dwNeededSize );
        if ( !lpAddressCaps )
        {
            goto error;
        }

        lpAddressCaps->dwTotalSize = dwNeededSize;
        errCode = lineGetAddressCaps (
                                        ghLineApp,
                                        iLine,
                                        iAddress,
                                        gCurrentLineInfo.dwAPIVersion,
                                        0,
                                        lpAddressCaps
                                     );
        if ( errCode )
        {
            errString (NULL, errCode, MB_ICONSTOP | MB_OK );
            goto error;
        }

        if ( lpAddressCaps-> dwNeededSize <= lpAddressCaps-> dwTotalSize )
        {
            break;
        }

        dwNeededSize = lpAddressCaps->dwNeededSize;
        DialerFree( lpAddressCaps );
        lpAddressCaps = NULL;

    } while( TRUE );


    // get the address name
    pszAddressName = DialerAlloc( MAXBUFSIZE * sizeof(TCHAR));
    if ( !pszAddressName )
    {
        goto error;
    }

    if ( lpAddressCaps-> dwAddressSize > 0 )
    {
        // keep string length bounded
        if ( lpAddressCaps-> dwAddressSize > (MAXBUFSIZE - 1 ) )
        {
            lstrcpyn( 
                    pszAddressName, 
                    (LPTSTR) ((char*)lpAddressCaps + lpAddressCaps->dwAddressOffset),
                    MAXBUFSIZE
                   );
            pszAddressName[ MAXBUFSIZE - 1] = '\0';
        }
        else
        {
            lstrcpy ( 
                     pszAddressName,
                     (LPTSTR) ((char*)lpAddressCaps + lpAddressCaps->dwAddressOffset)
                    );
        }
    }
    else 
    // use default name
    {
        wsprintf(pszAddressName, TEXT("Address %d"), iAddress);
    }

error:
    if ( lpAddressCaps )
    {
        DialerFree( lpAddressCaps );
    }

    return pszAddressName;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
INT_PTR CALLBACK DialingProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{

    switch(msg)
    {
        TCHAR szTemp[ TAPIMAXCALLEDPARTYSIZE ];

        case WM_INITDIALOG:
            // set global handle to window
            ghWndDialing = hwnd;

            AmpersandCompensate( gszCurrentName, szTemp );
            
            SetDlgItemText(hwnd, IDD_DGNUMBERTEXT, gszCurrentNumber);
            SetDlgItemText(hwnd, IDD_DGNAMETEXT, szTemp );
            break;

        case WM_COMMAND:
            switch ( LOWORD( (DWORD)wParam ) )
            {
                // hang up
                case IDCANCEL: 
                    // if lineMakeCall has completed
                    // only then drop call.
                    if (!gfMakeCallReplyPending && ghCall )
                    {
                        if ( ( gDropCallRequestID = lineDrop ( ghCall, NULL, 0 ) ) < 0 )
                        {
                            errString ( ghWndDialing, gDropCallRequestID, MB_ICONSTOP | MB_OK );
                        }
                    }
                    else
                    {
                        DialerLineClose();
                        gfCurrentLineAvail = TRUE;
                        gfMakeCallReplyPending = FALSE;
                    }

                    ghWndDialing = NULL;
                    EndDialog(hwnd, FALSE);

                    return TRUE;


                // something else terminated the call
                // all we have to do is terminate this dialog box
                case IDOK: 
                    ghWndDialing = NULL;
                    EndDialog(hwnd, TRUE);

                    return TRUE;
            }
            break;

        default:
          ;
    }
    return FALSE;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
INT_PTR CALLBACK AboutProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
    {
    switch(msg)
        {
        case WM_INITDIALOG:
            {
            TCHAR sz[MAXBUFSIZE];
            TCHAR szLabel[MAXBUFSIZE];

            // sets up the version number for Windows
            GetDlgItemText(hwnd, IDD_ATEXTTITLE, sz, MAXBUFSIZE);
            wsprintf(
                szLabel,
                sz,
                LOWORD(GetVersion()) & 0xFF,
                HIBYTE(LOWORD(GetVersion)) == 10 ? 1 : 0
                );
            SetDlgItemText(hwnd, IDD_ATEXTTITLE, szLabel);

            return TRUE;
            }

        case WM_COMMAND:
            if(LOWORD((DWORD)wParam) == IDOK)
                {
                EndDialog(hwnd, TRUE);
                return TRUE;
                }
            break;
        }
    return FALSE;
    }



//***************************************************************************
//***************************************************************************
//***************************************************************************
INT_PTR CALLBACK ConnectUsingProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    static const DWORD aMenuHelpIDs[] = 
    {
        IDD_CUTEXTLINE,         IDH_DIALER_OPTIONS_LINE,
        IDD_CULISTLINE,         IDH_DIALER_OPTIONS_LINE,
        IDD_CUTEXTADDRESS,      IDH_DIALER_OPTIONS_ADDRESS,
        IDD_CULISTADDRESS,      IDH_DIALER_OPTIONS_ADDRESS,
        IDD_CUSIMPLETAPICHKBOX, IDH_DIALER_OPTIONS_VOICE,
        IDD_CUPROPERTIES,       IDH_DIALER_OPTIONS_PROPERTIES,
        0,                      0
    };

    switch(msg)
    {
        case WM_HELP: 
            // processes clicks on controls when
            // context mode help is selected
            WinHelp (
                        ((LPHELPINFO)lParam)->hItemHandle,
                        gszHELPfilename,
                        HELP_WM_HELP,
                        (ULONG_PTR)aMenuHelpIDs
                    );
            return TRUE;

        case WM_CONTEXTMENU:
            // processes right-clicks on controls
            WinHelp (
                        (HWND)wParam,
                        gszHELPfilename,
                        HELP_CONTEXTMENU,
                        (ULONG_PTR)aMenuHelpIDs
                    );
            return TRUE;

        case WM_INITDIALOG:
        {
            BOOL fEnable;
            DWORD dwPriority;

            //
            // Is there any point in even showing this dialog box?
            if ( gnAvailDevices == 0 )
            {
                // Nope.  Let's tell the user what we don't like.
                errString ( ghWndMain, ERR_NOLINES, MB_ICONEXCLAMATION | MB_OK );

                EndDialog(hwnd, FALSE);
                return TRUE;
            }

            // if not brought up by InitializeTAPI()
            if ( lParam != INVALID_LINE ) 
            {
                // hide error text
                EnableWindow( GetDlgItem( hwnd, IDD_CUERRORTEXT ), FALSE );
            }

            // get list of lines into the line list box.
            fEnable = InitializeLineBox( GetDlgItem(hwnd, IDD_CULISTLINE) );
            EnableWindow( GetDlgItem( hwnd, IDD_CULISTLINE ), fEnable);

            // get list of addresses into the address list box.
            fEnable =    fEnable && 
                        InitializeAddressBox (
                                                GetDlgItem(hwnd, IDD_CULISTLINE),
                                                GetDlgItem(hwnd, IDD_CULISTADDRESS)
                                             );
            EnableWindow( GetDlgItem( hwnd, IDD_CULISTADDRESS ), fEnable );
            EnableWindow( GetDlgItem( hwnd, IDOK ), fEnable );

            EnableWindow( GetDlgItem( hwnd, IDD_CUPROPERTIES ), fEnable );

            lineGetAppPriority (
                                TEXT("DIALER.EXE"),
                                0, // checking app priority for Assisted Telephony requests
                                NULL,
                                LINEREQUESTMODE_MAKECALL,
                                NULL,
                                &dwPriority
                               );
            CheckDlgButton(hwnd, IDD_CUSIMPLETAPICHKBOX, (dwPriority == 1));

            // if dwPriority == 1, we're supporting Assisted Telephony AND
            // have the highest priority.
            EnableWindow (
                            GetDlgItem(hwnd, IDD_CUSIMPLETAPICHKBOX),
                            gfRegistered
                         );

            return FALSE;
        }

        case WM_COMMAND:
        {
            switch ( LOWORD( (DWORD)wParam ) )
            {
                case IDD_CULISTLINE:
                    if ( HIWORD( wParam ) == CBN_SELENDOK )
                        // update address box
                        InitializeAddressBox (
                                                GetDlgItem(hwnd, IDD_CULISTLINE),
                                                GetDlgItem(hwnd, IDD_CULISTADDRESS)
                                             ); 
                    break;

                case IDD_CUPROPERTIES:
                {
                    HWND hW = GetDlgItem(hwnd, IDD_CULISTLINE);

                    lineConfigDialog (    
                                        // device ID
                                        (DWORD) SendMessage (
                                                                hW,
                                                                CB_GETITEMDATA,
                                                                (WORD) SendMessage(hW, CB_GETCURSEL, 0, 0),
                                                                0
                                                            ), 
                                        hwnd,
                                        NULL
                                     );
                    break;
                }

                case IDOK:
                {
                    HWND hwndBox;
                    TCHAR szBuffer[MAXBUFSIZE];
                    DWORD dwPriority;
                    HKEY hKey = NULL;
                    DWORD dwSize;

                    RegCreateKeyEx (DIALER_REGISTRY_ROOT, DIALER_REGISTRY_PATH, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL);

                    // Update line
                    hwndBox = GetDlgItem( hwnd, IDD_CULISTLINE );
                    giCurrentLine = (int) SendMessage (
                                                    hwndBox,
                                                    CB_GETITEMDATA,
                                                    SendMessage( hwndBox, CB_GETCURSEL, 0, 0 ),
                                                    0
                                                );

                    // base 10
     