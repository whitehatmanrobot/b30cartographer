------



PWSTR g_wzRootDSE = L"RootDSE";
PWSTR g_wzSchemaNamingContext = L"schemaNamingContext";
PWSTR g_wzLDAPAbstractSchemaFormat = L"LDAP://%s/schema/%s";


//
// Attribute names:
//
PWSTR g_wzDescription = L"description"; // ADSTYPE_CASE_IGNORE_STRING
PWSTR g_wzName = L"name";               // ADSTYPE_CASE_IGNORE_STRING
PWSTR g_wzMemberAttr = L"member";       // ADSTYPE_DN_STRING


#define _WIZ_FULL_CTRL _GRANT_ALL

// turn off check for warning C4127: conditional expression is constant
#pragma warning (disable : 4127)

///////////////////////////////////////////////////////////////////////
// CWString

BOOL CWString::LoadFromResource(UINT uID)
{
  int nBufferSize = 128;
  static const int nCountMax = 4;
  int nCount = 1;

  do 
  {
    LPWSTR lpszBuffer = (LPWSTR)alloca(nCount*nBufferSize*sizeof(WCHAR));
	  int iRet = ::LoadString(_Module.GetResourceInstance(), uID, 
					  lpszBuffer, nBufferSize);
	  if (iRet == 0)
	  {
		  (*this) = L"?";
		  return FALSE; // not found
	  }
	  if (iRet == nBufferSize-1) // truncation
    {
      if (nCount > nCountMax)
      {
        // too many reallocations
        (*this) = lpszBuffer;
        return FALSE; // truncation
      }
      // try to expand buffer
      nBufferSize *=2;
      nCount++;
    }
    else
    {
      // got it
      (*this) = lpszBuffer;
      break;
    }
  }
  while (TRUE);


	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////////

// catenate the server name and the 1779 name
// to get an LDAP path like "LDAP://myserv.foo.com./cn=host,..."
void BuildLdapPathHelper(LPCWSTR lpszServerName, LPCWSTR lpszNamingContext, CWString& szLdapPath)
{
  static LPCWSTR lpszFmt = L"LDAP://%s/%s";
  int nServerNameLen = lstrlen(lpszServerName)+1;
	int nFormatStringLen = lstrlen(lpszFmt)+1;
  int nNamingContext = lstrlen(lpszNamingContext)+1;
  
	// build the LDAP path for the schema class
	WCHAR* pwszNewObjectPath = 
		(WCHAR*)alloca(sizeof(WCHAR)*(nServerNameLen+nFormatStringLen+nNamingContext));
	wsprintf(pwszNewObjectPath, lpszFmt, lpszServerName, lpszNamingContext);

  szLdapPath = pwszNewObjectPath;
}


// catenate the server name and the 1779 name
// to get something like "\\myserv.foo.com.\cn=host,..."
void BuildWin32PathHelper(LPCWSTR lpszServerName, LPCWSTR lpszNamingContext, CWString& szWin32Path)
{
  static LPCWSTR lpszFmt = L"\\\\%s\\%s";
  int nServerNameLen = lstrlen(lpszServerName)+1;
	int nFormatStringLen = lstrlen(lpszFmt)+1;
  int nNamingContext = lstrlen(lpszNamingContext)+1;
  
	// build the LDAP path for the schema class
	WCHAR* pwszNewObjectPath = 
		(WCHAR*)alloca(sizeof(WCHAR)*(nServerNameLen+nFormatStringLen+nNamingContext));
	wsprintf(pwszNewObjectPath, lpszFmt, lpszServerName, lpszNamingContext);

  szWin32Path = pwszNewObjectPath;
}

HRESULT GetCanonicalNameFromNamingContext(LPCWSTR lpszNamingContext, CWString& szCanonicalName)
{
  szCanonicalName = L"";

  // assume in the form "cn=xyz,..."
  LPWSTR lpszCanonicalName = NULL;
  HRESULT hr = CrackName((LPWSTR)lpszNamingContext, &lpszCanonicalName, GET_OBJ_CAN_NAME);
  if (SUCCEEDED(hr) && (lpszCanonicalName != NULL))
  {
    szCanonicalName = lpszCanonicalName;
  }
  if (lpszCanonicalName != NULL)
    ::LocalFree(lpszCanonicalName);
  return hr;
}

/////////////////////////////////////////////////////////////////////////

class CContainerProxyBase
{
public:
  CContainerProxyBase() { } 
  virtual ~CContainerProxyBase() {}
  virtual BOOL Add(LPCWSTR lpsz) = 0;
};


template <class TOBJ, class TARR, class TFILTR> class CContainerProxy 
        : public CContainerProxyBase
{
public:
  CContainerProxy(TARR* pArr, TFILTR* pFilter)
  {
    m_pArr = pArr;
    m_pFilter = pFilter;
  }
  virtual BOOL Add(LPCWSTR lpsz)
  {
    ULONG filterFlags = 0x0;
    if ( (m_pFilter == NULL) || 
          (m_pFilter->CanAdd(lpsz, &filterFlags)) )
    {
      TOBJ* p = new TOBJ(filterFlags, lpsz);
      if (p == NULL)
        return FALSE;
      return m_pArr->Add(p);
    }
    return TRUE;
  }

private:
  TARR* m_pArr;
  TFILTR* m_pFilter;
};




/////////////////////////////////////////////////////////////////////////

BOOL LoadStringHelper(UINT uID, LPTSTR lpszBuffer, int nBufferMax)
{
	int iRet = ::LoadString(_Module.GetResourceInstance(), uID, 
					lpszBuffer, nBufferMax);
	if (iRet == 0)
	{
		lpszBuffer[0] = NULL;
		return FALSE; // not found
	}
	if (iRet == nBufferMax-1)
		return FALSE; // truncation
	return TRUE;
}


BOOL GetStringFromHRESULTError(HRESULT hr, CWString& szErrorString, BOOL bTryADsIErrors)
{
  HRESULT hrGetLast = S_OK;
  DWORD status;
  PTSTR ptzSysMsg = NULL;

  // first check if we have extended ADs errors
  if ((hr != S_OK) && bTryADsIErrors) 
  {
    WCHAR Buf1[256], Buf2[256];
    hrGetLast = ::ADsGetLastError(&status, Buf1, 256, Buf2, 256);
    TRACE(_T("ADsGetLastError returned status of %lx, error: %s, name %s\n"),
          status, Buf1, Buf2);
    if ((status != ERROR_INVALID_DATA) && (status != 0)) 
    {
      hr = status;
    }
  }

  // try the system first
  int nChars = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                      | FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (PTSTR)&ptzSysMsg, 0, NULL);

  if (nChars == 0) 
  { 
    //try ads errors
    static HMODULE g_adsMod = 0;
    if (0 == g_adsMod)
      g_adsMod = GetModuleHandle (L"activeds.dll");
    nChars = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_HMODULE, g_adsMod, hr,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (PTSTR)&ptzSysMsg, 0, NULL);
  }

  if (nChars > 0)
  {
    szErrorString = ptzSysMsg;
    ::LocalFree(ptzSysMsg);
  }

  return (nChars > 0);
}



BOOL GetStringFromWin32Error(DWORD dwErr, CWString& szErrorString)
{
  return GetStringFromHRESULTError(HRESULT_FROM_WIN32(dwErr),szErrorString);
}

//
// Given a GUID struct, it returns a GUID in string format, without {}
//
BOOL FormatStringGUID(LPWSTR lpszBuf, UINT nBufSize, const GUID* pGuid)
{
  lpszBuf[0] = NULL;

  // if it is a NULL GUID*, just return an empty string
  if (pGuid == NULL)
  {
    return FALSE;
  }
  
/*
typedef struct _GUID {
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[ 8 ];
}

  int _snwprintf( wchar_t *buffer, size_t count, const wchar_t *format [, argument] ... );
*/
  return (_snwprintf(lpszBuf, nBufSize, 
            L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x", 
            pGuid->Data1, pGuid->Data2, pGuid->Data3, 
            pGuid->Data4[0], pGuid->Data4[1],
            pGuid->Data4[2], pGuid->Data4[3], pGuid->Data4[4], pGuid->Data4[5], pGuid->Data4[6], pGuid->Data4[7]) > 0);
}




//
// Given a GUID in string format (without {}) it returns a GUID struct
//
// e.g. "00299570-246d-11d0-a768-00aa006e0529" to a struct form
//

BOOL GuidFromString(GUID* pGuid, LPCWSTR lpszGuidString)
{
  ZeroMemory(pGuid, sizeof(GUID));
  if (lpszGuidString == NULL)
  {
    return FALSE;
  }

  int nLen = lstrlen(lpszGuidString);
  // the string length should be 36
  if (nLen != 36)
    return FALSE;

  // add the braces to call the Win32 API
  LPWSTR lpszWithBraces = (LPWSTR)alloca((nLen+1+2)*sizeof(WCHAR)); // NULL plus {}
  wsprintf(lpszWithBraces, L"{%s}", lpszGuidString);

  return SUCCEEDED(::CLSIDFromString(lpszWithBraces, pGuid));
}




DWORD AddEntryInAcl(PEXPLICIT_ACCESS pAccessEntry, PACL* ppAcl)
{
  // add an entry in the DACL
  PACL pOldAcl = *ppAcl;

  TRACE(L"Calling SetEntriesInAcl()\n");

  DWORD dwErr = ::SetEntriesInAcl(1, pAccessEntry, pOldAcl, ppAcl);
  
  TRACE(L"SetEntriesInAcl() returned dwErr = 0x%x\n", dwErr);

  if (dwErr == ERROR_SUCCESS && NULL != pOldAcl )
  {
    ::LocalFree(pOldAcl);
  }
  return dwErr;
}

#ifdef DBG

void TraceGuid(LPCWSTR lpszMsg, const GUID* pGuid)
{
  WCHAR szGuid[128];
  FormatStringGUID(szGuid, 128, pGuid);
  TRACE(L"%s %s\n", lpszMsg, szGuid);
}

#define TRACE_GUID(msg, pGuid)\
  TraceGuid(msg, pGuid);

#else

#define TRACE_GUID(msg, pGuid)

#endif

DWORD AddObjectRightInAcl(IN      PSID pSid, 
                          IN      ULONG uAccess, 
                          IN      const GUID* pRightGUID, 
                          IN      const GUID* pInheritGUID, 
                          IN OUT  PACL* ppAcl)
{
  // trace input parameters

  TRACE(L"AddObjectRightInAcl()\n");
  TRACE(L"ULONG uAccess = 0x%x\n", uAccess);
  TRACE_GUID(L"pRightGUID =", pRightGUID);
  TRACE_GUID(L"pInheritGUID =", pInheritGUID);


  EXPLICIT_ACCESS AccessEntry;
  ZeroMemory(&AccessEntry, sizeof(EXPLICIT_ACCESS));

  if( uAccess == 0 )
    return ERROR_SUCCESS;

  // initialize EXPLICIT_ACCESS
  AccessEntry.grfAccessPermissions = uAccess;
  AccessEntry.grfAccessMode = GRANT_ACCESS;
  AccessEntry.grfInheritance = SUB_CONTAINERS_ONLY_INHERIT;
  if (pInheritGUID != NULL)
  {
	  AccessEntry.grfInheritance	|= INHERIT_ONLY;
  }

  OBJECTS_AND_SID ObjectsAndSid;
  ZeroMemory(&ObjectsAndSid, sizeof(OBJECTS_AND_SID));


  TRACE(L"AccessEntry.grfAccessPermissions = 0x%x\n", AccessEntry.grfAccessPermissions);
  TRACE(L"AccessEntry.grfAccessMode = 0x%x\n", AccessEntry.grfAccessMode);
  TRACE(L"AccessEntry.grfInheritance = 0x%x\n", AccessEntry.grfInheritance);


  TRACE(L"BuildTrusteeWithObjectsAndSid()\n");

  BuildTrusteeWithObjectsAndSid(&(AccessEntry.Trustee), 
                              &ObjectsAndSid,
                              const_cast<GUID*>(pRightGUID),    // class, right or property
                              const_cast<GUID*>(pInheritGUID),  // inherit guid (class)
                              pSid                              // SID for user or group
                              );

  return ::AddEntryInAcl(&AccessEntry, ppAcl);
}


//////////////////////////////////////////////////////////////////////////////

long SafeArrayGetCount(const VARIANT& refvar)
{
	if (V_VT(&refvar) == VT_BSTR)
	{
    return (long)1;
	}
  if ( V_VT(&refvar) != ( VT_ARRAY | VT_VARIANT ) )
  {
    ASSERT(FALSE);
    return (long)0;
  }

  SAFEARRAY *saAttributes = V_ARRAY( &refvar );
  long start, end;
  HRESULT hr = SafeArrayGetLBound( saAttributes, 1, &start );
  if( FAILED(hr) )
    return (long)0;

  hr = SafeArrayGetUBound( saAttributes, 1, &end );
  if( FAILED(hr) )
    return (long)0;

  return (end - start + 1);
}

HRESULT VariantArrayToContainer(const VARIANT& refvar, CContainerProxyBase* pCont)
{
  HRESULT hr = S_OK;
  long start, end, current;

	if (V_VT(&refvar) == VT_BSTR)
	{
    //TRACE(_T("VT_BSTR: %s\n"),V_BSTR(&refvar));
    pCont->Add(V_BSTR(&refvar));
	  return S_OK;
	}

  //
  // Check the VARIANT to make sure we have
  // an array of variants.
  //

  if ( V_VT(&refvar) != ( VT_ARRAY | VT_VARIANT ) )
  {
    ASSERT(FALSE);
    return E_UNEXPECTED;
  }
  SAFEARRAY *saAttributes = V_ARRAY( &refvar );

  //
  // Figure out the dimensions of the array.
  //

  hr = SafeArrayGetLBound( saAttributes, 1, &start );
    if( FAILED(hr) )
      return hr;

  hr = SafeArrayGetUBound( saAttributes, 1, &end );
    if( FAILED(hr) )
      return hr;

  //
  // Process the array elements.
  //
  VARIANT SingleResult;
  for ( current = start       ;
        current <= end        ;
        current++   )
  {
    ::VariantInit( &SingleResult );
    hr = SafeArrayGetElement( saAttributes, &current, &SingleResult );
    if( FAILED(hr) )
        return hr;
    if ( V_VT(&SingleResult) != VT_BSTR )
                    return E_UNEXPECTED;

    //TRACE(_T("VT_BSTR: %s\n"),V_BSTR(&SingleResult));
    pCont->Add(V_BSTR(&SingleResult));
    VariantClear( &SingleResult );
  }
  return S_OK;
}


HRESULT GetGlobalNamingContexts(LPCWSTR lpszServerName, 
                                CWString& szPhysicalSchemaNamingContext,
                                CWString& szConfigurationNamingContext)

{
  HRESULT hr = S_OK;

  CComPtr<IADs> spRootDSE;
  CWString szRootDSEPath;

  BuildLdapPathHelper(lpszServerName, g_wzRootDSE, szRootDSEPath);
  
  hr = ::ADsOpenObjectHelper(szRootDSEPath,
                  IID_IADs,
                  (void**)&spRootDSE
                  );
  if (FAILED(hr)) 
  {
    TRACE(L"Error opening ADsOpenObjectHelper(%S), hr=%x\n", (LPCWSTR)szRootDSEPath,hr);
    return hr;
  }

  CComVariant varSchemaNamingContext;
  hr = spRootDSE->Get((PWSTR)g_wzSchemaNamingContext,
                    &varSchemaNamingContext);
  if (FAILED(hr)) 
  {
    TRACE(_T("Error spRootDSE->Get((PWSTR)g_wzSchemaNamingContext), hr=%x\n"), hr);
    return hr;
  }

  // finally get value 
  // (e.g. "cn=schema,cn=configuration,dc=marcocdev,dc=ntdev,dc=microsoft,dc=com")
  ASSERT(varSchemaNamingContext.vt == VT_BSTR);
  szPhysicalSchemaNamingContext = varSchemaNamingContext.bstrVal;


  // get the configuration container naming context
  CComVariant varConfigurationNamingContext;
  hr = spRootDSE->Get(L"configurationNamingContext",&varConfigurationNamingContext);
  if (FAILED(hr))
  {
    TRACE(L"Failed spRootDSE->Get(configurationNamingContext,&varConfigurationNamingContext), returned hr = 0x%x\n", hr);
    return hr;
  }
  ASSERT(varConfigurationNamingContext.vt == VT_BSTR);
  szConfigurationNamingContext = varConfigurationNamingContext.bstrVal;

  return hr;
}

HRESULT GetSchemaClassName(LPCWSTR lpszServerName, LPCWSTR lpszPhysicalSchemaNamingContext,
                           LPCWSTR lpszClassLdapDisplayName, // e.g. "organizationalUnit"
                           CWString& szClassName // e.g. "Organizational-Unit"
                           )
{
  szClassName = L"";

	// build the LDAP path for the schema class
  CWString szPhysicalSchemaPath;
  BuildLdapPathHelper(lpszServerName, lpszPhysicalSchemaNamingContext, szPhysicalSchemaPath);

  CAdsiSearch search;
  HRESULT hr = search.Init(szPhysicalSchemaPath);
  if (FAILED(hr))
    return hr;

  static LPCWSTR lpszFilterFormat = L"(&(objectCategory=CN=Class-Schema,%s)(lDAPDisplayName=%s))";

  int nFmtLen = lstrlen(lpszFilterFormat);
  int nSchemaContextLen = lstrlen(lpszPhysicalSchemaNamingContext);
  int nClassLen = lstrlen(lpszClassLdapDisplayName);

  WCHAR* lpszFilter = (WCHAR*)alloca(sizeof(WCHAR)*(nFmtLen+nSchemaContextLen+nClassLen+1));
  wsprintf(lpszFilter, lpszFilterFormat, lpszPhysicalSchemaNamingContext, lpszClassLdapDisplayName);

  static const int cAttrs = 1;
  static LPCWSTR pszAttribsArr[cAttrs] = {L"name"}; 
  
  hr = search.SetSearchScope(ADS_SCOPE_ONELEVEL);
  if (FAILED(hr))
    return hr;

  hr = search.DoQuery(lpszFilter, pszAttribsArr, cAttrs);
  if (FAILED(hr))
    return hr;

  // expact a single result
  hr = search.GetNextRow();
  if ( hr == S_ADS_NOMORE_ROWS)
  {
    hr = E_ADS_UNKNOWN_OBJECT;
  }
  if (FAILED(hr))
    return hr;

  hr = search.GetColumnString(pszAttribsArr[0], szClassName);
  return hr;
}




LPCWSTR g_lpszSummaryIdent = L"    ";
LPCWSTR g_lpszSummaryNewLine = L"\r\n";


void WriteSummaryTitleLine(CWString& szSummary, UINT nTitleID, LPCWSTR lpszNewLine)
{
  CWString szTemp;
  szTemp.LoadFromResource(nTitleID);
  WriteSummaryLine(szSummary, szTemp, NULL, lpszNewLine);
  szSummary += lpszNewLine;
}


void WriteSummaryLine(CWString& szSummary, LPCWSTR lpsz, LPCWSTR lpszIdent, LPCWSTR lpszNewLine)
{
  if (lpszIdent != NULL)
    szSummary += lpszIdent;
  szSummary += lpsz;
  szSummary += lpszNewLine;
}



//////////////////////////////////////////////////////////////////////////////

LPCWSTR _GetFilePath()
{
  static LPCWSTR g_lpszFileName = L"\\system32\\dssec.dat";
  static WCHAR g_lpszFilePath[2*MAX_PATH] = L"";

  if (g_lpszFilePath[0] == NULL)
  {
  	UINT nLen = ::GetSystemWindowsDirectory(g_lpszFilePath, MAX_PATH);
	  if (nLen == 0)
		  return NULL;
    wcscat(g_lpszFilePath, g_lpszFileName);
  }
  return g_lpszFilePath;
}




ULONG GetClassFlags(LPCWSTR lpszClassName)
{
  LPCWSTR lpszAttr = L"@";
  INT nDefault = 0;
  return ::GetPrivateProfileInt(lpszClassName, lpszAttr, nDefault, _GetFilePath());
  //return nDefault;
}



/////////////////////////////////////////////////////////////////////////////
// CFilterEntry

class CFilterEntry
{
public:
  CFilterEntry(LPWSTR lpszEntry)
  {
    m_lpszName = lpszEntry;
    m_nFlags = 0;
    Parse();
  }
  LPCWSTR m_lpszName;
  ULONG m_nFlags;

  bool operator<(CFilterEntry& x) 
  { 
      UNREFERENCED_PARAMETER (x);
      return false;
  }

private:
  void Parse()
  {
    WCHAR* p = (WCHAR*)m_lpszName;
    while (*p != NULL)
    {
      if (*p == TEXT('='))
      {
        *p = NULL;
        m_nFlags = _wtoi(p+1);
        break;
      }
      p++;
    }
  }

};

class CFilterEntryHolder
{
public:
  CFilterEntryHolder()
  {
    m_pCharBuf = NULL;
    m_dwCharBufSize = 0;
  }
  ~CFilterEntryHolder()
  {
    if (m_pCharBuf != NULL)
      free(m_pCharBuf);
  }

  ULONG GetAttributeFlags(LPCWSTR lpszClassName, LPCWSTR lpszAttr);

private:
  CWString m_szClassName;
  CGrowableArr<CFilterEntry> m_entries;
  WCHAR* m_pCharBuf;
  DWORD m_dwCharBufSize;

  BOOL _ReadFile();
  void _LoadFromFile();
  ULONG _FindInCache(LPCWSTR lpszAttr);

};


BOOL CFilterEntryHolder::_ReadFile()
{
  if (m_pCharBuf == NULL)
  {
    m_dwCharBufSize = 4096;
    m_pCharBuf = (WCHAR*)malloc(sizeof(WCHAR)*m_dwCharBufSize);
  }
  if (m_pCharBuf == NULL)
    return FALSE;

  BOOL bNeedRealloc = FALSE;
  int nReallocCount = 0;
  do
  {
    DWORD dwCharCount = ::GetPrivateProfileSection(m_szClassName, 
                        m_pCharBuf, m_dwCharBufSize,  _GetFilePath());
    if (dwCharCount == 0)
      return FALSE;
    bNeedRealloc = dwCharCount  == (m_dwCharBufSize - 2);
    if (bNeedRealloc)
    {
      if (nReallocCount > 4)
        return FALSE;
      m_dwCharBufSize = 2*m_dwCharBufSize;
      m_pCharBuf = (WCHAR*)realloc(m_pCharBuf, sizeof(WCHAR)*m_dwCharBufSize);
      nReallocCount++;
    }
  }
  while (bNeedRealloc);
  return TRUE;
}

void CFilterEntryHolder::_LoadFromFile()
{
  m_entries.Clear();
  if (!_ReadFile())
    return;

  WCHAR* p = m_pCharBuf;
  WCHAR* pEntry = p;

  while ( ! (( *p == NULL ) && ( *(p+1) == NULL )) )
  {
    if (*p == NULL)
    {
      TRACE(_T("pEntry = <%s>\n"), pEntry);
      m_entries.Add(new CFilterEntry(pEntry));
      pEntry = p+1;
    }
    p++;
  }
  if ( pEntry < p)
    m_entries.Add(new CFilterEntry(pEntry)); // add the last one

  for (ULONG k=0; k<m_entries.GetCount(); k++)
  {
    TRACE(_T("k = %d, <%s> flags = %d\n"), k, m_entries[k]->m_lpszName, m_entries[k]->m_nFlags);
  }
}

ULONG CFilterEntryHolder::_FindInCache(LPCWSTR lpszAttr)
{
  for (ULONG k=0; k<m_entries.GetCount(); k++)
  {
    if (_wcsicmp(m_entries[k]->m_lpszName, lpszAttr) == 0)
      return m_entries[k]->m_nFlags;
  }
  return 0; // default
}


ULONG CFilterEntryHolder::GetAttributeFlags(LPCWSTR lpszClassName, LPCWSTR lpszAttr)
{
  if (_wcsicmp(lpszClassName, m_szClassName) != 0)
  {
    // class name changed
     m_szClassName = lpszClassName;
    _LoadFromFile();
  }
  return _FindInCache(lpszAttr);
}


ULONG GetAttributeFlags(LPCWSTR lpszClassName, LPCWSTR lpszAttr)
{
  static CFilterEntryHolder g_holder;
  return g_holder.GetAttributeFlags(lpszClassName, lpszAttr);
//  INT nDefault = 0;
//  return ::GetPrivateProfileInt(lpszClassName, lpszAttr, nDefault, _GetFilePath());
  //return nDefault;
}



///////////////////////////////////////////////////////////////////////
// CPrincipal


HRESULT CPrincipal::Initialize(PDS_SELECTION pDsSelection, HICON hClassIcon)
{

  TRACE(_T("pwzName = %s\n"), pDsSelection->pwzName);   // e.g. JoeB
  TRACE(_T("pwzADsPath = %s\n"), pDsSelection->pwzADsPath); // "LDAP:..." or "WINNT:..."
  TRACE(_T("pwzClass = %s\n"), pDsSelection->pwzClass); // e.g. "user"
  TRACE(_T("pwzUPN = %s\n"), pDsSelection->pwzUPN); // .e.g. "JoeB@acme.com."

  WCHAR  const c_szClassComputer[] = L"computer";

  // get the SID
  ASSERT(pDsSelection->pvarFetchedAttributes);
  if (pDsSelection->pvarFetchedAttributes[0].vt == VT_EMPTY)
  {
    TRACE(L"CPrincipal::Initialize() failed on VT_EMPTY sid\n");
    // fatal error, we cannot proceed
    return E_INVALIDARG;
  }
  if (pDsSelection->pvarFetchedAttributes[0].vt != (VT_ARRAY | VT_UI1))
  {
    TRACE(L"CPrincipal::Initialize() failed on (VT_ARRAY | VT_UI1) sid\n");
    // fatal error, we cannot proceed
    return E_INVALIDARG;
  }

  // make sure we have a good SID
  PSID pSid = pDsSelection->pvarFetchedAttributes[0].parray->pvData;
  HRESULT   hr = Initialize (pSid);
  if ( FAILED (hr) )
      return hr;

  // copy the icon
  m_hClassIcon = hClassIcon;
  // copy the strings
  m_szClass = pDsSelection->pwzClass;

  //Strip from Computer Name
  //16414	02/28/2000	*DS Admin snapin - DelWiz, need to strip the '$' from the end of computer names

  m_szName = pDsSelection->pwzName;
  if( m_szClass && m_szName && ( wcscmp( m_szClass, (LPWSTR)c_szClassComputer) == 0 ) )
  {
    // Strip the trailing '$'
    LPWSTR pszTemp; 
    pszTemp= (LPWSTR)(LPCWSTR)m_szName;
    int nLen = lstrlen(pszTemp);
    if (nLen && pszTemp[nLen-1] == TEXT('$'))
    {
        pszTemp[nLen-1] = TEXT('\0');
    }
  }
  
  m_szADsPath = pDsSelection->pwzADsPath;

  if( m_szClass && m_szADsPath && ( wcscmp( m_szClass, (LPWSTR)c_szClassComputer) == 0 ) )
  {
    // Strip the trailing '$'
    LPWSTR pszTemp; 
    pszTemp= (LPWSTR)(LPCWSTR)m_szADsPath;
    int nLen = lstrlen(pszTemp);
    if (nLen && pszTemp[nLen-1] == TEXT('$'))
    {
        pszTemp[nLen-1] = TEXT('\0');
    }
  }

  m_szUPN = pDsSelection->pwzUPN;
  

  // set the display name
  _ComposeDisplayName();

  return S_OK; 
}

HRESULT CPrincipal::Initialize (PSID pSid)
{
  if (!IsValidSid(pSid))
  {
    TRACE(L"CPrincipal::Initialize() failed on IsValidSid()\n");
    // fatal error, we cannot proceed
    return E_INVALIDARG;
  }

  // we have a good SID, copy it
  if (!m_sidHolder.Copy(pSid))
  {
    TRACE(L"CPrincipal::Initialize() failed on m_sidHolder.Copy(pSid)\n");
    // fatal error, we cannot proceed
    return E_OUTOFMEMORY;
  }

  return S_OK;
}

BOOL BuildSamName(LPCWSTR lpszPath, CWString& s)
{
  // strip the WINNT provider and reverse slashes
  static LPCWSTR lpszPrefix = L"WinNT://";
  int nPrefixLen = lstrlen(lpszPrefix);

  if (_wcsnicmp(lpszPath, lpszPrefix, nPrefixLen ) != 0)
  {
    // not matching
    return FALSE;
  }

  // make a copy
  LPCWSTR lpzsTemp = lpszPath+nPrefixLen; // past the prefix

  s = L"";
  for (WCHAR* pChar = const_cast<LPWSTR>(lpzsTemp); (*pChar) != NULL; pChar++)
  {
    if (*pChar == L'/')
      s += L'\\';
    else
      s += *pChar;
  }
  return TRUE;
}



void CPrincipal::_ComposeDisplayName()
{
  LPCWSTR lpszAddToName = NULL;

  // check if there is a UPN
  LPCWSTR lpszUPN = m_szUPN;
  if ( (lpszUPN != NULL) && (lstrlen(lpszUPN) > 0))
  {
    lpszAddToName = lpszUPN;
  }

  // as a second chance, add the domain\name
  LPCWSTR lpszPath = m_szADsPath;
  CWString sTemp;

  if ((lpszAddToName == NULL) && (lpszPath != NULL) && (lstrlen(lpszPath) > 0))
  {
    if (BuildSamName(lpszPath,sTemp))
    {
      lpszAddToName = sTemp;
    }
  }
  
  if (lpszAddToName != NULL)
  {
    static LPCWSTR lpszFormat = L"%s (%s)";
    size_t nLen = lstrlen(lpszAddToName) + lstrlen(lpszFormat) + m_szName.size() + 1;
    LPWSTR lpszTemp = (LPWSTR)alloca(nLen*sizeof(WCHAR));
    wsprintf(lpszTemp, lpszFormat, m_szName.c_str(), lpszAddToName);
    m_szDisplayName = lpszTemp;
  }
  else
  {
    // got nothing, just use the name
    m_szDisplayName = m_szName;
  }
}


BOOL CPrincipal::IsEqual(CPrincipal* p)
{
  return (_wcsicmp(m_szADsPath, p->m_szADsPath) == 0);
}


BOOL CPrincipalList::AddIfNotPresent(CPrincipal* p)
{
  CPrincipalList::iterator i;
  for (i = begin(); i != end(); ++i)
  {
    if ((*i)->IsEqual(p))
    {
      delete p; // duplicate
      return FALSE;
    }
  }
  push_back(p);
  return TRUE;
}


void CPrincipalList::WriteSummaryInfo(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine)
{
  WriteSummaryTitleLine(szSummary, IDS_DELEGWIZ_FINISH_PRINCIPALS, lpszNewLine);

  CPrincipalList::iterator i;
  for (i = begin(); i != end(); ++i)
  {
    WriteSummaryLine(szSummary, (*i)->GetDisplayName(), lpszIdent, lpszNewLine);
  }
  szSummary += lpszNewLine;
}

///////////////////////////////////////////////////////////////////////
// CControlRightInfo

void CControlRightInfo::SetLocalizedName(UINT nLocalizationDisplayId, HMODULE hModule)
{
  WCHAR szLocalizedDisplayName[256];

  DWORD dwChars = 0;

  if (hModule != NULL)
  {
    dwChars = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                            hModule,  
                            nLocalizationDisplayId,
                            0,
                            szLocalizedDisplayName,
                            256,
                            NULL);
  }

  if (dwChars > 0)
  {
    m_szLocalizedName = szLocalizedDisplayName;
  }
  else
  {
    // failed, just use the LDAP display name
    m_szLocalizedName = m_szLdapDisplayName;
  }

  // need to set the display name
  if (IsPropertySet())
  {
    CWString szPropertySetFormat;
    szPropertySetFormat.LoadFromResource(IDS_DELEGWIZ_RW_PROPERTYSET);
    WCHAR* lpszBuffer = (WCHAR*)alloca(sizeof(WCHAR)*(szPropertySetFormat.size()+m_szLocalizedName.size()+1));

    // we have a different display name
    wsprintf(lpszBuffer, szPropertySetFormat, (LPCWSTR)m_szLocalizedName);
    m_szDisplayName = lpszBuffer;
  }
  else
  {
    // same as raw
    m_szDisplayName = m_szLocalizedName;
  }
}

///////////////////////////////////////////////////////////////////////
// CControlRightInfoArray 

class CDsSecLib
{
public:
  CDsSecLib()
  { 
    m_hInstance = ::LoadLibrary(L"dssec.dll");
  }
  ~CDsSecLib()
  { 
    if (m_hInstance != NULL)
      ::FreeLibrary(m_hInstance);
  }
  
  HINSTANCE Get() { return m_hInstance; }
private:
  HINSTANCE m_hInstance;
};


HRESULT CControlRightInfoArray::InitFromDS(CAdsiObject* pADSIObj,
                                           const GUID* pSchemaIDGUID)
{
  TRACE(L"CControlRightInfoArray::InitFromDS()\n\n");

  ASSERT(pSchemaIDGUID != NULL);

  LPWSTR lpszSchemaIDGUID = (LPWSTR)alloca(128*sizeof(WCHAR));
  if(!lpszSchemaIDGUID)
    return E_OUTOFMEMORY;
  if (!FormatStringGUID(lpszSchemaIDGUID, 128, pSchemaIDGUID))
  {
    return E_INVALIDARG;
  }

  
	// build the LDAP path for the schema class
  CWString szPhysicalSchemaPath;
  LPCWSTR lpszPhysicalSchemaNamingContext = pADSIObj->GetPhysicalSchemaNamingContext();
  BuildLdapPathHelper(pADSIObj->GetServerName(), lpszPhysicalSchemaNamingContext, szPhysicalSchemaPath);

  // build the extended rights container naming context and LDAP path
  CWString szExtendedRightsNamingContext;
  szExtendedRightsNamingContext = L"CN=Extended-Rights,";
  szExtendedRightsNamingContext += pADSIObj->GetConfigurationNamingContext();
  CWString szExtendedRightsPath;
  BuildLdapPathHelper(pADSIObj->GetServerName(), szExtendedRightsNamingContext, szExtendedRightsPath);

  // bind a query to the extended rights container
  CAdsiSearch search;
  HRESULT hr = search.Init(szExtendedRightsPath);
  TRACE(L"search.Init(%s) returned hr = 0x%x\n", (LPCWSTR)szExtendedRightsPath, hr);

  if (FAILED(hr))
  {
    return hr;
  }

  // build an LDAP query string
  static LPCWSTR lpszFilterFormat = L"(&(objectCategory=CN=Control-Access-Right,%s)(AppliesTo=%s))";

  int nFmtLen = lstrlen(lpszFilterFormat);
  int nArgumentLen = lstrlen(lpszPhysicalSchemaNamingContext) + lstrlen(lpszSchemaIDGUID);

  WCHAR* lpszFilter = (WCHAR*)alloca(sizeof(WCHAR)*(nFmtLen+nArgumentLen+1));
  wsprintf(lpszFilter, lpszFilterFormat, lpszPhysicalSchemaNamingContext, lpszSchemaIDGUID);

  // build an array of wanted columns
  static const int cAttrs = 4;
  static LPCWSTR pszAttribsArr[cAttrs] = 
  {
    L"displayName",     // e.g. "Change Password"
    L"rightsGuid",      // e.g. "ab721a53-1e2f-...." (i.e. GUID in string form w/o {})
    L"validAccesses",    // bitmask of access righs
    L"localizationDisplayId"    // bitmask of access righs
  }; 
  
  hr = search.SetSearchScope(ADS_SCOPE_ONELEVEL);
  TRACE(L"search.SetSearchScope(ADS_SCOPE_ONELEVEL) returned hr = 0x%x\n", hr);
  if (FAILED(hr))
    return hr;

  hr = search.DoQuery(lpszFilter, pszAttribsArr, cAttrs);
  TRACE(L"search.DoQuery(lpszFilter, pszAttribsArr, cAttrs) returned hr = 0x%x\n", hr);
  if (FAILED(hr))
    return hr;

  TRACE(L"\n");

  CWString szRightsGUID;
  ULONG nLocalizationDisplayId;

  // load DSSEC.DLL to provide localized
  CDsSecLib DsSecLib;

  while ((hr = search.GetNextRow()) != S_ADS_NOMORE_ROWS)
  {
    if (FAILED(hr))
      continue;

    CControlRightInfo* pInfo = new CControlRightInfo();

    HRESULT hr0 = search.GetColumnString(pszAttribsArr[0], pInfo->m_szLdapDisplayName);

    // the DS gives us the GUID in string form, but we need it in struct form
    HRESULT hr1 = search.GetColumnString(pszAttribsArr[1], szRightsGUID);
    if (SUCCEEDED(hr1))
    {
      if (!::GuidFromString(&(pInfo->m_rightsGUID), szRightsGUID.c_str()))
      {
        TRACE(L"GuidFromString(_, %s) failed!\n", szRightsGUID.c_str());
        hr1 = E_INVALIDARG;
      }
    }

    HRESULT hr2 = search.GetColumnInteger(pszAttribsArr[2], pInfo->m_fAccess);

    HRESULT hr3 = search.GetColumnInteger(pszAttribsArr[3], nLocalizationDisplayId);

    TRACE(L"Name = <%s>, \n       Guid = <%s>, Access = 0x%x, nLocalizationDisplayId = %d\n", 
            pInfo->m_szLdapDisplayName.c_str(), szRightsGUID.c_str(), pInfo->m_fAccess, nLocalizationDisplayId);
    
    if (FAILED(hr0) || FAILED(hr1) || FAILED(hr2) || FAILED(hr3))
    {
      TRACE(L"WARNING: discarding right, failed on columns: hr0 = 0x%x, hr1 = 0x%x, hr2 = 0x%x, hr3 = 0x%x\n",
                            hr0, hr1, hr2, hr3);
      delete pInfo;
    }
    else
    {
      pInfo->SetLocalizedName(nLocalizationDisplayId, DsSecLib.Get());

      Add(pInfo);
    }
  } // while

  TRACE(L"\n\n");

  if (hr == S_ADS_NOMORE_ROWS)
    hr = S_OK;

  return hr;
}


//////////////////////////////////////////////////////////////////////
// CPropertyRightInfo

const ULONG CPropertyRightInfo::m_nRightCountMax = 2;
const ULONG CPropertyRightInfo::m_nReadIndex = 0;
const ULONG CPropertyRightInfo::m_nWriteIndex = 1;


LPCWSTR CPropertyRightInfo::GetRightDisplayString(ULONG iRight)
{
  static WCHAR szReadFmt[256] = L"";
  static WCHAR szWriteFmt[256] = L"";
  static WCHAR szReadAll[256] = L"";
  static WCHAR szWriteAll[256] = L"";

  static WCHAR szDisplay[512];

  ASSERT(GetName() != NULL); // must have a name!!!

  szDisplay[0] = NULL;
  WCHAR* pFmt = NULL;

  if (iRight == m_nReadIndex)
  {
    if (szReadFmt[0] == NULL)
      LoadStringHelper(IDS_DELEGWIZ_READ_PROPERTY, szReadFmt, ARRAYSIZE(szReadFmt));
    pFmt = szReadFmt;
  }
  else if (iRight == m_nWriteIndex)
  {
    if (szWriteFmt[0] == NULL)
      LoadStringHelper(IDS_DELEGWIZ_WRITE_PROPERTY, szWriteFmt, ARRAYSIZE(szWriteFmt));
    pFmt = szWriteFmt;
  }
  wsprintf(szDisplay, pFmt, GetDisplayName());
  return szDisplay;
}

void CPropertyRightInfo::SetRight(ULONG iRight, BOOL b)
{
  switch (iRight)
  {
  case m_nReadIndex: 
    if (b)
      m_Access |= ACTRL_DS_READ_PROP;
    else
      m_Access &= ~ACTRL_DS_READ_PROP;
    break;
  case m_nWriteIndex:
    if (b)
      m_Access |= ACTRL_DS_WRITE_PROP;
    else
      m_Access &= ~ACTRL_DS_WRITE_PROP;
    break;
  default:
    ASSERT(FALSE);
  };
}

ULONG CPropertyRightInfo::GetRight(ULONG iRight)
{
  switch (iRight)
  {
  case m_nReadIndex: 
    return (ULONG)ACTRL_DS_READ_PROP;
    break;
  case m_nWriteIndex: 
    return (ULONG)ACTRL_DS_WRITE_PROP;
    break;
  default:
    ASSERT(FALSE);
  };
  return 0;
}

BOOL CPropertyRightInfo::IsRightSelected(ULONG iRight)
{
  BOOL bRes = FALSE;
  switch (iRight)
  {
  case m_nReadIndex: 
    bRes = m_Access & ACTRL_DS_READ_PROP;
    break;
  case m_nWriteIndex: 
    bRes = m_Access & ACTRL_DS_WRITE_PROP;
    break;
  default:
    ASSERT(FALSE);
  };
  return bRes;
}


//////////////////////////////////////////////////////////////////////
// CPropertyRightInfoArray

template <class T> class CClassPtr
{
public:
  CClassPtr() { m_p = NULL;}
  ~CClassPtr() { if (m_p) delete m_p;}

  CClassPtr& operator=(T* p)
  {
    m_p = p;
    return *this;
  }
  T* operator->()
  {
    return m_p;
  }
  T* operator&()
  {
    return m_p;
  }



private:
  T* m_p;
};

HRESULT CPropertyRightInfoArray::InitFromSchema(CAdsiObject* pADSIObj,
                                           IADsClass * pDsSchemaClass,
                                           LPCWSTR lpszClassName,
                                           BOOL bUseFilter)
{
  // setup
  Clear();

  CClassPtr<CPropertyRightInfoFilter> spFilter;
  if (bUseFilter)
  {
    spFilter = new CPropertyRightInfoFilter();
    spFilter->SetClassName(lpszClassName);
  }

  if (pDsSchemaClass == NULL)
  {
    ASSERT(lpszClassName == NULL);
    return S_OK;
  }

  // get data from DS for specific properties
  VARIANT MandatoryListVar, OptionalListVar;
  ::VariantInit(&MandatoryListVar);
  ::VariantInit(&OptionalListVar);
  HRESULT hr = pDsSchemaClass->get_MandatoryProperties(&MandatoryListVar);
  if (FAILED(hr))
  {
    ::VariantClear(&MandatoryListVar);
    return hr;
  }
  hr = pDsSchemaClass->get_OptionalProperties(&OptionalListVar);
  if (FAILED(hr))
  {
    ::VariantClear(&OptionalListVar);
    return hr;
  }

  // add the results to the array
  CContainerProxy<CPropertyRightInfo, CPropertyRightInfoArray, CPropertyRightInfoFilter> 
            cont(this, &spFilter);

  VariantArrayToContainer(MandatoryListVar, &cont);
  VariantArrayToContainer(OptionalListVar, &cont);

  ::VariantClear(&MandatoryListVar);
  ::VariantClear(&OptionalListVar);

  // now need to set the friendly names
  ULONG nCount = (ULONG) GetCount();
  WCHAR szFrendlyName[1024];
  HRESULT hrName;
  
  for (ULONG i=0; i<nCount; i++)
  {
    LPCWSTR lpszName = (*this)[i]->GetName();
    if (lpszName != NULL)
    {
      hrName = pADSIObj->GetFriendlyAttributeName(lpszClassName, 
                                                  lpszName, 
                                                  szFrendlyName, 1024);
      ASSERT(SUCCEEDED(hrName));
      (*this)[i]->SetDisplayName(SUCCEEDED(hrName) ? szFrendlyName : NULL);
    }
  }

  // get guids
  for (i=0; i<nCount; i++)
  {
    CPropertyRightInfo* pInfo = (*this)[i];
    LPCWSTR lpszName = pInfo->GetName();
    hr = pADSIObj->GetClassGuid(lpszName, TRUE, pInfo->m_schemaIDGUID);
    if (SUCCEEDED(hr))
    {
      WCHAR szTest[128];
      FormatStringGUID(szTest, 128, &(pInfo->m_schemaIDGUID));
      TRACE(L"name = <%s>, guid = <%s>\n", lpszName, szTest);
    }
    else
    {
      TRACE(L"GetClassGuid(%s) failed hr = 0x%x\n", lpszName, hr);
      return hr;
    }
  }

  Sort();
  return hr;
}



//////////////////////////////////////////////////////////////////////
// CClassRightInfo


const ULONG CClassRightInfo::m_nRightCountMax = 2;
const ULONG CClassRightInfo::m_nCreateIndex = 0;
const ULONG CClassRightInfo::m_nDeleteIndex = 1;


LPCWSTR CClassRightInfo::GetRightDisplayString(ULONG iRight)
{
  static WCHAR szCreateFmt[256] = L"";
  static WCHAR szDeleteFmt[256] = L"";
  static WCHAR szCreateAll[256] = L"";
  static WCHAR szDeleteAll[256] = L"";

  static WCHAR szDisplay[512];

  ASSERT(GetName() != NULL); // must have a name!!!
  
  szDisplay[0] = NULL;
  WCHAR* pFmt = NULL;

  if (iRight == m_nCreateIndex)
  {
    if (szCreateFmt[0] == NULL)
      LoadStringHelper(IDS_DELEGWIZ_CREATE_CLASS, szCreateFmt, ARRAYSIZE(szCreateFmt));
    pFmt = szCreateFmt;
  }
  else if (iRight == m_nDeleteIndex)
  {
    if (szDeleteFmt[0] == NULL)
      LoadStringHelper(IDS_DELEGWIZ_DELETE_CLASS, szDeleteFmt, ARRAYSIZE(szDeleteFmt));
    pFmt = szDeleteFmt;
  }
  wsprintf(szDisplay, pFmt, GetDisplayName());
  return szDisplay;
}

void CClassRightInfo::SetRight(ULONG iRight, BOOL b)
{
  switch (iRight)
  {
  case m_nCreateIndex: 
    if (b)
      m_Access |= ACTRL_DS_CREATE_CHILD;
    else
      m_Access &= ~ACTRL_DS_CREATE_CHILD;
    break;
  case m_nDeleteIndex: 
    if (b)
      m_Access |= ACTRL_DS_DELETE_CHILD;
    else
      m_Access &= ~ACTRL_DS_DELETE_CHILD;
    break;
  default:
    ASSERT(FALSE);
  };
}

ULONG CClassRightInfo::GetRight(ULONG iRight)
{
  switch (iRight)
  {
  case m_nCreateIndex: 
    return (ULONG)ACTRL_DS_CREATE_CHILD;
    break;
  case m_nDeleteIndex: 
    return (ULONG)ACTRL_DS_DELETE_CHILD;
    break;
  default:
    ASSERT(FALSE);
  };
  return 0;
}

BOOL CClassRightInfo::IsRightSelected(ULONG iRight)
{
 BOOL bRes = FALSE;
  switch (iRight)
  {
  case m_nCreateIndex: 
    bRes = m_Access & ACTRL_DS_CREATE_CHILD;
    break;
  case m_nDeleteIndex: 
    bRes = m_Access & ACTRL_DS_DELETE_CHILD;
    break;
  default:
    ASSERT(FALSE);
  };
  return bRes;
}


//////////////////////////////////////////////////////////////////////
// CClassRightInfoArray

HRESULT CClassRightInfoArray::InitFromSchema(CAdsiObject* pADSIObj, 
                                        IADsClass* pDsSchemaClass,
                                        BOOL bUseFilter)
{
  // setup
  Clear();

  if (pDsSchemaClass == NULL)
    return S_OK;

  // read from DS
  VARIANT ContainmentListVar;
  ::VariantInit(&ContainmentListVar);
  HRESULT hr = pDsSchemaClass->get_Containment(&ContainmentListVar);
  if (FAILED(hr))
  {
    ::VariantClear(&ContainmentListVar);
    return hr;
  }


  CClassPtr<CClassRightInfoFilter> spFilter;
  if (bUseFilter)
  {
    spFilter = new CClassRightInfoFilter();
  }
  
  // add to array and filter
  CContainerProxy<CClassRightInfo, CClassRightInfoArray, CClassRightInfoFilter> 
          cont(this, &spFilter);
  VariantArrayToContainer(ContainmentListVar, &cont);

  ::VariantClear(&ContainmentListVar);

  
  // now need to set the friendly names
  ULONG nCount = (ULONG) GetCount();
  WCHAR szFrendlyName[1024];
  HRESULT hrName;
  for (ULONG i=0; i<nCount; i++)
  {
    LPCWSTR lpszName = (*this)[i]->GetName();
    if (lpszName != NULL)
    {
      hrName = pADSIObj->GetFriendlyClassName(lpszName, szFrendlyName, 1024);
      ASSERT(SUCCEEDED(hrName));
      (*this)[i]->SetDisplayName(SUCCEEDED(hrName) ? szFrendlyName : NULL);
    }
  }

  // get guids
  for (i=0; i<nCount; i++)
  {
    CClassRightInfo* pInfo = (*this)[i];
    LPCWSTR lpszName = pInfo->GetName();
    hr = pADSIObj->GetClassGuid(lpszName, FALSE, pInfo->m_schemaIDGUID);
    if (SUCCEEDED(hr))
    {
      WCHAR szTest[128];
      FormatStringGUID(szTest, 128, &(pInfo->m_schemaIDGUID));
      TRACE(L"name = <%s>, guid = <%s>\n", lpszName, szTest);
    }
    else
    {
      TRACE(L"GetClassGuid(%s) failed hr = 0x%x\n", lpszName, hr);
      return hr;
    }
  }

  Sort();

  return hr;
}


///////////////////////////////////////////////////////////////////////
// CAccessPermissionsHolderBase

CAccessPermissionsHolderBase::CAccessPermissionsHolderBase(BOOL bUseFilter)
{
  m_bUseFilter = bUseFilter;
}

CAccessPermissionsHolderBase::~CAccessPermissionsHolderBase()
{
  Clear();
}

void CAccessPermissionsHolderBase::Clear()
{
  m_accessRightInfoArr.Clear();  
  m_controlRightInfoArr.Clear();  

  m_propertyRightInfoArray.Clear();
  m_classRightInfoArray.Clear();
}

BOOL CAccessPermissionsHolderBase::HasPermissionSelected()
{
  ULONG i,j;
  // check access rigths
  for (i = 0; i < m_accessRightInfoArr.GetCount(); i++)
  {
    if (m_accessRightInfoArr[i]->IsSelected())
        return TRUE;
  }
  
  // check control rigths
  for (i = 0; i < m_controlRightInfoArr.GetCount(); i++)
  {
    if (m_controlRightInfoArr[i]->IsSelected())
        return TRUE;
  }

  // subobjects rigths
  for (i = 0; i < m_classRightInfoArray.GetCount(); i++)
  {
    for (j=0; j< m_classRightInfoArray[i]->GetRightCount(); j++)
    {
      if ( m_classRightInfoArray[i]->IsRightSelected(j) )
        return TRUE;
    }
  }

  // property rights
  for (i = 0; i < m_propertyRightInfoArray.GetCount(); i++)
  {
    for (j=0; j< m_propertyRightInfoArray[i]->GetRightCount(); j++)
    {
      if ( m_propertyRightInfoArray[i]->IsRightSelected(j) )
        return TRUE;
    }
  }

  return FALSE;
}

/*
typedef struct _ACTRL_CONTROL_INFOW
{
    LPWSTR 	    lpControlId;
	LPWSTR 	    lpControlName;
} ACTRL_CONTROL_INFOW, *PACTRL_CONTROL_INFOW;

typedef struct _ACTRL_ACCESS_INFOW
{
    ULONG       fAccessPermission;
    LPWSTR      lpAccessPermissionName;
} ACTRL_ACCESS_INFOW, *PACTRL_ACCESS_INFOW;

*/



HRESULT CAccessPermissionsHolderBase::ReadDataFromDS(CAdsiObject* pADSIObj,
                                               LPCWSTR /*lpszObjectNamingContext*/, 
                                               LPCWSTR lpszClassName,
                                               const GUID* pSchemaIDGUID,
                                               BOOL bChildClass,
											   BOOL bHideListObject)
{
#if DBG
  WCHAR szGUID[128];
  FormatStringGUID(szGUID, 128, pSchemaIDGUID);
  TRACE(L"CAccessPermissionsHolderBase::ReadDataFromDS(_, %s, %s)\n",
          lpszClassName, szGUID);
#endif


  Clear();

  HRESULT hr = S_OK;
  if (pSchemaIDGUID != NULL)
  {
    hr = m_controlRightInfoArr.InitFromDS(pADSIObj, pSchemaIDGUID);
    TRACE(L"hr = m_controlRightInfoArr.InitFromDS(...) returned hr = 0x%x\n", hr);
    if (FAILED(hr))
    {
      return hr;
    }
  }


  hr = _ReadClassInfoFromDS(pADSIObj, lpszClassName);
  if (FAILED(hr))
  {
    return hr;
  }
    
  hr = _LoadAccessRightInfoArrayFromTable(bChildClass,bHideListObject);
  return hr;
}


HRESULT CAccessPermissionsHolderBase::_ReadClassInfoFromDS(CAdsiObject* pADSIObj, 
                                                     LPCWSTR lpszClassName)
{
  HRESULT hr = S_OK;
  CComPtr<IADsClass> spSchemaObjectClass;

  if (lpszClassName != NULL)
  {
    int nServerNameLen = lstrlen(pADSIObj->GetServerName());
	  int nClassNameLen = lstrlen(lpszClassName);
	  int nFormatStringLen = lstrlen(g_wzLDAPAbstractSchemaFormat);
	  
	  // build the LDAP path for the schema class
	  WCHAR* pwszSchemaObjectPath = 
		  (WCHAR*)alloca(sizeof(WCHAR)*(nServerNameLen+nClassNameLen+nFormatStringLen+1));
	  wsprintf(pwszSchemaObjectPath, g_wzLDAPAbstractSchemaFormat, pADSIObj->GetServerName(), lpszClassName);

	  // get the schema class ADSI object
	  hr = ::ADsOpenObjectHelper(pwszSchemaObjectPath, 
					  IID_IADsClass, (void**)&spSchemaObjectClass);
	  if (FAILED(hr))
		  return hr;

  }


  //TRACE(_T("\nObject Properties\n\n"));
  hr = m_propertyRightInfoArray.InitFromSchema(pADSIObj, spSchemaObjectClass,lpszClassName, m_bUseFilter);
	if (FAILED(hr))
		return hr;

  //TRACE(_T("\nObject contained classes\n\n"));
  return m_classRightInfoArray.InitFromSchema(pADSIObj, spSchemaObjectClass, m_bUseFilter);
}



DWORD CAccessPermissionsHolderBase::UpdateAccessList( CPrincipal* pPrincipal,
									                                    CSchemaClassInfo* pClassInfo,
                                                      LPCWSTR /*lpszServerName*/,
                                                      LPCWSTR /*lpszPhysicalSchemaNamingContext*/,
									                                    PACL *ppAcl)
{
  TRACE(L"CAccessPermissionsHolderBase::UpdateAccessList()\n");
  const GUID* pClassGUID = NULL;

  TRACE(L"User or Group Name: %s\n", pPrincipal->GetDisplayName());
  
  BOOL bChildClass = TRUE;
  if (pClassInfo != NULL)
  {
    pClassGUID = pClassInfo->GetSchemaGUID();
    bChildClass =  (pClassInfo->m_dwChildClass != CHILD_CLASS_NOT_EXIST );
  }

  return _UpdateAccessListHelper(pPrincipal->GetSid(), pClassGUID, ppAcl,bChildClass);
}


DWORD CAccessPermissionsHolderBase::_UpdateAccessListHelper(PSID pSid, 
                                                 const GUID* pClassGUID,
                                                 PACL *ppAcl,
                                                 BOOL bChildClass)
{
  TRACE(L"CAccessPermissionsHolderBase::_UpdateAccessListHelper()\n");

  ASSERT(pSid != NULL);

  ULONG AccessAllClass = 0;
  ULONG AccessAllProperty = 0;
  
  DWORD dwErr = 0;

  // set common variables

  ULONG uAccess = 0; // to be set and reset as see fit

  if (m_accessRightInfoArr[0]->IsSelected()) // full control
	{
    uAccess = _WIZ_FULL_CTRL;
    dwErr = ::AddObjectRightInAcl(pSid, uAccess, NULL, pClassGUID, ppAcl);
    if (dwErr != ERROR_SUCCESS)
      goto exit;
	}
	else
    {
        // add an entry for all the standard access permissions:
        // OR all the selected permissions together
        uAccess = 0;
        UINT nSel = 0;
		for (UINT k=0; k < m_accessRightInfoArr.GetCount(); k++)
		{
		    if (m_accessRightInfoArr[k]->IsSelected())
            {
                nSel++;
                uAccess |= m_accessRightInfoArr[k]->GetAccess();
            }
        } // for

        if( !bChildClass )
            uAccess &= (~(ACTRL_DS_CREATE_CHILD|ACTRL_DS_DELETE_CHILD));
        if (nSel > 0)
        {
          // keep track of "All" flags
            if (uAccess & ACTRL_DS_READ_PROP)
                AccessAllProperty |= ACTRL_DS_READ_PROP;
            if (uAccess &  ACTRL_DS_WRITE_PROP)
                AccessAllProperty |= ACTRL_DS_WRITE_PROP;

            if (uAccess & ACTRL_DS_CREATE_CHILD)
                AccessAllClass |= ACTRL_DS_CREATE_CHILD;
            if (uAccess &  ACTRL_DS_DELETE_CHILD)
                AccessAllClass |= ACTRL_DS_DELETE_CHILD;

            dwErr = ::AddObjectRightInAcl(pSid, uAccess, NULL, pClassGUID, ppAcl);

            if (dwErr != ERROR_SUCCESS)
                goto exit;
        }

        // add an entry for each of the control rights
        for (k=0; k < m_controlRightInfoArr.GetCount(); k++)
        {
            if (m_controlRightInfoArr[k]->IsSelected())
            {
                uAccess = m_controlRightInfoArr[k]->GetAccess();
                dwErr = ::AddObjectRightInAcl(pSid, uAccess, 
                                              m_controlRightInfoArr[k]->GetRightsGUID(), 
                                              pClassGUID,
                                              ppAcl);
            if (dwErr != ERROR_SUCCESS)
                goto exit;
            }
        } // for

        // add an entry for each of the subobjects rigths
        for (ULONG iClass = 0; iClass < m_classRightInfoArray.GetCount(); iClass++)
        {
          ULONG Access = m_classRightInfoArray[iClass]->GetAccess();
          if (Access != 0)
          {
            if (iClass > 0)
            {
              ULONG nRightCount = m_classRightInfoArray[iClass]->GetRightCount();
              for (ULONG iCurrRight=0; iCurrRight<nRightCount; iCurrRight++)
              {
                // the first entry is the Create/Delete All, no need for other permissions,
                ULONG currAccess = m_classRightInfoArray[iClass]->GetRight(iCurrRight);
                if (currAccess & AccessAllClass)
                {
                  // right already present, strip out
                  Access &= ~currAccess;
                }
              } // for
            }
            if (Access != 0)
            {
              uAccess = Access;
              dwErr = ::AddObjectRightInAcl(pSid, uAccess,  
                                            m_classRightInfoArray[iClass]->GetSchemaGUID(), 
                                            pClassGUID,
                                            ppAcl);
              if (dwErr != ERROR_SUCCESS)
                goto exit;
            }
          }
        } // for

        // add an entry for each property right to set
        for (ULONG iProperty=0; iProperty < m_propertyRightInfoArray.GetCount(); iProperty++)
        {
          ULONG Access = m_propertyRightInfoArray[iProperty]->GetAccess();
          if (Access != 0)
          {
            if (iProperty > 0)
            {
              ULONG nRightCount = m_propertyRightInfoArray[iProperty]->GetRightCount();
              for (ULONG iCurrRight=0; iCurrRight<nRightCount; iCurrRight++)
              {
                // the first entry is the Create/Delete All, no need for other permissions,
                ULONG currAccess = m_propertyRightInfoArray[iProperty]->GetRight(iCurrRight);
                if (currAccess & AccessAllProperty)
                {
                  // right already present, strip out
                  Access &= ~currAccess;
                }
              } // for
            }
            if (Access != 0)
            {
              uAccess = Access;
              dwErr = ::AddObjectRightInAcl(pSid, uAccess,  
                                            m_propertyRightInfoArray[iProperty]->GetSchemaGUID(),
                                            pClassGUID,
                                            ppAcl);
              if (dwErr != ERROR_SUCCESS)
                goto exit;
            }
          }
        }

    } // if

exit:

	return dwErr;
}




///////////////////////////////////////////////////////////////////////
// CCustomAccessPermissionsHolder

CCustomAccessPermissionsHolder::CCustomAccessPermissionsHolder()
      : CAccessPermissionsHolderBase(TRUE)
{
}

CCustomAccessPermissionsHolder::~CCustomAccessPermissionsHolder()
{
  Clear();
}

void CCustomAccessPermissionsHolder::Clear()
{
  CAccessPermissionsHolderBase::Clear();
  m_listViewItemArr.Clear();
}


struct CAccessRightTableEntry
{
  UINT m_nStringID;
  ULONG m_fAccess;
};


#define _WIZ_READ \
  (READ_CONTROL | ACTRL_DS_LIST | ACTRL_DS_READ_PROP | ACTRL_DS_LIST_OBJECT)

#define _WIZ_WRITE \
  (ACTRL_DS_SELF | ACTRL_DS_WRITE_PROP)



HRESULT CCustomAccessPermissionsHolder::_LoadAccessRightInfoArrayFromTable(BOOL bCreateDeleteChild,BOOL bHideListObject)
{
  static CAccessRightTableEntry _pTable[] = 
  {
    { IDS_DELEGWIZ_ACTRL_FULL,                 _WIZ_FULL_CTRL },
    { IDS_DELEGWIZ_ACTRL_READ,                 _WIZ_READ },
    { IDS_DELEGWIZ_ACTRL_WRITE,                _WIZ_WRITE },
/*
    { IDS_DELEGWIZ_ACTRL_SYSTEM_ACCESS,       ACCESS_SYSTEM_SECURITY },
    { IDS_DELEGWIZ_ACTRL_DELETE,              DELETE                 },
    { IDS_DELEGWIZ_ACTRL_READ_CONTROL,        READ_CONTROL           },
    { IDS_DELEGWIZ_ACTRL_CHANGE_ACCESS,       WRITE_DAC              },
    { IDS_DELEGWIZ_ACTRL_CHANGE_OWNER,        WRITE_OWNER      },
*/
    { IDS_DELEGWIZ_ACTRL_DS_CREATE_CHILD,     ACTRL_DS_CREATE_CHILD   },
    { IDS_DELEGWIZ_ACTRL_DS_DELETE_CHILD,     ACTRL_DS_DELETE_CHILD   },
/*
    { IDS_DELEGWIZ_ACTRL_DS_LIST,             ACTRL_DS_LIST           },
    { IDS_DELEGWIZ_ACTRL_DS_SELF,             ACTRL_DS_SELF           },
*/
    { IDS_DELEGWIZ_ACTRL_DS_READ_PROP,        ACTRL_DS_READ_PROP      },
    { IDS_DELEGWIZ_ACTRL_DS_WRITE_PROP,       ACTRL_DS_WRITE_PROP     },
/*
    { IDS_DELEGWIZ_ACTRL_DS_DELETE_TREE,      ACTRL_DS_DELETE_TREE    },
    { IDS_DELEGWIZ_ACTRL_DS_LIST_OBJECT,      ACTRL_DS_LIST_OBJECT    },
    { IDS_DELEGWIZ_ACTRL_DS_CONTROL_ACCESS,   ACTRL_DS_CONTROL_ACCESS },
*/
    {0, 0x0 } // end of table marker
  };

  if(bHideListObject)
  {	
	  _pTable[0].m_fAccess &= ~ACTRL_DS_LIST_OBJECT;
	  _pTable[1].m_fAccess &= ~ACTRL_DS_LIST_OBJECT;
  }
	



  TRACE(L"\nCCustomAccessPermissionsHolder::_LoadAccessRightInfoArrayFromTable()\n\n");

  for(CAccessRightTableEntry* pCurrEntry = (CAccessRightTableEntry*)_pTable; 
                      pCurrEntry->m_nStringID != NULL; pCurrEntry++)
  {
    if( !bCreateDeleteChild && ( 
                                (pCurrEntry->m_fAccess == ACTRL_DS_CREATE_CHILD) ||
                                (pCurrEntry->m_fAccess == ACTRL_DS_DELETE_CHILD ) ) )

        continue;
    CAccessRightInfo* pInfo = new CAccessRightInfo();
    if( !pInfo )
      return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    if (!pInfo->m_szDisplayName.LoadFromResource(pCurrEntry->m_nStringID))
    {
      delete pInfo;
      continue;
    }
    pInfo->m_fAccess = pCurrEntry->m_fAccess;

    TRACE(L"Display Name = <%s>, Access = 0x%x\n", 
          pInfo->m_szDisplayName.c_str(), pInfo->m_fAccess);
    m_accessRightInfoArr.Add(pInfo);
  }

  TRACE(L"\nCCustomAccessPermissionsHolder::_LoadAccessRightInfoArrayFromTable() exiting\n\n");

  return S_OK;
}




void CCustomAccessPermissionsHolder::_SelectAllRigths()
{
  ULONG i,j;

  // select all access rigths
  for (i = 0; i < m_accessRightInfoArr.GetCount(); i++)
  {
    m_accessRightInfoArr[i]->Select(TRUE);
  }

  // select all control rights rigths
  for (i = 0; i < m_controlRightInfoArr.GetCount(); i++)
  {
    m_controlRightInfoArr[i]->Select(TRUE);
  }

  // select all subobjects rigths
  for (i = 0; i < m_classRightInfoArray.GetCount(); i++)
  {
    for (j=0; j< m_classRightInfoArray[i]->GetRightCount(); j++)
    {
      m_classRightInfoArray[i]->SetRight(j, TRUE);
    }
  }

  // select all property rights
  for (i = 0; i < m_propertyRightInfoArray.GetCount(); i++)
  {
    for (j=0; j< m_propertyRightInfoArray[i]->GetRightCount(); j++)
    {
      m_propertyRightInfoArray[i]->SetRight(j, TRUE);
    }
  }

}


void CCustomAccessPermissionsHolder::_SelectAllPropertyRigths(ULONG fAccessPermission)
{
  for (UINT i=0; i<m_propertyRightInfoArray.GetCount(); i++)
  {
    m_propertyRightInfoArray[i]->AddAccessRight(fAccessPermission);
  }
}

void CCustomAccessPermissionsHolder::_SelectAllSubObjectRigths(ULONG fAccessPermission)
{
  for (UINT i=0; i<m_classRightInfoArray.GetCount(); i++)
  {
    m_classRightInfoArray[i]->AddAccessRight(fAccessPermission);
  }
}


void CCustomAccessPermissionsHolder::_DeselectAssociatedRights(ULONG fAccessPermission)
{
  // deselect full control first
  m_accessRightInfoArr[0]->Select(FALSE);

  if (fAccessPermission != 0)
  {
    // deselect any other basic right that contains the flag
    UINT nCount = (ULONG) m_accessRightInfoArr.GetCount();
    for (ULONG iAccess=0; iAccess<nCount; iAccess++)
    {
      if (m_accessRightInfoArr[iAccess]->GetAccess() & fAccessPermission)
        m_accessRightInfoArr[iAccess]->Select(FALSE);
    }
  }
}


void CCustomAccessPermissionsHolder::Select(IN CRigthsListViewItem* pItem,
                                            IN BOOL bSelect,
                                            OUT ULONG* pnNewFilterState)
{
  ASSERT(pItem != NULL);

  *pnNewFilterState = 0;

  switch (pItem->m_type)
  {
    case CRigthsListViewItem::access: // access rights
    case CRigthsListViewItem::ctrl: // general rights
      {
        // make the change to the entry that was passed in as argument
        if (pItem->m_type == CRigthsListViewItem::access)
        {
          m_accessRightInfoArr[pItem->m_iIndex]->Select(bSelect);
        }
        else
        {
          m_controlRightInfoArr[pItem->m_iIndex]->Select(bSelect);
        }
        
        // now see if this triggers changes to the other entries
        if (bSelect)
        {
          if  (pItem->m_type == CRigthsListViewItem::access) 
          {
            if (pItem->m_iIndex == 0)
            {
              // the user checked full control, need to select all the rigths
              _SelectAllRigths();

              // set flags to mark which set of flags is affected
              *pnNewFilterState |= FILTER_EXP_GEN;

              if (m_propertyRightInfoArray.GetCount() > 0)
                *pnNewFilterState |= FILTER_EXP_PROP;

              if (m_classRightInfoArray.GetCount() > 0)
                *pnNewFilterState |= FILTER_EXP_SUBOBJ;
            }
            else 
            {
              // check if the user selected some read/write all or create/delete all right
              UINT iAccess = pItem->m_iIndex;
              ULONG fAccessPermission = m_accessRightInfoArr[iAccess]->GetAccess();

              if ((fAccessPermission == _WIZ_READ) || (fAccessPermission == _WIZ_WRITE) )
              {
                // need to select all the Read or Write Properties entried
                // and the ACTRL_DS_READ_PROP ACTRL_DS_WRITE_PROP (Read All/Write All)
                // select all access rigths
                UINT nAssociatedAccessRight = 
                  (fAccessPermission == _WIZ_READ) ? ACTRL_DS_READ_PROP : ACTRL_DS_WRITE_PROP;
                for (UINT i = 0; i < m_accessRightInfoArr.GetCount(); i++)
                {
                  if (m_accessRightInfoArr[i]->GetAccess() == nAssociatedAccessRight)
                  {
                    m_accessRightInfoArr[i]->Select(TRUE);
                    _SelectAllPropertyRigths(nAssociatedAccessRight);
                    if (m_propertyRightInfoArray.GetCount() > 0)
                      *pnNewFilterState |= FILTER_EXP_PROP;
                    break;
                  }
                }
              }

              if ( (fAccessPermission == ACTRL_DS_CREATE_CHILD) || (fAccessPermission == ACTRL_DS_DELETE_CHILD) )
              {
                // need to select all the Create or Delete Child entries, if present
                _SelectAllSubObjectRigths(fAccessPermission);

                // set the flags
                if (m_classRightInfoArray.GetCount() > 0)
                  *pnNewFilterState |= FILTER_EXP_SUBOBJ;
              }
              else if ( (fAccessPermission == ACTRL_DS_READ_PROP) || (fAccessPermission == ACTRL_DS_WRITE_PROP) )
              {
                // need to select all the Read or Write Property entries, if present
                _SelectAllPropertyRigths(fAccessPermission);

                // set the flags
                if (m_propertyRightInfoArray.GetCount() > 0)
                  *pnNewFilterState |= FILTER_EXP_PROP;
              } // if
            } // if index zero
          } // if type is access
        }
        else // i.e. !bSelect
        {
          if (pItem->m_type == CRigthsListViewItem::access)
          {
            if (pItem->m_iIndex != 0)
            {
              // deselection on anything but full control
              _DeselectAssociatedRights(m_accessRightInfoArr[pItem->m_iIndex]->GetAccess());
            }
          }
          else if (pItem->m_type == CRigthsListViewItem::ctrl)
          {
            _DeselectAssociatedRights(m_controlRightInfoArr[pItem->m_iIndex]->GetAccess());
          }
/*
          // deselection on anything but full control
          if ( !((pItem->m_iIndex == 0) && (pItem->m_type == CRigthsListViewItem::access)) )
          {
            _DeselectAssociatedRights(0);
          }
*/
        }
      }
      break;

    case CRigthsListViewItem::prop: // property rights
      {
        ASSERT(pItem->m_iIndex < m_propertyRightInfoArray.GetCount());
        m_propertyRightInfoArray[pItem->m_iIndex]->SetRight(pItem->m_iRight, bSelect);
        if (!bSelect)
        {
          // unchecking any Read/Write property, will unckeck the Read/Write All,
          // Read and full control
          _DeselectAssociatedRights(m_propertyRightInfoArray[pItem->m_iIndex]->GetRight(pItem->m_iRight));
        }
      }
      break;

    case CRigthsListViewItem::subobj: // subobject rigths
      {
        ASSERT(pItem->m_iIndex < m_classRightInfoArray.GetCount());
        m_classRightInfoArray[pItem->m_iIndex]->SetRight(pItem->m_iRight, bSelect);
        if (!bSelect)
        {
          // unchecking any Create/Delete property, will unckeck the Create/Delete All
          // and full control
          _DeselectAssociatedRights(m_classRightInfoArray[pItem->m_iIndex]->GetRight(pItem->m_iRight));
        }
      }
      break;
    default:
      ASSERT(FALSE);
  };

}


void CCustomAccessPermissionsHolder::FillAccessRightsListView(
                       CCheckListViewHelper* pListViewHelper,
                       ULONG nFilterState)
{
  // clear the array of list view item proxies
  m_listViewItemArr.Clear();

  // enumerate the permissions and add to the checklist
  ULONG i,j;
  ULONG iListViewItem = 0;
  
  // GENERAL RIGTHS
  if (nFilterState & FILTER_EXP_GEN)
  {
    // add the list of access rights
    UINT nAccessCount = (ULONG) m_accessRightInfoArr.GetCount();
    for (i = 0; i < nAccessCount; i++)
    {
      // filter out entries with ACTRL_SYSTEM_ACCESS (auditing rigths)
      if  ( (m_accessRightInfoArr[i]->GetAccess() & ACTRL_SYSTEM_ACCESS) == 0)
      {
        CRigthsListViewItem* p = new CRigthsListViewItem(i, // index in m_accessRightInfoArr
                                                         0, // iRight
                                                         CRigthsListViewItem::access);
        m_listViewItemArr.Add(p);
        pListViewHelper->InsertItem(iListViewItem, 
                                    m_accessRightInfoArr[i]->GetDisplayName(), 
                                    (LPARAM)p,
                                    m_accessRightInfoArr[i]->IsSelected());
        iListViewItem++;
      }
    }

    // add the list of control rights
    UINT nControlCount = (ULONG) m_controlRightInfoArr.GetCount();
    for (i = 0; i < nControlCount; i++)
    {
      CRigthsListViewItem* p = new CRigthsListViewItem(i, // index in m_controlRightInfoArr
                                                        0, // iRight 
                                                        CRigthsListViewItem::ctrl);
      m_listViewItemArr.Add(p);
      pListViewHelper->InsertItem(iListViewItem, 
                                  m_controlRightInfoArr[i]->GetDisplayName(), 
                                  (LPARAM)p,
                                  m_controlRightInfoArr[i]->IsSelected());
      iListViewItem++;
    }
  }
  
  // PROPERTY RIGTHS
  if (nFilterState & FILTER_EXP_PROP)
  {
    // it expands (2x)
    for (i = 0; i < (ULONG) m_propertyRightInfoArray.GetCount(); i++)
    {
      for (j=0; j< m_propertyRightInfoArray[i]->GetRightCount(); j++)
      {
        CRigthsListViewItem* p = new CRigthsListViewItem(i,j, CRigthsListViewItem::prop);
        m_listViewItemArr.Add(p);
        pListViewHelper->InsertItem(iListViewItem, 
                        m_propertyRightInfoArray[i]->GetRightDisplayString(j), 
                        (LPARAM)p,
                        m_propertyRightInfoArray[i]->IsRightSelected(j));
        iListViewItem++;
      }
    }
  }

  // SUBOBJECT RIGTHS
  if (nFilterState & FILTER_EXP_SUBOBJ)
  {
    // it expands (2x)
    for (i = 0; i < m_classRightInfoArray.GetCount(); i++)
    {
      for (j=0; j< m_classRightInfoArray[i]->GetRightCount(); j++)
      {
        CRigthsListViewItem* p = new CRigthsListViewItem(i,j, CRigthsListViewItem::subobj);
        m_listViewItemArr.Add(p);
        pListViewHelper->InsertItem(iListViewItem, 
                      m_classRightInfoArray[i]->GetRightDisplayString(j), 
                      (LPARAM)p,
                      m_classRightInfoArray[i]->IsRightSelected(j));
        iListViewItem++;
      }
    }
  } // if

  ASSERT(iListViewItem == m_listViewItemArr.GetCount());
}

void CCustomAccessPermissionsHolder::UpdateAccessRightsListViewSelection(
                       CCheckListViewHelper* pListViewHelper,
                       ULONG /*nFilterState*/)
{
  // syncrhonize the UI with the data
  int nListViewCount = pListViewHelper->GetItemCount();

  for (int iListViewItem=0; iListViewItem < nListViewCount; iListViewItem++)
  {
    CRigthsListViewItem* pCurrItem = 
          (CRigthsListViewItem*)pListViewHelper->GetItemData(iListViewItem);

    switch (pCurrItem->m_type)
    {
      case CRigthsListViewItem::access:
        {
          pListViewHelper->SetItemCheck(iListViewItem, 
                    m_accessRightInfoArr[pCurrItem->m_iIndex]->IsSelected());
        }
        break;
      case CRigthsListViewItem::ctrl:
        {
          pListViewHelper->SetItemCheck(iListViewItem,
                m_controlRightInfoArr[pCurrItem->m_iIndex]->IsSelected());
        }
        break;
      case CRigthsListViewItem::prop:
        {
         pListViewHelper->SetItemCheck(iListViewItem,
           m_propertyRightInfoArray[pCurrItem->m_iIndex]->IsRightSelected(pCurrItem->m_iRight));
        }
        break;
      case CRigthsListViewItem::subobj:
        {
         pListViewHelper->SetItemCheck(iListViewItem,
           m_classRightInfoArray[pCurrItem->m_iIndex]->IsRightSelected(pCurrItem->m_iRight));
        }
        break;
    } // switch
  } // for

}



void CCustomAccessPermissionsHolder::WriteSummary(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine)
{
  WriteSummaryTitleLine(szSummary, IDS_DELEGWIZ_FINISH_PERMISSIONS, lpszNewLine);

  if (m_accessRightInfoArr[0]->IsSelected()) // full control
	{
    WriteSummaryLine(szSummary, m_accessRightInfoArr[0]->GetDisplayName(), lpszIdent, lpszNewLine);
	}
	else
	{
    ULONG AccessAllClass = 0;
    ULONG AccessAllProperty = 0;

    UINT i,j,k;
    // add an entry for all the standard access permissions:
		for (k=0; k < m_accessRightInfoArr.GetCount(); k++)
		{
			if (m_accessRightInfoArr[k]->IsSelected())
      {
        // keep track of "All" flags
        if (m_accessRightInfoArr[k]->GetAccess() & ACTRL_DS_READ_PROP)
          AccessAllProperty |= ACTRL_DS_READ_PROP;
        if (m_accessRightInfoArr[k]->GetAccess() &  ACTRL_DS_WRITE_PROP)
          AccessAllProperty |= ACTRL_DS_WRITE_PROP;

        if (m_accessRightInfoArr[k]->GetAccess() & ACTRL_DS_CREATE_CHILD)
          AccessAllClass |= ACTRL_DS_CREATE_CHILD;
        if (m_accessRightInfoArr[k]->GetAccess() &  ACTRL_DS_DELETE_CHILD)
          AccessAllClass |= ACTRL_DS_DELETE_CHILD;

        WriteSummaryLine(szSummary, m_accessRightInfoArr[k]->GetDisplayName(), lpszIdent, lpszNewLine);
      }
    } // for

    // add an entry for each of the control rights
    for (k=0; k < m_controlRightInfoArr.GetCount(); k++)
    {
      if (m_controlRightInfoArr[k]->IsSelected())
      {
        WriteSummaryLine(szSummary, m_controlRightInfoArr[k]->GetDisplayName(), lpszIdent, lpszNewLine);
      }
    } // for

    // add an entry for each of the subobjects rigths
    for (i = 0; i < m_classRightInfoArray.GetCount(); i++)
    {
      for (j=0; j< m_classRightInfoArray[i]->GetRightCount(); j++)
      {
        if ( m_classRightInfoArray[i]->IsRightSelected(j) &&
              ((AccessAllClass & m_classRightInfoArray[i]->GetRight(j)) == 0) )
        {
          WriteSummaryLine(szSummary, m_classRightInfoArray[i]->GetRightDisplayString(j), lpszIdent, lpszNewLine);
        }
      }
    }

    // add an entry for each property right to set
    for (i = 0; i < m_propertyRightInfoArray.GetCount(); i++)
    {
      for (j=0; j< m_propertyRightInfoArray[i]->GetRightCount(); j++)
      {
        if ( m_propertyRightInfoArray[i]->IsRightSelected(j) &&
            ((AccessAllProperty & m_propertyRightInfoArray[0]->GetRight(j)) == 0) )
        {
          WriteSummaryLine(szSummary, m_propertyRightInfoArray[i]->GetRightDisplayString(j), lpszIdent, lpszNewLine);
        }
      }
    }

  } // if

  szSummary += lpszNewLine;
}



///////////////////////////////////////////////////////////////////////
// CCheckListViewHelper

#define CHECK_BIT(x) ((x >> 12) -1)
#define CHECK_CHANGED(pNMListView) \
	(CHECK_BIT(pNMListView->uNewState) ^ CHECK_BIT(pNMListView->uOldState))

#define LVIS_STATEIMAGEMASK_CHECK (0x2000)
#define LVIS_STATEIMAGEMASK_UNCHECK (0x1000)


BOOL CCheckListViewHelper::IsChecked(NM_LISTVIEW* pNMListView)
{
	return (CHECK_BIT(pNMListView->uNewState) != 0);
}


BOOL CCheckListViewHelper::CheckChanged(NM_LISTVIEW* pNMListView)
{
	if (pNMListView->uOldState == 0)
		return FALSE; // adding new items...
	return CHECK_CHANGED(pNMListView) ? TRUE : FALSE;
}

BOOL CCheckListViewHelper::Initialize(UINT nID, HWND hParent)
{
	m_hWnd = GetDlgItem(hParent, nID);
	if (m_hWnd == NULL)
		return FALSE;

	ListView_SetExtendedListViewStyle(m_hWnd, LVS_EX_CHECKBOXES);

	RECT r;
	::GetClientRect(m_hWnd, &r);
	int scroll = ::GetSystemMetrics(SM_CXVSCROLL);
	LV_COLUMN col;
	ZeroMemory(&col, sizeof(LV_COLUMN));
	col.mask = LVCF_WIDTH;
	col.cx = (r.right - r.left) - scroll;
	return (0 == ListView_InsertColumn(m_hWnd,0,&col));
}

int CCheckListViewHelper::InsertItem(int iItem, LPCTSTR lpszText, LPARAM lParam, BOOL bCheck)
{
  TRACE(_T("CCheckListViewHelper::InsertItem(%d,%s,%x)\n"),iItem, lpszText, lParam);

	LV_ITEM item;
	ZeroMemory(&item, sizeof(LV_ITEM));
	item.mask = LVIF_TEXT | LVIF_PARAM;
	item.pszText = (LPTSTR)lpszText;
	item.lParam = lParam;
	item.iItem = iItem;

  int iRes = ListView_InsertItem(m_hWnd, &item);
  if ((iRes != -1) && bCheck)
    SetItemCheck(iItem, TRUE);
  return iRes;
}

BOOL CCheckListViewHelper::SetItemCheck(int iItem, BOOL bCheck)
{
	LV_ITEM item;
	ZeroMemory(&item, sizeof(LV_ITEM));
	item.mask = LVIF_STATE;
	item.state = bCheck ? LVIS_STATEIMAGEMASK_CHECK : LVIS_STATEIMAGEMASK_UNCHECK;
	item.stateMask = LVIS_STATEIMAGEMASK;
	item.iItem = iItem;
	return ListView_SetItem(m_hWnd, &item);
}

void CCheckListViewHelper::SetCheckAll(BOOL bCheck)
{
	LV_ITEM item;
	ZeroMemory(&item, sizeof(LV_ITEM));
	item.mask = LVIF_STATE;
	item.state = bCheck ? LVIS_STATEIMAGEMASK_CHECK : LVIS_STATEIMAGEMASK_UNCHECK;
	item.stateMask = LVIS_STATEIMAGEMASK;

	int nCount = ListView_GetItemCount(m_hWnd);
	for (int k = 0; k< nCount; k++)
	{
		item.iItem = k;
		ListView_SetItem(m_hWnd, &item);
	}
}

LPARAM CCheckListViewHelper::GetItemData(int iItem)
{
	LV_ITEM item;
	ZeroMemory(&item, sizeof(LV_ITEM));
	item.mask = LVIF_PARAM;
	item.iItem = iItem;
	ListView_GetItem(m_hWnd, &item);
	return item.lParam;
}

int CCheckListViewHelper::GetCheckCount()
{
	int nCount = GetItemCount();
	int nCheckCount = 0;
	for (int k=0; k<nCount; k++)
	{
		if (ListView_GetCheckState(m_hWnd,k))
			nCheckCount++;
	}
	return nCheckCount;
}

BOOL CCheckListViewHelper::IsItemChecked(int iItem)
{
  return ListView_GetCheckState(m_hWnd, iItem);
}

void CCheckListViewHelper::GetCheckedItems(int nCheckCount, int* nCheckArray)
{
	int nCount = GetItemCount();
	int nCurrentCheck = 0;
	for (int k=0; k<nCount; k++)
	{
		if (ListView_GetCheckState(m_hWnd,k) && nCurrentCheck < nCheckCount)
		{
			nCheckArray[nCurrentCheck++] = k;
		}
	}
}


////////////////////////////////////////////////////////////////////////////
// CNamedSecurityInfo

/*
DWORD CNamedSecurityInfo::Get()
{
  Reset(); // clear previous data

  LPWSTR lpProvider = NULL; // not used
  LPWSTR lpProperty = NULL; // want all

  return ::GetNamedSecurityInfoEx(IN (LPWSTR) m_szObjectName.data(),
                        IN   SE_DS_OBJECT_ALL,
                        IN   DACL_SECURITY_INFORMATION,
                        IN   lpProvider,
                        IN   lpProperty,
                        OUT  &m_pAccessList,
                        OUT  &m_pAuditList,
                        OUT  &m_pOwner,
                        OUT  &m_pGroup);
}


DWORD CNamedSecurityInfo::Set()
{
  LPWSTR lpProvider = NULL; // not used

  dwErr = ::SetNamedSecurityInfoEx(IN   (LPWSTR) m_szObjectName.data(),
                        IN   SE_DS_OBJECT_ALL,
                        IN   DACL_SECURITY_INFORMATION,
                        IN   lpProvider,
                        IN   m_pAccessList,
                        IN   m_pAuditList,
                        IN   m_pOwner,
                        IN   m_pGroup,
                        IN   NULL); // PACTRL_OVERLAPPED pOverlapped;
}

CNamedSecurityInfo::Reset()
{
	if (m_pAuditList != NULL)
		::LocalFree(m_pAuditList);
	if (m_pOwner != NULL)
		::LocalFree(m_pOwner);
	if (m_pGroup != NULL)
		::LocalFree(m_pGroup);

	if (m_pAccessList != NULL)
		::LocalFree(m_pAccessList);
}

*/


////////////////////////////////////////////////////////////////////////////
// CAdsiObject

HRESULT CAdsiObject::Bind(LPCWSTR lpszLdapPath)
{
  _Clear();

  CComBSTR bstrNamingContext;
  CComBSTR bstrClass;


	// try to bind to the given LDAP path
  HRESULT hr = ::ADsOpenObjectHelper(lpszLdapPath,
                        IID_IADs,
                        (void **)&m_spIADs);
  if (FAILED(hr))
	{
    TRACE(_T("Bind to DS object for IADs failed: %lx.\n"), hr);
    goto error;
  }

  // get the DNS server name
  hr = _QueryDNSServerName();
  if (FAILED(hr))
	{
    TRACE(_T("Trying to get the DNS server name failed: %lx.\n"), hr);
    goto error;
  }

  hr = _InitGlobalNamingContexts();
  if (FAILED(hr))
	{
    TRACE(_T("Trying to get the physical schema naming context failed: %lx.\n"), hr);
    goto error;
  }

  // need now to rebuild the LDAP path
  // to make sure we talk always to the same server
  hr = GetPathNameObject()->SkipPrefix(lpszLdapPath, &bstrNamingContext);
  if (FAILED(hr))
  {
    TRACE(_T("Trying to get X500 name failed: %lx.\n"), hr);
    goto error;
  }
  if ( (!bstrNamingContext ) || (!bstrNamingContext[0]))
  {
    goto error;
  }
  m_szNamingContext = bstrNamingContext;
  BuildLdapPathHelper(GetServerName(), bstrNamingContext, m_szLdapPath);

  // get the canonical name
  hr = GetCanonicalNameFromNamingContext(bstrNamingContext, m_szCanonicalName);
  if (FAILED(hr))
  {
    TRACE(_T("Trying to get canonical name failed, using naming context instead: %lx.\n"), hr);
    m_szCanonicalName = bstrNamingContext;
  }
  // get the object class
	hr = m_spIADs->get_Class(&bstrClass);
  if (FAILED(hr))
  {
    TRACE(_T("Trying to get class name failed: %lx.\n"), hr);
    goto error;
  }
  ASSERT(bstrClass != NULL);
  m_szClass = bstrClass;


  // load and set the display specifier cache
  hr = ::CoCreateInstance(CLSID_DsDisplaySpecifier,
                          NULL,
						              CLSCTX_INPROC_SERVER,
                          IID_IDsDisplaySpecifier,
                          (void**)&m_spIDsDisplaySpecifier);
  if (FAILED(hr))
  {
    TRACE(_T("Trying to get the display specifier cache failed: %lx.\n"), hr);
    goto error;
  }

  hr = m_spIDsDisplaySpecifier->SetServer(GetServerName(), NULL, NULL, 0x0);
  if (FAILED(hr))
  {
    TRACE(_T("m_spIDsDisplaySpecifier->SetServer(%s) failed\n"), GetServerName());
    goto error;
  }

  ASSERT(SUCCEEDED(hr)); // all went fine
  return hr;

error:
  // on error condition, just reset the info, we do not
  // want a partially constructed object
  _Clear();
  return hr;
}



#define DO_TIMING

HRESULT CAdsiObject::QuerySchemaClasses(CGrowableArr<CSchemaClassInfo>*	pSchemaClassesInfoArray,
                                        BOOL bGetAttributes)
{
  TRACE(L"\n==================================================\n");
  TRACE(L"CAdsiObject::QuerySchemaClasses\n\n");
#if defined (DO_TIMING)
  DWORD dwTick1 = ::GetTickCount();
#endif

  // make sure we are bound
  if (m_spIADs == NULL)
  {
    return E_INVALIDARG;
  }

	// cleanup current entries in the list
	pSchemaClassesInfoArray->Clear();

	// build the LDAP path for the schema class
  CWString szPhysicalSchemaPath;
  LPCWSTR lpszPhysicalSchemaNamingContext = GetPhysicalSchemaNamingContext();
  BuildLdapPathHelper(GetServerName(), lpszPhysicalSchemaNamingContext, szPhysicalSchemaPath);

  CAdsiSearch search;
  HRESULT hr = search.Init(szPhysicalSchemaPath);
  if (FAILED(hr))
    return hr;

  static LPCWSTR lpszClassFilterFormat = L"(&(objectCategory=CN=Class-Schema,%s)(lDAPDisplayName=*))";
  static LPCWSTR lpszAttributeFilterFormat = L"(&(objectCategory=CN=Attribute-Schema,%s)(lDAPDisplayName=*))";
  LPCWSTR lpszFilterFormat = bGetAttributes ? lpszAttributeFilterFormat : lpszClassFilterFormat;

  int nFmtLen = lstrlen(lpszFilterFormat);
  int nSchemaContextLen = lstrlen(lpszPhysicalSchemaNamingContext);

  WCHAR* lpszFilter = (WCHAR*)alloca(sizeof(WCHAR)*(nFmtLen+nSchemaContextLen+1));
  wsprintf(lpszFilter, lpszFilterFormat, lpszPhysicalSchemaNamingContext);

  static const int cAttrs = 4;
  static LPCWSTR pszAttribsArr[cAttrs] = 
  {
    L"lDAPDisplayName", // e.g. "organizationalUnit"
    L"name",             // e.g. "Organizational-Unit"
    L"schemaIDGUID",
	L"objectClassCategory",	
  }; 

  
  hr = search.SetSearchScope(ADS_SCOPE_ONELEVEL);
  if (FAILED(hr))
    return hr;
  hr = search.DoQuery(lpszFilter, pszAttribsArr, cAttrs);

  if (FAILED(hr))
    return hr;

  CWString szLDAPName, szName;
  szLDAPName = L"";
  szName = L"";
  GUID schemaIDGUID;
  ULONG iObjectClassCategory=0;

  while ((hr = search.GetNextRow()) != S_ADS_NOMORE_ROWS)
  {
    if (FAILED(hr))
      continue;

    HRESULT hr0 = search.GetColumnString(pszAttribsArr[0], szLDAPName);
    HRESULT hr1 = search.GetColumnString(pszAttribsArr[1], szName);
    HRESULT hr2 = search.GetColumnOctectStringGUID(pszAttribsArr[2], schemaIDGUID);
	HRESULT hr3 = search.GetColumnInteger(pszAttribsArr[3], iObjectClassCategory);


    if (FAILED(hr0) || FAILED(hr1) || FAILED(hr2) || FAILED(hr3))
      continue;

    ULONG fFilterFlags = ::GetClassFlags(szLDAPName);

    CSchemaClassInfo* p = new CSchemaClassInfo(szLDAPName, szName, &schemaIDGUID);
	if(!p)
		return E_OUTOFMEMORY;

    BOOL bFilter = (fFilterFlags & IDC_CLASS_NO);
    if (bFilter)
      p->SetFiltered();

	//is class Auxiallary
	if(iObjectClassCategory == 3)
		p->SetAux();

    pSchemaClassesInfoArray->Add(p);
    //TRACE(L"Class %s inserted, IsFiltered() == %d\n", (LPCWSTR)szName, p->IsFiltered());

  } // while

  TRACE(L"\n================================================\n");
#if defined (DO_TIMING)
  DWORD dwTick2 = ::GetTickCount();
  TRACE(L"Time to do Schema Query loop (mSec) = %d\n", dwTick2-dwTick1);
#endif

  _GetFriendlyClassNames(pSchemaClassesInfoArray);

#if defined (DO_TIMING)
  dwTick2 = ::GetTickCount();
#endif
  pSchemaClassesInfoArray->Sort(); // wrt friendly class name

#if defined (DO_TIMING)
  DWORD dwTick3 = ::GetTickCount();
  TRACE(L"Time to sort (mSec) = %d\n", dwTick3-dwTick2);
#endif



  TRACE(L"exiting CAdsiObject::QuerySchemaClasses()\n\n");
  return hr;
}


HRESULT CAdsiObject::GetClassGuid(LPCWSTR lpszClassLdapDisplayName, BOOL bGetAttribute, GUID& guid)
{
  //TRACE(L"CAdsiObject::GetClassGuid(%s, _)\n\n", lpszClassLdapDisplayName);

  ZeroMemory(&guid, sizeof(GUID));

  // make sure we are bound
  if (m_spIADs == NULL)
  {
    return E_INVALIDARG;
  }


	// build the LDAP path for the schema class
  CWString szPhysicalSchemaPath;
  LPCWSTR lpszPhysicalSchemaNamingContext = GetPhysicalSchemaNamingContext();
  BuildLdapPathHelper(GetServerName(), lpszPhysicalSchemaNamingContext, szPhysicalSchemaPath);

  CAdsiSearch search;
  HRESULT hr = search.Init(szPhysicalSchemaPath);
  if (FAILED(hr))
    return hr;

  static LPCWSTR lpszClassFilterFormat = L"(&(objectCategory=CN=Class-Schema,%s)(lDAPDisplayName=%s))";
  static LPCWSTR lpszAttributeFilterFormat = L"(&(objectCategory=CN=Attribute-Schema,%s)(lDAPDisplayName=%s))";
  LPCWSTR lpszFilterFormat = bGetAttribute ? lpszAttributeFilterFormat : lpszClassFilterFormat;

  int nFmtLen = lstrlen(lpszFilterFormat);
  int nSchemaContextLen = lstrlen(lpszPhysicalSchemaNamingContext);
  int nlDAPDisplayNameLen = lstrlen(lpszClassLdapDisplayName);

  WCHAR* lpszFilter = (WCHAR*)alloca(sizeof(WCHAR)*(nFmtLen+nSchemaContextLen+nlDAPDisplayNameLen+1));
  wsprintf(lpszFilter, lpszFilterFormat, lpszPhysicalSchemaNamingContext, lpszClassLdapDisplayName);


  //TRACE(L"lpszFilter = %s\n", lpszFilter);

  static const int cAttrs = 1;
  static LPCWSTR pszAttribsArr[cAttrs] = 
  {
    L"schemaIDGUID",
  }; 
  
  hr = search.SetSearchScope(ADS_SCOPE_ONELEVEL);
  if (FAILED(hr))
    return hr;
  hr = search.DoQuery(lpszFilter, pszAttribsArr, cAttrs);

  if (FAILED(hr))
    return hr;


  // expect a single result
  hr = search.GetNextRow();
  if ( hr == S_ADS_NOMORE_ROWS)
  {
    hr = E_ADS_UNKNOWN_OBJECT;
  }
  if (FAILED(hr))
    return hr;

  hr = search.GetColumnOctectStringGUID(pszAttribsArr[0], guid);

  //TRACE(L"exiting CAdsiObject::GetClassGuid()\n\n");
  return hr;
}




HRESULT CAdsiObject::_QueryDNSServerName()
{
  // make sure we are bound
  if (m_spIADs == NULL)
  {
    return E_INVALIDARG;
  }

  m_szServerName = L"";

  CComPtr<IADsObjectOptions> spIADsObjectOptions;
  HRESULT hr = m_spIADs->QueryInterface(IID_IADsObjectOptions, (void**)&spIADsObjectOptions);
  if (FAILED(hr))
    return hr;

  CComVariant var;
  hr = spIADsObjectOptions->GetOption(ADS_OPTION_SERVERNAME, &var);
  if (FAILED(hr))
    return hr;

  ASSERT(var.vt == VT_BSTR);
  m_szServerName = V_BSTR(&var);
  return hr;
}


HRESULT CAdsiObject::_InitGlobalNamingContexts()
{
  return ::GetGlobalNamingContexts(GetServerName(),
                                   m_szPhysicalSchemaNamingContext,
                                   m_szConfigurationNamingContext);
}



HICON CAdsiObject::GetClassIcon(LPCWSTR lpszObjectClass)
{
  ASSERT(m_spIDsDisplaySpecifier != NULL);

  return m_spIDsDisplaySpecifier->GetIcon(lpszObjectClass,
                                          DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON,
                                          32, 32);
}


HRESULT CAdsiObject::GetFriendlyClassName(LPCWSTR lpszObjectClass, 
                                          LPWSTR lpszBuffer, int cchBuffer)
{
  ASSERT(m_spIDsDisplaySpecifier != NULL);
  return m_spIDsDisplaySpecifier->GetFriendlyClassName(lpszObjectClass,
                                                       lpszBuffer,
                                                       cchBuffer);
}

HRESULT CAdsiObject::GetFriendlyAttributeName(LPCWSTR lpszObjectClass, 
                                              LPCWSTR lpszAttributeName,
                                              LPWSTR lpszBuffer, int cchBuffer)
{
  ASSERT(m_spIDsDisplaySpecifier != NULL);
  return m_spIDsDisplaySpecifier->GetFriendlyAttributeName(lpszObjectClass, 
                                                           lpszAttributeName,
                                                           lpszBuffer, cchBuffer);
}


#if (FALSE)

HRESULT CAdsiObject::_GetFriendlyClassNames(CGrowableArr<CSchemaClassInfo>*	pSchemaClassesInfoArray)
{
  TRACE(L"begin _GetFriendlyClassNames() loop on all classes\n");

#if defined (DO_TIMING)
  DWORD dwTick1 = ::GetTickCount();
#endif

  // now get the friendly class name to display
  ULONG nCount = pSchemaClassesInfoArray->GetCount();
  WCHAR szFrendlyName[1024];

  for (UINT k=0; k<nCount; k++)
  {
    CSchemaClassInfo* p = (*pSchemaClassesInfoArray)[k];
    HRESULT hrFriendlyName = this->GetFriendlyClassName(p->GetName(), szFrendlyName, 1024);
    ASSERT(SUCCEEDED(hrFriendlyName));
    (*pSchemaClassesInfoArray)[k]->SetDisplayName(SUCCEEDED(hrFriendlyName) ? szFrendlyName : NULL);
  }

#if defined (DO_TIMING)
  DWORD dwTick2 = ::GetTickCount();
  TRACE(L"Time to call _GetFriendlyClassNames() loop (mSec) = %d\n", dwTick2-dwTick1);
#endif

  return S_OK;
}

#else

HRESULT CAdsiObject::_GetFriendlyClassNames(CGrowableArr<CSchemaClassInfo>*	pSchemaClassesInfoArray)
{
  TRACE(L"\nbegin _GetFriendlyClassNames() using ADSI query\n");

#if defined (DO_TIMING)
  DWORD dwTick1 = ::GetTickCount();
#endif

  ASSERT(m_spIDsDisplaySpecifier != NULL);

  // get the display specifiers locale container (e.g. 409)
  CComPtr<IADs> spLocaleContainer;
  HRESULT hr = m_spIDsDisplaySpecifier->GetDisplaySpecifier(NULL, IID_IADs, (void**)&spLocaleContainer);
  if (FAILED(hr))
    return hr;

  // get distinguished name of the container
  CComVariant varLocaleContainerDN;
  hr = spLocaleContainer->Get(L"distinguishedName", &varLocaleContainerDN);
  if (FAILED(hr))
    return hr;

  // build the LDAP path for it
  CWString szLocaleContainerPath;
  BuildLdapPathHelper(GetServerName(), varLocaleContainerDN.bstrVal, szLocaleContainerPath);

	// build the LDAP path for the schema class
  CWString szPhysicalSchemaPath;
  LPCWSTR lpszPhysicalSchemaNamingContext = GetPhysicalSchemaNamingContext();
  BuildLdapPathHelper(GetServerName(), lpszPhysicalSchemaNamingContext, szPhysicalSchemaPath);

  // build an LDAP query string
  static LPCWSTR lpszFilterFormat = L"(objectCategory=CN=Display-Specifier,%s)";

  int nFmtLen = lstrlen(lpszFilterFormat);
  int nArgumentLen = lstrlen(lpszPhysicalSchemaNamingContext);

  WCHAR* lpszFilter = (WCHAR*)alloca(sizeof(WCHAR)*(nFmtLen+nArgumentLen+1));
  wsprintf(lpszFilter, lpszFilterFormat, lpszPhysicalSchemaNamingContext);


  // execute a query to get the CN and the class display name
  CAdsiSearch search;
  hr = search.Init(szLocaleContainerPath);
  if (FAILED(hr))
    return hr;

  // build an array of wanted columns
  static const int cAttrs = 2;
  static LPCWSTR pszAttribsArr[cAttrs] = 
  {
    L"cn",                  // e.g. "organizationalUnit-Display"
    L"classDisplayName",    // e.g. "Organizational Unit" (i.e. the localizable one)
  }; 
  
  hr = search.SetSearchScope(ADS_SCOPE_ONELEVEL);
  //TRACE(L"search.SetSearchScope(ADS_SCOPE_ONELEVEL) returned hr = 0x%x\n", hr);
  if (FAILED(hr))
    return hr;

  hr = search.DoQuery(lpszFilter, pszAttribsArr, cAttrs);
  //TRACE(L"search.DoQuery(lpszFilter, pszAttribsArr, cAttrs) returned hr = 0x%x\n", hr);
  if (FAILED(hr))
    return hr;

  // need to keep track of matches
  size_t nCount = pSchemaClassesInfoArray->GetCount();

  BOOL* bFoundArray = (BOOL*)alloca(nCount*sizeof(BOOL));
  ZeroMemory(bFoundArray, nCount*sizeof(BOOL));

  WCHAR szBuffer[1024];


  CWString szNamingAttribute, szClassDisplayName;

  while ((hr = search.GetNextRow()) != S_ADS_NOMORE_ROWS)
  {
    if (FAILED(hr))
      continue;

    HRESULT hr0 = search.GetColumnString(pszAttribsArr[0], szNamingAttribute);
    HRESULT hr1 = search.GetColumnString(pszAttribsArr[1], szClassDisplayName);

    //TRACE(L"szNamingAttribute = <%s>, szClassDisplayName = <%s>\n", 
    //        szNamingAttribute.c_str(), szClassDisplayName.c_str());
    
    if (FAILED(hr0) || FAILED(hr1) )
    {
      TRACE(L"WARNING: discarding right, failed on columns: hr0 = 0x%x, hr1 = 0x%x\n",
                            hr0, hr1);
      continue;
    }
    
    // got a good name, need to match with the entries in the array
    for (UINT k=0; k<nCount; k++)
    {
      if (!bFoundArray[k])
      {
        CSchemaClassInfo* p = (*pSchemaClassesInfoArray)[k];
        wsprintf(szBuffer, L"%s-Display",p->GetName());
        if (_wcsicmp(szBuffer, szNamingAttribute) == 0)
        {
          //TRACE(L"   matching for %s\n",p->GetName());
          p->SetDisplayName(szClassDisplayName);
          bFoundArray[k] = TRUE;
        }
      }
    } // for
  } // while

  // take care of the ones that did not have any display specifier
  for (UINT k=0; k<nCount; k++)
  {
    if (!bFoundArray[k])
    {
      (*pSchemaClassesInfoArray)[k]->SetDisplayName(NULL);
    }
  } // for

  TRACE(L"\n\n");

  if (hr == S_ADS_NOMORE_ROWS)
    hr = S_OK;

#if defined (DO_TIMING)
  DWORD dwTick2 = ::GetTickCount();
  TRACE(L"Time to call _GetFriendlyClassNames() on ADSI query (mSec) = %d\n", dwTick2-dwTick1);
#endif

  return hr;
}

#endif

bool
CAdsiObject::GetListObjectEnforced()
{
	if(m_iListObjectEnforced != -1)
		return (m_iListObjectEnforced==1);

	PADS_ATTR_INFO pAttributeInfo = NULL;
	IDirectoryObject *pDirectoryService = NULL;
	IADsPathname *pPath = NULL;
	BSTR strServicePath = NULL;
	do
	{
		m_iListObjectEnforced = 0;    // Assume "not enforced"
		HRESULT hr = S_OK;

		int i;

		// Create a path object for manipulating ADS paths
		hr = CoCreateInstance(CLSID_Pathname,
							  NULL,
							  CLSCTX_INPROC_SERVER,
							  IID_IADsPathname,
							  (LPVOID*)&pPath);
		if(FAILED(hr))
			break;

		CComBSTR bstrConfigPath = L"LDAP://";
		if(GetServerName())
		{
			bstrConfigPath += GetServerName();
			bstrConfigPath += L"/";
		}
		if(!GetConfigurationNamingContext())
			break;
		bstrConfigPath += GetConfigurationNamingContext();

		if(!bstrConfigPath.Length())
			break;

		hr = pPath->Set(bstrConfigPath, ADS_SETTYPE_FULL);
		if(FAILED(hr))
			break;


		const LPWSTR aszServicePath[] =
		{
			L"CN=Services",
			L"CN=Windows NT",
			L"CN=Directory Service",
		};

		for (i = 0; i < ARRAYSIZE(aszServicePath); i++)
		{
			hr = pPath->AddLeafElement(aszServicePath[i]);
			if(FAILED(hr))
				break;
		}

		hr = pPath->Retrieve(ADS_FORMAT_WINDOWS, &strServicePath);
		if(FAILED(hr))
			break;

		hr = ADsGetObject(strServicePath,
						  IID_IDirectoryObject,
						  (LPVOID*)&pDirectoryService);
		if(FAILED(hr))
			break;

		WCHAR const c_szDsHeuristics[] = L"dSHeuristics";
		LPWSTR pszDsHeuristics = (LPWSTR)c_szDsHeuristics;
		DWORD dwAttributesReturned = 0;
		hr = pDirectoryService->GetObjectAttributes(&pszDsHeuristics,
													1,
													&pAttributeInfo,
													&dwAttributesReturned);
		if (FAILED(hr)|| !pAttributeInfo)
			break;

		ASSERT(ADSTYPE_DN_STRING <= pAttributeInfo->dwADsType);
		ASSERT(ADSTYPE_NUMERIC_STRING >= pAttributeInfo->dwADsType);
		ASSERT(1 == pAttributeInfo->dwNumValues);
		LPWSTR pszHeuristicString = pAttributeInfo->pADsValues->NumericString;
		if (pszHeuristicString &&
			lstrlenW(pszHeuristicString) > 2 &&
			L'0' != pszHeuristicString[2])
		{
			m_iListObjectEnforced = 1;
		}

	}while(0);

    if (pAttributeInfo)
        FreeADsMem(pAttributeInfo);

    if(pDirectoryService)
		pDirectoryService->Release();
		
    if(pPath)
		pPath->Release();
	if(strServicePath)
		SysFreeString(strServicePath);

    return (m_iListObjectEnforced==1);
}



////////////////////////////////////////////////////////////////////////////////////////
// CAdsiSearch



HRESULT CAdsiSearch::DoQuery(LPCWSTR lpszFilter, LPCWSTR* pszAttribsArr, int cAttrs)
{
  if (m_spSearchObj == NULL)
    return E_ADS_BAD_PATHNAME;

  static const int NUM_PREFS=3;
  static const int QUERY_PAGESIZE = 256;
  ADS_SEARCHPREF_INFO aSearchPref[NUM_PREFS];

  aSearchPref[0].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
  aSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[0].vValue.Integer = ADS_CHASE_REFERRALS_EXTERNAL;
  aSearchPref[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
  aSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[1].vValue.Integer = QUERY_PAGESIZE;
  aSearchPref[2].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
  aSearchPref[2].vValue.dwType = ADSTYPE_BOOLEAN;
  aSearchPref[2].vValue.Integer = FALSE;
    
  HRESULT hr = m_spSearchObj->SetSearchPreference (aSearchPref, NUM_PREFS);
  if (FAILED(hr))
    return hr;
    
  return m_spSearchObj->ExecuteSearch((LPWSTR)lpszFilter,
                                  (LPWSTR*)pszAttribsArr,
                                  cAttrs,
                                  &m_SearchHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\common\_deltemp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       _deltemp.cpp
//
//--------------------------------------------------------------------------


///////////////////////////////////////////////////////////////////////
// LOCAL FUNCTIONS

CSchemaClassInfo* _FindClassByName(LPCWSTR lpszClassName, 
                                 CGrowableArr<CSchemaClassInfo>* pSchemaClassesInfoArray)
{
  int nCount = (int) pSchemaClassesInfoArray->GetCount();
  for (int k=0; k < nCount; k++)
	{
    if (wcscmp(lpszClassName, (*pSchemaClassesInfoArray)[k]->GetName()) == 0)
      return (*pSchemaClassesInfoArray)[k];
  }
  TRACE(L"_FindClassByName(%s) failed\n", lpszClassName);
  return NULL;
}



///////////////////////////////////////////////////////////////////////
// LOCAL CLASSES

////////////////////////////////////////////////////////////////////////
// CTemplateClassReferences

class CTemplateClassReferences
{
public:
  CTemplateClassReferences()
  {
    m_pClassInfo = NULL;
    m_bScopeClass = FALSE;
  }
  CSchemaClassInfo* m_pClassInfo;
  BOOL m_bScopeClass;
  CTemplateObjectTypeListRef m_templateObjectListRef;
};

////////////////////////////////////////////////////////////////////////
// CTemplateClassReferencesList

class CTemplateClassReferencesList : public CPtrList<CTemplateClassReferences*>
{
public:
  CTemplateClassReferencesList() : 
      CPtrList<CTemplateClassReferences*>(FALSE) 
  {
  }
  
  CTemplateClassReferences* FindReference(LPCWSTR lpszClassName)
  {
    CTemplateClassReferencesList::iterator i;
    for (i = begin(); i != end(); ++i)
    {
      CTemplateClassReferences* p = (*i);
      ASSERT(p != NULL);
      if (p->m_pClassInfo != NULL)
      {
        if (wcscmp(p->m_pClassInfo->GetName(),lpszClassName) == 0)
        {
          return p;
        }
      }
    }

    return NULL;
  }
  

};


///////////////////////////////////////////////////////////////////////
// CTemplateAccessPermissionsHolder

CTemplateAccessPermissionsHolder::CTemplateAccessPermissionsHolder(CSchemaClassInfo* pClassInfo,
                                                                   BOOL bScopeClass)
            : CAccessPermissionsHolderBase(FALSE)
{
  ASSERT(pClassInfo != NULL);
  m_pClassInfo = pClassInfo;
  m_bScopeClass = bScopeClass;
}

CTemplateAccessPermissionsHolder::~CTemplateAccessPermissionsHolder()
{
  Clear();
}


HRESULT CTemplateAccessPermissionsHolder::_LoadAccessRightInfoArrayFromTable( BOOL /*bIgnore*/ ,BOOL /*bIgnore*/)
{

  TRACE(L"\nCTemplateAccessPermissionsHolder::_LoadAccessRightInfoArrayFromTable()\n\n");

  for(_ACCESS_BIT_MAP* pCurrEntry = (_ACCESS_BIT_MAP*)GetTemplateAccessRightsMap(); 
                      pCurrEntry->lpsz != NULL; pCurrEntry++)
  {
    CAccessRightInfo* pInfo = new CAccessRightInfo();

    if( !pInfo )
      return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    pInfo->m_szDisplayName = pCurrEntry->lpsz;
    pInfo->m_fAccess = pCurrEntry->fMask;

    TRACE(L"Display Name = <%s>, Access = 0x%x\n", 
          pInfo->m_szDisplayName.c_str(), pInfo->m_fAccess);
    m_accessRightInfoArr.Add(pInfo);
  }

  TRACE(L"\nCTemplateAccessPermissionsHolder::_LoadAccessRightInfoArrayFromTable() exiting\n\n");
  return S_OK;
}


HRESULT CTemplateAccessPermissionsHolder::GetAccessPermissions(CAdsiObject* pADSIObj)
{
  ASSERT(m_pClassInfo != NULL);
  return ReadDataFromDS(pADSIObj, pADSIObj->GetNamingContext(), 
                        m_pClassInfo->GetName(),
                        m_pClassInfo->GetSchemaGUID(), TRUE);

}



BOOL CTemplateAccessPermissionsHolder::SetupFromClassReferences(CTemplateObjectTypeListRef* pRefList)
{
  ASSERT(pRefList != NULL);

  TRACE(L"\nStart setting up permission holder <%s> from template class references\n\n",
    m_pClassInfo->GetName());

    
  // now go through the list of object list references and set
  CTemplateObjectTypeListRef refListValidObjectTypes; // keep track of how many suceeded

  CTemplateObjectTypeListRef::iterator iObjectType;
  for (iObjectType = pRefList->begin(); iObjectType != pRefList->end(); ++iObjectType)
  {
    BOOL bSet = FALSE;
    CTemplateObjectType* pObjectType = (*iObjectType);
    ASSERT(pObjectType != NULL);

    CTemplatePermissionList* pPermissionList = pObjectType->GetPermissionList();
    CTemplatePermissionList::iterator iPermission;

    for (iPermission = pPermissionList->begin(); iPermission != pPermissionList->end(); ++iPermission)
    {
      CTemplatePermission* pTemplatePermission = (*iPermission);
      ASSERT(pTemplatePermission != NULL);

      // need to match the permission type
      if (pTemplatePermission->GetAccessMask() == 0x0)
      {
        // this is a control right
        if (_SetControlRight(pTemplatePermission->GetControlRight()))
        {
          bSet = TRUE;
        }
                         
      }
      else
      {
        if (_SetAccessMask(pTemplatePermission->GetName(),
                       pTemplatePermission->GetAccessMask()))
        {
          bSet = TRUE;
        }
      }
    } // for permission

    if (bSet)
    {
      // we succeded with the current one, so keep track of it
      refListValidObjectTypes.push_back(pObjectType);
    }

  } // for object type


  // verify we got something valid
  size_t nValidCount = refListValidObjectTypes.size();
  if (nValidCount == 0)
  {
    TRACE(L"Failed to set up permission holder: no valid references\n");
    return FALSE; // nothing was set
  }

  TRACE(L"Setting up permission holder succeeded\n");

  return TRUE; // got valid data
}


BOOL CTemplateAccessPermissionsHolder::_SetControlRight(LPCWSTR lpszControlRight)
{
  // need to find the control right and select it

  UINT nRightCount = (UINT) m_controlRightInfoArr.GetCount();
  for (UINT k=0; k < nRightCount; k++)
  {
    //TRACE(L"_SetControlRight() comparing <%s> with <%s>\n", m_controlRightInfoArr[k]->GetDisplayName(), lpszControlRight);

    //NOTICE: we try to map both the display name or raw display name,
    // just in case somebody uses one or the other in the template
    if ( (wcscmp(m_controlRightInfoArr[k]->GetLocalizedName(), lpszControlRight) == 0) ||
          (wcscmp(m_controlRightInfoArr[k]->GetLdapDisplayName(), lpszControlRight) == 0) )
    {
      TRACE(L"_SetControlRight(%s) found a match\n", lpszControlRight);
      m_controlRightInfoArr[k]->Select(TRUE);
      return TRUE;
    }
  } // for
  
  TRACE(L"_SetControlRight(%s) failed to find a match\n", lpszControlRight);
  return FALSE;
}

BOOL CTemplateAccessPermissionsHolder::_SetAccessMask(LPCWSTR lpszName, ULONG fAccessMask)
{
  // is it the @ for "this class"
  // general rights
  if (wcscmp(lpszName, g_lpszThisObject) == 0)
  {
    return _SetGeneralRighs(fAccessMask);
  }
  
  // try property rights ( read or write)
  if (_SetPropertyRight(lpszName, fAccessMask))
    return TRUE;

  // try subobject rigths (create or delete)
  if (_SetSubObjectRight(lpszName, fAccessMask))
    return TRUE;

  TRACE(L"_SetAccessMask(%s, 0x%x) failed to find a match\n", lpszName, fAccessMask);
  return FALSE; // no matching
}


BOOL CTemplateAccessPermissionsHolder::_SetGeneralRighs(ULONG fAccessMask)
{
  // if full control, just select the first item in the selection array
  if (fAccessMask == _GRANT_ALL)
  {
    TRACE(L"_SetGeneralRighs(0x%x) granting full control\n", fAccessMask);
    m_accessRightInfoArr[0]->Select(TRUE);
    return TRUE;
  }

  // try to map into the array of general rights
  BOOL bSet = FALSE;
  UINT nRightCount = (UINT) m_accessRightInfoArr.GetCount();
  for (ULONG k=0; k<nRightCount; k++)
  {
    if (m_accessRightInfoArr[k]->GetAccess() == fAccessMask)
    {
      TRACE(L"_SetGeneralRighs(0x%x) granting %s (0x%x)\n", 
                                  fAccessMask, 
                                  m_accessRightInfoArr[k]->GetDisplayName(),
                                  m_accessRightInfoArr[k]->GetAccess());
      m_accessRightInfoArr[k]->Select(TRUE);
      bSet = TRUE;
    }
  } // for

  return bSet;
}

BOOL CTemplateAccessPermissionsHolder::_SetPropertyRight(LPCWSTR lpszName, ULONG fAccessMask)
{
  for (UINT i = 0; i < m_propertyRightInfoArray.GetCount(); i++)
  {
    if (wcscmp(lpszName, m_propertyRightInfoArray[i]->GetName()) == 0)
    {
      // we found a matching property name
      BOOL bSet = FALSE;
      for (UINT j=0; j< m_propertyRightInfoArray[i]->GetRightCount(); j++)
      {
        if ((fAccessMask & m_propertyRightInfoArray[i]->GetRight(j)) != 0) 
        {
          // we found a matching right
          TRACE(L"Setting property %s \n",  m_propertyRightInfoArray[i]->GetRightDisplayString(j));
          m_propertyRightInfoArray[i]->SetRight(j, TRUE);
          bSet = TRUE;
        }
      } // for j
      return bSet;
    } // if
  } // for i

  //TRACE(L"_SetPropertyRight(%s, 0x%x) failed to match\n", lpszName, fAccessMask);
  return FALSE; // did not find anything
}

BOOL CTemplateAccessPermissionsHolder::_SetSubObjectRight(LPCWSTR lpszName, ULONG fAccessMask)
{
  for (UINT i = 0; i < m_classRightInfoArray.GetCount(); i++)
  {
    if (wcscmp(lpszName, m_classRightInfoArray[i]->GetName()) == 0)
    {
      // we found a matching class name
      BOOL bSet = FALSE;
      for (UINT j=0; j< m_classRightInfoArray[i]->GetRightCount(); j++)
      {
        if ((fAccessMask & m_classRightInfoArray[i]->GetRight(j)) != 0)
        {
          // we found a matching right
          TRACE(L"Setting subobject right %s\n", m_classRightInfoArray[i]->GetRightDisplayString(j));
          m_classRightInfoArray[i]->SetRight(j, TRUE);
          bSet = TRUE;
        }
      } // for j
      return bSet;
    } // if
  } // for i

  //TRACE(L"_SetSubObjectRight(%s, 0x%x) failed to match\n", lpszName, fAccessMask);
  return FALSE; // did not find anything
}





DWORD CTemplateAccessPermissionsHolder::UpdateAccessList(CPrincipal* pPrincipal,
                                                         LPCWSTR lpszServerName,
                                                         LPCWSTR lpszPhysicalSchemaNamingContext,
                                                         PACL *ppAcl )
{
  // just call base class function with the embedded info
  ASSERT(m_pClassInfo != NULL);

  CSchemaClassInfo* pClassInfo = m_pClassInfo;
  if (m_bScopeClass)
  {
    pClassInfo = NULL;
  }
  return CAccessPermissionsHolderBase::UpdateAccessList(pPrincipal, 
                                                        pClassInfo, 
                                                        lpszServerName,
                                                        lpszPhysicalSchemaNamingContext,
                                                        ppAcl);
}


///////////////////////////////////////////////////////////////////////
// CTemplateAccessPermissionsHolderManager


BOOL CTemplateAccessPermissionsHolderManager::LoadTemplates()
{
  // REVIEW_MARCOC: need to load from registry
  // need to ask Praerit about the details
  return m_templateManager.Load(L"delegwiz.inf");
}


BOOL CTemplateAccessPermissionsHolderManager::HasTemplates(LPCWSTR lpszClass) 
{
  return m_templateManager.HasTemplates(lpszClass);
}

BOOL CTemplateAccessPermissionsHolderManager::HasSelectedTemplates()  
{
   return m_templateManager.HasSelectedTemplates();
}

void CTemplateAccessPermissionsHolderManager::DeselectAll()
{
  m_templateManager.DeselectAll();
}


BOOL CTemplateAccessPermissionsHolderManager::
              InitPermissionHoldersFromSelectedTemplates(CGrowableArr<CSchemaClassInfo>* pSchemaClassesInfoArray,
                                                          CAdsiObject* pADSIObj)
{
  TRACE(L"\n\nInitPermissionHoldersFromSelectedTemplates()\n\n");

  // reset the array of permission holders
  m_permissionHolderArray.Clear();

  CTemplateClassReferencesList templateClassReferencesList;
  LPCWSTR lpszScopeClass = pADSIObj->GetClass();

  
  // loop on all templates that apply to this scope class and are selected
  CTemplateList::iterator iTemplate;
  CTemplateList* pTemplateList = m_templateManager.GetTemplateList();

  for (iTemplate = pTemplateList->begin(); iTemplate != pTemplateList->end(); ++iTemplate)
  {
    CTemplate* pTemplate = (*iTemplate);
    ASSERT(pTemplate != NULL);

    // the template must apply to this class and be selected
    if (pTemplate->AppliesToClass(lpszScopeClass) && pTemplate->m_bSelected)
    {
      // loop on all the pertinent object types in the template
      CTemplateObjectTypeList* pObjectTypeList = pTemplate->GetObjectTypeList();
      CTemplateObjectTypeList::iterator iObjectType;

      for (iObjectType = pObjectTypeList->begin(); 
                        iObjectType != pObjectTypeList->end(); ++iObjectType)
      {
        CTemplateObjectType* pObjectType = (*iObjectType);
        ASSERT(pObjectType != NULL);

        LPCWSTR lpszCurrentClassName = pObjectType->GetObjectName();

        // does the object type refer to the SCOPE keyword?
        BOOL bScopeClass = (wcscmp(g_lpszScope, lpszCurrentClassName) == 0);
        if (!bScopeClass)
        {
          // if not, does the object type refer to the scope class?
          bScopeClass = (wcscmp(lpszScopeClass, lpszCurrentClassName) == 0);
        }


        // see if we already have a reference to it
        CTemplateClassReferences* pClassReference = 
          templateClassReferencesList.FindReference(lpszCurrentClassName);

        if (pClassReference == NULL)
        {
          // not seen before can we find the class into the schema?
          CSchemaClassInfo* pChildClassInfo = 
              _FindClassByName(bScopeClass ? lpszScopeClass : lpszCurrentClassName, 
                                    pSchemaClassesInfoArray);

          if (pChildClassInfo != NULL)
          {
            // found the class, create a new reference
            pClassReference = new CTemplateClassReferences();
            pClassReference->m_pClassInfo = pChildClassInfo;
            pClassReference->m_bScopeClass = bScopeClass;

            // add it to the reference list
            templateClassReferencesList.push_back(pClassReference);
          }
        }

        if (pClassReference != NULL)
        {
          // we have a valid class reference
          ASSERT(pClassReference->m_bScopeClass == bScopeClass);
          ASSERT(pClassReference->m_pClassInfo != NULL);

          // add the object type
          pClassReference->m_templateObjectListRef.push_back(pObjectType);
        }
      } // for all object types

    } // if applicable template

  } // for all templates


  // now we have a list of references to work on
  // for each reference we have to create a permission holder and set it

  CTemplateClassReferencesList::iterator iClassRef;
  for (iClassRef = templateClassReferencesList.begin(); iClassRef != templateClassReferencesList.end(); ++iClassRef)
  {
    CTemplateClassReferences* pClassRef = (*iClassRef);
    ASSERT(pClassRef != NULL);

    TRACE(L"\nStart processing class references for class <%s>\n", pClassRef->m_pClassInfo->GetName());

    // for the given class reference, need to retain the class info
    CTemplateAccessPermissionsHolder* pPermissionHolder = 
                    new CTemplateAccessPermissionsHolder(pClassRef->m_pClassInfo, 
                                                         pClassRef->m_bScopeClass);

    HRESULT hr = pPermissionHolder->GetAccessPermissions(pADSIObj);
    if (SUCCEEDED(hr))
    {
      if (pPermissionHolder->SetupFromClassReferences(&(pClassRef->m_templateObjectListRef)))
      {
        // successfully set up, can add to the list
        m_permissionHolderArray.Add(pPermissionHolder);
        pPermissionHolder = NULL;
      }
    }

    if (pPermissionHolder != NULL)
    {
      TRACE(L"Invalid class references, throwing away permission holder\n");
      // invalid one, just throw away
      delete pPermissionHolder;
    }
    TRACE(L"End processing class references for class <%s>\n", pClassRef->m_pClassInfo->GetName());

  } // for each class reference
  
  
  TRACE(L"\nInitPermissionHoldersFromSelectedTemplates() has %d valid holders\n\n\n", 
    m_permissionHolderArray.GetCount());

  // we must have at least a valid and set template holder
  return m_permissionHolderArray.GetCount() > 0;
}


DWORD CTemplateAccessPermissionsHolderManager::UpdateAccessList(
                                                         CPrincipal* pPrincipal,
                                                         LPCWSTR lpszServerName,
                                                         LPCWSTR lpszPhysicalSchemaNamingContext,
                                                         PACL *ppAcl)
{
  // apply each permission holder in the list

  long nCount = (long) m_permissionHolderArray.GetCount();
  for (long k=0; k<nCount; k++)
  {
    CTemplateAccessPermissionsHolder* pCurrHolder = m_permissionHolderArray[k];
    DWORD dwErr = pCurrHolder->UpdateAccessList(pPrincipal,
                                                lpszServerName,
                                                lpszPhysicalSchemaNamingContext,
                                                ppAcl);
    if (dwErr != 0)
      return dwErr;
  }
  
  return 0;
}







///////////////// UI related operations //////////////////////////////////////////

BOOL CTemplateAccessPermissionsHolderManager::FillTemplatesListView(
                                             CCheckListViewHelper* pListViewHelper,
                                             LPCWSTR lpszClass)
{
	// clear check list
	pListViewHelper->DeleteAllItems();

  ULONG iListViewItem = 0;

  CTemplateList::iterator i;
  CTemplateList* pList = m_templateManager.GetTemplateList();
  for (i = pList->begin(); i != pList->end(); ++i)
  {
    CTemplate* p = (*i);
    ASSERT(p != NULL);
    if (p->AppliesToClass(lpszClass))
    {
      pListViewHelper->InsertItem(iListViewItem, 
                          p->GetDescription(), 
                          (LPARAM)p,
                          p->m_bSelected);
      iListViewItem++;
    }
  }

  return (iListViewItem > 0);
}



void CTemplateAccessPermissionsHolderManager::WriteSummary(CWString& szSummary, 
                                                           LPCWSTR lpszIdent, LPCWSTR lpszNewLine)
{
  WriteSummaryTitleLine(szSummary, IDS_DELEGWIZ_FINISH_TEMPLATE, lpszNewLine);

  CTemplateList::iterator i;
  CTemplateList* pList = m_templateManager.GetTemplateList();
  for (i = pList->begin(); i != pList->end(); ++i)
  {
    CTemplate* p = (*i);
    ASSERT(p != NULL);
    if (p->m_bSelected)
    {
      WriteSummaryLine(szSummary, p->GetDescription(), lpszIdent, lpszNewLine);
    }
  }
  szSummary += lpszNewLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\oudeleg\dbg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dbg.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"

/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_DSA_TRACE) || defined(_USE_DSA_ASSERT) || defined(_USE_DSA_TIMER)

UINT GetInfoFromIniFile(LPCWSTR lpszSection, LPCWSTR lpszKey, INT nDefault = 0)
{
  static LPCWSTR lpszFile = L"\\system32\\dsuiwiz.ini";

  WCHAR szFilePath[2*MAX_PATH];
	UINT nLen = ::GetSystemWindowsDirectory(szFilePath, 2*MAX_PATH);
	if (nLen == 0)
		return nDefault;

  wcscat(szFilePath, lpszFile);
  return ::GetPrivateProfileInt(lpszSection, lpszKey, nDefault, szFilePath);
}
#endif


#if defined(_USE_DSA_TRACE)

#ifdef DEBUG_DSA
DWORD g_dwTrace = 0x1;
#else
DWORD g_dwTrace = ::GetInfoFromIniFile(L"Debug", L"Trace");
#endif

void DSATrace(LPCTSTR lpszFormat, ...)
{ 
  if (g_dwTrace == 0)
    return;

	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	WCHAR szBuffer[512];

	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), lpszFormat, args);

	// was there an error? was the expanded string too long?
	ASSERT(nBuf >= 0);
  ::OutputDebugString(szBuffer);

	va_end(args);
}

#endif // defined(_USE_DSA_TRACE)

#if defined(_USE_DSA_ASSERT)

DWORD g_dwAssert = ::GetInfoFromIniFile(L"Debug", L"Assert");

BOOL DSAAssertFailedLine(LPCSTR lpszFileName, int nLine)
{ 
  if (g_dwAssert == 0)
    return FALSE;

  WCHAR szMessage[_MAX_PATH*2];

	// assume the debugger or auxiliary port
	wsprintf(szMessage, _T("Assertion Failed: File %hs, Line %d\n"),
		lpszFileName, nLine);
	OutputDebugString(szMessage);

	// display the assert
	int nCode = ::MessageBox(NULL, szMessage, _T("Assertion Failed!"),
		MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);

  OutputDebugString(L"after message box\n");
	if (nCode == IDIGNORE)
  {
		return FALSE;   // ignore
  }

	if (nCode == IDRETRY)
  {
		return TRUE;    // will cause DebugBreak
  }

	abort();     // should not return 
	return TRUE;

}
#endif // _USE_DSA_ASSERT

#if defined(_USE_DSA_TIMER)

#ifdef TIMER_DSA
DWORD g_dwTimer = 0x1;
#else
DWORD g_dwTimer = ::GetInfoFromIniFile(L"Debug", L"Timer");
#endif

DWORD StartTicks = ::GetTickCount();
DWORD LastTicks = 0;

void DSATimer(LPCTSTR lpszFormat, ...)
{
  if (g_dwTimer == 0)
    return;

	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	WCHAR szBuffer[512], szBuffer2[512];

        DWORD CurrentTicks = GetTickCount() - StartTicks;
        DWORD Interval = CurrentTicks - LastTicks;
        LastTicks = CurrentTicks;

        nBuf = swprintf(szBuffer2,
                           L"%d, (%d): %ws", CurrentTicks,
							Interval, lpszFormat);
	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), 
                           szBuffer2, 
                           args);

	// was there an error? was the expanded string too long?
	ASSERT(nBuf >= 0);
  ::OutputDebugString(szBuffer);

	va_end(args);
}
#endif // _USE_DSA_TIMER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\oudeleg\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------



/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_DSA_TRACE)
  #if defined(TRACE)
    #undef TRACE
    void  DSATrace(LPCWSTR, ...);
    #define TRACE DSATrace
  #endif // defined(TRACE)
#endif // defined(_USE_DSA_TRACE)


#if defined(_USE_DSA_ASSERT)
#undef ASSERT
#undef VERIFY
#undef THIS_FILE
#define THIS_FILE          __FILE__
BOOL DSAAssertFailedLine(LPCSTR lpszFileName, int nLine);
#define ASSERT(f) \
	do \
	{ \
	if (!(f) && DSAAssertFailedLine(THIS_FILE, __LINE__)) \
		::DebugBreak(); \
	} while (0) \

#define VERIFY(f)          ASSERT(f)

#endif // _USE_DSA_ASSERT

#if defined (_USE_DSA_TIMER)

void DSATimer(LPCWSTR, ...);
#define TIMER DSATimer

#else

#define TIMER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\oudeleg\deltempl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       deltempl.cpp
//
//--------------------------------------------------------------------------



#include <pch.h>

#include "resource.h"

#include "util.h"
#include "deltempl.h"

#include <_deltemp.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\oudeleg\dsuiwiz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsuiwiz.h
//
//--------------------------------------------------------------------------


#ifndef _DSUIWIZ_H
#define _DSUIWIZ_H

extern const GUID CLSID_OuDelegWizExt;


#endif // _DSUIWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\oudeleg\delegwiz.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       delegwiz.cpp
//
//--------------------------------------------------------------------------



#include "pch.h"
#include "wizbase.h"
#include "util.h"
#include <initguid.h>
#include <cmnquery.h> // ICommonQuery
#include <dsquery.h>
#include <dsclient.h>

#include "resource.h"
#include "dsuiwiz.h"
#include "delegWiz.h"

#define GET_OU_WIZARD() ((CDelegWiz*)GetWizard())





/////////////////////////////////////////////////////////////////////////////


void InitBigBoldFont(HWND hWnd, HFONT& hFont)
{
   ASSERT(::IsWindow(hWnd));

   NONCLIENTMETRICS ncm;
   memset(&ncm, 0, sizeof(ncm));
   ncm.cbSize = sizeof(ncm);
   ::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

   LOGFONT boldLogFont = ncm.lfMessageFont;
   boldLogFont.lfWeight = FW_BOLD;

   // load big font definition from resources
   WCHAR szFontName[LF_FACESIZE];
   if (0 == ::LoadString(_Module.GetResourceInstance(), IDS_BIG_BOLD_FONT_NAME,
                boldLogFont.lfFaceName, LF_FACESIZE))
   {
     // set to default of failed to load
      wcscpy(boldLogFont.lfFaceName, L"Verdana Bold"); // LF_FACESIZE == 32
   }
   
   WCHAR szFontSize[128];
   int nFontSize = 0;
   if (0 != ::LoadString(_Module.GetResourceInstance(), IDS_BIG_BOLD_FONT_SIZE,
                szFontSize, sizeof(szFontSize)/sizeof(WCHAR)))
   {
      nFontSize = _wtoi(szFontSize);
   }
   if (nFontSize == 0)
     nFontSize = 12; // default


   HDC hdc = ::GetDC(hWnd);
   //Bug fix  447884
   if( hdc )
   {

      boldLogFont.lfHeight =
         0 - (::GetDeviceCaps(hdc, LOGPIXELSY) * nFontSize / 72);

      hFont = ::CreateFontIndirect((const LOGFONT*)(&boldLogFont));

      ::ReleaseDC(hWnd, hdc);
   }
}


void SetLargeFont(HWND hWndDialog, int nControlID)
{
   ASSERT(::IsWindow(hWndDialog));
   ASSERT(nControlID);

   static HFONT boldLogFont = 0;
   if (boldLogFont == 0)
   {
      InitBigBoldFont(hWndDialog, boldLogFont);
   }

   HWND hWndControl = ::GetDlgItem(hWndDialog, nControlID);

   if (hWndControl)
   {
     ::SendMessage(hWndControl, WM_SETFONT, (WPARAM)boldLogFont, MAKELPARAM(TRUE, 0));    
   }
}

////////////////////////////////////////////////////////////////////////////
// CDelegWiz_StartPage


BOOL CDelegWiz_StartPage::OnSetActive()
{
	CDelegWiz* pWizard = GET_OU_WIZARD();
	pWizard->SetWizardButtonsFirst(TRUE);
	return TRUE;
}

LRESULT CDelegWiz_StartPage::OnInitDialog(UINT uMsg, WPARAM wParam, 
					LPARAM lParam, BOOL& bHandled)
{
  LRESULT lRes = 1;

  SetLargeFont(m_hWnd, IDC_STATIC_WELCOME);

  return lRes;
}


#ifdef _SKIP_NAME_PAGE

LRESULT CDelegWiz_StartPage::OnWizardNext()
{
  BOOL bSuccess = TRUE;
  HRESULT hr = S_OK;
  CDelegWiz* pWiz = GET_OU_WIZARD();

  // if we do not have an object, we will browse from the next page
  if (!pWiz->CanChangeName() && !m_bBindOK)
  {
    // make sure it exists and it is of the right type
    {
      // scope to restore cursor
      CWaitCursor wait;
      hr = pWiz->GetObjectInfo();
    }

    if (FAILED(hr))
	  {
      WCHAR szFmt[256];
      LoadStringHelper(IDS_DELEGWIZ_ERR_INVALID_OBJ_NAME, szFmt, 256);
      WCHAR szMsg[512];
      wsprintf(szMsg, szFmt, pWiz->GetCanonicalName());
		  pWiz->WizReportHRESULTError(szMsg, hr);
		  goto error;
	  }


    {
      // scope to restore cursor
      CWaitCursor wait;
      hr = pWiz->GetClassInfoFromSchema();
    }

	  if (FAILED(hr))
	  {
      WCHAR szFmt[256];
      LoadStringHelper(IDS_DELEGWIZ_ERR_INVALID_OBJ_INFO, szFmt, 256);
      WCHAR szMsg[512];
      wsprintf(szMsg, szFmt, pWiz->GetCanonicalName());
		  pWiz->WizReportHRESULTError(szMsg, hr);
      goto error;
	  }

    // all fine, we do not need to do it anymore
    m_bBindOK = TRUE;
  }


  OnWizardNextHelper();
	return 0; // all fine, go to next page

error:
  pWiz->SetWizardButtonsFirst(FALSE);
  return -1; // do not advance
}

#endif



////////////////////////////////////////////////////////////////////////////
// CDelegWiz_NamePage




LRESULT CDelegWiz_NamePage::OnInitDialog(UINT uMsg, WPARAM wParam, 
					LPARAM lParam, BOOL& bHandled)
{
  LRESULT lRes = 1;
  CDelegWiz* pWiz = GET_OU_WIZARD();
	m_hwndNameEdit = GetDlgItem(IDC_OBJ_NAME_EDIT);

	if (!pWiz->CanChangeName()) // called on a given object
	{
    // hide static text that gives instructions
    HWND hwndNameStatic = GetDlgItem(IDC_OBJ_NAME_STATIC);
    ::ShowWindow(hwndNameStatic, FALSE);

    // change text to the editbox 
    HWND hwndNameEditStatic = GetDlgItem(IDC_OBJ_NAME_EDIT_STATIC);
    CWString szLabel;
    szLabel.LoadFromResource(IDS_OBJ_NAME_EDIT_STATIC);
    ::SendMessage(hwndNameEditStatic, WM_SETTEXT,0 , (LPARAM)(LPCWSTR)szLabel);

    // remove the tabstop flag from the Edit Box
    LONG style = ::GetWindowLong(m_hwndNameEdit, GWL_STYLE);
    style &= ~WS_TABSTOP;
    ::SetWindowLong(m_hwndNameEdit, GWL_STYLE, style);
    // make the Edit Box Read Only
    ::SendMessage(m_hwndNameEdit, EM_SETREADONLY, TRUE, 0L);

    // disable and hide the Browse Button
    HWND hWndBrowseButton = GetDlgItem(IDC_BROWSE_BUTTON);
		::EnableWindow(hWndBrowseButton, FALSE);
    ::ShowWindow(hWndBrowseButton, FALSE);

    lRes = 0;
	}
	return lRes;
}



LRESULT CDelegWiz_NamePage::OnBrowse(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	// load resources to customize dialog
	TCHAR szCaption[256];
	LoadStringHelper(IDS_DELEGWIZ_BROWSE_CONTAINER_CAPTION, szCaption, ARRAYSIZE(szCaption));
	TCHAR szTitle[256];
	LoadStringHelper(IDS_DELEGWIZ_BROWSE_CONTAINER_TITLE, szTitle, ARRAYSIZE(szTitle));

	// set dialog struct
	TCHAR szPath[MAX_PATH+1];
	szPath[0] = NULL;
	DSBROWSEINFO dsbi;
	::ZeroMemory( &dsbi, sizeof(dsbi) );

	dsbi.cbStruct = sizeof(DSBROWSEINFO);
	dsbi.hwndOwner = m_hWnd;
	dsbi.pszCaption = szCaption;
	dsbi.pszTitle = szTitle;
	dsbi.pszRoot = NULL;		// ADS path to root (NULL == root of DS namespace)
	dsbi.pszPath = szPath;
	dsbi.cchPath = (sizeof(szPath) / sizeof(TCHAR));
	dsbi.dwFlags = DSBI_ENTIREDIRECTORY;

	// REVIEW_MARCOC: need to determine how to show/hide hidden folders
	dsbi.dwFlags |= DSBI_INCLUDEHIDDEN; //m_fBrowseHiddenFolders ? DSBI_INCLUDEHIDDEN : 0;
	
	dsbi.pfnCallback = NULL;
	dsbi.lParam = 0;

	// make the call to the dialog
	int iRet = ::DsBrowseForContainer( &dsbi );

	if ( IDOK == iRet ) 
	{ // returns -1, 0, IDOK or IDCANCEL
	  // get path from BROWSEINFO struct, put in text edit field
	  //TRACE(_T("returned from DS Browse successfully with:\n %s\n"),
		//	dsbi.pszPath);
		::SetWindowText(m_hwndNameEdit, szPath);
	} 

	return 1;
}



BOOL CDelegWiz_NamePage::OnSetActive()
{
	CDelegWiz* pWiz = GET_OU_WIZARD();

#ifdef _SKIP_NAME_PAGE
  if (!pWiz->CanChangeName())
  {
    // just cause the page to fail, so that we skip it
    return FALSE;
  }
#endif

  HRESULT hr = S_OK;
  if (pWiz->m_bFwd && !pWiz->CanChangeName()) // called on a given object
	{
    // need to bind now to get the needed data
    hr = pWiz->GetObjectInfo();
    if (SUCCEEDED(hr))
    {
      // set the name of the object in the Edit Box
      ::SendMessage(m_hwndNameEdit, WM_SETTEXT, 0, (LPARAM)pWiz->GetCanonicalName());
    }
    else
    {
      WCHAR szFmt[256];
      LoadStringHelper(IDS_DELEGWIZ_ERR_INVALID_OBJ_NAME, szFmt, 256);
      WCHAR szMsg[512];
      wsprintf(szMsg, szFmt, pWiz->GetCanonicalName());
		  pWiz->WizReportHRESULTError(szMsg, hr);
    }
  }

  pWiz->SetWizardButtonsMiddle(SUCCEEDED(hr));
	return TRUE;
}

LRESULT CDelegWiz_NamePage::OnWizardNext()
{
  BOOL bSuccess = TRUE;
  HRESULT hr = S_OK;
  CDelegWiz* pWiz = GET_OU_WIZARD();
  if (pWiz->CanChangeName())
  {
	  // retrieve name  from the edit control
	  int nEditTextLen = ::SendMessage(m_hwndNameEdit, WM_GETTEXTLENGTH,0,0) + 1;// count NULL
	  TCHAR* lpszName = (TCHAR*)alloca(sizeof(TCHAR)*(nEditTextLen));
	  ::SendMessage(m_hwndNameEdit, WM_GETTEXT, (WPARAM)nEditTextLen, (LPARAM)lpszName);

    // this will get the equivalent LDAP path
	  pWiz->SetName(lpszName);
  
    // make sure it exists and it is of the right type
    {
      // scope to restore cursor
      CWaitCursor wait;
      hr = pWiz->GetObjectInfo();
    }
	  if (FAILED(hr))
	  {
      WCHAR szFmt[256];
      LoadStringHelper(IDS_DELEGWIZ_ERR_INVALID_OBJ_NAME, szFmt, 256);
      WCHAR szMsg[512];
      wsprintf(szMsg, szFmt, pWiz->GetCanonicalName());
		  pWiz->WizReportHRESULTError(szMsg, hr);
		  goto error;
	  }
  } // if can change name

  {
    // scope to restore cursor
    CWaitCursor wait;
    hr = pWiz->GetClassInfoFromSchema();
  }

	if (FAILED(hr))
	{
    WCHAR szFmt[256];
    LoadStringHelper(IDS_DELEGWIZ_ERR_INVALID_OBJ_INFO, szFmt, 256);
    WCHAR szMsg[512];
    wsprintf(szMsg, szFmt, pWiz->GetCanonicalName());
		pWiz->WizReportHRESULTError(szMsg, hr);
    goto error;
	}

  OnWizardNextHelper();
	return 0; // all fine, go to next page

error:
  pWiz->SetWizardButtonsMiddle(FALSE);
  return -1; // do not advance
}

////////////////////////////////////////////////////////////////////////////
// CDelegWiz_DelegationTemplateSelectionPage

LRESULT CDelegWiz_DelegationTemplateSelectionPage::OnInitDialog(UINT uMsg, WPARAM wParam, 
					LPARAM lParam, BOOL& bHandled)
{
	m_delegationTemplatesListView.Initialize(IDC_DELEGATE_TEMPLATE_LIST, m_hWnd);
	
	// set the correct value for radiobuttons text
	m_hwndDelegateTemplateRadio = GetDlgItem(IDC_DELEGATE_TEMPLATE_RADIO);
	_ASSERTE(m_hwndDelegateTemplateRadio != NULL);
	m_hwndDelegateCustomRadio = GetDlgItem(IDC_DELEGATE_CUSTOM_RADIO);
	_ASSERTE(m_hwndDelegateCustomRadio != NULL);
	
	// set default setting
	::SendMessage(m_hwndDelegateTemplateRadio,  BM_SETCHECK, BST_CHECKED, 0);

	return 1;
}

LRESULT CDelegWiz_DelegationTemplateSelectionPage::OnDelegateTypeRadioChange(WORD wNotifyCode, WORD wID, 
													  HWND hWndCtl, BOOL& bHandled)
{
	SyncControlsHelper(IDC_DELEGATE_CUSTOM_RADIO == wID);
	return 1;
}

LRESULT CDelegWiz_DelegationTemplateSelectionPage::OnListViewItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pnmh;
	if (CCheckListViewHelper::CheckChanged(pNMListView))
	{
		int nSelCount = m_delegationTemplatesListView.GetCheckCount();
		GET_OU_WIZARD()->SetWizardButtonsMiddle(nSelCount > 0);
	}
	return 1;
}

BOOL CDelegWiz_DelegationTemplateSelectionPage::OnSetActive()
{
	CDelegWiz* pWizard = GET_OU_WIZARD();
	BOOL bRetVal = TRUE;
	BOOL bDelegateCustom = 
			(BST_CHECKED == ::SendMessage(m_hwndDelegateCustomRadio, BM_GETCHECK,0,0));

	if (pWizard->m_bFwd)
	{
    // need to fill in with data
    BOOL bHaveTemplates = 
        pWizard->m_templateAccessPermissionsHolderManager.FillTemplatesListView(
              &m_delegationTemplatesListView, pWizard->GetClass())> 0;
    
		if (!bDelegateCustom && !bHaveTemplates)
    {
      ::SendMessage(m_hwndDelegateCustomRadio, BM_SETCHECK,BST_CHECKED,0);
      ::SendMessage(m_hwndDelegateTemplateRadio, BM_SETCHECK,BST_UNCHECKED,0);
      bDelegateCustom = TRUE;
    }
		SyncControlsHelper(bDelegateCustom);
	}
	else
	{
		// data already in, just coming back from next page
		if (bDelegateCustom)
		{
			pWizard->SetWizardButtonsMiddle(TRUE);
		}
		else
		{
			int nSelCount = m_delegationTemplatesListView.GetCheckCount();
			pWizard->SetWizardButtonsMiddle(nSelCount > 0);
		}
	}
	return TRUE;
}

LRESULT CDelegWiz_DelegationTemplateSelectionPage::OnWizardNext()
{
  HRESULT hr = S_OK;
	int nSelCount = -1;
	int* nSelArray = NULL;
  BOOL bCanAdvance = FALSE;

  CDelegWiz* pWiz = GET_OU_WIZARD();

	// check if the delegation is on all objects
  
  BOOL bCustom = TRUE;
  UINT nNextPageID = 0;
	if (BST_CHECKED == ::SendMessage(m_hwndDelegateCustomRadio, BM_GETCHECK,0,0))
	{
    nSelCount = 0;
    nSelArray = NULL;
    bCanAdvance = TRUE;
	}
	else
	{
		ASSERT(BST_CHECKED == ::SendMessage(m_hwndDelegateTemplateRadio, BM_GETCHECK,0,0));
    bCustom = FALSE;

    nSelCount = 0;
    int nCount = m_delegationTemplatesListView.GetItemCount();
  	for (int k=0; k<nCount; k++)
  	{
      CTemplate* pTempl = (CTemplate*)m_delegationTemplatesListView.GetItemData(k);
      pTempl->m_bSelected = m_delegationTemplatesListView.IsItemChecked(k);
      if (pTempl->m_bSelected)
        nSelCount++;
    }

    bCanAdvance = (nSelCount > 0);
	}

	if (!bCanAdvance)
		goto error;

  // set branching info
  if (bCustom)
  {
    // just move to the next custom page
    nNextPageID = CDelegWiz_ObjectTypeSelectionPage::IDD;
    pWiz->m_objectTypeSelectionPage.m_nPrevPageID = IDD;
    pWiz->m_finishPage.m_nPrevPageID = CDelegWiz_DelegatedRightsPage::IDD;
    pWiz->m_finishPage.SetCustom();
  }
  else
  {
    // need to gather info for the selected templates
    {
      // scope to restore cursor
      CWaitCursor wait;

      if (!pWiz->InitPermissionHoldersFromSelectedTemplates())
      {
        // REVIEW_MARCOC: need to give a message to the user
        pWiz->WizMessageBox(IDS_DELEGWIZ_ERR_TEMPL_APPLY);
        goto error;
      }
    }

    // got info, can proceed
    nNextPageID = CDelegWiz_FinishPage::IDD;
    pWiz->m_finishPage.m_nPrevPageID = IDD;
    pWiz->m_finishPage.SetTemplate();
  }
  OnWizardNextHelper();

	return nNextPageID; // advance next

error:
  // do not advance, error
  pWiz->SetWizardButtonsMiddle(FALSE);
  return -1; 
}



void CDelegWiz_DelegationTemplateSelectionPage::SyncControlsHelper(BOOL bDelegateCustom)
{
  CDelegWiz* pWiz = GET_OU_WIZARD();
	// uncheck all items in the listview if delegating custom
	if (bDelegateCustom)
  {
		m_delegationTemplatesListView.SetCheckAll(FALSE);
    pWiz->m_templateAccessPermissionsHolderManager.DeselectAll(); // in the list templates
  }

	// disable listbox if "delegate custom"
	m_delegationTemplatesListView.EnableWindow(!bDelegateCustom);

	// enable "Wizard Next" 
  BOOL bEnableNext = bDelegateCustom ? 
                              TRUE : (m_delegationTemplatesListView.GetCheckCount() > 0);

  pWiz->SetWizardButtonsMiddle(bEnableNext);
}





////////////////////////////////////////////////////////////////////////////
// CDelegWiz_ObjectTypeSelectionPage


LRESULT CDelegWiz_ObjectTypeSelectionPage::OnInitDialog(UINT uMsg, WPARAM wParam, 
					LPARAM lParam, BOOL& bHandled)
{
	m_objectTypeListView.Initialize(IDC_OBJ_TYPE_LIST, m_hWnd);
	
	// set the correct value for radiobuttons text
	m_hwndDelegateAllRadio = GetDlgItem(IDC_DELEGATE_ALL_RADIO);
	ASSERT(m_hwndDelegateAllRadio != NULL);
	m_hwndDelegateFollowingRadio = GetDlgItem(IDC_DELEGATE_FOLLOWING_RADIO);
	ASSERT(m_hwndDelegateFollowingRadio != NULL);
    m_hwndDelegateCreateChild = GetDlgItem(IDC_DELEGATE_CREATE_CHILD);
    ASSERT(m_hwndDelegateCreateChild != NULL);
    m_hwndDelegateDeleteChild = GetDlgItem(IDC_DELEGATE_DELETE_CHILD);
    ASSERT(m_hwndDelegateDeleteChild != NULL);


	// set default setting
	::SendMessage(m_hwndDelegateAllRadio,  BM_SETCHECK, BST_CHECKED, 0);
    ::SendMessage(m_hwndDelegateCreateChild,  BM_SETCHECK, BST_UNCHECKED, 0);
    ::SendMessage(m_hwndDelegateCreateChild,  BM_SETCHECK, BST_UNCHECKED, 0);


	return 1;
}

LRESULT CDelegWiz_ObjectTypeSelectionPage::OnObjectRadioChange(WORD wNotifyCode, WORD wID, 
													  HWND hWndCtl, BOOL& bHandled)
{
	SyncControlsHelper(IDC_DELEGATE_ALL_RADIO == wID);
	return 1;
}

LRESULT CDelegWiz_ObjectTypeSelectionPage::OnCreateDelCheckBoxChanage(WORD wNotifyCode, WORD wID, 
													  HWND hWndCtl, BOOL& bHandled)
{
     CDelegWiz* pWiz = GET_OU_WIZARD();
     if( IDC_DELEGATE_CREATE_CHILD == wID )
     {
         if( ::SendMessage( hWndCtl, BM_GETCHECK,0,0 ) )
            pWiz->m_fCreateDelChild |= ACTRL_DS_CREATE_CHILD;
         else
            pWiz->m_fCreateDelChild &= ~ACTRL_DS_CREATE_CHILD;
     }

     if( IDC_DELEGATE_DELETE_CHILD == wID )
     {
         if( ::SendMessage( hWndCtl, BM_GETCHECK,0,0 ) )
            pWiz->m_fCreateDelChild |= ACTRL_DS_DELETE_CHILD;
         else
            pWiz->m_fCreateDelChild &= ~ACTRL_DS_DELETE_CHILD;
     }
     return 1;
}


LRESULT CDelegWiz_ObjectTypeSelectionPage::OnListViewItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pnmh;
	if (CCheckListViewHelper::CheckChanged(pNMListView))
	{
		int nSelCount = m_objectTypeListView.GetCheckCount();
		GET_OU_WIZARD()->SetWizardButtonsMiddle(nSelCount > 0);
	}
	return 1;
}


void CDelegWiz_ObjectTypeSelectionPage::SyncControlsHelper(BOOL bDelegateAll)
{
  CDelegWiz* pWiz = GET_OU_WIZARD();
	
	if (bDelegateAll)
  {
    // uncheck all items in the listview if delegating all
		m_objectTypeListView.SetCheckAll(FALSE); // in the listview
      pWiz->DeselectSchemaClassesSelectionCustom(); // in the list of schama classes
      //Uncheck delete/create check boxes
      ::SendMessage(m_hwndDelegateCreateChild,BM_SETCHECK,0,0);
      ::SendMessage(m_hwndDelegateDeleteChild,BM_SETCHECK,0,0);
      pWiz->m_fCreateDelChild = 0;

  }


	// enable "Wizard Next" of "delegate all"
	pWiz->SetWizardButtonsMiddle(bDelegateAll);
    // disable listbox if "delegate all"
 	m_objectTypeListView.EnableWindow(!bDelegateAll);
   ::EnableWindow( m_hwndDelegateCreateChild, !bDelegateAll);
   ::EnableWindow( m_hwndDelegateDeleteChild, !bDelegateAll);
}


void CDelegWiz_ObjectTypeSelectionPage::SetRadioControlText(HWND hwndCtrl, LPCWSTR lpszFmtText, LPCWSTR lpszText)
{
	// format new text
	int nTextLen = lstrlen(lpszText)+1; // count NULL
	int nFmtTextLen = lstrlen(lpszFmtText)+1; // count NULL
	WCHAR* lpszNewText = (WCHAR*)alloca(sizeof(WCHAR)*(nFmtTextLen+nTextLen));
	wsprintf(lpszNewText, lpszFmtText, lpszText);

	// set back
	::SendMessage(hwndCtrl, WM_SETTEXT, 0, (WPARAM)lpszNewText);
}



BOOL CDelegWiz_ObjectTypeSelectionPage::OnSetActive()
{
	CDelegWiz* pWizard = GET_OU_WIZARD();
	BOOL bRetVal = TRUE;
	BOOL bDelegateAll = 
			(BST_CHECKED == ::SendMessage(m_hwndDelegateAllRadio, BM_GETCHECK,0,0));

	if (pWizard->m_bFwd)
	{
		// need to fill in with data
    BOOL bFilter = TRUE;
    BOOL bHaveChildClasses = pWizard->FillCustomSchemaClassesListView(&m_objectTypeListView, bFilter) > 0;
    if (!bHaveChildClasses)
    {
      ::SendMessage(m_hwndDelegateAllRadio, BM_SETCHECK,BST_CHECKED,0);
      ::SendMessage(m_hwndDelegateFollowingRadio, BM_SETCHECK,BST_UNCHECKED,0);
      ::EnableWindow(m_hwndDelegateFollowingRadio, FALSE);
      
      bDelegateAll = TRUE;
    }
		SyncControlsHelper(bDelegateAll);
	}
	else
	{
		// data already in, just coming back from next page
		if (bDelegateAll)
		{
			pWizard->SetWizardButtonsMiddle(TRUE);
		}
		else
		{
			int nSelCount = m_objectTypeListView.GetCheckCount();
			pWizard->SetWizardButtonsMiddle(nSelCount > 0);
		}
	}
	return TRUE;
}

LRESULT CDelegWiz_ObjectTypeSelectionPage::OnWizardNext()
{
	HRESULT hr = S_OK;
	BOOL bCanAdvance = FALSE;
	CDelegWiz* pWiz = GET_OU_WIZARD();
	pWiz->m_bAuxClass = false;
	// check if the delegation is on all objects
	if (BST_CHECKED == ::SendMessage(m_hwndDelegateAllRadio, BM_GETCHECK,0,0))
	{
		bCanAdvance = TRUE;
	}
	else
	{
		ASSERT(BST_CHECKED == ::SendMessage(m_hwndDelegateFollowingRadio, BM_GETCHECK,0,0));
		int nSelCount = 0;
		int nCount = m_objectTypeListView.GetItemCount();
		CSchemaClassInfo* pAuxClassInfo = NULL;
  		for (int k=0; k<nCount; k++)
  		{
			CSchemaClassInfo* pChildClassInfo = (CSchemaClassInfo*)m_objectTypeListView.GetItemData(k);
			pChildClassInfo->m_bSelected = m_objectTypeListView.IsItemChecked(k);
			if (pChildClassInfo->m_bSelected)
			{
				nSelCount++;
				if(pChildClassInfo->IsAux())
				{
					pWiz->m_bAuxClass = true;		
					if(!pAuxClassInfo)
						pAuxClassInfo = pChildClassInfo;
				}
			}
		}
		bCanAdvance = (nSelCount > 0);
		if(nSelCount > 1 && pWiz->m_bAuxClass)
		{
			LPWSTR pszMessage = NULL;
			FormatStringID(&pszMessage, IDS_DELEGWIZ_ONE_AUX_CLASS,pAuxClassInfo->GetDisplayName());
			pWiz->WizMessageBox(pszMessage);
			LocalFree(pszMessage);

			bCanAdvance = FALSE;
		}
	}

	if (!bCanAdvance)
		goto error;

	{
		// scope to restore cursor
		CWaitCursor wait;
  		bCanAdvance = pWiz->SetSchemaClassesSelectionCustom();
	}
	if (!bCanAdvance)
		goto error;
	
  // for the selected child class(es), get the access permissions
  // to display in the next page

  {
    // scope to restore cursor
    CWaitCursor wait;
    bCanAdvance = pWiz->GetCustomAccessPermissions();
  }
  if (!bCanAdvance)
    goto error;

  OnWizardNextHelper();
	return 0; // advance next

error:
  // do not advance, error
  pWiz->SetWizardButtonsMiddle(FALSE);
  return -1; 
}




///////////////////////////////////////////////////////////////////////
// CPrincipalListViewHelper

BOOL CPrincipalListViewHelper::Initialize(UINT nID, HWND hParent)
{
	m_hWnd = GetDlgItem(hParent, nID);
	if (m_hWnd == NULL)
		return FALSE;

  if (!m_imageList.Create(m_hWnd))
    return FALSE;

  SetImageList();

	RECT r;
	::GetClientRect(m_hWnd, &r);
	int scroll = ::GetSystemMetrics(SM_CXVSCROLL);
	LV_COLUMN col;
	ZeroMemory(&col, sizeof(LV_COLUMN));
	col.mask = LVCF_WIDTH;
	col.cx = (r.right - r.left) - scroll;
  m_defaultColWidth = col.cx;
	return (0 == ListView_InsertColumn(m_hWnd,0,&col));
}

int CPrincipalListViewHelper::InsertItem(int iItem, CPrincipal* pPrincipal)
{
  // need to get the icon index
  int nIconIndex = m_imageList.GetIconIndex(pPrincipal->GetClass());
  if (nIconIndex == -1)
  {
    nIconIndex = m_imageList.AddIcon(pPrincipal->GetClass(), 
                                      pPrincipal->GetClassIcon());
    if (nIconIndex != -1)
      SetImageList();
  }

	LV_ITEM item;
	ZeroMemory(&item, sizeof(LV_ITEM));
	item.mask = LVIF_TEXT | LVIF_PARAM;
	item.pszText = (LPWSTR)(LPCWSTR)(pPrincipal->GetDisplayName());
	item.lParam = (LPARAM)pPrincipal;
	item.iItem = iItem;
  
  if (nIconIndex != -1)
  {
    item.iImage = nIconIndex;
    item.mask |= LVIF_IMAGE;
  }
  int iRes = ListView_InsertItem(m_hWnd, &item);
  return iRes;
}

BOOL CPrincipalListViewHelper::SelectItem(int iItem)
{
  LV_ITEM item;
  ZeroMemory(&item, sizeof(LV_ITEM));
  item.mask = LVIF_STATE;
  item.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
  item.state = LVIS_FOCUSED | LVIS_SELECTED;
  return ListView_SetItem(m_hWnd, &item);
}


CPrincipal* CPrincipalListViewHelper::GetItemData(int iItem)
{
	LV_ITEM item;
	ZeroMemory(&item, sizeof(LV_ITEM));
	item.mask = LVIF_PARAM;
	item.iItem = iItem;
	ListView_GetItem(m_hWnd, &item);
	return (CPrincipal*)item.lParam;
}

void CPrincipalListViewHelper::DeleteSelectedItems(CGrowableArr<CPrincipal>* pDeletedArr)
{
  int nItemIndex;
  while ( (nItemIndex = ListView_GetNextItem(m_hWnd, -1, LVNI_SELECTED)) != -1)
  {
    CPrincipal* pPrincipal = GetItemData(nItemIndex);
    if (ListView_DeleteItem(m_hWnd, nItemIndex))
    {
      pDeletedArr->Add(pPrincipal);
    }
	} // if
  // restore selection to first item
  if (GetItemCount() > 0)
    SelectItem(0);
}


void CPrincipalListViewHelper::UpdateWidth(int cxNew)
{
  int cx = GetWidth(); // get current col width from the control
  if (cxNew < m_defaultColWidth)
    cxNew = m_defaultColWidth;
  if (cxNew != cx)
    SetWidth(cx);
}



////////////////////////////////////////////////////////////////////////////
// CDelegWiz_PrincipalSelectionPage

LRESULT CDelegWiz_PrincipalSelectionPage::OnInitDialog(UINT uMsg, WPARAM wParam, 
					LPARAM lParam, BOOL& bHandled)
{
  // initialize the list of principals
	m_principalListView.Initialize(IDC_SELECTED_PRINCIPALS_LIST, m_hWnd);

  // cache handle for the remove button
	m_hwndRemoveButton = GetDlgItem(IDC_REMOVE_BUTTON);
	return 1;
}


LRESULT CDelegWiz_PrincipalSelectionPage::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	GET_OU_WIZARD()->AddPrincipals(&m_principalListView);
	SyncButtons();
   return 1;
}

LRESULT CDelegWiz_PrincipalSelectionPage::OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	GET_OU_WIZARD()->DeletePrincipals(&m_principalListView);
	SyncButtons();
	return 1;
}

LRESULT CDelegWiz_PrincipalSelectionPage::OnListViewSelChange(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
	SyncButtons();
	return 1;
}

BOOL CDelegWiz_PrincipalSelectionPage::OnSetActive()
{
	CDelegWiz* pWizard = GET_OU_WIZARD();
	SyncButtons();
	return TRUE;
}


LRESULT CDelegWiz_PrincipalSelectionPage::OnWizardNext()
{
  CDelegWiz* pWiz = GET_OU_WIZARD();

  // set branching info
  UINT nNextPageID = 0;
  if (pWiz->m_templateAccessPermissionsHolderManager.HasTemplates(pWiz->GetClass()))
  {
    nNextPageID = CDelegWiz_DelegationTemplateSelectionPage::IDD;
  }
  else
  {
    nNextPageID = CDelegWiz_ObjectTypeSelectionPage::IDD;
    pWiz->m_objectTypeSelectionPage.m_nPrevPageID = IDD;
  }

  OnWizardNextHelper();
  return nNextPageID;
}


void CDelegWiz_PrincipalSelectionPage::SyncButtons()
{
	BOOL bEnable = FALSE;
  int nItemCount = m_principalListView.GetItemCount();
	if (nItemCount > 0)
	{
		bEnable = m_principalListView.GetSelCount() > 0;
	}
	::EnableWindow(m_hwndRemoveButton, bEnable);

	CDelegWiz* pWiz = GET_OU_WIZARD();
	pWiz->SetWizardButtonsMiddle(nItemCount > 0);
}


////////////////////////////////////////////////////////////////////////////
// CDelegWiz_DelegatedRightsPage


LRESULT CDelegWiz_DelegatedRightsPage::OnInitDialog(UINT uMsg, WPARAM wParam, 
					LPARAM lParam, BOOL& bHandled)
{
	// initialize check list view
	m_delegatedRigthsListView.Initialize(IDC_DELEG_RIGHTS_LIST, m_hWnd);

	// get HWND's of controls
	m_hwndGeneralRigthsCheck = GetDlgItem(IDC_SHOW_GENERAL_CHECK);
	_ASSERTE(m_hwndGeneralRigthsCheck);
	m_hwndPropertyRightsCheck = GetDlgItem(IDC_SHOW_PROPERTY_CHECK);
	_ASSERTE(m_hwndPropertyRightsCheck);
	m_hwndSubobjectRightsCheck = GetDlgItem(IDC_SHOW_SUBOBJ_CHECK);
	_ASSERTE(m_hwndSubobjectRightsCheck);

	return 1;
}


BOOL CDelegWiz_DelegatedRightsPage::OnSetActive()
{
	CDelegWiz* pWizard = GET_OU_WIZARD();

	if (pWizard->m_bFwd)
	{
		if(pWizard->m_bAuxClass)
			SetFilterOptions(FILTER_EXP_GEN_DISABLED|FILTER_EXP_PROP);
		else
			SetFilterOptions(FILTER_EXP_GEN);

		ResetCheckList(); // will set wizard button
	}
	else
	{
		//coming back from next page, just set the wizard button
		pWizard->SetWizardButtonsMiddle(pWizard->HasPermissionSelectedCustom());
	}
	return TRUE;
}

LRESULT CDelegWiz_DelegatedRightsPage::OnWizardNext()
{
  CDelegWiz* pWiz = GET_OU_WIZARD();
	// must at least one check > 0
  if (pWiz->HasPermissionSelectedCustom())
  {
    OnWizardNextHelper();
    return 0;
  }

  pWiz->SetWizardButtonsMiddle(FALSE);
  return -1;
}


LRESULT CDelegWiz_DelegatedRightsPage::OnFilterChange(WORD wNotifyCode, WORD wID, 
											 HWND hWndCtl, BOOL& bHandled)
{
	ResetCheckList();
	return 1;
}



LRESULT CDelegWiz_DelegatedRightsPage::OnListViewItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
  if (m_bUIUpdateInProgress)
    return 1;

	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pnmh;
	if (CCheckListViewHelper::CheckChanged(pNMListView))
	{
		CRigthsListViewItem* pItem = (CRigthsListViewItem*)pNMListView->lParam; // item data
		CDelegWiz* pWizard = GET_OU_WIZARD();

    ULONG nCurrFilterOptions = GetFilterOptions();

    ULONG nNewFilterOptions = 0;
		pWizard->OnCustomAccessRightsCheckListClick(
                  pItem, CCheckListViewHelper::IsChecked(pNMListView),
                  &nNewFilterOptions);

    nNewFilterOptions |= nCurrFilterOptions;

    m_bUIUpdateInProgress = TRUE;
    // this call will cause a series of notifications:
    // we have to disable them to avoid reentrancy

    if (nNewFilterOptions == nCurrFilterOptions)
    {
      // no need to change filter selection, just update the checkboxes
      pWizard->UpdateAccessRightsListViewSelection(&m_delegatedRigthsListView, nNewFilterOptions);
    }
    else
    {
      // filter selection must be changed, 
      // so we have to update the check boxes and to refill the checklist
      SetFilterOptions(nNewFilterOptions);
      ResetCheckList();
    }
    m_bUIUpdateInProgress = FALSE;

		BOOL bSel = pWizard->HasPermissionSelectedCustom();
		pWizard->SetWizardButtonsMiddle(bSel);
	}

	return 1;
}


void CDelegWiz_DelegatedRightsPage::ResetCheckList()
{
  // get a new filtered list of rights in the list view
	CDelegWiz* pWizard = GET_OU_WIZARD();

  // this call will cause a series of notifications:
  // we have to disable them to avoid reentrancy
  m_bUIUpdateInProgress = TRUE;
	pWizard->FillCustomAccessRightsListView(&m_delegatedRigthsListView, GetFilterOptions());
	m_bUIUpdateInProgress = FALSE;
  
	pWizard->SetWizardButtonsMiddle(pWizard->HasPermissionSelectedCustom());
}

ULONG CDelegWiz_DelegatedRightsPage::GetFilterOptions()
{
  ULONG nFilterState = 0;
  
  // read the filtering options from checkboxes  
	if (BST_CHECKED == ::SendMessage(m_hwndGeneralRigthsCheck, BM_GETCHECK, 0, 0))
    nFilterState |= FILTER_EXP_GEN;

  if (BST_CHECKED == ::SendMessage(m_hwndPropertyRightsCheck, BM_GETCHECK, 0, 0))
    nFilterState |= FILTER_EXP_PROP;

	if (BST_CHECKED == ::SendMessage(m_hwndSubobjectRightsCheck, BM_GETCHECK, 0, 0))
    nFilterState |= FILTER_EXP_SUBOBJ;

  return nFilterState;
}



inline WPARAM _Checked(ULONG f) { return f ? BST_CHECKED : BST_UNCHECKED;}

void CDelegWiz_DelegatedRightsPage::SetFilterOptions(ULONG nFilterOptions)
{
  ::EnableWindow(m_hwndGeneralRigthsCheck,!(nFilterOptions & FILTER_EXP_GEN_DISABLED));
  ::SendMessage(m_hwndGeneralRigthsCheck, BM_SETCHECK, _Checked(nFilterOptions & FILTER_EXP_GEN), 0);
  ::SendMessage(m_hwndPropertyRightsCheck, BM_SETCHECK, _Checked(nFilterOptions & FILTER_EXP_PROP), 0);
  ::SendMessage(m_hwndSubobjectRightsCheck, BM_SETCHECK, _Checked(nFilterOptions & FILTER_EXP_SUBOBJ), 0);
}


////////////////////////////////////////////////////////////////////////////
// CDelegWiz_FinishPage

LRESULT CDelegWiz_FinishPage::OnInitDialog(UINT uMsg, WPARAM wParam, 
					LPARAM lParam, BOOL& bHandled)
{
  SetLargeFont(m_hWnd, IDC_STATIC_COMPLETION);
  return 1;
}

LRESULT CDelegWiz_FinishPage::OnSetFocusSummaryEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  ASSERT(hWndCtl == GetDlgItem(IDC_EDIT_SUMMARY));
  ::SendMessage(hWndCtl, EM_SETSEL, (WPARAM)-1, (LPARAM)0);

  if (m_bNeedSetFocus)
  {
    m_bNeedSetFocus = FALSE;
    TRACE(_T("Resetting Focus\n"));

    HWND hwndSheet = ::GetParent(m_hWnd);
    ASSERT(::IsWindow(hwndSheet));
    HWND hWndFinishCtrl =::GetDlgItem(hwndSheet, 0x3025);
    ASSERT(::IsWindow(hWndFinishCtrl));
    ::SetFocus(hWndFinishCtrl);
  }
  return 1;
}


BOOL CDelegWiz_FinishPage::OnSetActive()
{
	CDelegWiz* pWizard = GET_OU_WIZARD();
	pWizard->SetWizardButtonsLast(TRUE);

  CWString szSummary;
  if (m_bCustom)
    pWizard->WriteSummaryInfoCustom(szSummary, g_lpszSummaryIdent, g_lpszSummaryNewLine);
  else
    pWizard->WriteSummaryInfoTemplate(szSummary, g_lpszSummaryIdent, g_lpszSummaryNewLine);

  HWND hWndSummary = GetDlgItem(IDC_EDIT_SUMMARY);
  ::SetWindowText(hWndSummary, (LPCWSTR)szSummary);

  m_bNeedSetFocus = TRUE;

	return TRUE;
}


BOOL CDelegWiz_FinishPage::OnWizardFinish()
{
  CWaitCursor wait;
  BOOL bRes;
  CDelegWiz* pWizard = GET_OU_WIZARD();

  if (m_bCustom)
    bRes = GET_OU_WIZARD()->FinishCustom();
  else
	  bRes = GET_OU_WIZARD()->FinishTemplate();
	return bRes;
}



////////////////////////////////////////////////////////////////////////////
// CDelegWiz

const long CDelegWiz::nSchemaClassesSelAll = -2;
const long CDelegWiz::nSchemaClassesSelMultiple = -1;



// REVIEW_MARCOC: should probably nuke, not used
BOOL Is256ColorSupported()
{
    BOOL bRetval = FALSE;
    HDC hdc = GetDC(NULL);
    if( hdc )
    {
        if( GetDeviceCaps( hdc, BITSPIXEL ) >= 8 )
        {
            bRetval = TRUE;
        }
        ReleaseDC(NULL, hdc);
    }
    return bRetval;
}


CDelegWiz::CDelegWiz() : 
	CWizardBase(IDB_DELEG_WATER, IDB_DELEG_HD, IDS_DELEGWIZ_WIZ_TITLE),
	m_startPage(this),
	m_namePage(this),
  m_templateSelectionPage(this),
	m_userOrGroupSelectionPage(this),
	m_objectTypeSelectionPage(this),
	m_delegatedRightsPage(this),
	m_finishPage(this),
	m_bAuxClass(FALSE)
{
    m_lpszLDAPPath = NULL;

	m_nSchemaClassesSel = nSchemaClassesSelAll;
    m_fCreateDelChild = 0;


	// Add the property pages
	m_startPage.InitWiz97(TRUE);
	AddPage(m_startPage);

	m_namePage.InitWiz97(FALSE,
			IDS_DELEGWIZ_NAME_TITLE,
			IDS_DELEGWIZ_NAME_SUBTITLE);
	AddPage(m_namePage);


	m_userOrGroupSelectionPage.InitWiz97(FALSE,
			IDS_DELEGWIZ_PRINCIPALS_SEL_TITLE,
			IDS_DELEGWIZ_PRINCIPALS_SEL_SUBTITLE);
	AddPage(m_userOrGroupSelectionPage);
	
  // branching page
  m_templateSelectionPage.InitWiz97(FALSE,
 			IDS_DELEGWIZ_TEMPLATE_SEL_TITLE,
			IDS_DELEGWIZ_TEMPLATE_SEL_SUBTITLE);
  AddPage(m_templateSelectionPage);

	m_objectTypeSelectionPage.InitWiz97(FALSE,
		IDS_DELEGWIZ_OBJ_TYPE_SEL_TITLE,
		IDS_DELEGWIZ_OBJ_TYPE_SEL_SUBTITLE);
	AddPage(m_objectTypeSelectionPage);
	
	m_delegatedRightsPage.InitWiz97(FALSE,
		IDS_DELEGWIZ_DELEG_RIGHTS_TITLE,
		IDS_DELEGWIZ_DELEG_RIGHTS_SUBTITLE);
	AddPage(m_delegatedRightsPage);
	
	m_finishPage.InitWiz97(TRUE);
	AddPage(m_finishPage);


  m_templateAccessPermissionsHolderManager.LoadTemplates();
};


CDelegWiz::~CDelegWiz()
{
}


HRESULT CDelegWiz::AddPrincipalsFromBrowseResults(CPrincipalListViewHelper* pListViewHelper, 
                                                  PDS_SELECTION_LIST pDsSelectionList)
{
  TRACE(L"CDelegWiz::AddPrincipalsFromBrowseResults()\n");

	HRESULT hr = S_OK;
	if ( (pDsSelectionList == NULL) || (pDsSelectionList->cItems == 0))
  {
    TRACE(L"CDelegWiz::AddPrincipalsFromBrowseResults(), no items!!!\n");
		return E_INVALIDARG;
  }

  int nListInsertPosition = pListViewHelper->GetItemCount();
  for (int i = 0; i < pDsSelectionList->cItems; i++)
  {
    TRACE(L"For loop, pDsSelectionList->cItems = %d\n", pDsSelectionList->cItems);

		// add to list of principals
		CPrincipal* pPrincipal = new CPrincipal;
		if (pPrincipal != NULL)
		{
      HICON hClassIcon = m_adsiObject.GetClassIcon(pDsSelectionList->aDsSelection[i].pwzClass);
      HRESULT hrInit = pPrincipal->Initialize(&(pDsSelectionList->aDsSelection[i]), hClassIcon);
      if (FAILED(hrInit))
      {
        LPCWSTR lpszName = pDsSelectionList->aDsSelection[i].pwzName;
        WCHAR szFmt[256];
        LoadStringHelper(IDS_DELEGWIZ_ERR_INVALID_PRINCIPAL, szFmt, 256);
        int nNameLen = lstrlen(lpszName) + 1;

        WCHAR* lpszMsg = (WCHAR*)alloca(sizeof(WCHAR)*(nNameLen+256));
        wsprintf(lpszMsg, szFmt, lpszName);
        WizReportHRESULTError(lpszMsg, hrInit);
        delete pPrincipal;
        continue;
      }

      // add to list of principals (if not already there)
			if (m_principalList.AddIfNotPresent(pPrincipal))
      {
  			// add to listbox (assume not sorted)
        pListViewHelper->InsertItem(nListInsertPosition, pPrincipal);
        nListInsertPosition++;
      }

		} // if pPrincipal not NULL

  } // for

  // make sure there is a selection
  if ( (pListViewHelper->GetItemCount() > 0) &&
        (pListViewHelper->GetSelCount() == 0) )
  {
    // if we have items, but none is selected, make sure we set the selection
    // to the first one.
    pListViewHelper->SelectItem(0);
  }

	// update width
  //pListViewHelper->UpdateWidth(m_principalList.GetMaxListboxExtent());
	return hr;
}




/*
typedef struct _DSOP_FILTER_FLAGS
{
    DSOP_UPLEVEL_FILTER_FLAGS   Uplevel;
    ULONG                       flDownlevel;
} DSOP_FILTER_FLAGS;

  
typedef struct _DSOP_SCOPE_INIT_INFO
{
    ULONG               cbSize;
    ULONG               flType;
    ULONG               flScope;
    DSOP_FILTER_FLAGS   FilterFlags;
    PCWSTR              pwzDcName;      // OPTIONAL
    PCWSTR              pwzADsPath;     // OPTIONAL
    HRESULT             hr;
} DSOP_SCOPE_INIT_INFO, *PDSOP_SCOPE_INIT_INFO;

*/

DSOP_SCOPE_INIT_INFO g_aDSOPScopes[] =
{
#if 0
    {
        cbSize,
        flType,
        flScope,
        {
            { flBothModes, flMixedModeOnly, flNativeModeOnly },
            flDownlevel,
        },
        pwzDcName,
        pwzADsPath,
        hr // OUT
    },
#endif

    // The Global Catalog
    {
        sizeof(DSOP_SCOPE_INIT_INFO),
        DSOP_SCOPE_TYPE_GLOBAL_CATALOG,
        DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT|
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS|
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS,
        {
            { DSOP_FILTER_INCLUDE_ADVANCED_VIEW | DSOP_FILTER_USERS | 
              DSOP_FILTER_UNIVERSAL_GROUPS_SE | DSOP_FILTER_GLOBAL_GROUPS_SE | 
              DSOP_FILTER_COMPUTERS | DSOP_FILTER_WELL_KNOWN_PRINCIPALS, 0, 0 },
            0,
        },
        NULL,
        NULL,
        S_OK
    },

    // The domain to which the target computer is joined.
    {
        sizeof(DSOP_SCOPE_INIT_INFO),
        DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,
        DSOP_SCOPE_FLAG_STARTING_SCOPE | 
        DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT|
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS|
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS,
        {
          // joined domain is always NT5 for DS ACLs Editor
          { 0, 
          //mixed: users, well known SIDs, local groups, builtin groups, global groups, computers
          DSOP_FILTER_INCLUDE_ADVANCED_VIEW | DSOP_FILTER_USERS  | DSOP_FILTER_WELL_KNOWN_PRINCIPALS | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE | DSOP_FILTER_BUILTIN_GROUPS | DSOP_FILTER_GLOBAL_GROUPS_SE | DSOP_FILTER_COMPUTERS , 

          //native users, well known SIDs, local groups, builtin groups, global groups, universal groups, computers
          DSOP_FILTER_INCLUDE_ADVANCED_VIEW | DSOP_FILTER_USERS  | DSOP_FILTER_WELL_KNOWN_PRINCIPALS | 
          DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE | DSOP_FILTER_BUILTIN_GROUPS |
          DSOP_FILTER_GLOBAL_GROUPS_SE | DSOP_FILTER_UNIVERSAL_GROUPS_SE | DSOP_FILTER_COMPUTERS
          },
        0, // zero for downlevel joined domain, should be DS-aware
        },
        NULL,
        NULL,
        S_OK
    },

    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    {
        sizeof(DSOP_SCOPE_INIT_INFO),
        DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,
	DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT|
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS|
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS,

        {
            { DSOP_FILTER_INCLUDE_ADVANCED_VIEW | DSOP_FILTER_USERS | DSOP_FILTER_UNIVERSAL_GROUPS_SE | DSOP_FILTER_GLOBAL_GROUPS_SE | DSOP_FILTER_COMPUTERS, 0, 0},
            0,
        },
        NULL,
        NULL,
        S_OK
    },

    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    {
        sizeof(DSOP_SCOPE_INIT_INFO),
        DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN,
        DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT|        
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS|
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS,
        {
            { DSOP_FILTER_INCLUDE_ADVANCED_VIEW | DSOP_FILTER_USERS | DSOP_FILTER_UNIVERSAL_GROUPS_SE | 				DSOP_FILTER_GLOBAL_GROUPS_SE | DSOP_FILTER_COMPUTERS, 0, 0},
            DSOP_DOWNLEVEL_FILTER_USERS | DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS,
        },
        NULL,
        NULL,
        S_OK
    },
};



HRESULT CDelegWiz::AddPrincipals(CPrincipalListViewHelper* pListViewHelper)
{
  TRACE(L"CDelegWiz::AddPrincipals()\n");

  // create object picker COM object
  CComPtr<IDsObjectPicker> spDsObjectPicker;
  HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker, (void**)&spDsObjectPicker);
  if (FAILED(hr))
  {
    TRACE(L"CoCreateInstance(CLSID_DsObjectPicker) failed, hr = 0x%x\n");
    return hr;
  }

    // set init info
  DSOP_INIT_INFO InitInfo;
  ZeroMemory(&InitInfo, sizeof(InitInfo));

  InitInfo.cbSize = sizeof(DSOP_INIT_INFO);
  InitInfo.pwzTargetComputer = m_adsiObject.GetServerName();
  InitInfo.cDsScopeInfos = sizeof(g_aDSOPScopes)/sizeof(DSOP_SCOPE_INIT_INFO);
  InitInfo.aDsScopeInfos = g_aDSOPScopes;
  InitInfo.flOptions = DSOP_FLAG_MULTISELECT;
  InitInfo.cAttributesToFetch = 1;
  LPCWSTR lpszObjectSID = L"objectSid";
  InitInfo.apwzAttributeNames = const_cast<LPCTSTR *>(&lpszObjectSID);


  TRACE(L"InitInfo.cbSize               = %d\n",    InitInfo.cbSize);
  TRACE(L"InitInfo.pwzTargetComputer    = %s\n",    InitInfo.pwzTargetComputer);
  TRACE(L"InitInfo.cDsScopeInfos        = %d\n",    InitInfo.cDsScopeInfos);
  TRACE(L"InitInfo.aDsScopeInfos        = 0x%x\n",  InitInfo.aDsScopeInfos);
  TRACE(L"InitInfo.flOptions            = 0x%x\n",  InitInfo.flOptions);
  TRACE(L"InitInfo.cAttributesToFetch   = %d\n",    InitInfo.cAttributesToFetch);
  TRACE(L"InitInfo.apwzAttributeNames[0]= %s\n", InitInfo.apwzAttributeNames[0]);

  // initialize object picker
  hr = spDsObjectPicker->Initialize(&InitInfo);
  if (FAILED(hr))
  {
    TRACE(L"spDsObjectPicker->Initialize(...) failed, hr = 0x%x\n");
    return hr;
  }

  // invoke the dialog
  CComPtr<IDataObject> spdoSelections;

  hr = spDsObjectPicker->InvokeDialog(m_hWnd, &spdoSelections);
  if (hr == S_FALSE || !spdoSelections)
  {
      return S_FALSE;
  }

  // retrieve data from data object
  FORMATETC fmte = {(CLIPFORMAT)_Module.GetCfDsopSelectionList(), NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = {TYMED_NULL, NULL, NULL};
  PDS_SELECTION_LIST pDsSelList = NULL;

  hr = spdoSelections->GetData(&fmte, &medium);
  if (FAILED(hr))
  {
    TRACE(L"spdoSelections->GetData(...) failed, hr = 0x%x\n");
    return hr;
  }

  pDsSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);


  hr = AddPrincipalsFromBrowseResults(pListViewHelper, pDsSelList);

  GlobalUnlock(medium.hGlobal);
  ReleaseStgMedium(&medium);

  return hr;
}


BOOL CDelegWiz::DeletePrincipals(CPrincipalListViewHelper* pListViewHelper)
{
  CGrowableArr<CPrincipal> deletedArr(FALSE); // do not own memory
  
  // remove from listview
  pListViewHelper->DeleteSelectedItems(&deletedArr);
  // remove from list of items
  int nDeletedCount = deletedArr.GetCount();
  for (int k=0; k<nDeletedCount; k++)
  {
    m_principalList.Remove(deletedArr[k]);
  }
  //pListViewHelper->UpdateWidth(m_principalList.GetMaxListboxExtent());
	return TRUE;
}


int CDelegWiz::FillCustomSchemaClassesListView(CCheckListViewHelper* pListViewHelper, BOOL bFilter)
{
	// clear old entries
	pListViewHelper->DeleteAllItems();

  int nCount = m_schemaClassInfoArray.GetCount();
  if (nCount == 0)
    return 0; // no insertions, nothing else to do

  // figure out the max len of items to get a big enough buffer
  int nMaxLen = 0;
  int nCurrLen = 0;
  for (long index = 0; index < nCount; index++)
	{
    nCurrLen = lstrlen(m_schemaClassInfoArray[index]->GetDisplayName());
    if (nCurrLen > nMaxLen)
      nMaxLen = nCurrLen;
  }

  CWString szFormat;
  szFormat.LoadFromResource(IDS_DELEGWIZ_CHILD_CLASS_FMT);

  WCHAR* pwszNewText = (WCHAR*)alloca(sizeof(WCHAR)*(szFormat.size()+nMaxLen+1));

	// add formatted entries, assume listbox not sorted
  long iListBoxItem = 0;
	for (index = 0; index < nCount; index++)
	{
    CSchemaClassInfo* pChildClassInfo = m_schemaClassInfoArray[index];
    pChildClassInfo->m_bSelected = FALSE;
    if (bFilter && pChildClassInfo->IsFiltered())
      continue;

		wsprintf(pwszNewText, (LPCWSTR)szFormat, pChildClassInfo->GetDisplayName());
		pListViewHelper->InsertItem(iListBoxItem, pwszNewText, (LPARAM)pChildClassInfo, FALSE);
    iListBoxItem++;
	}

	return iListBoxItem; // return the # of items inserted
}


BOOL CDelegWiz::SetSchemaClassesSelectionCustom()
{
  int nSelCount = 0;
  int nCount = m_schemaClassInfoArray.GetCount();
  CComPtr<IADsClass> spSchemaObjectClass;	
  
    m_bChildClass = FALSE;

    // get the selection count
    int nSingleSel = -1;
    for (int k=0; k < nCount; k++)
    {
        if (m_schemaClassInfoArray[k]->m_bSelected)
        {
            if( m_schemaClassInfoArray[k]->m_dwChildClass = CHILD_CLASS_NOT_CALCULATED )
            {
                if (m_schemaClassInfoArray[k]->GetName() != NULL)
                {
                    int nServerNameLen = lstrlen(m_adsiObject.GetServerName());
	                int nClassNameLen = lstrlen(m_schemaClassInfoArray[k]->GetName());
	                int nFormatStringLen = lstrlen(g_wzLDAPAbstractSchemaFormat);
	                VARIANT var = {0};

	                // build the LDAP path for the schema class
	                WCHAR* pwszSchemaObjectPath = 
		            (WCHAR*)alloca(sizeof(WCHAR)*(nServerNameLen+nClassNameLen+nFormatStringLen+1));
	                wsprintf(pwszSchemaObjectPath, g_wzLDAPAbstractSchemaFormat, m_adsiObject.GetServerName(), m_schemaClassInfoArray[k]->GetName());

	                // get the schema class ADSI object
	                HRESULT hr = ::ADsOpenObjectHelper(pwszSchemaObjectPath, 
					                          IID_IADsClass, (void**)&spSchemaObjectClass);
	                if (FAILED(hr))
		                return hr;

                    
                    spSchemaObjectClass->get_Containment(&var);

                    if (V_VT(&var) == (VT_ARRAY | VT_VARIANT))
                    {
                        LPSAFEARRAY psa = V_ARRAY(&var);

                        ASSERT(psa && psa->cDims == 1);

                        if (psa->rgsabound[0].cElements > 0)
                        {
                            m_schemaClassInfoArray[k]->m_dwChildClass = CHILD_CLASS_EXIST;
                        }
                        else
                            m_schemaClassInfoArray[k]->m_dwChildClass = CHILD_CLASS_NOT_EXIST;
                    }
                    else if (V_VT(&var) == VT_BSTR) // single entry
                    {
                        m_schemaClassInfoArray[k]->m_dwChildClass = CHILD_CLASS_EXIST;
                    }
                    else
                        m_schemaClassInfoArray[k]->m_dwChildClass = CHILD_CLASS_NOT_EXIST;

                    VariantClear(&var);

                }
            }

            if( m_schemaClassInfoArray[k]->m_dwChildClass != CHILD_CLASS_NOT_EXIST )
                m_bChildClass = TRUE;

            if (nSingleSel == -1)
                nSingleSel = k;
            nSelCount++;
        }
    }

  
  
  if (nSelCount == 0)
  {
    m_nSchemaClassesSel = nSchemaClassesSelAll;
    m_bChildClass = TRUE;
    return TRUE; // delegate control to all types
  }

  // keep track if it is a single selection
  if (nSelCount == 1)
  {
    ASSERT(nSingleSel != -1);
		m_nSchemaClassesSel = nSingleSel;
    return TRUE;
  }
	
	// multiple selection
  m_nSchemaClassesSel = nSchemaClassesSelMultiple;

  return TRUE;
}


void CDelegWiz::DeselectSchemaClassesSelectionCustom()
{
  int nCount = m_schemaClassInfoArray.GetCount();
	
  for (int k=0; k < nCount; k++)
  {
		m_schemaClassInfoArray[k]->m_bSelected = FALSE;
  }
}


BOOL CDelegWiz::GetCustomAccessPermissions()
{
	// remove all the old entries
	m_permissionHolder.Clear();

	// retrieve the string for the child class object type (single selection)
  // for multiple selection, it will be NULL

  CSchemaClassInfo* pClassInfo = NULL;

  switch (m_nSchemaClassesSel)
  {
  case nSchemaClassesSelMultiple:
    {
      // for multiple selection, it will be NULL
      pClassInfo = NULL;
    }
    break;
  case nSchemaClassesSelAll:
    {
      // just get the class name of the object we want to delegate rights on
      // need to find matching class in the schema info array
     	for (int k=0; k < m_schemaClassInfoArray.GetCount(); k++)
			{
				if (_wcsicmp(m_schemaClassInfoArray[k]->GetName(), m_adsiObject.GetClass()) == 0)
				{
          pClassInfo = m_schemaClassInfoArray[k];
          break;
				}
			} // for k
      ASSERT(pClassInfo != NULL);
    }
    break;
  default:
    {
      // single selection
      ASSERT( (m_nSchemaClassesSel >= 0) && 
			    (m_nSchemaClassesSel < m_schemaClassInfoArray.GetCount()) );
      pClassInfo = m_schemaClassInfoArray[m_nSchemaClassesSel];
    }
  } // switch

  // get the permissions from the DS
	LPCWSTR lpszClassName = NULL;
  const GUID* pSchemaIDGUID = NULL;
  if (pClassInfo != NULL)
  {
	  lpszClassName = pClassInfo->GetName();
    pSchemaIDGUID = pClassInfo->GetSchemaGUID();
  }


  HRESULT hr = m_permissionHolder.ReadDataFromDS(&m_adsiObject, 
												 m_adsiObject.GetNamingContext(),
                                                 lpszClassName, 
												 pSchemaIDGUID, 
												 m_bChildClass,
												 HideListObjectAccess());
                                           
  if (FAILED(hr))
  {
    WizReportHRESULTError(IDS_DELEGWIZ_ERR_PERMISSIONS, hr);
    return FALSE;
  }
  return TRUE;
}




void CDelegWiz::FillCustomAccessRightsListView(CCheckListViewHelper* pListViewHelper, 
											 ULONG nFilterState)
{
	// clear check list
	pListViewHelper->DeleteAllItems();
	
  m_permissionHolder.FillAccessRightsListView(pListViewHelper, nFilterState); 
}


void CDelegWiz::UpdateAccessRightsListViewSelection(
                       CCheckListViewHelper* pListViewHelper,
                       ULONG nFilterState)
{
  m_permissionHolder.UpdateAccessRightsListViewSelection(
                        pListViewHelper, nFilterState);
}


BOOL CDelegWiz::HasPermissionSelectedCustom()
{ 
  return m_permissionHolder.HasPermissionSelected();
}


void CDelegWiz::OnCustomAccessRightsCheckListClick(
                        CRigthsListViewItem* pItem,
												BOOL bSelected,
                        ULONG* pnNewFilterState)
{

  m_permissionHolder.Select(pItem, bSelected, pnNewFilterState);
}


void CDelegWiz::WriteSummaryInfoCustom(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine)
{
  // write object name and principals
  WriteSummaryInfoHelper(szSummary, lpszIdent, lpszNewLine);

  // write the list of rights
  m_permissionHolder.WriteSummary(szSummary, lpszIdent, lpszNewLine);

  // write the list of child classes (if applicable)
  if (m_nSchemaClassesSel != nSchemaClassesSelAll)
  {
    WriteSummaryTitleLine(szSummary, IDS_DELEGWIZ_FINISH_OBJECT, lpszNewLine);

	  for (int k=0; k < m_schemaClassInfoArray.GetCount(); k++)
	  {
		  if (m_schemaClassInfoArray[k]->m_bSelected)
		  {
        WriteSummaryLine(szSummary, m_schemaClassInfoArray[k]->GetDisplayName(), lpszIdent, lpszNewLine);
		  }
	  }
    szSummary += lpszNewLine;

  } // if
}



BOOL CDelegWiz::InitPermissionHoldersFromSelectedTemplates()
{
  if (!m_templateAccessPermissionsHolderManager.InitPermissionHoldersFromSelectedTemplates(
        &m_schemaClassInfoArray, &m_adsiObject))
  {
    // error: no valid and applicable data has been retrieved from the selected
    // templates
    return FALSE;
  }
  return TRUE;
}



void CDelegWiz::WriteSummaryInfoTemplate(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine)
{
  // write object name and principals
  WriteSummaryInfoHelper(szSummary,lpszIdent, lpszNewLine);

  // write the list of templates
  m_templateAccessPermissionsHolderManager.WriteSummary(szSummary, lpszIdent, lpszNewLine);
}




void CDelegWiz::WriteSummaryInfoHelper(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine)
{
  // set the canonical name
  WriteSummaryTitleLine(szSummary, IDS_DELEGWIZ_FINISH_FOLDER, lpszNewLine);

  WriteSummaryLine(szSummary, GetCanonicalName(), lpszIdent, lpszNewLine);
  szSummary += lpszNewLine;

  // write the list of principals
  m_principalList.WriteSummaryInfo(szSummary, lpszIdent, lpszNewLine);
}




/*
typedef struct _ACTRL_ACCESS_ENTRYW
{
    TRUSTEE_W       Trustee;
    ULONG           fAccessFlags;
    ACCESS_RIGHTS   Access;
    ACCESS_RIGHTS   ProvSpecificAccess;
    INHERIT_FLAGS   Inheritance;
    LPWSTR          lpInheritProperty;
} ACTRL_ACCESS_ENTRYW, *PACTRL_ACCESS_ENTRYW;
*/

DWORD CDelegWiz::UpdateAccessList(CPrincipal* pPrincipal,
									CSchemaClassInfo* pClassInfo,
									PACL *ppAcl)
{

  return m_permissionHolder.UpdateAccessList( 
                                            pPrincipal, pClassInfo, 
                                            m_adsiObject.GetServerName(),
                                            m_adsiObject.GetPhysicalSchemaNamingContext(),
                                            ppAcl);
}








DWORD CDelegWiz::BuildNewAccessListCustom(PACL *ppNewAcl)
{
	DWORD dwErr = 0;

  TRACE(L"BuildNewAccessListCustom()\n");

	// loop thru all the principals and classes
  CPrincipalList::iterator i;
  for (i = m_principalList.begin(); i != m_principalList.end(); ++i)
  {
    CPrincipal* pCurrPrincipal = *i;
		if (m_nSchemaClassesSel == nSchemaClassesSelAll)
    {
      // delegate on all objects
			dwErr = UpdateAccessList(
				      pCurrPrincipal, 
				      NULL, // all classes
				      ppNewAcl);
      if (dwErr != ERROR_SUCCESS)
		    return dwErr;
    }
		else if (m_nSchemaClassesSel == nSchemaClassesSelMultiple)
    {
      // delegate on multiple objects
			// multiple selection, loop thru each class to
			// add rights for each
			for (int k=0; k < m_schemaClassInfoArray.GetCount(); k++)
			{
				if (m_schemaClassInfoArray[k]->m_bSelected)
				{
					dwErr = UpdateAccessList(
						      pCurrPrincipal, 
						      m_schemaClassInfoArray[k],
						      ppNewAcl);
               if (dwErr != ERROR_SUCCESS)
        		      return dwErr;
               if( m_fCreateDelChild != 0 )
               {
                   dwErr = ::AddObjectRightInAcl( pCurrPrincipal->GetSid(),
                                                m_fCreateDelChild, 
                                                m_schemaClassInfoArray[k]->GetSchemaGUID(), 
                                                NULL,
                                                ppNewAcl);

                  if (dwErr != ERROR_SUCCESS)
        	     	      return dwErr;  
                }
  
				}
			} // for k
    }
    else
		{
			// single selection on child classes
			dwErr = UpdateAccessList(
				        pCurrPrincipal, 
				        m_schemaClassInfoArray[m_nSchemaClassesSel],
				        ppNewAcl);
         if (dwErr != ERROR_SUCCESS)
		      return dwErr;

         if( m_fCreateDelChild != 0 )
         {
            dwErr = ::AddObjectRightInAcl( pCurrPrincipal->GetSid(),
                                           m_fCreateDelChild, 
                                           m_schemaClassInfoArray[m_nSchemaClassesSel]->GetSchemaGUID(), 
                                           NULL,
                                           ppNewAcl);

            if (dwErr != ERROR_SUCCESS)
        	      return dwErr;  
         }		
      }
	} // for pCurrPrincipal

	return dwErr;
}

DWORD CDelegWiz::BuildNewAccessListTemplate(PACL *ppNewAcl)
{
	DWORD dwErr = 0;
  
  TRACE(L"BuildNewAccessListTemplate()\n");


	// loop thru all the principals and classes
  CPrincipalList::iterator i;
  for (i = m_principalList.begin(); i != m_principalList.end(); ++i)
  {
    CPrincipal* pCurrPrincipal = *i;
    dwErr = m_templateAccessPermissionsHolderManager.UpdateAccessList(
                                            pCurrPrincipal, 
                                            m_adsiObject.GetServerName(),
                                            m_adsiObject.GetPhysicalSchemaNamingContext(),
                                            ppNewAcl);

    if (dwErr != 0)
      break;
	} // for pCurrPrincipal

	return dwErr;
}



BOOL CDelegWiz::FinishHelper(BOOL bCustom)
{
	BOOL bRetVal = FALSE;
	DWORD dwErr = 0;


  PACL pDacl = NULL;
  PACL pOldAcl = NULL;
  PSECURITY_DESCRIPTOR pSD = NULL;

  LPCWSTR lpszObjectLdapPath = m_adsiObject.GetLdapPath();

  // get the security info
  TRACE(L"calling GetNamedSecurityInfo(%s, ...)\n", lpszObjectLdapPath);

  dwErr = ::GetNamedSecurityInfo(IN const_cast<LPWSTR>(lpszObjectLdapPath),
                          IN   SE_DS_OBJECT_ALL,
                          IN   DACL_SECURITY_INFORMATION,
                          OUT NULL,
                          OUT NULL,
                          OUT &pDacl,
                          OUT NULL,
                          OUT &pSD);

    TRACE(L"GetNamedSecurityInfo() returned dwErr = 0x%x\n", dwErr);

	if (dwErr != ERROR_SUCCESS)
	{
        TRACE(L"failed on GetNamedSecurityInfo(): dwErr = 0x%x\n", dwErr);
        WCHAR szMsg[512];
        LoadStringHelper(IDS_DELEGWIZ_ERR_GET_SEC_INFO, szMsg, 512);
		    WizReportWin32Error(szMsg, dwErr);
		    goto exit;
	}


  //pOldAcl is passed to functions which free it. pDacl cannot be
  //passed as pSD should be freed , not pDacl. Instead of changing code
  //to pass pSD, i am changing it to make a copy of pDacl which can 
  //be correctly freed.
  if(pDacl)
  {
    pOldAcl = (PACL)LocalAlloc(LPTR, pDacl->AclSize);
    if(!pOldAcl)
        return FALSE;
    memcpy(pOldAcl, pDacl,pDacl->AclSize);
  }
  LocalFree(pSD);
  pSD = NULL;
  pDacl = NULL;

  

	// build the new Access List 
  if (bCustom)
  {
	  dwErr = BuildNewAccessListCustom(&pOldAcl); // in/out parameter
  }
  else
  {
    dwErr = BuildNewAccessListTemplate(&pOldAcl); // in/out parameter
  }

	if (dwErr != ERROR_SUCCESS)
	{
    TRACE(_T("failed on BuildNewAccessListXXX()\n"));
    WCHAR szMsg[512];
    LoadStringHelper(IDS_DELEGWIZ_ERR_EDIT_SEC_INFO, szMsg, 512);
		WizReportWin32Error(szMsg, dwErr);
		goto exit;
	}


	// commit changes
  TRACE(L"calling SetNamedSecurityInfo(%s, ...)\n", lpszObjectLdapPath);

  dwErr = ::SetNamedSecurityInfo(IN const_cast<LPWSTR>(lpszObjectLdapPath),
                        IN   SE_DS_OBJECT_ALL,
                        IN   DACL_SECURITY_INFORMATION,
                        IN   NULL,
                        IN   NULL,
                        IN   pOldAcl,
                        IN   NULL);

  TRACE(L"SetNamedSecurityInfo() returned dwErr = 0x%x\n", dwErr);

	if (dwErr != ERROR_SUCCESS)
	{
		TRACE(L"failed on SetNamedSecurityInfo(): dwErr = 0x%x\n", dwErr);
    WCHAR szMsg[512];
	if(dwErr == ERROR_ACCESS_DENIED)
		LoadStringHelper(IDS_DELEGWIZ_ERR_ACCESS_DENIED, szMsg, 512);
	else
		LoadStringHelper(IDS_DELEGWIZ_ERR_SET_SEC_INFO, szMsg, 512);
	
	WizReportWin32Error(szMsg, dwErr);
    goto exit;
	}
	bRetVal = TRUE;


exit:
  // cleanup memory
	if (pOldAcl != NULL)
		::LocalFree(pOldAcl);

	return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\oudeleg\dsuiwiz.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsuiwiz.cpp
//
//--------------------------------------------------------------------------



#include "pch.h"
#include "util.h"
#include "resource.h"
//#include "initguid.h"
#include "dsuiwiz.h"

#include "ShellExt.h"

// {6BA3F852-23C6-11D1-B91F-00A0C9A06D2D}
static const CLSID CLSID_OuDelegWizExt = 
{ 0x6BA3F852, 0x23C6, 0x11D1, {0xB9, 0x1F, 0x00, 0xA0, 0xC9, 0xA0, 0x6D, 0x2D } };

COuDelegComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_OuDelegWizExt, CShellExt)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point


extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
		if (!_Module.InitClipboardFormats())
			return FALSE;
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\oudeleg\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    makefile.inc.

!ENDIF

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\oudeleg\delegwiz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       delegwiz.h
//
//--------------------------------------------------------------------------


#ifndef _DELEGWIZ_H
#define _DELEGWIZ_H


#include "wizbase.h"

#include "deltempl.h"


////////////////////////////////////////////////////////////////////////////
// FWD DECLARATIONS


// REVIEW_MARCOC: nuke when sure

#define _SKIP_NAME_PAGE


////////////////////////////////////////////////////////////////////////////
// CDelegWiz_StartPage

class CDelegWiz_StartPage : public CWizPageBase<CDelegWiz_StartPage>
{
public:
	CDelegWiz_StartPage(CWizardBase* pWiz) : CWizPageBase<CDelegWiz_StartPage>(pWiz) 
	{
#ifdef _SKIP_NAME_PAGE
    m_bBindOK = FALSE;
#endif
	}
	enum { IDD = IDD_DELEGWIZ_START };

private:
	BEGIN_MSG_MAP(CDelegWiz_StartPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	  CHAIN_MSG_MAP(CWizPageBase<CDelegWiz_StartPage>)
	END_MSG_MAP()

	// message handlers
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, 
						LPARAM lParam, BOOL& bHandled);

#ifdef _SKIP_NAME_PAGE
  BOOL m_bBindOK;
#endif

public:
	// standard wizard message handlers
	BOOL OnSetActive();

	LRESULT OnWizardBack() { return -1;	} // first page

#ifdef _SKIP_NAME_PAGE
  LRESULT OnWizardNext();
#endif

};

////////////////////////////////////////////////////////////////////////////
// CDelegWiz_NamePage

class CDelegWiz_NamePage : public CWizPageBase<CDelegWiz_NamePage>
{
public:
	CDelegWiz_NamePage(CWizardBase* pWiz) : CWizPageBase<CDelegWiz_NamePage>(pWiz) 
	{
		m_hwndNameEdit = NULL;
	}
	enum { IDD = IDD_DELEGWIZ_NAME };

private:
	BEGIN_MSG_MAP(CDelegWiz_NamePage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	  COMMAND_HANDLER(IDC_BROWSE_BUTTON, BN_CLICKED, OnBrowse)
	  CHAIN_MSG_MAP(CWizPageBase<CDelegWiz_NamePage>)
	END_MSG_MAP()

	// message handlers
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, 
						LPARAM lParam, BOOL& bHandled);
	LRESULT OnBrowse(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

public:
	// standard wizard message handlers
	BOOL OnSetActive();

	LRESULT OnWizardNext();

private:
	HWND m_hwndNameEdit;

};

///////////////////////////////////////////////////////////////////////
// CImageListHelper

class CImageListEntry
{
public:
  CImageListEntry(LPCWSTR lpszClass, int nIndex)
  {
    m_szClass = lpszClass;
    m_nIndex = nIndex;
  }
  bool operator<(CImageListEntry& x) { return false;}
  CWString m_szClass;
  int m_nIndex;
};

class CImageListHelper
{
public:
  CImageListHelper()
  {
    m_hImageList = NULL;
  }

  HIMAGELIST GetHandle() 
  { 
    ASSERT(m_hImageList != NULL);
    return m_hImageList;
  }
  BOOL Create(HWND hWndListView)
  {
    ASSERT(m_hImageList == NULL);
    m_hImageList = ImageList_Create(16, 16, ILC_COLOR, 0, 2);
    return m_hImageList != NULL;
  }

  int GetIconIndex(LPCWSTR lpszClass)
  {
    int nCount = m_imageCacheArr.GetCount();
    for (int k=0; k<nCount; k++)
    {
      if (_wcsicmp(m_imageCacheArr[k]->m_szClass, lpszClass) == 0)
        return m_imageCacheArr[k]->m_nIndex; // got cached
    }
    return -1; // not found
  }

  int AddIcon(LPCWSTR lpszClass, HICON hIcon)
  {
    ASSERT(m_hImageList != NULL);
    int nCount = m_imageCacheArr.GetCount();
    // add to the image list
    int nRes = ImageList_AddIcon(m_hImageList, hIcon);
    if (nRes != nCount)
      return nRes;
    
    // add to the cache
    CImageListEntry* pEntry = new CImageListEntry(lpszClass, nCount);
    m_imageCacheArr.Add(pEntry);
    return nCount; // new index
  }
private:
  CGrowableArr<CImageListEntry> m_imageCacheArr;
  HIMAGELIST m_hImageList;
};

///////////////////////////////////////////////////////////////////////
// CPrincipalListViewHelper

class CPrincipalListViewHelper
{
public:

	CPrincipalListViewHelper()
	{
    m_defaultColWidth = 0;
		m_hWnd = NULL;
	}

	BOOL Initialize(UINT nID, HWND hParent);
	int InsertItem(int iItem, CPrincipal* pPrincipal);
  BOOL SelectItem(int iItem);
	CPrincipal* GetItemData(int iItem);
	int GetItemCount()
	{
		return ListView_GetItemCount(m_hWnd);
	}
  int GetSelCount()
  {
    return ListView_GetSelectedCount(m_hWnd);
  }

	BOOL DeleteAllItems()
	{
		return ListView_DeleteAllItems(m_hWnd);
	}
  void SetImageList()
  {
    ListView_SetImageList(m_hWnd, m_imageList.GetHandle(), LVSIL_SMALL);
  }
  BOOL SetWidth(int cx)
  {
    return ListView_SetColumnWidth(m_hWnd, 0, cx);		
  }
  int GetWidth()
  {
    return ListView_GetColumnWidth(m_hWnd, 0);		
  }

  void DeleteSelectedItems(CGrowableArr<CPrincipal>* pDeletedArr);
  void UpdateWidth(int cxNew);

private:
	HWND m_hWnd;
  int m_defaultColWidth;
  CImageListHelper m_imageList;
};


////////////////////////////////////////////////////////////////////////////
// CDelegWiz_PrincipalSelectionPage

class CDelegWiz_PrincipalSelectionPage : public CWizPageBase<CDelegWiz_PrincipalSelectionPage>
{
public:
	CDelegWiz_PrincipalSelectionPage(CWizardBase* pWiz) : 
		CWizPageBase<CDelegWiz_PrincipalSelectionPage>(pWiz) 
	{
		m_hwndRemoveButton = NULL;
	}
	enum { IDD = IDD_DELEGWIZ_PRINCIPALS_SEL };

private:
	BEGIN_MSG_MAP(CDelegWiz_PrincipalSelectionPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	  COMMAND_HANDLER(IDC_ADD_BUTTON, BN_CLICKED, OnAdd)
	  COMMAND_HANDLER(IDC_REMOVE_BUTTON, BN_CLICKED, OnRemove)
	  NOTIFY_HANDLER(IDC_SELECTED_PRINCIPALS_LIST, LVN_ITEMCHANGED, OnListViewSelChange)
	  CHAIN_MSG_MAP(CWizPageBase<CDelegWiz_PrincipalSelectionPage>)
	END_MSG_MAP()

	// message handlers
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, 
						LPARAM lParam, BOOL& bHandled);
	LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnListViewSelChange(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

public:
	// standard wizard message handlers
	BOOL OnSetActive();
  LRESULT OnWizardNext();

private:
	CPrincipalListViewHelper	m_principalListView;
	HWND	m_hwndRemoveButton;

	void SyncButtons();
};


////////////////////////////////////////////////////////////////////////////
// CDelegWiz_DelegationTemplateSelectionPage

class CDelegWiz_DelegationTemplateSelectionPage : public CWizPageBase<CDelegWiz_DelegationTemplateSelectionPage>
{
public:
	CDelegWiz_DelegationTemplateSelectionPage(CWizardBase* pWiz) : 
		CWizPageBase<CDelegWiz_DelegationTemplateSelectionPage>(pWiz) 
	{
	  m_hwndDelegateTemplateRadio = NULL;
	  m_hwndDelegateCustomRadio = NULL;
	}
  ~CDelegWiz_DelegationTemplateSelectionPage() {}

  enum { IDD = IDD_DELEGWIZ_DELEG_TEMPLATE_SEL };

	BEGIN_MSG_MAP(CDelegWiz_DelegationTemplateSelectionPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	  COMMAND_HANDLER(IDC_DELEGATE_TEMPLATE_RADIO, BN_CLICKED, OnDelegateTypeRadioChange)
	  COMMAND_HANDLER(IDC_DELEGATE_CUSTOM_RADIO, BN_CLICKED, OnDelegateTypeRadioChange)
	  NOTIFY_HANDLER(IDC_DELEGATE_TEMPLATE_LIST, LVN_ITEMCHANGED, OnListViewItemChanged)
	  CHAIN_MSG_MAP(CWizPageBase<CDelegWiz_DelegationTemplateSelectionPage>)
	END_MSG_MAP()

	// message handlers
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, 
						LPARAM lParam, BOOL& bHandled);
	LRESULT OnDelegateTypeRadioChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnListViewItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

public:
	// standard wizard message handlers
	BOOL OnSetActive();
	LRESULT OnWizardNext();

private:
	CCheckListViewHelper m_delegationTemplatesListView;
	HWND m_hwndDelegateTemplateRadio;
	HWND m_hwndDelegateCustomRadio;

	void SyncControlsHelper(BOOL bDelegateCustom);
	static void SetRadioControlText(HWND hwndCtrl, LPCWSTR lpszFmtText, LPCTSTR lpszText);
};






////////////////////////////////////////////////////////////////////////////
// CDelegWiz_ObjectTypeSelectionPage

class CDelegWiz_ObjectTypeSelectionPage : public CWizPageBase<CDelegWiz_ObjectTypeSelectionPage>
{
public:
	CDelegWiz_ObjectTypeSelectionPage(CWizardBase* pWiz) : 
		CWizPageBase<CDelegWiz_ObjectTypeSelectionPage>(pWiz) 
	{
		m_hwndDelegateAllRadio = NULL;
		m_hwndDelegateFollowingRadio = NULL;
	}
  ~CDelegWiz_ObjectTypeSelectionPage() {}

  enum { IDD = IDD_DELEGWIZ_OBJ_TYPE_SEL };

	BEGIN_MSG_MAP(CDelegWiz_ObjectTypeSelectionPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	  COMMAND_HANDLER(IDC_DELEGATE_ALL_RADIO, BN_CLICKED, OnObjectRadioChange)
	  COMMAND_HANDLER(IDC_DELEGATE_FOLLOWING_RADIO, BN_CLICKED, OnObjectRadioChange)
     COMMAND_HANDLER(IDC_DELEGATE_CREATE_CHILD, BN_CLICKED, OnCreateDelCheckBoxChanage)
     COMMAND_HANDLER(IDC_DELEGATE_DELETE_CHILD, BN_CLICKED, OnCreateDelCheckBoxChanage)
	  NOTIFY_HANDLER(IDC_OBJ_TYPE_LIST, LVN_ITEMCHANGED, OnListViewItemChanged)
	  CHAIN_MSG_MAP(CWizPageBase<CDelegWiz_ObjectTypeSelectionPage>)
	END_MSG_MAP()

	// message handlers
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, 
						LPARAM lParam, BOOL& bHandled);
	LRESULT OnObjectRadioChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnListViewItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
   LRESULT OnCreateDelCheckBoxChanage(WORD wNotifyCode, WORD wID, 
													  HWND hWndCtl, BOOL& bHandled);
public:
	// standard wizard message handlers
	BOOL OnSetActive();
	LRESULT OnWizardNext();

private:
	CCheckListViewHelper m_objectTypeListView;
	HWND m_hwndDelegateAllRadio;
	HWND m_hwndDelegateFollowingRadio;
   HWND m_hwndDelegateCreateChild;
   HWND m_hwndDelegateDeleteChild;
	void SyncControlsHelper(BOOL bDelegateAll);
	static void SetRadioControlText(HWND hwndCtrl, LPCWSTR lpszFmtText, LPCTSTR lpszText);
};

////////////////////////////////////////////////////////////////////////////
// CDelegWiz_DelegatedRightsPage

class CDelegWiz_DelegatedRightsPage : public CWizPageBase<CDelegWiz_DelegatedRightsPage>
{
public:
	CDelegWiz_DelegatedRightsPage(CWizardBase* pWiz) : CWizPageBase<CDelegWiz_DelegatedRightsPage>(pWiz) 
	{
		m_hwndGeneralRigthsCheck = NULL;
		m_hwndPropertyRightsCheck = NULL;
    m_hwndSubobjectRightsCheck = NULL;

    m_bUIUpdateInProgress = FALSE;
	}
	
	enum { IDD = IDD_DELEGWIZ_DELEG_RIGHTS };
	
	BEGIN_MSG_MAP(CDelegWiz_DelegatedRightsPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	  COMMAND_HANDLER(IDC_SHOW_GENERAL_CHECK, BN_CLICKED, OnFilterChange)
	  COMMAND_HANDLER(IDC_SHOW_PROPERTY_CHECK, BN_CLICKED, OnFilterChange)
    COMMAND_HANDLER(IDC_SHOW_SUBOBJ_CHECK, BN_CLICKED, OnFilterChange)
	  NOTIFY_HANDLER(IDC_DELEG_RIGHTS_LIST, LVN_ITEMCHANGED, OnListViewItemChanged)
	  CHAIN_MSG_MAP(CWizPageBase<CDelegWiz_DelegatedRightsPage>)
	END_MSG_MAP()

	// message handlers
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnDelegateRadioChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnFilterChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnListViewItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	public:
	// standard wizard message handlers
	BOOL OnSetActive();
	LRESULT OnWizardNext();

private:
	CCheckListViewHelper m_delegatedRigthsListView;
	HWND m_hwndGeneralRigthsCheck;
  HWND m_hwndPropertyRightsCheck;
	HWND m_hwndSubobjectRightsCheck;

  BOOL m_bUIUpdateInProgress;

	void ResetCheckList();

  ULONG GetFilterOptions();
  void SetFilterOptions(ULONG nFilterOptions);
};

////////////////////////////////////////////////////////////////////////////
// CDelegWiz_FinishPage

class CDelegWiz_FinishPage : public CWizPageBase<CDelegWiz_FinishPage>
{
public:
	CDelegWiz_FinishPage(CWizardBase* pWiz) : 
        CWizPageBase<CDelegWiz_FinishPage>(pWiz) 
	{
    m_bNeedSetFocus = FALSE;
    m_bCustom = TRUE;
	}
	enum { IDD = IDD_DELEGWIZ_FINISH };
	BEGIN_MSG_MAP(CDelegWiz_FinishPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
 	  COMMAND_HANDLER(IDC_EDIT_SUMMARY, EN_SETFOCUS, OnSetFocusSummaryEdit)
	  CHAIN_MSG_MAP(CWizPageBase<CDelegWiz_FinishPage>)
	END_MSG_MAP()

	// message handlers
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, 
						LPARAM lParam, BOOL& bHandled);
	LRESULT OnSetFocusSummaryEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

public:
	// standard wizard message handlers
	BOOL OnSetActive();
	BOOL OnWizardFinish();

  void SetCustom() { m_bCustom = TRUE;}
  void SetTemplate() { m_bCustom = FALSE;}
  BOOL IsCustom(){ return m_bCustom; }


private:
  BOOL m_bNeedSetFocus;
  BOOL m_bCustom;
};



////////////////////////////////////////////////////////////////////////////
// CDelegWiz

class CDelegWiz : public CWizardBase
{
public:
	// construction/ destruction
	CDelegWiz();
	virtual ~CDelegWiz();

	// message map
	BEGIN_MSG_MAP(CDelegWiz)
	  CHAIN_MSG_MAP(CWizardBase)
	END_MSG_MAP()

  void InitFromLDAPPath(LPCWSTR lpszLDAPPath)
  {
    TRACE(L"CDelegWiz::InitFromLDAPPath(%s)\n", lpszLDAPPath);
    m_lpszLDAPPath = lpszLDAPPath;
  }
  LPCWSTR GetInitialLDAPPath() { return m_lpszLDAPPath;}

  BOOL CanChangeName() { return m_lpszLDAPPath == NULL;}
  LPCWSTR GetClass() { return m_adsiObject.GetClass();}
  LPCWSTR GetCanonicalName() { return m_adsiObject.GetCanonicalName();}
  void SetName(LPCWSTR lwsz)
  {
    ASSERT(FALSE); // TODO
  }


	HRESULT AddPrincipals(CPrincipalListViewHelper* pListViewHelper);
	BOOL DeletePrincipals(CPrincipalListViewHelper* pListViewHelper);

  HRESULT GetObjectInfo() 
  { 
    return m_adsiObject.Bind(GetInitialLDAPPath()); 
  }

  HRESULT GetClassInfoFromSchema() 
  { 
    return m_adsiObject.QuerySchemaClasses(&m_schemaClassInfoArray);
  }

  // ----- APIs for Custom Mode -----

	int FillCustomSchemaClassesListView(CCheckListViewHelper* pListViewHelper, BOOL bFilter);

	BOOL GetCustomAccessPermissions();
	void FillCustomAccessRightsListView(CCheckListViewHelper* pListViewHelper, 
											                ULONG nFilterState);

  void UpdateAccessRightsListViewSelection(
                       CCheckListViewHelper* pListViewHelper,
                       ULONG nFilterState);

	void OnCustomAccessRightsCheckListClick(
                        CRigthsListViewItem* pItem,
												BOOL bSelected,
                        ULONG* pnNewFilterState);

  BOOL HasPermissionSelectedCustom();

	BOOL SetSchemaClassesSelectionCustom();
  void DeselectSchemaClassesSelectionCustom();

	// finish page
	void SetSummaryInfoCustom(HWND hwndSummaryName, 
                               HWND hwndSummaryPrincipals,
                               HWND hwndSummaryRights,
                               HWND hwndSummaryObjects,
                               HWND hwndSummaryObjectsStatic);

	void WriteSummaryInfoCustom(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine); 

	BOOL FinishCustom() { return FinishHelper(TRUE);}


  // ----- APIs for Template Mode -----

  BOOL InitPermissionHoldersFromSelectedTemplates();

  // finish page
	void WriteSummaryInfoTemplate(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine); 

  BOOL FinishTemplate() { return FinishHelper(FALSE);}
  //This flag is used to create/delete childobjects of selected type.
  // Possible values are ACTRL_DS_CREATE_CHILD | ACTRL_DS_DELETE_CHILD
  DWORD  m_fCreateDelChild;   

  BOOL m_bAuxClass;

  BOOL HideListObjectAccess(void)
  {
    return !m_adsiObject.GetListObjectEnforced();
  }


private:

	// embedded wizard property pages
	CDelegWiz_StartPage					      m_startPage;
	CDelegWiz_NamePage					      m_namePage;
	CDelegWiz_PrincipalSelectionPage	m_userOrGroupSelectionPage;

  // page for template selection
  CDelegWiz_DelegationTemplateSelectionPage m_templateSelectionPage;

  // pages for the custom branch 
	CDelegWiz_ObjectTypeSelectionPage	m_objectTypeSelectionPage;
	CDelegWiz_DelegatedRightsPage		  m_delegatedRightsPage;

  // common finish page
  CDelegWiz_FinishPage				m_finishPage;


	// Domain/OU name data

  CAdsiObject       m_adsiObject;

  LPCWSTR           m_lpszLDAPPath; // path the wizard was initialized from

	// principals (Users and Groups)
	CPrincipalList				m_principalList;



	// schema classes info
  CGrowableArr<CSchemaClassInfo>	m_schemaClassInfoArray;

  // selection info about m_schemaClassInfoArray

  static const long nSchemaClassesSelAll;
  static const long nSchemaClassesSelMultiple;
	long						m_nSchemaClassesSel; // -1 for select all

  BOOL m_bChildClass;                 //determines if to show create/delet child objects in case of custom permission
	// custom rights
  CCustomAccessPermissionsHolder m_permissionHolder;

  CTemplateAccessPermissionsHolderManager m_templateAccessPermissionsHolderManager;
	
	// interface pointers
	CComPtr<IADsPathname>		m_spADsPath; // cached object pointer for name resolution

	// internal helpers
	HRESULT AddPrincipalsFromBrowseResults(CPrincipalListViewHelper* pListViewHelper, 
                                         PDS_SELECTION_LIST pDsSelectionList);

	DWORD BuildNewAccessListCustom(PACL *ppNewAcl);
  DWORD BuildNewAccessListTemplate(PACL *ppNewAcl);

	DWORD UpdateAccessList(CPrincipal* pPrincipal,
							CSchemaClassInfo* pClassInfo,
							PACL *ppAcl);

  void WriteSummaryInfoHelper(CWString& szSummary, LPCWSTR lpszIdent, LPCWSTR lpszNewLine);

  BOOL FinishHelper(BOOL bCustom);

  friend class CDelegWiz_DelegationTemplateSelectionPage;
  friend class CDelegWiz_PrincipalSelectionPage;

};

#endif // _DELEGWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\oudeleg\pch.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       pch.cpp
//
//--------------------------------------------------------------------------


#include "pch.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>

HRESULT WINAPI COuDelegComModule::UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister)
{
	static const WCHAR szIPS32[] = _T("InprocServer32");
	static const WCHAR szCLSID[] = _T("CLSID");

	HRESULT hRes = S_OK;

	LPOLESTR lpOleStrCLSIDValue;
	::StringFromCLSID(clsid, &lpOleStrCLSIDValue);

	CRegKey key;
	if (bRegister)
	{
		LONG lRes = key.Open(HKEY_CLASSES_ROOT, szCLSID);
		if (lRes == ERROR_SUCCESS)
		{
			lRes = key.Create(key, lpOleStrCLSIDValue);
			if (lRes == ERROR_SUCCESS)
			{
				WCHAR szModule[_MAX_PATH];
				::GetModuleFileName(m_hInst, szModule, _MAX_PATH);
				key.SetKeyValue(szIPS32, szModule);
			}
		}
		if (lRes != ERROR_SUCCESS)
			hRes = HRESULT_FROM_WIN32(lRes);
	}
	else
	{
		key.Attach(HKEY_CLASSES_ROOT);
		if (key.Open(key, szCLSID) == ERROR_SUCCESS)
			key.RecurseDeleteKey(lpOleStrCLSIDValue);
	}
	::CoTaskMemFree(lpOleStrCLSIDValue);
	return hRes;
}

BOOL COuDelegComModule::InitClipboardFormats()
{
	_ASSERTE(m_cfDsObjectNames == 0);
	m_cfDsObjectNames = ::RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
  _ASSERTE(m_cfParentHwnd == 0);
	m_cfParentHwnd = ::RegisterClipboardFormat(CFSTR_DS_PARENTHWND);
  _ASSERTE(m_cfDsopSelectionList == 0);
  m_cfDsopSelectionList = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

	return (m_cfDsObjectNames != 0) && (m_cfParentHwnd != 0) && (m_cfDsopSelectionList != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\oudeleg\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       pch.h
//
//--------------------------------------------------------------------------


#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#define _ATL_APARTMENT_THREADED

//#define _ATL_DISABLE_NO_VTABLE



#define _DELEGWIZ



//////////////////////////////////////////////
// CRT and C++ headers

#pragma warning( disable : 4530) // REVIEW_MARCOC: need to get the -GX flag to work 

#include <xstring>
#include <list>
#include <vector>
#include <algorithm>

using namespace std;

//////////////////////////////////////////////
// Windows and ATL headers

#include <windows.h>
//#include <windowsx.h>

#include <shellapi.h>
#include <shlobj.h>

#include <objsel.h>

#include <atlbase.h>
using namespace ATL;


//////////////////////////////////////////
// macros from windowsx.h (conflict in atlwin.h)

#define GET_WM_COMMAND_ID(wp, lp)               LOWORD(wp)
#define GET_WM_COMMAND_HWND(wp, lp)             (HWND)(lp)
#define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(wp)
#define GET_WM_COMMAND_MPS(id, hwnd, cmd)    \
        (WPARAM)MAKELONG(id, cmd), (LONG)(hwnd)

#define GET_WM_VSCROLL_CODE(wp, lp)                 LOWORD(wp)
#define GET_WM_VSCROLL_POS(wp, lp)                  HIWORD(wp)
#define GET_WM_VSCROLL_HWND(wp, lp)                 (HWND)(lp)
#define GET_WM_VSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)MAKELONG(code, pos), (LONG)(hwnd)


#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#endif
///////////////////////////////////////////
// ASSERT's and TRACE's without debug CRT's
#if defined (DBG)
  #if !defined (_DEBUG)
    #define ASSERT
    #define TRACE

    #define _USE_DSA_TRACE
    #define _USE_DSA_ASSERT
    #define _USE_DSA_TIMER
  #else
    #ifndef ASSERT
    #define ASSERT(x) _ASSERTE(x)
    #endif

    #ifndef TRACE
    #define TRACE ATLTRACE
    #endif
  #endif
#else
    #define ASSERT
    #define TRACE
#endif

#include "dbg.h"



//////////////////////////////////////////
// Miscellanea macros
#define ByteOffset(base, offset) (((LPBYTE)base)+offset)

//////////////////////////////////////////
// COuDelegComModule

class COuDelegComModule : public CComModule
{
public:
	COuDelegComModule()
	{
		m_cfDsObjectNames = 0;
    m_cfParentHwnd = 0;
	}
	HRESULT WINAPI UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister);
	BOOL InitClipboardFormats();
	UINT GetCfDsObjectNames() { return m_cfDsObjectNames;}
  UINT GetCfParentHwnd() { return m_cfParentHwnd;}
  UINT GetCfDsopSelectionList() { return m_cfDsopSelectionList;}
private:
	UINT m_cfDsObjectNames;
  UINT m_cfParentHwnd;
  UINT m_cfDsopSelectionList;
};

extern COuDelegComModule _Module;

//////////////////////////////////////////////////////////////
// further ATL and utility includes

#include <atlcom.h>
#include <atlwin.h>

#include "atldlgs.h"	// WTL sheet and ppage classes NenadS


#include <setupapi.h> // to read the .INF file

// ADS headers
#include <iads.h>
#include <activeds.h>
#include <dsclient.h>
#include <dsclintp.h>
#include <dsquery.h>
#include <dsgetdc.h>

#include <cmnquery.h>
#include <aclapi.h>
#include <aclui.h>

#include <ntdsapi.h> // DsBind/DsCrackNames
#include <lm.h>       // required for lmapibuf.h
#include <lmapibuf.h> // NetApiBufferFree

#include <propcfg.h> // from the admin\display project (clipboard format)
#include <dscmn.h>  // from the admin\display project (CrackName)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\oudeleg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsuiwiz.rc
//
#define IDS_BIG_BOLD_FONT_NAME          1
#define IDS_BIG_BOLD_FONT_SIZE          2
#define IDS_DELEGWIZ_WIZ_TITLE          90
#define IDS_DELEGWIZ_CONTEXT_MENU       100
#define IDS_DELEGWIZ_CONTEXT_MENU_DESCR 101
#define IDS_DELEGWIZ_BROWSE_CONTAINER_CAPTION 102
#define IDS_DELEGWIZ_BROWSE_CONTAINER_TITLE 103
#define IDS_DELEGWIZ_PRINCIPALS_SEL_TITLE 104
#define IDS_DELEGWIZ_PRINCIPALS_SEL_SUBTITLE 105
#define IDS_DELEGWIZ_OBJ_TYPE_SEL_TITLE 106
#define IDS_DELEGWIZ_OBJ_TYPE_SEL_SUBTITLE 107
#define IDS_DELEGWIZ_DELEG_RIGHTS_TITLE 108
#define IDS_DELEGWIZ_DELEG_RIGHTS_SUBTITLE 109
#define IDS_DELEGWIZ_NAME_TITLE         110
#define IDS_DELEGWIZ_NAME_SUBTITLE      111
#define IDS_DELEGWIZ_TEMPLATE_SEL_TITLE 112
#define IDS_DELEGWIZ_TEMPLATE_SEL_SUBTITLE 113
#define IDS_DELEGWIZ_READ_PROPERTY      114
#define IDS_DELEGWIZ_WRITE_PROPERTY     115
#define IDS_DELEGWIZ_CREATE_CLASS       116
#define IDS_DELEGWIZ_DELETE_CLASS       117
#define IDS_DELEGWIZ_CHILD_CLASS_FMT    118
#define IDS_DELEGWIZ_RW_PROPERTYSET     119
#define IDS_OBJ_NAME_EDIT_STATIC        120
#define IDS_DELEGWIZ_ERR_INVALID_OBJ_NAME 150
#define IDS_DELEGWIZ_ERR_INVALID_OBJ_INFO 151
#define IDS_DELEGWIZ_ERR_GET_SEC_INFO   152
#define IDS_DELEGWIZ_ERR_SET_SEC_INFO   153
#define IDS_DELEGWIZ_ERR_EDIT_SEC_INFO  154
#define IDS_DELEGWIZ_ERR_INVALID_PRINCIPAL 155
#define IDS_DELEGWIZ_ERR_PHYS_SCHEMA    156
#define IDS_DELEGWIZ_ERR_PERMISSIONS    157
#define IDS_DELEGWIZ_ERR_OBJ_PEC_PERM   158
#define IDS_DELEGWIZ_ERR_TEMPL_APPLY    159
#define IDS_DELEGWIZ_FINISH_FOLDER      180
#define IDS_DELEGWIZ_FINISH_OBJECT      181
#define IDS_DELEGWIZ_FINISH_TEMPLATE    182
#define IDS_DELEGWIZ_FINISH_PRINCIPALS  183
#define IDS_DELEGWIZ_FINISH_PERMISSIONS 184
#define IDS_DELEGWIZ_ACTRL_FULL         200
#define IDC_OBJ_NAME_EDIT               201
#define IDS_DELEGWIZ_ACTRL_SYSTEM_ACCESS 201
#define IDC_BROWSE_BUTTON               202
#define IDS_DELEGWIZ_ACTRL_DELETE       202
#define IDS_DELEGWIZ_ACTRL_READ_CONTROL 203
#define IDC_DELEGATE_ALL_RADIO          204
#define IDS_DELEGWIZ_ACTRL_CHANGE_ACCESS 204
#define IDC_DELEGATE_FOLLOWING_RADIO    205
#define IDS_DELEGWIZ_ACTRL_CHANGE_OWNER 205
#define IDC_OBJ_TYPE_LIST               206
#define IDS_DELEGWIZ_ACTRL_DS_CREATE_CHILD 206
#define IDS_DELEGWIZ_ACTRL_DS_DELETE_CHILD 207
#define IDC_SHOW_GENERAL_CHECK          208
#define IDS_DELEGWIZ_ACTRL_DS_LIST      208
#define IDC_SHOW_PROPERTY_CHECK         209
#define IDB_DELEG_HD                    209
#define IDS_DELEGWIZ_ACTRL_DS_SELF      209
#define IDC_SHOW_SUBOBJ_CHECK           210
#define IDB_DELEG_WATER                 210
#define IDS_DELEGWIZ_ACTRL_DS_READ_PROP 210
#define IDC_DELEG_RIGHTS_LIST           211
#define IDD_DELEGWIZ_PRINCIPALS_SEL     211
#define IDS_DELEGWIZ_ACTRL_DS_WRITE_PROP 211
#define IDC_SELECTED_PRINCIPALS_LIST    212
#define IDS_DELEGWIZ_ACTRL_DS_DELETE_TREE 212
#define IDC_REMOVE_BUTTON               213
#define IDS_DELEGWIZ_ACTRL_DS_LIST_OBJECT 213
#define IDC_ADD_BUTTON                  214
#define IDS_DELEGWIZ_ACTRL_DS_CONTROL_ACCESS 214
#define IDS_DELEGWIZ_ACTRL_READ         215
#define IDS_DELEGWIZ_ACTRL_WRITE        216
#define IDS_DELEGWIZ_ERR_ACCESS_DENIED  217
#define IDS_DELEGWIZ_ONE_AUX_CLASS      218
#define IDC_STATIC_WELCOME              220
#define IDC_STATIC_COMPLETION           221
#define IDC_DELEGATE_TEMPLATE_LIST      222
#define IDC_DELEGATE_CUSTOM_RADIO       223
#define IDC_DELEGATE_TEMPLATE_RADIO     224
#define IDC_EDIT_SUMMARY                226
#define IDC_OBJ_NAME_EDIT_STATIC        227
#define IDC_OBJ_NAME_STATIC             228
#define IDC_DELEGATE_CREATE_CHILD       230
#define IDC_DELEGATE_DELETE_CHILD       231
#define IDD_DELEGWIZ_FINISH             250
#define IDD_DELEGWIZ_START              267
#define IDD_DELEGWIZ_OBJ_TYPE_SEL       268
#define IDD_DELEGWIZ_DELEG_RIGHTS       269
#define IDD_DELEGWIZ_NAME               270
#define IDD_DELEGWIZ_DELEG_TEMPLATE_SEL 271

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        212
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         232
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\oudeleg\shellext.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       shellext.h
//
//--------------------------------------------------------------------------



//////////////////////////////////////////////////////////////////////
#ifndef _SHELLEXT_H
#define _SHELLEXT_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CShellExt

class CShellExt :
	public IShellExtInit,
	public IContextMenu,
	public CComObjectRoot,
	public CComCoClass<CShellExt,&CLSID_OuDelegWizExt>
{
public:
	CShellExt()
  {
    m_hParentWnd = NULL;
  }


BEGIN_COM_MAP(CShellExt)
	COM_INTERFACE_ENTRY(IShellExtInit)
	COM_INTERFACE_ENTRY(IContextMenu)
END_COM_MAP()

	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
	{
		return _Module.UpdateRegistryCLSID(GetObjectCLSID(), bRegister);
	}


DECLARE_NOT_AGGREGATABLE(CShellExt)


// IShellExtInit methods
public:
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, LPDATAOBJECT pdtobj,
                          HKEY hkeyProgID);

// IContextMenu methods
public:
    STDMETHOD(QueryContextMenu)(HMENU hMenu, UINT indexMenu, UINT idCmdFirst,
                                UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpcmi);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uFlags, UINT FAR *reserved,
                                LPSTR pszName, UINT cchMax);

private:
  HWND m_hParentWnd;
  CWString m_szObjectLDAPPath;
};

#endif // _SHELLEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\oudeleg\tempcore.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tempcore.cpp
//
//--------------------------------------------------------------------------


#include "pch.h"

#include <_tempcor.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\oudeleg\wizbase.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       wizbase.h
//
//--------------------------------------------------------------------------

#ifndef _WIZBASE_H
#define _WIZBASE_H

#include "util.h"

////////////////////////////////////////////////////////////////////////////
// FWD DECLARATIONS

////////////////////////////////////////////////////////////////////////////
// CWizardBase

class CWizardBase : public CPropertySheet
{
public:
	// construction/ destruction
	CWizardBase(UINT nWatermarkBitmapID, UINT nBannerBitmapID, UINT nTitleID = -1)
	{
		m_psh.hplWatermark = NULL;         
		m_psh.dwFlags |= PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
		m_psh.pszbmWatermark      = MAKEINTRESOURCE(nWatermarkBitmapID);
	    m_psh.pszbmHeader         = MAKEINTRESOURCE(nBannerBitmapID);

    m_bFwd = TRUE;
    m_nTitleID = nTitleID;
	}
	virtual ~CWizardBase(){}

	// message map
	BEGIN_MSG_MAP(CWizardBase)
      MESSAGE_HANDLER(WM_NCDESTROY, OnNcDestroy)
	END_MSG_MAP()


	// message handlers
	LRESULT OnNcDestroy(UINT uMsg, WPARAM wParam, 
						LPARAM lParam, BOOL& bHandled)
	{
		// NOTICE: important!!!. BUG workaround.
		// We have to handle this message because we use ATL 2.1
		// The DECLARE_EMPTY_MSG_MAP() macro in the new ATLWIN.H
		// works only with the modified CWindowImplBase::WindowProc()
		return DefWindowProc(uMsg, wParam, lParam);
	}

	// helpers for setting wizard buttons
	void SetWizardButtonsFirst(BOOL bValid) 
	{ 
		SetWizardButtons(bValid ? PSWIZB_NEXT : 0);
	}
	void SetWizardButtonsMiddle(BOOL bValid) 
	{ 
		SetWizardButtons(bValid ? (PSWIZB_BACK|PSWIZB_NEXT) : PSWIZB_BACK);
	}
	void SetWizardButtonsLast(BOOL bValid) 
	{ 
		SetWizardButtons(bValid ? (PSWIZB_BACK|PSWIZB_FINISH) : (PSWIZB_BACK|PSWIZB_DISABLEDFINISH));
	}

  
  // message box helpers
  int WizMessageBox(LPCTSTR lpszText, UINT nType = MB_OK)
  {
    CWString szTitle;
    szTitle.LoadFromResource(m_nTitleID);
    return MessageBox(lpszText, szTitle, nType);
  }
  int WizMessageBox(UINT nMsgID, UINT nType = MB_OK)
  {
    CWString szMsg;
    szMsg.LoadFromResource(nMsgID);
    return WizMessageBox(szMsg, nType);
  }

  // error message helpers
  void WizReportHRESULTError(LPCWSTR lpszMsg, HRESULT hr)
  {
    CWString szErrorString;
    if (GetStringFromHRESULTError(hr, szErrorString))
    {
      CWString szTemp;
      szTemp = lpszMsg;
      szTemp += L" ";
      szTemp += szErrorString;
      WizMessageBox(szTemp);
    }
    else
    {
      WizMessageBox(lpszMsg);
    }
  }
  void WizReportHRESULTError(UINT nStringID, HRESULT hr)
  {
    CWString szMsg;
    szMsg.LoadFromResource(nStringID);
    WizReportHRESULTError(szMsg, hr);
  }
  void WizReportWin32Error(LPCWSTR lpszMsg, DWORD dwErr)
  {
    CWString szErrorString;
    if (GetStringFromWin32Error(dwErr, szErrorString))
    {
      CWString szTemp;
      szTemp = lpszMsg;
      szTemp += L" ";
      szTemp += szErrorString;
      WizMessageBox(szTemp);
    }
    else
    {
      WizMessageBox(lpszMsg);
    }
  }
  void WizReportWin32Error(UINT nStringID, DWORD dwErr)
  {
    CWString szMsg;
    szMsg.LoadFromResource(nStringID);
    WizReportWin32Error(szMsg, dwErr);
  }


public:
  BOOL            m_bFwd;

private:
  UINT            m_nTitleID;
};




////////////////////////////////////////////////////////////////////////////
// CWizPageBase

template <class T>
class CWizPageBase : public CPropertyPageImpl<T>
{
public:
	CWizPageBase(CWizardBase* pWiz)
	{
		m_pWiz = pWiz;
		m_lpszHeaderTitleBuf = NULL;
		m_lpszHeaderSubTitleBuf = NULL;
    m_nPrevPageID = 0;
	}
	~CWizPageBase()
	{
		if (m_lpszHeaderTitleBuf != NULL)
			delete[] m_lpszHeaderTitleBuf;
		if (m_lpszHeaderSubTitleBuf != NULL)
			delete[] m_lpszHeaderSubTitleBuf;
	}

	CWizardBase* GetWizard() { return m_pWiz; }
	void InitWiz97(BOOL bHideHeader, UINT nTitleID=0, UINT nSubTitleID=0)
	{
		if (bHideHeader)
			m_psp.dwFlags |= PSP_HIDEHEADER;
		else
		{
			int nBufferMax = 128;
			if (nTitleID != 0)
			{
				m_lpszHeaderTitleBuf = new TCHAR[nBufferMax];
            if( m_lpszHeaderTitleBuf )
            {
				   if (LoadStringHelper(nTitleID, m_lpszHeaderTitleBuf, nBufferMax))
				   {
					   m_psp.dwFlags |= PSP_USEHEADERTITLE;
					   m_psp.pszHeaderTitle = m_lpszHeaderTitleBuf;
				   }
            }
			}
			if (nSubTitleID != 0)
			{
				m_lpszHeaderSubTitleBuf = new TCHAR[nBufferMax];
            if(m_lpszHeaderSubTitleBuf )
            {
				   LoadStringHelper(nSubTitleID, m_lpszHeaderSubTitleBuf, nBufferMax);
				   m_psp.dwFlags |= PSP_USEHEADERSUBTITLE;
				   m_psp.pszHeaderSubTitle = m_lpszHeaderSubTitleBuf;
            }
			}
		}
	}

public:
	// standard wizard message handlers
	LRESULT OnWizardBack()
  {
    m_pWiz->m_bFwd = FALSE;
    UINT nTempPrevPageID = m_nPrevPageID;
    m_nPrevPageID = 0;
    return nTempPrevPageID;
  }

	LRESULT OnWizardNext()
  {
    OnWizardNextHelper();
    return 0;
  }

  void OnWizardNextHelper()
  {
    m_pWiz->m_bFwd = TRUE;
  }


public: 
  UINT m_nPrevPageID;
  

private:
	CWizardBase*	m_pWiz;
	LPTSTR			m_lpszHeaderTitleBuf;
	LPTSTR			m_lpszHeaderSubTitleBuf;

};

#endif // _WIZBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\oudeleg\shellext.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       shellext.cpp
//
//--------------------------------------------------------------------------


#include "pch.h"
#include "util.h"
#include "dsuiwiz.h"
#include "shellext.h"
#include "delegwiz.h"



//#define _MMC_HACK

#ifdef _MMC_HACK

BOOL CALLBACK EnumThreadWndProc(HWND hwnd, /* enumerated HWND */
								LPARAM lParam /* pass a HWND* for return value*/ )
{
	ASSERT(hwnd);
	HWND hParentWnd = GetParent(hwnd);
	// the main window of the MMC console should staitsfy this condition
	if ( ((hParentWnd == GetDesktopWindow()) || (hParentWnd == NULL))  && IsWindowVisible(hwnd) )
	{
		HWND* pH = (HWND*)lParam;
		*pH = hwnd;
		return FALSE; // stop enumerating
	}
	return TRUE;
}



HWND FindMMCMainWindow()
{
	DWORD dwThreadID = ::GetCurrentThreadId();
	ASSERT(dwThreadID != 0);
	HWND hWnd = NULL;
	BOOL bEnum = EnumThreadWindows(dwThreadID, EnumThreadWndProc,(LPARAM)&hWnd);
	ASSERT(hWnd != NULL);
	return hWnd;
}

#endif // _MMC_HACK

HWND _GetParentWindow(LPDATAOBJECT pDataObj )
{
  HWND hWnd = NULL;
	STGMEDIUM ObjMedium = {TYMED_NULL};
	FORMATETC fmte = {(CLIPFORMAT)_Module.GetCfParentHwnd(),
						NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

	if (SUCCEEDED(pDataObj->GetData(&fmte, &ObjMedium)))
	{
	  hWnd = *((HWND*)ObjMedium.hGlobal);
		::ReleaseStgMedium(&ObjMedium);
	}
#ifdef _MMC_HACK
  if (hWnd == NULL)
    hWnd = FindMMCMainWindow();
#endif
  return hWnd;
}

HRESULT _GetObjectLDAPPath(IDataObject* pDataObj, CWString& szLDAPPath)
{
  TRACE(L"entering _GetObjectLDAPPath()\n");
	if (pDataObj == NULL)
	{
		// no data object, no name
		szLDAPPath = L"";
		return E_INVALIDARG;
	}

	//crack the data object and get the name
	STGMEDIUM ObjMedium = {TYMED_NULL};
	FORMATETC fmte = {(CLIPFORMAT)_Module.GetCfDsObjectNames(),
						NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	// Get the path to the DS object from the data object.
  HRESULT hr = pDataObj->GetData(&fmte, &ObjMedium);
	if (SUCCEEDED(hr))
	{
		LPDSOBJECTNAMES pDsObjectNames = (LPDSOBJECTNAMES)ObjMedium.hGlobal;
		if (pDsObjectNames->cItems == 1)
		{
			LPCWSTR lpsz = (LPCWSTR)ByteOffset(pDsObjectNames,
                                 pDsObjectNames->aObjects[0].offsetName);
      if ((lpsz == NULL) || (lpsz[0] == NULL))
      {
        szLDAPPath = L"";
        hr = E_INVALIDARG;
      }
      else
      {
        szLDAPPath = lpsz;
      }
		}
    else
    {
      szLDAPPath = L"";
      hr = E_INVALIDARG;
    }
		::ReleaseStgMedium(&ObjMedium);
	}

  TRACE(L"returning from _GetObjectLDAPPath(_, %s), hr = 0x%x\n", (LPCWSTR)szLDAPPath, hr);

	return hr;
}
/////////////////////////////////////////////////////////////////////////
// IShellExtInit methods

STDMETHODIMP CShellExt::Initialize(
    LPCITEMIDLIST pidlFolder,
    LPDATAOBJECT  lpdobj,
    HKEY          hKeyProgID)
{
  if (lpdobj == NULL)
    return E_INVALIDARG;

  m_hParentWnd = _GetParentWindow(lpdobj);

  if ((m_hParentWnd == NULL) || !::IsWindow(m_hParentWnd))
    return E_INVALIDARG;

  return _GetObjectLDAPPath(lpdobj, m_szObjectLDAPPath);
}

/////////////////////////////////////////////////////////////////////////
// IContextMenu methods

STDMETHODIMP CShellExt::QueryContextMenu(
    HMENU hMenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags)
{
	// only one menu item to insert (position zero)
	TCHAR szContextMenu[128];
	LoadStringHelper(IDS_DELEGWIZ_CONTEXT_MENU, szContextMenu, ARRAYSIZE(szContextMenu));
	UINT countMenuItems = 1;
    ::InsertMenu(hMenu, indexMenu, MF_STRING | MF_BYPOSITION,
                 idCmdFirst /* + 0*/, szContextMenu);

    return MAKE_SCODE(SEVERITY_SUCCESS, 0, countMenuItems);
}



STDMETHODIMP CShellExt::GetCommandString(
    UINT_PTR idCmd,
    UINT    uFlags,
    UINT  * reserved,
    LPSTR   pszName,
    UINT    cchMax)
{
  if (uFlags != GCS_HELPTEXT) 
  {
    return S_OK;
  }

  //
  // Copy the requested string to the caller's buffer.
  //
	if (idCmd == 0) // we inserted the zero-th element
	{
    // this is really WCHAR, as Jim swears, so lets trust him...
    LPWSTR lpszHack = (LPWSTR)pszName;
    if (::LoadStringHelper(IDS_DELEGWIZ_CONTEXT_MENU_DESCR,
			  lpszHack, cchMax))
    {
      return S_OK;
    }
	}
	return E_INVALIDARG;
}





STDMETHODIMP CShellExt::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpcmi)
{
	if (lpcmi == NULL)
		return E_INVALIDARG;

    
    //Check if you have read and write permission
    if( InitCheckAccess(m_hParentWnd, m_szObjectLDAPPath) != S_OK )
    {
        return S_OK;
    }

	if (!HIWORD(lpcmi->lpVerb))
	{
		UINT iCmd = LOWORD(lpcmi->lpVerb);
		if (iCmd == 0)
		{
      ASSERT(m_hParentWnd != NULL);
			CDelegWiz delegWiz;
      delegWiz.InitFromLDAPPath(m_szObjectLDAPPath);
			delegWiz.DoModal(m_hParentWnd);
		}
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\connmgr\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by trustmon.rc
//
#define IDS_PROJNAME                    100
#define IDS_HEALTHMONPRV_DESC               101
//#define IDR_TrustPrv                    102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\connmgr\source\connection.cpp ===
// Connection.cpp: implementation of the CConnection class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ConnMgr.h"
#include "Connection.h"
#include "Ping.h"

#include <process.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// CConnection

IMPLEMENT_DYNCREATE(CConnection,CObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CConnection::CConnection(BSTR bsMachineName, IWbemLocator* pIWbemLocator)
{
	OutputDebugString(_T("CConnection::CConnection()\n"));
	ASSERT(pIWbemLocator);

	Init();
	m_bsMachineName = SysAllocString(bsMachineName);
	m_sNamespace.Format(_T("\\\\%s\\root\\cimv2\\MicrosoftHealthmonitor"),bsMachineName);
	m_pIWbemLocator		= pIWbemLocator;
	m_pIWbemLocator->AddRef();

	StartMonitor();
}

CConnection::CConnection()
{
	OutputDebugString(_T("CConnection::CConnection()\n"));

	Init();
}

CConnection::~CConnection()
{
  OutputDebugString(_T("CConnection::~CConnection()\n"));  
	// stop monitoring
	StopMonitor();

	RemoveAllEventEntries();

  if( m_pIWbemServices )
  {
		if (m_bAvailable)
			m_pIWbemServices->Release();
    m_pIWbemServices = NULL;
  }

	if (m_pIWbemLocator)
	{
		if (m_bAvailable)
			m_pIWbemLocator->Release();
		m_pIWbemLocator = NULL;
	}

	SysFreeString(m_bsMachineName);

	CloseHandle(m_threadData.m_hDie);
	CloseHandle(m_threadData.m_hDead);

	// zzz
	CloseHandle(m_hReadyToConnect);
}

//////////////////////////////////////////////////////////////////////
// Initialize CConnection data members.
//////////////////////////////////////////////////////////////////////
void CConnection::Init()
{
	OutputDebugString(_T("CConnection::Init()\n"));
  m_bAvailable					=	false;
	m_bFirstConnect				= true;
  m_pIWbemServices			= NULL;
	m_pIWbemLocator				= NULL;
	m_dwPollInterval			= 10000;
	m_bsMachineName				= NULL;

	m_threadData.m_hDie		= CreateEvent(NULL, TRUE, FALSE, NULL);
	m_threadData.m_hDead	= CreateEvent(NULL, TRUE, FALSE, NULL);
	m_hrLastConnectResult = S_OK;

	//zzz
	m_hReadyToConnect			= CreateEvent(NULL, TRUE, FALSE, NULL);
}

//////////////////////////////////////////////////////////////////////
// Start/Stop Monitoring connection
//////////////////////////////////////////////////////////////////////
void CConnection::StartMonitor()
{
	OutputDebugString(_T("CConnection::StartMonitor()\n"));

	m_threadData.m_bkptr = this;
	m_hThread = (HANDLE)_beginthreadex(	NULL,
																			0,
																			MonitorConnection,
																			&m_threadData,
																			0,
																			&m_threadID );	
	if (!m_hThread)
	{
		OutputDebugString(_T("CConnection::StartMonitor() Error on _beginthreadex\n"));
	}
}

void CConnection::StopMonitor()
{
	OutputDebugString(_T("CConnection::StopMonitor()\n"));

	// tell it to die now.
	SetEvent(m_threadData.m_hDie);

	// if connection is down just kill it.
	if (!m_bAvailable)
	{
		TerminateThread(m_hThread, 0);
		return;
	}

	// otherwise, give it a chance to die.
	if (WAIT_TIMEOUT == 
					WaitForSingleObject(m_threadData.m_hDead, m_dwPollInterval))
	{
		OutputDebugString(_T("CConnection::StartMonitor() Timed out - Killing thread.\n"));
		TerminateThread(m_hThread, 0);
	}
}

//////////////////////////////////////////////////////////////////////
// Thread Func: Establish initial connection and check status.
//////////////////////////////////////////////////////////////////////
unsigned int __stdcall CConnection::MonitorConnection(void *pv)
{
	OutputDebugString(_T("CConnection::MonitorNode() New Thread!\n"));

	struct threadData* pData = (struct threadData*)pv;

	HRESULT hRes = pData->m_bkptr->Connect();	// Try to connect first.
	if (FAILED(hRes))
		pData->m_bkptr->NotifyConsole(hRes);

	while (true)
	{
		if (WAIT_OBJECT_0 == WaitForSingleObject(pData->m_hDie, 
													pData->m_bkptr->m_dwPollInterval) )
		{
			SetEvent(pData->m_hDead);
			break;
		}
		// Monitor Managed Node
		pData->m_bkptr->CheckConnection();
	}

	_endthreadex(0);

	return 0;
}

//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Check connection status
//////////////////////////////////////////////////////////////////////
void CConnection::CheckConnection()
{
	OutputDebugString(_T("CConnection::CheckNode()\n"));

	if (m_bAvailable)		// Connection is available
	{										//	Check to see it is still valid.
		if (!PingMachine())
		{									// Connection went down!
			OutputDebugString(_T("CConnection::CheckConnection()-Lost connection!\n"));
			m_hrLastConnectResult = WBEM_E_TRANSPORT_FAILURE;
			SetConnectionStatus(false);	
			NotifyConsole(m_hrLastConnectResult);
			return;
		}
		// Now, check Wbem connection
		m_hrLastConnectResult = m_pIWbemServices->GetObject(0L,0L,0L,0L,0L);
		if (FAILED(m_hrLastConnectResult))
		{
			// Wbem connection is no longer valid!
			OutputDebugString(_T("CConnection::CheckConnection()-Lost wbem connection!\n"));
			SetConnectionStatus(false);	 
			NotifyConsole(m_hrLastConnectResult);
		}
	}
	else
	{
		// Try to re-establish connection
		Connect();
	}
}

//////////////////////////////////////////////////////////////////////
// Connection operations
//////////////////////////////////////////////////////////////////////
HRESULT CConnection::Connect()
{
	OutputDebugString(_T("CConnection::Connect()\n"));

	// zzz
	WaitForSingleObject(m_hReadyToConnect, INFINITE);

	m_hrLastConnectResult = WBEM_E_TRANSPORT_FAILURE;

	// can it be reached?
	if (!PingMachine())
		return m_hrLastConnectResult;

	// now, try to connect to namespace
	m_hrLastConnectResult = ConnectToNamespace();

	if (FAILED(m_hrLastConnectResult))
		return m_hrLastConnectResult;

	// is agent ready?
	if (FAILED(m_hrLastConnectResult = IsAgentReady()))
		return m_hrLastConnectResult;

	// is agent correct version ?
	if( FAILED(m_hrLastConnectResult = IsAgentCorrectVersion()) )
		return m_hrLastConnectResult;

	UnRegisterAllEvents();
	if (SUCCEEDED(m_hrLastConnectResult = RegisterAllEvents()))
	{
		SetConnectionStatus(true);
		NotifyConsole(m_hrLastConnectResult);
	}

	return m_hrLastConnectResult;
}

inline HRESULT CConnection::IsAgentReady()
{
	// check to see if agent providers are ready to service external requests.
	if (!m_pIWbemServices)
		return WBEM_E_TRANSPORT_FAILURE;

	IEnumWbemClassObject* pEnumObj = NULL;
	// HMSystemStatus ready?
	BSTR bsName = SysAllocString(L"Microsoft_HMSystemStatus");	
	HRESULT hRes = m_pIWbemServices->CreateInstanceEnum(bsName,
																											WBEM_FLAG_SHALLOW,
																											NULL,
																											&pEnumObj);
	SysFreeString(bsName);

	if (FAILED(hRes))
	{
		CString sDebugString;
		sDebugString.Format(_T("IsAgentReady()-Agent is unavailable to deliver SystemStatus on %s. Operation failed with result=<%X>."), CString(m_bsMachineName), hRes);
		OutputDebugString(sDebugString);
		return hRes;
	}

	pEnumObj->Release();
	pEnumObj = NULL;

/*
	// HMCatStatus ready?
	SysReAllocString(&bsName, L"HMCatStatus");	
	hRes = m_pIWbemServices->CreateInstanceEnum(bsName,
																							WBEM_FLAG_SHALLOW,
																							NULL,
																							&pEnumObj);
	SysFreeString(bsName);

	if (FAILED(hRes))
		return hRes;

	pEnumObj->Release();
	pEnumObj = NULL;

	// HMMachStatus ready?
	SysReAllocString(&bsName, L"HMMachStatus");	
	hRes = m_pIWbemServices->CreateInstanceEnum(bsName,
																							WBEM_FLAG_SHALLOW,
																							NULL,
																							&pEnumObj);
	SysFreeString(bsName);

	if (FAILED(hRes))
		return hRes;

	pEnumObj->Release();
	pEnumObj = NULL;
*/

	return S_OK;
}

inline HRESULT CConnection::IsAgentCorrectVersion()
{
	// check to see if agent is correct version to service external requests.
	if (!m_pIWbemServices)
		return WBEM_E_TRANSPORT_FAILURE;

	IEnumWbemClassObject* pEnumObj = NULL;

	// HMVersion check

	// enumerate for HMVersion
	BSTR bsName = SysAllocString(L"Microsoft_HMVersion");	
	HRESULT hRes = m_pIWbemServices->CreateInstanceEnum(bsName,
																											WBEM_FLAG_SHALLOW,
																											NULL,
																											&pEnumObj);
	SysFreeString(bsName);

	if (FAILED(hRes))
	{
		CString sDebugString;
		sDebugString.Format(_T("IsAgentCorrectVersion()-Unable to enumerate for Microsoft_HMVersion on system %s. Operation failed with result=<%X>."), CString(m_bsMachineName), hRes);
		OutputDebugString(sDebugString);
		return hRes;
	}

	IWbemClassObject* pObject = NULL;
	ULONG uReturned = 0L;

	hRes = pEnumObj->Next(WBEM_INFINITE,1,&pObject,&uReturned);
  if( FAILED(hRes) || uReturned == 0L )
  {
		pEnumObj->Release();
		pEnumObj = NULL;
		CString sDebugString;
		sDebugString.Format(_T("IsAgentCorrectVersion()-Unable to enumerate for Microsoft_HMVersion on system %s. Operation failed with result=<%X>.\n"), CString(m_bsMachineName), hRes);
		OutputDebugString(sDebugString);
    return hRes;
  }

  VARIANT vPropValue;
  VariantInit(&vPropValue);

	bsName = SysAllocString(L"MajorVersion");	

  hRes = pObject->Get(bsName, 0L, &vPropValue, NULL, NULL);

	SysFreeString(bsName);

  if( FAILED(hRes) )
  {
		pObject->Release();
		pEnumObj->Release();
		pEnumObj = NULL;
		CString sDebugString;
		sDebugString.Format(_T("IsAgentCorrectVersion()-Unable to enumerate for Microsoft_HMVersion on system %s. Operation failed with result=<%X>.\n"), CString(m_bsMachineName), hRes);
		OutputDebugString(sDebugString);
    return hRes;
  }	

  CString sMajorVersion = V_BSTR(&vPropValue);

  VariantClear(&vPropValue);

	if( _ttoi(sMajorVersion) != SCHEMA_MAJOR_VERSION )
	{
		pObject->Release();
		pEnumObj->Release();
		hRes = E_NOTIMPL;
		CString sDebugString;
		sDebugString.Format(_T("IsAgentCorrectVersion()-Incorrect Agent version number on system %s.\n"), CString(m_bsMachineName));
		OutputDebugString(sDebugString);
		return hRes;
	}

  VariantInit(&vPropValue);

	bsName = SysAllocString(L"MinorVersion");	

  hRes = pObject->Get(bsName, 0L, &vPropValue, NULL, NULL);

	SysFreeString(bsName);

  if( FAILED(hRes) )
  {
		pObject->Release();
		pEnumObj->Release();
		pEnumObj = NULL;
		CString sDebugString;
		sDebugString.Format(_T("IsAgentCorrectVersion()-Incorrect Agent version number on system %s.\n"), CString(m_bsMachineName));
		OutputDebugString(sDebugString);
    return hRes;
  }	

  CString sMinorVersion = V_BSTR(&vPropValue);

  VariantClear(&vPropValue);

	if( _ttoi(sMinorVersion) != SCHEMA_MINOR_VERSION )
	{
		pObject->Release();
		pEnumObj->Release();
		hRes = E_NOTIMPL;
		CString sDebugString;
		sDebugString.Format(_T("IsAgentCorrectVersion()-Incorrect Agent version number on system %s.\n"), CString(m_bsMachineName));
		OutputDebugString(sDebugString);
		return hRes;
	}

	pObject->Release();
	pEnumObj->Release();
	pEnumObj = NULL;

	return hRes;
}

inline void CConnection::SetConnectionStatus(BOOL bFlag)
{
	OutputDebugString(_T("CConnection::SetConnectionStatus()\n"));
	if (m_bAvailable != bFlag)
	{
		m_bAvailable = bFlag;
	}
	else
		OutputDebugString(_T("CConnection::SetConnectionStatus()-No change in Connection Status!\n"));
}

inline BOOL CConnection::PingMachine()
{
	OutputDebugString(_T("CConnection::Ping()\n"));
	CPing Pong;
	unsigned long ulIP = Pong.ResolveName(m_bsMachineName);
	if (!Pong.Ping(ulIP,999))
	{
		CString sDebugString;
		sDebugString.Format(_T("PingMachine() failed on system %s.\n"), CString(m_bsMachineName));
		OutputDebugString(sDebugString);
		return false;
	}

	return true;
}

//////////////////////////////////////////////////////////////////////
// Namespace operations
//////////////////////////////////////////////////////////////////////
inline HRESULT CConnection::ConnectToNamespace(BSTR bsNamespace /*= NULL*/)
{
	OutputDebugString(_T("CConnection::ConnectToNamespace()\n"));

	if (m_pIWbemServices)
	{
		m_pIWbemServices->Release();
//		m_pIWbemServices = NULL();
		m_pIWbemServices = NULL;
	}

	HRESULT hRes;
	if( ! bsNamespace )
	{
		bsNamespace = m_sNamespace.AllocSysString();
		hRes = m_pIWbemLocator->ConnectServer(bsNamespace,0L,0L,0L,0L,0L,0L,&m_pIWbemServices);		
		::SysFreeString(bsNamespace);
	}
	else
	{
		hRes = m_pIWbemLocator->ConnectServer(bsNamespace,0L,0L,0L,0L,0L,0L,&m_pIWbemServices);		
	}
	
	return hRes;
}

//////////////////////////////////////////////////////////////////////
// Event Operations
//////////////////////////////////////////////////////////////////////
BOOL CConnection::AddEventEntry(const CString& sQuery, IWbemObjectSink*& pSink)
{
	OutputDebugString(_T("CConnection::AddEventEntry()\n"));

	ASSERT(pSink);
	if( pSink == NULL )
	{
		OutputDebugString(_T("CConnection::AddEventEntry()-pSink is NULL. Failed.\n"));
		return false;
	}
	
	ASSERT(!sQuery.IsEmpty());
	if( sQuery.IsEmpty() )
	{
		OutputDebugString(_T("CConnection::AddEventEntry()-The query string passed is empty. Failed.\n"));
		return false;
	}

	// do not add duplicate event entry.
	for (int i = 0; i < m_EventConsumers.GetSize(); i++)
	{
		if (pSink		== m_EventConsumers[i]->m_pSink &&
				sQuery	== m_EventConsumers[i]->m_sQuery)
				return true;
	}

	CEventRegistrationEntry* pEntry = new CEventRegistrationEntry(sQuery, pSink);
	m_EventConsumers.Add(pEntry);

	if( m_bAvailable )
	{
		BSTR	bsLang	= SysAllocString(L"WQL");
		BSTR	bsQuery = pEntry->m_sQuery.AllocSysString();

		HRESULT hr = m_pIWbemServices->ExecNotificationQueryAsync(bsLang,
																											bsQuery,
																											0L,
																											0L,
																											pEntry->m_pSink);
		::SysFreeString(bsQuery);
		::SysFreeString(bsLang);

		if (SUCCEEDED(hr))
				pEntry->m_bRegistered = true;		
	}

	// zzz
	SetEvent(m_hReadyToConnect);
	return true;
}

BOOL CConnection::RemoveEventEntry(IWbemObjectSink*& pSink)
{
	OutputDebugString(_T("CConnection::RemoveEventEntry()\n"));
	for( int i=0; i < m_EventConsumers.GetSize(); i++ )
	{
		if( pSink == m_EventConsumers[i]->m_pSink )
		{
			CEventRegistrationEntry* pEntry = m_EventConsumers[i];
			ASSERT(pEntry);
			ASSERT_VALID(pEntry);

			if (pEntry->m_bRegistered && m_pIWbemServices && m_bAvailable)
			{
				if (SUCCEEDED(m_pIWbemServices->CancelAsyncCall(pEntry->m_pSink)))
					pEntry->m_bRegistered = false;
			}
			delete pEntry;
			m_EventConsumers.RemoveAt(i);

			return TRUE;
		}
	}
	return TRUE;
}

void CConnection::RemoveAllEventEntries()
{
	OutputDebugString(_T("CConnection::RemoveAllEventEntries()\n"));
	HRESULT hr;
	for (int i=0; i < m_EventConsumers.GetSize(); i++)
	{
		CEventRegistrationEntry* pEntry = m_EventConsumers[i];
		ASSERT(pEntry);
		ASSERT_VALID(pEntry);

		if (pEntry->m_bRegistered && m_pIWbemServices && m_bAvailable)
			hr = m_pIWbemServices->CancelAsyncCall(pEntry->m_pSink);

		delete pEntry;
	}
	m_EventConsumers.RemoveAll();
}

HRESULT CConnection::RegisterAllEvents()
{
	OutputDebugString(_T("CConnection::RegisterAllEvents()\n"));

	// if there's no sink, return server too busy.
	if (!m_EventConsumers.GetSize())
		return WBEM_E_SERVER_TOO_BUSY;

	HRESULT hr = S_OK;
	int i = 0;
	BSTR	bsLang	= SysAllocString(L"WQL");
	for(i=0; i < m_EventConsumers.GetSize(); i++)
	{
		CEventRegistrationEntry* pEntry = m_EventConsumers[i];
		ASSERT(pEntry);
		ASSERT_VALID(pEntry);

		if( pEntry->m_eType != AsyncQuery )
		{
			BSTR	bsQuery = pEntry->m_sQuery.AllocSysString();

      OutputDebugString(_T("\t"));
      OutputDebugString(pEntry->m_sQuery);
      OutputDebugString(_T("\n"));

			hr = m_pIWbemServices->ExecNotificationQueryAsync(bsLang,
																												bsQuery,
																												0L,
																												0L,
																												pEntry->m_pSink);
			::SysFreeString(bsQuery);

			if (SUCCEEDED(hr))
					pEntry->m_bRegistered = true;
			else
				break;
		}
		else
		{
			pEntry->SendInstances(m_pIWbemServices,2);
			m_EventConsumers.RemoveAt(i);
			delete pEntry;
		}
	}
	::SysFreeString(bsLang);
	// Cancel any succeeded calls????
	/*
	i--;
	if (FAILED(hr) && i >= 0)
	{	// cancel succeeded calls
		while(i>=0)
		{
			CEventRegistrationEntry* pEntry = m_EventConsumers[i];
			ASSERT(pEntry);
			ASSERT_VALID(pEntry);
			if (pEntry->m_bRegistered)
			{
				HRESULT hRes = m_pIWbemServices->CancelAsyncCall(pEntry->m_pSink);
				pEntry->m_bRegistered = false;
			}
			i--;
		}
	}
	*/
	return hr;
}

void CConnection::UnRegisterAllEvents()
{
	OutputDebugString(_T("CConnection::UnRegisterAllEvents()\n"));

	for (int i=0; i < m_EventConsumers.GetSize(); i++)
	{
		CEventRegistrationEntry* pEntry = m_EventConsumers[i];
		ASSERT(pEntry);
		ASSERT_VALID(pEntry);
		if (pEntry->m_bRegistered && pEntry->m_eType != AsyncQuery )
		{
			HRESULT hr = m_pIWbemServices->CancelAsyncCall(pEntry->m_pSink);
			pEntry->m_bRegistered = false;
		}
	}
}
//////////////////////////////////////////////////////////////////////
// Console notification
//////////////////////////////////////////////////////////////////////
inline HRESULT CConnection::NotifyConsole(HRESULT hRes)
{
	OutputDebugString(_T("CConnection::NotifyCosole()\n"));

	HRESULT hr = S_OK;
	// Set notify flag appropriately
	long lFlag = 0;
	if (hRes == S_OK)
	{
		if (m_bFirstConnect)
		{
			lFlag = 2;
		}
		else
			lFlag = 1;
	}

	for (int i=0; i < m_EventConsumers.GetSize(); i++)
	{
		CEventRegistrationEntry* pEntry = m_EventConsumers[i];
		ASSERT(pEntry);
		ASSERT_VALID(pEntry);

		// Notify console w/ connection status
		if (i == 0)
			hr = pEntry->NotifyConsole(lFlag, hRes);

		// If connection is bad, no need to continue
		if (hRes != S_OK)
			break;
		
		// Reset first connect flag
		if (SUCCEEDED(hr) && m_bFirstConnect)
				m_bFirstConnect = false;

		HRESULT hr2 = pEntry->SendInstances(m_pIWbemServices, lFlag);
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\extens\oudeleg\util.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       util.cpp
//
//--------------------------------------------------------------------------


#include "pch.h"

#include "resource.h"

#include "util.h"

#include "delegWiz.h"

#include <_util.cpp>

VOID DisplayMessageBox(HWND hwnd, LPWSTR lpszText)
{
    CWString szTitle;
    szTitle.LoadFromResource(IDS_DELEGWIZ_WIZ_TITLE);
    ::MessageBox(hwnd,lpszText, szTitle, MB_OK);
}


//This function checks if current user has read and write
//access to the szObjectPath. If not it shows appropriate 
//Message box.
HRESULT InitCheckAccess( HWND hwndParent, LPCWSTR pszObjectLADPPath )
{
    HRESULT hr = S_OK;
    WCHAR szSDRightsProp[]      = L"sDRightsEffective";
    LPWSTR pProp = (LPWSTR)szSDRightsProp;
    PADS_ATTR_INFO pSDRightsInfo = NULL;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD dwAttributesReturned;
    IDirectoryObject *pDsObject = NULL;
    SECURITY_INFORMATION si = 0;

    //Check Permission to "Read Permission"
    DWORD dwErr = ::GetNamedSecurityInfo(IN const_cast<LPWSTR>(pszObjectLADPPath),
                                         SE_DS_OBJECT_ALL,
                                         DACL_SECURITY_INFORMATION,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &pSecurityDescriptor);
  

    TRACE(L"GetNamedSecurityInfo() returned dwErr = 0x%x\n", dwErr);

    if (dwErr != ERROR_SUCCESS)
	{
        TRACE(L"failed on GetNamedSecurityInfo(): dwErr = 0x%x\n", dwErr);
        WCHAR szMsg[512];
        LoadStringHelper(IDS_DELEGWIZ_ERR_GET_SEC_INFO, szMsg, 512);
		DisplayMessageBox(hwndParent, szMsg);
        hr = HRESULT_FROM_WIN32(dwErr);
		goto exit_gracefully;
	}
    
    // Bind to the object 
    hr = ADsOpenObject(pszObjectLADPPath,
                       (LPWSTR)NULL,
                       (LPWSTR)NULL,
                       ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND,
                       IID_IDirectoryObject,
                       (LPVOID*)&pDsObject);
    if( hr != S_OK )
        goto exit_gracefully;

    // Read the sDRightsEffective property to determine writability
    pDsObject->GetObjectAttributes(  &pProp,
                                     1,
                                     &pSDRightsInfo,
                                     &dwAttributesReturned);
    if (pSDRightsInfo)
    {
        si = pSDRightsInfo->pADsValues->Integer;
        FreeADsMem(pSDRightsInfo);
    }
    else
    {
        //
        // Note that GetObjectAttributes commonly returns S_OK even when
        // it fails, so the HRESULT is basically useless here.
        //
        // This can fail if we don't have read_property access, which can
        // happen when an admin is trying to restore access to an object
        // that has had all access removed or denied
        //
        // Assume we can write the Owner and DACL. If not, the worst that
        // happens is the user gets an "Access Denied" message when trying
        // to save changes.
        //
        si = DACL_SECURITY_INFORMATION;
    }

    if( !(si & DACL_SECURITY_INFORMATION) )
	{
		TRACE(L"failed on SetNamedSecurityInfo(): dwErr = 0x%x\n", dwErr);
        WCHAR szMsg[512];
        LoadStringHelper(IDS_DELEGWIZ_ERR_ACCESS_DENIED, szMsg, 512);
		DisplayMessageBox(hwndParent, szMsg);
        hr = !S_OK;
	}


exit_gracefully:
     if( pSecurityDescriptor )
        LocalFree(pSecurityDescriptor);
    if( pDsObject )
        pDsObject->Release();
    return hr;
}


DWORD
FormatStringID(LPTSTR *ppszResult, UINT idStr , ...)
{
    va_list args;
    va_start(args, idStr);
	TCHAR szFormat[1024];
	LoadStringHelper(idStr, szFormat, ARRAYSIZE(szFormat));
    return FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                         szFormat,
                         0,
                         0,
                         (LPTSTR)ppszResult,
                         1,
                         &args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\connmgr\source\connectionmanager.h ===
// ConnectionManager.h : Declaration of the CConnectionManager

#ifndef __CONNECTIONMANAGER_H_
#define __CONNECTIONMANAGER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CConnectionManager
class ATL_NO_VTABLE CConnectionManager : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CConnectionManager, &CLSID_ConnectionManager>,
	public IConnectionManager
{
public:
	CConnectionManager();

	virtual ~CConnectionManager();

DECLARE_REGISTRY_RESOURCEID(IDR_CONNECTIONMANAGER)

BEGIN_COM_MAP(CConnectionManager)
	COM_INTERFACE_ENTRY(IConnectionManager)
END_COM_MAP()


// IConnectionManager
public:
	STDMETHOD(RegisterEventNotification)
											(/*[in]*/BSTR bsMachineName, 
											 /*[in]*/BSTR bsQuery, 
											 /*[in]*/IWbemObjectSink* pSink);

	STDMETHOD(GetConnection)
											(/*[in]*/BSTR bsMachineName, 
											 /*[out]*/IWbemServices __RPC_FAR *__RPC_FAR * ppIWbemServices, 
											 /*[out]*/long* lStatus);

	STDMETHOD(RemoveConnection)
											(/*[in]*/ BSTR bsMachineName,
											 /*[in]*/IWbemObjectSink* pSink);

// CComObjectRootEx
	HRESULT FinalConstruct();
	void		FinalRelease();

// Create/Destroy
public:
	STDMETHOD(ConnectToNamespace)(BSTR bsNamespace, IWbemServices** ppService);
	STDMETHOD(ExecQueryAsync)(/*[in]*/BSTR bsMachineName, /*[in]*/BSTR bsQuery, /*[in]*/IWbemObjectSink* pSink);
  void Destroy();

// Implementation Operations
protected:

  HRESULT CreateLocator();
	BOOL		ValidMachine(BSTR& bsMachine);

  CTypedPtrMap<CMapStringToPtr,CString,CConnection*> m_ConnectionMap;
  IWbemLocator* m_pIWbemLocator;
};

#endif //__CONNECTIONMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\connmgr\source\connectionmanager.cpp ===
// ConnectionManager.cpp : Implementation of CConnectionManager
#include "stdafx.h"
#include "Connection.h"
#include "ConnMgr.h"
#include "ConnectionManager.h"

#include <process.h>
#include "Ping.h"
/////////////////////////////////////////////////////////////////////////////
// CConnectionManager

/////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CConnectionManager::CConnectionManager()
{
	OutputDebugString(_T("CConnectionManager::CConnectionManager()\n"));
}

CConnectionManager::~CConnectionManager()
{
	OutputDebugString(_T("CConnectionManager::~CConnectionManager()\n"));
}

/////////////////////////////////////////////////////////////////////////////
// Final Construct and Release

HRESULT CConnectionManager::FinalConstruct()
{
	OutputDebugString(_T("CConnectionManager::FinalConstruct()\n"));

	HRESULT hRes = CreateLocator();

	return hRes;
}

void CConnectionManager::FinalRelease()
{
	OutputDebugString(_T("CConnectionManager::FinalRelease()\n"));

	Destroy();
}

/////////////////////////////////////////////////////////////////////////////
// Startup/Termination

HRESULT CConnectionManager::CreateLocator()
{
  OutputDebugString(_T("CConnectionManager::CreateLocator()\n"));

	m_pIWbemLocator = NULL;

	HRESULT hr = CoCreateInstance(CLSID_WbemLocator,
																NULL,
																CLSCTX_INPROC_SERVER,
																IID_IWbemLocator,
																(LPVOID*)&m_pIWbemLocator);

	if (FAILED(hr))
	{
    OutputDebugString(_T("Failed to create Locator !"));
    return hr;
  }

  ASSERT(m_pIWbemLocator);

  return hr;  
}

void CConnectionManager::Destroy()
{
  OutputDebugString(_T("CConnectionManager::Destroy()\n"));

  // destroy all the connections laying around
  POSITION pos = m_ConnectionMap.GetStartPosition();
  CConnection* pConnection = NULL;
  CString sName;
  while( pos != NULL )
  {    
    m_ConnectionMap.GetNextAssoc( pos, sName, pConnection);
    ASSERT(pConnection);
    ASSERT_VALID(pConnection);
    if( pConnection )
      delete pConnection;
  }

  m_ConnectionMap.RemoveAll();

  if( m_pIWbemLocator )
  {
    m_pIWbemLocator->Release();
    m_pIWbemLocator = NULL;
  }
}

/////////////////////////////////////////////////////////////////////////////
// Helper functions
BOOL CConnectionManager::ValidMachine(BSTR& bsMachine)
{
  OutputDebugString(_T("CConnection::ValidateMachine()\n"));
	CPing Pong;

	// Resolve the machine name to see it is valid
	unsigned long ulIP = Pong.ResolveName(bsMachine);
	if( ulIP == 0L )
	{
		CString sDebugString;
		sDebugString.Format(_T("Could not resolve hostname for <%s>.\n"), CString(bsMachine));
		OutputDebugString(sDebugString);
		return false;
	}

	return true;
}
/////////////////////////////////////////////////////////////////////////////
// Interface Methods.

STDMETHODIMP CConnectionManager::GetConnection(BSTR bsMachineName, 
																							 IWbemServices __RPC_FAR *__RPC_FAR * ppIWbemServices,
																							 long* lStatus)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CString sDebugString;
	sDebugString.Format(_T("CConnectionManager::GetConnection() for %s.\n"), CString(bsMachineName));
	OutputDebugString(sDebugString);
	

	*ppIWbemServices	= NULL;
	*lStatus					= 0;

	// if connection is already in the map, return it.
  CConnection* pConnection = NULL;

  if( m_ConnectionMap.Lookup(bsMachineName,pConnection) != 0 )
  {	
    ASSERT(pConnection);
    ASSERT_VALID(pConnection);

    if( pConnection->m_bAvailable)
    {
      *ppIWbemServices = pConnection->m_pIWbemServices;
			(*ppIWbemServices)->AddRef();	
      *lStatus = 1;
    }
    else
    {
			sDebugString.Format(_T("GetConnection(%s)-Connection is unavailable. Last connect attempt result=<%X>.\n"), CString(bsMachineName), pConnection->m_hrLastConnectResult);
			OutputDebugString(sDebugString);
    }
		return pConnection->m_hrLastConnectResult;
  }

	// if not valid, do not add it the map
	if (!ValidMachine(bsMachineName))
		return E_FAIL;

	// otherwise create a new connection.
 	pConnection = new CConnection(bsMachineName, m_pIWbemLocator);
	m_ConnectionMap.SetAt(bsMachineName,pConnection);

	return S_OK;
}

STDMETHODIMP CConnectionManager::RemoveConnection(BSTR bsMachineName,IWbemObjectSink * pSink)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	OutputDebugString(_T("CConnectionManager::RemoveConnection()\n"));

  CConnection* pConnection = NULL;

	if( m_ConnectionMap.Lookup(bsMachineName,pConnection) != 0 )
	{
		ASSERT(pConnection);
    ASSERT_VALID(pConnection);

    if( pConnection == NULL )
		{
			return E_FAIL;
		}

		if (pSink)
			pConnection->RemoveEventEntry(pSink);

		if( pConnection->GetEventConsumerCount() == 0 )
		{			
			if (!m_ConnectionMap.RemoveKey(bsMachineName))
				OutputDebugString(_T("CConnectionManager::RemoveConnection() - Failed to Remove Connection!\n"));
			delete pConnection;
		}
	}

	return S_OK;
}

STDMETHODIMP CConnectionManager::RegisterEventNotification(BSTR bsMachineName, 
																														BSTR bsQuery, 
																														IWbemObjectSink * pSink)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	OutputDebugString(_T("CConnectionManager::RegisterEventNotification()\n"));

	ASSERT(pSink);

  CConnection* pConnection = NULL;
  if( m_ConnectionMap.Lookup(bsMachineName,pConnection) == 0 )
	{
		OutputDebugString(_T("CConnectionManager::RegisterEventNotification()-Failed to find connection\n"));
		return E_FAIL;
	}

	ASSERT(pConnection);

	BOOL bResultRegister = pConnection->AddEventEntry(bsQuery,pSink);

	if (!bResultRegister)
	{
		OutputDebugString(_T("CConnectionManager::RegisterEventNotification()-Failed to add event.\n"));
		return E_FAIL;
	}

	return S_OK;
}

STDMETHODIMP CConnectionManager::ExecQueryAsync(BSTR bsMachineName, BSTR bsQuery, IWbemObjectSink *pSink)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	OutputDebugString(_T("CConnectionManager::ExecQueryAsync()\n"));

	ASSERT(pSink);

  CConnection* pConnection = NULL;
  if( m_ConnectionMap.Lookup(bsMachineName,pConnection) == 0 )
	{
		OutputDebugString(_T("CConnectionManager::ExecQueryAsync()-Failed to find connection\n"));
		return E_FAIL;
	}

	ASSERT(pConnection);
	HRESULT hRes = S_OK;

	if( pConnection->m_bAvailable )
	{
		OutputDebugString(_T("ExecQueryAsync - connection available\n"));
		ASSERT(pConnection->m_pIWbemServices);
		BSTR bsLanguage = SysAllocString(_T("WQL"));
		hRes = pConnection->m_pIWbemServices->ExecQueryAsync(bsLanguage, bsQuery, WBEM_FLAG_BIDIRECTIONAL, NULL, pSink);
		SysFreeString(bsLanguage);
		CString sDebugString;
		sDebugString.Format(_T("ExecQueryAsync returns %x\n"),hRes);
		OutputDebugString(sDebugString);
	}
	else
	{
		OutputDebugString(_T("ExecQueryAsync - no connection available\n"));

		BOOL bResultRegister = pConnection->AddEventEntry(bsQuery,pSink);

		if (!bResultRegister)
		{
			OutputDebugString(_T("CConnectionManager::ExecQueryAsync()-Failed to add event.\n"));
			return E_FAIL;
		}
	}

	return hRes;
}

STDMETHODIMP CConnectionManager::ConnectToNamespace(BSTR bsNamespace, IWbemServices __RPC_FAR *__RPC_FAR * ppIWbemServices)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	hr = m_pIWbemLocator->ConnectServer(bsNamespace,0L,0L,0L,0L,0L,0L,ppIWbemServices);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\connmgr\source\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\connmgr\source\connmgr.cpp ===
// ConnMgr.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f ConnMgrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "Connection.h"
#include "ConnMgr.h"

#include "ConnMgr_i.c"
#include "ConnectionManager.h"

class CConnApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int	 ExitInstance();
	BOOL	InitCOMSecurity();
};

CConnApp theApp;


LONG CExeModule::Unlock()
{
	LONG l = CComModule::Unlock();
	if (l == 0)
	{
#if _WIN32_WINNT >= 0x0400
		if (CoSuspendClassObjects() == S_OK)
			PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#else
		PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#endif
	}
	return l;
}

HRESULT CExeModule::UpdateRegistry(LPCOLESTR lpszRes, BOOL bRegister)
{
	USES_CONVERSION;

	CComPtr<IRegistrar> p;

	HRESULT hRes = CoCreateInstance(CLSID_Registrar, NULL,
																	CLSCTX_INPROC_SERVER, 
																	IID_IRegistrar, (void**)&p);
	if (FAILED(hRes))
	{
		AfxMessageBox(_T("Failed to create ATL Registrar! Try updated version of ATL.DLL."));
		return hRes;
	}

	_ATL_MODULE* pM = this;
	
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(pM->m_hInst, szModule, _MAX_PATH);
	p->AddReplacement(OLESTR("Module"), T2OLE(szModule));

	LPCOLESTR szType = OLESTR("REGISTRY");
	GetModuleFileName(pM->m_hInstResource, szModule, _MAX_PATH);
	LPOLESTR pszModule = T2OLE(szModule);
#ifdef SAVE
	if (HIWORD(lpszRes)==0)
	{
		if (bRegister)
			hRes = p->ResourceRegister(pszModule, ((UINT)LOWORD((DWORD)lpszRes)), szType);
		else
			hRes = p->ResourceUnregister(pszModule, ((UINT)LOWORD((DWORD)lpszRes)), szType);
	}
	else
	{
#endif
		if (bRegister)
			hRes = p->ResourceRegisterSz(pszModule, lpszRes, szType);
		else
			hRes = p->ResourceUnregisterSz(pszModule, lpszRes, szType);
#ifdef SAVE
	}
#endif
	return hRes;

}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_ConnectionManager, CConnectionManager)
END_OBJECT_MAP()

LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
	while (*p1 != NULL)
	{
		LPCTSTR p = p2;
		while (*p != NULL)
		{
			if (*p1 == *p++)
				return p1+1;
		}
		p1++;
	}
	return NULL;
}

BOOL CConnApp::InitCOMSecurity()
{
	HRESULT hRes = CoInitializeSecurity(NULL, -1, NULL, NULL,
																		RPC_C_AUTHN_LEVEL_CONNECT,
																		RPC_C_IMP_LEVEL_IMPERSONATE,
																		NULL,
																		EOAC_NONE,
																		NULL);
	if (FAILED(hRes))
		return false;
	

	return true;
}


BOOL CConnApp::InitInstance()     
{
	// CG: The following block was added by the Windows Sockets component.
	{
		if (!AfxSocketInit())
		{
			AfxMessageBox(CG_IDS_SOCKETS_INIT_FAILED);
			return FALSE;
		}

	}
	// Initialize OLE libraries 
	HRESULT hr = CoInitializeEx(NULL,COINIT_MULTITHREADED);
	if (FAILED(hr))
	{
		AfxMessageBox(_T("OLE Initialization Failed!"));
		return FALSE;        
	}

	// Initialize COM Security
	if (!InitCOMSecurity())        
	{
		AfxMessageBox(_T("Security Initialization Failed!"));
		return FALSE;        
	}
	

	// Initialize the ATL Module
  _Module.Init(ObjectMap,m_hInstance);
  
	_Module.dwThreadID = GetCurrentThreadId();

#ifdef _AFXDLL
	Enable3dControls(); // Call this when using MFC in a shared DLL
#else        
	Enable3dControlsStatic(); 
#endif

	// Check command line arguments
	TCHAR szTokens[] = _T("-/");
	BOOL	bRun = TRUE;
	LPCTSTR lpszToken = FindOneOf(m_lpCmdLine, szTokens);
	while (lpszToken != NULL)
	{
		// Register ATL/MFC class factories
		if (lstrcmpi(lpszToken, _T("Embedding")) == 0 ||
				lstrcmpi(lpszToken, _T("Automation")) == 0)
		{
			AfxOleSetUserCtrl(FALSE);
			break;
		}
		else if (lstrcmpi(lpszToken, _T("UnregServer")) == 0)
		{
			_Module.UpdateRegistryFromResource(IDR_ConnMgr, FALSE);
//			_Module.UpdateRegistry((LPCOLESTR)MAKEINTRESOURCE(IDR_CONNECTIONMANAGER), false);
			_Module.UpdateRegistry(_T("connectionmanager.rgs"), false);

			bRun = FALSE;
			break;
		}
		else if (lstrcmpi(lpszToken, _T("RegServer")) == 0)
		{
			_Module.UpdateRegistryFromResource(IDR_ConnMgr, TRUE);
//			_Module.UpdateRegistry((LPCOLESTR)MAKEINTRESOURCE(IDR_CONNECTIONMANAGER), true);
			_Module.UpdateRegistry(_T("connectionmanager.rgs"), true);
			COleObjectFactory::UpdateRegistryAll();
			bRun = FALSE;
			break;
		}
		lpszToken = FindOneOf(lpszToken, szTokens);
	}

	if (bRun)
	{
		_Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER,REGCLS_MULTIPLEUSE);
		COleObjectFactory::RegisterAll();
	}

	return TRUE;
}

int CConnApp::ExitInstance()     
{
	CoUninitialize();
	// MFC's class factories registration is
  // automatically revoked by MFC itself
  _Module.RevokeClassObjects(); 
	
	// Revoke class factories for ATL
  _Module.Term();               
	
	// cleanup ATL Global Module
	CoUninitialize();
        
	return CWinApp::ExitInstance();  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\connmgr\source\connmgrex.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Mon Jul 20 15:14:02 1998
 */
/* Compiler settings for connmgrex.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __connmgrex_h__
#define __connmgrex_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWbemClassObject_FWD_DEFINED__
#define __IWbemClassObject_FWD_DEFINED__
typedef interface IWbemClassObject IWbemClassObject;
#endif 	/* __IWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemObjectAccess_FWD_DEFINED__
#define __IWbemObjectAccess_FWD_DEFINED__
typedef interface IWbemObjectAccess IWbemObjectAccess;
#endif 	/* __IWbemObjectAccess_FWD_DEFINED__ */


#ifndef __IWbemQualifierSet_FWD_DEFINED__
#define __IWbemQualifierSet_FWD_DEFINED__
typedef interface IWbemQualifierSet IWbemQualifierSet;
#endif 	/* __IWbemQualifierSet_FWD_DEFINED__ */


#ifndef __IWbemServices_FWD_DEFINED__
#define __IWbemServices_FWD_DEFINED__
typedef interface IWbemServices IWbemServices;
#endif 	/* __IWbemServices_FWD_DEFINED__ */


#ifndef __IWbemLocator_FWD_DEFINED__
#define __IWbemLocator_FWD_DEFINED__
typedef interface IWbemLocator IWbemLocator;
#endif 	/* __IWbemLocator_FWD_DEFINED__ */


#ifndef __IWbemObjectSink_FWD_DEFINED__
#define __IWbemObjectSink_FWD_DEFINED__
typedef interface IWbemObjectSink IWbemObjectSink;
#endif 	/* __IWbemObjectSink_FWD_DEFINED__ */


#ifndef __IEnumWbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef interface IEnumWbemClassObject IEnumWbemClassObject;
#endif 	/* __IEnumWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef interface IWbemCallResult IWbemCallResult;
#endif 	/* __IWbemCallResult_FWD_DEFINED__ */


#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef interface IWbemContext IWbemContext;
#endif 	/* __IWbemContext_FWD_DEFINED__ */


#ifndef __IUnsecuredApartment_FWD_DEFINED__
#define __IUnsecuredApartment_FWD_DEFINED__
typedef interface IUnsecuredApartment IUnsecuredApartment;
#endif 	/* __IUnsecuredApartment_FWD_DEFINED__ */


#ifndef __WbemLocator_FWD_DEFINED__
#define __WbemLocator_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemLocator WbemLocator;
#else
typedef struct WbemLocator WbemLocator;
#endif /* __cplusplus */

#endif 	/* __WbemLocator_FWD_DEFINED__ */


#ifndef __WbemContext_FWD_DEFINED__
#define __WbemContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemContext WbemContext;
#else
typedef struct WbemContext WbemContext;
#endif /* __cplusplus */

#endif 	/* __WbemContext_FWD_DEFINED__ */


#ifndef __UnsecuredApartment_FWD_DEFINED__
#define __UnsecuredApartment_FWD_DEFINED__

#ifdef __cplusplus
typedef class UnsecuredApartment UnsecuredApartment;
#else
typedef struct UnsecuredApartment UnsecuredApartment;
#endif /* __cplusplus */

#endif 	/* __UnsecuredApartment_FWD_DEFINED__ */


#ifndef __IWbemClassObject_FWD_DEFINED__
#define __IWbemClassObject_FWD_DEFINED__
typedef interface IWbemClassObject IWbemClassObject;
#endif 	/* __IWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemQualifierSet_FWD_DEFINED__
#define __IWbemQualifierSet_FWD_DEFINED__
typedef interface IWbemQualifierSet IWbemQualifierSet;
#endif 	/* __IWbemQualifierSet_FWD_DEFINED__ */


#ifndef __IWbemLocator_FWD_DEFINED__
#define __IWbemLocator_FWD_DEFINED__
typedef interface IWbemLocator IWbemLocator;
#endif 	/* __IWbemLocator_FWD_DEFINED__ */


#ifndef __IWbemObjectSink_FWD_DEFINED__
#define __IWbemObjectSink_FWD_DEFINED__
typedef interface IWbemObjectSink IWbemObjectSink;
#endif 	/* __IWbemObjectSink_FWD_DEFINED__ */


#ifndef __IEnumWbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef interface IEnumWbemClassObject IEnumWbemClassObject;
#endif 	/* __IEnumWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef interface IWbemContext IWbemContext;
#endif 	/* __IWbemContext_FWD_DEFINED__ */


#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef interface IWbemCallResult IWbemCallResult;
#endif 	/* __IWbemCallResult_FWD_DEFINED__ */


#ifndef __IWbemServices_FWD_DEFINED__
#define __IWbemServices_FWD_DEFINED__
typedef interface IWbemServices IWbemServices;
#endif 	/* __IWbemServices_FWD_DEFINED__ */


#ifndef __IWbemObjectAccess_FWD_DEFINED__
#define __IWbemObjectAccess_FWD_DEFINED__
typedef interface IWbemObjectAccess IWbemObjectAccess;
#endif 	/* __IWbemObjectAccess_FWD_DEFINED__ */


#ifndef __IUnsecuredApartment_FWD_DEFINED__
#define __IUnsecuredApartment_FWD_DEFINED__
typedef interface IUnsecuredApartment IUnsecuredApartment;
#endif 	/* __IUnsecuredApartment_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __WbemClient_v1_LIBRARY_DEFINED__
#define __WbemClient_v1_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: WbemClient_v1
 * at Mon Jul 20 15:14:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid] */ 












typedef /* [v1_enum] */ 
enum tag_WBEM_GENUS_TYPE
    {	WBEM_GENUS_CLASS	= 1,
	WBEM_GENUS_INSTANCE	= 2
    }	WBEM_GENUS_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_CHANGE_FLAG_TYPE
    {	WBEM_FLAG_CREATE_OR_UPDATE	= 0,
	WBEM_FLAG_UPDATE_ONLY	= 0x1,
	WBEM_FLAG_CREATE_ONLY	= 0x2
    }	WBEM_CHANGE_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_GENERIC_FLAG_TYPE
    {	WBEM_FLAG_RETURN_IMMEDIATELY	= 0x10,
	WBEM_FLAG_RETURN_WBEM_COMPLETE	= 0,
	WBEM_FLAG_BIDIRECTIONAL	= 0,
	WBEM_FLAG_FORWARD_ONLY	= 0x20,
	WBEM_FLAG_NO_ERROR_OBJECT	= 0x40,
	WBEM_FLAG_RETURN_ERROR_OBJECT	= 0,
	WBEM_FLAG_SEND_STATUS	= 0x80,
	WBEM_FLAG_DONT_SEND_STATUS	= 0,
	WBEM_FLAG_ENSURE_LOCATABLE	= 0x100,
	WBEM_FLAG_SEND_ONLY_SELECTED	= 0,
	WBEM_RETURN_WHEN_COMPLETE	= 0,
	WBEM_RETURN_IMMEDIATELY	= 0x10
    }	WBEM_GENERIC_FLAG_TYPE;

typedef 
enum tag_WBEM_STATUS_TYPE
    {	WBEM_STATUS_COMPLETE	= 0,
	WBEM_STATUS_REQUIREMENTS	= 1,
	WBEM_STATUS_PROGRESS	= 2
    }	WBEM_STATUS_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_TIMEOUT_TYPE
    {	WBEM_NO_WAIT	= 0,
	WBEM_INFINITE	= 0xffffffff
    }	WBEM_TIMEOUT_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_CONDITION_FLAG_TYPE
    {	WBEM_FLAG_ALWAYS	= 0,
	WBEM_FLAG_ONLY_IF_TRUE	= 0x1,
	WBEM_FLAG_ONLY_IF_FALSE	= 0x2,
	WBEM_FLAG_ONLY_IF_IDENTICAL	= 0x3,
	WBEM_MASK_PRIMARY_CONDITION	= 0x3,
	WBEM_FLAG_KEYS_ONLY	= 0x4,
	WBEM_FLAG_REFS_ONLY	= 0x8,
	WBEM_FLAG_LOCAL_ONLY	= 0x10,
	WBEM_FLAG_PROPAGATED_ONLY	= 0x20,
	WBEM_FLAG_SYSTEM_ONLY	= 0x30,
	WBEM_FLAG_NONSYSTEM_ONLY	= 0x40,
	WBEM_MASK_CONDITION_ORIGIN	= 0x70
    }	WBEM_CONDITION_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_FLAVOR_TYPE
    {	WBEM_FLAVOR_DONT_PROPAGATE	= 0,
	WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE	= 0x1,
	WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS	= 0x2,
	WBEM_FLAVOR_MASK_PROPAGATION	= 0xf,
	WBEM_FLAVOR_OVERRIDABLE	= 0,
	WBEM_FLAVOR_NOT_OVERRIDABLE	= 0x10,
	WBEM_FLAVOR_MASK_PERMISSIONS	= 0x10,
	WBEM_FLAVOR_ORIGIN_LOCAL	= 0,
	WBEM_FLAVOR_ORIGIN_PROPAGATED	= 0x20,
	WBEM_FLAVOR_ORIGIN_SYSTEM	= 0x40,
	WBEM_FLAVOR_MASK_ORIGIN	= 0x60
    }	WBEM_FLAVOR_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_QUERY_FLAG_TYPE
    {	WBEM_FLAG_DEEP	= 0,
	WBEM_FLAG_SHALLOW	= 1,
	WBEM_FLAG_PROTOTYPE	= 2
    }	WBEM_QUERY_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_LIMITATION_FLAG_TYPE
    {	WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS	= 0x10,
	WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS	= 0x20
    }	WBEM_LIMITATION_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_TEXT_FLAG_TYPE
    {	WBEM_FLAG_NO_FLAVORS	= 0x1
    }	WBEM_TEXT_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_COMPARISON_FLAG
    {	WBEM_COMPARISON_INCLUDE_ALL	= 0,
	WBEM_FLAG_IGNORE_QUALIFIERS	= 0x1,
	WBEM_FLAG_IGNORE_OBJECT_SOURCE	= 0x2,
	WBEM_FLAG_IGNORE_DEFAULT_VALUES	= 0x4,
	WBEM_FLAG_IGNORE_CLASS	= 0x8,
	WBEM_FLAG_IGNORE_CASE	= 0x10,
	WBEM_FLAG_IGNORE_FLAVOR	= 0x20
    }	WBEM_COMPARISON_FLAG;

typedef /* [v1_enum] */ 
enum tag_WBEM_LOCKING
    {	WBEM_FLAG_ALLOW_READ	= 0x1
    }	WBEM_LOCKING_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_CIMTYPE_ENUMERATION
    {	CIM_ILLEGAL	= 0xfff,
	CIM_EMPTY	= 0,
	CIM_SINT8	= 16,
	CIM_UINT8	= 17,
	CIM_SINT16	= 2,
	CIM_UINT16	= 18,
	CIM_SINT32	= 3,
	CIM_UINT32	= 19,
	CIM_SINT64	= 20,
	CIM_UINT64	= 21,
	CIM_REAL32	= 4,
	CIM_REAL64	= 5,
	CIM_BOOLEAN	= 11,
	CIM_STRING	= 8,
	CIM_DATETIME	= 101,
	CIM_REFERENCE	= 102,
	CIM_CHAR16	= 103,
	CIM_OBJECT	= 13,
	CIM_FLAG_ARRAY	= 0x2000
    }	CIMTYPE_ENUMERATION;

typedef long CIMTYPE;

typedef /* [v1_enum] */ 
enum tag_WBEMSTATUS
    {	WBEM_NO_ERROR	= 0,
	WBEM_S_NO_ERROR	= 0,
	WBEM_S_SAME	= 0,
	WBEM_S_FALSE	= 1,
	WBEM_S_ALREADY_EXISTS	= 0x40001,
	WBEM_S_RESET_TO_DEFAULT	= WBEM_S_ALREADY_EXISTS + 1,
	WBEM_S_DIFFERENT	= WBEM_S_RESET_TO_DEFAULT + 1,
	WBEM_S_TIMEDOUT	= WBEM_S_DIFFERENT + 1,
	WBEM_S_NO_MORE_DATA	= WBEM_S_TIMEDOUT + 1,
	WBEM_S_OPERATION_CANCELLED	= WBEM_S_NO_MORE_DATA + 1,
	WBEM_S_PENDING	= WBEM_S_OPERATION_CANCELLED + 1,
	WBEM_S_DUPLICATE_OBJECTS	= WBEM_S_PENDING + 1,
	WBEM_E_FAILED	= 0x80041001,
	WBEM_E_NOT_FOUND	= WBEM_E_FAILED + 1,
	WBEM_E_ACCESS_DENIED	= WBEM_E_NOT_FOUND + 1,
	WBEM_E_PROVIDER_FAILURE	= WBEM_E_ACCESS_DENIED + 1,
	WBEM_E_TYPE_MISMATCH	= WBEM_E_PROVIDER_FAILURE + 1,
	WBEM_E_OUT_OF_MEMORY	= WBEM_E_TYPE_MISMATCH + 1,
	WBEM_E_INVALID_CONTEXT	= WBEM_E_OUT_OF_MEMORY + 1,
	WBEM_E_INVALID_PARAMETER	= WBEM_E_INVALID_CONTEXT + 1,
	WBEM_E_NOT_AVAILABLE	= WBEM_E_INVALID_PARAMETER + 1,
	WBEM_E_CRITICAL_ERROR	= WBEM_E_NOT_AVAILABLE + 1,
	WBEM_E_INVALID_STREAM	= WBEM_E_CRITICAL_ERROR + 1,
	WBEM_E_NOT_SUPPORTED	= WBEM_E_INVALID_STREAM + 1,
	WBEM_E_INVALID_SUPERCLASS	= WBEM_E_NOT_SUPPORTED + 1,
	WBEM_E_INVALID_NAMESPACE	= WBEM_E_INVALID_SUPERCLASS + 1,
	WBEM_E_INVALID_OBJECT	= WBEM_E_INVALID_NAMESPACE + 1,
	WBEM_E_INVALID_CLASS	= WBEM_E_INVALID_OBJECT + 1,
	WBEM_E_PROVIDER_NOT_FOUND	= WBEM_E_INVALID_CLASS + 1,
	WBEM_E_INVALID_PROVIDER_REGISTRATION	= WBEM_E_PROVIDER_NOT_FOUND + 1,
	WBEM_E_PROVIDER_LOAD_FAILURE	= WBEM_E_INVALID_PROVIDER_REGISTRATION + 1,
	WBEM_E_INITIALIZATION_FAILURE	= WBEM_E_PROVIDER_LOAD_FAILURE + 1,
	WBEM_E_TRANSPORT_FAILURE	= WBEM_E_INITIALIZATION_FAILURE + 1,
	WBEM_E_INVALID_OPERATION	= WBEM_E_TRANSPORT_FAILURE + 1,
	WBEM_E_INVALID_QUERY	= WBEM_E_INVALID_OPERATION + 1,
	WBEM_E_INVALID_QUERY_TYPE	= WBEM_E_INVALID_QUERY + 1,
	WBEM_E_ALREADY_EXISTS	= WBEM_E_INVALID_QUERY_TYPE + 1,
	WBEM_E_OVERRIDE_NOT_ALLOWED	= WBEM_E_ALREADY_EXISTS + 1,
	WBEM_E_PROPAGATED_QUALIFIER	= WBEM_E_OVERRIDE_NOT_ALLOWED + 1,
	WBEM_E_PROPAGATED_PROPERTY	= WBEM_E_PROPAGATED_QUALIFIER + 1,
	WBEM_E_UNEXPECTED	= WBEM_E_PROPAGATED_PROPERTY + 1,
	WBEM_E_ILLEGAL_OPERATION	= WBEM_E_UNEXPECTED + 1,
	WBEM_E_CANNOT_BE_KEY	= WBEM_E_ILLEGAL_OPERATION + 1,
	WBEM_E_INCOMPLETE_CLASS	= WBEM_E_CANNOT_BE_KEY + 1,
	WBEM_E_INVALID_SYNTAX	= WBEM_E_INCOMPLETE_CLASS + 1,
	WBEM_E_NONDECORATED_OBJECT	= WBEM_E_INVALID_SYNTAX + 1,
	WBEM_E_READ_ONLY	= WBEM_E_NONDECORATED_OBJECT + 1,
	WBEM_E_PROVIDER_NOT_CAPABLE	= WBEM_E_READ_ONLY + 1,
	WBEM_E_CLASS_HAS_CHILDREN	= WBEM_E_PROVIDER_NOT_CAPABLE + 1,
	WBEM_E_CLASS_HAS_INSTANCES	= WBEM_E_CLASS_HAS_CHILDREN + 1,
	WBEM_E_QUERY_NOT_IMPLEMENTED	= WBEM_E_CLASS_HAS_INSTANCES + 1,
	WBEM_E_ILLEGAL_NULL	= WBEM_E_QUERY_NOT_IMPLEMENTED + 1,
	WBEM_E_INVALID_QUALIFIER_TYPE	= WBEM_E_ILLEGAL_NULL + 1,
	WBEM_E_INVALID_PROPERTY_TYPE	= WBEM_E_INVALID_QUALIFIER_TYPE + 1,
	WBEM_E_VALUE_OUT_OF_RANGE	= WBEM_E_INVALID_PROPERTY_TYPE + 1,
	WBEM_E_CANNOT_BE_SINGLETON	= WBEM_E_VALUE_OUT_OF_RANGE + 1,
	WBEM_E_INVALID_CIM_TYPE	= WBEM_E_CANNOT_BE_SINGLETON + 1,
	WBEM_E_INVALID_METHOD	= WBEM_E_INVALID_CIM_TYPE + 1,
	WBEM_E_INVALID_METHOD_PARAMETERS	= WBEM_E_INVALID_METHOD + 1,
	WBEM_E_SYSTEM_PROPERTY	= WBEM_E_INVALID_METHOD_PARAMETERS + 1,
	WBEM_E_INVALID_PROPERTY	= WBEM_E_SYSTEM_PROPERTY + 1,
	WBEM_E_CALL_CANCELLED	= WBEM_E_INVALID_PROPERTY + 1,
	WBEM_E_SHUTTING_DOWN	= WBEM_E_CALL_CANCELLED + 1,
	WBEM_E_PROPAGATED_METHOD	= WBEM_E_SHUTTING_DOWN + 1,
	WBEM_E_UNSUPPORTED_PARAMETER	= WBEM_E_PROPAGATED_METHOD + 1,
	WBEM_E_MISSING_PARAMETER_ID	= WBEM_E_UNSUPPORTED_PARAMETER + 1,
	WBEM_E_INVALID_PARAMETER_ID	= WBEM_E_MISSING_PARAMETER_ID + 1,
	WBEM_E_NONCONSECUTIVE_PARAMETER_IDS	= WBEM_E_INVALID_PARAMETER_ID + 1,
	WBEM_E_PARAMETER_ID_ON_RETVAL	= WBEM_E_NONCONSECUTIVE_PARAMETER_IDS + 1,
	WBEM_E_INVALID_OBJECT_PATH	= WBEM_E_PARAMETER_ID_ON_RETVAL + 1,
	WBEM_E_OUT_OF_DISK_SPACE	= WBEM_E_INVALID_OBJECT_PATH + 1,
	WBEMESS_E_REGISTRATION_TOO_BROAD	= 0x80042001,
	WBEMESS_E_REGISTRATION_TOO_PRECISE	= WBEMESS_E_REGISTRATION_TOO_BROAD + 1
    }	WBEMSTATUS;


EXTERN_C const IID LIBID_WbemClient_v1;

#ifndef __IWbemClassObject_INTERFACE_DEFINED__
#define __IWbemClassObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemClassObject
 * at Mon Jul 20 15:14:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object][restricted][local] */ 



EXTERN_C const IID IID_IWbemClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("dc12a681-737f-11cf-884d-00aa004b2e24")
    IWbemClassObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetQualifierSet( 
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ CIMTYPE __RPC_FAR *pType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ CIMTYPE Type) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ BSTR strName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ BSTR strQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pQualifierVal,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lEnumFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ CIMTYPE __RPC_FAR *pType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyQualifierSet( 
            /* [in] */ BSTR pstrProperty,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectText( 
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pstrObjectText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpawnDerivedClass( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpawnInstance( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewInstance) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareTo( 
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pCompareTo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyOrigin( 
            /* [in] */ BSTR strName,
            /* [out] */ BSTR __RPC_FAR *pstrClassName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InheritsFrom( 
            /* [in] */ BSTR strAncestor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethod( 
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInSignature,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutMethod( 
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pInSignature,
            /* [in] */ IWbemClassObject __RPC_FAR *pOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMethod( 
            /* [in] */ BSTR strName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginMethodEnumeration( 
            /* [in] */ long lEnumFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextMethod( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInSignature,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndMethodEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodQualifierSet( 
            /* [in] */ BSTR strMethod,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodOrigin( 
            /* [in] */ BSTR strMethodName,
            /* [out] */ BSTR __RPC_FAR *pstrClassName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemClassObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQualifierSet )( 
            IWbemClassObject __RPC_FAR * This,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ CIMTYPE __RPC_FAR *pType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ CIMTYPE Type);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR strName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNames )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR strQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pQualifierVal,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnumeration )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ CIMTYPE __RPC_FAR *pType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnumeration )( 
            IWbemClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyQualifierSet )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR pstrProperty,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IWbemClassObject __RPC_FAR * This,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectText )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pstrObjectText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpawnDerivedClass )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewClass);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpawnInstance )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewInstance);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompareTo )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pCompareTo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyOrigin )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [out] */ BSTR __RPC_FAR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InheritsFrom )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR strAncestor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethod )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInSignature,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutMethod )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pInSignature,
            /* [in] */ IWbemClassObject __RPC_FAR *pOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteMethod )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR strName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginMethodEnumeration )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NextMethod )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInSignature,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndMethodEnumeration )( 
            IWbemClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethodQualifierSet )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR strMethod,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethodOrigin )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR strMethodName,
            /* [out] */ BSTR __RPC_FAR *pstrClassName);
        
        END_INTERFACE
    } IWbemClassObjectVtbl;

    interface IWbemClassObject
    {
        CONST_VTBL struct IWbemClassObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemClassObject_GetQualifierSet(This,ppQualSet)	\
    (This)->lpVtbl -> GetQualifierSet(This,ppQualSet)

#define IWbemClassObject_Get(This,strName,lFlags,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Get(This,strName,lFlags,pVal,pType,plFlavor)

#define IWbemClassObject_Put(This,strName,lFlags,pVal,Type)	\
    (This)->lpVtbl -> Put(This,strName,lFlags,pVal,Type)

#define IWbemClassObject_Delete(This,strName)	\
    (This)->lpVtbl -> Delete(This,strName)

#define IWbemClassObject_GetNames(This,strQualifierName,lFlags,pQualifierVal,pNames)	\
    (This)->lpVtbl -> GetNames(This,strQualifierName,lFlags,pQualifierVal,pNames)

#define IWbemClassObject_BeginEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lEnumFlags)

#define IWbemClassObject_Next(This,lFlags,pstrName,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,pstrName,pVal,pType,plFlavor)

#define IWbemClassObject_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemClassObject_GetPropertyQualifierSet(This,pstrProperty,ppQualSet)	\
    (This)->lpVtbl -> GetPropertyQualifierSet(This,pstrProperty,ppQualSet)

#define IWbemClassObject_Clone(This,ppCopy)	\
    (This)->lpVtbl -> Clone(This,ppCopy)

#define IWbemClassObject_GetObjectText(This,lFlags,pstrObjectText)	\
    (This)->lpVtbl -> GetObjectText(This,lFlags,pstrObjectText)

#define IWbemClassObject_SpawnDerivedClass(This,lFlags,ppNewClass)	\
    (This)->lpVtbl -> SpawnDerivedClass(This,lFlags,ppNewClass)

#define IWbemClassObject_SpawnInstance(This,lFlags,ppNewInstance)	\
    (This)->lpVtbl -> SpawnInstance(This,lFlags,ppNewInstance)

#define IWbemClassObject_CompareTo(This,lFlags,pCompareTo)	\
    (This)->lpVtbl -> CompareTo(This,lFlags,pCompareTo)

#define IWbemClassObject_GetPropertyOrigin(This,strName,pstrClassName)	\
    (This)->lpVtbl -> GetPropertyOrigin(This,strName,pstrClassName)

#define IWbemClassObject_InheritsFrom(This,strAncestor)	\
    (This)->lpVtbl -> InheritsFrom(This,strAncestor)

#define IWbemClassObject_GetMethod(This,strName,lFlags,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> GetMethod(This,strName,lFlags,ppInSignature,ppOutSignature)

#define IWbemClassObject_PutMethod(This,strName,lFlags,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> PutMethod(This,strName,lFlags,pInSignature,pOutSignature)

#define IWbemClassObject_DeleteMethod(This,strName)	\
    (This)->lpVtbl -> DeleteMethod(This,strName)

#define IWbemClassObject_BeginMethodEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginMethodEnumeration(This,lEnumFlags)

#define IWbemClassObject_NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)

#define IWbemClassObject_EndMethodEnumeration(This)	\
    (This)->lpVtbl -> EndMethodEnumeration(This)

#define IWbemClassObject_GetMethodQualifierSet(This,strMethod,ppQualSet)	\
    (This)->lpVtbl -> GetMethodQualifierSet(This,strMethod,ppQualSet)

#define IWbemClassObject_GetMethodOrigin(This,strMethodName,pstrClassName)	\
    (This)->lpVtbl -> GetMethodOrigin(This,strMethodName,pstrClassName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemClassObject_GetQualifierSet_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);


void __RPC_STUB IWbemClassObject_GetQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Get_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR strName,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
    /* [unique][in][out] */ CIMTYPE __RPC_FAR *pType,
    /* [unique][in][out] */ long __RPC_FAR *plFlavor);


void __RPC_STUB IWbemClassObject_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Put_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR strName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT __RPC_FAR *pVal,
    /* [in] */ CIMTYPE Type);


void __RPC_STUB IWbemClassObject_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Delete_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR strName);


void __RPC_STUB IWbemClassObject_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetNames_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR strQualifierName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT __RPC_FAR *pQualifierVal,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);


void __RPC_STUB IWbemClassObject_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_BeginEnumeration_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lEnumFlags);


void __RPC_STUB IWbemClassObject_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Next_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
    /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
    /* [unique][in][out] */ CIMTYPE __RPC_FAR *pType,
    /* [unique][in][out] */ long __RPC_FAR *plFlavor);


void __RPC_STUB IWbemClassObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_EndEnumeration_Proxy( 
    IWbemClassObject __RPC_FAR * This);


void __RPC_STUB IWbemClassObject_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetPropertyQualifierSet_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR pstrProperty,
    /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);


void __RPC_STUB IWbemClassObject_GetPropertyQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Clone_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppCopy);


void __RPC_STUB IWbemClassObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetObjectText_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ BSTR __RPC_FAR *pstrObjectText);


void __RPC_STUB IWbemClassObject_GetObjectText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_SpawnDerivedClass_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewClass);


void __RPC_STUB IWbemClassObject_SpawnDerivedClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_SpawnInstance_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewInstance);


void __RPC_STUB IWbemClassObject_SpawnInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_CompareTo_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject __RPC_FAR *pCompareTo);


void __RPC_STUB IWbemClassObject_CompareTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetPropertyOrigin_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR strName,
    /* [out] */ BSTR __RPC_FAR *pstrClassName);


void __RPC_STUB IWbemClassObject_GetPropertyOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_InheritsFrom_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR strAncestor);


void __RPC_STUB IWbemClassObject_InheritsFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethod_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR strName,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInSignature,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutSignature);


void __RPC_STUB IWbemClassObject_GetMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_PutMethod_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR strName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject __RPC_FAR *pInSignature,
    /* [in] */ IWbemClassObject __RPC_FAR *pOutSignature);


void __RPC_STUB IWbemClassObject_PutMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_DeleteMethod_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR strName);


void __RPC_STUB IWbemClassObject_DeleteMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_BeginMethodEnumeration_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lEnumFlags);


void __RPC_STUB IWbemClassObject_BeginMethodEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_NextMethod_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInSignature,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutSignature);


void __RPC_STUB IWbemClassObject_NextMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_EndMethodEnumeration_Proxy( 
    IWbemClassObject __RPC_FAR * This);


void __RPC_STUB IWbemClassObject_EndMethodEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethodQualifierSet_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR strMethod,
    /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);


void __RPC_STUB IWbemClassObject_GetMethodQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethodOrigin_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR strMethodName,
    /* [out] */ BSTR __RPC_FAR *pstrClassName);


void __RPC_STUB IWbemClassObject_GetMethodOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemClassObject_INTERFACE_DEFINED__ */


#ifndef __IWbemObjectAccess_INTERFACE_DEFINED__
#define __IWbemObjectAccess_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemObjectAccess
 * at Mon Jul 20 15:14:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object][restricted][local] */ 



EXTERN_C const IID IID_IWbemObjectAccess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("49353c9a-516b-11d1-aea6-00c04fb68820")
    IWbemObjectAccess : public IWbemClassObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyHandle( 
            /* [in] */ BSTR strPropertyName,
            /* [out] */ CIMTYPE __RPC_FAR *pType,
            /* [out] */ long __RPC_FAR *plHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePropertyValue( 
            /* [in] */ long lHandle,
            /* [in] */ long lNumBytes,
            /* [size_is][in] */ byte __RPC_FAR *aData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPropertyValue( 
            /* [in] */ long lHandle,
            /* [in] */ long lBufferSize,
            /* [out] */ long __RPC_FAR *plNumBytes,
            /* [length_is][size_is][out] */ byte __RPC_FAR *aData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadDWORD( 
            /* [in] */ long lHandle,
            /* [out] */ DWORD __RPC_FAR *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteDWORD( 
            /* [in] */ long lHandle,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadQWORD( 
            /* [in] */ long lHandle,
            /* [out] */ MIDL_uhyper __RPC_FAR *pqw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteQWORD( 
            /* [in] */ long lHandle,
            /* [in] */ MIDL_uhyper pw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyInfoByHandle( 
            /* [in] */ long lHandle,
            /* [out] */ BSTR __RPC_FAR *pstrName,
            /* [out] */ CIMTYPE __RPC_FAR *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Lock( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unlock( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectAccessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemObjectAccess __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemObjectAccess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQualifierSet )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ CIMTYPE __RPC_FAR *pType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ CIMTYPE Type);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR strName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNames )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR strQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pQualifierVal,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnumeration )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ CIMTYPE __RPC_FAR *pType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnumeration )( 
            IWbemObjectAccess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyQualifierSet )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR pstrProperty,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectText )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pstrObjectText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpawnDerivedClass )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewClass);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpawnInstance )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewInstance);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompareTo )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pCompareTo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyOrigin )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [out] */ BSTR __RPC_FAR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InheritsFrom )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR strAncestor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethod )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInSignature,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutMethod )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pInSignature,
            /* [in] */ IWbemClassObject __RPC_FAR *pOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteMethod )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR strName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginMethodEnumeration )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NextMethod )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInSignature,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndMethodEnumeration )( 
            IWbemObjectAccess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethodQualifierSet )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR strMethod,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethodOrigin )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR strMethodName,
            /* [out] */ BSTR __RPC_FAR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyHandle )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR strPropertyName,
            /* [out] */ CIMTYPE __RPC_FAR *pType,
            /* [out] */ long __RPC_FAR *plHandle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WritePropertyValue )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [in] */ long lNumBytes,
            /* [size_is][in] */ byte __RPC_FAR *aData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadPropertyValue )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [in] */ long lBufferSize,
            /* [out] */ long __RPC_FAR *plNumBytes,
            /* [length_is][size_is][out] */ byte __RPC_FAR *aData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadDWORD )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [out] */ DWORD __RPC_FAR *pdw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteDWORD )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadQWORD )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [out] */ MIDL_uhyper __RPC_FAR *pqw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteQWORD )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [in] */ MIDL_uhyper pw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyInfoByHandle )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [out] */ BSTR __RPC_FAR *pstrName,
            /* [out] */ CIMTYPE __RPC_FAR *pType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Lock )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unlock )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemObjectAccessVtbl;

    interface IWbemObjectAccess
    {
        CONST_VTBL struct IWbemObjectAccessVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectAccess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectAccess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectAccess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectAccess_GetQualifierSet(This,ppQualSet)	\
    (This)->lpVtbl -> GetQualifierSet(This,ppQualSet)

#define IWbemObjectAccess_Get(This,strName,lFlags,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Get(This,strName,lFlags,pVal,pType,plFlavor)

#define IWbemObjectAccess_Put(This,strName,lFlags,pVal,Type)	\
    (This)->lpVtbl -> Put(This,strName,lFlags,pVal,Type)

#define IWbemObjectAccess_Delete(This,strName)	\
    (This)->lpVtbl -> Delete(This,strName)

#define IWbemObjectAccess_GetNames(This,strQualifierName,lFlags,pQualifierVal,pNames)	\
    (This)->lpVtbl -> GetNames(This,strQualifierName,lFlags,pQualifierVal,pNames)

#define IWbemObjectAccess_BeginEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lEnumFlags)

#define IWbemObjectAccess_Next(This,lFlags,pstrName,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,pstrName,pVal,pType,plFlavor)

#define IWbemObjectAccess_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemObjectAccess_GetPropertyQualifierSet(This,pstrProperty,ppQualSet)	\
    (This)->lpVtbl -> GetPropertyQualifierSet(This,pstrProperty,ppQualSet)

#define IWbemObjectAccess_Clone(This,ppCopy)	\
    (This)->lpVtbl -> Clone(This,ppCopy)

#define IWbemObjectAccess_GetObjectText(This,lFlags,pstrObjectText)	\
    (This)->lpVtbl -> GetObjectText(This,lFlags,pstrObjectText)

#define IWbemObjectAccess_SpawnDerivedClass(This,lFlags,ppNewClass)	\
    (This)->lpVtbl -> SpawnDerivedClass(This,lFlags,ppNewClass)

#define IWbemObjectAccess_SpawnInstance(This,lFlags,ppNewInstance)	\
    (This)->lpVtbl -> SpawnInstance(This,lFlags,ppNewInstance)

#define IWbemObjectAccess_CompareTo(This,lFlags,pCompareTo)	\
    (This)->lpVtbl -> CompareTo(This,lFlags,pCompareTo)

#define IWbemObjectAccess_GetPropertyOrigin(This,strName,pstrClassName)	\
    (This)->lpVtbl -> GetPropertyOrigin(This,strName,pstrClassName)

#define IWbemObjectAccess_InheritsFrom(This,strAncestor)	\
    (This)->lpVtbl -> InheritsFrom(This,strAncestor)

#define IWbemObjectAccess_GetMethod(This,strName,lFlags,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> GetMethod(This,strName,lFlags,ppInSignature,ppOutSignature)

#define IWbemObjectAccess_PutMethod(This,strName,lFlags,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> PutMethod(This,strName,lFlags,pInSignature,pOutSignature)

#define IWbemObjectAccess_DeleteMethod(This,strName)	\
    (This)->lpVtbl -> DeleteMethod(This,strName)

#define IWbemObjectAccess_BeginMethodEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginMethodEnumeration(This,lEnumFlags)

#define IWbemObjectAccess_NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)

#define IWbemObjectAccess_EndMethodEnumeration(This)	\
    (This)->lpVtbl -> EndMethodEnumeration(This)

#define IWbemObjectAccess_GetMethodQualifierSet(This,strMethod,ppQualSet)	\
    (This)->lpVtbl -> GetMethodQualifierSet(This,strMethod,ppQualSet)

#define IWbemObjectAccess_GetMethodOrigin(This,strMethodName,pstrClassName)	\
    (This)->lpVtbl -> GetMethodOrigin(This,strMethodName,pstrClassName)


#define IWbemObjectAccess_GetPropertyHandle(This,strPropertyName,pType,plHandle)	\
    (This)->lpVtbl -> GetPropertyHandle(This,strPropertyName,pType,plHandle)

#define IWbemObjectAccess_WritePropertyValue(This,lHandle,lNumBytes,aData)	\
    (This)->lpVtbl -> WritePropertyValue(This,lHandle,lNumBytes,aData)

#define IWbemObjectAccess_ReadPropertyValue(This,lHandle,lBufferSize,plNumBytes,aData)	\
    (This)->lpVtbl -> ReadPropertyValue(This,lHandle,lBufferSize,plNumBytes,aData)

#define IWbemObjectAccess_ReadDWORD(This,lHandle,pdw)	\
    (This)->lpVtbl -> ReadDWORD(This,lHandle,pdw)

#define IWbemObjectAccess_WriteDWORD(This,lHandle,dw)	\
    (This)->lpVtbl -> WriteDWORD(This,lHandle,dw)

#define IWbemObjectAccess_ReadQWORD(This,lHandle,pqw)	\
    (This)->lpVtbl -> ReadQWORD(This,lHandle,pqw)

#define IWbemObjectAccess_WriteQWORD(This,lHandle,pw)	\
    (This)->lpVtbl -> WriteQWORD(This,lHandle,pw)

#define IWbemObjectAccess_GetPropertyInfoByHandle(This,lHandle,pstrName,pType)	\
    (This)->lpVtbl -> GetPropertyInfoByHandle(This,lHandle,pstrName,pType)

#define IWbemObjectAccess_Lock(This,lFlags)	\
    (This)->lpVtbl -> Lock(This,lFlags)

#define IWbemObjectAccess_Unlock(This,lFlags)	\
    (This)->lpVtbl -> Unlock(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectAccess_GetPropertyHandle_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ BSTR strPropertyName,
    /* [out] */ CIMTYPE __RPC_FAR *pType,
    /* [out] */ long __RPC_FAR *plHandle);


void __RPC_STUB IWbemObjectAccess_GetPropertyHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WritePropertyValue_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [in] */ long lNumBytes,
    /* [size_is][in] */ byte __RPC_FAR *aData);


void __RPC_STUB IWbemObjectAccess_WritePropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadPropertyValue_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [in] */ long lBufferSize,
    /* [out] */ long __RPC_FAR *plNumBytes,
    /* [length_is][size_is][out] */ byte __RPC_FAR *aData);


void __RPC_STUB IWbemObjectAccess_ReadPropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadDWORD_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [out] */ DWORD __RPC_FAR *pdw);


void __RPC_STUB IWbemObjectAccess_ReadDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WriteDWORD_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [in] */ DWORD dw);


void __RPC_STUB IWbemObjectAccess_WriteDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadQWORD_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [out] */ MIDL_uhyper __RPC_FAR *pqw);


void __RPC_STUB IWbemObjectAccess_ReadQWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WriteQWORD_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [in] */ MIDL_uhyper pw);


void __RPC_STUB IWbemObjectAccess_WriteQWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_GetPropertyInfoByHandle_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [out] */ BSTR __RPC_FAR *pstrName,
    /* [out] */ CIMTYPE __RPC_FAR *pType);


void __RPC_STUB IWbemObjectAccess_GetPropertyInfoByHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_Lock_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemObjectAccess_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_Unlock_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemObjectAccess_Unlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectAccess_INTERFACE_DEFINED__ */


#ifndef __IWbemQualifierSet_INTERFACE_DEFINED__
#define __IWbemQualifierSet_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemQualifierSet
 * at Mon Jul 20 15:14:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][local][restricted][object] */ 



EXTERN_C const IID IID_IWbemQualifierSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("dc12a680-737f-11cf-884d-00aa004b2e24")
    IWbemQualifierSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ long lFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ BSTR strName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemQualifierSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemQualifierSet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemQualifierSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ long lFlavor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ BSTR strName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNames )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnumeration )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnumeration )( 
            IWbemQualifierSet __RPC_FAR * This);
        
        END_INTERFACE
    } IWbemQualifierSetVtbl;

    interface IWbemQualifierSet
    {
        CONST_VTBL struct IWbemQualifierSetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemQualifierSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemQualifierSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemQualifierSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemQualifierSet_Get(This,strName,lFlags,pVal,plFlavor)	\
    (This)->lpVtbl -> Get(This,strName,lFlags,pVal,plFlavor)

#define IWbemQualifierSet_Put(This,strName,pVal,lFlavor)	\
    (This)->lpVtbl -> Put(This,strName,pVal,lFlavor)

#define IWbemQualifierSet_Delete(This,strName)	\
    (This)->lpVtbl -> Delete(This,strName)

#define IWbemQualifierSet_GetNames(This,lFlags,pNames)	\
    (This)->lpVtbl -> GetNames(This,lFlags,pNames)

#define IWbemQualifierSet_BeginEnumeration(This,lFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lFlags)

#define IWbemQualifierSet_Next(This,lFlags,pstrName,pVal,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,pstrName,pVal,plFlavor)

#define IWbemQualifierSet_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Get_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ BSTR strName,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
    /* [unique][in][out] */ long __RPC_FAR *plFlavor);


void __RPC_STUB IWbemQualifierSet_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Put_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ BSTR strName,
    /* [in] */ VARIANT __RPC_FAR *pVal,
    /* [in] */ long lFlavor);


void __RPC_STUB IWbemQualifierSet_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Delete_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ BSTR strName);


void __RPC_STUB IWbemQualifierSet_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_GetNames_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);


void __RPC_STUB IWbemQualifierSet_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_BeginEnumeration_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemQualifierSet_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Next_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
    /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
    /* [unique][in][out] */ long __RPC_FAR *plFlavor);


void __RPC_STUB IWbemQualifierSet_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_EndEnumeration_Proxy( 
    IWbemQualifierSet __RPC_FAR * This);


void __RPC_STUB IWbemQualifierSet_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemQualifierSet_INTERFACE_DEFINED__ */


#ifndef __IWbemServices_INTERFACE_DEFINED__
#define __IWbemServices_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemServices
 * at Mon Jul 20 15:14:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][restricted][object] */ 



EXTERN_C const IID IID_IWbemServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("9556dc99-828c-11cf-a37e-00aa003240c7")
    IWbemServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemServices __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemServices __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenNamespace )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelAsyncCall )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryObjectSink )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObject )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutClass )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutClassAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteClass )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteClassAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateClassEnum )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateClassEnumAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutInstance )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutInstanceAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteInstance )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteInstanceAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstanceEnum )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstanceEnumAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecQuery )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecQueryAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecNotificationQuery )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecNotificationQueryAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecMethod )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR strObjectPath,
            /* [in] */ BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecMethodAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR strObjectPath,
            /* [in] */ BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        END_INTERFACE
    } IWbemServicesVtbl;

    interface IWbemServices
    {
        CONST_VTBL struct IWbemServicesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemServices_OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult)	\
    (This)->lpVtbl -> OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult)

#define IWbemServices_CancelAsyncCall(This,pSink)	\
    (This)->lpVtbl -> CancelAsyncCall(This,pSink)

#define IWbemServices_QueryObjectSink(This,lFlags,ppResponseHandler)	\
    (This)->lpVtbl -> QueryObjectSink(This,lFlags,ppResponseHandler)

#define IWbemServices_GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult)	\
    (This)->lpVtbl -> GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult)

#define IWbemServices_GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServices_PutClass(This,pObject,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutClass(This,pObject,lFlags,pCtx,ppCallResult)

#define IWbemServices_PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)

#define IWbemServices_DeleteClass(This,strClass,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteClass(This,strClass,lFlags,pCtx,ppCallResult)

#define IWbemServices_DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler)

#define IWbemServices_CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum)

#define IWbemServices_CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler)

#define IWbemServices_PutInstance(This,pInst,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutInstance(This,pInst,lFlags,pCtx,ppCallResult)

#define IWbemServices_PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)

#define IWbemServices_DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServices_DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServices_CreateInstanceEnum(This,strClass,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateInstanceEnum(This,strClass,lFlags,pCtx,ppEnum)

#define IWbemServices_CreateInstanceEnumAsync(This,strClass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateInstanceEnumAsync(This,strClass,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)

#define IWbemServices_ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)

#define IWbemServices_ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)	\
    (This)->lpVtbl -> ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)

#define IWbemServices_ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler)	\
    (This)->lpVtbl -> ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemServices_OpenNamespace_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR strNamespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);


void __RPC_STUB IWbemServices_OpenNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CancelAsyncCall_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink);


void __RPC_STUB IWbemServices_CancelAsyncCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_QueryObjectSink_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);


void __RPC_STUB IWbemServices_QueryObjectSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_GetObject_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_GetObjectAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_GetObjectAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutClass_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_PutClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutClassAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_PutClassAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteClass_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_DeleteClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteClassAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_DeleteClassAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateClassEnum_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IWbemServices_CreateClassEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateClassEnumAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_CreateClassEnumAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutInstance_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_PutInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutInstanceAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_PutInstanceAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteInstance_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_DeleteInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteInstanceAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_DeleteInstanceAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateInstanceEnum_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IWbemServices_CreateInstanceEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateInstanceEnumAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_CreateInstanceEnumAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecQuery_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR strQueryLanguage,
    /* [in] */ BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IWbemServices_ExecQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecQueryAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR strQueryLanguage,
    /* [in] */ BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_ExecQueryAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecNotificationQuery_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR strQueryLanguage,
    /* [in] */ BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IWbemServices_ExecNotificationQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecNotificationQueryAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR strQueryLanguage,
    /* [in] */ BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_ExecNotificationQueryAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecMethod_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR strObjectPath,
    /* [in] */ BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_ExecMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecMethodAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR strObjectPath,
    /* [in] */ BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_ExecMethodAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemServices_INTERFACE_DEFINED__ */


#ifndef __IWbemLocator_INTERFACE_DEFINED__
#define __IWbemLocator_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemLocator
 * at Mon Jul 20 15:14:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][local][restricted][object] */ 



EXTERN_C const IID IID_IWbemLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("dc12a687-737f-11cf-884d-00aa004b2e24")
    IWbemLocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConnectServer( 
            /* [in] */ BSTR strNetworkResource,
            /* [in] */ BSTR strUser,
            /* [in] */ BSTR strPassword,
            /* [in] */ BSTR strLocale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ BSTR strAuthority,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppNamespace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemLocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemLocator __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemLocator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConnectServer )( 
            IWbemLocator __RPC_FAR * This,
            /* [in] */ BSTR strNetworkResource,
            /* [in] */ BSTR strUser,
            /* [in] */ BSTR strPassword,
            /* [in] */ BSTR strLocale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ BSTR strAuthority,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppNamespace);
        
        END_INTERFACE
    } IWbemLocatorVtbl;

    interface IWbemLocator
    {
        CONST_VTBL struct IWbemLocatorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemLocator_ConnectServer(This,strNetworkResource,strUser,strPassword,strLocale,lSecurityFlags,strAuthority,pCtx,ppNamespace)	\
    (This)->lpVtbl -> ConnectServer(This,strNetworkResource,strUser,strPassword,strLocale,lSecurityFlags,strAuthority,pCtx,ppNamespace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemLocator_ConnectServer_Proxy( 
    IWbemLocator __RPC_FAR * This,
    /* [in] */ BSTR strNetworkResource,
    /* [in] */ BSTR strUser,
    /* [in] */ BSTR strPassword,
    /* [in] */ BSTR strLocale,
    /* [in] */ long lSecurityFlags,
    /* [in] */ BSTR strAuthority,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppNamespace);


void __RPC_STUB IWbemLocator_ConnectServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemLocator_INTERFACE_DEFINED__ */


#ifndef __IWbemObjectSink_INTERFACE_DEFINED__
#define __IWbemObjectSink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemObjectSink
 * at Mon Jul 20 15:14:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][restricted][object] */ 



EXTERN_C const IID IID_IWbemObjectSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("7c857801-7381-11cf-884d-00aa004b2e24")
    IWbemObjectSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemObjectSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemObjectSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemObjectSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Indicate )( 
            IWbemObjectSink __RPC_FAR * This,
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatus )( 
            IWbemObjectSink __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam);
        
        END_INTERFACE
    } IWbemObjectSinkVtbl;

    interface IWbemObjectSink
    {
        CONST_VTBL struct IWbemObjectSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectSink_Indicate(This,lObjectCount,apObjArray)	\
    (This)->lpVtbl -> Indicate(This,lObjectCount,apObjArray)

#define IWbemObjectSink_SetStatus(This,lFlags,hResult,strParam,pObjParam)	\
    (This)->lpVtbl -> SetStatus(This,lFlags,hResult,strParam,pObjParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectSink_Indicate_Proxy( 
    IWbemObjectSink __RPC_FAR * This,
    /* [in] */ long lObjectCount,
    /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray);


void __RPC_STUB IWbemObjectSink_Indicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectSink_SetStatus_Proxy( 
    IWbemObjectSink __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ HRESULT hResult,
    /* [in] */ BSTR strParam,
    /* [in] */ IWbemClassObject __RPC_FAR *pObjParam);


void __RPC_STUB IWbemObjectSink_SetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectSink_INTERFACE_DEFINED__ */


#ifndef __IEnumWbemClassObject_INTERFACE_DEFINED__
#define __IEnumWbemClassObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumWbemClassObject
 * at Mon Jul 20 15:14:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][restricted][object] */ 



EXTERN_C const IID IID_IEnumWbemClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("027947e1-d731-11ce-a357-000000000001")
    IEnumWbemClassObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lTimeout,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjects,
            /* [out] */ ULONG __RPC_FAR *puReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextAsync( 
            /* [in] */ ULONG uCount,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ long lTimeout,
            /* [in] */ ULONG nCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWbemClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumWbemClassObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumWbemClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumWbemClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjects,
            /* [out] */ ULONG __RPC_FAR *puReturned);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NextAsync )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ ULONG uCount,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [in] */ ULONG nCount);
        
        END_INTERFACE
    } IEnumWbemClassObjectVtbl;

    interface IEnumWbemClassObject
    {
        CONST_VTBL struct IEnumWbemClassObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWbemClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumWbemClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumWbemClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumWbemClassObject_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumWbemClassObject_Next(This,lTimeout,uCount,apObjects,puReturned)	\
    (This)->lpVtbl -> Next(This,lTimeout,uCount,apObjects,puReturned)

#define IEnumWbemClassObject_NextAsync(This,uCount,pSink)	\
    (This)->lpVtbl -> NextAsync(This,uCount,pSink)

#define IEnumWbemClassObject_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumWbemClassObject_Skip(This,lTimeout,nCount)	\
    (This)->lpVtbl -> Skip(This,lTimeout,nCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Reset_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This);


void __RPC_STUB IEnumWbemClassObject_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Next_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [in] */ ULONG uCount,
    /* [length_is][size_is][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjects,
    /* [out] */ ULONG __RPC_FAR *puReturned);


void __RPC_STUB IEnumWbemClassObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_NextAsync_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This,
    /* [in] */ ULONG uCount,
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink);


void __RPC_STUB IEnumWbemClassObject_NextAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Clone_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumWbemClassObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Skip_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [in] */ ULONG nCount);


void __RPC_STUB IEnumWbemClassObject_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWbemClassObject_INTERFACE_DEFINED__ */


#ifndef __IWbemCallResult_INTERFACE_DEFINED__
#define __IWbemCallResult_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemCallResult
 * at Mon Jul 20 15:14:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][restricted][object] */ 



EXTERN_C const IID IID_IWbemCallResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("44aca675-e8fc-11d0-a07c-00c04fb68820")
    IWbemCallResult : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetResultObject( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppResultObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultString( 
            /* [in] */ long lTimeout,
            /* [out] */ BSTR __RPC_FAR *pstrResultString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultServices( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppServices) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallStatus( 
            /* [in] */ long lTimeout,
            /* [out] */ long __RPC_FAR *plStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemCallResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemCallResult __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemCallResult __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultObject )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppResultObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultString )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [out] */ BSTR __RPC_FAR *pstrResultString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultServices )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppServices);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCallStatus )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [out] */ long __RPC_FAR *plStatus);
        
        END_INTERFACE
    } IWbemCallResultVtbl;

    interface IWbemCallResult
    {
        CONST_VTBL struct IWbemCallResultVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemCallResult_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemCallResult_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemCallResult_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemCallResult_GetResultObject(This,lTimeout,ppResultObject)	\
    (This)->lpVtbl -> GetResultObject(This,lTimeout,ppResultObject)

#define IWbemCallResult_GetResultString(This,lTimeout,pstrResultString)	\
    (This)->lpVtbl -> GetResultString(This,lTimeout,pstrResultString)

#define IWbemCallResult_GetResultServices(This,lTimeout,ppServices)	\
    (This)->lpVtbl -> GetResultServices(This,lTimeout,ppServices)

#define IWbemCallResult_GetCallStatus(This,lTimeout,plStatus)	\
    (This)->lpVtbl -> GetCallStatus(This,lTimeout,plStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultObject_Proxy( 
    IWbemCallResult __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppResultObject);


void __RPC_STUB IWbemCallResult_GetResultObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultString_Proxy( 
    IWbemCallResult __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [out] */ BSTR __RPC_FAR *pstrResultString);


void __RPC_STUB IWbemCallResult_GetResultString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultServices_Proxy( 
    IWbemCallResult __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppServices);


void __RPC_STUB IWbemCallResult_GetResultServices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetCallStatus_Proxy( 
    IWbemCallResult __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [out] */ long __RPC_FAR *plStatus);


void __RPC_STUB IWbemCallResult_GetCallStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemCallResult_INTERFACE_DEFINED__ */


#ifndef __IWbemContext_INTERFACE_DEFINED__
#define __IWbemContext_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemContext
 * at Mon Jul 20 15:14:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][local][restricted][object] */ 



EXTERN_C const IID IID_IWbemContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("44aca674-e8fc-11d0-a07c-00c04fb68820")
    IWbemContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWbemContext __RPC_FAR *__RPC_FAR *ppNewCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pstrName,
            /* [out] */ VARIANT __RPC_FAR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [out] */ VARIANT __RPC_FAR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteValue( 
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IWbemContext __RPC_FAR * This,
            /* [out] */ IWbemContext __RPC_FAR *__RPC_FAR *ppNewCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNames )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnumeration )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pstrName,
            /* [out] */ VARIANT __RPC_FAR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnumeration )( 
            IWbemContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags,
            /* [out] */ VARIANT __RPC_FAR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteValue )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAll )( 
            IWbemContext __RPC_FAR * This);
        
        END_INTERFACE
    } IWbemContextVtbl;

    interface IWbemContext
    {
        CONST_VTBL struct IWbemContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemContext_Clone(This,ppNewCopy)	\
    (This)->lpVtbl -> Clone(This,ppNewCopy)

#define IWbemContext_GetNames(This,lFlags,pNames)	\
    (This)->lpVtbl -> GetNames(This,lFlags,pNames)

#define IWbemContext_BeginEnumeration(This,lFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lFlags)

#define IWbemContext_Next(This,lFlags,pstrName,pValue)	\
    (This)->lpVtbl -> Next(This,lFlags,pstrName,pValue)

#define IWbemContext_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemContext_SetValue(This,strName,lFlags,pValue)	\
    (This)->lpVtbl -> SetValue(This,strName,lFlags,pValue)

#define IWbemContext_GetValue(This,strName,lFlags,pValue)	\
    (This)->lpVtbl -> GetValue(This,strName,lFlags,pValue)

#define IWbemContext_DeleteValue(This,strName,lFlags)	\
    (This)->lpVtbl -> DeleteValue(This,strName,lFlags)

#define IWbemContext_DeleteAll(This)	\
    (This)->lpVtbl -> DeleteAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemContext_Clone_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [out] */ IWbemContext __RPC_FAR *__RPC_FAR *ppNewCopy);


void __RPC_STUB IWbemContext_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_GetNames_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);


void __RPC_STUB IWbemContext_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_BeginEnumeration_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemContext_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_Next_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ BSTR __RPC_FAR *pstrName,
    /* [out] */ VARIANT __RPC_FAR *pValue);


void __RPC_STUB IWbemContext_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_EndEnumeration_Proxy( 
    IWbemContext __RPC_FAR * This);


void __RPC_STUB IWbemContext_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_SetValue_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ BSTR strName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT __RPC_FAR *pValue);


void __RPC_STUB IWbemContext_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_GetValue_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ BSTR strName,
    /* [in] */ long lFlags,
    /* [out] */ VARIANT __RPC_FAR *pValue);


void __RPC_STUB IWbemContext_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_DeleteValue_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ BSTR strName,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemContext_DeleteValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_DeleteAll_Proxy( 
    IWbemContext __RPC_FAR * This);


void __RPC_STUB IWbemContext_DeleteAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemContext_INTERFACE_DEFINED__ */


#ifndef __IUnsecuredApartment_INTERFACE_DEFINED__
#define __IUnsecuredApartment_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IUnsecuredApartment
 * at Mon Jul 20 15:14:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][restricted] */ 



EXTERN_C const IID IID_IUnsecuredApartment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("1cfaba8c-1523-11d1-ad79-00c04fd8fdff")
    IUnsecuredApartment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateObjectStub( 
            /* [in] */ IUnknown __RPC_FAR *pObject,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppStub) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUnsecuredApartmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUnsecuredApartment __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUnsecuredApartment __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUnsecuredApartment __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateObjectStub )( 
            IUnsecuredApartment __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pObject,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppStub);
        
        END_INTERFACE
    } IUnsecuredApartmentVtbl;

    interface IUnsecuredApartment
    {
        CONST_VTBL struct IUnsecuredApartmentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUnsecuredApartment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUnsecuredApartment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUnsecuredApartment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUnsecuredApartment_CreateObjectStub(This,pObject,ppStub)	\
    (This)->lpVtbl -> CreateObjectStub(This,pObject,ppStub)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUnsecuredApartment_CreateObjectStub_Proxy( 
    IUnsecuredApartment __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pObject,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppStub);


void __RPC_STUB IUnsecuredApartment_CreateObjectStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUnsecuredApartment_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_WbemLocator;

class DECLSPEC_UUID("4590f811-1d3a-11d0-891f-00aa004b2e24")
WbemLocator;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_WbemContext;

class DECLSPEC_UUID("674B6698-EE92-11d0-AD71-00C04FD8FDFF")
WbemContext;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_UnsecuredApartment;

class DECLSPEC_UUID("49bd2028-1523-11d1-ad79-00c04fd8fdff")
UnsecuredApartment;
#endif
#endif /* __WbemClient_v1_LIBRARY_DEFINED__ */

/****************************************
 * Generated header for interface: __MIDL_itf_connmgrex_0000
 * at Mon Jul 20 15:14:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_connmgrex_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_connmgrex_0000_v0_0_s_ifspec;

/****************************************
 * Generated header for interface: __MIDL_itf_connmgrex_0072
 * at Mon Jul 20 15:14:02 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_connmgrex_0072_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_connmgrex_0072_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\connmgr\source\connection.h ===
// Connection.h: interface for the CConnection class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CONNECTION_H__59B02D24_0BC7_11D2_BDCC_00C04FA35447__INCLUDED_)
#define AFX_CONNECTION_H__59B02D24_0BC7_11D2_BDCC_00C04FA35447__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define SCHEMA_MAJOR_VERSION 2
#define SCHEMA_MINOR_VERSION 1

#define IDS_STRING_HMCATSTATUS_QUERY			_T("select * from __InstanceModificationEvent where TargetInstance isa \"HMCatStatus\"")
#define IDS_STRING_HMEVENT_QUERY					_T("select * from __InstanceCreationEvent where TargetInstance isa \"HMEvent\"")
#define IDS_STRING_HMMACHSTATUS_QUERY			_T("select * from __InstanceModificationEvent where TargetInstance isa \"HMMachStatus\"")
#define IDS_STRING_HMSYSTEMSTATUS_QUERY		_T("select * from __InstanceModificationEvent where TargetInstance isa \"Microsoft_HMSystemStatus\"")
#define IDS_STRING_HMCONFIGCREATE_QUERY		_T("select * from __InstanceCreationEvent where TargetInstance isa \"Microsoft_HMConfiguration\"")
#define IDS_STRING_HMCONFIGDELETE_QUERY		_T("select * from __InstanceDeletionEvent where TargetInstance isa \"Microsoft_HMConfiguration\"")

enum HMClassType { HMEvent, HMMachStatus, HMCatStatus, HMSystemStatus, HMConfig, AsyncQuery };
//////////////////////////////////////////////////////////////////////
// class CEventRegistrationEntry
//////////////////////////////////////////////////////////////////////
class CEventRegistrationEntry : public CObject
{

DECLARE_DYNCREATE(CEventRegistrationEntry)

// Constructors
public:
	CEventRegistrationEntry();
	CEventRegistrationEntry(CString sQuery, IWbemObjectSink* pSink);
// Destructor
public:
	~CEventRegistrationEntry();

// SetStatus
public:
	HRESULT NotifyConsole(long lFlag, HRESULT hr);

// SendEvents
	HRESULT SendInstances(IWbemServices*& pServices, long lFlag);
	
// Attributes
public:
	CString						m_sQuery;
	BOOL							m_bRegistered;
	IWbemObjectSink*	m_pSink;
	HMClassType				m_eType;
	BSTR							m_bsClassName;
};

//////////////////////////////////////////////////////////////////////
// class CConnection
//////////////////////////////////////////////////////////////////////
class CConnection : public CObject  
{
DECLARE_DYNCREATE(CConnection)

public:
// Constructor/Destructor
	CConnection(BSTR bsMachineName, IWbemLocator* pIWbemLocator);
	CConnection();
	virtual ~CConnection();

// Helper functions
public:
	BOOL		AddEventEntry(const CString& sQuery, IWbemObjectSink*& pSink);
	BOOL		RemoveEventEntry(IWbemObjectSink*& pSink);
	int		GetEventConsumerCount() { return (int)m_EventConsumers.GetSize(); }

private:
	void		StartMonitor();
	void		StopMonitor();
	void		Init();

// Event operations
	HRESULT	RegisterAllEvents();
	void		UnRegisterAllEvents();		
	void		RemoveAllEventEntries();
	inline	HRESULT NotifyConsole(HRESULT hRes);

// Connection Operation
	HRESULT			Connect();
	inline BOOL	PingMachine();
	inline void	SetConnectionStatus(BOOL bFlag);
	inline HRESULT IsAgentReady();
	inline HRESULT IsAgentCorrectVersion();

// Winmgmt Namespace operations
private:
	inline HRESULT	ConnectToNamespace(BSTR bsNamespace = NULL);	

// data members
public:
	IWbemServices*	m_pIWbemServices;
	BOOL						m_bAvailable;
	HRESULT					m_hrLastConnectResult;

private:
	IWbemLocator*		m_pIWbemLocator;
	BSTR						m_bsMachineName;
	CString					m_sNamespace;
	BOOL						m_bFirstConnect;
	DWORD						m_dwPollInterval;

	CTypedPtrArray<CObArray,CEventRegistrationEntry*> m_EventConsumers;
	
	//zzz Connection/Registration sync. object
	HANDLE					m_hReadyToConnect;

// Static thread function to monitor connection status
protected:
	static unsigned int __stdcall MonitorConnection(void *pv);
	void			CheckConnection();

protected:
	HANDLE		m_hThread;		// thread handle
	unsigned	m_threadID;		// thread id

	struct threadData				// thread data structure
	{
		CConnection*	m_bkptr;	
		HANDLE				m_hDie;		
		HANDLE				m_hDead;	
	}	
	m_threadData;
};

#endif // !defined(AFX_CONNECTION_H__59B02D24_0BC7_11D2_BDCC_00C04FA35447__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\connmgr\source\evententry.cpp ===
// Connection.cpp: implementation of the CConnection class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ConnMgr.h"
#include "Connection.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// CEventRegistrationEntry

IMPLEMENT_DYNCREATE(CEventRegistrationEntry,CObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEventRegistrationEntry::CEventRegistrationEntry()
{
	OutputDebugString(_T("CEventRegistrationEntry::CEventRegistrationEntry()\n"));

	m_pSink				= NULL;
	m_bRegistered = FALSE;
	m_sQuery			= _T("");
}

CEventRegistrationEntry::CEventRegistrationEntry(CString sQuery, IWbemObjectSink* pSink)
{
	OutputDebugString(_T("CEventRegistrationEntry::CEventRegistrationEntry(CString, IWbemObjectSink*)\n"));

	m_pSink = pSink;
	m_pSink->AddRef();

	m_sQuery = sQuery;
	m_bRegistered = FALSE;

	if (m_sQuery == IDS_STRING_HMEVENT_QUERY)
	{
		m_bsClassName = SysAllocString(L"HMEvent");
		m_eType = HMEvent;
	}
	else if (m_sQuery == IDS_STRING_HMMACHSTATUS_QUERY)
	{
		m_bsClassName = SysAllocString(L"HMMachStatus");
		m_eType = HMMachStatus;
	}
	else if( m_sQuery == IDS_STRING_HMCATSTATUS_QUERY)
	{
		m_bsClassName = SysAllocString(L"HMCatStatus");
		m_eType = HMCatStatus;
	}
	else if( m_sQuery == IDS_STRING_HMSYSTEMSTATUS_QUERY)
	{
		m_bsClassName = SysAllocString(L"Microsoft_HMSystemStatus");
		m_eType = HMSystemStatus;
	}
	else if( m_sQuery == IDS_STRING_HMCONFIGCREATE_QUERY)
	{
		m_bsClassName = NULL;
		m_eType = HMConfig;
	}
	else if( m_sQuery == IDS_STRING_HMCONFIGDELETE_QUERY)
	{
		m_bsClassName = NULL;
		m_eType = HMConfig;
	}
	else
	{
		m_eType = AsyncQuery;
		m_bsClassName = NULL;
	}
}

CEventRegistrationEntry::~CEventRegistrationEntry()
{
	OutputDebugString(_T("CEventRegistrationEntry::~CEventRegistrationEntry()\n"));

	if (m_pSink)
		m_pSink->Release();

	m_pSink				= NULL;

	SysFreeString(m_bsClassName);
}

HRESULT CEventRegistrationEntry::NotifyConsole(long lFlag, HRESULT hr)
{
	OutputDebugString(_T("CEventRegistrationEntry::NotifyConsole()\n"));

	ASSERT(m_pSink);

	// other temporary data
	HRESULT hResult							=  hr;
	BSTR		strParam						= NULL;
	IWbemClassObject* pObjParam	= NULL;

	HRESULT hRes = m_pSink->SetStatus(lFlag, hResult, strParam, pObjParam);

	return hRes;
}

HRESULT CEventRegistrationEntry::SendInstances(IWbemServices*& pServices, long lFlag)
{
	OutputDebugString(_T("CEventRegistrationEntry::SendInstances()\n"));

	ASSERT(pServices);

	HRESULT hRes = S_OK;
	if(m_eType == HMEvent || m_eType == HMSystemStatus)
	{
		OutputDebugString(_T("\tSending HMSystemStatus instances...\n"));
    OutputDebugString(_T("\t"));
    OutputDebugString(m_bsClassName);
    OutputDebugString(_T("\n"));

		if (lFlag == 2)
			hRes = pServices->CreateInstanceEnumAsync(m_bsClassName, WBEM_FLAG_SHALLOW, NULL, m_pSink);

		return hRes;
	}
	else if( m_eType == AsyncQuery )
	{
		if (lFlag == 2)
		{
			OutputDebugString(_T("\tExecuting async query for instances...\n"));
      OutputDebugString(_T("\t"));
      OutputDebugString(m_sQuery);
      OutputDebugString(_T("\n"));
			BSTR bsQuery = m_sQuery.AllocSysString();
			BSTR bsLanguage = SysAllocString(_T("WQL"));
			hRes = pServices->ExecQueryAsync(bsLanguage, bsQuery, WBEM_FLAG_BIDIRECTIONAL, NULL, m_pSink);
			SysFreeString(bsQuery);
			SysFreeString(bsLanguage);
		}

		return hRes;
	}
	
	hRes = pServices->CreateInstanceEnumAsync(m_bsClassName, WBEM_FLAG_SHALLOW, NULL, m_pSink);

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\connmgr\source\ping.cpp ===
// Ping.cpp : implementation file
//

#include "stdafx.h"
#include "ConnMgr.h"
#include "Ping.h"

extern "C"
{
	#include <ipexport.h>
	#include <icmpapi.h>
}

#define PING_TIMEOUT 100

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPing

CPing::CPing()
{

}

CPing::~CPing()
{
}

/////////////////////////////////////////////////////////////////////////////
// Operations
/////////////////////////////////////////////////////////////////////////////

unsigned long CPing::ResolveIP(const CString& sIP)
{
	//Task 1:	Given IP Address i.e. "111.111.111.111",
	//	Return Network byte ordered address (ulIP)
	unsigned long ulIP;
	USES_CONVERSION;
	char* pszIP = T2A(sIP);
	ulIP =(IPAddr)inet_addr(pszIP);
	return ulIP;
}

unsigned long CPing::ResolveName(const CString& sHostName)
{
	//Task 1:	Resolve HostName (through DNS or WINS, whichever appropriate)
	//Task 2:	Return network byte ordered address (ulIP)	
	unsigned long ulIP;
	hostent* phostent;
	USES_CONVERSION;
	char* pszName = T2A(sHostName);
	phostent = gethostbyname(pszName);

	if (phostent == NULL)
	{
		for( int i = 0; pszName[i] != NULL; i++  )
		{
			// note that according to RFC 952, the only valid characters are the numbers 0-9,
			// the letters A-Z, the period and the minues sign. All other characters are
			// converted to a minus sign if they are invalid. Technically, the underscore and the
			// exclamation point are invalid as well. However, since NT
			if( (int)pszName[i] <= 0 )
			{
				pszName[i] = '-';
			}
		}

		phostent = gethostbyname(pszName);
		if (phostent == NULL)
			return 0;
	}
	ulIP = *(DWORD*)(*phostent->h_addr_list);
	return ulIP;
}

BOOL CPing::Ping(unsigned long ulIP, int iPingTimeout)
{
	//Task 1:	Open ICMP Handle
	//Task 2:	Create Structure to receive ping reply
	//Task 3:	SendPing (SendEcho)
	//Task 4:	Close ICMP Handle
	//Task 5:	Return RoundTripTime
	unsigned long ip = ulIP;
	HANDLE icmphandle = IcmpCreateFile();
	char reply[sizeof(icmp_echo_reply)+8];
	icmp_echo_reply* iep = (icmp_echo_reply*)&reply;
	iep->RoundTripTime = 0xffffffff;
	
	for (int i = 0; i < ICMP_ECHO_RETRY; i++)
		if (IcmpSendEcho(icmphandle,ip,0,0,NULL,reply,sizeof(icmp_echo_reply)+8,iPingTimeout))
			break;

	IcmpCloseHandle(icmphandle);
	return iep->Status == IP_SUCCESS;
}

CString CPing::GetIP(unsigned long ulIP)
{
	//Task 1:	Given a host order ulIP Address
	//	Return a IP address in format of xxx.xxx.xxx.xxx
	char* szAddr;
	struct in_addr inetAddr;
	inetAddr.s_addr = (IPAddr)ulIP;
	szAddr = inet_ntoa(inetAddr);
	USES_CONVERSION;
	CString csIP = A2T(szAddr);	
	return csIP;
}

// Do not edit the following lines, which are needed by ClassWizard.
#if 0
BEGIN_MESSAGE_MAP(CPing, CSocket)
	//{{AFX_MSG_MAP(CPing)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
#endif	// 0

/////////////////////////////////////////////////////////////////////////////
// CPing member functions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\connmgr\source\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ConnMgr.rc
//
#define IDS_PROJNAME                    100
#define IDR_ConnMgr                     100
#define IDR_CONNECTIONMANAGER           101
#define CG_IDS_SOCKETS_INIT_FAILED      102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\connmgr\source\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__FA84E6E9_0B7B_11D2_BDCB_00C04FA35447__INCLUDED_)
#define AFX_STDAFX_H__FA84E6E9_0B7B_11D2_BDCB_00C04FA35447__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <afxwin.h>
#include <afxdisp.h>
#include <afxtempl.h>
#include <afxsock.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
	HRESULT UpdateRegistry(LPCOLESTR lpszRes, BOOL bRegister);
};
extern CExeModule _Module;
#include <atlcom.h>

#include <wbemcli.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__FA84E6E9_0B7B_11D2_BDCB_00C04FA35447__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\connmgr\source\ping.h ===
#if !defined(AFX_PING_H__AC22CA72_3551_11D2_8A45_0000F87A3912__INCLUDED_)
#define AFX_PING_H__AC22CA72_3551_11D2_8A45_0000F87A3912__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Ping.h : header file
//

#define ICMP_ECHO_RETRY	3		// Retry.
/////////////////////////////////////////////////////////////////////////////
// CPing command target

class CPing : public CSocket
{

// Construction/Destruction
public:
	CPing();
	virtual ~CPing();

// Operations
public:
	unsigned long ResolveIP(const CString& strIP);
	unsigned long ResolveName(const CString& strHostName);
	BOOL Ping(unsigned long ulIP, int iPingTimeout);
	CString GetIP(unsigned long ulIP);

// Overrides
public:
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPing)
	//}}AFX_VIRTUAL

	// Generated message map functions
	//{{AFX_MSG(CPing)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

// Implementation
protected:
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PING_H__AC22CA72_3551_11D2_8A45_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\action.h ===
//***************************************************************************
//
//  ACTION.H
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: To act as the coordinator of actions. WMI actually provides the
//			code and support to carry out the actions (like email). This class
//			does the scheduling, and throttling of them.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#if !defined( __ACTION_H )
#define __ACTION_H

#include <wbemcli.h>
#include <vector>
#include "global.h"
#include "tmpcnsmr.h"
#include "base.h"

typedef struct _tag_QStruct
{
	LPTSTR szQuery;
	CTempConsumer* pTempSink;
	long lThrottleTime;
	long lReminderTime;
	unsigned long ulTriggerStates;
	DWORD startTick;
	DWORD reminderTimeTick;
	BOOL bThrottleOn;
	LPTSTR szConfigActionAssocPath;
	LPTSTR szUserConfigPath;
	LPTSTR szChildPath;
	CBase *pBase;
	HRESULT hRes;
} QSTRUCT, *PQSTRUCT;
typedef std::vector<QSTRUCT, std::allocator<QSTRUCT> > QLIST;


class CAction : public CBase
{
public:
	CAction();
	~CAction();

//	LPTSTR m_szGUID;
//	LPTSTR m_szName;
	LPTSTR m_szDescription;
	int m_iActiveDays;
	long m_lBeginHourTime;
	long m_lBeginMinuteTime;
	long m_lEndHourTime;
	long m_lEndMinuteTime;
	BOOL m_bEnabled;
	BOOL m_bParentEnabled;
	LPTSTR m_szTypeGUID;
//	BOOL m_bFTCBBroken;
	QLIST m_qList;
//	long m_lCurrState;
	TCHAR m_szDTTime[512];
	TCHAR m_szTime[512];
	LPTSTR m_pszStatusGUID;
	BOOL m_bValidLoad;

	HRESULT LoadInstanceFromMOF(IWbemClassObject* pObj, BOOL bModifyPass=FALSE);
	BOOL OnAgentInterval(void);
	BOOL HandleTempEvent(LPTSTR szGUID, IWbemClassObject* pObj);
	BOOL HandleTempErrorEvent(BSTR szGUID, long lErrorCode, LPTSTR pszErrorDescription);
	HRESULT FindAndModAction(BSTR szGUID, IWbemClassObject* pObj);
	BOOL FindAndCreateActionAssociation(BSTR szGUID, IWbemClassObject* pObj);
	BOOL FindAndModActionAssociation(BSTR szGUID, IWbemClassObject* pObj);
	BOOL FireEvent(long lErrorCode, LPTSTR pszErrorDescription, int iResString);
	HRESULT GetHMActionStatus(IWbemClassObject** ppInstance, IWbemClassObject* pObj, LPTSTR pszClass, int iResString);
	BOOL DeleteConfigActionAssoc(LPTSTR pszConfigGUID, LPTSTR pszActionGUID);
	BOOL DeleteEFAndFTCB(void);
	LPTSTR GetGUID(void);
	BOOL DeleteAConfig(void);
	HRESULT SendHMActionStatusInstances(IWbemObjectSink* pSink);
	HRESULT SendHMActionStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
	BOOL checkTime(void);
	CBase *FindImediateChildByName(LPTSTR pszName);
	BOOL GetNextChildName(LPTSTR pszChildName, LPTSTR pszOutName);
	CBase *FindPointerFromName(LPTSTR pszName);
//	BOOL ModifyAssocForMove(CBase *pNewParentBase);
	BOOL ReceiveNewChildForMove(CBase *pBase);
	BOOL DeleteChildFromList(LPTSTR pszGUID);
	BOOL SendReminderActionIfStateIsSame(IWbemObjectSink* pActionEventSink, IWbemObjectSink* pActionTriggerEventSink, IWbemClassObject* pActionInstance, IWbemClassObject* pActionTriggerInstance, unsigned long ulTriggerStates);
	Cleanup(BOOL bClearAll);
	HRESULT RemapAction(void);
	HRESULT RemapOneAction(IWbemClassObject* pObj);
	HRESULT CheckForBadLoad(void);
};
#endif  // __ACTION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\action.cpp ===
//***************************************************************************
//
//  ACTION.CPP
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: To act as the coordinator of actions. WMI actually provides the
//			code and support to carry out the actions (like email). This class
//			does the scheduling, and throttling of them.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <stdio.h>
#include <tchar.h>
#include "system.h"
#include "action.h"

extern CSystem* g_pSystem;
extern HMODULE g_hWbemComnModule;
static BYTE LocalSystemSID[] = {1,1,0,0,0,0,0,5,18,0,0,0};


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAction::CAction()
{

	MY_OUTPUT(L"ENTER ***** CAction::CAction...", 4);

	m_szGUID = NULL;
	m_szName = NULL;
	m_szDescription = NULL;
	m_szTypeGUID = NULL;
	m_pszStatusGUID = NULL;
	m_lCurrState = HM_GOOD;
	m_hmStatusType = HMSTATUS_ACTION;
	m_bValidLoad = FALSE;

	wcscpy(m_szDTTime, m_szDTCurrTime);
	wcscpy(m_szTime, m_szCurrTime);

	MY_OUTPUT(L"EXIT ***** CAction::CAction...", 4);
}

CAction::~CAction()
{
	MY_OUTPUT(L"ENTER ***** CAction::~CAction...", 4);

	Cleanup(TRUE);
	if (m_szGUID)
	{
		delete [] m_szGUID;
		m_szGUID = NULL;
	}

	m_bValidLoad = FALSE;

	MY_OUTPUT(L"EXIT ***** CAction::~CAction...", 4);
}

//
// Load a single Action
//
HRESULT CAction::LoadInstanceFromMOF(IWbemClassObject* pActionConfigInst, BOOL bModifyPass/*FALSE*/)
{
	HRESULT hRetRes = S_OK;
	TCHAR szTemp[1024];
	GUID guid;
	LPTSTR pszStr;
	LPTSTR pszTemp;
	BOOL bRetValue = TRUE;
	QSTRUCT Q;
	BSTR Language = NULL;
	BSTR Query = NULL;
	HRESULT hRes;
	ULONG uReturned;
	IWbemClassObject *pAssocObj = NULL;
	IEnumWbemClassObject *pEnum = NULL;
	LPTSTR pszUpper = NULL;

	MY_OUTPUT(L"ENTER ***** CAction::LoadInstanceFromMOF...", 4);


	m_bValidLoad = TRUE;
	if (m_szGUID == NULL)
	{
		// Get the GUID property
		hRetRes = GetStrProperty(pActionConfigInst, L"GUID", &m_szGUID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) return hRetRes;
	}

	if (bModifyPass==FALSE)
	{
		Cleanup(TRUE);
		hRetRes = CoCreateGuid(&guid);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		m_pszStatusGUID = new TCHAR[100];
		MY_ASSERT(m_pszStatusGUID); if (!m_pszStatusGUID) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		StringFromGUID2(guid, m_pszStatusGUID, 100);
	}
	else
	{
		Cleanup(FALSE);
	}

	// Get the Name. If it is NULL then we use the qualifier
	hRetRes = GetStrProperty(pActionConfigInst, L"Name", &m_szName);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	// Get the Description. If it is NULL then we use the qualifier
	hRetRes = GetStrProperty(pActionConfigInst, L"Description", &m_szDescription);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	hRetRes = GetBoolProperty(pActionConfigInst, L"Enabled", &m_bEnabled);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	hRetRes = GetUint8Property(pActionConfigInst, L"ActiveDays", &m_iActiveDays);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	// The time format looks as follows "********0600**.******+***"; hh is hours and mm is minutes
	// All else is ignored.
	hRetRes = GetStrProperty(pActionConfigInst, L"BeginTime", &pszTemp);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	pszStr = wcschr(pszTemp, '.');
	if (pszStr)
	{
		// Back up to look at the minute
		pszStr -= 2;
		*pszStr = '\0';
		pszStr -= 2;
		m_lBeginMinuteTime= _wtol(pszStr);
		// Back up to look at the hour
		*pszStr = '\0';
		pszStr -= 2;
		m_lBeginHourTime= _wtol(pszStr);
	}
	else
	{
		m_lBeginMinuteTime= -1;
		m_lBeginHourTime= -1;
	}
	delete [] pszTemp;

	hRetRes = GetStrProperty(pActionConfigInst, L"EndTime", &pszTemp);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	pszStr = wcschr(pszTemp, '.');
	if (pszStr)
	{
		// Back up to look at the minute
		pszStr -= 2;
		*pszStr = '\0';
		pszStr -= 2;
		m_lEndMinuteTime= _wtol(pszStr);
		// Back up to look at the hour
		*pszStr = '\0';
		pszStr -= 2;
		m_lEndHourTime= _wtol(pszStr);
	}
	else
	{
		m_lEndMinuteTime= -1;
		m_lEndHourTime= -1;
	}
	delete [] pszTemp;

	hRetRes = GetStrProperty(pActionConfigInst, L"TypeGUID", &m_szTypeGUID);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	//
	// Need to create a temporary consumer for each configuration object associated to
	// this Action. These are the real events that are happening to cause the actions
	// to fire.
	//
	if (!bModifyPass)
	{
		//
		// Loop through all Associations to this Action
		//
		Language = SysAllocString(L"WQL");
		MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		wcscpy(szTemp, L"REFERENCES OF {MicrosoftHM_ActionConfiguration.GUID=\"");
		lstrcat(szTemp, m_szGUID);
		lstrcat(szTemp, L"\"} WHERE ResultClass=MicrosoftHM_ConfigurationActionAssociation");
		Query = SysAllocString(szTemp);
		MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

		// Initialize IEnumWbemClassObject pointer
		pEnum = NULL;

		// Issue query
    	hRetRes = g_pIWbemServices->ExecQuery(Language, Query, WBEM_FLAG_FORWARD_ONLY, 0, &pEnum);

		SysFreeString(Query);
		Query = NULL;
		SysFreeString(Language);
		Language = NULL;

		if (hRetRes != 0)
		{
			MY_HRESASSERT(hRetRes);
		}
		else
		{
			// Retrieve objects in result set
			while (TRUE)
			{
				pAssocObj = NULL;
				uReturned = 0;

				hRes = pEnum->Next(0, 1, &pAssocObj, &uReturned);
				if (uReturned == 0)
				{
					break;
				}

				//
				// Next, setup the temporary consumer for the event(s) that the actions is
				// triggered by, so we can do throttling.
				//
				hRetRes = GetStrProperty(pAssocObj, L"ParentPath", &Q.szUserConfigPath);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
				Q.pBase = g_pSystem->GetParentPointerFromPath(Q.szUserConfigPath);
				if (!Q.pBase || (Q.pBase && Q.pBase->m_hmStatusType==HMSTATUS_THRESHOLD))
				{
					if (Q.szUserConfigPath)
						delete [] Q.szUserConfigPath;
					pAssocObj->Release();
					pAssocObj = NULL;
					continue;
				}

//				hRetRes = GetUint32Property(pAssocObj, L"ThrottleTime", &Q.lThrottleTime);
//				MY_HRESASSERT(hRetRes);
				Q.lThrottleTime = 0;

				hRetRes = GetUint32Property(pAssocObj, L"ReminderTime", &Q.lReminderTime);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

				hRetRes = GetStrProperty(pAssocObj, L"Query", &Q.szQuery);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

				//
				// Look for "...State=0 OR State=9"
				//
				pszUpper = _wcsdup(Q.szQuery);
				MY_ASSERT(pszUpper); if (!pszUpper) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				_wcsupr(pszUpper);
				Q.ulTriggerStates = 0;
				pszStr = wcsstr(pszUpper, L"STATE");
				if (pszStr)
				{
					if (wcschr(pszStr, '0'))
					{
						Q.ulTriggerStates |= 1<<0;
					}
					if (wcschr(pszStr, '4'))
					{
						Q.ulTriggerStates |= 1<<4;
					}
					if (wcschr(pszStr, '5'))
					{
						Q.ulTriggerStates |= 1<<5;
					}
					if (wcschr(pszStr, '8'))
					{
						Q.ulTriggerStates |= 1<<8;
					}
					if (wcschr(pszStr, '9'))
					{
						Q.ulTriggerStates |= 1<<9;
					}
				}
				free(pszUpper);
				pszUpper = NULL;

				hRetRes = GetStrProperty(pAssocObj, L"__PATH", &Q.szConfigActionAssocPath);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

				hRetRes = GetStrProperty(pAssocObj, L"ChildPath", &Q.szChildPath);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

				if (m_bEnabled)
				{
					//
					// Setup the event query. We need to be able to identify each individual
					// use of this Action! Pass in this unique property.
					//
					Q.pTempSink = new CTempConsumer(Q.szConfigActionAssocPath);
					MY_ASSERT(Q.pTempSink); if (!Q.pTempSink) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
					Q.hRes = 0;

					Language = SysAllocString(L"WQL");
					MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
					Query = SysAllocString(Q.szQuery);
					MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
					hRes = 1;
					if (g_pIWbemServices != NULL)
					{
						hRes = g_pIWbemServices->ExecNotificationQueryAsync(
													Language,
													Query,
													0,
													NULL,
													Q.pTempSink);
						Q.hRes = hRes;
					}

					SysFreeString(Query);
					Query = NULL;
					SysFreeString(Language);
					Language = NULL;
				}
				else
				{
					Q.pTempSink = 0;
					Q.hRes = 0;
				}

				Q.startTick = 0;
				Q.reminderTimeTick = 0;
				Q.bThrottleOn = FALSE;
				MY_ASSERT(Q.pBase);
				m_qList.push_back(Q);

				// Release it.
				pAssocObj->Release();
				pAssocObj = NULL;
			}

			// All done
			pEnum->Release();
			pEnum = NULL;
		}
	}

	m_bValidLoad = TRUE;
	MY_OUTPUT(L"EXIT ***** CAction::LoadInstanceFromMOF...", 4);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	if (Query)
		SysFreeString(Query);
	if (Language)
		SysFreeString(Language);
	if (pszUpper)
		free(pszUpper);
	if (pAssocObj)
		pAssocObj->Release();
	if (pEnum)
		pEnum->Release();
	Cleanup(TRUE);
	m_bValidLoad = FALSE;
	return hRetRes;
}

//
// In the case of Actions, they don't actually have an interval to them, but they
// get called here for each action every second (the base agent interval).
//
BOOL CAction::OnAgentInterval(void)
{
	HRESULT hRetRes = S_OK;
	HRESULT hRes;
	IWbemClassObject* pInstance = NULL;
	HRESULT hRes2;
	IWbemClassObject* pInstance2 = NULL;
	DWORD currTick;
	BOOL bTimeOK;
	int i, iSize;
	QSTRUCT *pQ;
	BSTR Language = NULL;
	BSTR Query = NULL;
	GUID guid;

	if (m_bValidLoad == FALSE)
		return FALSE;

	//
	// Make sure that we are in a valid time to run.
	//
	bTimeOK = checkTime();

	// Remember that the DISABLED state overrides SCHEDULEDOUT.
	if ((m_bEnabled==FALSE && m_lCurrState==HM_DISABLED) ||
		(bTimeOK==FALSE && m_lCurrState==HM_SCHEDULEDOUT && m_bEnabled))
	{
		return TRUE;
	}
	else if (m_bEnabled==FALSE && m_lCurrState!=HM_DISABLED ||
			bTimeOK==FALSE && m_lCurrState!=HM_SCHEDULEDOUT)
	{
		//
		// Going into Scheduled Outage OR DISABLED.
		// What if we are going from ScheduledOut to Disabled?
		// Or from Disabled to ScheduledOut?
		// Possible transitions:
		// GOOD -> Disabled
		// GOOD -> ScheduledOut
		// Disabled -> ScheduledOut
		// ScheduledOut -> Disabled
		//
		iSize = m_qList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_qList.size());
			pQ = &m_qList[i];

			if (pQ->pTempSink)
			{
				g_pIWbemServices->CancelAsyncCall((IWbemObjectSink*)pQ->pTempSink);
				pQ->pTempSink->Release();
				pQ->pTempSink = NULL;
			}
			pQ->hRes = 0;
		}
		if (m_bEnabled==FALSE)
		{
			m_lCurrState = HM_DISABLED;
			FireEvent(-1, NULL, HMRES_ACTION_DISABLE);
		}
		else
		{
			m_lCurrState = HM_SCHEDULEDOUT;
			FireEvent(-1, NULL, HMRES_ACTION_OUTAGE);
		}
		return TRUE;
	}
	else if (m_lCurrState==HM_DISABLED || m_lCurrState==HM_SCHEDULEDOUT)
	{
		//
		// Comming out of Scheduled Outage OR DISABLED.
		// Might be going from ScheduledOut/Disabled to Disabled,
		// or disabled to ScheduledOut.
		//
		m_lCurrState = HM_GOOD;
		FireEvent(-1, NULL, HMRES_ACTION_ENABLE);

		// Re-setup the event consumer
		iSize = m_qList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_qList.size());
			pQ = &m_qList[i];
			pQ->pTempSink = new CTempConsumer(pQ->szConfigActionAssocPath);
			MY_ASSERT(pQ->pTempSink); if (!pQ->pTempSink) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			pQ->hRes = 0;

			Language = SysAllocString(L"WQL");
			MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			Query = SysAllocString(pQ->szQuery);
			MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			hRes = 1;
			if (g_pIWbemServices != NULL)
			{
				hRes = g_pIWbemServices->ExecNotificationQueryAsync(
											Language,
											Query,
											0,
											NULL,
											pQ->pTempSink);
				pQ->hRes = hRes;
			}

			SysFreeString(Query);
			Query = NULL;
			SysFreeString(Language);
			Language = NULL;

			if (hRes != 0)
			{
				MY_HRESASSERT(hRes);
			}
			else
			{
				pQ->startTick = 0;
				pQ->reminderTimeTick = 0;
				pQ->bThrottleOn = FALSE;
			}
		}
	}

	//
	// Determine if the throttle time needs to come into play.
	//
	currTick = GetTickCount();
	iSize = m_qList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_qList.size());
		pQ = &m_qList[i];

		if (0<pQ->lThrottleTime)
		{
			// May have not gone off yet
			if ((0<pQ->startTick))
			{
				// Check to see if alloted time has passed
				if ((pQ->lThrottleTime*1000) < (currTick-pQ->startTick))
				{
					pQ->bThrottleOn = FALSE;
					pQ->startTick = 0;
				}
				else
				{
					pQ->bThrottleOn = TRUE;
				}
			}
		}
	}

	// Try and prevent problems where we may have had a query fail to register
	iSize = m_qList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_qList.size());
		pQ = &m_qList[i];

		if (pQ->hRes!=0)
		{
			Language = SysAllocString(L"WQL");
			MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			Query = SysAllocString(pQ->szQuery);
			MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			hRes = 1;
			if (g_pIWbemServices != NULL && pQ->pTempSink && pQ->hRes!=0)
			{
				hRes = g_pIWbemServices->ExecNotificationQueryAsync(
											Language,
											Query,
											0,
											NULL,
											pQ->pTempSink);
				MY_HRESASSERT(hRes);
				pQ->hRes = hRes;
			}

			SysFreeString(Query);
			Query = NULL;
			SysFreeString(Language);
			Language = NULL;
			if (hRes == 0)
			{
				pQ->startTick = 0;
				pQ->reminderTimeTick = 0;
				pQ->bThrottleOn = FALSE;
			}
		}
	}

	//
	// Determine if we need to fire off a reminder event.
	// We first need to be in the violated state.
	//
	iSize = m_qList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_qList.size());
		pQ = &m_qList[i];
		MY_ASSERT(pQ->pBase);
		if ((g_pActionEventSink || g_pActionTriggerEventSink) && pQ->pBase &&
			pQ->lReminderTime!=0 && pQ->reminderTimeTick==pQ->lReminderTime)
		{
			// Fire event to console, and another one to the event consumer
			wcscpy(m_szDTTime, m_szDTCurrTime);
			wcscpy(m_szTime, m_szCurrTime);
			m_lCurrState = HM_GOOD;
			if (m_pszStatusGUID)
			{
				delete [] m_pszStatusGUID;
				m_pszStatusGUID = NULL;
			}
			hRetRes = CoCreateGuid(&guid);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			m_pszStatusGUID = new TCHAR[100];
			MY_ASSERT(m_pszStatusGUID); if (!m_pszStatusGUID) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			StringFromGUID2(guid, m_pszStatusGUID, 100);
			hRes = GetHMActionStatus(&pInstance, NULL, L"MicrosoftHM_ActionStatusEvent", HMRES_ACTION_FIRED);
			hRes2 = GetHMActionStatus(&pInstance2, NULL, L"MicrosoftHM_ActionTriggerEvent", HMRES_ACTION_FIRED);
			if (SUCCEEDED(hRes) && SUCCEEDED(hRes2))
			{
				pQ->pBase->SendReminderActionIfStateIsSame(g_pActionEventSink, g_pActionTriggerEventSink, pInstance, pInstance2, pQ->ulTriggerStates);
			}
			else
			{
				MY_OUTPUT(L"failed to get instance!", 1);
				MY_HRESASSERT(hRes);
				MY_HRESASSERT(hRes2);
			}
			if (pInstance)
			{
				pInstance->Release();
				pInstance = NULL;
			}
			if (pInstance2)
			{
				pInstance2->Release();
				pInstance2 = NULL;
			}
			pQ->reminderTimeTick = 0;
		}
		if (pQ->lReminderTime!=0 && pQ->reminderTimeTick==pQ->lReminderTime)
			pQ->reminderTimeTick = 0;
		pQ->reminderTimeTick++;
	}

	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (Query)
		SysFreeString(Query);
	if (Language)
		SysFreeString(Language);
	m_bValidLoad = FALSE;
	Cleanup(TRUE);
	return FALSE;
}

//
// Here we get an event, and since we act as the gatekeeper to pass on the final event
// that the EventConsumer will get fired from, we decide if we need to throttle.
// To send on the event, we embed the incomming event into ours.
//
BOOL CAction::HandleTempEvent(LPTSTR szConfigActionAssocPath, IWbemClassObject* pObj)
{
	BOOL bRetValue = TRUE;
	IWbemClassObject* pInstance = NULL;
	HRESULT hRes;
	BOOL bFound;
	QSTRUCT *pQ;
	int i, iSize;

	MY_OUTPUT(L"ENTER ***** CAction::HandleTempEvent...", 2);

	if (m_bValidLoad == FALSE)
		return FALSE;

	m_lCurrState = HM_GOOD;
	//
	// See if it is one of these
	//
	bFound = FALSE;
	iSize = m_qList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_qList.size());
		pQ = &m_qList[i];
		if (!_wcsicmp(pQ->szConfigActionAssocPath, szConfigActionAssocPath))
		{
			bFound = TRUE;
			break;
		}
	}

	//
	// We capture the time that this happened, so that we can throttle in the
	// OnAgentInterval call we can disable the action from happening (until time again).
	//
	if (bFound==FALSE)
	{
		return FALSE;
	}

	if (pQ->startTick == 0)
	{
		pQ->startTick = GetTickCount();
	}

	MY_OUTPUT2(L"HandleTempEvent GUID=%s", m_szGUID, 4);
	MY_OUTPUT2(L"szConfigActionAssocPath=%s", szConfigActionAssocPath, 4);

	if (pQ->bThrottleOn == FALSE)
	{
		if (pQ->lReminderTime != 0)
		{
			pQ->reminderTimeTick = 0;
		}

		// Don't send if no-one is listening!
		if (g_pActionTriggerEventSink != NULL)
		{
			wcscpy(m_szDTTime, m_szDTCurrTime);
			wcscpy(m_szTime, m_szCurrTime);
			FireEvent(-1, NULL, HMRES_ACTION_FIRED);
			hRes = GetHMActionStatus(&pInstance, pObj, L"MicrosoftHM_ActionTriggerEvent", HMRES_ACTION_FIRED);
			if (SUCCEEDED(hRes))
			{
				if (g_pActionTriggerEventSink) 
				{
					hRes = g_pActionTriggerEventSink->Indicate(1, &pInstance);
					//WBEM_E_SERVER_TOO_BUSY is Ok. Wbem will deliver.
					if (FAILED(hRes) && hRes != WBEM_E_SERVER_TOO_BUSY)
					{
						bRetValue = FALSE;
						MY_OUTPUT(L"Failed on Indicate!", 4);
					}
				}
				pInstance->Release();
				pInstance = NULL;
			}
			else
			{
				MY_OUTPUT(L"failed to get instance!", 1);
				MY_HRESASSERT(hRes);
			}
		}
	}

	MY_OUTPUT(L"EXIT ***** CAction::HandleTempEvent...", 2);
	return bRetValue;
}

//oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

HRESULT CAction::FindAndModAction(BSTR szGUID, IWbemClassObject* pObj)
{
	HRESULT hRetRes = S_OK;

	//
	// Is this us we are looking for?
	//
	if (!_wcsicmp(m_szGUID, szGUID))
	{
		hRetRes = LoadInstanceFromMOF(pObj, TRUE);
		return hRetRes;
	}

	return WBEM_S_DIFFERENT;
}

BOOL CAction::FindAndCreateActionAssociation(BSTR szGUID, IWbemClassObject* pObj)
{
	HRESULT hRes;
	HRESULT hRetRes = S_OK;
	int i, iSize;
	QSTRUCT *pQ;
	QSTRUCT Q;
	BOOL bFound;
	BOOL bTimeOK;
	LPTSTR pszStr;
	BSTR Language = NULL;
	BSTR Query = NULL;
	LPTSTR pszConfigActionAssocPath = NULL;
	LPTSTR pszUpper = NULL;

	if (m_bValidLoad == FALSE)
		return FALSE;

	//
	// Is this the Action we are looking for?
	//
	if (!_wcsicmp(m_szGUID, szGUID))
	{
		hRetRes = GetStrProperty(pObj, L"__PATH", &pszConfigActionAssocPath);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		MY_OUTPUT2(L"Association to Action GUID=%s", szGUID, 4);
		MY_OUTPUT2(L"To PATH=%s", pszConfigActionAssocPath, 4);
		// Now check to see if this association already exists
		bFound = FALSE;
		iSize = m_qList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_qList.size());
			pQ = &m_qList[i];
			if (!_wcsicmp(pQ->szConfigActionAssocPath, pszConfigActionAssocPath))
			{
				bFound = TRUE;
				break;
			}
		}

		delete [] pszConfigActionAssocPath;
		pszConfigActionAssocPath = NULL;


		if (bFound == FALSE)
		{
			MY_OUTPUT(L"OK: Not found yet.", 4);
			Q.szUserConfigPath = NULL;
			Q.szQuery = NULL;
			Q.szConfigActionAssocPath = NULL;
			Q.szChildPath = NULL;
			//
			// Next, setup the temporary consumer for the event(s) that the actions is
			// triggered by, so we can do throttling.
			//
			hRetRes = GetStrProperty(pObj, L"ParentPath", &Q.szUserConfigPath);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			Q.pBase = g_pSystem->GetParentPointerFromPath(Q.szUserConfigPath);
			if (!Q.pBase || (Q.pBase && Q.pBase->m_hmStatusType==HMSTATUS_THRESHOLD))
			{
				if (Q.szUserConfigPath)
				{
					delete [] Q.szUserConfigPath;
				}
			}
			else
			{
//				hRetRes = GetUint32Property(pObj, L"ThrottleTime", &Q.lThrottleTime);
//				MY_HRESASSERT(hRetRes);
				Q.lThrottleTime = 0;

				hRetRes = GetUint32Property(pObj, L"ReminderTime", &Q.lReminderTime);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

				hRetRes = GetStrProperty(pObj, L"Query", &Q.szQuery);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

				//
				// Look for "...State=0 OR State=9"
				//
				pszUpper = _wcsdup(Q.szQuery);
				MY_ASSERT(pszUpper); if (!pszUpper) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				_wcsupr(pszUpper);
				Q.ulTriggerStates = 0;
				pszStr = wcsstr(pszUpper, L"STATE");
				if (pszStr)
				{
					if (wcschr(pszStr, '0'))
					{
						Q.ulTriggerStates |= 1<<0;
					}
					if (wcschr(pszStr, '4'))
					{
						Q.ulTriggerStates |= 1<<4;
					}
					if (wcschr(pszStr, '5'))
					{
						Q.ulTriggerStates |= 1<<5;
					}
					if (wcschr(pszStr, '8'))
					{
						Q.ulTriggerStates |= 1<<8;
					}
					if (wcschr(pszStr, '9'))
					{
						Q.ulTriggerStates |= 1<<9;
					}
				}
				free(pszUpper);
				pszUpper = NULL;

				hRetRes = GetStrProperty(pObj, L"__PATH", &Q.szConfigActionAssocPath);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

				hRetRes = GetStrProperty(pObj, L"ChildPath", &Q.szChildPath);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

				TCHAR msgbuf[1024];
				wsprintf(msgbuf, L"ACTIONASSOCIATION: AGUID=%s parentpath=%s childpath=%s", szGUID, Q.szUserConfigPath, Q.szChildPath);
				MY_OUTPUT(msgbuf, 4);
				//
				// Setup the event query. We need to be able to identify each individual
				// use of this Action! Pass in this unique property.
				//
				bTimeOK = checkTime();
				if (m_bEnabled==TRUE && bTimeOK==TRUE)
				{
					Q.pTempSink = new CTempConsumer(Q.szConfigActionAssocPath);
					MY_ASSERT(Q.pTempSink); if (!Q.pTempSink) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

					Language = SysAllocString(L"WQL");
					MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
					Query = SysAllocString(Q.szQuery);
					MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
					hRes = 1;
					Q.hRes = 0;
					if (g_pIWbemServices != NULL)
					{
						hRes = g_pIWbemServices->ExecNotificationQueryAsync(
													Language,
													Query,
													0,
													NULL,
													Q.pTempSink);
						Q.hRes = hRes;
					}

					SysFreeString(Query);
					Query = NULL;
					SysFreeString(Language);
					Language = NULL;

					Q.startTick = 0;
					Q.reminderTimeTick = 0;
					Q.bThrottleOn = FALSE;
					MY_ASSERT(Q.pBase);
					m_qList.push_back(Q);
				}
				else
				{
					Q.pTempSink = NULL;
					Q.startTick = 0;
					Q.reminderTimeTick = 0;
					Q.bThrottleOn = FALSE;
					MY_ASSERT(Q.pBase);
					m_qList.push_back(Q);
				}
			}
			return TRUE;
		}
		else
		{
			MY_OUTPUT(L"WHY?: Already There.", 4);
			return FALSE;
		}

	}
	else
	{
		return FALSE;
	}

error:
	MY_ASSERT(FALSE);
	if (pszUpper)
		free(pszUpper);
	if (pszConfigActionAssocPath)
		delete [] pszConfigActionAssocPath;
	if (Q.szUserConfigPath)
		delete [] Q.szUserConfigPath;
	if (Q.szQuery)
		delete [] Q.szQuery;
	if (Q.szConfigActionAssocPath)
		delete [] Q.szConfigActionAssocPath;
	if (Q.szChildPath)
		delete [] Q.szChildPath;
	if (Query)
		SysFreeString(Query);
	if (Language)
		SysFreeString(Language);
	return TRUE;
}

BOOL CAction::FindAndModActionAssociation(BSTR szGUID, IWbemClassObject* pObj)
{
	HRESULT hRes;
	HRESULT hRetRes;
	int i, iSize;
	QSTRUCT *pQ;
	LPTSTR pszTemp;
	BOOL bFound;
	BSTR Language = NULL;
	BSTR Query = NULL;
	BOOL bSameQuery = FALSE;
	BOOL bTimeOK;
	LPTSTR pszUpper = NULL;
	LPTSTR pszStr;

	if (m_bValidLoad == FALSE)
		return FALSE;

	//
	// Is this the Action we are looking for?
	//
	if (!_wcsicmp(m_szGUID, szGUID))
	{
		hRetRes = GetStrProperty(pObj, L"__PATH", &pszTemp);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		// Now check to see if this association already exists
		bFound = FALSE;
		iSize = m_qList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_qList.size());
			pQ = &m_qList[i];
			if (!_wcsicmp(pQ->szConfigActionAssocPath, pszTemp))
			{
				bFound = TRUE;
				break;
			}
		}

		delete [] pszTemp;
		pszTemp = NULL;

		if (bFound == TRUE)
		{
			MY_OUTPUT2(L"MODACTIONASSOCIATION: AGUID=%s", szGUID, 4);
			MY_OUTPUT2(L"parentpath=%s", pQ->szUserConfigPath, 4);
			MY_OUTPUT2(L"childpath=%s", pQ->szChildPath, 4);

			if (pQ->szQuery)
			{
				hRetRes = GetStrProperty(pObj, L"Query", &pszTemp);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

				if (!wcscmp(pQ->szQuery, pszTemp))
				{
					bSameQuery = TRUE;
					pQ->reminderTimeTick = 0;
				}

				// Check to See if we have to register a new query.
				if (!bSameQuery)
				{
					delete [] pQ->szQuery;
					pQ->szQuery = NULL;
					hRetRes = GetStrProperty(pObj, L"Query", &pQ->szQuery);
					MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

					//
					// Look for "...State=0 OR State=9"
					//
					pszUpper = _wcsdup(pQ->szQuery);
					MY_ASSERT(pszUpper); if (!pszUpper) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
					_wcsupr(pszUpper);
					pQ->ulTriggerStates = 0;
					pszStr = wcsstr(pszUpper, L"STATE");
					if (pszStr)
					{
						if (wcschr(pszStr, '0'))
						{
							pQ->ulTriggerStates |= 1<<0;
						}
						if (wcschr(pszStr, '4'))
						{
							pQ->ulTriggerStates |= 1<<4;
						}
						if (wcschr(pszStr, '5'))
						{
							pQ->ulTriggerStates |= 1<<5;
						}
						if (wcschr(pszStr, '8'))
						{
							pQ->ulTriggerStates |= 1<<8;
						}
						if (wcschr(pszStr, '9'))
						{
							pQ->ulTriggerStates |= 1<<9;
						}
					}
					free(pszUpper);
					pszUpper = NULL;
				}
				delete [] pszTemp;
				pszTemp = NULL;
			}

			if (pQ->szUserConfigPath)
			{
				delete [] pQ->szUserConfigPath;
				pQ->szUserConfigPath = NULL;
			}

			if (pQ->szChildPath)
			{
				delete [] pQ->szChildPath;
				pQ->szChildPath = NULL;
			}

			if (pQ->pTempSink && !bSameQuery)
			{
				g_pIWbemServices->CancelAsyncCall((IWbemObjectSink*)pQ->pTempSink);
				pQ->pTempSink->Release();
				pQ->pTempSink = NULL;
			}

			//
			// Next, setup the temporary consumer for the event(s) that the actions is
			// triggered by, so we can do throttling.
			//
//			hRetRes = GetUint32Property(pObj, L"ThrottleTime", &pQ->lThrottleTime);
//			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			pQ->lThrottleTime = 0;

			hRetRes = GetUint32Property(pObj, L"ReminderTime", &pQ->lReminderTime);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

			hRetRes = GetStrProperty(pObj, L"ParentPath", &pQ->szUserConfigPath);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

			hRetRes = GetStrProperty(pObj, L"ChildPath", &pQ->szChildPath);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

			//
			// Setup the event query. We need to be able to identify each individual
			// use of this Action! Pass in this unique property.
			//
			bTimeOK = checkTime();
			if (!bSameQuery && m_bEnabled==TRUE && bTimeOK==TRUE)
			{
				pQ->pTempSink = new CTempConsumer(pQ->szConfigActionAssocPath);
				MY_ASSERT(pQ->pTempSink); if (!pQ->pTempSink) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

				Language = SysAllocString(L"WQL");
				MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				Query = SysAllocString(pQ->szQuery);
				MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				hRes = 1;
				pQ->hRes = 0;
				if (g_pIWbemServices != NULL)
				{
					hRes = g_pIWbemServices->ExecNotificationQueryAsync(
												Language,
												Query,
												0,
												NULL,
												//XXXm_pContext,
												pQ->pTempSink);
					pQ->hRes = hRes;
				}

				SysFreeString(Query);
				Query = NULL;
				SysFreeString(Language);
				Language = NULL;

				if (hRes != 0)
				{
					MY_HRESASSERT(hRes);
				}
				else
				{
					pQ->startTick = 0;
					pQ->reminderTimeTick = 0;
					pQ->bThrottleOn = FALSE;
				}
			}
		}

		return TRUE;
	}
	else
	{
		return FALSE;
	}

error:
	MY_ASSERT(FALSE);
	if (pszTemp)
		free(pszTemp);
	if (Query)
		SysFreeString(Query);
	if (Language)
		SysFreeString(Language);
	Cleanup(TRUE);
	m_bValidLoad = FALSE;
	return TRUE;
}

BOOL CAction::DeleteConfigActionAssoc(LPTSTR pszConfigGUID, LPTSTR pszActionGUID)
{
	TCHAR *pszEventFilter = NULL;
	BSTR instName = NULL;
	BOOL bFound = FALSE;
	TCHAR szGUID[1024];
	LPTSTR pStr;
	LPTSTR pStr2;
	int i, iSize;
	QSTRUCT *pQ;
	QLIST::iterator iaQ;
	IWbemClassObject* pInst = NULL;
	HRESULT hRes;
	HRESULT hRetRes = S_OK;

	if (m_bValidLoad == FALSE)
		return FALSE;

	//
	// First verify that we have the proper action identified.
	//
	if (_wcsicmp(m_szGUID, pszActionGUID))
	{
		return FALSE;
	}

	TCHAR msgbuf[1024];
	wsprintf(msgbuf, L"DELETECONFIGACTIONASSOCIATION: CONFIGGUID=%s AGUID=%s", pszConfigGUID, pszActionGUID);
	MY_OUTPUT(msgbuf, 4);

	//
	// Verify the Configuration instance associated to this Action
	// We are not deleting the ActionConfig, or the __EventConsumer,
	//__EventFilter, __FilterToConsumerBinding Just usage of it - ConfigActionAssoc
	//
	iSize = m_qList.size();
	iaQ = m_qList.begin();
	for (i=0; i<iSize; i++, iaQ++)
	{
		MY_ASSERT(i<m_qList.size());
		pQ = &m_qList[i];
		wcscpy(szGUID, pQ->szUserConfigPath);
		pStr = wcschr(szGUID, '\"');
		if (pStr)
		{
			pStr++;
			pStr2 = wcschr(pStr, '\"');
			if (pStr2)
			{
				*pStr2 = '\0';
			}
		}
		else
		{
			pStr = wcschr(szGUID, '=');
			if (pStr)
			{
				pStr++;
				if (*pStr == '@')
				{
					pStr2 = pStr;
					pStr2++;
					*pStr2 = '\0';
				}
			}
		}

		if (pStr)
		{
			if (!_wcsicmp(pStr, pszConfigGUID))
			{
				hRetRes = GetWbemObjectInst(&g_pIWbemServices, pQ->szConfigActionAssocPath, NULL, &pInst);
				if (!pInst)
				{
					MY_HRESASSERT(hRetRes);
					return FALSE;
				}
				hRetRes = GetStrProperty(pInst, L"EventFilter", &pszEventFilter);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
				pInst->Release();
				pInst = NULL;

				delete [] pszEventFilter;
				pszEventFilter = NULL;


				//
				// Delete MicrosoftHM_ConfigurationActionAssociation.
				//
				instName = SysAllocString(pQ->szConfigActionAssocPath);
				MY_ASSERT(instName); if (!instName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				if ((hRes = g_pIWbemServices->DeleteInstance(instName, 0L,	NULL, NULL)) != S_OK)
				{
 					MY_OUTPUT(L"ENTER ***** ConfigurationActionAssoc Delete failed...", 4);
				}
				SysFreeString(instName);
				instName = NULL;

				if (pQ->szQuery)
				{
					delete [] pQ->szQuery;
					pQ->szQuery = NULL;
				}

				if (pQ->szConfigActionAssocPath)
				{
					delete [] pQ->szConfigActionAssocPath;
					pQ->szConfigActionAssocPath = NULL;
				}

				if (pQ->szUserConfigPath)
				{
					delete [] pQ->szUserConfigPath;
					pQ->szUserConfigPath = NULL;
				}

				if (pQ->szChildPath)
				{
					delete [] pQ->szChildPath;
					pQ->szChildPath = NULL;
				}

				if (pQ->pTempSink)
				{
					g_pIWbemServices->CancelAsyncCall((IWbemObjectSink*)pQ->pTempSink);
					pQ->pTempSink->Release();
					pQ->pTempSink = NULL;
				}

				m_qList.erase(iaQ);
				bFound = TRUE;
				break;
			}
		}
	}

	if (bFound == TRUE)
	{
	}

	return bFound;

error:
	MY_ASSERT(FALSE);
	if (pszEventFilter)
		delete [] pszEventFilter;
	if (instName)
		SysFreeString(instName);
	if (pInst)
		pInst->Release();
	return TRUE;
}

BOOL CAction::DeleteEFAndFTCB(void)
{
	TCHAR szTemp[1024];
	TCHAR *pszEventConsumer = NULL;
	BSTR instName = NULL;
	LPTSTR pStr;
	LPTSTR pStr2;
	IWbemClassObject* pInst = NULL;
	HRESULT hRes;
	HRESULT hRetRes = S_OK;

	//
	// Delete the __EventFilter
	//
	wcscpy(szTemp, L"__EventFilter.Name=\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"");
	instName = SysAllocString(szTemp);
	MY_ASSERT(instName); if (!instName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	if ((hRes = g_pIWbemServices->DeleteInstance(instName, 0L,	NULL, NULL)) != S_OK)
	{
		MY_OUTPUT(L"ENTER ***** __EventFilter Delete failed...", 4);
	}
	SysFreeString(instName);
	instName = NULL;

	//
	// Delete the __FilterToConsumerBinding. Looks as follows -
	//__FilterToConsumerBinding.
	//Consumer="CommandLineEventConsumer.Name=\"{944E9251-6C58-11d3-90E9-006097919914}\"",
	//Filter="__EventFilter.Name=\"{944E9251-6C58-11d3-90E9-006097919914}\""
	//
	wcscpy(szTemp, L"MicrosoftHM_ActionConfiguration.GUID=\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"");
	hRetRes = GetWbemObjectInst(&g_pIWbemServices, szTemp, NULL, &pInst);
	if (!pInst)
	{
		return FALSE;
	}
	hRetRes = GetStrProperty(pInst, L"EventConsumer", &pszEventConsumer);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	pInst->Release();
	pInst = NULL;

	// We need to format the strings a bit, need extra backslashes in there
	pStr = wcschr(pszEventConsumer, ':');
	MY_ASSERT(pStr); if (!pStr) goto Badstring;
	pStr++;
	pStr2 = wcschr(pStr, '\"');
	MY_ASSERT(pStr2); if (!pStr2) goto Badstring;
	*pStr2 = '\0';
	wcscpy(szTemp, L"__FilterToConsumerBinding.Consumer=\"");
	lstrcat(szTemp, L"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:");
	lstrcat(szTemp, pStr);
	lstrcat(szTemp, L"\\\"");
	pStr = pStr2;
	pStr++;
	pStr2 = wcschr(pStr, '\"');
	MY_ASSERT(pStr2); if (!pStr2) goto Badstring;
	*pStr2 = '\0';
	lstrcat(szTemp, pStr);
	lstrcat(szTemp, L"\\\"\",Filter=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:");

	lstrcat(szTemp, L"__EventFilter.Name=\\\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\\\"\"");

	instName = SysAllocString(szTemp);
	MY_ASSERT(instName); if (!instName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	if ((hRes = g_pIWbemServices->DeleteInstance(instName, 0L,	NULL, NULL)) != S_OK)
	{
		MY_OUTPUT(L"ENTER ***** __FilterToConsumerBinding Delete failed...", 4);
	}
	SysFreeString(instName);
	instName = NULL;
	goto Goodstring;

Badstring:
	MY_OUTPUT(L"ENTER ***** Bad FilterToConsumer string", 4);
Goodstring:
	delete [] pszEventConsumer;
	pszEventConsumer = NULL;

	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (pszEventConsumer)
		delete [] pszEventConsumer;
	if (instName)
		SysFreeString(instName);
	if (pInst)
		pInst->Release();
	return FALSE;
}

//
// Delete the Action Configuration instance and everything that goes with it.
// Need to delete the ActionConfiguration, __EventConsumer, all ConfigActionAssoc's,
// __EventFilter's, __FilterToConsumerBinding's
//
BOOL CAction::DeleteAConfig(void)
{
	HRESULT hRes;
	QLIST qList;
	QSTRUCT Q;
	QSTRUCT *pQ;
	int i, iSize;
	TCHAR szTemp[1024];
	TCHAR *pszEventConsumer = NULL;
	BSTR instName = NULL;
	LPTSTR pStr1;
	LPTSTR pStr2;
	LPTSTR pStr3;
	LPTSTR pStr4;
	BSTR Language = NULL;
	BSTR Query = NULL;
	IEnumWbemClassObject *pEnum;
	IWbemClassObject *pAssocObj = NULL;
	ULONG uReturned;
	IWbemClassObject* pInst = NULL;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** CAction::DeleteAConfig...", 1);

	TCHAR msgbuf[1024];
	wsprintf(msgbuf, L"DELETE: AGUID=%s", m_szGUID);
	MY_OUTPUT(msgbuf, 4);
	//
	// Get rid of all associations to the action.
	// Make use of other function, loop through all associations
	//
	Language = SysAllocString(L"WQL");
	MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(szTemp, L"REFERENCES OF {MicrosoftHM_ActionConfiguration.GUID=\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"} WHERE ResultClass=MicrosoftHM_ConfigurationActionAssociation");
	Query = SysAllocString(szTemp);
	MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

	// Initialize IEnumWbemClassObject pointer
	pEnum = 0;

	// Issue query
   	hRes = g_pIWbemServices->ExecQuery(Language, Query, WBEM_FLAG_FORWARD_ONLY, 0, &pEnum);

	SysFreeString(Query);
	Query = NULL;
	SysFreeString(Language);
	Language = NULL;

	if (hRes != 0)
	{
		MY_OUTPUT(L"ENTER ***** DeleteAConfig failed...", 4);
		return FALSE;
	}

	// Retrieve objects in result set
	while (TRUE)
	{
		pAssocObj = NULL;
		uReturned = 0;

		hRes = pEnum->Next(0, 1, &pAssocObj, &uReturned);

		if (uReturned == 0)
		{
			break;
		}

		hRetRes = GetStrProperty(pAssocObj, L"ParentPath", &Q.szUserConfigPath);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		hRetRes = GetStrProperty(pAssocObj, L"ChildPath", &Q.szChildPath);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		qList.push_back(Q);

		// Release it.
		pAssocObj->Release();
		pAssocObj = NULL;
	}
	// All done
	pEnum->Release();
	pEnum = NULL;

	iSize = qList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<qList.size());
		pQ = &qList[i];

		pStr1 = wcschr(pQ->szUserConfigPath, '\"');
		if (pStr1)
		{
			pStr1++;
			pStr2 = wcschr(pStr1, '\"');
			if (pStr2)
			{
				*pStr2 = '\0';
			}
		}
		pStr3 = wcschr(pQ->szChildPath, '\"');
		if (pStr3)
		{
			pStr3++;
			pStr4 = wcschr(pStr3, '\"');
			if (pStr4)
			{
				*pStr4 = '\0';
			}
		}

		DeleteConfigActionAssoc(pStr1, pStr3);

		if (pQ->szUserConfigPath)
			delete [] pQ->szUserConfigPath;

		if (pQ->szChildPath)
			delete [] pQ->szChildPath;
	}
	qList.clear();

	//
	// Finally we can get rid of the __EventFilter and __FilterToConsumerBinding.
	//
	DeleteEFAndFTCB();

	//
	// Finally we can get rid of the actual ActionConfiguration instance, and the __EventConsumer.
	//
	wcscpy(szTemp, L"MicrosoftHM_ActionConfiguration.GUID=\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"");
	hRetRes = GetWbemObjectInst(&g_pIWbemServices, szTemp, NULL, &pInst);
	if (!pInst)
	{
		MY_HRESASSERT(hRetRes);
		return FALSE;
	}
	hRetRes = GetStrProperty(pInst, L"EventConsumer", &pszEventConsumer);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	pInst->Release();
	pInst = NULL;

	instName = SysAllocString(szTemp);
	MY_ASSERT(instName); if (!instName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	if ((hRes = g_pIWbemServices->DeleteInstance(instName, 0L,	NULL, NULL)) != S_OK)
	{
		MY_OUTPUT(L"ENTER ***** ActionConfiguration Delete failed...", 4);
	}
	SysFreeString(instName);
	instName = NULL;

	instName = SysAllocString(pszEventConsumer);
	MY_ASSERT(instName); if (!instName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	if ((hRes = g_pIWbemServices->DeleteInstance(instName, 0L,	NULL, NULL)) != S_OK)
	{
		MY_OUTPUT(L"ENTER ***** EventConsumer Delete failed...", 4);
	}
	SysFreeString(instName);
	instName = NULL;
	delete [] pszEventConsumer;
	pszEventConsumer = NULL;

	MY_OUTPUT(L"EXIT ***** CAction::DeleteAConfig...", 1);
	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (pszEventConsumer)
		delete [] pszEventConsumer;
	if (instName)
		SysFreeString(instName);
	if (Query)
		SysFreeString(Query);
	if (Language)
		SysFreeString(Language);
	if (pAssocObj)
		pAssocObj->Release();
	if (pEnum)
		pEnum->Release();
	if (pInst)
		pInst->Release();
	return FALSE;
}

// This is only for event sending related to going into a scheduled outage time,
// or the disabling of the action.
BOOL CAction::FireEvent(long lErrorCode, LPTSTR pszErrorDescription, int iResString)
{
	HRESULT hRetRes = S_OK;
	GUID guid;
	HRESULT hRes;
	BOOL bRetValue = TRUE;
	IWbemClassObject* pInstance = NULL;
	LPVOID lpMsgBuf = NULL;
	TCHAR szTemp[1024] = L"";
	TCHAR buf[256] = L"";

	MY_OUTPUT(L"ENTER ***** CAction::FireEvent...", 2);

	// Don't send if no-one is listening!
	if (g_pActionEventSink == NULL)
	{
		return bRetValue;
	}

	if (iResString != HMRES_ACTION_LOADFAIL)
	{
		if (m_pszStatusGUID)
		{
			delete [] m_pszStatusGUID;
			m_pszStatusGUID = NULL;
		}
		hRetRes = CoCreateGuid(&guid);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		m_pszStatusGUID = new TCHAR[100];
		MY_ASSERT(m_pszStatusGUID); if (!m_pszStatusGUID) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		StringFromGUID2(guid, m_pszStatusGUID, 100);

		wcscpy(m_szDTTime, m_szDTCurrTime);
		wcscpy(m_szTime, m_szCurrTime);
	}

	hRes = GetHMActionStatus(&pInstance, NULL, L"MicrosoftHM_ActionStatusEvent", iResString);
	if (SUCCEEDED(hRes))
	{
		// Add in the extra error info if available
		if (lErrorCode != -1)
		{
			if (g_hResLib == NULL || !LoadString(g_hResLib, iResString, szTemp, 1024))
			{
				MY_ASSERT(FALSE);
				wcscpy(szTemp, L"Could not locate resource string.");
			}
			wsprintf(buf, L" 0x%08x : ", lErrorCode);
			wcsncat(szTemp, buf, 1023-wcslen(szTemp));
			szTemp[1023] = '\0';
			if (g_hWbemComnModule)
			{
				FormatMessage(FORMAT_MESSAGE_MAX_WIDTH_MASK|FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE,
								g_hWbemComnModule, lErrorCode, 0, (LPTSTR) &lpMsgBuf, 0, NULL);
				if (lpMsgBuf)
				{
					wcsncat(szTemp, (LPCTSTR)lpMsgBuf, 1023-wcslen(szTemp));
					szTemp[1023] = '\0';
					LocalFree(lpMsgBuf);
					wcsncat(szTemp, L". ", 1023-wcslen(szTemp));
					szTemp[1023] = '\0';
				}
			}
			if (pszErrorDescription)
			{
				wcsncat(szTemp, pszErrorDescription, 1023-wcslen(szTemp));
				szTemp[1023] = '\0';
			}
			PutStrProperty(pInstance, L"Message", szTemp);
		}

		MY_OUTPUT2(L"EVENT: Action State Change=%d", m_lCurrState, 4);
		if (g_pActionEventSink) 
		{
			hRes = g_pActionEventSink->Indicate(1, &pInstance);
			//WBEM_E_SERVER_TOO_BUSY is Ok. Wbem will deliver.
			if (FAILED(hRes) && hRes != WBEM_E_SERVER_TOO_BUSY)
			{
				MY_HRESASSERT(hRes);
				bRetValue = FALSE;
				MY_OUTPUT(L"Failed on Indicate!", 4);
			}
		}

		pInstance->Release();
		pInstance = NULL;
	}
	else
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT(L"failed to get instance!", 1);
	}

	MY_OUTPUT(L"EXIT ***** CAction::FireEvent...", 2);
	return bRetValue;

error:
	MY_ASSERT(FALSE);
	if (pInstance)
		pInstance->Release();
	return FALSE;
}

HRESULT CAction::GetHMActionStatus(IWbemClassObject** ppInstance, IWbemClassObject* pObj, LPTSTR pszClass, int iResString)
{
	BOOL bRetValue = TRUE;
	IWbemClassObject* pClass = NULL;
	TCHAR szTemp[1024];
	BSTR bsString = NULL;
	HRESULT hRes;
	HRESULT hRetRes;
	VARIANT v;
	long lState;
	DWORD dwNameLen = MAX_COMPUTERNAME_LENGTH + 2;
	TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 2];
	VariantInit(&v);

	MY_OUTPUT(L"ENTER ***** CAction::GetHMActionStatus...", 1);

	bsString = SysAllocString(pszClass);
	MY_ASSERT(bsString); if (!bsString) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	hRes = g_pIWbemServices->GetObject(bsString, 0L, NULL, &pClass, NULL);
	SysFreeString(bsString);
	bsString = NULL;

	if (FAILED(hRes))
	{
		MY_HRESASSERT(hRes);
		return hRes;
	}

	hRes = pClass->SpawnInstance(0, ppInstance);
	pClass->Release();
	pClass = NULL;

	if (FAILED(hRes))
	{
		MY_HRESASSERT(hRes);
		return hRes;
	}

	if (iResString != HMRES_ACTION_LOADFAIL)
	{
		PutStrProperty(*ppInstance, L"GUID", m_szGUID);
		PutStrProperty(*ppInstance, L"Name", m_szName);

		if (GetComputerName(szComputerName, &dwNameLen))
		{
			PutStrProperty(*ppInstance, L"SystemName", szComputerName);
		}
		else
		{
			PutStrProperty(*ppInstance, L"SystemName", L"LocalMachine");
		}

		if (pObj)
		{
			hRetRes = GetUint32Property(pObj, L"State", &lState);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			PutUint32Property(*ppInstance, L"State", lState);
		}
		else
		{
			PutUint32Property(*ppInstance, L"State", m_lCurrState);
		}

		if (pObj)
		{
			VariantInit(&v);
			V_VT(&v) = VT_UNKNOWN;
			V_UNKNOWN(&v) = (IUnknown*)pObj;
			(V_UNKNOWN(&v))->AddRef();
			hRes = (*ppInstance)->Put(L"EmbeddedStatusEvent", 0L, &v, 0L);
			VariantClear(&v);
			MY_HRESASSERT(hRes);
		}

		PutStrProperty(*ppInstance, L"TimeGeneratedGMT", m_szDTCurrTime);
		PutStrProperty(*ppInstance, L"LocalTimeFormatted", m_szCurrTime);
		PutStrProperty(*ppInstance, L"StatusGUID", m_pszStatusGUID);
	}
	else
	{
		PutUint32Property(*ppInstance, L"State", HM_CRITICAL);
		PutStrProperty(*ppInstance, L"Name", L"...");
	}

	if (g_hResLib == NULL || !LoadString(g_hResLib, iResString, szTemp, 1024))
	{
		MY_ASSERT(FALSE);
		wcscpy(szTemp, L"Could not locate resource string.");
	}
	PutStrProperty(*ppInstance, L"Message", szTemp);

	MY_OUTPUT(L"EXIT ***** CAction::GetHMActionStatus...", 1);
	return hRes;

error:
	MY_ASSERT(FALSE);
	if (bsString)
		SysFreeString(bsString);
	if (pClass)
		pClass->Release();
	return hRetRes;
}

LPTSTR CAction::GetGUID(void)
{
	return m_szGUID;
}

HRESULT CAction::SendHMActionStatusInstances(IWbemObjectSink* pSink)
{
	HRESULT hRes = S_OK;
	IWbemClassObject* pObj = NULL;
	int iResString;

	MY_OUTPUT(L"ENTER ***** CAction::SendHMActionStatusInstances...", 2);

	if (m_bValidLoad == FALSE)
		return WBEM_E_INVALID_OBJECT;

	if (pSink == NULL)
	{
		MY_OUTPUT(L"Instances-Invalid Sink", 1);
		return WBEM_E_INVALID_PARAMETER;
	}

	if (m_lCurrState==HM_SCHEDULEDOUT)
	{
		iResString = HMRES_ACTION_OUTAGE;
	}
	else if (m_lCurrState==HM_DISABLED)
	{
		iResString = HMRES_ACTION_DISABLE;
	}
	else if (m_lCurrState==HM_CRITICAL)
	{
		iResString = HMRES_ACTION_FAILED;
	}
	else
	{
		iResString = HMRES_ACTION_ENABLE;
	}
	// Provide Instance
	hRes = GetHMActionStatus(&pObj, NULL, L"MicrosoftHM_ActionStatus", iResString);
	if (SUCCEEDED(hRes))
	{
		hRes = pSink->Indicate(1, &pObj);

		if (FAILED(hRes) && hRes!=WBEM_E_SERVER_TOO_BUSY && hRes!=WBEM_E_CALL_CANCELLED && hRes!=WBEM_E_TRANSPORT_FAILURE)
		{
			MY_HRESASSERT(hRes);
			MY_OUTPUT(L"SendHMSystemStatusInstances-failed to send status!", 1);
		}

		pObj->Release();
		pObj = NULL;
	}
	else
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT(L":SendHMSystemStatusInstances-failed to get instance!", 1);
	}

	MY_OUTPUT(L"EXIT ***** CAction::SendHMSystemStatusInstances...", 2);
	return hRes;
}

// For a single GetObject
HRESULT CAction::SendHMActionStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	MY_OUTPUT(L"ENTER ***** CAction::SendHMActionStatusInstance...", 1);

	//
	// Is this the one we are looking for?
	//
	if (!_wcsicmp(m_szGUID, pszGUID))
	{
		if (m_bValidLoad == FALSE)
			return WBEM_E_INVALID_OBJECT;

		SendHMActionStatusInstances(pSink);
		return S_OK;
	}

	MY_OUTPUT(L"EXIT ***** CAction::SendHMActionStatusInstance...", 1);
	return WBEM_S_DIFFERENT;
}

BOOL CAction::checkTime(void)
{
	BOOL bTimeOK;
	SYSTEMTIME st;	// system time

	//
	// Make sure that we are in a valid time to run.
	// NULL (-1) means run all the time.
	//
	bTimeOK = FALSE;
	if (m_bEnabled==TRUE)
	{
		GetLocalTime(&st);

		bTimeOK = FALSE;
		// Check the Day of the Week
		if (!(m_iActiveDays&(1<<st.wDayOfWeek)))
		{
		}
		else if (m_lBeginHourTime<0 || m_lEndHourTime<0)
		{
			bTimeOK = TRUE;
		}
		else if (m_lBeginHourTime==m_lEndHourTime && m_lBeginMinuteTime==m_lEndMinuteTime)
		{
			// Check the Hours of operation
			// First see if we are doing an inclusive time tests, or an exclusive time test
			// Case where the time is exactly equal, and that means run this once per day
			if (st.wHour==m_lBeginHourTime && st.wMinute==m_lBeginMinuteTime)
			{
				if (st.wSecond <= HM_POLLING_INTERVAL)
				{
					bTimeOK = TRUE;
				}
			}
		}
		else if ((m_lBeginHourTime < m_lEndHourTime) ||
			((m_lBeginHourTime==m_lEndHourTime) && m_lBeginMinuteTime < m_lEndMinuteTime))
		{
			// Inclusive case
			if ((m_lBeginHourTime < st.wHour) ||
				((m_lBeginHourTime == st.wHour) && m_lBeginMinuteTime <= st.wMinute))
			{
				if ((st.wHour < m_lEndHourTime) ||
					((st.wHour == m_lEndHourTime) && st.wMinute < m_lEndMinuteTime))
				{
					bTimeOK = TRUE;
				}
			}
		}
		else
		{
			// Exclusive case
			if ((m_lEndHourTime > st.wHour) ||
				((m_lEndHourTime == st.wHour) && m_lEndMinuteTime > st.wMinute))
			{
				bTimeOK = TRUE;
			}
			else if ((st.wHour > m_lBeginHourTime) ||
				((st.wHour == m_lBeginHourTime) && st.wMinute >= m_lBeginMinuteTime))
			{
				bTimeOK = TRUE;
			}
		}
	}

	return bTimeOK;
}

CBase *CAction::FindImediateChildByName(LPTSTR pszName)
{
	MY_ASSERT(FALSE);

	return NULL;
}

BOOL CAction::GetNextChildName(LPTSTR pszChildName, LPTSTR pszOutName)
{
	MY_ASSERT(FALSE);

	return NULL;
}

CBase *CAction::FindPointerFromName(LPTSTR pszName)
{
	MY_ASSERT(FALSE);

	return NULL;
}

#ifdef SAVE
BOOL CAction::ModifyAssocForMove(CBase *pNewParentBase)
{
	MY_ASSERT(FALSE);

	return TRUE;
}
#endif

BOOL CAction::ReceiveNewChildForMove(CBase *pBase)
{
	MY_ASSERT(FALSE);

	return FALSE;
}

BOOL CAction::DeleteChildFromList(LPTSTR pszGUID)
{
	MY_ASSERT(FALSE);

	return FALSE;
}

BOOL CAction::SendReminderActionIfStateIsSame(IWbemObjectSink* pActionEventSink, IWbemObjectSink* pActionTriggerEventSink, IWbemClassObject* pActionInstance, IWbemClassObject* pActionTriggerInstance, unsigned long ulTriggerStates)
{
	MY_ASSERT(FALSE);

	return FALSE;
}

BOOL CAction::HandleTempErrorEvent(BSTR szGUID, long lErrorCode, LPTSTR pszErrorDescription)
{
	if (m_bValidLoad == FALSE)
		return FALSE;

	//
	// Is this us we are looking for?
	//
	if (!_wcsicmp(m_szGUID, szGUID))
	{
		m_lCurrState = HM_CRITICAL;
		FireEvent(lErrorCode, pszErrorDescription, HMRES_ACTION_FAILED);
		return TRUE;
	}

	return FALSE;
}

BOOL CAction::Cleanup(BOOL bClearAll)
{
	int i, iSize;
	QSTRUCT *pQ;

	if (m_szName)
	{
		delete [] m_szName;
		m_szName = NULL;
	}
	if (m_szDescription)
	{
		delete [] m_szDescription;
		m_szDescription = NULL;
	}
	if (m_szTypeGUID)
	{
		delete [] m_szTypeGUID;
		m_szTypeGUID = NULL;
	}

	if (bClearAll)
	{
		if (m_pszStatusGUID)
		{
			delete [] m_pszStatusGUID;
			m_pszStatusGUID = NULL;
		}

		iSize = m_qList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_qList.size());
			pQ = &m_qList[i];
			if (pQ->szQuery)
				delete [] pQ->szQuery;

			if (pQ->szConfigActionAssocPath)
				delete [] pQ->szConfigActionAssocPath;

			if (pQ->szUserConfigPath)
				delete [] pQ->szUserConfigPath;

			if (pQ->szChildPath)
				delete [] pQ->szChildPath;

			if (pQ->pTempSink)
			{
				g_pIWbemServices->CancelAsyncCall((IWbemObjectSink*)pQ->pTempSink);
				pQ->pTempSink->Release();
				pQ->pTempSink = NULL;
			}
		}
		m_qList.clear();
	}

	return TRUE;
}

HRESULT CAction::RemapAction(void)
{
	HRESULT hRetRes = S_OK;
	QLIST qList;
	TCHAR szTemp[1024];
	LPTSTR pStr2;
	TCHAR *pszEventConsumer = NULL;
	LPTSTR pStr;
	IWbemClassObject* pInst = NULL;

	MY_OUTPUT(L"ENTER ***** CAction::RemapAction...", 1);

	wcscpy(szTemp, L"MicrosoftHM_ActionConfiguration.GUID=\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"");
	hRetRes = GetWbemObjectInst(&g_pIWbemServices, szTemp, NULL, &pInst);
	if (!pInst)
	{
		MY_HRESASSERT(hRetRes);
		return FALSE;
	}
	hRetRes = GetStrProperty(pInst, L"EventConsumer", &pszEventConsumer);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	pInst->Release();
	pInst = NULL;

	//
	// __EventConsumer.
	//
	hRetRes = GetWbemObjectInst(&g_pIWbemServices, pszEventConsumer, NULL, &pInst);
	if (!pInst)
	{
		MY_HRESASSERT(hRetRes);
		return FALSE;
	}
	hRetRes = RemapOneAction(pInst);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	pInst->Release();
	pInst = NULL;

	//
	// __EventFilter.
	//
	wcscpy(szTemp, L"__EventFilter.Name=\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"");
	hRetRes = GetWbemObjectInst(&g_pIWbemServices, szTemp, NULL, &pInst);
	if (!pInst)
	{
		MY_HRESASSERT(hRetRes);
		return FALSE;
	}
	hRetRes = RemapOneAction(pInst);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	pInst->Release();
	pInst = NULL;

	//
	// __FilterToConsumerBinding
	//
	// We need to format the strings a bit, need extra backslashes in there
	pStr = wcschr(pszEventConsumer, ':');
	MY_ASSERT(pStr); if (!pStr) goto Badstring;
	pStr++;
	pStr2 = wcschr(pStr, '\"');
	MY_ASSERT(pStr2); if (!pStr2) goto Badstring;
	*pStr2 = '\0';
	wcscpy(szTemp, L"__FilterToConsumerBinding.Consumer=\"");
	lstrcat(szTemp, L"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:");
	lstrcat(szTemp, pStr);
	lstrcat(szTemp, L"\\\"");
	pStr = pStr2;
	pStr++;
	pStr2 = wcschr(pStr, '\"');
	MY_ASSERT(pStr2); if (!pStr2) goto Badstring;
	*pStr2 = '\0';
	lstrcat(szTemp, pStr);
	lstrcat(szTemp, L"\\\"\",Filter=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:");

	lstrcat(szTemp, L"__EventFilter.Name=\\\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\\\"\"");

	hRetRes = GetWbemObjectInst(&g_pIWbemServices, szTemp, NULL, &pInst);
	if (!pInst)
	{
		MY_HRESASSERT(hRetRes);
		return FALSE;
	}
	hRetRes = RemapOneAction(pInst);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	pInst->Release();
	pInst = NULL;
	goto Goodstring;

Badstring:
	MY_OUTPUT(L"ENTER ***** Bad FilterToConsumer string", 4);
Goodstring:
	delete [] pszEventConsumer;
	pszEventConsumer = NULL;

	MY_OUTPUT(L"EXIT ***** CAction::RemapAction...", 1);
	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (pszEventConsumer)
		delete [] pszEventConsumer;
	if (pInst)
		pInst->Release();
	return FALSE;
}

HRESULT CAction::RemapOneAction(IWbemClassObject* pObj)
{
	HANDLE hToken = NULL;
	HRESULT hRetRes = S_OK;
	IWbemCallResult *pResult = 0;
	SAFEARRAY* psa = NULL;
	VARIANT	var;
	CIMTYPE vtType;
	long lBound, uBound;
	BOOL bObjIsLocalSystem;
	BOOL bSuccess;
	SID_IDENTIFIER_AUTHORITY ntauth = SECURITY_NT_AUTHORITY;
	DWORD dwLengthNeeded;
	void* psid = 0;
	PTOKEN_USER pUserInfo = NULL;

	VariantInit(&var);

	// Need to verify that we're in fact running under the LocalSystem SID!
	// otherwise we'd end up in an infinite loop!  Need an assert to check that
	// the current thread is running as LocalSystem.
	bSuccess = OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken);
	MY_ASSERT(bSuccess); if (!bSuccess) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

	// Call GetTokenInformation to get the buffer size.
	dwLengthNeeded = 0;
	bSuccess = GetTokenInformation(hToken, TokenUser, NULL, dwLengthNeeded, &dwLengthNeeded);

	// Allocate the buffer.
	pUserInfo = (PTOKEN_USER) GlobalAlloc(GPTR, dwLengthNeeded);
	MY_ASSERT(pUserInfo); if (!pUserInfo) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

	// Call GetTokenInformation again to get the group information.
	bSuccess = GetTokenInformation(hToken, TokenUser, pUserInfo, dwLengthNeeded, &dwLengthNeeded);
	MY_ASSERT(bSuccess); if (!bSuccess) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

	bSuccess = AllocateAndInitializeSid(&ntauth, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &psid);
	MY_ASSERT(bSuccess); if (!bSuccess) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

	// Verify that winmgmt is running under LocalSystem. If not we don't do anything.
	if (EqualSid(pUserInfo->User.Sid, psid))
	{
		// get the CreatorSID of this instance
		hRetRes = pObj->Get(L"CreatorSID", 0, &var, &vtType, NULL);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		if (vtType != (CIM_UINT8 | CIM_FLAG_ARRAY))
		{
			hRetRes = WBEM_E_FAILED;
			goto error;
		}

		// make sure it's the right size
		psa = var.parray;
		if (::SafeArrayGetElemsize(psa) != 1)
		{
			hRetRes = WBEM_E_FAILED;
			goto error;
		}

		hRetRes = ::SafeArrayGetLBound(psa, 1, &lBound);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = ::SafeArrayGetUBound(psa, 1, &uBound);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		if (lBound !=0)
		{
			hRetRes = WBEM_E_FAILED;
			goto error;
		}

		// now see if this is LocalSystem by comparing to 
		// the hardcoded LocalSystem SID
		bObjIsLocalSystem = false;
		if (uBound == (sizeof LocalSystemSID)-1 )
		{
			LPVOID lpCreatorSID = NULL;
			hRetRes = ::SafeArrayAccessData(psa, &lpCreatorSID);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			if (memcmp (lpCreatorSID, LocalSystemSID, sizeof LocalSystemSID) == 0)
			{
				bObjIsLocalSystem = true;
			}
			hRetRes = ::SafeArrayUnaccessData(psa);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		}

		// If it's not a LocalSystem SID, to replace it with a LocalSytem SID,
		// we need to just store the instance in WMI-- WMI will automatically
		// replace the SID that's there with our SID-- LocalSystem.
		//
		if (bObjIsLocalSystem == FALSE)
		{
			hRetRes = g_pIWbemServices->PutInstance(pObj, WBEM_FLAG_UPDATE_ONLY, NULL, &pResult);
//			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		}
		VariantClear(&var);
	}

	CloseHandle(hToken);
	FreeSid(psid);
	if (pUserInfo)
		GlobalFree(pUserInfo);
	return S_OK;

error:
MY_OUTPUT2(L"11 0x%08x\n",hRetRes,5);
	MY_ASSERT(FALSE);
	VariantClear(&var);
	CloseHandle(hToken);
	FreeSid(psid);
	if (pUserInfo)
		GlobalFree(pUserInfo);
	return hRetRes;
}

HRESULT CAction::CheckForBadLoad(void)
{
	HRESULT hRetRes = S_OK;
	IWbemClassObject* pObj = NULL;
	TCHAR szTemp[1024];

	if (m_bValidLoad == FALSE)
	{
		wcscpy(szTemp, L"MicrosoftHM_ActionConfiguration.GUID=\"");
		lstrcat(szTemp, m_szGUID);
		lstrcat(szTemp, L"\"");
		hRetRes = GetWbemObjectInst(&g_pIWbemServices, szTemp, NULL, &pObj);
		if (!pObj)
		{
			MY_HRESASSERT(hRetRes);
			return S_FALSE;
		}
		hRetRes = LoadInstanceFromMOF(pObj, FALSE);
		// Here is where we can try and send out a generic SOS if the load failed each time!!!
		if (hRetRes != S_OK)
		{
			FireEvent(-1, NULL, HMRES_ACTION_LOADFAIL);
		}
		MY_HRESASSERT(hRetRes);
		pObj->Release();
		pObj = NULL;
		return hRetRes;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\base.cpp ===
//***************************************************************************
//
//  BASE.CPP
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: Abstract base class for CSystem, CDataGroup, CDataCollector, CThreshold and CAction
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "base.h"

extern HMODULE g_hModule;
// STATIC DATA
HRLLIST CBase::mg_hrlList;
ILIST CBase::mg_DGEventList;
ILIST CBase::mg_DCEventList;
ILIST CBase::mg_DCPerInstanceEventList;
ILIST CBase::mg_TEventList;
//ILIST CBase::mg_TIEventList;
ILIST CBase::mg_DCStatsEventList;

ILIST CBase::mg_DCStatsInstList;
TCHAR CBase::m_szDTCurrTime[512];
TCHAR CBase::m_szCurrTime[512];

//STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC
void CBase::CalcCurrTime(void)
{
	TCHAR szTemp[512];
	SYSTEMTIME st;	// system time

	// Formatted as follows -> "20000814135809.000000+***"
	GetSystemTime(&st);
	swprintf(m_szDTCurrTime, L"%04d%02d%02d%02d%02d%02d.000000+000",
   		st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);

//	GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SLONGDATE, szTemp, 100);
//	GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SSHORTDATE, szTemp, 100);
	m_szCurrTime[0] = '\0';
//	GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, NULL, szTemp, m_szCurrTime, 100);
	GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, NULL, NULL, m_szCurrTime, 100);
	GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, NULL, NULL, szTemp, 100);
	wcscat(m_szCurrTime, L" ");
	wcscat(m_szCurrTime, szTemp);

	return;
}

//STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC
void CBase::CleanupHRLList(void)
{
	HRLSTRUCT *phrl;
	int iSize;
	int i;

	// Since this is a global shared array, we need to do this
	// in a static function.

	iSize = mg_hrlList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<mg_hrlList.size());
		phrl = &mg_hrlList[i];
		FreeLibrary(phrl->hResLib);
	}
}

void CBase::CleanupEventLists(void)
{
	int i, iSize;
	IWbemClassObject* pInstance = NULL;

	// Since this is a global shared array, we need to do this
	// in a static function.

	iSize = mg_DGEventList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<mg_DGEventList.size());
		pInstance = mg_DGEventList[i];
    	pInstance->Release();
		pInstance = NULL;
	}
	mg_DGEventList.clear();

	iSize = mg_DCEventList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<mg_DCEventList.size());
		pInstance = mg_DCEventList[i];
    	pInstance->Release();
		pInstance = NULL;
	}
	mg_DCEventList.clear();

	iSize = mg_DCPerInstanceEventList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<mg_DCPerInstanceEventList.size());
		pInstance = mg_DCPerInstanceEventList[i];
    	pInstance->Release();
		pInstance = NULL;
	}
	mg_DCPerInstanceEventList.clear();

	iSize = mg_TEventList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<mg_TEventList.size());
		pInstance = mg_TEventList[i];
    	pInstance->Release();
		pInstance = NULL;
	}
	mg_TEventList.clear();

#ifdef SAVE
	iSize = mg_TIEventList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<mg_TIEventList.size());
		pInstance = mg_TIEventList[i];
    	pInstance->Release();
		pInstance = NULL;
	}
	mg_TIEventList.clear();
#endif

	iSize = mg_DCStatsEventList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<mg_DCStatsEventList.size());
		pInstance = mg_DCStatsEventList[i];
    	pInstance->Release();
		pInstance = NULL;
	}
	mg_DCStatsEventList.clear();

	iSize = mg_DCStatsInstList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<mg_DCStatsInstList.size());
		pInstance = mg_DCStatsInstList[i];
    	pInstance->Release();
		pInstance = NULL;
	}
	mg_DCStatsInstList.clear();

}
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBase::CBase()
{
//	m_hResLib = NULL;
}

CBase::~CBase()
{
	MY_OUTPUT(L"ENTER ***** CBaseDestuctor...", 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\base.h ===
//***************************************************************************
//
//  BASE.H
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: Abstract base class for CSystem, CDataGroup, CDataCollector, CThreshold and CAction
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#if !defined( __BASE_H )
#define __BASE_H

//#include <wbemcli.h>
#include <vector>
//#include <iterator>
#include "global.h"

enum HMSTATUS_TYPE {HMSTATUS_SYSTEM, HMSTATUS_DATAGROUP, HMSTATUS_DATACOLLECTOR, HMSTATUS_THRESHOLD, HMSTATUS_ACTION};

typedef struct _tag_HRLStruct
{
	LPTSTR szTargetResourceDLL;
	HINSTANCE hResLib;
} HRLSTRUCT, *PHRLSTRUCT;

typedef std::vector<HRLSTRUCT, std::allocator<HRLSTRUCT> > HRLLIST;

typedef std::vector<IWbemClassObject*, std::allocator<IWbemClassObject*> > ILIST;

class CBase
{
public:
	CBase();
	virtual ~CBase();

	long m_lCurrState;
//	LPTSTR m_szResourceDLL;
	LPTSTR m_szName;
	LPTSTR m_szGUID;
	HMSTATUS_TYPE m_hmStatusType;

	//
	// STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC
	//
	static void CleanupHRLList(void);
	static void CleanupEventLists(void);
	static void CalcCurrTime(void);
	static HRLLIST mg_hrlList;
	static ILIST mg_DGEventList;
	static ILIST mg_DCEventList;
	static ILIST mg_DCPerInstanceEventList;
	static ILIST mg_TEventList;
//	static ILIST mg_TIEventList;
	static ILIST mg_DCStatsEventList;

	static ILIST mg_DCStatsInstList;
	static TCHAR m_szDTCurrTime[512];
	static TCHAR m_szCurrTime[512];

//	BOOL fillInResourceHandle(void);
	virtual CBase *FindImediateChildByName(LPTSTR pszChildName) = 0;
	virtual BOOL GetNextChildName(LPTSTR pszChildName, LPTSTR pszOutName) = 0;
	virtual CBase *FindPointerFromName(LPTSTR pszChildName) = 0;
//	virtual BOOL ModifyAssocForMove(CBase *pNewParentBase) = 0;
	virtual BOOL ReceiveNewChildForMove(CBase *pBase) = 0;
	virtual BOOL DeleteChildFromList(LPTSTR pszGUID) = 0;
	virtual BOOL SendReminderActionIfStateIsSame(IWbemObjectSink* pActionEventSink, IWbemObjectSink* pActionTriggerEventSink, IWbemClassObject* pActionInstance, IWbemClassObject* pActionTriggerInstance, unsigned long ulTriggerStates) = 0;
	virtual HRESULT CheckForBadLoad(void) = 0;
};
#endif  // __BASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\consumer.h ===
// Consumer.h: interface for the CConsumer class.
//
//////////////////////////////////////////////////////////////////////

#if !defined( __CONSUMER_H )
#define __CONSUMER_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CConsumer : public IWbemUnboundObjectSink
{
// Constructor/Destructor
public:
	CConsumer();
	virtual ~CConsumer();


public:
// IUnknown
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID* ppv);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

// IWbemUnboundObjectSink override
	STDMETHODIMP IndicateToConsumer(IWbemClassObject* pLogicalConsumer,
							LONG lNumObjects, IWbemClassObject** ppObjects);

// CConsumer
private:
	HRESULT ProcessEvent(IWbemClassObject*);
	HRESULT ProcessModEvent(IWbemClassObject*, IWbemClassObject*);
//	HRESULT GetWbemClassObject(IWbemClassObject**, VARIANT*);

private:
	DWORD						m_cRef;

// Static thread function
protected:
	static unsigned int __stdcall Update(void *pv);

	HANDLE		m_hUpdateThrdFn;
	unsigned	m_uThrdId;
	long		m_lAgentInterval;

};

#endif  // __CONSUMER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\consumer.cpp ===
// Consumer.cpp: implementation of the CConsumer class.
//
//  Copyright (c)1999-20000 Microsoft Corporation, All Rights Reserved
//////////////////////////////////////////////////////////////////////
#define HM_AGENT_INTERVAL	1000

#include <atlbase.h>

#include "hmagent.h"
#include "system.h"
#include "Consumer.h"
#include <process.h>
#include "global.h"

extern CSystem* g_pSystem;
extern HANDLE g_hConfigLock;
extern HANDLE g_hThrdDie;
extern HANDLE g_hThrdDead;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CConsumer::CConsumer()
{
	// one and only instance of Consumer.
	MY_OUTPUT(L"ENTER CConsumer::CConsumer()", 1);

	m_cRef = 1;
	m_uThrdId = 0;
	m_hUpdateThrdFn = NULL;

	// Set the polling interval. Default to 1 sec. if the value is invalid
	m_lAgentInterval = HM_AGENT_INTERVAL;

	// If this ever fails, the agent will not be able to do any work
	if( (m_hUpdateThrdFn = 
		(HANDLE)_beginthreadex(NULL, 0, Update, this, 0, &m_uThrdId)) ==0)
	{
		OutputDebugString(L"_beginthreadex FAILED! HM agent inactive\n");
	}

	MY_ASSERT(m_hUpdateThrdFn);
}

CConsumer::~CConsumer()
{
	MY_OUTPUT(L"CConsumer::~CConsumer", 1);

	if(!SetEvent(g_hThrdDie))
	{
		DWORD dwErr = GetLastError();
		MY_OUTPUT(L"SetEvent for CConsumer failed with error ",dwErr);
	}

	// *** At this point, WBEM already terminated our thread.
}

// Static thread fuction to update data point.
unsigned int __stdcall CConsumer::Update(void *pv)
{
	CConsumer* pThis = (CConsumer*)pv;
	BOOL bRet = FALSE;

	while(1)
	{
		if (WAIT_OBJECT_0 == WaitForSingleObject(g_hThrdDie, pThis->m_lAgentInterval))
		{
			MY_OUTPUT(L"CConsumer::Update()-Told to die!", 1);
			SetEvent(g_hThrdDead);
			break;
		}
		if (WaitForSingleObject(g_hConfigLock, HM_ASYNC_TIMEOUT) != WAIT_OBJECT_0)
		{
			continue;
		}

		if (!g_pSystem)
		{
			ReleaseMutex(g_hConfigLock);
			continue;
		}

		bRet = g_pSystem->OnAgentInterval();
		
		ReleaseMutex(g_hConfigLock);
	}
	
	_endthreadex(0);
	return 0;
}

//////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//////////////////////////////////////////////////////////////////////
STDMETHODIMP CConsumer::QueryInterface(REFIID riid, LPVOID* ppv)
{
	*ppv = NULL;

	if (riid == IID_IUnknown || riid == IID_IWbemUnboundObjectSink)
	{
		*ppv = this;
		AddRef();
		return S_OK;
	}

	return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CConsumer::AddRef(void)
{
	return InterlockedIncrement((long*)&m_cRef);
}

STDMETHODIMP_(ULONG) CConsumer::Release(void)
{
	return InterlockedDecrement((long*)&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// IWbemUnboundObjectSink Implementation
//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// IndicateToConsumer: Consumes following HealthMon events :
// Timer Event, Threshold modification event(HMDataPoint), 
// and Category update event(HMStaticCatStatus).

STDMETHODIMP CConsumer::IndicateToConsumer(IWbemClassObject* pLogicalConsumer,
LONG lNumObjects, IWbemClassObject** ppObjects)
{
	MY_OUTPUT(L"ENTER CConsumer::IndicateToConsumer()", 1);
	
	HRESULT hRes = S_OK;

	// WBEM may deliver multiple events
	for (long i = 0; i < lNumObjects; i++)
	{
		hRes = ProcessEvent(ppObjects[i]);

		if (FAILED(hRes))
		{
			MY_OUTPUT2(L"CConsumer::IndicateToConsumer() Failed tp process event: 0x%08x\n",hRes,4);
		}

	}	// end for loop

	if (hRes == WBEM_E_NOT_FOUND)	// ok, otherwise CIMOM will reque this event
	{
		hRes = S_OK;				
	}

	MY_OUTPUT(L"EXIT CConsumer::IndicateToConsumer()", 1);
	return hRes;
}

//////////////////////////////////////////////////////////////////////
// CConsumer Implementation
//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// ProcessEvent: Processes CIMOM events
//
HRESULT CConsumer::ProcessEvent(IWbemClassObject* pClass)
{
	VARIANT vDispatch;
 
	MY_OUTPUT(L"CConsumer::ProcessEvent()", 1);

	//
	// Decide if it is a Timer, Creation, Modification, Deletion or some type of event.
	//
	VariantInit(&vDispatch);
	HRESULT hRes = pClass->Get(L"TargetInstance", 0L, &vDispatch, 0, 0); 

	switch (hRes)
	{
	case WBEM_E_NOT_FOUND:
		{
			// Timer Event
			hRes = S_OK;
			VariantClear(&vDispatch);
			break;
		}
	case WBEM_S_NO_ERROR:
		{
			IWbemClassObject* pTargetInstance = NULL;
			hRes = GetWbemClassObject(&pTargetInstance, &vDispatch);
			MY_HRESASSERT(hRes);

			if (SUCCEEDED(hRes))
			{
				hRes = ProcessModEvent(pClass, pTargetInstance);
			}

			if (pTargetInstance)
			{
				pTargetInstance->Release();
			}
			VariantClear(&vDispatch);
			break;
		}
	default:
		{
			MY_HRESASSERT(hRes);
			MY_OUTPUT2(L"CConsumer::ProcessEvent()-Unexpected Error: 0x%08x\n",hRes,4);
			break;
		}
	} // end switch

	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// ProcessModEvent: Processes the inst. modification events
//
HRESULT CConsumer::ProcessModEvent(IWbemClassObject* pClass, IWbemClassObject* pInst)
{
	TCHAR szParent[HM_MAX_PATH];
	TCHAR szChild[HM_MAX_PATH];
	CComVariant	vInstClassName;
	CComVariant	vOperationClassName;
	CComVariant	vParent;
	CComVariant	vChild;
	HRESULT hRes = S_OK;
	TCHAR	*pszInstName = NULL;
	TCHAR	*pszOperationName = NULL;
	BOOL	bMod = FALSE;
	DWORD dwErr = 0;

	MY_OUTPUT(L"CConsumer::ProcessModEvent()", 1);

	// So we don't step on our toes.
	dwErr = WaitForSingleObject(g_hConfigLock, HM_ASYNC_TIMEOUT);
	if(dwErr != WAIT_OBJECT_0)
	{
		if(dwErr = WAIT_TIMEOUT)
		{
			TRACE_MUTEX(L"TIMEOUT MUTEX");
			return WBEM_S_TIMEDOUT;
		}
		else
		{
			MY_OUTPUT(L"WaitForSingleObject on Mutex failed",4);
			return WBEM_E_FAILED;
		}
	}

	if (!g_pSystem)
	{
		ReleaseMutex(g_hConfigLock);
		return hRes;
	}

	hRes = pInst->Get(L"__CLASS", 0L, &vInstClassName, 0L, 0L);
	if (FAILED(hRes))
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT(L"CConsumer::ValidateModEvent()-Unexpected Error!", 4);
		ReleaseMutex(g_hConfigLock);
		return hRes;
	}
	
	hRes = pClass->Get(L"__CLASS", 0L, &vOperationClassName, 0L, 0L);
	if (FAILED(hRes))
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT(L"CConsumer::ValidateModEvent()-Unexpected Error!", 4);
		ReleaseMutex(g_hConfigLock);
		return hRes;
	}
	
	pszInstName = V_BSTR(&vInstClassName);
	pszOperationName = V_BSTR(&vOperationClassName);
	MY_ASSERT(wcslen(pszInstName) > HM_PREFIX_LEN);
	
	if(wcscmp(pszOperationName, HM_MOD_CLASS_NAME)==0)
	{
		bMod = TRUE;
	}
	else
	{
		bMod = FALSE;
	}


	try
	{
	if (!wcscmp(L"SystemConfiguration", pszInstName+HM_PREFIX_LEN))
	{
		if (bMod)
		{
			hRes = g_pSystem->ModSystem(pInst);
		}
		else
		{
//XXXSend out a CRITICAL MESSAGE, Tell them they need to re-install the agent
			MY_ASSERT(FALSE);
			hRes =  S_FALSE;
		}
	}
	else if (!wcscmp(L"DataGroupConfiguration", pszInstName+HM_PREFIX_LEN))
	{
		if (bMod)
		{
			hRes = g_pSystem->ModDataGroup(pInst);
		}
		else
		{
			MY_ASSERT(FALSE);
			hRes =  S_FALSE;
		}
	}
	else if (!wcscmp(L"PolledGetObjectDataCollectorConfiguration", pszInstName+HM_PREFIX_LEN))
	{
		if (bMod)
		{
			hRes = g_pSystem->ModDataCollector(pInst);
		}
		else
		{
			MY_ASSERT(FALSE);
			hRes =  S_FALSE;
		}
	}
	else if (!wcscmp(L"PolledMethodDataCollectorConfiguration", pszInstName+HM_PREFIX_LEN))
	{
		if (bMod)
		{
			hRes = g_pSystem->ModDataCollector(pInst);
		}
		else
		{
			MY_ASSERT(FALSE);
			hRes =  S_FALSE;
		}
	}
	else if (!wcscmp(L"PolledQueryDataCollectorConfiguration", pszInstName+HM_PREFIX_LEN))
	{
		if (bMod)
		{
			hRes = g_pSystem->ModDataCollector(pInst);
		}
		else
		{
			MY_ASSERT(FALSE);
			hRes =  S_FALSE;
		}
	}
	else if (!wcscmp(L"EventQueryDataCollectorConfiguration", pszInstName+HM_PREFIX_LEN))
	{
		if (bMod)
		{
			hRes = g_pSystem->ModDataCollector(pInst);
		}
		else
		{
			MY_ASSERT(FALSE);
			hRes =  S_FALSE;
		}
	}
	else if (!wcscmp(L"ThresholdConfiguration", pszInstName+HM_PREFIX_LEN))
	{
		if (bMod)
		{
			hRes = g_pSystem->ModThreshold(pInst);
		}
		else
		{
			MY_ASSERT(FALSE);
			hRes =  S_FALSE;
		}
	}
	else if (!wcscmp(L"ActionConfiguration", pszInstName+HM_PREFIX_LEN))
	{
		if (bMod)
		{
			hRes = g_pSystem->ModAction(pInst);
		}
		else if (!wcscmp(L"__InstanceCreationEvent", pszOperationName))
		{
			hRes = g_pSystem->CreateAction(pInst);
		}
		else
		{
			MY_ASSERT(FALSE);
			hRes =  S_FALSE;
		}
	}
	else if (!wcscmp(L"ConfigurationActionAssociation", pszInstName+HM_PREFIX_LEN))
	{
		if (bMod)
		{
			g_pSystem->ModActionAssociation(pInst);
		}
		else if (!wcscmp(L"__InstanceCreationEvent", pszOperationName))
		{
			g_pSystem->CreateActionAssociation(pInst);
		}
		else if (!wcscmp(L"__InstanceDeletionEvent", pszOperationName))
		{
//XXX			g_pSystem->DeleteActionAssociation(pInst);
		}
		else
		{
			MY_ASSERT(FALSE);
			hRes =  S_FALSE;
		}
	}
	else if (!wcscmp(L"ConfigurationAssociation", pszInstName+HM_PREFIX_LEN))
	{
		if (!wcscmp(L"__InstanceCreationEvent", pszOperationName))
		{
			
			hRes = pInst->Get(L"ParentPath", 0L, &vParent, 0L, 0L);
			if (FAILED(hRes))
			{
				MY_HRESASSERT(hRes);
			
			}
			else
			{
			
				hRes = pInst->Get(L"ChildPath", 0L, &vChild, 0L, 0L);
				if (FAILED(hRes))
				{
					MY_HRESASSERT(hRes);
				}
				else
				{
					wcscpy(szParent, V_BSTR(&vParent));
					wcscpy(szChild, V_BSTR(&vChild));
					if (wcsstr(szParent, L"MicrosoftHM_SystemConfiguration") &&
						wcsstr(szChild, L"MicrosoftHM_DataGroupConfiguration"))
					{
						hRes = g_pSystem->CreateSystemDataGroupAssociation(pInst);
					}
					else if (wcsstr(szParent, L"MicrosoftHM_DataGroupConfiguration") &&
							 wcsstr(szChild, L"MicrosoftHM_DataGroupConfiguration"))
					{
						hRes = g_pSystem->CreateDataGroupDataGroupAssociation(pInst);
					}
					else if (wcsstr(szParent, L"MicrosoftHM_DataGroupConfiguration") &&
							(wcsstr(szChild, L"MicrosoftHM_DataCollectorConfiguration") ||
							 wcsstr(szChild, L"MicrosoftHM_PolledGetObjectDataCollectorConfiguration") ||
							 wcsstr(szChild, L"MicrosoftHM_PolledMethodDataCollectorConfiguration") ||
							 wcsstr(szChild, L"MicrosoftHM_PolledQueryDataCollectorConfiguration") ||
							 wcsstr(szChild, L"MicrosoftHM_EventQueryDataCollectorConfiguration")
							 ))
					{
						hRes = g_pSystem->CreateDataGroupDataCollectorAssociation(pInst);
					}
					else if ((wcsstr(szParent, L"MicrosoftHM_DataCollectorConfiguration") ||
							 wcsstr(szParent, L"MicrosoftHM_PolledGetObjectDataCollectorConfiguration") ||
							 wcsstr(szParent, L"MicrosoftHM_PolledMethodDataCollectorConfiguration") ||
							 wcsstr(szParent, L"MicrosoftHM_PolledQueryDataCollectorConfiguration") ||
							 wcsstr(szParent, L"MicrosoftHM_EventQueryDataCollectorConfiguration")
							 ) &&
							 wcsstr(szChild, L"MicrosoftHM_ThresholdConfiguration"))
					{
						hRes = g_pSystem->CreateDataCollectorThresholdAssociation(pInst);
					}
				}
			}
		}
		else
		{
			MY_ASSERT(FALSE);
			hRes =  S_FALSE;
		}
	}
	else
	{
		MY_ASSERT(FALSE);
		hRes =  S_FALSE;
	}

	}
	catch (...)
	{
		MY_ASSERT(FALSE);
		hRes =  S_FALSE;
	}

	ReleaseMutex(g_hConfigLock);

	MY_OUTPUT(L"EXIT CConsumer::ProcessModEvent()", 1);
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\datacltr.cpp ===
//***************************************************************************
//
//  DATACLTR.CPP
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: CDataCollector class to do WMI instance collection.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <tchar.h>
#include "datacltr.h"
#include "datagrp.h"
#include "system.h"

extern CSystem* g_pSystem;
extern CSystem* g_pStartupSystem;
extern LPTSTR conditionLocStr[10];
extern LPTSTR stateLocStr[9];

// STATIC DATA
NSLIST CDataCollector::mg_nsList;

//STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC
void CDataCollector::DETerminationCleanup(void)
{
	NSSTRUCT *pns;
	int iSize;
	int i;

	// Since this is a global shared array, we need to do this
	// in a static function.
	iSize = mg_nsList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<mg_nsList.size());
		pns = &mg_nsList[i];
		pns->pIWbemServices->Release();
		pns->pIWbemServices = NULL;
		if (pns->szTargetNamespace)
		{
			delete [] pns->szTargetNamespace;
			pns->szTargetNamespace = NULL;
		}
		if (pns->szLocal)
		{
			delete [] pns->szLocal;
			pns->szLocal = NULL;
		}
	}

	if (g_pDataCollectorEventSink != NULL)
	{
		g_pDataCollectorEventSink->Release();
		g_pDataCollectorEventSink = NULL;
	}

	if (g_pDataCollectorPerInstanceEventSink != NULL)
	{
		g_pDataCollectorPerInstanceEventSink->Release();
		g_pDataCollectorPerInstanceEventSink = NULL;
	}
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataCollector::CDataCollector()
{

	MY_OUTPUT(L"ENTER ***** CDataCollector...", 4);

	Init();
	m_hmStatusType = HMSTATUS_DATACOLLECTOR;
	m_bValidLoad = FALSE;

	MY_OUTPUT(L"EXIT ***** CDataCollector...", 4);
}

CDataCollector::~CDataCollector()
{
	MY_OUTPUT(L"ENTER ***** ~CDataCollector...", 4);

	g_pStartupSystem->RemovePointerFromMasterList(this);
	m_bValidLoad = TRUE;
	Cleanup(FALSE);
	if (m_szGUID)
	{
		delete [] m_szGUID;
		m_szGUID = NULL;
	}
	if (m_szParentObjPath)
	{
		delete [] m_szParentObjPath;
		m_szParentObjPath = NULL;
	}

	MY_OUTPUT(L"EXIT ***** ~CDataCollector...", 4);
}

// get polling interval in milliseconds.
long CDataCollector::GetCollectionIntervalMultiple()
{
	return m_lCollectionIntervalMultiple;
}

//
// We keep a global static list of pointers to namespaces, so we can share them
// and be more efficient about it. Each time a new one comes in, we add it to the
// list.
//
HRESULT CDataCollector::fillInNamespacePointer(void)
{
	HRESULT hRetRes = S_OK;
	int i;
	int iSize;
	BSTR bsNamespace = NULL;
	BSTR bsLocal = NULL;
	BOOL bFound = FALSE;
	NSSTRUCT ns;
	NSSTRUCT *pns;
	IWbemLocator *pLocator = NULL;
	IWbemServices *pService = NULL;
	ns.szTargetNamespace = NULL;
	ns.szLocal = NULL;

	MY_OUTPUT(L"ENTER ***** fillInNamespacePointer...", 4);
	hRetRes = CoCreateInstance(CLSID_WbemAdministrativeLocator, NULL,
													CLSCTX_INPROC_SERVER,
													IID_IWbemLocator,
													(LPVOID*) &pLocator);
	if (FAILED(hRetRes))
	{
		MY_HRESASSERT(hRetRes);
		return hRetRes;
	}
	MY_ASSERT(pLocator);

	// We already have apointer to the local Healthmon namespace
	if (!_wcsicmp(m_szTargetNamespace, L"healthmon"))
	{
		m_pIWbemServices = g_pIWbemServices;
	}
	else
	{
		iSize = mg_nsList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<mg_nsList.size());
			pns = &mg_nsList[i];
			if (!_wcsicmp(m_szTargetNamespace, pns->szTargetNamespace) && !_wcsicmp(m_szLocal, pns->szLocal))
			{
				m_pIWbemServices = pns->pIWbemServices;
				bFound = TRUE;
				break;
			}
		}

		if (bFound == FALSE)
		{
			bsNamespace = SysAllocString(m_szTargetNamespace);
			MY_ASSERT(bsNamespace); if (!bsNamespace) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			if (_wcsicmp(m_szLocal, L""))
			{
				bsLocal = SysAllocString(m_szLocal);
				MY_ASSERT(bsLocal); if (!bsLocal) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			}
		
			hRetRes = pLocator->ConnectServer(bsNamespace, 
										NULL, 
										NULL, 
										bsLocal, 
										0L,
										NULL, 
										NULL, 
										&pService);

			if (FAILED(hRetRes))
			{
				hRetRes = hRetRes;
				m_pIWbemServices = NULL;
				if (hRetRes != WBEM_E_INVALID_NAMESPACE) MY_HRESASSERT(hRetRes);
				MY_OUTPUT2(L"Failed to connect to namespace=%s", m_szTargetNamespace, 4);
			}
			else
			{
				// Store one in the static array
				m_pIWbemServices = pService;
				ns.szTargetNamespace = new TCHAR[wcslen(m_szTargetNamespace)+1];
				MY_ASSERT(ns.szTargetNamespace); if (!ns.szTargetNamespace) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				wcscpy(ns.szTargetNamespace , m_szTargetNamespace);
				ns.szLocal = new TCHAR[wcslen(m_szLocal)+1];
				MY_ASSERT(ns.szLocal); if (!ns.szLocal) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				wcscpy(ns.szLocal , m_szLocal);
				ns.pIWbemServices = pService;
				mg_nsList.push_back(ns);
			}

			SysFreeString(bsNamespace);
			bsNamespace = NULL;
			if (bsLocal)
			{
				SysFreeString(bsLocal);
				bsLocal = NULL;
			}
		}
	}

	if (pLocator)
	{
		pLocator->Release();
		pLocator = NULL;
	}

	MY_OUTPUT(L"EXIT ***** fillInNamespacePointer...", 4);
	return hRetRes;

error:
	MY_ASSERT(FALSE);
	if (bsNamespace)
		SysFreeString(bsNamespace);
	if (bsLocal)
		SysFreeString(bsLocal);
	if (ns.szTargetNamespace)
		delete [] ns.szTargetNamespace;
	if (ns.szLocal)
		delete [] ns.szLocal;
	if (pLocator)
		pLocator->Release();
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return FALSE;
}

//
// Load a single DataCollector, and everything under it.
//
HRESULT CDataCollector::LoadInstanceFromMOF(IWbemClassObject* pObj, CDataGroup *pParentDG, LPTSTR pszParentObjPath, BOOL bModifyPass/*FALSE*/)
{
	GUID guid;
	int i, iSize;
	CThreshold* pThreshold;
	LPTSTR pszTemp;
	LPTSTR pszStr;
	HRESULT hRetRes = S_OK;
//XXXXX
//static count = 0;

	MY_OUTPUT(L"ENTER ***** CDataCollector::LoadInstanceFromMOF...", 4);

	// Make sure that the Thresholds are loaded properly first
	iSize = m_thresholdList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		if (pThreshold->m_bValidLoad == FALSE)
//			return WBEM_E_INVALID_OBJECT;
			return S_OK;
	}

	m_bValidLoad = TRUE;
	Cleanup(bModifyPass);

	if (bModifyPass == FALSE)
	{
		// This is the first initial read in of this
		// Get the GUID property
		// If this fails we will actually not go through with the creation of this object.
		if (m_szGUID)
		{
			delete [] m_szGUID;
			m_szGUID = NULL;
		}
		hRetRes = GetStrProperty(pObj, L"GUID", &m_szGUID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		m_szParentObjPath = new TCHAR[wcslen(pszParentObjPath)+1];
		MY_ASSERT(m_szParentObjPath); if (!m_szParentObjPath) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		wcscpy(m_szParentObjPath, pszParentObjPath);
		m_pParentDG = pParentDG;
		hRetRes = CoCreateGuid(&guid);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		StringFromGUID2(guid, m_szStatusGUID, 100);
		hRetRes = g_pStartupSystem->AddPointerToMasterList(this);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}
	else
	{
		m_lIntervalCount = -1;
	}

	MY_OUTPUT2(L"m_szGUID=%s", m_szGUID, 4);

	// Get the Name. If it is NULL or rather blank, then we use the qualifier
	hRetRes = GetStrProperty(pObj, L"Name", &m_szName);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	// Get the Description. If it is NULL then we use the qualifier
	hRetRes = GetStrProperty(pObj, L"Description", &m_szDescription);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	hRetRes = GetStrProperty(pObj, L"TargetNamespace", &m_szTargetNamespace);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	hRetRes = GetStrProperty(pObj, L"Local", &m_szLocal);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	InitContext(pObj);

	hRetRes = GetUint32Property(pObj, L"CollectionIntervalMsecs", &m_lCollectionIntervalMultiple);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	m_lCollectionIntervalMultiple /= 1000;

	hRetRes = GetUint32Property(pObj, L"CollectionTimeOut", &m_lCollectionTimeOut);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	if (m_lCollectionIntervalMultiple < m_lCollectionTimeOut)
	{
		m_lCollectionTimeOut = m_lCollectionIntervalMultiple;
	}

	hRetRes = GetUint32Property(pObj, L"StatisticsWindowSize", &m_lStatisticsWindowSize);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	hRetRes = GetUint8Property(pObj, L"ActiveDays", &m_iActiveDays);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	// The time format looks as follows "********0600**.******+***"; hh is hours and mm is minutes
	// All else is ignored.
	hRetRes = GetStrProperty(pObj, L"BeginTime", &pszTemp);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	pszStr = wcschr(pszTemp, '.');
	if (pszStr)
	{
		// Back up to look at the minute
		pszStr -= 2;
		*pszStr = '\0';
		pszStr -= 2;
		m_lBeginMinuteTime= _wtol(pszStr);
		// Back up to look at the hour
		*pszStr = '\0';
		pszStr -= 2;
		m_lBeginHourTime= _wtol(pszStr);
	}
	else
	{
//XXXBad format, default to something
		m_lBeginMinuteTime= -1;
		m_lBeginHourTime= -1;
	}
	delete [] pszTemp;

	hRetRes = GetStrProperty(pObj, L"EndTime", &pszTemp);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	pszStr = wcschr(pszTemp, '.');
	if (pszStr)
	{
		// Back up to look at the minute
		pszStr -= 2;
		*pszStr = '\0';
		pszStr -= 2;
		m_lEndMinuteTime= _wtol(pszStr);
		// Back up to look at the hour
		*pszStr = '\0';
		pszStr -= 2;
		m_lEndHourTime= _wtol(pszStr);
	}
	else
	{
//XXXBad format, default to something
		m_lEndMinuteTime= -1;
		m_lEndHourTime= -1;
	}
	delete [] pszTemp;

	hRetRes = GetStrProperty(pObj, L"TypeGUID", &m_szTypeGUID);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	hRetRes = GetBoolProperty(pObj, L"RequireReset", &m_bRequireReset);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	hRetRes = GetBoolProperty(pObj, L"Enabled", &m_bEnabled);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	hRetRes = GetStrProperty(pObj, L"Message", &m_szMessage);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	hRetRes = GetStrProperty(pObj, L"ResetMessage", &m_szResetMessage);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	//
	// Now load all the Thresholds that are children of this one.
	//
	if (bModifyPass == FALSE)
	{
		if (m_bEnabled==FALSE || m_pParentDG->m_bEnabled==FALSE || m_pParentDG->m_bParentEnabled==FALSE)
		{
			if (m_pParentDG->m_bEnabled==FALSE || m_pParentDG->m_bParentEnabled==FALSE)
				m_bParentEnabled = FALSE;
			// Since our parent is disabled, we will not be able to get into
			// our OnAgentInterval function and send the disabled status later.
			SetCurrState(HM_DISABLED);
			FireEvent(TRUE);
		}

		hRetRes = InternalizeThresholds();
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}
	else
	{
		//
		// Set our state to enabled, or disabled and transfer to the child thresholds
		//
		if (m_bEnabled==FALSE || m_bParentEnabled==FALSE)
		{
			iSize = m_thresholdList.size();
			for (i=0; i < iSize; i++)
			{
				MY_ASSERT(i<m_thresholdList.size());
				pThreshold = m_thresholdList[i];
				pThreshold->SetParentEnabledFlag(FALSE);
			}
		}
		else
		{
			iSize = m_thresholdList.size();
			for (i=0; i < iSize; i++)
			{
				MY_ASSERT(i<m_thresholdList.size());
				pThreshold = m_thresholdList[i];
				pThreshold->SetParentEnabledFlag(TRUE);
			}
		}
	}

	// Setup what is needed to track statistics on each property listed
	// (Need to do this after the Thresholds are read in, because we may
	// need to insert some properties that were not in the list)
	hRetRes = InitPropertyStatus(pObj);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	//
	// Do any initialization stuff now
	//

	// Get the pointer to the namespace used in this DataCollector
	hRetRes = fillInNamespacePointer();
	if (hRetRes != WBEM_E_INVALID_NAMESPACE)
	{
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}

	m_ulErrorCode = 0;
	m_ulErrorCodePrev = MAX_ULONG;
	m_bValidLoad = TRUE;

//XXXXX
#ifdef SAVE
//static count = 0;
if (count==3 || count==4 || count==5 || count==6 || count==11)
{
count++;
	hRetRes = WBEM_E_OUT_OF_MEMORY;
	goto error;
}
else
{
	count++;
}
#endif

	MY_OUTPUT(L"EXIT ***** CDataCollector::LoadInstanceFromMOF...", 4);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

HRESULT CDataCollector::InternalizeThresholds(void)
{
	TCHAR szTemp[1024];
	HRESULT hRetRes = S_OK;
	ULONG uReturned;
	BSTR Language = NULL;
	BSTR Query = NULL;
	IWbemClassObject *pObj = NULL;
	IEnumWbemClassObject *pEnum = NULL;
	LPTSTR pszTempGUID = NULL;

	MY_OUTPUT(L"ENTER ***** CDataCollector::InternalizeThresholds...", 4);

	// Just loop through all top level Thresholds associated with the DataCollector.
	// Call a method of each, and have the Threshold load itself.
	Language = SysAllocString(L"WQL");
	MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(szTemp, L"ASSOCIATORS OF {MicrosoftHM_DataCollectorConfiguration.GUID=\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"} WHERE ResultClass=MicrosoftHM_ThresholdConfiguration");
	Query = SysAllocString(szTemp);
	MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

	// Issue query
    hRetRes = g_pIWbemServices->ExecQuery(Language, Query, WBEM_FLAG_FORWARD_ONLY, 0, &pEnum);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	SysFreeString(Query);
	Query = NULL;
	SysFreeString(Language);
	Language = NULL;

	// Retrieve objects in result set
	while (TRUE)
	{
		pObj = NULL;
		uReturned = 0;

		hRetRes = pEnum->Next(0, 1, &pObj, &uReturned);
		MY_ASSERT(hRetRes==S_OK || hRetRes==WBEM_S_FALSE);
		if (hRetRes!=S_OK && hRetRes!=WBEM_S_FALSE)
		{
			MY_HRESASSERT(hRetRes);
			pEnum->Release();
			pEnum = NULL;
			return hRetRes;
		}

		if (uReturned == 0)
		{
			break;
		}

		// See if this is already read in. Need to prevent endless loop, circular references.
		hRetRes = GetStrProperty(pObj, L"GUID", &pszTempGUID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		if (!g_pStartupSystem->FindPointerFromGUIDInMasterList(pszTempGUID))
		{
			//
			// Create the internal class to represent the Threshold
			//
			CThreshold* pThreshold = new CThreshold;
			MY_ASSERT(pThreshold); if (!pThreshold) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

			if (m_deType == HM_PGDE)
			{
				wcscpy(szTemp, L"MicrosoftHM_PolledGetObjectDataCollectorConfiguration.GUID=\\\"");
			}
			else if (m_deType == HM_PMDE)
			{
				wcscpy(szTemp, L"MicrosoftHM_PolledMethodDataCollectorConfiguration.GUID=\\\"");
			}
			else if (m_deType == HM_PQDE)
			{
				wcscpy(szTemp, L"MicrosoftHM_PolledQueryDataCollectorConfiguration.GUID=\\\"");
			}
			else if (m_deType == HM_EQDE)
			{
				wcscpy(szTemp, L"MicrosoftHM_EventQueryDataCollectorConfiguration.GUID=\\\"");
			}
			else
			{
				MY_ASSERT(FALSE);
			}
			lstrcat(szTemp, m_szGUID);
			lstrcat(szTemp, L"\\\"");
			hRetRes = pThreshold->LoadInstanceFromMOF(pObj, this, szTemp);
			if (hRetRes==S_OK)
			{
				m_thresholdList.push_back(pThreshold);
			}
			else
			{
				MY_HRESASSERT(hRetRes);
				delete pThreshold;
			}
		}
		delete [] pszTempGUID;
		pszTempGUID = NULL;

		// Release it.
		pObj->Release();
		pObj = NULL;
	}

	// All done
	pEnum->Release();
	pEnum = NULL;

	MY_OUTPUT(L"EXIT ***** CDataCollector::InternalizeThresholds...", 4);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	if (Query)
		SysFreeString(Query);
	if (Language)
		SysFreeString(Language);
	if (pszTempGUID)
		delete [] pszTempGUID;
	if (pObj)
		pObj->Release();
	if (pEnum)
		pEnum->Release();
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

//
// Create an array element for each property we are interested
//
BOOL CDataCollector::InitContext(IWbemClassObject* pObj)
{
	BOOL bRetValue = TRUE;
#ifdef SAVE
	HRESULT hRes;
	HRESULT hRetRes;
	VARIANT v;
	VARIANT vValue;
	IUnknown* vUnknown;
	IWbemClassObject* pCO;
	BSTR bstrPropName = NULL;
	long iLBound, iUBound;
	LPTSTR szName;
	LPTSTR szValue;
	long lType;

	VariantInit(&v);
	bstrPropName = SysAllocString(L"Context");
	if ((hRes = pObj->Get(bstrPropName, 0L, &v, NULL, NULL)) == S_OK) 
	{
		if (V_VT(&v)==VT_NULL)
		{
//			MY_ASSERT(FALSE);
		}
		else
		{
			MY_ASSERT(V_VT(&v)==(VT_UNKNOWN|VT_ARRAY));
                
			SafeArrayGetLBound(v.parray, 1, &iLBound);
			SafeArrayGetUBound(v.parray, 1, &iUBound);
			if ((iUBound - iLBound + 1) == 0)
			{
				MY_ASSERT(FALSE);
			}
			else
			{
				for (long i = iLBound; i <= iUBound; i++)
				{
					if (m_pContext == NULL)
					{
						hRes = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER,
												IID_IWbemContext, (void **)&m_pContext);
						if (S_OK != hRes)
						{
							MY_HRESASSERT(hRes);
						}
					}

					VariantInit(&vValue);
					vUnknown = NULL;
					SafeArrayGetElement(v.parray, &i, &vUnknown);
					pCO = (IWbemClassObject *)vUnknown;

					hRetRes = GetStrProperty(pCO, L"Name", &szName);
					MY_HRESASSERT(hRetRes);

					hRetRes = GetUint32Property(pCO, L"Type", &lType);
					MY_HRESASSERT(hRetRes);

					hRetRes = GetStrProperty(pCO, L"Value", &szValue);
					MY_HRESASSERT(hRetRes);

					//
					// Set the name value pair into the IWbemContext object
					//
					if (lType == CIM_SINT8 ||
						lType == CIM_SINT16 ||
						lType == CIM_CHAR16)
					{
						V_VT(&vValue) = VT_I2;
						V_I2(&vValue) = _wtol(szValue);
					}
					else if (lType == CIM_SINT32 ||
						lType == CIM_UINT16 ||
						lType == CIM_UINT32)
					{
						V_VT(&vValue) = VT_I4;
						V_I4(&vValue) = _wtol(szValue);
					}
					else if (lType == CIM_REAL32)
					{
						V_VT(&vValue) = VT_R4;
						V_R4(&vValue) = wcstod(szValue, NULL);
					}
					else if (lType == CIM_BOOLEAN)
					{
						V_VT(&vValue) = VT_BOOL;
						V_BOOL(&vValue) = (BOOL) _wtol(szValue);
					}
					else if (lType == CIM_SINT64 ||
						lType == CIM_UINT64 ||
//XXX				lType == CIM_REF ||
						lType == CIM_STRING ||
						lType == CIM_DATETIME)
					{
						V_VT(&vValue) = VT_BSTR;
						V_BSTR(&vValue) = SysAllocString(szValue);
					}
					else if (lType == CIM_REAL64)
					{
						V_VT(&vValue) = VT_R8;
						V_R8(&vValue) = wcstod(szValue, NULL);
					}
					else if (lType == CIM_UINT8)
					{
						V_VT(&vValue) = VT_UI1;
						V_UI1(&vValue) = (unsigned char) _wtoi(szValue);
					}
					else
					{
						MY_ASSERT(FALSE);
					}

					hRes = m_pContext->SetValue(szName, 0L, &vValue);

					if (S_OK != hRes)
					{
						MY_HRESASSERT(hRes);
					}
					VariantClear(&vValue);

					delete [] szName;
					delete [] szValue;
					vUnknown->Release();
				}
			}
		}
	}
	else
	{
		bRetValue = FALSE;
		MY_HRESASSERT(hRes);
	}
	VariantClear(&v);
	SysFreeString(bstrPropName);
#endif

	MY_OUTPUT(L"EXIT ***** GetStrProperty...", 1);
	return bRetValue;
}

//
// Create an array element for each property we are interested
//
HRESULT CDataCollector::InitPropertyStatus(IWbemClassObject* pObj)
{
	HRESULT hRetRes = S_OK;
	VARIANT v;
	BSTR vStr = NULL;
	BOOL bFound = FALSE;
	long iLBound, iUBound;
	PNSTRUCT pn;
	int i, iSize;
	CThreshold* pThreshold;

	pn.szPropertyName = NULL;
	pn.iRefCount = 1;
	pn.type = 0;

	VariantInit(&v);
	if ((hRetRes = pObj->Get(L"Properties", 0L, &v, NULL, NULL)) == S_OK) 
	{
		if (V_VT(&v)==VT_NULL)
		{
		}
		else
		{
			MY_ASSERT(V_VT(&v)==(VT_BSTR|VT_ARRAY));
                
			hRetRes = SafeArrayGetLBound(v.parray, 1, &iLBound);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			hRetRes = SafeArrayGetUBound(v.parray, 1, &iUBound);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			if ((iUBound - iLBound + 1) == 0)
			{
			}
			else
			{
				for (long i = iLBound; i <= iUBound; i++)
				{
					vStr = NULL;
					hRetRes = SafeArrayGetElement(v.parray, &i, &vStr);
					MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
					if (_wcsicmp(vStr, L"CollectionInstanceCount") &&
						_wcsicmp(vStr, L"CollectionErrorCode") &&
						_wcsicmp(vStr, L"CollectionErrorDescription"))
					{
						pn.szPropertyName = new TCHAR[wcslen(vStr)+2];
						MY_ASSERT(pn.szPropertyName); if (!pn.szPropertyName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
						wcscpy(pn.szPropertyName, vStr);
						m_pnList.push_back(pn);
					}
					SysFreeString(vStr);
					vStr = NULL;
				}
			}
		}
	}
	else
	{
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}
	VariantClear(&v);

	//
	// Insert all the properties used by Thresholds, that are not found in the list yet.
	// Refcount those that are in there already.
	//
	iSize = m_thresholdList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		if (_wcsicmp(pThreshold->m_szPropertyName, L"CollectionInstanceCount") &&
			_wcsicmp(pThreshold->m_szPropertyName, L"CollectionErrorCode") &&
			_wcsicmp(pThreshold->m_szPropertyName, L"CollectionErrorDescription"))
		{
			hRetRes = insertNewProperty(pThreshold->m_szPropertyName);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		}
	}

	pn.szPropertyName = new TCHAR[wcslen(L"CollectionInstanceCount")+2];
	MY_ASSERT(pn.szPropertyName); if (!pn.szPropertyName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(pn.szPropertyName, L"CollectionInstanceCount");
	m_pnList.push_back(pn);

	pn.szPropertyName = new TCHAR[wcslen(L"CollectionErrorCode")+2];
	MY_ASSERT(pn.szPropertyName); if (!pn.szPropertyName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(pn.szPropertyName, L"CollectionErrorCode");
	m_pnList.push_back(pn);

	pn.szPropertyName = new TCHAR[wcslen(L"CollectionErrorDescription")+2];
	MY_ASSERT(pn.szPropertyName); if (!pn.szPropertyName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(pn.szPropertyName, L"CollectionErrorDescription");
	m_pnList.push_back(pn);

	return hRetRes;

error:
	MY_ASSERT(FALSE);
//	VariantClear(&v);
//	if (pn.szPropertyName)
//		pn.szPropertyName = NULL;
	if (vStr)
		SysFreeString(vStr);
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

//
// This is the entry point for the Agents base 10 second timer. At this time we
// Have each DataCollector and Threshold do its job.
//
BOOL CDataCollector::OnAgentInterval(void)
{
	int i, iSize;
	long lIntervalCountTemp;
	CThreshold* pThreshold;
	BOOL bTimeOK;

	MY_OUTPUT(L"ENTER ***** CDataCollector::OnAgentInterval...", 1);

	//
	// Don't do anything if we are not loaded correctly.
	// Or, if a Threshold is having problems.
	//
	if (m_bValidLoad == FALSE)
		return FALSE;

	iSize = m_thresholdList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		if (pThreshold->m_bValidLoad == FALSE)
			return FALSE;
	}

	m_lPrevState = m_lCurrState;
	m_lNumberChanges = 0;
	m_szErrorDescription[0] = '\0';

	// Remember that the DISABLED state overrides SCHEDULEDOUT.
	if ((m_bEnabled==FALSE || m_bParentEnabled==FALSE) && m_lCurrState==HM_DISABLED)
	{
		return TRUE;
	}
	//
	// Make sure that we are in a valid time to run.
	//
	bTimeOK = checkTime();
	if (bTimeOK==FALSE && m_lCurrState==HM_SCHEDULEDOUT && m_bEnabled && m_bParentEnabled)
	{
		return TRUE;
	}
	else if ((m_bEnabled==FALSE || m_bParentEnabled==FALSE) && m_lCurrState!=HM_DISABLED ||
			bTimeOK==FALSE && m_lCurrState!=HM_SCHEDULEDOUT)
	{
		//
		// Going into Scheduled Outage OR DISABLED.
		// What if we are going from ScheduledOut to Disabled?
		// Or from Disabled to ScheduledOut?
		// Possible transitions:
		// GOOD -> Disabled
		// GOOD -> ScheduledOut
		// Disabled -> ScheduledOut
		// ScheduledOut -> Disabled
		//
		if (m_bEnabled==FALSE || m_bParentEnabled==FALSE)
		{
			//
			// This is where we are transitioning into the DISABLED State
			//
			EnumDone();

			if (m_lPrevState == HM_SCHEDULEDOUT)
			{
				iSize = m_thresholdList.size();
				for (i = 0; i < iSize; i++)
				{
					MY_ASSERT(i<m_thresholdList.size());
					pThreshold = m_thresholdList[i];
					pThreshold->SetParentScheduledOutFlag(FALSE);
				}
			}

			iSize = m_thresholdList.size();
			for (i = 0; i < iSize; i++)
			{
				MY_ASSERT(i<m_thresholdList.size());
				pThreshold = m_thresholdList[i];
				pThreshold->SetParentEnabledFlag(FALSE);
			}
			m_lCurrState = HM_DISABLED;
			CDataCollector::EvaluateThresholds(FALSE);

			m_lNumberChanges = 1;
			m_lIntervalCount = -1;

			FireEvent(FALSE);
		}
		else
		{
			//
			// This is where we are transitioning into the SCHEDULEDOUT State
			//
			EnumDone();

			iSize = m_thresholdList.size();
			for (i = 0; i < iSize; i++)
			{
				MY_ASSERT(i<m_thresholdList.size());
				pThreshold = m_thresholdList[i];
				pThreshold->SetParentScheduledOutFlag(TRUE);
			}
			m_lCurrState = HM_SCHEDULEDOUT;
			CDataCollector::EvaluateThresholds(FALSE);

			m_lNumberChanges = 1;
			m_lIntervalCount = -1;

			FireEvent(FALSE);
		}
		return TRUE;
	}
#ifdef SAVE
	else if (m_lCurrState==HM_DISABLED || m_lCurrState==HM_SCHEDULEDOUT)
	{
What was in action.cpp
		//
		// Comming out of Scheduled Outage OR DISABLED.
		// Might be going from ScheduledOut/Disabled to Disabled,
		// or disabled to ScheduledOut.
		//
		m_lCurrState = HM_GOOD;
		FireEvent(-1, NULL, HMRES_ACTION_ENABLE);
	}
#endif
	else
	{
		if (m_lPrevState == HM_SCHEDULEDOUT)
		{
			iSize = m_thresholdList.size();
			for (i = 0; i < iSize; i++)
			{
				MY_ASSERT(i<m_thresholdList.size());
				pThreshold = m_thresholdList[i];
				pThreshold->SetParentScheduledOutFlag(FALSE);
			}
		}
		if (m_lPrevState == HM_DISABLED)
		{
			iSize = m_thresholdList.size();
			for (i = 0; i < iSize; i++)
			{
				MY_ASSERT(i<m_thresholdList.size());
				pThreshold = m_thresholdList[i];
				pThreshold->SetParentEnabledFlag(TRUE);
			}
		}
		//
		// We are either beginning a Collection, or in the middle of one
		//
		m_lIntervalCount++;
		if (m_bKeepCollectingSemiSync == FALSE)
		{
			//
			// Here is where we need to fire an event in advance, because we are going to be in the
			// collecting state until we have retrieved something, or in the case of the event based
			// data collector, we reach the end of the collection interval.
			//
			if (m_lIntervalCount==0 || m_lIntervalCount==1)
			{
				m_lCurrState = HM_COLLECTING;
				m_lPrevState = m_lCurrState;
				iSize = m_thresholdList.size();
				for (i = 0; i < iSize ; i++)
				{
					MY_ASSERT(i<m_thresholdList.size());
					pThreshold = m_thresholdList[i];
					pThreshold->SetCurrState(HM_COLLECTING);
				}

				iSize = m_thresholdList.size();
				for (i=0; i < iSize; i++)
				{
					MY_ASSERT(i<m_thresholdList.size());
					pThreshold = m_thresholdList[i];
					pThreshold->FireEvent(TRUE);
				}

				FireEvent(TRUE);
				//
				// In order to smooth out the CPU utilization of the HealthMon Agent,
				// random offset each Data Collector.
				//
				if (m_lCollectionIntervalMultiple != 0)
				{
					if (m_lIntervalCount==1)
					{
						m_lIntervalCount = rand()%m_lCollectionIntervalMultiple;
						if (m_lIntervalCount == 0)
							m_lIntervalCount++;
					}
					else
					{
						// This case we have been forced to forego the random, and do immediate
						m_lIntervalCount = 1;
					}
				}
			}

			//
			// Beginning a Collection
			// Check to see if this is at an interval that we need to run at.
			//
			if ((m_lCollectionIntervalMultiple == 0) ||
				(m_lIntervalCount!=1 && (m_lIntervalCount-1)%m_lCollectionIntervalMultiple))
			{
				return TRUE;
			}

			CollectInstance();
			//
			// Optomized, for when we know we have not recieved any events during the interval
			//
			if (m_bKeepCollectingSemiSync)
			{
				// This is for the case where this Data Collector might have been the only
				// reason for the parent data group to be in a CRITICAL state, and now, because
				// We do not push up the COLLECTING state, the data group might miss the change.
				if (m_lCurrState==HM_COLLECTING && m_lPrevState!=m_lCurrState)
				{
					m_lNumberChanges++;
				}
				return TRUE;
			}
		}
		else
		{
			//
			// Means that we still have not received all the instance(s) back yet!
			// Keep trying to collect the instance until the TimeOut has expired!
			// Also watch for when the next interval has been reached and we still have not
			// received the instance!
			//
			m_lCollectionTimeOutCount++;
			CollectInstanceSemiSync();
			if (m_bKeepCollectingSemiSync)
			{
				// Check to see if we are over the TimeOut period.
				if (m_lCollectionTimeOutCount == m_lCollectionTimeOut)
				{
					if (m_ulErrorCode != HMRES_TIMEOUT)
					{
						lIntervalCountTemp = m_lIntervalCount;
						ResetState(FALSE, FALSE);
						m_lIntervalCount = lIntervalCountTemp;
					}
					else
					{
						EnumDone();
					}
					MY_ASSERT(FALSE);
					m_ulErrorCode = HMRES_TIMEOUT;
					GetLatestAgentError(HMRES_TIMEOUT, m_szErrorDescription);
					StoreStandardProperties();
				}
				else
				{
					// This is the case where we just return, and keep trying to collect
					return TRUE;
				}
			}
		}

		//
		// We have made it to this point because we have received all of the instance(s)
		//

		//
		// Evaluate the instance(s) property(s) against the threshold(s).
		// In the case of evnt based data collector, we do not have any events to look at
		// at the start, but need to wait for the end of the interval.
		//
		if (m_deType!=HM_EQDE || (m_deType==HM_EQDE && (m_lIntervalCount!=1 || m_ulErrorCode!=0)))
		{
			wcscpy(m_szDTCollectTime, m_szDTCurrTime);
			wcscpy(m_szCollectTime, m_szCurrTime);
			EvaluateThresholds(FALSE, TRUE, FALSE, FALSE);
			if (m_deType!=HM_EQDE)
			{
				EvaluateThresholds(FALSE, FALSE, TRUE, FALSE);
			}
		}

		// Event data collector will have called to send their own event
		if (m_deType!=HM_EQDE)
		{
			SendEvents();
			FireStatisticsEvent();
		}

		// To sync up prev and curr states for those cases that could keep producing events
		if (m_ulErrorCode != 0)
		{
			iSize = m_thresholdList.size();
			for (i = 0; i < iSize ; i++)
			{
				MY_ASSERT(i<m_thresholdList.size());
				pThreshold = m_thresholdList[i];
				pThreshold->SetPrevState(HM_CRITICAL);
			}
		}
	}


	if (m_deType == HM_EQDE)
	{
		m_lNumInstancesCollected = 0;
	}

	iSize = m_thresholdList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		if (pThreshold->m_bValidLoad == FALSE)
		{
			MY_ASSERT(FALSE);
			m_bValidLoad = FALSE;
			Cleanup(FALSE);
			break;
		}
	}

	m_ulErrorCodePrev = m_ulErrorCode;

	MY_OUTPUT(L"EXIT ***** CDataCollector::OnAgentInterval...", 1);
	return TRUE;
}

BOOL CDataCollector::SendEvents(void)
{
	int i, iSize;
	long state;
	CThreshold* pThreshold;
	long lCurrChildCount = 0;

	if (m_bValidLoad == FALSE)
		return FALSE;

	//
	// See if any Thresholds were set into the RESET state,
	// This causes the DataCollector to set all Thresholds to the GOOD state, and
	// re-evaluate all thresholds.
	//
//XXXWith this in we can implement the RESET feature, but we still need to debug fully,
	CheckForReset();

	//
	// Set State of the DataCollector to the worst of everything under it
	//
	m_lNumberNormals = 0;
	m_lNumberWarnings = 0;
	m_lNumberCriticals = 0;
	m_lNumberChanges = 0;
	iSize = m_thresholdList.size();
	lCurrChildCount = iSize;
	if (iSize != 0)
	{
		m_lCurrState = -1;
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<m_thresholdList.size());
			pThreshold = m_thresholdList[i];
			state = pThreshold->GetCurrState();
			MY_OUTPUT2(L"State=%d", state, 4);
			if (state > m_lCurrState)
			{
				m_lCurrState = state;
			}
			if (state == HM_GOOD)
			{
				m_lNumberNormals++;
			}
			if (state == HM_WARNING)
			{
				m_lNumberWarnings++;
			}
			if (state == HM_CRITICAL)
			{
				m_lNumberCriticals++;
			}
			if (pThreshold->GetChange())
			{
				MY_OUTPUT(L"CHANGE", 4);
				m_lNumberChanges++;
			}
		}

		// The disabled state of things below us did not roll up
		if (m_lCurrState==HM_DISABLED)
		{
			m_lCurrState = HM_GOOD;
			if (m_lPrevState != m_lCurrState)
			{
				m_lNumberChanges++;
			}
		}
		if (m_lCurrState == -1)
		{
			if (m_bEnabled==FALSE || m_bParentEnabled==FALSE)
			{
				m_lCurrState = HM_DISABLED;
			}
			else
			{
				m_lCurrState = HM_GOOD;
			}

			if (m_lPrevState != m_lCurrState)
			{
				m_lNumberChanges = 1;
			}
		}
	}
	else
	{
		m_lCurrState = HM_GOOD;
		if (m_lPrevState != m_lCurrState)
		{
			m_lNumberChanges = 1;
		}
	}

	// Finally if all else fails, and we have a DE that is RESET required, and we have an INIT
	// state, then set things to GOOD
	if (m_bRequireReset && m_lCurrState == HM_COLLECTING)
	{
		m_lNumberChanges = 0;
		iSize = m_thresholdList.size();
		for (i = 0; i < iSize; i++)
		{
			MY_ASSERT(i<m_thresholdList.size());
			pThreshold = m_thresholdList[i];
			pThreshold->SetCurrState(HM_GOOD);
			if (pThreshold->GetChange())
			{
				m_lNumberChanges++;
			}
		}
		m_lCurrState = HM_GOOD;
	}

	if (m_lPrevChildCount!=lCurrChildCount)
	{
		if (m_lNumberChanges==0 && m_lPrevState!=m_lCurrState)
		{
			m_lNumberChanges++;
		}
	}
	m_lPrevChildCount = lCurrChildCount;

	FireEvent(FALSE);
	FirePerInstanceEvents();

	return TRUE;
}

//
// If there has been a change in the state then send an event
//
HRESULT CDataCollector::FireEvent(BOOL bForce)
{
	HRESULT hRetRes = S_OK;
	IWbemClassObject* pInstance = NULL;
	GUID guid;
	HRESULT hRes;

	MY_OUTPUT(L"ENTER ***** CDataCollector::FireEvent...", 2);

	// Don't send if no-one is listening!
	if (g_pDataCollectorEventSink == NULL)
	{
		return S_OK;
	}

MY_OUTPUT2(L"m_lPrevState=%d", m_lPrevState, 4);
MY_OUTPUT2(L"m_lCurrState=%d", m_lCurrState, 4);
MY_OUTPUT2(L"m_lNumberChanges=%d", m_lNumberChanges, 4);
	// A quick test to see if anything has really changed!
	// Proceed if there have been changes
	if (bForce || (m_lNumberChanges!=0 && m_lPrevState!=m_lCurrState))
	{
	}
	else
	{
		return FALSE;
	}

	MY_OUTPUT2(L"EVENT: DataCollector State Change=%d", m_lCurrState, 4);

	// Proceed if there have been changes
	// yyyymmddhhmmss.ssssssXUtc; X = GMT(+ or -), Utc = 3 dig. offset from UTC.")]
	wcscpy(m_szDTTime, m_szDTCurrTime);
	wcscpy(m_szTime, m_szCurrTime);
	hRetRes = CoCreateGuid(&guid);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	StringFromGUID2(guid, m_szStatusGUID, 100);

	hRes = GetHMDataCollectorStatusInstance(&pInstance, TRUE);
	if (FAILED(hRes))
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT(L"failed to get instance!", 1);
		return FALSE;
	}
	else
	{
		//
		// Place Extrinsit event in vector for sending at end of interval.
		// All get sent at once.
		//
		mg_DCEventList.push_back(pInstance);
	}

	MY_OUTPUT(L"EXIT ***** CDataCollector::FireEvent...", 2);
	return hRetRes;

error:
	MY_ASSERT(FALSE);
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

//
// Send out events for each instance that has had a change of state.
// The state of each will be the worst of all.
//
BOOL CDataCollector::FirePerInstanceEvents(void)
{
	long state;
	int i, iSize;
	BOOL bRetValue = TRUE;
	IWbemClassObject* pInstance = NULL;
	ACTUALINSTSTRUCT *pActualInst;
	long firstInstanceState = -1;

	MY_OUTPUT(L"ENTER ***** CDataCollector::FirePerInstanceEvents...", 2);

	// Don't send if no-one is listening!
	if (g_pDataCollectorPerInstanceEventSink == NULL)
	{
		return bRetValue;
	}

	//
	// We can loop through the set of collected instances and ask each Threshold
	// to tell us if the state has changed as far as each is concerned, for the
	// property they are lookin at.
	//
	iSize = m_actualInstList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_actualInstList.size());
		pActualInst = &m_actualInstList[i];

		if ((state=PassBackStateIfChangedPerInstance(pActualInst->szInstanceID, (BOOL)i==0))!=-1)
		{
			if (i==0)
			{
				firstInstanceState = state;
			}
			// Update time since we had a state change
			wcscpy(pActualInst->szDTTime, m_szDTCurrTime);
			wcscpy(pActualInst->szTime, m_szCurrTime);
			if (GetHMDataCollectorPerInstanceStatusEvent(pActualInst->szInstanceID, pActualInst, state, &pInstance, TRUE)==S_OK)
			{
				//
				// Place Extrinsit event in vector for sending at end of interval.
				// All get sent at once.
				//
				mg_DCPerInstanceEventList.push_back(pInstance);
			}
		}
	}

	//
	// Do it for the three default properties
	//
	if (firstInstanceState==-1 && (state=PassBackStateIfChangedPerInstance(L"CollectionInstanceCount", FALSE))!=-1)
	{
		// Update time since we had a state change
		wcscpy(m_szDTCICTime, m_szDTCurrTime);
		wcscpy(m_szCICTime, m_szCurrTime);
		if (GetHMDataCollectorPerInstanceStatusEvent(L"CollectionInstanceCount", NULL, state, &pInstance, TRUE)==S_OK)
		{
			//
			// Place Extrinsit event in vector for sending at end of interval.
			// All get sent at once.
			//
			mg_DCPerInstanceEventList.push_back(pInstance);
		}
	}

	if (firstInstanceState==-1 && (state=PassBackStateIfChangedPerInstance(L"CollectionErrorCode", FALSE))!=-1)
	{
		// Update time since we had a state change
		wcscpy(m_szDTCECTime, m_szDTCurrTime);
		wcscpy(m_szCECTime, m_szCurrTime);
		if (GetHMDataCollectorPerInstanceStatusEvent(L"CollectionErrorCode", NULL, state, &pInstance, TRUE)==S_OK)
		{
			//
			// Place Extrinsit event in vector for sending at end of interval.
			// All get sent at once.
			//
			mg_DCPerInstanceEventList.push_back(pInstance);
		}
	}

	MY_OUTPUT(L"EXIT ***** CDataCollector::FirePerInstanceEvents...", 2);
	return TRUE;
}

long CDataCollector::PassBackStateIfChangedPerInstance(LPTSTR pszInstName, BOOL bCombineWithStandardProperties)
{
	int i, iSize;
	long worstState, state;
	CThreshold* pThreshold;

	worstState = -1;
	iSize = m_thresholdList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		state = pThreshold->PassBackStateIfChangedPerInstance(pszInstName);
		if (state != -1)
		{
			if (state==HM_DISABLED)
			{
				state = HM_GOOD;
			}
			if (state > worstState)
			{
				worstState = state;
			}
		}
	}

	if (bCombineWithStandardProperties)
	{
		iSize = m_thresholdList.size();
		for (i=0; i < iSize; i++)
		{
			MY_ASSERT(i<m_thresholdList.size());
			pThreshold = m_thresholdList[i];
			state = pThreshold->PassBackStateIfChangedPerInstance(L"CollectionInstanceCount");
			if (state != -1)
			{
				if (state==HM_DISABLED)
				{
					state = HM_GOOD;
				}
				if (state > worstState)
				{
					worstState = state;
				}
			}
			state = pThreshold->PassBackStateIfChangedPerInstance(L"CollectionErrorCode");
			if (state != -1)
			{
				if (state==HM_DISABLED)
				{
					state = HM_GOOD;
				}
				if (state > worstState)
				{
					worstState = state;
				}
			}
		}
	}

	// May have had one Threshold go from CRITICAL to GOOD and have a change, while another
	// Threshold was WARNING and stayed WARNING with no change, so need to go there.
	if (worstState != -1)
	{
		iSize = m_thresholdList.size();
		for (i=0; i < iSize; i++)
		{
			MY_ASSERT(i<m_thresholdList.size());
			pThreshold = m_thresholdList[i];
			state = pThreshold->PassBackWorstStatePerInstance(pszInstName);
			if (state != -1)
			{
				if (state==HM_DISABLED)
				{
					state = HM_GOOD;
				}
				if (state > worstState)
				{
					worstState = state;
				}
			}
		}
		if (bCombineWithStandardProperties)
		{
			iSize = m_thresholdList.size();
			for (i=0; i < iSize; i++)
			{
				MY_ASSERT(i<m_thresholdList.size());
				pThreshold = m_thresholdList[i];
				state = pThreshold->PassBackWorstStatePerInstance(L"CollectionInstanceCount");
				if (state != -1)
				{
					if (state==HM_DISABLED)
					{
						state = HM_GOOD;
					}
					if (state > worstState)
					{
						worstState = state;
					}
				}
				state = pThreshold->PassBackWorstStatePerInstance(L"CollectionErrorCode");
				if (state != -1)
				{
					if (state==HM_DISABLED)
					{
						state = HM_GOOD;
					}
					if (state > worstState)
					{
						worstState = state;
					}
				}
			}
		}
	}

	return worstState;
}

long CDataCollector::PassBackWorstStatePerInstance(LPTSTR pszInstName, BOOL bCombineWithStandardProperties)
{
	int i, iSize;
	long worstState, state;
	CThreshold* pThreshold;

	worstState = -1;
	iSize = m_thresholdList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		state = pThreshold->PassBackWorstStatePerInstance(pszInstName);
		if (state != -1)
		{
			if (state==HM_DISABLED)
			{
				state = HM_GOOD;
			}
			if (state > worstState)
			{
				worstState = state;
			}
		}
	}

	if (bCombineWithStandardProperties)
	{
		iSize = m_thresholdList.size();
		for (i=0; i < iSize; i++)
		{
			MY_ASSERT(i<m_thresholdList.size());
			pThreshold = m_thresholdList[i];
			state = pThreshold->PassBackWorstStatePerInstance(L"CollectionInstanceCount");
			if (state != -1)
			{
				if (state==HM_DISABLED)
				{
					state = HM_GOOD;
				}
				if (state > worstState)
				{
					worstState = state;
				}
			}
			state = pThreshold->PassBackWorstStatePerInstance(L"CollectionErrorCode");
			if (state != -1)
			{
				if (state==HM_DISABLED)
				{
					state = HM_GOOD;
				}
				if (state > worstState)
				{
					worstState = state;
				}
			}
		}
	}

	return worstState;
}

// Only Send statistics information on a change
BOOL CDataCollector::FireStatisticsEvent(void)
{
	BOOL bRetValue = TRUE;

	if (m_bValidLoad == FALSE)
		return FALSE;

	MY_OUTPUT(L"ENTER ***** CDataCollector::FireStatisticsEvent...", 2);

	// Don't send if no-one is listening!
	if (g_pDataCollectorStatisticsEventSink == NULL)
	{
		return bRetValue;
	}
MY_OUTPUT2(L"Someone listening for statistics GUID=%s", m_szGUID, 4);

	fillInPropertyStatus(m_szDTCurrTime, m_szCurrTime);

	MY_OUTPUT(L"EXIT ***** CDataCollector::FireStatisticsEvent...", 2);
	return bRetValue;
}

BOOL CDataCollector::fillInPropertyStatus(LPTSTR szDTTime, LPTSTR szTime)
{
MY_ASSERT(FALSE);
//Not used anymore!

	return TRUE;
}

//
// Store the values for the properties that we care about.
//
BOOL CDataCollector::StoreValues(IWbemClassObject* pObj, LPTSTR pszInstID)
{
	HRESULT hRetRes = S_OK;
	int i, iSize;
	int j, jSize;
	PNSTRUCT *ppn;
	INSTSTRUCT *pinst;
	HRESULT hRes;
	VARIANT v;
	BOOL bRetValue = TRUE;
	BOOL bFirstType = FALSE;
	BOOL bFound;
	CThreshold* pThreshold;
	VariantInit(&v);

	if (m_bValidLoad == FALSE)
		return FALSE;

	MY_OUTPUT(L"ENTER ***** CDataCollector::StoreValues...", 1);

	//
	// LOOP through all the properties we are suppose to collect data for into the instance(s).
	// If the type is set to 0 in the PropertyStat struct, then we know that it
	// is the first time we have seen this instance, so set it!
	//
	iSize = m_pnList.size();
	if (pObj)
	{
		for (i=0; i < iSize-3; i++)
		{
			MY_ASSERT(i<m_pnList.size());
			ppn = &m_pnList[i];
			bFound = FALSE;
			jSize = ppn->instList.size();
			for (j = 0; j < jSize ; j++)
			{
				MY_ASSERT(j<ppn->instList.size());
				pinst = &ppn->instList[j];
				if (!_wcsicmp(pinst->szInstanceID, pszInstID))
				{
					bFound = TRUE;
					break;
				}
			}
			MY_ASSERT(bFound == TRUE);

			if (bFound == TRUE)
			{
				if (!_wcsicmp(ppn->szPropertyName, L"CollectionInstanceCount") ||
					!_wcsicmp(ppn->szPropertyName, L"CollectionErrorCode") ||
					!_wcsicmp(ppn->szPropertyName, L"CollectionErrorDescription"))
				{
					// Don't do for the these properties
					continue;
				}
				// Get the data from the perfmon property
				VariantInit(&v);
				if (ppn->type == 0)
				{
					bFirstType = TRUE;
				}
				if ((hRes = pObj->Get(ppn->szPropertyName, 0L, &v, &ppn->type, NULL)) == S_OK)
				{
					MY_OUTPUT(L"Property Get worked", 3);
					if (bFirstType)
					{
						ResetInst(pinst, ppn->type);
					}
					if (V_VT(&v)==VT_NULL)
					{
						MY_OUTPUT(L"NULL TYPE", 3);
						if (pinst->szCurrValue)
						{
							delete [] pinst->szCurrValue;
							pinst->szCurrValue = NULL;
						}
						if (ppn->type == CIM_STRING)
						{
							pinst->szCurrValue = new TCHAR[5];
							MY_ASSERT(pinst->szCurrValue); if (!pinst->szCurrValue) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
							wcscpy(pinst->szCurrValue , L"");
						}
						pinst->bNull = TRUE;
					}
					else
					{
						// We are going from collecting NULL to actually getting something
						if (bFirstType==FALSE && pinst->bNull==TRUE)
						{
							m_lCurrState = HM_COLLECTING;
							jSize = m_thresholdList.size();
							for (j=0; j<jSize; j++)
							{
								MY_ASSERT(j<m_thresholdList.size());
								pThreshold = m_thresholdList[j];
								pThreshold->SetCurrState(HM_COLLECTING);
							}
						}
						pinst->bNull = FALSE;
						if (V_VT(&v)==VT_R4)
						{
							pinst->currValue.fValue = V_R4(&v);
							MY_ASSERT(ppn->type == CIM_REAL32);
						}
						else if (V_VT(&v)==VT_R8)
						{
							pinst->currValue.dValue = V_R8(&v);
							MY_ASSERT(ppn->type == CIM_REAL64);
						}
						else if (V_VT(&v)==VT_I2)
						{
							pinst->currValue.lValue = (long) V_I2(&v);
						}
						else if (V_VT(&v)==VT_I4)
						{
							if (ppn->type == CIM_UINT32)
							{
								pinst->currValue.ulValue = V_UI4(&v);
							}
							else
							{
								pinst->currValue.lValue = (long) V_I4(&v);
							}
						}
//				else if (V_VT(&v)==VT_UI4)
//				{
//					pinst->currValue.ulValue = (long) V_UI4(&v);
//				}
						else if (V_VT(&v)==VT_UI1)
						{
							pinst->currValue.lValue = (long) V_UI1(&v);
						}
						else if (V_VT(&v)==VT_BOOL)
						{
							pinst->currValue.lValue = (long) V_BOOL(&v);
							if (pinst->currValue.lValue != 0.0)
							{
								pinst->currValue.lValue = 1.0;
							}
						}
						else if (V_VT(&v)==VT_BSTR)
						{
							if (ppn->type == CIM_SINT64)
							{
								pinst->currValue.i64Value = _wtoi64(V_BSTR(&v));
							}
							else if (ppn->type == CIM_UINT64)
							{
								pinst->currValue.ui64Value = 0;
								ReadUI64(V_BSTR(&v), pinst->currValue.ui64Value);
							}
							else
							{
								ppn->type = CIM_STRING;
								if (pinst->szCurrValue)
								{
									delete [] pinst->szCurrValue;
								}
								pinst->szCurrValue = new TCHAR[wcslen(V_BSTR(&v))+2];
								MY_ASSERT(pinst->szCurrValue); if (!pinst->szCurrValue) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
								wcscpy(pinst->szCurrValue , V_BSTR(&v));
							}
						}
						else
						{
							// If for example we had a VT_BSTR | VT_ARRAY would we end up here?
							// We need to do something to detect arrays, and assert, or handle them???
							MY_OUTPUT(L"UNKNOWN DATA TYPE", 3);
							ppn->type = CIM_STRING;
							if (pinst->szCurrValue)
							{
								delete [] pinst->szCurrValue;
							}
							pinst->szCurrValue = new TCHAR[8];
							MY_ASSERT(pinst->szCurrValue); if (!pinst->szCurrValue) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
							wcscpy(pinst->szCurrValue , L"UNKNOWN");
						}
					}

					//
					// Update the min,max and average values
					//
					if (ppn->type != CIM_STRING)
					{
						CalcStatistics(pinst, ppn->type);
					}
				}
				else
				{
					m_ulErrorCode = hRes;
					GetLatestWMIError(HMRES_BADDCPROP, hRes, m_szErrorDescription);
					wcscat(m_szErrorDescription, L" ");
					wcscat(m_szErrorDescription, ppn->szPropertyName);
					bRetValue = FALSE;
					MY_OUTPUT2(L"Couldn't Get instance property=%s", ppn->szPropertyName, 4);
				}
				VariantClear(&v);
			}
		}
	}
	else
	{
		if (!_wcsicmp(pszInstID, L"CollectionInstanceCount"))
		{
			i = iSize-3;
		}
		else if (!_wcsicmp(pszInstID, L"CollectionErrorCode"))
		{
			i = iSize-2;
		}
		else if (!_wcsicmp(pszInstID, L"CollectionErrorDescription"))
		{
			i = iSize-1;
		}
		else
		{
			MY_ASSERT(FALSE);
			i = iSize-3;
		}
		MY_ASSERT(i<m_pnList.size());
		ppn = &m_pnList[i];
		bFound = FALSE;
		jSize = ppn->instList.size();
		for (j = 0; j < jSize ; j++)
		{
			MY_ASSERT(j<ppn->instList.size());
			pinst = &ppn->instList[j];
			if (!_wcsicmp(pinst->szInstanceID, pszInstID))
			{
				bFound = TRUE;
				break;
			}
		}
		MY_ASSERT(bFound == TRUE);

		if (bFound == TRUE)
		{
			//
			// Case where this is the special number of instances property!
			//
			if (!_wcsicmp(pszInstID, L"CollectionInstanceCount"))
			{
				ppn->type = CIM_UINT32;
				pinst->currValue.ulValue = m_lNumInstancesCollected;
				CalcStatistics(pinst, ppn->type);
			}
			else if (!_wcsicmp(pszInstID, L"CollectionErrorCode"))
			{
				ppn->type = CIM_UINT32;
				pinst->currValue.ulValue = m_ulErrorCode;
				CalcStatistics(pinst, ppn->type);
			}
			else if (!_wcsicmp(pszInstID, L"CollectionErrorDescription"))
			{
				ppn->type = CIM_STRING;
				if (pinst->szCurrValue)
				{
					delete [] pinst->szCurrValue;
				}
				pinst->szCurrValue = new TCHAR[wcslen(m_szErrorDescription)+2];
				MY_ASSERT(pinst->szCurrValue); if (!pinst->szCurrValue) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				wcscpy(pinst->szCurrValue , m_szErrorDescription);
			}
			else
			{
				MY_ASSERT(FALSE);
			}
		}
	}

	MY_OUTPUT(L"EXIT ***** CDataCollector::StoreValues...", 1);
	return bRetValue;

error:
	MY_ASSERT(FALSE);
	m_ulErrorCode = HMRES_NOMEMORY;
	GetLatestAgentError(HMRES_NOMEMORY, m_szErrorDescription);
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return FALSE;
}

BOOL CDataCollector::StoreStandardProperties(void)
{
	HRESULT hRetRes;

	if (m_bValidLoad == FALSE)
		return FALSE;

	//
	// Set the standard properties
	//
	hRetRes = CheckInstanceExistance(NULL, L"CollectionInstanceCount");
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	StoreValues(NULL, L"CollectionInstanceCount");

	CheckInstanceExistance(NULL, L"CollectionErrorCode");
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	StoreValues(NULL, L"CollectionErrorCode");

	CheckInstanceExistance(NULL, L"CollectionErrorDescription");
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	StoreValues(NULL, L"CollectionErrorDescription");

	return TRUE;

error:
	MY_ASSERT(FALSE);
	m_ulErrorCode = hRetRes;
	GetLatestWMIError(HMRES_OBJECTNOTFOUND, hRetRes, m_szErrorDescription);
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return FALSE;
}

BOOL CDataCollector::CalcStatistics(INSTSTRUCT *pinst, CIMTYPE type)
{
	int i;
	int iSize;
	VALSTRUCT val;
	VALSTRUCT *pval;
	VALLIST::iterator iaVAL;
	union hm_datatypes value;

	if (type == CIM_STRING)
	{
		MY_ASSERT(FALSE);
	}
	else if (type == CIM_DATETIME)
	{
		MY_ASSERT(FALSE);
	}
	else if (type == CIM_REAL32)
	{
		if (pinst->currValue.fValue < pinst->minValue.fValue)
		{
			pinst->minValue.fValue = pinst->currValue.fValue;
		}

		if (pinst->maxValue.fValue < pinst->currValue.fValue)
		{
			pinst->maxValue.fValue = pinst->currValue.fValue;
		}

		//
		// Add new value to the end.
		// If we are over the limit of number of samples to keep,
		// drop the oldest.
		//
		val.value.fValue = pinst->currValue.fValue;
		pinst->valList.push_back(val);

		iSize = pinst->valList.size();
		if (m_lStatisticsWindowSize < iSize)
		{
			iaVAL=pinst->valList.begin();
			pinst->valList.erase(iaVAL);
		}

		//
		// Now calculate the average from what we have.
		//
		value.fValue = 0;
		iSize = pinst->valList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<pinst->valList.size());
			pval = &pinst->valList[i];
			value.fValue += pval->value.fValue;
		}
		if (i==0)
			pinst->avgValue.fValue = value.fValue;
		else
			pinst->avgValue.fValue = value.fValue/i;
	}
	else if (type == CIM_REAL64)
	{
		if (pinst->currValue.dValue < pinst->minValue.dValue)
		{
			pinst->minValue.dValue = pinst->currValue.dValue;
		}

		if (pinst->maxValue.dValue < pinst->currValue.dValue)
		{
			pinst->maxValue.dValue = pinst->currValue.dValue;
		}

		//
		// Add new value to the end.
		// If we are over the limit of number of samples to keep,
		// drop the oldest.
		//
		val.value.dValue = pinst->currValue.dValue;
		pinst->valList.push_back(val);

		iSize = pinst->valList.size();
		if (m_lStatisticsWindowSize < iSize)
		{
			iaVAL=pinst->valList.begin();
			pinst->valList.erase(iaVAL);
		}

		//
		// Now calculate the average from what we have.
		//
		value.dValue = 0;
		iSize = pinst->valList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<pinst->valList.size());
			pval = &pinst->valList[i];
			value.dValue += pval->value.dValue;
		}
		if (i==0)
			pinst->avgValue.dValue = value.dValue;
		else
			pinst->avgValue.dValue = value.dValue/i;
	}
	else if (type == CIM_SINT64)
	{
		if (pinst->currValue.i64Value < pinst->minValue.i64Value)
		{
			pinst->minValue.i64Value = pinst->currValue.i64Value;
		}

		if (pinst->maxValue.i64Value < pinst->currValue.i64Value)
		{
			pinst->maxValue.i64Value = pinst->currValue.i64Value;
		}

		//
		// Add new value to the end.
		// If we are over the limit of number of samples to keep,
		// drop the oldest.
		//
		val.value.i64Value = pinst->currValue.i64Value;
		pinst->valList.push_back(val);

		iSize = pinst->valList.size();
		if (m_lStatisticsWindowSize < iSize)
		{
			iaVAL=pinst->valList.begin();
			pinst->valList.erase(iaVAL);
		}

		//
		// Now calculate the average from what we have.
		//
		value.i64Value = 0;
		iSize = pinst->valList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<pinst->valList.size());
			pval = &pinst->valList[i];
			value.i64Value += pval->value.i64Value;
		}
		if (i==0)
			pinst->avgValue.i64Value = value.i64Value;
		else
			pinst->avgValue.i64Value = value.i64Value/i;
	}
	else if (type == CIM_UINT64)
	{
		if (pinst->currValue.ui64Value < pinst->minValue.ui64Value)
		{
			pinst->minValue.ui64Value = pinst->currValue.ui64Value;
		}

		if (pinst->maxValue.ui64Value < pinst->currValue.ui64Value)
		{
			pinst->maxValue.ui64Value = pinst->currValue.ui64Value;
		}

		//
		// Add new value to the end.
		// If we are over the limit of number of samples to keep,
		// drop the oldest.
		//
		val.value.ui64Value = pinst->currValue.ui64Value;
		pinst->valList.push_back(val);

		iSize = pinst->valList.size();
		if (m_lStatisticsWindowSize < iSize)
		{
			iaVAL=pinst->valList.begin();
			pinst->valList.erase(iaVAL);
		}

		//
		// Now calculate the average from what we have.
		//
		value.ui64Value = 0;
		iSize = pinst->valList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<pinst->valList.size());
			pval = &pinst->valList[i];
			value.ui64Value += pval->value.ui64Value;
		}
		if (i==0)
			pinst->avgValue.ui64Value = value.ui64Value;
		else
			pinst->avgValue.ui64Value = value.ui64Value/i;
	}
	else if (type == CIM_UINT32)
	{
		// Must be an integer type
		if (pinst->currValue.ulValue < pinst->minValue.ulValue)
		{
			pinst->minValue.ulValue = pinst->currValue.ulValue;
		}

		if (pinst->maxValue.ulValue < pinst->currValue.ulValue)
		{
			pinst->maxValue.ulValue = pinst->currValue.ulValue;
		}

		//
		// Add new value to the end.
		// If we are over the limit of number of samples to keep,
		// drop the oldest.
		//
		val.value.ulValue = pinst->currValue.ulValue;
		pinst->valList.push_back(val);

		iSize = pinst->valList.size();
		if (m_lStatisticsWindowSize < iSize)
		{
			iaVAL=pinst->valList.begin();
			pinst->valList.erase(iaVAL);
		}

		//
		// Now calculate the average from what we have.
		//
		value.ulValue = 0;
		iSize = pinst->valList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<pinst->valList.size());
			pval = &pinst->valList[i];
			value.ulValue += pval->value.ulValue;
		}
		if (i==0)
			pinst->avgValue.ulValue = value.ulValue;
		else
			pinst->avgValue.ulValue = value.ulValue/i;
	}
	else
	{
		// Must be an integer type
		if (pinst->currValue.lValue < pinst->minValue.lValue)
		{
			pinst->minValue.lValue = pinst->currValue.lValue;
		}

		if (pinst->maxValue.lValue < pinst->currValue.lValue)
		{
			pinst->maxValue.lValue = pinst->currValue.lValue;
		}

		//
		// Add new value to the end.
		// If we are over the limit of number of samples to keep,
		// drop the oldest.
		//
		val.value.lValue = pinst->currValue.lValue;
		pinst->valList.push_back(val);

		iSize = pinst->valList.size();
		if (m_lStatisticsWindowSize < iSize)
		{
			iaVAL=pinst->valList.begin();
			pinst->valList.erase(iaVAL);
		}

		//
		// Now calculate the average from what we have.
		//
		value.lValue = 0;
		iSize = pinst->valList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<pinst->valList.size());
			pval = &pinst->valList[i];
			value.lValue += pval->value.lValue;
		}
		if (i==0)
			pinst->avgValue.lValue = value.lValue;
		else
			pinst->avgValue.lValue = value.lValue/i;
	}

	return TRUE;
}

BOOL CDataCollector::EvaluateThresholds(BOOL bIgnoreReset, BOOL bSkipStandard/*=FALSE*/, BOOL bSkipOthers/*=FALSE*/, BOOL bDoThresholdSkipClean/*=TRUE*/)
{
	LPTSTR pszPropertyName;
	int iSize;
	int jSize;
	int i;
	int j;
	CThreshold* pThreshold;
	PNSTRUCT *ppn = NULL;
	BOOL bFound = FALSE;
	INSTSTRUCT *pinst;

	if (m_bValidLoad == FALSE)
		return FALSE;

	//
	// For each threshold associated with this DataCollector, find the property status
	// structure, and have the threshold evaluate against the current values.
	//
	iSize = m_thresholdList.size();
	for (i = 0; i < iSize; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		if (pThreshold->m_bValidLoad == FALSE)
			break;
		pszPropertyName = pThreshold->GetPropertyName();
		if (bSkipStandard && (!_wcsicmp(pszPropertyName, L"CollectionInstanceCount") ||
			!_wcsicmp(pszPropertyName, L"CollectionErrorCode") ||
			!_wcsicmp(pszPropertyName, L"CollectionErrorDescription")))
		{
			if (bDoThresholdSkipClean)
				pThreshold->SkipClean();
			continue;
		}
		if (bSkipOthers && (_wcsicmp(pszPropertyName, L"CollectionInstanceCount") &&
			_wcsicmp(pszPropertyName, L"CollectionErrorCode") &&
			_wcsicmp(pszPropertyName, L"CollectionErrorDescription")))
		{
			if (bDoThresholdSkipClean)
				pThreshold->SkipClean();
			continue;
		}
		jSize = m_pnList.size();
		for (j = 0; j < jSize ; j++)
		{
			MY_ASSERT(j<m_pnList.size());
			ppn = &m_pnList[j];
			if (!_wcsicmp(ppn->szPropertyName, pszPropertyName))
			{
				bFound = TRUE;
				break;
			}
		}

		//
		// If the type is still equal to zero, that means that the threshold is probably looking
		// at a property that does not exist.
		// Also remember that if we are transitioning to DISABLED, or SCHEDULEDOUT we need to
		// go into the Threshold evaluation do disable them.
		//
		if ((m_lCurrState==HM_DISABLED || m_lCurrState==HM_SCHEDULEDOUT) ||
			((m_ulErrorCode==0 || (m_ulErrorCode!=0 && !wcscmp(pszPropertyName, L"CollectionErrorCode"))) &&
			(bFound && ppn->type!=0)))
		{
			//
			// Also need to watch for case where we can't do evaluation yet.
			// If AVERAGE is used, then wait until full window of samples has been collected.
			// If difference, then must wait for the second one.
			//
			if (pThreshold->m_bUseDifference)
			{
				if (m_lIntervalCount < 2)
				{
					continue;
				}
			}
			else if (pThreshold->m_bUseAverage)
			{
				// Need to find out how many samples we have
				MY_ASSERT(ppn);
				if (ppn->instList.size())
				{
					pinst = &ppn->instList[0];
					if (pinst->valList.size() < m_lStatisticsWindowSize)
					{
						continue;
					}
				}
				else
				{
				}
			}

			// If this threshold has already been violated and the RequireReset is TRUE
			// then we don't need to test for re-arm.
				if (bIgnoreReset == TRUE)
				{
					if (pThreshold->GetCurrState() != HM_RESET)
					{
						pThreshold->SetCurrState(HM_COLLECTING);
						pThreshold->SetBackPrev(ppn);
						pThreshold->OnAgentInterval(&m_actualInstList, ppn, m_bRequireReset);
					}
				}
				else
				{
					pThreshold->OnAgentInterval(&m_actualInstList, ppn, m_bRequireReset);
				}
		}
		else
		{
			if (pThreshold->m_bEnabled==FALSE || pThreshold->m_bParentEnabled==FALSE || pThreshold->m_bParentScheduledOut)
			{
					pThreshold->OnAgentInterval(&m_actualInstList, ppn, m_bRequireReset);
			}
 			else if (m_ulErrorCode!=0)
			{
					// Case where had an error in the collection process that needs to take priority.
					pThreshold->SetCurrState(HM_CRITICAL, m_ulErrorCode!=m_ulErrorCodePrev, HMRES_DCUNKNOWN);
					pThreshold->FireEvent(m_ulErrorCode!=m_ulErrorCodePrev);
			}
			else if (ppn->type==0)
			{
				// Having zero instances is not a crime if we are certain types of DataColectors.
				if (m_lNumInstancesCollected>0)
				{
					// Case where the property to collect did not exist
					m_ulErrorCode = HMRES_BADTHRESHPROP;
					pThreshold->SetCurrState(HM_CRITICAL, m_ulErrorCode!=m_ulErrorCodePrev, HMRES_BADTHRESHPROP);
					pThreshold->FireEvent(m_ulErrorCode!=m_ulErrorCodePrev);
					GetLatestAgentError(HMRES_BADTHRESHPROP, m_szErrorDescription);
					wcscat(m_szErrorDescription, L" ");
					wcscat(m_szErrorDescription, pszPropertyName);
					StoreValues(NULL, L"CollectionErrorCode");
					StoreValues(NULL, L"CollectionErrorDescription");
				}
				else
				{
					pThreshold->SetCurrState(HM_GOOD, m_ulErrorCode!=m_ulErrorCodePrev, HMRES_DCUNKNOWN);
					pThreshold->FireEvent(m_ulErrorCode!=m_ulErrorCodePrev);
				}
			}
			else
			{
			}
		}
	}

	return TRUE;
}

HRESULT CDataCollector::SendHMDataCollectorStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	MY_ASSERT(pSink!=NULL);

	//
	// Is this the one we are looking for?
	//
	if (!_wcsicmp(m_szGUID, pszGUID))
	{
		//
		// Don't do anything if we are not loaded correctly.
		//
//XXX		if (m_bValidLoad == FALSE)
//XXX			return WBEM_E_INVALID_OBJECT;

		return SendHMDataCollectorStatusInstances(pSink);
	}
	else
	{
		return WBEM_S_DIFFERENT;
	}
}

HRESULT CDataCollector::SendHMDataCollectorStatusInstances(IWbemObjectSink* pSink)
{
	HRESULT hRes = S_OK;
	IWbemClassObject* pInstance = NULL;

	MY_OUTPUT(L"ENTER ***** SendHMDataCollectorStatusInstances...", 2);

//XXX	if (m_bValidLoad == FALSE)
//XXX		return WBEM_E_INVALID_OBJECT;

	if (pSink == NULL)
	{
		MY_OUTPUT(L"CDC::SendInitialHMMachStatInstances-Invalid Sink", 1);
		return WBEM_E_FAILED;
	}

	hRes = GetHMDataCollectorStatusInstance(&pInstance, FALSE);
	if (SUCCEEDED(hRes))
	{
		hRes = pSink->Indicate(1, &pInstance);

		if (FAILED(hRes) && hRes!=WBEM_E_SERVER_TOO_BUSY && hRes!=WBEM_E_CALL_CANCELLED && hRes!=WBEM_E_TRANSPORT_FAILURE)
		{
			MY_OUTPUT(L"SendHMDataCollectorStatusInstances-failed to send status!", 1);
		}

		pInstance->Release();
		pInstance = NULL;
	}
	else
	{
		MY_OUTPUT(L":SendHMDataCollectorStatusInstances-failed to get instance!", 1);
	}

	MY_OUTPUT(L"EXIT ***** SendHMDataCollectorStatusInstances...", 2);
	return hRes;
}

HRESULT CDataCollector::SendHMDataCollectorPerInstanceStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	MY_ASSERT(pSink!=NULL);

	//
	// Is this the one we are looking for?
	//
	if (!_wcsicmp(m_szGUID, pszGUID))
	{
		if (m_bValidLoad == FALSE)
			return WBEM_E_INVALID_OBJECT;

		return SendHMDataCollectorPerInstanceStatusInstances(pSink);
	}
	else
	{
		return WBEM_S_DIFFERENT;
	}
}

// This one is for enumeration of all Instances outside of the hierarchy.
// Just the flat list.
HRESULT CDataCollector::SendHMDataCollectorPerInstanceStatusInstances(IWbemObjectSink* pSink)
{
	HRESULT hRes;
	long state;
	int i, iSize;
	BOOL bRetValue = TRUE;
	IWbemClassObject* pInstance = NULL;
	ACTUALINSTSTRUCT *pActualInst;
	long firstInstanceState = -1;

	MY_OUTPUT(L"ENTER ***** CDataCollector::SendHMDataCollectorPerInstanceStatusInstance...", 2);

	if (m_bValidLoad == FALSE)
		return WBEM_E_INVALID_OBJECT;

	if (pSink == NULL)
	{
		MY_OUTPUT(L"-Invalid Sink", 1);
		return WBEM_E_FAILED;
	}

	//
	// We can loop through the set of collected instances and ask each Threshold
	// to tell us if the state has changed as far as each is concerned, for the
	// property they are lookin at.
	//
	iSize = m_actualInstList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_actualInstList.size());
		pActualInst = &m_actualInstList[i];

		state = PassBackWorstStatePerInstance(pActualInst->szInstanceID, (BOOL)i==0);
		if (state==-1) state = HM_COLLECTING;
		if (i==0)
		{
			firstInstanceState = state;
		}
		hRes = GetHMDataCollectorPerInstanceStatusEvent(pActualInst->szInstanceID, pActualInst, state, &pInstance, FALSE);
		if (SUCCEEDED(hRes))
		{
			hRes = pSink->Indicate(1, &pInstance);
	
			if (FAILED(hRes) && hRes!=WBEM_E_SERVER_TOO_BUSY && hRes!=WBEM_E_CALL_CANCELLED && hRes!=WBEM_E_TRANSPORT_FAILURE)
			{
				MY_OUTPUT(L"SendHMDataCollectorStatusInstances-failed to send status!", 1);
			}
	
			pInstance->Release();
			pInstance = NULL;
		}
		else
		{
			MY_OUTPUT(L":SendHMDataCollectorStatusInstances-failed to get instance!", 1);
		}
	}

	//
	// Do it for the three default properties
	//
	if (firstInstanceState==-1)
	{
		state = PassBackWorstStatePerInstance(L"CollectionInstanceCount", FALSE);
		if (state==-1) state = HM_COLLECTING;
		hRes = GetHMDataCollectorPerInstanceStatusEvent(L"CollectionInstanceCount", NULL, state, &pInstance, FALSE);
		if (SUCCEEDED(hRes))
		{
			hRes = pSink->Indicate(1, &pInstance);

			if (FAILED(hRes) && hRes!=WBEM_E_SERVER_TOO_BUSY && hRes!=WBEM_E_CALL_CANCELLED && hRes!=WBEM_E_TRANSPORT_FAILURE)
			{
				MY_OUTPUT(L"SendHMDataCollectorStatusInstances-failed to send status!", 1);
			}

			pInstance->Release();
			pInstance = NULL;
		}
		else
		{
			MY_OUTPUT(L":SendHMDataCollectorStatusInstances-failed to get instance!", 1);
		}
	}

	if (firstInstanceState==-1)
	{
		state = PassBackWorstStatePerInstance(L"CollectionErrorCode", FALSE);
		if (state==-1) state = HM_COLLECTING;
		hRes = GetHMDataCollectorPerInstanceStatusEvent(L"CollectionErrorCode", NULL, state, &pInstance, FALSE);
		if (SUCCEEDED(hRes))
		{
			hRes = pSink->Indicate(1, &pInstance);

			if (FAILED(hRes) && hRes!=WBEM_E_SERVER_TOO_BUSY && hRes!=WBEM_E_CALL_CANCELLED && hRes!=WBEM_E_TRANSPORT_FAILURE)
			{
				MY_OUTPUT(L"SendHMDataCollectorStatusInstances-failed to send status!", 1);
			}

			pInstance->Release();
			pInstance = NULL;
		}
		else
		{
			MY_OUTPUT(L":SendHMDataCollectorStatusInstances-failed to get instance!", 1);
		}
	}

#ifdef SAVE
	state = PassBackWorstStatePerInstance(L"CollectionErrorDescription");
	if (state==-1) state = HM_COLLECTING;
	hRes = GetHMDataCollectorPerInstanceStatusEvent(L"CollectionErrorDescription", NULL, state, &pInstance, FALSE);
	if (SUCCEEDED(hRes))
	{
		hRes = pSink->Indicate(1, &pInstance);

		if (FAILED(hRes) && hRes!=WBEM_E_SERVER_TOO_BUSY && hRes!=WBEM_E_CALL_CANCELLED && hRes!=WBEM_E_TRANSPORT_FAILURE)
		{
			MY_OUTPUT(L"SendHMDataCollectorStatusInstances-failed to send status!", 1);
		}

		pInstance->Release();
		pInstance = NULL;
	}
	else
	{
		MY_OUTPUT(L":SendHMDataCollectorStatusInstances-failed to get instance!", 1);
	}
#endif


	MY_OUTPUT(L"EXIT ***** CDataCollector::FirePerInstanceEvents...", 2);
	return S_OK;
}

HRESULT CDataCollector::SendHMDataCollectorStatisticsInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	MY_ASSERT(pSink!=NULL);

	//
	// Is this the one we are looking for?
	//
	if (!_wcsicmp(m_szGUID, pszGUID))
	{
		if (m_bValidLoad == FALSE)
			return WBEM_E_INVALID_OBJECT;

		return SendHMDataCollectorStatisticsInstances(pSink);
	}
	else
	{
		return WBEM_S_DIFFERENT;
	}
}

HRESULT CDataCollector::SendHMDataCollectorStatisticsInstances(IWbemObjectSink* pSink)
{
	HRESULT hRes = S_OK;

	MY_OUTPUT(L"ENTER ***** SendHMDataCollectorStatisticsInstances...", 2);

	if (m_bValidLoad == FALSE)
		return WBEM_E_INVALID_OBJECT;

	if (pSink == NULL)
	{
		MY_OUTPUT(L"CDC::SendInitialHMMachStatInstances-Invalid Sink", 1);
		return WBEM_E_FAILED;
	}

	hRes = GetHMDataCollectorStatisticsInstances(m_szDTCollectTime, m_szCollectTime);

	MY_OUTPUT(L"EXIT ***** SendHMDataCollectorStatisticsInstances...", 2);
	return hRes;
}

HRESULT CDataCollector::SendHMThresholdStatusInstances(IWbemObjectSink* pSink)
{
	int i;
	int iSize;
	CThreshold *pThreshold;
	PNSTRUCT *ppn = NULL;
	BOOL bFound = FALSE;

	MY_OUTPUT(L"ENTER ***** SendHMThresholdStatusInstances...", 1);

	// Have all Thresholds of this DataCollector send their status
	iSize = m_thresholdList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		pThreshold->SendHMThresholdStatusInstances(pSink);
	}

	MY_OUTPUT(L"EXIT ***** SendHMThresholdStatusInstances...", 1);
	return S_OK;
}

HRESULT CDataCollector::SendHMThresholdStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	int i;
	int iSize;
	CThreshold *pThreshold;
	PNSTRUCT *ppn = NULL;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** SendHMThresholdStatusInstance...", 1);

	// Try to find the one that needs sending
	iSize = m_thresholdList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		hRetRes = pThreshold->SendHMThresholdStatusInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	MY_OUTPUT(L"EXIT ***** SendHMThresholdStatusInstance...", 1);
	return WBEM_S_DIFFERENT;
}

HRESULT CDataCollector::GetHMDataCollectorStatusInstance(IWbemClassObject** ppInstance, BOOL bEventBased)
{
	TCHAR szTemp[1024];
	IWbemClassObject* pClass = NULL;
	BSTR bsString = NULL;
	HRESULT hRetRes = S_OK;
	DWORD dwNameLen = MAX_COMPUTERNAME_LENGTH + 2;
	TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 2];

	MY_OUTPUT(L"ENTER ***** GetHMSystemStatusInstance...", 1);

	if (bEventBased)
	{
		bsString = SysAllocString(L"MicrosoftHM_DataCollectorStatusEvent");
		MY_ASSERT(bsString); if (!bsString) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	}
	else
	{
		bsString = SysAllocString(L"MicrosoftHM_DataCollectorStatus");
		MY_ASSERT(bsString); if (!bsString) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	}
	hRetRes = g_pIWbemServices->GetObject(bsString, 0L, NULL, &pClass, NULL);
	SysFreeString(bsString);
	bsString = NULL;

	if (FAILED(hRetRes))
	{
		return hRetRes;
	}

	hRetRes = pClass->SpawnInstance(0, ppInstance);
	pClass->Release();
	pClass = NULL;

	if (FAILED(hRetRes))
		return hRetRes;

	if (m_bValidLoad == FALSE)
	{
		hRetRes = PutStrProperty(*ppInstance, L"GUID", m_szGUID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = PutStrProperty(*ppInstance, L"ParentGUID", m_pParentDG->m_szGUID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = PutUint32Property(*ppInstance, L"State", HM_CRITICAL);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_DC_LOADFAIL, szTemp, 1024))
		{
			wcscpy(szTemp, L"Data Collector failed to load.");
		}
		hRetRes = PutStrProperty(*ppInstance, L"Message", szTemp);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		if (GetComputerName(szComputerName, &dwNameLen))
		{
			hRetRes = PutStrProperty(*ppInstance, L"SystemName", szComputerName);
		}
		else
		{
			hRetRes = PutStrProperty(*ppInstance, L"SystemName", L"LocalMachine");
		}
		hRetRes = PutStrProperty(*ppInstance, L"TimeGeneratedGMT", m_szDTTime);
		hRetRes = PutStrProperty(*ppInstance, L"LocalTimeFormatted", m_szTime);
hRetRes = PutStrProperty(*ppInstance, L"Name", L"...");
	}
	else
	{
		hRetRes = PutStrProperty(*ppInstance, L"GUID", m_szGUID);
		hRetRes = PutStrProperty(*ppInstance, L"ParentGUID", m_pParentDG->m_szGUID);
		hRetRes = PutStrProperty(*ppInstance, L"Name", m_szName);
		if (GetComputerName(szComputerName, &dwNameLen))
		{
			hRetRes = PutStrProperty(*ppInstance, L"SystemName", szComputerName);
		}
		else
		{
			hRetRes = PutStrProperty(*ppInstance, L"SystemName", L"LocalMachine");
		}
		hRetRes = PutUint32Property(*ppInstance, L"State", m_lCurrState);
		hRetRes = PutUint32Property(*ppInstance, L"CollectionInstanceCount", m_lNumInstancesCollected);
		hRetRes = PutUUint32Property(*ppInstance, L"CollectionErrorCode", m_ulErrorCode);
		hRetRes = PutStrProperty(*ppInstance, L"CollectionErrorDescription", m_szErrorDescription);
		hRetRes = PutStrProperty(*ppInstance, L"TimeGeneratedGMT", m_szDTTime);
		hRetRes = PutStrProperty(*ppInstance, L"LocalTimeFormatted", m_szTime);
		hRetRes = PutStrProperty(*ppInstance, L"StatusGUID", m_szStatusGUID);

		if (m_lCurrState==HM_SCHEDULEDOUT)
		{
			if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_OUTAGE, szTemp, 1024))
			{
				wcscpy(szTemp, L"Data Collector in Scheduled Outage State");
			}
			hRetRes = PutStrProperty(*ppInstance, L"Message", szTemp);
		}
		else if (m_lCurrState==HM_DISABLED)
		{
			if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_DISABLE, szTemp, 1024))
			{
				wcscpy(szTemp, L"Data Collector in Disabled State");
			}
			hRetRes = PutStrProperty(*ppInstance, L"Message", szTemp);
		}
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}

	MY_OUTPUT(L"EXIT ***** GetHMSystemStatusInstance...", 1);
	return hRetRes;

error:
	MY_ASSERT(FALSE);
	if (bsString)
		SysFreeString(bsString);
	if (pClass)
		pClass->Release();
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

HRESULT CDataCollector::GetHMDataCollectorStatisticsInstances(LPTSTR szDTTime, LPTSTR szTime)
{
	HRESULT hRetRes = S_OK;
	PNSTRUCT *ppn = NULL;
	INSTSTRUCT *pinst = NULL;
	int i, iSize;
	int j, jSize;
	TCHAR szTemp[128] = {0};
	IWbemClassObject* pClass = NULL;
	IWbemClassObject* pInstance = NULL;
	BSTR bsString = NULL;
	DWORD dwNameLen = MAX_COMPUTERNAME_LENGTH + 2;
	TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 2];
	int rc = 0;
	char buffer[50];

	iSize = m_pnList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_pnList.size());
		ppn = &m_pnList[i];

		jSize = ppn->instList.size();
		for (j=0; j < jSize ; j++)
		{
			MY_ASSERT(j<ppn->instList.size());
			pinst = &ppn->instList[j];
	
			bsString = SysAllocString(L"MicrosoftHM_DataCollectorStatistics");
			MY_ASSERT(bsString); if (!bsString) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			hRetRes = g_pIWbemServices->GetObject(bsString, 0L, NULL, &pClass, NULL);
			SysFreeString(bsString);
			bsString = NULL;

			if (FAILED(hRetRes))
			{
				return hRetRes;
			}

			hRetRes = pClass->SpawnInstance(0, &pInstance);
			pClass->Release();
			pClass = NULL;

			if (FAILED(hRetRes))
				return hRetRes;

			hRetRes = PutStrProperty(pInstance, L"GUID", m_szGUID);
			if (GetComputerName(szComputerName, &dwNameLen))
			{
				hRetRes = PutStrProperty(pInstance, L"SystemName", szComputerName);
			}
			else
			{
				hRetRes = PutStrProperty(pInstance, L"SystemName", L"LocalMachine");
			}
			hRetRes = PutStrProperty(pInstance, L"PropertyName", ppn->szPropertyName);
			hRetRes = PutStrProperty(pInstance, L"InstanceName", pinst->szInstanceID);
			hRetRes = PutStrProperty(pInstance, L"TimeGeneratedGMT", szDTTime);
			hRetRes = PutStrProperty(pInstance, L"LocalTimeFormatted", szTime);
			if (pinst->bNull==TRUE)
			{
				hRetRes = PutStrProperty(pInstance, L"CurrentValue", L"NULL");
			}
			else if (ppn->type==CIM_STRING || ppn->type==CIM_DATETIME)
			{
				if (pinst->szCurrValue)
				{
					hRetRes = PutStrProperty(pInstance, L"CurrentValue", pinst->szCurrValue);
				}
				else
				{
					hRetRes = PutStrProperty(pInstance, L"CurrentValue", L"");
				}
			}
			else if (ppn->type == CIM_REAL32)
			{
				_gcvt((double)pinst->currValue.fValue, 7, buffer);
				rc = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, buffer, strlen(buffer), szTemp, 128);
				szTemp[rc] = NULL;
				hRetRes = PutStrProperty(pInstance, L"CurrentValue", szTemp);
			}
			else if (ppn->type == CIM_REAL64)
			{
				_gcvt(pinst->currValue.dValue, 7, buffer);
				rc = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, buffer, strlen(buffer), szTemp, 128);
				szTemp[rc] = NULL;
				hRetRes = PutStrProperty(pInstance, L"CurrentValue", szTemp);
			}
			else if (ppn->type == CIM_SINT64)
			{
				_i64tow(pinst->currValue.i64Value, szTemp, 10 );
				hRetRes = PutStrProperty(pInstance, L"CurrentValue", szTemp);
			}
			else if (ppn->type == CIM_UINT64)
			{
				_ui64tow(pinst->currValue.ui64Value, szTemp, 10 );
				hRetRes = PutStrProperty(pInstance, L"CurrentValue", szTemp);
			}
			else if (ppn->type == CIM_UINT32)
			{
				// Must be an integer type
				_ultow(pinst->currValue.ulValue, szTemp, 10 );
				hRetRes = PutStrProperty(pInstance, L"CurrentValue", szTemp);
			}
			else
			{
				// Must be an integer type
				_ltow(pinst->currValue.lValue, szTemp, 10 );
				hRetRes = PutStrProperty(pInstance, L"CurrentValue", szTemp);
			}

			if (pinst->bNull==TRUE)
			{
				hRetRes = PutStrProperty(pInstance, L"MinValue", L"");
				hRetRes = PutStrProperty(pInstance, L"MaxValue", L"");
				hRetRes = PutStrProperty(pInstance, L"AvgValue", L"");
			}
			else if (ppn->type==CIM_STRING || ppn->type==CIM_DATETIME)
			{
				hRetRes = PutStrProperty(pInstance, L"MinValue", L"");
				hRetRes = PutStrProperty(pInstance, L"MaxValue", L"");
				hRetRes = PutStrProperty(pInstance, L"AvgValue", L"");
			}
			else if (ppn->type == CIM_REAL32)
			{
				_gcvt((double)pinst->minValue.fValue, 7, buffer);
				rc = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, buffer, strlen(buffer), szTemp, 128);
				szTemp[rc] = NULL;
				hRetRes = PutStrProperty(pInstance, L"MinValue", szTemp);
				_gcvt((double)pinst->maxValue.fValue, 7, buffer);
				rc = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, buffer, strlen(buffer), szTemp, 128);
				szTemp[rc] = NULL;
				hRetRes = PutStrProperty(pInstance, L"MaxValue", szTemp);
				_gcvt((double)pinst->avgValue.fValue, 7, buffer);
				rc = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, buffer, strlen(buffer), szTemp, 128);
				szTemp[rc] = NULL;
				hRetRes = PutStrProperty(pInstance, L"AvgValue", szTemp);
			}
			else if (ppn->type == CIM_REAL64)
			{
				_gcvt(pinst->minValue.dValue, 7, buffer);
				rc = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, buffer, strlen(buffer), szTemp, 128);
				szTemp[rc] = NULL;
				hRetRes = PutStrProperty(pInstance, L"MinValue", szTemp);
				_gcvt(pinst->maxValue.dValue, 7, buffer);
				rc = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, buffer, strlen(buffer), szTemp, 128);
				szTemp[rc] = NULL;
				hRetRes = PutStrProperty(pInstance, L"MaxValue", szTemp);
				_gcvt(pinst->avgValue.dValue, 7, buffer);
				rc = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, buffer, strlen(buffer), szTemp, 128);
				szTemp[rc] = NULL;
				hRetRes = PutStrProperty(pInstance, L"AvgValue", szTemp);
			}
			else if (ppn->type == CIM_SINT64)
			{
				_i64tow(pinst->minValue.i64Value, szTemp, 10 );
				hRetRes = PutStrProperty(pInstance, L"MinValue", szTemp);
				_i64tow(pinst->maxValue.i64Value, szTemp, 10 );
				hRetRes = PutStrProperty(pInstance, L"MaxValue", szTemp);
				_i64tow(pinst->avgValue.i64Value, szTemp, 10 );
				hRetRes = PutStrProperty(pInstance, L"AvgValue", szTemp);
			}
			else if (ppn->type == CIM_UINT64)
			{
				_ui64tow(pinst->minValue.ui64Value, szTemp, 10 );
				hRetRes = PutStrProperty(pInstance, L"MinValue", szTemp);
				_ui64tow(pinst->maxValue.ui64Value, szTemp, 10 );
				hRetRes = PutStrProperty(pInstance, L"MaxValue", szTemp);
				_ui64tow(pinst->avgValue.ui64Value, szTemp, 10 );
				hRetRes = PutStrProperty(pInstance, L"AvgValue", szTemp);
			}
			else if (ppn->type == CIM_UINT32)
			{
				// Must be an integer type
				_ultow(pinst->minValue.ulValue, szTemp, 10 );
				hRetRes = PutStrProperty(pInstance, L"MinValue", szTemp);
				_ultow(pinst->maxValue.ulValue, szTemp, 10 );
				hRetRes = PutStrProperty(pInstance, L"MaxValue", szTemp);
				_ultow(pinst->avgValue.ulValue, szTemp, 10 );
				hRetRes = PutStrProperty(pInstance, L"AvgValue", szTemp);
			}
			else
			{
				// Must be an integer type
				_ltow(pinst->minValue.lValue, szTemp, 10 );
				hRetRes = PutStrProperty(pInstance, L"MinValue", szTemp);
				_ltow(pinst->maxValue.lValue, szTemp, 10 );
				hRetRes = PutStrProperty(pInstance, L"MaxValue", szTemp);
				_ltow(pinst->avgValue.lValue, szTemp, 10 );
				hRetRes = PutStrProperty(pInstance, L"AvgValue", szTemp);
			}

			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			// If we do not have all our samples, then don't show the average yet
			if (pinst->valList.size() < m_lStatisticsWindowSize)
			{
				hRetRes = PutStrProperty(pInstance, L"AvgValue", L"-");
			}

			mg_DCStatsInstList.push_back(pInstance);
		}
	}

	return S_OK;

error:
	MY_ASSERT(FALSE);
	if (bsString)
		SysFreeString(bsString);
	if (pClass)
		pClass->Release();
	iSize = mg_DCStatsInstList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<mg_DCStatsInstList.size());
		pInstance = mg_DCStatsInstList[i];
    	pInstance->Release();
	}
	mg_DCStatsInstList.clear();
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

long CDataCollector::GetCurrState(void)
{
	return m_lCurrState;
}

HRESULT CDataCollector::FindAndModDataCollector(BSTR szGUID, IWbemClassObject* pObj)
{
	HRESULT hRetRes = S_OK;

	//
	// Is this us we are looking for?
	//
	if (!_wcsicmp(m_szGUID, szGUID))
	{
		hRetRes = LoadInstanceFromMOF(pObj, NULL, L"", TRUE);
		return hRetRes;
	}

	return WBEM_S_DIFFERENT;
}

HRESULT CDataCollector::FindAndModThreshold(BSTR szGUID, IWbemClassObject* pObj)
{
	TCHAR szTemp[1024];
	HRESULT hRetRes = S_OK;
	int i, iSize;
	CThreshold* pThreshold;

	if (m_bValidLoad == FALSE)
		return WBEM_E_INVALID_OBJECT;

	//
	// Look at Threshold of this DataDataCollector
	//
	iSize = m_thresholdList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		if (pThreshold->m_bValidLoad == FALSE)
			return WBEM_E_INVALID_OBJECT;
		hRetRes = pThreshold->FindAndModThreshold(szGUID, pObj);
		if (hRetRes==S_OK)
		{
			wcsncpy(szTemp, pThreshold->m_szPropertyName, 1023);
			szTemp[1023] = '\0';
			// Check to see if the Threshold is looking at a different property!
			if (_wcsicmp(szTemp, pThreshold->m_szPropertyName))
			{
				if (_wcsicmp(szTemp, L"CollectionInstanceCount") &&
					_wcsicmp(szTemp, L"CollectionErrorCode") &&
					_wcsicmp(szTemp, L"CollectionErrorDescription"))
				{
					propertyNotNeeded(szTemp);
				}
				if (_wcsicmp(pThreshold->m_szPropertyName, L"CollectionInstanceCount") &&
					_wcsicmp(pThreshold->m_szPropertyName, L"CollectionErrorCode") &&
					_wcsicmp(pThreshold->m_szPropertyName, L"CollectionErrorDescription"))
				{
					hRetRes = insertNewProperty(pThreshold->m_szPropertyName);
					if (hRetRes != S_OK)
						return hRetRes;
				}
			}
			ResetState(TRUE, TRUE);
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			MY_ASSERT(FALSE);
			m_bValidLoad = FALSE;
			Cleanup(FALSE);
			return hRetRes;
		}
	}

	return WBEM_S_DIFFERENT;
}

HRESULT CDataCollector::AddThreshold(BSTR szParentGUID, BSTR szChildGUID)
{
	int i, iSize;
	TCHAR szTemp[1024];
	CThreshold* pThreshold = NULL;
	IWbemClassObject *pObj = NULL;
	BSTR Path = NULL;
	HRESULT hRetRes;
	LPTSTR pszTempGUID = NULL;

	//
	// Are we the parent DataGroup that we want to add under?
	//
	if (!_wcsicmp(m_szGUID, szParentGUID))
	{
		//
		// First check to see if is in there already!
		//
		iSize = m_thresholdList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<m_thresholdList.size());
			pThreshold = m_thresholdList[i];
			if (!_wcsicmp(szChildGUID, pThreshold->GetGUID()))
			{
				return S_OK;
			}
		}

		//
		// Add in the Threshold
		//
		wcscpy(szTemp, L"MicrosoftHM_ThresholdConfiguration.GUID=\"");
		lstrcat(szTemp, szChildGUID);
		lstrcat(szTemp, L"\"");
		Path = SysAllocString(szTemp);
		MY_ASSERT(Path); if (!Path) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

		hRetRes = GetWbemObjectInst(&g_pIWbemServices, Path, NULL, &pObj);
		if (!pObj)
		{
			SysFreeString(Path);
			Path = NULL;
			return hRetRes;
		}

		TCHAR msgbuf[1024];
		wsprintf(msgbuf, L"ASSOCIATION: Threshold to DataCollector ParentDCGUID=%s ChildTGUID=%s", szParentGUID, szChildGUID);
		MY_OUTPUT(msgbuf, 4);

		// See if this is already read in. Need to prevent endless loop, circular references.
		hRetRes = GetStrProperty(pObj, L"GUID", &pszTempGUID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		if (!g_pStartupSystem->FindPointerFromGUIDInMasterList(pszTempGUID))
		{
			//
			// Create the internal class to represent the DataGroup
			//
			pThreshold = new CThreshold;
			MY_ASSERT(pThreshold); if (!pThreshold) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			if (m_deType == HM_PGDE)
			{
				wcscpy(szTemp, L"MicrosoftHM_PolledGetObjectDataCollectorConfiguration.GUID=\\\"");
			}
			else if (m_deType == HM_PMDE)
			{
				wcscpy(szTemp, L"MicrosoftHM_PolledMethodDataCollectorConfiguration.GUID=\\\"");
			}
			else if (m_deType == HM_PQDE)
			{
				wcscpy(szTemp, L"MicrosoftHM_PolledQueryDataCollectorConfiguration.GUID=\\\"");
			}
			else if (m_deType == HM_EQDE)
			{
				wcscpy(szTemp, L"MicrosoftHM_EventQueryDataCollectorConfiguration.GUID=\\\"");
			}
			lstrcat(szTemp, m_szGUID);
			lstrcat(szTemp, L"\\\"");
			if (pThreshold->LoadInstanceFromMOF(pObj, this, szTemp)==S_OK)
			{
				if (_wcsicmp(pThreshold->m_szPropertyName, L"CollectionInstanceCount") &&
					_wcsicmp(pThreshold->m_szPropertyName, L"CollectionErrorCode") &&
					_wcsicmp(pThreshold->m_szPropertyName, L"CollectionErrorDescription"))
				{
					hRetRes = insertNewProperty(pThreshold->m_szPropertyName);
					MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
				}

				//
				// Get Threshold and DataCollector synced up. Plus we may have been in the middle of a
				// collection interval as this came in.
				//
				ResetState(TRUE, TRUE);

				m_thresholdList.push_back(pThreshold);
			}
			else
			{
				delete pThreshold;
			}
		}

		delete [] pszTempGUID;
		pszTempGUID = NULL;
		pObj->Release();
		pObj = NULL;
		SysFreeString(Path);
		Path = NULL;

		return S_OK;
	}

	return WBEM_S_DIFFERENT;

error:
	MY_ASSERT(FALSE);
	if (pszTempGUID)
		delete [] pszTempGUID;
	if (Path)
		SysFreeString(Path);
	if (pObj)
		pObj->Release();
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

LPTSTR CDataCollector::GetGUID(void)
{
	return m_szGUID;
}

BOOL CDataCollector::ResetResetThresholdStates(void)
{
	int i, iSize;
	CThreshold* pThreshold;

	iSize = m_thresholdList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		pThreshold->ResetResetThreshold();
	}

	return TRUE;
}

BOOL CDataCollector::GetChange(void)
{
	if (m_lNumberChanges!=0 && m_lPrevState!=m_lCurrState)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

//
// Called By the Delete method that the HMSystemConfiguration class exposes.
// We search down the hierarchy until we find what we need to delete.
// We are only search down form where we are, as the object above already verified
// that we are not what was being looked for.
//
HRESULT CDataCollector::FindAndDeleteByGUID(LPTSTR pszGUID)
{
	BOOL bDeleted = FALSE;
	int i, iSize;
	CThreshold* pThreshold;
	RLIST::iterator iaR;

	//
	// Traverse the complete hierarchy to find the object to delete.
	//
	iSize = m_thresholdList.size();
	iaR=m_thresholdList.begin();
	for (i=0; i<iSize; i++, iaR++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		if (pThreshold->m_bValidLoad == FALSE)
			return WBEM_E_INVALID_OBJECT;
		if (!_wcsicmp(pszGUID, pThreshold->GetGUID()))
		{
			if (_wcsicmp(pThreshold->m_szPropertyName, L"CollectionInstanceCount") &&
				_wcsicmp(pThreshold->m_szPropertyName, L"CollectionErrorCode") &&
				_wcsicmp(pThreshold->m_szPropertyName, L"CollectionErrorDescription"))
			{
				propertyNotNeeded(pThreshold->m_szPropertyName);
			}
			pThreshold->DeleteThresholdConfig();
			delete pThreshold;
			m_thresholdList.erase(iaR);
			bDeleted = TRUE;
			TCHAR msgbuf[1024];
			wsprintf(msgbuf, L"DELETION: TGUID=%s", pszGUID);
			MY_OUTPUT(msgbuf, 4);
			//
			// Get Threshold and DataCollector synced up. Plus we may have been in the middle of a
			// collection interval as this came in.
			//
			ResetState(TRUE, TRUE);
			break;
		}
	}

	if (bDeleted == FALSE)
	{
		return S_FALSE;
	}
	else
	{
		return S_OK;
	}
}

//
// HMSystemConfiguration class exposes this method.
//
HRESULT CDataCollector::FindAndEnableByGUID(LPTSTR pszGUID, BOOL bEnable)
{
	BOOL bFound = FALSE;
	int i, iSize;
	CThreshold* pThreshold;

	//
	// Traverse the complete hierarchy to find the object to enable/disable.
	//
	iSize = m_thresholdList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		if (!_wcsicmp(pszGUID, pThreshold->GetGUID()))
		{
			bFound = TRUE;
			break;
		}
	}

	if (bFound == FALSE)
	{
		return S_FALSE;
	}
	else
	{
		return S_OK;
	}
}

//
// HMSystemConfiguration class exposes this method.
//
// Get rid of the data that was collected, so we can be clean,
// just as if we just started running.
//
//
HRESULT CDataCollector::ResetState(BOOL bPreserveThresholdStates, BOOL bDoImmediate)
{
	CThreshold* pThreshold;
	PNSTRUCT *ppn = NULL;
	INSTSTRUCT *pinst;
	InstIDSTRUCT *pInstID;
	int i, j;
	int iSize, jSize;
	ACTUALINSTSTRUCT *pActualInst;

	MY_OUTPUT(L"ENTER ***** CDataCollector::ResetState...", 1);

	if (m_bEnabled==FALSE || m_bParentEnabled==FALSE)
	{
		return S_OK;
	}

	CleanupSemiSync();

	m_ulErrorCodePrev = MAX_ULONG;
	m_lIntervalCount = 0;
	if (bDoImmediate)
	{
		m_lIntervalCount = -1;
	}
	else
	{
		m_lIntervalCount = 0;
	}

	m_lCollectionTimeOutCount = 0;
	m_lNumInstancesCollected = 0;
	if (bPreserveThresholdStates == FALSE)
	{
		m_lCurrState = HM_COLLECTING;
	}

	m_bKeepCollectingSemiSync = FALSE;

	iSize = m_pnList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_pnList.size());
		ppn = &m_pnList[i];
		jSize = ppn->instList.size();
		for (j = 0; j < jSize ; j++)
		{
			MY_ASSERT(j<ppn->instList.size());
			pinst = &ppn->instList[j];
			if (pinst->szCurrValue)
			{
				delete [] pinst->szCurrValue;
			}
			if (pinst->szInstanceID)
			{
				delete [] pinst->szInstanceID;
			}
			pinst->valList.clear();
		}
		ppn->instList.clear();
	}

	iSize = m_thresholdList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		pThreshold->ClearInstList();
		if (bPreserveThresholdStates == FALSE)
		{
			pThreshold->SetCurrState(HM_COLLECTING);
		}
	}

	iSize = m_actualInstList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_actualInstList.size());
		pActualInst = &m_actualInstList[i];
		if (pActualInst->szInstanceID)
		{
			delete [] pActualInst->szInstanceID;
		}
		if (pActualInst->pInst)
		{
			pActualInst->pInst->Release();
			pActualInst->pInst = NULL;
		}
	}
	m_actualInstList.clear();


	//
	// Need this for sure with PMDC, does it adversly affect other DataCollectors
	//
	iSize = m_instIDList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_instIDList.size());
		pInstID = &m_instIDList[i];
		delete [] pInstID->szInstanceIDPropertyName;
	}
	m_instIDList.clear();

	MY_OUTPUT(L"EXIT ***** CDataCollector::ResetState...", 1);
	return S_OK;
}

//
// HMSystemConfiguration class exposes this method.
//
HRESULT CDataCollector::ResetStatistics(void)
{
	INSTSTRUCT *pinst;
	PNSTRUCT *ppn;
	int i, j;
	int iSize, jSize;

	MY_OUTPUT(L"ENTER ***** CDataCollector::ResetStatistics...", 1);

	if (m_bEnabled==FALSE || m_bParentEnabled==FALSE)
	{
		return S_OK;
	}

	iSize = m_pnList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_pnList.size());
		ppn = &m_pnList[i];
		jSize = ppn->instList.size();
		for (j = 0; j < jSize ; j++)
		{
			MY_ASSERT(j<ppn->instList.size());
			pinst = &ppn->instList[j];

			if (pinst->szCurrValue)
			{
				delete [] pinst->szCurrValue;
			}
			pinst->szCurrValue = NULL;
			ResetInst(pinst, ppn->type);
			pinst->valList.clear();
		}
	}

	EvaluateNow(TRUE);

	MY_OUTPUT(L"EXIT ***** CDataCollector::ResetStatistics...", 1);
	return S_OK;
}

//
// HMSystemConfiguration class exposes this method.
// Set the increment count back to zero temporarily, so it will
// run at the next second interval, then set back!
//
HRESULT CDataCollector::EvaluateNow(BOOL bDoImmediate)
{

	MY_OUTPUT(L"ENTER ***** CDataCollector::EvaluateNow...", 1);

	if (m_bValidLoad == FALSE)
		return WBEM_E_INVALID_OBJECT;

	EnumDone();

	if (bDoImmediate)
	{
		m_lIntervalCount = -1;
	}
	else
	{
		m_lIntervalCount = 0;
	}

	m_lCollectionTimeOutCount = 0;
	if (m_deType != HM_EQDE)
	{
		m_lNumInstancesCollected = 0;
	}

	MY_OUTPUT(L"EXIT ***** CDataCollector::EvaluateNow...", 1);
	return S_OK;
}

BOOL CDataCollector::SetParentEnabledFlag(BOOL bEnabled)
{
	int i, iSize;
	CThreshold* pThreshold;

	m_bParentEnabled = bEnabled;

	if (m_bEnabled==FALSE || m_bParentEnabled==FALSE)
	{
	}
	else
	{
		m_lIntervalCount = 0;
	}

	//
	// Now traverse children and call for everything below
	//
	iSize = m_thresholdList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		pThreshold->SetParentEnabledFlag(m_bEnabled && m_bParentEnabled);
	}

	return TRUE;
}

BOOL CDataCollector::Init(void)
{

	MY_OUTPUT(L"ENTER ***** CDataCollector::Init...", 1);

	m_lIntervalCount = 0;
	m_lCollectionTimeOutCount = 0;
	m_lNumberNormals = 0;
	m_lNumberWarnings = 0;
	m_lNumberCriticals = 0;
	m_lNumberChanges = 0;
	m_lNumInstancesCollected = 0;
	m_lCurrState = HM_COLLECTING;
	m_lPrevState = HM_COLLECTING;
	m_ulErrorCode = 0;
	m_ulErrorCodePrev = MAX_ULONG;
	m_lCollectionTimeOut = 0;
	m_szGUID = NULL;
	m_szParentObjPath = NULL;
	m_pParentDG = NULL;
	m_szName = NULL;
	m_szDescription = NULL;
	m_szUserName = NULL;
	m_szPassword = NULL;
	m_szTargetNamespace = NULL;
	m_szLocal = NULL;
	m_szTypeGUID = NULL;
	m_pContext = NULL;
	m_pCallResult = NULL;
	m_bKeepCollectingSemiSync = FALSE;
	m_bEnabled = TRUE;
	m_bParentEnabled = TRUE;
	m_pIWbemServices = NULL;
	m_lCollectionIntervalMultiple = 60;
	m_lStatisticsWindowSize = 6;
	m_iActiveDays = 0;
	m_lBeginHourTime = 0;
	m_lBeginMinuteTime = 0;
	m_lEndHourTime = 0;
	m_lEndMinuteTime = 0;
	m_lTypeGUID = 0;
	m_bRequireReset = FALSE;
	m_bReplicate = FALSE;
	m_lId = 0;
	m_szErrorDescription[0] = '\0';
	m_szMessage = NULL;
	m_szResetMessage = NULL;
	m_lPrevChildCount = 0;

	// yyyymmddhhmmss.ssssssXUtc; X = GMT(+ or -), Utc = 3 dig. offset from UTC.")]
	wcscpy(m_szTime, m_szCurrTime);
	wcscpy(m_szCollectTime, m_szCurrTime);
	wcscpy(m_szCICTime, m_szCurrTime);
	wcscpy(m_szCECTime, m_szCurrTime);

	wcscpy(m_szDTTime, m_szDTCurrTime);
	wcscpy(m_szDTCollectTime, m_szDTCurrTime);
	wcscpy(m_szDTCICTime, m_szDTCurrTime);
	wcscpy(m_szDTCECTime, m_szDTCurrTime);

	MY_OUTPUT(L"EXIT ***** CDataCollector::Init...", 1);
	return TRUE;
}

BOOL CDataCollector::Cleanup(BOOL bSavePrevSettings)
{
	PNSTRUCT *ppn;
	INSTSTRUCT *pinst;
	int i, iSize;
	int j, jSize;
	CThreshold* pThreshold;
	InstIDSTRUCT *pInstID;
	ACTUALINSTSTRUCT *pActualInst;
	IWbemClassObject* pInstance = NULL;

	MY_OUTPUT(L"ENTER ***** CDataCollector::Cleanup...", 1);

	if (bSavePrevSettings == FALSE)
	{
//		if (m_szParentObjPath)
//		{
//			delete [] m_szParentObjPath;
//			m_szParentObjPath = NULL;
//		}
	}

	if (m_szName)
	{
		delete [] m_szName;
		m_szName = NULL;
	}
	if (m_szDescription)
	{
		delete [] m_szDescription;
		m_szDescription = NULL;
	}
	if (m_szMessage)
	{
		delete [] m_szMessage;
		m_szMessage = NULL;
	}
	if (m_szResetMessage)
	{
		delete [] m_szResetMessage;
		m_szResetMessage = NULL;
	}
	if (m_szUserName)
	{
		delete [] m_szUserName;
		m_szUserName = NULL;
	}
	if (m_szPassword)
	{
		delete [] m_szPassword;
		m_szPassword = NULL;
	}
	if (m_szTargetNamespace)
	{
		delete [] m_szTargetNamespace;
		m_szTargetNamespace = NULL;
	}
	if (m_szLocal)
	{
		delete [] m_szLocal;
		m_szLocal = NULL;
	}
	iSize = m_instIDList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_instIDList.size());
		pInstID = &m_instIDList[i];
		delete [] pInstID->szInstanceIDPropertyName;
	}
	m_instIDList.clear();
	if (m_szTypeGUID)
	{
		delete [] m_szTypeGUID;
		m_szTypeGUID = NULL;
	}

	if (m_pContext != NULL)
	{
		m_pContext->Release();
		m_pContext = NULL;
	}

	if (m_pCallResult != NULL)
	{
		m_pCallResult->Release();
		m_pCallResult = NULL;
	}

	if (bSavePrevSettings)
	{
		ResetState(TRUE, TRUE);

		//
		// Need to also get rid of the Property names,
		// As ResetState does not do that.
		//
		iSize = m_pnList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<m_pnList.size());
			ppn = &m_pnList[i];
			if (ppn->szPropertyName)
			{
				delete [] ppn->szPropertyName;
			}
		}
		m_pnList.clear();
	}
	else
	{
		iSize = m_pnList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<m_pnList.size());
			ppn = &m_pnList[i];
			if (ppn->szPropertyName)
			{
				delete [] ppn->szPropertyName;
			}

			jSize = ppn->instList.size();
			for (j = 0; j < jSize ; j++)
			{
				MY_ASSERT(j<ppn->instList.size());
				pinst = &ppn->instList[j];
				if (pinst->szCurrValue)
				{
					delete [] pinst->szCurrValue;
				}
				if (pinst->szInstanceID)
				{
					delete [] pinst->szInstanceID;
				}
				pinst->valList.clear();
			}
			ppn->instList.clear();
		}
		m_pnList.clear();
	
		//
		// Clean up everything under this DataCollector
		//
		if (m_bValidLoad == TRUE)
		{
			iSize = m_thresholdList.size();
			for (i = 0; i < iSize ; i++)
			{
				MY_ASSERT(i<m_thresholdList.size());
				pThreshold = m_thresholdList[i];
				delete pThreshold;
			}
			m_thresholdList.clear();
		}

		iSize = m_actualInstList.size();
		for (i=0; i < iSize; i++)
		{
			MY_ASSERT(i<m_actualInstList.size());
			pActualInst = &m_actualInstList[i];
			if (pActualInst->szInstanceID)
			{
				delete [] pActualInst->szInstanceID;
			}
			if (pActualInst->pInst)
			{
				pActualInst->pInst->Release();
				pActualInst->pInst = NULL;
			}
		}
		m_actualInstList.clear();
	}

	if (m_bValidLoad == FALSE)
	{
		EnumDone();
		if (GetHMDataCollectorStatusInstance(&pInstance, TRUE) == S_OK)
		{
			mg_DCEventList.push_back(pInstance);
		}
	}

	MY_OUTPUT(L"EXIT ***** CDataCollector::Cleanup...", 1);
	return TRUE;
}

#ifdef SAVE
//
// For when moving from one parent to another
//
BOOL CDataCollector::ModifyAssocForMove(CBase *pNewParentBase)
{
	HRESULT hRes;
	TCHAR szTemp[1024];
	TCHAR szNewTemp[1024];
	BSTR instName;
	IWbemContext *pCtx = 0;
	IWbemCallResult *pResult = 0;
	IWbemClassObject* pObj = NULL;
	IWbemClassObject* pNewObj = NULL;

	MY_OUTPUT(L"ENTER ***** CDataGroup::ModifyAssocForMove...", 4);
	MY_OUTPUT2(L"m_szGUID=%s", m_szGUID, 4);

	//
	// Figure out the new parent path
	//
	if (pNewParentBase->m_hmStatusType == HMSTATUS_DATAGROUP)
	{
		wcscpy(szNewTemp, L"\\\\.\\root\\cimv2\\MicrosoftHealthMonitor:MicrosoftHM_DataGroupConfiguration.GUID=\"");
	}
	else
	{
		MY_ASSERT(FALSE);
	}
	lstrcat(szNewTemp, pNewParentBase->m_szGUID);
	lstrcat(szNewTemp, L"\"");

	//
	// Delete the association from my parent to me.
	//
	if (m_deType == HM_PGDE)
	{
		wcscpy(szTemp, L"\\\\.\\root\\cimv2\\MicrosoftHealthMonitor:MicrosoftHM_PolledGetObjectDataCollectorConfiguration.GUID=\"");
	}
	else if (m_deType == HM_PMDE)
	{
		wcscpy(szTemp, L"\\\\.\\root\\cimv2\\MicrosoftHealthMonitor:MicrosoftHM_PolledMethodDataCollectorConfiguration.GUID=\"");
	}
	else if (m_deType == HM_PQDE)
	{
		wcscpy(szTemp, L"\\\\.\\root\\cimv2\\MicrosoftHealthMonitor:MicrosoftHM_PolledQueryDataCollectorConfiguration.GUID=\"");
	}
	else if (m_deType == HM_EQDE)
	{
		wcscpy(szTemp, L"\\\\.\\root\\cimv2\\MicrosoftHealthMonitor:MicrosoftHealthMonitor:MicrosoftHM_EventQueryDataCollectorConfiguration.GUID=\\\"");
	}
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"");

	instName = SysAllocString(L"MicrosoftHM_ConfigurationAssociation");
	if ((hRes = g_pIWbemServices->GetObject(instName, 0L, NULL, &pObj, NULL)) != S_OK)
	{
	}
	SysFreeString(instName);

	if (pObj)
	{
		hRes = pObj->SpawnInstance(0, &pNewObj);
		pObj->Release();
		PutStrProperty(pNewObj, L"ChildPath", szTemp);
		PutStrProperty(pNewObj, L"ParentPath", szNewTemp);
		hRes = g_pIWbemServices->PutInstance(pNewObj, 0, NULL, &pResult);
		pNewObj->Release();
		pNewObj = NULL;
	}

	DeleteDEConfig(TRUE);

	if (pNewParentBase->m_hmStatusType == HMSTATUS_DATAGROUP)
	{
		wcscpy(szNewTemp, L"MicrosoftHM_DataGroupConfiguration.GUID=\\\"");
		lstrcat(szNewTemp, pNewParentBase->m_szGUID);
		lstrcat(szNewTemp, L"\\\"");
	}
	else
	{
		MY_ASSERT(FALSE);
	}
	if (m_szParentObjPath)
	{
		delete [] m_szParentObjPath;
	}
	m_szParentObjPath = new TCHAR[wcslen(szNewTemp)+1];
	wcscpy(m_szParentObjPath, szNewTemp);

	m_pParentDG = (CDataGroup *) pNewParentBase;

	MY_OUTPUT(L"EXIT ***** CDataGroup::ModifyAssocForMove...", 4);
	return TRUE;
}
#endif

BOOL CDataCollector::ReceiveNewChildForMove(CBase *pBase)
{
//XXX seems to be some code missing here,
//did we clean up from the old place things like m_pnList, and add to the new one if it is a
//new property.
// Like what we do in -> CDataCollector::AddThreshold()
	MY_ASSERT(FALSE);
	MY_ASSERT(pBase->m_hmStatusType == HMSTATUS_DATACOLLECTOR);

	m_thresholdList.push_back((CThreshold *)pBase);
//	(CThreshold *)pBase->SetParentEnabledFlag(m_bEnabled);

	if (_wcsicmp(((CThreshold *)pBase)->m_szPropertyName, L"CollectionInstanceCount") &&
		_wcsicmp(((CThreshold *)pBase)->m_szPropertyName, L"CollectionErrorCode") &&
		_wcsicmp(((CThreshold *)pBase)->m_szPropertyName, L"CollectionErrorDescription"))
	{
		insertNewProperty(((CThreshold *)pBase)->m_szPropertyName);
//		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}

	//
	// Get Threshold and DataCollector synced up. Plus we may have been in the middle of a
	// collection interval as this came in.
	//
	ResetState(TRUE, TRUE);

	return TRUE;
}

BOOL CDataCollector::DeleteChildFromList(LPTSTR pszGUID)
{
	int i, iSize;
	CThreshold* pThreshold;
	RLIST::iterator iaR;
	BOOL bFound = FALSE;

	iSize = m_thresholdList.size();
	iaR=m_thresholdList.begin();
	for (i=0; i<iSize; i++, iaR++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		if (pThreshold->m_bValidLoad == FALSE)
			return FALSE;
		if (!_wcsicmp(pszGUID, pThreshold->GetGUID()))
		{
			if (_wcsicmp(pThreshold->m_szPropertyName, L"CollectionInstanceCount") &&
				_wcsicmp(pThreshold->m_szPropertyName, L"CollectionErrorCode") &&
				_wcsicmp(pThreshold->m_szPropertyName, L"CollectionErrorDescription"))
			{
				propertyNotNeeded(pThreshold->m_szPropertyName);
			}
			m_thresholdList.erase(iaR);
			bFound = TRUE;
			break;
		}
	}

	return bFound;
}

BOOL CDataCollector::DeleteDEConfig(BOOL bDeleteAssocOnly)
{
	int i, iSize;
	CThreshold* pThreshold;
	HRESULT hRetRes = S_OK;
	TCHAR szTemp[1024];
	BSTR instName = NULL;

	MY_OUTPUT(L"ENTER ***** CDataCollector::DeleteDEConfig...", 4);
	MY_OUTPUT2(L"m_szGUID=%s", m_szGUID, 4);

	//
	// Delete the association from my parent to me.
	//
	if (m_deType == HM_PGDE)
	{
		wcscpy(szTemp, L"MicrosoftHM_ConfigurationAssociation.ChildPath=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:MicrosoftHM_PolledGetObjectDataCollectorConfiguration.GUID=\\\"");
	}
	else if (m_deType == HM_PMDE)
	{
		wcscpy(szTemp, L"MicrosoftHM_ConfigurationAssociation.ChildPath=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:MicrosoftHM_PolledMethodDataCollectorConfiguration.GUID=\\\"");
	}
	else if (m_deType == HM_PQDE)
	{
		wcscpy(szTemp, L"MicrosoftHM_ConfigurationAssociation.ChildPath=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:MicrosoftHM_PolledQueryDataCollectorConfiguration.GUID=\\\"");
	}
	else if (m_deType == HM_EQDE)
	{
		wcscpy(szTemp, L"MicrosoftHM_ConfigurationAssociation.ChildPath=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:MicrosoftHM_EventQueryDataCollectorConfiguration.GUID=\\\"");
	}
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\\\"\",ParentPath=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:");
	lstrcat(szTemp, m_szParentObjPath);
	lstrcat(szTemp, L"\"");
	instName = SysAllocString(szTemp);
	MY_ASSERT(instName); if (!instName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	if ((hRetRes = g_pIWbemServices->DeleteInstance(instName, 0L,	NULL, NULL)) != S_OK)
	{
		SysFreeString(instName);
		instName = NULL;
		wcscpy(szTemp, L"MicrosoftHM_ConfigurationAssociation.ChildPath=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:MicrosoftHM_DataCollectorConfiguration.GUID=\\\"");
		lstrcat(szTemp, m_szGUID);
		lstrcat(szTemp, L"\\\"\",ParentPath=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:");
		lstrcat(szTemp, m_szParentObjPath);
		lstrcat(szTemp, L"\"");
		instName = SysAllocString(szTemp);
		MY_ASSERT(instName); if (!instName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		if ((hRetRes = g_pIWbemServices->DeleteInstance(instName, 0L,	NULL, NULL)) != S_OK)
		{
//			MY_HRESASSERT(hRes);
		}
	}
	SysFreeString(instName);
	instName = NULL;

	if (bDeleteAssocOnly)
	{
		return TRUE;
	}

	//
	// Delete our exact instance
	//
	wcscpy(szTemp, L"MicrosoftHM_DataCollectorConfiguration.GUID=\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"");
	instName = SysAllocString(szTemp);
	MY_ASSERT(instName); if (!instName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	if ((hRetRes = g_pIWbemServices->DeleteInstance(instName, 0L,	NULL, NULL)) != S_OK)
	{
//		MY_HRESASSERT(hRes);
	}
	SysFreeString(instName);
	instName = NULL;

	//
	// Traverse the complete hierarchy and delete
	//
	iSize = m_thresholdList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		pThreshold->DeleteThresholdConfig();
		delete pThreshold;
	}
	m_thresholdList.clear();

	//
	// Get rid of any associations to actions for this
	//
	g_pSystem->DeleteAllConfigActionAssoc(m_szGUID);

	MY_OUTPUT(L"EXIT ***** CDataCollector::DeleteDEConfig...", 4);
	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (instName)
		SysFreeString(instName);
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return FALSE;
}

BOOL CDataCollector::DeleteDEInternal(void)
{
	int i, iSize;
	CThreshold* pThreshold;

	MY_OUTPUT(L"ENTER ***** CDataCollector::DeleteDEInternal...", 4);


	//
	// Traverse the complete hierarchy and delete
	//
	iSize = m_thresholdList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		delete pThreshold;
	}
	m_thresholdList.clear();

	//
	// Get rid of any associations to actions for this
	//
//	g_pSystem->DeleteAllConfigActionAssoc(m_szGUID);

	MY_OUTPUT(L"EXIT ***** CDataCollector::DeleteDEInternal...", 4);
	return TRUE;
}

HRESULT CDataCollector::FindAndCopyByGUID(LPTSTR pszGUID, ILIST* pConfigList, LPTSTR *pszOriginalParentGUID)
{
	int i, iSize;
	CThreshold* pThreshold;
	HRESULT hRetRes = S_OK;

	//
	// Find what to copy
	//
	iSize = m_thresholdList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		if (!_wcsicmp(pszGUID, pThreshold->GetGUID()))
		{
			hRetRes = pThreshold->Copy(pConfigList, NULL, NULL);
			*pszOriginalParentGUID = m_szGUID;
			return hRetRes;
		}
	}

	return WBEM_S_DIFFERENT;
}

HRESULT CDataCollector::Copy(ILIST* pConfigList, LPTSTR pszOldParentGUID, LPTSTR pszNewParentGUID)
{
	GUID guid;
	TCHAR szTemp[1024];
	TCHAR szNewGUID[1024];
	IWbemClassObject* pInst = NULL;
	IWbemClassObject* pInstCopy = NULL;
	IWbemClassObject* pInstAssocCopy = NULL;
	IWbemClassObject* pObj = NULL;
	int i, iSize;
	CThreshold* pThreshold;
	BSTR Language = NULL;
	BSTR Query = NULL;
	IEnumWbemClassObject *pEnum;
	ULONG uReturned;
	IWbemContext *pCtx = 0;
	LPTSTR pszParentPath = NULL;
	LPTSTR pszChildPath = NULL;
	LPTSTR pStr;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** CDataCollector::Copy...", 1);

	if (m_bValidLoad == FALSE)
		return WBEM_E_INVALID_OBJECT;

	//
	// Get the origional starting point HMConfiguration instance.
	//
	wcscpy(szTemp, L"MicrosoftHM_Configuration.GUID=\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"");
	hRetRes = GetWbemObjectInst(&g_pIWbemServices, szTemp, NULL, &pInst);
	if (!pInst)
	{
		return hRetRes;
	}

	//
	// Clone the instance, and change the GUID
	//
	hRetRes = pInst->Clone(&pInstCopy);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	hRetRes = CoCreateGuid(&guid);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	StringFromGUID2(guid, szNewGUID, 100);
	hRetRes = PutStrProperty(pInstCopy, L"GUID", szNewGUID);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	pConfigList->push_back(pInstCopy);

	//
	// Add instance of HMConfigurationAssociation where we are the child,
	// using the parent GUID passed in.
	// Change the GUIDs of both the Parent and Child.
	// also make sure that the machine name is not in the path, and is relative!
	//
	if (pszOldParentGUID != NULL)
	{
		Language = SysAllocString(L"WQL");
		MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		wcscpy(szTemp, L"REFERENCES OF {MicrosoftHM_Configuration.GUID=\"");
		lstrcat(szTemp, m_szGUID);
		lstrcat(szTemp, L"\"} WHERE ResultClass=MicrosoftHM_ConfigurationAssociation Role=ChildPath");
		Query = SysAllocString(szTemp);
		MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

		// Initialize IEnumWbemClassObject pointer
		pEnum = 0;

		// Issue query
   		hRetRes = g_pIWbemServices->ExecQuery(Language, Query, WBEM_FLAG_FORWARD_ONLY, 0, &pEnum);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		SysFreeString(Query);
		Query = NULL;
		SysFreeString(Language);
		Language = NULL;

		// Retrieve object in result set
		pObj = NULL;
		uReturned = 0;

		hRetRes = pEnum->Next(0, 1, &pObj, &uReturned);
	
		if (uReturned == 0)
		{
			hRetRes = WBEM_E_INVALID_OBJECT_PATH; goto error;
		}
	
		//
		// Change the GUIDs
		//
		hRetRes = GetStrProperty(pObj, L"ParentPath", &pszParentPath);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		hRetRes = GetStrProperty(pObj, L"ChildPath", &pszChildPath);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		pStr = wcschr(pszParentPath, '\"');
		if (pStr)
		{
			pStr++;
			wcsncpy(pStr, pszNewParentGUID, wcslen(pszNewParentGUID));
		}
		else
		{
			hRetRes = WBEM_E_INVALID_OBJECT_PATH; goto error;
		}

		pStr = wcschr(pszChildPath, '\"');
		if (pStr)
		{
			pStr++;
			wcsncpy(pStr, szNewGUID, wcslen(szNewGUID));
		}
		else
		{
			hRetRes = WBEM_E_INVALID_OBJECT_PATH; goto error;
		}

		hRetRes = pObj->Clone(&pInstAssocCopy);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = PutStrProperty(pInstAssocCopy, L"ParentPath", pszParentPath);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = PutStrProperty(pInstAssocCopy, L"ChildPath", pszChildPath);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		pConfigList->push_back(pInstAssocCopy);


		// Release it.
		pObj->Release();
		pObj = NULL;
		pEnum->Release();
		pEnum = NULL;
		delete [] pszParentPath;
		pszParentPath = NULL;
		delete [] pszChildPath;
		pszChildPath = NULL;
	}

	//
	// Add in all children
	//
	iSize = m_thresholdList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		hRetRes = pThreshold->Copy(pConfigList, m_szGUID, szNewGUID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}

	pInst->Release();
	pInst = NULL;

	MY_OUTPUT(L"EXIT ***** CDataCollector::Copy...", 1);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	if (pInst)
		pInst->Release();
	if (pObj)
		pObj->Release();
	if (pEnum)
		pEnum->Release();
	if (Query)
		SysFreeString(Query);
	if (Language)
		SysFreeString(Language);
	if (pszParentPath)
		delete [] pszParentPath;
	if (pszChildPath)
		delete [] pszChildPath;
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

CBase *CDataCollector::GetParentPointerFromGUID(LPTSTR pszGUID)
{
	int i, iSize;
	CThreshold* pThreshold;
	BOOL bFound = FALSE;
	CBase *pBase;

	iSize = m_thresholdList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		if (!_wcsicmp(pszGUID, pThreshold->GetGUID()))
		{
			pBase = pThreshold;
			bFound = TRUE;
			break;
		}
	}

	if (bFound == TRUE)
	{
		return pBase;
	}
	else
	{
		return NULL;
	}
}

CBase *CDataCollector::FindImediateChildByName(LPTSTR pszName)
{
	int i, iSize;
	CThreshold* pThreshold;
	BOOL bFound = FALSE;
	CBase *pBase;

	iSize = m_thresholdList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		if (pThreshold->m_bValidLoad == FALSE)
			return NULL;
		if (!_wcsicmp(pszName, pThreshold->m_szName))
		{
			pBase = pThreshold;
			bFound = TRUE;
			break;
		}
	}

	if (bFound == TRUE)
	{
		return pBase;
	}
	else
	{
		return NULL;
	}
}

BOOL CDataCollector::GetNextChildName(LPTSTR pszChildName, LPTSTR pszOutName)
{
	TCHAR szTemp[1024];
	TCHAR szIndex[1024];
	int i, iSize;
	BOOL bFound;
	CThreshold* pThreshold;
	int index;

	// We are here because we know that one exists already with the same name.
	// So, lets start off trying to guess what the next name should be and get one.
	index = 0;
	bFound = TRUE;
	while (bFound == TRUE)
	{
		wcscpy(szTemp, pszChildName);
		_itow(index, szIndex, 10);
		lstrcat(szTemp, L" ");
		lstrcat(szTemp, szIndex);

		bFound = FALSE;
		iSize = m_thresholdList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_thresholdList.size());
			pThreshold = m_thresholdList[i];
			if (pThreshold->m_bValidLoad == FALSE)
				break;
			if (!_wcsicmp(szTemp, pThreshold->m_szName))
			{
				bFound = TRUE;
				break;
			}
		}
		index++;
	}
	wcscpy(pszOutName, szTemp);

	return TRUE;
}

CBase *CDataCollector::FindPointerFromName(LPTSTR pszName)
{
	int i, iSize;
	CThreshold* pThreshold;
	BOOL bFound = FALSE;
	CBase *pBase;

	iSize = m_thresholdList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		if (!_wcsicmp(pszName, pThreshold->GetGUID()))
		{
			pBase = pThreshold;
			bFound = TRUE;
			break;
		}
	}

	if (bFound == TRUE)
	{
		return pBase;
	}
	else
	{
		return NULL;
	}
}

HRESULT CDataCollector::GetInstanceID(IWbemClassObject* pObj, LPTSTR *pszID)
{
	HRESULT hRetRes = NULL;
	TCHAR szTemp[1024];
	LPTSTR pszTemp = NULL;
	InstIDSTRUCT InstID;
	SAFEARRAY *psaNames = NULL;
	BSTR PropName = NULL;
	long lLower, lUpper; 
	int i, iSize;
	InstIDSTRUCT *pInstID;

	if (m_bValidLoad == FALSE)
		return FALSE;

	iSize = m_instIDList.size();
	if (iSize == 0)
	{
		hRetRes = pObj->GetNames(NULL, WBEM_FLAG_KEYS_ONLY | WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames);
		if (SUCCEEDED(hRetRes))
		{
			// Get the number of properties.
			hRetRes = SafeArrayGetLBound(psaNames, 1, &lLower);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			hRetRes = SafeArrayGetUBound(psaNames, 1, &lUpper);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

			if ((lUpper - lLower + 1) == 0)
			{
				InstID.szInstanceIDPropertyName = new TCHAR[3];
				MY_ASSERT(InstID.szInstanceIDPropertyName); if (!InstID.szInstanceIDPropertyName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				wcscpy(InstID.szInstanceIDPropertyName , L"@");
				m_instIDList.push_back(InstID);
			}
			else
			{
				// For each property...
				for (long k=lLower; k<=lUpper; k++) 
				{
					// Get this property.
					hRetRes = SafeArrayGetElement(psaNames, &k, &PropName);
					MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
					if (SUCCEEDED(hRetRes))
					{
						InstID.szInstanceIDPropertyName = new TCHAR[wcslen(PropName)+2];
						MY_ASSERT(InstID.szInstanceIDPropertyName); if (!InstID.szInstanceIDPropertyName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
						wcscpy(InstID.szInstanceIDPropertyName , PropName);
						SysFreeString(PropName);
						PropName = NULL;
						m_instIDList.push_back(InstID);
					}
				}
			}
			SafeArrayDestroy(psaNames);
			psaNames = NULL;
		}
	}

	MY_ASSERT(m_instIDList.size());

	//
	// Add it as a new instance if necessary
	// All PropertyNames have the same list of instances.
	// Just look at the first PropertyName, and search through
	// its list of instances.
	//
	MY_ASSERT(m_instIDList.size());
	pInstID = &m_instIDList[0];
	if (!wcscmp(pInstID->szInstanceIDPropertyName, L"@"))
	{
		*pszID = new TCHAR[3];
		MY_ASSERT(pszID); if (!pszID) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		wcscpy(*pszID , L"@");
	}
	else
	{
		szTemp[0] = '\0';
		iSize = m_instIDList.size();
		for (i=0; i < iSize; i++)
		{
			if (i != 0)
				wcscat(szTemp, L";");
			MY_ASSERT(i<m_instIDList.size());
			pInstID = &m_instIDList[i];
			hRetRes = GetAsStrProperty(pObj, pInstID->szInstanceIDPropertyName, &pszTemp);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			wcscat(szTemp, pszTemp);
			delete [] pszTemp;
			pszTemp = NULL;
		}
		*pszID = new TCHAR[wcslen(szTemp)+2];
		MY_ASSERT(pszID); if (!pszID) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		wcscpy(*pszID , szTemp);
	}

	return hRetRes;

error:
	MY_ASSERT(FALSE);
	if (PropName)
		SysFreeString(PropName);
	if (pszTemp)
		delete [] pszTemp;
	if (psaNames)
		SafeArrayDestroy(psaNames);
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

//
// Adds new instances that have not been seen before, and makes ones seen alread as
// needed again. If pObj is NULL, that means it is one of the special Agent provided
// properties - CollectionInstanceCount, CollectionErrorCode or CollectionErrorDescription.
//
HRESULT CDataCollector::CheckInstanceExistance(IWbemClassObject *pObj, LPTSTR pszInstanceID)
{
	HRESULT hRetRes = S_OK;
	BOOL bFound;
	PNSTRUCT *ppn;
	INSTSTRUCT *pinst;
	int i, j, iSize, jSize;
	int foundInstID;
	CThreshold *pThreshold;
	IRSSTRUCT *pirs;
	INSTSTRUCT inst;
	LPTSTR pszPropertyName;
//	BOOL bRetValue;

	if (m_bValidLoad == FALSE)
		return FALSE;

	// Just need to look at the instance list of the first property to tell if the
	// instance has been seen yet.
	if (pObj)
	{
		bFound = FALSE;
		iSize = m_pnList.size();
		if (4 <= iSize)
		{
			i = 0;
			MY_ASSERT(i<m_pnList.size());
			ppn = &m_pnList[i];
			jSize = ppn->instList.size();
			for (j=0; j < jSize ; j++)
			{
				MY_ASSERT(j<ppn->instList.size());
				pinst = &ppn->instList[j];
				if (!_wcsicmp(pinst->szInstanceID, pszInstanceID))
				{
					bFound = TRUE;
					foundInstID = j;
					break;
				}
			}
		}
	}
	else
	{
		bFound = FALSE;
		iSize = m_pnList.size();
		if (3 <= iSize)
		{
			if (!_wcsicmp(pszInstanceID, L"CollectionInstanceCount"))
			{
				i = iSize-3;
			}
			else if (!_wcsicmp(pszInstanceID, L"CollectionErrorCode"))
			{
				i = iSize-2;
			}
			else if (!_wcsicmp(pszInstanceID, L"CollectionErrorDescription"))
			{
				i = iSize-1;
			}
			else
			{
				MY_ASSERT(FALSE);
				i = iSize-3;
			}
			MY_ASSERT(i<m_pnList.size());
			ppn = &m_pnList[i];
			jSize = ppn->instList.size();
			for (j=0; j < jSize ; j++)
			{
				MY_ASSERT(j<ppn->instList.size());
				pinst = &ppn->instList[j];
				if (!_wcsicmp(pinst->szInstanceID, pszInstanceID))
				{
					bFound = TRUE;
					foundInstID = j;
					break;
				}
			}
		}
	}

	if (bFound == FALSE)
	{
		// Add an instance to each property name.
		// Only add the CollectionInstanceCount instance to the CollectionInstanceCount property.
		// and the CollectionErrorCode instance to the CollectionErrorCode property.
		// and the CollectionErrorDescription instance to the CollectionErrorDescription property.
		iSize = m_pnList.size();
		if (pObj)
		{
			for (i=0; i < iSize-3; i++)
			{
				MY_ASSERT(i<m_pnList.size());
				ppn = &m_pnList[i];
				inst.szInstanceID = new TCHAR[wcslen(pszInstanceID)+2];
				MY_ASSERT(inst.szInstanceID); if (!inst.szInstanceID) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				wcscpy(inst.szInstanceID, pszInstanceID);
				inst.szCurrValue = NULL;
				ResetInst(&inst, ppn->type);
				inst.bNull = FALSE;
				inst.bNeeded = TRUE;
				ppn->instList.push_back(inst);
			}

			// Also add instance for all thresholds under this DataCollector
			// Only add the CollectionInstanceCount instance to the Threshold looking at
			// the CollectionInstanceCount property. Same for CollectionErrorCode and CollectionErrorDescription.
			iSize = m_thresholdList.size();
			for (i=0; i < iSize; i++)
			{
				MY_ASSERT(i<m_thresholdList.size());
				pThreshold = m_thresholdList[i];
				pszPropertyName = pThreshold->GetPropertyName();
				if (_wcsicmp(pszPropertyName, L"CollectionInstanceCount") &&
					_wcsicmp(pszPropertyName, L"CollectionErrorCode") &&
					_wcsicmp(pszPropertyName, L"CollectionErrorDescription"))
				{
					hRetRes = pThreshold->AddInstance(pszInstanceID);
					MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
				}
			}
		}
		else
		{
			if (!_wcsicmp(pszInstanceID, L"CollectionInstanceCount"))
			{
				i = iSize-3;
			}
			else if (!_wcsicmp(pszInstanceID, L"CollectionErrorCode"))
			{
				i = iSize-2;
			}
			else if (!_wcsicmp(pszInstanceID, L"CollectionErrorDescription"))
			{
				i = iSize-1;
			}
			else
			{
				MY_ASSERT(FALSE);
				i = iSize-3;
			}

			MY_ASSERT(i<m_pnList.size());
			ppn = &m_pnList[i];
			inst.szInstanceID = new TCHAR[wcslen(pszInstanceID)+2];
			MY_ASSERT(inst.szInstanceID); if (!inst.szInstanceID) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			wcscpy(inst.szInstanceID, pszInstanceID);
			inst.szCurrValue = NULL;
			ResetInst(&inst, ppn->type);
			inst.bNull = FALSE;
			inst.bNeeded = TRUE;
			ppn->instList.push_back(inst);

			// Also add instance for all thresholds under this DataCollector
			// Only add the CollectionInstanceCount instance to the Threshold looking at
			// the CollectionInstanceCount property. Same for CollectionErrorCode and CollectionErrorDescription.
			iSize = m_thresholdList.size();
			for (i=0; i < iSize; i++)
			{
				MY_ASSERT(i<m_thresholdList.size());
				pThreshold = m_thresholdList[i];
				pszPropertyName = pThreshold->GetPropertyName();
				if (!_wcsicmp(pszPropertyName, pszInstanceID) ||
					!_wcsicmp(pszPropertyName, pszInstanceID) ||
					!_wcsicmp(pszPropertyName, pszInstanceID))
				{
					hRetRes = pThreshold->AddInstance(pszInstanceID);
					MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
				}
			}
		}
	}
	else
	{
		iSize = m_pnList.size();
		if (pObj)
		{
			for (i=0; i < iSize-3 ; i++)
			{
				MY_ASSERT(i<m_pnList.size());
				ppn = &m_pnList[i];
				MY_ASSERT(foundInstID<ppn->instList.size());
				pinst = &ppn->instList[foundInstID];
				pinst->bNull = FALSE;
				pinst->bNeeded = TRUE;
			}

			//Also for all thresholds under this DataCollector
			iSize = m_thresholdList.size();
			for (i=0; i < iSize ; i++)
			{
				MY_ASSERT(i<m_thresholdList.size());
				pThreshold = m_thresholdList[i];
				pszPropertyName = pThreshold->GetPropertyName();
				if (_wcsicmp(pszPropertyName, L"CollectionInstanceCount") &&
					_wcsicmp(pszPropertyName, L"CollectionErrorCode") &&
					_wcsicmp(pszPropertyName, L"CollectionErrorDescription"))
				{
					MY_ASSERT(foundInstID<pThreshold->m_irsList.size());
					pirs = &pThreshold->m_irsList[foundInstID];
					pirs->bNeeded = TRUE;
				}
			}
		}
		else
		{
			if (!_wcsicmp(pszInstanceID, L"CollectionInstanceCount"))
			{
				i = iSize-3;
			}
			else if (!_wcsicmp(pszInstanceID, L"CollectionErrorCode"))
			{
				i = iSize-2;
			}
			else if (!_wcsicmp(pszInstanceID, L"CollectionErrorDescription"))
			{
				i = iSize-1;
			}
			else
			{
				MY_ASSERT(FALSE);
				i = iSize-3;
			}

			MY_ASSERT(i<m_pnList.size());
			ppn = &m_pnList[i];
			MY_ASSERT(foundInstID<ppn->instList.size());
			pinst = &ppn->instList[foundInstID];
			pinst->bNull = FALSE;
			pinst->bNeeded = TRUE;

			// Also for all thresholds under this DataCollector
			// Only add the CollectionInstanceCount instance to the Threshold looking at
			// the CollectionInstanceCount property. Same for CollectionErrorCode and CollectionErrorDescription.
			iSize = m_thresholdList.size();
			for (i=0; i < iSize ; i++)
			{
				MY_ASSERT(i<m_thresholdList.size());
				pThreshold = m_thresholdList[i];
				pszPropertyName = pThreshold->GetPropertyName();
				if (!_wcsicmp(pszPropertyName, pszInstanceID) ||
					!_wcsicmp(pszPropertyName, pszInstanceID) ||
					!_wcsicmp(pszPropertyName, pszInstanceID))
				{
					MY_ASSERT(foundInstID<pThreshold->m_irsList.size());
					pirs = &pThreshold->m_irsList[foundInstID];
					pirs->bNeeded = TRUE;
				}
			}
		}
	}

	if (pObj)
	{
		hRetRes = CheckActualInstanceExistance(pObj, pszInstanceID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}

	return hRetRes;

error:
	MY_ASSERT(FALSE);
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

HRESULT CDataCollector::CheckActualInstanceExistance(IWbemClassObject *pObj, LPTSTR pszInstanceID)
{
	HRESULT hRetRes = S_OK;
	BOOL bFound;
	int i, iSize;
	INSTSTRUCT inst;
	ACTUALINSTSTRUCT actualInst;
	ACTUALINSTSTRUCT *pActualInst;

	if (m_bValidLoad == FALSE)
		return FALSE;

	//
	// Check the list of actual instances that the Data Collector is collecting.
	// We keep around the latest one(s) for the DataCollector.
	//
	bFound = FALSE;
	iSize = m_actualInstList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_actualInstList.size());
		pActualInst = &m_actualInstList[i];
		if (!_wcsicmp(pActualInst->szInstanceID, pszInstanceID))
		{
			pActualInst->bNeeded = TRUE;
			if (pActualInst->pInst)
			{
				pActualInst->pInst->Release();
				pActualInst->pInst = NULL;
			}

			hRetRes = pObj->Clone(&pActualInst->pInst);
			if (FAILED(hRetRes))
			{
				MY_HRESASSERT(hRetRes);
				return hRetRes;
			}
			bFound = TRUE;
			break;
		}
	}

	if (bFound == FALSE)
	{
		actualInst.szInstanceID = new TCHAR[wcslen(pszInstanceID)+2];
		MY_ASSERT(actualInst.szInstanceID); if (!actualInst.szInstanceID) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		wcscpy(actualInst.szInstanceID, pszInstanceID);
		actualInst.pInst = NULL;
		actualInst.bNeeded = TRUE;
		wcscpy(actualInst.szDTTime, m_szDTCurrTime);
		wcscpy(actualInst.szTime, m_szCurrTime);
		hRetRes = pObj->Clone(&actualInst.pInst);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		m_actualInstList.push_back(actualInst);
	}

	return hRetRes;

error:
	MY_ASSERT(FALSE);
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

BOOL CDataCollector::GetEnabledChange(void)
{
	BOOL bChanged = FALSE;

	if ((m_bEnabled==FALSE || m_bParentEnabled==FALSE) && m_lCurrState!=HM_DISABLED)
	{
		bChanged = TRUE;
	}

	if ((m_bEnabled==TRUE && m_bParentEnabled==TRUE) && m_lCurrState==HM_DISABLED)
	{
		bChanged = TRUE;
	}

	return bChanged;
}

BOOL CDataCollector::SetCurrState(HM_STATE state, BOOL bCheckChanges/*FALSE*/)
{
	m_lCurrState = state;

	return TRUE;
}

BOOL CDataCollector::checkTime(void)
{
	BOOL bTimeOK;
	SYSTEMTIME st;	// system time

	//
	// Make sure that we are in a valid time to run.
	// NULL (-1) means run all the time.
	//
	bTimeOK = FALSE;
	if (m_bEnabled==TRUE && m_bParentEnabled==TRUE)
	{
		GetLocalTime(&st);

		bTimeOK = FALSE;
		// Check the Day of the Week
		if (!(m_iActiveDays&(1<<st.wDayOfWeek)))
		{
		}
		else if (m_lBeginHourTime<0 || m_lEndHourTime<0)
		{
			bTimeOK = TRUE;
		}
		else if (m_lBeginHourTime==m_lEndHourTime && m_lBeginMinuteTime==m_lEndMinuteTime)
		{
			// Check the Hours of operation
			// First see if we are doing an inclusive time tests, or an exclusive time test
//XXXStill need work here. What happens when we have the collection interval set
//to go off every 10 seconds. We will keep doing this
			// Case where the time is exactly equal, and that means run this once per day
			if (st.wHour==m_lBeginHourTime && st.wMinute==m_lBeginMinuteTime)
			{
				if (st.wSecond <= HM_POLLING_INTERVAL)
				{
					bTimeOK = TRUE;
				}
			}
		}
		else if ((m_lBeginHourTime < m_lEndHourTime) ||
			((m_lBeginHourTime==m_lEndHourTime) && m_lBeginMinuteTime < m_lEndMinuteTime))
		{
			// Inclusive case
			if ((m_lBeginHourTime < st.wHour) ||
				((m_lBeginHourTime == st.wHour) && m_lBeginMinuteTime <= st.wMinute))
			{
				if ((st.wHour < m_lEndHourTime) ||
					((st.wHour == m_lEndHourTime) && st.wMinute < m_lEndMinuteTime))
				{
					bTimeOK = TRUE;
				}
			}
		}
		else
		{
			// Exclusive case
			if ((m_lEndHourTime > st.wHour) ||
				((m_lEndHourTime == st.wHour) && m_lEndMinuteTime > st.wMinute))
			{
				bTimeOK = TRUE;
			}
			else if ((st.wHour > m_lBeginHourTime) ||
				((st.wHour == m_lBeginHourTime) && st.wMinute >= m_lBeginMinuteTime))
			{
				bTimeOK = TRUE;
			}
		}
	}

	return bTimeOK;
}

HRESULT CDataCollector::GetHMDataCollectorPerInstanceStatusEvent(LPTSTR pszInstanceID, ACTUALINSTSTRUCT *pActualInst, long state, IWbemClassObject** ppInstance, BOOL bEventBased)
{
	HRESULT hRetRes = S_OK;
	GUID guid;
	BSTR bsName = NULL;
	VARIANT v;
	IWbemClassObject* pEmbeddedDataCollectorInst = NULL;
	IWbemClassObject* pClass = NULL;
	BSTR bsString = NULL;
	DWORD dwNameLen = MAX_COMPUTERNAME_LENGTH + 2;
	TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 2];
	TCHAR szStatusGUID[1024];
	VariantInit(&v);

	MY_OUTPUT(L"ENTER *****CDataCollector::GetHMDataCollectorPerInstanceStatusEvent...", 1);

	if (bEventBased)
	{
		bsString = SysAllocString(L"MicrosoftHM_DataCollectorPerInstanceStatusEvent");
		MY_ASSERT(bsString); if (!bsString) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	}
	else
	{
		bsString = SysAllocString(L"MicrosoftHM_DataCollectorPerInstanceStatus");
		MY_ASSERT(bsString); if (!bsString) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	}
	hRetRes = g_pIWbemServices->GetObject(bsString, 0L, NULL, &pClass, NULL);
	SysFreeString(bsString);
	bsString = NULL;
	if (FAILED(hRetRes))
	{
		MY_HRESASSERT(hRetRes);
		return hRetRes;
	}

	hRetRes = pClass->SpawnInstance(0, ppInstance);
	pClass->Release();
	pClass = NULL;

	if (FAILED(hRetRes))
	{
		MY_HRESASSERT(hRetRes);
		return hRetRes;
	}

	hRetRes = CoCreateGuid(&guid);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	StringFromGUID2(guid, szStatusGUID, 100);

	hRetRes = PutStrProperty(*ppInstance, L"GUID", m_szGUID);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	hRetRes = PutStrProperty(*ppInstance, L"InstanceName", pszInstanceID);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	hRetRes = PutStrProperty(*ppInstance, L"Name", m_szName);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	hRetRes = PutStrProperty(*ppInstance, L"ParentGUID", m_pParentDG->m_szGUID);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	hRetRes = PutUint32Property(*ppInstance, L"State", state);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	hRetRes = PutUint32Property(*ppInstance, L"CollectionInstanceCount", m_lNumInstancesCollected);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	hRetRes = PutUUint32Property(*ppInstance, L"CollectionErrorCode", m_ulErrorCode);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	hRetRes = PutStrProperty(*ppInstance, L"CollectionErrorDescription", m_szErrorDescription);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	hRetRes = PutStrProperty(*ppInstance, L"StatusGUID", szStatusGUID);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	if (pActualInst)
	{
		hRetRes = PutStrProperty(*ppInstance, L"TimeGeneratedGMT", pActualInst->szDTTime);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = PutStrProperty(*ppInstance, L"LocalTimeFormatted", pActualInst->szTime);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}
	else if (!wcscmp(pszInstanceID, L"CollectionInstanceCount"))
	{
		hRetRes = PutStrProperty(*ppInstance, L"TimeGeneratedGMT", m_szDTCICTime);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = PutStrProperty(*ppInstance, L"LocalTimeFormatted", m_szCICTime);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}
	else if (!wcscmp(pszInstanceID, L"CollectionErrorCode"))
	{
		hRetRes = PutStrProperty(*ppInstance, L"TimeGeneratedGMT", m_szDTCECTime);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = PutStrProperty(*ppInstance, L"LocalTimeFormatted", m_szCECTime);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}
	else
	{
		MY_ASSERT(FALSE);
		hRetRes = PutStrProperty(*ppInstance, L"TimeGeneratedGMT", m_szDTCurrTime);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = PutStrProperty(*ppInstance, L"LocalTimeFormatted", m_szCurrTime);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}
	// Get the computer name of the machine
	if (GetComputerName(szComputerName, &dwNameLen))
	{
		hRetRes = PutStrProperty(*ppInstance, L"SystemName", szComputerName);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}
	else
	{
		hRetRes = PutStrProperty(*ppInstance, L"SystemName", L"LocalMachine");
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}

	if (state != HM_GOOD)
	{
		hRetRes = PutStrProperty(*ppInstance, L"Message", m_szMessage);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}
	else
	{
		hRetRes = PutStrProperty(*ppInstance, L"Message", m_szResetMessage);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}

	if (pActualInst)
	{
		hRetRes = FormatMessage(*ppInstance, pActualInst->pInst);
	}
	else
	{
		hRetRes = FormatMessage(*ppInstance, NULL);
	}

//XXX
//Make sure that this code is correct
	if (pActualInst && hRetRes==S_OK && m_bValidLoad)
	{
		hRetRes = pActualInst->pInst->Clone(&pEmbeddedDataCollectorInst);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		if (pEmbeddedDataCollectorInst)
		{
			bsName = SysAllocString(L"EmbeddedCollectedInstance");
			MY_ASSERT(bsName); if (!bsName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			VariantInit(&v);
			V_VT(&v) = VT_UNKNOWN;
			V_UNKNOWN(&v) = (IUnknown*)pEmbeddedDataCollectorInst;
			(V_UNKNOWN(&v))->AddRef();
			hRetRes = (*ppInstance)->Put(bsName, 0L, &v, 0L);
			VariantClear(&v);
			SysFreeString(bsName);
			bsName = NULL;
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			pEmbeddedDataCollectorInst->Release();
			pEmbeddedDataCollectorInst = NULL;
		}
	}

	MY_OUTPUT(L"EXIT *****CDataCollector::GetHMDataCollectorPerInstanceStatusEvent...", 1);
	return hRetRes;

error:
	MY_ASSERT(FALSE);
	if (bsString)
		SysFreeString(bsString);
	if (bsName)
		SysFreeString(bsName);
	if (pClass)
		pClass->Release();
	if (pEmbeddedDataCollectorInst)
		pEmbeddedDataCollectorInst->Release();
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

//
// Do string replacement for the Message property
//
HRESULT CDataCollector::FormatMessage(IWbemClassObject* pIRSInstance, IWbemClassObject *pEmbeddedInstance)
{
	HRESULT hRetRes = S_OK;
	BSTR PropName = NULL;
	LPTSTR pszMsg = NULL;
	SAFEARRAY *psaNames = NULL;
	long lNum;
	LPTSTR pszDest = NULL;
	LPTSTR pszUpperMsg = NULL;
	LPTSTR pszNewMsg = NULL;
	LPTSTR pStr = NULL;
	LPTSTR pStr2 = NULL;
	LPTSTR pStrStart = NULL;
	TOKENSTRUCT tokenElmnt;
	TOKENSTRUCT *pTokenElmnt;
	REPSTRUCT repElmnt;
	REPSTRUCT *pRepElmnt;
	REPSTRUCT *pRepElmnt2;
	REPLIST replacementList;
	int i, iSize, iSizeNeeded, j;
	long lLower, lUpper; 
	static TOKENLIST tokenList;
	TOKENLIST embeddedInstTokenList;

	if (m_bValidLoad == FALSE)
		return FALSE;

	//
	// We only need to build the set of tokens one time, then from then on
	// we just need to fill in the values for what the replacement strings are.
	//
	if (tokenList.size() == 0)
	{
		//
		// First we build the set of tokens that we are looking for. Each property that
		// is in the ThresholdStatusInstance. We build that set of strings,
		// and the values to replace with.
		//

		//
		// Now go through ThresholdInstance, which is where the Message String
		// actually lives. Get that set of properties for the Instances.
		//
		hRetRes = pIRSInstance->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames);
		if (SUCCEEDED(hRetRes))
		{
			// Get the number of properties.
			SafeArrayGetLBound(psaNames, 1, &lLower);
			SafeArrayGetUBound(psaNames, 1, &lUpper);

			// For each property...
			for (long l=lLower; l<=lUpper; l++) 
			{
				// Get this property.
				hRetRes = SafeArrayGetElement(psaNames, &l, &PropName);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
				// Will want to skip some that don't make sense.
				if (!wcscmp(PropName, L"Message"))
				{
					SysFreeString(PropName);
					PropName = NULL;
					continue;
				}
				else if (!wcscmp(PropName, L"ResetMessage"))
				{
					SysFreeString(PropName);
					PropName = NULL;
					continue;
				}
				else if (!wcscmp(PropName, L"EmbeddedCollectedInstance"))
				{
					SysFreeString(PropName);
					PropName = NULL;
					continue;
				}
				tokenElmnt.szOrigToken = new TCHAR[wcslen(PropName)+1];
				MY_ASSERT(tokenElmnt.szOrigToken); if (!tokenElmnt.szOrigToken) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				wcscpy(tokenElmnt.szOrigToken, PropName);
				tokenElmnt.szToken = new TCHAR[wcslen(PropName)+3];
				MY_ASSERT(tokenElmnt.szToken); if (!tokenElmnt.szToken) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				wcscpy(tokenElmnt.szToken, L"%");
				wcscat(tokenElmnt.szToken, PropName);
				wcscat(tokenElmnt.szToken, L"%");
				_wcsupr(tokenElmnt.szToken);
				tokenElmnt.szReplacementText = NULL;
				tokenList.push_back(tokenElmnt);
				SysFreeString(PropName);
				PropName = NULL;
			}
			SafeArrayDestroy(psaNames);
			psaNames = NULL;
		}
	}

	//
	// Populate the list of properties on the embedded instance that came from the
	// Data Collector.
	//
	if (pEmbeddedInstance)
	{
		MY_ASSERT(pEmbeddedInstance);
		hRetRes = pEmbeddedInstance->GetNames(NULL, WBEM_FLAG_ALWAYS, NULL, &psaNames);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		// Get the number of properties.
		SafeArrayGetLBound(psaNames, 1, &lLower);
		SafeArrayGetUBound(psaNames, 1, &lUpper);

		// For each property...
		for (long l=lLower; l<=lUpper; l++) 
		{
			// Get this property.
			hRetRes = SafeArrayGetElement(psaNames, &l, &PropName);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			tokenElmnt.szOrigToken = new TCHAR[wcslen(PropName)+1];
			MY_ASSERT(tokenElmnt.szOrigToken); if (!tokenElmnt.szOrigToken) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			wcscpy(tokenElmnt.szOrigToken, PropName);
			tokenElmnt.szToken = new TCHAR[wcslen(PropName)+29];
			MY_ASSERT(tokenElmnt.szToken); if (!tokenElmnt.szToken) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			wcscpy(tokenElmnt.szToken, L"%");
			wcscat(tokenElmnt.szToken, L"EmbeddedCollectedInstance.");
			wcscat(tokenElmnt.szToken, PropName);
			wcscat(tokenElmnt.szToken, L"%");
			_wcsupr(tokenElmnt.szToken);
			tokenElmnt.szReplacementText = NULL;
			embeddedInstTokenList.push_back(tokenElmnt);
			SysFreeString(PropName);
			PropName = NULL;
		}
		SafeArrayDestroy(psaNames);
		psaNames = NULL;
	}

	//
	// Now we can fill in the values to use for the replacement strings.
	//

	//
	// Now go through each ThresholdInstance, which is where the Message String
	// actually lives. Get that set of properties of the Instance,
	// And do the message formatting while there.
	//

	//
	// Get the replacement strings for this instance
	//
	iSize = tokenList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<tokenList.size());
		pTokenElmnt = &tokenList[i];
		if (pTokenElmnt->szReplacementText != NULL)
		{
			delete [] pTokenElmnt->szReplacementText;
			pTokenElmnt->szReplacementText = NULL;
		}
		
		if (!wcscmp(pTokenElmnt->szToken, L"%TESTCONDITION%"))
		{
			hRetRes = GetUint32Property(pIRSInstance, pTokenElmnt->szOrigToken, &lNum);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			MY_ASSERT(lNum<9);
			pStr = new TCHAR[wcslen(conditionLocStr[lNum])+1];
			MY_ASSERT(pStr); if (!pStr) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			wcscpy(pStr, conditionLocStr[lNum]);
		}
		else if (!wcscmp(pTokenElmnt->szToken, L"%STATE%"))
		{
			hRetRes = GetUint32Property(pIRSInstance, pTokenElmnt->szOrigToken, &lNum);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			MY_ASSERT(lNum<10);
			pStr = new TCHAR[wcslen(stateLocStr[lNum])+1];
			MY_ASSERT(pStr); if (!pStr) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			wcscpy(pStr, stateLocStr[lNum]);
		}
		else
		{
			hRetRes = GetAsStrProperty(pIRSInstance, pTokenElmnt->szOrigToken, &pStr);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		}
		pTokenElmnt->szReplacementText = pStr;
	}

	//
	// Get the replacement strings for this instance - Embedded
	//
	iSize = embeddedInstTokenList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<embeddedInstTokenList.size());
		pTokenElmnt = &embeddedInstTokenList[i];
		if (pTokenElmnt->szReplacementText != NULL)
		{
			delete [] pTokenElmnt->szReplacementText;
			pTokenElmnt->szReplacementText = NULL;
		}
		
		MY_ASSERT(pEmbeddedInstance);
		hRetRes = GetAsStrProperty(pEmbeddedInstance, pTokenElmnt->szOrigToken, &pStr);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		pTokenElmnt->szReplacementText = pStr;
	}

	//
	// Now we have both lists of tokens that have replacement
	// strings that go with them and the replacement strings
	// that go with them
	//

	//
	// Do formatting of Message. We replace all Variable Tags.
	// Sample string -
	// "Drive %InstanceName% is full. Currently at %CurrentValue%%."
	//

	//
	// Get the origional un-formatted message first.
	// To make case in-sensitive, do a _strdup and then a _wcsupr on the string
	// to scan run the code on it, and then free the duplicated string.
	//
	// If it uses resource IDs, then get that string first, then format that!!!
	hRetRes = GetStrProperty(pIRSInstance, L"Message", &pszMsg);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	pszUpperMsg = _wcsdup(pszMsg);
	MY_ASSERT(pszUpperMsg); if (!pszUpperMsg) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	_wcsupr(pszUpperMsg);

	//
	// First loop through and find every token that needs replacing.
	// Put that info into the replacement list.
	//
	// We will do strstr() for each special token until there are no more to find
	// for each. At each find we will store the offset into the string of what
	// we found. Then we sort by what came first.
	//
	// Quick test to see if it is worth searching
	if (wcschr(pszUpperMsg, '%'))
	{
		iSize = tokenList.size();
		pStrStart = pszUpperMsg;
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<tokenList.size());
			pTokenElmnt = &tokenList[i];
			pStr = wcsstr(pStrStart, pTokenElmnt->szToken);
			if (pStr != NULL)
			{
				repElmnt.pStartStr = pszMsg+(pStr-pszUpperMsg);
				repElmnt.len = wcslen(pTokenElmnt->szToken);
				repElmnt.pszReplacementText = pTokenElmnt->szReplacementText;
				replacementList.push_back(repElmnt);
				i--;
				pStrStart = pStr+1;
			}
			else
			{
				pStrStart = pszUpperMsg;
			}
		}

		// Embedded stuff
		iSize = embeddedInstTokenList.size();
		pStrStart = pszUpperMsg;
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<embeddedInstTokenList.size());
			pTokenElmnt = &embeddedInstTokenList[i];
			pStr = wcsstr(pStrStart, pTokenElmnt->szToken);
			if (pStr != NULL)
			{
				repElmnt.pStartStr = pszMsg+(pStr-pszUpperMsg);
				repElmnt.len = wcslen(pTokenElmnt->szToken);
				repElmnt.pszReplacementText = pTokenElmnt->szReplacementText;
				replacementList.push_back(repElmnt);
				i--;
				pStrStart = pStr+1;
			}
			else
			{
				pStrStart = pszUpperMsg;
			}
		}

		//
		// Need to look for replacement strings that have not been replaced.
		// Simply search for %EmbeddedCollectedInstance. and find the end % for each
		// Replace them with <null>
		//
		if (!pEmbeddedInstance)
		{
			pStrStart = pszUpperMsg;
			while (TRUE)
			{
				pStr = wcsstr(pStrStart, L"%EMBEDDEDCOLLECTEDINSTANCE.");
				if (pStr != NULL)
				{
					repElmnt.pStartStr = pszMsg+(pStr-pszUpperMsg);
					pStr2 = pStr;
					while (pStr2++)
					{
						if (*pStr2=='%' || iswspace(*pStr2))
							break;
					}
					if (*pStr2=='%')
					{
						repElmnt.len = (pStr2-pStr)+1;
						repElmnt.pszReplacementText = L"<null>";
						replacementList.push_back(repElmnt);
					}
					pStrStart = pStr+1;
				}
				else
				{
					break;
				}
			}
		}
	}

	iSize = replacementList.size();
	if (iSize != 0)
	{
		//
		// Next, sort the replacement list from the first string to
		// be replaced, to the last. Shell sort, Knuth, Vol13, pg. 84.
		//
		for (int gap=iSize/2; 0<gap; gap/=2)
		{
			for (i=gap; i<iSize; i++)
			{
				for (j=i-gap; 0<=j; j-=gap)
				{
					MY_ASSERT(j+gap<replacementList.size());
					pRepElmnt = &replacementList[j+gap];
					MY_ASSERT(j<replacementList.size());
					pRepElmnt2 = &replacementList[j];
					if (pRepElmnt->pStartStr < pRepElmnt2->pStartStr)
					{
						MY_ASSERT(j<replacementList.size());
						repElmnt = replacementList[j];
						MY_ASSERT(j+gap<replacementList.size());
						replacementList[j] = replacementList[j+gap];
						MY_ASSERT(j+gap<replacementList.size());
						replacementList[j+gap] = repElmnt;
					}
				}
			}
		}

		//
		// Next, figure out the size needed for the Message with
		// everything replaced.
		//
		iSizeNeeded = wcslen(pszMsg)+1;
		iSize = replacementList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<replacementList.size());
			pRepElmnt = &replacementList[i];
			iSizeNeeded -= pRepElmnt->len;
			iSizeNeeded += wcslen(pRepElmnt->pszReplacementText);
		}
		pszNewMsg = new TCHAR[iSizeNeeded];
		MY_ASSERT(pszNewMsg); if (!pszNewMsg) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		*pszNewMsg = '\0';

		//
		// Next, we loop through and do the actual replacements.
		// "Drive %InstanceName% is full. Currently at %CurrentValue%%."
		//
		pszDest = pszMsg;
		iSize = replacementList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<replacementList.size());
			pRepElmnt = &replacementList[i];
			*(pRepElmnt->pStartStr) = '\0';
			wcscat(pszNewMsg, pszDest);
			wcscat(pszNewMsg, pRepElmnt->pszReplacementText);
//XXXWould memcpy be faster???							memcpy(pszDest, source, charCnt*sizeof(TCHAR));
			pszDest = pRepElmnt->pStartStr+pRepElmnt->len;
		}
		wcscat(pszNewMsg, pszDest);

		PutStrProperty(pIRSInstance, L"Message", pszNewMsg);
		delete [] pszNewMsg;
		pszNewMsg = NULL;
		replacementList.clear();
	}
	else
	{
		PutStrProperty(pIRSInstance, L"Message", pszMsg);
	}

	delete [] pszMsg;
	pszMsg = NULL;
	free(pszUpperMsg);
	pszUpperMsg = NULL;

	// Free up the temporary token list
	iSize = embeddedInstTokenList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<embeddedInstTokenList.size());
		pTokenElmnt = &embeddedInstTokenList[i];
		if (pTokenElmnt->szToken)
			delete [] pTokenElmnt->szToken;
		if (pTokenElmnt->szOrigToken)
			delete [] pTokenElmnt->szOrigToken;
		if (pTokenElmnt->szReplacementText)
			delete [] pTokenElmnt->szReplacementText;
	}
	embeddedInstTokenList.clear();

	return hRetRes;

error:
	MY_ASSERT(FALSE);
	if (PropName)
		SysFreeString(PropName);
	if (psaNames)
		SafeArrayDestroy(psaNames);
	if (pszNewMsg)
		delete [] pszNewMsg;
	if (pszMsg)
		delete [] pszMsg;
	if (pszUpperMsg)
		free(pszUpperMsg);
	iSize = embeddedInstTokenList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<embeddedInstTokenList.size());
		pTokenElmnt = &embeddedInstTokenList[i];
		if (pTokenElmnt->szToken)
			delete [] pTokenElmnt->szToken;
		if (pTokenElmnt->szOrigToken)
			delete [] pTokenElmnt->szOrigToken;
		if (pTokenElmnt->szReplacementText)
			delete [] pTokenElmnt->szReplacementText;
	}
	embeddedInstTokenList.clear();
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

BOOL CDataCollector::SendReminderActionIfStateIsSame(IWbemObjectSink* pActionEventSink, IWbemObjectSink* pActionTriggerEventSink, IWbemClassObject* pActionInstance, IWbemClassObject* pActionTriggerInstance, unsigned long ulTriggerStates)
{
	HRESULT hRetRes = S_OK;
	IWbemClassObject* pInstance = NULL;
	BSTR bsName = NULL;
	VARIANT v;
	long state;
	int i, iSize;
	BOOL bRetValue = TRUE;
	ACTUALINSTSTRUCT *pActualInst;
	long firstInstanceState = -1;
	GUID guid;
	TCHAR szStatusGUID[100];
	VariantInit(&v);

	MY_OUTPUT(L"ENTER ***** CDataCollector::SendReminderActionIfStateIsSame...", 2);
	if (m_bValidLoad == FALSE)
		return FALSE;

	//
	// We can loop through the set of collected instances and ask each Threshold
	// to tell us if the state has changed as far as each is concerned, for the
	// property they are lookin at.
	//
	iSize = m_actualInstList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_actualInstList.size());
		pActualInst = &m_actualInstList[i];

		state = PassBackWorstStatePerInstance(pActualInst->szInstanceID, (BOOL)i==0);
		if (state==-1) state = HM_COLLECTING;
		if (i==0)
		{
			firstInstanceState = state;
		}
		// Check to see if still in the desired state
		if (!(ulTriggerStates&(1<<state)))
		{
			continue;
		}

		hRetRes = GetHMDataCollectorPerInstanceStatusEvent(pActualInst->szInstanceID, pActualInst, state, &pInstance, TRUE);
		if (SUCCEEDED(hRetRes))
		{
			PutUint32Property(pActionTriggerInstance, L"State", m_lCurrState);
	
			bsName = SysAllocString(L"EmbeddedStatusEvent");
			MY_ASSERT(bsName); if (!bsName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			VariantInit(&v);
			V_VT(&v) = VT_UNKNOWN;
			V_UNKNOWN(&v) = (IUnknown*)pInstance;
			(V_UNKNOWN(&v))->AddRef();
			hRetRes = (pActionTriggerInstance)->Put(bsName, 0L, &v, 0L);
			VariantClear(&v);
			SysFreeString(bsName);
			bsName = NULL;
			MY_HRESASSERT(hRetRes);
	
			if (pActionEventSink) 
			{
				hRetRes = CoCreateGuid(&guid);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
				StringFromGUID2(guid, szStatusGUID, 100);
				hRetRes = PutStrProperty(pActionInstance, L"StatusGUID", szStatusGUID);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
				hRetRes = pActionEventSink->Indicate(1, &pActionInstance);
				//WBEM_E_SERVER_TOO_BUSY is Ok. Wbem will deliver.
				if (FAILED(hRetRes) && hRetRes != WBEM_E_SERVER_TOO_BUSY)
				{
					MY_HRESASSERT(hRetRes);
					MY_OUTPUT(L"Failed on Indicate!", 4);
				}
			}
			if (pActionTriggerEventSink) 
			{
				hRetRes = pActionTriggerEventSink->Indicate(1, &pActionTriggerInstance);
				//WBEM_E_SERVER_TOO_BUSY is Ok. Wbem will deliver.
				if (FAILED(hRetRes) && hRetRes != WBEM_E_SERVER_TOO_BUSY)
				{
					MY_HRESASSERT(hRetRes);
					MY_OUTPUT(L"Failed on Indicate!", 4);
				}
			}

			pInstance->Release();
			pInstance = NULL;
		}
		else
		{
			MY_HRESASSERT(hRetRes);
			MY_OUTPUT(L"failed to get instance!", 4);
		}
	}

	//
	// Do it for the three default properties
	//
	if (firstInstanceState==-1)
	{
		state = PassBackWorstStatePerInstance(L"CollectionInstanceCount", FALSE);
		if (state==-1) state = HM_COLLECTING;
		// Check to see if still in the desired state
		if ((ulTriggerStates&(1<<state)))
		{
			hRetRes = GetHMDataCollectorPerInstanceStatusEvent(L"CollectionInstanceCount", NULL, state, &pInstance, TRUE);
			if (SUCCEEDED(hRetRes))
			{
				PutUint32Property(pActionTriggerInstance, L"State", m_lCurrState);
	
				bsName = SysAllocString(L"EmbeddedStatusEvent");
				MY_ASSERT(bsName); if (!bsName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				VariantInit(&v);
				V_VT(&v) = VT_UNKNOWN;
				V_UNKNOWN(&v) = (IUnknown*)pInstance;
				(V_UNKNOWN(&v))->AddRef();
				hRetRes = (pActionTriggerInstance)->Put(bsName, 0L, &v, 0L);
				VariantClear(&v);
				SysFreeString(bsName);
				bsName = NULL;
				MY_HRESASSERT(hRetRes);
	
				if (pActionEventSink) 
				{
					hRetRes = CoCreateGuid(&guid);
					MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
					StringFromGUID2(guid, szStatusGUID, 100);
					hRetRes = PutStrProperty(pActionInstance, L"StatusGUID", szStatusGUID);
					MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
					hRetRes = pActionEventSink->Indicate(1, &pActionInstance);
					//WBEM_E_SERVER_TOO_BUSY is Ok. Wbem will deliver.
					if (FAILED(hRetRes) && hRetRes != WBEM_E_SERVER_TOO_BUSY)
					{
						MY_HRESASSERT(hRetRes);
						MY_OUTPUT(L"Failed on Indicate!", 4);
					}
				}
				if (pActionTriggerEventSink) 
				{
					hRetRes = pActionTriggerEventSink->Indicate(1, &pActionTriggerInstance);
					//WBEM_E_SERVER_TOO_BUSY is Ok. Wbem will deliver.
					if (FAILED(hRetRes) && hRetRes != WBEM_E_SERVER_TOO_BUSY)
					{
						MY_HRESASSERT(hRetRes);
						MY_OUTPUT(L"Failed on Indicate!", 4);
					}
				}

				pInstance->Release();
				pInstance = NULL;
			}
			else
			{
				MY_HRESASSERT(hRetRes);
				MY_OUTPUT(L"failed to get instance!", 4);
			}
		}
	}

	if (firstInstanceState==-1)
	{
		state = PassBackWorstStatePerInstance(L"CollectionErrorCode", FALSE);
		if (state==-1) state = HM_COLLECTING;
		// Check to see if still in the desired state
		if ((ulTriggerStates&(1<<state)))
		{
			hRetRes = GetHMDataCollectorPerInstanceStatusEvent(L"CollectionInstanceCount", NULL, state, &pInstance, TRUE);
			if (SUCCEEDED(hRetRes))
			{
				PutUint32Property(pActionTriggerInstance, L"State", m_lCurrState);
	
				bsName = SysAllocString(L"EmbeddedStatusEvent");
				MY_ASSERT(bsName); if (!bsName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				VariantInit(&v);
				V_VT(&v) = VT_UNKNOWN;
				V_UNKNOWN(&v) = (IUnknown*)pInstance;
				(V_UNKNOWN(&v))->AddRef();
				hRetRes = (pActionTriggerInstance)->Put(bsName, 0L, &v, 0L);
				VariantClear(&v);
				SysFreeString(bsName);
				bsName = NULL;
				MY_HRESASSERT(hRetRes);
	
				if (pActionEventSink) 
				{
					hRetRes = CoCreateGuid(&guid);
					MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
					StringFromGUID2(guid, szStatusGUID, 100);
					hRetRes = PutStrProperty(pActionInstance, L"StatusGUID", szStatusGUID);
					MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
					hRetRes = pActionEventSink->Indicate(1, &pActionInstance);
					//WBEM_E_SERVER_TOO_BUSY is Ok. Wbem will deliver.
					if (FAILED(hRetRes) && hRetRes != WBEM_E_SERVER_TOO_BUSY)
					{
						MY_HRESASSERT(hRetRes);
						MY_OUTPUT(L"Failed on Indicate!", 4);
					}
				}
				if (pActionTriggerEventSink) 
				{
					hRetRes = pActionTriggerEventSink->Indicate(1, &pActionTriggerInstance);
					//WBEM_E_SERVER_TOO_BUSY is Ok. Wbem will deliver.
					if (FAILED(hRetRes) && hRetRes != WBEM_E_SERVER_TOO_BUSY)
					{
						MY_HRESASSERT(hRetRes);
						MY_OUTPUT(L"Failed on Indicate!", 4);
					}
				}

				pInstance->Release();
				pInstance = NULL;
			}
			else
			{
				MY_HRESASSERT(hRetRes);
				MY_OUTPUT(L"failed to get instance!", 4);
			}
		}
	}

#ifdef SAVE
	state = PassBackWorstStatePerInstance(L"CollectionErrorDescription");
#endif

	MY_OUTPUT(L"EXIT ***** CDataCollector::SendReminderActionIfStateIsSame...", 2);
	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (bsName)
		SysFreeString(bsName);
	if (pInstance)
		pInstance->Release();
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return FALSE;
}

HRESULT CDataCollector::insertNewProperty(LPTSTR pszPropertyName)
{
	HRESULT hRetRes = S_OK;
	int i, iSize;
	PNSTRUCT *ppn;
	BOOL bFound = FALSE;
	BOOL bDoInsert = FALSE;
	PNSTRUCT pn;
	PNLIST::iterator iaPN;

	bFound = FALSE;
	iaPN=m_pnList.begin();
	iSize = m_pnList.size();
	for (i=0; i<iSize; i++, iaPN++)
	{
		MY_ASSERT(i<m_pnList.size());
		ppn = &m_pnList[i];
		if (!_wcsicmp(ppn->szPropertyName, pszPropertyName))
		{
			bFound = TRUE;
			ppn->iRefCount++;
			break;
		}
		// We know it can't be further than this one, and we can insert here
		if (!_wcsicmp(ppn->szPropertyName, L"CollectionInstanceCount"))
		{
			bDoInsert = TRUE;
			break;
		}
	}
	// Add it it is new!
	if (bFound == FALSE)
	{
		pn.szPropertyName = new TCHAR[wcslen(pszPropertyName)+2];
		MY_ASSERT(pn.szPropertyName); if (!pn.szPropertyName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		wcscpy(pn.szPropertyName, pszPropertyName);
		pn.iRefCount = 1;
		pn.type = 0;
		if (bDoInsert)
		{
			m_pnList.insert(iaPN, pn);
		}
		else
		{
			m_pnList.push_back(pn);
		}
	}
	
	return hRetRes;

error:
	MY_ASSERT(FALSE);
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

BOOL CDataCollector::propertyNotNeeded(LPTSTR pszPropertyName)
{
	int j, jSize;
	int k, kSize;
	PNSTRUCT *ppn;
	BOOL bAdded = FALSE;
	PNLIST::iterator iaPN;
	INSTSTRUCT *pinst;

	//
	// Delete the property if this Threshold was the last one that needed it.
	// Refcount if there already.
	//
	iaPN=m_pnList.begin();
	jSize = m_pnList.size();
	for (j=0; j<jSize; j++, iaPN++)
	{
		MY_ASSERT(j<m_pnList.size());
		ppn = &m_pnList[j];
		if (!_wcsicmp(ppn->szPropertyName, pszPropertyName))
		{
			ppn->iRefCount--;
			if (ppn->iRefCount==0)
			{
				kSize = ppn->instList.size();
				for (k = 0; k < kSize ; k++)
				{
					MY_ASSERT(k<ppn->instList.size());
					pinst = &ppn->instList[k];
					if (pinst->szCurrValue)
					{
						delete [] pinst->szCurrValue;
					}
					if (pinst->szInstanceID)
					{
						delete [] pinst->szInstanceID;
					}
					pinst->valList.clear();
				}
				ppn->instList.clear();
				m_pnList.erase(iaPN);
			}
			break;
		}
		// We know it can't be further than this one, and we can insert here
		if (!_wcsicmp(ppn->szPropertyName, L"CollectionInstanceCount"))
		{
			break;
		}
	}

	return TRUE;
}

BOOL CDataCollector::ResetInst(INSTSTRUCT *pinst, CIMTYPE type)
{
	if (type == CIM_REAL32)
	{
		pinst->currValue.fValue = 0;
		pinst->minValue.fValue = MAX_FLOAT;
		pinst->maxValue.fValue = 0;
		pinst->avgValue.fValue = 0;
	}
	else if (type == CIM_REAL64)
	{
		pinst->currValue.dValue = 0;
		pinst->minValue.dValue = MAX_DOUBLE;
		pinst->maxValue.dValue = 0;
		pinst->avgValue.dValue = 0;
	}
	else if (type == CIM_SINT64)
	{
		pinst->currValue.i64Value = 0;
		pinst->minValue.i64Value = MAX_I64;
		pinst->maxValue.i64Value = 0;
		pinst->avgValue.i64Value = 0;
	}
	else if (type == CIM_UINT64)
	{
		pinst->currValue.ui64Value = 0;
		pinst->minValue.ui64Value = MAX_UI64;
		pinst->maxValue.ui64Value = 0;
		pinst->avgValue.ui64Value = 0;
	}
	else if (type == CIM_UINT32)
	{
		pinst->currValue.ulValue = 0;
		pinst->minValue.ulValue = MAX_ULONG;
		pinst->maxValue.ulValue = 0;
		pinst->avgValue.ulValue = 0;
	}
	else
	{
		pinst->currValue.lValue = 0;
		pinst->minValue.lValue = MAX_LONG;
		pinst->maxValue.lValue = 0;
		pinst->avgValue.lValue = 0;
	}

	return TRUE;
}

BOOL CDataCollector::CheckForReset(void)
{
	BOOL bFoundReset;
	BOOL bFoundNonNormal;
//	PNSTRUCT *ppn;
	long state;
	int i, iSize;
//	int j, jSize;
	CThreshold* pThreshold;
//	INSTSTRUCT *pinst;
//	ACTUALINSTSTRUCT *pActualInst;

	//
	// See if we have a Threshold in the RESET state
	//
	bFoundReset = FALSE;
	bFoundNonNormal = FALSE;
	iSize = m_thresholdList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		state = pThreshold->GetCurrState();
		if (state == HM_RESET)
		{
			bFoundReset = TRUE;
		}
		if (state==HM_WARNING || state==HM_CRITICAL)
		{
			bFoundNonNormal = TRUE;
		}
		if (bFoundReset && bFoundNonNormal)
			break;
	}

	if (bFoundReset && bFoundNonNormal)
	{
		// If we don't call the base method, we may get into an endless loop.
		CDataCollector::EvaluateThresholds(TRUE, TRUE, FALSE, FALSE);
		CDataCollector::EvaluateThresholds(TRUE, FALSE, TRUE, FALSE);

		//
		// Set back the RESET one(s)
		//
		m_lCurrState = HM_COLLECTING;
		iSize = m_thresholdList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<m_thresholdList.size());
			pThreshold = m_thresholdList[i];
			if (pThreshold->GetCurrState() == HM_RESET)
			{
				pThreshold->SetCurrState(HM_GOOD);
			}
		}
	}
//#ifdef SAVE
//XXX???Do we want the following???
	else if (bFoundReset)
	{
		if (m_deType!=HM_EQDE && m_bRequireReset)
		{
			iSize = m_thresholdList.size();
			for (i = 0; i < iSize ; i++)
			{
				MY_ASSERT(i<m_thresholdList.size());
				pThreshold = m_thresholdList[i];
				if (pThreshold->GetCurrState() == HM_RESET)
				{
					pThreshold->ResetResetThreshold();
				}
			}
		}
	}
//#endif

	return TRUE;
}

HRESULT CDataCollector::CheckForBadLoad(void)
{
	HRESULT hRetRes = S_OK;
	IWbemClassObject* pObj = NULL;
	TCHAR szTemp[1024];
	IWbemClassObject* pInstance = NULL;

	if (m_bValidLoad == FALSE)
	{
		wcscpy(szTemp, L"MicrosoftHM_DataCollectorConfiguration.GUID=\"");
		lstrcat(szTemp, m_szGUID);
		lstrcat(szTemp, L"\"");
		hRetRes = GetWbemObjectInst(&g_pIWbemServices, szTemp, NULL, &pObj);
		if (!pObj)
		{
			MY_HRESASSERT(hRetRes);
			return S_FALSE;
		}
		hRetRes = LoadInstanceFromMOF(pObj, NULL, L"", TRUE);
		// Here is where we can try and send out a generic SOS if the load failed each time!!!
		if (hRetRes != S_OK)
		{
			if (GetHMDataCollectorStatusInstance(&pInstance, TRUE) == S_OK)
			{
				mg_DCEventList.push_back(pInstance);
			}
		}
		else
		{
			if (GetHMDataCollectorStatusInstance(&pInstance, TRUE) == S_OK)
			{
				mg_DCEventList.push_back(pInstance);
			}
			ResetState(TRUE, TRUE);
		}
		MY_HRESASSERT(hRetRes);
		pObj->Release();
		pObj = NULL;
		return hRetRes;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\datacltr.h ===
//***************************************************************************
//
//  DATACLTR.H
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: CDataCollector class to do WMI instance collection.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#if !defined( __DATACLTR_H )
#define __DATACLTR_H

#include <wbemcli.h>
#include <vector>
#include "global.h"
#include "base.h"
#include "threshld.h"

typedef struct _tag_NSStruct
{
	LPTSTR szTargetNamespace;		// Namespace class exists in
	LPTSTR szLocal;
	IWbemServices* pIWbemServices; // pointer to the namespace
} NSSTRUCT, *PNSSTRUCT;

typedef struct _tag_InstIDStruct
{
	LPTSTR szInstanceIDPropertyName;
} InstIDSTRUCT, *PInstIDSTRUCT;

typedef std::vector<NSSTRUCT, std::allocator<NSSTRUCT> > NSLIST;
typedef std::vector<CThreshold*, std::allocator<CThreshold*> > RLIST;
typedef std::vector<InstIDSTRUCT, std::allocator<InstIDSTRUCT> > InstIDLIST;

class CDataGroup; // Forward declaration

class CDataCollector : public CBase
{
public:
	CDataCollector();
	virtual ~CDataCollector();


	CDataGroup *m_pParentDG;
	long m_lNumberNormals;
	long m_lNumberWarnings;
	long m_lNumberCriticals;
	IWbemServices* m_pIWbemServices;
	RLIST m_thresholdList;
	LPTSTR m_szParentObjPath;
	LPTSTR m_szDescription;
	LPTSTR m_szUserName;
	LPTSTR m_szPassword;
	LPTSTR m_szTargetNamespace;
	LPTSTR m_szLocal;
	InstIDLIST m_instIDList; // List of the key properties of the class we are collecting
	ACTUALINSTLIST m_actualInstList; // List of actual instances being collected (most recent)
	LPTSTR m_szTypeGUID;
	long m_lCollectionIntervalMultiple;
	long m_lCollectionTimeOut;
	long m_lStatisticsWindowSize;
	int m_iActiveDays;
	long m_lBeginHourTime;
	long m_lBeginMinuteTime;
	long m_lEndHourTime;
	long m_lEndMinuteTime;
	long m_lTypeGUID;
	BOOL m_bRequireReset;
	BOOL m_bReplicate;
	BOOL m_bEnabled;
	BOOL m_bParentEnabled; // So we can transfer down the hierarchy the state.
	long m_lId;
	long m_lNumberChanges;
	IWbemContext *m_pContext;
	HM_DE_TYPE m_deType;
	IWbemCallResult *m_pCallResult;
	BOOL m_bKeepCollectingSemiSync;
	TCHAR m_szTime[512];
	TCHAR m_szCollectTime[512];
	TCHAR m_szCICTime[512];
	TCHAR m_szCECTime[512];
	TCHAR m_szDTTime[512];
	TCHAR m_szDTCollectTime[512];
	TCHAR m_szDTCICTime[512];
	TCHAR m_szDTCECTime[512];
	TCHAR m_szStatusGUID[100];
	unsigned long m_ulErrorCode;
	TCHAR m_szErrorDescription[4096];
	LPTSTR m_szMessage;
	LPTSTR m_szResetMessage;
	HRESULT FormatMessage(IWbemClassObject* pIRSInstance, IWbemClassObject *pEmbeddedInstance);
//	HM_UNKNOWN_REASON m_unknownReason;
//	HRESULT m_unknownhRes;
//	TCHAR m_szWmiError[1024];
	long m_lPrevChildCount;
	BOOL m_ulErrorCodePrev;
	BOOL m_bValidLoad;


	long m_lIntervalCount;
	long m_lCollectionTimeOutCount;
	long m_lNumInstancesCollected;
	long m_lPrevState;
//	long m_lCurrState;

	BOOL Cleanup(BOOL bSavePrevSettings);
	BOOL Init(void);
	BOOL OnAgentInterval(void);
	BOOL SendEvents(void);
	HRESULT FireEvent(BOOL bForce);
	BOOL FireStatisticsEvent(void);
	virtual BOOL CollectInstance(void) = 0;
	virtual BOOL CollectInstanceSemiSync(void) = 0;
	virtual BOOL CleanupSemiSync(void) = 0;
	virtual BOOL EnumDone(void) = 0;
	BOOL StoreValues(IWbemClassObject* pObj, LPTSTR pszInstID);
	BOOL StoreStandardProperties(void);
	long GetCollectionIntervalMultiple();
	virtual HRESULT LoadInstanceFromMOF(IWbemClassObject* pObj, CDataGroup *pParentDG, LPTSTR pszParentObjPath, BOOL bModifyPass=FALSE);

	//
	// STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC
	//
	static void DETerminationCleanup(void);
//private:
	static NSLIST mg_nsList;
	PNLIST m_pnList;

//	static BOOL fillInNamespacePointer(void);
	HRESULT fillInNamespacePointer(void);
	HRESULT InternalizeThresholds(void);
	BOOL InitContext(IWbemClassObject* pObj);
	HRESULT InitPropertyStatus(IWbemClassObject* pObj);
	virtual BOOL EvaluateThresholds(BOOL bIgnoreReset, BOOL bSkipStandard=FALSE, BOOL bSkipOthers=FALSE, BOOL bDoThresholdSkipClean=TRUE);

	HRESULT SendHMDataCollectorStatusInstances(IWbemObjectSink* pSink);
	HRESULT SendHMDataCollectorStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
	HRESULT SendHMDataCollectorPerInstanceStatusInstances(IWbemObjectSink* pSink);
	HRESULT SendHMDataCollectorPerInstanceStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
	HRESULT SendHMDataCollectorStatisticsInstances(IWbemObjectSink* pSink);
	HRESULT SendHMDataCollectorStatisticsInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
	HRESULT SendHMThresholdStatusInstances(IWbemObjectSink* pSink);
	HRESULT SendHMThresholdStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
//	HRESULT SendHMThresholdStatusInstanceInstances(IWbemObjectSink* pSink);
//	HRESULT SendHMThresholdStatusInstanceInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
	HRESULT GetHMDataCollectorStatusInstance(IWbemClassObject** ppInstance, BOOL bEventBased);
//	HRESULT GetHMDataCollectorStatisticsInstancePrev(IWbemClassObject** ppInstance);
	HRESULT GetHMDataCollectorStatisticsInstances(LPTSTR szDTTime, LPTSTR szTime);
	long GetCurrState(void);
	BOOL ConsolodateStatistics(IWbemClassObject** ppInstance);
	HRESULT FindAndModDataCollector(BSTR szGUID, IWbemClassObject* pObj);
	HRESULT FindAndModThreshold(BSTR szGUID, IWbemClassObject* pObj);
	LPTSTR GetGUID(void);
	HRESULT AddThreshold(BSTR szParentGUID, BSTR szChildGUID);
	BOOL CalcStatistics(INSTSTRUCT *ppn, CIMTYPE type);
	BOOL ResetResetThresholdStates(void);
	BOOL GetChange(void);
	BOOL fillInPropertyStatus(LPTSTR szDTTime, LPTSTR szTime);
//	BOOL GetHMPropertyStatusInstance(PNSTRUCT *ppn, LPTSTR szTime);
//	BOOL GetHMPropertyStatusInstanceInstance(PNSTRUCT *ppn, INSTSTRUCT *pinst, LPTSTR szTime);
	HRESULT FindAndDeleteByGUID(LPTSTR pszGUID);
	HRESULT FindAndEnableByGUID(LPTSTR pszGUID, BOOL bEnable);
	HRESULT ResetState(BOOL bPreserveThresholdStates, BOOL bDoImmediate);
	HRESULT ResetStatistics(void);
	HRESULT EvaluateNow(BOOL bDoImmediate);
	virtual BOOL SetParentEnabledFlag(BOOL bEnabled);
	BOOL DeleteDEConfig(BOOL bDeleteAssocOnly=FALSE);
	BOOL DeleteDEInternal(void);
//XXX	BOOL Enable(BOOL bEnable);
	HRESULT FindAndCopyByGUID(LPTSTR pszGUID, ILIST* pConfigList, LPTSTR *pszParentGUID);
	HRESULT Copy(ILIST* pConfigList, LPTSTR pszOldParentGUID, LPTSTR pszNewParentGUID);
	CBase *GetParentPointerFromGUID(LPTSTR pszGUID);
	CBase *FindImediateChildByName(LPTSTR pszChildName);
	BOOL GetNextChildName(LPTSTR pszChildName, LPTSTR pszOutName);
	CBase *FindPointerFromName(LPTSTR pszChildName);
	HRESULT GetInstanceID(IWbemClassObject *pObj, LPTSTR *pszID);
	HRESULT CheckInstanceExistance(IWbemClassObject *pObj, LPTSTR pszInstanceID);
	HRESULT CheckActualInstanceExistance(IWbemClassObject *pObj, LPTSTR pszInstanceID);
	BOOL GetEnabledChange(void);
	BOOL SetCurrState(HM_STATE state, BOOL bCheckChanges=FALSE);
	BOOL checkTime(void);
//	BOOL ModifyAssocForMove(CBase *pNewParentBase);
	BOOL ReceiveNewChildForMove(CBase *pBase);
	BOOL DeleteChildFromList(LPTSTR pszGUID);
	BOOL FirePerInstanceEvents(void);
	long PassBackStateIfChangedPerInstance(LPTSTR pszInstName, BOOL bCombineWithStandardProperties);
	HRESULT GetHMDataCollectorPerInstanceStatusEvent(LPTSTR pszInstanceID, ACTUALINSTSTRUCT *pActualInst, long state, IWbemClassObject** ppInstance, BOOL bEventBased);
	long PassBackWorstStatePerInstance(LPTSTR pszInstName, BOOL bCombineWithStandardProperties);
	BOOL SendReminderActionIfStateIsSame(IWbemObjectSink* pActionEventSink, IWbemObjectSink* pActionTriggerEventSink, IWbemClassObject* pActionInstance, IWbemClassObject* pActionTriggerInstance, unsigned long ulTriggerStates);
	HRESULT insertNewProperty(LPTSTR pszPropertyName);
	BOOL propertyNotNeeded(LPTSTR pszPropertyName);
	BOOL ResetInst(INSTSTRUCT *pinst, CIMTYPE type);
	BOOL CheckForReset(void);
	HRESULT CheckForBadLoad(void);
};
#endif  // __DATACLTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\eqde.cpp ===
//***************************************************************************
//
//  EQDE.CPP
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: CEventQueryDataCollector class to do WMI instance collection.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "eqde.h"
#include "system.h"
extern CSystem* g_pSystem;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEventQueryDataCollector::CEventQueryDataCollector()
{
	MY_OUTPUT(L"ENTER ***** CEventQueryDataCollector...", 4);

	m_pTempSink = NULL;
	m_deType = HM_EQDE;
	m_szQuery = NULL;
	m_lNumInstancesCollected = 0;
	m_hResLast = 0;

	MY_OUTPUT(L"EXIT ***** CEventQueryDataCollector...", 4);
}

CEventQueryDataCollector::~CEventQueryDataCollector()
{
	MY_OUTPUT(L"ENTER ***** ~CEventQueryDataCollector...", 4);

	if (m_szQuery)
		delete [] m_szQuery;

	if (m_pTempSink)
	{
		m_pIWbemServices->CancelAsyncCall((IWbemObjectSink*)m_pTempSink);
		m_pTempSink->Release();
		m_pTempSink = NULL;
	}

	EnumDone();

	MY_OUTPUT(L"EXIT ***** ~CEventQueryDataCollector...", 4);
}

//
// Load a single DataCollector, and everything under it.
//
HRESULT CEventQueryDataCollector::LoadInstanceFromMOF(IWbemClassObject* pObj, CDataGroup *pParentDG, LPTSTR pszParentObjPath, BOOL bModifyPass/*FALSE*/)
{
	TCHAR szQuery[4096];
	BSTR Language = NULL;
	BSTR Query = NULL;
	BSTR bstrClassName = NULL;
	IEnumWbemClassObject *pEnumDataPoints = NULL;
	IWbemClassObject *pDataPoint = NULL;
	IWbemLocator *pLocator = NULL;
	BOOL bRetValue = TRUE;
	HRESULT hRetRes = S_OK;
	IWbemClassObject *pClass = NULL;
	IWbemQualifierSet *pQSet = NULL;
	BSTR PathToClass = NULL;
	VARIANT v;
	BSTR bstrError = NULL;
	BSTR bstrWarning = NULL;
	BSTR bstrInformation = NULL;
	BSTR bstrAuditSuccess = NULL;
	BSTR bstrAuditFailure = NULL;
	SAFEARRAY* psa = NULL;
	LCID lcID;
	VariantInit(&v);
	int i, iSize;
	CThreshold* pThreshold;

	MY_OUTPUT(L"ENTER ***** CEventQueryDataCollector::LoadInstanceFromMOF...", 4);
	iSize = m_thresholdList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		if (pThreshold->m_bValidLoad == FALSE)
			return WBEM_E_INVALID_OBJECT;
//			return S_OK;
	}

	if (m_szQuery)
	{
		delete [] m_szQuery;
		m_szQuery = NULL;
	}
	m_lNumInstancesCollected = 0;

	if (m_pTempSink)
	{
		m_pIWbemServices->CancelAsyncCall((IWbemObjectSink*)m_pTempSink);
		m_pTempSink->Release();
		m_pTempSink = NULL;
	}

	//
	// Call the base class to load the common properties. Then do the specific ones.
	//
	hRetRes = CDataCollector::LoadInstanceFromMOF(pObj, pParentDG, pszParentObjPath, bModifyPass);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) return hRetRes;

	// Get the GUID property
	hRetRes = GetStrProperty(pObj, L"Query", &m_szQuery);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

//OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
	//
	// On non-English machines we must alter the query that uses Win32_NtLogEvent class.
	// Whistler will have evnttype property that is a uint8 to use, instead of the Type property.
	//
	lcID = PRIMARYLANGID(GetSystemDefaultLCID());
	wcsncpy(szQuery, m_szQuery, 4095);
	szQuery[4095] = '\0';
	_wcsupr(szQuery);
	if (!(lcID != 0 && lcID == 0x00000009) &&
		wcsstr(szQuery, L"WIN32_NTLOGEVENT"))
	{
		// Get the class definition.
		PathToClass = SysAllocString(L"Win32_NTLogEvent");
		MY_ASSERT(PathToClass); if (!PathToClass) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		hRetRes = g_pIWbemServicesCIMV2->GetObject(PathToClass, WBEM_FLAG_USE_AMENDED_QUALIFIERS, 0, &pClass, 0);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		SysFreeString(PathToClass); PathToClass=NULL;

		hRetRes = pClass->GetPropertyQualifierSet(L"Type", &pQSet);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		pClass->Release(); pClass = NULL;

		hRetRes = pQSet->Get(L"Values", 0, &v, 0);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		psa = V_ARRAY(&v);
		BSTR *pBstr = 0;
		hRetRes = SafeArrayAccessData(psa, (void**) &pBstr);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		bstrError = pBstr[psa->rgsabound[0].lLbound];
		bstrWarning = pBstr[psa->rgsabound[0].lLbound + 1];
		bstrInformation = pBstr[psa->rgsabound[0].lLbound + 2];
		bstrAuditSuccess = pBstr[psa->rgsabound[0].lLbound + 3];
		bstrAuditFailure = pBstr[psa->rgsabound[0].lLbound + 4];

		hRetRes = ReplaceStr(&m_szQuery, L"ERROR", bstrError);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = ReplaceStr(&m_szQuery, L"WARNING", bstrWarning);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = ReplaceStr(&m_szQuery, L"INFORMATION", bstrInformation);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = ReplaceStr(&m_szQuery, L"AUDIT SUCCESS", bstrAuditSuccess);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = ReplaceStr(&m_szQuery, L"AUDIT FAILURE", bstrAuditFailure);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		SafeArrayUnaccessData(psa);
		psa = NULL;
		pQSet->Release(); pQSet = NULL;
	}
//OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO

	wcsncpy(szQuery, m_szQuery, 4095);
	szQuery[4095] = '\0';
	_wcsupr(szQuery);
	if (wcsstr(szQuery, L"INSTANCECREATIONEVENT") || wcsstr(szQuery, L"CLASSCREATIONEVENT"))
	{
		m_bInstCreationQuery = TRUE;
	}
	else
	{
		m_bInstCreationQuery = FALSE;
	}

	//
	// Setup the event query
	//
	if (m_bEnabled==TRUE && m_bParentEnabled==TRUE)
	{
		Language = SysAllocString(L"WQL");
		MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		Query = SysAllocString(m_szQuery);
		MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		hRetRes = 1;
		m_hResLast = 0;
		if (m_pIWbemServices != NULL)
		{
			m_pTempSink = new CTempConsumer(this);
			MY_ASSERT(m_pTempSink); if (!m_pTempSink) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			hRetRes = m_pIWbemServices->ExecNotificationQueryAsync(
										Language,
										Query,
										0,
										m_pContext,
										m_pTempSink);
			m_hResLast = hRetRes;
		}

		SysFreeString(Language);
		Language = NULL;
		SysFreeString(Query);
		Query = NULL;

		TCHAR buf[256];
		wsprintf(buf, L"BAD ExecNotificationQueryAsync: 0x%08x", hRetRes);
		MY_OUTPUT(buf, 4);
		if (hRetRes != WBEM_S_NO_ERROR)
		{
			if (m_pTempSink)
			{
				m_pTempSink->Release();
				m_pTempSink = NULL;
			}
		}
		else
		{
			MY_OUTPUT(L"GOOD ExecNotificationQueryAsync", 4);
		}
	}
	m_startTick = GetTickCount();
	m_lTryDelayTime = 120;

	MY_OUTPUT(L"EXIT ***** CEventQueryDataCollector::LoadInstanceFromMOF...", 4);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	if (PathToClass)
		SysFreeString(PathToClass);
	if (pClass)
		pClass->Release();
	if (pQSet)
		pQSet->Release();
	if (psa)
		SafeArrayUnaccessData(psa);
	if (Language)
		SysFreeString(Language);
	if (Query)
		SysFreeString(Query);
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

//
// Event based data collectors work in a bit different manner than the polled data collectors.
// Specifically we collect all the instances as them come into the HandleTempEvent function,
// and then at the collection interval we evaluate each one in turn, serialy, so we
// end up with a state being what ever the last event was. We also only evaluate the Thresholds
// that are across CollectionErrorCode, CollectionInstanceCount, CollectionErrorDescription.
// We thus also only end up with potentially one single event after we evaluate all that came
// in. That one can be used with action sending.
// This also means that there is no such thing as multi-instance when it comes to Event
// based data collectors.
// We will keep that one last event around forever, as it represents the last thing we reveived,
// get rid rid of it if the user does a RESET.
// We get the events into a special holding vector, and transfer them over one at a time later,
// at the interval when we do the evaluation.
//
BOOL CEventQueryDataCollector::CollectInstance(void)
{
	HRESULT hRetRes = S_OK;
	BSTR Language = NULL;
	BSTR Query = NULL;
	DWORD currTick;

	MY_OUTPUT(L"ENTER ***** CEventQueryDataCollector::CollectInstance...", 1);

	//
	// Try and fix up queries that failed to register for some reason.
	//
	if (m_bEnabled==TRUE && m_bParentEnabled==TRUE && m_pIWbemServices!=NULL &&
		m_hResLast!=0 && m_lTryDelayTime != -1)
	{
		// Do some time checking, to make a minute go by before try again in this case!
		currTick = GetTickCount();
		if ((m_lTryDelayTime*1000) < (currTick-m_startTick))
		{
			m_lTryDelayTime = -1;
			Language = SysAllocString(L"WQL");
			MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			Query = SysAllocString(m_szQuery);
			MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			m_pTempSink = new CTempConsumer(this);
			MY_ASSERT(m_pTempSink); if (!m_pTempSink) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			hRetRes = m_pIWbemServices->ExecNotificationQueryAsync(
										Language,
										Query,
										0,
										m_pContext,
										m_pTempSink);
			m_hResLast = hRetRes;

			SysFreeString(Language);
			Language = NULL;
			SysFreeString(Query);
			Query = NULL;

			TCHAR buf[256];
			wsprintf(buf, L"BAD ExecNotificationQueryAsync: 0x%08x", hRetRes);
			MY_OUTPUT(buf, 4);
			if (hRetRes != WBEM_S_NO_ERROR)
			{
				MY_HRESASSERT(hRetRes);
				if (m_pTempSink)
				{
					m_pTempSink->Release();
					m_pTempSink = NULL;
				}
			}
			else
			{
				MY_OUTPUT(L"GOOD ExecNotificationQueryAsync", 4);
			}
		}
	}

	if (m_pIWbemServices == NULL)
	{
		m_ulErrorCode = HMRES_BADWMI;
		GetLatestAgentError(HMRES_BADWMI, m_szErrorDescription);
		StoreStandardProperties();
		return FALSE;
	}

	if (m_pTempSink == NULL)
	{
		m_ulErrorCode = m_hResLast;
//		GetLatestAgentError(HMRES_OBJECTNOTFOUND, m_szErrorDescription);
		GetLatestWMIError(HMRES_OBJECTNOTFOUND, m_ulErrorCode, m_szErrorDescription);
		StoreStandardProperties();
		return FALSE;
	}

	EnumDone();

	MY_OUTPUT(L"EXIT ***** CEventQueryDataCollector::CollectInstance...", 1);
	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (Language)
		SysFreeString(Language);
	if (Query)
		SysFreeString(Query);
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

BOOL CEventQueryDataCollector::HandleTempEvent(IWbemClassObject* pObj)
{
	TCHAR szTemp[4096];
	HRESULT hRes;
	SAFEARRAY *psaNames = NULL;
	BSTR PropName = NULL;
	VARIANT vDispatch;
	VARIANT v;
	IWbemClassObject* pTargetInstance = NULL;
	INSTSTRUCT inst;
	long lIntervalCountTemp;
	long lNumInstancesCollectedTemp;
	BOOL bEmbeddedEvent;
	HOLDINSTSTRUCT holdInst;
	VariantInit(&v);
	VariantInit(&vDispatch);

	MY_OUTPUT(L"ENTER ***** CEventQueryDataCollector::HandleTempEvent...", 4);

	if (m_bValidLoad == FALSE)
		return FALSE;

	// We can't open ourselves up to an unlimited number of instances flooding in.
	// Set the message error, and when we get to the collection interval it will be sent out
	if (g_pSystem->m_lNumInstancesAccepted < m_lNumInstancesCollected)
	{
		if (m_ulErrorCode != HMRES_TOOMANYINSTS)
		{
			lIntervalCountTemp = m_lIntervalCount;
			lNumInstancesCollectedTemp = m_lNumInstancesCollected;
			ResetState(FALSE, FALSE);
			m_lIntervalCount = lIntervalCountTemp;
			m_lNumInstancesCollected = lNumInstancesCollectedTemp;
		}
		else
		{
			EnumDone();
		}
		m_ulErrorCode = HMRES_TOOMANYINSTS;
		GetLatestAgentError(HMRES_TOOMANYINSTS, m_szErrorDescription);
		StoreStandardProperties();
		return TRUE;
	}

	//
	// Decide if this is an __InstanceXXXEvent. If it is grab the TargetInstance as the object
	// to use, else we have what we need in pObj as it is.
	//
	VariantInit(&v);
	hRes = pObj->Get(L"__CLASS", 0L, &v, 0L, 0L);

	if (FAILED(hRes))
	{	// UNEXPECTED FAILURE!
		MY_OUTPUT2(L"CEQ Unexpected Error: 0x%08x\n",hRes,4);
		MY_OUTPUT2(L"m_szGUID was=%s",m_szGUID,4);
		MY_HRESASSERT(hRes);
		VariantClear(&v);
		return TRUE;
	}
	
	wcsncpy(szTemp, V_BSTR(&v), 4095);
	szTemp[4095] = '\0';
	_wcsupr(szTemp);
	if (wcsstr(szTemp, L"__INSTANCE") || wcsstr(szTemp, L"__CLASS"))
	{
		bEmbeddedEvent = TRUE;
		MY_OUTPUT(L"::HandleTempEvent -> Embedded event", 3);
	}
	else
	{
		bEmbeddedEvent = FALSE;
		m_bInstCreationQuery = TRUE;
		MY_OUTPUT(L"::HandleTempEvent -> NON Embedded event", 3);
	}
	VariantClear(&v);

	//
	//
	//
	if (bEmbeddedEvent == TRUE)
	{
		VariantInit(&vDispatch);
		if (wcsstr(szTemp, L"__INSTANCE"))
			hRes = pObj->Get(L"TargetInstance", 0L, &vDispatch, 0, 0); 
		else if (wcsstr(szTemp, L"__CLASS"))
			hRes = pObj->Get(L"TargetClass", 0L, &vDispatch, 0, 0); 
		else
			hRes = pObj->Get(L"TargetInstance", 0L, &vDispatch, 0, 0); 
		hRes = GetWbemClassObject(&pTargetInstance, &vDispatch);
	}
	else
	{
		pTargetInstance = pObj;
	}

	if (SUCCEEDED(hRes))
	{
		m_lNumInstancesCollected++;

		holdInst.pEvent = NULL;
		hRes = pTargetInstance->Clone(&holdInst.pEvent);
		if (FAILED(hRes))
		{
			MY_ASSERT(FALSE);
		}
		else
		{
			m_holdList.push_back(holdInst);
		}

		if (bEmbeddedEvent == TRUE)
		{
			pTargetInstance->Release();
		}
	}
	else
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT2(L"CEQ Unexpected Error: 0x%08x\n",hRes,4);
		MY_OUTPUT2(L"m_szGUID was=%s",m_szGUID,4);
	}

	if (bEmbeddedEvent == TRUE)
	{
		VariantClear(&vDispatch);
	}
	m_ulErrorCode = 0;

	MY_OUTPUT(L"EXIT ***** CEventQueryDataCollector::HandleTempEvent...", 4);
	return TRUE;
}

BOOL CEventQueryDataCollector::CollectInstanceSemiSync(void)
{
	MY_ASSERT(FALSE);
	return TRUE;
}

BOOL CEventQueryDataCollector::EnumDone(void)
{
	IWbemClassObject *pObj = NULL;
	BOOL bRetValue = TRUE;
	PNSTRUCT *ppn;
	INSTSTRUCT inst;
	INSTSTRUCT *pinst;
	int i, j, iSize, jSize;
	CThreshold *pThreshold;
	SAFEARRAY *psaNames = NULL;
	BSTR PropName = NULL;
	ACTUALINSTSTRUCT *pActualInst;

	CleanupSemiSync();

	// If we got any new events in this collection interval, we can dump the old one.
	if (m_holdList.size())
	{
		//
		// Now loop through and get rid of instances that are no longer around
		//
		iSize = m_pnList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<m_pnList.size());
			ppn = &m_pnList[i];
			jSize = ppn->instList.size();
			for (j = 0; j < jSize ; j++)
			{
				MY_ASSERT(j<ppn->instList.size());
				pinst = &ppn->instList[j];
				if (pinst->szCurrValue)
					delete [] pinst->szCurrValue;
				if (pinst->szInstanceID)
					delete [] pinst->szInstanceID;
				pinst->valList.clear();
			}
			ppn->instList.clear();
		}

		// Also for all thresholds under this DataCollector
		iSize = m_thresholdList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<m_thresholdList.size());
			pThreshold = m_thresholdList[i];
			pThreshold->ClearInstList();
		}

		iSize = m_actualInstList.size();
		for (i=0; i < iSize; i++)
		{
			MY_ASSERT(i<m_actualInstList.size());
			pActualInst = &m_actualInstList[i];
			if (pActualInst->szInstanceID)
				delete [] pActualInst->szInstanceID;
			if (pActualInst->pInst)
			{
				pActualInst->pInst->Release();
				pActualInst->pInst = NULL;
			}
		}
		m_actualInstList.clear();
//XXXOnce again take common code and place it in the base class!^^^^^^^^^^^^^^^^^^^^^^^^^
	}

	return TRUE;
}

BOOL CEventQueryDataCollector::CleanupSemiSync(void)
{
	m_bKeepCollectingSemiSync = FALSE;
	m_lCollectionTimeOutCount = 0;

	return TRUE;
}

BOOL CEventQueryDataCollector::EvaluateThresholds(BOOL bIgnoreReset, BOOL bSkipStatndard, BOOL bSkipOthers, BOOL bDoThresholdSkipClean)
{
	HRESULT hRes;
	LPTSTR pszID = NULL;
	TCHAR szID[32];
	TCHAR szID2[32];
	HOLDINSTSTRUCT *pHoldInst;
	int i, iSize;
	long lPrevState;
	long lNumberChanges = 0;

	// Need to keep track of the overall prev state of the DC so that DG can roll up changes
	lPrevState = m_lCurrState;

	//
	// Feed each temp event in one at a time from the special holding vector
	//
	iSize = m_holdList.size();
	if (iSize > 0)
	{
		wcscpy(m_szDTCollectTime, m_szDTCurrTime);
		wcscpy(m_szCollectTime, m_szCurrTime);
	}
//XXXIs this risky???We do not need to do anything because we did not receive any events!!!
//	if (iSize==0)
//		return TRUE;
	for (i=0; i<iSize; i++)
	{
		m_lPrevState = m_lCurrState;
		m_lNumberChanges = 0;
//		m_ulErrorCode = 0;
//		m_szErrorDescription[0] = '\0';

		MY_ASSERT(i<m_holdList.size());
		pHoldInst = &m_holdList[i];
		MY_ASSERT(pHoldInst->pEvent);

		//
		// Figure out the key property name to identify instances with.
		//
		if (m_bInstCreationQuery == TRUE)
		{
			wsprintf(szID, L"(%5d)", i);
		}
		else
		{
			hRes = GetInstanceID(pHoldInst->pEvent, &pszID);
			if (hRes != S_OK)
			{
				m_ulErrorCode = hRes;
				GetLatestWMIError(HMRES_OBJECTNOTFOUND, hRes, m_szErrorDescription);
				StoreStandardProperties();
				EnumDone();
				return FALSE;
			}
			wsprintf(szID2, L"%s(%5d)", pszID, i);
			wcscpy(szID, szID2);
			delete [] pszID;
		}

		//
		// Mark instances need to keep around, and add new ones
		//
		hRes = CheckInstanceExistance(pHoldInst->pEvent, szID);
		if (hRes != S_OK)
		{
			m_ulErrorCode = hRes;
			GetLatestWMIError(HMRES_OBJECTNOTFOUND, hRes, m_szErrorDescription);
			StoreStandardProperties();
			EnumDone();
			return FALSE;
		}

		StoreValues(pHoldInst->pEvent, szID);

		CDataCollector::EvaluateThresholds(bIgnoreReset, TRUE, FALSE, TRUE);
		SendEvents();
		lNumberChanges += m_lNumberChanges;

		if (pHoldInst->pEvent)
		{
			pHoldInst->pEvent->Release();
			pHoldInst->pEvent = NULL;
		}

		// Keep clearing out the event info, unless it is the last one, which we
		// want to keep around, as it represents the final state.
		if (i < iSize-1)
		{
			EnumDone();
		}
	}
	m_holdList.clear();

	// Need to be able to independantly send out events for standard property violations
	m_lPrevState =	lPrevState;
	m_lCurrState =	lPrevState;
	m_lNumberChanges = 0;
//	m_ulErrorCode = 0;
//	m_szErrorDescription[0] = '\0';
	StoreStandardProperties();
	CDataCollector::EvaluateThresholds(bIgnoreReset, FALSE, TRUE, TRUE);
	SendEvents();
	lNumberChanges += m_lNumberChanges;
	FireStatisticsEvent();

	// Need to keep track of the overall prev state of the DC so that DG can roll up changes
	m_lPrevState =	lPrevState;
	m_lNumberChanges = lNumberChanges;

	return TRUE;
}

BOOL CEventQueryDataCollector::SetParentEnabledFlag(BOOL bEnabled)
{
	BSTR Language = NULL;
	BSTR Query = NULL;
	HRESULT hRetRes = S_OK;

	CDataCollector::SetParentEnabledFlag(bEnabled);

	m_lNumInstancesCollected = 0;

	if (m_pTempSink)
	{
		m_pIWbemServices->CancelAsyncCall((IWbemObjectSink*)m_pTempSink);
		m_pTempSink->Release();
		m_pTempSink = NULL;
	}

	//
	// Setup the event query
	//
	if (m_bEnabled==TRUE && m_bParentEnabled==TRUE)
	{
		Language = SysAllocString(L"WQL");
		MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		Query = SysAllocString(m_szQuery);
		MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		hRetRes = 1;
		m_hResLast = 0;
		if (m_pIWbemServices != NULL)
		{
			m_pTempSink = new CTempConsumer(this);
			MY_ASSERT(m_pTempSink); if (!m_pTempSink) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			hRetRes = m_pIWbemServices->ExecNotificationQueryAsync(
										Language,
										Query,
										0,
										m_pContext,
										m_pTempSink);
			m_hResLast = hRetRes;
		}

		SysFreeString(Language);
		Language = NULL;
		SysFreeString(Query);
		Query = NULL;

		TCHAR buf[256];
		wsprintf(buf, L"BAD ExecNotificationQueryAsync: 0x%08x", hRetRes);
		MY_OUTPUT(buf, 4);
		if (hRetRes != WBEM_S_NO_ERROR)
		{
			if (m_pTempSink)
			{
				m_pTempSink->Release();
				m_pTempSink = NULL;
			}
		}
		else
		{
			MY_OUTPUT(L"GOOD ExecNotificationQueryAsync", 4);
		}
	}
	m_startTick = GetTickCount();
	m_lTryDelayTime = 120;

	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (Language)
		SysFreeString(Language);
	if (Query)
		SysFreeString(Query);
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\eqde.h ===
//***************************************************************************
//
//  EQDE.H
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: CEventQueryDataCollector class to do WMI instance collection.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#include "tmpcnsmr.h"

#if !defined( __EQDE_H )
#define __EQDE_H

#include "datacltr.h"

typedef struct _tag_HOLDINSTStruct
{
	IWbemClassObject* pEvent;
} HOLDINSTSTRUCT, *PHOLDINSTSTRUCT;
typedef std::vector<HOLDINSTSTRUCT, std::allocator<HOLDINSTSTRUCT> > HOLDINSTLIST;

class CEventQueryDataCollector : public CDataCollector
{
public:
	CEventQueryDataCollector();
	virtual ~CEventQueryDataCollector();

	LPTSTR m_szQuery;
	CTempConsumer* m_pTempSink;
	BOOL m_bInstCreationQuery;
	HOLDINSTLIST m_holdList;
	HRESULT m_hResLast;
	DWORD m_startTick;
	long m_lTryDelayTime;

	HRESULT LoadInstanceFromMOF(IWbemClassObject* pObj, CDataGroup *pParentDG, LPTSTR pszParentGUID, BOOL bModifyPass=FALSE);
	BOOL HandleTempEvent(IWbemClassObject* pObj);

private:
	BOOL CollectInstance(void);
	BOOL CollectInstanceSemiSync(void);
	BOOL CleanupSemiSync(void);
	BOOL EnumDone(void);
	BOOL EvaluateThresholds(BOOL bIgnoreReset, BOOL bSkipStandard, BOOL bSkipOthers, BOOL bDoThresholdSkipClean);
	BOOL SetParentEnabledFlag(BOOL bEnabled);
};
#endif  // __EQDE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\copypaste.cpp ===
//***************************************************************************
//
//  COPYPASTE.CPP
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: Copying and pasting code below. 
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#pragma warning (disable: 4786)	// exceeds 255 chars in browser info
#define _WIN32_DCOM
#include "global.h"
#include "system.h"

#define ASSERT MY_ASSERT
#define TRACE(x) MY_OUTPUT(x, 4)
#include <comdef.h>
#include <wbemcli.h>
#include "SafeArray.h"
#include "StringMap.h"

// smart pointers for common WMI types
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemQualifierSet, __uuidof(IWbemQualifierSet));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));

// a bunch of constant strings. Enables us to change class names without a lot of cut 
// and paste
static const _bstr_t bstrLocalHealthMonNamespace(L"\\\\.\\ROOT\\CIMV2\\MicrosoftHealthMonitor");
static const _bstr_t bstrHealthMonNamespace(L"ROOT\\CIMV2\\MicrosoftHealthMonitor");
static const _bstr_t bstrBaseConfigurationPath(L"MicrosoftHM_Configuration");
static const _bstr_t bstrFilterToConsumerBindingClassPath(L"__FilterToConsumerBinding");
static const _bstr_t bstrEventConsumerClassPath(L"__EventConsumer");
static const _bstr_t bstrEventFilterClassPath(L"__EventFilter");
static const _bstr_t bstrActionAssocClassPath(L"MicrosoftHM_ConfigurationActionAssociation");
static const _bstr_t bstrActionConfigurationClassPath(L"MicrosoftHM_ActionConfiguration");
static const _bstr_t bstrTopPath(L"MicrosoftHM_SystemConfiguration.GUID=\"{@}\"");
static const _bstr_t bstrTopGUID(L"{@}");
static const _bstr_t bstrConfigurationAssocClassPath(L"MicrosoftHM_ConfigurationAssociation");
static const _bstr_t bstrThresholdConfigurationClassPath(L"MicrosoftHM_ThresholdConfiguration");
static const _bstr_t bstrDataCollectorConfigurationClassPath(L"MicrosoftHM_DataCollectorConfiguration");
static const _bstr_t bstrDataGroupConfigurationClassPath(L"MicrosoftHM_DataGroupConfiguration");
static const _bstr_t bstrSystemConfigurationClassPath(L"MicrosoftHM_SystemConfiguration");
static const _bstr_t strLanguage(L"WQL");
static const _bstr_t MOFFileHeader1( 
	L"////////////////////////////////////////////////////////\n"
	L"//	Automatically generated Health Monitor MOF dump\n"
	L"//	Parent Root = "
	);
static const _bstr_t MOFFileHeader2( 
	L"\n"
	L"////////////////////////////////////////////////////////\n"
	L"\n"
	L"#pragma autorecover\n"
	L"#pragma namespace(\"\\\\\\\\.\\\\ROOT\\\\CIMV2\\\\MicrosoftHealthMonitor\")\n"
	L"\n"
	L"\n");

// get a BSTR-valued property
static HRESULT GetStringProperty (IWbemClassObject* pObj, 
						   LPCWSTR lpszPropName, 
						   _bstr_t& bstr)
{
	_variant_t var;
	CHECK_ERROR (pObj->Get(lpszPropName, 0, &var, NULL, NULL));
	if (V_VT(&var) != VT_BSTR)
	{
		CHECK_ERROR (E_INVALIDARG); // bad data type.  should never happen
	}
	CHECK_ERROR (SafeAssign (bstr, var));
	return S_OK;
}

static HRESULT GetUint32Property (IWbemClassObject* pObj, 
						   LPCWSTR lpszPropName, 
						   DWORD& val)
{
	_variant_t var;
	CHECK_ERROR (pObj->Get(lpszPropName, 0, &var, NULL, NULL));
	if (V_VT(&var) != VT_I4)
	{
		CHECK_ERROR (E_INVALIDARG); // bad data type.  should never happen
	}
	val = V_I4(&var);
	return S_OK;
}


// get a BSTR-valued property
static HRESULT PutStringProperty (IWbemClassObject* pObj, 
						   LPCWSTR lpszPropName, 
						   const _bstr_t& bstr)
{
	_variant_t var;				
	CHECK_ERROR (SafeAssign (var, bstr));
	CHECK_ERROR (pObj->Put(lpszPropName, 0, &var, NULL));
	return S_OK;
}

static HRESULT CompareInstances (IWbemClassObject* pObj1, IWbemClassObject* pObj2, bool& bMatch)
{
	// compare all the properties of these two instances
	if (pObj1 == NULL || pObj2 == NULL)
		return WBEM_E_INVALID_PARAMETER;
	
	HRESULT hr = S_OK;
	CHECK_ERROR (pObj1->BeginEnumeration (WBEM_FLAG_NONSYSTEM_ONLY));

	while (TRUE)
	{
		// get property.
		BSTR bstrVal;
		hr = pObj1->Next(0, &bstrVal, NULL, NULL, NULL );
		if (hr == WBEM_S_NO_MORE_DATA)
			break;		// BREAK OUT!!!! We're done.
		else if (FAILED (hr))
			break; 
		_bstr_t bstrName(bstrVal, false);	// false for attach and auto-free

		_variant_t var1, var2;
		CIMTYPE eType1, eType2;
		if (pObj1->Get(bstrName, 0, &var1, &eType1, NULL))
			break; 
		if (pObj2->Get(bstrName, 0, &var2, &eType2, NULL))
			break; 
		if (eType1 != eType2)
		{
			bMatch = false;	// differnet CIM types
			break; 
		}
		else if (var1 != var2)
		{
			bMatch = false;	// differnet values
			break; 
		}
	}
	
	if (FAILED (hr))
	{
		pObj1->EndEnumeration ();	// clean up just in case
		CHECK_ERROR (hr);
	}

	CHECK_ERROR	(pObj1->EndEnumeration ());

	bMatch = true;
	return WBEM_S_NO_ERROR;
}

// Same as Clone(), but works across machine boundaries.  Clone()
// only works on local instances.
static HRESULT CopyInstance (IWbemServicesPtr& WMI,
							  IWbemClassObjectPtr& pObj1, 
							  IWbemClassObjectPtr& pObj2)
{
	// first, get the class so that we can spawn a new instance
	_bstr_t bstrClass;
	IWbemClassObjectPtr smartpClass;
	CHECK_ERROR (GetStringProperty(pObj1, L"__CLASS", bstrClass));
	CHECK_ERROR (WMI->GetObject (bstrClass, 
				WBEM_FLAG_RETURN_WBEM_COMPLETE, 
				NULL, 
				&smartpClass, 
				NULL));
	CHECK_ERROR (smartpClass->SpawnInstance (0, &pObj2));

	HRESULT hr = S_OK;
	CHECK_ERROR (pObj1->BeginEnumeration (WBEM_FLAG_NONSYSTEM_ONLY));

	while (TRUE)
	{
		// get property name
		BSTR bstrVal;
		hr = pObj1->Next(0, &bstrVal, NULL, NULL, NULL );
		if (hr == WBEM_S_NO_MORE_DATA)
			break;		// BREAK OUT!!!! We're done.
		else if (FAILED (hr))
			break; 
		_bstr_t bstrName(bstrVal, false);	// false for attach and auto-free

		// get the property on one and copy to the other
		_variant_t var;
		CIMTYPE eType1;
		if (FAILED(hr = pObj1->Get(bstrName, 0, &var, &eType1, NULL)))
			break; 
		if (FAILED(hr = pObj2->Put(bstrName, 0, &var, 0)))
			break; 
	}
	
	if (FAILED (hr))
	{
		pObj1->EndEnumeration ();	// clean up just in case
		CHECK_ERROR (hr);
	}

	CHECK_ERROR	(pObj1->EndEnumeration ());
	return WBEM_S_NO_ERROR;
}


//
//	escape a string so that it's OK to put in an object path
//
static HRESULT WmiPathEscape (LPCWSTR pszPath, _bstr_t& ResultPath)
{
	// first, allocate a string twice as big.  (escaping never exceeds 2x size)
	BSTR bstr = ::SysAllocStringLen (NULL, wcslen(pszPath)*2);
	if (bstr == NULL)
		CHECK_ERROR (E_OUTOFMEMORY);
	WCHAR *pDest = bstr;
	for (LPCWSTR pSrc = pszPath; *pSrc; pSrc++)
	{
		if (*pSrc == L'\"' || *pSrc == L'\\')
		{
			*pDest++ = L'\\';
		}
		*pDest++ = *pSrc;	// unescaped char
	}
	*pDest++ = 0;	// null-terminate
	CHECK_ERROR (SafeAssign(ResultPath, bstr));
	::SysFreeString(bstr);	// free this now that copy is made
	return S_OK;
}

static HRESULT GetAssociationPath (_bstr_t& strAssocPath,
							LPCWSTR szAssocClass,
							LPCWSTR szInstance1Role,
							LPCWSTR szInstance1Path,
							LPCWSTR szInstance2Role,
							LPCWSTR szInstance2Path)
{
	try
	{
		// first, escape the object paths so that they can be encased in 
		// other object paths
		_bstr_t bstrInstance1Path, bstrInstance2Path;
		CHECK_ERROR (WmiPathEscape(szInstance1Path, bstrInstance1Path))
		CHECK_ERROR (WmiPathEscape(szInstance2Path, bstrInstance2Path))
		
		// now construct the association path
		strAssocPath = szAssocClass;
		strAssocPath += L".";
		strAssocPath += szInstance1Role;
		strAssocPath += L"=\"";
		strAssocPath += bstrInstance1Path;
		strAssocPath += L"\",";
		strAssocPath += szInstance2Role;
		strAssocPath += L"=\"";
		strAssocPath += bstrInstance2Path;
		strAssocPath += L"\"";
	}
	catch (_com_error e)
	{
		CHECK_ERROR (e.Error());
	}
	return S_OK;
}

// OK, it's an action.  There are four instances: 
// This method saves them all.
// a) The ConfigurationActionAssication, between the HM object and the action
// b) the action configuration itself
// c) The event filter
// d) the event consumer
// e) the filter-to-consumer binding
static HRESULT AddActionOtherInstances (
	SafeArrayOneDimWbemClassObject& saInstances,
	int& nArrayIndex,
	IWbemClassObjectPtr& smartpParent,
	IWbemServices* WMI
	)
{
	IWbemClassObjectPtr smartpFilter, smartpConsumer, smartpFilterToConsumerBinding;
	HRESULT hr;
	ULONG nRet;

	// First, build paths for the filter & consumer
	_bstr_t bstrActionGUID, bstrConsumerPath, bstrFilterPath;
	CHECK_ERROR(GetStringProperty(smartpParent, L"GUID", bstrActionGUID));
	CHECK_ERROR(GetStringProperty(smartpParent, L"EventConsumer", bstrConsumerPath));
	try
	{
		// The Filter
		bstrFilterPath = L"__EventFilter.Name=\"";
		bstrFilterPath += bstrActionGUID;
		bstrFilterPath += "\"";
	}
	catch (_com_error e)
	{
		CHECK_ERROR (e.Error());	// out of memory
	}

	// ok, now that we've got the paths, let's get the objects themselves
	CHECK_ERROR (WMI->GetObject (bstrConsumerPath, 
				WBEM_FLAG_RETURN_WBEM_COMPLETE, 
				NULL, 
				&smartpConsumer, 
				NULL));
	CHECK_ERROR (WMI->GetObject (bstrFilterPath, 
				WBEM_FLAG_RETURN_WBEM_COMPLETE, 
				NULL, 
				&smartpFilter, 
				NULL));

	// Now query to get the Filter To Consumer Binding
	_bstr_t strQueryFTCB;
	try
	{
		strQueryFTCB = L"REFERENCES OF {";
		strQueryFTCB += bstrFilterPath;
		strQueryFTCB += "} WHERE ResultClass = ";
		strQueryFTCB += bstrFilterToConsumerBindingClassPath;
	}
	catch (_com_error e)
	{
		CHECK_ERROR (e.Error());	// out of memory
	}

	// now get the Filter-to-consumer binding from WMI.
	// note that this must return a valid instance or it's an error!
	IEnumWbemClassObjectPtr pEnumFTCB;
	CHECK_ERROR (WMI->ExecQuery (strLanguage, strQueryFTCB, 0, NULL, &pEnumFTCB));
	hr = pEnumFTCB->Next(5000, 1, &smartpFilterToConsumerBinding, &nRet);
	if (FAILED(hr))
		CHECK_ERROR (hr);	// either S_FALSE (none found) or error
	if (hr == WBEM_S_TIMEDOUT)
		CHECK_ERROR (RPC_E_TIMEOUT);	// it timed out.  bad!
	if (hr != WBEM_S_NO_ERROR)
		CHECK_ERROR (E_FAIL);	// no associations found.  bad!

	// now add'em to the array
	CHECK_ERROR (saInstances.SafePutElement(nArrayIndex++, smartpConsumer));
	CHECK_ERROR (saInstances.SafePutElement(nArrayIndex++, smartpFilter));
	CHECK_ERROR (saInstances.SafePutElement(nArrayIndex++, smartpFilterToConsumerBinding));
	return S_OK;
}

static HRESULT BuildInstancesArray (
	SafeArrayOneDimWbemClassObject& saInstances,
	int& nArrayIndex,
	IWbemClassObjectPtr& smartpParent,
	IWbemServices* WMI,
	bool bCopyActionsOnly = false, // only copy the actions; nothing more
	bool bFirstTime = true	// recursion?
	)
{
	ULONG nRet;
	HRESULT hr;

	ASSERT (smartpParent != NULL);
	_bstr_t bstrParentPath;
	CHECK_ERROR (GetStringProperty (smartpParent, L"__RELPATH", bstrParentPath));

	// Next, deal with children.  Depending on what kind of 
	// configuration class this is, we respond differently
	_bstr_t bstrClass;
	bool bCanHaveChildren = false;
	if (bCopyActionsOnly)
	{
		bCanHaveChildren = true;	// get all the actions
	}
	else
	{
		CHECK_ERROR (GetStringProperty(smartpParent,L"__CLASS", bstrClass));

		// first time through, we need to store the parent object before we
		// recurse to find kids
		if (bFirstTime)
		{
			// if it's an action, store the filter, binding, etc.
			// note that we need to store these first, as the 
			// agent needs to have the configuration show up last.
			if (!_wcsicmp (bstrClass, bstrActionConfigurationClassPath))
			{
				CHECK_ERROR (AddActionOtherInstances (saInstances,
												nArrayIndex,
												smartpParent,
												WMI ));
			}

			// store the top instance
			CHECK_ERROR (saInstances.SafePutElement (nArrayIndex++, smartpParent));
		}

		if (!_wcsicmp (bstrClass, bstrActionConfigurationClassPath) || 
			!_wcsicmp (bstrClass, bstrThresholdConfigurationClassPath))
		{
			// it's a threshold or action.  There are never children.
			return WBEM_S_NO_ERROR;
		}
		else
		{
			// it may have children.  below we will recurse to handle children
			bCanHaveChildren = true;
		}
	}

	if (bCanHaveChildren)
	{
		// build the apppropriate queries to fetch the associators for 
		// this parent object. Note that there is a weird syntax for the 
		// ASSOCIATORS OF and REFERENCES OF queries which combines query 
		// clauses without using AND.  See the WMI SDK descripion of 
		// REFERENCES OF for more details.
		_bstr_t bstrQueryChildren;
		try
		{
			// all the actions
			if (bCopyActionsOnly)
			{
				bstrQueryChildren = "SELECT * FROM ";
				bstrQueryChildren += bstrActionConfigurationClassPath;
			}
			else
			{
				// all the associations referencing us
				bstrQueryChildren = L"REFERENCES OF {";
				bstrQueryChildren += bstrParentPath;
				bstrQueryChildren += "} WHERE ResultClass = ";
				bstrQueryChildren += bstrConfigurationAssocClassPath;
				bstrQueryChildren += " Role = ParentPath";
			}
		}
		catch (_com_error e)
		{
			CHECK_ERROR (e.Error());	// out of memory
		}

		IEnumWbemClassObjectPtr pEnum;
		if (FAILED (hr = WMI->ExecQuery (strLanguage, bstrQueryChildren, 0, NULL, &pEnum)))
		{
//	TRACE (L"%s\n", (LPCTSTR) bstrQueryChildren);
			if (hr != WBEM_E_NOT_FOUND) // notfound is OK-- there may be no children.  We're done.
			{
				CHECK_ERROR (hr);
			}
		}
		else	// everything is OK.  now enumerate
		{
			_bstr_t bstrParentPath, bstrChildPath;
			IWbemClassObjectPtr smartpAssocInstance, smartpInstance;
			for (	hr = pEnum->Next(5000, 1, &smartpAssocInstance, &nRet); 
					SUCCEEDED(hr) && hr == WBEM_S_NO_ERROR; 
					hr = pEnum->Next(5000, 1, &smartpAssocInstance, &nRet))
			{
				// if we are just getting the actions, 
				if (bCopyActionsOnly)
				{
					// if it's an action, store the filter, binding, etc.
					// note that we need to store these first, as the 
					// agent needs to have the configuration show up last.
					CHECK_ERROR (AddActionOtherInstances (saInstances,
													nArrayIndex,
													smartpAssocInstance,
													WMI ));
					// store the instance.  
					CHECK_ERROR (saInstances.SafePutElement (nArrayIndex++, smartpAssocInstance));

				}
				else
				{		// not only the actions
					_variant_t var;
					
					// now get the configuration instance that this association
					// instance actually points to
					CHECK_ERROR (GetStringProperty(smartpAssocInstance, 
													L"ChildPath", 
													bstrChildPath));
					CHECK_ERROR (WMI->GetObject (bstrChildPath, 
								WBEM_FLAG_RETURN_WBEM_COMPLETE, 
								NULL, 
								&smartpInstance, 
								NULL));

					// If it's an action, store the other subinstances as well
					// note that we need to store the subinstances first, as the 
					// agent needs to have the configuration show up last.
					CHECK_ERROR (GetStringProperty(smartpInstance,L"__CLASS", bstrClass));
					if (!_wcsicmp (bstrClass, bstrActionConfigurationClassPath))
					{
						CHECK_ERROR (AddActionOtherInstances (saInstances,
														nArrayIndex,
														smartpInstance,
														WMI ));
					}

					// store the instance.  
					CHECK_ERROR (saInstances.SafePutElement (nArrayIndex++, smartpInstance));

					// now put the association in the array
					CHECK_ERROR (saInstances.SafePutElement(nArrayIndex++, smartpAssocInstance));

					// now recurse to deal with *this* object's children
					// note that actions and thresholds have no kids
					if (_wcsicmp (bstrClass, bstrActionConfigurationClassPath) != 0 && 
						_wcsicmp (bstrClass, bstrThresholdConfigurationClassPath) != 0)
					{
						CHECK_ERROR (BuildInstancesArray (saInstances, 
														nArrayIndex, 
														smartpInstance, 
														WMI,
														false	// recursion!
														));
					}
				}
			}
			if (hr == WBEM_S_TIMEDOUT)
				CHECK_ERROR (RPC_E_TIMEOUT);	// it timed out.  bad!
			CHECK_ERROR (hr);
		}
	}
	return WBEM_S_NO_ERROR;
}

enum EGuidType {GUID_PLAIN, GUID_PATH, GUID_QUERY};
static HRESULT ReGuidOneProperty (IWbemClassObjectPtr& pObj, 
						LPCWSTR wszPropName, 
						StringToStringMap& GuidMap, 
						EGuidType eType)
{
	// get the current value of the property from WMI
	_variant_t var;
	CIMTYPE CimType;
	CHECK_ERROR (pObj->Get(wszPropName, 0, &var, &CimType, NULL));
	if (var.vt != VT_BSTR)
	{
		ASSERT (FALSE);
		return E_FAIL;	// bad type of prop!  
	}
	// OK, now pull out the BSTR and remove it from the variant
	_bstr_t bstrCurrentPropValue(var.bstrVal, false);
	var.Detach();

	// now locate the GUID in the string
	LPCWSTR pGuidStr;
	WCHAR szGUID[39];	// enough space to fit a GUID in Unicode
	switch (eType)
	{
	case GUID_PLAIN:
		pGuidStr = bstrCurrentPropValue;
		ASSERT (CimType == CIM_STRING);
		break;
	case GUID_PATH:
		pGuidStr = wcschr ((LPWSTR)bstrCurrentPropValue, L'{');
		ASSERT (CimType == CIM_REFERENCE);
		break;
	case GUID_QUERY:
		pGuidStr = wcschr ((LPWSTR)bstrCurrentPropValue, L'{');
		ASSERT (CimType == CIM_STRING);
		break;
	}
	if (pGuidStr == NULL)
	{
		ASSERT (FALSE);
		return E_FAIL;	// corrupt WMI value!
	}

	LPCWSTR pEndBracket = wcschr (pGuidStr, '}');
	if (pEndBracket == NULL)
	{
		ASSERT (FALSE);
		return E_FAIL;	// corrupt WMI value!
	}
	else if (pEndBracket - pGuidStr == 2 && pGuidStr[1] == '@')
	{
		return S_OK;	// it's the system configuration instance. 
						// No need to re-guid.
	}
	else if (pEndBracket - pGuidStr != 37 )
	{
		ASSERT (FALSE);
		return E_FAIL;	// corrupt WMI value!
	}
	ASSERT (pGuidStr[0] == '{');
	ASSERT (pGuidStr[37] == '}');

	// now move the string into temp storage
	wcsncpy (szGUID, pGuidStr, 38);
	szGUID[38] = 0;

	// have we seen this one?
	_bstr_t bstrGuidNew;
	bool bFound;
	CHECK_ERROR (GuidMap.Find (szGUID, bstrGuidNew, bFound));
	if (bFound)
	{
		// OK, we found this GUID there already.  Use the preset
		// replacement GUID
		wcsncpy ((LPWSTR) pGuidStr, bstrGuidNew, 38);
	}
	else
	{
		// we haven't already seen this. Generate a new GUID, add it 
		// to the map
		CGuidString strNewGuid;
		GuidMap.Add (szGUID, strNewGuid);
		wcsncpy ((LPWSTR) pGuidStr, strNewGuid, 38);
	}

	// OK, now we have a BSTR with the new GUID.
	CHECK_ERROR (PutStringProperty (pObj, wszPropName, bstrCurrentPropValue));
	return S_OK;
}

// walk through the array looking for GUID's.  When we find a GUID,
// we will check a mapping table to see if it is already mapped to another
// GUID. If it is, we will replace it and move on through the list.  If 
// it isn't in the table, we will generate a new GUID, replace the 
// one already there, and store the new GUID in the table
static HRESULT ReGuid(SafeArrayOneDimWbemClassObject& saInstances, 
				StringToStringMap& aGuidMap )
{
	HRESULT hr; 
	for ( int i = 0, nLen = saInstances.GetSize(); i < nLen; i++)
	{
		IWbemClassObjectPtr pObj;
		CHECK_ERROR (saInstances.GetElement(i, &pObj));
		ASSERT (pObj != NULL);
		// now check the class of this object.  Depending on the class type, 

		_bstr_t bstrClass, bstrPath;
		CHECK_ERROR (GetStringProperty (pObj, L"__RELPATH", bstrPath))
		CHECK_ERROR (GetStringProperty (pObj, L"__CLASS", bstrClass));

		// now re-guid the appropriate properties
		if (!_wcsicmp(bstrClass, bstrActionConfigurationClassPath))
		{
			hr = ReGuidOneProperty (pObj, L"GUID", aGuidMap, GUID_PLAIN);
			hr = ReGuidOneProperty (pObj, L"EventConsumer", aGuidMap, GUID_PATH);
		}
		else if (pObj->InheritsFrom(bstrBaseConfigurationPath)==S_OK)
		{
			// it's a configuration class, but not action config.  Use the GUID property
			hr = ReGuidOneProperty (pObj, L"GUID", aGuidMap, GUID_PLAIN);
		}
		else if (pObj->InheritsFrom(bstrEventConsumerClassPath)==S_OK)
		{
			hr = ReGuidOneProperty (pObj, L"Name", aGuidMap, GUID_PLAIN);
		}
		else if (pObj->InheritsFrom(L"__EventFilter")==S_OK)
		{
			hr = ReGuidOneProperty (pObj, L"Name", aGuidMap, GUID_PLAIN);
			hr = ReGuidOneProperty (pObj, L"Query", aGuidMap, GUID_QUERY);
		}
		else if (!_wcsicmp(bstrClass, bstrFilterToConsumerBindingClassPath))
		{
 			hr = ReGuidOneProperty (pObj, L"Consumer", aGuidMap, GUID_PATH);
			hr = ReGuidOneProperty (pObj, L"Filter", aGuidMap, GUID_PATH);
		}
		else if (!_wcsicmp(bstrClass, bstrActionAssocClassPath))
		{
			hr = ReGuidOneProperty (pObj, L"ParentPath", aGuidMap, GUID_PATH);
			hr = ReGuidOneProperty (pObj, L"ChildPath", aGuidMap, GUID_PATH);
			hr = ReGuidOneProperty (pObj, L"EventFilter", aGuidMap, GUID_PATH);
			hr = ReGuidOneProperty (pObj, L"Query", aGuidMap, GUID_QUERY);
		}
		else if (!_wcsicmp(bstrClass, bstrConfigurationAssocClassPath))
		{
			hr = ReGuidOneProperty (pObj, L"ParentPath", aGuidMap, GUID_PATH);
			hr = ReGuidOneProperty (pObj, L"ChildPath", aGuidMap, GUID_PATH);
		}
		else
		{
			ASSERT (FALSE);	// should never happen. it's an invalid class.
		}
		CHECK_ERROR (hr);
	}
	return S_OK;
}

//
//	Detect all actions with duplicate names between the clipboard and the target
//	Fill up a GUID map with the dupes
//
static HRESULT FillActionGuidMap(	SafeArrayOneDimWbemClassObject& saInstances, 
							StringToStringMap& ActionNameToGuidMap, 
							StringToStringMap& GuidMap)
{
	for ( int i = 0, nLen = saInstances.GetSize(); i < nLen; i++)
	{
		IWbemClassObjectPtr pObj;
		CHECK_ERROR (saInstances.GetElement(i, &pObj));
		ASSERT (pObj != NULL);

		_bstr_t bstrClass, bstrPath;
		CHECK_ERROR (GetStringProperty (pObj, L"__CLASS", bstrClass));

		// now re-guid the appropriate properties
		if (_wcsicmp(bstrClass, bstrActionConfigurationClassPath) != 0)
			continue;	// we only care about actions!

		_bstr_t bstrGuidCurrentAction, bstrName;		
		bool bFound = false;
		CHECK_ERROR (GetStringProperty(pObj, L"Name", bstrName));
		CHECK_ERROR (ActionNameToGuidMap.Find(bstrName, bstrGuidCurrentAction, bFound));
		if (bFound)
		{
			// there's a duplicate!  We'll store a mapping of the GUID in
			// the clipboard's instance to the duplicate action GUID.
			_bstr_t bstrGUID;		
			CHECK_ERROR (GetStringProperty (pObj, L"GUID", bstrGUID));
			CHECK_ERROR (GuidMap.Add(bstrGUID, bstrGuidCurrentAction));
		}
	}
	return S_OK;
}

static HRESULT Copy(LPTSTR szSourceComputer, 
			 LPTSTR szGUID, 
			 bstr_t& bstrParentGUID,	// [out]
			 SafeArrayOneDimWbemClassObject& saInstances,
			 CSystem& System)
{
	// impersonate the caller.  Important since we're now calling into
	// WMI and need to make sure caller is allowed
	CHECK_ERROR(CoImpersonateClient());

	_bstr_t bstrNamespace = L"\\\\";
	bstrNamespace += szSourceComputer;
	bstrNamespace += L"\\";
	bstrNamespace += bstrHealthMonNamespace;

	IWbemServicesPtr WMI = g_pIWbemServices;
//	IWbemLocatorPtr WMILocator;
//	IWbemServicesPtr WMI;
//	CHECK_ERROR (WMILocator.CreateInstance(__uuidof(WbemLocator),NULL));
//	CHECK_ERROR (WMILocator->ConnectServer (bstrNamespace, 
//												NULL, NULL, NULL, 0, NULL, NULL, 
//												&WMI));
	_bstr_t bstrPath; 
	try
	{
		bstrPath = bstrBaseConfigurationPath;
		bstrPath += L".GUID=\"";
		bstrPath += szGUID;
		bstrPath += L"\"";
	}
	catch (_com_error e)
	{
		CHECK_ERROR (e.Error());	// out of memory
	}

	IWbemClassObjectPtr smartpObj;
	HRESULT hr = WMI->GetObject (bstrPath, 
				WBEM_FLAG_RETURN_WBEM_COMPLETE, 
				NULL, 
				&smartpObj, 
				NULL);
	if (hr == WBEM_E_NOT_FOUND)
	{
		return WBEM_E_NOT_FOUND;	// it's not there
	}
	CHECK_ERROR (hr);

	// if it's a single action, then we fake the parent to be the system instance
	// same if it's the entire system that we're copying
	_bstr_t bstrClass;
	CHECK_ERROR (GetStringProperty(smartpObj, L"__CLASS", bstrClass));
	if (!_wcsicmp (bstrClass, bstrActionConfigurationClassPath)
		|| !_wcsicmp (bstrClass, bstrSystemConfigurationClassPath))
	{
		try
		{	
			bstrParentGUID = bstrTopGUID;
		}
		catch (_com_error e)
		{
			CHECK_ERROR (e.Error());	// out of memory
		}
	}
	else
	{
		// build the query to find our parent
		_bstr_t bstrParentQuery;
		try
		{
			bstrParentQuery = L"ASSOCIATORS OF {";
			bstrParentQuery += bstrPath;
			bstrParentQuery += L"} WHERE"; 
			bstrParentQuery += L" ResultRole = ParentPath";
		}
		catch (_com_error e)
		{
			CHECK_ERROR (e.Error());	// out of memory
		}

		// now exec the query to fetch the parent
		ULONG nRet;
		IEnumWbemClassObjectPtr pEnumParent;
		IWbemClassObjectPtr smartpParent;
		CHECK_ERROR (WMI->ExecQuery (strLanguage, bstrParentQuery, 0, NULL, &pEnumParent));
		hr = pEnumParent->Next(5000, 1, &smartpParent, &nRet);
		if (FAILED(hr))
			CHECK_ERROR (hr);
		if (hr == WBEM_S_TIMEDOUT)
			CHECK_ERROR (RPC_E_TIMEOUT);	// it timed out.  bad!
		if (hr != WBEM_S_NO_ERROR)
			CHECK_ERROR (E_FAIL);	// no parent found.  bad!
		CHECK_ERROR (GetStringProperty(smartpParent, L"GUID", bstrParentGUID));
	}

	// now actually go get the array
	int nArrayIndex = 0;
	CHECK_ERROR (saInstances.Clear());
	CHECK_ERROR (saInstances.Create());

	// now build an array of all the instances underneath this one
	CHECK_ERROR (BuildInstancesArray (saInstances,
									nArrayIndex,
									smartpObj,
									WMI));

	// now, if this was the entire system that we were copying, copy the
	// unattached actions as well.
	if (!_wcsicmp (bstrClass, bstrSystemConfigurationClassPath))
	{
		// now add all the actions to the array
		CHECK_ERROR (BuildInstancesArray (saInstances,
										nArrayIndex,
										smartpObj,
										WMI,
										true));
	}

	CHECK_ERROR (saInstances.Resize(nArrayIndex));

	return S_OK;
}

// the input is an array of instances to be added, in order.  Add them.
// Note that actions will be compared to actions currently on the box.
static HRESULT Paste(LPCTSTR pszTargetComputer,
				LPCTSTR pszTargetParentGUID, 
				LPCTSTR pszOriginalComputer, 
				LPCTSTR pszOriginalParentGUID, 
				SAFEARRAY* psa, 
				BOOL bForceReplace,
				CSystem& System)
{
	// impersonate the caller.  Important since we're now calling into
	// WMI and need to make sure caller is allowed
	CHECK_ERROR(CoImpersonateClient());

	_bstr_t bstrNamespace = L"\\\\";
	bstrNamespace += pszTargetComputer;
	bstrNamespace += L"\\";
	bstrNamespace += bstrHealthMonNamespace;

	TCHAR szComputerName[1024];
	DWORD dwSize = 1024;
	::GetComputerName(szComputerName, &dwSize);
	if (!_wcsicmp(szComputerName, pszTargetComputer))
		pszTargetComputer = L".";
	if (!_wcsicmp(szComputerName, pszOriginalComputer))
		pszOriginalComputer = L".";

	IWbemServicesPtr WMI = g_pIWbemServices;
	HRESULT hr;
//  Commented-out code below was used when we were not part of the agent.
//	IWbemLocatorPtr WMILocator;
//	IWbemServicesPtr WMI;
//	CHECK_ERROR (WMILocator.CreateInstance(__uuidof(WbemLocator),NULL));
//	CHECK_ERROR (WMILocator->ConnectServer (bstrNamespace, 
//												NULL, NULL, NULL, 0, NULL, NULL, 
//												&WMI));
	// if we didn't create the array, then don't 
	// bother proceeding
	VARIANT varSA;
	varSA.vt = VT_ARRAY | VT_UNKNOWN;
	varSA.parray = psa;
	if (!SafeArrayOneDimWbemClassObject::IsValid(varSA))
		CHECK_ERROR (E_INVALIDARG); 

	// since we know that it's one of ours, and because our SafeArray wrapper
	// is the same length as a regular safe array, we can cast it.
	SafeArrayOneDimWbemClassObject& saInstancesOriginal = (SafeArrayOneDimWbemClassObject&)varSA;

	// if we're pasting in the same parent, then the behavior should
	// match Windows, where you add a " (2)" to the name and make a copy
	bool bPasteOnSameMachine = !_wcsicmp (pszTargetComputer,pszOriginalComputer);
	bool bPasteInSameFolder = bPasteOnSameMachine && 
			!_wcsicmp (pszTargetParentGUID, pszOriginalParentGUID);

	_bstr_t bstrParentRelPath; 
	try
	{
		bstrParentRelPath = bstrBaseConfigurationPath;
		bstrParentRelPath += L".GUID=\"";
		bstrParentRelPath += pszTargetParentGUID;
		bstrParentRelPath += L"\"";
	}
	catch (_com_error e)
	{
		CHECK_ERROR (e.Error());	// out of memory
	}
	
	// Pasting Algorithm
	// ==========================================================
	// 1. If child with same name already exists in parent: If bOverwrite = TRUE, 
	//		delete the other guy.  If bOverwrite = FALSE, return an error.
	// 2. If actions with same name but *different* contents already exists in parent:
	//		If bOverwrite = TRUE, delete the other actions.  If bOverwrite = FALSE,
	//		return an error.
	// 3. If actions with same name and *same* contents already exists in parent, 
	//		reassign the to-be-pasted GUID's to match the target. 
	// 4. Now simply Put each member of the array.
	//===========================================================

	// fetch this parent instance
	IWbemClassObjectPtr smartpParentInstance;
	CHECK_ERROR (WMI->GetObject (bstrParentRelPath, 
					WBEM_FLAG_RETURN_WBEM_COMPLETE, 
					NULL, 
					&smartpParentInstance, 
					NULL));
	// get the full, normalized path
	CHECK_ERROR (GetStringProperty(smartpParentInstance, L"__RELPATH", bstrParentRelPath));

	// First, get the top instance of the array.  This is the parent
	IWbemClassObjectPtr smartpTopInstance;
	CHECK_ERROR (saInstancesOriginal.GetElement (0, &smartpTopInstance));
	int nTopIndex = 0;

	// now get the name of that top instance
	_bstr_t bstrTopInstanceName, bstrTopInstanceClass;
	CHECK_ERROR (GetStringProperty(smartpTopInstance, L"__CLASS", bstrTopInstanceClass));
	if (bstrTopInstanceClass == bstrSystemConfigurationClassPath)
	{
		// we cannot (yet) paste the entire system
		CHECK_ERROR (E_INVALIDARG);
	}

	// now see if we're only copying actions-- which will be the case if an 
	// action (or the filter, binding, etc.) is first on the list of instances 
	// coming back from the Copy command.
	// BUGBUG: need to do something better than simply looking for the string
	// "Consumer" below-- not all event consumers will contain that string!
	bool bIsActionTopInstance = 
			bstrTopInstanceClass == bstrActionConfigurationClassPath 
			|| bstrTopInstanceClass == bstrFilterToConsumerBindingClassPath
			|| wcsstr ((LPCTSTR) bstrTopInstanceClass, L"Consumer") != NULL
			|| bstrTopInstanceClass == bstrEventFilterClassPath;

	if (bIsActionTopInstance)
	{
		// we need to find the name of the action.  But the action is not on top-- it could
		// be any of the top 4 instances (action config, filter, consumer or binding).  So go look.
		// we've already checked the zeroth, so we can start at 1.
		for (int i = 1; i < 4; i++)
		{
			CHECK_ERROR (saInstancesOriginal.GetElement (i, &smartpTopInstance));
			CHECK_ERROR (GetStringProperty(smartpTopInstance, L"__CLASS", bstrTopInstanceClass));
			if (bstrTopInstanceClass == bstrActionConfigurationClassPath)
			{
				// found it!  we will get the name
				nTopIndex = i;
				break;
			}
		}
		if (i == 4)
		{
			CHECK_ERROR (E_INVALIDARG);	// uh-oh.  the instance array was corrupted.
		}
	}

	// finally, get the name of the instance
	CHECK_ERROR (GetStringProperty(smartpTopInstance, L"Name", bstrTopInstanceName));

	// Build a query to look for siblings in the new parent
	_bstr_t bstrQueryChildren;
	try
	{
		if (bIsActionTopInstance)
		{
			// for actions, there is no parent.  Just list all actions
			bstrQueryChildren = L"SELECT * FROM MicrosoftHM_ActionConfiguration";
		}
		else
		{
			// first, make a query for get kids of this parent
			bstrQueryChildren = L"ASSOCIATORS OF {";
			bstrQueryChildren += bstrParentRelPath;
			bstrQueryChildren += L"} WHERE"; 
			bstrQueryChildren += L" ResultRole = ChildPath";
		}
	}
	catch (_com_error e)
	{
		CHECK_ERROR (e.Error());	// out of memory
	}

	// now execute this query. Look for siblings with matching (i.e. conflicting) names
	StringToStringMap TopLevelNameConflictMap;
	_bstr_t bstrConflictGUID;
	IEnumWbemClassObjectPtr pEnum;
//	TRACE (L"%s\n", (LPCTSTR) bstrQueryChildren);
	if (FAILED (hr = WMI->ExecQuery (strLanguage, bstrQueryChildren, 0, NULL, &pEnum)))
	{
//		TRACE (L"%s\n", (LPCTSTR) bstrQueryChildren);
		if (hr != WBEM_E_NOT_FOUND) // notfound is OK-- there may be no children.  We're done.
		{
			CHECK_ERROR (hr);
		}
	}
	else
	{
		_bstr_t bstrChildName;
		IWbemClassObjectPtr smartpInstance;
		ULONG nRet;
		for (	hr = pEnum->Next(5000, 1, &smartpInstance, &nRet); 
				SUCCEEDED(hr) && hr == WBEM_S_NO_ERROR; 
				hr = pEnum->Next(5000, 1, &smartpInstance, &nRet))
		{
			_bstr_t bstrChildName, bstrChildClass;
			CHECK_ERROR (GetStringProperty(smartpInstance, L"Name", bstrChildName));
			CHECK_ERROR (GetStringProperty(smartpInstance, L"__CLASS", bstrChildClass));

			// if this child is an action, then the only case where we care about 
			// conflicts is in the top-level.  Otherwise, the actions are not really
			// "children" (they're just associated via the ConfigActionAssociation class)
			// so we can ignore them.  But if this is an action as the
			// top instance, you bet we want to check for conflicts!
			if (!bIsActionTopInstance && (bstrChildClass == bstrActionConfigurationClassPath))
				continue;

			// store this for later, in case we have to rename the top item.
			if (bPasteInSameFolder)
				CHECK_ERROR(TopLevelNameConflictMap.Add(bstrChildName, L"NotUsed"));

			// check for conflict
			if (!_wcsicmp (bstrChildName, bstrTopInstanceName))
			{
				CHECK_ERROR (GetStringProperty(smartpInstance, L"GUID", bstrConflictGUID));
				if (!bPasteInSameFolder)
				{
					// uh, oh. We have a name conflict.  Depending on whether the 
					// user wants to perform any overwrites, we will either have to 
					// delete the conflicting one or return an error.
					if (bForceReplace)
					{
						TRACE(L"Paste: Instance Name Conflict.  We will delete the conflicting one");
						break;
					}
					else
					{
						TRACE(L"Paste: Instance Name Conflict.  Returning an error.");
						return WBEM_E_ALREADY_EXISTS;
					}
				}
			}
		}
		if (hr == WBEM_S_TIMEDOUT)
			CHECK_ERROR (RPC_E_TIMEOUT);	// it timed out.  bad!
		CHECK_ERROR (hr);
	}

	// OK, Now build a map of the names of actions already on the target
	// and their GUID's
	try
	{
		bstrQueryChildren = L"SELECT * FROM ";
		bstrQueryChildren += bstrActionConfigurationClassPath;
	}
	catch (_com_error e)
	{
		CHECK_ERROR (e.Error());	// out of memory
	}

	// we will store a hashtable of mapping action names to their
	// GUID's.  This will help us in re-GUIDing and in identifying conflicts.
	StringToStringMap ActionNameToGuidMap;

	// now execute this query
	if (FAILED (hr = WMI->ExecQuery (strLanguage, bstrQueryChildren, 0, NULL, &pEnum)))
	{
//		TRACE (L"%s\n", (LPCTSTR) bstrQueryChildren);
		if (hr != WBEM_E_NOT_FOUND) // notfound is OK-- there may be no children.  We're done.
		{
			CHECK_ERROR (hr);
		}
	}
	else
	{
		_bstr_t bstrChildName;
		IWbemClassObjectPtr smartpInstance;
		ULONG nRet;
		for (	hr = pEnum->Next(5000, 1, &smartpInstance, &nRet); 
				SUCCEEDED(hr) && hr == WBEM_S_NO_ERROR; 
				hr = pEnum->Next(5000, 1, &smartpInstance, &nRet))
		{
			_bstr_t bstrActionName, bstrActionGUID;
			CHECK_ERROR (GetStringProperty(smartpInstance, L"Name", bstrActionName));
			CHECK_ERROR (GetStringProperty(smartpInstance, L"GUID", bstrActionGUID));
			CHECK_ERROR (ActionNameToGuidMap.Add(bstrActionName, bstrActionGUID));
		}
	}

	// OK, now we will make a copy of the array.
	bool bAlreadyFound = false;
	SafeArrayOneDimWbemClassObject saInstancesNew;
	CHECK_ERROR (saInstancesNew.Create());
	for (int i = 0, nLen = saInstancesOriginal.GetSize(); i < nLen; i++)
	{
		IWbemClassObjectPtr smartpInstance;
		CHECK_ERROR (saInstancesOriginal.GetElement (i, &smartpInstance));
		
		// make a copy & store it.  Note that it's a no-no to take instances
		// from one machine and PutInstance them on another machine-- they will
		// fail intermittently.  So we in turn do a "manual clone" here to 
		// spawn the instance locally and copy the properties one by one
		// On the same machine, it's faster and more efficient to use Clone(),
		// so we do.
		IWbemClassObjectPtr smartpNewInstance;
		if (bPasteOnSameMachine)
		{
			CHECK_ERROR (smartpInstance->Clone(&smartpNewInstance));
		}
		else
		{
			CHECK_ERROR (CopyInstance (WMI, smartpInstance, smartpNewInstance));
		}
		CHECK_ERROR (saInstancesNew.SafePutElement(i, smartpNewInstance));

		// reassign, considering that we're re-GUIDing it
		if (i == nTopIndex)
			smartpTopInstance = smartpNewInstance;
		/*
		if (!bAlreadyFound)
		{
		// get name, GUID, and class
		_bstr_t bstrClass;
		CHECK_ERROR (GetStringProperty(smartpNewInstance, "__CLASS", &bstrClass);

		// if it's action-related, see if it's already there
		if (!_wcsicmp(bstrFilterToConsumerBindingClassPath, bstrClass) 
			|| !_wcsicmp(bstrEventConsumerClassPath, bstrClass) 
			|| !_wcsicmp(bstrActionAssocClassPath, bstrClass) 
			|| !_wcsicmp(bstrActionConfigurationClassPath, bstrClass) )
		{
			CHECK_ERROR (GetStringProperty(smartpNewInstance, "Name", &bstrActionName);
			_bstr_t bstrGuidNew, bstrName;		
			bool bFound;
			CHECK_ERROR (GetStringProperty(pObj, L"Name", bstrName));
			CHECK_ERROR (GuidMap.Find(bstrName, bstrGuidNew, bFound));
			if (bFound)
			{
			}
		}
*/
	}
	// trim the new array
	CHECK_ERROR (saInstancesNew.Resize(nLen));

	// now find all the actions we're associated to, compare their names 
	// to actions on the target machine, and fill up a hashtable map
	// with the list of conflicts. Note that if this is just one action that
	// we're copying locally, there's no need to look for conflicts because
	// we're renaming the action anyway.
	StringToStringMap GuidMap;
	if (! (bIsActionTopInstance && bPasteInSameFolder) )
	{
		CHECK_ERROR (FillActionGuidMap(saInstancesNew, ActionNameToGuidMap, GuidMap));
		int nDuplicateCount = GuidMap.GetSize();

		if (nDuplicateCount > 0 && !bPasteOnSameMachine)
		{
			// uh, oh. We have a name conflict.  Depending on whether the 
			// user wants to perform any overwrites, we will either have to 
			// delete the conflicting one or return an error.
			if (bForceReplace)
			{
				TRACE(L"Paste: Action Name Conflict.  We will delete the conflicting one");
			}
			else
			{
				TRACE(L"Paste: Action Name Conflict.  Returning an error.");
				return WBEM_E_ALREADY_EXISTS;
			}
		}		
	}
	
	// Now, let's change all the GUID's (except for the actions
	// that we'll be replacing, as above).
	CHECK_ERROR (ReGuid (saInstancesNew, GuidMap));

	// Now, let's see if I need to rename the top-level item to
	// resolve name conflicts
	if ((LPCWSTR)bstrConflictGUID != NULL)
	{
		if (bPasteInSameFolder)
		{
			// if we get here, we're renaming our top item to avoid 
			// a name conflict, just like Explorer does
			i = 2;
			bool bFound = true;
			_bstr_t bstrName;
			do 
			{
				// compose a name, like Foo (2), Foo (3), etc. like explorer does
				WCHAR szNumber[20];
				bstrName = bstrTopInstanceName;
				bstrName += L" (";
				bstrName += _itow (i++, szNumber, 10);
				bstrName += L")";

				_bstr_t NotUsed;
				CHECK_ERROR (TopLevelNameConflictMap.Find(bstrName, NotUsed, bFound));
			} while (bFound);

			// when we get to here, we've found a free name
			CHECK_ERROR (PutStringProperty(smartpTopInstance, L"Name", bstrName));
		}
		else if (! bIsActionTopInstance)
		{
			// we're almost there.  Now we need to delete the top-level item on the
			// target, if present, to make room for us.  Use the delete method.
			// note that we *do not* go through this codepath for actions, because
			// for actions we will just lay down a new action, with the same GUID,
			// right over the old one.  If we actually did call delete (via the agent)
			// the agent would clobber all the action assocations, whereas we want to 
			// keep them there and have the new action just fall right into place
			IWbemClassObjectPtr smartpSystemClass, smartpInParamsClass, 
				smartpInParamsInstance, smartpResults;

			// impersonate the caller.  Important since we're now calling into
			// WMI and need to make sure caller is allowed
			CHECK_ERROR(CoImpersonateClient());

			// BUGBUG: For next release, we need to think about how to provide 
			// safer functionality here, so that we don't actually delete the 
			// target until we've successfully added the new stuff
			// until then, just delete the conflict
			CHECK_ERROR(System.FindAndDeleteByGUID(bstrConflictGUID));
/*
			// now that this code lives inside the agent, there's no need to call 
			// an external method on the agent.  It's much easier-- just call
			// the FindAndDeleteByGUID function on the system class!
	
			// get the system class
			CHECK_ERROR (WMI->GetObject (bstrSystemConfigurationClassPath, 
						WBEM_FLAG_RETURN_WBEM_COMPLETE, 
						NULL, 
						&smartpSystemClass, 
						NULL));
			// get the delete method in-params "class"
			CHECK_ERROR (smartpSystemClass->GetMethod (L"Delete", 0, &smartpInParamsClass, NULL));
			CHECK_ERROR (smartpInParamsClass->SpawnInstance (0, &smartpInParamsInstance));
			CHECK_ERROR (PutStringProperty(smartpInParamsInstance, L"TargetGUID", bstrTopInstanceGUID));
			CHECK_ERROR (WMI->ExecMethod(bstrSystemConfigurationClassPath,
										L"Delete",
										WBEM_FLAG_RETURN_WBEM_COMPLETE,
										NULL,
										smartpInParamsInstance,
										&smartpResults,
										NULL));
			DWORD dwReturnValue;
			CHECK_ERROR (GetUint32Property (smartpResults, L"ReturnValue", dwReturnValue));
			CHECK_ERROR (dwReturnValue);
*/
		}
	}

	// Now we need to compute the association to link the new instances up to the 
	// parent instance.  This should get the agent to pick up the change and set
	// all the balls in motion.  Note that actions don't require parent associations--
	// actions are just global instances available everywhere.
	IWbemClassObjectPtr smartpAssocInstance;
	if (! bIsActionTopInstance)
	{
		IWbemClassObjectPtr smartpAssocClass;
		
		_bstr_t bstrParentPath, bstrTopInstancePath, bstrTopInstanceRelPath;
		CHECK_ERROR (GetStringProperty(smartpTopInstance, L"__RELPATH", bstrTopInstanceRelPath));
		try
		{
			bstrParentPath = bstrLocalHealthMonNamespace 
				+ L":" 
				+ bstrParentRelPath;
			bstrTopInstancePath = bstrLocalHealthMonNamespace 
				+ L":" 
				+ bstrTopInstanceRelPath;
		}
		catch (_com_error e)
		{
			CHECK_ERROR (e.Error());
		}


		// now create the association
		CHECK_ERROR (WMI->GetObject (bstrConfigurationAssocClassPath, 
					WBEM_FLAG_RETURN_WBEM_COMPLETE, 
					NULL, 
					&smartpAssocClass, 
					NULL));
		CHECK_ERROR(smartpAssocClass->SpawnInstance(0, &smartpAssocInstance));
		CHECK_ERROR(PutStringProperty(smartpAssocInstance, L"ParentPath", bstrParentPath));
		CHECK_ERROR(PutStringProperty(smartpAssocInstance, L"ChildPath", bstrTopInstancePath));
	}

	// Whew!  Finally, we're ready to paste the new items.  Let 'er rip!
	for (i = 0, nLen = saInstancesNew.GetSize(); i < nLen; i++)
	{
		IWbemClassObjectPtr smartpInstance;
		CHECK_ERROR (saInstancesNew.GetElement (i, &smartpInstance));

		_bstr_t bstrClass, bstrPath;
		CHECK_ERROR (GetStringProperty(smartpInstance, L"__RELPATH", bstrPath));
		CHECK_ERROR (GetStringProperty(smartpInstance, L"__CLASS", bstrClass));

		// If the user is pasting on the same machine, there's no need to write
		// actions, since we will simply use associations to the same actions. 
		// The one exception is if we're pasting a single action (which will
		// result in a new action being laid down).
		if (bPasteOnSameMachine && ! bIsActionTopInstance)
		{
			if (!_wcsicmp(bstrFilterToConsumerBindingClassPath, bstrClass) 
				|| !_wcsicmp(bstrEventConsumerClassPath, bstrClass) 
				|| !_wcsicmp(bstrEventFilterClassPath, bstrClass) 
				|| !_wcsicmp(bstrActionConfigurationClassPath, bstrClass) )
			{
				continue;	// skip if it's an action
			}
		}
		// TODO: as an optmization, we should consider not laying down 
		// multiple copies of the same action.  WMI should handle our saves as
		// simple instance modification events, but it would speed things up
		// to filter out multiple copies of actions.

		// impersonate the caller.  Important since we're now calling into
		// WMI and need to make sure caller is allowed
		CHECK_ERROR(CoImpersonateClient());

		// finally, lay down the new instance!
		HRESULT hr = WMI->PutInstance(smartpInstance, 
									WBEM_FLAG_RETURN_WBEM_COMPLETE | WBEM_FLAG_CREATE_OR_UPDATE,
									NULL,
									NULL);
		if (hr == WBEM_E_ACCESS_DENIED)
		{
			// we may have trouble overwriting action instances when those 
			// were created by another user.  But since admin users should
			// be able to override this restriction, and only admins can 
			// use HM in this release, I think that we're OK.  
			// BUGBUG: in future HM releases, we should consider deleting
			// old action instances if the SID's are different from ours.
		}
		if (FAILED(hr))
		{
			CHECK_ERROR (hr);
		}
		if (i == 0 && (bool) smartpAssocInstance)
		{
			// now that we've stored the top-level parent, let's add the association
			// to the parent. There's a bug in the rest of the agent that it won't
			// pick up action associations unless the parent instance is already 
			// associated. Hopefully this will be fixed, but until then we'll link up
			// the new top instance right at first.
			CHECK_ERROR(WMI->PutInstance(smartpAssocInstance, 
									WBEM_FLAG_RETURN_WBEM_COMPLETE | WBEM_FLAG_CREATE_OR_UPDATE,
									NULL,
									NULL));
		}

		//BUGBUG: shouldn't lay down anything that's already there and the same as us!
		//BUGBUG: before calling it a conflict, must compare properties!
	}

	return S_OK;
}

// Below are the actual entry points for the old agent code
// to call the new copy & paste functionality
HRESULT CSystem::AgentPaste(LPTSTR pszTargetGUID, 
				   SAFEARRAY* psa, 
				   LPTSTR pszOriginalSystem, 
				   LPTSTR pszOriginalParentGUID, 
				   BOOL bForceReplace)
{
	HRESULT hr = Paste(L".", pszTargetGUID, pszOriginalSystem, 
				pszOriginalParentGUID, psa, bForceReplace, *this);
	// BUGBUG: the agent returns the HRESULT of the Paste back
	// through the __ReturnValue of the method, not through WMI
	// errors.  This is bad-- needs to be changed.
	if (hr == WBEM_E_ALREADY_EXISTS)
		return 2; // 2 is what console recognizes here. 
	else if (FAILED(hr))
		return hr;	
	else
		return 0;
}

HRESULT CSystem::AgentCopy(LPTSTR pszGUID, 
						   SAFEARRAY** ppsa, 
						   LPTSTR *pszOriginalParentGUID)
{
	SafeArrayOneDimWbemClassObject sa;
	CHECK_ERROR (sa.Create());
	_bstr_t bstrParentGUID;

	// now call the underlying copy routine
	HRESULT hr = Copy(L".", pszGUID, bstrParentGUID, sa, *this);
	CHECK_ERROR (hr);

	VARIANT var = sa.Detach();
	*ppsa = var.parray;
	// copy the BSTR into a new[] string, as the caller expects.  
	// should really use a smart pointer or _bstr_t instead....
	TCHAR* p = new TCHAR[bstrParentGUID.length()+1];
	if (p == NULL)
		CHECK_ERROR (E_OUTOFMEMORY);
	wcscpy (p, bstrParentGUID);
	*pszOriginalParentGUID = p;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\evtprov.cpp ===
// EVTPROV.CPP: implementation of the CBaseEventProvider class.
//
//////////////////////////////////////////////////////////////////////

#include "HMAgent.h"
//#include "system.h"
#include "evtprov.h"

//////////////////////////////////////////////////////////////////////
// global data
//extern CSystem* g_pSystem;
extern HANDLE g_hConfigLock;
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBaseEventProvider::CBaseEventProvider()
{
	OutputDebugString(L"CBaseEventProvider::CBaseEventProvider()\n");

//	m_pSystem = g_pSystem;

	m_cRef = 0L;
	m_pIWbemServices = NULL;
}

CBaseEventProvider::~CBaseEventProvider()
{
	OutputDebugString(L"CBaseEventProvider::~CBaseEventProvider()\n");

	if (m_pIWbemServices)
	{
		m_pIWbemServices->Release();
	}

	m_pIWbemServices	= NULL;
}

//////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//////////////////////////////////////////////////////////////////////
STDMETHODIMP CBaseEventProvider::QueryInterface(REFIID riid, LPVOID* ppv)
{
	*ppv = NULL;

	if (IID_IUnknown==riid || IID_IWbemEventProvider==riid)
	{
		*ppv = (IWbemEventProvider *) this;
		AddRef();
		return S_OK;
	}

	if (IID_IWbemProviderInit==riid)
	{
		*ppv = (IWbemProviderInit *) this;
		AddRef();
		return S_OK;
	}

	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CBaseEventProvider::AddRef(void)
{
	return InterlockedIncrement((long*)&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// IWbemProviderInit Implementation
//////////////////////////////////////////////////////////////////////

HRESULT CBaseEventProvider::Initialize(	LPWSTR pszUser,
										LONG lFlags,
										LPWSTR pszNamespace,
										LPWSTR pszLocale,
										IWbemServices __RPC_FAR *pNamespace,
										IWbemContext __RPC_FAR *pCtx,
										IWbemProviderInitSink __RPC_FAR *pInitSink)
{
	OutputDebugString(L"CBaseEventProvider::Initialize()\n");
	
	if (NULL == pNamespace)
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// save the IWbemServices namespace
	// we may need it later
	m_pIWbemServices = pNamespace;
	m_pIWbemServices->AddRef();

	// Tell CIMOM that we're up and running.
	MY_ASSERT(pInitSink);
	pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
  
	return WBEM_NO_ERROR;
}            

//////////////////////////////////////////////////////////////////////
// IWbemProvider Implementation
//////////////////////////////////////////////////////////////////////
HRESULT CBaseEventProvider::ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags)
{
	if (NULL == pSink)
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	return WBEM_E_NOT_SUPPORTED;
}

STDMETHODIMP_(ULONG) CBaseEventProvider::Release(void)
{
	LONG lCount;

	lCount = InterlockedDecrement((long*)&m_cRef);

	if (0 != lCount)
	{
		return lCount;
	}

	delete this;
	return 0L;
}

//////////////////////////////////////////////////////////////////////
// Derived Implementation
//////////////////////////////////////////////////////////////////////

HRESULT CSystemEventProvider::ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags)
{
	OutputDebugString(L"CSystemEventProvider::ProvideEvents\n");

	// Set CSystem to deliver events
	pSink->AddRef();
	g_pSystemEventSink = pSink;

	return WBEM_NO_ERROR;
}

STDMETHODIMP_(ULONG) CSystemEventProvider::Release(void)
{
	OutputDebugString(L"CSystemEventProvider::Release()\n");

	LONG	lCount = InterlockedDecrement((long*)&m_cRef);

	if (0 != lCount)
	{
		return lCount;
	}

	OutputDebugString(L"CSystemEventProvider::Release - Terminating Evt Delivery\n");

	if (g_pSystemEventSink)
	{
		g_pSystemEventSink->Release();
	}
	g_pSystemEventSink = NULL;

	delete this;
	return 0L;
}

HRESULT CDataGroupEventProvider::ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags)
{
	OutputDebugString(L"CDataGroupEventProvider::ProvideEvents\n");

	// Set CSystem to deliver events
	pSink->AddRef();
	g_pDataGroupEventSink = pSink;

	return WBEM_NO_ERROR;
}

STDMETHODIMP_(ULONG) CDataGroupEventProvider::Release(void)
{
	OutputDebugString(L"CDataGroupEventProvider::Release()\n");

	LONG	lCount = InterlockedDecrement((long*)&m_cRef);

	if (0 != lCount)
	{
		return lCount;
	}

	OutputDebugString(L"CDataGroupEventProvider::Release - Terminating Evt Delivery\n");

	if (g_pDataGroupEventSink)
	{
		g_pDataGroupEventSink->Release();
	}
	g_pDataGroupEventSink = NULL;

	delete this;

	return 0L;
}

HRESULT CDataCollectorEventProvider::ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags)
{
	OutputDebugString(L"CDataCollectorEventProvider::ProvideEvents\n");

	// Set CSystem to deliver events
	pSink->AddRef();
	g_pDataCollectorEventSink = pSink;

	return WBEM_NO_ERROR;
}

STDMETHODIMP_(ULONG) CDataCollectorEventProvider::Release(void)
{
	OutputDebugString(L"CDataCollectorEventProvider::Release()\n");

	LONG	lCount = InterlockedDecrement((long*)&m_cRef);

	if (0 != lCount)
	{
		return lCount;
	}

	OutputDebugString(L"CDataCollectorEventProvider::Release - Terminating Evt Delivery\n");

	if (g_pDataCollectorEventSink)
	{
		g_pDataCollectorEventSink->Release();
	}
	g_pDataCollectorEventSink = NULL;

	delete this;
	return 0L;
}

HRESULT CDataCollectorPerInstanceEventProvider::ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags)
{
	OutputDebugString(L"CDataCollectorPerInstanceEventProvider::ProvideEvents\n");

	// Set CSystem to deliver events
	pSink->AddRef();
	g_pDataCollectorPerInstanceEventSink = pSink;

	return WBEM_NO_ERROR;
}

STDMETHODIMP_(ULONG) CDataCollectorPerInstanceEventProvider::Release(void)
{
	OutputDebugString(L"CDataCollectorPerInstanceEventProvider::Release()\n");

	LONG	lCount = InterlockedDecrement((long*)&m_cRef);

	if (0 != lCount)
	{
		return lCount;
	}

	OutputDebugString(L"CDataCollectorPerInstanceEventProvider::Release - Terminating Evt Delivery\n");

	if (g_pDataCollectorPerInstanceEventSink)
	{
		g_pDataCollectorPerInstanceEventSink->Release();
	}
	g_pDataCollectorPerInstanceEventSink = NULL;

	delete this;
	return 0L;
}


HRESULT CThresholdEventProvider::ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags)
{
	OutputDebugString(L"CThresholdEventProvider::ProvideEvents\n");

	// Set CSystem to deliver events
	pSink->AddRef();
	g_pThresholdEventSink = pSink;

	return WBEM_NO_ERROR;
}

STDMETHODIMP_(ULONG) CThresholdEventProvider::Release(void)
{
	OutputDebugString(L"CThresholdEventProvider::Release()\n");

	LONG	lCount = InterlockedDecrement((long*)&m_cRef);

	if (0 != lCount)
	{
		return lCount;
	}

	OutputDebugString(L"CThresholdEventProvider::Release - Terminating Evt Delivery\n");

	if (g_pThresholdEventSink)
	{
		g_pThresholdEventSink->Release();
	}
	g_pThresholdEventSink = NULL;

	delete this;
	return 0L;
}


HRESULT CActionEventProvider::ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags)
{
	OutputDebugString(L"CActionEventProvider::ProvideEvents\n");

	// Set CSystem to deliver events
	pSink->AddRef();
	g_pActionEventSink = pSink;

	return WBEM_NO_ERROR;
}

STDMETHODIMP_(ULONG) CActionEventProvider::Release(void)
{
	OutputDebugString(L"CActionEventProvider::Release()\n");

	LONG	lCount = InterlockedDecrement((long*)&m_cRef);

	if (0 != lCount)
	{
		return lCount;
	}

	OutputDebugString(L"CActionEventProvider::Release - Terminating Evt Delivery\n");

	if (g_pActionEventSink)
	{
		g_pActionEventSink->Release();
	}
	g_pActionEventSink = NULL;

	delete this;
	return 0L;
}

HRESULT CActionTriggerEventProvider::ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags)
{
	OutputDebugString(L"CActionTriggerEventProvider::ProvideEvents\n");

	// Set CSystem to deliver events
	pSink->AddRef();
	g_pActionTriggerEventSink = pSink;

	return WBEM_NO_ERROR;
}

STDMETHODIMP_(ULONG) CActionTriggerEventProvider::Release(void)
{
	OutputDebugString(L"CActionTriggerEventProvider::Release()\n");

	LONG	lCount = InterlockedDecrement((long*)&m_cRef);

	if (0 != lCount)
	{
		return lCount;
	}

	OutputDebugString(L"CActionTriggerEventProvider::Release - Terminating Evt Delivery\n");

	if (g_pActionTriggerEventSink)
	{
		g_pActionTriggerEventSink->Release();
	}
	g_pActionTriggerEventSink = NULL;

	delete this;
	return 0L;
}


///////////////////////////////////////////////////////////////////////////////////////

#ifdef SAVE
HRESULT CDataCollectorStatisticsEventProvider::ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags)
{
	OutputDebugString(L"CDataCollectorStatisticsEventProvider::ProvideEvents\n");

	// Set CSystem to deliver events
	pSink->AddRef();
	g_pDataCollectorStatisticsEventSink = pSink;

	return WBEM_NO_ERROR;
}

STDMETHODIMP_(ULONG) CDataCollectorStatisticsEventProvider::Release(void)
{
	OutputDebugString(L"CDataCollectorStatisticsEventProvider::Release()\n");
//XXXPut all these back in, or create a different mutex, so can differentiate
//between blocking the three things - config edit, come here beacuse of WMI request
//and AgentInterval. We were having a problem with action association and creation of the
//__FilterToConsumerBinding instance, that it would then call back in on a separate thread
//And we would block here. The reason is that the Action code also registers an event sink for
//Status events, so that it can do the Throttling, that beings us back into here on a separate thread
//and we block each other! Becuse the call in Action.cpp never returns...
//I don't remember why it was comming into the release code however.
//The reason for the Mutex in the first place is to avoid a timming issue where the DE code or other
//similar event code that calls Indicate doesn;t have the sink pointer taken away, because just
//before it goes to use it it is pre-empted and this code NULLs it out!. This would happen when the
//console goes away.
//The Instprov.cpp code and calls to indicate in DE.cpp are OK as they are still protected by
//the EditMutex. There we want to prevent two threads colliding, like a delete happening
//At the same time someone is enumerating the SystemStatus class.

//XXXMY_OUTPUT(L"BLOCK - BLOCK CDataCollectorStatisticsEventProvider::Release BLOCK - g_hConfigLock BLOCK WAIT", 1);
//XXX	WaitForSingleObject(g_hConfigLock, INFINITE);
//XXXMY_OUTPUT(L"BLOCK - BLOCK CDataCollectorStatisticsEventProvider::Release BLOCK - g_hConfigLock BLOCK GOT IT", 1);

	LONG	lCount = InterlockedDecrement((long*)&m_cRef);

	if (0 != lCount)
	{
//XXXMY_OUTPUT(L"BLOCK - BLOCK CDataCollectorStatisticsEventProvider::Release g_hConfigLock BLOCK - RELEASE IT", 1);
//XXX		ReleaseMutex(g_hConfigLock);
//XXXMY_OUTPUT(L"BLOCK - BLOCK CDataCollectorStatisticsEventProvider::Release g_hConfigLock BLOCK - RELEASED", 1);
		return lCount;
	}

	OutputDebugString(L"CDataCollectorEventStatisticsProvider::Release - Terminating Evt Delivery\n");

	if (g_pDataCollectorStatisticsEventSink)
		g_pDataCollectorStatisticsEventSink->Release();
	g_pDataCollectorStatisticsEventSink = NULL;

	delete this;

//XXXMY_OUTPUT(L"BLOCK - BLOCK CDataCollectorStatisticsEventProvider::Release g_hConfigLock BLOCK - RELEASE IT", 1);
//XXX	ReleaseMutex(g_hConfigLock);
//XXXMY_OUTPUT(L"BLOCK - BLOCK CDataCollectorStatisticsEventProvider::Release g_hConfigLock BLOCK - RELEASED", 1);

	return 0L;
}
#endif

#ifdef SAVE
HRESULT CThresholdInstanceEventProvider::ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags)
{
	OutputDebugString(L"CThresholdInstanceEventProvider::ProvideEvents\n");

	// Set CSystem to deliver events
	pSink->AddRef();
	g_pThresholdInstanceEventSink = pSink;

	return WBEM_NO_ERROR;
}

STDMETHODIMP_(ULONG) CThresholdInstanceEventProvider::Release(void)
{
	OutputDebugString(L"CThresholdInstanceEventProvider::Release()\n");

//ZZZMY_OUTPUT(L"BLOCK - BLOCK CThresholdInstanceEventProvider::Release g_hConfigLock BLOCK - BLOCK WAIT", 1);
//ZZZ	WaitForSingleObject(g_hConfigLock, INFINITE);
//ZZZMY_OUTPUT(L"BLOCK - BLOCK CThresholdInstanceEventProvider::Release BLOCK - g_hConfigLock BLOCK GOT IT", 1);

	LONG	lCount = InterlockedDecrement((long*)&m_cRef);

	if (0 != lCount)
	{
//ZZZMY_OUTPUT(L"BLOCK - BLOCK CThresholdInstanceEventProvider::Release g_hConfigLock BLOCK - RELEASE IT", 1);
//ZZZ		ReleaseMutex(g_hConfigLock);
//ZZZMY_OUTPUT(L"BLOCK - BLOCK CThresholdInstanceEventProvider::Release g_hConfigLock BLOCK - RELEASED", 1);
		return lCount;
	}

	OutputDebugString(L"CThresholdInstanceEventProvider::Release - Terminating Evt Delivery\n");

	if (g_pThresholdInstanceEventSink)
		g_pThresholdInstanceEventSink->Release();
	g_pThresholdInstanceEventSink = NULL;

	delete this;

//ZZZMY_OUTPUT(L"BLOCK - BLOCK CThresholdInstanceEventProvider::Release g_hConfigLock BLOCK - RELEASE IT", 1);
//ZZZ	ReleaseMutex(g_hConfigLock);
//ZZZMY_OUTPUT(L"BLOCK - BLOCK CThresholdInstanceEventProvider::Release g_hConfigLock BLOCK - RELEASED", 1);

	return 0L;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\datagrp.h ===
//***************************************************************************
//
//  DATAGRP.H
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: CDataGroup class. Is used to group CDatapoints.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#if !defined( __DATAGRP_H )
#define __DATAGRP_H

#include <wbemcli.h>
#include <vector>
//#include <time.h>
#include "base.h"
#include "pgde.h"
#include "pmde.h"
#include "pqde.h"
#include "eqde.h"

class CDataGroup; // Forward declaration
typedef std::vector<CDataGroup*, std::allocator<CDataGroup*> > DGLIST;
typedef std::vector<CDataCollector*, std::allocator<CDataCollector*> > DCLIST;

class CDataGroup : public CBase
{
public:
	CDataGroup();
	~CDataGroup();


	// A DataGroup can have DataGroups and DataCollectors under it
	CDataGroup *m_pParentDG;
	DGLIST m_dataGroupList;
	DCLIST m_dataCollectorList;
	LPTSTR m_szParentObjPath;
//	long m_lNameRID;
	LPTSTR m_szDescription;
//	long m_lDescriptionRID;
//	LPTSTR m_szResourceDLL;
	BOOL m_bEnabled;
	BOOL m_bParentEnabled; // So we can transfer down the hierarchy the state.
	long m_lNumberNormals;
	long m_lNumberWarnings;
	long m_lNumberCriticals;
	long m_lTotalCount;
	long m_lGreenCount;
	long m_lYellowCount;
	long m_lRedCount;
	long m_lPrevState;
	long m_lPrevChildCount;
//	long m_lCurrState;
	long m_lNumberDGChanges;
	long m_lNumberDEChanges;
	long m_lNumberChanges;
	LPTSTR m_szMessage;
	LPTSTR m_szResetMessage;
	TCHAR m_szDTTime[512];
	TCHAR m_szTime[512];
	BOOL m_bValidLoad;


	//
	// STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC
	//
	static void DGTerminationCleanup(void);

	// return polling interval in milliseconds
	BOOL OnAgentInterval(void);
	HRESULT LoadInstanceFromMOF(IWbemClassObject* pObj, CDataGroup *pParentDG, LPTSTR pszParentObjPath, BOOL bModifyPass=FALSE);
	HRESULT InternalizeDataGroups(void);
	HRESULT InternalizeDataCollectors(void);

	BOOL FireEvent(BOOL bForce);
	HRESULT SendHMDataGroupStatusInstances(IWbemObjectSink* pSink, BOOL bSendAllDGS=TRUE);
	HRESULT SendHMDataGroupStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
	HRESULT SendHMDataCollectorStatusInstances(IWbemObjectSink* pSink);
	HRESULT SendHMDataCollectorStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
	HRESULT SendHMDataCollectorPerInstanceStatusInstances(IWbemObjectSink* pSink);
	HRESULT SendHMDataCollectorPerInstanceStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
	HRESULT SendHMDataCollectorStatisticsInstances(IWbemObjectSink* pSink);
	HRESULT SendHMDataCollectorStatisticsInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
	HRESULT SendHMThresholdStatusInstances(IWbemObjectSink* pSink);
	HRESULT SendHMThresholdStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
//	HRESULT SendHMThresholdStatusInstanceInstances(IWbemObjectSink* pSink);
//	HRESULT SendHMThresholdStatusInstanceInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
	HRESULT GetHMDataGroupStatusInstance(IWbemClassObject** ppInstance, BOOL bEventBased);
	long GetCurrState(void);
	BOOL ConsolodateStatus(IWbemClassObject** ppInstance, BOOL bChangesOnly);
	BOOL FindAndModDataGroup(BSTR, IWbemClassObject*);
	BOOL FindAndModDataCollector(BSTR, IWbemClassObject*);
	HRESULT FindAndModThreshold(BSTR, IWbemClassObject*);
	LPTSTR GetGUID(void);
	HRESULT AddDataGroup(BSTR szParentGUID, BSTR szChildGUID);
	HRESULT AddDataCollector(BSTR szParentGUID, BSTR szChildGUID);
	HRESULT AddThreshold(BSTR szParentGUID, BSTR szChildGUID);
	BOOL ResetResetThresholdStates(void);
	BOOL GetChange(void);
	HRESULT FindAndDeleteByGUID(LPTSTR pszGUID);
	HRESULT FindAndEnableByGUID(LPTSTR pszGUID, BOOL bEnable);
	HRESULT FindAndResetDEStateByGUID(LPTSTR pszGUID);
	HRESULT FindAndResetDEStatisticsByGUID(LPTSTR pszGUID);
	HRESULT FindAndEvaluateNowDEByGUID(LPTSTR pszGUID);
	BOOL SetParentEnabledFlag(BOOL bEnabled);
	BOOL Cleanup(void);
	BOOL DeleteDGConfig(BOOL bDeleteAssocOnly=FALSE);
	BOOL DeleteDGInternal(void);
	BOOL ResetState(void);
	BOOL ResetStatistics(void);
	BOOL EvaluateNow(void);
	BOOL FindAndCopyByGUID(LPTSTR pszGUID, ILIST* pConfigList, LPTSTR *pszParentGUID);
	HRESULT Copy(ILIST* pConfigList, LPTSTR pszOldParentGUID, LPTSTR pszNewParentGUID);
	CBase *GetParentPointerFromGUID(LPTSTR pszGUID);
	CBase *FindImediateChildByName(LPTSTR pszChildName);
	BOOL GetNextChildName(LPTSTR pszChildName, LPTSTR pszOutName);
	CBase *FindPointerFromName(LPTSTR pszChildName);
	BOOL SetCurrState(HM_STATE state, BOOL bCheckChanges=FALSE);
//	BOOL ModifyAssocForMove(CBase *pNewParentBase);
	BOOL ReceiveNewChildForMove(CBase *pBase);
	BOOL DeleteChildFromList(LPTSTR pszGUID);
	BOOL FormatMessage(IWbemClassObject* pInstance);
	BOOL SendReminderActionIfStateIsSame(IWbemObjectSink* pActionEventSink, IWbemObjectSink* pActionTriggerEventSink, IWbemClassObject* pActionInstance, IWbemClassObject* pActionTriggerInstance, unsigned long ulTriggerStates);
	HRESULT CheckForBadLoad(void);
};
#endif  // __DATAGRP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\datagrp.cpp ===
//***************************************************************************
//
//  DATAGRP.CPP
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: CDataGroup class. Is used to group CDatapoints.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <tchar.h>
#include "datagrp.h"
#include "system.h"

extern CSystem* g_pSystem;
extern CSystem* g_pStartupSystem;
extern LPTSTR conditionLocStr[];
extern LPTSTR stateLocStr[];

//STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC
void CDataGroup::DGTerminationCleanup(void)
{
	if (g_pDataGroupEventSink != NULL)
	{
		g_pDataGroupEventSink->Release();
		g_pDataGroupEventSink = NULL;
	}
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataGroup::CDataGroup()
{
	MY_OUTPUT(L"ENTER ***** CDataGroup...", 4);

	m_lNumberNormals = 0;
	m_lNumberWarnings = 0;
	m_lNumberCriticals = 0;
	m_lCurrState = HM_GOOD;
	m_lPrevState = HM_GOOD;
	m_lPrevChildCount = 0;
	m_lTotalCount = 0;
	m_lGreenCount = 0;
	m_lYellowCount = 0;
	m_lRedCount = 0;
	m_szGUID = NULL;
	m_szParentObjPath = NULL;
	m_pParentDG = NULL;
	m_szName = NULL;
	m_szDescription = NULL;
	m_lNumberDGChanges = 0;
	m_lNumberDEChanges = 0;
	m_lNumberChanges = 0;
	m_bParentEnabled = TRUE;
	m_bEnabled = TRUE;
	m_szMessage = NULL;
	m_szResetMessage = NULL;
	wcscpy(m_szDTTime, m_szDTCurrTime);
	wcscpy(m_szTime, m_szCurrTime);
	m_hmStatusType = HMSTATUS_DATAGROUP;
	m_bValidLoad = FALSE;

	MY_OUTPUT(L"EXIT ***** CDataGroup...", 4);
}

CDataGroup::~CDataGroup()
{

	MY_OUTPUT(L"ENTER ***** ~CDataGroup...", 4);

	g_pStartupSystem->RemovePointerFromMasterList(this);
	Cleanup();
	if (m_szGUID)
	{
		delete [] m_szGUID;
		m_szGUID = NULL;
	}
	if (m_szParentObjPath)
	{
		delete [] m_szParentObjPath;
		m_szParentObjPath = NULL;
	}
	m_bValidLoad = FALSE;

	MY_OUTPUT(L"EXIT ***** ~CDataGroup...", 4);
}

//
// Load a single DataGroup, and everything under it.
//
HRESULT CDataGroup::LoadInstanceFromMOF(IWbemClassObject* pObj, CDataGroup *pParentDG, LPTSTR pszParentObjPath, BOOL bModifyPass/*FALSE*/)
{
	int i, iSize;
	CDataCollector *pDataCollector;
	CDataGroup *pDataGroup;
	BOOL bRetValue = TRUE;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** CDataGroup::LoadInstanceFromMOF...", 4);

	Cleanup();
	m_bValidLoad = TRUE;

	if (bModifyPass == FALSE)
	{
		// This is the first initial read in of this
		// Get the GUID property.
		// If this fails we will actually not go through with the creation of this object.
		if (m_szGUID)
		{
			delete [] m_szGUID;
			m_szGUID = NULL;
		}
		hRetRes = GetStrProperty(pObj, L"GUID", &m_szGUID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		if (m_szParentObjPath)
		{
			delete [] m_szParentObjPath;
			m_szParentObjPath = NULL;
		}
		m_szParentObjPath = new TCHAR[wcslen(pszParentObjPath)+1];
		MY_ASSERT(m_szParentObjPath); if (!m_szParentObjPath) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		wcscpy(m_szParentObjPath, pszParentObjPath);
		m_pParentDG = pParentDG;
		hRetRes = g_pStartupSystem->AddPointerToMasterList(this);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}

	// Get the Name. If it is NULL then we use the qualifier
	hRetRes = GetStrProperty(pObj, L"Name", &m_szName);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	// Get the Description. If it is NULL then we use the qualifier
	hRetRes = GetStrProperty(pObj, L"Description", &m_szDescription);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	hRetRes = GetBoolProperty(pObj, L"Enabled", &m_bEnabled);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	hRetRes = GetStrProperty(pObj, L"Message", &m_szMessage);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	hRetRes = GetStrProperty(pObj, L"ResetMessage", &m_szResetMessage);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	//
	// Now load all the DataGroups that are children of this one.
	//
	if (bModifyPass == FALSE)
	{
		if (m_pParentDG == NULL)
		{
			if (m_bEnabled==FALSE || (g_pSystem && g_pSystem->m_bEnabled==FALSE))
			{
				if (g_pSystem && g_pSystem->m_bEnabled==FALSE)
					m_bParentEnabled = FALSE;
				// Since our parent is disabled, we will not be able to get into
				// our OnAgentInterval function and send the disabled status later.
				SetCurrState(HM_DISABLED);
				FireEvent(TRUE);
			}
		}
		else
		{
			if (m_bEnabled==FALSE || m_pParentDG->m_bEnabled==FALSE || m_pParentDG->m_bParentEnabled==FALSE)
			{
				if (m_pParentDG->m_bEnabled==FALSE || m_pParentDG->m_bParentEnabled==FALSE)
					m_bParentEnabled = FALSE;
				// Since our parent is disabled, we will not be able to get into
				// our OnAgentInterval function and send the disabled status later.
				SetCurrState(HM_DISABLED);
				FireEvent(TRUE);
			}
		}

		hRetRes = InternalizeDataGroups();
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = InternalizeDataCollectors();
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}
	else
	{
		//
		// Set our state to enabled, or disabled and transfer to the child thresholds
		//
		if (m_bEnabled==FALSE || m_bParentEnabled==FALSE)
		{
			iSize = m_dataCollectorList.size();
			for (i=0; i < iSize; i++)
			{
				MY_ASSERT(i<m_dataCollectorList.size());
				pDataCollector = m_dataCollectorList[i];
				pDataCollector->SetParentEnabledFlag(FALSE);
			}

			iSize = m_dataGroupList.size();
			for (i=0; i < iSize; i++)
			{
				MY_ASSERT(i<m_dataGroupList.size());
				pDataGroup = m_dataGroupList[i];
				pDataGroup->SetParentEnabledFlag(FALSE);
			}
		}
		else
		{
			iSize = m_dataCollectorList.size();
			for (i=0; i < iSize; i++)
			{
				MY_ASSERT(i<m_dataCollectorList.size());
				pDataCollector = m_dataCollectorList[i];
				pDataCollector->SetParentEnabledFlag(TRUE);
			}

			iSize = m_dataGroupList.size();
			for (i=0; i < iSize; i++)
			{
				MY_ASSERT(i<m_dataGroupList.size());
				pDataGroup = m_dataGroupList[i];
				pDataGroup->SetParentEnabledFlag(TRUE);
			}
		}
		m_lCurrState = HM_COLLECTING;
	}

	m_bValidLoad = TRUE;
	MY_OUTPUT(L"EXIT ***** CDataGroup::LoadInstanceFromMOF...", 4);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	Cleanup();
	m_bValidLoad = FALSE;
	return hRetRes;
}

HRESULT CDataGroup::InternalizeDataGroups(void)
{
	TCHAR szTemp[1024];
	HRESULT hRetRes = S_OK;
	ULONG uReturned;
	IWbemClassObject *pObj = NULL;
	BSTR Language = NULL;
	BSTR Query = NULL;
	LPTSTR pszTempGUID = NULL;
	IEnumWbemClassObject *pEnum = 0;

	MY_OUTPUT(L"ENTER ***** CDataGroup::InternalizeDataGroups...", 4);

	// Just loop through all top level DataGroups associated with the DataGroup.
	// Call a method of each, and have the datagroup load itself.
	// Dril down and then have each DataGroup load itself.
	Language = SysAllocString(L"WQL");
	MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(szTemp, L"ASSOCIATORS OF {MicrosoftHM_DataGroupConfiguration.GUID=\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"} WHERE ResultClass=MicrosoftHM_DataGroupConfiguration");
	lstrcat(szTemp, L" Role=ParentPath");
	Query = SysAllocString(szTemp);
	MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

	// Initialize IEnumWbemClassObject pointer

	// Issue query
	hRetRes = g_pIWbemServices->ExecQuery(Language, Query, WBEM_FLAG_FORWARD_ONLY, 0, &pEnum);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	SysFreeString(Query);
	Query = NULL;
	SysFreeString(Language);
	Language = NULL;

	// Retrieve objects in result set
	while (TRUE)
	{
		pObj = NULL;
		uReturned = 0;

		hRetRes = pEnum->Next(0, 1, &pObj, &uReturned);
		MY_ASSERT(hRetRes==S_OK || hRetRes==WBEM_S_FALSE);
		if (hRetRes!=S_OK && hRetRes!=WBEM_S_FALSE)
		{
			MY_HRESASSERT(hRetRes);
			pEnum->Release();
			pEnum = NULL;
			return hRetRes;
		}

		if (uReturned == 0)
		{
			break;
		}

		// See if this is already read in. Need to prevent endless loop, circular references.
		hRetRes = GetStrProperty(pObj, L"GUID", &pszTempGUID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		if (!g_pStartupSystem->FindPointerFromGUIDInMasterList(pszTempGUID))
		{
			// Create the internal class to represent the DataGroup
			CDataGroup* pDG = new CDataGroup;
			MY_ASSERT(pDG); if (!pDG) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			wcscpy(szTemp, L"MicrosoftHM_DataGroupConfiguration.GUID=\\\"");
			lstrcat(szTemp, m_szGUID);
			lstrcat(szTemp, L"\\\"");
			hRetRes = pDG->LoadInstanceFromMOF(pObj, this, szTemp);
			if (hRetRes==S_OK)
			{
				m_dataGroupList.push_back(pDG);
			}
			else
			{
				MY_HRESASSERT(hRetRes);
				pDG->DeleteDGInternal();
				delete pDG;
			}
		}
		delete [] pszTempGUID;
		pszTempGUID = NULL;

		// Release it.
		pObj->Release();
		pObj = NULL;
	}

	// All done
	pEnum->Release();
	pEnum = NULL;

	MY_OUTPUT(L"EXIT ***** CDataGroup::InternalizeDataGroups...", 4);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	if (Query)
		SysFreeString(Query);
	if (Language)
		SysFreeString(Language);
	if (pszTempGUID)
		delete [] pszTempGUID;
	if (pObj)
		pObj->Release();
	if (pEnum)
		pEnum->Release();
	Cleanup();
	m_bValidLoad = FALSE;
	return hRetRes;
}

HRESULT CDataGroup::InternalizeDataCollectors(void)
{
	TCHAR szTemp[1024];
	VARIANT	v;
	ULONG uReturned;
	HRESULT hRetRes = S_OK;
	IWbemClassObject *pObj = NULL;
	CDataCollector* pDE = NULL;
	BSTR Language = NULL;
	BSTR Query = NULL;
	LPTSTR pszTempGUID = NULL;
	IEnumWbemClassObject *pEnum = 0;
	VariantInit(&v);

	MY_OUTPUT(L"ENTER ***** CDataGroup::InternalizeDataCollectors...", 4);

	// Just loop through all top level DataCollectors associated with the DataGroup.
	// Call a method of each, and have the datagroup load itself.
	// Dril down and then have each DataCollector load itself.
	Language = SysAllocString(L"WQL");
	MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(szTemp, L"ASSOCIATORS OF {MicrosoftHM_DataGroupConfiguration.GUID=\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"} WHERE ResultClass=MicrosoftHM_DataCollectorConfiguration");
	Query = SysAllocString(szTemp);
	MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

	// Initialize IEnumWbemClassObject pointer

	// Issue query
    hRetRes = g_pIWbemServices->ExecQuery(Language, Query, WBEM_FLAG_FORWARD_ONLY, 0, &pEnum);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	SysFreeString(Query);
	Query = NULL;
	SysFreeString(Language);
	Language = NULL;

	// Retrieve objects in result set
	while (TRUE)
	{
		pObj = NULL;
		uReturned = 0;

		hRetRes = pEnum->Next(0, 1, &pObj, &uReturned);
		if (hRetRes!=S_OK && hRetRes!=WBEM_S_FALSE)
		{
			MY_HRESASSERT(hRetRes);
			pEnum->Release();
			pEnum = NULL;
			return hRetRes;
		}

		if (uReturned == 0)
		{
			break;
		}

		//
		// Create the internal class to represent the DataCollector
		//
		VariantInit(&v);
		hRetRes = pObj->Get(L"__CLASS", 0L, &v, 0L, 0L);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	
		// See if this is already read in. Need to prevent endless loop, circular references.
		hRetRes = GetStrProperty(pObj, L"GUID", &pszTempGUID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		if (!g_pStartupSystem->FindPointerFromGUIDInMasterList(pszTempGUID))
		{
			if (!wcscmp(L"MicrosoftHM_PolledGetObjectDataCollectorConfiguration", V_BSTR(&v)))
			{
				pDE = new CPolledGetObjectDataCollector;
			}
			else if (!wcscmp(L"MicrosoftHM_PolledMethodDataCollectorConfiguration", V_BSTR(&v)))
			{
				pDE = new CPolledMethodDataCollector;
			}
			else if (!wcscmp(L"MicrosoftHM_PolledQueryDataCollectorConfiguration", V_BSTR(&v)))
			{
				pDE = new CPolledQueryDataCollector;
			}
			else if (!wcscmp(L"MicrosoftHM_EventQueryDataCollectorConfiguration", V_BSTR(&v)))
			{
				pDE = new CEventQueryDataCollector;
			}
			else
			{
				MY_ASSERT(FALSE);
			}
			MY_ASSERT(pDE); if (!pDE) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

			wcscpy(szTemp, L"MicrosoftHM_DataGroupConfiguration.GUID=\\\"");
			lstrcat(szTemp, m_szGUID);
			lstrcat(szTemp, L"\\\"");
			hRetRes = pDE->LoadInstanceFromMOF(pObj, this, szTemp);
			if (hRetRes==S_OK)
			{
				m_dataCollectorList.push_back(pDE);
			}
			else
			{
				MY_HRESASSERT(hRetRes);
				pDE->DeleteDEInternal();
				delete pDE;
			}
		}
		delete [] pszTempGUID;
		pszTempGUID = NULL;
		hRetRes = VariantClear(&v);

		// Release it.
		pObj->Release();
		pObj = NULL;
	}

	// All done
	pEnum->Release();

	MY_OUTPUT(L"EXIT ***** CDataGroup::InternalizeDataCollectors...", 4);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	VariantClear(&v);
	if (Query)
		SysFreeString(Query);
	if (Language)
		SysFreeString(Language);
	if (pszTempGUID)
		delete [] pszTempGUID;
	if (pObj)
		pObj->Release();
	if (pEnum)
		pEnum->Release();
	Cleanup();
	m_bValidLoad = FALSE;
	return hRetRes;
}

//
// DataGroups can contain other DataGroups AND/OR DataCollectors.
// First loop through the DataCollectors, then the DataGroups.
//
BOOL CDataGroup::OnAgentInterval(void)
{
	BOOL bRetValue = TRUE;
	long state;
	int i;
	int iSize;
	long lCurrChildCount = 0;
	CDataCollector *pDataCollector;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** OnAgentInterval...", 1);

	if (m_bValidLoad == FALSE)
		return FALSE;

	m_lNumberDGChanges = 0;
	m_lNumberDEChanges = 0;
	m_lNumberChanges = 0;

	//
	// Don't do anything if we are disabled.
	//
	if ((m_bEnabled==FALSE || m_bParentEnabled==FALSE) && m_lCurrState==HM_DISABLED)
	{
		return bRetValue;
	}

	m_lPrevState = m_lCurrState;

	iSize = m_dataCollectorList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];
		pDataCollector->OnAgentInterval();
	}
	lCurrChildCount = iSize;

	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];

		// Have the DataGroup loop through all of its DataCollectors
		pDataGroup->OnAgentInterval();
	}
	lCurrChildCount += iSize;

	if (m_bEnabled==FALSE || m_bParentEnabled==FALSE)
	{
		m_lCurrState = HM_DISABLED;
		if (m_lNumberChanges == 0)
			m_lNumberChanges = 1;
	}
	else
	{
		//
		// Set State of the DataGroup to the worst of everything under it
		//
		m_lNumberNormals = 0;
		m_lNumberWarnings = 0;
		m_lNumberCriticals = 0;
		m_lNumberDGChanges = 0;
		m_lNumberDEChanges = 0;
		m_lNumberChanges = 0;
		m_lCurrState = -1;
		iSize = m_dataCollectorList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<m_dataCollectorList.size());
			pDataCollector = m_dataCollectorList[i];
			state = pDataCollector->GetCurrState();
			// Some states do not roll up
			if (state > m_lCurrState)
			{
				m_lCurrState = state;
			}
			if (state == HM_GOOD)
			{
				m_lNumberNormals++;
			}
			if (state == HM_WARNING)
			{
				m_lNumberWarnings++;
			}
			if (state == HM_CRITICAL)
			{
				m_lNumberCriticals++;
			}
			if (pDataCollector->GetChange())
			{
				m_lNumberDEChanges++;
			}
		}
		iSize = m_dataGroupList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<m_dataGroupList.size());
			pDataGroup = m_dataGroupList[i];
			state = pDataGroup->GetCurrState();
			// Some state do not roll up, so watch for these
			if (state > m_lCurrState)
			{
				m_lCurrState = state;
			}
			if (state == HM_GOOD)
			{
				m_lNumberNormals++;
			}
			if (state == HM_WARNING)
			{
				m_lNumberWarnings++;
			}
			if (state == HM_CRITICAL)
			{
				m_lNumberCriticals++;
			}
			if (pDataGroup->GetChange())
			{
				m_lNumberDGChanges++;
			}
		}

		//
		// If we are still in one of these states that does not roll up, then we can assume that
		// There was nothing else to over-rode the state, so ckeck for a difference from last time.
		//
		if (m_lCurrState==HM_SCHEDULEDOUT || m_lCurrState==HM_DISABLED || m_lCurrState==HM_COLLECTING)
		{
			m_lCurrState = HM_GOOD;
			if (m_lPrevState != m_lCurrState)
			{
				m_lNumberChanges++;
			}
		}
		else if (m_lCurrState == -1)
		{
			// Maybe we don't have any Groups underneith
			// Or the disabled state of things below us did not roll up
			if (m_bEnabled==FALSE || m_bParentEnabled==FALSE)
			{
				m_lCurrState = HM_DISABLED;
			}
			else
			{
				m_lCurrState = HM_GOOD;
			}

			if (m_lPrevState != m_lCurrState)
			{
				m_lNumberChanges++;
			}
		}
		else if (m_lPrevState==HM_DISABLED && m_lPrevState != m_lCurrState)
		{
			m_lNumberChanges++;
		}
	}

	if (m_lPrevChildCount!=lCurrChildCount)
	{
		if (m_lNumberDGChanges==0 && m_lNumberDEChanges==0 && m_lNumberChanges==0 && m_lPrevState!=m_lCurrState)
		{
			m_lNumberChanges++;
		}
	}
	m_lPrevChildCount = lCurrChildCount;

	FireEvent(FALSE);

	MY_OUTPUT(L"EXIT ***** OnAgentInterval...", 1);
	return bRetValue;
}

//
// If there has been a change in the state then send an event
//
BOOL CDataGroup::FireEvent(BOOL bIgnoreChanges)
{
	BOOL bRetValue = TRUE;
	IWbemClassObject* pInstance = NULL;
	HRESULT hRes;

	MY_OUTPUT(L"ENTER ***** CDataGroup::FireEvent...", 2);

	// Don't send if no-one is listening!
	if (g_pDataGroupEventSink == NULL)
	{
		return bRetValue;
	}

	// A quick test to see if anything has really changed!
	// Proceed if there have been changes
	if (bIgnoreChanges || ((m_lNumberDGChanges!=0 || m_lNumberDEChanges!=0 || m_lNumberChanges!=0) && m_lPrevState!=m_lCurrState))
	{
	}
	else
	{
		return FALSE;
	}

	MY_OUTPUT2(L"EVENT: DataGroup State Change=%d", m_lCurrState, 4);

	// Update time if there has been a change
	wcscpy(m_szDTTime, m_szDTCurrTime);
	wcscpy(m_szTime, m_szCurrTime);

	hRes = GetHMDataGroupStatusInstance(&pInstance, TRUE);
	if (FAILED(hRes))
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT(L"failed to get instance!", 4);
		return FALSE;
	}
	else
	{
		//
		// Place Extrinsit event in vector for sending at end of interval.
		// All get sent at once.
		//
		mg_DGEventList.push_back(pInstance);
	}

	MY_OUTPUT(L"EXIT ***** CDataGroup::FireEvent...", 2);
	return bRetValue;
}

HRESULT CDataGroup::SendHMDataGroupStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	HRESULT hRetRes = S_OK;
	int i, iSize;
	CDataGroup *pDataGroup;

	MY_ASSERT(pSink!=NULL);

	//
	// Is this the one we are looking for?
	//
	if (!_wcsicmp(m_szGUID, pszGUID))
	{
//XXX		if (m_bValidLoad == FALSE)
//XXX			return WBEM_E_INVALID_OBJECT;
		return SendHMDataGroupStatusInstances(pSink, FALSE);
	}

	//
	// Drill down to find.
	//
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		hRetRes = pDataGroup->SendHMDataGroupStatusInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	return WBEM_S_DIFFERENT;
}

HRESULT CDataGroup::SendHMDataGroupStatusInstances(IWbemObjectSink* pSink, BOOL bSendAllDGS/*TRUE*/)
{
	HRESULT hRes = S_OK;
	IWbemClassObject* pInstance = NULL;
	int i, iSize;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** SendHMDataGroupStatusInstances...", 2);

//XXX	if (m_bValidLoad == FALSE)
//XXX		return WBEM_E_INVALID_OBJECT;

	if (pSink == NULL)
	{
		MY_OUTPUT(L"CDC::SendInitialHMMachStatInstances-Invalid Sink", 1);
		return WBEM_E_FAILED;
	}

	hRes = GetHMDataGroupStatusInstance(&pInstance, FALSE);
	if (SUCCEEDED(hRes))
	{
		hRes = pSink->Indicate(1, &pInstance);

		if (FAILED(hRes) && hRes!=WBEM_E_SERVER_TOO_BUSY && hRes!=WBEM_E_CALL_CANCELLED && hRes!=WBEM_E_TRANSPORT_FAILURE)
		{
			MY_HRESASSERT(hRes);
			MY_OUTPUT(L"SendHMDataGroupStatusInstances-failed to send status!", 1);
		}

		pInstance->Release();
		pInstance = NULL;
	}
	else
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT(L":SendHMDataGroupStatusInstances-failed to get instance!", 1);
	}

	if (bSendAllDGS)
	{
		//
		// Have Children DataGroups also send their status
		//
		iSize = m_dataGroupList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<m_dataGroupList.size());
			pDataGroup = m_dataGroupList[i];

			hRes = pDataGroup->SendHMDataGroupStatusInstances(pSink);
		}
	}

	MY_OUTPUT(L"EXIT ***** SendHMDataGroupStatusInstances...", 1);
	return hRes;
}

HRESULT CDataGroup::SendHMDataCollectorStatusInstances(IWbemObjectSink* pSink)
{
	BOOL bRetValue = TRUE;
	int i, iSize;
	CDataCollector *pDataCollector;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** SendHMDataCollectorStatusInstances...", 1);

	// Have all DataCollectors of this DaataGroup send their status
	iSize = m_dataCollectorList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];

		// Have the component loop through all of its DataCollectors
		pDataCollector->SendHMDataCollectorStatusInstances(pSink);
	}

	// Next go down the chain through child DataGroups
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];

		// Have the component loop through all of its DataCollectors
		pDataGroup->SendHMDataCollectorStatusInstances(pSink);
	}

	MY_OUTPUT(L"EXIT ***** SendHMDataCollectorStatusInstances...", 1);
	return bRetValue;
}

HRESULT CDataGroup::SendHMDataCollectorStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	int i;
	int iSize;
	CDataCollector *pDataCollector;
	CDataGroup *pDataGroup;
	HRESULT hRetRes;

	MY_OUTPUT(L"ENTER ***** SendHMDataCollectorStatusInstance...", 1);

	// Try to find the one that needs sending
	iSize = m_dataCollectorList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];

		// Have the component loop through all of its DataCollectors
		hRetRes = pDataCollector->SendHMDataCollectorStatusInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	// Next go down the chain through child DataGroups
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];

		// Have the component loop through all of its DataCollectors
		hRetRes = pDataGroup->SendHMDataCollectorStatusInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	MY_OUTPUT(L"EXIT ***** SendHMDataCollectorStatusInstance...", 1);
	return WBEM_S_DIFFERENT;
}

HRESULT CDataGroup::SendHMDataCollectorPerInstanceStatusInstances(IWbemObjectSink* pSink)
{
	BOOL bRetValue = TRUE;
	int i, iSize;
	CDataCollector *pDataCollector;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** SendHMDataCollectorPerInstanceStatusInstances...", 1);

	// Have all DataCollectors of this DataGroup send their status
	iSize = m_dataCollectorList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];

		// Have the component loop through all of its DataCollectors
		pDataCollector->SendHMDataCollectorPerInstanceStatusInstances(pSink);
	}

	// Next go down the chain through child DataGroups
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];

		// Have the component loop through all of its DataCollectors
		pDataGroup->SendHMDataCollectorPerInstanceStatusInstances(pSink);
	}

	MY_OUTPUT(L"EXIT ***** SendHMDataCollectorPerInstanceStatusInstances...", 1);
	return bRetValue;
}

HRESULT CDataGroup::SendHMDataCollectorPerInstanceStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	HRESULT hRetRes = S_OK;
	int i;
	int iSize;
	CDataCollector *pDataCollector;
	CDataGroup *pDataGroup;
	BOOL bFound;

	MY_OUTPUT(L"ENTER ***** SendHMDataCollectorPerInstanceStatusInstance...", 1);

	// Try to find the one that needs sending
	bFound = FALSE;
	iSize = m_dataCollectorList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];

		// Have the component loop through all of its DataCollectors
		hRetRes = pDataCollector->SendHMDataCollectorPerInstanceStatusInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	// Next go down the chain through child DataGroups
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];

		// Have the component loop through all of its DataCollectors
		hRetRes = pDataGroup->SendHMDataCollectorPerInstanceStatusInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	MY_OUTPUT(L"EXIT ***** SendHMDataCollectorPerInstanceStatusInstance...", 1);
	return WBEM_S_DIFFERENT;
}

HRESULT CDataGroup::SendHMDataCollectorStatisticsInstances(IWbemObjectSink* pSink)
{
	BOOL bRetValue = TRUE;
	int i, iSize;
	CDataCollector *pDataCollector;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** SendHMDataCollectorStatisticsInstances...", 1);

	// Have all DataCollectors of this DaataGroup send their status
	iSize = m_dataCollectorList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];

		// Have the component loop through all of its DataCollectors
		pDataCollector->SendHMDataCollectorStatisticsInstances(pSink);
	}

	// Next go down the chain through child DataGroups
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];

		// Have the component loop through all of its DataCollectors
		pDataGroup->SendHMDataCollectorStatisticsInstances(pSink);
	}

	MY_OUTPUT(L"EXIT ***** SendHMDataCollectorStatisticsInstances...", 1);
	return bRetValue;
}

HRESULT CDataGroup::SendHMDataCollectorStatisticsInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	int i;
	int iSize;
	CDataCollector *pDataCollector;
	CDataGroup *pDataGroup;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** SendHMDataCollectorStatisticsInstance...", 1);

	// Try to find the one that needs sending
	iSize = m_dataCollectorList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];

		// Have the component loop through all of its DataCollectors
		hRetRes = pDataCollector->SendHMDataCollectorStatisticsInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	// Next go down the chain through child DataGroups
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
	
		// Have the component loop through all of its DataCollectors
		hRetRes = pDataGroup->SendHMDataCollectorStatisticsInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	MY_OUTPUT(L"EXIT ***** SendHMDataCollectorStatisticsInstance...", 1);
	return WBEM_S_DIFFERENT;
}

HRESULT CDataGroup::SendHMThresholdStatusInstances(IWbemObjectSink* pSink)
{
	BOOL bRetValue = TRUE;
	int i;
	int iSize;
	CDataCollector *pDataCollector;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** SendHMThresholdStatusInstances...", 1);

	// Have all DataCollectors of this DaataGroup send their status
	iSize = m_dataCollectorList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];

		// Have the component loop through all of its DataCollectors
		pDataCollector->SendHMThresholdStatusInstances(pSink);
	}

	// Next go down the chain through child DataGroups
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];

		// Have the component loop through all of its DataCollectors
		pDataGroup->SendHMThresholdStatusInstances(pSink);
	}

	MY_OUTPUT(L"EXIT ***** SendHMThresholdStatusInstances...", 1);
	return bRetValue;
}

HRESULT CDataGroup::SendHMThresholdStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	int i;
	int iSize;
	CDataCollector *pDataCollector;
	CDataGroup *pDataGroup;
	BOOL bFound;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** SendHMThresholdStatusInstance...", 1);

	// Try to find the one that needs sending
	bFound = FALSE;
	iSize = m_dataCollectorList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];

		// Have the component loop through all of its DataCollectors
		hRetRes = pDataCollector->SendHMThresholdStatusInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	// Next go down the chain through child DataGroups
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];

		// Have the component loop through all of its DataCollectors
		hRetRes = pDataGroup->SendHMThresholdStatusInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	MY_OUTPUT(L"EXIT ***** SendHMThresholdStatusInstance...", 1);
	return WBEM_S_DIFFERENT;
}

#ifdef SAVE
HRESULT CDataGroup::SendHMThresholdStatusInstanceInstances(IWbemObjectSink* pSink)
{
	BOOL bRetValue = TRUE;
	int i;
	int iSize;
	CDataCollector *pDataCollector;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** SendHMThresholdStatusInstanceInstances...", 1);

	// Have all DataCollectors of this DaataGroup send their status
	iSize = m_dataCollectorList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];

		// Have the component loop through all of its DataCollectors
		pDataCollector->SendHMThresholdStatusInstanceInstances(pSink);
	}

	// Next go down the chain through child DataGroups
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];

		// Have the component loop through all of its DataCollectors
		pDataGroup->SendHMThresholdStatusInstanceInstances(pSink);
	}

	MY_OUTPUT(L"EXIT ***** SendHMThresholdStatusInstanceInstances...", 1);
	return bRetValue;
}

HRESULT CDataGroup::SendHMThresholdStatusInstanceInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	int i;
	int iSize;
	CDataCollector *pDataCollector;
	CDataGroup *pDataGroup;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** SendHMThresholdStatusInstanceInstance...", 1);

	// Try to find the one that needs sending
	iSize = m_dataCollectorList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];

		// Have the component loop through all of its DataCollectors
		hRetRes = pDataCollector->SendHMThresholdStatusInstanceInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	// Next go down the chain through child DataGroups
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];

		// Have the component loop through all of its DataCollectors
		hRetRes = pDataGroup->SendHMThresholdStatusInstanceInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	MY_OUTPUT(L"EXIT ***** SendHMThresholdStatusInstanceInstance...", 1);
	return WBEM_S_DIFFERENT;
}
#endif

HRESULT CDataGroup::GetHMDataGroupStatusInstance(IWbemClassObject** ppInstance, BOOL bEventBased)
{
	TCHAR szTemp[1024];
	IWbemClassObject* pClass = NULL;
	BSTR bsString = NULL;
	HRESULT hRetRes = S_OK;
	DWORD dwNameLen = MAX_COMPUTERNAME_LENGTH + 2;
	TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 2];

	MY_OUTPUT(L"ENTER ***** GetHMDataGroupStatusInstance...", 1);

	if (bEventBased)
		bsString = SysAllocString(L"MicrosoftHM_DataGroupStatusEvent");
	else
		bsString = SysAllocString(L"MicrosoftHM_DataGroupStatus");
	MY_ASSERT(bsString); if (!bsString) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	hRetRes = g_pIWbemServices->GetObject(bsString, 0L, NULL, &pClass, NULL);
	SysFreeString(bsString);
	bsString = NULL;

	if (FAILED(hRetRes))
	{
		MY_HRESASSERT(hRetRes);
		return hRetRes;
	}

	hRetRes = pClass->SpawnInstance(0, ppInstance);
	pClass->Release();
	pClass = NULL;

	if (FAILED(hRetRes))
	{
		MY_HRESASSERT(hRetRes);
		return hRetRes;
	}

	if (m_bValidLoad == FALSE)
	{
		hRetRes = PutStrProperty(*ppInstance, L"GUID", m_szGUID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = PutUint32Property(*ppInstance, L"State", HM_CRITICAL);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_DG_LOADFAIL, szTemp, 1024))
		{
			wcscpy(szTemp, L"Data Group failed to load.");
		}
		hRetRes = PutStrProperty(*ppInstance, L"Message", szTemp);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
hRetRes = PutStrProperty(*ppInstance, L"Name", L"...");
MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}
	else
	{
		hRetRes = PutStrProperty(*ppInstance, L"GUID", m_szGUID);
		if (m_pParentDG)
			hRetRes = PutStrProperty(*ppInstance, L"ParentGUID", m_pParentDG->m_szGUID);
		else
			hRetRes = PutStrProperty(*ppInstance, L"ParentGUID", L"{@}");
		hRetRes = PutStrProperty(*ppInstance, L"Name", m_szName);
		if (GetComputerName(szComputerName, &dwNameLen))
		{
			hRetRes = PutStrProperty(*ppInstance, L"SystemName", szComputerName);
		}
		else
		{
			hRetRes = PutStrProperty(*ppInstance, L"SystemName", L"LocalMachine");
		}
		hRetRes = PutStrProperty(*ppInstance, L"TimeGeneratedGMT", m_szDTTime);
		hRetRes = PutStrProperty(*ppInstance, L"LocalTimeFormatted", m_szTime);
		hRetRes = PutUint32Property(*ppInstance, L"State", m_lCurrState);

		if (m_lCurrState != HM_GOOD)
		{
			hRetRes = PutStrProperty(*ppInstance, L"Message", m_szMessage);
		}
		else
		{
			hRetRes = PutStrProperty(*ppInstance, L"Message", m_szResetMessage);
		}
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		FormatMessage(*ppInstance);
	}

	MY_OUTPUT(L"EXIT ***** GetHMDataGroupStatusInstance...", 1);
	return hRetRes;

error:
	MY_ASSERT(FALSE);
	if (bsString)
		SysFreeString(bsString);
	if (pClass)
		pClass->Release();
	Cleanup();
	m_bValidLoad = FALSE;
	return hRetRes;
}

LPTSTR CDataGroup::GetGUID(void)
{
	return m_szGUID;
}

long CDataGroup::GetCurrState(void)
{
	return m_lCurrState;
}

BOOL CDataGroup::FindAndModDataGroup(BSTR szGUID, IWbemClassObject* pObj)
{
	HRESULT hRetRes = S_OK;
	int i, iSize;
	CDataGroup* pDataGroup;

	//
	// Is this us we are looking for?
	//
	if (!_wcsicmp(m_szGUID, szGUID))
	{
		hRetRes = LoadInstanceFromMOF(pObj, this, L"", TRUE);
		return hRetRes;
	}

	//
	// Drill down to find.
	//
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		hRetRes = pDataGroup->FindAndModDataGroup(szGUID, pObj);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	return WBEM_S_DIFFERENT;
}

BOOL CDataGroup::FindAndModDataCollector(BSTR szGUID, IWbemClassObject* pObj)
{
	HRESULT hRetRes;
	int i, iSize;
	CDataGroup* pDataGroup;
	CDataCollector* pDataCollector;

	//
	// Look at DataCollectors of this DataGroup first.
	//
	iSize = m_dataCollectorList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];
		hRetRes = pDataCollector->FindAndModDataCollector(szGUID, pObj);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	//
	// Drill down to other DataGroups to possibly find.
	//
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		hRetRes = pDataGroup->FindAndModDataCollector(szGUID, pObj);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	return WBEM_S_DIFFERENT;
}

HRESULT CDataGroup::FindAndModThreshold(BSTR szGUID, IWbemClassObject* pObj)
{
	HRESULT hRetRes;
	int i, iSize;
	CDataGroup* pDataGroup;
	CDataCollector* pDataCollector;

	//
	// Look at DataCollectors of this DataGroup first.
	//
	iSize = m_dataCollectorList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];
		hRetRes = pDataCollector->FindAndModThreshold(szGUID, pObj);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	//
	// Drill down to other DataGroups to possibly find.
	//
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		hRetRes = pDataGroup->FindAndModThreshold(szGUID, pObj);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	return WBEM_S_DIFFERENT;
}


HRESULT CDataGroup::AddDataGroup(BSTR szParentGUID, BSTR szChildGUID)
{
	TCHAR szTemp[1024];
	IWbemClassObject *pObj = NULL;
	BSTR Path = NULL;
	int i, iSize;
	CDataGroup* pDataGroup;
	DGLIST::iterator iaDG;
	HRESULT hRetRes;
	LPTSTR pszTempGUID = NULL;

	//
	// Are we the parent DataGroup that we want to add under?
	//
	if (!_wcsicmp(m_szGUID, szParentGUID))
	{
		//
		// Make sure it is not already in there first!
		//
		iSize = m_dataGroupList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<m_dataGroupList.size());
			pDataGroup = m_dataGroupList[i];
			if (!_wcsicmp(szChildGUID, pDataGroup->GetGUID()))
			{
				return S_OK;
			}
		}

		//
		// Add in the DataGroup. Everything below will follow.
		//
		wcscpy(szTemp, L"MicrosoftHM_DataGroupConfiguration.GUID=\"");
		lstrcat(szTemp, szChildGUID);
		lstrcat(szTemp, L"\"");
		Path = SysAllocString(szTemp);
		MY_ASSERT(Path); if (!Path) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

		hRetRes = GetWbemObjectInst(&g_pIWbemServices, Path, NULL, &pObj);
//XXXGet back an HRESULT and then return that
		if (!pObj)
		{
			MY_HRESASSERT(hRetRes);
			SysFreeString(Path);
			Path = NULL;
			return S_FALSE;
		}

		TCHAR msgbuf[1024];
		wsprintf(msgbuf, L"ASSOCIATION: DataGroup to DataGroup ParentDGGUID=%s ChildDGGUID=%s", szParentGUID, szChildGUID);
		MY_OUTPUT(msgbuf, 4);

		// See if this is already read in. Need to prevent endless loop, circular references.
		hRetRes = GetStrProperty(pObj, L"GUID", &pszTempGUID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		if (!g_pStartupSystem->FindPointerFromGUIDInMasterList(pszTempGUID))
		{
			//
			// Create the internal class to represent the DataGroup
			//
			CDataGroup* pDG = new CDataGroup;
			MY_ASSERT(pDG); if (!pDG) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			wcscpy(szTemp, L"MicrosoftHM_DataGroupConfiguration.GUID=\\\"");
			lstrcat(szTemp, m_szGUID);
			lstrcat(szTemp, L"\\\"");
			hRetRes = pDG->LoadInstanceFromMOF(pObj, this, szTemp);
			if (hRetRes==S_OK)
			{
				m_dataGroupList.push_back(pDG);
			}
			else
			{
				MY_HRESASSERT(hRetRes);
				pDG->DeleteDGInternal();
				delete pDG;
			}
		}
		delete [] pszTempGUID;
		pszTempGUID = NULL;

		pObj->Release();
		pObj = NULL;
		SysFreeString(Path);
		Path = NULL;
		return S_OK;
	}

	//
	// Keep searching down till we find the DataGroup to add under
	//
	iSize = m_dataGroupList.size();
	iaDG=m_dataGroupList.begin();
	for (i = 0; i < iSize ; i++, iaDG++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		// Look at branch below to see if can find it
		hRetRes = pDataGroup->AddDataGroup(szParentGUID, szChildGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	return WBEM_S_DIFFERENT;

error:
	MY_ASSERT(FALSE);
	if (pszTempGUID)
		delete [] pszTempGUID;
	if (Path)
		SysFreeString(Path);
	if (pObj)
		pObj->Release();
	Cleanup();
	m_bValidLoad = FALSE;
	return hRetRes;
}

HRESULT CDataGroup::AddDataCollector(BSTR szParentGUID, BSTR szChildGUID)
{
	HRESULT hRetRes = S_OK;
	VARIANT	v;
	TCHAR szTemp[1024];
	int i, iSize;
	DGLIST::iterator iaDG;
	CDataGroup* pDataGroup = NULL;
	CDataCollector* pDataCollector = NULL;
	CDataCollector* pDE = NULL;
	IWbemClassObject *pObj = NULL;
	BSTR Path = NULL;
	LPTSTR pszTempGUID = NULL;
	VariantInit(&v);

	//
	// Are we the parent DataGroup that we want to add under?
	//
	if (!_wcsicmp(m_szGUID, szParentGUID))
	{
		//
		// Make sure it is not already in there first!
		//
		iSize = m_dataCollectorList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<m_dataCollectorList.size());
			pDataCollector = m_dataCollectorList[i];
			if (!_wcsicmp(szChildGUID, pDataCollector->GetGUID()))
			{
				return S_OK;
			}
		}

		//
		// Add in the DataGroup. Everything below will follow.
		//
		wcscpy(szTemp, L"MicrosoftHM_DataCollectorConfiguration.GUID=\"");
		lstrcat(szTemp, szChildGUID);
		lstrcat(szTemp, L"\"");
		Path = SysAllocString(szTemp);
		MY_ASSERT(Path); if (!Path) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

		hRetRes = GetWbemObjectInst(&g_pIWbemServices, Path, NULL, &pObj);
		if (!pObj)
		{
			SysFreeString(Path);
			Path = NULL;
			return hRetRes;
		}

		// Create the internal class to represent the DataGroup
		VariantInit(&v);
		hRetRes = pObj->Get(L"__CLASS", 0L, &v, 0L, 0L);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	
		// See if this is already read in. Need to prevent endless loop, circular references.
		hRetRes = GetStrProperty(pObj, L"GUID", &pszTempGUID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		if (!g_pStartupSystem->FindPointerFromGUIDInMasterList(pszTempGUID))
		{
			if (!wcscmp(L"MicrosoftHM_PolledGetObjectDataCollectorConfiguration", V_BSTR(&v)))
			{
				pDE = new CPolledGetObjectDataCollector;
			}
			else if (!wcscmp(L"MicrosoftHM_PolledMethodDataCollectorConfiguration", V_BSTR(&v)))
			{
				pDE = new CPolledMethodDataCollector;
			}
			else if (!wcscmp(L"MicrosoftHM_PolledQueryDataCollectorConfiguration", V_BSTR(&v)))
			{
				pDE = new CPolledQueryDataCollector;
			}
			else if (!wcscmp(L"MicrosoftHM_EventQueryDataCollectorConfiguration", V_BSTR(&v)))
			{
				pDE = new CEventQueryDataCollector;
			}
			else
			{
				MY_ASSERT(FALSE);
			}
			MY_ASSERT(pDE); if (!pDE) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

			TCHAR msgbuf[1024];
			wsprintf(msgbuf, L"ASSOCIATION: DataCollector to DataGroup ParentDGGUID=%s ChildDCGUID=%s", szParentGUID, szChildGUID);
			MY_OUTPUT(msgbuf, 4);
			wcscpy(szTemp, L"MicrosoftHM_DataGroupConfiguration.GUID=\\\"");
			lstrcat(szTemp, m_szGUID);
			lstrcat(szTemp, L"\\\"");
			hRetRes = pDE->LoadInstanceFromMOF(pObj, this, szTemp);
			if (hRetRes==S_OK)
			{
				m_dataCollectorList.push_back(pDE);
			}
			else
			{
				MY_HRESASSERT(hRetRes);
				pDE->DeleteDEInternal();
				delete pDE;
			}
		}
		delete [] pszTempGUID;
		pszTempGUID = NULL;

		VariantClear(&v);
		pObj->Release();
		pObj = NULL;
		SysFreeString(Path);
		Path = NULL;
		return S_OK;
	}

	//
	// Keep searching down till we find the DataGroup to add under
	//
	iSize = m_dataGroupList.size();
	iaDG=m_dataGroupList.begin();
	for (i = 0; i < iSize ; i++, iaDG++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		// Look at branch below to see if can find it
		hRetRes = pDataGroup->AddDataCollector(szParentGUID, szChildGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	return WBEM_S_DIFFERENT;

error:
	MY_ASSERT(FALSE);
	VariantClear(&v);
	if (pszTempGUID)
		delete [] pszTempGUID;
	if (Path)
		SysFreeString(Path);
	if (pObj)
		pObj->Release();
	Cleanup();
	m_bValidLoad = FALSE;
	return hRetRes;
}

HRESULT CDataGroup::AddThreshold(BSTR szParentGUID, BSTR szChildGUID)
{
	IWbemClassObject *pObj = NULL;
	BOOL bAdded = FALSE;
	int i, iSize;
	CDataCollector* pDataCollector;
	CDataGroup* pDataGroup;
	HRESULT hRetRes;

	//
	// Add the Threshold, it will add everything under itself.
	// See if it belongs to one of the DataCollectors at this level.
	//
	iSize = m_dataCollectorList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];
		hRetRes = pDataCollector->AddThreshold(szParentGUID, szChildGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	// Keep looking, if have not found yet
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		// Look at branch below to see if can find it
		hRetRes = pDataGroup->AddThreshold(szParentGUID, szChildGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	return WBEM_S_DIFFERENT;
}

BOOL CDataGroup::ResetResetThresholdStates(void)
{
	BOOL bRetValue = TRUE;
	int i;
	int iSize;
	CDataCollector *pDataCollector;
	CDataGroup *pDataGroup;

	iSize = m_dataCollectorList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];
		pDataCollector->ResetResetThresholdStates();
	}

	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		pDataGroup->ResetResetThresholdStates();
	}

	return bRetValue;
}

BOOL CDataGroup::GetChange(void)
{
	if ((m_lNumberDGChanges!=0 || m_lNumberDEChanges!=0 || m_lNumberChanges!=0) && m_lPrevState!=m_lCurrState)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

//
// Called By the Delete method that the HMSystemConfiguration class exposes.
// We search down the hierarchy until we find what we need to delete.
// We are only search down form where we are, as the object above already verified
// that we are not what was being looked for.
//
HRESULT CDataGroup::FindAndDeleteByGUID(LPTSTR pszGUID)
{
	BOOL bDeleted = FALSE;
	int i, iSize;
	CDataGroup* pDataGroup;
	DGLIST::iterator iaDG;
	CDataCollector* pDataCollector;
	DCLIST::iterator iaDC;

	//
	// Traverse the complete hierarchy to find the object to delete.
	//
	iSize = m_dataGroupList.size();
	iaDG=m_dataGroupList.begin();
	for (i=0; i<iSize; i++, iaDG++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		if (!_wcsicmp(pszGUID, pDataGroup->GetGUID()))
		{
			pDataGroup->DeleteDGConfig();
			delete pDataGroup;
			m_dataGroupList.erase(iaDG);
			bDeleted = TRUE;
			TCHAR msgbuf[1024];
			wsprintf(msgbuf, L"DELETION: DGGUID=%s", pszGUID);
			MY_OUTPUT(msgbuf, 4);
			break;
		}
		// Look at branch below to see if can find it
		if (pDataGroup->FindAndDeleteByGUID(pszGUID)==S_OK)
		{
			bDeleted = TRUE;
			break;
		}
	}

	if (bDeleted == FALSE)
	{
		iSize = m_dataCollectorList.size();
		iaDC=m_dataCollectorList.begin();
		for (i=0; i<iSize; i++, iaDC++)
		{
			MY_ASSERT(i<m_dataCollectorList.size());
			pDataCollector = m_dataCollectorList[i];
			if (!_wcsicmp(pszGUID, pDataCollector->GetGUID()))
			{
				pDataCollector->DeleteDEConfig();
				pDataCollector->EnumDone();
				delete pDataCollector;
				m_dataCollectorList.erase(iaDC);
				bDeleted = TRUE;
				TCHAR msgbuf[1024];
				wsprintf(msgbuf, L"DELETION: DCGUID=%s", pszGUID);
				MY_OUTPUT(msgbuf, 4);
				break;
			}
			// Look at branch below to see if can find it
			if (pDataCollector->FindAndDeleteByGUID(pszGUID)==S_OK)
			{
				bDeleted = TRUE;
				break;
			}
		}
	}

	if (bDeleted == FALSE)
	{
		return S_FALSE;
	}
	else
	{
		return S_OK;
	}
}

//
// HMSystemConfiguration class exposes this method.
//
HRESULT CDataGroup::FindAndEnableByGUID(LPTSTR pszGUID, BOOL bEnable)
{
	BOOL bFound = FALSE;
	int i, iSize;
	CDataGroup* pDataGroup;
	CDataCollector* pDataCollector;

	//
	// Traverse the complete hierarchy to find the object to enable/disable.
	//
	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		if (!_wcsicmp(pszGUID, pDataGroup->GetGUID()))
		{
			bFound = TRUE;
			break;
		}
		// Look at branch below to see if can find it
		if (pDataGroup->FindAndEnableByGUID(pszGUID, bEnable)==S_OK)
		{
			bFound = TRUE;
			break;
		}
	}

	if (bFound == FALSE)
	{
		iSize = m_dataCollectorList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_dataCollectorList.size());
			pDataCollector = m_dataCollectorList[i];
			if (!_wcsicmp(pszGUID, pDataCollector->GetGUID()))
			{
				bFound = TRUE;
				break;
			}
			// Look at branch below to see if can find it
			if (pDataCollector->FindAndEnableByGUID(pszGUID, bEnable)==S_OK)
			{
				bFound = TRUE;
				break;
			}
		}
	}

	if (bFound == FALSE)
	{
		return S_FALSE;
	}
	else
	{
		return S_OK;
	}
}

//
// HMSystemConfiguration class exposes this method.
//
HRESULT CDataGroup::FindAndResetDEStateByGUID(LPTSTR pszGUID)
{
	BOOL bFound = FALSE;
	int i, iSize;
	CDataGroup* pDataGroup;
	CDataCollector* pDataCollector;

	//
	// Traverse the complete hierarchy to find the DG, or DE to Reset.
	//
	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		if (!_wcsicmp(pszGUID, pDataGroup->GetGUID()))
		{
			pDataGroup->ResetState();
			bFound = TRUE;
			break;
		}
		// Look at branch below to see if can find it
		if (pDataGroup->FindAndResetDEStateByGUID(pszGUID)==S_OK)
		{
			bFound = TRUE;
			break;
		}
	}

	if (bFound == FALSE)
	{
		iSize = m_dataCollectorList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_dataCollectorList.size());
			pDataCollector = m_dataCollectorList[i];
			if (!_wcsicmp(pszGUID, pDataCollector->GetGUID()))
			{
				pDataCollector->ResetState(FALSE, TRUE);
				bFound = TRUE;
				break;
			}
		}
	}

	if (bFound == FALSE)
	{
		return S_FALSE;
	}
	else
	{
		return S_OK;
	}
}

BOOL CDataGroup::ResetState(void)
{
	int i, iSize;
	CDataGroup* pDataGroup;
	CDataCollector* pDataCollector;

	//
	// Traverse the complete hierarchy to find the DG, or DE to Reset.
	//
	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		pDataGroup->ResetState();
	}

	iSize = m_dataCollectorList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];
		pDataCollector->ResetState(FALSE, FALSE);
	}

	return TRUE;
}

//
// HMSystemConfiguration class exposes this method.
//
HRESULT CDataGroup::FindAndResetDEStatisticsByGUID(LPTSTR pszGUID)
{
	BOOL bFound = FALSE;
	int i, iSize;
	CDataGroup* pDataGroup;
	CDataCollector* pDataCollector;

	//
	// Traverse the complete hierarchy to find the DG, or DE to Reset.
	//
	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		if (!_wcsicmp(pszGUID, pDataGroup->GetGUID()))
		{
			pDataGroup->ResetStatistics();
			bFound = TRUE;
			break;
		}
		// Look at branch below to see if can find it
		if (pDataGroup->FindAndResetDEStatisticsByGUID(pszGUID)==S_OK)
		{
			bFound = TRUE;
			break;
		}
	}

	if (bFound == FALSE)
	{
		iSize = m_dataCollectorList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_dataCollectorList.size());
			pDataCollector = m_dataCollectorList[i];
			if (!_wcsicmp(pszGUID, pDataCollector->GetGUID()))
			{
				pDataCollector->ResetStatistics();
				bFound = TRUE;
				break;
			}
		}
	}

	if (bFound == FALSE)
	{
		return S_FALSE;
	}
	else
	{
		return S_OK;
	}
}

BOOL CDataGroup::ResetStatistics(void)
{
	int i, iSize;
	CDataGroup* pDataGroup;
	CDataCollector* pDataCollector;

	//
	// Traverse the complete hierarchy to find the DG, or DE to Reset.
	//
	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		pDataGroup->ResetStatistics();
	}

	iSize = m_dataCollectorList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];
		pDataCollector->ResetStatistics();
	}

	return TRUE;
}

//
// HMSystemConfiguration class exposes this method.
//
HRESULT CDataGroup::FindAndEvaluateNowDEByGUID(LPTSTR pszGUID)
{
	BOOL bFound = FALSE;
	int i, iSize;
	CDataGroup* pDataGroup;
	CDataCollector* pDataCollector;

	//
	// Traverse the complete hierarchy to find the DG, or DE to Reset.
	//
	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		if (!_wcsicmp(pszGUID, pDataGroup->GetGUID()))
		{
			pDataGroup->EvaluateNow();
			bFound = TRUE;
			break;
		}
		// Look at branch below to see if can find it
		if (pDataGroup->FindAndEvaluateNowDEByGUID(pszGUID)==S_OK)
		{
			bFound = TRUE;
			break;
		}
	}

	if (bFound == FALSE)
	{
		iSize = m_dataCollectorList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_dataCollectorList.size());
			pDataCollector = m_dataCollectorList[i];
			if (!_wcsicmp(pszGUID, pDataCollector->GetGUID()))
			{
				pDataCollector->EvaluateNow(TRUE);
				bFound = TRUE;
				break;
			}
		}
	}

	if (bFound == FALSE)
	{
		return S_FALSE;
	}
	else
	{
		return S_OK;
	}
}

BOOL CDataGroup::EvaluateNow(void)
{
	int i, iSize;
	CDataGroup* pDataGroup;
	CDataCollector* pDataCollector;

	//
	// Traverse the complete hierarchy to find the DG, or DE to Reset.
	//
	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		pDataGroup->EvaluateNow();
	}

	iSize = m_dataCollectorList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];
		pDataCollector->EvaluateNow(FALSE);
	}

	return TRUE;
}

BOOL CDataGroup::SetParentEnabledFlag(BOOL bEnabled)
{
	int i, iSize;
	CDataCollector *pDataCollector;
	CDataGroup *pDataGroup;

	m_bParentEnabled = bEnabled;

	//
	// Now traverse children and call for everything below
	//
	iSize = m_dataCollectorList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];
		pDataCollector->SetParentEnabledFlag(m_bEnabled && m_bParentEnabled);
	}

	iSize = m_dataGroupList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		pDataGroup->SetParentEnabledFlag(m_bEnabled && m_bParentEnabled);
	}

	return TRUE;
}


BOOL CDataGroup::Cleanup(void)
{
	MY_OUTPUT(L"ENTER ***** CDataGroup::Cleanup...", 1);

	if (m_szName)
	{
		delete [] m_szName;
		m_szName = NULL;
	}
	if (m_szDescription)
	{
		delete [] m_szDescription;
		m_szDescription = NULL;
	}
	if (m_szMessage)
	{
		delete [] m_szMessage;
		m_szMessage = NULL;
	}
	if (m_szResetMessage)
	{
		delete [] m_szResetMessage;
		m_szResetMessage = NULL;
	}

	MY_OUTPUT(L"EXIT ***** CDataGroup::Cleanup...", 1);
	return TRUE;
}

//
// For when moving from one parent to another
//
#ifdef SAVE
BOOL CDataGroup::ModifyAssocForMove(CBase *pNewParentBase)
{
	HRESULT hRes;
	TCHAR szTemp[1024];
	TCHAR szNewTemp[1024];
	BSTR instName;
	IWbemContext *pCtx = 0;
	IWbemCallResult *pResult = 0;
	IWbemClassObject* pObj = NULL;
	IWbemClassObject* pNewObj = NULL;

	MY_OUTPUT(L"ENTER ***** CDataGroup::ModifyAssocForMove...", 4);
	MY_OUTPUT2(L"m_szGUID=%s", m_szGUID, 4);

	//
	// Figure out the new parent path
	//
	if (pNewParentBase->m_hmStatusType == HMSTATUS_SYSTEM)
	{
		wcscpy(szNewTemp, L"\\\\.\\root\\cimv2\\MicrosoftHealthMonitor:MicrosoftHM_SystemConfiguration.GUID=\"{@}\"");
	}
	else if (pNewParentBase->m_hmStatusType == HMSTATUS_DATAGROUP)
	{
		wcscpy(szNewTemp, L"\\\\.\\root\\cimv2\\MicrosoftHealthMonitor:MicrosoftHM_DataGroupConfiguration.GUID=\"");
		lstrcat(szNewTemp, pNewParentBase->m_szGUID);
		lstrcat(szNewTemp, L"\"");
	}
	else
	{
		MY_ASSERT(FALSE);
	}

	//
	// Delete the association from my parent to me.
	//
	wcscpy(szTemp, L"\\\\.\\root\\cimv2\\MicrosoftHealthMonitor:MicrosoftHM_DataGroupConfiguration.GUID=\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"");

	instName = SysAllocString(L"MicrosoftHM_ConfigurationAssociation");
//MY_OUTPUT(instName, 4);
	if ((hRes = g_pIWbemServices->GetObject(instName, 0L, NULL, &pObj, NULL)) != S_OK)
	{
		MY_HRESASSERT(hRes);
	}
	SysFreeString(instName);

	if (pObj)
	{
		hRes = pObj->SpawnInstance(0, &pNewObj);
		MY_HRESASSERT(hRes);
		pObj->Release();
		PutStrProperty(pNewObj, L"ChildPath", szTemp);
		PutStrProperty(pNewObj, L"ParentPath", szNewTemp);
		hRes = g_pIWbemServices->PutInstance(pNewObj, 0, NULL, &pResult);
		MY_HRESASSERT(hRes);
		pNewObj->Release();
		pNewObj = NULL;
	}

	DeleteDGConfig(TRUE);

	if (pNewParentBase->m_hmStatusType == HMSTATUS_SYSTEM)
	{
		wcscpy(szNewTemp, L"MicrosoftHM_SystemConfiguration.GUID=\\\"{@}\\\"");
	}
	else if (pNewParentBase->m_hmStatusType == HMSTATUS_DATAGROUP)
	{
		wcscpy(szNewTemp, L"MicrosoftHM_DataGroupConfiguration.GUID=\\\"");
		lstrcat(szNewTemp, pNewParentBase->m_szGUID);
		lstrcat(szNewTemp, L"\\\"");
	}
	else
	{
		MY_ASSERT(FALSE);
	}
	if (m_szParentObjPath)
	{
		delete [] m_szParentObjPath;
	}
	m_szParentObjPath = new TCHAR[wcslen(szNewTemp)+1];
	wcscpy(m_szParentObjPath, szNewTemp);

	m_pParentDG = (CDataGroup *) pNewParentBase;

	MY_OUTPUT(L"EXIT ***** CDataGroup::ModifyAssocForMove...", 4);
	return TRUE;
}
#endif

BOOL CDataGroup::ReceiveNewChildForMove(CBase *pBase)
{
	if (pBase->m_hmStatusType == HMSTATUS_DATAGROUP)
	{
		m_dataGroupList.push_back((CDataGroup *)pBase);
	}
	else if (pBase->m_hmStatusType == HMSTATUS_DATACOLLECTOR)
	{
		m_dataCollectorList.push_back((CDataCollector *)pBase);
	}
	else
	{
		MY_ASSERT(FALSE);
	}

	return TRUE;
}

BOOL CDataGroup::DeleteChildFromList(LPTSTR pszGUID)
{
	int i, iSize;
	CDataGroup* pDataGroup;
	DGLIST::iterator iaDG;
	CDataCollector* pDataCollector;
	DCLIST::iterator iaDC;
	BOOL bFound = FALSE;

	iSize = m_dataGroupList.size();
	iaDG=m_dataGroupList.begin();
	for (i=0; i<iSize; i++, iaDG++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		if (!_wcsicmp(pszGUID, pDataGroup->GetGUID()))
		{
			m_dataGroupList.erase(iaDG);
			bFound = TRUE;
			break;
		}
	}

	if (bFound == FALSE)
	{
		iSize = m_dataCollectorList.size();
		iaDC=m_dataCollectorList.begin();
		for (i=0; i<iSize; i++, iaDC++)
		{
			MY_ASSERT(i<m_dataCollectorList.size());
			pDataCollector = m_dataCollectorList[i];
			if (!_wcsicmp(pszGUID, pDataCollector->GetGUID()))
			{
				m_dataCollectorList.erase(iaDC);
				bFound = TRUE;
				break;
			}
		}
	}

	return bFound;
}

BOOL CDataGroup::DeleteDGConfig(BOOL bDeleteAssocOnly/*=FALSE*/)
{
	int i, iSize;
	CDataGroup* pDataGroup;
	CDataCollector* pDataCollector;
	HRESULT hRetRes = S_OK;
	TCHAR szTemp[1024];
	BSTR instName = NULL;

	MY_OUTPUT(L"ENTER ***** CDataGroup::DeleteDGConfig...", 4);
	MY_OUTPUT2(L"m_szGUID=%s", m_szGUID, 4);

	//
	// Delete the association from my parent to me.
	//
	// NOTE: Remember the triple backslashes on the inner quotes.
	if (!wcscmp(m_szParentObjPath, L"{@}"))
	{
		wcscpy(szTemp, L"MicrosoftHM_ConfigurationAssociation.ChildPath=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:MicrosoftHM_DataGroupConfiguration.GUID=\\\"");
		lstrcat(szTemp, m_szGUID);
		lstrcat(szTemp, L"\\\"\",ParentPath=\"MicrosoftHM_SystemConfiguration.GUID=\\\"{@}\\\"\"");
	}
	else
	{
		wcscpy(szTemp, L"MicrosoftHM_ConfigurationAssociation.ChildPath=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:MicrosoftHM_DataGroupConfiguration.GUID=\\\"");
		lstrcat(szTemp, m_szGUID);
		lstrcat(szTemp, L"\\\"\",ParentPath=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:");
		lstrcat(szTemp, m_szParentObjPath);
		lstrcat(szTemp, L"\"");
	}
	instName = SysAllocString(szTemp);
	MY_ASSERT(instName); if (!instName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	if ((hRetRes = g_pIWbemServices->DeleteInstance(instName, 0L,	NULL, NULL)) != S_OK)
	{
		SysFreeString(instName);
		instName = NULL;
		if (!wcscmp(m_szParentObjPath, L"{@}"))
		{
			wcscpy(szTemp, L"MicrosoftHM_ConfigurationAssociation.ChildPath=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:MicrosoftHM_DataGroupConfiguration.GUID=\\\"");
			lstrcat(szTemp, m_szGUID);
			lstrcat(szTemp, L"\\\"\",ParentPath=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:MicrosoftHM_SystemConfiguration.GUID=\\\"{@}\\\"\"");
			instName = SysAllocString(szTemp);
			if ((hRetRes = g_pIWbemServices->DeleteInstance(instName, 0L,	NULL, NULL)) != S_OK)
			{
//				MY_HRESASSERT(hRetRes);
				MY_OUTPUT(L"Delete failure", 4);
			}
			SysFreeString(instName);
			instName = NULL;
		}
		else
		{
			MY_OUTPUT(L"Delete failure", 4);
			MY_ASSERT(FALSE);
		}
	}
	else
	{
		SysFreeString(instName);
		instName = NULL;
	}

	if (bDeleteAssocOnly)
	{
		return TRUE;
	}

	//
	// Delete our exact instance
	//
	wcscpy(szTemp, L"MicrosoftHM_DataGroupConfiguration.GUID=\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"");
	instName = SysAllocString(szTemp);
	MY_ASSERT(instName); if (!instName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	if ((hRetRes = g_pIWbemServices->DeleteInstance(instName, 0L,	NULL, NULL)) != S_OK)
	{
		MY_OUTPUT(L"Delete failure", 4);
		MY_HRESASSERT(hRetRes);
	}
	SysFreeString(instName);
	instName = NULL;

	//
	// Traverse the complete hierarchy and delete all the way!
	//
	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		pDataGroup->DeleteDGConfig();
		delete pDataGroup;
	}
	m_dataGroupList.clear();

	iSize = m_dataCollectorList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];
		pDataCollector->DeleteDEConfig();
		pDataCollector->EnumDone();
		delete pDataCollector;
	}
	m_dataCollectorList.clear();

	//
	// Get rid of any associations to actions for this
	//
	g_pSystem->DeleteAllConfigActionAssoc(m_szGUID);

	MY_OUTPUT(L"EXIT ***** CDataGroup::DeleteDGConfig...", 4);
	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (instName)
		SysFreeString(instName);
	Cleanup();
	m_bValidLoad = FALSE;
	return FALSE;
}

BOOL CDataGroup::DeleteDGInternal(void)
{
	int i, iSize;
	CDataGroup* pDataGroup;
	CDataCollector* pDataCollector;

	MY_OUTPUT(L"ENTER ***** CDataGroup::DeleteDGInternal...", 4);

	//
	// Traverse the complete hierarchy and delete all the way!
	//
	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		delete pDataGroup;
	}
	m_dataGroupList.clear();

	iSize = m_dataCollectorList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];
		pDataCollector->EnumDone();
		delete pDataCollector;
	}
	m_dataCollectorList.clear();

	//
	// Get rid of any associations to actions for this
	//
//	g_pSystem->DeleteAllConfigActionAssoc(m_szGUID);

	MY_OUTPUT(L"EXIT ***** CDataGroup::DeleteDGInternal...", 4);
	return TRUE;
}

BOOL CDataGroup::FindAndCopyByGUID(LPTSTR pszGUID, ILIST* pConfigList, LPTSTR *pszOriginalParentGUID)
{
	HRESULT hRetRes = S_OK;
	int i, iSize;
	CDataGroup* pDataGroup;
	CDataCollector* pDataCollector;

	//
	// Traverse the complete hierarchy to find the DG, or DE to Reset.
	//
	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		if (!_wcsicmp(pszGUID, pDataGroup->GetGUID()))
		{
			hRetRes = pDataGroup->Copy(pConfigList, NULL, NULL);
			*pszOriginalParentGUID = m_szGUID;
			return hRetRes;
		}

		// Look at branch below to see if can find it
		hRetRes = pDataGroup->FindAndCopyByGUID(pszGUID, pConfigList, pszOriginalParentGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	iSize = m_dataCollectorList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];
		if (!_wcsicmp(pszGUID, pDataCollector->GetGUID()))
		{
			hRetRes = pDataCollector->Copy(pConfigList, NULL, NULL);
			*pszOriginalParentGUID = m_szGUID;
			return hRetRes;
		}
		// Look at branch below to see if can find it
		hRetRes = pDataCollector->FindAndCopyByGUID(pszGUID, pConfigList, pszOriginalParentGUID);
		if (hRetRes==S_OK)
		{
			return S_OK;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			return hRetRes;
		}
	}

	return WBEM_S_DIFFERENT;
}

HRESULT CDataGroup::Copy(ILIST* pConfigList, LPTSTR pszOldParentGUID, LPTSTR pszNewParentGUID)
{
	GUID guid;
	TCHAR szTemp[1024];
	TCHAR szNewGUID[1024];
	IWbemClassObject* pInst = NULL;
	IWbemClassObject* pInstCopy = NULL;
	IWbemClassObject* pInstAssocCopy = NULL;
	IWbemClassObject* pObj = NULL;
	HRESULT hRetRes = S_OK;
	int i, iSize;
	CDataGroup* pDataGroup;
	CDataCollector* pDataCollector;
	BSTR Language = NULL;
	BSTR Query = NULL;
	IEnumWbemClassObject *pEnum;
	ULONG uReturned;
	IWbemContext *pCtx = 0;
	LPTSTR pszParentPath = NULL;
	LPTSTR pszChildPath= NULL;
	LPTSTR pStr;

	MY_OUTPUT(L"ENTER ***** CDataGroup::Copy...", 1);

	if (m_bValidLoad == FALSE)
		return WBEM_E_INVALID_OBJECT;

	//
	// Get the origional starting point HMConfiguration instance.
	//
	wcscpy(szTemp, L"MicrosoftHM_Configuration.GUID=\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"");
	hRetRes = GetWbemObjectInst(&g_pIWbemServices, szTemp, NULL, &pInst);
	if (!pInst)
	{
		MY_HRESASSERT(hRetRes);
		return hRetRes;
	}

	//
	// Clone the instance, and change the GUID
	//
	hRetRes = pInst->Clone(&pInstCopy);
	if (FAILED(hRetRes))
	{
		MY_HRESASSERT(hRetRes);
		pInst->Release();
		pInst = NULL;
		return hRetRes;
	}
	hRetRes = CoCreateGuid(&guid);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	StringFromGUID2(guid, szNewGUID, 100);
	hRetRes = PutStrProperty(pInstCopy, L"GUID", szNewGUID);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	pConfigList->push_back(pInstCopy);

	//
	// Add instance of HMConfigurationAssociation where we are the child,
	// using the parent GUID passed in.
	// Change the GUIDs of both the Parent and Child.
	// also make sure that the machine name is not in the path, and is relative!
	//
	if (pszOldParentGUID != NULL)
	{
		Language = SysAllocString(L"WQL");
		MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		wcscpy(szTemp, L"REFERENCES OF {MicrosoftHM_Configuration.GUID=\"");
		lstrcat(szTemp, m_szGUID);
		lstrcat(szTemp, L"\"} WHERE ResultClass=MicrosoftHM_ConfigurationAssociation Role=ChildPath");
		Query = SysAllocString(szTemp);
		MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

		// Initialize IEnumWbemClassObject pointer
		pEnum = 0;

		// Issue query
   		hRetRes = g_pIWbemServices->ExecQuery(Language, Query, WBEM_FLAG_FORWARD_ONLY, 0, &pEnum);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		SysFreeString(Query);
		Query = NULL;
		SysFreeString(Language);
		Language = NULL;

		// Retrieve object in result set
		pObj = NULL;
		uReturned = 0;

		hRetRes = pEnum->Next(0, 1, &pObj, &uReturned);
	
		if (uReturned == 0)
		{
			hRetRes = WBEM_E_INVALID_OBJECT_PATH; goto error;
		}
	
		//
		// Change the GUIDs
		//
		hRetRes = GetStrProperty(pObj, L"ParentPath", &pszParentPath);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		hRetRes = GetStrProperty(pObj, L"ChildPath", &pszChildPath);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		pStr = wcschr(pszParentPath, '\"');
		if (pStr)
		{
			pStr++;
			wcsncpy(pStr, pszNewParentGUID, wcslen(pszNewParentGUID));
		}
		else
		{
			hRetRes = WBEM_E_INVALID_OBJECT_PATH; goto error;
		}

		pStr = wcschr(pszChildPath, '\"');
		if (pStr)
		{
			pStr++;
			wcsncpy(pStr, szNewGUID, wcslen(szNewGUID));
		}
		else
		{
			hRetRes = WBEM_E_INVALID_OBJECT_PATH; goto error;
		}

		hRetRes = pObj->Clone(&pInstAssocCopy);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = PutStrProperty(pInstAssocCopy, L"ParentPath", pszParentPath);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = PutStrProperty(pInstAssocCopy, L"ChildPath", pszChildPath);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		pConfigList->push_back(pInstAssocCopy);


		// Release it.
		pObj->Release();
		pObj = NULL;
		pEnum->Release();
		pEnum = NULL;
		delete [] pszParentPath;
		pszParentPath = NULL;
		delete [] pszChildPath;
		pszChildPath = NULL;
	}

	//
	// Add in all children
	//
	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		pDataGroup->Copy(pConfigList, m_szGUID, szNewGUID);
	}

	iSize = m_dataCollectorList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataCollectorList.size());
		pDataCollector = m_dataCollectorList[i];
		pDataCollector->Copy(pConfigList, m_szGUID, szNewGUID);
	}

	pInst->Release();
	pInst = NULL;

	MY_OUTPUT(L"EXIT ***** CDataGroup::Copy...", 1);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	if (pInst)
		pInst->Release();
	if (pObj)
		pObj->Release();
	if (pEnum)
		pEnum->Release();
	if (Query)
		SysFreeString(Query);
	if (Language)
		SysFreeString(Language);
	if (pszParentPath)
		delete [] pszParentPath;
	if (pszChildPath)
		delete [] pszChildPath;
	Cleanup();
	m_bValidLoad = FALSE;
	return hRetRes;
}

CBase *CDataGroup::GetParentPointerFromGUID(LPTSTR pszGUID)
{
	int i, iSize;
	CDataGroup* pDataGroup;
	CDataCollector* pDataCollector;
	BOOL bFound = FALSE;
	CBase *pBase;

	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		if (!_wcsicmp(pszGUID, pDataGroup->GetGUID()))
		{
			pBase = pDataGroup;
			bFound = TRUE;
			break;
		}
		// Look at branch below to see if can find it
		pBase = pDataGroup->GetParentPointerFromGUID(pszGUID);
		if (pBase)
		{
			bFound = TRUE;
			break;
		}
	}

	if (bFound == FALSE)
	{
		iSize = m_dataCollectorList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_dataCollectorList.size());
			pDataCollector = m_dataCollectorList[i];
			if (!_wcsicmp(pszGUID, pDataCollector->GetGUID()))
			{
				pBase = pDataCollector;
				bFound = TRUE;
				break;
			}
			// Look at branch below to see if can find it
			pBase = pDataCollector->GetParentPointerFromGUID(pszGUID);
			if (pBase)
			{
				bFound = TRUE;
				break;
			}
		}
	}

	if (bFound == TRUE)
	{
		return pBase;
	}
	else
	{
		return NULL;
	}
}

CBase *CDataGroup::FindImediateChildByName(LPTSTR pszName)
{
	int i, iSize;
	CDataGroup* pDataGroup;
	CDataCollector* pDataCollector;
	BOOL bFound = FALSE;
	CBase *pBase;

	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		if (!_wcsicmp(pszName, pDataGroup->m_szName))
		{
			pBase = pDataGroup;
			bFound = TRUE;
			break;
		}
	}

	if (bFound == FALSE)
	{
		iSize = m_dataCollectorList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_dataCollectorList.size());
			pDataCollector = m_dataCollectorList[i];
			if (!_wcsicmp(pszName, pDataCollector->m_szName))
			{
				pBase = pDataCollector;
				bFound = TRUE;
				break;
			}
		}
	}

	if (bFound == TRUE)
	{
		return pBase;
	}
	else
	{
		return NULL;
	}
}

BOOL CDataGroup::GetNextChildName(LPTSTR pszChildName, LPTSTR pszOutName)
{
	TCHAR szTemp[1024];
	TCHAR szIndex[1024];
	int i, iSize;
	BOOL bFound;
	CDataGroup* pDataGroup;
	CDataCollector* pDataCollector;
	int index;

	// We are here because we know that one exists already with the same name.
	// So, lets start off trying to guess what the next name should be and get one.
	index = 0;
	bFound = TRUE;
	while (bFound == TRUE)
	{
		wcscpy(szTemp, pszChildName);
		_itot(index, szIndex, 10);
		lstrcat(szTemp, L" ");
		lstrcat(szTemp, szIndex);

		bFound = FALSE;
		iSize = m_dataGroupList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_dataGroupList.size());
			pDataGroup = m_dataGroupList[i];
			if (!_wcsicmp(szTemp, pDataGroup->m_szName))
			{
				bFound = TRUE;
				break;
			}
		}
		iSize = m_dataCollectorList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_dataCollectorList.size());
			pDataCollector = m_dataCollectorList[i];
			if (pDataCollector->m_bValidLoad == FALSE)
				break;
			if (!_wcsicmp(szTemp, pDataCollector->m_szName))
			{
				bFound = TRUE;
				break;
			}
		}
		index++;
	}
	wcscpy(pszOutName, szTemp);

	return TRUE;
}

CBase *CDataGroup::FindPointerFromName(LPTSTR pszName)
{
	int i, iSize;
	CDataGroup* pDataGroup;
	CDataCollector* pDataCollector;
	BOOL bFound = FALSE;
	CBase *pBase;

	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		if (!_wcsicmp(pszName, pDataGroup->GetGUID()))
		{
			pBase = pDataGroup;
			bFound = TRUE;
			break;
		}
		// Look at branch below to see if can find it
		pBase = pDataGroup->FindPointerFromName(pszName);
		if (pBase)
		{
			bFound = TRUE;
			break;
		}
	}

	if (bFound == FALSE)
	{
		iSize = m_dataCollectorList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_dataCollectorList.size());
			pDataCollector = m_dataCollectorList[i];
			if (!_wcsicmp(pszName, pDataCollector->GetGUID()))
			{
				pBase = pDataCollector;
				bFound = TRUE;
				break;
			}
			// Look at branch below to see if can find it
			pBase = pDataCollector->FindPointerFromName(pszName);
			if (pBase)
			{
				bFound = TRUE;
				break;
			}
		}
	}

	if (bFound == TRUE)
	{
		return pBase;
	}
	else
	{
		return NULL;
	}
}

BOOL CDataGroup::SetCurrState(HM_STATE state, BOOL bCheckChanges/*FALSE*/)
{

	m_lCurrState = state;

	return TRUE;
}

//
// Do string replacement for the Message property
//
BOOL CDataGroup::FormatMessage(IWbemClassObject* pInstance)
{
	BSTR PropName = NULL;
	LPTSTR pszMsg = NULL;
	SAFEARRAY *psaNames = NULL;
	long lNum;
	HRESULT hRetRes = S_OK;
	LPTSTR pszDest = NULL;
	LPTSTR pszUpperMsg = NULL;
	LPTSTR pszNewMsg = NULL;
	LPTSTR pStr = NULL;
	LPTSTR pStr2 = NULL;
	LPTSTR pStrStart = NULL;
	TOKENSTRUCT tokenElmnt;
	TOKENSTRUCT *pTokenElmnt;
	REPSTRUCT repElmnt;
	REPSTRUCT *pRepElmnt;
	REPSTRUCT *pRepElmnt2;
	REPLIST replacementList;
	int i, iSize, iSizeNeeded, j;
	long lLower, lUpper; 
	static TOKENLIST tokenList;

	//
	// We only need to build the set of tokens one time, then from then on
	// we just need to fill in the values for what the replacement strings are.
	//
	if (tokenList.size() == 0)
	{
		//
		// First we build the set of tokens that we are looking for. Each property that
		// is in the ThresholdStatusInstance. We build that set of strings,
		// and the values to replace with.
		//

		//
		// Now go through ThresholdInstance, which is where the Message String
		// actually lives. Get that set of properties for the Instances.
		//
		psaNames = NULL;
		hRetRes = pInstance->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames);
		if (SUCCEEDED(hRetRes))
		{
			// Get the number of properties.
			SafeArrayGetLBound(psaNames, 1, &lLower);
			SafeArrayGetUBound(psaNames, 1, &lUpper);

			// For each property...
			for (long l=lLower; l<=lUpper; l++) 
			{
				// Get this property.
				hRetRes = SafeArrayGetElement(psaNames, &l, &PropName);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
				// Will want to skip some that don't make sense.
				if (!wcscmp(PropName, L"Message"))
				{
					SysFreeString(PropName);
					PropName = NULL;
					continue;
				}
				else if (!wcscmp(PropName, L"ResetMessage"))
				{
					SysFreeString(PropName);
					PropName = NULL;
					continue;
				}
				else if (!wcscmp(PropName, L"EmbeddedCollectedInstance"))
				{
					SysFreeString(PropName);
					PropName = NULL;
					continue;
				}
				tokenElmnt.szOrigToken = new TCHAR[wcslen(PropName)+1];
				MY_ASSERT(tokenElmnt.szOrigToken); if (!tokenElmnt.szOrigToken) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				wcscpy(tokenElmnt.szOrigToken, PropName);
				tokenElmnt.szToken = new TCHAR[wcslen(PropName)+3];
				MY_ASSERT(tokenElmnt.szToken); if (!tokenElmnt.szToken) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				wcscpy(tokenElmnt.szToken, L"%");
				wcscat(tokenElmnt.szToken, PropName);
				wcscat(tokenElmnt.szToken, L"%");
				_wcsupr(tokenElmnt.szToken);
				tokenElmnt.szReplacementText = NULL;
				tokenList.push_back(tokenElmnt);
				SysFreeString(PropName);
				PropName = NULL;
			}
			SafeArrayDestroy(psaNames);
			psaNames = NULL;
		}
	}

	//
	// Now we can fill in the values to use for the replacement strings.
	//

	//
	// Now go through each ThresholdInstance, which is where the Message String
	// actually lives. Get that set of properties of the Instance,
	// And do the message formatting while there.
	//

	//
	// Get the replacement strings for this instance
	//
	iSize = tokenList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<tokenList.size());
		pTokenElmnt = &tokenList[i];
		if (pTokenElmnt->szReplacementText != NULL)
		{
			delete [] pTokenElmnt->szReplacementText;
		}
		
		if (!wcscmp(pTokenElmnt->szToken, L"%TESTCONDITION%"))
		{
			hRetRes = GetUint32Property(pInstance, pTokenElmnt->szOrigToken, &lNum);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			MY_ASSERT(lNum<9);
			pStr = new TCHAR[wcslen(conditionLocStr[lNum])+1];
			MY_ASSERT(pStr); if (!pStr) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			wcscpy(pStr, conditionLocStr[lNum]);
		}
		else if (!wcscmp(pTokenElmnt->szToken, L"%STATE%"))
		{
			hRetRes = GetUint32Property(pInstance, pTokenElmnt->szOrigToken, &lNum);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			MY_ASSERT(lNum<10);
			pStr = new TCHAR[wcslen(stateLocStr[lNum])+1];
			MY_ASSERT(pStr); if (!pStr) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			wcscpy(pStr, stateLocStr[lNum]);
		}
		else
		{
			hRetRes = GetAsStrProperty(pInstance, pTokenElmnt->szOrigToken, &pStr);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		}
		pTokenElmnt->szReplacementText = pStr;
	}

	//
	// Now we have both lists of tokens that have replacement
	// strings that go with them and the replacement strings
	// that go with them
	//

	//
	// Do formatting of Message. We replace all Variable Tags.
	// Sample string -
	// "Drive %InstanceName% is full. Currently at %CurrentValue%%."
	//

	//
	// Get the origional un-formatted message first.
	// To make case in-sensitive, do a _strdup and then a _wcsupr on the string
	// to scan run the code on it, and then free the duplicated string.
	//
	// If it uses resource IDs, then get that string first, then format that!!!
	hRetRes = GetStrProperty(pInstance, L"Message", &pszMsg);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	pszUpperMsg = _wcsdup(pszMsg);
	MY_ASSERT(pszUpperMsg); if (!pszUpperMsg) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	_wcsupr(pszUpperMsg);

	//
	// First loop through and find every token that needs replacing.
	// Put that info into the replacement list.
	//
	// We will do strstr() for each special token until there are no more to find
	// for each. At each find we will store the offset into the string of what
	// we found. Then we sort by what came first.
	//
	// Quick test to see if it is worth searching
	if (wcschr(pszUpperMsg, '%'))
	{
		iSize = tokenList.size();
		pStrStart = pszUpperMsg;
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<tokenList.size());
			pTokenElmnt = &tokenList[i];
			pStr = wcsstr(pStrStart, pTokenElmnt->szToken);
			if (pStr != NULL)
			{
				repElmnt.pStartStr = pszMsg+(pStr-pszUpperMsg);
				repElmnt.len = wcslen(pTokenElmnt->szToken);
				repElmnt.pszReplacementText = pTokenElmnt->szReplacementText;
				replacementList.push_back(repElmnt);
				i--;
				pStrStart = pStr+1;
			}
			else
			{
				pStrStart = pszUpperMsg;
			}
		}

		//
		// Need to look for replacement strings that have not been replaced.
		// Simply search for %EmbeddedCollectedInstance. and find the end % for each
		// Replace them with <null>
		//
		pStrStart = pszUpperMsg;
		while (TRUE)
		{
			pStr = wcsstr(pStrStart, L"%EMBEDDEDCOLLECTEDINSTANCE.");
			if (pStr != NULL)
			{
				repElmnt.pStartStr = pszMsg+(pStr-pszUpperMsg);
				pStr2 = pStr;
				while (pStr2++)
				{
					if (*pStr2=='%' || iswspace(*pStr2))
						break;
				}
				if (*pStr2=='%')
				{
					repElmnt.len = (pStr2-pStr)+1;
					repElmnt.pszReplacementText = L"<null>";
					replacementList.push_back(repElmnt);
				}
				pStrStart = pStr+1;
			}
			else
			{
				break;
			}
		}
	}

	iSize = replacementList.size();
	if (iSize != 0)
	{
		//
		// Next, sort the replacement list from the first string to
		// be replaced, to the last. Shell sort, Knuth, Vol13, pg. 84.
		//
		for (int gap=iSize/2; 0<gap; gap/=2)
		{
			for (i=gap; i<iSize; i++)
			{
				for (j=i-gap; 0<=j; j-=gap)
				{
					MY_ASSERT(j+gap<replacementList.size());
					pRepElmnt = &replacementList[j+gap];
					MY_ASSERT(j<replacementList.size());
					pRepElmnt2 = &replacementList[j];
					if (pRepElmnt->pStartStr < pRepElmnt2->pStartStr)
					{
						MY_ASSERT(j<replacementList.size());
						repElmnt = replacementList[j];
						MY_ASSERT(j+gap<replacementList.size());
						replacementList[j] = replacementList[j+gap];
						MY_ASSERT(j+gap<replacementList.size());
						replacementList[j+gap] = repElmnt;
					}
				}
			}
		}

		//
		// Next, figure out the size needed for the Message with
		// everything replaced.
		//
		iSizeNeeded = wcslen(pszMsg)+1;
		iSize = replacementList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<replacementList.size());
			pRepElmnt = &replacementList[i];
			iSizeNeeded -= pRepElmnt->len;
			iSizeNeeded += wcslen(pRepElmnt->pszReplacementText);
		}
		pszNewMsg = new TCHAR[iSizeNeeded];
		MY_ASSERT(pszNewMsg); if (!pszNewMsg) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		*pszNewMsg = '\0';

		//
		// Next, we loop through and do the actual replacements.
		// "Drive %InstanceName% is full. Currently at %CurrentValue%%."
		//
		pszDest = pszMsg;
		iSize = replacementList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<replacementList.size());
			pRepElmnt = &replacementList[i];
			*(pRepElmnt->pStartStr) = '\0';
			wcscat(pszNewMsg, pszDest);
			wcscat(pszNewMsg, pRepElmnt->pszReplacementText);
//XXXWould memcpy be faster???							memcpy(pszDest, source, charCnt*sizeof(TCHAR));
			pszDest = pRepElmnt->pStartStr+pRepElmnt->len;
		}
		wcscat(pszNewMsg, pszDest);
		PutStrProperty(pInstance, L"Message", pszNewMsg);
		delete [] pszNewMsg;
		pszNewMsg = NULL;
		replacementList.clear();
	}
	else
	{
		PutStrProperty(pInstance, L"Message", pszMsg);
	}

	delete [] pszMsg;
	pszMsg = NULL;
	free(pszUpperMsg);
	pszUpperMsg = NULL;

	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (PropName)
		SysFreeString(PropName);
	if (psaNames)
		SafeArrayDestroy(psaNames);
	if (pszNewMsg)
		delete [] pszNewMsg;
	if (pszMsg)
		delete [] pszMsg;
	if (pszUpperMsg)
		free(pszUpperMsg);
	Cleanup();
	m_bValidLoad = FALSE;
	return hRetRes;
}

BOOL CDataGroup::SendReminderActionIfStateIsSame(IWbemObjectSink* pActionEventSink, IWbemObjectSink* pActionTriggerEventSink, IWbemClassObject* pActionInstance, IWbemClassObject* pActionTriggerInstance, unsigned long ulTriggerStates)
{
	HRESULT hRetRes = S_OK;
	IWbemClassObject* pInstance = NULL;
	VARIANT v;
	GUID guid;
	TCHAR szStatusGUID[100];
	VariantInit(&v);

	if (m_bValidLoad == FALSE)
		return FALSE;
	//
	// Check to see if still in the desired state
	//
	if (!(ulTriggerStates&(1<<m_lCurrState)))
	{
		return TRUE;
	}

	hRetRes = GetHMDataGroupStatusInstance(&pInstance, TRUE);
	if (SUCCEEDED(hRetRes))
	{
		PutUint32Property(pActionTriggerInstance, L"State", m_lCurrState);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		VariantInit(&v);
		V_VT(&v) = VT_UNKNOWN;
		V_UNKNOWN(&v) = (IUnknown*)pInstance;
		(V_UNKNOWN(&v))->AddRef();
		hRetRes = (pActionTriggerInstance)->Put(L"EmbeddedStatusEvent", 0L, &v, 0L);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		VariantClear(&v);

		if (pActionEventSink) 
		{
			hRetRes = CoCreateGuid(&guid);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			StringFromGUID2(guid, szStatusGUID, 100);
			hRetRes = PutStrProperty(pActionInstance, L"StatusGUID", szStatusGUID);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			hRetRes = pActionEventSink->Indicate(1, &pActionInstance);
			//WBEM_E_SERVER_TOO_BUSY is Ok. Wbem will deliver.
			if (FAILED(hRetRes) && hRetRes != WBEM_E_SERVER_TOO_BUSY)
			{
				MY_HRESASSERT(hRetRes);
				MY_OUTPUT(L"Failed on Indicate!", 4);
			}
		}
		if (pActionTriggerEventSink) 
		{
			hRetRes = pActionEventSink->Indicate(1, &pActionTriggerInstance);
			//WBEM_E_SERVER_TOO_BUSY is Ok. Wbem will deliver.
			if (FAILED(hRetRes) && hRetRes != WBEM_E_SERVER_TOO_BUSY)
			{
				MY_HRESASSERT(hRetRes);
				MY_OUTPUT(L"Failed on Indicate!", 4);
			}
		}

		pInstance->Release();
		pInstance = NULL;
	}
	else
	{
		MY_HRESASSERT(hRetRes);
		MY_OUTPUT(L"failed to get instance!", 4);
	}

	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (pInstance)
		pInstance->Release();
	return FALSE;
}

HRESULT CDataGroup::CheckForBadLoad(void)
{
	HRESULT hRetRes = S_OK;
	IWbemClassObject* pObj = NULL;
	TCHAR szTemp[1024];
	IWbemClassObject* pInstance = NULL;

	if (m_bValidLoad == FALSE)
	{
		wcscpy(szTemp, L"MicrosoftHM_DataGroupConfiguration.GUID=\"");
		lstrcat(szTemp, m_szGUID);
		lstrcat(szTemp, L"\"");
		hRetRes = GetWbemObjectInst(&g_pIWbemServices, szTemp, NULL, &pObj);
		if (!pObj)
		{
			MY_HRESASSERT(hRetRes);
			return S_FALSE;
		}
		hRetRes = LoadInstanceFromMOF(pObj, NULL, L"", TRUE);
		// Here is where we can try and send out a generic SOS if the load failed each time!!!
		if (hRetRes != S_OK)
		{
			if (GetHMDataGroupStatusInstance(&pInstance, TRUE) == S_OK)
			{
				mg_DGEventList.push_back(pInstance);
			}
		}
		else
		{
			if (GetHMDataGroupStatusInstance(&pInstance, TRUE) == S_OK)
			{
				mg_DGEventList.push_back(pInstance);
			}
		}
		MY_HRESASSERT(hRetRes);
		pObj->Release();
		pObj = NULL;
		return hRetRes;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\evtprov.h ===
// BaseEventProvider.h: interface for the CBaseEventProvider class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BASEEVENTPROVIDER_H__1CCFABA4_1A8C_11D2_BDD9_00C04FA35447__INCLUDED_)
#define AFX_BASEEVENTPROVIDER_H__1CCFABA4_1A8C_11D2_BDD9_00C04FA35447__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "datacltr.h"

class CBaseEventProvider :	public IWbemEventProvider, public IWbemProviderInit
{
public:
	CBaseEventProvider();
	virtual ~CBaseEventProvider();

public:
// IUnknown
	STDMETHODIMP			QueryInterface(REFIID riid, LPVOID* ppv);
	STDMETHODIMP_(ULONG)	AddRef(void);
	STDMETHODIMP_(ULONG)	Release(void);

// IWbemEventProvider
	HRESULT STDMETHODCALLTYPE ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags);
// IWbemEventProviderInit
	HRESULT STDMETHODCALLTYPE Initialize(	LPWSTR pszUser,
											LONG lFlags,
											LPWSTR pszNamespace,
											LPWSTR pszLocale,
											IWbemServices __RPC_FAR *pNamespace,
											IWbemContext __RPC_FAR *pCtx,
											IWbemProviderInitSink __RPC_FAR *pInitSink);

// CBaseEventProvider

protected:
	ULONG m_cRef;
	IWbemServices* m_pIWbemServices;
//	CSystem* m_pSystem;
//	IWbemObjectSink* m_pEvtSink;
};

class CSystemEventProvider : public CBaseEventProvider
{
	STDMETHODIMP_(ULONG) Release(void);
	HRESULT STDMETHODCALLTYPE ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags);
};

class CDataGroupEventProvider : public CBaseEventProvider
{
	STDMETHODIMP_(ULONG) Release(void);
	HRESULT STDMETHODCALLTYPE ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags);
};

class CDataCollectorEventProvider : public CBaseEventProvider
{
	STDMETHODIMP_(ULONG) Release(void);
	HRESULT STDMETHODCALLTYPE ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags);
};

class CDataCollectorPerInstanceEventProvider : public CBaseEventProvider
{
	STDMETHODIMP_(ULONG) Release(void);
	HRESULT STDMETHODCALLTYPE ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags);
};

//class CDataCollectorStatisticsEventProvider : public CBaseEventProvider
//{
//	STDMETHODIMP_(ULONG) Release(void);
//	HRESULT STDMETHODCALLTYPE ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags);
//};

class CThresholdEventProvider : public CBaseEventProvider
{
	STDMETHODIMP_(ULONG) Release(void);
	HRESULT STDMETHODCALLTYPE ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags);
};

//class CThresholdInstanceEventProvider : public CBaseEventProvider
//{
//	STDMETHODIMP_(ULONG) Release(void);
//	HRESULT STDMETHODCALLTYPE ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags);
//};

class CActionEventProvider : public CBaseEventProvider
{
	STDMETHODIMP_(ULONG) Release(void);
	HRESULT STDMETHODCALLTYPE ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags);
};

class CActionTriggerEventProvider : public CBaseEventProvider
{
	STDMETHODIMP_(ULONG) Release(void);
	HRESULT STDMETHODCALLTYPE ProvideEvents(IWbemObjectSink __RPC_FAR *pSink, long lFlags);
};

#endif // !defined(AFX_BASEEVENTPROVIDER_H__1CCFABA4_1A8C_11D2_BDD9_00C04FA35447__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\factory.cpp ===
// Factory.cpp: implementation of the CFactory class.
//
//////////////////////////////////////////////////////////////////////

#include "hmagent.h"
#include "consumer.h"
#include "system.h"
#include "evtprov.h"
#include "instprov.h"
#include "methprov.h"
#include "factory.h"
#include "Provider.h"

extern long g_cComponents;
extern long g_cServerLocks;
//extern CSystem* g_pSystem;

//extern HANDLE g_hEvtReady;

//////////////////////////////////////////////////////////////////////
// CHealthMonFactory - Base Class Factory
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBaseFactory::CBaseFactory()
{
	m_cRef = 0L;
}

CBaseFactory::~CBaseFactory()
{
}

//////////////////////////////////////////////////////////////////////
// Query Interface
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CBaseFactory::QueryInterface(REFIID riid, LPVOID* ppv)
{
	*ppv=NULL;

	if (IID_IUnknown==riid || IID_IClassFactory==riid)
	{
		*ppv=this;
		AddRef();
		return S_OK;
	}

	return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////
// AddRef/Release()
//////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CBaseFactory::AddRef(void)
{
    return InterlockedIncrement((long*)&m_cRef);
}

STDMETHODIMP_(ULONG) CBaseFactory::Release(void)
{
    ULONG ulNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == ulNewCount)
	{
        delete this;
	}
    
    return ulNewCount;
}

//////////////////////////////////////////////////////////////////////
// Create Instance
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CBaseFactory::CreateInstance(LPUNKNOWN	pUnkOuter, REFIID riid, LPVOID* ppObj)
{
	*ppObj = NULL;

	if (NULL != pUnkOuter)
	{
		return CLASS_E_NOAGGREGATION;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Lock Server
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CBaseFactory::LockServer(BOOL fLock)
{
	if (fLock)
	{
		InterlockedIncrement((LONG *) &g_cServerLocks);
	}
	else
	{
		InterlockedDecrement((LONG *) &g_cServerLocks);
	}

	return S_OK;
}


//////////////////////////////////////////////////////////////////////
// Class Factory for Consumer (original agent)
//		Create instance of CConsumer
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CConsFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, LPVOID *ppv)
{
	HRESULT hr;
    CProvider *pProvider = NULL;

    if (pUnkOuter)
	{
		return E_FAIL;
	}

    pProvider = new CProvider();

    if (pProvider == NULL)
	{
		*ppv = NULL;
		return E_OUTOFMEMORY;
	}

    if (pProvider)
    {
        hr = pProvider->QueryInterface(riid, ppv);
		MY_HRESASSERT(hr);
    }
    
    return NOERROR;
}

//////////////////////////////////////////////////////////////////////
// Class Factory for Event Providers
//		Create instance of CBaseEventprovider
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CSystemEvtProvFactory::CreateInstance(LPUNKNOWN	pUnkOuter, REFIID riid, LPVOID* ppObj)
{
	*ppObj = NULL;

	if (NULL != pUnkOuter)
	{
		return CLASS_E_NOAGGREGATION;
	}

	CSystemEventProvider* pProvider = new CSystemEventProvider();

	if (!pProvider)
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = pProvider->QueryInterface(riid, ppObj);
	MY_HRESASSERT(hr);

	return hr;
}

STDMETHODIMP CDataGroupEvtProvFactory::CreateInstance(LPUNKNOWN	pUnkOuter, REFIID riid, LPVOID* ppObj)
{
	*ppObj = NULL;

	if (NULL != pUnkOuter)
	{
		return CLASS_E_NOAGGREGATION;
	}

	CDataGroupEventProvider* pProvider = new CDataGroupEventProvider;

	if (!pProvider)
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = pProvider->QueryInterface(riid, ppObj);
	MY_HRESASSERT(hr);

	return hr;
}

STDMETHODIMP CDataCollectorEvtProvFactory::CreateInstance(LPUNKNOWN	pUnkOuter, REFIID riid, LPVOID* ppObj)
{
	*ppObj = NULL;

	if (NULL != pUnkOuter)
	{
		return CLASS_E_NOAGGREGATION;
	}

	CDataCollectorEventProvider* pProvider = new CDataCollectorEventProvider;

	if (!pProvider)
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = pProvider->QueryInterface(riid, ppObj);
	MY_HRESASSERT(hr);

	return hr;
}

STDMETHODIMP CDataCollectorPerInstanceEvtProvFactory::CreateInstance(LPUNKNOWN	pUnkOuter, REFIID riid, LPVOID* ppObj)
{
	*ppObj = NULL;

	if (NULL != pUnkOuter)
	{
		return CLASS_E_NOAGGREGATION;
	}

	CDataCollectorPerInstanceEventProvider* pProvider = new CDataCollectorPerInstanceEventProvider;

	if (!pProvider)
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = pProvider->QueryInterface(riid, ppObj);
	MY_HRESASSERT(hr);

	return hr;
}


STDMETHODIMP CThresholdEvtProvFactory::CreateInstance(LPUNKNOWN	pUnkOuter, REFIID riid, LPVOID* ppObj)
{
	*ppObj = NULL;

	if (NULL != pUnkOuter)
	{
		return CLASS_E_NOAGGREGATION;
	}

	CThresholdEventProvider* pProvider = new CThresholdEventProvider;

	if (!pProvider)
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = pProvider->QueryInterface(riid, ppObj);
	MY_HRESASSERT(hr);

	return hr;
}


STDMETHODIMP CActionEvtProvFactory::CreateInstance(LPUNKNOWN	pUnkOuter, REFIID riid, LPVOID* ppObj)
{
	*ppObj = NULL;

	if (NULL != pUnkOuter)
	{
		return CLASS_E_NOAGGREGATION;
	}

	CActionEventProvider* pProvider = new CActionEventProvider;

	if (!pProvider)
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = pProvider->QueryInterface(riid, ppObj);
	MY_HRESASSERT(hr);

	return hr;
}

STDMETHODIMP CActionTriggerEvtProvFactory::CreateInstance(LPUNKNOWN	pUnkOuter, REFIID riid, LPVOID* ppObj)
{
	*ppObj = NULL;

	if (NULL != pUnkOuter)
	{
		return CLASS_E_NOAGGREGATION;
	}

	CActionTriggerEventProvider* pProvider = new CActionTriggerEventProvider;

	if (!pProvider)
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = pProvider->QueryInterface(riid, ppObj);
	MY_HRESASSERT(hr);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// Class Factory for Instance Provider.
//		Create instance of CBaseInstanceProvider
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CInstProvFactory::CreateInstance(LPUNKNOWN	pUnkOuter, REFIID riid, LPVOID* ppObj)
{
	*ppObj = NULL;

	if (NULL != pUnkOuter)
	{
		return CLASS_E_NOAGGREGATION;
	}

	CBaseInstanceProvider* pProvider = new CBaseInstanceProvider;

	if (!pProvider)
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = pProvider->QueryInterface(riid, ppObj);
	MY_HRESASSERT(hr);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// Class Factory for Method Provider.
//		Create instance of CCMethProvFactory
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CMethProvFactory::CreateInstance(LPUNKNOWN	pUnkOuter, REFIID riid, LPVOID* ppObj)
{
	*ppObj = NULL;

	if (NULL != pUnkOuter)
		return CLASS_E_NOAGGREGATION;

	CBaseMethodProvider* pProvider = new CBaseMethodProvider;

	if (!pProvider)
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = pProvider->QueryInterface(riid, ppObj);
	MY_HRESASSERT(hr);

	return hr;
}

#ifdef SAVE
STDMETHODIMP CDataCollectorStatisticsEvtProvFactory::CreateInstance(LPUNKNOWN	pUnkOuter, REFIID riid, LPVOID* ppObj)
{
	*ppObj = NULL;

	if (NULL != pUnkOuter)
	{
		return CLASS_E_NOAGGREGATION;
	}

	CDataCollectorStatisticsEventProvider* pProvider = new CDataCollectorStatisticsEventProvider;

	if (!pProvider)
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = pProvider->QueryInterface(riid, ppObj);
	MY_HRESASSERT(hr);

	return hr;
}
#endif

#ifdef SAVE
STDMETHODIMP CThresholdInstanceEvtProvFactory::CreateInstance(LPUNKNOWN	pUnkOuter, REFIID riid, LPVOID* ppObj)
{
	*ppObj = NULL;

	if (NULL != pUnkOuter)
		return CLASS_E_NOAGGREGATION;

//ZZZMY_OUTPUT(L"BLOCK - BLOCK CThresholdInstanceEvtProvFactory::CreateInstance BLOCK - g_hEvtReady BLOCK WAIT", 1);
//ZZZ	if (WaitForSingleObject(g_hEvtReady, 0) != WAIT_OBJECT_0 || g_pSystem == NULL)
//ZZZ	{
//ZZZMY_OUTPUT(L"BLOCK - BLOCK CThresholdInstanceEvtProvFactory::CreateInstance BLOCK - g_hEvtReady BLOCK NOT READY", 1);
//ZZZ		return E_FAIL;
//ZZZ	}
//ZZZMY_OUTPUT(L"BLOCK - BLOCK CThresholdInstanceEvtProvFactory::CreateInstance BLOCK - g_hEvtReady BLOCK READY", 1);
//	MY_ASSERT(g_pSystem);

	CThresholdInstanceEventProvider* pProvider = new CThresholdInstanceEventProvider;

	if (!pProvider)
		return E_OUTOFMEMORY;

	HRESULT hr = pProvider->QueryInterface(riid, ppObj);
	MY_HRESASSERT(hr);

	return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\global.h ===
//***************************************************************************
//
//  GLOBAL.H
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: Global helper functions, defines, macros...
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#if !defined( __GLOBAL_H )
#define __GLOBAL_H

#include <crtdbg.h>
#include <stdio.h>
#include <tchar.h>
#include <vector>
#include "wmihelper.h"

extern IWbemServices* g_pIWbemServices;
extern IWbemServices* g_pIWbemServicesCIMV2;
extern IWbemObjectSink* g_pSystemEventSink;
extern IWbemObjectSink* g_pDataGroupEventSink;
extern IWbemObjectSink* g_pDataCollectorEventSink;
extern IWbemObjectSink* g_pDataCollectorPerInstanceEventSink;
extern IWbemObjectSink* g_pDataCollectorStatisticsEventSink;
extern IWbemObjectSink* g_pThresholdEventSink;
//extern IWbemObjectSink* g_pThresholdInstanceEventSink;
extern IWbemObjectSink* g_pActionEventSink;
extern IWbemObjectSink* g_pActionTriggerEventSink;
extern HINSTANCE g_hResLib;

//#define MAX_INT			0x7fff
//#define MAX_UINT		0xffff
#define MAX_LONG		0x7fffffffL
#define MAX_ULONG		0xffffffffL
#define MAX_I64		0x7fffffffffffffffL
#define MAX_UI64		0xffffffffffffffffL
#define MAX_FLOAT  	3.402823E+38F
#define MAX_DOUBLE  	1.797693E+308
#define MIN_DOUBLE  	-1.7E+307

//#define MY_OUTPUT_TO_FILE 1

#ifdef _DEBUG
#ifdef MY_OUTPUT_TO_FILE
extern FILE* debug_f;
#define MY_OUTPUT(msg, iLevel)\
{\
TCHAR	l_buf[1024];\
SYSTEMTIME l_st;\
if (iLevel >= 4) {\
	GetLocalTime(&l_st);\
	wsprintf(l_buf, L"%02d:%02d:%02d %08x %d, %S, %s\n",\
					l_st.wHour, l_st.wMinute, l_st.wSecond,\
					GetCurrentThreadId(), (int)__LINE__, __FILE__, (msg));\
	OutputDebugString(l_buf);\
	_ftprintf(debug_f, l_buf);\
	fflush(debug_f);\
}\
}
#else
#define MY_OUTPUT(msg, iLevel)\
{\
TCHAR	l_buf[1024];\
SYSTEMTIME l_st;\
if (iLevel >= 4) {\
	GetLocalTime(&l_st);\
	wsprintf(l_buf, L"%02d:%02d:%02d %08x %d, %S, %s\n",\
					l_st.wHour, l_st.wMinute, l_st.wSecond,\
					GetCurrentThreadId(), (int)__LINE__, __FILE__, msg);\
	OutputDebugString(l_buf);\
}\
}
#endif
#else
#ifdef MY_OUTPUT_TO_FILE
extern FILE* debug_f;
#define MY_OUTPUT(msg, iLevel)\
{\
TCHAR	l_buf[1024];\
SYSTEMTIME l_st;\
if (iLevel >= 4) {\
	GetLocalTime(&l_st);\
	wsprintf(l_buf, L"%02d:%02d:%02d %08x %d, %S, %s\n",\
					l_st.wHour, l_st.wMinute, l_st.wSecond,\
					GetCurrentThreadId(), (int)__LINE__, __FILE__, (msg));\
	_ftprintf(debug_f, l_buf);\
	fflush(debug_f);\
}\
}
#else
#define MY_OUTPUT(msg, iLevel)
;
#endif
#endif

#ifdef _DEBUG
#ifdef MY_OUTPUT_TO_FILE
extern FILE* debug_f;
#define MY_OUTPUT2(msg, arg1, iLevel)\
{\
TCHAR	l_msg[1024];\
TCHAR	l_buf[1024];\
SYSTEMTIME l_st;\
if (iLevel >= 4) {\
	GetLocalTime(&l_st);\
	wsprintf(l_msg, (msg), (arg1));\
	wsprintf(l_buf, L"%02d:%02d:%02d %08x %d, %S, %s\n",\
					l_st.wHour, l_st.wMinute, l_st.wSecond,\
					GetCurrentThreadId(), (int)__LINE__, __FILE__, l_msg);\
	OutputDebugString(l_buf);\
	_ftprintf(debug_f, l_buf);\
	fflush(debug_f);\
}\
}
#else
#define MY_OUTPUT2(msg, arg1, iLevel)\
{\
TCHAR	l_msg[1024];\
TCHAR	l_buf[1024];\
SYSTEMTIME l_st;\
if (iLevel >= 4) {\
	GetLocalTime(&l_st);\
	wsprintf(l_msg, (msg), (arg1));\
	wsprintf(l_buf, L"%02d:%02d:%02d %08x %d, %S, %s\n",\
					l_st.wHour, l_st.wMinute, l_st.wSecond,\
					GetCurrentThreadId(), (int)__LINE__, __FILE__, l_msg);\
	OutputDebugString(l_buf);\
}\
}
#endif
#else
#ifdef MY_OUTPUT_TO_FILE
extern FILE* debug_f;
#define MY_OUTPUT2(msg, arg1, iLevel)\
{\
TCHAR	l_msg[1024];\
TCHAR	l_buf[1024];\
SYSTEMTIME l_st;\
if (iLevel >= 4) {\
	GetLocalTime(&l_st);\
	wsprintf(l_msg, (msg), (arg1));\
	wsprintf(l_buf, L"%02d:%02d:%02d %08x %d, %S, %s\n",\
					l_st.wHour, l_st.wMinute, l_st.wSecond,\
					GetCurrentThreadId(), (int)__LINE__, __FILE__, l_msg);\
	_ftprintf(debug_f, l_buf);\
	fflush(debug_f);\
}\
}
#else
#define MY_OUTPUT2(msg, arg1, iLevel)
;
#endif
#endif

//		_ASSERT(condition);
#ifdef _DEBUG
extern FILE* debug_f;
#define MY_ASSERT(condition)\
{\
	if (!(condition)) {\
		TCHAR l_buf[1024];\
		SYSTEMTIME l_st;\
		GetLocalTime(&l_st);\
		wsprintf(l_buf, L"%02d:%02d:%02d %08x %d, %S\n",\
				l_st.wHour, l_st.wMinute, l_st.wSecond,\
				GetCurrentThreadId(), (int)__LINE__, __FILE__);\
		_ftprintf(debug_f, l_buf);\
		fflush(debug_f);\
		DebugBreak();\
	}\
}
#else
extern FILE* debug_f;
#define MY_ASSERT(condition)\
{\
	if (!(condition)) {\
		TCHAR l_buf[1024];\
		SYSTEMTIME l_st;\
		GetLocalTime(&l_st);\
		wsprintf(l_buf, L"%02d:%02d:%02d %08x %d, %S\n",\
				l_st.wHour, l_st.wMinute, l_st.wSecond,\
				GetCurrentThreadId(), (int)__LINE__, __FILE__);\
		_ftprintf(debug_f, l_buf);\
		fflush(debug_f);\
	}\
}
#endif

//		_ASSERT((hres_condition)==S_OK);
#ifdef _DEBUG
extern FILE* debug_f;
#define MY_HRESASSERT(hres_condition)\
{\
	if ((hres_condition)!=S_OK) {\
		TCHAR l_buf[1024];\
		SYSTEMTIME l_st;\
		GetLocalTime(&l_st);\
		wsprintf(l_buf, L"%02d:%02d:%02d %08x %d, %S 0x%08x\n",\
				l_st.wHour, l_st.wMinute, l_st.wSecond,\
				GetCurrentThreadId(), (int)__LINE__, __FILE__, (hres_condition));\
		_ftprintf(debug_f, l_buf);\
		fflush(debug_f);\
		DebugBreak();\
	}\
}
#else
extern FILE* debug_f;
#define MY_HRESASSERT(hres_condition)\
{\
	if ((hres_condition)!=S_OK) {\
		TCHAR l_buf[1024];\
		SYSTEMTIME l_st;\
		GetLocalTime(&l_st);\
		wsprintf(l_buf, L"%02d:%02d:%02d %08x %d, %S 0x%08x\n",\
				l_st.wHour, l_st.wMinute, l_st.wSecond,\
				GetCurrentThreadId(), (int)__LINE__, __FILE__, (hres_condition));\
		_ftprintf(debug_f, l_buf);\
		fflush(debug_f);\
	}\
}
#endif

//#define HM_POLLING_INTERVAL 10
#define HM_POLLING_INTERVAL 1

// HM_RESET is a special state that is temporary to the object until it is done reseting
// It is not known of outside of the agent.
enum HM_STATE {HM_GOOD, HM_COLLECTING, HM_RESET, HM_INFO, HM_DISABLED, HM_SCHEDULEDOUT, HM_RESERVED1, HM_RESERVED2, HM_WARNING, HM_CRITICAL};

enum HM_CONDITION {HM_LT, HM_GT, HM_EQ, HM_NE, HM_GE, HM_LE, HM_CONTAINS, HM_NOTCONTAINS, HM_ALWAYS};

enum HM_DE_TYPE {HM_PGDE, HM_PMDE, HM_PQDE, HM_EQDE};

//enum HM_UNKNOWN_REASON {HM_UNKNOWN_NONE, HM_UNKNOWN_BADWMI, HM_UNKNOWN_OBJECTNOTFOUND, HM_UNKNOWN_NOINST, HM_UNKNOWN_ENUMFAIL, HM_UNKNOWN_TIMEOUT, HM_UNKNOWN_NULL, HM_UNKNOWN_TOOMANYINSTS, HM_UNKNOWN_BADTHRESHPROP};

#define HMRES_BADWMI 4
#define HMRES_OBJECTNOTFOUND 5
#define HMRES_NOINST 6
#define HMRES_ENUMFAIL 7
#define HMRES_TIMEOUT 8
#define HMRES_OUTAGE 9
#define HMRES_DISABLE 10
#define HMRES_NULLVALUE 11
#define HMRES_DCUNKNOWN 12
#define HMRES_TOOMANYINSTS 13
#define HMRES_BADTHRESHPROP 14
#define HMRES_MISSINGDESC 15
#define HMRES_DESC 16
#define HMRES_BADERROR 17
#define HMRES_OK 18
#define HMRES_COLLECTING 19
#define HMRES_RESET 20
#define HMRES_INFO 21
#define HMRES_DISABLED 22
#define HMRES_SCHEDULEDOUT 23
#define HMRES_RESERVED1 24
#define HMRES_RESERVED2 25
#define HMRES_WARNING 26
#define HMRES_CRITICAL 27
#define HMRES_LT 28
#define HMRES_GT 29
#define HMRES_EQ 30
#define HMRES_NE 31
#define HMRES_GTEQ 32
#define HMRES_LTEQ 33
#define HMRES_CONTAINS 34
#define HMRES_NOTCONTAINS 35
#define HMRES_ALWAYS 36
#define HMRES_ACTION_OUTAGE 37
#define HMRES_ACTION_DISABLE 38
#define HMRES_ACTION_FIRED 39
#define HMRES_ACTION_FAILED 40
#define HMRES_ACTION_ENABLE 41
#define HMRES_ACTION_LOADFAIL 42
#define HMRES_NOMEMORY 43
#define HMRES_SYSTEM_LOADFAIL 44
#define HMRES_DG_LOADFAIL 45
#define HMRES_DC_LOADFAIL 46
#define HMRES_THRESHOLD_LOADFAIL 47
#define HMRES_BADDCPROP 48

typedef struct _tag_TOKENStruct
{
	LPTSTR szOrigToken;
	LPTSTR szToken;
	LPTSTR szReplacementText;
} TOKENSTRUCT;
typedef std::vector<TOKENSTRUCT, std::allocator<TOKENSTRUCT> > TOKENLIST;

typedef struct _tag_REPStruct
{
	LPTSTR pStartStr;
	int len;
	LPTSTR pszReplacementText;
} REPSTRUCT;
typedef std::vector<REPSTRUCT, std::allocator<REPSTRUCT> > REPLIST;

BOOL ReadUI64(LPCWSTR wsz, UNALIGNED unsigned __int64& rui64);
HRESULT ReplaceStr(LPTSTR *pszString, LPTSTR pszOld, LPTSTR pszNew);

#ifdef _DEBUG
#define TRACE_MUTEX(msg)\
{\
		TCHAR l_buf[1024];\
		SYSTEMTIME l_st;\
		GetLocalTime(&l_st);\
		wsprintf(l_buf, L"%s %02d:%02d:%02d %08x %d, %S\n",\
				(msg), l_st.wHour, l_st.wMinute, l_st.wSecond,\
				GetCurrentThreadId(), (int)__LINE__, __FILE__);\
		_ftprintf(debug_f, l_buf);\
		fflush(debug_f);\
}
#else
#define TRACE_MUTEX(msg)
;
#endif
#endif  // __GLOBAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\hmagent.h ===
#ifndef __HMAGENT_H_
#define __HMAGENT_H_

#include <objbase.h>
#include <tchar.h>

#include <wbemcli.h>
#include <wbemprov.h>

#include <crtdbg.h>

//#include <resource.h>

// Defines

#define	EVENT_GENERATION_INTERVAL	2000
#define EVENT_THREAD_TIMEOUT			8000
#define EVENTLOG_MAX_MSG_LENGTH		128
#define EVENTLOG_ID_OFFSET				38

#define EVENTLOG_ID_STARTED				100
#define EVENTLOG_ID_FATAL_ERROR		101
#define EVENTLOG_ID_CIMV2_NAMESPACE_ERROR	102
#define EVENTLOG_ID_HEALTHMON_NAMESPACE_ERROR	103


#define MAX_INSERT_STRINGS				10
#define LOCAL_TIME_FORMAT					L"%04d%02d%02d%02d%02d%02d.%06d%c%03d"
#define	MAX_CONDITION_LENGTH			3
#define MAX_NAME_LENGTH						256

//federiga begin
#define HM_ASYNC_TIMEOUT	120000
#define HM_PREFIX_LEN		12
#define HM_MAX_PATH			4096
#define HM_GUID_PART		L".GUID=\"{"
#define HM_GUID_PART_LEN	8
#define HM_MOD_CLASS_NAME	L"__InstanceModificationEvent"
#define HM_START_LINE		L"=============== HM 2.1 Debug Log Start ===============\n"
//federiga end

enum ThreadStatus { Pending, Running, PendingStop, Stopped };

HRESULT Register(const wchar_t* szModule, const wchar_t* szName, const wchar_t* szThreading, REFCLSID clsid);
HRESULT UnRegister(REFCLSID clsid);

BOOL		Initialize();
void		UnInitialize();

BOOL		InitializeHealthMon();
BOOL		IsNamespaceExist();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\factory.h ===
// Factory.h: interface for the CFactory class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(__MYFACTORY_H)
#define __MYFACTORY_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//////////////////////////////////////////////////////////////////////
// Base Class Factory for HealthMon consumer and providers
//////////////////////////////////////////////////////////////////////

class CBaseFactory : public IClassFactory
{
public:
	CBaseFactory();
	virtual ~CBaseFactory();

public:
// IUnknown
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID* ppv);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

//IClassFactory members
	STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
	STDMETHODIMP LockServer(BOOL);

protected:
	ULONG m_cRef;
};

//////////////////////////////////////////////////////////////////////
// Class Factory for Consumer (original agent)
//////////////////////////////////////////////////////////////////////

class CConsFactory : public CBaseFactory
{
public:
	STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
};


//////////////////////////////////////////////////////////////////////
// Class Factories for Event Providers
//////////////////////////////////////////////////////////////////////

class CSystemEvtProvFactory : public CBaseFactory
{
public:
	STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
};

class CDataGroupEvtProvFactory : public CBaseFactory
{
public:
	STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
};

class CDataCollectorEvtProvFactory : public CBaseFactory
{
public:
	STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
};

class CDataCollectorPerInstanceEvtProvFactory : public CBaseFactory
{
public:
	STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
};

class CDataCollectorStatisticsEvtProvFactory : public CBaseFactory
{
public:
	STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
};

class CThresholdEvtProvFactory : public CBaseFactory
{
public:
	STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
};

//class CThresholdInstanceEvtProvFactory : public CBaseFactory
//{
//public:
//	STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
//};

class CActionEvtProvFactory : public CBaseFactory
{
public:
	STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
};

class CActionTriggerEvtProvFactory : public CBaseFactory
{
public:
	STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
};

//////////////////////////////////////////////////////////////////////
// Class Factories for Instance Provider
//////////////////////////////////////////////////////////////////////

class CInstProvFactory : public CBaseFactory
{
public:
	STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
};

//////////////////////////////////////////////////////////////////////
// Class Factories for Method Provider
//////////////////////////////////////////////////////////////////////

class CMethProvFactory : public CBaseFactory
{
public:
	STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
};

#endif // !defined(__MYFACTORY_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\hmagent.cpp ===
//***************************************************************************
//
//  HMAGENT.CPP
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: Defines the entry point for the DLL application.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

//#include <windows.h>
//#include <winnls.h>
#include "hmagent.h"
#include "system.h"
#include "factory.h"
#include <process.h>

/////////////////////////////////////////////////////////////////////////////
// Global data
HMODULE g_hModule = NULL;
HINSTANCE g_hResLib = NULL;
HMODULE g_hWbemComnModule = NULL;

long g_cComponents = 0;
long g_cServerLocks = 0;

HANDLE g_hConfigLock = NULL;

CSystem* g_pSystem = NULL;
CSystem* g_pStartupSystem = NULL;
HANDLE g_hEvtReady = NULL; // ready to service COM requests
CRITICAL_SECTION g_protect;
HANDLE g_hThrdDie = NULL;
HANDLE g_hThrdDead = NULL;

//#ifdef _DEBUG
FILE* debug_f;
//#endif

/////////////////////////////////////////////////////////////////////////////
// CLSIDs for HealthMon

// HealthMon Instance Provider
// {68AC0D34-DB09-11d2-8F56-006097919914}
static const GUID CLSID_HMInstProvider = 
{ 0x68ac0d34, 0xdb09, 0x11d2, { 0x8f, 0x56, 0x0, 0x60, 0x97, 0x91, 0x99, 0x14 } };

// HealthMon Consumer
// {68AC0D35-DB09-11d2-8F56-006097919914}
static const GUID CLSID_HMConsumer = 
{ 0x68ac0d35, 0xdb09, 0x11d2, { 0x8f, 0x56, 0x0, 0x60, 0x97, 0x91, 0x99, 0x14 } };

// HealthMon System Event Provider
// {68AC0D36-DB09-11d2-8F56-006097919914}
static const GUID CLSID_HMSystemEventProvider = 
{ 0x68ac0d36, 0xdb09, 0x11d2, { 0x8f, 0x56, 0x0, 0x60, 0x97, 0x91, 0x99, 0x14 } };

// HealthMon DataGroup Event Provider
// {68AC0D37-DB09-11d2-8F56-006097919914}
static const GUID CLSID_HMDataGroupEventProvider = 
{ 0x68ac0d37, 0xdb09, 0x11d2, { 0x8f, 0x56, 0x0, 0x60, 0x97, 0x91, 0x99, 0x14 } };

// HealthMon DataCollector Event Provider
// {68AC0D38-DB09-11d2-8F56-006097919914}
static const GUID CLSID_HMDataCollectorEventProvider = 
{ 0x68ac0d38, 0xdb09, 0x11d2, { 0x8f, 0x56, 0x0, 0x60, 0x97, 0x91, 0x99, 0x14 } };

// HealthMon DataCollector PerInstance Event Provider
// {3A7A82DC-8D5C-4ab7-801B-A1C7D30089C6}
static const GUID CLSID_HMDataCollectorPerInstanceEventProvider = 
{ 0x3a7a82dc, 0x8d5c, 0x4ab7, { 0x80, 0x1b, 0xa1, 0xc7, 0xd3, 0x0, 0x89, 0xc6 } };

// HealthMon DataCollectorStatistics Event Provider
// {68AC0D40-DB09-11d2-8F56-006097919914}
//static const GUID CLSID_HMDataCollectorStatisticsEventProvider = 
//{ 0x68ac0d40, 0xdb09, 0x11d2, { 0x8f, 0x56, 0x0, 0x60, 0x97, 0x91, 0x99, 0x14 } };

// HealthMon Threshold Event Provider
// {68AC0D39-DB09-11d2-8F56-006097919914}
static const GUID CLSID_HMThresholdEventProvider = 
{ 0x68ac0d39, 0xdb09, 0x11d2, { 0x8f, 0x56, 0x0, 0x60, 0x97, 0x91, 0x99, 0x14 } };

// HealthMon Method Provider
// {68AC0D41-DB09-11d2-8F56-006097919914}
static const GUID CLSID_HMMethProvider = 
{ 0x68ac0d41, 0xdb09, 0x11d2, { 0x8f, 0x56, 0x0, 0x60, 0x97, 0x91, 0x99, 0x14 } };

// HealthMon ThresholdInstance Event Provider
// {68AC0D42-DB09-11d2-8F56-006097919914}
//static const GUID CLSID_HMThresholdInstanceEventProvider = 
//{ 0x68ac0d42, 0xdb09, 0x11d2, { 0x8f, 0x56, 0x0, 0x60, 0x97, 0x91, 0x99, 0x14 } };

// HealthMon Action Event Provider
// {68AC0D43-DB09-11d2-8F56-006097919914}
static const GUID CLSID_HMActionEventProvider = 
{ 0x68ac0d43, 0xdb09, 0x11d2, { 0x8f, 0x56, 0x0, 0x60, 0x97, 0x91, 0x99, 0x14 } };

// HealthMon Action Trigger Event Provider
// {68AC0D44-DB09-11d2-8F56-006097919914}
static const GUID CLSID_HMActionTriggerEventProvider = 
{ 0x68ac0d44, 0xdb09, 0x11d2, { 0x8f, 0x56, 0x0, 0x60, 0x97, 0x91, 0x99, 0x14 } };

//static unsigned int __stdcall CheckFinalInit(void *pv);
unsigned int __stdcall CheckFinalInit(void *pv);

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		debug_f = _tfopen(L"hmdebug.log", L"a+");
		if(!debug_f)
		{
			OutputDebugString(L"Impossible to open log file");
		}
		else // write a start line in the debug log file
		{
			_ftprintf(debug_f, HM_START_LINE);
			fflush(debug_f);
		}
		g_hModule = hInstance;
		MY_OUTPUT(L"DLLMAIN->DLL_PROCESS_ATTACH", 1);

		DisableThreadLibraryCalls(hInstance);
		__try
		{
			InitializeCriticalSection(&g_protect);
		}
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			OutputDebugString(L"Impossible to initialize critical section");
			MY_ASSERT(FALSE);
			return FALSE;
		}

		if (Initialize())
		{
			return TRUE;
		}
		else
		{
			MY_ASSERT(FALSE);
			return FALSE;
		}
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		MY_OUTPUT(L"DLLMAIN->DLL_PROCESS_DETACH", 1);
		UnInitialize(); // even if it fails, try to unitialize the rest anyway
		DeleteCriticalSection(&g_protect);
		
		if(debug_f)
		{
			fclose(debug_f);
		}

		return TRUE;
	}
	return TRUE;    
}

STDAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void** ppv)
{
	unsigned uThrdId = 0;
	HANDLE hThrdFn = NULL;
	HRESULT hRes = S_OK;
	CBaseFactory* pFactory = NULL;
	static BOOL bFirstTime = TRUE;
	DWORD	dwErr = 0;
	BOOL	bGotCritSec = FALSE;

	if (clsid == CLSID_HMInstProvider || 
		clsid == CLSID_HMMethProvider || 
		clsid == CLSID_HMConsumer)
	{
		try
        {
            EnterCriticalSection(&g_protect);
        }
        catch(...)
        {
            return E_OUTOFMEMORY;
        }
		
		bGotCritSec = TRUE;
		//
		// Initialize HealthMon()
		//
		if (!g_pStartupSystem)
		{
			if (bFirstTime)
			{
	  			if(!ResetEvent(g_hEvtReady)) // System is Not yet ready!
				{
					dwErr = GetLastError();
					MY_OUTPUT2(L"ResetEvent failed with error %d",dwErr, 4);
					hRes = HRESULT_FROM_WIN32(dwErr);
					goto ExitPoint;
				}
				hThrdFn = (HANDLE)_beginthreadex(NULL, 0, CheckFinalInit, NULL, 0, &uThrdId);
				if (!hThrdFn)
				{
					MY_OUTPUT(L"ERROR creating a thread", 1);
					hRes = E_UNEXPECTED;
					goto ExitPoint;
				}
				bFirstTime = FALSE;
			}
			if (InitializeHealthMon())
			{
				MY_OUTPUT(L"DllGetClassObject: HealthMon Initialized", 1);
				if(!SetEvent(g_hEvtReady))    // System is ready.
				{
					dwErr = GetLastError();
					MY_OUTPUT2(L"ResetEvent failed with error %d",dwErr, 4);
					hRes = HRESULT_FROM_WIN32(dwErr);
					goto ExitPoint;
				}
			}
			else
			{
				MY_ASSERT(FALSE);
				MY_OUTPUT(L"DllGetClassObject: FAILURE TO INITIALIZE HealthMon", 1);
				hRes = E_UNEXPECTED;
				goto ExitPoint;
			}
		}

		// initialization went fine.
		LeaveCriticalSection(&g_protect);
		bGotCritSec = FALSE;
	}
	else
	{
		// nothing to initialize
	}

	//
	// Create Class Factories for Providers
	//
	if (clsid == CLSID_HMInstProvider)
	{
		pFactory = new CInstProvFactory;
	}
	else if (clsid == CLSID_HMMethProvider)
	{
		pFactory = new CMethProvFactory;
	}
	else if (clsid == CLSID_HMSystemEventProvider)
	{
		pFactory = new CSystemEvtProvFactory;
	}
	else if (clsid == CLSID_HMDataGroupEventProvider)
	{
		pFactory = new CDataGroupEvtProvFactory;
	}
	else if (clsid == CLSID_HMDataCollectorEventProvider)
	{
		pFactory = new CDataCollectorEvtProvFactory;
	}
	else if (clsid == CLSID_HMDataCollectorPerInstanceEventProvider)
	{
		pFactory = new CDataCollectorPerInstanceEvtProvFactory;
	}
	else if (clsid == CLSID_HMThresholdEventProvider)
	{
		pFactory = new CThresholdEvtProvFactory;
	}
	else if (clsid == CLSID_HMActionEventProvider)
	{
		pFactory = new CActionEvtProvFactory;
	}
	else if (clsid == CLSID_HMActionTriggerEventProvider)
	{
		pFactory = new CActionTriggerEvtProvFactory;
	}
	else if (clsid == CLSID_HMConsumer)
	{
		pFactory = new CConsFactory;
	}
	else
	{
		MY_ASSERT(FALSE);
		return CLASS_E_CLASSNOTAVAILABLE;
	}

	if (pFactory ==NULL)
	{
		MY_OUTPUT(L"DllGetClassObject: ERROR:pFactory is NULL", 1);
		return E_OUTOFMEMORY;
	}
	
	hRes = pFactory->QueryInterface(iid, ppv);
	
	if (FAILED(hRes))
	{
//		MY_HRESASSERT(hRes);
		MY_OUTPUT(L"DllGetClassObject: ERROR:QI failed", 1);
		pFactory->Release();
	}

ExitPoint:
	if(bGotCritSec)
	{
		LeaveCriticalSection(&g_protect);
	}

	return hRes;
}

unsigned int __stdcall CheckFinalInit(void *pv)
{
	DWORD dwError = 0;
	// We will get the Mutex first here, and block everyone else from
	// proceeding untill fully initialized.
MY_OUTPUT(L"BLOCK - BLOCK Consumer::Update BLOCK - g_hConfigLock BLOCK WAIT", 1);
	if(WaitForSingleObject(g_hConfigLock, INFINITE) != WAIT_OBJECT_0)
	{
		// error!
		MY_OUTPUT(L"WaitForSingleObject failed",1);
		dwError = GetLastError();
		goto Exit;
	}
MY_OUTPUT(L"BLOCK - BLOCK Consumer::Update BLOCK - g_hConfigLock BLOCK GOT IT", 1);

	if(WaitForSingleObject(g_hEvtReady, INFINITE) != WAIT_OBJECT_0)
	{
		// error!
		MY_OUTPUT(L"WaitForSingleObject failed",1);
		dwError = GetLastError();
		goto Exit;
	}

	try
	{
		g_pSystem = g_pStartupSystem;
		g_pSystem->OnAgentInterval();
	}
	catch (...)
	{
		MY_ASSERT(FALSE);
	}

MY_OUTPUT(L"BLOCK - BLOCK Consumer::Update g_hConfigLock BLOCK - RELEASE IT", 1);
	if(!ReleaseMutex(g_hConfigLock))
	{
		dwError = GetLastError();
		MY_OUTPUT2(L"ReleaseMutex failed with error %d",dwError, 4);
	}
MY_OUTPUT(L"BLOCK - BLOCK Consumer::Update g_hConfigLock BLOCK - RELEASED", 1);

Exit:
	_endthreadex(0);

	return dwError;
}


STDAPI DllCanUnloadNow()
{
	if(g_cServerLocks == 0 && g_cComponents == 0)
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}

STDAPI DllRegisterServer()
{
	HRESULT hRes;
	wchar_t szModule[_MAX_PATH];

	MY_OUTPUT(L"DllRegisterServer", 1);
	// Get module file name
//DebugBreak();
//MY_ASSERT(FALSE);

	if(!GetModuleFileNameW(g_hModule, szModule, _MAX_PATH))
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	// Register Instance Provider
	hRes = Register(szModule, L"HealthMon System Instance Provider", L"Both", CLSID_HMInstProvider);
	if (FAILED(hRes))
		return hRes;

	// Register Method Provider
	hRes = Register(szModule, L"HealthMon System Method Provider", L"Both", CLSID_HMMethProvider);
	if (FAILED(hRes))
		return hRes;

	// Register System Event Provider
	hRes = Register(szModule, L"HealthMon System Event Provider", L"Both", CLSID_HMSystemEventProvider);
	if (FAILED(hRes))
		return hRes;

	// Register DataGroup Event Provider
	hRes = Register(szModule, L"HealthMon DataGroup Event Provider", L"Both", CLSID_HMDataGroupEventProvider);
	if (FAILED(hRes))
		return hRes;

	// Register DataCollector Event Provider
	hRes = Register(szModule, L"HealthMon DataCollector Event Provider", L"Both", CLSID_HMDataCollectorEventProvider);
	if (FAILED(hRes))
		return hRes;

	// Register DataCollector Per Instance Event Provider
	hRes = Register(szModule, L"HealthMon DataCollector Per Instance Event Provider", L"Both", CLSID_HMDataCollectorPerInstanceEventProvider);
	if (FAILED(hRes))
		return hRes;

	// Register DataCollectorStatistics Event Provider
//	hRes = Register(szModule, L"HealthMon DataCollectorStatistics Event Provider", L"Both", CLSID_HMDataCollectorStatisticsEventProvider);
//	if (FAILED(hRes))
//		return hRes;

	// Register Threshold Event Provider
	hRes = Register(szModule, L"HealthMon Threshold Event Provider", L"Both", CLSID_HMThresholdEventProvider);
	if (FAILED(hRes))
		return hRes;

	// Register ThresholdInstance Event Provider
//	hRes = Register(szModule, L"HealthMon ThresholdInstance Event Provider", L"Both", CLSID_HMThresholdInstanceEventProvider);
//	if (FAILED(hRes))
//		return hRes;

	// Register Action Event Provider
	hRes = Register(szModule, L"HealthMon Action Event Provider", L"Both", CLSID_HMActionEventProvider);
	if (FAILED(hRes))
		return hRes;

	// Register Action Trigger Event Provider
	hRes = Register(szModule, L"HealthMon Action Trigger Event Provider", L"Both", CLSID_HMActionTriggerEventProvider);
	if (FAILED(hRes))
		return hRes;

	//Register consumer
	hRes = Register(szModule, L"HealthMon Event Consumer", L"Both", CLSID_HMConsumer);
	if (FAILED(hRes))
		return hRes;
	
	MY_OUTPUT(L"DllRegisterServer - OK", 1);
	return S_OK;
}

STDAPI DllUnregisterServer()
{
	HRESULT hRes;

	hRes = UnRegister(CLSID_HMInstProvider);
	if (FAILED(hRes))
		return hRes;

	hRes = UnRegister(CLSID_HMMethProvider);
	if (FAILED(hRes))
		return hRes;

	hRes = UnRegister(CLSID_HMSystemEventProvider);
	if (FAILED(hRes))
		return hRes;

	hRes = UnRegister(CLSID_HMDataGroupEventProvider);
	if (FAILED(hRes))
		return hRes;

	hRes = UnRegister(CLSID_HMDataCollectorEventProvider);
	if (FAILED(hRes))
		return hRes;

	hRes = UnRegister(CLSID_HMDataCollectorPerInstanceEventProvider);
	if (FAILED(hRes))
		return hRes;

//	hRes = UnRegister(CLSID_HMDataCollectorStatisticsEventProvider);
//	if (FAILED(hRes))
//		return hRes;

	hRes = UnRegister(CLSID_HMThresholdEventProvider);
	if (FAILED(hRes))
		return hRes;

//	hRes = UnRegister(CLSID_HMThresholdInstanceEventProvider);
//	if (FAILED(hRes))
//		return hRes;

	hRes = UnRegister(CLSID_HMActionEventProvider);
	if (FAILED(hRes))
		return hRes;

	hRes = UnRegister(CLSID_HMActionTriggerEventProvider);
	if (FAILED(hRes))
		return hRes;

	hRes = UnRegister(CLSID_HMConsumer);
	if (FAILED(hRes))
		return hRes;

	return S_OK;
}

HRESULT Register(const wchar_t* szModule, const wchar_t* szName, const wchar_t* szThreading, REFCLSID clsid)
{
	wchar_t		szKey[_MAX_PATH];
	wchar_t*	pGuidStr = 0;
	HKEY		hKey; 
	HKEY		hSubKey;
	HRESULT hRes;


	// pass CLSID
	hRes = StringFromCLSID(clsid, &pGuidStr);
	if (hRes != S_OK)
	{
		if (pGuidStr)
		{
			CoTaskMemFree(pGuidStr);
		}
		return hRes;
	}
	swprintf(szKey, L"SOFTWARE\\CLASSES\\CLSID\\%s", pGuidStr);
	CoTaskMemFree(pGuidStr);

	LONG lRet = RegCreateKeyW(HKEY_LOCAL_MACHINE, szKey, &hKey);
	if (lRet != ERROR_SUCCESS)
		return E_FAIL;

	lRet = RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) szName, wcslen(szName) * 2 + 2);
	if (lRet != ERROR_SUCCESS)
		return E_FAIL;

	lRet = RegCreateKey(hKey, L"InprocServer32", &hSubKey);
	if (lRet != ERROR_SUCCESS)
		return E_FAIL;

	lRet = RegSetValueExW(hSubKey, 0, 0, REG_SZ, (const BYTE *) szModule, wcslen(szModule) * 2 + 2);
	if (lRet != ERROR_SUCCESS)
		return E_FAIL;

	lRet = RegSetValueExW(hSubKey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) szThreading, wcslen(szThreading) * 2 + 2);
	if (lRet != ERROR_SUCCESS)
		return E_FAIL;

	lRet = RegCloseKey(hSubKey);
	if (lRet != ERROR_SUCCESS)
		return E_FAIL;

	lRet = RegCloseKey(hKey);
	if (lRet != ERROR_SUCCESS)
		return E_FAIL;

	return S_OK;
}


HRESULT UnRegister(REFCLSID clsid)
{
	wchar_t*	pGuidStr = 0;
	wchar_t		szKeyPath[_MAX_PATH];
	HRESULT hRes;
	HKEY hKey;

	hRes = StringFromCLSID(clsid, &pGuidStr);
	if (hRes != S_OK)
	{
		if (pGuidStr)
			CoTaskMemFree(pGuidStr);
		return hRes;
	}
	swprintf(szKeyPath, L"SOFTWARE\\CLASSES\\CLSID\\%s", pGuidStr);
	
	// Delete InProcServer32 subkey
	LONG lRet = RegOpenKeyW(HKEY_LOCAL_MACHINE, szKeyPath, &hKey);
	if (lRet != ERROR_SUCCESS)
		return E_FAIL;

	lRet = RegDeleteKeyW(hKey, L"InprocServer32");
	if (lRet != ERROR_SUCCESS)
		return E_FAIL;

	lRet = RegCloseKey(hKey);
	if (lRet != ERROR_SUCCESS)
		return E_FAIL;

	// Delete CLSID GUID key
	lRet = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\CLASSES\\CLSID", &hKey);
	if (lRet != ERROR_SUCCESS)
		return E_FAIL;

	lRet = RegDeleteKeyW(hKey, pGuidStr);
	if (lRet != ERROR_SUCCESS)
		return E_FAIL;

	lRet = RegCloseKey(hKey);
	if (lRet != ERROR_SUCCESS)
		return E_FAIL;

	return S_OK;
}

BOOL Initialize()
{
	WIN32_FIND_DATA FindFileData;
	HANDLE hFind;
	wchar_t		szModule[_MAX_PATH];
	wchar_t		szPath[_MAX_PATH];
	wchar_t		szDefPath[_MAX_PATH];
	wchar_t		szDir[_MAX_PATH];
	wchar_t		szTemp[_MAX_PATH];
	LCID lcID;
	LCID dirlcID;
	BOOL bFound = FALSE;
	

	//
	// Load the resource file for the system local
	//
	DWORD dwRes = GetModuleFileNameW(g_hModule, szModule, _MAX_PATH);
	if(!dwRes)
	{
		dwRes = GetLastError();
		MY_OUTPUT2(L"GetModuleFileName failed: %d",dwRes,4);
		return FALSE;
		// dbg output 
	}

	/*
	_tsplitpath(szModule, szPath, szDir, NULL, NULL);
	lstrcat(szPath, szDir);
	lstrcpy(szDefPath, szPath);
	pStr = wcsrchr(szPath, '\\');
	*pStr = '\0';
	pStr = wcsrchr(szPath, '\\');
	*pStr = '\0';
	lstrcpy(szPath, L"WBEMCOMN.DLL");*/
	g_hWbemComnModule = LoadLibrary(L"WBEMCOMN.DLL");
	if(!g_hWbemComnModule)
	{
		dwRes = GetLastError();
		MY_OUTPUT2(L"LoadLibrary failed: %d",dwRes,4);
		return FALSE;
	}

	_tsplitpath(szModule, szPath, szDir, NULL, NULL);
	lstrcat(szPath, szDir);
	lstrcpy(szDefPath, szPath);

	lcID = GetSystemDefaultLCID();
	swprintf(szTemp, L"%08x\\HMonitorRes.dll", lcID);
	lstrcat(szPath, szTemp);

	if ((g_hResLib = LoadLibrary(szPath)) == NULL)
	{
		MY_ASSERT(FALSE);
		// Couldn't find what we think is the default language, so search for one that matches the
		// primary ID.
		szPath[0] = '\0';
		lstrcpy(szPath, szDefPath);
		lstrcat(szPath, L"0*");
		hFind = FindFirstFile(szPath, &FindFileData);
		while (hFind != INVALID_HANDLE_VALUE)
		{
			if (FindFileData.dwFileAttributes | FILE_ATTRIBUTE_DIRECTORY)
			{
				dirlcID = wcstoul(FindFileData.cFileName, NULL, 16);
				if (PRIMARYLANGID(lcID) == PRIMARYLANGID(dirlcID))
				{
					lstrcpy(szTemp, szDefPath);
					lstrcat(szTemp, FindFileData.cFileName);
					lstrcat(szTemp, L"\\HMonitorRes.dll");
					g_hResLib = LoadLibrary(szTemp);
					if (g_hResLib != NULL)
					{
						bFound = TRUE;
						FindClose(hFind);
						break;
					}
					else
					{
						MY_ASSERT(FALSE);
						dwRes = GetLastError();
					}
				}
			}

			if (!FindNextFile(hFind, &FindFileData))
			{
				FindClose(hFind);
				break;
			}
		}

		if (bFound == FALSE)
		{
			// default case.
			lstrcpy(szTemp, szDefPath);
			lstrcat(szTemp, L"00000409\\HMonitorRes.dll");
			g_hResLib = LoadLibrary(szTemp);
			if (g_hResLib == NULL)
			{
				MY_ASSERT(FALSE);
				dwRes = GetLastError();
			}
		}
	}

	//
	// Create the objects needed for thread syncronization
	//
	g_hEvtReady = CreateEvent(NULL, TRUE, TRUE, NULL);	// ready to service COM requests
	if (!g_hEvtReady)
		return FALSE;
	g_hConfigLock = CreateMutex(NULL, FALSE, NULL);
	if (!g_hConfigLock)
		return FALSE;
	g_hThrdDie = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (!g_hThrdDie)
		return FALSE;
	g_hThrdDead = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (!g_hThrdDead)
		return FALSE;

	// artificially increment the lock count
	InterlockedIncrement(&g_cServerLocks);

	return TRUE;
}

void UnInitialize()
{
	if (g_hResLib)
		FreeLibrary(g_hResLib);

	if (g_hEvtReady)
		CloseHandle(g_hEvtReady);
	if (g_hConfigLock)
		CloseHandle(g_hConfigLock);
	if (g_hThrdDie)
		CloseHandle(g_hThrdDie);
	if (g_hThrdDead)
		CloseHandle(g_hThrdDead);

	if(g_hWbemComnModule)
		FreeLibrary(g_hWbemComnModule);
}


BOOL InitializeHealthMon()
{
CSystem* pSystem = NULL;
	// don't forget to remove the CEvent log creation from the System constructor
//XXXDebugBreak();	
	OutputDebugString(L"InitializeHealthMon()\n");


	try
	{
		pSystem = new CSystem;

		if (!pSystem->InitWbemPointer())
		{
			OutputDebugString(L"InitializeHealthMon() - Failed to init Wbem pointers!\n");
			delete pSystem;
			pSystem = NULL;
			return FALSE;
		}

//XXXDebug and make sure this first test works
		if (pSystem->InternalizeHMNamespace()!=S_OK)
		{
			OutputDebugString(L"InitializeHealthMon() - Failed to init Status!\n");
		
		// Log to EventLog
#ifdef SAVE
		pSystem->m_pLog->LogEvent(0,0,EVENTLOG_ID_FATAL_ERROR,0,NULL);
#endif

			delete pSystem;
			pSystem = NULL;
			return FALSE;
		}

		// Log to NT Event Log that HealthMon is started.
#ifdef SAVE
	pSystem->m_pLog->LogEvent(0,0,EVENTLOG_ID_STARTED,0,NULL);
#endif

//		g_pSystem = pSystem;
		g_pStartupSystem = pSystem;
	}
	catch (...)
	{
		MY_ASSERT(FALSE);
//XXXSee if can put in a log to NTEvent Log is think it is a ggod idea still
//from the catch points, of from MY_ASSERT???
//LogEvent(0,0,EVENTLOG_ID_STARTED,0,NULL);
		return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\instprov.cpp ===
// INSTPROV.CPP: implementation of the CBaseInstanceProvider class.
//
//////////////////////////////////////////////////////////////////////
#include "HMAgent.h"
#include "instprov.h"

//////////////////////////////////////////////////////////////////////
// global data
extern CSystem* g_pSystem;
extern HANDLE g_hConfigLock;
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBaseInstanceProvider::CBaseInstanceProvider()
{
	OutputDebugString(L"CBaseInstanceProvider::CBaseInstanceProvider()\n");

	m_cRef = 0L;
	m_pIWbemServices = NULL;
}

CBaseInstanceProvider::~CBaseInstanceProvider()
{
	OutputDebugString(L"CBaseInstanceProvider::~CBaseInstanceProvider()\n");

	if (m_pIWbemServices)
	{
		m_pIWbemServices->Release();
	}
	m_pIWbemServices = NULL;
}

//////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CBaseInstanceProvider::QueryInterface(REFIID riid, LPVOID* ppv)
{
	MY_ASSERT(ppv);

	*ppv = NULL;

	if(riid== IID_IWbemServices)
	{
		*ppv=(IWbemServices*)this;
	}
	else if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
	{
		*ppv=(IWbemProviderInit*)this;
	}
	else
	{
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;   

}

STDMETHODIMP_(ULONG) CBaseInstanceProvider::AddRef(void)
{
	return InterlockedIncrement((long*)&m_cRef);
}

STDMETHODIMP_(ULONG) CBaseInstanceProvider::Release(void)
{
	LONG	lCount = InterlockedDecrement((long*)&m_cRef);

	if (0 != lCount)
	{
		return lCount;
	}

	delete this;
	return 0L;
}

//////////////////////////////////////////////////////////////////////
// IWbemProviderInit Implementation
//////////////////////////////////////////////////////////////////////

HRESULT CBaseInstanceProvider::Initialize(LPWSTR pszUser,
LONG lFlags,
LPWSTR pszNamespace,
LPWSTR pszLocale,
IWbemServices __RPC_FAR *pNamespace,
IWbemContext __RPC_FAR *pCtx,
IWbemProviderInitSink __RPC_FAR *pInitSink)
{
	OutputDebugString(L"CBaseInstanceProvider::Initialize()\n");

	if (NULL == pNamespace)
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	m_pIWbemServices = pNamespace;
	m_pIWbemServices->AddRef();

	
	pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	return WBEM_S_NO_ERROR;
}

//////////////////////////////////////////////////////////////////////
// IWbemService Implementation
//////////////////////////////////////////////////////////////////////

HRESULT CBaseInstanceProvider::CreateInstanceEnumAsync(const BSTR Class, long lFlags,
IWbemContext __RPC_FAR *pCtx, IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	HRESULT hRes;
	DWORD dwErr = 0;
	TCHAR szClass[HM_MAX_PATH];

	if (pResponseHandler == NULL)
	{
		return WBEM_E_INVALID_PARAMETER;
	}

MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::CreateInstanceEnumAsync BLOCK - g_hConfigLock BLOCK WAIT", 4);
	dwErr = WaitForSingleObject(g_hConfigLock, HM_ASYNC_TIMEOUT);
	if(dwErr != WAIT_OBJECT_0)
	{
		if(dwErr = WAIT_TIMEOUT)
		{
			TRACE_MUTEX(L"TIMEOUT MUTEX");
			return WBEM_S_TIMEDOUT;
		}
		else
		{
			TRACE_MUTEX(L"WaitForSingleObject on Mutex failed");
			return WBEM_E_FAILED;
		}
	}
MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::CreateInstanceEnumAsync BLOCK - g_hConfigLock BLOCK GOT IT", 4);

	if (!g_pSystem)
	{
		ReleaseMutex(g_hConfigLock);
		return S_FALSE;
	}

	// Class is a MicrosoftHM_xxx
	MY_ASSERT(wcslen(Class) > HM_PREFIX_LEN);

	wcsncpy(szClass, Class, HM_MAX_PATH-1);
	szClass[HM_MAX_PATH-1] = '\0';
	_wcsupr(szClass);

	if (!wcscmp(szClass+HM_PREFIX_LEN, L"SYSTEMSTATUS"))
	{
		hRes = g_pSystem->SendHMSystemStatusInstances(pResponseHandler);
	}
	else if (!wcscmp(szClass+HM_PREFIX_LEN, L"DATAGROUPSTATUS"))
	{
		hRes = g_pSystem->SendHMDataGroupStatusInstances(pResponseHandler);
	}
	else if (!wcscmp(szClass+HM_PREFIX_LEN, L"DATACOLLECTORSTATUS"))
	{
		hRes = g_pSystem->SendHMDataCollectorStatusInstances(pResponseHandler);
	}
	else if (!wcscmp(szClass+HM_PREFIX_LEN, L"DATACOLLECTORPERINSTANCESTATUS"))
	{
		hRes = g_pSystem->SendHMDataCollectorPerInstanceStatusInstances(pResponseHandler);
	}
	else if (!wcscmp(szClass+HM_PREFIX_LEN, L"DATACOLLECTORSTATISTICS"))
	{
		hRes = g_pSystem->SendHMDataCollectorStatisticsInstances(pResponseHandler);
	}
	else if (!wcscmp(szClass+HM_PREFIX_LEN, L"THRESHOLDSTATUS"))
	{
		hRes = g_pSystem->SendHMThresholdStatusInstances(pResponseHandler);
	}
	else if (!wcscmp(szClass+HM_PREFIX_LEN, L"ACTIONSTATUS"))
	{
		hRes = g_pSystem->SendHMActionStatusInstances(pResponseHandler);
	}
	else
	{
		// class not supported by this provider
		hRes = pResponseHandler->SetStatus(0L, WBEM_E_FAILED, NULL, NULL);
MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::CreateInstanceEnumAsync g_hConfigLock BLOCK - RELEASE IT", 4);
		ReleaseMutex(g_hConfigLock);
MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::CreateInstanceEnumAsync g_hConfigLock BLOCK - RELEASED", 4);
		return WBEM_E_NOT_SUPPORTED;
	}
	
	if (FAILED(hRes))
	{
		OutputDebugString(L"CBaseInstanceProvider SendSMEvents failed!");
		pResponseHandler->SetStatus(0L, WBEM_E_FAILED, NULL, NULL);

MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::CreateInstanceEnumAsync g_hConfigLock BLOCK - RELEASE IT", 4);

		ReleaseMutex(g_hConfigLock);

MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::CreateInstanceEnumAsync g_hConfigLock BLOCK - RELEASED", 4);

		return hRes;
	}
	
	//  Now let caller know it's done.
	pResponseHandler->SetStatus(0L, WBEM_S_NO_ERROR, NULL, NULL);

MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::CreateInstanceEnumAsync g_hConfigLock BLOCK - RELEASE IT", 4);
	
	ReleaseMutex(g_hConfigLock);

MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::CreateInstanceEnumAsync g_hConfigLock BLOCK - RELEASED", 4);
	
	return WBEM_S_NO_ERROR;
	
}


HRESULT CBaseInstanceProvider::GetObjectAsync(const BSTR ObjectPath, long lFlags, IWbemContext __RPC_FAR *pCtx,
IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	TCHAR szPath[HM_MAX_PATH];
	LPTSTR pszGUID;
	LPTSTR pszEnd;
	HRESULT hRes;
	DWORD dwErr = 0;

	if (pResponseHandler==NULL || (HM_MAX_PATH-1) < wcslen(ObjectPath))
	{
		return WBEM_E_INVALID_PARAMETER;
	}

MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync BLOCK - g_hConfigLock BLOCK WAIT", 4);
	
	dwErr = WaitForSingleObject(g_hConfigLock, HM_ASYNC_TIMEOUT);
	if(dwErr != WAIT_OBJECT_0)
	{
		if(dwErr = WAIT_TIMEOUT)
		{
			TRACE_MUTEX(L"TIMEOUT MUTEX");
			return WBEM_S_TIMEDOUT;
		}
		else
		{
			MY_OUTPUT(L"WaitForSingleObject on Mutex failed",4);
			return WBEM_E_FAILED;
		}
	}

MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync BLOCK - g_hConfigLock BLOCK GOT IT", 4);
	
	OutputDebugString(L"CBaseInstanceProvider::GetObjectAsync()\n");

	if (!g_pSystem)
	{
		ReleaseMutex(g_hConfigLock);
		return S_FALSE;
	}

	//	
	// Going to look something like this ->
	// MicrosoftHM_DataGroupStatus.GUID="{269EA380-07CA-11d3-8FEB-006097919914}"
	//
	wcsncpy(szPath, ObjectPath, HM_MAX_PATH-1);
	szPath[HM_MAX_PATH-1] = '\0';
	_wcsupr(szPath);
	
	pszEnd = wcschr(szPath, '.');
	if (pszEnd)
	{
		*pszEnd = '\0';
		pszEnd++;
		pszEnd = wcschr(pszEnd, '"');
		if (pszEnd)
		{
			pszEnd++;
			pszGUID = pszEnd;
			pszEnd = wcschr(pszEnd, '"');
			if (pszEnd)
			{
				*pszEnd = '\0';
			}
			else
			{
				MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASE IT", 4);
				ReleaseMutex(g_hConfigLock);
				MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASED", 4);
				return WBEM_E_INVALID_PARAMETER;
			}
		}
		else
		{
			MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASE IT", 4);
			ReleaseMutex(g_hConfigLock);
			MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASED", 4);
			return WBEM_E_INVALID_PARAMETER;
		}
	}
	else
	{
		pszEnd = wcschr(szPath, '=');
		if (pszEnd)
		{
			*pszEnd = '\0';
			pszEnd++;
			if (*pszEnd == '@')
			{
				pszGUID = pszEnd;
			}
			else
			{
				MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASE IT", 4);
				ReleaseMutex(g_hConfigLock);
				MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASED", 4);
				return WBEM_E_INVALID_PARAMETER;
			}
		}
		else
		{
			MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASE IT", 4);
			ReleaseMutex(g_hConfigLock);
			MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASED", 4);
			return WBEM_E_INVALID_PARAMETER;
		}
	}

	try
	{
		//
		// Now find out which instance type we need to return.
		//
		if (!wcscmp(szPath+HM_PREFIX_LEN, L"SYSTEMSTATUS"))
		{
			hRes = g_pSystem->SendHMSystemStatusInstance(pResponseHandler, pszGUID);
		}
		else if (!wcscmp(szPath+HM_PREFIX_LEN, L"DATAGROUPSTATUS"))
		{
			hRes = g_pSystem->SendHMDataGroupStatusInstance(pResponseHandler, pszGUID);
		}
		else if (!wcscmp(szPath+HM_PREFIX_LEN, L"DATACOLLECTORSTATUS"))
		{
			hRes = g_pSystem->SendHMDataCollectorStatusInstance(pResponseHandler, pszGUID);
		}
		else if (!wcscmp(szPath+HM_PREFIX_LEN, L"DATACOLLECTORPERINSTANCESTATUS"))
		{
			hRes = g_pSystem->SendHMDataCollectorPerInstanceStatusInstance(pResponseHandler, pszGUID);
		}
		else if (!wcscmp(szPath+HM_PREFIX_LEN, L"DATACOLLECTORSTATISTICS"))
		{
			hRes = g_pSystem->SendHMDataCollectorStatisticsInstance(pResponseHandler, pszGUID);
		}
		else if (!wcscmp(szPath+HM_PREFIX_LEN, L"THRESHOLDSTATUS"))
		{
			hRes = g_pSystem->SendHMThresholdStatusInstance(pResponseHandler, pszGUID);
		}
		else if (!wcscmp(szPath+HM_PREFIX_LEN, L"ACTIONSTATUS"))
		{
			hRes = g_pSystem->SendHMActionStatusInstance(pResponseHandler, pszGUID);
		}
		else
		{
			MY_ASSERT(FALSE);
			hRes = pResponseHandler->SetStatus(0L, WBEM_E_FAILED, NULL, NULL);
MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASE IT", 4);
		ReleaseMutex(g_hConfigLock);
MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASED", 4);
			return WBEM_E_NOT_SUPPORTED;
		}
	}
	catch (...)
	{
		hRes = S_FALSE;
		MY_ASSERT(FALSE);
	}

	if (FAILED(hRes))
	{
		MY_HRESASSERT(hRes);
		OutputDebugString(L"CBaseInstanceProvider SendSMEvents failed!");
		pResponseHandler->SetStatus(0L, WBEM_E_FAILED, NULL, NULL);
MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASE IT", 4);
	ReleaseMutex(g_hConfigLock);
MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASED", 4);
		return hRes;
	}
	
	//  Now let caller know it's done.
	pResponseHandler->SetStatus(0L, WBEM_S_NO_ERROR, NULL, NULL);

MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASE IT", 4);
	ReleaseMutex(g_hConfigLock);
MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASED", 4);
	return WBEM_S_NO_ERROR;
}

HRESULT CBaseInstanceProvider::ExecQueryAsync(const BSTR QueryLanguage, const BSTR Query, long lFlags,
IWbemContext __RPC_FAR *pCtx, IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	TCHAR szQuery[HM_MAX_PATH];
	LPTSTR pszClass;
	LPTSTR pszGUID;
	LPTSTR pszEnd;
	HRESULT hRes;
	BOOL bCapable;
	DWORD dwErr = 0;

	if((pResponseHandler == NULL) || (wcslen(Query) > HM_MAX_PATH-1))
	{
		return WBEM_E_INVALID_PARAMETER;
	}


	MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync BLOCK - g_hConfigLock BLOCK WAIT", 4);
	dwErr = WaitForSingleObject(g_hConfigLock, HM_ASYNC_TIMEOUT);
	if(dwErr != WAIT_OBJECT_0)
	{
		if(dwErr = WAIT_TIMEOUT)
		{
			TRACE_MUTEX(L"TIMEOUT MUTEX");
			return WBEM_S_TIMEDOUT;
		}
		else
		{
			TRACE_MUTEX(L"WaitForSingleObject on Mutex failed");
			return WBEM_E_FAILED;
		}
	}
	MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync BLOCK - g_hConfigLock BLOCK GOT IT", 4);
	OutputDebugString(L"CBaseInstanceProvider::GetObjectAsync()\n");

	if (!g_pSystem)
	{
		ReleaseMutex(g_hConfigLock);
		return S_FALSE;
	}

	//	
	// Going to look something like this ->
	// select * from MicrosoftHM_DataCollectorstatus where GUID="{X}"
	//
	wcsncpy(szQuery, Query, HM_MAX_PATH-1);
	szQuery[HM_MAX_PATH-1] = '\0';
	bCapable = FALSE;
	_wcsupr(szQuery);
	pszEnd = wcsstr(szQuery, L"FROM");
	if (pszEnd)
	{
		// Get the name of the Class we are being asked to supply instances of
		pszEnd += 4;
		while (*pszEnd==' ' || *pszEnd=='\t')
		{
			pszEnd++;
		}
		pszClass = pszEnd;
		while (*pszEnd!=' ' && *pszEnd!='\t' && *pszEnd!='\0' && *pszEnd!='=')
		{
			pszEnd++;
		}
		*pszEnd = '\0';
		pszEnd++;

		//
		// Make sure it is something we can handle
		//
		if (!wcsstr(pszEnd, L"AND") && !wcsstr(pszEnd, L"OR") && (wcsstr(pszEnd, L" GUID") || wcsstr(pszEnd, L"\tGUID")))
		{
			pszEnd = wcschr(pszEnd, '"');
			if (pszEnd)
			{
				pszEnd++;
				pszGUID = pszEnd;
				pszEnd = wcschr(pszEnd, '"');
				if (pszEnd)
				{
					*pszEnd = '\0';
					bCapable = TRUE;
				}
			}
		}
	}
	else
	{
		pszClass = szQuery;
	}

	if (bCapable)
	{
		try
		{
			//
			// Now find out which instance type we need to return.
			//
			if (!wcscmp(pszClass+HM_PREFIX_LEN, L"SYSTEMSTATUS"))
			{
				hRes = g_pSystem->SendHMSystemStatusInstance(pResponseHandler, pszGUID);
			}
			else if (!wcscmp(pszClass+HM_PREFIX_LEN, L"DATAGROUPSTATUS"))
			{
				hRes = g_pSystem->SendHMDataGroupStatusInstance(pResponseHandler, pszGUID);
			}
			else if (!wcscmp(pszClass+HM_PREFIX_LEN, L"DATACOLLECTORSTATUS"))
			{
				hRes = g_pSystem->SendHMDataCollectorStatusInstance(pResponseHandler, pszGUID);
			}
			else if (!wcscmp(pszClass+HM_PREFIX_LEN, L"DATACOLLECTORPERINSTANCESTATUS"))
			{
				hRes = g_pSystem->SendHMDataCollectorPerInstanceStatusInstance(pResponseHandler, pszGUID);
			}
			else if (!wcscmp(pszClass+HM_PREFIX_LEN, L"DATACOLLECTORSTATISTICS"))
			{
				hRes = g_pSystem->SendHMDataCollectorStatisticsInstance(pResponseHandler, pszGUID);
			}
			else if (!wcscmp(pszClass+HM_PREFIX_LEN, L"THRESHOLDSTATUS"))
			{
				hRes = g_pSystem->SendHMThresholdStatusInstance(pResponseHandler, pszGUID);
			}
			else if (!wcscmp(pszClass+HM_PREFIX_LEN, L"ACTIONSTATUS"))
			{
				hRes = g_pSystem->SendHMActionStatusInstance(pResponseHandler, pszGUID);
			}
			else
			{
				MY_ASSERT(FALSE);
				hRes = pResponseHandler->SetStatus(0L, WBEM_E_FAILED, NULL, NULL);
MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASE IT", 4);
			ReleaseMutex(g_hConfigLock);
MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASED", 4);
				return WBEM_E_NOT_SUPPORTED;
			}
		}
		catch (...)
		{
			hRes = S_FALSE;
			MY_ASSERT(FALSE);
		}

		if (FAILED(hRes))
		{
//			MY_HRESASSERT(hRes);
			hRes = pResponseHandler->SetStatus(0L, WBEM_E_FAILED, NULL, NULL);
MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASE IT", 4);
		ReleaseMutex(g_hConfigLock);
MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASED", 4);
			return hRes;
		}
	
		//  Now let caller know it's done.
		hRes = pResponseHandler->SetStatus(0L, WBEM_S_NO_ERROR, NULL, NULL);

MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASE IT", 4);
		ReleaseMutex(g_hConfigLock);
MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASED", 4);
		return WBEM_S_NO_ERROR;
	}
	else
	{
		//  Now let caller know it's done.
//XXX		pResponseHandler->SetStatus(0L, WBEM_S_NO_ERROR, NULL, NULL);
		// To implement ExecQueryAsync, and have WMI handle query if the query is too
		// complicated. The proper way to handle it today is to call 
		pResponseHandler->SetStatus(WBEM_STATUS_REQUIREMENTS,  WBEM_REQUIREMENTS_START_POSTFILTER, 0, NULL);

		// And then proceed to enumerate all your instances. 
		// NOTE!!! Don't need to release the Mutex because it is done inside the call.
		hRes = CBaseInstanceProvider::CreateInstanceEnumAsync(pszClass, lFlags, pCtx, pResponseHandler);

		// NOTE!!! Don't need to release the Mutex because it is done inside the call.
		// OR DO WE. Once for each Wait called.
//XXX
MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASE IT", 4);
		ReleaseMutex(g_hConfigLock);
MY_OUTPUT(L"BLOCK - BLOCK CBaseInstanceProvider::GetObjectAsync g_hConfigLock BLOCK - RELEASED", 4);

		return hRes;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\global.cpp ===
//***************************************************************************
//
//  GLOBAL.CPP
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: Global helper functions, defines, macros...
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "global.h"


IWbemServices* g_pIWbemServices = NULL;
IWbemServices* g_pIWbemServicesCIMV2 = NULL;

//XXXSet the following as static vaiables of each of their repecive classes,
//and provide a Set function for it.
IWbemObjectSink* g_pSystemEventSink = NULL;
IWbemObjectSink* g_pDataGroupEventSink = NULL;
IWbemObjectSink* g_pDataCollectorEventSink = NULL;
IWbemObjectSink* g_pDataCollectorPerInstanceEventSink = NULL;
IWbemObjectSink* g_pDataCollectorStatisticsEventSink = NULL;
IWbemObjectSink* g_pThresholdEventSink = NULL;
//IWbemObjectSink* g_pThresholdInstanceEventSink = NULL;
IWbemObjectSink* g_pActionEventSink = NULL;
IWbemObjectSink* g_pActionTriggerEventSink = NULL;

//LPTSTR state[] = {L"OK",L"COLLECTING",L"RESET",L"INFO",L"DISABLED",L"SCHEDULEDOUT",L"RESERVED1",L"RESERVED2",L"WARNING",L"CRITICAL"};
//LPTSTR condition[] = {L"<",L">",L"=",L"!=",L">=",L"<=",L"contains",L"!contains",L"always"};
LPTSTR stateLocStr[10];
LPTSTR conditionLocStr[9];

void ClearLocStrings(void);


// Set these at startup
HRESULT SetLocStrings(void)
{
	int i;
	TCHAR szTemp[1024];
	HRESULT hRetRes = S_OK;

	for (i=0; i<10; i++)
	{
		stateLocStr[i] = NULL;
	}
	for (i=0; i<9; i++)
	{
		conditionLocStr[i] = NULL;
	}

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_OK, szTemp, 1024))
	{
		wcscpy(szTemp, L"OK");
	}
	stateLocStr[0] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(stateLocStr[0]); if (!stateLocStr[0]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(stateLocStr[0], szTemp);

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_COLLECTING, szTemp, 1024))
	{
		wcscpy(szTemp, L"COLLECTING");
	}
	stateLocStr[1] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(stateLocStr[1]); if (!stateLocStr[1]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(stateLocStr[1], szTemp);

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_RESET, szTemp, 1024))
	{
		wcscpy(szTemp, L"RESET");
	}
	stateLocStr[2] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(stateLocStr[2]); if (!stateLocStr[2]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(stateLocStr[2], szTemp);

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_INFO, szTemp, 1024))
	{
		wcscpy(szTemp, L"INFO");
	}
	stateLocStr[3] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(stateLocStr[3]); if (!stateLocStr[3]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(stateLocStr[3], szTemp);

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_DISABLED, szTemp, 1024))
	{
		wcscpy(szTemp, L"DISABLED");
	}
	stateLocStr[4] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(stateLocStr[4]); if (!stateLocStr[4]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(stateLocStr[4], szTemp);

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_SCHEDULEDOUT, szTemp, 1024))
	{
		wcscpy(szTemp, L"SCHEDULEDOUT");
	}
	stateLocStr[5] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(stateLocStr[5]); if (!stateLocStr[5]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(stateLocStr[5], szTemp);

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_RESERVED1, szTemp, 1024))
	{
		wcscpy(szTemp, L"RESERVED1");
	}
	stateLocStr[6] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(stateLocStr[6]); if (!stateLocStr[6]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(stateLocStr[6], szTemp);

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_RESERVED2, szTemp, 1024))
	{
		wcscpy(szTemp, L"RESERVED2");
	}
	stateLocStr[7] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(stateLocStr[7]); if (!stateLocStr[7]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(stateLocStr[7], szTemp);

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_WARNING, szTemp, 1024))
	{
		wcscpy(szTemp, L"WARNING");
	}
	stateLocStr[8] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(stateLocStr[8]); if (!stateLocStr[8]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(stateLocStr[8], szTemp);

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_CRITICAL, szTemp, 1024))
	{
		wcscpy(szTemp, L"CRITICAL");
	}
	stateLocStr[9] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(stateLocStr[9]); if (!stateLocStr[9]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(stateLocStr[9], szTemp);

	//
	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_LT, szTemp, 1024))
	{
		wcscpy(szTemp, L"<");
	}
	conditionLocStr[0] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(conditionLocStr[0]); if (!conditionLocStr[0]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(conditionLocStr[0], szTemp);

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_GT, szTemp, 1024))
	{
		wcscpy(szTemp, L">");
	}
	conditionLocStr[1] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(conditionLocStr[1]); if (!conditionLocStr[1]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(conditionLocStr[1], szTemp);

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_EQ, szTemp, 1024))
	{
		wcscpy(szTemp, L"=");
	}
	conditionLocStr[2] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(conditionLocStr[2]); if (!conditionLocStr[2]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(conditionLocStr[2], szTemp);

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_NE, szTemp, 1024))
	{
		wcscpy(szTemp, L"!=");
	}
	conditionLocStr[3] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(conditionLocStr[3]); if (!conditionLocStr[3]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(conditionLocStr[3], szTemp);

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_GTEQ, szTemp, 1024))
	{
		wcscpy(szTemp, L">=");
	}
	conditionLocStr[4] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(conditionLocStr[4]); if (!conditionLocStr[4]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(conditionLocStr[4], szTemp);

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_LTEQ, szTemp, 1024))
	{
		wcscpy(szTemp, L"<=");
	}
	conditionLocStr[5] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(conditionLocStr[5]); if (!conditionLocStr[5]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(conditionLocStr[5], szTemp);

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_CONTAINS, szTemp, 1024))
	{
		wcscpy(szTemp, L"contains");
	}
	conditionLocStr[6] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(conditionLocStr[6]); if (!conditionLocStr[6]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(conditionLocStr[6], szTemp);

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_NOTCONTAINS, szTemp, 1024))
	{
		wcscpy(szTemp, L"!contains");
	}
	conditionLocStr[7] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(conditionLocStr[7]); if (!conditionLocStr[7]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(conditionLocStr[7], szTemp);

	if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_ALWAYS, szTemp, 1024))
	{
		wcscpy(szTemp, L"always");
	}
	conditionLocStr[8] = new TCHAR[wcslen(szTemp)+1];
	MY_ASSERT(conditionLocStr[8]); if (!conditionLocStr[8]) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(conditionLocStr[8], szTemp);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	ClearLocStrings();
	return hRetRes;
}

void ClearLocStrings(void)
{
	int i;

	for (i=0; i<10; i++)
	{
		delete [] stateLocStr[i];
	}

	for (i=0; i<9; i++)
	{
		delete [] conditionLocStr[i];
	}

}

BOOL ReadUI64(LPCWSTR wsz, UNALIGNED unsigned __int64& rui64)
{
    unsigned __int64 ui64 = 0;
    const WCHAR* pwc = wsz;

    // Check for a NULL pointer
    if ( NULL == wsz )
    {
        return FALSE;
    }

    while(ui64 < 0xFFFFFFFFFFFFFFFF / 8 && *pwc >= L'0' && *pwc <= L'9')
    {
        unsigned __int64 ui64old = ui64;
        ui64 = ui64 * 10 + (*pwc - L'0');
        if(ui64 < ui64old)
            return FALSE;

        pwc++;
    }

    if(*pwc)
    {
        return FALSE;
    }

    rui64 = ui64;
    return TRUE;
}

HRESULT ReplaceStr(LPTSTR *pszString, LPTSTR pszOld, LPTSTR pszNew)
{
	HRESULT hRetRes = S_OK;
	BSTR bstrPropName = NULL;
	TCHAR szQuery[4096];
	LPTSTR pStr;
	LPTSTR pStr2;
	LPTSTR pszNewStr;

	MY_ASSERT(pszOld);
	if (!pszOld)
	{
		return WBEM_E_INVALID_PROPERTY;
	}

	MY_ASSERT(pszNew);
	if (!pszNew)
	{
		return WBEM_E_INVALID_PROPERTY;
	}

	MY_ASSERT(*pszString);
	if (!*pszString)
	{
		return WBEM_E_INVALID_PROPERTY;
	}

	wcsncpy(szQuery, *pszString, 4095);
	szQuery[4095] = '\0';
	_wcsupr(szQuery);
	pStr = wcsstr(szQuery, pszOld);
	if (!pStr)
	{
		return S_OK;
	}

	pszNewStr = new TCHAR[wcslen(*pszString)+wcslen(pszNew)-wcslen(pszOld)+1];
	MY_ASSERT(pszNewStr);
	if (!pszNewStr)
	{
		hRetRes = WBEM_E_OUT_OF_MEMORY;
	}
	else
	{
		pStr2 = *pszString;
		pStr2 += pStr-szQuery;
		*pStr2 = '\0';
		wcscpy(pszNewStr, *pszString);
		wcscat(pszNewStr, pszNew);
		pStr2 += wcslen(pszOld);
		wcscat(pszNewStr, pStr2);
	}

	if (hRetRes == S_OK)
	{
		delete [] *pszString;
		*pszString = pszNewStr;
	}

	return hRetRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\instprov.h ===
// BaseInstanceProvider.h: interface for the CBaseInstanceProvider class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BASEINSTANCEPROVIDER_H__1CCFABA5_1A8C_11D2_BDD9_00C04FA35447__INCLUDED_)
#define AFX_BASEINSTANCEPROVIDER_H__1CCFABA5_1A8C_11D2_BDD9_00C04FA35447__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "system.h"
//#include "dataelmt.h"

class CBaseInstanceProvider : public IWbemServices, public IWbemProviderInit
{
public:
	CBaseInstanceProvider();
	virtual ~CBaseInstanceProvider();

protected:
	ULONG m_cRef;
	IWbemServices* m_pIWbemServices;

public:
// CBaseInstanceProvider Operation

// IUnknown
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID* ppv);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

// IWbemEventProviderInit
	HRESULT STDMETHODCALLTYPE Initialize(LPWSTR pszUser,
										LONG lFlags,
										LPWSTR pszNamespace,
										LPWSTR pszLocale,
										IWbemServices __RPC_FAR *pNamespace,
										IWbemContext __RPC_FAR *pCtx,
										IWbemProviderInitSink __RPC_FAR *pInitSink);

// IWbemServices
  HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
//XXX      /* [in] */ BSTR Class,
      /* [in] */ const BSTR Class,
      /* [in] */ long lFlags,
      /* [in] */ IWbemContext __RPC_FAR *pCtx,
      /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

  HRESULT STDMETHODCALLTYPE GetObjectAsync( 
//XXX        /* [in] */ BSTR ObjectPath,
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
// IWbemServices Unsupported functions
	inline HRESULT STDMETHODCALLTYPE OpenNamespace( 
//XXX          /* [in] */ BSTR Namespace,
          /* [in] */ const BSTR Namespace,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
          /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
  
	inline HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
    
  inline HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE GetObject( 
//XXX        /* [in] */ BSTR ObjectPath,
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

	inline HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE DeleteClass( 
//XXX        /* [in] */ BSTR Class,
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
//XXX        /* [in] */ BSTR Class,
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE CreateClassEnum( 
//XXX        /* [in] */ BSTR Superclass,
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum){return WBEM_E_NOT_SUPPORTED;};

	inline HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
//XXX        /* [in] */ BSTR Superclass,
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE DeleteInstance( 
//XXX        /* [in] */ BSTR ObjectPath,
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
//XXX        /* [in] */ BSTR ObjectPath,
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
//XXX        /* [in] */ BSTR Class,
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
	inline HRESULT STDMETHODCALLTYPE ExecQuery( 
//XXX        /* [in] */ BSTR QueryLanguage,
//XXX        /* [in] */ BSTR Query,
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
	HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
//XXX        /* [in] */ BSTR QueryLanguage,
//XXX        /* [in] */ BSTR Query,
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
	inline HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
//XXX        /* [in] */ BSTR QueryLanguage,
//XXX        /* [in] */ BSTR Query,
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
//XXX        /* [in] */ BSTR QueryLanguage,
//XXX        /* [in] */ BSTR Query,
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

#ifdef SAVE
	inline HRESULT STDMETHODCALLTYPE ExecMethod( BSTR, BSTR, long, IWbemContext*,
        IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

	inline HRESULT STDMETHODCALLTYPE ExecMethodAsync( BSTR, BSTR, long, 
        IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}
#endif
        virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
//XXX            /* [in] */ BSTR strObjectPath,
//XXX            /* [in] */ BSTR strMethodName,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
//XXX            /* [in] */ BSTR strObjectPath,
//XXX            /* [in] */ BSTR strMethodName,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

};

#endif // !defined(AFX_BASEINSTANCEPROVIDER_H__1CCFABA5_1A8C_11D2_BDD9_00C04FA35447__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\methprov.h ===
// BaseMethodProvider.h: interface for the CBaseMethodProvider class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _methprov_H_
#define _methprov_H_

#include "system.h"
//#include "dataelmt.h"

class CBaseMethodProvider : public IWbemServices, public IWbemProviderInit
{
public:
	CBaseMethodProvider();
	virtual ~CBaseMethodProvider();

protected:
	ULONG m_cRef;
	IWbemServices* m_pIWbemServices;
	CSystem* m_pSystem;

public:
// CBaseMethodProvider Operation

// IUnknown
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID* ppv);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

// IWbemEventProviderInit
	HRESULT STDMETHODCALLTYPE Initialize(LPWSTR pszUser,
										LONG lFlags,
										LPWSTR pszNamespace,
										LPWSTR pszLocale,
										IWbemServices __RPC_FAR *pNamespace,
										IWbemContext __RPC_FAR *pCtx,
										IWbemProviderInitSink __RPC_FAR *pInitSink);

// IWbemServices
  HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
//XXX      /* [in] */ BSTR Class,
      /* [in] */ const BSTR Class,
      /* [in] */ long lFlags,
      /* [in] */ IWbemContext __RPC_FAR *pCtx,
      /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;}

  HRESULT STDMETHODCALLTYPE GetObjectAsync( 
//XXX        /* [in] */ BSTR ObjectPath,
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    
// IWbemServices Unsupported functions
	inline HRESULT STDMETHODCALLTYPE OpenNamespace( 
//XXX          /* [in] */ BSTR Namespace,
          /* [in] */ const BSTR Namespace,
          /* [in] */ long lFlags,
          /* [in] */ IWbemContext __RPC_FAR *pCtx,
          /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
          /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
  
	inline HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
    
  inline HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE GetObject( 
//XXX        /* [in] */ BSTR ObjectPath,
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

	inline HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE DeleteClass( 
//XXX        /* [in] */ BSTR Class,
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
//XXX        /* [in] */ BSTR Class,
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE CreateClassEnum( 
//XXX        /* [in] */ BSTR Superclass,
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum){return WBEM_E_NOT_SUPPORTED;};

	inline HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
//XXX        /* [in] */ BSTR Superclass,
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE DeleteInstance( 
//XXX        /* [in] */ BSTR ObjectPath,
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
//XXX        /* [in] */ BSTR ObjectPath,
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
//XXX        /* [in] */ BSTR Class,
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
	inline HRESULT STDMETHODCALLTYPE ExecQuery( 
//XXX        /* [in] */ BSTR QueryLanguage,
//XXX        /* [in] */ BSTR Query,
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
//XXX        /* [in] */ BSTR QueryLanguage,
//XXX        /* [in] */ BSTR Query,
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
//XXX        /* [in] */ BSTR QueryLanguage,
//XXX        /* [in] */ BSTR Query,
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
	inline HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
//XXX        /* [in] */ BSTR QueryLanguage,
//XXX        /* [in] */ BSTR Query,
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

#ifdef SAVE
	inline HRESULT STDMETHODCALLTYPE ExecMethod( BSTR, BSTR, long, IWbemContext*,
        IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

	inline HRESULT STDMETHODCALLTYPE ExecMethodAsync( BSTR, BSTR, long, 
        IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}
#endif
        virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
//XXX            /* [in] */ BSTR strObjectPath,
//XXX            /* [in] */ BSTR strMethodName,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
//XXX            /* [in] */ BSTR strObjectPath,
//XXX            /* [in] */ BSTR strMethodName,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\pgde.cpp ===
//***************************************************************************
//
//  PGDE.CPP
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: CPolledGetObjectDataCollector class to do WMI instance collection.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "pgde.h"
#include "system.h"
extern CSystem* g_pSystem;


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPolledGetObjectDataCollector::CPolledGetObjectDataCollector()
{
	MY_OUTPUT(L"ENTER ***** CPolledGetObjectDataCollector...", 1);

	m_pRefresher = NULL;
	m_pConfigureRefresher = NULL;
	m_pEnum = NULL;
	m_pObjAccess = NULL;
	m_lId = 0;
	m_szObjectPath = NULL;
	m_deType = HM_PGDE;
	m_lNumInstancesCollected = 0;
	m_pEnumObjs = NULL;
	m_pCallResult = NULL;

	MY_OUTPUT(L"EXIT ***** CPolledGetObjectDataCollector...", 1);
}

CPolledGetObjectDataCollector::~CPolledGetObjectDataCollector()
{
	MY_OUTPUT(L"ENTER ***** ~CPolledGetObjectDataCollector...", 1);

	if (m_szObjectPath)
	{
		delete [] m_szObjectPath;
	}

	if (m_pRefresher != NULL)
	{
		m_pRefresher->Release();
		m_pRefresher = NULL;
	}

	if (m_pConfigureRefresher != NULL)
	{
		m_pConfigureRefresher->Release();
		m_pConfigureRefresher = NULL;
	}

	if (m_pEnum != NULL)
	{
		m_pEnum->Release();
		m_pEnum = NULL;
	}

	if (m_pObjAccess != NULL)
	{
		m_pObjAccess->Release();
		m_pObjAccess = NULL;
	}

	EnumDone();

	MY_OUTPUT(L"EXIT ***** ~CPolledGetObjectDataCollector...", 1);
}

//
// Load a single DataCollector, and everything under it.
//
HRESULT CPolledGetObjectDataCollector::LoadInstanceFromMOF(IWbemClassObject* pObj, CDataGroup *pParentDG, LPTSTR pszParentObjPath, BOOL bModifyPass/*FALSE*/)
{
	HRESULT hRes;
	IWbemClassObject* pConfigObj = NULL;
	BOOL bRetValue = TRUE;
	HRESULT hRetRes = S_OK;
	int i, iSize;
	CThreshold* pThreshold;

	MY_OUTPUT(L"ENTER ***** CPolledGetObjectDataCollector::LoadInstanceFromMOF...", 4);
	iSize = m_thresholdList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		if (pThreshold->m_bValidLoad == FALSE)
			return WBEM_E_INVALID_OBJECT;
//			return S_OK;
	}

	if (m_szObjectPath)
	{
		delete [] m_szObjectPath;
		m_szObjectPath = NULL;
	}
	m_lNumInstancesCollected = 0;

	//
	// Call the base class to load the common properties. Then do the specific ones.
	//
	hRetRes = CDataCollector::LoadInstanceFromMOF(pObj, pParentDG, pszParentObjPath, bModifyPass);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) return hRetRes;

	// Get the GUID property
	hRetRes = GetStrProperty(pObj, L"ObjectPath", &m_szObjectPath);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	// Decide if the path sets us up for multiple instances
	if (wcschr(m_szObjectPath, L'='))
	{
		m_bMultiInstance = FALSE;
	}
	else
	{
		m_bMultiInstance = TRUE;
	}

	//
	// Check to see if the High Performance interfaces are supported
	// Otherwise we just revert to less efficient WMI interfaces
	//
	hRes = E_UNEXPECTED;
	if (SUCCEEDED(hRes))
	{
	}
	else
	{
		m_pRefresher = NULL;
		bRetValue = FALSE;
	}

	if (bModifyPass)
	{
	}

	MY_OUTPUT(L"EXIT ***** CPolledGetObjectDataCollector::LoadInstanceFromMOF...", 4);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

//
// Get the instance out of WMI, and store all the properties we care about.
// Also calculate statistics for them.
//
BOOL CPolledGetObjectDataCollector::CollectInstance(void)
{
	BSTR bstrName = NULL;
	TCHAR szTemp[1024];
	HRESULT hRes;
	IWbemClassObject *pObj = NULL;
	BOOL bRetValue = TRUE;
	PNSTRUCT *ppn;
	INSTSTRUCT inst;
	INSTSTRUCT *pinst;
	int i, j, iSize, jSize;
	SAFEARRAY *psaNames = NULL;
	BSTR PropName = NULL;
	CThreshold *pThreshold;
	IRSSTRUCT *pirs;
	ACTUALINSTSTRUCT *pActualInst;

	MY_OUTPUT(L"ENTER ***** CPolledGetObjectDataCollector::CollectInstance...", 1);

	m_lNumInstancesCollected = 0;

	if (m_pIWbemServices == NULL)
	{
//XXX		m_lCurrState = HM_CRITICAL;
		MY_ASSERT(FALSE);
		m_ulErrorCode = HMRES_BADWMI;
		GetLatestAgentError(HMRES_BADWMI, m_szErrorDescription);
		StoreStandardProperties();
		return FALSE;
	}

	//
	// First we can tell if this is going to be single instance, or multi-instance
	//
//XXXCould split this out into four functions that call from here.
	if (m_bMultiInstance==TRUE)
	{
//XXXNeed to change this to be asyncronous???
		//
		// MULTI-INSTANCE CASE
		//

		//
		// Check to see if the High Performance interfaces are supported
		//
		if (m_pRefresher!=NULL)
		{
			// Ask for the refresh
#ifdef SAVE
			hRes = m_pRefresher->Refresh(0L);
			if (FAILED(hRes))
			{
			}
#endif

			// Now get the instance
		}
		else
		{
			//
			// We get an instance at a time, so we can set all to not needed first,
			// then go through them, do StoreValues... and delete what is not needed.
			//

			//
			// Mark each instance, so we can tell if we still need them.
			//
			iSize = m_pnList.size();
			for (i = 0; i < iSize ; i++)
			{
				MY_ASSERT(i<m_pnList.size());
				ppn = &m_pnList[i];
				jSize = ppn->instList.size();
				for (j = 0; j < jSize ; j++)
				{
					MY_ASSERT(j<ppn->instList.size());
					pinst = &ppn->instList[j];
					pinst->bNeeded = FALSE;
				}
			}

			// Also for all thresholds under this DataCollector
			iSize = m_thresholdList.size();
			for (i = 0; i < iSize; i++)
			{
				MY_ASSERT(i<m_thresholdList.size());
				pThreshold = m_thresholdList[i];
				jSize = pThreshold->m_irsList.size();
				for (j = 0; j < jSize; j++)
				{
					MY_ASSERT(j<pThreshold->m_irsList.size());
					pirs = &pThreshold->m_irsList[j];
					pirs->bNeeded = FALSE;
				}
			}

			iSize = m_actualInstList.size();
			for (i=0; i < iSize; i++)
			{
				MY_ASSERT(i<m_actualInstList.size());
				pActualInst = &m_actualInstList[i];
				pActualInst->bNeeded = FALSE;
			}

			//
			// Enumerate through the instances
			//
			bstrName = SysAllocString(m_szObjectPath);
			m_pEnumObjs = NULL;
			hRes = m_pIWbemServices->CreateInstanceEnum(bstrName,
					WBEM_FLAG_SHALLOW|WBEM_FLAG_FORWARD_ONLY|WBEM_FLAG_RETURN_IMMEDIATELY, NULL,
					&m_pEnumObjs);
			if (hRes != S_OK)
			{
				m_ulErrorCode = hRes;
				GetLatestWMIError(HMRES_OBJECTNOTFOUND, hRes, m_szErrorDescription);
				StoreStandardProperties();
				bRetValue = FALSE;
				MY_HRESASSERT(hRes);
				MY_OUTPUT2(L"PGDE-Unexpected Error: 0x%08x",hRes,4);
				MY_OUTPUT2(L"m_szGUID was=%s",m_szGUID,4);
				MY_OUTPUT2(L"bstrName was=%s",bstrName,4);
				MY_OUTPUT2(L"CreateInstanceEnum(%s)",m_szObjectPath,4);
			}
			else
			{
				m_bKeepCollectingSemiSync = TRUE;
				bRetValue = CollectInstanceSemiSync();
			}
			SysFreeString(bstrName);
		}
	}
	else
	{
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//XXX
//XXX
//XXX
//We should just always use the multi-instance code, and delete this code.
//The multi-instance code will still work in the single instance case!!!!!
//XXX
//XXX
//XXX
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		//
		// SINGLE INSTANCE CASE
		//

		//
		// Check to see if the High Performance interfaces are supported
		//
		if (m_pRefresher!=NULL)
		{
			// Ask for the refresh
#ifdef SAVE
			hRes = m_pRefresher->Refresh(0L);
			if (FAILED(hRes))
			{
			}
#endif

			// Now get the instances
		}
		else
		{
			//
			// Mark each instance, so we can tell if we still need them.
			//
			iSize = m_pnList.size();
			for (i = 0; i < iSize ; i++)
			{
				MY_ASSERT(i<m_pnList.size());
				ppn = &m_pnList[i];
				jSize = ppn->instList.size();
				for (j = 0; j < jSize ; j++)
				{
					MY_ASSERT(j<ppn->instList.size());
					pinst = &ppn->instList[j];
					pinst->bNeeded = FALSE;
				}
			}

			// Also for all thresholds under this DataCollector
			iSize = m_thresholdList.size();
			for (i = 0; i < iSize; i++)
			{
				MY_ASSERT(i<m_thresholdList.size());
				pThreshold = m_thresholdList[i];
				jSize = pThreshold->m_irsList.size();
				for (j = 0; j < jSize; j++)
				{
					MY_ASSERT(j<pThreshold->m_irsList.size());
					pirs = &pThreshold->m_irsList[j];
					pirs->bNeeded = FALSE;
				}
			}

			iSize = m_actualInstList.size();
			for (i=0; i < iSize; i++)
			{
				MY_ASSERT(i<m_actualInstList.size());
				pActualInst = &m_actualInstList[i];
				pActualInst->bNeeded = FALSE;
			}

			//
			// This is the single instance, NON-HighPerformance case
			//
			swprintf(szTemp, L"%s", m_szObjectPath);
			hRes = GetWbemObjectInstSemiSync(&m_pIWbemServices, szTemp, m_pContext, &m_pCallResult);
			if (hRes != S_OK || m_pCallResult == NULL)
			{
				m_ulErrorCode = hRes;
				GetLatestWMIError(HMRES_OBJECTNOTFOUND, hRes, m_szErrorDescription);
				StoreStandardProperties();
				bRetValue = FALSE;
				MY_HRESASSERT(hRes);
				MY_OUTPUT2(L"PGDE-Unexpected Error: 0x%08x",hRes,4);
				MY_OUTPUT2(L"m_szGUID was=%s",m_szGUID,4);
				MY_OUTPUT2(L"CreateWbemObjectInstSemiSync(%s)",m_szObjectPath,4);
			}
			else
			{
				m_bKeepCollectingSemiSync = TRUE;
				bRetValue = CollectInstanceSemiSync();
			}
		}
	}

	MY_OUTPUT(L"EXIT ***** CPolledGetObjectDataCollector::CollectInstance...", 1);
	return bRetValue;
}

BOOL CPolledGetObjectDataCollector::CollectInstanceSemiSync(void)
{
	LPTSTR pszID = NULL;
	HRESULT hRes;
	IWbemClassObject *pObj;
	IWbemClassObject *apObj[10];
	INSTSTRUCT inst;
	long lStatus;
	ULONG uReturned = 0;

	MY_OUTPUT(L"ENTER ***** CPolledGetObjectDataCollector::CollectInstanceSemiSync...", 1);

	if (m_bMultiInstance==TRUE)
	{
		MY_ASSERT(m_pEnumObjs);
		// We never want to block here, so we set it for zero second timeout,
		// and have it return immediatly what it has available.
		hRes = m_pEnumObjs->Next(0, 10, apObj, &uReturned);

		if (hRes == WBEM_S_TIMEDOUT)
		{
			// Didn't get full list of instances yet.
			if (!ProcessObjects(uReturned, apObj))
			{
				EnumDone();
				return FALSE;
			}
			return FALSE;
		}
		else if (hRes == WBEM_S_FALSE)
		{
			//
			// Means that we are done. The number returned was less than asked for.
			// But we still process what we did recieve to finish it off.
			// Add in a fake instance for the number of instances returned.
			//
			if (!ProcessObjects(uReturned, apObj))
			{
				EnumDone();
				return FALSE;
			}
			else
			{
				m_ulErrorCode = 0;
				StoreStandardProperties();
				EnumDone();
//XXXWhy was this here???				m_lCurrState = HM_GOOD;
				return TRUE;
			}
		}
		else if (hRes == WBEM_S_NO_ERROR)
		{
			// Means that we have an instance, The number returned was what was requested
		}
		else
		{
			MY_HRESASSERT(hRes);
			MY_OUTPUT2(L"PGDE-Unexpected Error MultiInstance Next(): 0x%08x",hRes,4);
			MY_OUTPUT2(L"m_szGUID was=%s",m_szGUID,4);
			MY_OUTPUT2(L"ObjectPath was=%s",m_szObjectPath,4);
			m_ulErrorCode = hRes;
			GetLatestWMIError(HMRES_ENUMFAIL, hRes, m_szErrorDescription);
			StoreStandardProperties();
			EnumDone();
			return FALSE;
		}

		if (apObj[0] == NULL)
		{
			//
			// NULL in this case can actually happen. An example is where the
			// threshold is to see if the SQL Server service is running. If it
			// is not even on the machine, then we would get an error looking
			// for its instance.
			//
			m_ulErrorCode = hRes;
			GetLatestWMIError(HMRES_OBJECTNOTFOUND, hRes, m_szErrorDescription);
			StoreStandardProperties();
			EnumDone();
		}
		else
		{
			MY_ASSERT(uReturned>=1);
			if (!ProcessObjects(uReturned, apObj))
			{
				EnumDone();
				return FALSE;
			}
//			else
//			{
//				m_ulErrorCode = 0;
//			}
		}
	}
	else
	{
		MY_ASSERT(m_pCallResult);
		lStatus = 0;
		//
		// Keep trying until we get WBEM_S_NO_ERROR. Then we know the GetObject call has completed.
		// hRes will contain the result of the origional GetObject call if needed.
		//
		hRes = m_pCallResult->GetCallStatus(0, &lStatus);
		if (hRes == WBEM_S_TIMEDOUT)
		{
			return FALSE;
		}
		else if (hRes == WBEM_S_NO_ERROR)
		{
			// Means that we are done.
			// HOWEVER, we don't know if we ever retrieved any instances!
			// This is different from the multi-instance case, because we do
			// ask for a single specific instance, and will know below if it is there!
		}
		else
		{
			MY_HRESASSERT(hRes);
			MY_OUTPUT2(L"PGDE-Unexpected Error SingleInstance GetCallStatus: 0x%08x",hRes,4);
			MY_OUTPUT2(L"m_szGUID was=%s",m_szGUID,4);
			MY_OUTPUT2(L"ObjectPath was=%s",m_szObjectPath,4);
			m_ulErrorCode = hRes;
			GetLatestWMIError(HMRES_OBJECTNOTFOUND, hRes, m_szErrorDescription);
			StoreStandardProperties();
			EnumDone();
			return FALSE;
		}

		//
		// This may mean that the call completed, and the object was not found (e.g. bad path).
		//
		if (lStatus != 0)
		{
			MY_HRESASSERT(lStatus);
			m_ulErrorCode = lStatus;
			GetLatestWMIError(HMRES_OBJECTNOTFOUND, lStatus, m_szErrorDescription);
			StoreStandardProperties();
			EnumDone();
			return FALSE;
		}

		//
		// Get the Object finaly.
		//
		hRes = m_pCallResult->GetResultObject(0, &pObj);
		if (pObj == NULL)
		{
			MY_ASSERT(FALSE);
			//
			// NULL in this case can actually happen. An example is where the
			// threshold is to see if the SQL Server service is running. If it
			// is not even on the machine, then we would get an error looking
			// for its instance.
			//
			m_lCurrState = HM_WARNING;
			m_ulErrorCode = 0;
			EnumDone();
		}
		else
		{
			//
			// Figure out the key property name to identify instances with.
			//
			hRes = GetInstanceID(pObj, &pszID);
			if (hRes != S_OK)
			{
				pObj->Release();
				m_ulErrorCode = hRes;
				GetLatestWMIError(HMRES_OBJECTNOTFOUND, hRes, m_szErrorDescription);
				StoreStandardProperties();
				EnumDone();
				return FALSE;
			}
	
			//
			// Mark instances need to keep around, and add new ones
			//
			hRes = CheckInstanceExistance(pObj, pszID);
			if (hRes != S_OK)
			{
				delete [] pszID;
				pObj->Release();
				m_ulErrorCode = hRes;
				GetLatestWMIError(HMRES_OBJECTNOTFOUND, hRes, m_szErrorDescription);
				StoreStandardProperties();
				EnumDone();
				return FALSE;
			}

			m_lNumInstancesCollected = 1;
			StoreValues(pObj, pszID);
			delete [] pszID;
			pObj->Release();
			pObj = NULL;

			//
			// We are done.
			// Add in a fake instance for the number of instances returned.
			//
			m_ulErrorCode = 0;
			StoreStandardProperties();
			m_lCurrState = HM_GOOD;
			EnumDone();
		}
		return TRUE;
	}

	MY_OUTPUT(L"EXIT ***** CPolledGetObjectDataCollector::CollectInstanceSemiSync...", 1);
	return FALSE;
}

BOOL CPolledGetObjectDataCollector::ProcessObjects(ULONG uReturned, IWbemClassObject **apObj)
{
	HRESULT hRes;
	LPTSTR pszID;
	ULONG n;
	BOOL bRetValue = TRUE;

	for (n = 0; n < uReturned; n++)
	{
		if (g_pSystem->m_lNumInstancesAccepted <m_lNumInstancesCollected)
		{
			m_ulErrorCode = HMRES_TOOMANYINSTS;
			GetLatestAgentError(HMRES_TOOMANYINSTS, m_szErrorDescription);
			StoreStandardProperties();
			bRetValue = FALSE;
			break;
		}
//Why does the above cause ASSERT on 1151 of Threshold.cpp???
		//
		// Figure out the key property name to identify instances with.
		//
		hRes = GetInstanceID(apObj[n], &pszID);
		if (hRes != S_OK)
		{
			m_ulErrorCode = hRes;
			GetLatestWMIError(HMRES_OBJECTNOTFOUND, hRes, m_szErrorDescription);
			StoreStandardProperties();
			bRetValue = FALSE;
			break;
		}

		//
		// Special case to throw out the "_Total" instance in the multi-instance case
		//
		if (!_wcsicmp(pszID, L"_total"))
		{
			delete [] pszID;
			continue;
		}

		//
		// Mark instances need to keep around, and add new ones
		//
		hRes = CheckInstanceExistance(apObj[n], pszID);
		if (hRes != S_OK)
		{
			delete [] pszID;
			m_ulErrorCode = hRes;
			GetLatestWMIError(HMRES_OBJECTNOTFOUND, hRes, m_szErrorDescription);
			StoreStandardProperties();
			bRetValue = FALSE;
			break;
		}

		//
		// Now store each property that we need to for this instance
		//
		m_lNumInstancesCollected++;
		StoreValues(apObj[n], pszID);

		delete [] pszID;
	}

	for (n = 0; n < uReturned; n++)
	{
		apObj[n]->Release();
		apObj[n] = NULL;
	}
	return bRetValue;
}

//XXXIs EnumDone needed in all cases, if so place it in the base class
BOOL CPolledGetObjectDataCollector::EnumDone(void)
{
	IRSSTRUCT *pirs;
	IWbemClassObject *pObj = NULL;
	BOOL bRetValue = TRUE;
	PNSTRUCT *ppn;
	INSTSTRUCT inst;
	INSTSTRUCT *pinst;
	int i, j, iSize, jSize;
	CThreshold *pThreshold;
	SAFEARRAY *psaNames = NULL;
	BSTR PropName = NULL;
	INSTLIST::iterator iaPINST;
	IRSLIST::iterator iaPIRS;
	ACTUALINSTLIST::iterator iaPAI;
	ACTUALINSTSTRUCT *pActualInst;

	CleanupSemiSync();

//XXXAdd similar code to get rid of what is not needed in the m_instList
//XXXOnce again take common code and place it in the base class!VVVVVVVVVVVVVVVVVVVVVVVVv
	//
	// Now loop through and get rid of instances that are no longer around
	//
	iSize = m_pnList.size();
	for (i = 0; i < iSize; i++)
	{
		MY_ASSERT(i<m_pnList.size());
		ppn = &m_pnList[i];
		iaPINST = ppn->instList.begin();
		jSize = ppn->instList.size();
		for (j = 0; j < jSize && iaPINST ; j++)
		{
			pinst = iaPINST;
			if (pinst->bNeeded == FALSE)
			{
				if (pinst->szInstanceID)
					delete [] pinst->szInstanceID;
				if (pinst->szCurrValue)
					delete [] pinst->szCurrValue;
				pinst->szCurrValue = NULL;
				iaPINST = ppn->instList.erase(iaPINST);
			}
			else
			{
				iaPINST++;
			}
		}
	}

	// Also for all thresholds under this DataCollector
	iSize = m_thresholdList.size();
	for (i = 0; i < iSize; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		iaPIRS = pThreshold->m_irsList.begin();
		jSize = pThreshold->m_irsList.size();
		for (j = 0; j < jSize && iaPIRS ; j++)
		{
			pirs = iaPIRS;
			if (pirs->bNeeded == FALSE)
			{
				if (pirs->szInstanceID)
					delete [] pirs->szInstanceID;
				iaPIRS = pThreshold->m_irsList.erase(iaPIRS);
			}
			else
			{
				iaPIRS++;
			}
		}
	}

	iaPAI = m_actualInstList.begin();
	jSize = m_actualInstList.size();
	for (j = 0; j < jSize && iaPAI; j++)
	{
		pActualInst = iaPAI;
		if (pActualInst->bNeeded == FALSE)
		{
			if (pActualInst->szInstanceID)
			{
				delete [] pActualInst->szInstanceID;
			}
			if (pActualInst->pInst)
			{
				pActualInst->pInst->Release();
				pActualInst->pInst = NULL;
			}
			iaPAI = m_actualInstList.erase(iaPAI);
		}
		else
		{
			iaPAI++;
		}
	}
//XXXOnce again take common code and place it in the base class!^^^^^^^^^^^^^^^^^^^^^^^^^

	return TRUE;
}

BOOL CPolledGetObjectDataCollector::CleanupSemiSync(void)
{
	if (m_bMultiInstance==TRUE)
	{
		if (m_pEnumObjs)
		{
			m_pEnumObjs->Release(); 
			m_pEnumObjs = NULL;
		}
	}
	else
	{
		if (m_pCallResult)
		{
			m_pCallResult->Release();
			m_pCallResult = NULL;
		}
	}

	m_bKeepCollectingSemiSync = FALSE;
	m_lCollectionTimeOutCount = 0;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\methprov.cpp ===
// METHPROV.CPP: implementation of the CBaseMethodProvider class.
//
//////////////////////////////////////////////////////////////////////
#include <atlbase.h>
#include "HMAgent.h"
#include "methprov.h"

//////////////////////////////////////////////////////////////////////
// global data
extern CSystem* g_pSystem;
extern HANDLE g_hConfigLock;
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBaseMethodProvider::CBaseMethodProvider()
{
	OutputDebugString(L"CBaseMethodProvider::CBaseMethodProvider()\n");

	MY_ASSERT(g_pSystem);
	m_pSystem = g_pSystem;

	m_cRef = 0L;
	m_pIWbemServices = NULL;
}

CBaseMethodProvider::~CBaseMethodProvider()
{
	OutputDebugString(L"CBaseMethodProvider::~CBaseMethodProvider()\n");

	if (m_pIWbemServices)
	{
		m_pIWbemServices->Release();
	}

	m_pIWbemServices = NULL;
}

//////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CBaseMethodProvider::QueryInterface(REFIID riid, LPVOID* ppv)
{
	*ppv = NULL;

	if(riid== IID_IWbemServices)
	{
		*ppv=(IWbemServices*)this;
	}

	if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
	{
		*ppv=(IWbemProviderInit*)this;
	}
  

	if (NULL!=*ppv) 
	{
		AddRef();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}

}

STDMETHODIMP_(ULONG) CBaseMethodProvider::AddRef(void)
{
	return InterlockedIncrement((long*)&m_cRef);
}

STDMETHODIMP_(ULONG) CBaseMethodProvider::Release(void)
{
	LONG	lCount = InterlockedDecrement((long*)&m_cRef);

	if (0 != lCount)
	{
		return lCount;
	}

	delete this;
	return 0L;
}

//////////////////////////////////////////////////////////////////////
// IWbemProviderInit Implementation
//////////////////////////////////////////////////////////////////////

HRESULT CBaseMethodProvider::Initialize(LPWSTR pszUser,
LONG lFlags,
LPWSTR pszNamespace,
LPWSTR pszLocale,
IWbemServices __RPC_FAR *pNamespace,
IWbemContext __RPC_FAR *pCtx,
IWbemProviderInitSink __RPC_FAR *pInitSink)
{
	OutputDebugString(L"CBaseMethodProvider::Initialize()\n");

	if (NULL == pNamespace)
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	m_pIWbemServices = pNamespace;
	m_pIWbemServices->AddRef();

	pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	return WBEM_S_NO_ERROR;
}

//////////////////////////////////////////////////////////////////////
// IWbemService Implementation
//////////////////////////////////////////////////////////////////////

HRESULT CBaseMethodProvider::ExecMethodAsync(const BSTR ObjectPath, const BSTR MethodName, 
            long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, 
            IWbemObjectSink* pResultSink)
{
    CComVariant var;
	CComVariant v;
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutClass = NULL;    
    IWbemClassObject* pOutParams = NULL;
	SAFEARRAY* psa = NULL;
	LPTSTR szOriginalSystem = NULL;
	LPTSTR szOriginalParentGUID = NULL;
	LPTSTR szGUID = NULL;
	DWORD iRetValue;
	HRESULT hRetRes;
	BOOL bForceReplace;
	DWORD dwErr = 0;

	MY_OUTPUT(L"CBaseMethodProvider::ExecMethodAsync()", 1);

	//
    // Do some minimal error checking.
	//
    if(MethodName == NULL || pInParams == NULL || pResultSink == NULL)
	{
        return WBEM_E_INVALID_PARAMETER;
	}

	if (!g_pSystem)
	{
		hRetRes=WBEM_E_FAILED;
		goto error;
	}

    hRetRes = m_pIWbemServices->GetObject(ObjectPath, 0, pCtx, &pClass, NULL);
	if(hRetRes != S_OK)
	{
		MY_HRESASSERT(hRetRes);
		goto error;
	}
 
	// Call the appropriate method.
	// retval == 0 means success...
    
    // Get the input argument
    hRetRes = pInParams->Get(L"TargetGUID", 0, &var, NULL, NULL);   
	MY_HRESASSERT(hRetRes); 
	if (hRetRes != S_OK)
	{
		goto error;
	}

	if (V_VT(&var)==VT_NULL)
	{
		hRetRes = WBEM_E_INVALID_PARAMETER;
		goto error;
	}
   	
	hRetRes = pClass->GetMethod(MethodName, 0, NULL, &pOutClass);
	MY_HRESASSERT(hRetRes); 
	if (hRetRes != S_OK) 
	{
		goto error;
	}

	hRetRes = pOutClass->SpawnInstance(0, &pOutParams);
	MY_HRESASSERT(hRetRes); 
	if (hRetRes != S_OK)
	{
		goto error;
	}

	// now we need to acquire the Mutex, not before!
	MY_OUTPUT(L"BLOCK - BLOCK CBaseMethodProvider::ExecMethodAsync BLOCK - g_hConfigLock BLOCK WAIT", 4);
	dwErr = WaitForSingleObject(g_hConfigLock, HM_ASYNC_TIMEOUT);
	if(dwErr != WAIT_OBJECT_0)
	{
		if(dwErr = WAIT_TIMEOUT)
		{
			TRACE_MUTEX(L"TIMEOUT MUTEX");
			return WBEM_S_TIMEDOUT;
		}
		else
		{
			MY_OUTPUT(L"WaitForSingleObject on Mutex failed",4);
			return WBEM_E_FAILED;
		}
	}

	MY_OUTPUT(L"BLOCK - BLOCK CBaseMethodProvider::ExecMethodAsync BLOCK - g_hConfigLock BLOCK GOT IT", 4);

	try
	{
	if (!wcscmp(MethodName, L"Delete"))
	{
		hRetRes = m_pSystem->FindAndDeleteByGUID(V_BSTR(&var));
		iRetValue = hRetRes;
	}
	else if (!wcscmp(MethodName, L"ResetAndCheckNow"))
	{
		hRetRes = m_pSystem->FindAndResetDEStateByGUID(V_BSTR(&var));
		iRetValue = hRetRes;
	}
	else if (!wcscmp(MethodName, L"ResetDataCollectorStatistics"))
	{
		hRetRes = m_pSystem->FindAndResetDEStatisticsByGUID(V_BSTR(&var));
		iRetValue = hRetRes;
	}
	else if (!wcscmp(MethodName, L"CopyWithActions"))
	{
		hRetRes = m_pSystem->FindAndCopyWithActionsByGUID(V_BSTR(&var), &psa, &szOriginalParentGUID);
		if (hRetRes==S_OK)
		{
    		// This method returns values, and so create an instance of the
    		// output argument class.

			DWORD dwNameLen = MAX_COMPUTERNAME_LENGTH + 1;
			TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
			if (GetComputerName(szComputerName, &dwNameLen))
			{
				hRetRes = PutStrProperty(pOutParams, L"OriginalSystem", szComputerName);
			}
			else
			{
				hRetRes = PutStrProperty(pOutParams, L"OriginalSystem", L"LocalMachine");
			}

			if(FAILED(hRetRes))
			{
				goto error;
			}

			hRetRes = PutStrProperty(pOutParams, L"OriginalParentGUID", szOriginalParentGUID);
			if(FAILED(hRetRes))
			{
				goto error;
			}

			hRetRes = PutSAProperty(pOutParams, L"Instances", psa);
			if(FAILED(hRetRes))
			{
				goto error;
			}
			// Don't need to delete this below unless there was an error!
			// We do not free this if we sent it in a Put.
			// Because, we do a VariantClear(&v); inside of PutSAProperty.
			psa = NULL;

			iRetValue = 0;
		}
		else
		{
			iRetValue = hRetRes;
			MY_OUTPUT(L"failed to get instance!", 1);
		}
	}
	else if (!wcscmp(MethodName, L"PasteWithActions"))
	{
		hRetRes = pInParams->Get(L"Instances", 0L, &v, NULL, NULL);
		MY_ASSERT(hRetRes==S_OK); 
		
		if (hRetRes != S_OK)
		{
			goto error;
		}

		if (V_VT(&v)==VT_NULL)
		{
			iRetValue = 1;
		}
		else
		{
			MY_ASSERT(V_VT(&v)==(VT_UNKNOWN|VT_ARRAY));
			hRetRes = GetStrProperty(pInParams, L"OriginalSystem", &szOriginalSystem);
			MY_ASSERT(hRetRes==S_OK); 
			if (hRetRes != S_OK)
			{ 
				goto error;
			}

			hRetRes = GetStrProperty(pInParams, L"OriginalParentGUID", &szOriginalParentGUID);
			MY_ASSERT(hRetRes==S_OK); 
			if (hRetRes != S_OK)
			{
				goto error;
			}

			hRetRes = GetBoolProperty(pInParams, L"ForceReplace", &bForceReplace);
			MY_ASSERT(hRetRes==S_OK);
			if(FAILED(hRetRes))
			{
				goto error;
			}

			hRetRes = m_pSystem->FindAndPasteWithActionsByGUID(V_BSTR(&var), v.parray, szOriginalSystem, szOriginalParentGUID, bForceReplace);
			if(FAILED(hRetRes))
			{
				goto error;
			}

			iRetValue = hRetRes;

		}

		//
		// Send the output object back to the client via the sink. 
		
	}
	else if (!wcscmp(MethodName, L"Copy"))
	{
		hRetRes = m_pSystem->FindAndCopyByGUID(V_BSTR(&var), &psa, &szOriginalParentGUID);
		if (hRetRes==S_OK)
		{
    		// This method returns values, and so create an instance of the
    		// output argument class.

			DWORD dwNameLen = MAX_COMPUTERNAME_LENGTH + 1;
			TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
			if (GetComputerName(szComputerName, &dwNameLen))
			{
				hRetRes = PutStrProperty(pOutParams, L"OriginalSystem", szComputerName);
			}
			else
			{
				hRetRes = PutStrProperty(pOutParams, L"OriginalSystem", L"LocalMachine");
			}

			if(FAILED(hRetRes))
			{
				goto error;
			}

			hRetRes = PutStrProperty(pOutParams, L"OriginalParentGUID", szOriginalParentGUID);
			szOriginalParentGUID = NULL; // Don't need to delete this below, as we are pointing it to something
			if(FAILED(hRetRes))
			{
				goto error;
			}

			hRetRes = PutSAProperty(pOutParams, L"Instances", psa);
			if(FAILED(hRetRes))
			{
				goto error;
			}
			// Don't need to delete this below unless there was an error!
			// We do not free this if we sent it in a Put.
			// Because, we do a VariantClear(&v); inside of PutSAProperty.
			psa = NULL;
			iRetValue = 0;
		}
		else
		{
			iRetValue = hRetRes;
			szOriginalParentGUID = NULL; // Don't need to delete this below, as we are pointing it to something
			MY_OUTPUT(L"failed to get instance!", 1);
		}
	}
	else if (!wcscmp(MethodName, L"Paste"))
	{
		
		
		hRetRes = pInParams->Get(L"Instances", 0L, &v, NULL, NULL);
		MY_ASSERT(hRetRes==S_OK); 
		
		if (hRetRes != S_OK)
		{
			goto error;
		}

		if (V_VT(&v)==VT_NULL)
		{
			iRetValue = 1;
		}
		else
		{
			MY_ASSERT(V_VT(&v)==(VT_UNKNOWN|VT_ARRAY));
			hRetRes = GetStrProperty(pInParams, L"OriginalSystem", &szOriginalSystem);
			MY_ASSERT(hRetRes==S_OK); 
			if (hRetRes != S_OK)
			{ 
				goto error;
			}

			hRetRes = GetStrProperty(pInParams, L"OriginalParentGUID", &szOriginalParentGUID);
			MY_ASSERT(hRetRes==S_OK); 
			if (hRetRes != S_OK)
			{
				goto error;
			}

			hRetRes = GetBoolProperty(pInParams, L"ForceReplace", &bForceReplace);
			MY_ASSERT(hRetRes==S_OK);
			if(FAILED(hRetRes))
			{
				goto error;
			}

			hRetRes = m_pSystem->FindAndPasteByGUID(V_BSTR(&var), v.parray, szOriginalSystem, szOriginalParentGUID, bForceReplace);
			if(FAILED(hRetRes))
			{
				goto error;
			}

			iRetValue = hRetRes;

		}

		//
		// Send the output object back to the client via the sink. 
		
	}
	else if (!_wcsicmp(MethodName, L"Move"))
	{

#ifdef SAVE
		hRetRes = GetStrProperty(pInParams, L"TargetParentGUID", &szGUID);
		MY_ASSERT(hRetRes==S_OK); 
		if(FAILED(hRetRes))
		{
			goto error;
		}

		hRetRes = m_pSystem->Move(V_BSTR(&var), szGUID);
		iRetValue = hRetRes;
		if(FAILED(hRetRes))
		{
			goto error;
		}

	
#endif

		hRetRes = S_OK;
		iRetValue = hRetRes;
	}
	else if (!wcscmp(MethodName, L"DeleteConfigurationActionAssociation"))
	{
		hRetRes = GetStrProperty(pInParams, L"ActionGUID", &szGUID);
		MY_ASSERT(hRetRes==S_OK); 
		if(FAILED(hRetRes))
		{
			goto error;
		}

		hRetRes = m_pSystem->DeleteConfigActionAssoc(V_BSTR(&var), szGUID);
		iRetValue = hRetRes;
		if(FAILED(hRetRes))
		{
			goto error;
		}

	}
	else
	{
		hRetRes = WBEM_E_NOT_SUPPORTED;
		goto error;
	}

	}
	catch (...)
	{
		hRetRes = S_FALSE;
		iRetValue = S_FALSE;
		MY_ASSERT(FALSE);
	}

	//
	// Set the return value
	//
	VariantClear(&var);
	var.vt = VT_I4;
	var.lVal = iRetValue;
	hRetRes = pOutParams->Put(L"ReturnValue" , 0, &var, 0); 
	if(FAILED(hRetRes))
	{
		goto error;
	}

	// Send the output object back to the client via the sink.
	hRetRes = pResultSink->Indicate(1, &pOutParams);    
	if(FAILED(hRetRes))
	{
		goto error;
	}

error:
	// all done now, set the status
	if(SUCCEEDED(hRetRes))
	{
		pResultSink->SetStatus(0,WBEM_S_NO_ERROR,NULL,NULL);
	}
	else
	{
		MY_ASSERT(FALSE);
		pResultSink->SetStatus(0,hRetRes,NULL,NULL);
	}

	if (pClass)
		pClass->Release();
	if (pOutClass)
		pOutClass->Release();
	if (pOutParams)
		pOutParams->Release();
	if (szOriginalSystem)
		delete [] szOriginalSystem;
	if (szOriginalParentGUID)
		delete [] szOriginalParentGUID;
	if (psa)
	{
		MY_ASSERT(FALSE);
		SafeArrayDestroy(psa); 
	}
	if (szGUID)
		delete [] szGUID;

MY_OUTPUT(L"BLOCK - BLOCK CBaseMethodProvider::ExecMethodAsync g_hConfigLock BLOCK - RELEASE IT", 4);
	ReleaseMutex(g_hConfigLock);
MY_OUTPUT(L"BLOCK - BLOCK CBaseMethodProvider::ExecMethodAsync g_hConfigLock BLOCK - RELEASED", 4);
	return hRetRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\pmde.h ===
//***************************************************************************
//
//  PMDE.H
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: CPolledMethodDataCollector class to do WMI instance collection.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#if !defined( __PMDE_H )
#define __PMDE_H

#include "datacltr.h"

typedef struct _tag_PARStruct
{
	LPTSTR szName;		// Name of Parameter
	long lType;			// The value type
	LPTSTR szValue;		// The actual value
} PARSTRUCT, *PPARSTRUCT;
typedef std::vector<PARSTRUCT, std::allocator<PARSTRUCT> > PARLIST;


class CPolledMethodDataCollector : public CDataCollector
{
public:
	CPolledMethodDataCollector();
	virtual ~CPolledMethodDataCollector();


	LPTSTR m_szObjectPath;
	LPTSTR m_szMethodName;
	PARLIST m_parameterList;

	HRESULT LoadInstanceFromMOF(IWbemClassObject* pObj, CDataGroup *pParentDG, LPTSTR pszParentGUID, BOOL bModifyPass=FALSE);

private:
	BOOL CollectInstance(void);
	BOOL CollectInstanceSemiSync(void);
	BOOL CleanupSemiSync(void);
	BOOL EnumDone(void);
};
#endif  // __PMDE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by trustmon.rc
//
#define IDS_PROJNAME                    100
#define IDS_HEALTHMONPRV_DESC               101
//#define IDR_TrustPrv                    102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\pmde.cpp ===
//***************************************************************************
//
//  PMDE.CPP
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: CPolledMethodDataCollector class to do WMI instance collection.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "pmde.h"


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPolledMethodDataCollector::CPolledMethodDataCollector()
{
	MY_OUTPUT(L"ENTER ***** CPolledMethodDataCollector...", 4);

	//
	// XXX
	//
#ifdef SAVE
	m_pHMEventSink = NULL;
#endif
	m_szObjectPath = NULL;
	m_szMethodName = NULL;
	m_deType = HM_PMDE;
	m_lNumInstancesCollected = 0;
	m_pCallResult = NULL;

	MY_OUTPUT(L"EXIT ***** CPolledMethodDataCollector...", 4);
}

CPolledMethodDataCollector::~CPolledMethodDataCollector()
{
	int iSize;
	int i;
	PARSTRUCT *pparameter;

	MY_OUTPUT(L"ENTER ***** ~CPolledMethodDataCollector...", 4);

	if (m_szObjectPath)
		delete [] m_szObjectPath;
	if (m_szMethodName)
		delete [] m_szMethodName;

	iSize = m_parameterList.size();
	for (i=0; i<iSize ;i++)
	{
		MY_ASSERT(i<m_parameterList.size());
		pparameter = &m_parameterList[i];
		if (pparameter->szName)
		{
			delete [] pparameter->szName;
		}

		if (pparameter->szValue)
		{
			delete [] pparameter->szValue;
		}
	}

	EnumDone();

	MY_OUTPUT(L"EXIT ***** ~CPolledMethodDataCollector...", 4);
}

//
// Load a single DataCollector, and everything under it.
//
HRESULT CPolledMethodDataCollector::LoadInstanceFromMOF(IWbemClassObject* pObj, CDataGroup *pParentDG, LPTSTR pszParentObjPath, BOOL bModifyPass/*FALSE*/)
{
	BOOL bRetValue = TRUE;
	VARIANT v;
	VARIANT vValue;
	IUnknown* vUnknown;
	IWbemClassObject* pCO;
	long iLBound, iUBound;
	long lType;
	PARSTRUCT par;
	int iSize;
	long i;
	PARSTRUCT *pparameter;
	HRESULT hRetRes = S_OK;
	VariantInit(&v);
	VariantInit(&vValue);
	CThreshold* pThreshold;

	MY_OUTPUT(L"ENTER ***** CPolledMethodDataCollector::LoadInstanceFromMOF...", 4);
	iSize = m_thresholdList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		if (pThreshold->m_bValidLoad == FALSE)
			return WBEM_E_INVALID_OBJECT;
	}

	if (m_szObjectPath)
	{
		delete [] m_szObjectPath;
		m_szObjectPath = NULL;
	}
	if (m_szMethodName)
	{
		delete [] m_szMethodName;
		m_szMethodName = NULL;
	}
	m_lNumInstancesCollected = 0;

	iSize = m_parameterList.size();
	for (i=0; i<iSize ;i++)
	{
		MY_ASSERT(i<m_parameterList.size());
		pparameter = &m_parameterList[i];

		if (pparameter->szName)
		{
			delete [] pparameter->szName;
		}

		if (pparameter->szValue)
		{
			delete [] pparameter->szValue;
		}
	}
	m_parameterList.clear();

	//
	// Call the base class to load the common properties. Then do the specific ones.
	//
	hRetRes = CDataCollector::LoadInstanceFromMOF(pObj, pParentDG, pszParentObjPath, bModifyPass);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) return hRetRes;

	hRetRes = GetStrProperty(pObj, L"ObjectPath", &m_szObjectPath);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	hRetRes = GetStrProperty(pObj, L"MethodName", &m_szMethodName);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	//
	// Get the IN parameters from the Arguments property.
	//
	VariantInit(&v);
	if ((hRetRes = pObj->Get(L"Arguments", 0L, &v, NULL, NULL)) == S_OK) 
	{
		if (V_VT(&v)==VT_NULL)
		{
//			MY_ASSERT(FALSE);
		}
		else
		{
			MY_ASSERT(V_VT(&v)==(VT_UNKNOWN|VT_ARRAY));
                
			SafeArrayGetLBound(v.parray, 1, &iLBound);
			SafeArrayGetUBound(v.parray, 1, &iUBound);
			if ((iUBound - iLBound + 1) == 0)
			{
				MY_ASSERT(FALSE);
			}
			else
			{
				for (i = iLBound; i <= iUBound; i++)
				{
					par.szName = NULL;
					par.szValue = NULL;
					VariantInit(&vValue);
					vUnknown = NULL;
					hRetRes = SafeArrayGetElement(v.parray, &i, &vUnknown);
					MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
					pCO = (IWbemClassObject *)vUnknown;

					hRetRes = GetStrProperty(pCO, L"Name", &par.szName);
					MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

					hRetRes = GetUint32Property(pCO, L"Type", &lType);
					MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
					par.lType = lType;

					hRetRes = GetStrProperty(pCO, L"Value", &par.szValue);
					MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

					m_parameterList.push_back(par);

					VariantClear(&vValue);

					vUnknown->Release();
				}
			}
		}
	}
	else
	{
		MY_HRESASSERT(hRetRes);
		return hRetRes;
	}
	VariantClear(&v);

	MY_OUTPUT(L"EXIT ***** CPolledMethodDataCollector::LoadInstanceFromMOF...", 4);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	VariantClear(&v);
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	if (m_szObjectPath)
	{
		delete [] m_szObjectPath;
		m_szObjectPath = NULL;
	}
	if (m_szMethodName)
	{
		delete [] m_szMethodName;
		m_szMethodName = NULL;
	}

	iSize = m_parameterList.size();
	for (i=0; i<iSize ;i++)
	{
		MY_ASSERT(i<m_parameterList.size());
		pparameter = &m_parameterList[i];
		if (pparameter->szName)
		{
			delete [] pparameter->szName;
		}

		if (pparameter->szValue)
		{
			delete [] pparameter->szValue;
		}
	}
	return hRetRes;
}

BOOL CPolledMethodDataCollector::CollectInstance(void)
{
	BOOL bRetValue = TRUE;
	int iSize;
	int i;
	PARSTRUCT *pparameter;
	HRESULT hRetRes = S_OK;
	VARIANT var; 
	SAFEARRAY* psa = NULL;
	IWbemClassObject *pObj = NULL;
    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutInst = NULL;
    IWbemClassObject *pInClass = NULL;
    IWbemClassObject *pInInst = NULL;
    BSTR ClassPath = NULL;
    BSTR MethodName = NULL;
	INSTSTRUCT inst;
	VariantInit(&var);

	MY_OUTPUT(L"ENTER ***** CPolledMethodDataCollector::CollectInstance...", 1);

	m_lNumInstancesCollected = 0;

	if (m_pIWbemServices == NULL)
	{
		m_ulErrorCode = HMRES_BADWMI;
		GetLatestAgentError(HMRES_BADWMI, m_szErrorDescription);
		StoreStandardProperties();
		return FALSE;
	}

	//
	// We get an instance at a time, so we can set all to not needed first,
	// then go through them, do StoreValues... and delete what is not needed.
	//

	//
	// Mark each instance, so we can tell if we still need them.
	//
#ifdef SAVE
	iSize = m_pnList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_pnList.size());
		ppn = &m_pnList[i];
		jSize = ppn->instList.size();
		for (j = 0; j < jSize ; j++)
		{
			MY_ASSERT(j<ppn->instList.size());
			pinst = &ppn->instList[j];
			pinst->bNeeded = FALSE;
		}
	}
#endif


    ClassPath = SysAllocString(m_szObjectPath);
	MY_ASSERT(ClassPath); if (!ClassPath) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
    MethodName = SysAllocString(m_szMethodName);
	MY_ASSERT(MethodName); if (!MethodName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

    hRetRes = m_pIWbemServices->GetObject(ClassPath, 0, NULL, &pClass, NULL);
	if (FAILED(hRetRes) || pClass == NULL)
	{
		m_lCurrState = HM_WARNING;
	}
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK || pClass == NULL) goto error;

    // Get the input-argument class object and create an instance.
    hRetRes = pClass->GetMethod(MethodName, 0, &pInClass, NULL); 
	if (FAILED(hRetRes) || pClass == NULL)
	{
		m_lCurrState = HM_WARNING;
	}
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK || pInClass == NULL) goto error;

    hRetRes = pInClass->SpawnInstance(0, &pInInst);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	//
	// Set the IN parameters - they are actually properties on the instance we pass in.
	// We will do error checking to make sure that there is one by that name, by seeing
	// if the Put fails.
	//
	iSize = m_parameterList.size();
	for (i=0; i<iSize ;i++)
	{
		MY_ASSERT(i<m_parameterList.size());
		pparameter = &m_parameterList[i];
		VariantInit(&var);

		if (pparameter->lType == CIM_SINT8 ||
			pparameter->lType == CIM_SINT16 ||
			pparameter->lType == CIM_CHAR16)
		{
			V_VT(&var) = VT_I2;
			V_I2(&var) = _wtol(pparameter->szValue);
		}
		else if (pparameter->lType == CIM_SINT32 ||
			pparameter->lType == CIM_UINT16 ||
			pparameter->lType == CIM_UINT32)
		{
			V_VT(&var) = VT_I4;
			V_I4(&var) = _wtol(pparameter->szValue);
		}
		else if (pparameter->lType == CIM_REAL32)
		{
			V_VT(&var) = VT_R4;
			V_R4(&var) = wcstod(pparameter->szValue, NULL);
		}
		else if (pparameter->lType == CIM_BOOLEAN)
		{
			V_VT(&var) = VT_BOOL;
			V_BOOL(&var) = (BOOL) _wtol(pparameter->szValue);
		}
		else if (pparameter->lType == CIM_SINT64 ||
			pparameter->lType == CIM_UINT64 ||
//XXX				pparameter->lType == CIM_REF ||
			pparameter->lType == CIM_STRING ||
			pparameter->lType == CIM_DATETIME)
		{
			V_VT(&var) = VT_BSTR;
			V_BSTR(&var) = SysAllocString(pparameter->szValue);
		}
		else if (pparameter->lType == CIM_REAL64)
		{
			V_VT(&var) = VT_R8;
			V_R8(&var) = wcstod(pparameter->szValue, NULL);
		}
		else if (pparameter->lType == CIM_UINT8)
		{
			V_VT(&var) = VT_UI1;
			V_UI1(&var) = (unsigned char) _wtoi(pparameter->szValue);
		}
		else
		{
			MY_ASSERT(FALSE);
		}

    	hRetRes = pInInst->Put(pparameter->szName, 0, &var, 0);
		MY_HRESASSERT(hRetRes);
    	VariantClear(&var);
		if (psa != NULL)
		{
			SafeArrayDestroy(psa);
			psa = NULL;
		}
	}

	//
    // Call the method.
	//
    hRetRes = m_pIWbemServices->ExecMethod(ClassPath, MethodName, WBEM_FLAG_RETURN_IMMEDIATELY, m_pContext, pInInst, &pOutInst, &m_pCallResult);
	if (hRetRes != S_OK)
	{
		MY_HRESASSERT(hRetRes);
		MY_OUTPUT2(L"PMDE - ExecMethod Error: 0x%08x",hRetRes,4);
		MY_OUTPUT2(L"m_szGUID was=%s",m_szGUID,4);
		m_ulErrorCode = hRetRes;
		GetLatestWMIError(HMRES_OBJECTNOTFOUND, hRetRes, m_szErrorDescription);
		StoreStandardProperties();
		bRetValue = FALSE;
	}
	else
	{
		m_bKeepCollectingSemiSync = TRUE;
		bRetValue = CollectInstanceSemiSync();
	}

	//
    // Free up resources.
	//
    SysFreeString(ClassPath);
    ClassPath = NULL;
    SysFreeString(MethodName);
    MethodName = NULL;
    pClass->Release();
    pClass = NULL;
    pInInst->Release();
    pInInst = NULL;
    pInClass->Release();
    pInClass = NULL;

	MY_OUTPUT(L"EXIT ***** CPolledMethodDataCollector::CollectInstance...", 1);
	return bRetValue;

error:
	MY_ASSERT(FALSE);
	if (ClassPath)
    	SysFreeString(ClassPath);
   	if (MethodName)
    	SysFreeString(MethodName);
    if (pClass)
		pClass->Release();
    if (pInInst)
		pInInst->Release();
    if (pInClass)
		pInClass->Release();
	if (psa != NULL)
		SafeArrayDestroy(psa);
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

BOOL CPolledMethodDataCollector::CollectInstanceSemiSync(void)
{
	HRESULT hRetRes = S_OK;
	IWbemClassObject *pObj = NULL;
	PNSTRUCT *ppn;
	INSTSTRUCT inst;
	CThreshold *pThreshold;
	long lStatus;
	ULONG uReturned = 0;
	int i, iSize;
	InstIDSTRUCT InstID;

	MY_OUTPUT(L"ENTER ***** CPolledMethodDataCollector::CollectInstanceSemiSync...", 1);

	MY_ASSERT(m_pCallResult);
	lStatus = 0;
	//
	// Keep trying until we get WBEM_S_NO_ERROR. Then we know the GetObject call has completed.
	// hRes will contain the result of the origional GetObject call if needed.
	//
	hRetRes = m_pCallResult->GetCallStatus(0, &lStatus);
	if (hRetRes == WBEM_S_TIMEDOUT)
	{
		return FALSE;
	}
	else if (hRetRes == WBEM_S_NO_ERROR)
	{
		// Means that we have an instance
	}
	else
	{
		MY_HRESASSERT(hRetRes);
		MY_OUTPUT2(L"PMDE - GetCallStatus Error: 0x%08x",hRetRes,4);
		MY_OUTPUT2(L"m_szGUID was=%s",m_szGUID,4);
		MY_OUTPUT2(L"ClassPath was=%s",m_szObjectPath,4);
		MY_OUTPUT2(L"MethodName was=%s",m_szMethodName,4);
		m_ulErrorCode = 0;
		EnumDone();
		return FALSE;
	}

	//
	// This may mean that the call completed, and the object was not found (e.g. bad path).
	//
	if (lStatus != 0)
	{
		m_lCurrState = HM_WARNING;
		m_ulErrorCode = 0;
		EnumDone();
		return FALSE;
	}

	//
	// Get the Object finaly.
	//
	hRetRes = m_pCallResult->GetResultObject(0, &pObj);
	if (pObj == NULL)
	{
		//
		// NULL in this case can actually happen. An example is where the
		// threshold is to see if the SQL Server service is running. If it
		// is not even on the machine, then we would get an error looking
		// for its instance.
		//
		m_lCurrState = HM_WARNING;
		EnumDone();
	}
	else
	{
		EnumDone();

		//
		// Figure out the key property name to identify instances with.
		//
		iSize = m_instIDList.size();
		if (iSize == 0)
		{
			// There is no key property returned!!!
			InstID.szInstanceIDPropertyName = new TCHAR[7];
			MY_ASSERT(InstID.szInstanceIDPropertyName); if (!InstID.szInstanceIDPropertyName) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			wcscpy(InstID.szInstanceIDPropertyName , L"Method");
			m_instIDList.push_back(InstID);
			// Add an instance to each property name
			iSize = m_pnList.size();
			for (i=0; i < iSize ; i++)
 			{
				MY_ASSERT(i<m_pnList.size());
				ppn = &m_pnList[i];
				inst.szInstanceID = new TCHAR[2];
				MY_ASSERT(inst.szInstanceID); if (!inst.szInstanceID) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				wcscpy(inst.szInstanceID, L"");
				inst.szCurrValue = NULL;
				ResetInst(&inst, ppn->type);
				inst.bNull = FALSE;
				inst.bNeeded = TRUE;
				ppn->instList.push_back(inst);
 			}
			//Also add instance for all thresholds under this DataCollector
			iSize = m_thresholdList.size();
			for (i=0; i < iSize ; i++)
			{
				MY_ASSERT(i<m_thresholdList.size());
				pThreshold = m_thresholdList[i];
				hRetRes = pThreshold->AddInstance(L"");
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			}
		}
		MY_ASSERT(m_instIDList.size());

		//
		// Check the list of actual instances that the Data Collector is collecting.
		// We keep around the latest one(s) for the DataCollector.
		//
		CheckActualInstanceExistance(pObj, L"");

		m_lNumInstancesCollected = 1;
		StoreValues(pObj, L"");
		pObj->Release();
		pObj = NULL;

		//
		// Means that we are done.
		// Won't ever get here the first time
		// Add in a fake instance for the number of instances returned.
		//
		m_lCurrState = HM_GOOD;
		m_ulErrorCode = 0;
		StoreStandardProperties();
	}

	MY_OUTPUT(L"EXIT ***** CPolledMethodDataCollector::CollectInstanceSemiSync...", 1);
	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (pObj)
		pObj->Release();
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return FALSE;
}

BOOL CPolledMethodDataCollector::CleanupSemiSync(void)
{
	if (m_pCallResult)
	{
		m_pCallResult->Release();
		m_pCallResult = NULL;
	}

	m_bKeepCollectingSemiSync = FALSE;
	m_lCollectionTimeOutCount = 0;

	return TRUE;
}

BOOL CPolledMethodDataCollector::EnumDone(void)
{
	CleanupSemiSync();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\pqde.h ===
//***************************************************************************
//
//  PQDE.H
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: CPolledQueryDataCollector class to do WMI instance collection.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#if !defined( __PQDE_H )
#define __PQDE_H

#include "datacltr.h"

class CPolledQueryDataCollector : public CDataCollector
{
public:
	CPolledQueryDataCollector();
	virtual ~CPolledQueryDataCollector();


	LPTSTR m_szQuery;
	IEnumWbemClassObject *m_pEnumObjs;

	HRESULT LoadInstanceFromMOF(IWbemClassObject* pObj, CDataGroup *pParentDG, LPTSTR pszParentGUID, BOOL bModifyPass=FALSE);

private:
	BOOL CollectInstance(void);
	BOOL CollectInstanceSemiSync(void);
	BOOL ProcessObjects(ULONG uReturned, IWbemClassObject **apObj);
	BOOL CleanupSemiSync(void);
	BOOL EnumDone(void);
};
#endif  // __PQDE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\pgde.h ===
//***************************************************************************
//
//  PGDE.H
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: CPolledGetObjectDataCollector class to do WMI instance collection.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#if !defined( __PGDE_H )
#define __PGDE_H

#include "datacltr.h"

class CPolledGetObjectDataCollector : public CDataCollector
{
public:
	CPolledGetObjectDataCollector();
	virtual ~CPolledGetObjectDataCollector();


	LPTSTR m_szObjectPath;

//XXX	IWbemRefresher* m_pRefresher;
//XXX	IWbemConfigureRefresher* m_pConfigureRefresher;
//XXX	IWbemHiPerfEnum* m_pEnum;
//XXX	IWbemObjectAccess* m_pObjAccess;
	IUnknown* m_pRefresher;
	IUnknown* m_pConfigureRefresher;
	IUnknown* m_pEnum;
	IUnknown* m_pObjAccess;
	BOOL m_bMultiInstance;
	IEnumWbemClassObject *m_pEnumObjs;

	HRESULT LoadInstanceFromMOF(IWbemClassObject* pObj, CDataGroup *pParentDG, LPTSTR pszParentGUID, BOOL bModifyPass=FALSE);

private:
	BOOL CollectInstance(void);
	BOOL CollectInstanceSemiSync(void);
	BOOL ProcessObjects(ULONG uReturned, IWbemClassObject **apObj);
	BOOL CleanupSemiSync(void);
	BOOL EnumDone(void);
};
#endif  // __PGDE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\pqde.cpp ===
//***************************************************************************
//
//  PQDE.CPP
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: CPolledQueryDataCollector class to do WMI instance collection.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "pqde.h"
#include "system.h"
extern CSystem* g_pSystem;


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPolledQueryDataCollector::CPolledQueryDataCollector()
{
	MY_OUTPUT(L"ENTER ***** CPolledQueryDataCollector...", 4);

	m_szQuery = NULL;
	m_deType = HM_PQDE;
	m_pEnumObjs = NULL;

	MY_OUTPUT(L"EXIT ***** CPolledQueryDataCollector...", 4);
}

CPolledQueryDataCollector::~CPolledQueryDataCollector()
{
	MY_OUTPUT(L"ENTER ***** ~CPolledQueryDataCollector...", 4);

	if (m_szQuery)
		delete [] m_szQuery;

	EnumDone();

	MY_OUTPUT(L"EXIT ***** ~CPolledQueryDataCollector...", 4);
}

//
// Load a single DataCollector, and everything under it.
//
HRESULT CPolledQueryDataCollector::LoadInstanceFromMOF(IWbemClassObject* pObj, CDataGroup *pParentDG, LPTSTR pszParentObjPath, BOOL bModifyPass/*FALSE*/)
{
	HRESULT hRetRes = S_OK;
	int i, iSize;
	CThreshold* pThreshold;

	MY_OUTPUT(L"ENTER ***** CPolledQueryDataCollector::LoadInstanceFromMOF...", 4);
	iSize = m_thresholdList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		if (pThreshold->m_bValidLoad == FALSE)
			return WBEM_E_INVALID_OBJECT;
//			return S_OK;
	}

	if (m_szQuery)
	{
		delete [] m_szQuery;
		m_szQuery = NULL;
	}
	m_lNumInstancesCollected = 0;

	//
	// Call the base class to load the common properties. Then do the specific ones.
	//
	hRetRes = CDataCollector::LoadInstanceFromMOF(pObj, pParentDG, pszParentObjPath, bModifyPass);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) return hRetRes;

	// Get the GUID property
	hRetRes = GetStrProperty(pObj, L"Query", &m_szQuery);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	MY_OUTPUT(L"EXIT ***** CPolledQueryDataCollector::LoadInstanceFromMOF...", 4);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	m_bValidLoad = FALSE;
	Cleanup(FALSE);
	return hRetRes;
}

BOOL CPolledQueryDataCollector::CollectInstance(void)
{
    HRESULT hRes;
	BSTR Language;
	BSTR Query;
	IWbemClassObject *pObj = NULL;
	BOOL bRetValue = TRUE;
	SAFEARRAY *psaNames = NULL;
	BSTR PropName = NULL;
	int i, j, iSize, jSize;
	PNSTRUCT *ppn;
	INSTSTRUCT *pinst;
	INSTSTRUCT inst;
	CThreshold *pThreshold;
	IRSSTRUCT *pirs;
	ACTUALINSTSTRUCT *pActualInst;

	MY_OUTPUT(L"ENTER ***** CPolledQueryDataCollector::CollectInstance...", 1);

	m_lNumInstancesCollected = 0;
	if (m_pIWbemServices == NULL)
	{
		m_ulErrorCode = HMRES_BADWMI;
		GetLatestAgentError(HMRES_BADWMI, m_szErrorDescription);
		StoreStandardProperties();
		return FALSE;
	}

	//
	// We get an instance at a time, so we can set all to not needed first,
	// then go through them, do StoreValues... and delete what is not needed.
	//

	//
	// Mark each instance, so we can tell if we still need them.
	//
	iSize = m_pnList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_pnList.size());
		ppn = &m_pnList[i];
		jSize = ppn->instList.size();
		for (j = 0; j < jSize ; j++)
		{
			MY_ASSERT(j<ppn->instList.size());
			pinst = &ppn->instList[j];
			pinst->bNeeded = FALSE;
		}
	}

	// Also for all thresholds under this DataCollector
	iSize = m_thresholdList.size();
	for (i = 0; i < iSize; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		jSize = pThreshold->m_irsList.size();
		for (j = 0; j < jSize; j++)
		{
			MY_ASSERT(j<pThreshold->m_irsList.size());
			pirs = &pThreshold->m_irsList[j];
			pirs->bNeeded = FALSE;
		}
	}

	iSize = m_actualInstList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_actualInstList.size());
		pActualInst = &m_actualInstList[i];
		pActualInst->bNeeded = FALSE;
	}

	//
	// Submit the query, then get all the instances
	//
	Language = SysAllocString(L"WQL");
	Query = SysAllocString(m_szQuery);

	// Issue query
	m_pEnumObjs = NULL;
	hRes = m_pIWbemServices->ExecQuery(Language, Query, WBEM_FLAG_FORWARD_ONLY|WBEM_FLAG_RETURN_IMMEDIATELY, m_pContext, &m_pEnumObjs);

	SysFreeString(Query);
	SysFreeString(Language);

	if (hRes != S_OK)
	{
		m_ulErrorCode = hRes;
		GetLatestWMIError(HMRES_OBJECTNOTFOUND, hRes, m_szErrorDescription);
		StoreStandardProperties();
		bRetValue = FALSE;
		MY_HRESASSERT(hRes);
		MY_OUTPUT2(L"PQDC Unexpected Error: 0x%08x\n",hRes,4);
		MY_OUTPUT2(L"m_szGUID was=%s",m_szGUID,4);
		MY_OUTPUT2(L"m_szQuery was=%s",m_szQuery,4);
	}
	else
	{
		m_bKeepCollectingSemiSync = TRUE;
		bRetValue = CollectInstanceSemiSync();
	}

	MY_OUTPUT(L"EXIT ***** CPolledQueryDataCollector::CollectInstance...", 1);
	return bRetValue;
}

BOOL CPolledQueryDataCollector::CollectInstanceSemiSync(void)
{
	HRESULT hRes;
	IWbemClassObject *apObj[10];
	INSTSTRUCT inst;
	SAFEARRAY *psaNames = NULL;
	BSTR PropName = NULL;
	ULONG uReturned = 0;

	MY_OUTPUT(L"ENTER ***** CPolledQueryDataCollector::CollectInstanceSemiSync...", 1);

	MY_ASSERT(m_pEnumObjs);
	// We never want to block here, so we set it for zero second timeout,
	// and have it return immediatly what it has available.
	// Get up to 10 instances at a time.
	hRes = m_pEnumObjs->Next(0, 10, apObj, &uReturned);

	if (hRes == WBEM_S_TIMEDOUT)
	{
		// Get what is there
		if (!ProcessObjects(uReturned, apObj))
		{
			EnumDone();
			return FALSE;
		}
		return FALSE;
	}
	else if (hRes == WBEM_S_FALSE)
	{
		//
		// Means that we are done. The number returned was less than asked for.
		// But we still process what we did recieve to finish it off.
		// Add in a fake instance for the number of instances returned.
		//
		if (!ProcessObjects(uReturned, apObj))
		{
			EnumDone();
			return FALSE;
		}
		else
		{
			// NOTE: No instances returned is not an error!!!
			m_ulErrorCode = 0;
			StoreStandardProperties();
			EnumDone();
//XXXWhy was this here???				m_lCurrState = HM_GOOD;
			return TRUE;
		}
	}
	else if (hRes == WBEM_S_NO_ERROR)
	{
		// Means that we have an instance, The number returned was what was requested
	}
	else
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT2(L"PQDC Unexpected Error Next: 0x%08x\n",hRes,4);
		MY_OUTPUT2(L"m_szGUID was=%s",m_szGUID,4);
		m_ulErrorCode = hRes;
		GetLatestWMIError(HMRES_ENUMFAIL, hRes, m_szErrorDescription);
		StoreStandardProperties();
		EnumDone();
		return FALSE;
	}

	if (apObj[0] == NULL)
	{
		//
		// NULL in this case can actually happen. An example is where the
		// threshold is to see if the SQL Server service is running. If it
		// is not even on the machine, then we would get an error looking
		// for its instance.
		//
		m_ulErrorCode = hRes;
		GetLatestWMIError(HMRES_OBJECTNOTFOUND, hRes, m_szErrorDescription);
		StoreStandardProperties();
		EnumDone();
	}
	else
	{
		MY_ASSERT(uReturned>=1);
		if (!ProcessObjects(uReturned, apObj))
		{
			EnumDone();
			return FALSE;
		}
	}

	MY_OUTPUT(L"EXIT ***** CPolledQueryDataCollector::CollectInstanceSemiSync...", 1);
	return FALSE;
}

BOOL CPolledQueryDataCollector::ProcessObjects(ULONG uReturned, IWbemClassObject **apObj)
{
	HRESULT hRes;
	LPTSTR pszID;
	ULONG n;
	BOOL bRetValue = TRUE;

	for (n = 0; n < uReturned; n++)
	{
		if (g_pSystem->m_lNumInstancesAccepted <m_lNumInstancesCollected)
		{
			m_ulErrorCode = HMRES_TOOMANYINSTS;
			GetLatestAgentError(HMRES_TOOMANYINSTS, m_szErrorDescription);
			StoreStandardProperties();
			bRetValue = FALSE;
			break;
		}
		//
		// Figure out the key property name to identify instances with.
		//
		hRes = GetInstanceID(apObj[n], &pszID);
		if (hRes != S_OK)
		{
			m_ulErrorCode = hRes;
			GetLatestWMIError(HMRES_OBJECTNOTFOUND, hRes, m_szErrorDescription);
			StoreStandardProperties();
			bRetValue = FALSE;
			break;
		}

		//
		// Mark instances need to keep around, and add new ones
		//
		hRes = CheckInstanceExistance(apObj[n], pszID);
		if (hRes != S_OK)
		{
			delete [] pszID;
			m_ulErrorCode = hRes;
			GetLatestWMIError(HMRES_OBJECTNOTFOUND, hRes, m_szErrorDescription);
			StoreStandardProperties();
			bRetValue = FALSE;
			break;
		}

		//
		// Now store each property that we need to for this instance
		//
		m_lNumInstancesCollected++;
		StoreValues(apObj[n], pszID);

		delete [] pszID;
	}

	for (n = 0; n < uReturned; n++)
	{
		apObj[n]->Release();
		apObj[n] = NULL;
	}
	return bRetValue;
}

BOOL CPolledQueryDataCollector::EnumDone(void)
{
	IRSSTRUCT *pirs;
	IWbemClassObject *pObj = NULL;
	BOOL bRetValue = TRUE;
	PNSTRUCT *ppn;
	INSTSTRUCT inst;
	INSTSTRUCT *pinst;
	int i, j, iSize, jSize;
	CThreshold *pThreshold;
	SAFEARRAY *psaNames = NULL;
	BSTR PropName = NULL;
	INSTLIST::iterator iaPINST;
	IRSLIST::iterator iaPIRS;
	ACTUALINSTLIST::iterator iaPAI;
	ACTUALINSTSTRUCT *pActualInst;

	CleanupSemiSync();

//XXXAdd similar code to get rid of what is not needed in the m_instList
//XXXOnce again take common code and place it in the base class!VVVVVVVVVVVVVVVVVVVVVVVVv
	//
	// Now loop through and get rid of instances that are no longer around
	//
	iSize = m_pnList.size();
	for (i = 0; i < iSize; i++)
	{
		MY_ASSERT(i<m_pnList.size());
		ppn = &m_pnList[i];
		iaPINST = ppn->instList.begin();
		jSize = ppn->instList.size();
		for (j = 0; j < jSize && iaPINST ; j++)
		{
			pinst = iaPINST;
			if (pinst->bNeeded == FALSE)
			{
				if (pinst->szInstanceID)
					delete [] pinst->szInstanceID;
				if (pinst->szCurrValue)
					delete [] pinst->szCurrValue;
				pinst->szCurrValue = NULL;
				iaPINST = ppn->instList.erase(iaPINST);
			}
			else
			{
				iaPINST++;
			}
		}
	}

	// Also for all thresholds under this DataCollector
	iSize = m_thresholdList.size();
	for (i = 0; i < iSize; i++)
	{
		MY_ASSERT(i<m_thresholdList.size());
		pThreshold = m_thresholdList[i];
		iaPIRS = pThreshold->m_irsList.begin();
		jSize = pThreshold->m_irsList.size();
		for (j = 0; j < jSize && iaPIRS ; j++)
		{
			pirs = iaPIRS;
			if (pirs->bNeeded == FALSE)
			{
				if (pirs->szInstanceID)
					delete [] pirs->szInstanceID;
				iaPIRS = pThreshold->m_irsList.erase(iaPIRS);
			}
			else
			{
				iaPIRS++;
			}
		}
	}

	iaPAI = m_actualInstList.begin();
	jSize = m_actualInstList.size();
	for (j = 0; j < jSize && iaPAI; j++)
	{
		pActualInst = iaPAI;
		if (pActualInst->bNeeded == FALSE)
		{
			if (pActualInst->szInstanceID)
			{
				delete [] pActualInst->szInstanceID;
			}
			if (pActualInst->pInst)
			{
				pActualInst->pInst->Release();
				pActualInst->pInst = NULL;
			}
			iaPAI = m_actualInstList.erase(iaPAI);
		}
		else
		{
			iaPAI++;
		}
	}
//XXXOnce again take common code and place it in the base class!^^^^^^^^^^^^^^^^^^^^^^^^^

	return TRUE;
}

BOOL CPolledQueryDataCollector::CleanupSemiSync(void)
{
	if (m_pEnumObjs)
	{
		m_pEnumObjs->Release(); 
		m_pEnumObjs = NULL;
	}

	m_bKeepCollectingSemiSync = FALSE;
	m_lCollectionTimeOutCount = 0;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\provider.cpp ===
//***************************************************************************
//
//  PROVIDER.CPP
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: Event consumer provider class implementation
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "stdafx.h"
#include "Provider.h"
#include "Consumer.h"
#include <objbase.h>

CProvider::CProvider()
{
	m_cRef = 0L;
}

CProvider::~CProvider()
{
}

STDMETHODIMP CProvider::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IWbemEventConsumerProvider)
	{
        *ppv=this;
	}

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvider::AddRef(void)
{
	return InterlockedIncrement((long*)&m_cRef);
}

STDMETHODIMP_(ULONG) CProvider::Release(void)
{
	LONG	lCount = InterlockedDecrement((long*)&m_cRef);
    if (lCount != 0L)
	{
        return lCount;
	}

    delete this;
    return 0L;
}

STDMETHODIMP CProvider::Initialize(LPWSTR wszUser, LONG lFlags,
								   LPWSTR wszNamespace, LPWSTR wszLocale,
								   IWbemServices __RPC_FAR *pNamespace,
								   IWbemContext __RPC_FAR *pCtx,
								   IWbemProviderInitSink __RPC_FAR *pInitSink)
{

	
    // Tell CIMOM that we are initialized
    pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
    return WBEM_S_NO_ERROR;
}

//-----------------------------------------------------------
STDMETHODIMP CProvider::FindConsumer(
						IWbemClassObject* pLogicalConsumer,
						IWbemUnboundObjectSink** ppConsumer)
{
	// Singleton Consumer.
	static CConsumer Consumer;
//	return Consumer.QueryInterface(IID_IWbemUnboundObjectSink, (void**)ppConsumer);

	Consumer.QueryInterface(IID_IWbemUnboundObjectSink, (void**)ppConsumer);

	// WMI says: It is much more scalable to support IWbemEventConsumerProvider
	// interface.  In fact, it's even more scalable (M3-only feature!) to return
	// S_FALSE from the call to FindConsumer --- in that case we will use NULL
	// for the logical consumer pointer in the IndicateToConsumer call.
	// By returning S_FALSE you are saying: "I have extracted all the information
	// I need from the logical consumer instance and don't care to see it again."
	// This way, we don't have to keep it in memory.
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\provider.h ===
//***************************************************************************
//
//  PROVIDER.H
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: Event consumer provider class definition
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#if !defined( __PROVIDER_H )
#define __PROVIDER_H

#include <wbemcli.h>
#include <wbemprov.h>

class CProvider : public IWbemEventConsumerProvider
{
public:
	CProvider();
	~CProvider();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	STDMETHOD(Initialize)( 
			LPWSTR pszUser,
			LONG lFlags,
			LPWSTR pszNamespace,
			LPWSTR pszLocale,
			IWbemServices __RPC_FAR *pNamespace,
			IWbemContext __RPC_FAR *pCtx,
			IWbemProviderInitSink __RPC_FAR *pInitSink);

    STDMETHOD(FindConsumer)(
			IWbemClassObject* pLogicalConsumer,
			IWbemUnboundObjectSink** ppConsumer);

private:

	DWORD m_cRef;
};
#endif  // __PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	hmagent.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__19DA87E5_CA95_11D2_8F26_006097919914__INCLUDED_)
#define AFX_STDAFX_H__19DA87E5_CA95_11D2_8F26_006097919914__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__19DA87E5_CA95_11D2_8F26_006097919914__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\stringmap.h ===
///////////////////////////////////////////////////////
//	StringMap.H 
//
//	STL - based template which throws COM-compatible exceptions
//	for making maps
/////////////////////////////////////////////////////////

#pragma once
#pragma warning (disable: 4786)	// exceeds 255 chars in browser info
#include <comdef.h>
#include <string>
#include <map>

using namespace std;

class throwing_allocator : public allocator<wchar_t>
{
public:
	// overloading the allocation routines to throw
	// exceptions rather than fail silently
	pointer allocate(size_type _N, const void *)
		{
		pointer p = (_Allocate((difference_type)_N, (pointer)0)); 
			if (p == NULL)
				_com_raise_error (E_OUTOFMEMORY);
			return p;
		}
	char _FARQ *_Charalloc(size_type _N)
		{
		char _FARQ * p = _Allocate((difference_type)_N, (char _FARQ *)0); 
			if (p == NULL)
				_com_raise_error (E_OUTOFMEMORY);
			return p;
		}
};
typedef basic_string<wchar_t, char_traits<wchar_t>,
	throwing_allocator > throwing_wstring;

class StringToStringMap
{
	typedef std::map<throwing_wstring, throwing_wstring> throwing_map;
	throwing_map m_map;
public:
	HRESULT Add(LPCWSTR Key, LPCWSTR Value)
	{
		try
		{
			m_map[Key] = Value;
//			throwing_map::iterator p = m_map.find(Key);
//			ASSERT (m_map.find(Key) != m_map.end());
//			_bstr_t b = (*p).second.c_str();
//			TRACE ("%s -> %s\n", (LPCTSTR) _bstr_t(Key), (LPCTSTR) b);

		}
		catch (_com_error e)
		{
			return e.Error(); // out of memory
		}
		return S_OK;
	}
	throwing_map::size_type GetSize()
	{
		return m_map.size();
	}
	HRESULT Find(LPCWSTR Key, _bstr_t& Value, bool &bFound)
	{
		try
		{
			throwing_map::iterator p = m_map.find(Key);
			if (p == m_map.end())
			{
				bFound = false;
				return S_FALSE; 
			}
			else
			{
				Value = (*p).second.c_str();
				bFound = true;
			}
		}
		catch (_com_error e)
		{
			return e.Error(); // out of memory
		}
		return S_OK;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\safearray.h ===
////////////////////////////////////////////////
//	SAFEARRAY.H - SafeArray wrappers and other COM helpers
////////////////////////////////////////////////
#pragma once
#include <comdef.h>
#pragma warning (disable: 4786)	// exceeds 255 chars in browser info

//	Macro to make code constantly checking for HRESULTS
//	more readable
//
#define CHECK_ERROR(expression)	\
{ HRESULT hResultCheck = (expression);	\
TCHAR	l_buf[1024];\
  if (FAILED(hResultCheck))				\
	{									\
		wsprintf(l_buf,\
				L"%S(%d) : error %d (0x%X) [%s] while performing this action:\n    %s\n====\n", \
				__FILE__, __LINE__, hResultCheck, hResultCheck,	\
				_com_error(hResultCheck).ErrorMessage(), #expression); \
	OutputDebugString(l_buf);\
		ASSERT (FALSE);			\
	if (hResultCheck != WBEM_E_ACCESS_DENIED) \
		return hResultCheck;				\
	}							\
}
// quick class to generate a GUID and a string equivalent
class CGuidString
{
	WCHAR m_szGUID[39];	// enough space to fit a GUID in Unicode
	GUID m_guid;	// enough space to fit a GUID in Unicode
public:
	CGuidString()
	{
		Regen();
	}
	HRESULT GetBSTR (_bstr_t& str)
	{
		try { 
			str = m_szGUID; 
		}
		catch (_com_error e) {
			return e.Error();
		}
		return S_OK;
	}
	operator LPCWSTR() {return m_szGUID;}
	HRESULT Regen()
	{
		::ZeroMemory(m_szGUID, sizeof(m_szGUID));
		HRESULT hr = CoCreateGuid(&m_guid);
		StringFromGUID2 (m_guid, m_szGUID, sizeof(m_szGUID) / sizeof (WCHAR));
		return hr;
	}
};

//
//	template function to suppress exceptions generated from an 
//	assignment and turn them into HRESULTS. Note that this only works
//	with _com_error exceptions!
//
template<class T1, class T2> inline HRESULT SafeAssign(T1& dest, T2& src)
{
	try
	{
		dest = src;
	}
	catch (_com_error e)
	{
		return e.Error();
	}
	catch (...)
	{
		ASSERT (FALSE); // invalid type of exception!!!!
		return TYPE_E_TYPEMISMATCH;
	}
	return S_OK;
}

//
//	Dependency-free SAFEARRAY wrapper class
//	Adapted from MFC's COleSafeArray
//	Allows type-safe access to safearrays of any type
//
template <class T, VARTYPE t_vt> class CSafeArrayOneDim : public tagVARIANT
{
public:
	enum {INITIAL_ALLOC = 200};
	CSafeArrayOneDim()
	{
		// Validate the VARTYPE for SafeArrayCreate call
		ASSERT(!(t_vt & VT_ARRAY));
		ASSERT(!(t_vt & VT_BYREF));
		ASSERT(!(t_vt & VT_VECTOR));
		ASSERT(t_vt != VT_EMPTY);
		ASSERT(t_vt != VT_NULL);

		::ZeroMemory(this, sizeof(*this));	
		vt = VT_EMPTY; 
	}
	~CSafeArrayOneDim()
		{ Clear(); }
	operator VARIANT*()
		{ return this; }
	operator const VARIANT*() const
		{ return this; }

// operations
	HRESULT Create(
		DWORD nElements = INITIAL_ALLOC, 
		T* pvSrcData = NULL)
	{
		ASSERT(nElements > 0);

		// Free up old safe array if necessary
		Clear();

		// Allocate and fill proxy array of bounds (with lower bound of zero)
		SAFEARRAYBOUND saBounds;
		saBounds.lLbound = 0;
		saBounds.cElements = nElements;

		parray = ::SafeArrayCreate(t_vt, 1, &saBounds);
		if (parray == NULL)
			return E_OUTOFMEMORY;

		// set the correct variant type for us
		vt = unsigned short(t_vt | VT_ARRAY);

		// Copy over the data if neccessary
		if (pvSrcData != NULL)
		{
			T* pvDestData;
			CHECK_ERROR(AccessData(&pvDestData));
			memcpy(pvDestData, 
				pvSrcData, 
				::SafeArrayGetElemsize(parray) * nElements);
			CHECK_ERROR(UnaccessData());
		}
		return S_OK;
	}

	DWORD GetSize()
	{
		long nUBound;
		GetUBound(&nUBound);
		return nUBound + 1;
	}

	HRESULT Resize(DWORD dwElements)
	{
		SAFEARRAYBOUND rgsabound;
		rgsabound.cElements = dwElements;
		rgsabound.lLbound = 0;

		CHECK_ERROR(::SafeArrayRedim(parray, &rgsabound));
		return S_OK;
	}

	HRESULT Copy(LPSAFEARRAY* ppsa)
	{
		ASSERT (::SafeArrayGetDim(ppsa) == 1);
		CHECK_ERROR(::SafeArrayCopy(parray, ppsa));
		return S_OK;
	}

	// store an entry in the array-- resize if needed
	HRESULT SafePutElement(long nIndex, const T& pvData)
	{
		long nUBound;
		CHECK_ERROR (GetUBound(&nUBound));
		if (nUBound < 1)
		{
			ASSERT (FALSE);
			return E_INVALIDARG;
		}
		// do we need to expand?
		if (nUBound < nIndex)
		{
			// figure out the right new size
			while (nUBound < nIndex)
			{
				nUBound = nUBound * 2;
			}
			CHECK_ERROR (Resize(nUBound));
		}
		CHECK_ERROR(::SafeArrayPutElement(parray, &nIndex, pvData));
		return S_OK;
	}

	// Operations
	HRESULT Attach(VARIANT& varSrc)
	{
		if (!IsValid())
			CHECK_ERROR (E_INVALIDARG);

		// Free up previous safe array if necessary
		CHECK_ERROR(Clear());

		// give control of data to CSafeArrayOneDim
		memcpy(this, &varSrc, sizeof(varSrc));
		varSrc.vt = VT_EMPTY;	// take it from the source variant
		return S_OK;
	}

	static bool IsValid(const VARIANT& Other)
	{
		if ((Other.vt & VT_ARRAY) == 0)
			return false;		// must be an array
		if (Other.vt != unsigned short(t_vt | VT_ARRAY))
			return false;		// must be same type as us
		if (::SafeArrayGetDim(Other.parray) != 1)
			return false;		// make sure no multi-dim arrays
		long nLBound = -1;
		::SafeArrayGetLBound(Other.parray, 1, &nLBound);
		if (nLBound != 0)					
			return false;	// lower bound must be zero

		// all looks good
		return true;
	}


	VARIANT Detach()
	{
		VARIANT varResult = *this;
		vt = VT_EMPTY;
		return varResult;
	}

	// trivial COM API wrappers
	HRESULT Clear()
		{ return ::VariantClear(this); }
	HRESULT AccessData(T** ppvData)
		{ CHECK_ERROR(::SafeArrayAccessData(parray, (void**) ppvData)); return S_OK; }
	HRESULT UnaccessData()
		{ CHECK_ERROR(::SafeArrayUnaccessData(parray)); return S_OK; }
	HRESULT AllocData()
		{ CHECK_ERROR(::SafeArrayAllocData(parray)); return S_OK; }
	HRESULT AllocDescriptor()
		{ CHECK_ERROR(::SafeArrayAllocDescriptor(1, &parray)); return S_OK; }
	HRESULT GetUBound(long* pUbound)
		{	CHECK_ERROR(::SafeArrayGetUBound(parray, 1, pUbound)); return S_OK;	}
	HRESULT Lock()
		{ CHECK_ERROR(::SafeArrayLock(parray)); return S_OK; }
	HRESULT Unlock()
		{ CHECK_ERROR(::SafeArrayUnlock(parray)); return S_OK;}
	HRESULT Destroy()
		{ CHECK_ERROR(::SafeArrayDestroy(parray)); return S_OK; }
	HRESULT DestroyData()
		{ CHECK_ERROR(::SafeArrayDestroyData(parray)); return S_OK; }
	HRESULT DestroyDescriptor()
		{ CHECK_ERROR(::SafeArrayDestroyDescriptor(parray)); return S_OK; }
	HRESULT GetElement(long nIndex, T* pvData)
		{ CHECK_ERROR(::SafeArrayGetElement(parray, &nIndex, pvData)); return S_OK; }
	HRESULT PtrOfIndex(long* rgIndices, T** ppvData)
		{ CHECK_ERROR(::SafeArrayPtrOfIndex(parray, rgIndices, ppvData)); return S_OK; }
	HRESULT PutElement(long* rgIndices, T* pvData)
		{ CHECK_ERROR(::SafeArrayPutElement(parray, rgIndices, pvData)); return S_OK; }
	
};

// typdefs for common classes
typedef CSafeArrayOneDim<VARIANT, VT_VARIANT> SafeArrayOneDimVariant;
typedef CSafeArrayOneDim<IWbemClassObject*, VT_UNKNOWN> SafeArrayOneDimWbemClassObject;
typedef CSafeArrayOneDim<BSTR, VT_BSTR> SafeArrayOneDimBSTR;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\system.h ===
//***************************************************************************
//
//  SYSTEM.H
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: This CSystem class only has one instance. Its main member
//  function is called each time the polling interval goes off. It then goes
//  through all of the CComponents, CDataPoints, and CThresholds.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#if !defined( __SYSTEM_H )
#define __SYSTEM_H

#include <wbemcli.h>
#include <vector>
#include "datagrp.h"
#include "action.h"

//typedef std::vector<CDataGroup*, std::allocator<CDataGroup*> > DGLIST;
typedef std::vector<CAction*, std::allocator<CAction*> > ALIST;
typedef std::vector<CBase*, std::allocator<CBase*> > BLIST;


class CSystem : public CBase
{
public:
	CSystem();
	~CSystem();


	DGLIST m_dataGroupList; // A system can only have DataGroups under it
	ALIST m_actionList; // A system can only have DataGroups under it
	long m_lAgentInterval;
	long m_lStartupDelayTime;
	DWORD m_lFiveMinTimerTime;
	long m_lNumInstancesAccepted;
	BOOL m_bEnabled;
	long m_lPrevState;
	DWORD m_startTick;
	long m_lNumberNormals;
	long m_lNumberWarnings;
	long m_lNumberCriticals;
	long m_lNumberChanges;
	LPTSTR m_szMessage;
	LPTSTR m_szResetMessage;
	BLIST m_masterList; // Flat list of all instances derived from CBase
	long m_lPrevChildCount;
	TCHAR m_szDTTime[512];
	TCHAR m_szTime[512];
	CTempConsumer* m_pTempSink;
	CTempConsumer* m_pEFTempSink;
	CTempConsumer* m_pECTempSink;
	CTempConsumer* m_pFTCBTempSink;
	CTempConsumer* m_pEFModTempSink;
	CTempConsumer* m_pECModTempSink;
	CTempConsumer* m_pFTCBModTempSink;
    PROCESS_INFORMATION m_processInfo;
	BOOL m_bValidLoad;
	int m_numActionChanges;


	BOOL InitWbemPointer(void);
	HRESULT InternalizeHMNamespace(void);
	HRESULT InternalizeSystem(void);
	HRESULT LoadInstanceFromMOF(IWbemClassObject*);
	HRESULT InternalizeDataGroups(void);
	HRESULT DredgePerfmon(void);
	HRESULT InternalizeActions(void);
	HRESULT InitActionErrorListener(void);
	HRESULT InitActionSIDListener(CTempConsumer* pTempSink, LPTSTR pszQUERY);
	BOOL OnAgentInterval(void);
	long GetAgentInterval(void);
	long GetStartupDelayTime(void);
	HRESULT HandleTempActionErrorEvent(IWbemClassObject* pObj);
	HRESULT HandleTempActionSIDEvent(IWbemClassObject* pObj);
	BOOL HandleTempActionEvent(LPTSTR, IWbemClassObject*);
	BOOL HandleTempEvent(CEventQueryDataCollector*, IWbemClassObject*);

	HRESULT SendHMSystemStatusInstances(IWbemObjectSink* pSink);
	HRESULT SendHMSystemStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
	HRESULT SendHMDataGroupStatusInstances(IWbemObjectSink* pSink);
	HRESULT SendHMDataGroupStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
	HRESULT SendHMDataCollectorStatusInstances(IWbemObjectSink* pSink);
	HRESULT SendHMDataCollectorStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
	HRESULT SendHMDataCollectorPerInstanceStatusInstances(IWbemObjectSink* pSink);
	HRESULT SendHMDataCollectorPerInstanceStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
	HRESULT SendHMDataCollectorStatisticsInstances(IWbemObjectSink* pSink);
	HRESULT SendHMDataCollectorStatisticsInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
	HRESULT SendHMThresholdStatusInstances(IWbemObjectSink* pSink);
	HRESULT SendHMThresholdStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
//	HRESULT SendHMThresholdStatusInstanceInstances(IWbemObjectSink* pSink);
//	HRESULT SendHMThresholdStatusInstanceInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
	HRESULT SendHMActionStatusInstances(IWbemObjectSink* pSink);
	HRESULT SendHMActionStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
	HRESULT GetHMSystemStatusInstance(IWbemClassObject** ppInstance, BOOL bEventBased);
	BOOL FireEvents(void);
	BOOL FireEvent(void);

	HRESULT ModSystem(IWbemClassObject* pObj);
	HRESULT ModDataGroup(IWbemClassObject* pObj);
	HRESULT ModDataCollector(IWbemClassObject* pObj);
	HRESULT ModThreshold(IWbemClassObject* pObj);
	HRESULT ModAction(IWbemClassObject* pObj);
	BOOL CreateActionAssociation(IWbemClassObject* pObj);
	BOOL ModActionAssociation(IWbemClassObject* pObj);

	HRESULT CreateSystemDataGroupAssociation(IWbemClassObject* pObj);
//	BOOL DeleteSystemDataGroupAssociation(IWbemClassObject* pObj);
	HRESULT CreateDataGroupDataGroupAssociation(IWbemClassObject* pObj);
//	BOOL DeleteDataGroupDataGroupAssociation(IWbemClassObject* pObj);
	HRESULT CreateDataGroupDataCollectorAssociation(IWbemClassObject* pObj);
//	BOOL DeleteDataGroupDataCollectorAssociation(IWbemClassObject* pObj);
	HRESULT CreateDataCollectorThresholdAssociation(IWbemClassObject* pObj);
//	BOOL DeleteDataCollectorThresholdAssociation(IWbemClassObject* pObj);
	BOOL ResetResetThresholdStates(void);
	BOOL GetChange(void);
	HRESULT FindAndDeleteByGUID(LPTSTR pszGUID);
//	HRESULT FindAndEnableByGUID(LPTSTR pszGUID, BOOL bEnable);
	HRESULT FindAndResetDEStateByGUID(LPTSTR pszGUID);
	HRESULT FindAndResetDEStatisticsByGUID(LPTSTR pszGUID);
	HRESULT FindAndEvaluateNowDEByGUID(LPTSTR pszGUID);
	BOOL Enable(BOOL bEnable);
	HRESULT CreateAction(IWbemClassObject* pObj);
	HRESULT FindAndCopyByGUID(LPTSTR pszGUID, SAFEARRAY** ppsa, LPTSTR *pszOriginalParentGUID);
	HRESULT FindAndPasteByGUID(LPTSTR pszGUID, SAFEARRAY* ppsa, LPTSTR pszOriginalSystem, LPTSTR pszOriginalParentGUID, BOOL bForceReplace);
	HRESULT FindAndCopyWithActionsByGUID(LPTSTR pszGUID, SAFEARRAY** ppsa, LPTSTR *pszOriginalParentGUID);
	HRESULT FindAndPasteWithActionsByGUID(LPTSTR pszGUID, SAFEARRAY* ppsa, LPTSTR pszOriginalSystem, LPTSTR pszOriginalParentGUID, BOOL bForceReplace);
	CBase *GetParentPointerFromPath(LPTSTR pszParentPath);
	CBase *FindImediateChildByName(LPTSTR pszChildName);
	CBase *FindPointerFromName(LPTSTR pszChildName);
	BOOL GetNextChildName(LPTSTR pszChildName, LPTSTR pszOutName);
	HRESULT DeleteConfigActionAssoc(LPTSTR pszConfigGUID, LPTSTR pszActionGUID);
	HRESULT DeleteAllConfigActionAssoc(LPTSTR pszConfigGUID);
//	HRESULT Move(LPTSTR pszTargetGUID, LPTSTR pszNewParentGUID);
//	BOOL ModifyAssocForMove(CBase *pNewParentBase);
	BOOL ReceiveNewChildForMove(CBase *pBase);
	BOOL DeleteChildFromList(LPTSTR pszGUID);
	BOOL FormatMessage(IWbemClassObject* pInstance);
	BOOL SendReminderActionIfStateIsSame(IWbemObjectSink* pActionEventSink, IWbemObjectSink* pActionTriggerEventSink, IWbemClassObject* pActionInstance, IWbemClassObject* pActionTriggerInstance, unsigned long ulTriggerStates);
	HRESULT AddPointerToMasterList(CBase *pBase);
	BOOL RemovePointerFromMasterList(CBase *pBase);
	CBase *FindPointerFromGUIDInMasterList(LPTSTR pszGUID);
	// new cut & paste code
	HRESULT AgentCopy(LPTSTR pszGUID, SAFEARRAY** ppsa, LPTSTR *pszOriginalParentGUID);
	HRESULT AgentPaste(LPTSTR pszTargetGUID, 
			   SAFEARRAY* psa, 
			   LPTSTR pszOriginalSystem, 
			   LPTSTR pszOriginalParentGUID, 
			   BOOL bForceReplace); 
	HRESULT RemapActions(void);
	HRESULT CheckAllForBadLoad(void);
	HRESULT CheckForBadLoad(void);
};
#endif  // __SYSTEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\system.cpp ===
//***************************************************************************
//
//  SYSTEM.CPP
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: This HMMACHINE class only has one instance. Its main member
//  function is called each time the polling interval goes off. It then goes
//  through all of the CDataGroups, CDataCollectors, and CThresholds.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <process.h>
#include <tchar.h>
//#include <objbase.h>
#include "global.h"
#include "system.h"

extern HANDLE g_hConfigLock;
extern CSystem* g_pSystem;
extern CSystem* g_pStartupSystem;
extern LPTSTR conditionLocStr[];
extern LPTSTR stateLocStr[];
extern HMODULE g_hModule;
extern HRESULT SetLocStrings(void);
extern void ClearLocStrings(void);

static BYTE LocalSystemSID[] = {1,1,0,0,0,0,0,5,18,0,0,0};
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSystem::CSystem()
{
	MY_OUTPUT(L"ENTER ***** CSystem::CSystem...", 4);

	g_pIWbemServices = NULL;
	g_pIWbemServicesCIMV2 = NULL;
	m_lAgentInterval = 0;
	m_lStartupDelayTime = 0;
	m_lFiveMinTimerTime = 0;
	m_lNumInstancesAccepted = 20;
	m_lNumberChanges = 0;
	m_bEnabled = FALSE;
	m_lCurrState = HM_GOOD;
	m_lPrevState = HM_GOOD;
	m_startTick = GetTickCount();
	m_szGUID = NULL;
	m_hmStatusType = HMSTATUS_SYSTEM;
	m_lNumberNormals = 0;
	m_lNumberWarnings = 0;
	m_lNumberCriticals = 0;
	m_lNumberChanges = 0;
	m_lPrevChildCount = 0;
	m_szMessage = NULL;
	m_szResetMessage = NULL;
	CThreshold::GetLocal();
	m_pTempSink = NULL;
	m_pEFTempSink = NULL;
	m_pECTempSink = NULL;
	m_pFTCBTempSink = NULL;
	m_pEFModTempSink = NULL;
	m_pECModTempSink = NULL;
	m_pFTCBModTempSink = NULL;
	m_processInfo.hProcess = NULL;
	m_bValidLoad = FALSE;
	m_numActionChanges = 0;

	MY_OUTPUT(L"EXIT ***** CSystem::CSystem...", 4);
}

CSystem::~CSystem()
{
	int i, iSize;
	CDataGroup* pDataGroup;
	CAction* pAction;

	MY_OUTPUT(L"ENTER ***** ~CSystem::~CSystem...", 4);

//	g_pStartupSystem->RemovePointerFromMasterList(this);

	if (m_pTempSink)
	{
		g_pIWbemServices->CancelAsyncCall((IWbemObjectSink*)m_pTempSink);
		m_pTempSink->Release();
		m_pTempSink = NULL;
	}
	if (m_pEFTempSink)
	{
		g_pIWbemServices->CancelAsyncCall((IWbemObjectSink*)m_pEFTempSink);
		m_pEFTempSink->Release();
		m_pEFTempSink = NULL;
	}
	if (m_pECTempSink)
	{
		g_pIWbemServices->CancelAsyncCall((IWbemObjectSink*)m_pECTempSink);
		m_pECTempSink->Release();
		m_pECTempSink = NULL;
	}
	if (m_pFTCBTempSink)
	{
		g_pIWbemServices->CancelAsyncCall((IWbemObjectSink*)m_pFTCBTempSink);
		m_pFTCBTempSink->Release();
		m_pFTCBTempSink = NULL;
	}
	if (m_pEFModTempSink)
	{
		g_pIWbemServices->CancelAsyncCall((IWbemObjectSink*)m_pEFTempSink);
		m_pEFTempSink->Release();
		m_pEFTempSink = NULL;
	}
	if (m_pECModTempSink)
	{
		g_pIWbemServices->CancelAsyncCall((IWbemObjectSink*)m_pECTempSink);
		m_pECTempSink->Release();
		m_pECTempSink = NULL;
	}
	if (m_pFTCBModTempSink)
	{
		g_pIWbemServices->CancelAsyncCall((IWbemObjectSink*)m_pFTCBTempSink);
		m_pFTCBTempSink->Release();
		m_pFTCBTempSink = NULL;
	}

	if (m_szGUID)
	{
		delete [] m_szGUID;
		m_szGUID = NULL;
	}

	if (m_szMessage)
	{
		delete [] m_szMessage;
		m_szMessage = NULL;
	}
	if (m_szResetMessage)
	{
		delete [] m_szResetMessage;
		m_szResetMessage = NULL;
	}

	if (g_pSystemEventSink != NULL)
	{
		g_pSystemEventSink->Release();
		g_pSystemEventSink = NULL;
	}

	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		delete pDataGroup;
	}

	iSize = m_actionList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_actionList.size());
		pAction = m_actionList[i];
		delete pAction;
	}

	CDataGroup::DGTerminationCleanup();
	CDataCollector::DETerminationCleanup();
	CThreshold::ThresholdTerminationCleanup();
	CBase::CleanupHRLList();
	CBase::CleanupEventLists();
	ClearLocStrings();
	m_bValidLoad = FALSE;

	MY_OUTPUT(L"EXIT ***** ~CSystem::~CSystem...", 4);
}

BOOL CSystem::InitWbemPointer(void)
{
	HRESULT hRetRes = S_OK;
	BSTR bsNamespace = NULL;
	IWbemLocator *pLocator = NULL;

	MY_OUTPUT(L"ENTER ***** CSystem::InitWbemPointers...", 4);
	hRetRes = CoCreateInstance(CLSID_WbemAdministrativeLocator, NULL,
									CLSCTX_INPROC_SERVER,
									IID_IWbemLocator,
									(LPVOID*) &pLocator);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	bsNamespace = SysAllocString(L"\\\\.\\root\\cimv2\\MicrosoftHealthMonitor");
	MY_ASSERT(bsNamespace); if (!bsNamespace) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	hRetRes = pLocator->ConnectServer(bsNamespace, 
									NULL, 
									NULL, 
									NULL, 
									0L,
									NULL, 
									NULL, 
									&g_pIWbemServices);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	SysFreeString(bsNamespace);
	bsNamespace = NULL;
		
	MY_OUTPUT(L"CSystem::InitWbemPointer()-Connected to namespace", 4);

	bsNamespace = SysAllocString(L"\\\\.\\root\\cimv2");
	MY_ASSERT(bsNamespace); if (!bsNamespace) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	hRetRes = pLocator->ConnectServer(	bsNamespace, 
									NULL, 
									NULL, 
									NULL, 
									0L,
									NULL, 
									NULL, 
									&g_pIWbemServicesCIMV2);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	SysFreeString(bsNamespace);
	bsNamespace = NULL;

	pLocator->Release();
	pLocator = NULL;

	MY_OUTPUT(L"EXIT ***** CSystem::InitWbemPointers...", 4);
	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (pLocator)
		pLocator->Release();
	if (bsNamespace)
		SysFreeString(bsNamespace);
	return FALSE;
}

HRESULT CSystem::InternalizeHMNamespace(void)
{
    HRESULT hRes;
    HRESULT hRetRes;
	IWbemClassObject* pObj = NULL;
	IWbemClassObject* pNewObj = NULL;
	IWbemCallResult *pResult = 0;
	int i, iSize;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** CSystem::InternalizeHMNamespace...", 4);

	hRetRes = SetLocStrings();
	if (hRetRes != S_OK) return hRetRes;

	g_pStartupSystem = this;
	hRetRes = InternalizeSystem();
	if (hRetRes==S_OK)
	{
		//
		// This reads in all the components heirarchy from the HealthMon namespace.
		// Each component reads in what is under it. DataPoints get read in, and they
		// in turn read in their thresholds.
		//
		hRetRes = InternalizeDataGroups();
		if (hRetRes==S_OK)
		{
			//
			// Set our state to enabled, or disabled and transfer to the child thresholds
			//
			iSize = m_dataGroupList.size();
			for (i=0; i < iSize; i++)
			{
				MY_ASSERT(i<m_dataGroupList.size());
				pDataGroup = m_dataGroupList[i];
				pDataGroup->SetParentEnabledFlag(m_bEnabled);
			}
		}
		else
		{
			g_pStartupSystem = NULL;
			return hRetRes;
		}
	}
	else
	{
		g_pStartupSystem = NULL;
		return hRetRes;
	}

	// Implements the dormancy feature. If the agent has never been active
	// before, we will be the first time, because a console connected to the box.
	// Create this instance, that will keep us loaded from now on, even if
	// WMI stops and starts.
	// create an instance of TimerEvent Filter.
	// instance of __EventFilter
	// {
	//    Name				= "MicrosoftHM_Filter";
	//    Query				= "select * from __TimerEvent where TimerId=\"MicrosoftHM_Timer\"";
	//    QueryLanguage		= "WQL";
	// };

	hRetRes = GetWbemObjectInst(&g_pIWbemServices, L"__EventFilter.Name=\"MicrosoftHM_Filter\"", NULL, &pObj);
	MY_HRESASSERT(hRetRes);
	if (!pObj)
	{
		hRetRes = GetWbemObjectInst(&g_pIWbemServices, L"__EventFilter", NULL, &pObj);
		MY_HRESASSERT(hRetRes);
		if (pObj)
		{
			pObj->SpawnInstance(0, &pNewObj);
			pObj->Release();  // Don't need the class any more
			PutStrProperty(pNewObj, L"Name", L"MicrosoftHM_Filter");
			PutStrProperty(pNewObj, L"Query", L"select * from __TimerEvent where TimerId=\"MicrosoftHM_Timer\"");
			PutStrProperty(pNewObj, L"QueryLanguage", L"WQL");

			hRes = g_pIWbemServices->PutInstance(pNewObj, 0, NULL, &pResult);
			MY_HRESASSERT(hRes);
			pNewObj->Release();
			pNewObj = NULL;
		}
	}
	else
	{
		pObj->Release();
		pObj = NULL;
	}

	g_pStartupSystem = NULL;
	MY_OUTPUT(L"EXIT ***** CSystem::InternalizeHMNamespace...", 4);
	return S_OK;
}

//
// Get all the properties from the MicrosoftHM_SystemConfiguration instance
//
HRESULT CSystem::InternalizeSystem(void)
{
	BSTR szString = NULL;
	IWbemClassObject* pInst = NULL;
	IWbemClassObject *pClassObject = NULL;
	BOOL fRes = TRUE;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** CSystem::InternalizeSystem...", 4);

	CalcCurrTime();
	wcscpy(m_szDTTime, m_szDTCurrTime);
	wcscpy(m_szTime, m_szCurrTime);

	//
	// Get the properties from the SystemConfiguration instance
	//
	hRetRes = GetWbemObjectInst(&g_pIWbemServices, L"MicrosoftHM_SystemConfiguration.GUID=\"{@}\"", NULL, &pInst);
	if (!pInst)
	{
		MY_HRESASSERT(hRetRes);
		MY_OUTPUT(L"ERROR: Couldn't find MicrosoftHM_SYstemCOnfiguration", 4);
		return hRetRes;
	}

	hRetRes = LoadInstanceFromMOF(pInst);
	pInst->Release();
	pInst = NULL;

	MY_OUTPUT(L"EXIT ***** CSystem::InternalizeSystem...", 4);
	return hRetRes;
}

HRESULT CSystem::LoadInstanceFromMOF(IWbemClassObject* pInst)
{
	int i, iSize;
	CDataGroup *pDataGroup;

	HRESULT hRetRes = S_OK;
	BOOL bRetValue = TRUE;

	MY_OUTPUT(L"ENTER ***** CSystem::LoadInstanceFromMOF...", 4);

	m_bValidLoad = TRUE;
	if (m_szGUID == NULL)
	{
		// Get the GUID property
		hRetRes = GetStrProperty(pInst, L"GUID", &m_szGUID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) return hRetRes;
	}

//	if (bModifyPass == FALSE)
//	{
//		g_pStartupSystem->AddPointerToMasterList(this);
//	}

	m_lAgentInterval = HM_POLLING_INTERVAL;

	hRetRes = GetUint32Property(pInst, L"StartupDelayTime", &m_lStartupDelayTime);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	hRetRes = GetUint32Property(pInst, L"MaxInstancesPerDataCollector", &m_lNumInstancesAccepted);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	hRetRes = GetStrProperty(pInst, L"Message", &m_szMessage);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	hRetRes = GetStrProperty(pInst, L"ResetMessage", &m_szResetMessage);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	hRetRes = GetBoolProperty(pInst, L"Enabled", &m_bEnabled);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	//
	// Set our state to enabled, or disabled and transfer to the child thresholds
	//
	if (m_bEnabled==FALSE)
	{
		iSize = m_dataGroupList.size();
		for (i=0; i < iSize; i++)
		{
			MY_ASSERT(i<m_dataGroupList.size());
			pDataGroup = m_dataGroupList[i];
			pDataGroup->SetParentEnabledFlag(FALSE);
		}
	}
	else
	{
		iSize = m_dataGroupList.size();
		for (i=0; i < iSize; i++)
		{
			MY_ASSERT(i<m_dataGroupList.size());
			pDataGroup = m_dataGroupList[i];
			pDataGroup->SetParentEnabledFlag(TRUE);
		}
	}

	m_bValidLoad = TRUE;
	MY_OUTPUT(L"EXIT ***** CSystem::LoadInstanceFromMOF...", 4);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	if (m_szMessage)
	{
		delete [] m_szMessage;
		m_szMessage = NULL;
	}
	if (m_szResetMessage)
	{
		delete [] m_szResetMessage;
		m_szResetMessage = NULL;
	}
	m_bValidLoad = FALSE;
	return FALSE;
}

HRESULT CSystem::InternalizeDataGroups(void)
{
	HRESULT hRetRes = S_OK;
	BSTR Language = NULL;
	BSTR Query = NULL;
	ULONG uReturned;
	IWbemClassObject *pObj = NULL;
	IEnumWbemClassObject *pEnum = NULL;
	LPTSTR pszTempGUID = NULL;

	MY_OUTPUT(L"ENTER ***** CSystem::InternalizeDataGroups...", 4);

	// Just loop through all top level DataGroups associated with the System.
	// Call a method of each, and have the datagroup load itself.
	// Dril down and then have each DataCollector load itself.
	Language = SysAllocString(L"WQL");
	MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	Query = SysAllocString(L"ASSOCIATORS OF {MicrosoftHM_SystemConfiguration.GUID=\"{@}\"} WHERE ResultClass=MicrosoftHM_DataGroupConfiguration");
	MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

	// Issue query
	hRetRes = g_pIWbemServices->ExecQuery(Language, Query, WBEM_FLAG_FORWARD_ONLY, 0, &pEnum);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) return hRetRes;
	SysFreeString(Query);
	Query = NULL;
	SysFreeString(Language);
	Language = NULL;

	// Retrieve objects in result set
	while (TRUE)
	{
		pObj = NULL;
		uReturned = 0;

		hRetRes = pEnum->Next(0, 1, &pObj, &uReturned);
		MY_ASSERT(hRetRes==S_OK || hRetRes==WBEM_S_FALSE);
		if (hRetRes!=S_OK && hRetRes!=WBEM_S_FALSE)
		{
			MY_HRESASSERT(hRetRes);
			pEnum->Release();
			pEnum = NULL;
			return hRetRes;
		}

		if (uReturned == 0)
		{
			break;
		}

		// See if this is already read in. Need to prevent endless loop, circular references.
		hRetRes = GetStrProperty(pObj, L"GUID", &pszTempGUID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) return hRetRes;
		if (!g_pStartupSystem->FindPointerFromGUIDInMasterList(pszTempGUID))
		{
			// Create the internal class to represent the DataGroup
			CDataGroup* pDG = new CDataGroup;
			MY_ASSERT(pDG); if (!pDG) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			hRetRes = pDG->LoadInstanceFromMOF(pObj, NULL, m_szGUID);
			if (hRetRes==S_OK)
			{
				m_dataGroupList.push_back(pDG);
			}
			else
			{
				MY_ASSERT(FALSE);
				pDG->DeleteDGInternal();
				delete pDG;
			}
		}
		delete [] pszTempGUID;
		pszTempGUID = NULL;

		// Release it.
		pObj->Release();
		pObj = NULL;
	}

	// All done
	pEnum->Release();
	pEnum = NULL;

	MY_OUTPUT(L"EXIT ***** CSystem::InternalizeDataGroups...", 4);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	if (Query)
		SysFreeString(Query);
	if (Language)
		SysFreeString(Language);
	if (pObj)
		pObj->Release();
	if (pEnum)
		pEnum->Release();
	if (pszTempGUID)
		delete [] pszTempGUID;
	m_bValidLoad = FALSE;
	return hRetRes;
}

//
// Called every second. We loop through all the DataGroups.
// We call the member function of the DataGroup that will then loop through
// all of its DataGroups and DataCollectors.
//
BOOL CSystem::OnAgentInterval(void)
{
	BOOL bRetValue = TRUE;
	long state;
	int i;
	int iSize;
	CDataGroup *pDataGroup;
	CAction* pAction;
	DWORD currTick;
    DWORD dwReturnCode = 0L;
	long lCurrChildCount = 0;
	static int startup_init = 0;

	if (m_bValidLoad == FALSE)
	{
		currTick = GetTickCount();
		if ((150*1000) < (currTick-m_lFiveMinTimerTime))
		{
			m_lFiveMinTimerTime = currTick;
			CheckAllForBadLoad();
		}
		return FALSE;
	}

	if (startup_init == 0)
	{
		startup_init = 1;
		InternalizeActions();
		BOOL bSuccess = ImpersonateSelf(SecurityImpersonation);
		RemapActions();
		RevertToSelf();
		InitActionErrorListener();
		InitActionSIDListener(m_pEFTempSink, L"select * from __InstanceCreationEvent where TargetInstance isa \"__EventFilter\"");
		InitActionSIDListener(m_pECTempSink, L"select * from __InstanceCreationEvent where TargetInstance isa \"__EventConsumer\"");
		InitActionSIDListener(m_pFTCBTempSink, L"select * from __InstanceCreationEvent where TargetInstance isa \"__FilterToConsumerBinding\"");
		InitActionSIDListener(m_pEFModTempSink, L"select * from __InstanceModificationEvent where TargetInstance isa \"__EventFilter\"");
		InitActionSIDListener(m_pECModTempSink, L"select * from __InstanceModificationEvent where TargetInstance isa \"__EventConsumer\"");
		InitActionSIDListener(m_pFTCBModTempSink, L"select * from __InstanceModificationEvent where TargetInstance isa \"__FilterToConsumerBinding\"");
		DredgePerfmon();
		m_lFiveMinTimerTime = GetTickCount();
	}
	else
	{
		if (m_processInfo.hProcess)
		{
			GetExitCodeProcess(m_processInfo.hProcess, &dwReturnCode);
			if (dwReturnCode != STILL_ACTIVE)
			{
				CloseHandle(m_processInfo.hProcess);
				m_processInfo.hProcess = NULL;
			}
		}
	}

	currTick = GetTickCount();
	if ((150*1000) < (currTick-m_lFiveMinTimerTime))
	{
		m_lFiveMinTimerTime = currTick;
		CheckAllForBadLoad();
		// Safety net to catch just in case
		if (m_numActionChanges)
		{
			Sleep(5);
			m_numActionChanges = 0;
			BOOL bSuccess = ImpersonateSelf(SecurityImpersonation);
			RemapActions();
			RevertToSelf();
		}
	}

	if (m_numActionChanges>2)
	{
		Sleep(5);
		m_numActionChanges = 1;
		BOOL bSuccess = ImpersonateSelf(SecurityImpersonation);
		RemapActions();
		RevertToSelf();
	}

	MY_OUTPUT(L"ENTER ***** CSystem::OnAgentInterval...", 1);

	//
	// Wait for the delay time to be up before we do anything
	//
	if (m_lStartupDelayTime != -1)
	{
		currTick = GetTickCount();
		if ((m_lStartupDelayTime*1000) < (currTick-m_startTick))
		{
			m_lStartupDelayTime = -1;
		}
		else
		{
			return bRetValue;
		}
	}

	m_lNumberChanges = 0;

	//
	// Don't do anything if we are disabled.
	//
	if (m_bEnabled==FALSE && m_lCurrState==HM_DISABLED)
	{
		return bRetValue;
	}

	// Call to set the current time, for anyone to use that needs it.
	CalcCurrTime();

	//
	// Do Action scheduling and throttling
	//
	iSize = m_actionList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_actionList.size());
		pAction = m_actionList[i];
		pAction->OnAgentInterval();
	}

	m_lPrevState = m_lCurrState;

	iSize = m_dataGroupList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		pDataGroup->OnAgentInterval();
	}

	if (m_bEnabled==FALSE)
	{
		m_lCurrState = HM_DISABLED;
		if (m_lNumberChanges == 0)
			m_lNumberChanges = 1;
	}
	else
	{
		//
		// Set State of the system to the worst of everything under it
		//
		m_lNumberNormals = 0;
		m_lNumberWarnings = 0;
		m_lNumberCriticals = 0;
		m_lNumberChanges = 0;
		m_lCurrState = -1;
		iSize = m_dataGroupList.size();
		lCurrChildCount = iSize;
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<m_dataGroupList.size());
			pDataGroup = m_dataGroupList[i];
			state = pDataGroup->GetCurrState();
			if (state==HM_SCHEDULEDOUT || state==HM_DISABLED)
			{
				state = HM_GOOD;
			}
			if (state > m_lCurrState)
			{
				m_lCurrState = state;
			}
			if (state == HM_GOOD)
			{
				m_lNumberNormals++;
			}
			if (state == HM_WARNING)
			{
				m_lNumberWarnings++;
			}
			if (state == HM_CRITICAL)
			{
				m_lNumberCriticals++;
			}
			if (pDataGroup->GetChange())
			{
				m_lNumberChanges++;
			}
		}

		// Maybe we don't have any Groups underneith
		// Or the disabled state of things below us did not roll up
		if (m_lCurrState == -1)
		{
			if (m_bEnabled==FALSE)
			{
				m_lCurrState = HM_DISABLED;
			}
			else
			{
				m_lCurrState = HM_GOOD;
			}

			if (m_lPrevState != m_lCurrState)
			{
				m_lNumberChanges++;
			}
		}
		else if (m_lPrevState==HM_DISABLED && m_lPrevState != m_lCurrState)
		{
			m_lNumberChanges++;
		}
	}

	if (m_lPrevChildCount!=lCurrChildCount)
	{
		if (m_lNumberChanges==0 && m_lPrevState!=m_lCurrState)
		{
			m_lNumberChanges++;
		}
	}
	m_lPrevChildCount = lCurrChildCount;


	FireEvents();

	MY_OUTPUT(L"EXIT ***** CSystem::OnAgentInterval...", 1);
	return bRetValue;
}

HRESULT CSystem::DredgePerfmon(void)
{
	wchar_t szModule[_MAX_PATH];
	wchar_t szPath[_MAX_PATH];
	wchar_t szDir[_MAX_PATH];
	STARTUPINFO StartupInfo;
	DWORD dwReturnCode = 0L;
	BOOL bRetCode;

	MY_OUTPUT(L"ENTER ***** CSystem::DredgePerfmon...", 4);

    // Set the startup structure
    //==========================
	memset(&StartupInfo, '\0', sizeof(StartupInfo));

	StartupInfo.cb = sizeof(StartupInfo) ;		
	StartupInfo.lpReserved = NULL ;
	StartupInfo.lpDesktop = NULL ;
	StartupInfo.lpTitle = NULL ;
	StartupInfo.dwFlags = 0; //STARTF_USESHOWWINDOW;//0;
	StartupInfo.wShowWindow = SW_HIDE;
	StartupInfo.cbReserved2 = 0 ;    
	StartupInfo.lpReserved2 = NULL ;

	// Get the path to the dredger executable
	GetModuleFileNameW(g_hModule, szModule, _MAX_PATH);
	_tsplitpath(szModule, szPath, szDir, NULL, NULL);
	lstrcat(szPath, szDir);
	lstrcat(szPath, L"\\dredger.exe");

	bRetCode = CreateProcess(NULL,				// App name
							 szPath,			// Full command line
							 NULL,				// Process security attributes
							 NULL,				// Thread security attributes
							 FALSE,				// Process inherits handles
							 CREATE_NO_WINDOW,	// Creation flags
							 NULL,				// Environment
							 NULL,				// Current directory
							 &StartupInfo,		// STARTUP_INFO
							 &m_processInfo);		// PROCESS_INFORMATION

	MY_ASSERT(bRetCode);

	MY_OUTPUT(L"EXIT ***** CSystem::DredgePerfmon...", 4);
	return S_OK;
}   

// get polling interval in milliseconds.
long CSystem::GetAgentInterval(void)
{
	return (m_lAgentInterval*1000);
}

// get polling interval in milliseconds.
long CSystem::GetStartupDelayTime(void)
{
	return (m_lStartupDelayTime*1000);
}

// Pass on info to the DataCollector that has the GUID
BOOL CSystem::HandleTempActionEvent(LPTSTR szGUID, IWbemClassObject* pObj)
{
	BOOL bFound = FALSE;
	int i, iSize;
	CAction* pAction;
	DWORD dwErr = 0;

	if (m_bValidLoad == FALSE)
		return FALSE;

	MY_OUTPUT(L"BLOCK - BLOCK CSystem::HandleTempEvent BLOCK - g_hConfigLock BLOCK WAIT", 4);
	dwErr = WaitForSingleObject(g_hConfigLock, 120000);
	if(dwErr != WAIT_OBJECT_0)
	{
		if(dwErr = WAIT_TIMEOUT)
		{
			TRACE_MUTEX(L"TIMEOUT MUTEX");
			return FALSE;
//			return WBEM_S_TIMEDOUT;
		}
		else
		{
			MY_OUTPUT(L"WaitForSingleObject on Mutex failed",4);
			return FALSE;
//			return WBEM_E_FAILED;
		}
	}
	MY_OUTPUT(L"BLOCK - BLOCK CSystem::HandleTempEvent BLOCK - g_hConfigLock BLOCK GOT IT", 4);

	if (!g_pSystem)
	{
		ReleaseMutex(g_hConfigLock);
		return FALSE;
	}

	try
	{
		iSize = m_actionList.size();
		for (i=0; i < iSize; i++)
		{
			MY_ASSERT(i<m_actionList.size());
			pAction = m_actionList[i];
			if (pAction->HandleTempEvent(szGUID, pObj))
			{
				bFound = TRUE;
				break;
			}
		}

		if (bFound == FALSE)
		{
			MY_OUTPUT2(L"NOTFOUND: No body to handle event for GUID=%s", szGUID, 4);
		}
	}
	catch (...)
	{
		MY_ASSERT(FALSE);
	}

	MY_OUTPUT(L"BLOCK - BLOCK CSystem::HandleTempEvent g_hConfigLock BLOCK - RELEASE IT", 4);
	ReleaseMutex(g_hConfigLock);
	MY_OUTPUT(L"BLOCK - BLOCK CSystem::HandleTempEvent g_hConfigLock BLOCK - RELEASED", 4);
	return TRUE;
}

BOOL CSystem::HandleTempEvent(CEventQueryDataCollector *pEQDC, IWbemClassObject* pObj)
{
	BOOL bFound = FALSE;
	int i, iSize;
	CBase* pBase;
	DWORD dwErr = 0;

	if (m_bValidLoad == FALSE)
		return FALSE;

	MY_OUTPUT(L"BLOCK - BLOCK CSystem::HandleTempEvent BLOCK - g_hConfigLock BLOCK WAIT", 4);
	dwErr = WaitForSingleObject(g_hConfigLock, 120000);
	if(dwErr != WAIT_OBJECT_0)
	{
		if(dwErr = WAIT_TIMEOUT)
		{
			TRACE_MUTEX(L"TIMEOUT MUTEX");
			return FALSE;
//			return WBEM_S_TIMEDOUT;
		}
		else
		{
			MY_OUTPUT(L"WaitForSingleObject on Mutex failed",4);
			return FALSE;
//			return WBEM_E_FAILED;
		}
	}
	MY_OUTPUT(L"BLOCK - BLOCK CSystem::HandleTempEvent BLOCK - g_hConfigLock BLOCK GOT IT", 4);

	if (!g_pSystem)
	{
		ReleaseMutex(g_hConfigLock);
		return FALSE;
	}

	try
	{
		iSize = m_masterList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_masterList.size());
			pBase = m_masterList[i];
			if (pBase->m_hmStatusType == HMSTATUS_DATACOLLECTOR)
			{
				if (((CDataCollector *)pBase)->m_deType == HM_EQDE)
				{
					if (((CEventQueryDataCollector *)pBase) == pEQDC)
					{
						((CEventQueryDataCollector *)pBase)->HandleTempEvent(pObj);
						bFound = TRUE;
						break;
					}
				}
			}
		}

		if (bFound == FALSE)
		{
			MY_OUTPUT2(L"NOTFOUND: No body to handle event for GUID=%s", pBase->m_szGUID, 4);
		}
	}
	catch (...)
	{
		MY_ASSERT(FALSE);
	}

	MY_OUTPUT(L"BLOCK - BLOCK CSystem::HandleTempEvent g_hConfigLock BLOCK - RELEASE IT", 4);
	ReleaseMutex(g_hConfigLock);
	MY_OUTPUT(L"BLOCK - BLOCK CSystem::HandleTempEvent g_hConfigLock BLOCK - RELEASED", 4);
	return TRUE;
}

HRESULT CSystem::SendHMSystemStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	MY_OUTPUT2(L"System send for GUID=%s", pszGUID, 4);
	MY_ASSERT(pSink!=NULL);
	if (!wcscmp(L"{@}", pszGUID))
	{
		return SendHMSystemStatusInstances(pSink);
	}
	else
	{
		return WBEM_S_DIFFERENT;
	}
}

HRESULT CSystem::SendHMSystemStatusInstances(IWbemObjectSink* pSink)
{
	HRESULT hRes = S_OK;
	IWbemClassObject* pInstance = NULL;

	MY_OUTPUT(L"ENTER ***** SendHMSystemStatusInstances...", 4);

	if (pSink == NULL)
	{
		MY_OUTPUT(L"CDP::SendInitialHMMachStatInstances-Invalid Sink", 1);
		return WBEM_E_FAILED;
	}

	hRes = GetHMSystemStatusInstance(&pInstance, FALSE);
	if (SUCCEEDED(hRes))
	{
		hRes = pSink->Indicate(1, &pInstance);

		if (FAILED(hRes) && hRes != WBEM_E_SERVER_TOO_BUSY)
		{
			MY_HRESASSERT(hRes);
			MY_OUTPUT(L"SendHMSystemStatusInstances-failed to send status!", 4);
		}
		else
		{
			MY_OUTPUT(L"SendHMSystemStatusInstances-success!", 4);
		}

		pInstance->Release();
		pInstance = NULL;
	}
	else
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT(L":SendHMSystemStatusInstances-failed to get instance!", 1);
	}

	MY_OUTPUT(L"EXIT ***** SendHMSystemStatusInstances...", 4);
	return hRes;
}

HRESULT CSystem::SendHMDataGroupStatusInstances(IWbemObjectSink* pSink)
{
	BOOL bRetValue = TRUE;
	int i;
	int iSize;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** CSystem::SendDataGroupStatusInstances...", 4);

	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		pDataGroup->SendHMDataGroupStatusInstances(pSink);
	}

	MY_OUTPUT(L"EXIT ***** CSystem::SendDataGroupStatusInstances...", 4);
	return bRetValue;
}

HRESULT CSystem::SendHMDataGroupStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	HRESULT hRetRes = S_OK;
	int i;
	int iSize;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** CSystem::SendDataGroupStatusInstance...", 4);
	MY_OUTPUT2(L"DG send for GUID=%s", pszGUID, 4);

	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		hRetRes = pDataGroup->SendHMDataGroupStatusInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			break;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			break;
		}
	}

	if (hRetRes==WBEM_S_DIFFERENT)
	{
		hRetRes = WBEM_E_NOT_FOUND;
		MY_OUTPUT(L"GUID not found", 4);
	}

	MY_OUTPUT(L"EXIT ***** CSystem::SendDataGroupStatusInstance...", 4);
	return hRetRes;
}

HRESULT CSystem::SendHMDataCollectorStatusInstances(IWbemObjectSink* pSink)
{
	BOOL bRetValue = TRUE;
	int i;
	int iSize;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** CSystem::SendDataCollectorStatusInstances...", 4);

	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		pDataGroup->SendHMDataCollectorStatusInstances(pSink);
	}

	MY_OUTPUT(L"EXIT ***** CSystem::SendDataCollectorStatusInstances...", 4);
	return bRetValue;
}

HRESULT CSystem::SendHMDataCollectorStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	HRESULT hRetRes = S_OK;
	int i;
	int iSize;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** CSystem::SendDataCollectorStatusInstance...", 4);
	MY_OUTPUT2(L"DC send for GUID=%s", pszGUID, 4);

	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		hRetRes = pDataGroup->SendHMDataCollectorStatusInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			break;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			break;
		}
	}

	if (hRetRes==WBEM_S_DIFFERENT)
	{
		hRetRes = WBEM_E_NOT_FOUND;
		MY_OUTPUT(L"GUID not found", 4);
	}

	MY_OUTPUT(L"EXIT ***** CSystem::SendDataCollectorStatusInstance...", 4);
	return hRetRes;
}

HRESULT CSystem::SendHMDataCollectorPerInstanceStatusInstances(IWbemObjectSink* pSink)
{
	BOOL bRetValue = TRUE;
	int i;
	int iSize;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** CSystem::SendDataCollectorPerInstanceStatusInstances...", 4);

	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		pDataGroup->SendHMDataCollectorPerInstanceStatusInstances(pSink);
	}

	MY_OUTPUT(L"EXIT ***** CSystem::SendDataCollectorPerInstanceStatusInstances...", 4);
	return bRetValue;
}

HRESULT CSystem::SendHMDataCollectorPerInstanceStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	HRESULT hRetRes = S_OK;
	int i;
	int iSize;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** CSystem::SendDataCollectorPerInstanceStatusInstance...", 4);
	MY_OUTPUT2(L"DC send for GUID=%s", pszGUID, 4);

	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		hRetRes = pDataGroup->SendHMDataCollectorPerInstanceStatusInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			break;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			break;
		}
	}

	if (hRetRes==WBEM_S_DIFFERENT)
	{
		hRetRes = WBEM_E_NOT_FOUND;
		MY_OUTPUT(L"GUID not found", 4);
	}

	MY_OUTPUT(L"EXIT ***** CSystem::SendDataCollectorPerInstanceStatusInstance...", 4);
	return hRetRes;
}

HRESULT CSystem::SendHMDataCollectorStatisticsInstances(IWbemObjectSink* pSink)
{
	BOOL bRetValue = TRUE;
	int i, iSize;
	CDataGroup *pDataGroup;
    IWbemClassObject** aObjects;
	IWbemClassObject* pInstance = NULL;

	MY_OUTPUT(L"ENTER ***** CSystem::SendDataCollectorStatisticsInstances...", 4);

	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		pDataGroup->SendHMDataCollectorStatisticsInstances(pSink);
	}

	//
	// Loop through the DataCollectorStatistics Events and send them as one indicate
	//
	iSize = mg_DCStatsInstList.size();
    aObjects = new IWbemClassObject*[iSize];
	if (aObjects)
	{
		for (i=0; i < iSize; i++)
		{
			MY_ASSERT(i<mg_DCStatsInstList.size());
			pInstance = mg_DCStatsInstList[i];
    		aObjects[i] = pInstance;
		}
		SendEvents(pSink, aObjects, iSize);
	}
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<mg_DCStatsInstList.size());
		pInstance = mg_DCStatsInstList[i];
    	pInstance->Release();
	}
	mg_DCStatsInstList.clear();
	if (aObjects)
	    delete [] aObjects;

	MY_OUTPUT(L"EXIT ***** CSystem::SendDataCollectorStatisticsInstances...", 4);
	return bRetValue;
}

HRESULT CSystem::SendHMDataCollectorStatisticsInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	HRESULT hRetRes = S_OK;
	int i;
	int iSize;
	CDataGroup *pDataGroup;
	IWbemClassObject* pInstance = NULL;
	IWbemClassObject** aObjects;

	MY_OUTPUT(L"ENTER ***** CSystem::SendDataCollectorStatisticsInstance...", 4);
	MY_OUTPUT2(L"DCStatistics send for GUID=%s", pszGUID, 4);

	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		hRetRes = pDataGroup->SendHMDataCollectorStatisticsInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			break;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			break;
		}
	}

	//
	// Loop through the DataCollectorStatistics Events and send them as one indicate
	//
	iSize = mg_DCStatsInstList.size();
	aObjects = new IWbemClassObject*[iSize];
	if (aObjects)
	{
		for (i=0; i < iSize; i++)
		{
			MY_ASSERT(i<mg_DCStatsInstList.size());
			pInstance = mg_DCStatsInstList[i];
    		aObjects[i] = pInstance;
		}
		SendEvents(pSink, aObjects, iSize);
	}
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<mg_DCStatsInstList.size());
		pInstance = mg_DCStatsInstList[i];
    	pInstance->Release();
	}
	mg_DCStatsInstList.clear();
	if (aObjects)
		delete [] aObjects;

	if (hRetRes==WBEM_S_DIFFERENT)
	{
		hRetRes = WBEM_E_NOT_FOUND;
		MY_OUTPUT(L"GUID not found", 4);
		return WBEM_E_NOT_FOUND;
	}

	MY_OUTPUT(L"EXIT ***** CSystem::SendDataCollectorStatisticsInstance...", 4);
	return hRetRes;
}

HRESULT CSystem::SendHMThresholdStatusInstances(IWbemObjectSink* pSink)
{
	HRESULT hRetRes = S_OK;
	int i;
	int iSize;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** CSystem::SendThresholdStatusInstances...", 4);

	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		pDataGroup->SendHMThresholdStatusInstances(pSink);
	}

	MY_OUTPUT(L"EXIT ***** CSystem::SendThresholdStatusInstances...", 4);
	return hRetRes;
}

HRESULT CSystem::SendHMThresholdStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	HRESULT hRetRes = S_OK;
	int i;
	int iSize;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** CSystem::SendHMThresholdStatusInstance...", 4);
	MY_OUTPUT2(L"Threshold send for GUID=%s", pszGUID, 4);

	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		hRetRes = pDataGroup->SendHMThresholdStatusInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			break;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			break;
		}
	}

	if (hRetRes==WBEM_S_DIFFERENT)
	{
		hRetRes = WBEM_E_NOT_FOUND;
		MY_OUTPUT(L"GUID not found", 4);
	}

	MY_OUTPUT(L"EXIT ***** CSystem::SendHMThresholdStatusInstance...", 4);
	return hRetRes;
}

#ifdef SAVE
NOT USED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
NOT USED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
NOT USED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
HRESULT CSystem::SendHMThresholdStatusInstanceInstances(IWbemObjectSink* pSink)
{
	BOOL bRetValue = TRUE;
	int i;
	int iSize;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** CSystem::SendThresholdStatusInstanceInstances...", 4);

	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		pDataGroup->SendHMThresholdStatusInstanceInstances(pSink);
	}

	MY_OUTPUT(L"EXIT ***** CSystem::SendThresholdStatusInstanceInstances...", 4);
	return bRetValue;
}

NOT USED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
NOT USED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
NOT USED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
HRESULT CSystem::SendHMThresholdStatusInstanceInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	BOOL bRetValue = TRUE;
	int i;
	int iSize;
	CDataGroup *pDataGroup;

	MY_OUTPUT(L"ENTER ***** CSystem::SendHMThresholdStatusInstanceInstance...", 4);
	MY_OUTPUT2(L"ThresholdStatusInstances send for GUID=%s", pszGUID, 4);

	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		if (pDataGroup->SendHMThresholdStatusInstanceInstance(pSink, pszGUID))
		{
			MY_OUTPUT(L"Found", 4);
			break;
		}
	}

	MY_OUTPUT(L"EXIT ***** CSystem::SendHMThresholdStatusInstanceInstance...", 4);
	return bRetValue;
}
#endif

HRESULT CSystem::SendHMActionStatusInstances(IWbemObjectSink* pSink)
{
	HRESULT hRetRes = S_OK;
	int i;
	int iSize;
	CAction *pAction;

	MY_OUTPUT(L"ENTER ***** CSystem::SendActionStatusInstances...", 4);

	iSize = m_actionList.size();
	for (i = 0; i < iSize; i++)
	{
		MY_ASSERT(i<m_actionList.size());
		pAction = m_actionList[i];
		pAction->SendHMActionStatusInstances(pSink);
	}

	MY_OUTPUT(L"EXIT ***** CSystem::SendActionStatusInstances...", 4);
	return hRetRes;
}

HRESULT CSystem::SendHMActionStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	HRESULT hRetRes = S_OK;
	int i;
	int iSize;
	CAction *pAction;

	MY_OUTPUT(L"ENTER ***** CSystem::SendHMActionStatusInstance...", 4);
	MY_OUTPUT2(L"ActionStatus send for GUID=%s", pszGUID, 4);

	iSize = m_actionList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_actionList.size());
		pAction = m_actionList[i];
		hRetRes = pAction->SendHMActionStatusInstance(pSink, pszGUID);
		if (hRetRes==S_OK)
		{
			break;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			break;
		}
	}

	if (hRetRes==WBEM_S_DIFFERENT)
	{
		hRetRes = WBEM_E_NOT_FOUND;
		MY_OUTPUT(L"GUID not found", 4);
	}

	MY_OUTPUT(L"EXIT ***** CSystem::SendHMActionStatusInstance...", 4);
	return hRetRes;
}

BOOL CSystem::FireEvents(void)
{
	IWbemClassObject* pInstance = NULL;
	int i, iSize;

	// Send the System event
	FireEvent();

	//
	// Loop through the DataGroup Events and send them as one indicate
	//
	iSize = mg_DGEventList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<mg_DGEventList.size());
		pInstance = mg_DGEventList[i];
		SendEvents(g_pDataGroupEventSink, &pInstance, 1);
    	pInstance->Release();
	}
	mg_DGEventList.clear();

	//
	// Loop through the DataCollector Events and send them as one indicate
	//
	iSize = mg_DCEventList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<mg_DCEventList.size());
		pInstance = mg_DCEventList[i];
		SendEvents(g_pDataCollectorEventSink, &pInstance, 1);
    	pInstance->Release();
	}
	mg_DCEventList.clear();

	//
	// Loop through the DataCollector PerInstance Events and send them as one indicate
	//
	iSize = mg_DCPerInstanceEventList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<mg_DCPerInstanceEventList.size());
		pInstance = mg_DCPerInstanceEventList[i];
		SendEvents(g_pDataCollectorPerInstanceEventSink, &pInstance, 1);
    	pInstance->Release();
	}
	mg_DCPerInstanceEventList.clear();

	//
	// Loop through the Threshold Events and send them as one indicate
	//
	iSize = mg_TEventList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<mg_TEventList.size());
		pInstance = mg_TEventList[i];
		SendEvents(g_pThresholdEventSink, &pInstance, 1);
    	pInstance->Release();
	}
	mg_TEventList.clear();

	//
	// Loop through the ThresholdInstance Events and send them as one indicate
	//
//	iSize = mg_TIEventList.size();
//	for (i=0; i < iSize; i++)
//	{
//		MY_ASSERT(i<mg_TIEventList.size());
//		pInstance = mg_TIEventList[i];
//		SendEvents(g_pThresholdInstanceEventSink, &pInstance, 1);
//    	pInstance->Release();
//	}
//	mg_TIEventList.clear();

	//
	// Loop through the DataCollectorStatistics Events and send them as one indicate
	//
	iSize = mg_DCStatsEventList.size();
MY_ASSERT(iSize==0);
#ifdef SAVE
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<mg_DCStatsEventList.size());
		pInstance = mg_DCStatsEventList[i];
		SendEvents(g_pDataCollectorStatisticsEventSink, &pInstance, 1);
    	pInstance->Release();
	}
	mg_DCStatsEventList.clear();
#endif

#ifdef SAVE
XXX
//    IWbemClassObject** aObjects;
Need to wait for the Whistler fix for sending multiple objects with one Indicate
	//
	// Loop through the DataGroup Events and send them as one indicate
	//
	iSize = mg_DGEventList.size();
    aObjects = new IWbemClassObject*[iSize];
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<mg_DGEventList.size());
		pInstance = mg_DGEventList[i];
    	aObjects[i] = pInstance;
	}
	SendEvents(g_pDataGroupEventSink, aObjects, iSize);
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<mg_DGEventList.size());
		pInstance = mg_DGEventList[i];
    	pInstance->Release();
	}
	mg_DGEventList.clear();
    delete [] aObjects;
	.
	.
	.

#endif

	return TRUE;
}

//
// If there has been a change in the state then send an event
//
BOOL CSystem::FireEvent(void)
{
	HRESULT hRes;
	BOOL bRetValue = TRUE;
	IWbemClassObject* pInstance = NULL;

	MY_OUTPUT(L"ENTER ***** CSystem::FireEvent...", 2);

	// Don't send if no-one is listening!
	if (g_pSystemEventSink == NULL)
	{
		return bRetValue;
	}

	// A quick test to see if anything has really changed!
	// Proceed if there have been changes
	if (m_lNumberChanges!=0 && m_lPrevState!=m_lCurrState)
	{
	}
	else
	{
		return FALSE;
	}

	// Update time if there has been a change
	wcscpy(m_szDTTime, m_szDTCurrTime);
	wcscpy(m_szTime, m_szCurrTime);

	hRes = GetHMSystemStatusInstance(&pInstance, TRUE);
	if (SUCCEEDED(hRes) && g_pSystemEventSink)
	{
		MY_OUTPUT2(L"EVENT: System State Change=%d", m_lCurrState, 4);
		hRes = g_pSystemEventSink->Indicate(1, &pInstance);
		// WBEM_E_SERVER_TOO_BUSY is Ok. Wbem will deliver.
		if (FAILED(hRes) && hRes != WBEM_E_SERVER_TOO_BUSY)
		{
			MY_HRESASSERT(hRes);
			bRetValue = FALSE;
			MY_OUTPUT(L"Failed on Indicate!", 4);
		}

		pInstance->Release();
		pInstance = NULL;
	}
	else
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT(L"failed to get instance!", 4);
	}

	MY_OUTPUT(L"EXIT ***** CSystem::FireEvent...", 2);
	return bRetValue;
}

HRESULT CSystem::GetHMSystemStatusInstance(IWbemClassObject** ppInstance, BOOL bEventBased)
{
	TCHAR szTemp[1024];
	IWbemClassObject* pClass = NULL;
	BSTR bsString = NULL;
	HRESULT hRetRes;

	MY_OUTPUT(L"ENTER ***** GetHMSystemStatusInstance...", 1);

	if (bEventBased)
		bsString = SysAllocString(L"MicrosoftHM_SystemStatusEvent");
	else
		bsString = SysAllocString(L"MicrosoftHM_SystemStatus");
	MY_ASSERT(bsString); if (!bsString) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	hRetRes = g_pIWbemServices->GetObject(bsString, 0L, NULL, &pClass, NULL);
	SysFreeString(bsString);
	bsString = NULL;

	if (FAILED(hRetRes))
	{
		MY_HRESASSERT(hRetRes);
		MY_OUTPUT2(L"CSystem::GetHMSystemStatusInstance()-Couldn't get HMSystemStatusInstance Error: 0x%08x",hRetRes,4);
		return hRetRes;
	}

	hRetRes = pClass->SpawnInstance(0, ppInstance);
	pClass->Release();
	pClass = NULL;

	if (FAILED(hRetRes))
	{
		MY_HRESASSERT(hRetRes);
		MY_OUTPUT2(L"CSystem::GetHMSystemStatusInstance()-Couldn't get HMSystemStatusInstance Error: 0x%08x",hRetRes,4);
		return hRetRes;
	}

	if (m_bValidLoad == FALSE)
	{
		hRetRes = PutStrProperty(*ppInstance, L"GUID", L"{@}");
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = PutUint32Property(*ppInstance, L"State", HM_CRITICAL);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_SYSTEM_LOADFAIL, szTemp, 1024))
		{
			wcscpy(szTemp, L"System failed to load.");
		}
		hRetRes = PutStrProperty(*ppInstance, L"Message", szTemp);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
hRetRes = PutStrProperty(*ppInstance, L"Name", L"...");
MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}
	else
	{
		hRetRes = PutStrProperty(*ppInstance, L"GUID", L"{@}");
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		// Get the computer name of the machine
		DWORD dwNameLen = MAX_COMPUTERNAME_LENGTH + 1;
		TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];

		if (GetComputerName(szComputerName, &dwNameLen))
		{
			hRetRes = PutStrProperty(*ppInstance, L"Name", szComputerName);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			hRetRes = PutStrProperty(*ppInstance, L"SystemName", szComputerName);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		}
		else
		{
			hRetRes = PutStrProperty(*ppInstance, L"Name", L"LocalMachine");
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			hRetRes = PutStrProperty(*ppInstance, L"SystemName", L"LocalMachine");
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		}
		hRetRes = PutStrProperty(*ppInstance, L"TimeGeneratedGMT", m_szDTTime);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = PutStrProperty(*ppInstance, L"LocalTimeFormatted", m_szTime);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = PutUint32Property(*ppInstance, L"State", m_lCurrState);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		if (m_lCurrState != HM_GOOD)
		{
			hRetRes = PutStrProperty(*ppInstance, L"Message", m_szMessage);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		}
		else
		{
			hRetRes = PutStrProperty(*ppInstance, L"Message", m_szResetMessage);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		}
		FormatMessage(*ppInstance);
	}

	MY_OUTPUT(L"EXIT ***** GetHMSystemStatusInstance...", 1);
	return hRetRes;

error:
	MY_ASSERT(FALSE);
	if (bsString)
		SysFreeString(bsString);
	if (pClass)
		pClass->Release();
	return hRetRes;
}

HRESULT CSystem::ModSystem(IWbemClassObject* pObj)
{
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** CSystem::ModSystem...", 4);

	// Re-load
	hRetRes = LoadInstanceFromMOF(pObj);

	MY_OUTPUT(L"EXIT ***** CSystem::ModSystem...", 4);
	return hRetRes;
}

HRESULT CSystem::ModDataGroup(IWbemClassObject* pObj)
{
	HRESULT hRes;
	HRESULT hRetRes = WBEM_E_NOT_FOUND;
	int i, iSize;
	VARIANT	v;
	CDataGroup* pDataGroup;

	MY_OUTPUT(L"ENTER ***** CSystem::ModDataGroup...", 4);

	VariantInit(&v);
	hRes = pObj->Get(L"GUID", 0L, &v, 0L, 0L);
	if (FAILED(hRes))
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT(L"ENTER ***** CSystem::ModDataGroup-Unexpected Error!...", 4);
		VariantClear(&v);
		return hRes;
	}
	
	MY_OUTPUT2(L"DG mod for GUID=%s", V_BSTR(&v), 4);

	//
	// Search right under the System to find the DataGroup.
	// If don't find, drill down until we do.
	//
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		hRetRes = pDataGroup->FindAndModDataGroup(V_BSTR(&v), pObj);
		if (hRetRes==S_OK)
		{
			break;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			break;
		}
	}
	VariantClear(&v);

	if (hRetRes==WBEM_S_DIFFERENT)
	{
		hRetRes = WBEM_E_NOT_FOUND;
		MY_OUTPUT(L"GUID not found", 4);
	}
	else
	{
		MY_OUTPUT(L"Found", 4);
	}
	MY_OUTPUT(L"EXIT ***** CSystem::ModDataGroup...", 4);
	return hRetRes;
}

HRESULT CSystem::ModDataCollector(IWbemClassObject* pObj)
{
	HRESULT hRes;
	HRESULT hRetRes = WBEM_E_NOT_FOUND;
	int i, iSize;
	VARIANT	v;
	CDataGroup* pDataGroup;

	MY_OUTPUT(L"ENTER ***** CSystem::ModDataCollector...", 4);

	VariantInit(&v);
	hRes = pObj->Get(L"GUID", 0L, &v, 0L, 0L);
	if (FAILED(hRes))
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT(L"ENTER ***** CSystem::ModDataCollector-Unexpected Error!...", 4);
		VariantClear(&v);
		return hRes;
	}

	MY_OUTPUT2(L"DC mod for GUID=%s", V_BSTR(&v), 4);
	
	//
	// Search right under the System to find the DataGroup.
	// If don't find, drill down until we do.
	//
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		hRetRes = pDataGroup->FindAndModDataCollector(V_BSTR(&v), pObj);
		if (hRetRes==S_OK)
		{
			break;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			break;
		}
	}
	VariantClear(&v);

	if (hRetRes==WBEM_S_DIFFERENT)
	{
		hRetRes = WBEM_E_NOT_FOUND;
		MY_OUTPUT(L"GUID not found", 4);
	}
	else
	{
		MY_OUTPUT(L"Found", 4);
	}
	MY_OUTPUT(L"EXIT ***** CSystem::ModDataCollector...", 4);
	return hRetRes;
}

HRESULT CSystem::ModThreshold(IWbemClassObject* pObj)
{
	HRESULT hRes;
	HRESULT hRetRes = WBEM_E_NOT_FOUND;
	int i, iSize;
	VARIANT	v;
	CDataGroup* pDataGroup;

	MY_OUTPUT(L"ENTER ***** CSystem::ModThreshold...", 4);

	VariantInit(&v);
	hRes = pObj->Get(L"GUID", 0L, &v, 0L, 0L);
	if (FAILED(hRes))
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT(L"ENTER ***** CSystem::ModThreshold-Unexpected Error!...", 4);
		VariantClear(&v);
		return hRes;
	}

	MY_OUTPUT2(L"Threshold mod for GUID=%s", V_BSTR(&v), 4);
	
	//
	// Search right under the System to find the DataGroup.
	// If don't find, drill down until we do.
	//
	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		hRetRes = pDataGroup->FindAndModThreshold(V_BSTR(&v), pObj);
		if (hRetRes==S_OK)
		{
			break;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			break;
		}
	}
	VariantClear(&v);

	if (hRetRes==WBEM_S_DIFFERENT)
	{
		hRetRes = WBEM_E_NOT_FOUND;
		MY_OUTPUT(L"GUID not found", 4);
	}
	else
	{
		MY_OUTPUT(L"Found", 4);
	}
	MY_OUTPUT(L"EXIT ***** CSystem::ModThreshold...", 4);
	return hRetRes;
}

HRESULT CSystem::ModAction(IWbemClassObject* pObj)
{
	HRESULT hRes;
	HRESULT hRetRes = WBEM_E_NOT_FOUND;
	int i, iSize;
	VARIANT	v;
	CAction* pAction;

	MY_OUTPUT(L"ENTER ***** CSystem::ModAction...", 4);

	VariantInit(&v);
	hRes = pObj->Get(L"GUID", 0L, &v, 0L, 0L);
	if (FAILED(hRes))
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT(L"ENTER ***** CSystem::ModAction-Unexpected Error!...", 4);
		VariantClear(&v);
		return hRes;
	}

	MY_OUTPUT2(L"Action mod for GUID=%s", V_BSTR(&v), 4);
	
	//
	// Search right under the System to find the Action.
	// If don't find, drill down until we do.
	//
	iSize = m_actionList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_actionList.size());
		pAction = m_actionList[i];
		hRetRes = pAction->FindAndModAction(V_BSTR(&v), pObj);
		if (hRetRes==S_OK)
		{
			break;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			break;
		}
	}
	VariantClear(&v);

	if (hRetRes==WBEM_S_DIFFERENT)
	{
		hRetRes = WBEM_E_NOT_FOUND;
		MY_OUTPUT(L"GUID not found", 4);
	}
	else
	{
		MY_OUTPUT(L"Found", 4);
	}
	MY_OUTPUT(L"EXIT ***** CSystem::ModAction...", 4);
	return hRetRes;
}

BOOL CSystem::CreateActionAssociation(IWbemClassObject* pObj)
{
	TCHAR szGUID[1024];
	LPTSTR pStr;
	LPTSTR pStr2;
	HRESULT hRes;
	BOOL bRetValue = TRUE;
	int i, iSize;
	VARIANT	v;
	CAction* pAction;

	MY_OUTPUT(L"ENTER ***** CSystem::CreateActionAssociation...", 4);

	VariantInit(&v);
	hRes = pObj->Get(L"ChildPath", 0L, &v, 0L, 0L);
	if (FAILED(hRes))
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT(L"ENTER ***** CSystem::CreateActionAssociation-Unexpected Error!...", 4);
		VariantClear(&v);
		return FALSE;
	}

	// Get the Action GUID from the path
	wcscpy(szGUID, V_BSTR(&v));
	pStr = wcschr(szGUID, '\"');
	if (pStr)
	{
		pStr++;
		pStr2 = wcschr(pStr, '\"');
		if (pStr2)
		{
			*pStr2 = '\0';
			//
			// Find the Action and add the new association
			//
			iSize = m_actionList.size();
			for (i = 0; i < iSize ; i++)
			{
				MY_ASSERT(i<m_actionList.size());
				pAction = m_actionList[i];
				bRetValue = pAction->FindAndCreateActionAssociation(pStr, pObj);
				if (bRetValue)
				{
					break;
				}
			}
		}
	}
	VariantClear(&v);

	MY_OUTPUT(L"EXIT ***** CSystem::CreateActionAssociation...", 4);
	return bRetValue;
}

BOOL CSystem::ModActionAssociation(IWbemClassObject* pObj)
{
	TCHAR szGUID[1024];
	LPTSTR pStr;
	LPTSTR pStr2;
	HRESULT hRes;
	BOOL bRetValue = TRUE;
	int i, iSize;
	VARIANT	v;
	CAction* pAction;

	MY_OUTPUT(L"ENTER ***** CSystem::ModActionAssociation...", 4);

	VariantInit(&v);
	hRes = pObj->Get(L"ChildPath", 0L, &v, 0L, 0L);
	if (FAILED(hRes))
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT(L"ENTER ***** CSystem::ModActionAssociation-Unexpected Error!...", 4);
		VariantClear(&v);
		return FALSE;
	}

	// Get the Action GUID from the path
	wcscpy(szGUID, V_BSTR(&v));
	pStr = wcschr(szGUID, '\"');
	if (pStr)
	{
		pStr++;
		pStr2 = wcschr(pStr, '\"');
		if (pStr2)
		{
			*pStr2 = '\0';
			//
			// Find the Action and modify the association
			//
			iSize = m_actionList.size();
			for (i = 0; i < iSize ; i++)
			{
				MY_ASSERT(i<m_actionList.size());
				pAction = m_actionList[i];
				bRetValue = pAction->FindAndModActionAssociation(pStr, pObj);
				if (bRetValue)
				{
					break;
				}
			}
		}
	}
	VariantClear(&v);

	MY_OUTPUT(L"EXIT ***** CSystem::ModActionAssociation...", 4);
	return bRetValue;
}

HRESULT CSystem::CreateSystemDataGroupAssociation(IWbemClassObject* pObj)
{
	int i, iSize;
	TCHAR szTemp[1024];
	VARIANT	v;
	BOOL bFound;
	HRESULT hRetRes = S_OK;
	CDataGroup* pDG = NULL;
	CDataGroup* pDataGroup = NULL;
	BOOL bRetValue = TRUE;
	TCHAR szGUID[1024];
	LPTSTR pStr = NULL;
	LPTSTR pStr2 = NULL;
	BSTR Path = NULL;
	IWbemClassObject* pObj2 = NULL;
	LPTSTR pszTempGUID = NULL;

	MY_OUTPUT(L"ENTER ***** CSystem::CreateSystemDataGroupAssociation...", 4);

	//
	// Get the name of the child DataGroup
	//
	VariantInit(&v);
	hRetRes = pObj->Get(L"ChildPath", 0L, &v, 0L, 0L);
	MY_HRESASSERT(hRetRes); if (hRetRes != S_OK) goto error;


	wcscpy(szGUID, V_BSTR(&v));
	pStr = wcschr(szGUID, '\"');
	if (pStr)
	{
		pStr++;
		pStr2 = wcschr(pStr, '\"');
		if (pStr2)
		{
			*pStr2 = '\0';

			//
			// First make sure it is not in there already!
			//
			bFound = FALSE;
			iSize = m_dataGroupList.size();
			for (i = 0; i < iSize ; i++)
			{
				MY_ASSERT(i<m_dataGroupList.size());
				pDataGroup = m_dataGroupList[i];
				if (!_wcsicmp(pStr, pDataGroup->GetGUID()))
				{
					bFound = TRUE;
					break;
				}
			}

			MY_OUTPUT2(L"Association DG to System DGGUID=%s", pStr, 4);
			if (bFound == FALSE)
			{
				MY_OUTPUT(L"OK: Not found yet", 4);
				//
				// Add in the DataGroup. Everything below will follow.
				//
				wcscpy(szTemp, L"MicrosoftHM_DataGroupConfiguration.GUID=\"");
				lstrcat(szTemp, pStr);
				lstrcat(szTemp, L"\"");
				Path = SysAllocString(szTemp);
				MY_ASSERT(Path); if (!Path) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

				hRetRes = GetWbemObjectInst(&g_pIWbemServices, Path, NULL, &pObj2);
//XXXGet back an HRESULT and then return that
				MY_ASSERT(pObj2); if (!pObj2) {hRetRes = S_FALSE; goto error;}

				// See if this is already read in. Need to prevent endless loop, circular references.
				hRetRes = GetStrProperty(pObj2, L"GUID", &pszTempGUID);
				MY_ASSERT(hRetRes==S_OK); if (hRetRes!= S_OK) goto error;
				if (!g_pStartupSystem->FindPointerFromGUIDInMasterList(pszTempGUID))
				{
					//
					// Create the internal class to represent the DataGroup
					//
					pDG = new CDataGroup;
					MY_ASSERT(pDG); if (!pDG) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
					hRetRes = pDG->LoadInstanceFromMOF(pObj2, NULL, m_szGUID);
					if (hRetRes==S_OK)
					{
						m_dataGroupList.push_back(pDG);
						pDG->SetParentEnabledFlag(m_bEnabled);
					}
					else
					{
						MY_HRESASSERT(hRetRes);
						pDG->DeleteDGInternal();
						delete pDG;
						pDG = NULL;
					}
				}
				delete [] pszTempGUID;
				pszTempGUID = NULL;
				pObj2->Release();
				pObj2 = NULL;
				SysFreeString(Path);
				Path = NULL;
			}
			else
			{
				MY_OUTPUT(L"WHY?: Already there!", 4);
			}
		}
	}

	VariantClear(&v);

	MY_OUTPUT(L"EXIT ***** CSystem::CreateSystemDataGroupAssociation...", 4);
	return hRetRes;

error:
	MY_HRESASSERT(hRetRes);
	VariantClear(&v);
	if (Path)
		SysFreeString(Path);
	if (pObj2)
		pObj2->Release();
	if (pDG)
		delete pDG;
	if (pszTempGUID)
		delete [] pszTempGUID;

	return hRetRes;
}

HRESULT CSystem::CreateDataGroupDataGroupAssociation(IWbemClassObject* pObj)
{
	VARIANT	vParent;
	VARIANT	vChild;
	TCHAR szChildGUID[1024];
	DGLIST::iterator iaDG;
	int i, iSize;
	HRESULT hRetRes = S_OK;
	CDataGroup* pDataGroup = NULL;
	TCHAR szParentGUID[1024];
	LPTSTR pParentStr = NULL;
	LPTSTR pParentStr2 = NULL;
	LPTSTR pChildStr = NULL;
	LPTSTR pChildStr2 = NULL;
	VariantInit(&vParent);
	VariantInit(&vChild);

	MY_OUTPUT(L"ENTER ***** CSystem::CreateDataGroupDataGroupAssociation...", 4);

	//
	// Get the name of the parent DataGroup
	//
	hRetRes = pObj->Get(L"ParentPath", 0L, &vParent, 0L, 0L);
	MY_HRESASSERT(hRetRes); if (hRetRes != S_OK) goto error;

	//
	// Get the name of the child DataGroup
	//
	hRetRes = pObj->Get(L"ChildPath", 0L, &vChild, 0L, 0L);
	MY_HRESASSERT(hRetRes); if (hRetRes != S_OK) goto error;

	wcscpy(szChildGUID, V_BSTR(&vChild));
	pChildStr = wcschr(szChildGUID, '\"');
	if (pChildStr)
	{
		pChildStr++;
		pChildStr2 = wcschr(pChildStr, '\"');
		if (pChildStr2)
		{
			*pChildStr2 = '\0';
			wcscpy(szParentGUID, V_BSTR(&vParent));
			pParentStr = wcschr(szParentGUID, '\"');
			if (pParentStr)
			{
				pParentStr++;
				pParentStr2 = wcschr(pParentStr, '\"');
				if (pParentStr2)
				{
					*pParentStr2 = '\0';
					//
					// Add the DataGroup, it will add everything under itself
					//
					MY_OUTPUT2(L"Association DG to DG ParentGUID=%s", pParentStr, 4);
					MY_OUTPUT2(L"ChildGUID=%s", pChildStr, 4);
					iSize = m_dataGroupList.size();
					iaDG=m_dataGroupList.begin();
					for (i = 0; i < iSize ; i++, iaDG++)
					{
						MY_ASSERT(i<m_dataGroupList.size());
						pDataGroup = m_dataGroupList[i];
						hRetRes = pDataGroup->AddDataGroup(pParentStr, pChildStr);
						if (hRetRes==S_OK)
						{
							break;
						}
						else if (hRetRes!=WBEM_S_DIFFERENT)
						{
//							MY_HRESASSERT(hRetRes);
							break;
						}
					}
				}
			}
		}
	}

	VariantClear(&vParent);
	VariantClear(&vChild);

	MY_OUTPUT(L"EXIT ***** CSystem::CreateDataGroupDataGroupAssociation...", 4);
	return hRetRes;

error:
	MY_HRESASSERT(hRetRes);
	VariantClear(&vParent);
	VariantClear(&vChild);
	return hRetRes;
}

HRESULT CSystem::CreateDataGroupDataCollectorAssociation(IWbemClassObject* pObj)
{
	VARIANT	vParent;
	VARIANT	vChild;
	int i, iSize;
	TCHAR szParentGUID[1024];
	DGLIST::iterator iaDG;
	HRESULT hRetRes = S_OK;
	CDataGroup* pDataGroup = NULL;
	LPTSTR pParentStr = NULL;
	LPTSTR pParentStr2 = NULL;
	TCHAR szChildGUID[1024];
	LPTSTR pChildStr = NULL;
	LPTSTR pChildStr2 = NULL;
	VariantInit(&vParent);
	VariantInit(&vChild);

	MY_OUTPUT(L"ENTER ***** CSystem::CreateDataGroupDataCollectorAssociation...", 4);

	//
	// Get the name of the parent DataGroup
	//
	hRetRes = pObj->Get(L"ParentPath", 0L, &vParent, 0L, 0L);
	MY_HRESASSERT(hRetRes); if (hRetRes != S_OK) goto error;

	//
	// Get the name of the child DataGroup
	//
	hRetRes = pObj->Get(L"ChildPath", 0L, &vChild, 0L, 0L);
	MY_HRESASSERT(hRetRes); if (hRetRes != S_OK) goto error;


	wcscpy(szChildGUID, V_BSTR(&vChild));
	pChildStr = wcschr(szChildGUID, '\"');
	if (pChildStr)
	{
		pChildStr++;
		pChildStr2 = wcschr(pChildStr, '\"');
		if (pChildStr2)
		{
			*pChildStr2 = '\0';
			wcscpy(szParentGUID, V_BSTR(&vParent));
			pParentStr = wcschr(szParentGUID, '\"');
			if (pParentStr)
			{
				pParentStr++;
				pParentStr2 = wcschr(pParentStr, '\"');
				if (pParentStr2)
				{
					*pParentStr2 = '\0';
					//
					// Add the DataGroup, it will add everything under itself
					//
					MY_OUTPUT2(L"Association DC to DG ParentDGGUID=%s", pParentStr, 4);
					MY_OUTPUT2(L"ChildDCGUID=%s", pChildStr, 4);
					iSize = m_dataGroupList.size();
					iaDG=m_dataGroupList.begin();
					for (i = 0; i < iSize ; i++, iaDG++)
					{
						MY_ASSERT(i<m_dataGroupList.size());
						pDataGroup = m_dataGroupList[i];
						hRetRes = pDataGroup->AddDataCollector(pParentStr, pChildStr);
						if (hRetRes==S_OK)
						{
							break;
						}
						else if (hRetRes!=WBEM_S_DIFFERENT)
						{
//							MY_HRESASSERT(hRetRes);
							break;
						}
					}
				}
			}
		}
	}

	VariantClear(&vParent);
	VariantClear(&vChild);

	MY_OUTPUT(L"EXIT ***** CSystem::CreateDataGroupDataCollectorAssociation...", 4);
	return hRetRes;

error:
	MY_HRESASSERT(hRetRes);
	VariantClear(&vParent);
	VariantClear(&vChild);
	return hRetRes;
}

HRESULT CSystem::CreateDataCollectorThresholdAssociation(IWbemClassObject* pObj)
{
	VARIANT	vParent;
	VARIANT	vChild;
	int i, iSize;
	TCHAR szChildGUID[1024];
	DGLIST::iterator iaDG;
	HRESULT hRetRes = S_OK;
	CDataGroup* pDataGroup = NULL;
	TCHAR szParentGUID[1024];
	LPTSTR pParentStr = NULL;
	LPTSTR pParentStr2 = NULL;
	LPTSTR pChildStr = NULL;
	LPTSTR pChildStr2 = NULL;
	VariantInit(&vParent);
	VariantInit(&vChild);

	MY_OUTPUT(L"ENTER ***** CSystem::CreateDataCollectorThresholdAssociation...", 4);

	//
	// Get the name of the parent DataGroup
	//
	hRetRes = pObj->Get(L"ParentPath", 0L, &vParent, 0L, 0L);
	MY_HRESASSERT(hRetRes); if (hRetRes != S_OK) goto error;

	//
	// Get the name of the child DataGroup
	//
	hRetRes = pObj->Get(L"ChildPath", 0L, &vChild, 0L, 0L);
	MY_HRESASSERT(hRetRes); if (hRetRes != S_OK) goto error;

	wcscpy(szChildGUID, V_BSTR(&vChild));
	pChildStr = wcschr(szChildGUID, '\"');
	if (pChildStr)
	{
		pChildStr++;
		pChildStr2 = wcschr(pChildStr, '\"');
		if (pChildStr2)
		{
			*pChildStr2 = '\0';
			wcscpy(szParentGUID, V_BSTR(&vParent));
			pParentStr = wcschr(szParentGUID, '\"');
			if (pParentStr)
			{
				pParentStr++;
				pParentStr2 = wcschr(pParentStr, '\"');
				if (pParentStr2)
				{
					*pParentStr2 = '\0';
					//
					// Add the DataGroup, it will add everything under itself
					//
					MY_OUTPUT2(L"Association Threshold to DC ParentDCGUID=%s", pParentStr, 4);
					MY_OUTPUT2(L"ChildThreshGUID=%s", pChildStr, 4);
					iSize = m_dataGroupList.size();
					iaDG=m_dataGroupList.begin();
					for (i = 0; i < iSize ; i++, iaDG++)
					{
						MY_ASSERT(i<m_dataGroupList.size());
						pDataGroup = m_dataGroupList[i];
						hRetRes = pDataGroup->AddThreshold(pParentStr, pChildStr);
						if (hRetRes==S_OK)
						{
							break;
						}
						else if (hRetRes!=WBEM_S_DIFFERENT)
						{
//							MY_HRESASSERT(hRetRes);
							break;
						}
					}
				}
			}
		}
	}

	VariantClear(&vParent);
	VariantClear(&vChild);

	MY_OUTPUT(L"EXIT ***** CSystem::CreateDataCollectorThresholdAssociation...", 4);
	return hRetRes;

error:
	MY_HRESASSERT(hRetRes);
	VariantClear(&vParent);
	VariantClear(&vChild);
	return hRetRes;
}

BOOL CSystem::ResetResetThresholdStates(void)
{
	BOOL bRetValue = TRUE;
	int i;
	int iSize;
	CDataGroup *pDataGroup;

	iSize = m_dataGroupList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		pDataGroup->ResetResetThresholdStates();
	}

	return bRetValue;
}

BOOL CSystem::GetChange(void)
{
	if (m_lNumberChanges!=0 && m_lPrevState!=m_lCurrState)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

//
// Called By the Delete method that the HMSystemConfiguration class exposes.
// Code ends up in the methprov.pp file, then gets passed here.
// We could have done method providers on the instance basis, and then we would have
// delete called for a specifric instance, but instead we chose to have a global
// static class wide function, that appies to all objects in our hierarchy,
// so you must pass in the GUID of what you want deleted, and then we search for it.
//
//
//XXXOptomize this and other similar code by creating an access array that contains
// OR hash table that contains all the GUIDs and pointers to the classes, so can go directly
// to the object and delete it. Actually probably need to go to its parent to delete it,
// as it needs to get it out of its list.
HRESULT CSystem::FindAndDeleteByGUID(LPTSTR pszGUID)
{
	BOOL bDeleted = FALSE;
	int i, iSize;
	CDataGroup* pDataGroup;
	DGLIST::iterator iaDG;
	CAction* pAction;
	ALIST::iterator iaA;

	MY_OUTPUT(L"ENTER ***** CSystem::FindAndDeleteByGUID...", 4);
	MY_OUTPUT2(L"FIND DELETION: GUID=%s", pszGUID, 4);

	//
	// Traverse the complete hierarchy to find the object to delete.
	//
	iSize = m_dataGroupList.size();
	iaDG=m_dataGroupList.begin();
	for (i=0; i<iSize; i++, iaDG++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		if (!_wcsicmp(pszGUID, pDataGroup->GetGUID()))
		{
			pDataGroup->DeleteDGConfig();
			delete pDataGroup;
			m_dataGroupList.erase(iaDG);
			bDeleted = TRUE;
			MY_OUTPUT2(L"DELETION: DGGUID=%s", pszGUID, 4);
			break;
		}
		// Look at branch below to see if can find it
		if (pDataGroup->FindAndDeleteByGUID(pszGUID)==S_OK)
		{
			bDeleted = TRUE;
			break;
		}
	}

	//
	// Traverse through the actions also to see if that is what we were suppose to delete.
	//
	if (bDeleted == FALSE)
	{
		iSize = m_actionList.size();
		iaA=m_actionList.begin();
		for (i=0; i<iSize; i++, iaA++)
		{
			MY_ASSERT(i<m_actionList.size());
			pAction = m_actionList[i];
			if (!_wcsicmp(pszGUID, pAction->GetGUID()))
			{
				pAction->DeleteAConfig();
				delete pAction;
				m_actionList.erase(iaA);
				bDeleted = TRUE;
				MY_OUTPUT2(L"DELETION: AGUID=%s", pszGUID, 4);
				break;
			}
		}
	}

	if (bDeleted == FALSE)
	{
		MY_OUTPUT(L"GUID not found", 4);
		MY_OUTPUT(L"EXIT ***** CSystem::FindAndDeleteByGUID...", 4);
		return WBEM_E_NOT_FOUND;
	}
	else
	{
		MY_OUTPUT(L"EXIT ***** CSystem::FindAndDeleteByGUID...", 4);
		return S_OK;
	}
}

//
// HMSystemConfiguration class exposes this method.
// Code ends up in the methprov.pp file, then gets passed here.
//
HRESULT CSystem::FindAndResetDEStateByGUID(LPTSTR pszGUID)
{
	BOOL bFound = FALSE;
	int i, iSize;
	CDataGroup* pDataGroup;

	MY_OUTPUT(L"ENTER ***** CSystem::FindAndResetDEStateByGUID...", 4);
	MY_OUTPUT2(L"FIND RESET: GUID=%s", pszGUID, 4);

	if (!wcscmp(L"{@}", pszGUID))
	{
		bFound = TRUE;
		//
		// Do reset of EVERYTHING
		//
		iSize = m_dataGroupList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_dataGroupList.size());
			pDataGroup = m_dataGroupList[i];
			pDataGroup->ResetState();
		}
	}
	else
	{
		//
		// Traverse the complete hierarchy to find the object to reset state.
		//
		iSize = m_dataGroupList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_dataGroupList.size());
			pDataGroup = m_dataGroupList[i];
			if (!_wcsicmp(pszGUID, pDataGroup->GetGUID()))
			{
				pDataGroup->ResetState();
				bFound = TRUE;
				MY_OUTPUT(L"DG Found and reset", 4);
				break;
			}
			// Look at branch below to see if can find it
			if (pDataGroup->FindAndResetDEStateByGUID(pszGUID)==S_OK)
			{
				bFound = TRUE;
				break;
			}
		}
	}

	if (bFound == FALSE)
	{
		MY_OUTPUT(L"GUID not found", 4);
		MY_OUTPUT(L"EXIT ***** CSystem::FindAndResetDEStateByGUID...", 4);
		return WBEM_E_NOT_FOUND;
	}
	else
	{
		MY_OUTPUT(L"EXIT ***** CSystem::FindAndResetDEStateByGUID...", 4);
		return S_OK;
	}
}

//
// HMSystemConfiguration class exposes this method.
// Code ends up in the methprov.pp file, then gets passed here.
//
HRESULT CSystem::FindAndResetDEStatisticsByGUID(LPTSTR pszGUID)
{
	BOOL bFound = FALSE;
	int i, iSize;
	CDataGroup* pDataGroup;

	MY_OUTPUT(L"ENTER ***** CSystem::FindAndResetDEStatisticsByGUID...", 4);
	MY_OUTPUT2(L"FIND RESET STATISTICS: GUID=%s", pszGUID, 4);

	if (!wcscmp(L"{@}", pszGUID))
	{
		bFound = TRUE;
		//
		// Do reset of EVERYTHING
		//
		iSize = m_dataGroupList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_dataGroupList.size());
			pDataGroup = m_dataGroupList[i];
			pDataGroup->ResetStatistics();
		}
	}
	else
	{
		//
		// Traverse the complete hierarchy to find the object to reset statistics.
		//
		iSize = m_dataGroupList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_dataGroupList.size());
			pDataGroup = m_dataGroupList[i];
			if (!_wcsicmp(pszGUID, pDataGroup->GetGUID()))
			{
				pDataGroup->ResetStatistics();
				bFound = TRUE;
				MY_OUTPUT(L"DG found and reset statistics", 4);
				break;
			}
			// Look at branch below to see if can find it
			if (pDataGroup->FindAndResetDEStatisticsByGUID(pszGUID)==S_OK)
			{
				bFound = TRUE;
				break;
			}
		}
	}

	if (bFound == FALSE)
	{
		MY_OUTPUT(L"GUID not found", 4);
		MY_OUTPUT(L"EXIT ***** CSystem::FindAndResetDEStatisticsByGUID...", 4);
		return WBEM_E_NOT_FOUND;
	}
	else
	{
		MY_OUTPUT(L"EXIT ***** CSystem::FindAndResetDEStatisticsByGUID...", 4);
		return S_OK;
	}
}

//
// HMSystemConfiguration class exposes this method.
// Code ends up in the methprov.pp file, then gets passed here.
//
HRESULT CSystem::FindAndEvaluateNowDEByGUID(LPTSTR pszGUID)
{
	BOOL bFound = FALSE;
	int i, iSize;
	CDataGroup* pDataGroup;

	MY_OUTPUT(L"ENTER ***** CSystem::FindAndEvaluateNowByGUID...", 4);
	MY_OUTPUT2(L"FIND RESET STATISTICS: GUID=%s", pszGUID, 4);

	if (!wcscmp(L"{@}", pszGUID))
	{
		bFound = TRUE;
		//
		// Do reset of EVERYTHING
		//
		iSize = m_dataGroupList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_dataGroupList.size());
			pDataGroup = m_dataGroupList[i];
			pDataGroup->EvaluateNow();
		}
	}
	else
	{
		//
		// Traverse the complete hierarchy to find the object to evaluate now.
		//
		iSize = m_dataGroupList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_dataGroupList.size());
			pDataGroup = m_dataGroupList[i];
			if (!_wcsicmp(pszGUID, pDataGroup->GetGUID()))
			{
				pDataGroup->EvaluateNow();
				bFound = TRUE;
				MY_OUTPUT(L"DG found and Evaluate Now", 4);
				break;
			}
			// Look at branch below to see if can find it
			if (pDataGroup->FindAndEvaluateNowDEByGUID(pszGUID)==S_OK)
			{
				bFound = TRUE;
				break;
			}
		}
	}

	if (bFound == FALSE)
	{
		MY_OUTPUT(L"GUID not found", 4);
		MY_OUTPUT(L"EXIT ***** CSystem::FindAndEvaluateNowByGUID...", 4);
		return S_FALSE;
	}
	else
	{
		MY_OUTPUT(L"EXIT ***** CSystem::FindAndEvaluateNowByGUID...", 4);
		return S_OK;
	}
}

//
// HMSystemConfiguration class exposes this method.
// Code ends up in the methprov.pp file, then gets passed here.
//
BOOL CSystem::Enable(BOOL bEnable)
{
	HRESULT hRes;
//	BSTR PathToClass;
	int i, iSize;
	CDataGroup* pDataGroup;
	IWbemClassObject* pInst = NULL;
	IWbemCallResult *pResult = 0;

	MY_OUTPUT(L"ENTER ***** CSystem::Enable...", 4);

	if (m_bEnabled == bEnable)
		return TRUE;

	//
	// Set the variable, and do the same for all children.
	//
	m_bEnabled = bEnable;

	//
	// Traverse the complete hierarchy to find the object to enable/disable.
	//
	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
//XXX		pDataGroup->SetParentEnabledFlag(bEnable);
	}

	//
	// Set the property on this Configuration instance.
	//
	hRes = GetWbemObjectInst(&g_pIWbemServices, L"MicrosoftHM_SystemConfiguration.GUID=\"{@}\"", NULL, &pInst);
	if (!pInst)
	{
		MY_HRESASSERT(hRes);
		return FALSE;
	}

	hRes = PutBoolProperty(pInst, L"Enabled", m_bEnabled);
	hRes = g_pIWbemServices->PutInstance(pInst, 0, NULL, &pResult);
	pInst->Release();
	pInst = NULL;

	MY_OUTPUT(L"EXIT ***** CSystem::Enable...", 4);
	return TRUE;
}

//
// At startup, internalize all instances of Actions
//
HRESULT CSystem::InternalizeActions(void)
{
	ULONG uReturned;
	BOOL bFound = FALSE;
	int i, iSize;
	CAction* pAction;
	HRESULT hRetRes = S_OK;
	BSTR Language = NULL;
	BSTR Query = NULL;
	IWbemClassObject *pObj = NULL;
	LPTSTR pszTempGUID = NULL;
	IEnumWbemClassObject *pEnum = 0;

	MY_OUTPUT(L"ENTER ***** CSystem::InternalizeActions...", 4);

	Language = SysAllocString(L"WQL");
	MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	Query = SysAllocString(L"select * from MicrosoftHM_ActionConfiguration");
	MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

	// Issue query
	hRetRes = g_pIWbemServices->ExecQuery(Language, Query, WBEM_FLAG_FORWARD_ONLY, 0, &pEnum);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	SysFreeString(Query);
	Query = NULL;
	SysFreeString(Language);
	Language = NULL;

	// Retrieve objects in result set
	while (TRUE)
	{
		pObj = NULL;
		uReturned = 0;

		hRetRes = pEnum->Next(0, 1, &pObj, &uReturned);
		MY_ASSERT(hRetRes==S_OK || hRetRes==WBEM_S_FALSE);
		if (hRetRes!=S_OK && hRetRes!=WBEM_S_FALSE)
		{
			MY_HRESASSERT(hRetRes);
			pEnum->Release();
			pEnum = NULL;
			return hRetRes;
		}

		if (uReturned == 0)
		{
			break;
		}

		// See if this is already read in. Need to prevent duplicates.
		hRetRes = GetStrProperty(pObj, L"GUID", &pszTempGUID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		
		bFound = FALSE;
		iSize = m_actionList.size();
		for (i=0; i < iSize; i++)
		{
			MY_ASSERT(i<m_actionList.size());
			pAction = m_actionList[i];
			if (!_wcsicmp(pszTempGUID, pAction->m_szGUID))
			{
				bFound = TRUE;
				break;
			}
		}

		if (bFound == FALSE)
		{
			// Create the internal class to represent the Action
			CAction* pA = new CAction;
			MY_ASSERT(pA); if (!pA) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			hRetRes = pA->LoadInstanceFromMOF(pObj);
			if (hRetRes==S_OK)
			{
				m_actionList.push_back(pA);
			}
			else
			{
				MY_HRESASSERT(hRetRes);
				delete pA;
			}
		}
		delete [] pszTempGUID;
		pszTempGUID = NULL;

		// Release it.
		pObj->Release();
		pObj = NULL;
	}

	// All done
	pEnum->Release();
	pEnum = NULL;

	MY_OUTPUT(L"EXIT ***** CSystem::InternalizeActions...", 4);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	if (Query)
		SysFreeString(Query);
	if (Language)
		SysFreeString(Language);
	if (pszTempGUID)
		delete [] pszTempGUID;
	if (pObj)
		pObj->Release();
	if (pEnum)
		pEnum->Release();
	m_bValidLoad = FALSE;
	return hRetRes;
}

HRESULT CSystem::InitActionErrorListener(void)
{
	BSTR Language = NULL;
	BSTR Query = NULL;
	HRESULT hRetRes;

	Language = SysAllocString(L"WQL");
	MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	Query = SysAllocString(L"select * from __ConsumerFailureEvent where Event isa \"MicrosoftHM_ActionTriggerEvent\"");
	MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	hRetRes = S_FALSE;
	if (g_pIWbemServices != NULL)
	{
		m_pTempSink = new CTempConsumer(HMTEMPEVENT_ACTIONERROR);
		MY_ASSERT(m_pTempSink); if (!m_pTempSink) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		hRetRes = g_pIWbemServices->ExecNotificationQueryAsync(
									Language,
									Query,
									0,
									NULL,
									m_pTempSink);
	}
	SysFreeString(Language);
	Language = NULL;
	SysFreeString(Query);
	Query = NULL;

	MY_HRESASSERT(hRetRes);
	if (hRetRes != WBEM_S_NO_ERROR)
	{
		if (m_pTempSink)
		{
			m_pTempSink->Release();
			m_pTempSink = NULL;
		}
	}

	return S_OK;

error:
	MY_ASSERT(FALSE);
	if (Query)
		SysFreeString(Query);
	if (Language)
		SysFreeString(Language);
	m_bValidLoad = FALSE;
	return hRetRes;
}

HRESULT CSystem::InitActionSIDListener(CTempConsumer* pTempSink, LPTSTR pszQuery)
{
	BSTR Language = NULL;
	BSTR Query = NULL;
	HRESULT hRetRes;

	Language = SysAllocString(L"WQL");
	MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	Query = SysAllocString(pszQuery);
	MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	hRetRes = S_FALSE;
	if (g_pIWbemServices != NULL)
	{
		pTempSink = new CTempConsumer(HMTEMPEVENT_ACTIONSID);
		MY_ASSERT(pTempSink); if (!pTempSink) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		hRetRes = g_pIWbemServices->ExecNotificationQueryAsync(
									Language,
									Query,
									0,
									NULL,
									pTempSink);
	}
	SysFreeString(Language);
	Language = NULL;
	SysFreeString(Query);
	Query = NULL;

	MY_HRESASSERT(hRetRes);
	if (hRetRes != WBEM_S_NO_ERROR)
	{
		if (pTempSink)
		{
			pTempSink->Release();
			pTempSink = NULL;
		}
	}

	return S_OK;

error:
	MY_ASSERT(FALSE);
	if (Query)
		SysFreeString(Query);
	if (Language)
		SysFreeString(Language);
	m_bValidLoad = FALSE;
	return hRetRes;
}

HRESULT CSystem::HandleTempActionSIDEvent(IWbemClassObject* pObj)
{
	VARIANT vDispatch;
	VARIANT var;
	HRESULT hRetRes = S_OK;
	IWbemClassObject* pTargetInstance = NULL;
	VariantInit(&vDispatch);
	VariantInit(&var);
	IWbemClassObject* pInst = NULL;
	SAFEARRAY* psa = NULL;
	CIMTYPE vtType;
	long lBound, uBound;
	BOOL bObjIsLocalSystem;
	DWORD dwErr = 0;
	VariantInit(&vDispatch);
	VariantInit(&var);
	TCHAR szName[200];
	DWORD dwSize = 0;
	DWORD dwResult = 0;
	TCHAR szDomain[200];
	SID_NAME_USE SidType;
	LPVOID lpCreatorSID = NULL;

	MY_OUTPUT(L"BLOCK - BLOCK CSystem::HandleTempActionSIDEvent BLOCK - g_hConfigLock BLOCK WAIT", 4);
	dwErr = WaitForSingleObject(g_hConfigLock, 120000);
	if(dwErr != WAIT_OBJECT_0)
	{
		if(dwErr = WAIT_TIMEOUT)
		{
			TRACE_MUTEX(L"TIMEOUT MUTEX");
			return WBEM_S_TIMEDOUT;
		}
		else
		{
			MY_OUTPUT(L"WaitForSingleObject on Mutex failed",4);
			return WBEM_E_FAILED;
		}
	}
	MY_OUTPUT(L"BLOCK - BLOCK CSystem::HandleTempActionSIDEvent BLOCK - g_hConfigLock BLOCK GOT IT", 4);

	if (!g_pSystem)
	{
		ReleaseMutex(g_hConfigLock);
		return S_FALSE;
	}

	hRetRes = pObj->Get(L"TargetInstance", 0L, &vDispatch, 0, 0); 
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	hRetRes = GetWbemClassObject(&pTargetInstance, &vDispatch);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	// get the CreatorSID of this instance
	hRetRes = pTargetInstance->Get(L"CreatorSID", 0, &var, &vtType, NULL);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	if (vtType != (CIM_UINT8 | CIM_FLAG_ARRAY))
	{
		hRetRes = WBEM_E_FAILED;
		goto error;
	}

	// make sure it's the right size
	psa = var.parray;
	if (::SafeArrayGetElemsize(psa) != 1)
	{
		hRetRes = WBEM_E_FAILED;
		goto error;
	}

	hRetRes = ::SafeArrayGetLBound(psa, 1, &lBound);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	hRetRes = ::SafeArrayGetUBound(psa, 1, &uBound);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	if (lBound !=0)
	{
		hRetRes = WBEM_E_FAILED;
		goto error;
	}

	// now see if this is LocalSystem by comparing to 
	// the hardcoded LocalSystem SID
	bObjIsLocalSystem = false;
	if (uBound == (sizeof LocalSystemSID)-1 )
	{
		lpCreatorSID = NULL;
		hRetRes = ::SafeArrayAccessData(psa, &lpCreatorSID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		if (memcmp (lpCreatorSID, LocalSystemSID, sizeof LocalSystemSID) == 0)
			bObjIsLocalSystem = true;
		hRetRes = ::SafeArrayUnaccessData(psa);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}

	if (bObjIsLocalSystem == FALSE)
	{
		// Also, skip it if it is a LocalAccount! (non-domain)
		lpCreatorSID = NULL;
		hRetRes = ::SafeArrayAccessData(psa, &lpCreatorSID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		dwSize = 200;
		if( !LookupAccountSid(NULL, lpCreatorSID, szName, &dwSize, szDomain, &dwSize, &SidType))
		{
			// Didn't work for some reason, so assume we need to check.
			m_numActionChanges++;
		}
		else
		{
			DWORD dwNameLen = MAX_COMPUTERNAME_LENGTH + 1;
			TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
			if (GetComputerName(szComputerName, &dwNameLen))
			{
				// If machine name matches, then it is a local account, so skip!!!
				if (_wcsicmp(szComputerName, szDomain))
				{
					m_numActionChanges++;
				}
			}
			else
			{
				// Didn't work for some reason, so assume we need to check.
				m_numActionChanges++;
			}
		}
		hRetRes = ::SafeArrayUnaccessData(psa);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	}

	pTargetInstance->Release();
	pTargetInstance = NULL;
	VariantClear(&vDispatch);
	VariantClear(&var);
	ReleaseMutex(g_hConfigLock);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	if (pTargetInstance)
		pTargetInstance->Release();
	if (pInst)
		pInst->Release();
	VariantClear(&vDispatch);
	VariantClear(&var);
	ReleaseMutex(g_hConfigLock);
	return hRetRes;
}

// Pass on info to the DataCollector that has the GUID
HRESULT CSystem::HandleTempActionErrorEvent(IWbemClassObject* pObj)
{
	HRESULT hRetRes = S_OK;
	BOOL bFound = FALSE;
	VARIANT vDispatch;
	int i, iSize;
	CAction* pAction;
	IWbemClassObject* pTargetInstance = NULL;
	LPTSTR pszGUID = NULL;
	LPTSTR pszErrorDescription = NULL;
	long lNum;
	DWORD dwErr = 0;
	VariantInit(&vDispatch);

	MY_OUTPUT(L"BLOCK - BLOCK CSystem::HandleTempActionErrorEvent BLOCK - g_hConfigLock BLOCK WAIT", 4);
	dwErr = WaitForSingleObject(g_hConfigLock, 120000);
	if(dwErr != WAIT_OBJECT_0)
	{
		if(dwErr = WAIT_TIMEOUT)
		{
			TRACE_MUTEX(L"TIMEOUT MUTEX");
			return WBEM_S_TIMEDOUT;
		}
		else
		{
			MY_OUTPUT(L"WaitForSingleObject on Mutex failed",4);
			return WBEM_E_FAILED;
		}
	}
	MY_OUTPUT(L"BLOCK - BLOCK CSystem::HandleTempActionErrorEvent BLOCK - g_hConfigLock BLOCK GOT IT", 4);

	if (!g_pSystem)
	{
		ReleaseMutex(g_hConfigLock);
		return S_FALSE;
	}

	try
	{
		// Get the GUID from the Event property, which will be an ActionStatusEvent class, then
		// from that GUID property.

		VariantInit(&vDispatch);
		hRetRes = pObj->Get(L"Event", 0L, &vDispatch, 0, 0);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = GetWbemClassObject(&pTargetInstance, &vDispatch);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		hRetRes = GetStrProperty(pTargetInstance, L"GUID", &pszGUID);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		hRetRes = GetUint32Property(pObj, L"ErrorCode", &lNum);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		hRetRes = GetStrProperty(pObj, L"ErrorDescription", &pszErrorDescription);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		pTargetInstance->Release();
		VariantClear(&vDispatch);

		iSize = m_actionList.size();
		for (i=0; i < iSize; i++)
		{
			MY_ASSERT(i<m_actionList.size());
			pAction = m_actionList[i];
			if (pAction->HandleTempErrorEvent(pszGUID, lNum, pszErrorDescription))
			{
				bFound = TRUE;
				break;
			}
		}

		if (bFound == FALSE)
		{
			MY_OUTPUT2(L"NOTFOUND: No body to handle Action Error event for GUID=%s", pszGUID, 4);
		}
		delete [] pszGUID;
		pszGUID = NULL;
		delete [] pszErrorDescription;
		pszErrorDescription = NULL;
	}
	catch (...)
	{
		MY_ASSERT(FALSE);
	}

	MY_OUTPUT(L"BLOCK - BLOCK CSystem::HandleTempEvent g_hConfigLock BLOCK - RELEASE IT", 4);
	ReleaseMutex(g_hConfigLock);
	MY_OUTPUT(L"BLOCK - BLOCK CSystem::HandleTempEvent g_hConfigLock BLOCK - RELEASED", 4);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	if (pszGUID)
		delete [] pszGUID;
	if (pszErrorDescription)
		delete [] pszErrorDescription;
	ReleaseMutex(g_hConfigLock);
	return hRetRes;
}


//
// For ones that are created on the fly, after we are running.
//
HRESULT CSystem::CreateAction(IWbemClassObject* pObj)
{
	HRESULT hRetRes = S_OK;
	BOOL bFound = FALSE;
	int i, iSize;
	CAction* pAction;
	LPTSTR pszTempGUID = NULL;

	MY_OUTPUT(L"ENTER ***** CSystem::CreateAction...", 4);

	// See if this is already read in. Need to prevent duplicates.
	hRetRes = GetStrProperty(pObj, L"GUID", &pszTempGUID);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	
	bFound = FALSE;
	iSize = m_actionList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_actionList.size());
		pAction = m_actionList[i];
		if (!_wcsicmp(pszTempGUID, pAction->m_szGUID))
		{
			bFound = TRUE;
			break;
		}
	}

	if (bFound == FALSE)
	{
		// Create the internal class to represent the Action
		CAction* pA = new CAction;
		MY_ASSERT(pA); if (!pA) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		hRetRes = pA->LoadInstanceFromMOF(pObj);
		if (hRetRes==S_OK)
		{
			m_actionList.push_back(pA);
		}
		else
		{
			MY_HRESASSERT(hRetRes);
			delete pA;
		}
	}
	delete [] pszTempGUID;
	pszTempGUID= NULL;

	MY_OUTPUT(L"EXIT ***** CSystem::CreateAction...", 4);
	return hRetRes;

error:
	MY_ASSERT(FALSE);
	if (pszTempGUID)
		delete [] pszTempGUID;
	return hRetRes;
}

// Traverse the Configuration class hierarchy, like do from InternalizeDataGroups(),
// and create one single safearray to pass back.
// Contains the object that matches the GUID, and everything under it,
// including associations.
HRESULT CSystem::FindAndCopyByGUID(LPTSTR pszGUID, SAFEARRAY** ppsa, LPTSTR *pszOriginalParentGUID)
{
	int j;
	HRESULT hRetRes = S_OK;
	int i, iSize;
	CDataGroup* pDataGroup;
	SAFEARRAYBOUND bound[1]; 
	IWbemClassObject* pInstance = NULL;
	long ix[1]; 
	IUnknown* pIUnknown = NULL;
	ILIST configList;
	HRESULT hRes;
	static LPTSTR systemGUID = L"{@}";

	MY_OUTPUT(L"ENTER ***** CSystem::FindAndCopyByGUID...", 4);
	MY_OUTPUT2(L"COPY GUID=%s", pszGUID, 4);

	//
	// Traverse the complete hierarchy to find the object to delete.
	//
	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		if (!_wcsicmp(pszGUID, pDataGroup->GetGUID()))
		{
			hRetRes = pDataGroup->Copy(&configList, NULL, NULL);
			*pszOriginalParentGUID = systemGUID;
			break;
		}
		// Look at branch below to see if can find it
		hRetRes = pDataGroup->FindAndCopyByGUID(pszGUID, &configList, pszOriginalParentGUID);
		if (hRetRes==S_OK)
		{
			break;
		}
		else if (hRetRes!=WBEM_S_DIFFERENT)
		{
			break;
		}
	}

	if (hRetRes == WBEM_S_DIFFERENT)
	{
		MY_OUTPUT(L"TargetGuid to copy not found!", 4);
		return WBEM_E_NOT_FOUND;
	}
	else if (hRetRes != S_OK)
	{
		MY_OUTPUT(L"Copy error not found!", 4);
		return hRetRes;
	}

	//
	// Now, here at the end, place in the safe array!
	//
	iSize = configList.size();
	bound[0].lLbound = 0;
	bound[0].cElements = iSize;
	*ppsa = SafeArrayCreate(VT_UNKNOWN, 1, bound);
	if (*ppsa == NULL)
	{
		MY_OUTPUT(L"SafeArray creation failure!", 4);
		MY_ASSERT(FALSE);
		return WBEM_E_OUT_OF_MEMORY;
	} 

	j = 0;
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<configList.size());
		pInstance = configList[i];
		// Add the DG instance to the safe array
		hRes = pInstance->QueryInterface(IID_IUnknown, (void**) &pIUnknown);

		if (hRes != NOERROR) 
		{
			MY_HRESASSERT(hRes);
			MY_OUTPUT(L"Copy failure!", 4);
			SafeArrayDestroy(*ppsa); 
			return hRes;
		}
 
		ix[0] = j; 
		j++;
		hRes = SafeArrayPutElement(*ppsa, ix, pIUnknown); 
		if (hRes != S_OK) 
		{
			MY_HRESASSERT(hRes);
			MY_OUTPUT(L"Copy failure!", 4);
			MY_ASSERT(FALSE);
		}
 
		// SafeArrayPutElement adds a reference to the contents of the 
		// variant, so we must free the variable we have. 
		// 
		pIUnknown->Release();
		pInstance->Release();
		pIUnknown = NULL;
		pInstance = NULL;
	}

	MY_OUTPUT(L"EXIT ***** CSystem::FindAndCopyByGUID...", 4);
	return S_OK;
}

//
// What we need to do here is basically just do a PutInstance for everything
// in the array, and add the one association from my identified parent, to
// The first HMConfiguration object that was in the array.
// There are the thresholds to follow to make sure that we do not end up with two objects named
// the same at the same level. We follow the example of NTExplorer for this.
// Return 0 if success, 1 if error, and 2 if naming conflict when bForceReplace is set to FALSE.
//
HRESULT CSystem::FindAndPasteByGUID(LPTSTR pszTargetGUID, SAFEARRAY* psa, LPTSTR pszOriginalSystem, LPTSTR pszOriginalParentGUID, BOOL bForceReplace)
{
	BSTR Path = NULL;
	BSTR PathToClass = NULL;
	TCHAR szTemp[1024];
	LPTSTR pStr;
	HRESULT hRes;
	HRESULT hRetRes = S_OK;
	IUnknown* vUnknown;
	IWbemClassObject* pCO = NULL;
	long iLBound, iUBound;
	IWbemClassObject* pTargetObj = NULL;
	LPTSTR pszChildGUID = NULL;
	LPTSTR pszChildName = NULL;
	LPTSTR pszParentClass = NULL;
	LPTSTR pszChildClass = NULL;
	IWbemCallResult *pResult = 0;
	CBase *pParent = NULL;
	CBase *pChild = NULL;
	IWbemClassObject *pNewInstance = NULL;
	IWbemClassObject *pExampleClass = NULL;
	IWbemContext *pCtx = NULL;

	MY_OUTPUT(L"EXIT ***** CSystem::FindAndPasteByGUID...", 4);
	MY_OUTPUT2(L"PASTE Target GUID=%s", pszTargetGUID, 4);
	MY_OUTPUT2(L"OrigionalSystem=%s", pszOriginalSystem, 4);
	MY_OUTPUT2(L"OrigionalParent GUID=%s", pszOriginalParentGUID, 4);
	MY_OUTPUT2(L"ForceReplace=%d", (int)bForceReplace, 4);

	//
	// Make sure that the object exists that we are to copy ourselves under!
	//
	wcscpy(szTemp, L"MicrosoftHM_Configuration.GUID=\"");
	lstrcat(szTemp, pszTargetGUID);
	lstrcat(szTemp, L"\"");
	Path = SysAllocString(szTemp);
	MY_ASSERT(Path); if (!Path) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	hRetRes = GetWbemObjectInst(&g_pIWbemServices, Path, NULL, &pTargetObj);
	if (!pTargetObj)
	{
		MY_OUTPUT(L"Target Not found to paste under", 4);
		SysFreeString(Path);
		return 1;
	}
	SysFreeString(Path);
	Path = NULL;

	hRetRes = GetStrProperty(pTargetObj, L"__CLASS", &pszParentClass);
	MY_HRESASSERT(hRetRes);
//XXXMake sure to prevent a paste under a Threshold
//Strcmp Parent class with MicrosoftHM_ThresholdConfiguration

	//
	// Do a PutInstance for everything in the array.
	//
	SafeArrayGetLBound(psa, 1, &iLBound);
	SafeArrayGetUBound(psa, 1, &iUBound);
	if ((iUBound - iLBound + 1) == 0)
	{
		MY_ASSERT(FALSE);
	}
	else
	{
		for (long i = iLBound; i <= iUBound; i++)
		{
			vUnknown = NULL;
			hRetRes = SafeArrayGetElement(psa, &i, &vUnknown);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			pCO = (IWbemClassObject *)vUnknown;

			//
			// We have here the child to get pasted under the target.
			// First off we need to decide if we can paste it, and if we need
			// to do a replace of an existing configuration instance.
			// We also need to save info that is to be used later to create an association.
			//
			if (pszChildGUID == NULL)
			{
				hRetRes = GetStrProperty(pCO, L"GUID", &pszChildGUID);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
				hRetRes = GetStrProperty(pCO, L"Name", &pszChildName);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
				hRetRes = GetStrProperty(pCO, L"__CLASS", &pszChildClass);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

				//
				// Search for the parent, and then look to see if there is a
				// child with the same name.
				//
				pParent = GetParentPointerFromPath(szTemp);
				MY_ASSERT(pParent); if (!pParent) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				pChild = pParent->FindImediateChildByName(pszChildName);
				if (pChild)
				{
					//
					// We found a child with the same name already!
					//
					DWORD dwNameLen = MAX_COMPUTERNAME_LENGTH + 1;
					TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
					if (GetComputerName(szComputerName, &dwNameLen))
					{
					}
					else
					{
						wcscpy(szComputerName, L"LocalMachine");
					}

					//
					// Do what Explorer does, and act different if the original parent
					// is the same as the target parent.
					//
					if (!_wcsicmp(pszOriginalSystem, szComputerName) &&
						!_wcsicmp(pszOriginalParentGUID, pszTargetGUID))
					{
						//
						// This is where we are copying from and to the same parent.
						// So don't ask, just rename to next increment.
						//
						pStr = szTemp;
						pParent->GetNextChildName(pszChildName, pStr);
						PutStrProperty(pCO, L"Name", szTemp);
					}
					else
					{
						// Different parent, so ask if want to replace!
						if (bForceReplace)
						{
							// Delete the old one first!
							FindAndDeleteByGUID(pChild->m_szGUID);
							delete [] pszChildName;
							pszChildName = NULL;
						}
						else
						{
							delete [] pszParentClass;
							pszParentClass = NULL;
							delete [] pszChildClass;
							pszChildClass = NULL;
							delete [] pszChildGUID;
							pszChildGUID = NULL;
							delete [] pszChildName;
							pszChildName = NULL;
							vUnknown->Release();
							pTargetObj->Release();
							MY_OUTPUT(L"Paste conflict", 4);
							return 2;
						}
					}
				}
				else
				{
					// Not found, so we are OK to proceed
				}
			}

			hRes = g_pIWbemServices->PutInstance(pCO, 0, NULL, &pResult);
			if (hRes != S_OK)
			{
				MY_HRESASSERT(hRes);
				MY_OUTPUT2(L"Put failure Unexpected Error: 0x%08x",hRes,4);
			}

			vUnknown->Release();
		}
	}

	MY_ASSERT(pszChildGUID);
	//
	// Add the one association from my identified parent, to the first
	// HMConfiguration object that was in the array.
	//
	pResult = 0;

	// Get the association class definition.
	PathToClass = SysAllocString(L"MicrosoftHM_ConfigurationAssociation");
	MY_ASSERT(PathToClass); if (!PathToClass) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	hRes = g_pIWbemServices->GetObject(PathToClass, 0, pCtx, &pExampleClass, &pResult);
	SysFreeString(PathToClass);
	PathToClass = NULL;

	if (hRes != 0)
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT2(L"GetObject failure Unexpected Error: 0x%08x",hRes,4);
		return hRes;
	}

	// Create a new association instance.
	hRetRes = pExampleClass->SpawnInstance(0, &pNewInstance);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	pExampleClass->Release();
	pExampleClass = NULL;

	// If it is the System, then looks like ->"MicrosoftHM_SystemConfiguration.GUID=\"{@}\""
	// Child looks like ->"\\.\root\cimv2\MicrosoftHealthMonitor:
	// MicrosoftHM_DataGroupConfiguration.GUID="{269EA389-07CA-11d3-8FEB-006097919914}""
	// MicrosoftHM_Configuration.GUID="{269EA389-07CA-11d3-8FEB-006097919914}""
	if (!wcscmp(pszTargetGUID, L"{@}"))
	{
		wcscpy(szTemp, L"MicrosoftHM_SystemConfiguration.GUID=\"{@}\"");
	}
	else
	{
		wcscpy(szTemp, L"\\\\.\\root\\cimv2\\MicrosoftHealthMonitor:");
		lstrcat(szTemp, pszParentClass);
		lstrcat(szTemp, L".GUID=\"");
		lstrcat(szTemp, pszTargetGUID);
		lstrcat(szTemp, L"\"");
	}
	PutStrProperty(pNewInstance, L"ParentPath", szTemp);
	wcscpy(szTemp, L"\\\\.\\root\\cimv2\\MicrosoftHealthMonitor:");
	lstrcat(szTemp, pszChildClass);
	lstrcat(szTemp, L".GUID=\"");
	lstrcat(szTemp, pszChildGUID);
	lstrcat(szTemp, L"\"");
	PutStrProperty(pNewInstance, L"ChildPath", szTemp);

	// Write the association instance
	hRetRes = g_pIWbemServices->PutInstance(pNewInstance, 0, pCtx, &pResult);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	pNewInstance->Release();
	pNewInstance = NULL;

	//
	// Cleanup
	//
	if (pszChildGUID != NULL)
	{
		delete [] pszChildGUID;
		pszChildGUID = NULL;
	}
	pTargetObj->Release();
	pTargetObj = NULL;
	delete [] pszParentClass;
	pszParentClass = NULL;
	delete [] pszChildClass;
	pszChildClass = NULL;

	MY_OUTPUT(L"EXIT ***** CSystem::FindAndPasteByGUID...", 4);
	return 0;

error:
	MY_ASSERT(FALSE);
	if (pszParentClass)
		delete [] pszParentClass;
	if (pszChildClass)
		delete [] pszChildClass;
	if (pszChildGUID)
		delete [] pszChildGUID;
	if (pszChildName)
		delete [] pszChildName;
	if (pTargetObj)
		pTargetObj->Release();
	if (Path)
		SysFreeString(Path);
	if (PathToClass)
		SysFreeString(PathToClass);
	if (pNewInstance)
		pNewInstance->Release();
	if (pExampleClass)
		pExampleClass->Release();
	return hRetRes;
}

HRESULT CSystem::FindAndCopyWithActionsByGUID(LPTSTR pszGUID, SAFEARRAY** ppsa, LPTSTR *pszOriginalParentGUID)
{
	return AgentCopy (pszGUID, ppsa, pszOriginalParentGUID);
}

HRESULT CSystem::FindAndPasteWithActionsByGUID(LPTSTR pszTargetGUID, SAFEARRAY* psa, LPTSTR pszOriginalSystem, LPTSTR pszOriginalParentGUID, BOOL bForceReplace)
{
	return AgentPaste (pszTargetGUID, psa, pszOriginalSystem, pszOriginalParentGUID, bForceReplace);
}

//
// Delete the single use of an Action
//
#ifdef SAVE
HRESULT CSystem::Move(LPTSTR pszTargetGUID, LPTSTR pszNewParentGUID)
{
	int i, iSize;
	CDataGroup* pDataGroup;
	BOOL bFound = FALSE;
	CBase *pTargetBase = NULL;
	CBase *pNewParentBase = NULL;

	MY_OUTPUT(L"ENTER ***** CSystem::Move...", 4);
	MY_OUTPUT2(L"TargetGUID=%s", pszTargetGUID, 4);
	MY_OUTPUT2(L"NewParentGUID=%s", pszNewParentGUID, 4);

	//
	// First locate the thing to move
	//
	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		if (!_wcsicmp(pszTargetGUID, pDataGroup->GetGUID()))
		{
			pTargetBase = pDataGroup;
			break;
		}
		// Look at branch below to see if can find it
		pTargetBase = pDataGroup->GetParentPointerFromGUID(pszTargetGUID);
		if (pTargetBase)
		{
			break;
		}
	}

	if (pTargetBase)
	{
		bFound = FALSE;
		//
		// Next locate the place to move under
		//
		if (!wcscmp(pszNewParentGUID, L"{@}"))
		{
			pNewParentBase = this;
			bFound = TRUE;
		}
		else
		{
			iSize = m_dataGroupList.size();
			for (i=0; i<iSize; i++)
			{
				MY_ASSERT(i<m_dataGroupList.size());
				pDataGroup = m_dataGroupList[i];
				if (!_wcsicmp(pszNewParentGUID, pDataGroup->GetGUID()))
				{
					pNewParentBase = pDataGroup;
					bFound = TRUE;
					break;
				}
				// Look at branch below to see if can find it
				pNewParentBase = pDataGroup->GetParentPointerFromGUID(pszNewParentGUID);
				if (pNewParentBase)
				{
					bFound = TRUE;
					break;
				}
			}
		}

		if (pNewParentBase)
		{
			//
			// Make sure that it is a legal move.
			// Can't do things like move a Threshold under a System, or DataGroup.
			//
			if (pNewParentBase->m_hmStatusType == HMSTATUS_SYSTEM)
			{
				if (pTargetBase->m_hmStatusType != HMSTATUS_DATAGROUP)
				{
					bFound = FALSE;
				}
			}
			else if (pNewParentBase->m_hmStatusType == HMSTATUS_DATAGROUP)
			{
				if (pTargetBase->m_hmStatusType != HMSTATUS_DATAGROUP &&
					pTargetBase->m_hmStatusType != HMSTATUS_DATACOLLECTOR)
				{
					bFound = FALSE;
				}
			}
			else if (pNewParentBase->m_hmStatusType == HMSTATUS_DATACOLLECTOR)
			{
				if (pTargetBase->m_hmStatusType != HMSTATUS_THRESHOLD)
				{
					bFound = FALSE;
				}
			}
			else if (pNewParentBase->m_hmStatusType == HMSTATUS_THRESHOLD)
			{
				bFound = FALSE;
			}
			else
			{
				MY_ASSERT(FALSE);
			}

			if (bFound)
			{
				//
				// Delete the object out of the list of the old parent.
				//
				if (pTargetBase->m_hmStatusType == HMSTATUS_DATAGROUP)
				{
					if (((CDataGroup *)pTargetBase)->m_pParentDG == NULL)
					{
						g_pSystem->DeleteChildFromList(pszTargetGUID);
					}
					else
					{
						((CDataGroup *)pTargetBase)->m_pParentDG->DeleteChildFromList(pszTargetGUID);
					}
				}
				else if (pTargetBase->m_hmStatusType == HMSTATUS_DATACOLLECTOR)
				{
					((CDataCollector *)pTargetBase)->m_pParentDG->DeleteChildFromList(pszTargetGUID);
				}
				else if (pTargetBase->m_hmStatusType == HMSTATUS_THRESHOLD)
				{
					((CThreshold *)pTargetBase)->m_pParentDC->DeleteChildFromList(pszTargetGUID);
				}
				else
				{
					MY_ASSERT(FALSE);
				}

				//
				// Modify the association in the repository.
				//
				pTargetBase->ModifyAssocForMove(pNewParentBase);
	
				//
				// Move the object under its new parent
				//
				pNewParentBase->ReceiveNewChildForMove(pTargetBase);
			}
		}
	}

	if (bFound == FALSE)
	{
		MY_OUTPUT(L"GUID not found", 4);
		MY_OUTPUT(L"EXIT ***** CSystem::Move...", 4);
		return WBEM_E_NOT_FOUND;
	}
	else
	{
		MY_OUTPUT(L"EXIT ***** CSystem::Move...", 4);
		return S_OK;
	}
}
#endif

#ifdef SAVE
BOOL CSystem::ModifyAssocForMove(CBase *pNewParentBase)
{
	MY_ASSERT(FALSE);

	return TRUE;
}
#endif

BOOL CSystem::ReceiveNewChildForMove(CBase *pBase)
{
	m_dataGroupList.push_back((CDataGroup *)pBase);
//	(CDataGroup *)pBase->SetParentEnabledFlag(m_bEnabled);

	return TRUE;
}

BOOL CSystem::DeleteChildFromList(LPTSTR pszGUID)
{
	int i, iSize;
	CDataGroup* pDataGroup;
	DGLIST::iterator iaDG;

	iSize = m_dataGroupList.size();
	iaDG=m_dataGroupList.begin();
	for (i=0; i<iSize; i++, iaDG++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		if (!_wcsicmp(pszGUID, pDataGroup->GetGUID()))
		{
			m_dataGroupList.erase(iaDG);
			break;
		}
	}

	return TRUE;
}

//
// Delete the single use of an Action
//
HRESULT CSystem::DeleteConfigActionAssoc(LPTSTR pszConfigGUID, LPTSTR pszActionGUID)
{
	BOOL bFound = FALSE;
	int i, iSize;
	CAction* pAction;

	MY_OUTPUT(L"ENTER ***** CSystem::DeleteConfigActionAssociation...", 4);
	MY_OUTPUT2(L"ConfigGUID=%s", pszConfigGUID, 4);
	MY_OUTPUT2(L"ActionGUID=%s", pszActionGUID, 4);

	iSize = m_actionList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_actionList.size());
		pAction = m_actionList[i];
		if (pAction->DeleteConfigActionAssoc(pszConfigGUID, pszActionGUID))
		{
			bFound = TRUE;
			break;
		}
	}

	if (bFound == FALSE)
	{
		MY_OUTPUT(L"GUID not found", 4);
		MY_OUTPUT(L"EXIT ***** CSystem::DeleteConfigActionAssociation...", 4);
		return WBEM_E_NOT_FOUND;
	}
	else
	{
		MY_OUTPUT(L"EXIT ***** CSystem::DeleteConfigActionAssociation...", 4);
		return S_OK;
	}
}

//
// Delete the all associated actions to a given configuration GUID
//
HRESULT CSystem::DeleteAllConfigActionAssoc(LPTSTR pszConfigGUID)
{
	BOOL bFound = FALSE;
	int i, iSize;
	CAction* pAction;

	MY_OUTPUT(L"ENTER ***** CSystem::DeleteAllConfigActionAssociation...", 4);
	MY_OUTPUT2(L"ConfigGUID=%s", pszConfigGUID, 4);

	iSize = m_actionList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_actionList.size());
		pAction = m_actionList[i];
		if (pAction->DeleteConfigActionAssoc(pszConfigGUID, pAction->m_szGUID))
		{
			bFound = TRUE;
		}
	}

	if (bFound == FALSE)
	{
		MY_OUTPUT(L"No associations found. OK?", 4);
		MY_OUTPUT(L"EXIT ***** CSystem::DeleteAllConfigActionAssociation...", 4);
		return S_FALSE;
	}
	else
	{
		MY_OUTPUT(L"EXIT ***** CSystem::DeleteAllConfigActionAssociation...", 4);
		return S_OK;
	}
}

CBase *CSystem::GetParentPointerFromPath(LPTSTR pszParentPath)
{
	TCHAR szGUID[1024];
	int i, iSize;
	CDataGroup* pDataGroup;
	LPTSTR pStr;
	LPTSTR pStr2;
	BOOL bFound = FALSE;
	CBase *pBase;

	wcscpy(szGUID, pszParentPath);
	pStr = wcschr(szGUID, '\"');
	if (pStr)
	{
		pStr++;
		pStr2 = wcschr(pStr, '\"');
		if (pStr2)
		{
			*pStr2 = '\0';
			if (!wcscmp(pStr, L"{@}"))
			{
				pBase = this;
				bFound = TRUE;
			}
			else
			{
				iSize = m_dataGroupList.size();
				for (i=0; i<iSize; i++)
				{
					MY_ASSERT(i<m_dataGroupList.size());
					pDataGroup = m_dataGroupList[i];
					if (!_wcsicmp(pStr, pDataGroup->GetGUID()))
					{
						pBase = pDataGroup;
						bFound = TRUE;
						break;
					}
					// Look at branch below to see if can find it
					pBase = pDataGroup->GetParentPointerFromGUID(pStr);
					if (pBase)
					{
						bFound = TRUE;
						break;
					}
				}
			}
		}
	}
	else
	{
		pStr = wcschr(szGUID, '=');
		if (pStr)
		{
			pStr++;
			pStr++;
			pStr++;
			if (*pStr == '@')
			{
				pBase = this;
				bFound = TRUE;
			}
		}
	}

	if (bFound == TRUE)
	{
		return pBase;
	}
	else
	{
		return NULL;
	}
}

CBase *CSystem::FindImediateChildByName(LPTSTR pszName)
{
	int i, iSize;
	CDataGroup* pDataGroup;
	BOOL bFound = FALSE;
	CBase *pBase;

	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		if (!_wcsicmp(pszName, pDataGroup->m_szName))
		{
			pBase = pDataGroup;
			bFound = TRUE;
			break;
		}
	}

	if (bFound == TRUE)
	{
		return pBase;
	}
	else
	{
		return NULL;
	}
}

BOOL CSystem::GetNextChildName(LPTSTR pszChildName, LPTSTR pszOutName)
{
	TCHAR szTemp[1024];
	TCHAR szIndex[1024];
	int i, iSize;
	BOOL bFound;
	CDataGroup* pDataGroup;
	int index;

	// We are here because we know that one exists already with the same name.
	// So, lets start off trying to guess what the next name should be and get one.
	index = 0;
	bFound = TRUE;
	while (bFound == TRUE)
	{
		wcscpy(szTemp, pszChildName);
		_itot(index, szIndex, 10);
		lstrcat(szTemp, L" ");
		lstrcat(szTemp, szIndex);

		bFound = FALSE;
		iSize = m_dataGroupList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<m_dataGroupList.size());
			pDataGroup = m_dataGroupList[i];
			if (!_wcsicmp(szTemp, pDataGroup->m_szName))
			{
				bFound = TRUE;
				break;
			}
		}
		index++;
	}
	wcscpy(pszOutName, szTemp);

	return TRUE;
}

CBase *CSystem::FindPointerFromName(LPTSTR pszName)
{
	int i, iSize;
	CDataGroup* pDataGroup;
	BOOL bFound = FALSE;
	CBase *pBase;

	iSize = m_dataGroupList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_dataGroupList.size());
		pDataGroup = m_dataGroupList[i];
		if (!_wcsicmp(pszName, pDataGroup->m_szName))
		{
			pBase = pDataGroup;
			bFound = TRUE;
			break;
		}
		// Look at branch below to see if can find it
		pBase = pDataGroup->FindPointerFromName(pszName);
		if (pBase)
		{
			bFound = TRUE;
			break;
		}
	}

	if (bFound == TRUE)
	{
		return pBase;
	}
	else
	{
		return NULL;
	}
}

//
// Do string replacement for the Message property
//
BOOL CSystem::FormatMessage(IWbemClassObject* pInstance)
{
	BSTR PropName = NULL;
	LPTSTR pszMsg = NULL;
	SAFEARRAY *psaNames = NULL;
	long lNum;
	HRESULT hRetRes = S_OK;
	LPTSTR pszDest = NULL;
	LPTSTR pszUpperMsg = NULL;
	LPTSTR pszNewMsg = NULL;
	LPTSTR pStr = NULL;
	LPTSTR pStr2 = NULL;
	LPTSTR pStrStart = NULL;
	TOKENSTRUCT tokenElmnt;
	TOKENSTRUCT *pTokenElmnt;
	REPSTRUCT repElmnt;
	REPSTRUCT *pRepElmnt;
	REPSTRUCT *pRepElmnt2;
	REPLIST replacementList;
	int i, iSize, iSizeNeeded, j;
	long lLower, lUpper; 
	static TOKENLIST tokenList;

	//
	// We only need to build the set of tokens one time, then from then on
	// we just need to fill in the values for what the replacement strings are.
	//
	if (tokenList.size() == 0)
	{
		//
		// First we build the set of tokens that we are looking for. Each property that
		// is in the ThresholdStatusInstance. We build that set of strings,
		// and the values to replace with.
		//

		//
		// Now go through ThresholdInstance, which is where the Message String
		// actually lives. Get that set of properties for the Instances.
		//
		psaNames = NULL;
		hRetRes = pInstance->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames);
		if (SUCCEEDED(hRetRes))
		{
			// Get the number of properties.
			SafeArrayGetLBound(psaNames, 1, &lLower);
			SafeArrayGetUBound(psaNames, 1, &lUpper);

			// For each property...
			for (long l=lLower; l<=lUpper; l++) 
			{
				// Get this property.
				hRetRes = SafeArrayGetElement(psaNames, &l, &PropName);
				MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
				// Will want to skip some that don't make sense.
				if (!wcscmp(PropName, L"Message"))
				{
					SysFreeString(PropName);
					PropName = NULL;
					continue;
				}
				else if (!wcscmp(PropName, L"ResetMessage"))
				{
					SysFreeString(PropName);
					PropName = NULL;
					continue;
				}
				else if (!wcscmp(PropName, L"EmbeddedCollectedInstance"))
				{
					SysFreeString(PropName);
					PropName = NULL;
					continue;
				}
				tokenElmnt.szOrigToken = new TCHAR[wcslen(PropName)+1];
				MY_ASSERT(tokenElmnt.szOrigToken); if (!tokenElmnt.szOrigToken) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				wcscpy(tokenElmnt.szOrigToken, PropName);
				tokenElmnt.szToken = new TCHAR[wcslen(PropName)+3];
				MY_ASSERT(tokenElmnt.szToken); if (!tokenElmnt.szToken) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
				wcscpy(tokenElmnt.szToken, L"%");
				wcscat(tokenElmnt.szToken, PropName);
				wcscat(tokenElmnt.szToken, L"%");
				_wcsupr(tokenElmnt.szToken);
				tokenElmnt.szReplacementText = NULL;
				tokenList.push_back(tokenElmnt);
				SysFreeString(PropName);
				PropName = NULL;
			}
			SafeArrayDestroy(psaNames);
			psaNames = NULL;
		}
	}

	//
	// Now we can fill in the values to use for the replacement strings.
	//

	//
	// Now go through each ThresholdInstance, which is where the Message String
	// actually lives. Get that set of properties of the Instance,
	// And do the message formatting while there.
	//

	//
	// Get the replacement strings for this instance
	//
	iSize = tokenList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<tokenList.size());
		pTokenElmnt = &tokenList[i];
		if (pTokenElmnt->szReplacementText != NULL)
		{
			delete [] pTokenElmnt->szReplacementText;
		}
		
		if (!wcscmp(pTokenElmnt->szToken, L"%TESTCONDITION%"))
		{
			hRetRes = GetUint32Property(pInstance, pTokenElmnt->szOrigToken, &lNum);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			MY_ASSERT(lNum<9);
			pStr = new TCHAR[wcslen(conditionLocStr[lNum])+1];
			MY_ASSERT(pStr); if (!pStr) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			wcscpy(pStr, conditionLocStr[lNum]);
		}
		else if (!wcscmp(pTokenElmnt->szToken, L"%STATE%"))
		{
			hRetRes = GetUint32Property(pInstance, pTokenElmnt->szOrigToken, &lNum);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			MY_ASSERT(lNum<10);
			pStr = new TCHAR[wcslen(stateLocStr[lNum])+1];
			MY_ASSERT(pStr); if (!pStr) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			wcscpy(pStr, stateLocStr[lNum]);
		}
		else
		{
			hRetRes = GetAsStrProperty(pInstance, pTokenElmnt->szOrigToken, &pStr);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		}
		pTokenElmnt->szReplacementText = pStr;
	}

	//
	// Now we have both lists of tokens that have replacement
	// strings that go with them and the replacement strings
	// that go with them
	//

	//
	// Do formatting of Message. We replace all Variable Tags.
	// Sample string -
	// "Drive %InstanceName% is full. Currently at %CurrentValue%%."
	//

	//
	// Get the origional un-formatted message first.
	// To make case in-sensitive, do a _strdup and then a _wcsupr on the string
	// to scan run the code on it, and then free the duplicated string.
	//
	// If it uses resource IDs, then get that string first, then format that!!!
	hRetRes = GetStrProperty(pInstance, L"Message", &pszMsg);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

	pszUpperMsg = _wcsdup(pszMsg);
	MY_ASSERT(pszUpperMsg); if (!pszUpperMsg) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	_wcsupr(pszUpperMsg);

	//
	// First loop through and find every token that needs replacing.
	// Put that info into the replacement list.
	//
	// We will do strstr() for each special token until there are no more to find
	// for each. At each find we will store the offset into the string of what
	// we found. Then we sort by what came first.
	//
	// Quick test to see if it is worth searching
	if (wcschr(pszUpperMsg, '%'))
	{
		iSize = tokenList.size();
		pStrStart = pszUpperMsg;
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<tokenList.size());
			pTokenElmnt = &tokenList[i];
			pStr = wcsstr(pStrStart, pTokenElmnt->szToken);
			if (pStr != NULL)
			{
				repElmnt.pStartStr = pszMsg+(pStr-pszUpperMsg);
				repElmnt.len = wcslen(pTokenElmnt->szToken);
				repElmnt.pszReplacementText = pTokenElmnt->szReplacementText;
				replacementList.push_back(repElmnt);
				i--;
				pStrStart = pStr+1;
			}
			else
			{
				pStrStart = pszUpperMsg;
			}
		}

		//
		// Need to look for replacement strings that have not been replaced.
		// Simply search for %EmbeddedCollectedInstance. and find the end % for each
		// Replace them with <null>
		//
		pStrStart = pszUpperMsg;
		while (TRUE)
		{
			pStr = wcsstr(pStrStart, L"%EMBEDDEDCOLLECTEDINSTANCE.");
			if (pStr != NULL)
			{
				repElmnt.pStartStr = pszMsg+(pStr-pszUpperMsg);
				pStr2 = pStr;
				while (pStr2++)
				{
					if (*pStr2=='%' || iswspace(*pStr2))
						break;
				}
				if (*pStr2=='%')
				{
					repElmnt.len = (pStr2-pStr)+1;
					repElmnt.pszReplacementText = L"<null>";
					replacementList.push_back(repElmnt);
				}
				pStrStart = pStr+1;
			}
			else
			{
				break;
			}
		}
	}

	iSize = replacementList.size();
	if (iSize != 0)
	{
		//
		// Next, sort the replacement list from the first string to
		// be replaced, to the last. Shell sort, Knuth, Vol13, pg. 84.
		//
		for (int gap=iSize/2; 0<gap; gap/=2)
		{
			for (i=gap; i<iSize; i++)
			{
				for (j=i-gap; 0<=j; j-=gap)
				{
					MY_ASSERT(j+gap<replacementList.size());
					pRepElmnt = &replacementList[j+gap];
					MY_ASSERT(j<replacementList.size());
					pRepElmnt2 = &replacementList[j];
					if (pRepElmnt->pStartStr < pRepElmnt2->pStartStr)
					{
						MY_ASSERT(j<replacementList.size());
						repElmnt = replacementList[j];
						MY_ASSERT(j+gap<replacementList.size());
						replacementList[j] = replacementList[j+gap];
						MY_ASSERT(j+gap<replacementList.size());
						replacementList[j+gap] = repElmnt;
					}
				}
			}
		}

		//
		// Next, figure out the size needed for the Message with
		// everything replaced.
		//
		iSizeNeeded = wcslen(pszMsg)+1;
		iSize = replacementList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<replacementList.size());
			pRepElmnt = &replacementList[i];
			iSizeNeeded -= pRepElmnt->len;
			iSizeNeeded += wcslen(pRepElmnt->pszReplacementText);
		}
		pszNewMsg = new TCHAR[iSizeNeeded];
		MY_ASSERT(pszNewMsg); if (!pszNewMsg) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		*pszNewMsg = '\0';

		//
		// Next, we loop through and do the actual replacements.
		// "Drive %InstanceName% is full. Currently at %CurrentValue%%."
		//
		pszDest = pszMsg;
		iSize = replacementList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<replacementList.size());
			pRepElmnt = &replacementList[i];
			*(pRepElmnt->pStartStr) = '\0';
			wcscat(pszNewMsg, pszDest);
			wcscat(pszNewMsg, pRepElmnt->pszReplacementText);
//XXXWould memcpy be faster???							memcpy(pszDest, source, charCnt*sizeof(TCHAR));
			pszDest = pRepElmnt->pStartStr+pRepElmnt->len;
		}
		wcscat(pszNewMsg, pszDest);
		PutStrProperty(pInstance, L"Message", pszNewMsg);
		delete [] pszNewMsg;
		pszNewMsg = NULL;
		replacementList.clear();
	}
	else
	{
		PutStrProperty(pInstance, L"Message", pszMsg);
	}

	delete [] pszMsg;
	pszMsg = NULL;
	free(pszUpperMsg);
	pszUpperMsg = NULL;

	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (PropName)
		SysFreeString(PropName);
	if (psaNames)
		SafeArrayDestroy(psaNames);
	if (pszNewMsg)
		delete [] pszNewMsg;
	if (pszMsg)
		delete [] pszMsg;
	if (pszUpperMsg)
		free(pszUpperMsg);
	m_bValidLoad = FALSE;
	return hRetRes;
}

BOOL CSystem::SendReminderActionIfStateIsSame(IWbemObjectSink* pActionEventSink, IWbemObjectSink* pActionTriggerEventSink, IWbemClassObject* pActionInstance, IWbemClassObject* pActionTriggerInstance, unsigned long ulTriggerStates)
{
	HRESULT hRetRes = S_OK;
	IWbemClassObject* pInstance = NULL;
	VARIANT v;
	GUID guid;
	TCHAR szStatusGUID[100];
	VariantInit(&v);

	if (m_bValidLoad == FALSE)
		return FALSE;
	//
	// Check to see if still in the desired state
	//
	if (!(ulTriggerStates&(1<<m_lCurrState)))
	{
		return TRUE;
	}

	hRetRes = GetHMSystemStatusInstance(&pInstance, TRUE);
	if (SUCCEEDED(hRetRes))
	{
		hRetRes = PutUint32Property(pActionTriggerInstance, L"State", m_lCurrState);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		VariantInit(&v);
		V_VT(&v) = VT_UNKNOWN;
		V_UNKNOWN(&v) = (IUnknown*)pInstance;
		(V_UNKNOWN(&v))->AddRef();
		hRetRes = (pActionTriggerInstance)->Put(L"EmbeddedStatusEvent", 0L, &v, 0L);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		VariantClear(&v);

		if (pActionEventSink) 
		{
			hRetRes = CoCreateGuid(&guid);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			StringFromGUID2(guid, szStatusGUID, 100);
			hRetRes = PutStrProperty(pActionInstance, L"StatusGUID", szStatusGUID);
			MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
			hRetRes = pActionEventSink->Indicate(1, &pActionInstance);
			//WBEM_E_SERVER_TOO_BUSY is Ok. Wbem will deliver.
			if (FAILED(hRetRes) && hRetRes != WBEM_E_SERVER_TOO_BUSY)
			{
				MY_HRESASSERT(hRetRes);
				MY_OUTPUT(L"Failed on Indicate!", 4);
			}
		}
		if (pActionTriggerEventSink) 
		{
			hRetRes = pActionEventSink->Indicate(1, &pActionTriggerInstance);
			//WBEM_E_SERVER_TOO_BUSY is Ok. Wbem will deliver.
			if (FAILED(hRetRes) && hRetRes != WBEM_E_SERVER_TOO_BUSY)
			{
				MY_HRESASSERT(hRetRes);
				MY_OUTPUT(L"Failed on Indicate!", 4);
			}
		}

		pInstance->Release();
		pInstance = NULL;
	}
	else
	{
		MY_HRESASSERT(hRetRes);
		MY_OUTPUT(L"failed to get instance!", 4);
	}

	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (pInstance)
		pInstance->Release();
	return FALSE;
}

HRESULT CSystem::AddPointerToMasterList(CBase *pBaseIn)
{
	int i, iSize;
	CBase* pBase;

	MY_ASSERT(pBaseIn->m_szGUID);
	if (pBaseIn->m_szGUID == NULL)
		return S_FALSE;

	iSize = m_masterList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_masterList.size());
		pBase = m_masterList[i];
		if (pBaseIn->m_szGUID == pBase->m_szGUID)
		{
			MY_ASSERT(FALSE);
			return S_FALSE;
		}
	}

	m_masterList.push_back(pBaseIn);

	return S_OK;
}

BOOL CSystem::RemovePointerFromMasterList(CBase *pBaseIn)
{
	int i, iSize;
	CBase* pBase;
	BLIST::iterator iaB;

	MY_ASSERT(pBaseIn->m_szGUID);
	if (pBaseIn->m_szGUID == NULL)
		return FALSE;

	iaB=m_masterList.begin();
	iSize = m_masterList.size();
	for (i=0; i<iSize; i++, iaB++)
	{
		MY_ASSERT(i<m_masterList.size());
		pBase = m_masterList[i];
		if (pBaseIn->m_szGUID == pBase->m_szGUID)
		{
			m_masterList.erase(iaB);
			return TRUE;
		}
	}

	MY_ASSERT(FALSE);
	return FALSE;
}

CBase *CSystem::FindPointerFromGUIDInMasterList(LPTSTR pszGUID)
{
	int i, iSize;
	CBase* pBase;

	MY_ASSERT(pszGUID);
	if (pszGUID == NULL)
		return NULL;

	iSize = m_masterList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_masterList.size());
		pBase = m_masterList[i];
		if (!_wcsicmp(pszGUID, pBase->m_szGUID))
		{
			return pBase;
		}
	}

	return NULL;
}

HRESULT CSystem::RemapActions(void)
{
	int i, iSize;
	CAction* pAction;

	iSize = m_actionList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_actionList.size());
		pAction = m_actionList[i];
		pAction->RemapAction();
	}

	return S_OK;
}

HRESULT CSystem::CheckAllForBadLoad(void)
{
	int i, iSize;
	CBase* pBase;
	CAction* pAction;

//Verify the System???
	CheckForBadLoad();

	iSize = m_masterList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_masterList.size());
		pBase = m_masterList[i];
		pBase->CheckForBadLoad();
	}

	iSize = m_actionList.size();
	for (i=0; i < iSize; i++)
	{
		MY_ASSERT(i<m_actionList.size());
		pAction = m_actionList[i];
		pAction->CheckForBadLoad();
	}

	return S_OK;
}

HRESULT CSystem::CheckForBadLoad(void)
{
	HRESULT hRetRes = S_OK;
	IWbemClassObject* pObj = NULL;
	TCHAR szTemp[1024];
	IWbemClassObject* pInstance = NULL;
		HRESULT hRes;

	if (m_bValidLoad == FALSE)
	{
		wcscpy(szTemp, L"MicrosoftHM_SystemConfiguration.GUID=\"");
		lstrcat(szTemp, m_szGUID);
		lstrcat(szTemp, L"\"");
		hRetRes = GetWbemObjectInst(&g_pIWbemServices, szTemp, NULL, &pObj);
		if (!pObj)
		{
			MY_HRESASSERT(hRetRes);
			return S_FALSE;
		}
		hRetRes = LoadInstanceFromMOF(pObj);
		// Here is where we can try and send out a generic SOS if the load failed each time!!!
		if (hRetRes != S_OK)
		{
			hRes = GetHMSystemStatusInstance(&pInstance, TRUE);
		}
		else
		{
			hRes = GetHMSystemStatusInstance(&pInstance, TRUE);
		}
		if (SUCCEEDED(hRes) && g_pSystemEventSink)
		{
			MY_OUTPUT2(L"EVENT: System State Change=%d", m_lCurrState, 4);
			hRes = g_pSystemEventSink->Indicate(1, &pInstance);
			// WBEM_E_SERVER_TOO_BUSY is Ok. Wbem will deliver.
			if (FAILED(hRes) && hRes != WBEM_E_SERVER_TOO_BUSY)
			{
				MY_HRESASSERT(hRes);
				MY_OUTPUT(L"Failed on Indicate!", 4);
			}
				pInstance->Release();
			pInstance = NULL;
		}
		else
		{
			MY_HRESASSERT(hRes);
			MY_OUTPUT(L"failed to get instance!", 4);
		}
		MY_HRESASSERT(hRetRes);
		pObj->Release();
		pObj = NULL;
		return hRetRes;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\tmpcnsmr.h ===
// tmpcnsmr.h: interface for the CConsumer class.
//
//////////////////////////////////////////////////////////////////////
#if !defined( __TMPCNSMR_H )
#define __TMPCNSMR_H

#include <wbemprov.h>
//#include "eqde.h"
class CEventQueryDataCollector; // Forward declaration
enum HMTEMPEVENT_TYPE {HMTEMPEVENT_ACTION, HMTEMPEVENT_EQDC, HMTEMPEVENT_ACTIONERROR, HMTEMPEVENT_ACTIONSID};

class CTempConsumer : public IWbemObjectSink
{
// Constructor/Destructor
public:
	CTempConsumer(HMTEMPEVENT_TYPE eventType);
	CTempConsumer(LPTSTR szGUID);
	CTempConsumer(CEventQueryDataCollector *pEQDC);
	virtual ~CTempConsumer();

public:
// IUnknown
	STDMETHODIMP					QueryInterface(REFIID riid, LPVOID* ppv);
	STDMETHODIMP_(ULONG)	AddRef(void);
	STDMETHODIMP_(ULONG)	Release(void);

	STDMETHODIMP Indicate(long lObjectCount, IWbemClassObject** ppObjArray);

	STDMETHODIMP SetStatus(long lFlags, HRESULT hResult, BSTR strParam,
													IWbemClassObject* pObjParam);
private:
	UINT m_cRef;
	TCHAR m_szGUID[1024];
	CEventQueryDataCollector *m_pEQDC;
	HMTEMPEVENT_TYPE m_hmTempEventType;
};

#endif  // __TMPCNSMR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\tmpcnsmr.cpp ===
// tmpcnsmr.cpp: implementation of the CConsumer class.
//
//////////////////////////////////////////////////////////////////////

#include "HMAgent.h"
#include "system.h"
#include "tmpcnsmr.h"

extern CSystem* g_pSystem;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTempConsumer::CTempConsumer(HMTEMPEVENT_TYPE eventType)
{
	m_cRef = 1;
	m_hmTempEventType = eventType;
}

CTempConsumer::CTempConsumer(LPTSTR szGUID)
{
	m_cRef = 1;
	m_hmTempEventType = HMTEMPEVENT_ACTION;
	wcscpy(m_szGUID, szGUID);
}

CTempConsumer::CTempConsumer(CEventQueryDataCollector *pEQDC)
{
	MY_ASSERT(pEQDC);
	m_cRef = 1;
	m_hmTempEventType = HMTEMPEVENT_EQDC;
	m_pEQDC = pEQDC;
}

CTempConsumer::~CTempConsumer()
{
}

//////////////////////////////////////////////////////////////////////
// IUnknown Implementation
//////////////////////////////////////////////////////////////////////
STDMETHODIMP CTempConsumer::QueryInterface(REFIID riid, LPVOID* ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IWbemObjectSink == riid)
    {
        *ppv = (IWbemEventProvider *) this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CTempConsumer::AddRef(void)
{
	return InterlockedIncrement((long*)&m_cRef);
}

STDMETHODIMP_(ULONG) CTempConsumer::Release(void)
{
	LONG	lCount = InterlockedDecrement((long*)&m_cRef);

	if (0 != lCount)
	{
		return lCount;
	}

	delete this;
	return 0L;
}

//////////////////////////////////////////////////////////////////////
// IWbemObjectSink Implementation
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CTempConsumer::Indicate(long lObjectCount, IWbemClassObject** ppObjArray)
{
	if (!g_pSystem)
	{
		return WBEM_E_NOT_AVAILABLE;
	}

	for (long i = 0; i < lObjectCount; i++)
	{
		IWbemClassObject *pObj = ppObjArray[i];
		switch(m_hmTempEventType)
		{
		case HMTEMPEVENT_ACTION:
			g_pSystem->HandleTempActionEvent(m_szGUID, pObj);
			break;
		case HMTEMPEVENT_EQDC:
			g_pSystem->HandleTempEvent(m_pEQDC, pObj);
			break;
		case HMTEMPEVENT_ACTIONERROR:
			g_pSystem->HandleTempActionErrorEvent(pObj);
			break;
		case HMTEMPEVENT_ACTIONSID:
			g_pSystem->HandleTempActionSIDEvent(pObj);
			break;
		default:
			MY_ASSERT(FALSE);
		}
	}

	return WBEM_NO_ERROR;
}


//***************************************************************************
STDMETHODIMP CTempConsumer::SetStatus(
    long lFlags,
    HRESULT hResult,
    BSTR strParam,
    IWbemClassObject* pObjParam
    )
{
    // Not called during event delivery.
        
    return WBEM_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\threshld.cpp ===
//***************************************************************************
//
//  THRESHLD.CPP
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: CThreshold class to do thresholding on a CDatapoint class.
//  The CDatapoint class contains the WMI instance, and the CThreshold
//  class says what ptoperty to threshold against, and how.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <stdio.h>
#include <tchar.h>
#include "threshld.h"
#include "datacltr.h"
#include "system.h"

extern CSystem* g_pSystem;
extern CSystem* g_pStartupSystem;
BOOL CThreshold::mg_bEnglishCompare = TRUE;


//STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC
void CThreshold::ThresholdTerminationCleanup(void)
{
	if (g_pThresholdEventSink != NULL)
	{
		g_pThresholdEventSink->Release();
		g_pThresholdEventSink = NULL;
	}

#ifdef SAVE
	if (g_pThresholdInstanceEventSink != NULL)
	{
		g_pThresholdInstanceEventSink->Release();
		g_pThresholdInstanceEventSink = NULL;
	}
#endif
}

//STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC
void CThreshold::GetLocal(void)
{
	LCID lcID = PRIMARYLANGID(GetSystemDefaultLCID());
	if (lcID != 0 && lcID == 0x00000009)
	{
		mg_bEnglishCompare = TRUE;
	}
	else
	{
		mg_bEnglishCompare = FALSE;
	}
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CThreshold::CThreshold()
{
	MY_OUTPUT(L"ENTER ***** CThreshold...", 4);

	Init();
	m_hmStatusType = HMSTATUS_THRESHOLD;
	m_bValidLoad = FALSE;

	MY_OUTPUT(L"EXIT ***** CThreshold...", 4);
}

CThreshold::~CThreshold()
{
	MY_OUTPUT(L"ENTER ***** ~CThreshold...", 4);

	g_pStartupSystem->RemovePointerFromMasterList(this);
	Cleanup(FALSE);
	if (m_szGUID)
	{
		delete [] m_szGUID;
		m_szGUID = NULL;
	}
	m_bValidLoad = FALSE;

	MY_OUTPUT(L"EXIT ***** ~CThreshold...", 4);
}

//
// Load a single Threshold
//
HRESULT CThreshold::LoadInstanceFromMOF(IWbemClassObject* pObj, CDataCollector *pParentDC, LPTSTR pszParentObjPath, BOOL bModifyPass/*FALSE*/)
{
	long lTemp;
	HRESULT hRes = S_OK;
	BOOL bRetValue = TRUE;

	MY_OUTPUT(L"ENTER ***** CThreshold::LoadInstanceFromMOF...", 4);

	Cleanup(bModifyPass);
	m_bValidLoad = TRUE;

	if (bModifyPass == FALSE)
	{
		// This is the first initial read in of this
		// Get the GUID property
		// If this fails we will actually not go through with the creation of this object.
		if (m_szGUID)
		{
			delete [] m_szGUID;
			m_szGUID = NULL;
		}
		hRes = GetStrProperty(pObj, L"GUID", &m_szGUID);
		MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;

		m_szParentObjPath = new TCHAR[wcslen(pszParentObjPath)+1];
		MY_ASSERT(m_szParentObjPath); if (!m_szParentObjPath) {hRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		wcscpy(m_szParentObjPath, pszParentObjPath);
		m_pParentDC = pParentDC;
		hRes = g_pStartupSystem->AddPointerToMasterList(this);
		MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;
	}

	hRes = GetStrProperty(pObj, L"Name", &m_szName);
	MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;

	hRes = GetStrProperty(pObj, L"Description", &m_szDescription);
	MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;

	hRes = GetStrProperty(pObj, L"PropertyName", &m_szPropertyName);
	MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;

	if (!wcscmp(m_szPropertyName, L""))
	{
		delete [] m_szPropertyName;
		m_szPropertyName = new TCHAR[wcslen(L"CollectionErrorCode")+1];
		MY_ASSERT(m_szPropertyName); if (!m_szPropertyName) {hRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		wcscpy(m_szPropertyName, L"CollectionErrorCode");
	}

	bRetValue = GetUint32Property(pObj, L"UseFlag", &lTemp);
	MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;
	if (lTemp == 0)
	{
		m_bUseAverage = FALSE;
		m_bUseDifference = FALSE;
	}
	else if (lTemp == 1)
	{
		m_bUseAverage = TRUE;
		m_bUseDifference = FALSE;
	}
	else if (lTemp == 2)
	{
		m_bUseAverage = FALSE;
		m_bUseDifference = TRUE;
	}
	else
	{
		m_bUseAverage = FALSE;
		m_bUseDifference = FALSE;
		MY_ASSERT(FALSE);
	}

//	hRes = GetBoolProperty(pObj, L"UseSum", &m_bUseSum);
//	MY_HRESASSERT(hRes);
m_bUseSum = FALSE;

	//[values {"<",">","=","!=",">=","<=","contains","!contains","always"}]
	hRes = GetUint32Property(pObj, L"TestCondition", &m_lTestCondition);
	MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;

	hRes = GetStrProperty(pObj, L"CompareValue", &m_szCompareValue);
	MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;
	m_lCompareValue = wcstol(m_szCompareValue, NULL, 10);
	m_ulCompareValue = wcstoul(m_szCompareValue, NULL, 10);
	m_fCompareValue = (float) wcstod(m_szCompareValue, NULL);
	m_dCompareValue = wcstod(m_szCompareValue, NULL);
	m_i64CompareValue = _wtoi64(m_szCompareValue);
	m_ui64CompareValue = 0;
	ReadUI64(m_szCompareValue, m_ui64CompareValue);

	hRes = GetUint32Property(pObj, L"ThresholdDuration", &m_lThresholdDuration);
	MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;

	//[values {"CRITICAL","WARNING","INFO","RESET"}]
	hRes = GetUint32Property(pObj, L"State", &m_lViolationToState);
	MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;

	hRes = GetStrProperty(pObj, L"CreationDate", &m_szCreationDate);
	MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;

	hRes = GetStrProperty(pObj, L"LastUpdate", &m_szLastUpdate);
	MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;

	hRes = GetBoolProperty(pObj, L"Enabled", &m_bEnabled);
	MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;

	if (bModifyPass == FALSE)
	{
		if (m_bEnabled==FALSE || m_pParentDC->m_bEnabled==FALSE || m_pParentDC->m_bParentEnabled==FALSE)
		{
			if (m_pParentDC->m_bEnabled==FALSE || m_pParentDC->m_bParentEnabled==FALSE)
				m_bParentEnabled = FALSE;
			// Since our parent is disabled, we will not be able to get into
			// our OnAgentInterval function and send the disabled status later.
			SetCurrState(HM_DISABLED);
			FireEvent(TRUE);
		}
	}
	else
	{
		if (m_pParentDC->m_deType==HM_EQDE)
		{
			if (m_bEnabled==FALSE || m_pParentDC->m_bEnabled==FALSE || m_pParentDC->m_bParentEnabled==FALSE)
			{
				SetCurrState(HM_DISABLED);
				FireEvent(FALSE);
			}
		}
	}

	m_bValidLoad = TRUE;
	MY_OUTPUT(L"EXIT ***** CThreshold::LoadInstanceFromMOF...", 4);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	Cleanup(FALSE);
	m_bValidLoad = FALSE;
	return hRes;
}

BOOL CThreshold::SkipClean(void)
{
	IRSSTRUCT *pirs;
	int i, iSize;

	m_lNumberChanges = 0;

	//
	// Clear things before we start
	//
	m_lPrevState = m_lCurrState;
	iSize = m_irsList.size();
	for (i = 0; i < iSize; i++)
	{
		MY_ASSERT(i<m_irsList.size());
		pirs = &m_irsList[i];
		pirs->lPrevState = m_lCurrState;
		pirs->lCurrState = m_lCurrState;
		pirs->unknownReason = 0;
	}

	return TRUE;
}

//
// Evaluate this threshold against the property just collected
//
BOOL CThreshold::OnAgentInterval(ACTUALINSTLIST *actualInstList, PNSTRUCT *ppn, BOOL bRequireReset)
{
	long state;
	INSTSTRUCT *pinst;
	IRSSTRUCT *pirs;
	union hm_datatypes delta;
	int i, iSize;

	//
	// Don't do anything if we are not loaded correctly.
	//
	if (m_bValidLoad == FALSE)
		return FALSE;

	m_lNumberChanges = 0;

	//
	// Don't do anything if we are already in the state we need to be in.
	// DISABLED, SCHEDULEDOUT
	//
	if (((m_bEnabled==FALSE || m_bParentEnabled==FALSE) && m_lCurrState==HM_DISABLED) ||
		(m_bParentScheduledOut==TRUE && m_lCurrState==HM_SCHEDULEDOUT))
	{
		// The DISABLED and SCHEDULEDOUT states override the UNKNWON. We may be transitioning.
		if (((m_bEnabled==FALSE || m_bParentEnabled==FALSE) && m_lCurrState!=HM_DISABLED) ||
			(m_bParentScheduledOut==TRUE && m_lCurrState!=HM_SCHEDULEDOUT))
		{
			// The DISABLED state overrides SCHEDULEDOUT. We may be transitioning.
			if (((m_bEnabled==FALSE || m_bParentEnabled==FALSE) && m_lCurrState!=HM_DISABLED))
			{
			}
			else
			{
				if (m_lPrevState != m_lCurrState)
				{
					m_lPrevState = m_lCurrState;
					iSize = m_irsList.size();
					for (i = 0; i < iSize; i++)
					{
						MY_ASSERT(i<m_irsList.size());
						pirs = &m_irsList[i];
						pirs->lPrevState = m_lCurrState;
						pirs->lCurrState = m_lCurrState;
						pirs->unknownReason = 0;
					}
				}
				return TRUE;
			}
		}
		else
		{
			if (m_lPrevState != m_lCurrState)
			{
				m_lPrevState = m_lCurrState;
				iSize = m_irsList.size();
				for (i = 0; i < iSize; i++)
				{
					MY_ASSERT(i<m_irsList.size());
					pirs = &m_irsList[i];
					pirs->lPrevState = m_lCurrState;
					pirs->lCurrState = m_lCurrState;
					pirs->unknownReason = 0;
				}
			}
			return TRUE;
		}
	}

	//
	// Clear things before we start
	//
	m_lPrevState = m_lCurrState;
	iSize = m_irsList.size();
	for (i = 0; i < iSize; i++)
	{
		MY_ASSERT(i<m_irsList.size());
		pirs = &m_irsList[i];
		if ((m_lCurrState==HM_CRITICAL || m_lCurrState==HM_WARNING) && m_pParentDC->m_deType!=HM_EQDE)
		{
			pirs->lPrevState = pirs->lCurrState;
		}
		else
		{
			pirs->lPrevState = m_lCurrState;
			pirs->lCurrState = m_lCurrState;
		}
		pirs->unknownReason = 0;
	}

	//
	// This is where we are transitioning into the DISABLED State.
	//
	if (m_bEnabled==FALSE || m_bParentEnabled==FALSE)
	{
		SetCurrState(HM_DISABLED);
	}
	else if (m_bParentScheduledOut==TRUE)
	{
		SetCurrState(HM_SCHEDULEDOUT);
	}
	else
	{
		if (bRequireReset && (m_lCurrState==HM_WARNING || m_lCurrState==HM_CRITICAL))
			return TRUE;
		int x = ppn->instList.size();
		int y = m_irsList.size();
		// Check for something that should not be happening
		if (x != y)
		{
			MY_OUTPUT(L"BAD BAD BAD - Vector sizes do not match!!!", 2);
			MY_ASSERT(FALSE);
			return TRUE;
		}

		//
		// For each instance, evaluate what the current state is.
		//
		MY_ASSERT(ppn->instList.size() == m_irsList.size());
		iSize = ppn->instList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<ppn->instList.size());
			pinst = &ppn->instList[i];
			MY_ASSERT(i<m_irsList.size());
			pirs = &m_irsList[i];
	
			// Things to do the first evaluation that happens.
			if (ppn->type == CIM_REAL32)
			{
				if (pirs->fPrevValue == MAX_FLOAT)
				{
					if (m_bUseAverage)
						pirs->fPrevValue = pinst->avgValue.fValue;
					else
						pirs->fPrevValue = pinst->currValue.fValue;
				}
			}
			else if (ppn->type == CIM_REAL64)
			{
				if (pirs->dPrevValue == MAX_DOUBLE)
				{
					if (m_bUseAverage)
						pirs->dPrevValue = pinst->avgValue.dValue;
					else
						pirs->dPrevValue = pinst->currValue.dValue;
				}
			}
			else if (ppn->type == CIM_SINT64)
			{
				if (pirs->i64PrevValue == MAX_I64)
				{
					if (m_bUseAverage)
						pirs->i64PrevValue = pinst->avgValue.i64Value;
					else
						pirs->i64PrevValue = pinst->currValue.i64Value;
				}
			}
			else if (ppn->type == CIM_UINT64)
			{
				if (pirs->ui64PrevValue == MAX_UI64)
				{
					if (m_bUseAverage)
						pirs->ui64PrevValue = pinst->avgValue.ui64Value;
					else
						pirs->ui64PrevValue = pinst->currValue.ui64Value;
				}
			}
			else if (ppn->type == CIM_UINT32)
			{
				if (pirs->ulPrevValue == MAX_ULONG)
				{
					if (m_bUseAverage)
						pirs->ulPrevValue = pinst->avgValue.ulValue;
					else
						pirs->ulPrevValue = pinst->currValue.ulValue;
				}
			}
			else
			{
				if (pirs->lPrevValue == MAX_LONG)
				{
					if (m_bUseAverage)
						pirs->lPrevValue = pinst->avgValue.lValue;
					else
						pirs->lPrevValue = pinst->currValue.lValue;
				}
			}
	
			if (ppn->type == CIM_REAL32)
			{
				pirs->fPrevPrevValue = pirs->fPrevValue;
			}
			else if (ppn->type == CIM_REAL64)
			{
				pirs->dPrevPrevValue = pirs->dPrevValue;
			}
			else if (ppn->type == CIM_SINT64)
			{
				pirs->i64PrevPrevValue = pirs->i64PrevValue;
			}
			else if (ppn->type == CIM_UINT64)
			{
				pirs->ui64PrevPrevValue = pirs->ui64PrevValue;
			}
			else if (ppn->type == CIM_UINT32)
			{
				pirs->ulPrevPrevValue = pirs->ulPrevValue;
			}
			else
			{
				pirs->lPrevPrevValue = pirs->lPrevValue;
			}

			if ((pirs->lCurrState!=HM_CRITICAL && pirs->lCurrState!=HM_WARNING && pirs->lCurrState!=HM_RESET) ||
				m_lViolationToState!=pirs->lCurrState)
			{
				if (pirs->lCurrState!=HM_GOOD)
					pirs->lCurrState = HM_GOOD;
				if (m_bUseDifference)
				{
					if (m_bUseAverage)
					{
						if (ppn->type == CIM_REAL32)
						{
							if (pinst->avgValue.fValue < pirs->fPrevValue)
								delta.fValue = pirs->fPrevValue-pinst->avgValue.fValue;
							else
								delta.fValue = pinst->avgValue.fValue-pirs->fPrevValue;
						}
						else if (ppn->type == CIM_REAL64)
						{
							if (pinst->avgValue.dValue < pirs->dPrevValue)
								delta.dValue = pirs->dPrevValue-pinst->avgValue.dValue;
							else
								delta.dValue = pinst->avgValue.dValue-pirs->dPrevValue;
						}
						else if (ppn->type == CIM_SINT64)
						{
							if (pinst->avgValue.i64Value < pirs->i64PrevValue)
								delta.i64Value = pirs->i64PrevValue-pinst->avgValue.i64Value;
							else
								delta.i64Value = pinst->avgValue.i64Value-pirs->i64PrevValue;
						}
						else if (ppn->type == CIM_UINT64)
						{
							if (pinst->avgValue.ui64Value < pirs->ui64PrevValue)
								delta.ui64Value = pirs->ui64PrevValue-pinst->avgValue.ui64Value;
							else
								delta.ui64Value = pinst->avgValue.ui64Value-pirs->ui64PrevValue;
						}
						else if (ppn->type == CIM_UINT32)
						{
							if (pinst->avgValue.ulValue < pirs->ulPrevValue)
								delta.ulValue = pirs->ulPrevValue-pinst->avgValue.ulValue;
							else
								delta.ulValue = pinst->avgValue.ulValue-pirs->ulPrevValue;
						}
						else
						{
							if (pinst->avgValue.lValue < pirs->lPrevValue)
								delta.lValue = pirs->lPrevValue-pinst->avgValue.lValue;
							else
								delta.lValue = pinst->avgValue.lValue-pirs->lPrevValue;
						}
						CrossTest(ppn, pirs, L"", delta, pinst);
						if (ppn->type == CIM_REAL32)
						{
							pirs->fPrevValue = pinst->avgValue.fValue;
						}
						else if (ppn->type == CIM_REAL64)
						{
							pirs->dPrevValue = pinst->avgValue.dValue;
						}
						else if (ppn->type == CIM_SINT64)
						{
							pirs->i64PrevValue = pinst->avgValue.i64Value;
						}
						else if (ppn->type == CIM_UINT64)
						{
							pirs->ui64PrevValue = pinst->avgValue.ui64Value;
						}
						else if (ppn->type == CIM_UINT32)
						{
							pirs->ulPrevValue = pinst->avgValue.ulValue;
						}
						else
						{
							pirs->lPrevValue = pinst->avgValue.lValue;
						}
					}
					else
					{
						if (ppn->type == CIM_REAL32)
						{
							if (pinst->currValue.fValue < pirs->fPrevValue)
								delta.fValue = pirs->fPrevValue-pinst->currValue.fValue;
							else
								delta.fValue = pinst->currValue.fValue-pirs->fPrevValue;
						}
						else if (ppn->type == CIM_REAL64)
						{
							if (pinst->currValue.dValue < pirs->dPrevValue)
								delta.dValue = pirs->dPrevValue-pinst->currValue.dValue;
							else
								delta.dValue = pinst->currValue.dValue-pirs->dPrevValue;
						}
						else if (ppn->type == CIM_SINT64)
						{
							if (pinst->currValue.i64Value < pirs->i64PrevValue)
								delta.i64Value = pirs->i64PrevValue-pinst->currValue.i64Value;
							else
								delta.i64Value = pinst->currValue.i64Value-pirs->i64PrevValue;
						}
						else if (ppn->type == CIM_UINT64)
						{
							if (pinst->currValue.ui64Value < pirs->ui64PrevValue)
								delta.ui64Value = pirs->ui64PrevValue-pinst->currValue.ui64Value;
							else
								delta.ui64Value = pinst->currValue.ui64Value-pirs->ui64PrevValue;
						}
						else if (ppn->type == CIM_UINT32)
						{
							if (pinst->currValue.ulValue < pirs->ulPrevValue)
								delta.ulValue = pirs->ulPrevValue-pinst->currValue.ulValue;
							else
								delta.ulValue = pinst->currValue.ulValue-pirs->ulPrevValue;
						}
						else
						{
							if (pinst->currValue.lValue < pirs->lPrevValue)
								delta.lValue = pirs->lPrevValue-pinst->currValue.lValue;
							else
								delta.lValue = pinst->currValue.lValue-pirs->lPrevValue;
						}
						CrossTest(ppn, pirs, L"", delta, pinst);
						if (ppn->type == CIM_REAL32)
						{
							pirs->fPrevValue = pinst->currValue.fValue;
						}
						else if (ppn->type == CIM_REAL64)
						{
							pirs->dPrevValue = pinst->currValue.dValue;
						}
						else if (ppn->type == CIM_SINT64)
						{
							pirs->i64PrevValue = pinst->currValue.i64Value;
						}
						else if (ppn->type == CIM_UINT64)
						{
							pirs->ui64PrevValue = pinst->currValue.ui64Value;
						}
						else if (ppn->type == CIM_UINT32)
						{
							pirs->ulPrevValue = pinst->currValue.ulValue;
						}
						else
						{
							pirs->lPrevValue = pinst->currValue.lValue;
						}
					}
				}
				else
				{
					if (m_bUseAverage)
					{
						CrossTest(ppn, pirs, L"", pinst->avgValue, pinst);
						if (ppn->type == CIM_REAL32)
						{
							pirs->fPrevValue = pinst->avgValue.fValue;
						}
						else if (ppn->type == CIM_REAL64)
						{
							pirs->dPrevValue = pinst->avgValue.dValue;
						}
						else if (ppn->type == CIM_SINT64)
						{
							pirs->i64PrevValue = pinst->avgValue.i64Value;
						}
						else if (ppn->type == CIM_UINT64)
						{
							pirs->ui64PrevValue = pinst->avgValue.ui64Value;
						}
						else if (ppn->type == CIM_UINT32)
						{
							pirs->ulPrevValue = pinst->avgValue.ulValue;
						}
						else
						{
							pirs->lPrevValue = pinst->avgValue.lValue;
						}
					}
					else
					{
						CrossTest(ppn, pirs, pinst->szCurrValue, pinst->currValue, pinst);
					}
				}
			}
			else
			{
				if (m_bUseDifference)
				{
					if (m_bUseAverage)
					{
						if (ppn->type == CIM_REAL32)
						{
							if (pinst->avgValue.fValue < pirs->fPrevValue)
								delta.fValue = pirs->fPrevValue-pinst->avgValue.fValue;
							else
								delta.fValue = pinst->avgValue.fValue-pirs->fPrevValue;
						}
						else if (ppn->type == CIM_REAL64)
						{
							if (pinst->avgValue.dValue < pirs->dPrevValue)
								delta.dValue = pirs->dPrevValue-pinst->avgValue.dValue;
							else
								delta.dValue = pinst->avgValue.dValue-pirs->dPrevValue;
						}
						else if (ppn->type == CIM_SINT64)
						{
							if (pinst->avgValue.i64Value < pirs->i64PrevValue)
								delta.i64Value = pirs->i64PrevValue-pinst->avgValue.i64Value;
							else
								delta.i64Value = pinst->avgValue.i64Value-pirs->i64PrevValue;
						}
						else if (ppn->type == CIM_UINT64)
						{
							if (pinst->avgValue.ui64Value < pirs->ui64PrevValue)
								delta.ui64Value = pirs->ui64PrevValue-pinst->avgValue.ui64Value;
							else
								delta.ui64Value = pinst->avgValue.ui64Value-pirs->ui64PrevValue;
						}
						else if (ppn->type == CIM_UINT32)
						{
							if (pinst->avgValue.ulValue < pirs->ulPrevValue)
								delta.ulValue = pirs->ulPrevValue-pinst->avgValue.ulValue;
							else
								delta.ulValue = pinst->avgValue.ulValue-pirs->ulPrevValue;
						}
						else
						{
							if (pinst->avgValue.lValue < pirs->lPrevValue)
								delta.lValue = pirs->lPrevValue-pinst->avgValue.lValue;
							else
								delta.lValue = pinst->avgValue.lValue-pirs->lPrevValue;
						}
						RearmTest(ppn, pirs, L"", delta, pinst);
						if (ppn->type == CIM_REAL32)
						{
							pirs->fPrevValue = pinst->avgValue.fValue;
						}
						else if (ppn->type == CIM_REAL64)
						{
							pirs->dPrevValue = pinst->avgValue.dValue;
						}
						else if (ppn->type == CIM_SINT64)
						{
							pirs->i64PrevValue = pinst->avgValue.i64Value;
						}
						else if (ppn->type == CIM_UINT64)
						{
							pirs->ui64PrevValue = pinst->avgValue.ui64Value;
						}
						else if (ppn->type == CIM_UINT32)
						{
							pirs->ulPrevValue = pinst->avgValue.ulValue;
						}
						else
						{
							pirs->lPrevValue = pinst->avgValue.lValue;
						}
					}
					else
					{
						if (ppn->type == CIM_REAL32)
						{
							if (pinst->currValue.fValue < pirs->fPrevValue)
								delta.fValue = pirs->fPrevValue-pinst->currValue.fValue;
							else
								delta.fValue = pinst->currValue.fValue-pirs->fPrevValue;
						}
						else if (ppn->type == CIM_REAL64)
						{
							if (pinst->currValue.dValue < pirs->dPrevValue)
								delta.dValue = pirs->dPrevValue-pinst->currValue.dValue;
							else
								delta.dValue = pinst->currValue.dValue-pirs->dPrevValue;
						}
						else if (ppn->type == CIM_SINT64)
						{
							if (pinst->currValue.i64Value < pirs->i64PrevValue)
								delta.i64Value = pirs->i64PrevValue-pinst->currValue.i64Value;
							else
								delta.i64Value = pinst->currValue.i64Value-pirs->i64PrevValue;
						}
						else if (ppn->type == CIM_UINT64)
						{
							if (pinst->currValue.ui64Value < pirs->ui64PrevValue)
								delta.ui64Value = pirs->ui64PrevValue-pinst->currValue.ui64Value;
							else
								delta.ui64Value = pinst->currValue.ui64Value-pirs->ui64PrevValue;
						}
						else if (ppn->type == CIM_UINT32)
						{
							if (pinst->currValue.ulValue < pirs->ulPrevValue)
								delta.ulValue = pirs->ulPrevValue-pinst->currValue.ulValue;
							else
								delta.ulValue = pinst->currValue.ulValue-pirs->ulPrevValue;
						}
						else
						{
							if (pinst->currValue.lValue < pirs->lPrevValue)
								delta.lValue = pirs->lPrevValue-pinst->currValue.lValue;
							else
								delta.lValue = pinst->currValue.lValue-pirs->lPrevValue;
						}
						RearmTest(ppn, pirs, L"", delta, pinst);
						if (ppn->type == CIM_REAL32)
						{
							pirs->fPrevValue = pinst->currValue.fValue;
						}
						else if (ppn->type == CIM_REAL64)
						{
							pirs->dPrevValue = pinst->currValue.dValue;
						}
						else if (ppn->type == CIM_SINT64)
						{
							pirs->i64PrevValue = pinst->currValue.i64Value;
						}
						else if (ppn->type == CIM_UINT64)
						{
							pirs->ui64PrevValue = pinst->currValue.ui64Value;
						}
						else if (ppn->type == CIM_UINT32)
						{
							pirs->ulPrevValue = pinst->currValue.ulValue;
						}
						else
						{
							pirs->lPrevValue = pinst->currValue.lValue;
						}
					}
				}
				else
				{
					if (m_bUseAverage)
					{
						RearmTest(ppn, pirs, L"", pinst->avgValue, pinst);
						if (ppn->type == CIM_REAL32)
						{
							pirs->fPrevValue = pinst->avgValue.fValue;
						}
						else if (ppn->type == CIM_REAL64)
						{
							pirs->dPrevValue = pinst->avgValue.dValue;
						}
						else if (ppn->type == CIM_SINT64)
						{
							pirs->i64PrevValue = pinst->avgValue.i64Value;
						}
						else if (ppn->type == CIM_UINT64)
						{
							pirs->ui64PrevValue = pinst->avgValue.ui64Value;
						}
						else if (ppn->type == CIM_UINT32)
						{
							pirs->ulPrevValue = pinst->avgValue.ulValue;
						}
						else
						{
							pirs->lPrevValue = pinst->avgValue.lValue;
						}
					}
					else
					{
						RearmTest(ppn, pirs, pinst->szCurrValue, pinst->currValue, pinst);
					}
				}
			}
		}

		//
		// Set the state to the worst of all instances
		//
		m_lNumberNormals = 0;
		m_lNumberWarnings = 0;
		m_lNumberCriticals = 0;
		m_lNumberChanges = 0;
		m_lCurrState = -1;
		iSize = m_irsList.size();
		for (i = 0; i < iSize; i++)
		{
			MY_ASSERT(i<m_irsList.size());
			pirs = &m_irsList[i];
			state = pirs->lCurrState;
			if (state > m_lCurrState)
			{
				m_lCurrState = state;
			}
			if (state == HM_GOOD)
			{
				m_lNumberNormals++;
			}
			if (state == HM_WARNING)
			{
				m_lNumberWarnings++;
			}
			if (state == HM_CRITICAL)
			{
				m_lNumberCriticals++;
			}
			if (pirs->lPrevState != pirs->lCurrState)
			{
//MY_OUTPUT2(L"CHANGE state=%d", state, 4);
				m_lNumberChanges++;
			}
		}

		// Maybe we don't have anything underneith
		if (m_lCurrState == -1)
		{
			m_lCurrState = HM_GOOD;
			if (m_lPrevState != m_lCurrState)
			{
				m_lNumberChanges = 1;
			}
		}
	}

	//
	// the INFO state is not a state that we can transition to, but we just send out the message.
	//
	if (m_lCurrState == HM_INFO)
	{
		m_lCurrState = HM_GOOD;
	}
	else
	{
		FireEvent(FALSE);
	}

	return TRUE;
}

//
// If there has been a change in the state then send an event
//
BOOL CThreshold::FireEvent(BOOL bForce)
{
	BOOL bRetValue = TRUE;
	IWbemClassObject* pInstance = NULL;
	HRESULT hRes;
	IRSSTRUCT *pirs;
	int i, iSize;

	MY_OUTPUT(L"ENTER ***** CThreshold::FireEvent...", 2);

	// A quick test to see if anything has really changed!
	// Proceed if there have been changes
	if (m_lViolationToState==HM_RESET && bForce==FALSE && m_lNumberChanges!=0)
	{
		if (m_lPrevState==HM_DISABLED || m_lPrevState==HM_SCHEDULEDOUT ||
			m_lCurrState==HM_DISABLED || m_lCurrState==HM_SCHEDULEDOUT)
		{
		}
		else
		{
			m_lPrevState = m_lCurrState;
			iSize = m_irsList.size();
			for (i = 0; i < iSize; i++)
			{
				MY_ASSERT(i<m_irsList.size());
				pirs = &m_irsList[i];
				pirs->lPrevState = m_lCurrState;
				pirs->lCurrState = m_lCurrState;
				pirs->unknownReason = 0;
			}
			m_lNumberChanges = 0;
			return TRUE;
		}
	}
	else
	{
		if (bForce || (m_lNumberChanges!=0 && m_lPrevState!=m_lCurrState))
		{
		}
		else
		{
			return FALSE;
		}
	}

	// Don't send if no-one is listening!
	if (g_pThresholdEventSink == NULL)
	{
		return bRetValue;
	}

	MY_OUTPUT2(L"EVENT: Threshold State Change=%d", m_lCurrState, 4);

	// Update time if there has been a change
	wcscpy(m_szDTTime, m_szDTCurrTime);
	wcscpy(m_szTime, m_szCurrTime);

	hRes = GetHMThresholdStatusInstance(&pInstance, TRUE);
	if (FAILED(hRes))
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT(L"failed to get instance!", 1);
		return FALSE;
	}
	else
	{
		//
		// Place Extrinstic event in vector for sending at end of interval.
		// All get sent at once.
		//
		mg_TEventList.push_back(pInstance);
	}

	MY_OUTPUT(L"EXIT ***** CThreshold::FireEvent...", 2);
	return bRetValue;
}

BOOL CThreshold::CrossTest(PNSTRUCT *ppn, IRSSTRUCT *pirs, LPTSTR szTestValue, union hm_datatypes testValue, INSTSTRUCT *pinst)
{
	HRESULT hRes = S_OK;
	TCHAR szTemp[128] = {0};
	BOOL bViolated = FALSE;
	int i;
	BOOL bAllDigits;
	LPTSTR pszCompareValueUpper = NULL;
	LPTSTR pszTestValueUpper = NULL;
	int rc = 0;
	char buffer[50];

	MY_OUTPUT(L"ENTER ***** CrossTest...", 1);

	if (pinst->bNull)
	{
//		pirs->lCurrState = HM_CRITICAL;
//		pirs->unknownReason = HMRES_NULLVALUE;
		pirs->lCrossCountTry = 0;
		return TRUE;
	}

	if (m_lTestCondition == HM_LT)
	{
		if (ppn->type == CIM_STRING)
		{
			bAllDigits = FALSE;
			i = 0;
			while (szTestValue[i])
			{
				if (i==0)
					bAllDigits = TRUE;
				if (!iswdigit(szTestValue[i]))
				{
					bAllDigits = FALSE;
					break;
				}
				i++;
			}
			if (bAllDigits == FALSE)
			{
				if (mg_bEnglishCompare == TRUE)
				{
					if (_wcsicmp(szTestValue, m_szCompareValue)<0)
					{
						bViolated = TRUE;
					}
				}
				else
				{
					if (_wcsicoll(szTestValue, m_szCompareValue)<0)
					{
						bViolated = TRUE;
					}
				}
			}
			else
			{
				__int64 i64Value = _wtoi64(szTestValue);
				bViolated = (i64Value < m_i64CompareValue);
			}
		}
		else if (ppn->type == CIM_DATETIME)
		{
			if (_wcsicmp(szTestValue, m_szCompareValue)<0)
			{
				bViolated = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL32)
		{
			bViolated = (testValue.fValue < m_fCompareValue);
		}
		else if (ppn->type == CIM_REAL64)
		{
			bViolated = (testValue.dValue < m_dCompareValue);
		}
		else if (ppn->type == CIM_SINT64)
		{
			bViolated = (testValue.i64Value < m_i64CompareValue);
		}
		else if (ppn->type == CIM_UINT64)
		{
			bViolated = (testValue.ui64Value < m_ui64CompareValue);
		}
		else if (ppn->type == CIM_UINT32)
		{
			bViolated = (testValue.ulValue < m_ulCompareValue);
		}
		else
		{
			// Must be an integer type
			bViolated = (testValue.lValue < m_lCompareValue);
		}
	}
	else if (m_lTestCondition == HM_GT)
	{
		if (ppn->type == CIM_STRING)
		{
			bAllDigits = FALSE;
			i = 0;
			while (szTestValue[i])
			{
				if (i==0)
					bAllDigits = TRUE;
				if (!iswdigit(szTestValue[i]))
				{
					bAllDigits = FALSE;
					break;
				}
				i++;
			}
			if (bAllDigits == FALSE)
			{
				if (mg_bEnglishCompare == TRUE)
				{
					if (_wcsicmp(szTestValue, m_szCompareValue)>0)
					{
						bViolated = TRUE;
					}
				}
				else
				{
					if (_wcsicoll(szTestValue, m_szCompareValue)>0)
					{
						bViolated = TRUE;
					}
				}
			}
			else
			{
				__int64 i64Value = _wtoi64(szTestValue);
				bViolated = (i64Value > m_i64CompareValue);
			}
		}
		else if (ppn->type == CIM_DATETIME)
		{
			if (_wcsicmp(szTestValue, m_szCompareValue)>0)
			{
				bViolated = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL32)
		{
			bViolated = (testValue.fValue > m_fCompareValue);
		}
		else if (ppn->type == CIM_REAL64)
		{
			bViolated = (testValue.dValue > m_dCompareValue);
		}
		else if (ppn->type == CIM_SINT64)
		{
			bViolated = (testValue.i64Value > m_i64CompareValue);
		}
		else if (ppn->type == CIM_UINT64)
		{
			bViolated = (testValue.ui64Value > m_ui64CompareValue);
		}
		else if (ppn->type == CIM_UINT32)
		{
			bViolated = (testValue.ulValue > m_ulCompareValue);
		}
		else
		{
			// Must be an integer type
			bViolated = (testValue.lValue > m_lCompareValue);
		}
	}
	else if (m_lTestCondition == HM_EQ)
	{
		if (ppn->type == CIM_STRING)
		{
			if (mg_bEnglishCompare == TRUE)
			{
				if (_wcsicmp(szTestValue, m_szCompareValue)==0)
				{
					bViolated = TRUE;
				}
			}
			else
			{
				if (_wcsicoll(szTestValue, m_szCompareValue)==0)
				{
					bViolated = TRUE;
				}
			}
		}
		else if (ppn->type == CIM_DATETIME)
		{
			if (_wcsicmp(szTestValue, m_szCompareValue)==0)
			{
				bViolated = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL32)
		{
			bViolated = (testValue.fValue == m_fCompareValue);
		}
		else if (ppn->type == CIM_REAL64)
		{
			bViolated = (testValue.dValue == m_dCompareValue);
		}
		else if (ppn->type == CIM_SINT64)
		{
			bViolated = (testValue.i64Value == m_i64CompareValue);
		}
		else if (ppn->type == CIM_UINT64)
		{
			bViolated = (testValue.ui64Value == m_ui64CompareValue);
		}
		else if (ppn->type == CIM_UINT32)
		{
			bViolated = (testValue.ulValue == m_ulCompareValue);
		}
		else
		{
			// Must be an integer type
			bViolated = (testValue.lValue == m_lCompareValue);
		}
	}
	else if (m_lTestCondition == HM_NE)
	{
		if (ppn->type == CIM_STRING)
		{
			if (mg_bEnglishCompare == TRUE)
			{
				if (_wcsicmp(szTestValue, m_szCompareValue)!=0)
				{
					bViolated = TRUE;
				}
			}
			else
			{
				if (_wcsicoll(szTestValue, m_szCompareValue)!=0)
				{
					bViolated = TRUE;
				}
			}
		}
		else if (ppn->type == CIM_DATETIME)
		{
			if (_wcsicmp(szTestValue, m_szCompareValue)!=0)
			{
				bViolated = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL32)
		{
			bViolated = (testValue.fValue != m_fCompareValue);
		}
		else if (ppn->type == CIM_REAL64)
		{
			bViolated = (testValue.dValue != m_dCompareValue);
		}
		else if (ppn->type == CIM_SINT64)
		{
			bViolated = (testValue.i64Value != m_i64CompareValue);
		}
		else if (ppn->type == CIM_UINT64)
		{
			bViolated = (testValue.ui64Value != m_ui64CompareValue);
		}
		else if (ppn->type == CIM_UINT32)
		{
			bViolated = (testValue.ulValue != m_ulCompareValue);
		}
		else
		{
			// Must be an integer type
			bViolated = (testValue.lValue != m_lCompareValue);
		}
	}
	else if (m_lTestCondition == HM_GE)
	{
		if (ppn->type == CIM_STRING)
		{
			bAllDigits = FALSE;
			i = 0;
			while (szTestValue[i])
			{
				if (i==0)
					bAllDigits = TRUE;
				if (!iswdigit(szTestValue[i]))
				{
					bAllDigits = FALSE;
					break;
				}
				i++;
			}
			if (bAllDigits == FALSE)
			{
				if (mg_bEnglishCompare == TRUE)
				{
					if (_wcsicmp(szTestValue, m_szCompareValue)>=0)
					{
						bViolated = TRUE;
					}
				}
				else
				{
					if (_wcsicoll(szTestValue, m_szCompareValue)>=0)
					{
						bViolated = TRUE;
					}
				}
			}
			else
			{
				__int64 i64Value = _wtoi64(szTestValue);
				bViolated = (i64Value >= m_i64CompareValue);
			}
		}
		else if (ppn->type == CIM_DATETIME)
		{
			if (_wcsicmp(szTestValue, m_szCompareValue)>=0)
			{
				bViolated = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL32)
		{
			bViolated = (testValue.fValue >= m_fCompareValue);
		}
		else if (ppn->type == CIM_REAL64)
		{
			bViolated = (testValue.dValue >= m_dCompareValue);
		}
		else if (ppn->type == CIM_SINT64)
		{
			bViolated = (testValue.i64Value >= m_i64CompareValue);
		}
		else if (ppn->type == CIM_UINT64)
		{
			bViolated = (testValue.ui64Value >= m_ui64CompareValue);
		}
		else if (ppn->type == CIM_UINT32)
		{
			// Must be an integer type
			bViolated = (testValue.ulValue >= m_ulCompareValue);
		}
		else
		{
			// Must be an integer type
			bViolated = (testValue.lValue >= m_lCompareValue);
		}
	}
	else if (m_lTestCondition == HM_LE)
	{
		if (ppn->type == CIM_STRING)
		{
			bAllDigits = FALSE;
			i = 0;
			while (szTestValue[i])
			{
				if (i==0)
					bAllDigits = TRUE;
				if (!iswdigit(szTestValue[i]))
				{
					bAllDigits = FALSE;
					break;
				}
				i++;
			}
			if (bAllDigits == FALSE)
			{
				if (mg_bEnglishCompare == TRUE)
				{
					if (_wcsicmp(szTestValue, m_szCompareValue)<=0)
					{
						bViolated = TRUE;
					}
				}
				else
				{
					if (_wcsicoll(szTestValue, m_szCompareValue)<=0)
					{
						bViolated = TRUE;
					}
				}
			}
			else
			{
				__int64 i64Value = _wtoi64(szTestValue);
				bViolated = (i64Value <= m_i64CompareValue);
			}
		}
		else if (ppn->type == CIM_DATETIME)
		{
			if (_wcsicmp(szTestValue, m_szCompareValue)<=0)
			{
				bViolated = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL32)
		{
			bViolated = (testValue.fValue <= m_fCompareValue);
		}
		else if (ppn->type == CIM_REAL64)
		{
			bViolated = (testValue.dValue <= m_dCompareValue);
		}
		else if (ppn->type == CIM_SINT64)
		{
			bViolated = (testValue.i64Value <= m_i64CompareValue);
		}
		else if (ppn->type == CIM_UINT64)
		{
			bViolated = (testValue.ui64Value <= m_ui64CompareValue);
		}
		else if (ppn->type == CIM_UINT32)
		{
			bViolated = (testValue.ulValue <= m_ulCompareValue);
		}
		else
		{
			// Must be an integer type
			bViolated = (testValue.lValue <= m_lCompareValue);
		}
	}
	else if (m_lTestCondition == HM_CONTAINS)
	{
		if (ppn->type == CIM_STRING)
		{
			pszCompareValueUpper = _wcsdup(m_szCompareValue);
			MY_ASSERT(pszCompareValueUpper); if (!pszCompareValueUpper) {hRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			_wcsupr(pszCompareValueUpper);
			pszTestValueUpper = _wcsdup(szTestValue);
			MY_ASSERT(pszTestValueUpper); if (!pszTestValueUpper) {hRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			_wcsupr(pszTestValueUpper);
			if (wcsstr(pszTestValueUpper, pszCompareValueUpper))
			{
				bViolated = TRUE;
			}
			free(pszCompareValueUpper);
			pszCompareValueUpper = NULL;
			free(pszTestValueUpper);
			pszTestValueUpper = NULL;
		}
		else if (ppn->type == CIM_DATETIME)
		{
			if (wcsstr(szTestValue, m_szCompareValue))
			{
				bViolated = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL32)
		{
			_gcvt((double)testValue.fValue, 7, buffer);
			rc = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, buffer, strlen(buffer), szTemp, 128);
			szTemp[rc] = NULL;
			if (wcsstr(szTemp, m_szCompareValue))
			{
				bViolated = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL64)
		{
			_gcvt(testValue.dValue, 7, buffer);
			rc = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, buffer, strlen(buffer), szTemp, 128);
			szTemp[rc] = NULL;
			if (wcsstr(szTemp, m_szCompareValue))
			{
				bViolated = TRUE;
			}
		}
		else if (ppn->type == CIM_SINT64)
		{
			_i64tow(testValue.i64Value, szTemp, 10 );
			if (wcsstr(szTemp, m_szCompareValue))
			{
				bViolated = TRUE;
			}
		}
		else if (ppn->type == CIM_UINT64)
		{
			_ui64tow((int)testValue.ui64Value, szTemp, 10);
			if (wcsstr(szTemp, m_szCompareValue))
			{
				bViolated = TRUE;
			}
		}
		else if (ppn->type == CIM_UINT32)
		{
			_ultow(testValue.ulValue, szTemp, 10);
			if (wcsstr(szTemp, m_szCompareValue))
			{
				bViolated = TRUE;
			}
		}
		else
		{
			// Must be an integer type
			_ltow(testValue.lValue, szTemp, 10);
			if (wcsstr(szTemp, m_szCompareValue))
			{
				bViolated = TRUE;
			}
		}
	}
	else if (m_lTestCondition == HM_NOTCONTAINS)
	{
		if (ppn->type == CIM_STRING)
		{
			pszCompareValueUpper = _wcsdup(m_szCompareValue);
			MY_ASSERT(pszCompareValueUpper); if (!pszCompareValueUpper) {hRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			_wcsupr(pszCompareValueUpper);
			pszTestValueUpper = _wcsdup(szTestValue);
			MY_ASSERT(pszTestValueUpper); if (!pszTestValueUpper) {hRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			_wcsupr(pszTestValueUpper);
			if (!wcsstr(pszTestValueUpper, pszCompareValueUpper))
			{
				bViolated = TRUE;
			}
			free(pszCompareValueUpper);
			pszCompareValueUpper = NULL;
			free(pszTestValueUpper);
			pszTestValueUpper = NULL;
		}
		else if (ppn->type == CIM_DATETIME)
		{
			if (!wcsstr(szTestValue, m_szCompareValue))
			{
				bViolated = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL32)
		{
			_gcvt((double)testValue.fValue, 7, buffer);
			rc = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, buffer, strlen(buffer), szTemp, 128);
			szTemp[rc] = NULL;
			if (!wcsstr(szTemp, m_szCompareValue))
			{
				bViolated = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL64)
		{
			_gcvt(testValue.dValue, 7, buffer);
			rc = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, buffer, strlen(buffer), szTemp, 128);
			szTemp[rc] = NULL;
			if (!wcsstr(szTemp, m_szCompareValue))
			{
				bViolated = TRUE;
			}
		}
		else if (ppn->type == CIM_SINT64)
		{
			_i64tow(testValue.i64Value, szTemp, 10 );
			if (!wcsstr(szTemp, m_szCompareValue))
			{
				bViolated = TRUE;
			}
		}
		else if (ppn->type == CIM_UINT64)
		{
			_ui64tow((int)testValue.ui64Value, szTemp, 10);
			if (!wcsstr(szTemp, m_szCompareValue))
			{
				bViolated = TRUE;
			}
		}
		else if (ppn->type == CIM_UINT32)
		{
			_ultow(testValue.ulValue, szTemp, 10);
			if (!wcsstr(szTemp, m_szCompareValue))
			{
				bViolated = TRUE;
			}
		}
		else
		{
			// Must be an integer type
			_ltow(testValue.lValue, szTemp, 10);
			if (!wcsstr(szTemp, m_szCompareValue))
			{
				bViolated = TRUE;
			}
		}
	}
	else if (m_lTestCondition == HM_ALWAYS)
	{
		bViolated = TRUE;
	}
	else
	{
		MY_ASSERT(FALSE);
	}

	//
	// Also see if the duration test has been met
	//
	if (bViolated)
	{
		if (m_lThresholdDuration==0 || (m_lThresholdDuration <= pirs->lCrossCountTry))
		{
			pirs->lCurrState = m_lViolationToState;
		}
		pirs->lCrossCountTry++;
	}
	else
	{
		pirs->lCrossCountTry = 0;
	}

	MY_OUTPUT(L"EXIT ***** CrossTest...", 1);
	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (pszCompareValueUpper)
		free(pszCompareValueUpper);
	if (pszTestValueUpper)
		free(pszTestValueUpper);
	Cleanup(FALSE);
	m_bValidLoad = FALSE;
	return FALSE;
}

BOOL CThreshold::RearmTest(PNSTRUCT *ppn, IRSSTRUCT *pirs, LPTSTR szTestValue, union hm_datatypes testValue, INSTSTRUCT *pinst)
{
	HRESULT hRes = S_OK;
	TCHAR szTemp[128] = {0};
	BOOL bReset = FALSE;
	int i;
	BOOL bAllDigits;
	LPTSTR pszCompareValueUpper = NULL;
	LPTSTR pszTestValueUpper = NULL;
	int rc = 0;
	char buffer[50];

	MY_OUTPUT(L"ENTER ***** RearmTest...", 1);
//XXXIf too much of this code look duplicated from the Crosstest finction, try to
//combine the two, and pass in what need!!!

	if (pinst->bNull)
	{
//		pirs->lCurrState = HM_CRITICAL;
//		pirs->unknownReason = HMRES_NULLVALUE;
pirs->lCurrState = HM_GOOD;
pirs->lCrossCountTry = 0;
		return TRUE;
	}

	if (m_lTestCondition == HM_LT)
	{
		if (ppn->type == CIM_STRING)
		{
			bAllDigits = FALSE;
			i = 0;
			while (szTestValue[i])
			{
				if (i==0)
					bAllDigits = TRUE;
				if (!iswdigit(szTestValue[i]))
				{
					bAllDigits = FALSE;
					break;
				}
				i++;
			}
			if (bAllDigits == FALSE)
			{
				if (mg_bEnglishCompare == TRUE)
				{
					if (_wcsicmp(szTestValue, m_szCompareValue)>=0)
					{
						bReset = TRUE;
					}
				}
				else
				{
					if (_wcsicoll(szTestValue, m_szCompareValue)>=0)
					{
						bReset = TRUE;
					}
				}
			}
			else
			{
				__int64 i64Value = _wtoi64(szTestValue);
				bReset = (i64Value >= m_i64CompareValue);
			}
		}
		else if (ppn->type == CIM_DATETIME)
		{
			if (_wcsicmp(szTestValue, m_szCompareValue)>=0)
			{
				bReset = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL32)
		{
			bReset = (testValue.fValue >= m_fCompareValue);
		}
		else if (ppn->type == CIM_REAL64)
		{
			bReset = (testValue.dValue >= m_dCompareValue);
		}
		else if (ppn->type == CIM_SINT64)
		{
			bReset = (testValue.i64Value >= m_i64CompareValue);
		}
		else if (ppn->type == CIM_UINT64)
		{
			bReset = (testValue.ui64Value >= m_ui64CompareValue);
		}
		else if (ppn->type == CIM_UINT32)
		{
			bReset = (testValue.ulValue >= m_ulCompareValue);
		}
		else
		{
			// Must be an integer type
			bReset = (testValue.lValue >= m_lCompareValue);
		}
	}
	else if (m_lTestCondition == HM_GT)
	{
		if (ppn->type == CIM_STRING)
		{
			bAllDigits = FALSE;
			i = 0;
			while (szTestValue[i])
			{
				if (i==0)
					bAllDigits = TRUE;
				if (!iswdigit(szTestValue[i]))
				{
					bAllDigits = FALSE;
					break;
				}
				i++;
			}
			if (bAllDigits == FALSE)
			{
				if (mg_bEnglishCompare == TRUE)
				{
					if (_wcsicmp(szTestValue, m_szCompareValue)<=0)
					{
						bReset = TRUE;
					}
				}
				else
				{
					if (_wcsicoll(szTestValue, m_szCompareValue)<=0)
					{
						bReset = TRUE;
					}
				}
			}
			else
			{
				__int64 i64Value = _wtoi64(szTestValue);
				bReset = (i64Value <= m_i64CompareValue);
			}
		}
		else if (ppn->type == CIM_DATETIME)
		{
			if (_wcsicmp(szTestValue, m_szCompareValue)<=0)
			{
				bReset = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL32)
		{
			bReset = (testValue.fValue <= m_fCompareValue);
		}
		else if (ppn->type == CIM_REAL64)
		{
			bReset = (testValue.dValue <= m_dCompareValue);
		}
		else if (ppn->type == CIM_SINT64)
		{
			bReset = (testValue.i64Value <= m_i64CompareValue);
		}
		else if (ppn->type == CIM_UINT64)
		{
			bReset = (testValue.ui64Value <= m_ui64CompareValue);
		}
		else if (ppn->type == CIM_UINT32)
		{
			bReset = (testValue.ulValue <= m_ulCompareValue);
		}
		else
		{
			// Must be an integer type
			bReset = (testValue.lValue <= m_lCompareValue);
		}
	}
	else if (m_lTestCondition == HM_EQ)
	{
		if (ppn->type == CIM_STRING)
		{
			if (mg_bEnglishCompare == TRUE)
			{
				if (_wcsicmp(szTestValue, m_szCompareValue)!=0)
				{
					bReset = TRUE;
				}
			}
			else
			{
				if (_wcsicoll(szTestValue, m_szCompareValue)!=0)
				{
					bReset = TRUE;
				}
			}
		}
		else if (ppn->type == CIM_DATETIME)
		{
			if (_wcsicmp(szTestValue, m_szCompareValue)==0)
			{
				bReset = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL32)
		{
			bReset = (testValue.fValue != m_fCompareValue);
		}
		else if (ppn->type == CIM_REAL64)
		{
			bReset = (testValue.dValue != m_dCompareValue);
		}
		else if (ppn->type == CIM_SINT64)
		{
			bReset = (testValue.i64Value != m_i64CompareValue);
		}
		else if (ppn->type == CIM_UINT64)
		{
			bReset = (testValue.ui64Value != m_ui64CompareValue);
		}
		else if (ppn->type == CIM_UINT32)
		{
			bReset = (testValue.ulValue != m_ulCompareValue);
		}
		else
		{
			bReset = (testValue.lValue != m_lCompareValue);
		}
	}
	else if (m_lTestCondition == HM_NE)
	{
		if (ppn->type == CIM_STRING)
		{
			if (mg_bEnglishCompare == TRUE)
			{
				if (_wcsicmp(szTestValue, m_szCompareValue)==0)
				{
					bReset = TRUE;
				}
			}
			else
			{
				if (_wcsicoll(szTestValue, m_szCompareValue)==0)
				{
					bReset = TRUE;
				}
			}
		}
		else if (ppn->type == CIM_DATETIME)
		{
			if (_wcsicmp(szTestValue, m_szCompareValue)==0)
			{
				bReset = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL32)
		{
			bReset = (testValue.fValue == m_fCompareValue);
		}
		else if (ppn->type == CIM_REAL64)
		{
			bReset = (testValue.dValue == m_dCompareValue);
		}
		else if (ppn->type == CIM_SINT64)
		{
			bReset = (testValue.i64Value == m_i64CompareValue);
		}
		else if (ppn->type == CIM_UINT64)
		{
			bReset = (testValue.ui64Value == m_ui64CompareValue);
		}
		else if (ppn->type == CIM_UINT32)
		{
			bReset = (testValue.ulValue == m_ulCompareValue);
		}
		else
		{
			// Must be an integer type
			bReset = (testValue.lValue == m_lCompareValue);
		}
	}
	else if (m_lTestCondition == HM_GE)
	{
		if (ppn->type == CIM_STRING)
		{
			bAllDigits = FALSE;
			i = 0;
			while (szTestValue[i])
			{
				if (i==0)
					bAllDigits = TRUE;
				if (!iswdigit(szTestValue[i]))
				{
					bAllDigits = FALSE;
					break;
				}
				i++;
			}
			if (bAllDigits == FALSE)
			{
				if (mg_bEnglishCompare == TRUE)
				{
					if (_wcsicmp(szTestValue, m_szCompareValue)<0)
					{
						bReset = TRUE;
					}
				}
				else
				{
					if (_wcsicoll(szTestValue, m_szCompareValue)<0)
					{
						bReset = TRUE;
					}
				}
			}
			else
			{
				__int64 i64Value = _wtoi64(szTestValue);
				bReset = (i64Value < m_i64CompareValue);
			}
		}
		else if (ppn->type == CIM_DATETIME)
		{
			if (_wcsicmp(szTestValue, m_szCompareValue)<0)
			{
				bReset = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL32)
		{
			bReset = (testValue.fValue < m_fCompareValue);
		}
		else if (ppn->type == CIM_REAL64)
		{
			bReset = (testValue.dValue < m_dCompareValue);
		}
		else if (ppn->type == CIM_SINT64)
		{
			bReset = (testValue.i64Value < m_i64CompareValue);
		}
		else if (ppn->type == CIM_UINT64)
		{
			bReset = (testValue.ui64Value < m_ui64CompareValue);
		}
		else if (ppn->type == CIM_UINT32)
		{
			bReset = (testValue.ulValue < m_ulCompareValue);
		}
		else
		{
			// Must be an integer type
			bReset = (testValue.lValue < m_lCompareValue);
		}
	}
	else if (m_lTestCondition == HM_LE)
	{
		if (ppn->type == CIM_STRING)
		{
			bAllDigits = FALSE;
			i = 0;
			while (szTestValue[i])
			{
				if (i==0)
					bAllDigits = TRUE;
				if (!iswdigit(szTestValue[i]))
				{
					bAllDigits = FALSE;
					break;
				}
				i++;
			}
			if (bAllDigits == FALSE)
			{
				if (mg_bEnglishCompare == TRUE)
				{
					if (_wcsicmp(szTestValue, m_szCompareValue)>0)
					{
						bReset = TRUE;
					}
				}
				else
				{
					if (_wcsicoll(szTestValue, m_szCompareValue)>0)
					{
						bReset = TRUE;
					}
				}
			}
			else
			{
				__int64 i64Value = _wtoi64(szTestValue);
				bReset = (i64Value > m_i64CompareValue);
			}
		}
		else if (ppn->type == CIM_DATETIME)
		{
			if (_wcsicmp(szTestValue, m_szCompareValue)>0)
			{
				bReset = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL32)
		{
			bReset = (testValue.fValue > m_fCompareValue);
		}
		else if (ppn->type == CIM_REAL64)
		{
			bReset = (testValue.dValue > m_dCompareValue);
		}
		else if (ppn->type == CIM_SINT64)
		{
			bReset = (testValue.i64Value > m_i64CompareValue);
		}
		else if (ppn->type == CIM_UINT64)
		{
			bReset = (testValue.ui64Value > m_ui64CompareValue);
		}
		else if (ppn->type == CIM_UINT32)
		{
			bReset = (testValue.ulValue > m_ulCompareValue);
		}
		else
		{
			// Must be an integer type
			bReset = (testValue.lValue > m_lCompareValue);
		}
	}
	else if (m_lTestCondition == HM_CONTAINS)
	{
		if (ppn->type == CIM_STRING)
		{
			pszCompareValueUpper = _wcsdup(m_szCompareValue);
			MY_ASSERT(pszCompareValueUpper); if (!pszCompareValueUpper) {hRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			_wcsupr(pszCompareValueUpper);
			pszTestValueUpper = _wcsdup(szTestValue);
			MY_ASSERT(pszTestValueUpper); if (!pszTestValueUpper) {hRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			_wcsupr(pszTestValueUpper);
			if (!wcsstr(pszTestValueUpper, pszCompareValueUpper))
			{
				bReset = TRUE;
			}
			free(pszCompareValueUpper);
			pszCompareValueUpper = NULL;
			free(pszTestValueUpper);
			pszTestValueUpper = NULL;
		}
		else if (ppn->type == CIM_DATETIME)
		{
			if (!wcsstr(szTestValue, m_szCompareValue))
			{
				bReset = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL32)
		{
			_gcvt((double)testValue.fValue, 7, buffer);
			rc = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, buffer, strlen(buffer), szTemp, 128);
			szTemp[rc] = NULL;
			if (!wcsstr(szTemp, m_szCompareValue))
			{
				bReset = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL64)
		{
			_gcvt(testValue.dValue, 7, buffer);
			rc = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, buffer, strlen(buffer), szTemp, 128);
			szTemp[rc] = NULL;
			if (!wcsstr(szTemp, m_szCompareValue))
			{
				bReset = TRUE;
			}
		}
		else if (ppn->type == CIM_SINT64)
		{
			_i64tow(testValue.i64Value, szTemp, 10 );
			if (!wcsstr(szTemp, m_szCompareValue))
			{
				bReset = TRUE;
			}
		}
		else if (ppn->type == CIM_UINT64)
		{
			_ui64tow((int)testValue.ui64Value, szTemp, 10);
			if (!wcsstr(szTemp, m_szCompareValue))
			{
				bReset = TRUE;
			}
		}
		else if (ppn->type == CIM_UINT32)
		{
			// Must be an integer type
			_ultow(testValue.ulValue, szTemp, 10);
			if (!wcsstr(szTemp, m_szCompareValue))
			{
				bReset = TRUE;
			}
		}
		else
		{
			// Must be an integer type
			_ltow(testValue.lValue, szTemp, 10);
			if (!wcsstr(szTemp, m_szCompareValue))
			{
				bReset = TRUE;
			}
		}
	}
	else if (m_lTestCondition == HM_NOTCONTAINS)
	{
		if (ppn->type == CIM_STRING)
		{
			pszCompareValueUpper = _wcsdup(m_szCompareValue);
			MY_ASSERT(pszCompareValueUpper); if (!pszCompareValueUpper) {hRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			_wcsupr(pszCompareValueUpper);
			pszTestValueUpper = _wcsdup(szTestValue);
			MY_ASSERT(pszTestValueUpper); if (!pszTestValueUpper) {hRes = WBEM_E_OUT_OF_MEMORY; goto error;}
			_wcsupr(pszTestValueUpper);
			if (wcsstr(pszTestValueUpper, pszCompareValueUpper))
			{
				bReset = TRUE;
			}
			free(pszCompareValueUpper);
			pszCompareValueUpper = NULL;
			free(pszTestValueUpper);
			pszTestValueUpper = NULL;
		}
		else if (ppn->type == CIM_DATETIME)
		{
			if (wcsstr(szTestValue, m_szCompareValue))
			{
				bReset = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL32)
		{
			_gcvt((double)testValue.fValue, 7, buffer);
			rc = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, buffer, strlen(buffer), szTemp, 128);
			szTemp[rc] = NULL;
			if (wcsstr(szTemp, m_szCompareValue))
			{
				bReset = TRUE;
			}
		}
		else if (ppn->type == CIM_REAL64)
		{
			_gcvt(testValue.dValue, 7, buffer);
			rc = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, buffer, strlen(buffer), szTemp, 128);
			szTemp[rc] = NULL;
			if (wcsstr(szTemp, m_szCompareValue))
			{
				bReset = TRUE;
			}
		}
		else if (ppn->type == CIM_SINT64)
		{
			_i64tow(testValue.i64Value, szTemp, 10 );
			if (wcsstr(szTemp, m_szCompareValue))
			{
				bReset = TRUE;
			}
		}
		else if (ppn->type == CIM_UINT64)
		{
			_ui64tow((int)testValue.ui64Value, szTemp, 10);
			if (wcsstr(szTemp, m_szCompareValue))
			{
				bReset = TRUE;
			}
		}
		else if (ppn->type == CIM_UINT32)
		{
			_ultow(testValue.ulValue, szTemp, 10);
			if (wcsstr(szTemp, m_szCompareValue))
			{
				bReset = TRUE;
			}
		}
		else
		{
			// Must be an integer type
			_ltow(testValue.lValue, szTemp, 10);
			if (wcsstr(szTemp, m_szCompareValue))
			{
				bReset = TRUE;
			}
		}
	}
	else if (m_lTestCondition == HM_ALWAYS)
	{
	}
	else
	{
		MY_ASSERT(FALSE);
	}

	//
	// Now see if the duration test has been met
	//
	if (bReset)
	{
		pirs->lCurrState = HM_GOOD;
		pirs->lCrossCountTry = 0;
	}
	else
	{
	}

	MY_OUTPUT(L"EXIT ***** RearmTest...", 1);
	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (pszCompareValueUpper)
		free(pszCompareValueUpper);
	if (pszTestValueUpper)
		free(pszTestValueUpper);
	Cleanup(FALSE);
	m_bValidLoad = FALSE;
	return FALSE;
}

LPTSTR CThreshold::GetPropertyName(void)
{
	return m_szPropertyName;
}

HRESULT CThreshold::GetHMThresholdStatusInstance(IWbemClassObject** ppThresholdInstance, BOOL bEventBased)
{
	TCHAR szTemp[1024];
	IWbemClassObject* pClass = NULL;
	BSTR bsString = NULL;
	HRESULT hRes;
	DWORD dwNameLen = MAX_COMPUTERNAME_LENGTH + 2;
	TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 2];

	MY_OUTPUT(_T("ENTER ***** GetHMSystemStatusInstance..."), 1);

	if (bEventBased)
	{
		bsString = SysAllocString(L"MicrosoftHM_ThresholdStatusEvent");
	}
	else
	{
		bsString = SysAllocString(L"MicrosoftHM_ThresholdStatus");
	}
	MY_ASSERT(bsString); if (!bsString) {hRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	hRes = g_pIWbemServices->GetObject(bsString, 0L, NULL, &pClass, NULL);
	SysFreeString(bsString);
	bsString = NULL;
	MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;

	hRes = pClass->SpawnInstance(0, ppThresholdInstance);
	pClass->Release();
	pClass = NULL;
	MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;

	if (m_bValidLoad == FALSE)
	{
		hRes = PutStrProperty(*ppThresholdInstance, L"GUID", m_szGUID);
		MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;
		hRes = PutUint32Property(*ppThresholdInstance, L"State", HM_CRITICAL);
		MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;
		if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_THRESHOLD_LOADFAIL, szTemp, 1024))
		{
			wcscpy(szTemp, L"Threshold failed to load.");
		}
		hRes = PutStrProperty(*ppThresholdInstance, L"Message", szTemp);
		MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;
hRes = PutStrProperty(*ppThresholdInstance, L"Name", L"...");
MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;
	}
	else
	{
		hRes = PutStrProperty(*ppThresholdInstance, L"GUID", m_szGUID);
		MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;
		hRes = PutStrProperty(*ppThresholdInstance, L"ParentGUID", m_pParentDC->m_szGUID);
		MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;
		hRes = PutStrProperty(*ppThresholdInstance, L"Name", m_szName);
		MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;

		if (GetComputerName(szComputerName, &dwNameLen))
		{
			hRes = PutStrProperty(*ppThresholdInstance, L"SystemName", szComputerName);
			MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;
		}
		else
		{
			hRes = PutStrProperty(*ppThresholdInstance, L"SystemName", L"LocalMachine");
			MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;
		}
		hRes = PutStrProperty(*ppThresholdInstance, L"TimeGeneratedGMT", m_szDTTime);
		MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;

		hRes = PutStrProperty(*ppThresholdInstance, L"LocalTimeFormatted", m_szTime);
		MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;

		if (m_lCurrState==HM_RESET || (m_lViolationToState==HM_RESET && m_lCurrState==HM_COLLECTING))
			hRes = PutUint32Property(*ppThresholdInstance, L"State", HM_GOOD);
		else
			hRes = PutUint32Property(*ppThresholdInstance, L"State", m_lCurrState);
		MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;
	}

	MY_OUTPUT(_T("EXIT ***** GetHMSystemStatusInstance..."), 1);
	return hRes;

error:
	MY_ASSERT(FALSE);
	if (bsString)
		SysFreeString(bsString);
	if (pClass)
		pClass->Release();
	Cleanup(FALSE);
	m_bValidLoad = FALSE;
	return hRes;
}

// For a single GetObject
HRESULT CThreshold::SendHMThresholdStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	MY_ASSERT(pSink!=NULL);

	//
	// Is this the one we are looking for?
	//
	if (!_wcsicmp(m_szGUID, pszGUID))
	{
//XXX		if (m_bValidLoad == FALSE)
//XXX			return WBEM_E_INVALID_OBJECT;

		return SendHMThresholdStatusInstances(pSink);
	}
	else
	{
		return WBEM_S_DIFFERENT;
	}
}

// This one is for enumeration of all HMThresholdStatus Instances outside of the hierarchy.
// Just the flat list.
HRESULT CThreshold::SendHMThresholdStatusInstances(IWbemObjectSink* pSink)
{
	HRESULT hRes = S_OK;
	IWbemClassObject* pInstance = NULL;

	MY_OUTPUT(L"ENTER ***** SendHMThresholdStatusInstances...", 2);

//XXX	if (m_bValidLoad == FALSE)
//XXX		return WBEM_E_INVALID_OBJECT;

	if (pSink == NULL)
	{
		MY_OUTPUT(L"CDC::SendInitialHMMachStatInstances-Invalid Sink", 1);
		return WBEM_E_FAILED;
	}

	hRes = GetHMThresholdStatusInstance(&pInstance, FALSE);
	if (SUCCEEDED(hRes))
	{
		hRes = pSink->Indicate(1, &pInstance);

		if (FAILED(hRes) && hRes!=WBEM_E_SERVER_TOO_BUSY && hRes!=WBEM_E_CALL_CANCELLED && hRes!=WBEM_E_TRANSPORT_FAILURE)
		{
			MY_HRESASSERT(hRes);
			MY_OUTPUT(L"SendHMThresholdStatusInstances-failed to send status!", 1);
		}

		pInstance->Release();
		pInstance = NULL;
	}
	else
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT(L":SendHMThresholdStatusInstances-failed to get instance!", 1);
	}

	MY_OUTPUT(L"EXIT ***** SendHMThresholdStatusInstances...", 2);
	return hRes;
}

#ifdef SAVE
// For a single GetObject
HRESULT CThreshold::SendHMThresholdStatusInstanceInstance(ACTUALINSTLIST *actualInstList, PNSTRUCT *ppn, IWbemObjectSink* pSink, LPTSTR pszGUID)
{
	MY_OUTPUT(L"ENTER ***** SendHMThresholdStatusInstance...", 1);

	//
	// Is this the one we are looking for?
	//
	if (!_wcsicmp(m_szGUID, pszGUID))
	{
		SendHMThresholdStatusInstanceInstances(actualInstList, ppn, pSink);
		return TRUE;
	}

	MY_OUTPUT(L"EXIT ***** SendHMThresholdStatusInstance...", 1);
	return FALSE;
}

// This one is for enumeration of all HMThresholdStatus Instances outside of the hierarchy.
// Just the flat list.
HRESULT CThreshold::SendHMThresholdStatusInstanceInstances(ACTUALINSTLIST *actualInstList, PNSTRUCT *ppn, IWbemObjectSink* pSink)
{
	int i, iSize;
	IRSSTRUCT *pirs;
	INSTSTRUCT *pinst;
	HRESULT hRes = S_OK;
	IWbemClassObject* pObj = NULL;
	ACTUALINSTSTRUCT *pActualInst;

	MY_OUTPUT(L"ENTER ***** SendHMSystemStatusInstances...", 2);

	if (pSink == NULL)
	{
		MY_OUTPUT(L"CDP::SendInitialHMMachStatInstances-Invalid Sink", 1);
		return WBEM_E_INVALID_PARAMETER;
	}

//XXXABC
//	MY_ASSERT(m_irsList.size() == actualInstList->size());
	if (_wcsicmp(m_szPropertyName, L"CollectionInstanceCount") &&
		_wcsicmp(m_szPropertyName, L"CollectionErrorCode") &&
		_wcsicmp(m_szPropertyName, L"CollectionErrorDescription"))
	{
		MY_ASSERT(m_irsList.size() == actualInstList->size());
	}
	iSize = m_irsList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<ppn->instList.size());
		pinst = &ppn->instList[i];
		MY_ASSERT(i<m_irsList.size());
		pirs = &m_irsList[i];
		if (!_wcsicmp(m_szPropertyName, L"CollectionInstanceCount") ||
			!_wcsicmp(m_szPropertyName, L"CollectionErrorCode") ||
			!_wcsicmp(m_szPropertyName, L"CollectionErrorDescription"))
		{
			pActualInst = NULL;
		}
		else
		{
			pActualInst = &(*actualInstList)[i];
		}

		// Provide HMMachStatus Instance
		hRes = GetHMThresholdStatusInstanceInstance(pActualInst, ppn, pinst, pirs, &pObj, FALSE);
		if (SUCCEEDED(hRes))
		{
			hRes = pSink->Indicate(1, &pObj);
	
			if (FAILED(hRes) && hRes != WBEM_E_SERVER_TOO_BUSY)
			{
				MY_HRESASSERT(hRes);
				MY_OUTPUT(L"SendHMSystemStatusInstances-failed to send status!", 1);
			}
			pObj->Release();
			pObj = NULL;
		}
		else
		{
			MY_HRESASSERT(hRes);
			MY_OUTPUT(L":SendHMSystemStatusInstances-failed to get instance!", 1);
		}
	}

	MY_OUTPUT(L"EXIT ***** SendHMSystemStatusInstances...", 2);
	return hRes;
}
#endif

long CThreshold::GetCurrState(void)
{
	return m_lCurrState;
}

HRESULT CThreshold::FindAndModThreshold(BSTR szGUID, IWbemClassObject* pObj)
{
	HRESULT hRes = S_OK;

	//
	// Is this us we are looking for?
	//
	if (!_wcsicmp(m_szGUID, szGUID))
	{
		hRes = LoadInstanceFromMOF(pObj, NULL, L"", TRUE);
		return hRes;
	}

	return WBEM_S_DIFFERENT;
}

LPTSTR CThreshold::GetGUID(void)
{
	return m_szGUID;
}

BOOL CThreshold::SetParentEnabledFlag(BOOL bEnabled)
{
	m_bParentEnabled = bEnabled;

	return TRUE;
}

BOOL CThreshold::SetParentScheduledOutFlag(BOOL bScheduledOut)
{
	m_bParentScheduledOut = bScheduledOut;

	return TRUE;
}

BOOL CThreshold::SetCurrState(HM_STATE state, BOOL bForce/*=FALSE*/, int reason/* = 0*/)
{
	int i, iSize;
	IRSSTRUCT *pirs;

	if (m_pParentDC->m_deType==HM_EQDE && (m_bEnabled==FALSE || m_bParentEnabled==FALSE))
	{
		if (m_lCurrState!=HM_DISABLED)
		{
			m_lCurrState = HM_DISABLED;
			m_lNumberChanges++;
		}
		return TRUE;
	}

	m_lNumberChanges = 0;
	iSize = m_irsList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_irsList.size());
		pirs = &m_irsList[i];
		if (pirs->lCurrState != state)
		{
			m_lNumberChanges++;
		}
		pirs->lCurrState = state;
		pirs->unknownReason = reason;
	}

	if (iSize==0 || bForce)
	{
		if (m_lCurrState!=state || bForce)
		{
			m_lNumberChanges++;
		}
	}

	m_lCurrState = state;

	return TRUE;
}

BOOL CThreshold::SetBackPrev(PNSTRUCT *ppn)
{
	int i, iSize;
	IRSSTRUCT *pirs;

	iSize = m_irsList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_irsList.size());
		pirs = &m_irsList[i];
		if (ppn->type == CIM_REAL32)
		{
			pirs->fPrevValue = pirs->fPrevPrevValue;
		}
		else if (ppn->type == CIM_REAL64)
		{
			pirs->dPrevValue = pirs->dPrevPrevValue;
		}
		else if (ppn->type == CIM_SINT64)
		{
			pirs->i64PrevValue = pirs->i64PrevPrevValue;
		}
		else if (ppn->type == CIM_UINT64)
		{
			pirs->ui64PrevValue = pirs->ui64PrevPrevValue;
		}
		else if (ppn->type == CIM_UINT32)
		{
			pirs->ulPrevValue = pirs->ulPrevPrevValue;
		}
		else
		{
			pirs->lPrevValue = pirs->lPrevPrevValue;
		}
	}

	return TRUE;
}

BOOL CThreshold::ResetResetThreshold(void)
{
	int i, iSize;
	IRSSTRUCT *pirs;

	m_lCurrState = HM_RESET;
	m_lPrevState = HM_RESET;

	iSize = m_irsList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_irsList.size());
		pirs = &m_irsList[i];
		pirs->lCurrState = HM_RESET;
		pirs->lPrevState = HM_RESET;
		pirs->unknownReason = 0;
	}
	m_lNumberChanges = 0;

	return TRUE;
}

BOOL CThreshold::GetChange(void)
{
	if (m_lNumberChanges!=0 && m_lPrevState!=m_lCurrState)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CThreshold::GetEnabledChange(void)
{
	BOOL bChanged = FALSE;

	if ((m_bEnabled==FALSE || m_bParentEnabled==FALSE) && m_lCurrState!=HM_DISABLED)
	{
		bChanged = TRUE;
	}

	if ((m_bEnabled==TRUE && m_bParentEnabled==TRUE) && m_lCurrState==HM_DISABLED)
	{
		bChanged = TRUE;
	}

	return bChanged;
}

HRESULT CThreshold::AddInstance(LPTSTR pszID)
{
	HRESULT hRes = S_OK;
	GUID guid;
	IRSSTRUCT irs;

	irs.szInstanceID = new TCHAR[wcslen(pszID)+2];
	MY_ASSERT(irs.szInstanceID); if (!irs.szInstanceID) {hRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	wcscpy(irs.szInstanceID, pszID);
	// yyyymmddhhmmss.ssssssXUtc; X = GMT(+ or -), Utc = 3 dig. offset from UTC.")]
	wcscpy(irs.szDTTime, m_szDTCurrTime);
	wcscpy(irs.szTime, m_szCurrTime);
	hRes = CoCreateGuid(&guid);
	MY_HRESASSERT(hRes); if (hRes!=S_OK) goto error;
	irs.szStatusGUID = new TCHAR[100];
	MY_ASSERT(irs.szStatusGUID); if (!irs.szStatusGUID) {hRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	StringFromGUID2(guid, irs.szStatusGUID, 100);
	irs.lCurrState = HM_COLLECTING;
	irs.lPrevState = HM_COLLECTING;
	irs.unknownReason = 0;
	irs.lCrossCountTry = 0;
	irs.fPrevValue = MAX_FLOAT;
	irs.dPrevValue = MAX_DOUBLE;
	irs.i64PrevValue = MAX_I64;
	irs.ui64PrevValue = MAX_UI64;
	irs.lPrevValue = MAX_LONG;
	irs.ulPrevValue = MAX_ULONG;
	irs.bNeeded = TRUE;
	m_irsList.push_back(irs);

	return S_OK;

error:
	MY_ASSERT(FALSE);
	Cleanup(FALSE);
	m_bValidLoad = FALSE;
	return hRes;
}

BOOL CThreshold::ClearInstList(void)
{
	int i, iSize;
	IRSSTRUCT *pirs;

	iSize = m_irsList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_irsList.size());
		pirs = &m_irsList[i];
		if (pirs->szInstanceID)
		{
			delete [] pirs->szInstanceID;
		}
		if (pirs->szStatusGUID)
		{
			delete [] pirs->szStatusGUID;
		}
	}
	m_irsList.clear();

	return TRUE;
}


#ifdef SAVE
//
// Do string replacement for the Message property
//
BOOL CThreshold::FormatMessage(IWbemClassObject* pIRSInstance, IWbemClassObject *pEmbeddedInstance)
{
//	TCHAR szMsg[1024];
	BSTR PropName = NULL;
	LPTSTR pszMsg = NULL;
	SAFEARRAY *psaNames = NULL;
	long lNum;
	HRESULT hRes;
	LPTSTR pszDest;
	LPTSTR pszUpperMsg;
	LPTSTR pszNewMsg;
	LPTSTR pStr;
	LPTSTR pStrStart;
	TOKENSTRUCT tokenElmnt;
	TOKENSTRUCT *pTokenElmnt;
	REPSTRUCT repElmnt;
	REPSTRUCT *pRepElmnt;
	REPSTRUCT *pRepElmnt2;
	REPLIST replacementList;
	int i, iSize, iSizeNeeded, j;
//	long lMessageRID;
	long lLower, lUpper; 
//	long iLBound, iUBound;
//	IUnknown* vUnknown;
	static TOKENLIST tokenList;
//	int iRet;
	TOKENLIST embeddedInstTokenList;

	//
	// We only need to build the set of tokens one time, then from then on
	// we just need to fill in the values for what the replacement strings are.
	//
	if (tokenList.size() == 0)
	{
		//
		// First we build the set of tokens that we are looking for. Each property that
		// is in the ThresholdStatusInstance. We build that set of strings,
		// and the values to replace with.
		//

		//
		// Now go through ThresholdInstance, which is where the Message String
		// actually lives. Get that set of properties for the Instances.
		//
		psaNames = NULL;
		hRes = pIRSInstance->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames);
		if (SUCCEEDED(hRes))
		{
			// Get the number of properties.
			SafeArrayGetLBound(psaNames, 1, &lLower);
			SafeArrayGetUBound(psaNames, 1, &lUpper);

			// For each property...
			for (long l=lLower; l<=lUpper; l++) 
			{
				// Get this property.
				hRes = SafeArrayGetElement(psaNames, &l, &PropName);
				if (SUCCEEDED(hRes))
				{
					// Will want to skip some that don't make sense.
					if (!wcscmp(PropName, L"Message"))
					{
						SysFreeString(PropName);
						PropName = NULL;
						continue;
					}
					else if (!wcscmp(PropName, L"ResetMessage"))
					{
						SysFreeString(PropName);
						PropName = NULL;
						continue;
					}
					else if (!wcscmp(PropName, L"EmbeddedInstance"))
					{
						SysFreeString(PropName);
						PropName = NULL;
						continue;
					}
					tokenElmnt.szOrigToken = new TCHAR[wcslen(PropName)+1];
					wcscpy(tokenElmnt.szOrigToken, PropName);
					tokenElmnt.szToken = new TCHAR[wcslen(PropName)+3];
					wcscpy(tokenElmnt.szToken, L"%");
					wcscat(tokenElmnt.szToken, PropName);
					wcscat(tokenElmnt.szToken, L"%");
					_wcsupr(tokenElmnt.szToken);
					tokenElmnt.szReplacementText = NULL;
					tokenList.push_back(tokenElmnt);
					SysFreeString(PropName);
					PropName = NULL;
				}
			}
			SafeArrayDestroy(psaNames);
		}
	}

	//
	// Populate the list of properties on the embedded instance that came from the
	// Data Collector.
	//
	if (_wcsicmp(m_szPropertyName, L"CollectionInstanceCount") &&
		_wcsicmp(m_szPropertyName, L"CollectionErrorCode") &&
		_wcsicmp(m_szPropertyName, L"CollectionErrorDescription"))
	{
	psaNames = NULL;
	MY_ASSERT(pEmbeddedInstance);
	hRes = pEmbeddedInstance->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames);
	if (SUCCEEDED(hRes))
	{
		// Get the number of properties.
		SafeArrayGetLBound(psaNames, 1, &lLower);
		SafeArrayGetUBound(psaNames, 1, &lUpper);

		// For each property...
		for (long l=lLower; l<=lUpper; l++) 
		{
			// Get this property.
			hRes = SafeArrayGetElement(psaNames, &l, &PropName);
			if (SUCCEEDED(hRes))
			{
				tokenElmnt.szOrigToken = new TCHAR[wcslen(PropName)+1];
				wcscpy(tokenElmnt.szOrigToken, PropName);
				tokenElmnt.szToken = new TCHAR[wcslen(PropName)+20];
				wcscpy(tokenElmnt.szToken, L"%");
				wcscat(tokenElmnt.szToken, L"EmbeddedInstance.");
				wcscat(tokenElmnt.szToken, PropName);
				wcscat(tokenElmnt.szToken, L"%");
				_wcsupr(tokenElmnt.szToken);
				tokenElmnt.szReplacementText = NULL;
				embeddedInstTokenList.push_back(tokenElmnt);
				SysFreeString(PropName);
				PropName = NULL;
			}
		}
		SafeArrayDestroy(psaNames);
	}
	}

	//
	// Now we can fill in the values to use for the replacement strings.
	//

	//
	// Now go through each ThresholdInstance, which is where the Message String
	// actually lives. Get that set of properties of the Instance,
	// And do the message formatting while there.
	//

	//
	// Get the replacement strings for this instance
	//
	iSize = tokenList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<tokenList.size());
		pTokenElmnt = &tokenList[i];
		if (pTokenElmnt->szReplacementText != NULL)
		{
			delete [] pTokenElmnt->szReplacementText;
		}
		
		if (!wcscmp(pTokenElmnt->szToken, L"%TESTCONDITION%"))
		{
			hRes = GetUint32Property(pIRSInstance, pTokenElmnt->szOrigToken, &lNum);
			MY_HRESASSERT(hRes);
			MY_ASSERT(lNum<9);
			pStr = new TCHAR[wcslen(condition[lNum])+1];
			wcscpy(pStr, condition[lNum]);
		}
		else if (!wcscmp(pTokenElmnt->szToken, L"%STATE%"))
		{
			hRes = GetUint32Property(pIRSInstance, pTokenElmnt->szOrigToken, &lNum);
			MY_HRESASSERT(hRes);
			MY_ASSERT(lNum<10);
			pStr = new TCHAR[wcslen(state[lNum])+1];
			wcscpy(pStr, state[lNum]);
		}
		else
		{
			hRes = GetAsStrProperty(pIRSInstance, pTokenElmnt->szOrigToken, &pStr);
		}
		pTokenElmnt->szReplacementText = pStr;
		MY_HRESASSERT(hRes);
	}

	//
	// Get the replacement strings for this instance - Embedded
	//
	iSize = embeddedInstTokenList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<embeddedInstTokenList.size());
		pTokenElmnt = &embeddedInstTokenList[i];
		if (pTokenElmnt->szReplacementText != NULL)
		{
			delete [] pTokenElmnt->szReplacementText;
		}
		
		MY_ASSERT(pEmbeddedInstance);
		hRes = GetAsStrProperty(pEmbeddedInstance, pTokenElmnt->szOrigToken, &pStr);
		pTokenElmnt->szReplacementText = pStr;
		MY_HRESASSERT(hRes);
	}

	//
	// Now we have both lists of tokens that have replacement
	// strings that go with them and the replacement strings
	// that go with them
	//

	//
	// Do formatting of Message. We replace all Variable Tags.
	// Sample string -
	// "Drive %InstanceName% is full. Currently at %CurrentValue%%."
	//

	//
	// Get the origional un-formatted message first.
	// To make case in-sensitive, do a _strdup and then a _wcsupr on the string
	// to scan run the code on it, and then free the duplicated string.
	//
	// If it uses resource IDs, then get that string first, then format that!!!
	hRes = GetStrProperty(pIRSInstance, L"Message", &pszMsg);
	MY_HRESASSERT(hRes);

//	if (!wcscmp(pszMsg, L""))
//	{
//		delete [] pszMsg;
//		hRes = GetUint32Property(pIRSInstance, L"MessageStringRID", &lMessageRID);
//		MY_HRESASSERT(hRes);
//		if (m_hResLib == NULL)
//		{
//			wcscpy(szMsg , L"Resource DLL not found");
//		}
//		else
//		{
//	TCHAR szMsg[1024];
//	int iRet;
//			iRet = LoadString(m_hResLib, lMessageRID, szMsg, 1024);
//			if (iRet == 0)
//			{
//				wcscpy(szMsg , L"Resource string not found");
//			}
//		}
//		pszMsg = new TCHAR[wcslen(szMsg)+2];
//		wcscpy(pszMsg , szMsg);
//	}
//	else
//	{
//		hRes = GetStrProperty(pIRSInstance, L"Message", &pszMsg);
//		MY_HRESASSERT(hRes);
//	}
	pszUpperMsg = _wcsdup(pszMsg);
	_wcsupr(pszUpperMsg);

	//
	// First loop through and find every token that needs replacing.
	// Put that info into the replacement list.
	//
	// We will do strstr() for each special token until there are no more to find
	// for each. At each find we will store the offset into the string of what
	// we found. Then we sort by what came first.
	//
	// Quick test to see if it is worth searching
	if (wcschr(pszUpperMsg, '%'))
	{
		iSize = tokenList.size();
		pStrStart = pszUpperMsg;
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<tokenList.size());
			pTokenElmnt = &tokenList[i];
			pStr = wcsstr(pStrStart, pTokenElmnt->szToken);
			if (pStr != NULL)
			{
				repElmnt.pStartStr = pszMsg+(pStr-pszUpperMsg);
				repElmnt.len = wcslen(pTokenElmnt->szToken);
				repElmnt.pszReplacementText = pTokenElmnt->szReplacementText;
				replacementList.push_back(repElmnt);
				i--;
				pStrStart = pStr+1;
			}
			else
			{
				pStrStart = pszUpperMsg;
			}
		}

		// Embedded stuff
		iSize = embeddedInstTokenList.size();
		pStrStart = pszUpperMsg;
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<embeddedInstTokenList.size());
			pTokenElmnt = &embeddedInstTokenList[i];
			pStr = wcsstr(pStrStart, pTokenElmnt->szToken);
			if (pStr != NULL)
			{
				repElmnt.pStartStr = pszMsg+(pStr-pszUpperMsg);
				repElmnt.len = wcslen(pTokenElmnt->szToken);
				repElmnt.pszReplacementText = pTokenElmnt->szReplacementText;
				replacementList.push_back(repElmnt);
				i--;
				pStrStart = pStr+1;
			}
			else
			{
				pStrStart = pszUpperMsg;
			}
		}

		//
		// Need to look for replacement strings that have not been replaced.
		// Simply search for %EmbeddedCollectedInstance. and find the end % for each
		// Replace them with <null>
		//
		if (!pEmbeddedInstance)
		{
			pStrStart = pszUpperMsg;
			while (TRUE)
			{
				pStr = wcsstr(pStrStart, L"%EMBEDDEDCOLLECTEDINSTANCE.");
				if (pStr != NULL)
				{
					repElmnt.pStartStr = pszMsg+(pStr-pszUpperMsg);
					pStr2 = pStr;
					while (pStr2++)
					{
						if (*pStr2=='%' || iswspace(*pStr2))
							break;
					}
					if (*pStr2=='%')
					{
						repElmnt.len = (pStr2-pStr)+1;
						repElmnt.pszReplacementText = L"<null>";
						replacementList.push_back(repElmnt);
					}
					pStrStart = pStr+1;
				}
				else
				{
					break;
				}
			}
		}
	}

	iSize = replacementList.size();
	if (iSize != 0)
	{
		//
		// Next, sort the replacement list from the first string to
		// be replaced, to the last. Shell sort, Knuth, Vol13, pg. 84.
		//
		for (int gap=iSize/2; 0<gap; gap/=2)
		{
			for (i=gap; i<iSize; i++)
			{
				for (j=i-gap; 0<=j; j-=gap)
				{
					MY_ASSERT(j+gap<replacementList.size());
					pRepElmnt = &replacementList[j+gap];
					MY_ASSERT(j<replacementList.size());
					pRepElmnt2 = &replacementList[j];
					if (pRepElmnt->pStartStr < pRepElmnt2->pStartStr)
					{
						MY_ASSERT(j<replacementList.size());
						repElmnt = replacementList[j];
						MY_ASSERT(j+gap<replacementList.size());
						replacementList[j] = replacementList[j+gap];
						MY_ASSERT(j+gap<replacementList.size());
						replacementList[j+gap] = repElmnt;
					}
				}
			}
		}

		//
		// Next, figure out the size needed for the Message with
		// everything replaced.
		//
		iSizeNeeded = wcslen(pszMsg)+1;
		iSize = replacementList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<replacementList.size());
			pRepElmnt = &replacementList[i];
			iSizeNeeded -= pRepElmnt->len;
			iSizeNeeded += wcslen(pRepElmnt->pszReplacementText);
		}
		pszNewMsg = new TCHAR[iSizeNeeded];
		*pszNewMsg = '\0';

		//
		// Next, we loop through and do the actual replacements.
		// "Drive %InstanceName% is full. Currently at %CurrentValue%%."
		//
		pszDest = pszMsg;
		iSize = replacementList.size();
		for (i=0; i<iSize; i++)
		{
			MY_ASSERT(i<replacementList.size());
			pRepElmnt = &replacementList[i];
			*(pRepElmnt->pStartStr) = '\0';
			wcscat(pszNewMsg, pszDest);
			wcscat(pszNewMsg, pRepElmnt->pszReplacementText);
//XXXWould memcpy be faster???							memcpy(pszDest, source, charCnt*sizeof(TCHAR));
			pszDest = pRepElmnt->pStartStr+pRepElmnt->len;
		}
		wcscat(pszNewMsg, pszDest);
		PutStrProperty(pIRSInstance, L"Message", pszNewMsg);
		delete [] pszNewMsg;
		replacementList.clear();
	}
	else
	{
		PutStrProperty(pIRSInstance, L"Message", pszMsg);
	}

	delete [] pszMsg;
	free(pszUpperMsg);

	// Free up the temporary token list
	iSize = embeddedInstTokenList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<embeddedInstTokenList.size());
		pTokenElmnt = &embeddedInstTokenList[i];
		if (pTokenElmnt->szToken)
			delete [] pTokenElmnt->szToken;
		if (pTokenElmnt->szOrigToken)
			delete [] pTokenElmnt->szOrigToken;
		if (pTokenElmnt->szReplacementText)
			delete [] pTokenElmnt->szReplacementText;
	}
	embeddedInstTokenList.clear();

	return TRUE;
}
#endif

BOOL CThreshold::Init(void)
{

	MY_OUTPUT(L"ENTER ***** CThreshold::Init...", 4);

	m_bParentScheduledOut = FALSE;
	m_lNumberNormals = 0;
	m_lNumberWarnings = 0;
	m_lNumberCriticals = 0;
	m_lNumberChanges = 0;
	m_lCompareValue = -99999;
	m_lCurrState = HM_COLLECTING;
	m_lPrevState = HM_COLLECTING;
	m_szGUID = NULL;
	m_szParentObjPath = NULL;
	m_pParentDC = NULL;
	m_szName = NULL;
	m_szDescription = NULL;
	m_szPropertyName = NULL;
	m_szCompareValue = NULL;
	m_szCreationDate = NULL;
	m_szLastUpdate = NULL;
//	m_szMessage = NULL;
//	m_szResetMessage = NULL;
//	m_lID = 0;
	m_bUseAverage = FALSE;
	m_bUseDifference = FALSE;
	m_bUseSum = FALSE;
	m_lTestCondition = 0;
	m_lThresholdDuration = 0;
	m_lViolationToState = 9;
	m_lStartupDelay = 0;
	m_bEnabled = TRUE;
	m_bParentEnabled = TRUE;

	// yyyymmddhhmmss.ssssssXUtc; X = GMT(+ or -), Utc = 3 dig. offset from UTC.")]
	wcscpy(m_szDTTime, m_szDTCurrTime);
	wcscpy(m_szTime, m_szCurrTime);

	MY_OUTPUT(L"EXIT ***** CThreshold::Init...", 4);
	return TRUE;
}

BOOL CThreshold::Cleanup(BOOL bSavePrevSettings)
{
	int i, iSize;
	IRSSTRUCT *pirs;

	MY_OUTPUT(L"ENTER ***** CThreshold::Cleanup...", 4);

	if (bSavePrevSettings == FALSE)
	{
		if (m_szParentObjPath)
		{
			delete [] m_szParentObjPath;
			m_szParentObjPath = NULL;
		}
	}

	if (m_szName)
	{
		delete [] m_szName;
		m_szName = NULL;
	}
	if (m_szDescription)
	{
		delete [] m_szDescription;
		m_szDescription = NULL;
	}
	if (m_szPropertyName)
	{
		delete [] m_szPropertyName;
		m_szPropertyName = NULL;
	}
	if (m_szCompareValue)
	{
		delete [] m_szCompareValue;
		m_szCompareValue = NULL;
	}
	if (m_szCreationDate)
	{
		delete [] m_szCreationDate;
		m_szCreationDate = NULL;
	}
	if (m_szLastUpdate)
	{
		delete [] m_szLastUpdate;
		m_szLastUpdate = NULL;
	}
//	if (m_szMessage)
//	{
//		delete [] m_szMessage;
//		m_szMessage = NULL;
//	}
//	if (m_szResetMessage)
//	{
//		delete [] m_szResetMessage;
//		m_szResetMessage = NULL;
//	}

	if (bSavePrevSettings)
	{
		iSize = m_irsList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<m_irsList.size());
			pirs = &m_irsList[i];
			pirs->lCrossCountTry = 0;
			pirs->fPrevValue = MAX_FLOAT;
			pirs->dPrevValue = MAX_DOUBLE;
			pirs->i64PrevValue = MAX_I64;
			pirs->ui64PrevValue = MAX_UI64;
			pirs->lPrevValue = MAX_LONG;
			pirs->ulPrevValue = MAX_ULONG;
		}
	}
	else
	{
		iSize = m_irsList.size();
		for (i = 0; i < iSize ; i++)
		{
			MY_ASSERT(i<m_irsList.size());
			pirs = &m_irsList[i];
			if (pirs->szInstanceID)
			{
				delete [] pirs->szInstanceID;
			}
			if (pirs->szStatusGUID)
			{
				delete [] pirs->szStatusGUID;
			}
		}
		m_irsList.clear();
	}

	MY_OUTPUT(L"EXIT ***** CThreshold::Cleanup...", 4);
	return TRUE;
}

//
// For when moving from one parent to another
//
#ifdef SAVE
BOOL CThreshold::ModifyAssocForMove(CBase *pNewParentBase)
{
	HRESULT hRes;
	TCHAR szTemp[1024];
	TCHAR szNewTemp[1024];
	BSTR instName;
	IWbemContext *pCtx = 0;
	IWbemCallResult *pResult = 0;
	IWbemClassObject* pObj = NULL;
	IWbemClassObject* pNewObj = NULL;

	MY_OUTPUT(L"ENTER ***** CDataGroup::ModifyAssocForMove...", 4);
	MY_OUTPUT2(L"m_szGUID=%s", m_szGUID, 4);

	//
	// Figure out the new parent path
	//
	if (pNewParentBase->m_hmStatusType == HMSTATUS_DATACOLLECTOR &&
			((CDataCollector *)pNewParentBase)->m_deType == HM_EQDE)
	{
		wcscpy(szNewTemp, L"\\\\.\\root\\cimv2\\MicrosoftHealthMonitor:MicrosoftHM_EventQueryDataCollectorConfiguration.GUID=\"");
	}
	else if (pNewParentBase->m_hmStatusType == HMSTATUS_DATACOLLECTOR &&
			((CDataCollector *)pNewParentBase)->m_deType == HM_PGDE)
	{
		wcscpy(szNewTemp, L"\\\\.\\root\\cimv2\\MicrosoftHealthMonitor:MicrosoftHM_PolledGetObjectDataCollectorConfiguration.GUID=\"");
	}
	else if (pNewParentBase->m_hmStatusType == HMSTATUS_DATACOLLECTOR &&
			((CDataCollector *)pNewParentBase)->m_deType == HM_PMDE)
	{
		wcscpy(szNewTemp, L"\\\\.\\root\\cimv2\\MicrosoftHealthMonitor:MicrosoftHM_PolledMethodDataCollectorConfiguration.GUID=\"");
	}
	else if (pNewParentBase->m_hmStatusType == HMSTATUS_DATACOLLECTOR &&
			((CDataCollector *)pNewParentBase)->m_deType == HM_PQDE)
	{
		wcscpy(szNewTemp, L"\\\\.\\root\\cimv2\\MicrosoftHealthMonitor:MicrosoftHM_PolledQueryDataCollectorConfiguration.GUID=\"");
	}
	else
	{
		MY_ASSERT(FALSE);
	}
	lstrcat(szNewTemp, pNewParentBase->m_szGUID);
	lstrcat(szNewTemp, L"\"");

	//
	// Delete the association from my parent to me.
	//
	wcscpy(szTemp, L"\\\\.\\root\\cimv2\\MicrosoftHealthMonitor:MicrosoftHealthMonitor:MicrosoftHM_ThresholdConfiguration.GUID=\\\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"");

	instName = SysAllocString(L"MicrosoftHM_ConfigurationAssociation");
	if ((hRes = g_pIWbemServices->GetObject(instName, 0L, NULL, &pObj, NULL)) != S_OK)
	{
		MY_HRESASSERT(hRes);
	}
	SysFreeString(instName);

	if (pObj)
	{
		hRes = pObj->SpawnInstance(0, &pNewObj);
		pObj->Release();
		PutStrProperty(pNewObj, L"ChildPath", szTemp);
		PutStrProperty(pNewObj, L"ParentPath", szNewTemp);
		hRes = g_pIWbemServices->PutInstance(pNewObj, 0, NULL, &pResult);
		pNewObj->Release();
		pNewObj = NULL;
	}

	DeleteThresholdConfig(TRUE);

	if (pNewParentBase->m_hmStatusType == HMSTATUS_DATACOLLECTOR &&
			((CDataCollector *)pNewParentBase)->m_deType == HM_EQDE)
	{
		wcscpy(szNewTemp, L"MicrosoftHM_EventQueryDataCollectorConfiguration.GUID=\\\"");
	}
	else if (pNewParentBase->m_hmStatusType == HMSTATUS_DATACOLLECTOR &&
			((CDataCollector *)pNewParentBase)->m_deType == HM_PGDE)
	{
		wcscpy(szNewTemp, L"MicrosoftHM_PolledGetObjectDataCollectorConfiguration.GUID=\\\"");
	}
	else if (pNewParentBase->m_hmStatusType == HMSTATUS_DATACOLLECTOR &&
			((CDataCollector *)pNewParentBase)->m_deType == HM_PMDE)
	{
		wcscpy(szNewTemp, L"MicrosoftHM_PolledMethodDataCollectorConfiguration.GUID=\\\"");
	}
	else if (pNewParentBase->m_hmStatusType == HMSTATUS_DATACOLLECTOR &&
			((CDataCollector *)pNewParentBase)->m_deType == HM_PQDE)
	{
		wcscpy(szNewTemp, L"MicrosoftHM_PolledQueryDataCollectorConfiguration.GUID=\\\"");
	}
	else
	{
		MY_ASSERT(FALSE);
	}
	lstrcat(szNewTemp, pNewParentBase->m_szGUID);
	lstrcat(szNewTemp, L"\\\"");
	if (m_szParentObjPath)
	{
		delete [] m_szParentObjPath;
	}
	m_szParentObjPath = new TCHAR[wcslen(szNewTemp)+1];
	wcscpy(m_szParentObjPath, szNewTemp);

	m_pParentDC = (CDataCollector *)pNewParentBase;

	MY_OUTPUT(L"EXIT ***** CDataGroup::ModifyAssocForMove...", 4);
	return TRUE;
}
#endif

BOOL CThreshold::ReceiveNewChildForMove(CBase *pBase)
{
	MY_ASSERT(FALSE);

	return FALSE;
}

BOOL CThreshold::DeleteChildFromList(LPTSTR pszGUID)
{
	MY_ASSERT(FALSE);

	return FALSE;
}

BOOL CThreshold::DeleteThresholdConfig(BOOL bDeleteAssocOnly)
{
	HRESULT hRes = S_OK;
	TCHAR szTemp[1024];
	BSTR instName = NULL;
	LPTSTR pszStr = NULL;

	MY_OUTPUT(L"ENTER ***** CThreshold::DeleteThresholdConfig...", 4);
	MY_OUTPUT2(L"m_szGUID=%s", m_szGUID, 4);

	//
	// Delete the association from my parent to me.
	// For some reason, we have to try twice, as we can't count on  what will be there.
	//
	wcscpy(szTemp, L"MicrosoftHM_ConfigurationAssociation.ChildPath=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:MicrosoftHM_ThresholdConfiguration.GUID=\\\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\\\"\",ParentPath=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:");
	lstrcat(szTemp, m_szParentObjPath);
	lstrcat(szTemp, L"\"");
	instName = SysAllocString(szTemp);
	MY_ASSERT(instName); if (!instName) {hRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	if ((hRes = g_pIWbemServices->DeleteInstance(instName, 0L,	NULL, NULL)) != S_OK)
	{
		SysFreeString(instName);
		instName = NULL;
		wcscpy(szTemp, L"MicrosoftHM_ConfigurationAssociation.ChildPath=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:MicrosoftHM_ThresholdConfiguration.GUID=\\\"");
		lstrcat(szTemp, m_szGUID);
		lstrcat(szTemp, L"\\\"\",ParentPath=\"\\\\\\\\.\\\\root\\\\cimv2\\\\MicrosoftHealthMonitor:");
		lstrcat(szTemp, L"MicrosoftHM_DataCollectorConfiguration.");
		pszStr = wcsstr(m_szParentObjPath, L"GUID");
		lstrcat(szTemp, pszStr);
		lstrcat(szTemp, L"\"");
		instName = SysAllocString(szTemp);
		MY_ASSERT(instName); if (!instName) {hRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		if ((hRes = g_pIWbemServices->DeleteInstance(instName, 0L,	NULL, NULL)) != S_OK)
		{
			MY_OUTPUT2(L"Threshold delete failure GUID=%s", instName, 4);
		}
	}
	SysFreeString(instName);
	instName = NULL;

	if (bDeleteAssocOnly)
	{
		return TRUE;
	}

	//
	// Delete our exact instance
	//
	wcscpy(szTemp, L"MicrosoftHM_ThresholdConfiguration.GUID=\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"");
	instName = SysAllocString(szTemp);
	MY_ASSERT(instName); if (!instName) {hRes = WBEM_E_OUT_OF_MEMORY; goto error;}
	if ((hRes = g_pIWbemServices->DeleteInstance(instName, 0L,	NULL, NULL)) != S_OK)
	{
		MY_HRESASSERT(hRes);
		MY_OUTPUT2(L"Threshold delete failure GUID=%s", instName, 4);
	}
	SysFreeString(instName);
	instName = NULL;

	//
	// Get rid of any associations to actions for this
	//
	g_pSystem->DeleteAllConfigActionAssoc(m_szGUID);

	MY_OUTPUT(L"EXIT ***** CThreshold::DeleteThresholdConfig...", 4);
	return TRUE;

error:
	MY_ASSERT(FALSE);
	if (instName)
		SysFreeString(instName);
	Cleanup(FALSE);
	m_bValidLoad = FALSE;
	return FALSE;
}

HRESULT CThreshold::Copy(ILIST* pConfigList, LPTSTR pszOldParentGUID, LPTSTR pszNewParentGUID)
{
	GUID guid;
	TCHAR szTemp[1024];
	TCHAR szNewGUID[1024];
	IWbemClassObject* pInst = NULL;
	IWbemClassObject* pInstCopy = NULL;
	IWbemClassObject* pInstAssocCopy = NULL;
	IWbemClassObject* pObj = NULL;
	HRESULT hRetRes = S_OK;
	BSTR Language = NULL;
	BSTR Query = NULL;
	IEnumWbemClassObject *pEnum;
	ULONG uReturned;
	IWbemContext *pCtx = 0;
	LPTSTR pszParentPath = NULL;
	LPTSTR pszChildPath = NULL;
	LPTSTR pStr = NULL;

	MY_OUTPUT(L"ENTER ***** CThreshold::Copy...", 1);

	if (m_bValidLoad == FALSE)
		return WBEM_E_INVALID_OBJECT;

	//
	// Get the origional starting point HMConfiguration instance.
	//
	wcscpy(szTemp, L"MicrosoftHM_Configuration.GUID=\"");
	lstrcat(szTemp, m_szGUID);
	lstrcat(szTemp, L"\"");
	hRetRes = GetWbemObjectInst(&g_pIWbemServices, szTemp, NULL, &pInst);
	if (!pInst)
	{
		MY_HRESASSERT(hRetRes);
		return hRetRes;
	}

	//
	// Clone the instance, and change the GUID
	//
	hRetRes = pInst->Clone(&pInstCopy);
	if (FAILED(hRetRes))
	{
		MY_HRESASSERT(hRetRes);
		pInst->Release();
		pInst = NULL;
		return hRetRes;
	}
	hRetRes = CoCreateGuid(&guid);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	StringFromGUID2(guid, szNewGUID, 100);
	hRetRes = PutStrProperty(pInstCopy, L"GUID", szNewGUID);
	MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
	pConfigList->push_back(pInstCopy);

	//
	// Add instance of HMConfigurationAssociation where we are the child,
	// using the parent GUID passed in.
	// Change the GUIDs of both the Parent and Child.
	// also make sure that the machine name is not in the path, and is relative!
	//
	if (pszOldParentGUID != NULL)
	{
		Language = SysAllocString(L"WQL");
		MY_ASSERT(Language); if (!Language) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}
		wcscpy(szTemp, L"REFERENCES OF {MicrosoftHM_Configuration.GUID=\"");
		lstrcat(szTemp, m_szGUID);
		lstrcat(szTemp, L"\"} WHERE ResultClass=MicrosoftHM_ConfigurationAssociation Role=ChildPath");
		Query = SysAllocString(szTemp);
		MY_ASSERT(Query); if (!Query) {hRetRes = WBEM_E_OUT_OF_MEMORY; goto error;}

		// Initialize IEnumWbemClassObject pointer
		pEnum = 0;

		// Issue query
   	hRetRes = g_pIWbemServices->ExecQuery(Language, Query, WBEM_FLAG_FORWARD_ONLY, 0, &pEnum);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		SysFreeString(Query);
		Query = NULL;
		SysFreeString(Query);
		Language = NULL;

		// Retrieve object in result set
		pObj = NULL;
		uReturned = 0;

		hRetRes = pEnum->Next(0, 1, &pObj, &uReturned);
	
		if (uReturned == 0)
		{
			hRetRes = WBEM_E_INVALID_OBJECT_PATH; goto error;
		}
	
		//
		// Change the GUIDs
		//
		hRetRes = GetStrProperty(pObj, L"ParentPath", &pszParentPath);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		hRetRes = GetStrProperty(pObj, L"ChildPath", &pszChildPath);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;

		pStr = wcschr(pszParentPath, '\"');
		if (pStr)
		{
			pStr++;
			wcsncpy(pStr, pszNewParentGUID, wcslen(pszNewParentGUID));
		}
		else
		{
			hRetRes = WBEM_E_INVALID_OBJECT_PATH; goto error;
		}

		pStr = wcschr(pszChildPath, '\"');
		if (pStr)
		{
			pStr++;
			wcsncpy(pStr, szNewGUID, wcslen(szNewGUID));
		}
		else
		{
			hRetRes = WBEM_E_INVALID_OBJECT_PATH; goto error;
		}

		hRetRes = pObj->Clone(&pInstAssocCopy);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = PutStrProperty(pInstAssocCopy, L"ParentPath", pszParentPath);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		hRetRes = PutStrProperty(pInstAssocCopy, L"ChildPath", pszChildPath);
		MY_HRESASSERT(hRetRes); if (hRetRes!=S_OK) goto error;
		pConfigList->push_back(pInstAssocCopy);


		// Release it.
		pObj->Release();
		pObj = NULL;
		pEnum->Release();
		pEnum = NULL;
		delete [] pszParentPath;
		pszParentPath = NULL;
		delete [] pszChildPath;
		pszChildPath = NULL;
	}

	pInst->Release();
	pInst = NULL;

	MY_OUTPUT(L"EXIT ***** CThreshold::Copy...", 1);
	return S_OK;

error:
	MY_ASSERT(FALSE);
	if (pInst)
		pInst->Release();
	if (pObj)
		pObj->Release();
	if (pEnum)
		pEnum->Release();
	if (Query)
		SysFreeString(Query);
	if (Language)
		SysFreeString(Language);
	if (pszParentPath)
		delete [] pszParentPath;
	if (pszChildPath)
		delete [] pszChildPath;
	Cleanup(FALSE);
	m_bValidLoad = FALSE;
	return hRetRes;
}

CBase *CThreshold::FindImediateChildByName(LPTSTR pszName)
{
	MY_ASSERT(FALSE);

	return NULL;
}

BOOL CThreshold::GetNextChildName(LPTSTR pszChildName, LPTSTR pszOutName)
{
	MY_ASSERT(FALSE);

	return NULL;
}

CBase *CThreshold::FindPointerFromName(LPTSTR pszName)
{
	MY_ASSERT(FALSE);

	return NULL;
}

long CThreshold::PassBackStateIfChangedPerInstance(LPTSTR pszInstName)
{
	int i, iSize;
	IRSSTRUCT *pirs;
	BOOL bFound = FALSE;
	long state = -1;

	iSize = m_irsList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_irsList.size());
		pirs = &m_irsList[i];
		if (!wcscmp(pirs->szInstanceID, pszInstName))
		{
			if (pirs->lPrevState != pirs->lCurrState)
			{
				state = pirs->lCurrState;
				bFound = TRUE;
				break;
			}
		}
	}

	return state;
}

long CThreshold::PassBackWorstStatePerInstance(LPTSTR pszInstName)
{
	int i, iSize;
	IRSSTRUCT *pirs;
	BOOL bFound = FALSE;
	long state = -1;

	iSize = m_irsList.size();
	for (i=0; i<iSize; i++)
	{
		MY_ASSERT(i<m_irsList.size());
		pirs = &m_irsList[i];
		if (!wcscmp(pirs->szInstanceID, pszInstName))
		{
			state = pirs->lCurrState;
			bFound = TRUE;
			break;
		}
	}

	return state;
}

BOOL CThreshold::SetPrevState(HM_STATE state)
{
	int i, iSize;
	IRSSTRUCT *pirs;

	iSize = m_irsList.size();
	for (i = 0; i < iSize ; i++)
	{
		MY_ASSERT(i<m_irsList.size());
		pirs = &m_irsList[i];
		pirs->lCurrState = state;
		pirs->lPrevState = state;
	}

	m_lNumberChanges = 0;
	m_lCurrState = state;

	return TRUE;
}

BOOL CThreshold::SendReminderActionIfStateIsSame(IWbemObjectSink* pActionEventSink, IWbemObjectSink* pActionTriggerEventSink, IWbemClassObject* pActionInstance, IWbemClassObject* pActionTriggerInstance, unsigned long ulTriggerStates)
{
	MY_ASSERT(FALSE);

	return FALSE;
}

HRESULT CThreshold::CheckForBadLoad(void)
{
	HRESULT hRetRes = S_OK;
	IWbemClassObject* pObj = NULL;
	TCHAR szTemp[1024];
	IWbemClassObject* pInstance = NULL;

	if (m_bValidLoad == FALSE)
	{
		wcscpy(szTemp, L"MicrosoftHM_ThresholdConfiguration.GUID=\"");
		lstrcat(szTemp, m_szGUID);
		lstrcat(szTemp, L"\"");
		hRetRes = GetWbemObjectInst(&g_pIWbemServices, szTemp, NULL, &pObj);
		if (!pObj)
		{
			MY_HRESASSERT(hRetRes);
			return S_FALSE;
		}
		hRetRes = LoadInstanceFromMOF(pObj, NULL, L"", TRUE);
		// Here is where we can try and send out a generic SOS if the load failed each time!!!
		if (hRetRes != S_OK)
		{
			if (GetHMThresholdStatusInstance(&pInstance, TRUE) == S_OK)
			{
				mg_TEventList.push_back(pInstance);
			}
		}
		else
		{
			if (GetHMThresholdStatusInstance(&pInstance, TRUE) == S_OK)
			{
				mg_TEventList.push_back(pInstance);
			}
			m_pParentDC->ResetState(TRUE, TRUE);
		}
		MY_HRESASSERT(hRetRes);
		pObj->Release();
		pObj = NULL;
		return hRetRes;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\wmihelper.h ===
//***************************************************************************
//
//  WMIHELPER.H
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: Helper functions and wrappers around WMI
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#if !defined( __WMIHELPER_H )
#define __WMIHELPER_H

//#include <wbemcli.h>
//#include <wbemprov.h>
#include <wbemidl.h>
//#include <wbemprov.h>

	HRESULT GetStrProperty(IWbemClassObject *pDataPoint, LPTSTR pszProp, LPTSTR *pszString);
	HRESULT GetAsStrProperty(IWbemClassObject *pDataPoint, LPTSTR pszProp, LPTSTR *pszString);
	HRESULT GetReal32Property(IWbemClassObject *pDataPoint, LPTSTR pszProp, float *pFloat);
	HRESULT GetUint8Property(IWbemClassObject *pDataPoint, LPTSTR pszProp, int *pInt);
	HRESULT GetUint32Property(IWbemClassObject *pDataPoint, LPTSTR pszProp, long *pLong);
	HRESULT GetUint64Property(IWbemClassObject *pDataPoint, LPTSTR pszProp, unsigned __int64 *pInt64);
	HRESULT GetBoolProperty(IWbemClassObject *pDataPoint, LPTSTR pszProp, BOOL *pBool);
//	HRESULT GetObjectProperty(IWbemClassObject *pObj, LPTSTR pszProp, IWbemClassObject **pObject);
	HRESULT PutSAProperty(IWbemClassObject *pClassObject, LPTSTR szProp, SAFEARRAY* psa);
	HRESULT PutStrProperty(IWbemClassObject *pClassObject, LPTSTR szProp, LPTSTR szString);
	HRESULT PutUint32Property(IWbemClassObject *pClassObject, LPTSTR szProp, long lValue);
	HRESULT PutUUint32Property(IWbemClassObject *pClassObject, LPTSTR szProp, unsigned long lValue);
	HRESULT PutReal32Property(IWbemClassObject *pClassObject, LPTSTR szProp, float fValue);
	HRESULT PutBoolProperty(IWbemClassObject *pClassObject, LPTSTR szProp, BOOL bValue);
	HRESULT GetWbemObjectInst(IWbemServices** ppSvc, LPCTSTR szName, IWbemContext *pContext, IWbemClassObject **pOutObj);
//	HRESULT GetWbemObjectInstAmended(IWbemServices** ppSvc, LPCTSTR szName, IWbemContext *pContext, BOOL bErrorOK, IWbemClassObject **pOutObj);
	HRESULT GetWbemObjectInstSemiSync(IWbemServices** ppSvc, LPCTSTR szName, IWbemContext *pContext, IWbemCallResult **pOutObj);
//	HRESULT GetUint32Qualifier(IWbemClassObject *pObj, LPTSTR pszProp, LPTSTR pszQual, long *pLong);
//	HRESULT PutUint32Qualifier(IWbemClassObject *pObj, LPTSTR pszProp, LPTSTR pszQual, long pLong);
//	HRESULT GetInstModificationEvent(IWbemClassObject*& pInst, IWbemClassObject*& pPrevInst, IWbemClassObject **pOutObj);
//	HRESULT GetInstCreationEvent(IWbemClassObject*& pInst, IWbemClassObject **pOutObj);
//	HRESULT SendInstModificationEvent(IWbemObjectSink* pEventSink, IWbemClassObject*& pInstance, IWbemClassObject*& pPrevInstance);
//	HRESULT SendInstCreationEvent(IWbemObjectSink* pEventSink, IWbemClassObject*& pInstance);
	HRESULT SendEvents(IWbemObjectSink* pEventSink, IWbemClassObject** pInstances, int iSize);
	HRESULT	GetWbemClassObject(IWbemClassObject** ppObj, VARIANT* v);
	BOOL GetLatestWMIError(int code, HRESULT hResIn, LPTSTR pszString);
	BOOL GetLatestAgentError(int code, LPTSTR pszString);
//	BOOL SwapLocalizedStringsIn(void);
//	BOOL DoClass(LPTSTR pszClass, BOOL bDoMessage);
//	BOOL GetSafeArray(LPTSTR pszClass, LPTSTR pszPropertyName, VARIANT &psaValueMap, VARIANT &psaValues);
//	BOOL FindValue(SAFEARRAY *psaValueMap, SAFEARRAY *psaValues, LPTSTR pszString, LPTSTR *pszOutValue);

#endif  // __WMIHELPER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\threshld.h ===
//***************************************************************************
//
//  THRESHLD.H
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: CThreshold class to do thresholding on a CDatapoint class.
//  The CDatapoint class contains the WMI instance, and the CThreshold
//  class says what ptoperty to threshold against, and how.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#if !defined( __THRESHLD_H )
#define __THRESHLD_H

#include <wbemcli.h>
#include <vector>
#include "global.h"
#include "base.h"

// Add support for UINT64 and other similar datatypes.
// Need to use a union for the values collecting.
union hm_datatypes {
	long lValue;
	unsigned long ulValue;
	float fValue;
	double dValue;
	__int64 i64Value;
	unsigned __int64 ui64Value;
//	LPTSTR lpstr_value;
//	LPTSTR date_value;
//	unsigned char bool_value;
//	short int int_value;
};
//XXXTake out the kludge in the Threshold::CrossTest and RearmTest that was converting all numeric
//XXXstrings to numbers to do arithemetic compare instead of lexical.
//XXXIn the StoreValues code use the CIMTYPE that get from the Get call directly, as
//XXXwe do now in the ppn property.

typedef struct _tag_VALStruct
{
	union hm_datatypes value;
} VALSTRUCT, *PVALSTRUCT;
typedef std::vector<VALSTRUCT, std::allocator<VALSTRUCT> > VALLIST;

typedef struct _tag_INSTStruct
{
	LPTSTR szInstanceID;		// Name of instance
	LPTSTR szCurrValue;
	union hm_datatypes currValue;
	union hm_datatypes minValue;
	union hm_datatypes maxValue;
	union hm_datatypes avgValue;
	BOOL bNull;
	BOOL bNeeded;
	VALLIST valList;
} INSTSTRUCT, *PINSTSTRUCT;
typedef std::vector<INSTSTRUCT, std::allocator<INSTSTRUCT> > INSTLIST;

typedef struct _tag_PNStruct
{
	LPTSTR szPropertyName;
	CIMTYPE type;
//	BOOL bNull;
//	BOOL bNeeded;
	INSTLIST instList;
	int iRefCount;
} PNSTRUCT;
typedef std::vector<PNSTRUCT, std::allocator<PNSTRUCT> > PNLIST;

typedef struct _tag_IRSStruct
{
	LPTSTR szStatusGUID;
	TCHAR szDTTime[512];
	TCHAR szTime[512];
	LPTSTR szInstanceID;		// Name of instance
	long lPrevState;
	long lCurrState;
	long lCrossCountTry;
//	union hm_datatypes prevValue;
//	union hm_datatypes prevPrevValue;
	long lPrevValue;
	unsigned long ulPrevValue;
	float fPrevValue;
	double dPrevValue;
	__int64 i64PrevValue;
	unsigned __int64 ui64PrevValue;
	long lPrevPrevValue;
	unsigned long ulPrevPrevValue;
	float fPrevPrevValue;
	double dPrevPrevValue;
	__int64 i64PrevPrevValue;
	unsigned __int64 ui64PrevPrevValue;
	BOOL bNeeded;
	int unknownReason;
} IRSSTRUCT, *PIRSSTRUCT;
typedef std::vector<IRSSTRUCT, std::allocator<IRSSTRUCT> > IRSLIST;

typedef struct _tag_ACTUALINSTStruct
{
	LPTSTR szInstanceID;		// Name of instance
	IWbemClassObject* pInst;
	BOOL bNeeded;
	TCHAR szDTTime[512];
	TCHAR szTime[512];
} ACTUALINSTSTRUCT, *PACTUALINSTSTRUCT;
typedef std::vector<ACTUALINSTSTRUCT, std::allocator<ACTUALINSTSTRUCT> > ACTUALINSTLIST;

class CDataCollector; // Forward declaration

class CThreshold : public CBase
{
public:
	CThreshold();
	~CThreshold();

	CDataCollector *m_pParentDC;
	long m_lPrevState;
//	long m_lCurrState;
//	long m_lViolationValue;
//	IWbemServices* m_pIWbemServices;
	LPTSTR m_szParentObjPath;
//	long m_lNameRID;
	LPTSTR m_szDescription;
//	long m_lDescriptionRID;
//	LPTSTR m_szResourceDLL;
	long m_lID;
	LPTSTR m_szPropertyName;
	BOOL m_bUseAverage;
	BOOL m_bUseDifference;
	BOOL m_bUseSum;
//	HM_CONDITION m_lTestCondition;
	long m_lTestCondition;
	LPTSTR m_szCompareValue;
	long m_lCompareValue;
	unsigned long m_ulCompareValue;
	float m_fCompareValue;
	double m_dCompareValue;
	__int64 m_i64CompareValue;
	unsigned __int64 m_ui64CompareValue;
//	union hm_datatypes m_compareValue;
	long m_lThresholdDuration;
	long m_lViolationToState;
	LPTSTR m_szCreationDate;
	LPTSTR m_szLastUpdate;
//	LPTSTR m_szMessage;
//	long m_lMessageRID;
//	LPTSTR m_szResetMessage;
//	long m_lResetMessageRID;
	long m_lStartupDelay;
//XXX	int m_iActiveDays;
//XXX	long m_lBeginHourTime;
//XXX	long m_lBeginMinuteTime;
//XXX	long m_lEndHourTime;
//XXX	long m_lEndMinuteTime;
	BOOL m_bEnabled;
	BOOL m_bParentEnabled; // So we can transfer down the hierarchy the state.
	BOOL m_bParentScheduledOut;
	TCHAR m_szDTTime[512];
	TCHAR m_szTime[512];
	IRSLIST m_irsList;
	long m_lNumberNormals;
	long m_lNumberWarnings;
	long m_lNumberCriticals;
	long m_lNumberChanges;
	BOOL m_bValidLoad;

	//
	// STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC STATIC
	//
	static void ThresholdTerminationCleanup(void);
	static void GetLocal(void);
	static BOOL mg_bEnglishCompare;


	HRESULT LoadInstanceFromMOF(IWbemClassObject* pObj, CDataCollector *pParentDC, LPTSTR pszParentObjPath, BOOL bModifyPass=FALSE);
	// return polling interval in milliseconds
	BOOL OnAgentInterval(ACTUALINSTLIST *actualInstList, PNSTRUCT *ppn, BOOL bRequireReset);
	BOOL FireEvent(BOOL bForce);
	BOOL FireInstanceEvents(ACTUALINSTLIST *actualInstList, PNSTRUCT *ppn);
	LPTSTR GetPropertyName(void);
	BOOL CrossTest(PNSTRUCT *ppn, IRSSTRUCT *pirs, LPTSTR szTestValue, union hm_datatypes testValue, INSTSTRUCT *pinst);
	BOOL RearmTest(PNSTRUCT *ppn, IRSSTRUCT *pirs, LPTSTR szTestValue, union hm_datatypes testValue, INSTSTRUCT *pinst);
	HRESULT GetHMThresholdStatusInstance(IWbemClassObject** pInstance, BOOL bEventBased);
//	BOOL GetHMThresholdStatusInstanceInstance(ACTUALINSTSTRUCT *pActualInst, PNSTRUCT *ppn, INSTSTRUCT *pinst, IRSSTRUCT *pirs, IWbemClassObject** ppIRSInstance, BOOL bChangesOnly, BOOL bEventBased);

	HRESULT SendHMThresholdStatusInstances(IWbemObjectSink* pSink);
	HRESULT SendHMThresholdStatusInstance(IWbemObjectSink* pSink, LPTSTR pszGUID);
//	HRESULT SendHMThresholdStatusInstanceInstances(ACTUALINSTLIST *actualInstList, PNSTRUCT *ppn, IWbemObjectSink* pSink);
//	HRESULT SendHMThresholdStatusInstanceInstance(ACTUALINSTLIST *actualInstList, PNSTRUCT *ppn, IWbemObjectSink* pSink, LPTSTR pszGUID);
	long GetCurrState(void);
	HRESULT FindAndModThreshold(BSTR szGUID, IWbemClassObject* pObj);
	LPTSTR GetGUID(void);
	BOOL SetCurrState(HM_STATE state, BOOL bForce = FALSE, int reason = 0);
	BOOL SetPrevState(HM_STATE state);
	BOOL SetParentEnabledFlag(BOOL bEnabled);
	BOOL SetParentScheduledOutFlag(BOOL bScheduledOut);
	BOOL SetBackPrev(PNSTRUCT *ppn);
	BOOL ClearInstList(void);
	BOOL ResetResetThreshold(void);
	BOOL GetChange(void);
	BOOL GetEnabledChange(void);
	HRESULT AddInstance(LPTSTR pszID);
//	BOOL FormatMessages(IWbemClassObject* pObj);
	BOOL FormatMessage(IWbemClassObject* pIRSInstance, IWbemClassObject *pEmbeddedInstance);
//XXX	BOOL Enable(BOOL bEnable);
	BOOL Cleanup(BOOL bSavePrevSettings);
	BOOL Init(void);
	BOOL DeleteThresholdConfig(BOOL bDeleteAssocOnly=FALSE);
	HRESULT Copy(ILIST* pConfigList, LPTSTR pszOldParentGUID, LPTSTR pszNewParentGUID);
	CBase *FindImediateChildByName(LPTSTR pszChildName);
	BOOL GetNextChildName(LPTSTR pszChildName, LPTSTR pszOutName);
	CBase *FindPointerFromName(LPTSTR pszChildName);
//	BOOL ModifyAssocForMove(CBase *pNewParentBase);
	BOOL ReceiveNewChildForMove(CBase *pBase);
	BOOL DeleteChildFromList(LPTSTR pszGUID);
	long PassBackStateIfChangedPerInstance(LPTSTR pszInstName);
	long PassBackWorstStatePerInstance(LPTSTR pszInstName);
	BOOL SendReminderActionIfStateIsSame(IWbemObjectSink* pActionEventSink, IWbemObjectSink* pActionTriggerEventSink, IWbemClassObject* pActionInstance, IWbemClassObject* pActionTriggerInstance, unsigned long ulTriggerStates);
	BOOL SkipClean(void);
	HRESULT CheckForBadLoad(void);
};
#endif  // __THRESHLD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmagent\wmihelper.cpp ===
//***************************************************************************
//
//  WMIHELPER.CPP
//
//  Module: HEALTHMON SERVER AGENT
//
//  Purpose: Helper functions and wrappers around WMI
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "global.h"
#include "wmihelper.h"
extern HMODULE g_hWbemComnModule;


/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////PROPERTY GETS///////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

HRESULT GetStrProperty(IWbemClassObject *pObj, LPTSTR pszProp, LPTSTR *pszString)
{
	LPTSTR pszPropIn;
	VARIANT v;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** GetStrProperty...", 0);
	MY_ASSERT(pszProp);
	if (!pszProp)
	{
		return WBEM_E_INVALID_PROPERTY;
	}

	if (pszProp[0] == '\0')
	{
		pszPropIn = L" ";
	}
	else
	{
		pszPropIn = pszProp;
	}

	VariantInit(&v);
	if ((hRetRes = pObj->Get(pszPropIn, 0L, &v, NULL, NULL)) == S_OK) 
	{
		if (V_VT(&v)==VT_NULL)
		{
			*pszString = new TCHAR[2];
			MY_ASSERT(*pszString);
			if (!*pszString)
			{
				hRetRes = WBEM_E_OUT_OF_MEMORY;
			}
			else
			{
				wcscpy(*pszString , L"");
			}
		}
		else
		{
			MY_ASSERT(V_VT(&v)==VT_BSTR);
			*pszString = new TCHAR[wcslen(V_BSTR(&v))+2];
			MY_ASSERT(*pszString);
			if (!*pszString)
			{
				hRetRes = WBEM_E_OUT_OF_MEMORY;
			}
			else
			{
				wcscpy(*pszString , V_BSTR(&v));
			}
		}
	}
	else
	{
		MY_HRESASSERT(hRetRes);
	}
	VariantClear(&v);

	MY_OUTPUT(L"EXIT ***** GetStrProperty...", 0);
	return hRetRes;
}

HRESULT GetAsStrProperty(IWbemClassObject *pObj, LPTSTR pszProp, LPTSTR *pszString)
{
	LPTSTR pszPropIn;
	TCHAR szTemp[1024];
	HRESULT hRetRes = S_OK;
	VARIANT v;
	BOOL bBool;

	MY_OUTPUT(L"ENTER ***** GetAsStrProperty...", 0);
	MY_ASSERT(pszProp);
	if (!pszProp)
	{
		return WBEM_E_INVALID_PROPERTY;
	}

	if (pszProp[0] == '\0')
	{
		pszPropIn = L" ";
	}
	else
	{
		pszPropIn = pszProp;
	}

	VariantInit(&v);
	if ((hRetRes = pObj->Get(pszPropIn, 0L, &v, NULL, NULL)) == S_OK) 
	{
		if (V_VT(&v)==VT_NULL)
		{
			*pszString = new TCHAR[6];
			MY_ASSERT(*pszString);
			if (!*pszString)
			{
				hRetRes = WBEM_E_OUT_OF_MEMORY;
			}
			else
			{
				wcscpy(*pszString , L"NULL");
			}
		}
		else if (V_VT(&v)==VT_I4)
		{
			_ultow(V_I4(&v), szTemp, 10);
			*pszString = new TCHAR[wcslen(szTemp)+1];
			MY_ASSERT(*pszString);
			if (!*pszString)
			{
				hRetRes = WBEM_E_OUT_OF_MEMORY;
			}
			else
			{
				wcscpy(*pszString, szTemp);
			}
		}
		else if (V_VT(&v)==VT_BSTR)
		{
			*pszString = new TCHAR[wcslen(V_BSTR(&v))+2];
			MY_ASSERT(*pszString);
			if (!*pszString)
			{
				hRetRes = WBEM_E_OUT_OF_MEMORY;
			}
			else
			{
				wcscpy(*pszString, V_BSTR(&v));
			}
		}
		else if (V_VT(&v)==VT_R4)
		{
			swprintf(szTemp, L"%f.", V_R4(&v));
			*pszString = new TCHAR[wcslen(szTemp)+1];
			MY_ASSERT(*pszString);
			if (!*pszString)
			{
				hRetRes = WBEM_E_OUT_OF_MEMORY;
			}
			else
			{
				wcscpy(*pszString, szTemp);
			}
		}
		else if (V_VT(&v)==VT_BOOL)
		{
			bBool = V_BOOL(&v);
			*pszString = new TCHAR[2];
			MY_ASSERT(*pszString);
			if (!*pszString)
			{
				hRetRes = WBEM_E_OUT_OF_MEMORY;
			}
			else
			{
				if (bBool != 0.0)
				{
					wcscpy(*pszString, L"1");
				}
				else
				{
					wcscpy(*pszString, L"2");
				}
			}
		}
		else if (V_VT(&v)==VT_R8)
		{
			swprintf(szTemp, L"%lf", V_R8(&v));
			*pszString = new TCHAR[wcslen(szTemp)+1];
			MY_ASSERT(*pszString);
			if (!*pszString)
			{
				hRetRes = WBEM_E_OUT_OF_MEMORY;
			}
			else
			{
				wcscpy(*pszString, szTemp);
			}
		}
		else if (V_VT(&v)==VT_I2)
		{
			swprintf(szTemp, L"%i", V_I2(&v));
			*pszString = new TCHAR[wcslen(szTemp)+1];
			MY_ASSERT(*pszString);
			if (!*pszString)
			{
				hRetRes = WBEM_E_OUT_OF_MEMORY;
			}
			else
			{
				wcscpy(*pszString, szTemp);
			}
		}
		else if (V_VT(&v)==VT_UI1)
		{
			swprintf(szTemp, L"%u", V_UI1(&v));
			*pszString = new TCHAR[wcslen(szTemp)+1];
			MY_ASSERT(*pszString);
			if (!*pszString)
			{
				hRetRes = WBEM_E_OUT_OF_MEMORY;
			}
			else
			{
				wcscpy(*pszString, szTemp);
			}
		}
		else
		{
			// If for example we had a VT_BSTR | VT_ARRAY would we end up here.
			*pszString = new TCHAR[4];
			MY_ASSERT(*pszString);
			if (!*pszString)
			{
				hRetRes = WBEM_E_OUT_OF_MEMORY;
			}
			else
			{
				wcscpy(*pszString, L"???");
			}
		}
	}
	else
	{
		MY_HRESASSERT(hRetRes);
	}
	VariantClear(&v);

	MY_OUTPUT(L"EXIT ***** GetAsStrProperty...", 0);
	return hRetRes;
}

HRESULT GetReal32Property(IWbemClassObject *pObj, LPTSTR pszProp, float *pFloat)
{
	LPTSTR pszPropIn;
	VARIANT v;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** GetReal32Property...", 0);
	MY_ASSERT(pszProp);
	if (!pszProp)
	{
		return WBEM_E_INVALID_PROPERTY;
	}

	if (pszProp[0] == '\0')
	{
		pszPropIn = L" ";
	}
	else
	{
		pszPropIn = pszProp;
	}

	VariantInit(&v);
	if ((hRetRes = pObj->Get(pszPropIn, 0L, &v, NULL, NULL)) == S_OK) 
	{
		if (V_VT(&v)==VT_NULL)
		{
			MY_ASSERT(FALSE);
			*pFloat = 0;
		}
		else
		{
			MY_ASSERT(V_VT(&v)==VT_R4);
			*pFloat = V_R4(&v);
		}
	} 
	else
	{
		MY_HRESASSERT(hRetRes);
	}
	VariantClear(&v);

	MY_OUTPUT(L"EXIT ***** GetReal32Property...", 0);
	return hRetRes;
}

HRESULT GetUint8Property(IWbemClassObject *pObj, LPTSTR pszProp, int *pInt)
{
	LPTSTR pszPropIn;
	VARIANT v;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** GetUint8Property...", 0);
	MY_ASSERT(pszProp);
	if (!pszProp)
	{
		return WBEM_E_INVALID_PROPERTY;
	}

	if (pszProp[0] == '\0')
	{
		pszPropIn = L" ";
	}
	else
	{
		pszPropIn = pszProp;
	}

	VariantInit(&v);
	if ((hRetRes = pObj->Get(pszPropIn, 0L, &v, NULL, NULL)) == S_OK) 
	{
		if (V_VT(&v)==VT_NULL)
		{
			MY_ASSERT(FALSE);
			*pInt = 0;
		}
		else
		{
			MY_ASSERT(V_VT(&v)==VT_UI1);
			*pInt = V_UI1(&v);
		}
	} 
	else
	{
		MY_HRESASSERT(hRetRes);
	}
	VariantClear(&v);

	MY_OUTPUT(L"EXIT ***** GetUint8Property...", 0);
	return hRetRes;
}

HRESULT GetUint32Property(IWbemClassObject *pObj, LPTSTR pszProp, long *pLong)
{
	LPTSTR pszPropIn;
	VARIANT v;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** GetUint32Property...", 0);
	MY_ASSERT(pszProp);
	if (!pszProp)
	{
		return WBEM_E_INVALID_PROPERTY;
	}

	if (pszProp[0] == '\0')
	{
		pszPropIn = L" ";
	}
	else
	{
		pszPropIn = pszProp;
	}

	VariantInit(&v);
	if ((hRetRes = pObj->Get(pszPropIn, 0L, &v, NULL, NULL)) == S_OK) 
	{
		if (V_VT(&v)==VT_NULL)
		{
			MY_ASSERT(FALSE);
			*pLong = 0;
		}
		else
		{
			MY_ASSERT(V_VT(&v)==VT_I4);
			*pLong = V_I4(&v);
		}
	} 
	else
	{
		MY_HRESASSERT(hRetRes);
	}
	VariantClear(&v);

	MY_OUTPUT(L"EXIT ***** GetUint32Property...", 0);
	return hRetRes;
}

HRESULT GetUint64Property(IWbemClassObject *pObj, LPTSTR pszProp, unsigned __int64 *pInt64)
{
	LPTSTR pszPropIn;
	VARIANT v;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** GetUint64Property...", 0);
	MY_ASSERT(pszProp);
	if (!pszProp)
	{
		return WBEM_E_INVALID_PROPERTY;
	}

	if (pszProp[0] == '\0')
	{
		pszPropIn = L" ";
	}
	else
	{
		pszPropIn = pszProp;
	}

	VariantInit(&v);
	if ((hRetRes = pObj->Get(pszPropIn, 0L, &v, NULL, NULL)) == S_OK) 
	{
		if (V_VT(&v)==VT_NULL)
		{
			MY_ASSERT(FALSE);
			*pInt64 = 0;
		}
		else
		{
			MY_ASSERT(V_VT(&v)==VT_BSTR);
			*pInt64 = 0;
			ReadUI64(V_BSTR(&v), *pInt64);
		}
	} 
	else
	{
		MY_HRESASSERT(hRetRes);
	}
	VariantClear(&v);

	MY_OUTPUT(L"EXIT ***** GetUint64Property...", 0);
	return hRetRes;
}

HRESULT GetBoolProperty(IWbemClassObject *pObj, LPTSTR pszProp, BOOL *pBool)
{
	LPTSTR pszPropIn;
	VARIANT v;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** GetBoolProperty...", 0);
	MY_ASSERT(pszProp);
	if (!pszProp)
	{
		return WBEM_E_INVALID_PROPERTY;
	}

	if (pszProp[0] == '\0')
	{
		pszPropIn = L" ";
	}
	else
	{
		pszPropIn = pszProp;
	}

	VariantInit(&v);
	if ((hRetRes = pObj->Get(pszPropIn, 0L, &v, NULL, NULL)) == S_OK) 
	{
		if (V_VT(&v)==VT_NULL)
		{
			MY_ASSERT(FALSE);
			*pBool = (BOOL)0.0;
		}
		else
		{
			MY_ASSERT(V_VT(&v)==VT_BOOL);
			*pBool = V_BOOL(&v);
			if (*pBool != 0.0)
			{
				*pBool = (BOOL)1.0;
			}
		}
	} 
	else
	{
		MY_HRESASSERT(hRetRes);
	}
	VariantClear(&v);

	MY_OUTPUT(L"EXIT ***** GetBoolProperty...", 0);
	return hRetRes;
}

/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////PROPERTY PUTS///////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

HRESULT PutSAProperty(IWbemClassObject *pClassObject, LPTSTR pszProp, SAFEARRAY* psa)
{
	LPTSTR pszPropIn;
	VARIANT v;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** PutSAProperty...", 0);
	MY_ASSERT(pszProp);
	if (!pszProp)
	{
		return WBEM_E_INVALID_PROPERTY;
	}

	if (pszProp[0] == '\0')
	{
		pszPropIn = L" ";
	}
	else
	{
		pszPropIn = pszProp;
	}

	VariantInit(&v);
	V_VT(&v) = VT_UNKNOWN | VT_ARRAY;
	V_ARRAY(&v) = psa;
	if ((hRetRes = pClassObject->Put(pszPropIn, 0, &v, 0)) != S_OK)
	{
		MY_OUTPUT(L"Couldn't do an SA put", 4);
		MY_HRESASSERT(hRetRes);
	}
	VariantClear(&v);

	MY_OUTPUT(L"EXIT ***** PutSAProperty...", 0);
	return hRetRes;
}

HRESULT PutStrProperty(IWbemClassObject *pClassObject, LPTSTR pszProp, LPTSTR pszString)
{
	BSTR bstrString;
	LPTSTR pszPropIn;
	VARIANT v;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** PutSAProperty...", 0);
	MY_ASSERT(pszProp);
	if (!pszProp)
	{
		return WBEM_E_INVALID_PROPERTY;
	}

//XXXWhat want to put a NULL??? Same question for all Put methods.
//On the other hand, if the default for the class property is NULL, then don't need it
	if (!pszString)
	{
		return S_OK;
	}

	if (pszProp[0] == '\0')
	{
		pszPropIn = L" ";
	}
	else
	{
		pszPropIn = pszProp;
	}

	VariantInit(&v);
	V_VT(&v) = VT_BSTR;
	if (pszString[0] == '\0')
	{
		bstrString = SysAllocString(L" ");
		MY_ASSERT(bstrString); if (!bstrString) {return WBEM_E_OUT_OF_MEMORY;}
		bstrString[0] = '\0';
	}
	else
	{
		bstrString = SysAllocString(pszString);
	}
	MY_ASSERT(bstrString); if (!bstrString) {return WBEM_E_OUT_OF_MEMORY;}
	V_BSTR(&v) = bstrString;
	if ((hRetRes = pClassObject->Put(pszPropIn, 0, &v, 0)) != S_OK)
	{
		MY_OUTPUT(L"Couldn't do a string put", 4);
		MY_HRESASSERT(hRetRes);
	}
	VariantClear(&v);

	MY_OUTPUT(L"EXIT ***** PutStrProperty...", 0);
	return hRetRes;
}

HRESULT PutUint32Property(IWbemClassObject *pClassObject, LPTSTR pszProp, long lValue)
{
	LPTSTR pszPropIn;
	VARIANT v;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** PutUint32Property...", 0);
	MY_ASSERT(pszProp);
	if (!pszProp)
	{
		return WBEM_E_INVALID_PROPERTY;
	}

	if (pszProp[0] == '\0')
	{
		pszPropIn = L" ";
	}
	else
	{
		pszPropIn = pszProp;
	}

	VariantInit(&v);
	V_VT(&v) = VT_I4;
	V_I4(&v) = lValue;
	if ((hRetRes = pClassObject->Put(pszPropIn, 0, &v, 0)) != S_OK)
	{
		MY_OUTPUT(L"Couldn't do a uint32 put", 4);
		MY_HRESASSERT(hRetRes);
	}
	VariantClear(&v);

	MY_OUTPUT(L"EXIT ***** PutUint32Property...", 0);
	return hRetRes;
}

HRESULT PutUUint32Property(IWbemClassObject *pClassObject, LPTSTR pszProp, unsigned long ulValue)
{
	LPTSTR pszPropIn;
	VARIANT v;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** PutUint32Property...", 0);
	MY_ASSERT(pszProp);
	if (!pszProp)
	{
		return WBEM_E_INVALID_PROPERTY;
	}

	if (pszProp[0] == '\0')
	{
		pszPropIn = L" ";
	}
	else
	{
		pszPropIn = pszProp;
	}

	VariantInit(&v);
	V_VT(&v) = VT_I4;
	V_I4(&v) = ulValue;
	if ((hRetRes = pClassObject->Put(pszPropIn, 0, &v, 0)) != S_OK)
	{
		MY_OUTPUT(L"Couldn't do a uint32 put", 4);
		MY_HRESASSERT(hRetRes);
	}
	VariantClear(&v);

	MY_OUTPUT(L"EXIT ***** PutUint32Property...", 0);
	return hRetRes;
}

HRESULT PutReal32Property(IWbemClassObject *pClassObject, LPTSTR pszProp, float fValue)
{
	LPTSTR pszPropIn;
	VARIANT v;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** PutReal32Property...", 0);
	MY_ASSERT(pszProp);
	if (!pszProp)
	{
		return WBEM_E_INVALID_PROPERTY;
	}

	if (pszProp[0] == '\0')
	{
		pszPropIn = L" ";
	}
	else
	{
		pszPropIn = pszProp;
	}

	VariantInit(&v);
	V_VT(&v) = VT_R4;
	V_R4(&v) = fValue;
	if ((hRetRes = pClassObject->Put(pszPropIn, 0, &v, 0)) != S_OK)
	{
		MY_OUTPUT(L"Couldn't do a real32 put", 4);
		MY_HRESASSERT(hRetRes);
	}
	VariantClear(&v);

	MY_OUTPUT(L"EXIT ***** PutReal32Property...", 0);
	return hRetRes;
}

HRESULT PutBoolProperty(IWbemClassObject *pClassObject, LPTSTR pszProp, BOOL bValue)
{
	LPTSTR pszPropIn;
	VARIANT v;
	HRESULT hRetRes = S_OK;

	MY_OUTPUT(L"ENTER ***** PutBoolProperty...", 0);
	MY_ASSERT(pszProp);
	if (!pszProp)
	{
		return WBEM_E_INVALID_PROPERTY;
	}

	if (pszProp[0] == '\0')
	{
		pszPropIn = L" ";
	}
	else
	{
		pszPropIn = pszProp;
	}

	VariantInit(&v);
	V_VT(&v) = VT_BOOL;
	V_BOOL(&v) = (short) bValue;
	if ((hRetRes = pClassObject->Put(pszPropIn, 0, &v, 0)) != S_OK)
	{
		MY_OUTPUT(L"Couldn't do a bool put", 4);
		MY_HRESASSERT(hRetRes);
	}
	VariantClear(&v);

	MY_OUTPUT(L"EXIT ***** PutBoolProperty...", 0);
	return hRetRes;
}

/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////QUALIFIER GETS//////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////MISC GETS///////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

HRESULT GetWbemObjectInst(IWbemServices** ppSvc, LPCTSTR pszName, IWbemContext *pContext, IWbemClassObject **pOutObj)
{
	HRESULT hRetRes = S_OK;
	BSTR bstrClassName = NULL;

	*pOutObj = NULL;

	MY_OUTPUT(L"ENTER ***** GetWbemObjectInst...", 0);
	MY_ASSERT(pszName);
	if (!pszName)
	{
		return WBEM_E_INVALID_PROPERTY;
	}
	if (pszName[0] == '\0')
	{
		bstrClassName = SysAllocString(L" ");
		MY_ASSERT(bstrClassName); if (!bstrClassName) return WBEM_E_OUT_OF_MEMORY;
		bstrClassName[0] = '\0';
	}
	else
	{
		bstrClassName = SysAllocString(pszName);
	}
	MY_ASSERT(bstrClassName); if (!bstrClassName) return WBEM_E_OUT_OF_MEMORY;

	hRetRes = (*ppSvc)->GetObject(bstrClassName, 0L, pContext, pOutObj, NULL);
	if (FAILED(hRetRes))
	{
		MY_OUTPUT(L"GetWbemObjectInst:Failed to get object instance", 0);
//		MY_HRESASSERT(hRetRes);
	}

	SysFreeString(bstrClassName);

	MY_OUTPUT(L"EXIT ***** GetWbemObjectInst...", 0);
	return hRetRes;
}

HRESULT GetWbemObjectInstSemiSync(IWbemServices** ppSvc, LPCTSTR pszName, IWbemContext *pContext, IWbemCallResult **pOutObj)
{
	HRESULT hRetRes = S_OK;
	BSTR bstrPropName = NULL;

	MY_OUTPUT(L"ENTER ***** GetWbemObjectInstSemiSync...", 0);
	MY_ASSERT(pszName);
	if (!pszName)
	{
		return WBEM_E_INVALID_PROPERTY;
	}

	if (pszName[0] == '\0')
	{
		bstrPropName = SysAllocString(L" ");
		MY_ASSERT(bstrPropName); if (!bstrPropName) return WBEM_E_OUT_OF_MEMORY;
		bstrPropName[0] = '\0';
	}
	else
	{
		bstrPropName = SysAllocString(pszName);
	}
	MY_ASSERT(bstrPropName); if (!bstrPropName) return WBEM_E_OUT_OF_MEMORY;

	hRetRes = (*ppSvc)->GetObject(bstrPropName, WBEM_FLAG_RETURN_IMMEDIATELY, pContext, NULL, pOutObj);

	if (FAILED(hRetRes))
	{
		MY_OUTPUT(L"GetWbemObjectInst:Failed to get object instance", 0);
		MY_HRESASSERT(hRetRes);
	}

	SysFreeString(bstrPropName);

	MY_OUTPUT(L"EXIT ***** GetWbemObjectInstSemiSync...", 0);
	return hRetRes;
}

HRESULT SendEvents(IWbemObjectSink* pEventSink, IWbemClassObject** pInstances, int iSize)
{
	HRESULT hRetRes = S_OK;

	if (iSize == 0)
		return S_FALSE;

	// Send event to the sink if there's a listener
	if (pEventSink)
	{
		hRetRes = pEventSink->Indicate(iSize, pInstances);
		//WBEM_E_SERVER_TOO_BUSY is Ok. Wbem will deliver.
		if (FAILED(hRetRes) && hRetRes != WBEM_E_SERVER_TOO_BUSY)
		{
			MY_OUTPUT(L"Failed on Indicate!", 4);
			MY_HRESASSERT(hRetRes);
		}
	}

	return hRetRes;
}

HRESULT	GetWbemClassObject(IWbemClassObject** ppObj, VARIANT* v)
{
	HRESULT hRetRes = S_OK;

	IUnknown* pDispatch = (IUnknown*)V_UNKNOWN(v);

	pDispatch->AddRef();

	hRetRes = pDispatch->QueryInterface(IID_IWbemClassObject, (LPVOID*)ppObj);
	MY_HRESASSERT(hRetRes);
	pDispatch->Release();
	
	return hRetRes;
}

// This is only filled in if the provider supplies it, and in most cases it does not.
// Try using IWbemStatusText, or some other interface
BOOL GetLatestWMIError(int code, HRESULT hResIn, LPTSTR pszString)
{
	LPVOID lpMsgBuf;
	VARIANT varString;
	SCODE sc;
	IWbemClassObject *pErrorObject = NULL;
	IErrorInfo* pEI = NULL;
	TCHAR szError[1024];

	if(GetErrorInfo(0, &pEI) == S_OK)
	{
		pEI->QueryInterface(IID_IWbemClassObject, (void**)&pErrorObject);
		pEI->Release();
	}

	if (pErrorObject != NULL)
	{
		VariantInit(&varString);

		if (pErrorObject->InheritsFrom(L"__ExtendedStatus") == WBEM_NO_ERROR)
		{
			sc = pErrorObject->Get(L"Description", 0L, &varString, NULL, NULL);
			if (sc != S_OK)
			{
				if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_MISSINGDESC, pszString, 1023))
				{
					wcscpy(pszString, L"Unknown string. (Can't locate resource DLL)");
				}
				else
				{
					swprintf(szError, L"0x%08x : ", sc);
					wcsncat(pszString, szError, 1023-wcslen(pszString));
					pszString[1023] = '\0';
				}
			}
			else if (V_VT(&varString) == VT_BSTR)
			{
				if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_DESC, pszString, 1023))
				{
					wcscpy(pszString, L"Unknown string. (Can't locate resource DLL)");
				}
				else
				{
					swprintf(szError, L"%256wS.", V_BSTR(&varString));
					wcscat(pszString, szError);
				}
			}
			VariantClear(&varString);
		}
		else
		{
			if (g_hResLib == NULL || !LoadString(g_hResLib, HMRES_BADERROR, pszString, 1023))
			{
				wcscpy(pszString, L"Unknown string. (Can't locate resource DLL)");
			}
		}
		pErrorObject->Release();
	}

	szError[0] = '\0';
	GetLatestAgentError(code, szError);
	wcsncat(pszString, szError, 1023-wcslen(pszString));
	pszString[1023] = '\0';

	wsprintf(szError, L" 0x%08x : ", hResIn);
	wcsncat(pszString, szError, 1023-wcslen(pszString));
	pszString[1023] = '\0';
	if (g_hWbemComnModule)
	{
		FormatMessage(FORMAT_MESSAGE_MAX_WIDTH_MASK|FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE,
				g_hWbemComnModule, hResIn, 0, (LPTSTR) &lpMsgBuf, 0, NULL);
//MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language
		if (lpMsgBuf)
		{
			wcsncat(pszString, (LPCTSTR)lpMsgBuf, 1023-wcslen(pszString));
			pszString[1023] = '\0';
			LocalFree(lpMsgBuf);
			wcsncat(pszString, L". ", 1023-wcslen(pszString));
			pszString[1023] = '\0';
		}
	}
	return TRUE;
}

BOOL GetLatestAgentError(int code, LPTSTR pszString)
{
	if (g_hResLib == NULL || !LoadString(g_hResLib, code, pszString, 1023))
	{
		wcscpy(pszString, L"Unknown state. (Can't locate resource DLL)");
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\hmheaderctrl.h ===
#if !defined(AFX_HMHEADERCTRL_H__9D8E6327_190D_11D3_BDF0_0000F87A3912__INCLUDED_)
#define AFX_HMHEADERCTRL_H__9D8E6327_190D_11D3_BDF0_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HMHeaderCtrl.h : header file
//

#define _MAX_COLUMNS 2

/////////////////////////////////////////////////////////////////////////////
// CHMHeaderCtrl window

class CHMHeaderCtrl : public CHeaderCtrl
{
// Construction
public:
	CHMHeaderCtrl();

// Attributes
public:
	int GetLastColumn();
protected:
	HBITMAP GetArrowBitmap(bool bAscending);
	void CreateUpArrowBitmap();
	void CreateDownArrowBitmap();
	CBitmap m_up;
	CBitmap m_down;
	int m_iLastColumn;
	bool m_bSortAscending;

// Operations
public:
	int SetSortImage( int nColumn, bool bAscending );
	void RemoveSortImage(int nColumn);
	void RemoveAllSortImages();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHMHeaderCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHMHeaderCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CHMHeaderCtrl)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMHEADERCTRL_H__9D8E6327_190D_11D3_BDF0_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\hmlistview.cpp ===
// HMListView.cpp : Implementation of CHMListViewApp and DLL registration.

#include "stdafx.h"
#include "HMListView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CHMListViewApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x5116a803, 0xdafc, 0x11d2, { 0xbd, 0xa4, 0, 0, 0xf8, 0x7a, 0x39, 0x12 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CHMListViewApp::InitInstance - DLL initialization

BOOL CHMListViewApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		InitCommonControls();
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CHMListViewApp::ExitInstance - DLL termination

int CHMListViewApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\hmlist.cpp ===
// HMList.cpp : implementation file
//

#include "stdafx.h"
#include "HMListView.h"
#include "HMList.h"
#include "SortClass.h"
#include "HMListViewCtl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const int _IDM_HEADER_CONTEXTMENU_BASE = 1500;


//-----------------------------------------------------------------------------------
// IA64 : We add SetItemDataPtr and GetItemDataPtr since the old mechanism
//                of storing a pointer case to a DWORD or long can not be used
//                in Win64 because the high order bits of the pointer are lost on
//                conversion.
//*************************************************
// SetItemDataPtr
//*************************************************
BOOL CHMList::SetItemDataPtr(int nItem, void* ptr)
{
    if ((nItem < 0) || (nItem > (GetItemCount() - 1)))
        return FALSE;

    m_mapSortItems[nItem] = ptr;
    return TRUE;
}
//*************************************************
// GetItemDataPtr
//*************************************************
void* CHMList::GetItemDataPtr(int nItem) const
{
    if ((nItem < 0) || (nItem > (GetItemCount() - 1)))
        return NULL;

    void* p=NULL;

	if( ! m_mapSortItems.Lookup(nItem,(void*&)p) )
		return NULL;
    
    return p;
}
//------------------------------------------------------------------------------------





/////////////////////////////////////////////////////////////////////////////
// CHMList

/////////////////////////////////////////////////////////////////////////////
// Construction/Destruction
/////////////////////////////////////////////////////////////////////////////

CHMList::CHMList()
{
	m_bSorting = false;
	m_lColumnSortStates = 0;
  m_lColumnClicked = -1;
}

CHMList::~CHMList()
{
}

/////////////////////////////////////////////////////////////////////////////
// Sorting Operations
/////////////////////////////////////////////////////////////////////////////

void CHMList::SortColumn( int iSubItem, bool bSortingMultipleColumns )
{	
	int iNumCombinedSortedCols = GetNumCombinedSortedColumns();
	m_bSorting = true;

	if( bSortingMultipleColumns )
	{
		if( NotInCombinedSortedColumnList( iSubItem ) )
		{
			m_aCombinedSortedColumns[ iNumCombinedSortedCols++ ] = iSubItem;
		}
		else
		{
			MoveItemInCombinedSortedListToEnd( iSubItem );
		}

		for( int i = iNumCombinedSortedCols - 1; i >= 0 ; i-- )
		{
			SORT_STATE ssEachItem = GetItemSortState( m_aCombinedSortedColumns[i] );
			if( iNumCombinedSortedCols - 1 != i )
			{
				ssEachItem = (SORT_STATE)!ssEachItem;
			}
			
			CSortClass csc(this, m_aCombinedSortedColumns[i] );	
			csc.Sort( ssEachItem ? true : false );
			if( i == iNumCombinedSortedCols - 1 )
			{	//Only swap the last column's sort order.
				m_headerctrl.SetSortImage( m_aCombinedSortedColumns[i], ssEachItem ? true : false );
				SetItemSortState( m_aCombinedSortedColumns[i] , (SORT_STATE)!ssEachItem );			
			}
		}
	}
	else
	{
		m_headerctrl.RemoveAllSortImages();
		EmptyArray(m_aCombinedSortedColumns);
		m_aCombinedSortedColumns[ 0 ] = iSubItem;
		SORT_STATE ssEachItem = GetItemSortState( iSubItem );
		
		CSortClass csc(this, iSubItem );	
		csc.Sort( ssEachItem ? true : false );
		m_headerctrl.SetSortImage( iSubItem, ssEachItem ? true : false );
		SetItemSortState( iSubItem , (SORT_STATE)!ssEachItem );
	}
	m_bSorting = false;
}

const int CHMList::GetNumCombinedSortedColumns() const
{
	for( int i = 0; i < MAX_COLUMNS; i++ )
	{
		if( m_aCombinedSortedColumns[i] == -1 )
		{
			return i;
		}
	}
	return MAX_COLUMNS;
}

bool CHMList::NotInCombinedSortedColumnList(int iItem) const
{
	int iNumCombinedSortedColumns = GetNumCombinedSortedColumns();
	for( int i = 0; i < iNumCombinedSortedColumns; i++ )
	{
		if( m_aCombinedSortedColumns[i] == iItem )
		{
			return false;
		}
	}
	return true;
}

void CHMList::MoveItemInCombinedSortedListToEnd(int iItem)
{
	int iNumCombinedSortedColumns = GetNumCombinedSortedColumns();
	int aCombinedSortedColumns[MAX_COLUMNS];
	memset( aCombinedSortedColumns, -1, MAX_COLUMNS );
	int iItemIndex = FindItemInCombedSortedList( iItem );
	if( iItemIndex != -1 )
	{
		if( iItemIndex > 0 )
		{
			memcpy( aCombinedSortedColumns, m_aCombinedSortedColumns, iItemIndex * sizeof( int ) );
			memcpy( &aCombinedSortedColumns[iItemIndex], &m_aCombinedSortedColumns[iItemIndex + 1], (iNumCombinedSortedColumns - iItemIndex - 1) * sizeof(int) );
		}
	}
	aCombinedSortedColumns[ iNumCombinedSortedColumns - 1 ] = iItem;
	memcpy( m_aCombinedSortedColumns, aCombinedSortedColumns, MAX_COLUMNS * sizeof(int) );
	for( int i = 0; i < MAX_COLUMNS ; i++ )
	{
		if( aCombinedSortedColumns[i] == -1 )
			break;
	}
}

const SORT_STATE CHMList::GetItemSortState( int iItem ) const
{
	return (SORT_STATE)((m_lColumnSortStates) & ( 1 << iItem ));
}

void CHMList::SetItemSortState(int iItem, SORT_STATE bSortState)
{
	if( bSortState != GetItemSortState( iItem ) )
	{
		m_lColumnSortStates ^= (1 << iItem);
	}
}

void CHMList::EmptyArray( int *pArray )
{
	memset( pArray, -1, MAX_COLUMNS );
}

const bool CHMList::IsColumnNumeric( int iCol ) const
{
	for( int i = 0; i < m_aNumericColumns.GetSize(); i++ )
	{	
		if( m_aNumericColumns.GetAt( i ) == (UINT)iCol )
		{
			return true;
		}
	}
	return false;
}

int CHMList::FindItemInCombedSortedList( int iItem )
{
	int iNumCombinedSortedColumns = GetNumCombinedSortedColumns();
	for( int i = 0; i < iNumCombinedSortedColumns; i++ )
	{
		if(m_aCombinedSortedColumns[i] == iItem )
		{
			return i;
		}
	}
	return -1;
}

const int CHMList::IsControlPressed() const
{
	return (::GetKeyState( VK_SHIFT ) < 0 );
}

void CHMList::SetFilterType(long lType)
{
	CHMListViewCtrl* pCtl = (CHMListViewCtrl*)GetParent();

	if( pCtl->IsKindOf(RUNTIME_CLASS(CHMListViewCtrl)) )
	{
    HDITEM hdItem;
    HDTEXTFILTER hdTextFilter;
    CString sFilter;
  
    hdTextFilter.pszText = sFilter.GetBuffer(_MAX_PATH);
    hdTextFilter.cchTextMax = _MAX_PATH;
  
    ZeroMemory(&hdItem,sizeof(HDITEM));
    hdItem.mask = HDI_FILTER;
    hdItem.type = HDFT_ISSTRING;
    hdItem.pvFilter = &hdTextFilter;
        
    m_headerctrl.GetItem(m_lColumnClicked,&hdItem);
    sFilter.ReleaseBuffer();

    ZeroMemory(&hdItem,sizeof(HDITEM));
    hdItem.mask = HDI_LPARAM;
    hdItem.lParam = lType;
    m_headerctrl.SetItem(m_lColumnClicked,&hdItem);

    LRESULT lResult = 0L;
    pCtl->FireFilterChange(m_lColumnClicked,sFilter,lType,&lResult);
  }
}

BEGIN_MESSAGE_MAP(CHMList, CListCtrl)
	//{{AFX_MSG_MAP(CHMList)
	ON_WM_CREATE()
	ON_WM_CONTEXTMENU()
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnclick)
	ON_WM_DESTROY()
	ON_COMMAND(ID_HEADERCONTEXT_FILTERBAR, OnHeadercontextFilterbar)
	ON_NOTIFY_REFLECT(NM_CLICK, OnClick)
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
	ON_NOTIFY_REFLECT(NM_RCLICK, OnRclick)
	ON_NOTIFY_REFLECT(LVN_ENDLABELEDIT, OnEndlabeledit)
	ON_NOTIFY_REFLECT(LVN_KEYDOWN, OnKeydown)
	ON_NOTIFY(HDN_FILTERCHANGE, 0, OnFilterChange)
	ON_NOTIFY(HDN_FILTERBTNCLICK, 0, OnFilterButtonClicked)
	ON_COMMAND(ID_FILTERMENU_CONTAINS, OnFiltermenuContains)
	ON_COMMAND(ID_FILTERMENU_DOESNOTCONTAIN, OnFiltermenuDoesnotcontain)
	ON_COMMAND(ID_FILTERMENU_ENDSWITH, OnFiltermenuEndswith)
	ON_COMMAND(ID_FILTERMENU_ISEXACTLY, OnFiltermenuIsexactly)
	ON_COMMAND(ID_FILTERMENU_ISNOT, OnFiltermenuIsnot)
	ON_COMMAND(ID_FILTERMENU_STARTSWITH, OnFiltermenuStartswith)
	ON_COMMAND(ID_FILTERMENU_CLEARFILTER, OnFiltermenuClearfilter)
	ON_COMMAND(ID_FILTERMENU_CLEARALLFILTERS, OnFiltermenuClearallfilters)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHMList message handlers

BOOL CHMList::PreCreateWindow(CREATESTRUCT& cs) 
{
	cs.style = cs.style|LVS_EDITLABELS|LVS_REPORT;
	cs.lpszClass = _T("SysListView32");	
	
	return CListCtrl::PreCreateWindow(cs);
}

int CHMList::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CListCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_headerctrl.SubclassWindow( GetHeaderCtrl()->GetSafeHwnd() );
  m_headerctrl.SendMessage(HDM_SETFILTERCHANGETIMEOUT, 0, 1000);
		
	return 0;
}

void CHMList::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	// Handle right click on the header control
	if( pWnd->GetSafeHwnd() == GetHeaderCtrl()->GetSafeHwnd() )
	{
    CMenu menu;
		menu.LoadMenu(IDR_MENU_HEADER_CONTEXT);
		CMenu& listcontextmenu = *menu.GetSubMenu(1);

		CHeaderCtrl* pHdrCtrl = GetHeaderCtrl();
		DWORD dwStyle = GetWindowLong(pHdrCtrl->GetSafeHwnd(),GWL_STYLE);

		if( dwStyle & HDS_FILTERBAR )
		{
			listcontextmenu.CheckMenuItem(ID_HEADERCONTEXT_FILTERBAR,MF_BYCOMMAND|MF_CHECKED);
		}

		int iCol = 0;
		TCHAR szName[255];
		LVCOLUMN lvc;
		ZeroMemory(&lvc,sizeof(LVCOLUMN));
		lvc.mask = LVCF_TEXT|LVCF_WIDTH;
		lvc.pszText = szName;
		lvc.cchTextMax = 255;

		while( GetColumn(iCol,&lvc) )
		{
			if( lvc.cx > 0 )
			{
				listcontextmenu.AppendMenu(MF_CHECKED|MF_STRING,_IDM_HEADER_CONTEXTMENU_BASE+iCol,lvc.pszText);
			}
			else
			{
				listcontextmenu.AppendMenu(MF_UNCHECKED|MF_STRING,_IDM_HEADER_CONTEXTMENU_BASE+iCol,lvc.pszText);
			}
			iCol++;
		}

		listcontextmenu.TrackPopupMenu(TPM_LEFTALIGN,point.x,point.y,this);

		listcontextmenu.DestroyMenu();
    menu.DestroyMenu();
	}	
}

void CHMList::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	if( IsControlPressed() )
	{
		SortColumn( pNMListView->iSubItem, MULTI_COLUMN_SORT );
	}
	else
	{
		SortColumn( pNMListView->iSubItem, SINGLE_COLUMN_SORT );
	}

	*pResult = 0;

}

void CHMList::OnDestroy() 
{
	CListCtrl::OnDestroy();
}

void CHMList::OnHeadercontextFilterbar() 
{
	// set styles for the header control
	CHeaderCtrl* pHdrCtrl = GetHeaderCtrl();
	DWORD dwStyle = GetWindowLong(pHdrCtrl->GetSafeHwnd(),GWL_STYLE);

	if( dwStyle & HDS_FILTERBAR )
	{
		dwStyle &= ~HDS_FILTERBAR;
	}
	else
	{
		dwStyle |= HDS_FILTERBAR;
	}

	SetWindowLong(pHdrCtrl->GetSafeHwnd(),GWL_STYLE,dwStyle);
}

BOOL CHMList::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	WORD wID = LOWORD(wParam);

	if( wID >= _IDM_HEADER_CONTEXTMENU_BASE )
	{
		TCHAR szName[255];
		int iCol = wID - _IDM_HEADER_CONTEXTMENU_BASE;
		LVCOLUMN lvc;
		ZeroMemory(&lvc,sizeof(LVCOLUMN));
		lvc.mask = LVCF_TEXT|LVCF_WIDTH;
		lvc.cx = 0;
		lvc.pszText = szName;
		lvc.cchTextMax = 255;
		GetColumn(iCol,&lvc);
		if( lvc.cx == 0 )
		{
			CDC dc;
			dc.Attach(::GetDC(NULL));
		
			// get the width in pixels of the item
			CSize size  = dc.GetTextExtent(lvc.pszText);
			lvc.cx = size.cx + 50;
			
			HDC hDC = dc.Detach();
			::ReleaseDC(NULL,hDC);
		}
		else
		{
			lvc.cx = 0;
		}
		SetColumn(iCol,&lvc);
	}
		
	return CListCtrl::OnCommand(wParam, lParam);
}

#pragma warning(disable : 4100)
void CHMList::OnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	CHMListViewCtrl* pCtl = (CHMListViewCtrl*)GetParent();

	if( pCtl->IsKindOf(RUNTIME_CLASS(CHMListViewCtrl)) )
	{
		POSITION pos = GetFirstSelectedItemPosition();
		if( pos )
		{
			int iSelItem = GetNextSelectedItem(pos);
			long lParam = (long)GetItemData(iSelItem);
			pCtl->FireListClick(lParam);
		}
	}
	
	*pResult = 0;
}

void CHMList::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult) 
{
	CHMListViewCtrl* pCtl = (CHMListViewCtrl*)GetParent();

	if( pCtl->IsKindOf(RUNTIME_CLASS(CHMListViewCtrl)) )
	{
		POSITION pos = GetFirstSelectedItemPosition();
		if( pos )
		{
			int iSelItem = GetNextSelectedItem(pos);
			long lParam = (long)GetItemData(iSelItem);
			pCtl->FireListDblClick(lParam);
		}
	}
	
	*pResult = 0;
}

void CHMList::OnRclick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	CHMListViewCtrl* pCtl = (CHMListViewCtrl*)GetParent();

	if( pCtl->IsKindOf(RUNTIME_CLASS(CHMListViewCtrl)) )
	{
		POSITION pos = GetFirstSelectedItemPosition();
		if( pos )
		{
			int iSelItem = GetNextSelectedItem(pos);
			long lParam = (long)GetItemData(iSelItem);
			pCtl->FireListRClick(lParam);
		}
	}
	
	*pResult = 0;
}

void CHMList::OnEndlabeledit(NMHDR* pNMHDR, LRESULT* pResult) 
{
	LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR;
	CHMListViewCtrl* pCtl = (CHMListViewCtrl*)GetParent();

	if( pCtl->IsKindOf(RUNTIME_CLASS(CHMListViewCtrl)) )
	{
		if( pDispInfo->item.pszText )
		{
			pCtl->FireListLabelEdit(pDispInfo->item.pszText,
								(LONG_PTR)pDispInfo->item.lParam,
								pResult);
			return;
		}
	}
	
	*pResult = 0;
}

void CHMList::OnKeydown(NMHDR* pNMHDR, LRESULT* pResult) 
{
	LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR;

	CHMListViewCtrl* pCtl = (CHMListViewCtrl*)GetParent();

	if( pCtl->IsKindOf(RUNTIME_CLASS(CHMListViewCtrl)) )
	{
		pCtl->FireListKeyDown(pLVKeyDow->wVKey,
							  pLVKeyDow->flags,
							  pResult);
		return;
	}
	
	*pResult = 0;
}


void	CHMList::OnFilterChange(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NMHEADER	*pNMHdr = (NMHEADER*)pNMHDR;

	CHMListViewCtrl* pCtl = (CHMListViewCtrl*)GetParent();

	if( pCtl->IsKindOf(RUNTIME_CLASS(CHMListViewCtrl)) )
	{
    if( pCtl->m_bColumnInsertionComplete )
    {
      CString sFilter;
      long lType = -1;
      if( pNMHdr->iItem != -1 )
      {
        HDITEM hdItem;
        HDTEXTFILTER hdTextFilter;
      
        hdTextFilter.pszText = sFilter.GetBuffer(_MAX_PATH);
        hdTextFilter.cchTextMax = _MAX_PATH;
      
        ZeroMemory(&hdItem,sizeof(HDITEM));
        hdItem.mask = HDI_FILTER|HDI_LPARAM;
        hdItem.type = HDFT_ISSTRING;
        hdItem.pvFilter = &hdTextFilter;


        m_headerctrl.GetItem(pNMHdr->iItem,&hdItem);
        sFilter.ReleaseBuffer();
        lType = (long)hdItem.lParam;
      }
		  pCtl->FireFilterChange(pNMHdr->iItem,sFilter,lType,pResult);
		  return;
    }
	}
	
	*pResult = 0;

}


void	CHMList::OnFilterButtonClicked(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NMHDFILTERBTNCLICK	*pNMFButtonClick = (NMHDFILTERBTNCLICK*)pNMHDR;
	NMHEADER			*pNMHdr = (NMHEADER*)pNMHDR;

	CHMListViewCtrl* pCtl = (CHMListViewCtrl*)GetParent();

	if( pCtl->IsKindOf(RUNTIME_CLASS(CHMListViewCtrl)) )
	{
    CMenu menu;
		menu.LoadMenu(IDR_MENU_HEADER_CONTEXT);
		CMenu& filtermenu = *menu.GetSubMenu(2);

    HDITEM hdItem;
    long lType = 0L;
    
    ZeroMemory(&hdItem,sizeof(HDITEM));
    hdItem.mask = HDI_LPARAM;

    m_lColumnClicked = pNMHdr->iItem;
    m_headerctrl.GetItem(pNMHdr->iItem,&hdItem);

    lType = (long)hdItem.lParam;

    if( lType & HDFS_CONTAINS )
    {
      filtermenu.CheckMenuItem(ID_FILTERMENU_CONTAINS,MF_CHECKED|MF_BYCOMMAND);
    }

    if( lType & HDFS_DOES_NOT_CONTAIN )
    {
      filtermenu.CheckMenuItem(ID_FILTERMENU_DOESNOTCONTAIN,MF_CHECKED|MF_BYCOMMAND);
    }

    if( lType & HDFS_STARTS_WITH )
    {
      filtermenu.CheckMenuItem(ID_FILTERMENU_STARTSWITH,MF_CHECKED|MF_BYCOMMAND);
    }

    if( lType & HDFS_ENDS_WITH )
    {
      filtermenu.CheckMenuItem(ID_FILTERMENU_ENDSWITH,MF_CHECKED|MF_BYCOMMAND);
    }

    if( lType & HDFS_IS )
    {
      filtermenu.CheckMenuItem(ID_FILTERMENU_ISEXACTLY,MF_CHECKED|MF_BYCOMMAND);
    }

    if( lType & HDFS_IS_NOT )
    {
      filtermenu.CheckMenuItem(ID_FILTERMENU_ISNOT,MF_CHECKED|MF_BYCOMMAND);
    }


    CPoint point;
    GetCursorPos(&point);
    filtermenu.TrackPopupMenu(TPM_LEFTALIGN,point.x,point.y,this);

 		filtermenu.DestroyMenu();
    menu.DestroyMenu();

    ZeroMemory(&hdItem,sizeof(HDITEM));
    hdItem.mask = HDI_LPARAM;

    m_headerctrl.GetItem(pNMHdr->iItem,&hdItem);

    lType = (long)hdItem.lParam;

    
	}
	
	*pResult = 0;
}

#pragma warning(default : 4100)

void CHMList::OnFiltermenuContains() 
{
  SetFilterType(HDFS_CONTAINS);	
}

void CHMList::OnFiltermenuDoesnotcontain() 
{
	SetFilterType(HDFS_DOES_NOT_CONTAIN);	
}

void CHMList::OnFiltermenuEndswith() 
{
	SetFilterType(HDFS_ENDS_WITH);		
}

void CHMList::OnFiltermenuIsexactly() 
{
	SetFilterType(HDFS_IS);			
}

void CHMList::OnFiltermenuIsnot() 
{
	SetFilterType(HDFS_IS_NOT);				
}

void CHMList::OnFiltermenuStartswith() 
{
	SetFilterType(HDFS_STARTS_WITH);					
}

void CHMList::OnFiltermenuClearfilter() 
{
	Header_ClearFilter(m_headerctrl.GetSafeHwnd(),m_lColumnClicked);
}

void CHMList::OnFiltermenuClearallfilters() 
{
	Header_ClearAllFilters( m_headerctrl.GetSafeHwnd() );	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\hmlist.h ===
#if !defined(AFX_HMLIST_H__5116A81C_DAFC_11D2_BDA4_0000F87A3912__INCLUDED_)
#define AFX_HMLIST_H__5116A81C_DAFC_11D2_BDA4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HMList.h : header file
//

#include "HMHeaderCtrl.h"
#include <afxtempl.h>  // IA64

#define MAX_COLUMNS	       64
#define MULTI_COLUMN_SORT  1
#define SINGLE_COLUMN_SORT 0

enum SORT_STATE{ DESCENDING=0, ASCENDING=1 };

#define HDFS_INIT             0x0000
#define HDFS_CONTAINS         0x0001
#define HDFS_DOES_NOT_CONTAIN 0x0002
#define HDFS_STARTS_WITH      0x0004
#define HDFS_ENDS_WITH        0x0008
#define HDFS_IS               0x0010
#define HDFS_IS_NOT           0x0020

/////////////////////////////////////////////////////////////////////////////
// CHMList window

class CHMList : public CListCtrl
{
// Construction
public:
	CHMList();

// Sorting
public:
    //-----------------------------------------------------------------------------------
    //         IA64 : We add SetItemDataPtr and GetItemDataPtr since the old mechanism
    //                of storing a pointer case to a DWORD or long can not be used
    //                in Win64 because the high order bits of the pointer are lost on
    //                conversion.
    BOOL SetItemDataPtr(int nItem, void* ptr);
    void* GetItemDataPtr(int nItem) const;
private:
    CMap<int,int,void*,void*> m_mapSortItems;
public:
    //------------------------------------------------------------------------------------
	void SortColumn( int, bool = false );
	const int GetNumCombinedSortedColumns() const;
	bool NotInCombinedSortedColumnList( int iItem ) const;
	void MoveItemInCombinedSortedListToEnd( int );
	const SORT_STATE GetItemSortState( int ) const;
	void SetItemSortState(int iItem, SORT_STATE bSortState);
	void EmptyArray( int * );
	const bool IsColumnNumeric( int ) const;
	int FindItemInCombedSortedList( int );	
	const int IsControlPressed() const;

// Filtering
protected:
  void SetFilterType(long lType);

// Attributes
public:
protected:
	CHMHeaderCtrl m_headerctrl;
	__int64	      m_lColumnSortStates;
	int           m_aCombinedSortedColumns[MAX_COLUMNS];
	CUIntArray    m_aNumericColumns;
	bool					m_bSorting;
  long          m_lColumnClicked;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHMList)
	protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHMList();

	// Generated message map functions
protected:
	//{{AFX_MSG(CHMList)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	afx_msg void OnHeadercontextFilterbar();
	afx_msg void OnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEndlabeledit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydown(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnFilterChange(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnFilterButtonClicked(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnFiltermenuContains();
	afx_msg void OnFiltermenuDoesnotcontain();
	afx_msg void OnFiltermenuEndswith();
	afx_msg void OnFiltermenuIsexactly();
	afx_msg void OnFiltermenuIsnot();
	afx_msg void OnFiltermenuStartswith();
	afx_msg void OnFiltermenuClearfilter();
	afx_msg void OnFiltermenuClearallfilters();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMLIST_H__5116A81C_DAFC_11D2_BDA4_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\hmheaderctrl.cpp ===
// HMHeaderCtrl.cpp : implementation file
//

#include "stdafx.h"
#include "hmlistview.h"
#include "HMHeaderCtrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHMHeaderCtrl

CHMHeaderCtrl::CHMHeaderCtrl()
{
	m_iLastColumn = -1;
}

CHMHeaderCtrl::~CHMHeaderCtrl()
{
	m_up.DeleteObject();
	m_down.DeleteObject();
}

inline HBITMAP CHMHeaderCtrl::GetArrowBitmap(bool bAscending)
{
	if( bAscending )
	{
		if( ! m_up.GetSafeHandle() )
		{
			CreateUpArrowBitmap();
		}
		return (HBITMAP)m_up.GetSafeHandle();
	}
	else
	{
		if( ! m_down.GetSafeHandle() )
		{
			CreateDownArrowBitmap();
		}
		return (HBITMAP)m_down.GetSafeHandle();
	}

	return NULL;
}

inline void CHMHeaderCtrl::CreateUpArrowBitmap()
{
	CDC MemDC;
	CClientDC dc(this);
	CRect r(0,0,8,8);

	// create offscreen dc and offscreen bitmap
	MemDC.CreateCompatibleDC(&dc);

	m_up.CreateCompatibleBitmap(&dc,r.Width(),r.Height());

	CBitmap* pOldBitmap = MemDC.SelectObject(&m_up);

	// Draw the background
	MemDC.FillSolidRect(r, ::GetSysColor(COLOR_3DFACE));

	// Set up pens to use for drawing the triangle
	CPen penLight(PS_SOLID, 1, GetSysColor(COLOR_3DHILIGHT));
	CPen penShadow(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW));
	CPen *pOldPen = MemDC.SelectObject( &penLight );

	// Draw triangle pointing upwards
	MemDC.MoveTo( r.left,		r.bottom-1 );
	MemDC.LineTo( r.right,	r.bottom-1 );
	MemDC.LineTo( r.right/2,	r.top );

	MemDC.SelectObject( &penShadow );
	MemDC.LineTo( r.left, r.bottom-1 );

	// clean up
	MemDC.SelectObject(pOldPen);
	MemDC.SelectObject(pOldBitmap);
}

inline void CHMHeaderCtrl::CreateDownArrowBitmap()
{
	CDC MemDC;
	CClientDC dc(this);
	CRect r(0,0,8,8);

	// create offscreen dc and offscreen bitmap
	MemDC.CreateCompatibleDC(&dc);

	m_down.CreateCompatibleBitmap(&dc,r.Width(),r.Height());

	CBitmap* pOldBitmap = MemDC.SelectObject(&m_down);

	// Draw the background
	MemDC.FillSolidRect(r, ::GetSysColor(COLOR_3DFACE));

	// Set up pens to use for drawing the triangle
	CPen penLight(PS_SOLID, 1, GetSysColor(COLOR_3DHILIGHT));
	CPen penShadow(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW));
	CPen *pOldPen = MemDC.SelectObject( &penShadow );

	// Draw triangle pointing downwards
	MemDC.MoveTo( r.right,		r.top );
	MemDC.LineTo( r.left,			r.top );
	MemDC.LineTo( r.right/2,	r.bottom );

	MemDC.SelectObject( &penLight );
	MemDC.LineTo( r.right, r.top );

	// clean up
	MemDC.SelectObject(pOldPen);
	MemDC.SelectObject(pOldBitmap);
}

int CHMHeaderCtrl::SetSortImage( int nColumn, bool bAscending )
{
	int nPrevCol = m_iLastColumn;
	m_bSortAscending = bAscending;

	// set the passed column to display the appropriate sort indicator
	HDITEM hditem;
	hditem.mask = HDI_FORMAT;
	GetItem( nColumn, &hditem );
	hditem.mask = HDI_BITMAP | HDI_FORMAT;
	hditem.fmt |= HDF_BITMAP;
	hditem.fmt |= HDF_BITMAP_ON_RIGHT;
	hditem.hbm = (HBITMAP)GetArrowBitmap(bAscending);
	SetItem( nColumn, &hditem );

	// save off the last column the user clikced on
	m_iLastColumn = nColumn;

	return nPrevCol;
}

void CHMHeaderCtrl::RemoveSortImage(int nColumn)
{
	// clear the sort indicator from the previous column
	HDITEM hditem;
	hditem.mask = HDI_FORMAT;
	GetItem( nColumn, &hditem );
	hditem.mask = HDI_FORMAT;
	hditem.fmt &= ~HDF_BITMAP;
	hditem.fmt &= ~HDF_BITMAP_ON_RIGHT;
	SetItem( nColumn, &hditem );
}

void CHMHeaderCtrl::RemoveAllSortImages()
{
	int iCount = GetItemCount();
	for( int i = 0; i < iCount; i++ )
	{
		RemoveSortImage(i);
	}
}


BEGIN_MESSAGE_MAP(CHMHeaderCtrl, CHeaderCtrl)
	//{{AFX_MSG_MAP(CHMHeaderCtrl)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHMHeaderCtrl message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\hmlistview.h ===
#if !defined(AFX_HMLISTVIEW_H__5116A80C_DAFC_11D2_BDA4_0000F87A3912__INCLUDED_)
#define AFX_HMLISTVIEW_H__5116A80C_DAFC_11D2_BDA4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// HMListView.h : main header file for HMLISTVIEW.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CHMListViewApp : See HMListView.cpp for implementation.

class CHMListViewApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMLISTVIEW_H__5116A80C_DAFC_11D2_BDA4_0000F87A3912__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\hmlistviewctl.cpp ===
// HMListViewCtl.cpp : Implementation of the CHMListViewCtrl ActiveX Control class.

#include "stdafx.h"
#include "HMListView.h"
#include "HMListViewCtl.h"
#include "HMListViewPpg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CHMListViewCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CHMListViewCtrl, COleControl)
	//{{AFX_MSG_MAP(CHMListViewCtrl)
	ON_WM_CREATE()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CHMListViewCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CHMListViewCtrl)
	DISP_PROPERTY_EX(CHMListViewCtrl, "Title", GetTitle, SetTitle, VT_BSTR)
	DISP_PROPERTY_EX(CHMListViewCtrl, "Description", GetDescription, SetDescription, VT_BSTR)
	DISP_FUNCTION(CHMListViewCtrl, "SetProgressRange", SetProgressRange, VT_EMPTY, VTS_I4 VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "GetProgressPos", GetProgressPos, VT_I4, VTS_NONE)
	DISP_FUNCTION(CHMListViewCtrl, "SetProgressPos", SetProgressPos, VT_EMPTY, VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "InsertItem", InsertItem, VT_I4, VTS_I4 VTS_I4 VTS_BSTR VTS_I4 VTS_I4 VTS_I4 VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "InsertColumn", InsertColumn, VT_I4, VTS_I4 VTS_BSTR VTS_I4 VTS_I4 VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "SetItem", SetItem, VT_I4, VTS_I4 VTS_I4 VTS_I4 VTS_BSTR VTS_I4 VTS_I4 VTS_I4 VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "GetStringWidth", GetStringWidth, VT_I4, VTS_BSTR)
	DISP_FUNCTION(CHMListViewCtrl, "GetColumnWidth", GetColumnWidth, VT_I4, VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "SetColumnWidth", SetColumnWidth, VT_BOOL, VTS_I4 VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "FindItemByLParam", FindItemByLParam, VT_I4, VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "GetImageList", GetImageList, VT_I4, VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "DeleteAllItems", DeleteAllItems, VT_BOOL, VTS_NONE)
	DISP_FUNCTION(CHMListViewCtrl, "DeleteColumn", DeleteColumn, VT_BOOL, VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "StepProgressBar", StepProgressBar, VT_I4, VTS_NONE)
	DISP_FUNCTION(CHMListViewCtrl, "SetProgressStep", SetProgressStep, VT_I4, VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "SetImageList", SetImageList, VT_I4, VTS_I4 VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "GetNextItem", GetNextItem, VT_I4, VTS_I4 VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "GetItem", GetItem, VT_I4, VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "DeleteItem", DeleteItem, VT_BOOL, VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "GetItemCount", GetItemCount, VT_I4, VTS_NONE)
	DISP_FUNCTION(CHMListViewCtrl, "ModifyListStyle", ModifyListStyle, VT_BOOL, VTS_I4 VTS_I4 VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "GetColumnCount", GetColumnCount, VT_I4, VTS_NONE)
	DISP_FUNCTION(CHMListViewCtrl, "GetColumnOrderIndex", GetColumnOrderIndex, VT_I4, VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "SetColumnOrderIndex", SetColumnOrderIndex, VT_I4, VTS_I4 VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "GetColumnOrder", GetColumnOrder, VT_BSTR, VTS_NONE)
	DISP_FUNCTION(CHMListViewCtrl, "SetColumnOrder", SetColumnOrder, VT_EMPTY, VTS_BSTR)
	DISP_FUNCTION(CHMListViewCtrl, "SetColumnFilter", SetColumnFilter, VT_EMPTY, VTS_I4 VTS_BSTR VTS_I4)
	DISP_FUNCTION(CHMListViewCtrl, "GetColumnFilter", GetColumnFilter, VT_EMPTY, VTS_I4 VTS_PBSTR VTS_PI4)
	DISP_FUNCTION(CHMListViewCtrl, "GetSelectedCount", GetSelectedCount, VT_I4, VTS_NONE)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CHMListViewCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CHMListViewCtrl, COleControl)
	//{{AFX_EVENT_MAP(CHMListViewCtrl)
	EVENT_CUSTOM("ListClick", FireListClick, VTS_I4)
	EVENT_CUSTOM("ListDblClick", FireListDblClick, VTS_I4)
	EVENT_CUSTOM("ListRClick", FireListRClick, VTS_I4)
	EVENT_CUSTOM("CompareItem", FireCompareItem, VTS_I4  VTS_I4  VTS_I4  VTS_PI4)
	EVENT_CUSTOM("ListLabelEdit", FireListLabelEdit, VTS_BSTR  VTS_I4  VTS_PI4)
	EVENT_CUSTOM("ListKeyDown", FireListKeyDown, VTS_I4  VTS_I4  VTS_PI4)
	EVENT_CUSTOM("FilterChange", FireFilterChange, VTS_I4  VTS_BSTR  VTS_I4  VTS_PI4)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CHMListViewCtrl, 1)
	PROPPAGEID(CHMListViewPropPage::guid)
END_PROPPAGEIDS(CHMListViewCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CHMListViewCtrl, "HMLISTVIEW.HMListViewCtrl.1",
	0x5116a806, 0xdafc, 0x11d2, 0xbd, 0xa4, 0, 0, 0xf8, 0x7a, 0x39, 0x12)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CHMListViewCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DHMListView =
		{ 0x5116a804, 0xdafc, 0x11d2, { 0xbd, 0xa4, 0, 0, 0xf8, 0x7a, 0x39, 0x12 } };
const IID BASED_CODE IID_DHMListViewEvents =
		{ 0x5116a805, 0xdafc, 0x11d2, { 0xbd, 0xa4, 0, 0, 0xf8, 0x7a, 0x39, 0x12 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwHMListViewOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_IGNOREACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CHMListViewCtrl, IDS_HMLISTVIEW, _dwHMListViewOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CHMListViewCtrl::CHMListViewCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CHMListViewCtrl

BOOL CHMListViewCtrl::CHMListViewCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_HMLISTVIEW,
			IDB_HMLISTVIEW,
			afxRegApartmentThreading,
			_dwHMListViewOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// Licensing strings

static const TCHAR BASED_CODE _szLicFileName[] = _T("HMListView.lic");

static const WCHAR BASED_CODE _szLicString[] =
	L"Copyright (c) 1999 Microsoft";


/////////////////////////////////////////////////////////////////////////////
// CHMListViewCtrl::CHMListViewCtrlFactory::VerifyUserLicense -
// Checks for existence of a user license

BOOL CHMListViewCtrl::CHMListViewCtrlFactory::VerifyUserLicense()
{
	return AfxVerifyLicFile(AfxGetInstanceHandle(), _szLicFileName,
		_szLicString);
}


/////////////////////////////////////////////////////////////////////////////
// CHMListViewCtrl::CHMListViewCtrlFactory::GetLicenseKey -
// Returns a runtime licensing key

BOOL CHMListViewCtrl::CHMListViewCtrlFactory::GetLicenseKey(DWORD dwReserved,
	BSTR FAR* pbstrKey)
{
	if (pbstrKey == NULL)
		return FALSE;

	*pbstrKey = SysAllocString(_szLicString);
	return (*pbstrKey != NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CHMListViewCtrl::CHMListViewCtrl - Constructor

CHMListViewCtrl::CHMListViewCtrl()
{
	InitializeIIDs(&IID_DHMListView, &IID_DHMListViewEvents);

	m_bColumnInsertionComplete = false;
}


/////////////////////////////////////////////////////////////////////////////
// CHMListViewCtrl::~CHMListViewCtrl - Destructor

CHMListViewCtrl::~CHMListViewCtrl()
{
	// TODO: Cleanup your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CHMListViewCtrl::OnDraw - Drawing function

void CHMListViewCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{

}


/////////////////////////////////////////////////////////////////////////////
// CHMListViewCtrl::DoPropExchange - Persistence support

void CHMListViewCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CHMListViewCtrl::GetControlFlags -
// Flags to customize MFC's implementation of ActiveX controls.
//
// For information on using these flags, please see MFC technical note
// #nnn, "Optimizing an ActiveX Control".
DWORD CHMListViewCtrl::GetControlFlags()
{
	DWORD dwFlags = COleControl::GetControlFlags();


	// The control can receive mouse notifications when inactive.
	// TODO: if you write handlers for WM_SETCURSOR and WM_MOUSEMOVE,
	//		avoid using the m_hWnd member variable without first
	//		checking that its value is non-NULL.
	dwFlags |= pointerInactive;
	return dwFlags;
}


/////////////////////////////////////////////////////////////////////////////
// CHMListViewCtrl::OnResetState - Reset control to default state

void CHMListViewCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CHMListViewCtrl::AboutBox - Display an "About" box to the user

void CHMListViewCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_HMLISTVIEW);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CHMListViewCtrl message handlers

int CHMListViewCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	if( m_titlebar.Create(WS_BORDER|WS_CHILD|WS_VISIBLE|CCS_TOP|CCS_NODIVIDER,CRect(0,0,10,10),this,4500) == -1 )
		return -1;

	if( m_statusbar.Create(WS_BORDER|WS_CHILD|WS_VISIBLE|CCS_BOTTOM|CCS_NODIVIDER,CRect(0,lpCreateStruct->y,10,10),this,4501) == -1 )
		return -1;

	if( m_list.Create(WS_BORDER|WS_CHILD|WS_VISIBLE,CRect(0,0,10,10),this,4502) == -1 )
		return -1;

	// set styles for the list control
	DWORD dwStyle = GetWindowLong(m_list.GetSafeHwnd(),GWL_STYLE);
	dwStyle |= LVS_EDITLABELS;
	SetWindowLong(m_list.GetSafeHwnd(),GWL_STYLE,dwStyle);	

	// set the extended styles for the list control
	m_list.SetExtendedStyle(LVS_EX_INFOTIP|LVS_EX_LABELTIP|LVS_EX_FULLROWSELECT|LVS_EX_HEADERDRAGDROP);

	// set styles for the header control
	CHeaderCtrl* pHdrCtrl = m_list.GetHeaderCtrl();
	pHdrCtrl->ModifyStyle(0,HDS_DRAGDROP|HDS_BUTTONS/*|HDS_FILTERBAR*/);
	
	// set intial window sizes
	CRect rcControl;
	GetClientRect(rcControl);
	
	CRect rcTitle;
	m_titlebar.GetClientRect(rcTitle);

	CRect rcStatus;
	m_statusbar.GetClientRect(rcStatus);

	m_titlebar.SetWindowPos(NULL,0,0,rcControl.Width(),rcTitle.Height(),SWP_NOZORDER|SWP_NOMOVE|SWP_SHOWWINDOW);	

	m_list.SetWindowPos(NULL,0,rcTitle.Height()+1,rcControl.Width(),rcControl.Height()-rcTitle.Height()-rcTitle.Height()-3,SWP_NOZORDER|SWP_SHOWWINDOW);	

	m_statusbar.SetWindowPos(NULL,0,0,rcControl.Width(),rcStatus.Height(),SWP_NOZORDER|SWP_NOMOVE|SWP_SHOWWINDOW);	
	
	return 0;
}

void CHMListViewCtrl::OnSize(UINT nType, int cx, int cy) 
{
	COleControl::OnSize(nType, cx, cy);

	if( GetSafeHwnd() )
	{
		CRect rcControl;
		GetClientRect(rcControl);
		
		CRect rcTitle;
		m_titlebar.GetClientRect(rcTitle);

		CRect rcStatus;
		m_statusbar.GetClientRect(rcStatus);

		m_titlebar.SetWindowPos(NULL,0,0,rcControl.Width(),rcTitle.Height(),SWP_NOZORDER|SWP_NOMOVE|SWP_SHOWWINDOW);	

		m_list.SetWindowPos(NULL,0,rcTitle.Height()+1,rcControl.Width(),rcControl.Height()-rcTitle.Height()-rcTitle.Height()-3,SWP_NOZORDER|SWP_SHOWWINDOW);	

		m_statusbar.SetWindowPos(NULL,0,0,rcControl.Width(),rcStatus.Height(),SWP_NOZORDER|SWP_NOMOVE|SWP_SHOWWINDOW);	
	}
}

BSTR CHMListViewCtrl::GetTitle() 
{
	CString strResult = m_titlebar.GetTitleText();

	return strResult.AllocSysString();
}

void CHMListViewCtrl::SetTitle(LPCTSTR lpszNewValue) 
{
	m_titlebar.SetTitleText(lpszNewValue);
	SetModifiedFlag();
}

BSTR CHMListViewCtrl::GetDescription() 
{
	CString strResult = m_statusbar.GetDetailsText();

	return strResult.AllocSysString();
}

void CHMListViewCtrl::SetDescription(LPCTSTR lpszNewValue) 
{
	m_statusbar.SetDetailsText(lpszNewValue);
	SetModifiedFlag();
}

void CHMListViewCtrl::SetProgressRange(long lLowerBound, long lUpperBound) 
{
	CProgressCtrl& ctrl = m_statusbar.GetProgressCtrl();
	ctrl.SetRange32(lLowerBound,lUpperBound);
}

long CHMListViewCtrl::GetProgressPos() 
{
	CProgressCtrl& ctrl = m_statusbar.GetProgressCtrl();

	return ctrl.GetPos();
}

void CHMListViewCtrl::SetProgressPos(long lPos) 
{
	CProgressCtrl& ctrl = m_statusbar.GetProgressCtrl();
	ctrl.SetPos(lPos);
}

long CHMListViewCtrl::StepProgressBar() 
{
	CProgressCtrl& ctrl = m_statusbar.GetProgressCtrl();

	return ctrl.StepIt();
}

long CHMListViewCtrl::SetProgressStep(long lStep) 
{
	CProgressCtrl& ctrl = m_statusbar.GetProgressCtrl();

	return ctrl.SetStep(lStep);
}

long CHMListViewCtrl::InsertItem(long lMask, long lItem, LPCTSTR lpszItem, long lState, long lStateMask, long lImage, long lParam) 
{
	return m_list.InsertItem(lMask,lItem,lpszItem,lState,lStateMask,lImage,lParam);
}

long CHMListViewCtrl::InsertColumn(long lColumn, LPCTSTR lpszColumnHeading, long lFormat, long lWidth, long lSubItem) 
{
  HDITEM hdItem;
  ZeroMemory(&hdItem,sizeof(HDITEM));
  hdItem.mask = HDI_FILTER|HDI_LPARAM;
  hdItem.type = HDFT_ISSTRING;
  hdItem.lParam = HDFS_CONTAINS;

  m_bColumnInsertionComplete = false;

  long lResult = m_list.InsertColumn(lColumn,lpszColumnHeading,lFormat,lWidth,lSubItem);

  CHeaderCtrl* pHdrCtrl = m_list.GetHeaderCtrl();
  if( pHdrCtrl )
  {
    pHdrCtrl->SetItem(lResult,&hdItem);
    Header_ClearFilter(pHdrCtrl->GetSafeHwnd(),lResult);
  }

  m_bColumnInsertionComplete = true;

	return lResult;
}

long CHMListViewCtrl::SetItem(long lItem, long lSubItem, long lMask, LPCTSTR lpszItem, long lImage, long lState, long lStateMask, long lParam) 
{
	return m_list.SetItem(lItem,lSubItem,lMask,lpszItem,lImage,lState,lStateMask,lParam);
}

long CHMListViewCtrl::GetStringWidth(LPCTSTR lpsz) 
{
	return m_list.GetStringWidth(lpsz);
}

long CHMListViewCtrl::GetColumnWidth(long lCol) 
{
	return m_list.GetColumnWidth(lCol);
}

BOOL CHMListViewCtrl::SetColumnWidth(long lCol, long lcx) 
{
	return m_list.SetColumnWidth(lCol,lcx);
}

long CHMListViewCtrl::FindItemByLParam(long lParam) 
{
	LVFINDINFO lvfi;
	ZeroMemory(&lvfi,sizeof(lvfi));
	lvfi.flags = LVFI_PARAM;
	lvfi.lParam = lParam;
	
	return m_list.FindItem(&lvfi);
}

long CHMListViewCtrl::GetImageList(long lImageListType) 
{
	CImageList* pImageList = m_list.GetImageList(lImageListType);
	if( ! pImageList )
	{
		return -1L;
	}

#ifndef IA64
	return (long)pImageList->GetSafeHandle();
#endif // IA64
	return 0;
}

long CHMListViewCtrl::SetImageList(long lImageList, long lImageListType) 
{
	HIMAGELIST hImageList = (HIMAGELIST)lImageList;	
	CImageList* pOldImageList = m_list.SetImageList(CImageList::FromHandle(hImageList),lImageListType);

#ifndef IA64
	return (long)pOldImageList->GetSafeHandle();
#endif // IA64
	return 0;
}

BOOL CHMListViewCtrl::DeleteAllItems() 
{
	return m_list.DeleteAllItems();
}

BOOL CHMListViewCtrl::DeleteColumn(long lCol) 
{
	return m_list.DeleteColumn(lCol);
}

long CHMListViewCtrl::GetNextItem(long lItem, long lFlags) 
{
	return m_list.GetNextItem(lItem,lFlags);
}

long CHMListViewCtrl::GetItem(long lItemIndex) 
{
	LVITEM lvi;
	ZeroMemory(&lvi,sizeof(LVITEM));
	lvi.mask = LVIF_PARAM;
	lvi.iItem = lItemIndex;
	if( ! m_list.GetItem(&lvi) )
	{
		return -1L;
	}

	return (long)lvi.lParam;
}

BOOL CHMListViewCtrl::DeleteItem(long lIndex) 
{
	return m_list.DeleteItem(lIndex);
}

long CHMListViewCtrl::GetItemCount() 
{
	return m_list.GetItemCount();
}

BOOL CHMListViewCtrl::ModifyListStyle(long lRemove, long lAdd, long lFlags) 
{
	return m_list.ModifyStyle(lRemove,lAdd,lFlags);
}

long CHMListViewCtrl::GetColumnCount() 
{
	CHeaderCtrl* pHeaderCtrl = m_list.GetHeaderCtrl();
	if( !pHeaderCtrl )
	{
		return -1;
	}

	return pHeaderCtrl->GetItemCount();
}

long CHMListViewCtrl::GetColumnOrderIndex(long lColumn) 
{
	int nColumnCount = GetColumnCount();
	if( nColumnCount < 0L )
	{
		return -1;
	}

	if( lColumn >= nColumnCount )
	{
		return -1;
	}

	if( lColumn < 0 )
	{
		return -1;
	}
	
	int* OrderArray = new int[nColumnCount];

	if( ! m_list.GetColumnOrderArray(OrderArray,nColumnCount) )
	{
		delete[] OrderArray;
		return -1;
	}

	for( int i = 0; i < nColumnCount; i++ )
	{
		if( OrderArray[i] == lColumn )
		{
			delete[] OrderArray;
			return i;
		}
	}

	return -1;
}

long CHMListViewCtrl::SetColumnOrderIndex(long lColumn, long lOrder) 
{
	int nColumnCount = GetColumnCount();
	if( nColumnCount < 0L )
	{
		return -1;
	}

	if( lColumn >= nColumnCount )
	{
		return -1;
	}

	if( lColumn < 0 )
	{
		return -1;
	}
	
	int* OrderArray = new int[nColumnCount];

	if( ! m_list.GetColumnOrderArray(OrderArray,nColumnCount) )
	{
		delete[] OrderArray;
		return -1;
	}

	for( int i = 0; i < nColumnCount; i++ )
	{
		if( OrderArray[i] == lColumn )
		{			
			break;
		}
	}

	int Swap = OrderArray[lOrder];
	OrderArray[lOrder] = lColumn;
	OrderArray[i] = Swap;

	if( ! m_list.SetColumnOrderArray(nColumnCount,OrderArray) )
	{
		delete [] OrderArray;
		return -1;
	}

	delete [] OrderArray;

	return 1;
}


BSTR CHMListViewCtrl::GetColumnOrder() 
{
	CString strResult;

	int nColumnCount = GetColumnCount();
	if( nColumnCount < 0L )
	{
		return NULL;
	}
	
	int* OrderArray = new int[nColumnCount];

	if( ! m_list.GetColumnOrderArray(OrderArray,nColumnCount) )
	{
		delete[] OrderArray;
		return NULL;
	}

	for( int i = 0; i < nColumnCount; i++ )
	{
		CString sNumber;
		sNumber.Format(_T("%d "),OrderArray[i]);
		strResult += sNumber;
	}

	delete [] OrderArray;

	strResult.TrimRight(_T(" "));

	return strResult.AllocSysString();
}

void CHMListViewCtrl::SetColumnOrder(LPCTSTR lpszOrder) 
{
	int nColumnCount = GetColumnCount();
	if( nColumnCount < 0L )
	{
		return;
	}

	int* OrderArray = new int[nColumnCount];

	LPTSTR pszString = new TCHAR[_tcslen(lpszOrder)+1];
	_tcscpy(pszString,lpszOrder);

	LPTSTR pszToken = _tcstok(pszString,_T(" "));
	int i = 0;
	while( pszToken && i < nColumnCount )
	{
		OrderArray[i++] = _ttoi(pszToken);
		pszToken = _tcstok(NULL,_T(" "));
	}

	m_list.SetColumnOrderArray(nColumnCount,OrderArray);

	delete[] OrderArray;
	delete[] pszString;
}

void CHMListViewCtrl::SetColumnFilter(long lColumn, LPCTSTR lpszFilter, long lFilterType) 
{
	// TODO: Add your dispatch handler code here

}

void CHMListViewCtrl::GetColumnFilter(long lColumn, BSTR FAR* lplpszFilter, long FAR* lpFilterType) 
{
  HDITEM hdItem;
  HDTEXTFILTER hdTextFilter;
  CString sFilter;
  
  hdTextFilter.pszText = sFilter.GetBuffer(_MAX_PATH);
  hdTextFilter.cchTextMax = _MAX_PATH;
  
  ZeroMemory(&hdItem,sizeof(HDITEM));
  hdItem.mask = HDI_FILTER|HDI_LPARAM;
  hdItem.type = HDFT_ISSTRING;
  hdItem.pvFilter = &hdTextFilter;

  CHeaderCtrl* pHdrCtrl = m_list.GetHeaderCtrl();
  if( ! pHdrCtrl )
  {
    *lplpszFilter = NULL;
    *lpFilterType = -1L;
    return;
  }

  pHdrCtrl->GetItem(lColumn,&hdItem);
  sFilter.ReleaseBuffer();
  *lplpszFilter = sFilter.AllocSysString();
  *lpFilterType = (long)hdItem.lParam;
}

long CHMListViewCtrl::GetSelectedCount() 
{
	return m_list.GetSelectedCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\hmlistviewppg.h ===
#if !defined(AFX_HMLISTVIEWPPG_H__5116A816_DAFC_11D2_BDA4_0000F87A3912__INCLUDED_)
#define AFX_HMLISTVIEWPPG_H__5116A816_DAFC_11D2_BDA4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// HMListViewPpg.h : Declaration of the CHMListViewPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CHMListViewPropPage : See HMListViewPpg.cpp.cpp for implementation.

class CHMListViewPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CHMListViewPropPage)
	DECLARE_OLECREATE_EX(CHMListViewPropPage)

// Constructor
public:
	CHMListViewPropPage();

// Dialog Data
	//{{AFX_DATA(CHMListViewPropPage)
	enum { IDD = IDD_PROPPAGE_HMLISTVIEW };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CHMListViewPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMLISTVIEWPPG_H__5116A816_DAFC_11D2_BDA4_0000F87A3912__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\hmlistviewctl.h ===
#if !defined(AFX_HMLISTVIEWCTL_H__5116A814_DAFC_11D2_BDA4_0000F87A3912__INCLUDED_)
#define AFX_HMLISTVIEWCTL_H__5116A814_DAFC_11D2_BDA4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// HMListViewCtl.h : Declaration of the CHMListViewCtrl ActiveX Control class.

#include "HMList.h"
#include "TitlebarCtrl.h"
#include "StatusbarCtrl.h"

/////////////////////////////////////////////////////////////////////////////
// CHMListViewCtrl : See HMListViewCtl.cpp for implementation.

class CHMListViewCtrl : public COleControl
{
	DECLARE_DYNCREATE(CHMListViewCtrl)

// Constructor
public:
	CHMListViewCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHMListViewCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual DWORD GetControlFlags();
	//}}AFX_VIRTUAL
  
  bool m_bColumnInsertionComplete;

// Implementation
protected:
	~CHMListViewCtrl();

	CTitlebarCtrl m_titlebar;
	CStatusbarCtrl m_statusbar;
	CHMList m_list;

	BEGIN_OLEFACTORY(CHMListViewCtrl)        // Class factory and guid
		virtual BOOL VerifyUserLicense();
		virtual BOOL GetLicenseKey(DWORD, BSTR FAR*);
	END_OLEFACTORY(CHMListViewCtrl)

	DECLARE_OLETYPELIB(CHMListViewCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CHMListViewCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CHMListViewCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CHMListViewCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CHMListViewCtrl)
	afx_msg BSTR GetTitle();
	afx_msg void SetTitle(LPCTSTR lpszNewValue);
	afx_msg BSTR GetDescription();
	afx_msg void SetDescription(LPCTSTR lpszNewValue);
	afx_msg void SetProgressRange(long lLowerBound, long lUpperBound);
	afx_msg long GetProgressPos();
	afx_msg void SetProgressPos(long lPos);
	afx_msg long InsertItem(long lMask, long lItem, LPCTSTR lpszItem, long lState, long lStateMask, long lImage, long lParam);
	afx_msg long InsertColumn(long lColumn, LPCTSTR lpszColumnHeading, long lFormat, long lWidth, long lSubItem);
	afx_msg long SetItem(long lItem, long lSubItem, long lMask, LPCTSTR lpszItem, long lImage, long lState, long lStateMask, long lParam);
	afx_msg long GetStringWidth(LPCTSTR lpsz);
	afx_msg long GetColumnWidth(long lCol);
	afx_msg BOOL SetColumnWidth(long lCol, long lcx);
	afx_msg long FindItemByLParam(long lParam);
	afx_msg long GetImageList(long lImageListType);
	afx_msg BOOL DeleteAllItems();
	afx_msg BOOL DeleteColumn(long lCol);
	afx_msg long StepProgressBar();
	afx_msg long SetProgressStep(long lStep);
	afx_msg long SetImageList(long hImageList, long lImageListType);
	afx_msg long GetNextItem(long lItem, long lFlags);
	afx_msg long GetItem(long lItemIndex);
	afx_msg BOOL DeleteItem(long lIndex);
	afx_msg long GetItemCount();
	afx_msg BOOL ModifyListStyle(long lRemove, long lAdd, long lFlags);
	afx_msg long GetColumnCount();
	afx_msg long GetColumnOrderIndex(long lColumn);
	afx_msg long SetColumnOrderIndex(long lColumn, long lOrder);
	afx_msg BSTR GetColumnOrder();
	afx_msg void SetColumnOrder(LPCTSTR lpszOrder);
	afx_msg void SetColumnFilter(long lColumn, LPCTSTR lpszFilter, long lFilterType);
	afx_msg void GetColumnFilter(long lColumn, BSTR FAR* lplpszFilter, long FAR* lpFilterType);
	afx_msg long GetSelectedCount();
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
public:
	//{{AFX_EVENT(CHMListViewCtrl)
	void FireListClick(long lParam)
		{FireEvent(eventidListClick,EVENT_PARAM(VTS_I4), lParam);}
	void FireListDblClick(long lParam)
		{FireEvent(eventidListDblClick,EVENT_PARAM(VTS_I4), lParam);}
	void FireListRClick(long lParam)
		{FireEvent(eventidListRClick,EVENT_PARAM(VTS_I4), lParam);}
	void FireCompareItem(long lItem1, long lItem2, long lColumn, long FAR* lpResult)
		{FireEvent(eventidCompareItem,EVENT_PARAM(VTS_I4  VTS_I4  VTS_I4  VTS_PI4), lItem1, lItem2, lColumn, lpResult);}
	void FireListLabelEdit(LPCTSTR lpszNewName, LONG_PTR lParam, LRESULT* plResult)
		{FireEvent(eventidListLabelEdit,EVENT_PARAM(VTS_BSTR  VTS_I4  VTS_PI4), lpszNewName, lParam, plResult);}
	void FireListKeyDown(long lVKCode, long lFlags, LRESULT* plResult)
		{FireEvent(eventidListKeyDown,EVENT_PARAM(VTS_I4  VTS_I4  VTS_PI4), lVKCode, lFlags, plResult);}
	void FireFilterChange(long lItem, LPCTSTR pszFilter, long lFilterType, LRESULT* lpResult)
		{FireEvent(eventidFilterChange,EVENT_PARAM(VTS_I4  VTS_BSTR  VTS_I4  VTS_PI4), lItem, pszFilter, lFilterType, lpResult);}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CHMListViewCtrl)
	dispidTitle = 1L,
	dispidDescription = 2L,
	dispidSetProgressRange = 3L,
	dispidGetProgressPos = 4L,
	dispidSetProgressPos = 5L,
	dispidInsertItem = 6L,
	dispidInsertColumn = 7L,
	dispidSetItem = 8L,
	dispidGetStringWidth = 9L,
	dispidGetColumnWidth = 10L,
	dispidSetColumnWidth = 11L,
	dispidFindItemByLParam = 12L,
	dispidGetImageList = 13L,
	dispidDeleteAllItems = 14L,
	dispidDeleteColumn = 15L,
	dispidStepProgressBar = 16L,
	dispidSetProgressStep = 17L,
	dispidSetImageList = 18L,
	dispidGetNextItem = 19L,
	dispidGetItem = 20L,
	dispidDeleteItem = 21L,
	dispidGetItemCount = 22L,
	dispidModifyListStyle = 23L,
	dispidGetColumnCount = 24L,
	dispidGetColumnOrderIndex = 25L,
	dispidSetColumnOrderIndex = 26L,
	dispidGetColumnOrder = 27L,
	dispidSetColumnOrder = 28L,
	dispidSetColumnFilter = 29L,
	dispidGetColumnFilter = 30L,
	dispidGetSelectedCount = 31L,
	eventidListClick = 1L,
	eventidListDblClick = 2L,
	eventidListRClick = 3L,
	eventidCompareItem = 4L,
	eventidListLabelEdit = 5L,
	eventidListKeyDown = 6L,
	eventidFilterChange = 7L,
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMLISTVIEWCTL_H__5116A814_DAFC_11D2_BDA4_0000F87A3912__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\hmlistviewppg.cpp ===
// HMListViewPpg.cpp : Implementation of the CHMListViewPropPage property page class.

#include "stdafx.h"
#include "HMListView.h"
#include "HMListViewPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CHMListViewPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CHMListViewPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CHMListViewPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CHMListViewPropPage, "HMLISTVIEW.HMListViewPropPage.1",
	0x5116a807, 0xdafc, 0x11d2, 0xbd, 0xa4, 0, 0, 0xf8, 0x7a, 0x39, 0x12)


/////////////////////////////////////////////////////////////////////////////
// CHMListViewPropPage::CHMListViewPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CHMListViewPropPage

BOOL CHMListViewPropPage::CHMListViewPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_HMLISTVIEW_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CHMListViewPropPage::CHMListViewPropPage - Constructor

CHMListViewPropPage::CHMListViewPropPage() :
	COlePropertyPage(IDD, IDS_HMLISTVIEW_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CHMListViewPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT

	SetHelpInfo(_T("Names to appear in the control"), _T("HMLISTVIEW.HLP"), 0);
}


/////////////////////////////////////////////////////////////////////////////
// CHMListViewPropPage::DoDataExchange - Moves data between page and properties

void CHMListViewPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CHMListViewPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CHMListViewPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by HMListView.rc
//
#define IDS_HMLISTVIEW                  1
#define IDD_ABOUTBOX_HMLISTVIEW         1
#define IDB_HMLISTVIEW                  1
#define IDI_ABOUTDLL                    1
#define IDS_HMLISTVIEW_PPG              2
#define IDS_STRING_TITLE                3
#define IDS_STRING_DETAILS              4
#define IDS_HMLISTVIEW_PPG_CAPTION      200
#define IDD_PROPPAGE_HMLISTVIEW         200
#define IDR_MENU_HEADER_CONTEXT         205
#define ID_HEADERCONTEXT_FILTERBAR      32768
#define ID_FILTERMENU_CONTAINS          32769
#define ID_FILTERMENU_DOESNOTCONTAIN    32770
#define ID_FILTERMENU_STARTSWITH        32771
#define ID_FILTERMENU_ENDSWITH          32772
#define ID_FILTERMENU_ISEXACTLY         32773
#define ID_FILTERMENU_ISNOT             32774
#define ID_FILTERMENU_CLEARFILTER       32775
#define ID_FILTERMENU_CLEARALLFILTERS   32776

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        206
#define _APS_NEXT_COMMAND_VALUE         32777
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\hmlistview_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu Apr 13 09:30:57 2000
 */
/* Compiler settings for C:\SMSDev\HealthMon\HMListView\HMListView.odl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_HMLISTVIEWLib = {0x5116A803,0xDAFC,0x11D2,{0xBD,0xA4,0x00,0x00,0xF8,0x7A,0x39,0x12}};


const IID DIID__DHMListView = {0x5116A804,0xDAFC,0x11D2,{0xBD,0xA4,0x00,0x00,0xF8,0x7A,0x39,0x12}};


const IID DIID__DHMListViewEvents = {0x5116A805,0xDAFC,0x11D2,{0xBD,0xA4,0x00,0x00,0xF8,0x7A,0x39,0x12}};


const CLSID CLSID_HMListView = {0x5116A806,0xDAFC,0x11D2,{0xBD,0xA4,0x00,0x00,0xF8,0x7A,0x39,0x12}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\sortclass.h ===
// SortClass.h: interface for the CSortClass class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SORTCLASS_H__BC5ACAB5_1F95_11D3_BDFC_0000F87A3912__INCLUDED_)
#define AFX_SORTCLASS_H__BC5ACAB5_1F95_11D3_BDFC_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMList.h"  // IA64

class CSortClass
{
public:
	//CSortClass(CListCtrl * _pWnd, const int _iCol);  // IA64
	CSortClass(CHMList * _pWnd, const int _iCol);      // IA64
	virtual ~CSortClass();		
	
	int m_iCol;	
	int m_iStartingItem;
	int m_iEndingItem;

	//CListCtrl * m_pWnd;	 // IA64
    CHMList* m_pWnd;         // IA64
	
	void Sort(const bool bAsc);	
	
	static int CALLBACK CompareAsc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
	static int CALLBACK CompareDes(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

    // IA64: Store pointer to ourself for sorting
private:
    static CPtrArray m_arrpSortClasses; // IA64
    static int m_nSortClassInstances;    // IA64
    int    m_nThisSortInstance;

public:	

	class CSortItem	
	{	
		public:		
			virtual  ~CSortItem();
			CSortItem(const DWORD_PTR _dw, const CString &_txt);	// IA64	
			CString txt;		
			DWORD_PTR dw;  // IA64
	};
};
#endif // !defined(AFX_SORTCLASS_H__BC5ACAB5_1F95_11D3_BDFC_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\sortclass.cpp ===
// SortClass.cpp: implementation of the CSortClass class.
//
//////////////////////////////////////////////////////////////////////

// IA64
// Basically we need to convert all SetItemData and GetItemData to SetItemDataPtr 
// and GetItemDataPtr since we can not store a pointer as a long or DWORD since it
// loses its high order bits.


#include "stdafx.h"
#include "hmlistview.h"
#include "SortClass.h"
#include "HMListViewCtl.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
int CSortClass::m_nSortClassInstances=0;     // IA64
CPtrArray CSortClass::m_arrpSortClasses;    // IA64

// CSortClass::CSortClass(CListCtrl * _pWnd, const int _iCol)  // IA64
CSortClass::CSortClass(CHMList * _pWnd, const int _iCol)
{	
    ASSERT(_pWnd->IsKindOf(RUNTIME_CLASS(CHMList))); // IA64

    m_nThisSortInstance = m_nSortClassInstances++;
    m_arrpSortClasses.SetAtGrow(m_nThisSortInstance,this); // IA64

	m_iCol = _iCol;	
	m_pWnd = _pWnd;	
	ASSERT(m_pWnd);
	INT_PTR max = m_pWnd->GetItemCount();	
	DWORD_PTR dw;	 // IA64
	CString txt;	
	for (int t = 0; t < max; t++)
	{
// We will need to store the item ptr in a custom mapped array. Must be sure to
// delete these items in the list control's OnDeleteItem handler.
// IA64
		dw = m_pWnd->GetItemData(t); 
		txt = m_pWnd->GetItemText(t, m_iCol);
		
        // m_pWnd->SetItemData(t, (DWORD) new CSortItem(dw,txt));  // IA64
        m_pWnd->SetItemDataPtr(t,(void*) new CSortItem(dw,txt));   // IA64
// IA64
	}
}

CSortClass::~CSortClass()
{	
	ASSERT(m_pWnd);
	int max = m_pWnd->GetItemCount();
	CSortItem * pItem;
	for (int t = 0; t < max; t++)
	{
		//pItem = (CSortItem *) m_pWnd->GetItemData(t); // IA64
		pItem = (CSortItem *) m_pWnd->GetItemDataPtr(t); // IA64
		ASSERT(pItem);
		m_pWnd->SetItemData(t, pItem->dw);
		delete pItem;
	}
}

void CSortClass::Sort(const bool bAsc)
{	
// IA64 : Since we can not pass a ptr to the SortFunc, we need to pass it our
//        place holder reference in the static list of CSortClass ptrs.
// IA64
	if (bAsc)	
	{
		//m_pWnd->SortItems(CompareAsc, (DWORD)this);	
		m_pWnd->SortItems(CompareAsc, (DWORD)m_nThisSortInstance);	 // IA64
	}
	else
	{
		//m_pWnd->SortItems(CompareDes, (DWORD)this); 
		m_pWnd->SortItems(CompareDes, (DWORD)m_nThisSortInstance); // IA64
	}
// IA64
}


// IA64 : This also needs to be converted since lParam1 and lParam2 will
//                not contain pointers, they will contain the mapping to the pointers.
int CALLBACK CSortClass::CompareAsc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{	
	CSortItem * i1 = (CSortItem *) lParam1;
	CSortItem * i2 = (CSortItem *) lParam2;	
	ASSERT(i1 && i2);

	//CSortClass* pSC = (CSortClass*)lParamSort;       // IA64
    ASSERT(lParamSort <= m_arrpSortClasses.GetSize()); // IA64
	CSortClass* pSC = (CSortClass*)m_arrpSortClasses[lParamSort]; // IA64

	ASSERT(pSC);

	CHMListViewCtrl* pCtl = (CHMListViewCtrl*)pSC->m_pWnd->GetParent();

	if( ! pCtl->IsKindOf(RUNTIME_CLASS(CHMListViewCtrl)) )
	{
		ASSERT(FALSE);
		return -1;
	}

	long lResult = -2L;
	pCtl->FireCompareItem((long)i1->dw,(long)i2->dw,pSC->m_iCol,&lResult);

	return lResult == -2L ? i1->txt.CompareNoCase(i2->txt) : lResult;
}

int CALLBACK CSortClass::CompareDes(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{	
	CSortItem * i1 = (CSortItem *) lParam1;
	CSortItem * i2 = (CSortItem *) lParam2;	
	ASSERT(i1 && i2);

	//CSortClass* pSC = (CSortClass*)lParamSort;       // IA64
    ASSERT(lParamSort <= m_arrpSortClasses.GetSize()); // IA64
	CSortClass* pSC = (CSortClass*)m_arrpSortClasses[lParamSort]; // IA64
	ASSERT(pSC);

	CHMListViewCtrl* pCtl = (CHMListViewCtrl*)pSC->m_pWnd->GetParent();

	if( ! pCtl->IsKindOf(RUNTIME_CLASS(CHMListViewCtrl)) )
	{
		ASSERT(FALSE);
		return -1;
	}

	long lResult = -2L;
	pCtl->FireCompareItem((long)i2->dw,(long)i1->dw,pSC->m_iCol,&lResult);

	return lResult == -2L ? i2->txt.CompareNoCase(i1->txt) : lResult;
}

CSortClass::CSortItem::CSortItem(const DWORD_PTR _dw, const CString &_txt) // IA64
{
	dw = _dw;
	txt = _txt;
}

CSortClass::CSortItem::~CSortItem()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\statusbarctrl.h ===
#if !defined(AFX_STATUSBARCTRL_H__9D8E6323_190D_11D3_BDF0_0000F87A3912__INCLUDED_)
#define AFX_STATUSBARCTRL_H__9D8E6323_190D_11D3_BDF0_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// StatusbarCtrl.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CStatusbarCtrl window

class CStatusbarCtrl : public CReBarCtrl
{
// Construction
public:
	CStatusbarCtrl();

// Progress Band
public:
	CProgressCtrl& GetProgressCtrl() { ASSERT(m_progressctrl.GetSafeHwnd()); return m_progressctrl; }
protected:
	int CreateProgressBand();
	CProgressCtrl m_progressctrl;

// Details Band
public:
	CString GetDetailsText();
	void SetDetailsText(const CString& sText);
protected:
	int CreateDetailsBand();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStatusbarCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CStatusbarCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CStatusbarCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STATUSBARCTRL_H__9D8E6323_190D_11D3_BDF0_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\statusbarctrl.cpp ===
// StatusbarCtrl.cpp : implementation file
//

#include "stdafx.h"
#include "hmlistview.h"
#include "StatusbarCtrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CStatusbarCtrl

CStatusbarCtrl::CStatusbarCtrl()
{
}

CStatusbarCtrl::~CStatusbarCtrl()
{
}

inline int CStatusbarCtrl::CreateProgressBand()
{
	REBARBANDINFO rbbi;
	ZeroMemory(&rbbi,sizeof(rbbi));
	rbbi.cbSize = sizeof(REBARBANDINFO);
	rbbi.fMask = RBBIM_STYLE | RBBIM_COLORS | RBBIM_CHILD | RBBIM_SIZE;
	rbbi.fStyle = RBBS_CHILDEDGE | RBBS_NOGRIPPER;
	rbbi.clrFore = GetSysColor(COLOR_BTNTEXT);
	rbbi.clrBack = GetSysColor(COLOR_BTNFACE);
	rbbi.hwndChild = m_progressctrl.GetSafeHwnd();
	rbbi.cx = 100;

	return InsertBand(-1,&rbbi);
}

inline int CStatusbarCtrl::CreateDetailsBand()
{
	CString sText;
	sText.LoadString(IDS_STRING_DETAILS);
	CClientDC dc(this);
	CSize size = dc.GetTextExtent(sText);

	REBARBANDINFO rbbi;
	ZeroMemory(&rbbi,sizeof(rbbi));
	rbbi.cbSize = sizeof(REBARBANDINFO);
	rbbi.fMask = RBBIM_TEXT | RBBIM_STYLE | RBBIM_COLORS| RBBIM_SIZE;
	rbbi.lpText = (LPTSTR)(LPCTSTR)sText;
	rbbi.fStyle = RBBS_CHILDEDGE | RBBS_NOGRIPPER;
	rbbi.clrFore = GetSysColor(COLOR_HIGHLIGHTTEXT);
	rbbi.clrBack = GetSysColor(COLOR_INACTIVECAPTION);
	rbbi.cx = size.cx + 15;

	return InsertBand(-1,&rbbi);
}

CString CStatusbarCtrl::GetDetailsText()
{
	CString sText;
	REBARBANDINFO rbbi;
	ZeroMemory(&rbbi,sizeof(rbbi));
	rbbi.cbSize = sizeof(REBARBANDINFO);
	rbbi.fMask = RBBIM_TEXT;
	rbbi.lpText = sText.GetBuffer(255);
	rbbi.cch = 255;

	GetBandInfo(0,&rbbi);

	sText.ReleaseBuffer();

	return sText;
}

void CStatusbarCtrl::SetDetailsText(const CString& sText)
{
	CClientDC dc(this);
	CSize size = dc.GetTextExtent(sText);

	REBARBANDINFO rbbi;
	ZeroMemory(&rbbi,sizeof(rbbi));
	rbbi.cbSize = sizeof(REBARBANDINFO);
	rbbi.fMask = RBBIM_TEXT | RBBIM_SIZE;
	rbbi.lpText = (LPTSTR)(LPCTSTR)sText;
	rbbi.cx = size.cx +15;

	SetBandInfo(0,&rbbi);
}



BEGIN_MESSAGE_MAP(CStatusbarCtrl, CReBarCtrl)
	//{{AFX_MSG_MAP(CStatusbarCtrl)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CStatusbarCtrl message handlers

int CStatusbarCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CReBarCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	REBARINFO rbi;
	ZeroMemory(&rbi,sizeof(REBARINFO));
	rbi.cbSize = sizeof(REBARINFO);
	SetBarInfo(&rbi);

//	if( m_progressctrl.Create(WS_CHILD|WS_VISIBLE|PBS_SMOOTH,CRect(0,0,10,10),this,2500) == -1 )
//		return -1;

	CreateDetailsBand();
	
//	CreateProgressBand();

	ShowWindow(SW_SHOW);
	UpdateWindow();
		
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\stdafx.h ===
#if !defined(AFX_STDAFX_H__5116A80A_DAFC_11D2_BDA4_0000F87A3912__INCLUDED_)
#define AFX_STDAFX_H__5116A80A_DAFC_11D2_BDA4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Comon Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5116A80A_DAFC_11D2_BDA4_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\titlebarctrl.h ===
// TitlebarCtrl.h: interface for the CTitlebarCtrl class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_TITLEBARCTRL_H__51CEF5B8_DB32_11D2_BDA4_0000F87A3912__INCLUDED_)
#define AFX_TITLEBARCTRL_H__51CEF5B8_DB32_11D2_BDA4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "afxcmn.h"

#define IDC_VIEW_TOOLBAR 100
#define ID_TBB_VIEW			 500

class CTitlebarCtrl : public CReBarCtrl  
{

DECLARE_DYNCREATE(CTitlebarCtrl)

// Construction
public:
	CTitlebarCtrl();
	virtual ~CTitlebarCtrl();

// Title Band
public:
	CString GetTitleText();
	void SetTitleText(const CString& sTitle);
protected:
	int CreateTitleBand();

// Overrides
public:
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTitlebarCtrl)
	//}}AFX_VIRTUAL

// MFC Implementation
protected:

// Message maps
	//{{AFX_MSG(CTitlebarCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()


};

#endif // !defined(AFX_TITLEBARCTRL_H__51CEF5B8_DB32_11D2_BDA4_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmonres\hmonres.cpp ===
// stdrulesres.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include "stdrulesres.h"

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmlistview\titlebarctrl.cpp ===
// TitlebarCtrl.cpp: implementation of the CTitlebarCtrl class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "hmlistview.h"
#include "TitlebarCtrl.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CTitlebarCtrl, CReBarCtrl)

/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CTitlebarCtrl, CReBarCtrl)
	//{{AFX_MSG_MAP(CTitlebarCtrl)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTitlebarCtrl::CTitlebarCtrl()
{

}

CTitlebarCtrl::~CTitlebarCtrl()
{

}

int CTitlebarCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CReBarCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;

	REBARINFO rbi;
	ZeroMemory(&rbi,sizeof(REBARINFO));
	rbi.cbSize = sizeof(REBARINFO);
	SetBarInfo(&rbi);

	CreateTitleBand();

	ShowWindow(SW_SHOW);
	UpdateWindow();

	return 0;
}

// Title Band

CString CTitlebarCtrl::GetTitleText()
{
	CString sText;
	REBARBANDINFO rbbi;
	ZeroMemory(&rbbi,sizeof(rbbi));
	rbbi.cbSize = sizeof(REBARBANDINFO);
	rbbi.fMask = RBBIM_TEXT;
	rbbi.lpText = sText.GetBuffer(255);
	rbbi.cch = 255;

	GetBandInfo(0,&rbbi);

	sText.ReleaseBuffer();

	return sText;
}

void CTitlebarCtrl::SetTitleText(const CString& sTitle)
{
	CClientDC dc(this);
	CSize size = dc.GetTextExtent(sTitle);

	REBARBANDINFO rbbi;
	ZeroMemory(&rbbi,sizeof(rbbi));
	rbbi.cbSize = sizeof(REBARBANDINFO);
	rbbi.fMask = RBBIM_TEXT | RBBIM_SIZE;
	rbbi.lpText = (LPTSTR)(LPCTSTR)sTitle;
	rbbi.cx = size.cx + 100;

	SetBandInfo(0,&rbbi);

}

inline int CTitlebarCtrl::CreateTitleBand()
{
	CString sText;
	sText.LoadString(IDS_STRING_TITLE);
	CClientDC dc(this);
	CSize size = dc.GetTextExtent(sText);

	REBARBANDINFO rbbi;
	ZeroMemory(&rbbi,sizeof(rbbi));
	rbbi.cbSize = sizeof(REBARBANDINFO);
	rbbi.fMask = RBBIM_TEXT | RBBIM_STYLE | RBBIM_COLORS | RBBIM_SIZE;
	rbbi.lpText = (LPTSTR)(LPCTSTR)sText;
	rbbi.fStyle = RBBS_NOGRIPPER;
	rbbi.clrFore = GetSysColor(COLOR_HIGHLIGHTTEXT);
	rbbi.clrBack = GetSysColor(COLOR_INACTIVECAPTION);
	rbbi.cx = size.cx + 100;

	return InsertBand(-1,&rbbi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmonres\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	stdrulesres.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmonres\stdrulesres.h ===
// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the STDRULESRES_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// STDRULESRES_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#ifdef STDRULESRES_EXPORTS
#define STDRULESRES_API __declspec(dllexport)
#else
#define STDRULESRES_API __declspec(dllimport)
#endif

// This class is exported from the stdrulesres.dll
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmonres\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Script1.rc
//
#define IDS_STRING1                     1
#define HMRES_BADWMI                    1
#define IDS_STRING2                     2
#define HMRES_OBJECTNOTFOUND            2
#define IDS_STRING3                     3
#define HMRES_NOINST                    3
#define IDS_STRING4                     4
#define HMRES_ENUMFAIL                  4
#define IDS_STRING5                     5
#define HMRES_TIMEOUT                   5
#define IDS_STRING6                     6
#define HMRES_UNKNOWN                   6
#define IDS_STRING7                     7
#define HMRES_NODATA                    7
#define IDS_STRING8                     8
#define HMRES_SCHEDULEDOUT              8
#define IDS_STRING9                     9
#define HMRES_DISABLED                  9
#define IDS_STRING10                    10
#define HMRES_NULLVALUE                 10
#define IDS_STRING11                    11
#define HMRES_DCUNKNOWN                 11
#define IDS_STRING12                    12
#define HMRES_TOOMANYINSTS              12
#define IDS_STRING13                    13
#define HMRES_BADTHRESHPROP             13
#define IDS_STRING14                    14
#define IDS_STRING15                    15
#define IDS_STRING16                    16
#define IDS_STRING17                    17
#define IDS_STRING18                    18
#define IDS_STRING19                    19
#define IDS_STRING20                    20
#define IDS_STRING21                    21
#define IDS_STRING22                    22
#define IDS_STRING23                    23
#define IDS_STRING24                    24
#define IDS_STRING25                    25
#define IDS_STRING26                    26
#define IDS_STRING27                    27
#define IDS_STRING28                    28
#define IDS_STRING29                    29
#define IDS_STRING30                    30
#define IDS_STRING31                    31
#define IDS_STRING32                    32
#define IDS_STRING33                    33
#define IDS_STRING34                    34
#define IDS_STRING35                    35
#define IDS_STRING36                    36
#define IDS_STRING37                    37
#define IDS_STRING38                    38
#define IDS_STRING39                    39
#define IDS_STRING40                    40
#define IDS_STRING41                    41
#define IDS_STRING42                    42
#define IDS_STRING43                    43
#define IDS_STRING44                    44
#define IDS_STRING45                    45
#define IDS_STRING46                    46
#define IDS_STRING47                    47
#define IDS_STRING48                    48
#define IDS_STRING49                    49
#define IDS_STRING50                    50
#define IDS_STRING51                    51
#define IDS_STRING52                    52
#define IDS_STRING53                    53
#define IDS_STRING54                    54
#define IDS_STRING55                    55
#define IDS_STRING56                    56
#define IDS_STRING57                    57
#define IDS_STRING58                    58
#define IDS_STRING59                    59
#define IDS_STRING60                    60
#define IDS_STRING61                    61
#define IDS_STRING62                    62
#define IDS_STRING63                    63
#define IDS_STRING64                    64
#define IDS_STRING65                    65
#define IDS_STRING66                    66
#define IDS_STRING67                    67
#define IDS_STRING68                    68
#define IDS_STRING69                    69
#define IDS_STRING70                    70
#define IDS_STRING71                    71
#define IDS_STRING72                    72
#define IDS_STRING73                    73
#define IDS_STRING74                    74
#define IDS_STRING75                    75
#define IDS_STRING76                    76
#define IDS_STRING77                    77
#define IDS_STRING78                    78
#define IDS_STRING79                    79
#define IDS_STRING80                    80
#define IDS_STRING81                    81
#define IDS_STRING82                    82
#define IDS_STRING83                    83
#define IDS_STRING84                    84
#define IDS_STRING85                    85
#define IDS_STRING86                    86
#define IDS_STRING87                    87
#define IDS_STRING88                    88
#define IDS_STRING89                    89
#define IDS_STRING90                    90
#define IDS_STRING91                    91
#define IDS_STRING92                    92
#define IDS_STRING93                    93
#define IDS_STRING94                    94
#define IDS_STRING95                    95
#define IDS_STRING96                    96
#define IDS_STRING97                    97
#define IDS_STRING98                    98
#define IDS_STRING99                    99
#define IDS_STRING100                   100
#define IDS_STRING101                   101
#define IDS_STRING102                   102
#define IDS_STRING103                   103
#define IDS_STRING104                   104
#define IDS_STRING105                   105
#define IDS_STRING106                   106
#define IDS_STRING107                   107
#define IDS_STRING108                   108
#define IDS_STRING109                   109
#define IDS_STRING110                   110
#define IDS_STRING111                   111
#define IDS_STRING112                   112
#define IDS_STRING113                   113
#define IDS_STRING114                   114
#define IDS_STRING115                   115
#define IDS_STRING116                   116
#define IDS_STRING117                   117
#define IDS_STRING118                   118
#define IDS_STRING119                   119
#define IDS_STRING120                   120
#define IDS_STRING121                   121
#define IDS_STRING122                   122
#define IDS_STRING123                   123
#define IDS_STRING124                   124
#define IDS_STRING125                   125
#define IDS_STRING126                   126
#define IDS_STRING127                   127
#define IDS_STRING128                   128
#define IDS_STRING129                   129
#define IDS_STRING130                   130
#define IDS_STRING131                   131
#define IDS_STRING132                   132
#define IDS_STRING133                   133
#define IDS_STRING134                   134
#define IDS_STRING135                   135
#define IDS_STRING136                   136
#define IDS_STRING137                   137
#define IDS_STRING138                   138
#define IDS_STRING139                   139
#define IDS_STRING140                   140
#define IDS_STRING141                   141
#define IDS_STRING142                   142
#define IDS_STRING143                   143
#define IDS_STRING144                   144
#define IDS_STRING145                   145
#define IDS_STRING146                   146
#define IDS_STRING147                   147
#define IDS_STRING148                   148
#define IDS_STRING149                   149
#define IDS_STRING150                   150
#define IDS_STRING151                   151
#define IDS_STRING152                   152
#define IDS_STRING153                   153
#define IDS_STRING154                   154
#define IDS_STRING155                   155
#define IDS_STRING156                   156
#define IDS_STRING157                   157
#define IDS_STRING158                   158
#define IDS_STRING159                   159
#define IDS_STRING160                   160
#define IDS_STRING161                   161
#define IDS_STRING162                   162
#define IDS_STRING163                   163
#define IDS_STRING164                   164
#define IDS_STRING165                   165
#define IDS_STRING166                   166
#define IDS_STRING167                   167
#define IDS_STRING168                   168
#define IDS_STRING169                   169
#define IDS_STRING170                   170
#define IDS_STRING171                   171
#define IDS_STRING172                   172
#define IDS_STRING173                   173
#define IDS_STRING174                   174
#define IDS_STRING175                   175
#define IDS_STRING176                   176
#define IDS_STRING177                   177
#define IDS_STRING178                   178
#define IDS_STRING179                   179
#define IDS_STRING180                   180
#define IDS_STRING181                   181
#define IDS_STRING182                   182
#define IDS_STRING183                   183
#define IDS_STRING184                   184
#define IDS_STRING185                   185
#define IDS_STRING186                   186
#define IDS_STRING187                   187
#define IDS_STRING188                   188
#define IDS_STRING189                   189
#define IDS_STRING1000                  1000
#define IDS_STRING1001                  1001
#define IDS_STRING1002                  1002
#define IDS_STRING1003                  1003
#define IDS_STRING1004                  1004
#define IDS_STRING1005                  1005
#define IDS_STRING1006                  1006
#define IDS_STRING1007                  1007
#define IDS_STRING1008                  1008
#define IDS_STRING1009                  1009
#define IDS_STRING1010                  1010
#define IDS_STRING1011                  1011
#define IDS_STRING1012                  1012
#define IDS_STRING1013                  1013
#define IDS_STRING1014                  1014
#define IDS_STRING1015                  1015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmonres\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__70204F43_6FB5_11D3_90EE_006097919914__INCLUDED_)
#define AFX_STDAFX_H__70204F43_6FB5_11D3_90EE_006097919914__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__70204F43_6FB5_11D3_90EE_006097919914__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmsnapinres\hmsnapinres.cpp ===
// HMSnapinRes.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include <afxdllx.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static AFX_EXTENSION_MODULE HMSnapinResDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	// Remove this if you use lpReserved
	UNREFERENCED_PARAMETER(lpReserved);

	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("HMSNAPINRES.DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		if (!AfxInitExtensionModule(HMSnapinResDLL, hInstance))
			return 0;

		// Insert this DLL into the resource chain
		// NOTE: If this Extension DLL is being implicitly linked to by
		//  an MFC Regular DLL (such as an ActiveX Control)
		//  instead of an MFC application, then you will want to
		//  remove this line from DllMain and put it in a separate
		//  function exported from this Extension DLL.  The Regular DLL
		//  that uses this Extension DLL should then explicitly call that
		//  function to initialize this Extension DLL.  Otherwise,
		//  the CDynLinkLibrary object will not be attached to the
		//  Regular DLL's resource chain, and serious problems will
		//  result.

		new CDynLinkLibrary(HMSnapinResDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("HMSNAPINRES.DLL Terminating!\n");
		// Terminate the library before destructors are called
		AfxTermExtensionModule(HMSnapinResDLL);
	}
	return 1;   // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmsnapinres\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	HMSnapinRes.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmsnapinres\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7C54D571_C692_11D2_BD86_0000F87A3912__INCLUDED_)
#define AFX_STDAFX_H__7C54D571_C692_11D2_BD86_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC Automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7C54D571_C692_11D2_BD86_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmtabview\hmtabctrl.cpp ===
// HMTabCtrl.cpp : implementation file
//

#include "stdafx.h"
#include "HMTabView.h"
#include "HMTabCtrl.h"
#include "HMTabViewCtl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHMTabCtrl

CHMTabCtrl::CHMTabCtrl()
{
}

CHMTabCtrl::~CHMTabCtrl()
{
}


BEGIN_MESSAGE_MAP(CHMTabCtrl, CTabCtrl)
	//{{AFX_MSG_MAP(CHMTabCtrl)
	ON_NOTIFY_REFLECT(TCN_SELCHANGE, OnSelchange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHMTabCtrl message handlers

void CHMTabCtrl::OnSelchange(NMHDR* pNMHDR, LRESULT* pResult) 
{
	int iItem = GetCurSel();
	CHMTabViewCtrl* pCtrl = (CHMTabViewCtrl*)GetParent();
	if( pCtrl == NULL )
	{
		return;
	}

	pCtrl->OnSelChangeTabs(iItem);

	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmtabview\hmtabctrl.h ===
#if !defined(AFX_HMTABCTRL_H__4FFFC3A2_2F1E_11D3_BE10_0000F87A3912__INCLUDED_)
#define AFX_HMTABCTRL_H__4FFFC3A2_2F1E_11D3_BE10_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HMTabCtrl.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CHMTabCtrl window

class CHMTabCtrl : public CTabCtrl
{
// Construction
public:
	CHMTabCtrl();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHMTabCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHMTabCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CHMTabCtrl)
	afx_msg void OnSelchange(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMTABCTRL_H__4FFFC3A2_2F1E_11D3_BE10_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmsnapinres\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by HMSnapinRes.rc
//
#define IDS_STRING_ROOT_NODE            1
#define IDS_STRING_SYSTEMS_NODE         2
#define IDS_STRING_NAME                 3
#define IDS_STRING_NORMAL               4
#define IDS_STRING_WARNING              5
#define IDS_STRING_CRITICAL             6
#define IDS_STRING_UNKNOWN              7
#define IDS_STRING_LAST_MESSAGE         8
#define IDS_STRING_COMMENT              9
#define IDS_STRING_NEW_SYSTEMS_GROUP    10
#define IDS_STRING_NEW_SYSTEMS_GROUP_DESCRIPTION 11
#define IDS_STRING_CLEAR_EVENTS         12
#define IDS_STRING_CLEAR_EVENTS_DESCRIPTION 13
#define IDS_STRING_ALL_SYSTEMS_NODE     14
#define IDS_STRING_UNTITLED             15
#define IDS_STRING_NEW_SYSTEM           16
#define IDS_STRING_NEW_SYSTEM_DESCRIPTION 17
#define IDS_STRING_BROWSE_SYSTEM        18
#define IDS_STRING_STATUS_ONLY          19
#define IDS_STRING_ICONS_STATUS         20
#define IDS_STRING_STATUS_ONLY_DESCRIPTION 21
#define IDS_STRING_ICONS_STATUS_DESCRIPTION 22
#define IDS_STRING_SEPARATE_GROUP       23
#define IDS_STRING_SEPARATE_GROUP_DESCRIPTION 24
#define IDS_STRING_NEW_COMPONENT        25
#define IDS_STRING_NEW_COMPONENT_DESCRIPTION 26
#define IDS_STRING_REMOVE_SYSTEM        27
#define IDS_STRING_REMOVE_SYSTEM_DESCRIPTION 28
#define IDS_STRING_RESET_STATUS         29
#define IDS_STRING_RESET_STATUS_DESCRIPTION 30
#define IDS_STRING_ENABLE_ALL_THRESHOLDS 31
#define IDS_STRING_ENABLE_ALL_THRESHOLDS_DESCRIPTION 32
#define IDS_STRING_ENABLE_ALL_STATISTICS 33
#define IDS_STRING_ENABLE_ALL_STATISTICS_DESCRIPTION 34
#define IDS_STRING_SEVERITY             35
#define IDS_STRING_DATETIME             36
#define IDS_STRING_DE_CATEGORIES        37
#define IDS_STRING_SYSTEM               38
#define IDS_STRING_MESSAGE              39
#define IDS_STRING_PROCESSOR_NODE       40
#define IDS_STRING_TYPE                 41
#define IDS_STRING_CURRENT              42
#define IDS_STRING_MINIMUM              43
#define IDS_STRING_AVERAGE              44
#define UIT_IDC_TABLE                   44
#define IDS_STRING_MIN_RESPONSE         45
#define IDS_STRING_MAX_RESPONSE         46
#define IDS_STRING_AVG_RESPONSE         47
#define IDS_STRING_CURRENT_RESPONSE     48
#define IDS_STRING_MAXIMUM              49
#define IDS_STRING_DATA_POINT           50
#define IDS_STRING_FILE_INFORMATION     51
#define IDS_STRING_GENERIC_WMI_INSTANCE 52
#define IDS_STRING_HTTP_ADDRESS         53
#define IDS_STRING_INTERNET_PROTOCOL    54
#define IDS_STRING_SERVICE              55
#define IDS_STRING_NT_EVENTS            56
#define IDS_STRING_INVALID_MACHINE_NAME 57
#define IDS_STRING_INCORRECT_AGENT_VERSION 58
#define IDS_STRING_WBEM_NOT_INSTALLED   59
#define IDS_STRING_NO_CONNECT           60
#define IDS_STRING_PROVIDER_FAILURE     61
#define IDS_STRING_PROVIDER_LOAD_FAILURE 62
#define IDS_STRING_INVALID_NAMESPACE    63
#define IDS_STRING_INVALID_PARAMETER    64
#define IDS_STRING_OUT_OF_MEMORY        65
#define IDS_STRING_TRANSPORT_ERROR      66
#define IDS_STRING_OPERATION_CANCELLED  67
#define IDS_STRING_REGISTRATION_TOO_PRECISE 68
#define IDS_STRING_WBEM_NOT_AVAILABLE   69
#define IDS_STRING_UNKNOWN_ERROR        70
#define IDS_STRING_CONNMGR_DEAD         71
#define IDS_STRING_UNSPECIFIED_ERROR    72
#define IDS_STRING_GREATER_THAN         73
#define IDS_STRING_LESS_THAN            74
#define IDS_STRING_DISABLED             75
#define IDS_STRING_ACTION_POLICY        76
#define IDS_STRING_NEW_THRESHOLD        77
#define IDS_STRING_NEW_THRESHOLD_DESCRIPTION 78
#define IDS_STRING_ACTION               79
#define IDS_STRING_ACTIONPOLICY         80
#define IDS_STRING_ACTIONMAN            81
#define IDS_STRING_CONFIG               82
#define IDS_STRING_PERFMON              83
#define IDS_STRING_NONE                 84
#define IDS_STRING_CONNECTED            85
#define IDS_STRING_AUTO_FILTER          86
#define IDS_STRING_AUTO_FILTER_DESCRIPTION 87
#define IDS_STRING_NEW_SYSTEM_SHORTCUT  88
#define IDS_STRING_NEW_SYSTEM_SHORTCUT_DESCRIPTION 89
#define IDS_STRING_NEW_DATA_GROUP       90
#define IDS_STRING_RESET_STATISTICS     91
#define IDS_STRING_SNMP                 92
#define IDS_STRING_GENERIC_WMI_QUERY    93
#define IDS_STRING_EQUALS               94
#define IDS_STRING_DOES_NOT_EQUAL       95
#define IDS_STRING_GREATER_THAN_EQUAL_TO 96
#define IDS_STRING_LESS_THAN_EQUAL_TO   97
#define IDS_STRING_CONTAINS             98
#define IDS_STRING_DOES_NOT_CONTAIN     99
#define IDS_STRING_INFORMATION          100
#define IDI_ICON_HEALTHMON              101
#define IDS_STRING_RESET                101
#define IDS_STRING_WMI_BROWSE_TITLE     102
#define IDS_STRING_NAMESPACES           103
#define IDS_STRING_CLASSES              104
#define IDI_ICON_SYSTEMS                105
#define IDS_STRING_INSTANCES            105
#define IDI_ICON_GROUP                  106
#define IDS_STRING_PROPERTIES           106
#define IDI_ICON_GROUP_OPEN             107
#define IDS_STRING_SYSINFO_FORMAT       107
#define IDI_ICON_SYSTEM                 108
#define IDS_STRING_CHILDREN_OF_FORMAT   108
#define IDI_ICON_PROCESSOR              109
#define IDS_STRING_COUNT_OF_FORMAT      109
#define UIT_IDC_COMBO1                  110
#define IDS_STRING_EVENTS_OF_FORMAT     110
#define IDS_STRING_GENERIC_WMI_POLLED_QUERY 111
#define IDS_STRING_NEW                  112
#define IDS_STRING_TASK                 113
#define IDD_SYSTEM_GENERAL              114
#define IDS_STRING_NEW_DESCRIPTION      114
#define IDS_STRING_TASK_DESCRIPTION     115
#define IDB_BITMAP_HEALTHMON_LARGE      116
#define IDS_STRING_PERFMON_FMT          116
#define IDB_BITMAP_HEALTHMON_SMALL      117
#define IDS_STRING_EVENT_LOG_FMT        117
#define IDS_STRING_WMI_INSTANCE_FMT     118
#define IDS_STRING_WMI_EVENT_QUERY_FMT  119
#define IDS_STRING_WMI_QUERY_FMT        120
#define IDD_GROUP_GENERAL               121
#define IDS_STRING_SERVICE_FMT          121
#define IDD_GROUP_NEW_SYSTEMS           122
#define IDS_STRING_INET_FMT             122
#define IDS_STRING_HTTP_FMT             123
#define IDS_STRING_DATA_GROUP_FMT       124
#define IDD_HEALTHMONITOR_GENERAL       125
#define IDS_STRING_RULE_FMT             125
#define IDS_STRING_SYSTEM_FMT           126
#define IDS_STRING_SYSTEMGROUP_FMT      127
#define IDS_STRING_EVENTS               128
#define IDS_STRING_STATISTICS           129
#define UIT_IDC_EDIT1                   130
#define IDS_STRING_GROUP_CATEGORIES     130
#define IDS_STRING_EXPORT               131
#define IDS_STRING_IMPORT               132
#define IDS_STRING_MOF_FILTER           133
#define IDD_DIALOG_WMI_TEST             134
#define IDS_STRING_PATH                 134
#define IDS_STRING_ARRAY_OF             135
#define IDD_DIALOG_REMOVESYSTEM         136
#define IDS_STRING_CIM_ILLEGAL          136
#define IDI_ICON_WARNING                137
#define IDS_STRING_CIM_EMPTY            137
#define IDI_ICON_SYSTEM_WARNING         138
#define IDS_STRING_CIM_SINT             138
#define IDI_ICON_SYSTEM_CRITICAL        139
#define IDS_STRING_CIM_UINT             139
#define IDD_DIALOG_DISABLETHRESHOLD     140
#define IDI_ICON_SYSTEM_UNKNOWN         140
#define UIT_IDC_CHECK1                  140
#define IDS_STRING_CIM_REAL             140
#define IDD_DIALOG_SEPARATEGROUP        141
#define IDI_ICON_PROCESSOR_WARNING      141
#define IDS_STRING_CIM_BOOLEAN          141
#define IDI_ICON_PROCESSOR_CRITICAL     142
#define IDS_STRING_CIM_STRING           142
#define IDI_ICON_PROCESSOR_UNKNOWN      143
#define IDS_STRING_CIM_DATETIME         143
#define IDD_DIALOG_CLEAREVENTS          144
#define IDS_STRING_CIM_REFERENCE        144
#define IDS_STRING_CIM_CHAR16           145
#define IDS_STRING_CIM_OBJECT           146
#define IDS_STRING_SMTP_FMT             147
#define IDD_HEALTHMONITOR_HISTORY       148
#define IDS_STRING_FTP_FMT              148
#define IDS_STRING_SMTP                 149
#define IDS_STRING_FTP                  150
#define IDS_STRING_MODIFY_SYSTEM_SHORTCUT 151
#define IDD_DIALOG_ENABLETHRESHOLDING   152
#define IDS_STRING_WRONG_COLLECTION_VALUE 152
#define IDD_NEW_SYSTEM                  153
#define IDS_STRING_WAITING              153
#define IDS_STRING_SUMMARY              154
#define IDS_STRING_GUID                 155
#define IDS_STRING_WORKING              156
#define IDD_DATAPOINT_GENERAL           157
#define IDS_STRING_WARN_DELETE          157
#define IDD_THRESHOLD_GENERAL           158
#define IDS_STRING_DATA_GROUP           158
#define IDD_THRESHOLD_POLICY            159
#define IDS_STRING_SYSTEM_GROUP         159
#define UIT_IDC_LABEL1                  160
#define IDS_STRING_RULE                 160
#define IDD_THRESHOLD_EXPRESSION        161
#define UIT_IDC_LABEL2                  161
#define IDS_STRING_TOOLTIP_NEW          161
#define IDD_DATAPOINT_FILEINFORMATION   162
#define IDS_STRING_TOOLTIP_PROPERTY     162
#define IDD_DATAPOINT_HTTP              163
#define IDS_STRING_TOOLTIP_DELETE       163
#define IDD_DATAPOINT_INTERNETPROTOCOL  164
#define IDS_STRING_INVALID_SYSTEM       164
#define IDD_DATAPOINT_SERVICEPROCESS    165
#define IDS_STRING_CONDITION            165
#define IDD_DATAPOINT_WINDOWSNTEVENT    166
#define IDS_STRING_ACTION_EMAIL_FMT     166
#define IDD_DATAPOINT_PERFMON           167
#define IDS_STRING_ACTION_EMAIL         167
#define IDS_STRING_ACTION_CMDLINE_FMT   168
#define IDD_DATAPOINT_HTTP_ADVANCED     169
#define IDS_STRING_ACTION_CMDLINE       169
#define IDS_STRING_ACTION_LOGFILE_FMT   170
#define IDS_STRING_ACTION_LOGFILE       171
#define IDS_STRING_ACTION_NTEVENT_FMT   172
#define IDS_STRING_ACTION_NTEVENT       173
#define IDS_STRING_ACTION_SCRIPT_FMT    174
#define UIT_IDC_FRAME6                  175
#define IDS_STRING_ACTION_SCRIPT        175
#define IDS_STRING_ACTION_PAGING_FMT    176
#define IDS_STRING_ACTION_PAGING        177
#define IDS_STRING_ACTIONS              178
#define IDS_STRING_DISABLE_ACTIONS      179
#define IDS_STRING_WARN_CLEAR_EVENTS    180
#define IDS_STRING_TOOLTIP_SELECT_ALL   181
#define IDS_STRING_TOOLTIP_DESELECT_ALL 182
#define IDS_STRING_WARN_PROPPAGE_OPEN   183
#define IDS_STRING_NODATA               184
#define IDS_STRING_OUTAGE               185
#define IDS_STRING_BROWSE_FOLDER        186
#define IDS_STRING_FILTER               187
#define IDS_STRING_BROWSE_FILE          188
#define IDS_STRING_ENTER_FILENAME       189
#define IDS_STRING_CUT                  190
#define IDS_STRING_COPY                 191
#define IDS_STRING_PASTE                192
#define IDS_STRING_DELETE               193
#define IDS_STRING_ASSOCIATIONS_OF_FORMAT 194
#define IDS_STRING_GRAPH                195
#define IDS_STRING_STATISTICS_FOR       196
#define IDS_STRING_TIME                 197
#define IDS_STRING_PROPERTY             198
#define IDS_STRING_INSTANCE             199
#define IDS_STRING_FILE_INFO_FMT        200
#define IDS_STRING_HEALTHMON_RESULTSPANE 201
#define IDS_STRING_CONNECTION           202
#define IDS_STRING_ICMP                 203
#define IDS_STRING_ICMP_FMT             204
#define IDS_STRING_DISCONNECT           205
#define IDS_STRING_DISCONNECT_DESC      206
#define IDS_STRING_CHECK_NOW            207
#define IDS_STRING_CHECK_NOW_DESC       208
#define IDS_STRING_DISABLE_ACTIONS_DESC 209
#define IDS_STRING_MODIFY_SHORTCUTS_DESC 210
#define IDS_STRING_ACTION_CMDLINE_DESC  211
#define IDS_STRING_ACTION_EMAIL_DESC    212
#define IDS_STRING_FILEINFO_DESC        213
#define IDS_STRING_FTP_DESC             214
#define IDS_STRING_HTTP_DESC            215
#define IDS_STRING_ICMP_DESC            216
#define IDS_STRING_PERFMON_DESC         217
#define IDS_STRING_ACTION_SCRIPT_DESC   218
#define IDS_STRING_SERVICE_DESC         219
#define IDS_STRING_SMTP_DESC            220
#define IDS_STRING_ACTION_TEXTLOG_DESC  221
#define IDS_STRING_ACTION_NTEVENT_DESC  222
#define IDS_STRING_EVENTLOG_DESC        223
#define IDS_STRING_WMI_QUERY_DESC       224
#define IDS_STRING_WMI_EVTQUERY_DESC    225
#define IDS_STRING_WMI_INSTANCE_DESC    226
#define IDS_STRING_RESET_STATISTICS_DESC 227
#define IDS_STRING_STATUS               228
#define IDS_STRING_ICON_LEGEND          229
#define IDS_STRING_ICON_LEGEND_DESCRIPTION 230
#define IDS_STRING_ID                   231
#define IDS_STRING_CLEAR                232
#define IDS_STRING_REFRESH              233
#define IDS_STRING_HELP                 234
#define IDS_STRING_LASTUPDATE           235
#define IDS_STRING_NEW_COMPUTER         236
#define IDS_STRING_DOMAIN               237
#define IDS_STRING_OS                   238
#define IDS_STRING_WMI_VERSION          239
#define IDS_STRING_ALERTS_FORMAT        240
#define IDS_STRING_REMINDER_TIME        241
#define IDS_STRING_THROTTLE_TIME        242
#define IDS_STRING_ALERT_PROPERTIES     243
#define IDS_STRING_DISABLE              244
#define IDS_STRING_TIME_HOURS_FORMAT    245
#define IDS_STRING_TIME_MINUTES_FORMAT  246
#define IDS_STRING_TIME_SECONDS_FORMAT  247
#define IDS_STRING_NO_ITEMS_FOUND       248
#define IDS_STRING_COLLECTING           249
#define IDS_STRING_NO_NAME              250
#define IDS_STRING_NAMESPACES_ON_SYSTEM 251
#define IDS_STRING_COM_PLUS             252
#define IDS_STRING_COM_PLUS_DESC        253
#define IDS_STRING_COM_PLUS_FMT         254
#define IDS_STRING_COM_PLUS_APPS        255
#define IDS_STRING_WMI_ERROR            256
#define IDS_STRING_PROPERTIES_OF_ALERT  257
#define IDS_STRING_IS_ALWAYS_TRUE       258
#define IDS_STRING_NO_REMOTE_NAMESPACES 259
#define IDS_ERR_OLE_INIT_FAILED         260
#define IDS_ERR_MSGFILTER_REG_FAILED    261
#define IDS_ERR_MUST_CREATE_ATLEAST_ONE_COUNTER 262
#define IDS_ERR_FEATURE_NOT_IMPLEMENTED 263
#define IDS_ERR_MUST_SELECT_ATLEAST_ONE_COUNTER 264
#define IDS_STRING_NEW_DATA_COLLECTOR   265
#define IDS_STRING_NEW_DATA_COLLECTOR_DESC 266
#define IDS_STRING_OBJECTS              267
#define IDS_STRING_SERVICES             268
#define IDS_STRING_PROCESSES            269
#define IDS_STRING_MUST_CREATE_ACTION   270
#define IDS_ERR_SMTP_REQ_SERVER         271
#define IDS_ERR_SMTP_REQ_FROM           272
#define IDS_ERR_SMTP_REQ_TO             273
#define IDS_ERR_SMTP_REQ_MESSAGE        274
#define IDS_ERR_SMTP_REQ_TIMEOUT        275
#define IDS_ERR_PROXY_REQ               276
#define IDS_WARNING_DISKPERF            277
#define IDS_ERR_SELECT_STATE            278
#define IDS_ERR_MUST_SELECT_ATLEAST_ONE_PROPERTY 279
#define IDS_ERR_INSTANCE_NOT_EXISTS     280
#define IDS_ERR_CLASS_REQUIRED          281
#define IDS_ERR_CLASS_REQUIRED_FOR_INSTANCE 282
#define IDS_ERR_INVALID_NAMESPACE       283
#define IDS_STRING_FORMAT_SMTPNAME      284
#define IDS_STRING_FORMAT_ICMPNAME      285
#define IDS_NTEVENT_TYPE_ERRORS         286
#define IDS_NTEVENT_TYPE_ERRORS_AND_WARNINGS 287
#define IDS_NTEVENT_TYPE_EVENTS         288
#define IDS_NTEVENT_NEWNAME             289
#define IDS_NTEVENT_NEWNAME_EVENTID     290
#define IDS_NTEVENT_NEWNAME_LOGNAME     291
#define IDS_NTEVENT_NEWNAME_EVENTLOG    292
#define IDS_STRING_OK                   293
#define IDC_EDIT_EVENTID                530
#define IDC_EDIT_SOURCE                 531
#define IDC_EDIT_USER                   560
#define IDC_EDIT_CATEGORY               561
#define IDC_CHECK_INFORMATION           690
#define IDC_CHECK_WARNING               691
#define IDC_CHECK_ERROR                 692
#define IDC_CHECK_SUCCESS               693
#define IDC_CHECK_FAILURE               694
#define IDC_BUTTON_SELECT_ALL           1000
#define IDB_BITMAP_NEW                  1001
#define IDC_LIST1                       1001
#define IDB_BITMAP_PROPERTIES           1002
#define IDB_BITMAP_DELETE               1003
#define IDC_COMBO1                      1003
#define IDC_COMBO_THROTTLE_UNITS        1003
#define IDC_COMBO_FUNCTION              1003
#define IDB_BITMAP_SELECT_ALL           1004
#define IDC_COMBO_COMPARISON            1004
#define IDC_EDIT_POST_DATA              1004
#define IDC_COMBO_TIMEOUT_UNITS         1004
#define IDC_COMBO_LOGSIZE_UNITS         1004
#define IDC_COMBO_REMINDER_UNITS        1004
#define IDC_SPIN1                       1005
#define IDC_EDIT_EXTRA_HEADERS          1005
#define IDB_BITMAP_DESELECT_ALL         1005
#define IDC_LIST_SYSTEMS                1006
#define IDC_SPIN7                       1006
#define IDC_EDIT3                       1006
#define IDC_EDIT_DURATION               1006
#define IDC_SPIN3                       1006
#define IDB_BITMAP_NEW_SYSTEM           1006
#define IDC_EDIT_COMMENT                1007
#define IDC_COMBO_UNITS                 1007
#define IDB_BITMAP_CLEAR_EVENTS         1007
#define IDC_BUTTON_HELP                 1008
#define IDC_SPIN9                       1008
#define IDC_EDIT_TOTAL_SAMPLES          1008
#define IDC_BUTTON_OPEN                 1008
#define IDC_COMBO_RULE_TYPE             1008
#define IDC_BUTTON_BCC                  1008
#define IDB_BITMAP_RESET_STATUS         1008
#define IDC_EDIT_NAME                   1009
#define IDC_EDIT_MACHINE_NAME           1009
#define IDC_EDIT_NAMESPACE              1009
#define IDC_SPIN2                       1009
#define IDC_EDIT_SYSTEMS                1009
#define IDC_EDIT_VIOLATION_MESSAGE      1009
#define IDB_BITMAP_DISABLE              1009
#define IDC_BROWSE                      1010
#define IDC_WMI_NAMESPACE               1010
#define IDC_EDIT_COMPARE_TO             1010
#define IDC_EDIT_INSTANCE               1010
#define IDC_EDIT_NUMBER_EVENTS          1010
#define IDC_WMI_CLASS                   1011
#define IDC_BUTTON_DEL                  1011
#define IDC_EDIT_RESET_MESSAGE          1011
#define IDC_EDIT_COMPARE_NUMERIC        1011
#define IDC_BUTTON_NEW                  1012
#define IDC_CHECK1                      1012
#define IDC_EDIT_DATA_ELEMENT           1012
#define IDC_CHECK_SOURCE                1012
#define IDC_EDIT_PROXY_ADDRESS          1012
#define IDC_BUTTON_ADD                  1012
#define IDC_EDIT_FILE_NAME              1012
#define IDC_CHECK_USE                   1012
#define IDC_BUTTON_PROXY                1012
#define IDC_BUTTON_PROPERTIES           1013
#define IDC_EDIT_CLASS                  1013
#define IDC_STATIC_TITLE                1013
#define IDC_EDIT_COMMAND_LINE           1013
#define IDC_BUTTON_DELETE               1014
#define IDC_EDIT17                      1014
#define IDC_EDIT_OBJECT                 1014
#define IDC_EDIT_WORKING_DIR            1014
#define IDC_CHECK_CRITICAL              1014
#define IDC_CHECK2                      1015
#define IDC_CHECK_MANUAL_RESET          1015
#define IDC_CHECK_CATEGORY              1015
#define IDC_COMBO_HTTP_METHOD           1015
#define IDC_EDIT_EVENT_ID               1015
#define IDC_COMBO_MEASURE               1016
#define IDC_EDIT_PROCESS_TIMEOUT        1016
#define IDC_CHECK_DISABLED              1016
#define IDC_WMI_PATH                    1017
#define IDC_CHECK_NO_DATA               1017
#define IDC_WMI_NAMESPACE_BROWSE        1018
#define IDC_CHECK12                     1018
#define IDC_CHECK_REQUIRE_RESET         1018
#define IDC_EDIT_LOGSIZE                1018
#define IDC_EDIT_THROTTLE_TIME          1018
#define IDC_RADIO1                      1019
#define IDC_WMI_CLASS_BROWSE            1019
#define IDC_EDIT_REMINDER_TIME          1019
#define IDC_RADIO2                      1020
#define IDC_WMI_INSTANCE_BROWSE         1020
#define IDC_WMI_INSTANCE_BROWSE2        1021
#define Override                        1023
#define IDC_WMI_ACCESS_METHOD           1026
#define IDC_WMI_INSTANCES               1027
#define IDC_SAMPLE_INSTANCE             1029
#define IDC_INSTANCE_COUNT              1030
#define IDD_DATAPOINT_SCHEDULE          1033
#define IDI_ICON_MEMORY                 2000
#define IDI_ICON_MEMORY_WARNING         2001
#define IDI_ICON_MEMORY_CRITICAL        2002
#define IDC_BUTTON_ADVANCED             2002
#define IDI_ICON_MEMORY_UNKNOWN         2003
#define IDC_CHECK_EVENTID               2003
#define IDI_ICON_PAGINGFILE             2004
#define IDC_CHECK_USER                  2004
#define IDI_ICON_PAGINGFILE_WARNING     2005
#define IDI_ICON_PAGINGFILE_CRITICAL    2006
#define IDI_ICON_PAGINGFILE_UNKNOWN     2007
#define IDC_LIST3                       2007
#define IDI_ICON_LOGICALDISK            2008
#define IDC_LIST_PROPERTIES             2008
#define IDI_ICON_LOGICALDISK_WARNING    2009
#define IDC_WMI_PROPERTY_BROWSE         2009
#define IDC_LIST_FILE_PROPERTIES        2009
#define IDI_ICON_LOGICALDISK_CRITICAL   2010
#define IDC_BUTTON_BROWSE_NAMESPACE     2010
#define IDC_BUTTON_BROWSE_OBJECT        2010
#define IDI_ICON_LOGICALDISK_UNKNOWN    2011
#define IDC_EDIT_USER_NAME              2011
#define IDC_BUTTON_BROWSE_CLASS         2011
#define IDC_LIST_WMI_ITEMS              2011
#define IDI_ICON_PHYSICALDISK_WARNING   2012
#define IDC_BUTTON_BROWSE_INSTANCE      2012
#define IDC_RADIO_NONE                  2012
#define IDI_ICON_PHYSICALDISK_UNKNOWN   2013
#define IDC_EDIT_PASSWORD               2013
#define IDC_RADIO_NUMBER_EVENTS         2013
#define IDI_ICON_PHYSICALDISK_CRITICAL  2014
#define IDC_RADIO_TIME_PERIOD           2014
#define IDC_BUTTON_BROWSE_DIRECTORY     2014
#define IDI_ICON_PHYSICALDISK           2015
#define IDC_BUTTON3                     2015
#define IDC_BUTTON_TEST                 2015
#define IDC_EDIT_TIME_PERIOD            2015
#define IDC_EDIT_DATA_COLLECT_INTERVAL  2015
#define IDI_ICON_NIC                    2016
#define IDC_COMBO_TIME                  2016
#define IDI_ICON_NIC_WARNING            2017
#define IDC_STATIC_DATE_CREATED         2017
#define IDI_ICON_NIC_CRITICAL           2018
#define IDC_STATIC_DATE_LAST_MODIFIED   2018
#define IDI_ICON_NIC_UNKNOWN            2019
#define IDC_STATIC_CREATED              2019
#define IDI_ICON_SERVERQUEUE            2020
#define IDC_STATIC_MODIFIED             2020
#define IDI_ICON_SERVERQUEUE_WARNING    2021
#define IDC_STATIC_OS                   2021
#define IDI_ICON_SERVERQUEUE_CRITICAL   2022
#define IDC_STATIC_DOMAIN               2022
#define IDI_ICON_SERVERQUEUE_UNKNOWN    2023
#define IDC_STATIC_PROCESSOR            2023
#define IDI_ICON_SECURITY               2024
#define IDC_STATIC_WMI_VERSION          2024
#define IDI_ICON_SECURITY_WARNING       2025
#define IDC_STATIC_HM_VERSION           2025
#define IDI_ICON_SECURITY_CRITICAL      2026
#define IDC_CHECK_SUNDAY                2026
#define IDI_ICON_SECURITY_UNKNOWN       2027
#define IDC_CHECK_MONDAY                2027
#define IDI_ICON_FAULT                  2028
#define IDC_CHECK_TUESDAY               2028
#define IDI_ICON_FAULT_WARNING          2029
#define IDC_CHECK_WEDNESDAY             2029
#define IDI_ICON_FAULT_CRITICAL         2030
#define IDC_CHECK_THURSDAY              2030
#define IDI_ICON_FAULT_UNKNOWN          2031
#define IDC_CHECK_FRIDAY                2031
#define IDI_ICON_SQLSERVER              2032
#define IDC_CHECK_SATURDAY              2032
#define IDI_ICON_SQLSERVER_WARNING      2033
#define IDC_RADIO_ALL_DAY               2033
#define IDI_ICON_SQLSERVER_CRITICAL     2034
#define IDC_RADIO_ONLY_FROM             2034
#define IDI_ICON_SQLSERVER_UNKNOWN      2035
#define IDC_RADIO_ALL_DAY_EXCEPT        2035
#define IDI_ICON_IIS_WARNING            2036
#define IDC_RADIO_ONCE_DAILY            2036
#define IDI_ICON_IIS_UNKNOWN            2037
#define IDC_DATETIMEPICKER_START_1      2037
#define IDI_ICON_IIS_CRITICAL           2038
#define IDI_ICON_IIS                    2039
#define IDI_ICON_EXCHANGE               2040
#define IDI_ICON_EXCHANGE_CRITICAL      2041
#define IDC_DATETIMEPICKER_END_1        2041
#define IDI_ICON_EXCHANGE_UNKNOWN       2042
#define IDC_DATETIMEPICKER_START_2      2042
#define IDI_ICON_EXCHANGE_WARNING       2043
#define IDC_DATETIMEPICKER_END_2        2043
#define IDI_ICON_SNA_WARNING            2044
#define IDC_DATETIMEPICKER_ONCE         2044
#define IDI_ICON_SNA_UNKNOWN            2045
#define IDC_EDIT_QUERY                  2045
#define IDI_ICON_SNA_CRITICAL           2046
#define IDI_ICON_SNA                    2047
#define IDC_EDIT_PROCESS                2047
#define IDI_ICON_SMS_WARNING            2048
#define IDI_ICON_SMS_UNKNOWN            2049
#define IDC_BUTTON_BROWSE_PROCESS       2049
#define IDI_ICON_SMS_CRITICAL           2050
#define IDC_EDIT_SERVICE                2050
#define IDI_ICON_SMS                    2051
#define IDC_BUTTON_BROWSE_SERVICE       2051
#define IDI_ICON_1                      2052
#define IDC_EDIT_URL                    2052
#define IDI_ICON_2                      2053
#define IDC_EDIT_TIMEOUT                2053
#define IDI_ICON_3                      2054
#define IDC_COMBO_AUTHENTICATION        2054
#define IDI_ICON_UNKNOWN                2055
#define IDC_EDIT_PROXY_PORT             2055
#define IDC_EDIT_HOP_COUNT              2055
#define IDI_ICON_CRITICAL               2056
#define IDC_CHECK_USE_PROXY             2056
#define IDI_ICON_NORMAL                 2057
#define IDC_CHECK_FOLLOW_REDIRECTS      2057
#define IDI_ICON_DATAPOINT              2058
#define IDC_COMBO_LOG_FILE              2058
#define IDI_ICON_THRESHOLD              2059
#define IDI_ICON_COMPONENT              2060
#define IDC_EDIT_FOLDER                 2060
#define IDI_ICON_CONFIG                 2061
#define IDC_BUTTON_BROWSE_FOLDER        2061
#define IDI_ICON_ACTIONMAN              2062
#define IDI_ICON_ACTION                 2063
#define IDC_EDIT_FILE                   2063
#define IDC_BUTTON_BROWSE_FILE          2064
#define IDI_ICON_EXCHANGE_DISABLED      2065
#define IDI_ICON_FAULT_DISABLED         2066
#define IDC_EDIT_SERVER                 2066
#define IDI_ICON_IIS_DISABLED           2067
#define IDC_EDIT_FROM                   2067
#define IDI_ICON_LOGICALDISK_DISABLED   2068
#define IDR_LIST_MENUS                  2068
#define IDC_EDIT_TO                     2068
#define IDI_ICON_MEMORY_DISABLED        2069
#define IDC_EDIT_DATA                   2069
#define IDI_ICON_NIC_DISABLED           2070
#define IDI_ICON_PAGINGFILE_DISABLED    2071
#define IDC_EDIT_SUBJECT                2071
#define IDC_EDIT_DOWNLOAD_DIRECTORY     2071
#define IDI_ICON_PHYSICALDISK_DISABLED  2072
#define IDC_CHECK_USE_ASCII             2072
#define IDI_ICON_PROCESSOR_DISABLED     2073
#define IDI_ICON_SECURITY_DISABLED      2074
#define IDD_DIALOG_WMI_BROWSE           2074
#define IDC_COMBO_EVENT_TYPE            2074
#define IDI_ICON_SERVERQUEUE_DISABLED   2075
#define IDC_ANIMATE_PROGRESS            2075
#define IDI_ICON_SMS_DISABLED           2076
#define IDI_ICON_SNA_DISABLED           2077
#define IDD_DIALOG_OPERATION_IN_PROGRESS 2077
#define IDI_ICON_SQLSERVER_DISABLED     2078
#define IDD_DIALOG_NEW_SYSTEM           2078
#define IDI_ICON_SYSTEM_DISABLED        2079
#define IDC_COMBO_DOMAIN                2079
#define IDI_ICON_4                      2080
#define IDC_BUTTON_CHECK_NAMES          2080
#define IDI_ICON_COMPONENT_WARNING      2081
#define IDD_DIALOG_NEW_ACTION_ASSOC     2081
#define IDI_ICON_COMPONENT_CRITICAL     2082
#define IDC_LIST_ACTIONS                2082
#define IDI_ICON_COMPONENT_UNKNOWN      2083
#define IDI_ICON_COMPONENT_DISABLED     2084
#define IDI_ICON_DATAPOINT_WARNING      2085
#define IDD_DIALOG_CC                   2085
#define IDI_ICON_DATAPOINT_CRITICAL     2086
#define IDD_DIALOG_PROXY                2086
#define IDI_ICON_DATAPOINT_UNKNOWN      2087
#define IDC_BUTTON_DESELECT_ALL         2087
#define IDD_DIALOG_ALERT                2087
#define IDI_ICON_DATAPOINT_DISABLED     2088
#define IDI_ICON_THRESHOLD_WARNING      2089
#define IDC_STATIC_LOOK_IN              2089
#define IDI_ICON_THRESHOLD_CRITICAL     2090
#define IDC_STATIC_BAR                  2090
#define IDI_ICON_THRESHOLD_UNKNOWN      2091
#define IDC_EDIT_CC                     2091
#define IDI_ICON_THRESHOLD_DISABLED     2092
#define IDC_EDIT_BCC                    2092
#define IDI_ICON_SYSTEMS_WARNING        2093
#define IDC_EDIT_MESSAGE                2093
#define IDI_ICON_SYSTEMS_CRITICAL       2094
#define IDC_EDIT_LOGFILENAME            2094
#define IDI_ICON_SYSTEMS_DISABLED       2095
#define IDI_ICON_SYSTEMS_UNKNOWN        2096
#define IDC_EDIT_TEXT                   2096
#define IDI_ICON_GROUP_WARNING          2097
#define IDC_RADIO_TEXT_TYPE_ASCII       2097
#define IDI_ICON_GROUP_CRITICAL         2098
#define IDC_RADIO_TEXT_TYPE_UNICODE     2098
#define IDI_ICON_GROUP_DISABLED         2099
#define IDC_EDIT_EVENT_TEXT             2099
#define IDI_ICON_GROUP_UNKNOWN          2100
#define IDC_EDIT_PHONE                  2100
#define IDI_ICON_COMPONENT_OUTAGE       2101
#define IDC_EDIT_ANSWER_WAIT            2101
#define IDI_ICON_COMPONENT_NO_CONNECT   2102
#define IDC_EDIT_PAGER_ID               2102
#define IDI_ICON_SYSTEM_NO_CONNECT      2103
#define IDC_COMBO_SCRIPT_ENGINE         2103
#define IDI_ICON_SYSTEM_OUTAGE          2104
#define IDI_ICON_SYSTEMS_OUTAGE         2105
#define IDI_ICON_SYSTEMS_NO_CONNECT     2106
#define IDC_COMBO_ACTIONS               2106
#define IDI_ICON_THRESHOLD_OUTAGE       2107
#define IDC_CHECK_NORMAL                2107
#define IDI_ICON_THRESHOLD_NO_CONNECT   2108
#define IDC_LIST_FOLDER_PROPERTIES      2108
#define IDI_ICON_OUTAGE                 2109
#define IDC_LIST_PROCESS_PROPERTIES     2109
#define IDI_ICON_DISABLED               2110
#define IDC_LIST_SERVICE_PROPERTIES     2110
#define IDC_RADIO_DURATION_ANY          2110
#define IDC_BUTTON_CC                   2110
#define IDI_ICON_NO_CONNECT             2111
#define IDC_RADIO_DURATION              2111
#define IDC_BUTTON_INSERTION            2111
#define IDI_ICON_SYSTEM_SHORTCUT        2112
#define IDC_CHECK_WINDOWED              2112
#define IDC_BUTTON_INSERTION2           2112
#define IDI_ICON_SYSTEM_SHORTCUT_CRITICAL 2113
#define IDI_ICON_SYSTEM_SHORTCUT_DISABLED 2114
#define IDI_ICON_SYSTEM_SHORTCUT_NO_CONNECT 2115
#define IDI_ICON_SYSTEM_SHORTCUT_OUTAGE 2116
#define IDC_EDIT_PORT                   2116
#define IDI_ICON_SYSTEM_SHORTCUT_UNKNOWN 2117
#define IDC_EDIT_RETRY_COUNT            2117
#define IDI_ICON_SYSTEM_SHORTCUT_WARNING 2118
#define IDC_BUTTON_BROWSE_SYSTEM        2118
#define IDI_ICON_ACTION_SCRIPT          2119
#define IDC_ICON_STATIC                 2119
#define IDI_ICON_ACTION_NTEVENT         2120
#define IDC_COMBO_COMPARE_BOOLEAN       2120
#define IDI_ICON_ACTION_EMAIL           2121
#define IDC_EDIT_SEVERITY               2121
#define IDI_ICON_ACTION_LOGFILE         2122
#define IDC_EDIT_ID                     2122
#define IDI_ICON_ACTION_CMDLINE         2123
#define IDC_EDIT_DTIME                  2123
#define IDI_ICON_ACTION_PAGER           2124
#define IDC_EDIT_DATA_COLLECTOR         2124
#define IDI_ICON_DATAPOINT_NO_CONNECT   2125
#define IDC_EDIT_COMPUTER               2125
#define IDI_ICON_DATAPOINT_OUTAGE       2126
#define IDC_EDIT_ALERT                  2126
#define IDI_ICON_HEALTHMON_CRITICAL     2127
#define IDI_ICON_HEALTHMON_DISABLED     2128
#define IDI_ICON_HEALTHMON_NO_CONNECT   2129
#define IDC_STATIC_INFO                 2129
#define IDI_ICON_HEALTHMON_OUTAGE       2130
#define IDC_STATIC_TIME                 2130
#define IDI_ICON_HEALTHMON_UNKNOWN      2131
#define IDC_BUTTON_PREVIOUS             2131
#define IDI_ICON_HEALTHMON_WARNING      2132
#define IDC_BUTTON_NEXT                 2132
#define IDI_ICON_THRESHOLD_COLLECTING   2133
#define IDC_BUTTON_SUBJECT_INSERTION    2133
#define IDI_ICON_SYSTEMS_COLLECTING     2134
#define IDI_ICON_COMPONENT_COLLECTING   2135
#define IDI_ICON_HEALTHMON_COLLECTING   2136
#define IDI_ICON_DATAPOINT_COLLECTING   2137
#define IDI_ICON_SYSTEM_COLLECTING      2138
#define IDI_ICON_ACTION_CMDLINE_DISABLED 2141
#define IDI_ICON_ACTION_EMAIL_DISABLED  2142
#define IDI_ICON_ACTION_LOGFILE_DISABLED 2143
#define IDI_ICON_ACTION_NTEVENT_DISABLED 2145
#define IDI_ICON_ACTION_SCRIPT_DISABLED 2146
#define IDI_ICON_ACTIONS_DISABLED       2147
#define IDI_ICON_ACTION_CMDLINE_OUTAGE  2148
#define IDI_ICON_ACTION_EMAIL_OUTAGE    2149
#define IDI_ICON_ACTION_LOGFILE_OUTAGE  2150
#define IDI_ICON_ACTION_NTEVENT_OUTAGE  2151
#define IDI_ICON_ACTION_SCRIPT_OUTAGE   2152
#define IDS_DSC_CAT_PROCESSOR           3101
#define IDS_DSC_CAT_MEMORY              3102
#define IDS_DSC_CAT_PAGING              3103
#define IDS_DSC_CAT_LOGICALDISK         3104
#define IDS_DSC_CAT_PHYSICALDISK        3105
#define IDS_DSC_CAT_NETWORKINTERFACE    3106
#define IDS_DSC_CAT_SRVWORKQUE          3107
#define IDS_DSC_CAT_SECURITY            3108
#define IDS_DSC_CAT_FAULT               3109
#define IDS_DSC_CAT_SQL                 3110
#define IDS_DSC_CAT_IIS                 3111
#define IDS_DSC_CAT_EXCHANGE            3112
#define IDS_DSC_CAT_SNA                 3113
#define IDS_DSC_CAT_SMS                 3114
#define IDS_DSC_PROCESSOR_PERCTOTSYSTIME 3200
#define IDS_DSC_PROCESSOR_INTPERSEC     3201
#define IDS_DSC_MEMORY_PAGESPERSEC      3202
#define IDS_DSC_MEMORY_PERCCOMMBYTES    3203
#define IDS_DSC_MEMORY_POOLNONPAGEDBYTES 3204
#define IDS_DSC_MEMORY_PAGEREADSEC      3205
#define IDS_DSC_MEMORY_AVAILMEMORY      3206
#define IDS_DSC_PAGING_PERCUSAGE        3207
#define IDS_DSC_PAGING_PEAKUSAGE        3208
#define IDS_DSC_LOGICALDISK_FREESPACE   3209
#define IDS_DSC_PHYSICALDISK_DISKTIME   3210
#define IDS_DSC_PHYSICALDISK_QUELENGTH  3211
#define IDS_DSC_NETWORKINTERFACE_UTILIZATION 3212
#define IDS_DSC_SRVWORKQUE_SHORTAGES    3213
#define IDS_DSC_SRVWORKQUE_BLOCKEDQUE   3214
#define IDS_DSC_SRVWORKQUE_QUELENGTH    3215
#define IDS_DSC_SECURITY_LOGONERRORS    3216
#define IDS_DSC_SECURITY_ACCESSPERM     3217
#define IDS_DSC_FAULT_ERRSESSIONS       3218
#define IDS_DSC_FAULT_POOLPAGEDFAILURES 3219
#define IDS_DSC_FAULT_NONPAGEDFAILURES  3220
#define IDS_DSC_SQL_MSDTCSTOPPED        3221
#define IDS_DSC_SQL_MSSQLSERVERSTOPPED  3222
#define IDS_DSC_IIS_IISSTOPPED          3223
#define IDS_DSC_EXC_MSEXSASTOPPED       3224
#define IDS_DSC_EXC_MSEXDSSTOPPED       3225
#define IDS_DSC_EXC_MSEXMTASTOPPED      3226
#define IDS_DSC_EXC_MSEXISSTOPPED       3227
#define IDS_DSC_SNA_SNABASESTOPPED      3228
#define IDS_DSC_DISK_DISKPERF           3229
#define IDS_DSC_SNA_HOSTCONNECTION      3230
#define IDS_DSC_INTEL_MOTHER            3231
#define IDS_NAME_PROCESSOR_PERCTOTSYSTIME 3232
#define IDS_NAME_PROCESSOR_INTPERSEC    3233
#define IDS_NAME_MEMORY_PAGESPERSEC     3234
#define IDS_NAME_MEMORY_PERCCOMMBYTES   3235
#define IDS_NAME_MEMORY_POOLNONPAGEDBYTES 3236
#define IDS_NAME_MEMORY_PAGEREADSEC     3237
#define IDS_NAME_MEMORY_AVAILMEMORY     3238
#define IDS_NAME_PAGING_PERCUSAGE       3239
#define IDS_NAME_PAGING_PEAKUSAGE       3240
#define IDS_NAME_LOGICALDISK_FREESPACE  3241
#define IDS_NAME_PHYSICALDISK_DISKTIME  3242
#define IDS_NAME_PHYSICALDISK_QUELENGTH 3243
#define IDS_NAME_DISKPERF_STARTED       3244
#define IDS_NAME_NETWORKINTERFACE_UTILIZATION 3245
#define IDS_NAME_SRVWORKQUE_BLOCKEDQUE  3246
#define IDS_NAME_SRVWORKQUE_SHORTAGES   3247
#define IDS_NAME_SECURITY_LOGONERRORS   3248
#define IDS_NAME_SECURITY_ACCESSPERM    3249
#define IDS_NAME_FAULT_ERRSESSIONS      3250
#define IDS_NAME_FAULT_POOLPAGEDFAILURES 3251
#define IDS_NAME_FAULT_NONPAGEDFAILURES 3252
#define IDS_NAME_SQL_MSDTCSTOPPED       3253
#define IDS_NAME_SQL_MSSQLSERVERSTOPPED 3254
#define IDS_NAME_IIS_IISSTOPPED         3255
#define IDS_NAME_EXC_MSEXSASTOPPED      3256
#define IDS_NAME_EXC_MSEXDSSTOPPED      3257
#define IDS_NAME_EXC_MSEXMTASTOPPED     3258
#define IDS_NAME_EXC_MSEXISSTOPPED      3259
#define IDS_NAME_SNA_SNABASESTOPPED     3260
#define IDS_NAME_SNA_HOSTCONNECTION     3261
#define IDS_CAT_PROCESSOR               3262
#define IDS_CAT_MEMORY                  3263
#define IDS_CAT_PAGINGFILE              3264
#define IDS_CAT_LOGICALDISK             3265
#define IDS_CAT_PHYSICALDISK            3266
#define IDS_CAT_NETWORK                 3267
#define IDS_CAT_SERVER                  3268
#define IDS_CAT_SECURITY                3269
#define IDS_CAT_FAULT                   3270
#define IDS_CAT_SQLSERVER               3271
#define IDS_CAT_IISSERVER               3272
#define IDS_CAT_EXCHANGE                3273
#define IDS_CAT_SNASERVER               3274
#define IDS_CAT_SMSSERVER               3275
#define IDS_DSC_SMS_EXECSTOPPED         3276
#define IDS_NAME_SMS_EXECSTOPPED        3277
#define IDS_DSC_SMS_SITESTOPPED         3278
#define IDS_NAME_SMS_SITESTOPPED        3279
#define IDS_DSC_SMS_SQLMONSTOPPED       3280
#define IDS_NAME_SMS_SQLMONSTOPPED      3281
#define IDS_DSC_SMS_LOGDISCSTOPPED      3282
#define IDS_NAME_SMS_LOGDISCSTOPPED     3283
#define IDS_CAT_CATENABLE               3284
#define IDS_CAT_CATDISABLE              3285
#define IDS_CAT_INTEL                   3286
#define IDS_DSC_CAT_INTEL               3287
#define IDS_NAME_INTEL_CASE             3288
#define IDS_NAME_INTEL_FANEVENT         3289
#define IDS_NAME_INTEL_VOLTAGEEVENT     3290
#define IDS_NAME_INTEL_TEMPEVENT        3291
#define IDD_THRESHOLD_SCHEDULE          8304
#define IDD_DATAPOINT_SNMPDATA          8306
#define IDD_DATAPOINT_WMI_INSTANCE_OLD  8307
#define IDD_DATAPOINT_WMI_QUERY_OLD     8308
#define IDD_DATAPOINT_WMI_INSTANCE      8309
#define IDD_DATAPOINT_WMI_QUERY         8310
#define IDD_DIALOG_WMI_PROPERTY_BROWSE  8311
#define IDD_DATAPOINT_WMI_POLLED_QUERY  8312
#define IDD_DATAPOINT_SMTP              8313
#define IDD_DATAPOINT_FTP               8314
#define IDD_ACTION_ASSOCIATION          8315
#define IDD_ACTION_NTEVENTLOG           8316
#define IDD_ACTION_SCRIPT               8317
#define IDD_ACTION_CMDLINE              8318
#define IDD_ACTION_LOGFILE              8319
#define IDD_ACTION_EMAIL                8320
#define IDD_ACTION_PAGING               8321
#define IDD_ACTION_GENERAL              8322
#define IDD_THRESHOLD_MESSAGE           8323
#define IDD_ACTION_SCHEDULE             8324
#define IDD_DIALOG_BCC                  8325
#define IDD_DATAPOINT_ICMP              8326
#define IDD_DIALOG_DELETE_DATAGROUP     8327
#define IDD_DIALOG_DELETE_DATAPOINT     8328
#define IDD_THRESHOLD_EXPRESSION_OLD    8329
#define IDD_DATAPOINT_COM_PLUS          8330
#define ID_LISTHDRCONTEXT_FILTERBAR     32773

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2153
#define _APS_NEXT_COMMAND_VALUE         32774
#define _APS_NEXT_CONTROL_VALUE         2134
#define _APS_NEXT_SYMED_VALUE           2000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmtabview\hmtabview.cpp ===
// HMTabView.cpp : Implementation of CHMTabViewApp and DLL registration.

#include "stdafx.h"
#include "HMTabView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CHMTabViewApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x4fffc389, 0x2f1e, 0x11d3, { 0xbe, 0x10, 0, 0, 0xf8, 0x7a, 0x39, 0x12 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CHMTabViewApp::InitInstance - DLL initialization

BOOL CHMTabViewApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	AfxEnableControlContainer();

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CHMTabViewApp::ExitInstance - DLL termination

int CHMTabViewApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmtabview\ctrlwnd.cpp ===
// CtrlWnd.cpp : implementation file
//

#include "stdafx.h"
#include "CtrlWnd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CCtrlWnd,CWnd)

/////////////////////////////////////////////////////////////////////////////
// CCtrlWnd

CCtrlWnd::CCtrlWnd()
{
	EnableAutomation();
	m_wndControl.EnableAutomation();
}

CCtrlWnd::~CCtrlWnd()
{
}

BOOL CCtrlWnd::CreateControl(LPCTSTR lpszControlID)
{
	if( ! GetSafeHwnd() || ! ::IsWindow(GetSafeHwnd()) )
	{
		return FALSE;
	}

	if( m_wndControl.GetSafeHwnd() && ::IsWindow(m_wndControl.GetSafeHwnd()) )
	{
		m_wndControl.DestroyWindow();
	}

	CRect rc;
	GetClientRect(&rc);
	
	BOOL bResult = m_wndControl.CreateControl(lpszControlID,NULL,WS_VISIBLE|WS_TABSTOP,rc,this,152);

	return bResult;
}

CWnd* CCtrlWnd::GetControl()
{
	if( ! GetSafeHwnd() || ! ::IsWindow(GetSafeHwnd()) )
	{
		return NULL;
	}

	if( ! m_wndControl.GetSafeHwnd() || !::IsWindow(m_wndControl.GetSafeHwnd()) )
	{
		return NULL;
	}

	return &m_wndControl;
}

LPUNKNOWN CCtrlWnd::GetControlIUnknown()
{
	if( ! GetSafeHwnd() || ! ::IsWindow(GetSafeHwnd()) )
	{
		return NULL;
	}

	if( ! m_wndControl.GetSafeHwnd() || !::IsWindow(m_wndControl.GetSafeHwnd()) )
	{
		return NULL;
	}

	LPUNKNOWN pUnk = m_wndControl.GetControlUnknown();

	if( pUnk )
	{
		pUnk->AddRef();
	}

	return pUnk;
}

BEGIN_MESSAGE_MAP(CCtrlWnd, CWnd)
	//{{AFX_MSG_MAP(CCtrlWnd)
	ON_WM_PAINT()
	ON_WM_SIZE()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCtrlWnd message handlers

int CCtrlWnd::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	ShowWindow(SW_SHOW);
	
	return 0;
}

void CCtrlWnd::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	if( m_wndControl.GetSafeHwnd() && ::IsWindow(m_wndControl.GetSafeHwnd()) )
		return;

	CRect r;
	GetClientRect(&r);
	
	dc.FillSolidRect(r, GetSysColor(COLOR_3DFACE));
}

void CCtrlWnd::OnSize(UINT nType, int cx, int cy) 
{
	CWnd::OnSize(nType, cx, cy);
	
	if( ! m_wndControl.GetSafeHwnd() && ! ::IsWindow(m_wndControl.GetSafeHwnd()) )
		return;

	CRect rc;
	GetClientRect(&rc);

	m_wndControl.SetWindowPos(NULL,0,0,rc.Width(),rc.Height(),SWP_NOZORDER|SWP_NOMOVE|SWP_SHOWWINDOW);
}

void CCtrlWnd::PostNcDestroy() 
{
	CWnd::PostNcDestroy();

	delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmtabview\hmtabview.h ===
#if !defined(AFX_HMTABVIEW_H__4FFFC392_2F1E_11D3_BE10_0000F87A3912__INCLUDED_)
#define AFX_HMTABVIEW_H__4FFFC392_2F1E_11D3_BE10_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// HMTabView.h : main header file for HMTABVIEW.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CHMTabViewApp : See HMTabView.cpp for implementation.

class CHMTabViewApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMTABVIEW_H__4FFFC392_2F1E_11D3_BE10_0000F87A3912__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmtabview\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\instmof\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by trustmon.rc
//
#define IDS_PROJNAME                    100
#define IDS_HEALTHMONPRV_DESC               101
//#define IDR_TrustPrv                    102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmtabview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by HMTabView.rc
//

#define IDS_HMTABVIEW               1
#define IDS_HMTABVIEW_PPG           2

#define IDS_HMTABVIEW_PPG_CAPTION   200

#define IDD_PROPPAGE_HMTABVIEW      200

#define IDD_ABOUTBOX_HMTABVIEW      1

#define IDB_HMTABVIEW               1

#define IDI_ABOUTDLL				1

#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#define _APS_NEXT_COMMAND_VALUE         32768
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmtabview\hmtabviewppg.cpp ===
// HMTabViewPpg.cpp : Implementation of the CHMTabViewPropPage property page class.

#include "stdafx.h"
#include "HMTabView.h"
#include "HMTabViewPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CHMTabViewPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CHMTabViewPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CHMTabViewPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CHMTabViewPropPage, "HMTABVIEW.HMTabViewPropPage.1",
	0x4fffc38d, 0x2f1e, 0x11d3, 0xbe, 0x10, 0, 0, 0xf8, 0x7a, 0x39, 0x12)


/////////////////////////////////////////////////////////////////////////////
// CHMTabViewPropPage::CHMTabViewPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CHMTabViewPropPage

BOOL CHMTabViewPropPage::CHMTabViewPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_HMTABVIEW_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CHMTabViewPropPage::CHMTabViewPropPage - Constructor

CHMTabViewPropPage::CHMTabViewPropPage() :
	COlePropertyPage(IDD, IDS_HMTABVIEW_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CHMTabViewPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT

	SetHelpInfo(_T("Names to appear in the control"), _T("HMTABVIEW.HLP"), 0);
}


/////////////////////////////////////////////////////////////////////////////
// CHMTabViewPropPage::DoDataExchange - Moves data between page and properties

void CHMTabViewPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CHMTabViewPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CHMTabViewPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmtabview\hmtabviewppg.h ===
#if !defined(AFX_HMTABVIEWPPG_H__4FFFC39C_2F1E_11D3_BE10_0000F87A3912__INCLUDED_)
#define AFX_HMTABVIEWPPG_H__4FFFC39C_2F1E_11D3_BE10_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// HMTabViewPpg.h : Declaration of the CHMTabViewPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CHMTabViewPropPage : See HMTabViewPpg.cpp.cpp for implementation.

class CHMTabViewPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CHMTabViewPropPage)
	DECLARE_OLECREATE_EX(CHMTabViewPropPage)

// Constructor
public:
	CHMTabViewPropPage();

// Dialog Data
	//{{AFX_DATA(CHMTabViewPropPage)
	enum { IDD = IDD_PROPPAGE_HMTABVIEW };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CHMTabViewPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMTABVIEWPPG_H__4FFFC39C_2F1E_11D3_BE10_0000F87A3912__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmtabview\hmtabviewctl.h ===
#if !defined(AFX_HMTABVIEWCTL_H__4FFFC39A_2F1E_11D3_BE10_0000F87A3912__INCLUDED_)
#define AFX_HMTABVIEWCTL_H__4FFFC39A_2F1E_11D3_BE10_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// HMTabViewCtl.h : Declaration of the CHMTabViewCtrl ActiveX Control class.

#include "HMTabCtrl.h"
#include "..\splitter\CtrlWnd.h"

/////////////////////////////////////////////////////////////////////////////
// CHMTabViewCtrl : See HMTabViewCtl.cpp for implementation.

class CHMTabViewCtrl : public COleControl
{
	DECLARE_DYNCREATE(CHMTabViewCtrl)

// Constructor
public:
	CHMTabViewCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHMTabViewCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	//}}AFX_VIRTUAL

// Operations
public:
	void OnSelChangeTabs(int iItem);

// Child Members
protected:
	CHMTabCtrl m_TabCtrl;
	CTypedPtrArray<CObArray,CCtrlWnd*> m_Controls;

// Implementation
protected:
	~CHMTabViewCtrl();

	BEGIN_OLEFACTORY(CHMTabViewCtrl)        // Class factory and guid
		virtual BOOL VerifyUserLicense();
		virtual BOOL GetLicenseKey(DWORD, BSTR FAR*);
	END_OLEFACTORY(CHMTabViewCtrl)

	DECLARE_OLETYPELIB(CHMTabViewCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CHMTabViewCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CHMTabViewCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CHMTabViewCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CHMTabViewCtrl)
	afx_msg BOOL InsertItem(long lMask, long lItem, LPCTSTR lpszItem, long lImage, long lParam);
	afx_msg BOOL DeleteItem(long lItem);
	afx_msg BOOL DeleteAllItems();
	afx_msg BOOL CreateControl(long lItem, LPCTSTR lpszControlID);
	afx_msg LPUNKNOWN GetControl(long lItem);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CHMTabViewCtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CHMTabViewCtrl)
	dispidInsertItem = 1L,
	dispidDeleteItem = 2L,
	dispidDeleteAllItems = 3L,
	dispidCreateControl = 4L,
	dispidGetControl = 5L,
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMTABVIEWCTL_H__4FFFC39A_2F1E_11D3_BE10_0000F87A3912__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmtabview\hmtabviewctl.cpp ===
// HMTabViewCtl.cpp : Implementation of the CHMTabViewCtrl ActiveX Control class.

#include "stdafx.h"
#include "HMTabView.h"
#include "HMTabViewCtl.h"
#include "HMTabViewPpg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CHMTabViewCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CHMTabViewCtrl, COleControl)
	//{{AFX_MSG_MAP(CHMTabViewCtrl)
	ON_WM_CREATE()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CHMTabViewCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CHMTabViewCtrl)
	DISP_FUNCTION(CHMTabViewCtrl, "InsertItem", InsertItem, VT_BOOL, VTS_I4 VTS_I4 VTS_BSTR VTS_I4 VTS_I4)
	DISP_FUNCTION(CHMTabViewCtrl, "DeleteItem", DeleteItem, VT_BOOL, VTS_I4)
	DISP_FUNCTION(CHMTabViewCtrl, "DeleteAllItems", DeleteAllItems, VT_BOOL, VTS_NONE)
	DISP_FUNCTION(CHMTabViewCtrl, "CreateControl", CreateControl, VT_BOOL, VTS_I4 VTS_BSTR)
	DISP_FUNCTION(CHMTabViewCtrl, "GetControl", GetControl, VT_UNKNOWN, VTS_I4)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CHMTabViewCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CHMTabViewCtrl, COleControl)
	//{{AFX_EVENT_MAP(CHMTabViewCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CHMTabViewCtrl, 1)
	PROPPAGEID(CHMTabViewPropPage::guid)
END_PROPPAGEIDS(CHMTabViewCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CHMTabViewCtrl, "HMTABVIEW.HMTabViewCtrl.1",
	0x4fffc38c, 0x2f1e, 0x11d3, 0xbe, 0x10, 0, 0, 0xf8, 0x7a, 0x39, 0x12)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CHMTabViewCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DHMTabView =
		{ 0x4fffc38a, 0x2f1e, 0x11d3, { 0xbe, 0x10, 0, 0, 0xf8, 0x7a, 0x39, 0x12 } };
const IID BASED_CODE IID_DHMTabViewEvents =
		{ 0x4fffc38b, 0x2f1e, 0x11d3, { 0xbe, 0x10, 0, 0, 0xf8, 0x7a, 0x39, 0x12 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwHMTabViewOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CHMTabViewCtrl, IDS_HMTABVIEW, _dwHMTabViewOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CHMTabViewCtrl::CHMTabViewCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CHMTabViewCtrl

BOOL CHMTabViewCtrl::CHMTabViewCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_HMTABVIEW,
			IDB_HMTABVIEW,
			afxRegApartmentThreading,
			_dwHMTabViewOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// Licensing strings

static const TCHAR BASED_CODE _szLicFileName[] = _T("HMTabView.lic");

static const WCHAR BASED_CODE _szLicString[] =
	L"Copyright (c) 1999 Microsoft";


/////////////////////////////////////////////////////////////////////////////
// CHMTabViewCtrl::CHMTabViewCtrlFactory::VerifyUserLicense -
// Checks for existence of a user license

BOOL CHMTabViewCtrl::CHMTabViewCtrlFactory::VerifyUserLicense()
{
	return AfxVerifyLicFile(AfxGetInstanceHandle(), _szLicFileName,
		_szLicString);
}


/////////////////////////////////////////////////////////////////////////////
// CHMTabViewCtrl::CHMTabViewCtrlFactory::GetLicenseKey -
// Returns a runtime licensing key

BOOL CHMTabViewCtrl::CHMTabViewCtrlFactory::GetLicenseKey(DWORD dwReserved,
	BSTR FAR* pbstrKey)
{
	if (pbstrKey == NULL)
		return FALSE;

	*pbstrKey = SysAllocString(_szLicString);
	return (*pbstrKey != NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CHMTabViewCtrl::CHMTabViewCtrl - Constructor

CHMTabViewCtrl::CHMTabViewCtrl()
{
	InitializeIIDs(&IID_DHMTabView, &IID_DHMTabViewEvents);

	// TODO: Initialize your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CHMTabViewCtrl::~CHMTabViewCtrl - Destructor

CHMTabViewCtrl::~CHMTabViewCtrl()
{
	// TODO: Cleanup your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CHMTabViewCtrl::OnDraw - Drawing function

void CHMTabViewCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	pdc->FillSolidRect(rcBounds, GetSysColor(COLOR_3DFACE));
}


/////////////////////////////////////////////////////////////////////////////
// CHMTabViewCtrl::DoPropExchange - Persistence support

void CHMTabViewCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CHMTabViewCtrl::OnResetState - Reset control to default state

void CHMTabViewCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CHMTabViewCtrl::AboutBox - Display an "About" box to the user

void CHMTabViewCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_HMTABVIEW);
	dlgAbout.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// Operations

void CHMTabViewCtrl::OnSelChangeTabs(int iItem)
{
	CCtrlWnd* pWnd = NULL;	
	for( int i = 0; i < m_Controls.GetSize(); i++ )
	{		
		if( i == iItem )
		{
			pWnd = m_Controls[i];
		}
		else
		{
			m_Controls[i]->ShowWindow(SW_HIDE);
		}
	}

	if( pWnd )
	{
		pWnd->ShowWindow(SW_SHOW);
		pWnd->Invalidate(TRUE);
		pWnd->UpdateWindow();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CHMTabViewCtrl message handlers

int CHMTabViewCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	m_TabCtrl.Create( TCS_TABS | TCS_FLATBUTTONS | WS_CHILD | WS_VISIBLE, CRect(0,0,10,10), this, 0x1006);

	// init position for the window
	int cx=-1;
	int cy=-1;
	GetControlSize(&cx,&cy);

	m_TabCtrl.SetWindowPos(NULL,0,0,cx,cy-2,SWP_NOZORDER|SWP_SHOWWINDOW);

	return 0;
}

void CHMTabViewCtrl::OnSize(UINT nType, int cx, int cy) 
{
	COleControl::OnSize(nType, cx, cy);
	
	if( GetSafeHwnd() )
	{
		CRect rcControl;
		GetClientRect(rcControl);
		
		m_TabCtrl.SetWindowPos(NULL,0,0,rcControl.Width(),rcControl.Height()-2,SWP_NOZORDER|SWP_SHOWWINDOW);

		CRect rcDisplay;
		m_TabCtrl.GetWindowRect(rcDisplay);
		ScreenToClient(rcDisplay);
		m_TabCtrl.AdjustRect(FALSE,rcDisplay);
		rcDisplay.top += 4;
		rcDisplay.bottom -= 8;
		for( int i = 0; i < m_Controls.GetSize(); i++ )
		{			
			m_Controls[i]->SetWindowPos(NULL,rcDisplay.left,rcDisplay.top,rcDisplay.Width(),rcDisplay.Height(),SWP_NOZORDER);
			if( m_TabCtrl.GetCurSel() != i )
			{
				m_Controls[i]->ShowWindow(SW_HIDE);
			}
		}	
	}
}

BOOL CHMTabViewCtrl::InsertItem(long lMask, long lItem, LPCTSTR lpszItem, long lImage, long lParam) 
{
	CCtrlWnd* pCtrlWnd = new CCtrlWnd;
	if( ! pCtrlWnd->Create(NULL,NULL,WS_CHILD,CRect(0,0,10,10),&m_TabCtrl,500+lItem) )
	{
		delete pCtrlWnd;
		return FALSE;
	}

	m_Controls.InsertAt(lItem,pCtrlWnd);
	CRect rcDisplay;
	GetClientRect(rcDisplay);
	m_TabCtrl.AdjustRect(FALSE,rcDisplay);
	pCtrlWnd->SetWindowPos(NULL,rcDisplay.left,rcDisplay.top,rcDisplay.Width(),rcDisplay.Height(),SWP_NOZORDER);

	if( lItem == 0 )
	{
		pCtrlWnd->ShowWindow(SW_SHOW);
	}
	else
	{
		pCtrlWnd->ShowWindow(SW_HIDE);
		m_Controls[0]->Invalidate();
		m_Controls[0]->UpdateWindow();
	}

	return m_TabCtrl.InsertItem(lMask,lItem,lpszItem,lImage,lParam);
}

BOOL CHMTabViewCtrl::DeleteItem(long lItem) 
{
	if( lItem >= m_Controls.GetSize() || lItem < 0 )
	{
		return FALSE;
	}

	m_Controls[lItem]->DestroyWindow();
	m_Controls.RemoveAt(lItem);
	return m_TabCtrl.DeleteItem(lItem);
}

BOOL CHMTabViewCtrl::DeleteAllItems() 
{
	for( int i = 0; i < m_Controls.GetSize(); i++ )
	{
		m_Controls[i]->DestroyWindow();
	}
	return m_TabCtrl.DeleteAllItems();
}

BOOL CHMTabViewCtrl::CreateControl(long lItem, LPCTSTR lpszControlID) 
{
	if( lItem >= m_Controls.GetSize() || lItem < 0 )
	{
		return FALSE;
	}

	CCtrlWnd* pCtrlWnd = m_Controls[lItem];
	if( pCtrlWnd == NULL )
	{
		return FALSE;
	}

	BOOL bResult = pCtrlWnd->CreateControl(lpszControlID);
	pCtrlWnd->ShowWindow(SW_SHOW);
	pCtrlWnd->Invalidate();
	pCtrlWnd->UpdateWindow();

	return bResult;
}

LPUNKNOWN CHMTabViewCtrl::GetControl(long lItem) 
{
	if( lItem >= m_Controls.GetSize() || lItem < 0 )
	{
		return NULL;
	}

	return m_Controls[lItem]->GetControlIUnknown();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\hmtabview\stdafx.h ===
#if !defined(AFX_STDAFX_H__4FFFC390_2F1E_11D3_BE10_0000F87A3912__INCLUDED_)
#define AFX_STDAFX_H__4FFFC390_2F1E_11D3_BE10_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Comon Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes
#include <afxtempl.h>		// MFC Template classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4FFFC390_2F1E_11D3_BE10_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\action.cpp ===
// Action.cpp: implementation of the CAction class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "Action.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CAction,CHMObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAction::CAction()
{
  m_pActionStatusListener = NULL;
}

CAction::~CAction()
{
  DestroyStatusListener();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\instmof\instmof.cpp ===
#define _WIN32_DCOM
#define RCLENGTH 20

#include <objbase.h>
#include <winsvc.h>
#include <tchar.h>
#include <stdio.h>
#include <wbemcli.h>


#ifdef SAVE_ERIC
HRESULT DelNamespace (IWbemLocator *pWbemLocator, BSTR bsParentNamespace, BSTR bsTargetNamespace)
{
	HRESULT hres = 0;
	IWbemServices *pWbemServices = NULL;

	hres = pWbemLocator->ConnectServer(bsParentNamespace,
										NULL,
										NULL,
										NULL,
										0L,
										NULL,
										NULL,
										&pWbemServices);
	if (FAILED(hres))
	{
		OutputDebugString("Could not connect to parent namespace.\n");
		return hres;
	}
	
	hres = pWbemServices->DeleteInstance(bsTargetNamespace,
										  NULL,
										  NULL,
										  NULL);

	pWbemServices->Release();
	pWbemServices = NULL;

	return hres;
}

HRESULT clean()
{
	OutputDebugString("clean function\n");

	HRESULT hres = CoInitialize(NULL);

	hres = CoInitializeSecurity(NULL, -1, NULL, NULL, 
								RPC_C_AUTHN_LEVEL_CONNECT, 
								RPC_C_IMP_LEVEL_IMPERSONATE, 
								NULL, 0, 0);

	if (FAILED(hres))
	{
		OutputDebugString("CoInitializeSecurity Failed\n");
		return hres;
	}

	IWbemLocator *pIWbemLocator = NULL;

	hres = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
					        IID_IWbemLocator, (LPVOID *) &pIWbemLocator);
	if (FAILED(hres))
	{
		OutputDebugString("CoCreateInstance Failed\n");
		CoUninitialize();
		return hres;
	}

	BSTR bsParentNS = NULL;
	BSTR bsTargetNS = NULL;

	// Delete root\healthmon namespace if exists
	bsParentNS = SysAllocString (L"\\\\.\\root");
	bsTargetNS = SysAllocString (L"__namespace.name=\"HealthMon\"");

	hres = DelNamespace(pIWbemLocator, bsParentNS, bsTargetNS);

	SysFreeString(bsParentNS);
	SysFreeString(bsTargetNS);

	if (FAILED(hres))
	{
		OutputDebugString("Could not delete root\\healthmon\n");
	}

	// Delete root\cimv2\MicrosoftHealthMonitor namespace if exists
	bsParentNS = SysAllocString (L"\\\\.\\root\\cimv2");
	bsTargetNS = SysAllocString (L"__namespace.name=\"MicrosoftHealthMonitor\"");

	hres = DelNamespace(pIWbemLocator, bsParentNS, bsTargetNS);

	SysFreeString(bsParentNS);
	SysFreeString(bsTargetNS);

	if (FAILED(hres))
	{
		OutputDebugString("Could not delete root\\cimv2\\MicrosoftHealthMonitor\n");
	}
	
	pIWbemLocator->Release();
	pIWbemLocator = NULL;
	

	StopWMI();

	CoUninitialize();

	return TRUE;
}
#endif


int upgrade()
{
	OutputDebugString(L"upgrade function\n");
	return FALSE;
}
#ifdef SAVE_ERIC
BOOL MofComp(LPDLLCALLPARAMS lpDllParams)
{
#ifdef DEBUG
	__asm int 3
#endif

	HRESULT hres = S_OK;
	TCHAR *pszBuffer = NULL;
	pszBuffer = new TCHAR[MAX_STRING_LEN];

    // Set the startup structure
    //==========================
	if (strlen(lpDllParams->lpszParam) == 0)
	{	
		OutputDebugString (_T("Invalid Parameter\r\n"));
		
		LoadString(hInstance, INVALID_PATH, pszBuffer, MAX_STRING_LEN);
		SetVariable(lpDllParams, ERROR_TEXT, pszBuffer);
		pszBuffer[0]=NULL;

		SetVariable(lpDllParams, ERROR_FACILITY, lpDllParams->lpszParam);
	
		delete[] pszBuffer;
		return FALSE;
	}
	
	IMofCompiler* pCompiler = NULL;

	hres = CoInitialize(NULL);

	if (FAILED(hres))
	{
		OutputDebugString (_T("CoInitialize failed\r\n"));

		SetRC (lpDllParams, hres);

		LoadString(hInstance, COINIT_FAILED, pszBuffer, MAX_STRING_LEN);
		SetVariable(lpDllParams, ERROR_TEXT, pszBuffer);
		pszBuffer[0]=NULL;

		LoadString(hInstance, FACILITY_DCOM, pszBuffer, MAX_STRING_LEN);
		SetVariable(lpDllParams, ERROR_FACILITY, pszBuffer);
		pszBuffer[0]=NULL;

		delete[] pszBuffer;
		return FALSE;
	}

	hres = CoCreateInstance(CLSID_MofCompiler,
						  0,
						  CLSCTX_INPROC_SERVER,
						  IID_IMofCompiler,
						  (LPVOID *) &pCompiler);
	
	if (FAILED(hres))
	{
		OutputDebugString(_T("CoCreateInstance failed\r\n"));

		SetRC (lpDllParams, hres);

		LoadString(hInstance, CO_CREATE_INST_FAILED, pszBuffer, MAX_STRING_LEN);
		pszBuffer[0]=NULL;
		SetVariable(lpDllParams, ERROR_TEXT, pszBuffer);
		
		LoadString(hInstance, FACILITY_DCOM, pszBuffer, MAX_STRING_LEN);
		SetVariable(lpDllParams, ERROR_FACILITY, pszBuffer);
		pszBuffer[0]=NULL;

		CoUninitialize();

		delete[] pszBuffer;
		return FALSE;
	}

	WCHAR MofPath[MAX_PATH]; 
	MofPath[0]=0;
	int rc = 0;
	
	rc = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS,
						lpDllParams->lpszParam, strlen(lpDllParams->lpszParam),
						MofPath, MAX_PATH);
	MofPath[rc] = NULL;					// NULL termanate string
		
	if (rc == 0)
	{
		hres = GetLastError();
		
		SetRC (lpDllParams, hres);

		LoadString(hInstance, CONVT_PATH_FAILED, pszBuffer, MAX_STRING_LEN);
		SetVariable(lpDllParams, ERROR_TEXT, pszBuffer);
		pszBuffer[0]=NULL;

		OutputDebugString(_T("could not convert path to WCHAR\r\n"));

#ifdef _DEBUG
		if (hres == ERROR_INSUFFICIENT_BUFFER)
			OutputDebugString(_T("ERROR_INSUFFICIENT_BUFFER\r\n"));
		if (hres == ERROR_INVALID_FLAGS)
			OutputDebugString(_T("ERROR_INVALID_FLAGS\r\n"));
		if (hres == ERROR_INVALID_PARAMETER)
			OutputDebugString(_T("ERROR_INVALID_PARAMETER\r\n"));
		if (hres == ERROR_NO_UNICODE_TRANSLATION)
			OutputDebugString(_T("ERROR_NO_UNICODE_TRANSLATION\r\n"));
#endif

		CoUninitialize();

		delete[] pszBuffer;
		return FALSE;
	}

	WBEM_COMPILE_STATUS_INFO info;		
	char *OldWDir = NULL;
	char *NewWDir = NULL;
	OldWDir = new char[MAX_PATH*4];
	NewWDir = new char[MAX_PATH*4];
	
	GetVariable (lpDllParams, TEMP_DIR, NewWDir);

	_getcwd (OldWDir, MAX_PATH*4);
	if ( _chdir (NewWDir) )
	{
		GetVariable (lpDllParams, INSTALL_DIR, NewWDir);
		if ( _chdir (NewWDir) )
		{
			OutputDebugString(_T("could not set working dir\r\n"));
			_chdir (OldWDir);
		}
	}

	hres = pCompiler->CompileFile(MofPath,					//FileName
								NULL,						//ServerAndNamespace
								NULL,						//Username
								NULL,						//Authority
								NULL,						//password
								NULL,						//lOptionFlags---WBEM_FLAG_CONSOLE_PRINT output to a console window
								NULL,						//lClassFlags
								NULL,						//lInstanceFlags
								&info);						//pWbem_Compile_Status_Info
	pCompiler->Release();

	_chdir (OldWDir);

	delete[] OldWDir;
	delete[] NewWDir;
	OldWDir = NULL;
	NewWDir = NULL;

	if (hres == S_OK)
	{
		OutputDebugString(_T("Compiled file\r\n"));

		CoUninitialize();

		delete[] pszBuffer;
		return TRUE;
	}

	SetRC(lpDllParams, info.hRes);

	char RCLoc[MAX_STRING_LEN];
	if (info.ObjectNum == 0)
	{
		LoadString(hInstance, PHASE_ONLY, pszBuffer, MAX_STRING_LEN);
		sprintf (RCLoc, pszBuffer, info.lPhaseError);
	}
	else
	{
		LoadString(hInstance, PHASE_OBJECT_COMBO, pszBuffer, MAX_STRING_LEN);
		sprintf (RCLoc, pszBuffer, info.lPhaseError, info.ObjectNum,
			info.FirstLine, info.LastLine);
	}

	SetVariable(lpDllParams, ERROR_LOCATION, RCLoc);

#ifdef _DEBUG
	sprintf (RCLoc, "hres: %d\r\n", hres);
	OutputDebugString(RCLoc);
#endif

	if ((info.hRes > S_OK) && (info.hRes < MAX_MOFCOMP_ERRORS))			// syntax error while parsing
	{
		LoadString(hInstance, SYNTAX_FILE_ERROR, pszBuffer, MAX_STRING_LEN);
		SetVariable(lpDllParams, ERROR_TEXT, pszBuffer);
		pszBuffer[0]=NULL;

		char pszFacilityText[MAX_STRING_LEN];
		char pszMofFile[MAX_STRING_LEN];
		
		GetVariable(lpDllParams, MOF_FILE_NAME, pszMofFile);
		LoadString(hInstance, MOF_FILE_SPRINTF_STRING, pszBuffer, MAX_STRING_LEN);
		sprintf(pszFacilityText, pszBuffer, pszMofFile);
		SetVariable(lpDllParams, ERROR_FACILITY, pszFacilityText);

		OutputDebugString(_T("syntax or file error\r\n"));

		CoUninitialize();
		
		delete[] pszBuffer;
		return FALSE;
	}
	// WMI error while putting information
	HRESULT hr = 0;
	IWbemStatusCodeText * pSCText = NULL;

	hr = CoCreateInstance(CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
							IID_IWbemStatusCodeText, (LPVOID *) &pSCText);

	if (!SUCCEEDED(hr))
	{
		OutputDebugString(_T("could not instanciate WbemStatusCodeText\r\n"));

		LoadString(hInstance, UNKNOWN_ERROR, pszBuffer, MAX_STRING_LEN);
		SetVariable(lpDllParams, ERROR_TEXT, pszBuffer);
		pszBuffer[0]=NULL;

		CoUninitialize();

		delete[] pszBuffer;
		return FALSE;
	}

	BSTR bstr = 0;

	hr = pSCText->GetErrorCodeText(info.hRes, 0, 0, &bstr);
	if(hr == S_OK)
	{
		int size = 0;
		size = wcstombs(NULL, bstr, SysStringLen(bstr));
		char* pszErrorText = new char[size+1];
		wcstombs(pszErrorText, bstr, SysStringLen(bstr));
		pszErrorText[size]=NULL;
		SetVariable(lpDllParams, ERROR_TEXT, pszErrorText);
		delete[] pszErrorText;
		SysFreeString(bstr);
		bstr = 0;
	}

	hr = pSCText->GetFacilityCodeText(info.hRes, 0, 0, &bstr);
	if(hr == S_OK)
	{
		int size = 0;
		size = wcstombs(NULL, bstr, SysStringLen(bstr));
		char* pszFacilityText = new char[size+1];
		wcstombs(pszFacilityText, bstr, SysStringLen(bstr));
		pszFacilityText[size]=NULL;
		SetVariable(lpDllParams, ERROR_FACILITY, pszFacilityText);
		delete[] pszFacilityText;
		SysFreeString(bstr);
		bstr = 0;
	}
	pSCText->Release();
	
	OutputDebugString(_T("end\r\n"));

	CoUninitialize();

	delete[] pszBuffer;
	return FALSE;
}
#endif


int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
	_strupr (lpCmdLine);
	
#ifdef SAVE_ERIC
	if (strstr(lpCmdLine, "/CLEAN"))
	{
		OutputDebugString(L"clean command line\n");
		return clean();
	}

	if (strstr(lpCmdLine, "/UPGRADE"))
	{
		OutputDebugString("upgrade command line\n");
//		return upgrade();
	}
#endif
	
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\action.h ===
// Action.h: interface for the CAction class.
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03/18/00 v-marfin : bug 59492 : Changed CActionStatusListener from protected to public
//                     for access in CActionPolicy::CreateNewChildAction(). See comments there.
//
// 
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACTION_H__10AC036A_5D70_11D3_939D_00A0CC406605__INCLUDED_)
#define AFX_ACTION_H__10AC036A_5D70_11D3_939D_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMObject.h"
#include "ActionScopeItem.h"
#include "ActionStatusListener.h"

class CAction : public CHMObject  
{

DECLARE_DYNCREATE(CAction)

// construction/destruction
public:
	CAction();
	virtual ~CAction();

// WMI Operations
public:
	CString GetObjectPath();
	CString GetConsumerClassName() { return m_sConsumerClassName; }
	CWbemClassObject* GetConsumerClassObject();
	CWbemClassObject* GetAssociatedConfigObjects();
	CWbemClassObject* GetAssociationObjects();
	CWbemClassObject* GetA2CAssociation(const CString& sConfigGuid);
	CString GetConditionString(const CString& sConfigGuid);
  bool CreateStatusListener();
  void DestroyStatusListener();

    // v-marfin 59492 : Added this function to get the state at load time
  CString GetStatusObjectPath();

  // v-marfin : bug 59492 : Changed CActionStatusListener from protected to public
  //            for access in CActionPolicy::CreateNewChildAction(). See comments there.
  CActionStatusListener* m_pActionStatusListener;  
protected:	
	CString m_sConsumerClassName;

// Clipboard Operations
public:
	virtual bool Cut();
	virtual bool Copy();
	virtual bool Paste();

// Operations
public:
	virtual bool Refresh();

// Scope Item Members
public:
	virtual CScopePaneItem* CreateScopeItem();

// Action Type Info
public:
	CString GetTypeGuid();
	void SetTypeGuid(const CString& sGuid);
	int GetType();
	void SetType(int iType);
	CString GetUITypeName();
protected:
	int m_iType;
	CString m_sTypeGuid;

};

#include "Action.inl"

#endif // !defined(AFX_ACTION_H__10AC036A_5D70_11D3_939D_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionassociationpage.cpp ===
// ActionAssociationPage.cpp : implementation file
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03/23/00 v-marfin 61667 : Display MsgBox explaining that user needs to first 
//                           create an action before attempting to create a new
//                           association (if there are no actions defined).
// 03/23/00 v-marfin 62207 : In GetC2AAssociation(), check for passed GUID and if a singleton do not
//                           enclose in braces when formatting the query.
// 03/24/00 v-marfin 62192 : help link fix.
// 04/05/00 v-marfin 59643b : unmarshal connection OnInitDialog.


#include "stdafx.h"
#include "snapin.h"
#include "HMPropertyPage.h"
#include "ActionAssociationPage.h"
#include "NewActionAssociationDlg.h"
#include "Action.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CActionAssociationPage property page

IMPLEMENT_DYNCREATE(CActionAssociationPage, CHMPropertyPage)

CActionAssociationPage::CActionAssociationPage() : CHMPropertyPage(CActionAssociationPage::IDD)
{
	//{{AFX_DATA_INIT(CActionAssociationPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_sHelpTopic = _T("HMon21.chm::/dTHact.htm");  // v-marfin 62192 : help link fix
}

CActionAssociationPage::~CActionAssociationPage()
{
}

inline CWbemClassObject* CActionAssociationPage::GetAssociatedActions()
{
	// execute the query for actions
	CWbemClassObject* pActionConfigObject = new CWbemClassObject;
	CString sQuery;
	CString sGuid = GetObjectPtr()->GetGuid();
	if( sGuid == _T("@") ) // it is a System object... singleton class
	{
		sQuery = _T("ASSOCIATORS OF {Microsoft_HMSystemConfiguration=@} WHERE ResultClass=Microsoft_HMActionConfiguration");
	}
	else // it is an object beneath the system
	{
		sQuery.Format(IDS_STRING_C2A_ASSOC_QUERY,sGuid);
	}

	if( ! CHECKHRESULT(pActionConfigObject->Create(GetObjectPtr()->GetSystemName())) )
	{
		return NULL;
	}

	BSTR bsQuery = sQuery.AllocSysString();

	if( ! CHECKHRESULT(pActionConfigObject->ExecQuery(bsQuery)) )
	{
		::SysFreeString(bsQuery);
		return NULL;
	}

	::SysFreeString(bsQuery);


	return pActionConfigObject;
}

inline CString CActionAssociationPage::GetConditionString(const CString& sActionConfigGuid)
{
	CWbemClassObject* pA2CAssociation = GetA2CAssociation(sActionConfigGuid);
	if( ! pA2CAssociation )
	{
		return _T("");
	}

	CString sQuery;
	CString sCondition;
	CString sResString;

	pA2CAssociation->GetProperty(_T("Query"),sQuery);

	sQuery.MakeUpper();

	if( sQuery.Find(_T("TARGETINSTANCE.STATE=0")) != -1 )
	{
		sResString.LoadString(IDS_STRING_NORMAL);
		sCondition += sResString + _T(",");
	}

	if( sQuery.Find(_T("TARGETINSTANCE.STATE=8")) != -1 )
	{
		sResString.LoadString(IDS_STRING_WARNING);
		sCondition += sResString + _T(",");
	}

	if( sQuery.Find(_T("TARGETINSTANCE.STATE=9")) != -1 )
	{
		sResString.LoadString(IDS_STRING_CRITICAL);
		sCondition += sResString + _T(",");
	}

	if( sQuery.Find(_T("TARGETINSTANCE.STATE=7")) != -1 )
	{
		sResString.LoadString(IDS_STRING_NODATA);
		sCondition += sResString + _T(",");
	}

	if( sQuery.Find(_T("TARGETINSTANCE.STATE=4")) != -1 )
	{
		sResString.LoadString(IDS_STRING_DISABLED);
		sCondition += sResString + _T(",");
	}

	sCondition.TrimRight(_T(","));

	delete pA2CAssociation;

	return sCondition;
}

inline CWbemClassObject* CActionAssociationPage::GetA2CAssociation(const CString& sActionConfigGuid)
{
	CString sActionPath;
	sActionPath.Format(_T("Microsoft_HMActionConfiguration.GUID=\"%s\""),sActionConfigGuid);

	CString sQuery;
	sQuery.Format(_T("REFERENCES OF {%s} WHERE ResultClass=Microsoft_HMConfigurationActionAssociation Role=ChildPath"),sActionPath);

	CWbemClassObject* pAssociation = new CWbemClassObject;

	pAssociation->Create(GetObjectPtr()->GetSystemName());
	BSTR bsQuery = sQuery.AllocSysString();
	if( ! CHECKHRESULT(pAssociation->ExecQuery(bsQuery)) )
	{
		::SysFreeString(bsQuery);
    delete pAssociation;
		return NULL;
	}
	::SysFreeString(bsQuery);

	CString sParentPath;		
	CString sEventFilterPath;
	ULONG ulReturned = 0L;		

	while( pAssociation->GetNextObject(ulReturned) == S_OK && ulReturned > 0 )
	{
		pAssociation->GetProperty(_T("ParentPath"),sParentPath);
		if( sParentPath.Find(GetObjectPtr()->GetGuid()) != -1 )
		{
			break;
		}			
	}

	return pAssociation;
}

inline CWbemClassObject* CActionAssociationPage::GetC2AAssociation(const CString& sConfigGuid)
{

	CString sConfigPath;

    // v-marfin : 62207 
    // If incoming GUID is a singleton, do not format it as a normal GUID since that causes the
    // qeury to fail with invalid object path msg. 
    // For this the query should be:
    //
    //      References of {Microsoft_HMConfiguration.GUID="@"}  
    //      where ResultClass=Microsoft_HMConfigurationActionAssociation Role=ParentPath
    //
    // Which is basically the same query being used except without the braces around the GUID.
    //
    //
    CString sGUID;

    // Is passed parm a singleton?
    if (sConfigGuid == _T("@"))
    {
        sGUID = sConfigGuid;    // yes, do not enclose in braces.
    }
    else
    {
        sGUID.Format(_T("{%s}"),sConfigGuid); // no, enclose in braces
    }

	sConfigPath.Format(_T("Microsoft_HMConfiguration.GUID=\"%s\""),sGUID);

	CString sQuery;
	sQuery.Format(_T("REFERENCES OF {%s} WHERE ResultClass=Microsoft_HMConfigurationActionAssociation Role=ParentPath"),sConfigPath);

	CWbemClassObject* pAssociation = new CWbemClassObject;

	pAssociation->Create(GetObjectPtr()->GetSystemName());
	BSTR bsQuery = sQuery.AllocSysString();
	if( ! CHECKHRESULT(pAssociation->ExecQuery(bsQuery)) )
	{
		::SysFreeString(bsQuery);
    delete pAssociation;
		return NULL;
	}
	::SysFreeString(bsQuery);

	return pAssociation;
}

void CActionAssociationPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CActionAssociationPage)
	DDX_Control(pDX, IDC_LIST_ACTIONS, m_ActionsList);
	DDX_Control(pDX, IDC_BUTTON_PROPERTIES, m_PropertiesButton);
	DDX_Control(pDX, IDC_BUTTON_NEW, m_NewButton);
	DDX_Control(pDX, IDC_BUTTON_DELETE, m_DeleteButton);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CActionAssociationPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CActionAssociationPage)
	ON_WM_DESTROY()
	ON_NOTIFY(NM_CLICK, IDC_LIST_ACTIONS, OnClickListActions)
	ON_BN_CLICKED(IDC_BUTTON_PROPERTIES, OnButtonProperties)
	ON_BN_CLICKED(IDC_BUTTON_NEW, OnButtonNew)
	ON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST_ACTIONS, OnDblclkListActions)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CActionAssociationPage message handlers

BOOL CActionAssociationPage::OnInitDialog() 
{
	// unmarshal connmgr //59643b
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();
	
	// create the tooltip
	EnableToolTips();
	m_ToolTip.Create(this,TTS_ALWAYSTIP);
	m_ToolTip.AddTool(&m_NewButton,IDS_STRING_TOOLTIP_NEW);
	m_ToolTip.AddTool(&m_PropertiesButton,IDS_STRING_TOOLTIP_PROPERTY);
	m_ToolTip.AddTool(&m_DeleteButton,IDS_STRING_TOOLTIP_DELETE);
	m_ToolTip.Activate(TRUE);

	// create bitmaps and init each bitmap button	
	CBitmap bitmap;
	bitmap.LoadBitmap(IDB_BITMAP_NEW);
	m_hNewBitmap = (HBITMAP)bitmap.Detach();

	bitmap.LoadBitmap(IDB_BITMAP_PROPERTIES);
	m_hPropertiesBitmap = (HBITMAP)bitmap.Detach();

	bitmap.LoadBitmap(IDB_BITMAP_DELETE);
	m_hDeleteBitmap = (HBITMAP)bitmap.Detach();

	SendDlgItemMessage(IDC_BUTTON_NEW,BM_SETIMAGE,IMAGE_BITMAP,(LPARAM)m_hNewBitmap);
	SendDlgItemMessage(IDC_BUTTON_PROPERTIES,BM_SETIMAGE,IMAGE_BITMAP,(LPARAM)m_hPropertiesBitmap);
	SendDlgItemMessage(IDC_BUTTON_DELETE,BM_SETIMAGE,IMAGE_BITMAP,(LPARAM)m_hDeleteBitmap);

	// add columns to the listctrl
	CString sTitle;

	sTitle.LoadString(IDS_STRING_NAME);
	m_ActionsList.InsertColumn(0,sTitle,LVCFMT_LEFT,LVSCW_AUTOSIZE_USEHEADER);

	sTitle.LoadString(IDS_STRING_GUID);
	m_ActionsList.InsertColumn(1,sTitle,LVCFMT_LEFT,0);

	sTitle.LoadString(IDS_STRING_CONDITION);
	m_ActionsList.InsertColumn(2,sTitle,LVCFMT_LEFT,LVSCW_AUTOSIZE);

	sTitle.LoadString(IDS_STRING_THROTTLE_TIME);
	m_ActionsList.InsertColumn(3,sTitle,LVCFMT_RIGHT,LVSCW_AUTOSIZE_USEHEADER);

	sTitle.LoadString(IDS_STRING_REMINDER_TIME);
	m_ActionsList.InsertColumn(4,sTitle,LVCFMT_RIGHT,LVSCW_AUTOSIZE_USEHEADER);

	sTitle.LoadString(IDS_STRING_COMMENT);
	m_ActionsList.InsertColumn(5,sTitle,LVCFMT_LEFT,LVSCW_AUTOSIZE_USEHEADER);


	m_ActionsList.SetColumnWidth(0,LVSCW_AUTOSIZE_USEHEADER);
	m_ActionsList.SetColumnWidth(1,0);
	m_ActionsList.SetColumnWidth(2,LVSCW_AUTOSIZE_USEHEADER);
	m_ActionsList.SetColumnWidth(3,LVSCW_AUTOSIZE_USEHEADER);
  m_ActionsList.SetColumnWidth(4,LVSCW_AUTOSIZE_USEHEADER);
  m_ActionsList.SetColumnWidth(5,LVSCW_AUTOSIZE_USEHEADER);

	CWbemClassObject* pAssociation = GetC2AAssociation(GetObjectPtr()->GetGuid());  
	if( ! pAssociation )
	{
		return TRUE;
	}

	bool bFound = false;
	ULONG ulReturned = 0L;
	while( pAssociation->GetNextObject(ulReturned) == S_OK && ulReturned > 0 )
	{
    // get the action config object
    CString sActionPath;
    pAssociation->GetProperty(_T("ChildPath"),sActionPath);

    CWbemClassObject* pActionConfigObject = new CWbemClassObject;
    pActionConfigObject->Create(GetObjectPtr()->GetSystemName());
    
    if( CHECKHRESULT(pActionConfigObject->GetObject(sActionPath)) )
    {
      int iValue = -1;
		  CString sValue;	
		  pActionConfigObject->GetLocaleStringProperty(IDS_STRING_MOF_NAME,sValue);

		  int iIndex = m_ActionsList.InsertItem(0,sValue);

		  // set the GUID of the ActionConfig
		  pActionConfigObject->GetProperty(IDS_STRING_MOF_GUID,sValue);
		  m_ActionsList.SetItem(iIndex,1,LVIF_TEXT,sValue,NULL,NULL,NULL,NULL);

		  // set the Condition
		  sValue = GetConditionString(sValue);
		  m_ActionsList.SetItem(iIndex,2,LVIF_TEXT,sValue,NULL,NULL,NULL,NULL);		

      // set throttle time
      pAssociation->GetProperty(_T("ThrottleTime"),iValue);
      sValue.Format(_T("%d"),iValue);
      m_ActionsList.SetItem(iIndex,3,LVIF_TEXT,sValue,NULL,NULL,NULL,NULL);		

      // set reminder time
      pAssociation->GetProperty(_T("ReminderTime"),iValue);
      sValue.Format(_T("%d"),iValue);
      m_ActionsList.SetItem(iIndex,4,LVIF_TEXT,sValue,NULL,NULL,NULL,NULL);		

		  // set the Description
		  pActionConfigObject->GetLocaleStringProperty(IDS_STRING_MOF_DESCRIPTION,sValue);
		  m_ActionsList.SetItem(iIndex,5,LVIF_TEXT,sValue,NULL,NULL,NULL,NULL);		
		  bFound = true;
    }

    delete pActionConfigObject;
	}

	if( bFound )
	{
		m_ActionsList.SetColumnWidth(0,LVSCW_AUTOSIZE);
		m_ActionsList.SetColumnWidth(2,LVSCW_AUTOSIZE_USEHEADER);
	}

  delete pAssociation;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CActionAssociationPage::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) 
{
	MSG msg;
	PeekMessage(&msg,GetSafeHwnd(),0,0,PM_NOREMOVE);
	if( m_ToolTip.GetSafeHwnd() )
	{
		m_ToolTip.RelayEvent(&msg);
		m_ToolTip.Activate(TRUE);
	}

	return CHMPropertyPage::WindowProc(message, wParam, lParam);
}

void CActionAssociationPage::OnDestroy() 
{
	CHMPropertyPage::OnDestroy();
	
	DeleteObject(m_hNewBitmap);
	DeleteObject(m_hPropertiesBitmap);
	DeleteObject(m_hDeleteBitmap);	

    //59643
    CnxPropertyPageDestroy();		

}

void CActionAssociationPage::OnClickListActions(NMHDR* pNMHDR, LRESULT* pResult) 
{
	POSITION pos = m_ActionsList.GetFirstSelectedItemPosition();
	int iIndex = 0;
	if( pos )
	{	
		GetDlgItem(IDC_BUTTON_PROPERTIES)->EnableWindow(TRUE);
		GetDlgItem(IDC_BUTTON_DELETE)->EnableWindow(TRUE);
		
		iIndex = m_ActionsList.GetNextSelectedItem(pos);
	}
	else
	{
		GetDlgItem(IDC_BUTTON_PROPERTIES)->EnableWindow(FALSE);
		GetDlgItem(IDC_BUTTON_DELETE)->EnableWindow(FALSE);
	}
	
	*pResult = 0;
}

void CActionAssociationPage::OnButtonProperties() 
{
	POSITION pos = m_ActionsList.GetFirstSelectedItemPosition();
	int iIndex = 0;
	if( pos )
	{	
		iIndex = m_ActionsList.GetNextSelectedItem(pos);
		CString sActionName = m_ActionsList.GetItemText(iIndex,0);
		CString sGuid = m_ActionsList.GetItemText(iIndex,1);

		CString sActionPath;
		sActionPath.Format(_T("Microsoft_HMActionConfiguration.GUID=\"%s\""),sGuid);
	
		CString sQuery;
		sQuery.Format(_T("REFERENCES OF {%s} WHERE ResultClass=Microsoft_HMConfigurationActionAssociation Role=ChildPath"),sActionPath);

		CWbemClassObject Association;

		Association.Create(GetObjectPtr()->GetSystemName());
		BSTR bsQuery = sQuery.AllocSysString();
		if( ! CHECKHRESULT(Association.ExecQuery(bsQuery)) )
		{
			::SysFreeString(bsQuery);
			return;
		}
		::SysFreeString(bsQuery);

		CString sParentPath;		
		ULONG ulReturned = 0L;		

		while( Association.GetNextObject(ulReturned) == S_OK && ulReturned > 0 )
		{
			Association.GetProperty(_T("ParentPath"),sParentPath);
			if( sParentPath.Find(GetObjectPtr()->GetGuid()) != -1 )
			{
				break;
			}			
		}

  	Association.GetProperty(_T("Query"),sQuery);
		sQuery.MakeUpper();

		CNewActionAssociationDlg dlg;

		if( sQuery.Find(_T("TARGETINSTANCE.STATE=9")) != -1 )
		{
			dlg.m_bCritical = TRUE;
		}

		if( sQuery.Find(_T("TARGETINSTANCE.STATE=8")) != -1 )
		{
			dlg.m_bWarning = TRUE;
		}

		if( sQuery.Find(_T("TARGETINSTANCE.STATE=7")) != -1 )
		{
			dlg.m_bNoData = TRUE;
		}

		if( sQuery.Find(_T("TARGETINSTANCE.STATE=4")) != -1 )
		{
			dlg.m_bDisabled = TRUE;
		}

		if( sQuery.Find(_T("TARGETINSTANCE.STATE=0")) != -1 )
		{
			dlg.m_bNormal = TRUE;
		}

		// set the selection to the proper action in the combobox
		dlg.m_saActions.Add(sActionName);
		dlg.m_iSelectedAction = 0;
		dlg.m_bEnableActionsComboBox = FALSE;
    Association.GetProperty(_T("ThrottleTime"),dlg.m_iThrottleTime);
    Association.GetProperty(_T("ReminderTime"),dlg.m_iReminderTime);

		if( dlg.DoModal() == IDOK )
		{
			// construct the EventFilter query
			CString sQuery;

	    if( GetObjectPtr()->GetTypeName() == _T("Threshold") )
      {
        sQuery.Format(_T("select * from __InstanceModificationEvent where TargetInstance isa \"Microsoft_HMThresholdStatusInstance\" AND TargetInstance.GUID=\"{%s}\""),
                      GetObjectPtr()->GetGuid());
      }
      else
      {
		    sQuery.Format(IDS_STRING_HMSTATUS_QUERY_FMT,GetObjectPtr()->GetTypeName(),GetObjectPtr()->GetGuid());
      }


			CString sClause;
			CString sCondition;
			CString sResString;

			if( dlg.m_bNormal )
			{
				sClause += _T("TargetInstance.State=0 OR ");
				sResString.LoadString(IDS_STRING_NORMAL);
				sCondition += sResString + _T(",");
			}

			if( dlg.m_bWarning )
			{
				sClause += _T("TargetInstance.State=8 OR ");
				sResString.LoadString(IDS_STRING_WARNING);
				sCondition += sResString + _T(",");
			}

			if( dlg.m_bCritical )
			{
				sClause += _T("TargetInstance.State=9 OR ");
				sResString.LoadString(IDS_STRING_CRITICAL);
				sCondition += sResString + _T(",");
			}

			if( dlg.m_bDisabled )
			{
				sClause += _T("TargetInstance.State=4 OR ");
				sResString.LoadString(IDS_STRING_DISABLED);
				sCondition += sResString + _T(",");
			}

			if( dlg.m_bNoData )
			{
				sClause += _T("TargetInstance.State=7 OR ");
				sResString.LoadString(IDS_STRING_NODATA);
				sCondition += sResString + _T(",");
			}
			
			if( ! sClause.IsEmpty() )
			{
				sClause = _T(" AND (") + sClause;

				sClause = sClause.Left(sClause.GetLength() - 4);

				sClause += _T(")");

				sQuery += sClause;
			}

			sCondition.TrimRight(_T(","));

			Association.SetProperty(_T("Query"),sQuery);
      Association.SetProperty(_T("ReminderTime"),dlg.m_iReminderTime);
      Association.SetProperty(_T("ThrottleTime"),dlg.m_iThrottleTime);

			Association.SaveAllProperties();

      CString sValue;
			m_ActionsList.SetItem(iIndex,2,LVIF_TEXT,sCondition,NULL,NULL,NULL,NULL);
      
      sValue.Format(_T("%d"),dlg.m_iThrottleTime);
      m_ActionsList.SetItem(iIndex,3,LVIF_TEXT,sValue,NULL,NULL,NULL,NULL);
      
      sValue.Format(_T("%d"),dlg.m_iReminderTime);
      m_ActionsList.SetItem(iIndex,4,LVIF_TEXT,sValue,NULL,NULL,NULL,NULL);
		}

	} // end if pos
}

void CActionAssociationPage::OnButtonNew() 
{
	CNewActionAssociationDlg dlg;

	// query for the actions on this system
	CStringArray saGuids;
	CStringArray saDescriptions;
  CStringArray saConsumerPaths;
	CString sQuery = IDS_STRING_ACTIONCONFIG_QUERY;
	BSTR bsQuery = sQuery.AllocSysString();
	CWbemClassObject ActionConfigObject;
	
	ActionConfigObject.Create(GetObjectPtr()->GetSystemName());

	HRESULT hr = ActionConfigObject.ExecQuery(bsQuery);

	if( CHECKHRESULT(hr) )
	{
		ULONG ulReturned = 0L;
		while( ActionConfigObject.GetNextObject(ulReturned) == S_OK && ulReturned > 0 )
		{
			CString sValue;		
			ActionConfigObject.GetLocaleStringProperty(IDS_STRING_MOF_NAME,sValue);
			dlg.m_saActions.Add(sValue);
			ActionConfigObject.GetProperty(IDS_STRING_MOF_GUID,sValue);
			saGuids.Add(sValue);
			ActionConfigObject.GetLocaleStringProperty(IDS_STRING_MOF_DESCRIPTION,sValue);
			saDescriptions.Add(sValue);
      ActionConfigObject.GetProperty(IDS_STRING_MOF_EVENTCONSUMER,sValue);
      saConsumerPaths.Add(sValue);
		}
	}

    BOOL bAtLeastOneActionAlreadyExists=FALSE;

	for( int i = (int)dlg.m_saActions.GetSize()-1; i >= 0; i-- )
	{
		LVFINDINFO lvfi;
		ZeroMemory(&lvfi,sizeof(LVFINDINFO));
		lvfi.flags = LVFI_WRAP|LVFI_STRING;
		lvfi.psz = dlg.m_saActions[i];
		int iListIndex = m_ActionsList.FindItem(&lvfi);
		if( iListIndex >= 0 )
		{
            bAtLeastOneActionAlreadyExists=TRUE;

			saGuids.RemoveAt(i);
			dlg.m_saActions.RemoveAt(i);
		}
	}

	if( dlg.m_saActions.GetSize() == 0 ) 
	{
        // v-marfin 61667 : Show why we are returning. User must first create
        //                  an action before attempting an association. Only if there were no
        //                  actions in the list to begin with. If there was an action in the 
        //                  dialog list but that action is already being used, it will have been removed
        //                  from the m_saActions array so see if this is the case. If so, don't 
        //                  show an error prompt, just return.
        if (!bAtLeastOneActionAlreadyExists)
        {
            AfxMessageBox(IDS_STRING_MUST_CREATE_ACTION);
        }
		return;
	}

	// display the dialog

	if( dlg.DoModal() == IDOK )
	{
		CString sParentPath = GetObjectPtr()->GetObjectPath();
		CString sChildPath;
		sChildPath.Format(_T("\\\\.\\root\\cimv2\\MicrosoftHealthmonitor:Microsoft_HMActionConfiguration.GUID=\"%s\""),saGuids[dlg.m_iSelectedAction]);
		
		// create the association instance and fill out the paths to child, parent and filter
		CWbemClassObject ActionAssociation;
		ActionAssociation.Create(GetObjectPtr()->GetSystemName());

		BSTR bsActionAssociation = ::SysAllocString(L"Microsoft_HMConfigurationActionAssociation");
		if( ! CHECKHRESULT(ActionAssociation.CreateInstance(bsActionAssociation)) )
		{
			::SysFreeString(bsActionAssociation);
			return;
		}

		::SysFreeString(bsActionAssociation);

		ActionAssociation.SetProperty(_T("ParentPath"),sParentPath);
		ActionAssociation.SetProperty(_T("ChildPath"),sChildPath);
    ActionAssociation.SetProperty(_T("ReminderTime"),dlg.m_iReminderTime);
    ActionAssociation.SetProperty(_T("ThrottleTime"),dlg.m_iThrottleTime);

		// construct the query for modification events on HMStatus
		CString sQuery;

    if( GetObjectPtr()->GetTypeName() == _T("Threshold") )
    {
      sQuery.Format(_T("select * from __InstanceModificationEvent where TargetInstance isa \"Microsoft_HMThresholdStatusInstance\" AND TargetInstance.GUID=\"{%s}\""),
                    GetObjectPtr()->GetGuid());
    }
    else
    {
		  sQuery.Format(IDS_STRING_HMSTATUS_QUERY_FMT,GetObjectPtr()->GetTypeName(),GetObjectPtr()->GetGuid());
    }

		CString sClause;
		CString sCondition;
		CString sResString;

		if( dlg.m_bNormal )
		{
			sClause += _T("TargetInstance.State=0 OR ");
			sResString.LoadString(IDS_STRING_NORMAL);
			sCondition += sResString + _T(",");
		}

		if( dlg.m_bWarning )
		{
			sClause += _T("TargetInstance.State=8 OR ");
			sResString.LoadString(IDS_STRING_WARNING);
			sCondition += sResString + _T(",");
		}

		if( dlg.m_bCritical )
		{
			sClause += _T("TargetInstance.State=9 OR ");
			sResString.LoadString(IDS_STRING_CRITICAL);
			sCondition += sResString + _T(",");
		}

		if( dlg.m_bDisabled )
		{
			sClause += _T("TargetInstance.State=4 OR ");
			sResString.LoadString(IDS_STRING_DISABLED);
			sCondition += sResString + _T(",");
		}

		if( dlg.m_bNoData )
		{
			sClause += _T("TargetInstance.State=7 OR ");
			sResString.LoadString(IDS_STRING_NODATA);
			sCondition += sResString + _T(",");
		}

		if( ! sClause.IsEmpty() )
		{
			sClause = _T(" AND (") + sClause;

			sClause = sClause.Left(sClause.GetLength() - 4);

			sClause += _T(")");

			sQuery += sClause;
		}

		sCondition.TrimRight(_T(","));

    ActionAssociation.SetProperty(IDS_STRING_MOF_QUERY,sQuery);

#ifdef SAVE
		// create the __EventFilter instance and fill out the query
		CWbemClassObject EventFilter;
		EventFilter.Create(GetObjectPtr()->GetSystemName());

		BSTR bsEventFilter = ::SysAllocString(L"__EventFilter");
		if( ! CHECKHRESULT(EventFilter.CreateInstance(bsEventFilter)) )
		{
			::SysFreeString(bsEventFilter);
			return;
		}

		::SysFreeString(bsEventFilter);

		// create the GUID
		GUID ChildGuid;
		CoCreateGuid(&ChildGuid);

		OLECHAR szGuid[GUID_CCH];
		::StringFromGUID2(ChildGuid, szGuid, GUID_CCH);
		CString sGuid = OLE2CT(szGuid);		

		EventFilter.SetProperty(_T("Name"),sGuid);
		EventFilter.SetProperty(_T("QueryLanguage"),CString(_T("WQL")));

    // set event filter query to ActionStatus creation event
    sQuery.Format(IDS_STRING_HMACTIONSTATUS_QUERY_FMT,saGuids[dlg.m_iSelectedAction]);
		EventFilter.SetProperty(_T("Query"),sQuery);

		EventFilter.SaveAllProperties();
#endif

		CString sEventFilterPath;
//		sEventFilterPath.Format(_T("\\\\.\\root\\cimv2\\MicrosoftHealthmonitor:__EventFilter.Name=\"%s\""),sGuid);
		sEventFilterPath.Format(_T("\\\\.\\root\\cimv2\\MicrosoftHealthmonitor:__EventFilter.Name=\"%s\""),saGuids[dlg.m_iSelectedAction]);
		ActionAssociation.SetProperty(_T("EventFilter"),sEventFilterPath);
		ActionAssociation.SaveAllProperties();

#ifdef SAVE
		// create the __FilterToConsumerBinding instance and fill out the paths
		CWbemClassObject FilterToConsumerBinding;
		FilterToConsumerBinding.Create(GetObjectPtr()->GetSystemName());

		BSTR bsFTCB = ::SysAllocString(L"__FilterToConsumerBinding");
		if( ! CHECKHRESULT(FilterToConsumerBinding.CreateInstance(bsFTCB)) )
		{
			::SysFreeString(bsFTCB);
			return;
		}

		::SysFreeString(bsFTCB);

    FilterToConsumerBinding.SetProperty(_T("Consumer"),saConsumerPaths[dlg.m_iSelectedAction]);
    FilterToConsumerBinding.SetProperty(_T("Filter"),sEventFilterPath);

    FilterToConsumerBinding.SaveAllProperties();
#endif

		// now add an item to the list control
    CString sValue;
		
    int iIndex = m_ActionsList.InsertItem(0,dlg.m_saActions[dlg.m_iSelectedAction]);
		
    m_ActionsList.SetItem(iIndex,1,LVIF_TEXT,saGuids[dlg.m_iSelectedAction],NULL,NULL,NULL,NULL);
		
    m_ActionsList.SetItem(iIndex,2,LVIF_TEXT,sCondition,NULL,NULL,NULL,NULL);
		
    sValue.Format(_T("%d"),dlg.m_iThrottleTime);
    m_ActionsList.SetItem(iIndex,3,LVIF_TEXT,sValue,NULL,NULL,NULL,NULL);
    
    sValue.Format(_T("%d"),dlg.m_iReminderTime);
    m_ActionsList.SetItem(iIndex,4,LVIF_TEXT,sValue,NULL,NULL,NULL,NULL);
    
    m_ActionsList.SetItem(iIndex,5,LVIF_TEXT,saDescriptions[dlg.m_iSelectedAction],NULL,NULL,NULL,NULL);

    m_ActionsList.SetColumnWidth(0,LVSCW_AUTOSIZE);

	}
	
}

void CActionAssociationPage::OnButtonDelete() 
{
	POSITION pos = m_ActionsList.GetFirstSelectedItemPosition();
	int iIndex = 0;
	if( pos )
	{	
		iIndex = m_ActionsList.GetNextSelectedItem(pos);
		CString sActionGuid = m_ActionsList.GetItemText(iIndex,1);
    GetObjectPtr()->DeleteActionAssoc(sActionGuid);
		m_ActionsList.DeleteItem(iIndex);
	}	
}

void CActionAssociationPage::OnDblclkListActions(NMHDR* pNMHDR, LRESULT* pResult) 
{
  OnButtonProperties();
	
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionassociationpage.h ===
#if !defined(AFX_ACTIONASSOCIATIONPAGE_H__9136B32C_5C9B_11D3_BE49_0000F87A3912__INCLUDED_)
#define AFX_ACTIONASSOCIATIONPAGE_H__9136B32C_5C9B_11D3_BE49_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ActionAssociationPage.h : header file
//

#include "HMPropertyPage.h"
#include "WbemClassObject.h"

/////////////////////////////////////////////////////////////////////////////
// CActionAssociationPage dialog

class CActionAssociationPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CActionAssociationPage)

// Construction
public:
	CActionAssociationPage();
	~CActionAssociationPage();

// User Interface Attributes
protected:
	HBITMAP m_hPropertiesBitmap;
	HBITMAP m_hNewBitmap;
	HBITMAP m_hDeleteBitmap;
	CToolTipCtrl m_ToolTip;

// Helpers
protected:
	CWbemClassObject* GetAssociatedActions();
	CString GetConditionString(const CString& sGuid);
	CWbemClassObject* GetA2CAssociation(const CString& sActionConfigGuid);
  CWbemClassObject* GetC2AAssociation(const CString& sConfigGuid);

// Dialog Data
	//{{AFX_DATA(CActionAssociationPage)
	enum { IDD = IDD_ACTION_ASSOCIATION };
	CListCtrl	m_ActionsList;
	CButton	m_PropertiesButton;
	CButton	m_NewButton;
	CButton	m_DeleteButton;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CActionAssociationPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CActionAssociationPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnClickListActions(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonProperties();
	afx_msg void OnButtonNew();
	afx_msg void OnButtonDelete();
	afx_msg void OnDblclkListActions(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACTIONASSOCIATIONPAGE_H__9136B32C_5C9B_11D3_BE49_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actioncmdlinepage.h ===
#if !defined(AFX_ACTIONCMDLINEPAGE_H__10AC0363_5D70_11D3_939D_00A0CC406605__INCLUDED_)
#define AFX_ACTIONCMDLINEPAGE_H__10AC0363_5D70_11D3_939D_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ActionCmdLinePage.h : header file
//

#include "HMPropertyPage.h"
#include "InsertionStringMenu.h"

/////////////////////////////////////////////////////////////////////////////
// CActionCmdLinePage dialog

class CActionCmdLinePage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CActionCmdLinePage)

// Construction
public:
	CActionCmdLinePage();
	~CActionCmdLinePage();

// Dialog Data
	//{{AFX_DATA(CActionCmdLinePage)
	enum { IDD = IDD_ACTION_CMDLINE };
	CEdit	m_CmdLineWnd;
	CComboBox	m_TimeoutUnits;
	CString	m_sCommandLine;
	CString	m_sFileName;
	int		m_iTimeout;
	CString	m_sWorkingDirectory;
	BOOL	m_bWindowed;
	//}}AFX_DATA
	CInsertionStringMenu m_InsertionMenu;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CActionCmdLinePage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CActionCmdLinePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnButtonAdvanced();
	afx_msg void OnButtonBrowseDirectory();
	afx_msg void OnButtonBrowseFile();
	afx_msg void OnChangeEditCommandLine();
	afx_msg void OnChangeEditFileName();
	afx_msg void OnChangeEditProcessTimeout();
	afx_msg void OnChangeEditWorkingDir();
	afx_msg void OnSelendokComboTimeoutUnits();
	afx_msg void OnButtonInsertion();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACTIONCMDLINEPAGE_H__10AC0363_5D70_11D3_939D_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\action.inl ===
// File Action.inl
//
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03/18/00 v-marfin : bug 59492 - SetObjectPtr() before calling Create() so object
//                     has necessary member ptr set.
//



#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// WMI Operations
/////////////////////////////////////////////////////////////////////////////
// v-marfin 59492 ---------------------------------------
inline CString CAction::GetStatusObjectPath()
{
	TRACEX(_T("CAction::GetStatusObjectPath\n"));

	CString sPath;
	sPath.Format(IDS_STRING_MOF_OBJECTPATH,IDS_STRING_MOF_HMACTION_STATUS,GetGuid());

	return sPath;
}
//-------------------------------------------------------

inline CString CAction::GetObjectPath()
{
	TRACEX(_T("CAction::GetObjectPath\n"));

	CString sPath;
	sPath.Format(IDS_STRING_MOF_OBJECTPATH,IDS_STRING_MOF_HMA_CONFIG,GetGuid());

	return sPath;
}

inline CWbemClassObject* CAction::GetConsumerClassObject()
{
	TRACEX(_T("CAction::GetConsumerClassObject\n"));

	CWbemClassObject* pConfigObject = GetClassObject();

	if( ! pConfigObject )
	{
		return NULL;
	}

	CString sEventConsumerPath;
	pConfigObject->GetProperty(IDS_STRING_MOF_EVENTCONSUMER,sEventConsumerPath);

	delete pConfigObject;
	pConfigObject = NULL;

	if( sEventConsumerPath.IsEmpty() )
	{
		return NULL;
	}

	CWbemClassObject* pClassObject = new CWbemClassObject;

	if( ! CHECKHRESULT(pClassObject->Create(GetSystemName())) )
	{
		delete pClassObject;
		return NULL;
	}

	if( ! CHECKHRESULT(pClassObject->GetObject(sEventConsumerPath)) )
	{
		delete pClassObject;
		return NULL;
	}

	return pClassObject;
}

inline CWbemClassObject* CAction::GetAssociatedConfigObjects()
{
	TRACEX(_T("CAction::GetAssociatedConfigObjects\n"));

	// execute the query for config objects associated to this action
	CWbemClassObject* pConfigObject = new CWbemClassObject;
	CString sQuery;

	sQuery.Format(IDS_STRING_A2C_ASSOC_QUERY,GetGuid());

	if( ! CHECKHRESULT(pConfigObject->Create(GetSystemName())) )
	{
		return NULL;
	}

	BSTR bsQuery = sQuery.AllocSysString();

	if( ! CHECKHRESULT(pConfigObject->ExecQuery(bsQuery)) )
	{
		::SysFreeString(bsQuery);
		return NULL;
	}

	::SysFreeString(bsQuery);


	return pConfigObject;
}

inline CWbemClassObject* CAction::GetAssociationObjects()
{
	TRACEX(_T("CAction::GetAssociationObjects\n"));

	// execute the query for config objects associated to this action
	CWbemClassObject* pAssociationObject = new CWbemClassObject;

	CString sQuery;
	sQuery.Format(_T("REFERENCES OF {%s} WHERE ResultClass=Microsoft_HMConfigurationActionAssociation Role=ChildPath"),GetObjectPath());

	CWbemClassObject Association;

	pAssociationObject->Create(GetSystemName());
	BSTR bsQuery = sQuery.AllocSysString();
	if( ! CHECKHRESULT(pAssociationObject->ExecQuery(bsQuery)) )
	{
		::SysFreeString(bsQuery);
		return NULL;
	}
	::SysFreeString(bsQuery);


	return pAssociationObject;
}

inline CWbemClassObject* CAction::GetA2CAssociation(const CString& sConfigGuid)
{
	TRACEX(_T("CAction::GetEventFilter\n"));
	TRACEARGs(sConfigGuid);

	CString sActionPath = GetObjectPath();

	CString sQuery;
	sQuery.Format(_T("REFERENCES OF {%s} WHERE ResultClass=Microsoft_HMConfigurationActionAssociation Role=ChildPath"),sActionPath);

	CWbemClassObject* pAssociation = new CWbemClassObject;

	pAssociation->Create(GetSystemName());
	BSTR bsQuery = sQuery.AllocSysString();
	if( ! CHECKHRESULT(pAssociation->ExecQuery(bsQuery)) )
	{
		::SysFreeString(bsQuery);
    delete pAssociation;
		return NULL;
	}
	::SysFreeString(bsQuery);

	CString sParentPath;		
	CString sEventFilterPath;
	ULONG ulReturned = 0L;		

	while( pAssociation->GetNextObject(ulReturned) == S_OK && ulReturned > 0 )
	{
		pAssociation->GetProperty(_T("ParentPath"),sParentPath);
		if( sParentPath.Find(sConfigGuid) != -1 )
		{
			break;
		}			
	}

	return pAssociation;
}

inline CString CAction::GetConditionString(const CString& sConfigGuid)
{
	TRACEX(_T("CAction::GetConditionString\n"));
	TRACEARGs(sConfigGuid);

	CWbemClassObject* pAssociation = GetA2CAssociation(sConfigGuid);
	if( ! pAssociation )
	{
		return _T("");
	}

	CString sQuery;
	CString sCondition;
	CString sResString;

	pAssociation->GetProperty(_T("Query"),sQuery);

	sQuery.MakeUpper();

	if( sQuery.Find(_T("TARGETINSTANCE.STATE=0")) != -1 )
	{
		sResString.LoadString(IDS_STRING_NORMAL);
		sCondition += sResString + _T(",");
	}

	if( sQuery.Find(_T("TARGETINSTANCE.STATE=8")) != -1 )
	{
		sResString.LoadString(IDS_STRING_WARNING);
		sCondition += sResString + _T(",");
	}

	if( sQuery.Find(_T("TARGETINSTANCE.STATE=9")) != -1 )
	{
		sResString.LoadString(IDS_STRING_CRITICAL);
		sCondition += sResString + _T(",");
	}

	if( sQuery.Find(_T("TARGETINSTANCE.STATE=7")) != -1 )
	{
		sResString.LoadString(IDS_STRING_NODATA);
		sCondition += sResString + _T(",");
	}

	if( sQuery.Find(_T("TARGETINSTANCE.STATE=4")) != -1 )
	{
		sResString.LoadString(IDS_STRING_DISABLED);
		sCondition += sResString + _T(",");
	}

	sCondition.TrimRight(_T(","));

	delete pAssociation;

	return sCondition;
}

inline bool CAction::CreateStatusListener()
{
  if( ! m_pActionStatusListener )
  {
    m_pActionStatusListener = new CActionStatusListener;

	// v-marfin : bug 59492 - SetObjectPtr() before calling Create() so object
	//                        has necessary member ptr set.
    m_pActionStatusListener->SetObjectPtr(this);
    m_pActionStatusListener->Create();
  }

  return true;
}

inline void CAction::DestroyStatusListener()
{
  if( m_pActionStatusListener )
  {
    delete m_pActionStatusListener;
    m_pActionStatusListener = NULL;
  }
}

/////////////////////////////////////////////////////////////////////////////
// Clipboard Operations
/////////////////////////////////////////////////////////////////////////////

inline bool CAction::Cut()
{
	TRACEX(_T("CAction::Cut\n"));
	return false;
}

inline bool CAction::Copy()
{
	TRACEX(_T("CAction::Copy\n"));
	return false;
}
	
inline bool CAction::Paste()
{
	TRACEX(_T("CAction::Paste\n"));
	return false;
}

/////////////////////////////////////////////////////////////////////////////
// Operations
/////////////////////////////////////////////////////////////////////////////

inline bool CAction::Refresh()
{
	TRACEX(_T("CAction::Refresh\n"));
	return false;
}

/////////////////////////////////////////////////////////////////////////////
// Scope Item Members
/////////////////////////////////////////////////////////////////////////////

inline CScopePaneItem* CAction::CreateScopeItem()
{
	TRACEX(_T("CAction::CreateScopeItem\n"));

	CActionScopeItem * pNewItem = new CActionScopeItem;
	pNewItem->SetObjectPtr(this);

	return pNewItem;
}

/////////////////////////////////////////////////////////////////////////////
// Type GUID
/////////////////////////////////////////////////////////////////////////////

inline CString CAction::GetTypeGuid()
{
	TRACEX(_T("CAction::GetTypeGuid\n"));	

	return m_sTypeGuid;
}

inline void CAction::SetTypeGuid(const CString& sGuid)
{
	TRACEX(_T("CAction::SetTypeGuid\n"));
	TRACEARGs(sGuid);

	m_sTypeGuid = sGuid;

	if( m_sTypeGuid == IDS_STRING_MOF_HMAT_CMDLINE )
	{
		SetType(IDM_ACTION_CMDLINE);
		m_sConsumerClassName = _T("CommandLineEventConsumer");
	}
	else if( m_sTypeGuid == IDS_STRING_MOF_HMAT_EMAIL )
	{
		SetType(IDM_ACTION_EMAIL);
		m_sConsumerClassName = _T("SmtpEventConsumer");
	}
	else if( m_sTypeGuid == IDS_STRING_MOF_HMAT_TEXTLOG )
	{
		SetType(IDM_ACTION_LOGFILE);
		m_sConsumerClassName = _T("LogFileEventConsumer");
	}
	else if( m_sTypeGuid == IDS_STRING_MOF_HMAT_NTEVENT )
	{
		SetType(IDM_ACTION_NTEVENT);
		m_sConsumerClassName = _T("NTEventLogEventConsumer");
	}
	else if( m_sTypeGuid == IDS_STRING_MOF_HMAT_SCRIPT )
	{
		SetType(IDM_ACTION_SCRIPT);
		m_sConsumerClassName = _T("ActiveScriptEventConsumer");
	}
	else if( m_sTypeGuid == IDS_STRING_MOF_HMAT_PAGING )
	{
		SetType(IDM_ACTION_PAGING);
		m_sConsumerClassName = _T("PagerEventConsumer");
	}
}

inline int CAction::GetType()
{
	TRACEX(_T("CAction::GetType\n"));

	return m_iType;
}

inline void CAction::SetType(int iType)
{
	TRACEX(_T("CAction::SetType\n"));
	TRACEARGn(iType);

	m_iType = iType;
}

inline CString CAction::GetUITypeName()
{
	TRACEX(_T("CAction::GetUITypeName\n"));

	CString sTypeName;

	switch( GetType() )
	{
		case IDM_ACTION_CMDLINE:
		{
			sTypeName.LoadString(IDS_STRING_ACTION_CMDLINE_FMT);
		}
		break;

		case IDM_ACTION_EMAIL:
		{
			sTypeName.LoadString(IDS_STRING_ACTION_EMAIL_FMT);	
		}
		break;

		case IDM_ACTION_LOGFILE:
		{
			sTypeName.LoadString(IDS_STRING_ACTION_LOGFILE_FMT);	
		}
		break;

		case IDM_ACTION_NTEVENT:
		{
			sTypeName.LoadString(IDS_STRING_ACTION_NTEVENT_FMT);	
		}
		break;

		case IDM_ACTION_SCRIPT:
		{
			sTypeName.LoadString(IDS_STRING_ACTION_SCRIPT_FMT);	
		}
		break;

		case IDM_ACTION_PAGING:
		{
			sTypeName.LoadString(IDS_STRING_ACTION_PAGING_FMT);	
		}
		break;
	}

	sTypeName = sTypeName.Left(sTypeName.GetLength()-3);

	return sTypeName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actioncmdlinepage.cpp ===
// ActionCmdLinePage.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
// 03/28/00 v-marfin 61030 Change Browse for file dialog to fix default extension
#include "stdafx.h"
#include "snapin.h"
#include "ActionCmdLinePage.h"
#include "Action.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CActionCmdLinePage property page

IMPLEMENT_DYNCREATE(CActionCmdLinePage, CHMPropertyPage)

CActionCmdLinePage::CActionCmdLinePage() : CHMPropertyPage(CActionCmdLinePage::IDD)
{
	//{{AFX_DATA_INIT(CActionCmdLinePage)
	m_sCommandLine = _T("");
	m_sFileName = _T("");
	m_iTimeout = 0;
	m_sWorkingDirectory = _T("");
	m_bWindowed = FALSE;
	//}}AFX_DATA_INIT

	m_sHelpTopic = _T("HMon21.chm::/dcommact.htm");
}

CActionCmdLinePage::~CActionCmdLinePage()
{
}

void CActionCmdLinePage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CActionCmdLinePage)
	DDX_Control(pDX, IDC_EDIT_COMMAND_LINE, m_CmdLineWnd);
	DDX_Control(pDX, IDC_COMBO_TIMEOUT_UNITS, m_TimeoutUnits);
	DDX_Text(pDX, IDC_EDIT_COMMAND_LINE, m_sCommandLine);
	DDV_MaxChars(pDX, m_sCommandLine, 1024);
	DDX_Text(pDX, IDC_EDIT_FILE_NAME, m_sFileName);
	DDV_MaxChars(pDX, m_sFileName, 1024);
	DDX_Text(pDX, IDC_EDIT_PROCESS_TIMEOUT, m_iTimeout);
	DDX_Text(pDX, IDC_EDIT_WORKING_DIR, m_sWorkingDirectory);
	DDX_Check(pDX, IDC_CHECK_WINDOWED, m_bWindowed);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CActionCmdLinePage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CActionCmdLinePage)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_BUTTON_ADVANCED, OnButtonAdvanced)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_DIRECTORY, OnButtonBrowseDirectory)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_FILE, OnButtonBrowseFile)
	ON_EN_CHANGE(IDC_EDIT_COMMAND_LINE, OnChangeEditCommandLine)
	ON_EN_CHANGE(IDC_EDIT_FILE_NAME, OnChangeEditFileName)
	ON_EN_CHANGE(IDC_EDIT_PROCESS_TIMEOUT, OnChangeEditProcessTimeout)
	ON_EN_CHANGE(IDC_EDIT_WORKING_DIR, OnChangeEditWorkingDir)
	ON_CBN_SELENDOK(IDC_COMBO_TIMEOUT_UNITS, OnSelendokComboTimeoutUnits)
	ON_BN_CLICKED(IDC_BUTTON_INSERTION, OnButtonInsertion)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CActionCmdLinePage message handlers

BOOL CActionCmdLinePage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();

	if( ! m_InsertionMenu.Create(&m_CmdLineWnd,GetObjectPtr(),false) )
	{
		GetDlgItem(IDC_BUTTON_INSERTION)->EnableWindow(FALSE);
	}
	
	CWbemClassObject* pConsumerObject = ((CAction*)GetObjectPtr())->GetConsumerClassObject();

	if( pConsumerObject )
	{
		pConsumerObject->GetProperty(_T("CommandLineTemplate"),m_sCommandLine);
		pConsumerObject->GetProperty(_T("ExecutablePath"),m_sFileName);
		if( ! m_sFileName.CompareNoCase(_T("NOOP")) )
		{
			m_sFileName.Empty();
		}
		pConsumerObject->GetProperty(_T("KillTimeout"),m_iTimeout);
		m_TimeoutUnits.SetCurSel(0);
		pConsumerObject->GetProperty(_T("WorkingDirectory"),m_sWorkingDirectory);
		int iShowWindow = SW_SHOW;
		pConsumerObject->GetProperty(_T("ShowWindowCommand"),iShowWindow);
		m_bWindowed = iShowWindow == 1;
		delete pConsumerObject;
	}

	SendDlgItemMessage(IDC_SPIN2,UDM_SETRANGE32,0,99999);

	UpdateData(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CActionCmdLinePage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();

	int iOldTimeout = m_iTimeout;
	switch( m_TimeoutUnits.GetCurSel() )
	{
		case 1: // minutes
		{
			m_iTimeout *= 60;
		}
		break;

		case 2: // hours
		{
			m_iTimeout *= 360;
		}
		break;
	}

	CWbemClassObject* pConsumerObject = ((CAction*)GetObjectPtr())->GetConsumerClassObject();

	if( pConsumerObject )
	{
		pConsumerObject->SetProperty(_T("CommandLineTemplate"),m_sCommandLine);
		pConsumerObject->SetProperty(_T("ExecutablePath"),m_sFileName);
		pConsumerObject->SetProperty(_T("KillTimeout"),m_iTimeout);
		pConsumerObject->SetProperty(_T("WorkingDirectory"),m_sWorkingDirectory);
		pConsumerObject->SetProperty(_T("RunInteractively"),true);
		pConsumerObject->SetProperty(_T("ShowWindowCommand"),m_bWindowed);
		pConsumerObject->SaveAllProperties();
		delete pConsumerObject;
	}

	m_iTimeout = iOldTimeout;

  SetModified(FALSE);

	return TRUE;
}

void CActionCmdLinePage::OnDestroy() 
{
	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}

void CActionCmdLinePage::OnButtonAdvanced() 
{
	// TODO: Add your control notification handler code here
	
}

void CActionCmdLinePage::OnButtonBrowseDirectory() 
{
	UpdateData(TRUE);
	LPMALLOC pMalloc;
	if( ::SHGetMalloc(&pMalloc) == NOERROR )
	{
		BROWSEINFO bi;
		TCHAR szBuffer[MAX_PATH];
		LPITEMIDLIST pidlDesktop;
		LPITEMIDLIST pidl;
		
		if( ::SHGetSpecialFolderLocation(GetSafeHwnd(),CSIDL_DESKTOP,&pidlDesktop) != NOERROR )
			return;

    CString sResString;
    sResString.LoadString(IDS_STRING_BROWSE_FOLDER);

		bi.hwndOwner = GetSafeHwnd();
		bi.pidlRoot = pidlDesktop;
		bi.pszDisplayName = szBuffer;
		bi.lpszTitle = LPCTSTR(sResString);
		bi.ulFlags = BIF_RETURNONLYFSDIRS;
		bi.lpfn = NULL;
		bi.lParam = 0;

		if( (pidl = ::SHBrowseForFolder(&bi)) != NULL )
		{
			if (SUCCEEDED(::SHGetPathFromIDList(pidl, szBuffer)))
			{
				m_sWorkingDirectory = szBuffer;
				UpdateData(FALSE);
			}

			pMalloc->Free(pidl);
		}
		pMalloc->Free(pidlDesktop);
		pMalloc->Release();
	}
}

void CActionCmdLinePage::OnButtonBrowseFile() 
{
	UpdateData(TRUE);
	CString sFilter;
	CString sTitle;

	sFilter.LoadString(IDS_STRING_FILTER);
	sTitle.LoadString(IDS_STRING_BROWSE_FILE);

	// v-marfin 61030 Change Browse for file dialog to fix default extension
	// CFileDialog fdlg(TRUE,_T("*.*"),NULL,OFN_FILEMUSTEXIST|OFN_SHAREAWARE|OFN_HIDEREADONLY,sFilter);
	CFileDialog fdlg(TRUE,			// Is FILEOPEN dialog?
					 NULL,			// default extension if no extension provided
					 NULL,			// initial filename
					 OFN_FILEMUSTEXIST|OFN_SHAREAWARE|OFN_HIDEREADONLY,  // flags
					 sFilter);		// filter

	fdlg.m_ofn.lpstrTitle = sTitle;

	if( fdlg.DoModal() == IDOK )
	{
		m_sFileName = fdlg.GetPathName();
		UpdateData(FALSE);
	}

}

void CActionCmdLinePage::OnChangeEditCommandLine() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionCmdLinePage::OnChangeEditFileName() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionCmdLinePage::OnChangeEditProcessTimeout() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionCmdLinePage::OnChangeEditWorkingDir() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionCmdLinePage::OnSelendokComboTimeoutUnits() 
{
	SetModified();
	
}

void CActionCmdLinePage::OnButtonInsertion() 
{
	CPoint pt;
	GetCursorPos(&pt);
	m_InsertionMenu.DisplayMenu(pt);
	UpdateData();
	SetModified();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionconfiglistener.cpp ===
// ActionConfigListener.cpp: implementation of the CActionConfigListener class.
//
//
// 03/20/00 v-marfin : bug 59492 : Create listener when creating action since that is 
//                                 where the valid "this" object used to SetObjectPtr() is.
//
//
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "ActionConfigListener.h"
#include "Action.h"
#include "ActionPolicy.h"
#include "Event.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CActionConfigListener,CWbemEventListener)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CActionConfigListener::CActionConfigListener()
{
}

CActionConfigListener::~CActionConfigListener()
{
	Destroy();
}

/////////////////////////////////////////////////////////////////////////////
// Create/Destroy
/////////////////////////////////////////////////////////////////////////////

bool CActionConfigListener::Create()
{
	TRACEX(_T("CActionConfigListener::Create\n"));

	// first create the unsecured apartment
	HRESULT hr = S_OK;
  IWbemObjectSink* pSink = (IWbemObjectSink*)GetInterface(&IID_IWbemObjectSink);
  ASSERT(pSink);
	CString sSystemName = m_pHMObject->GetSystemName();

	if( s_pIUnsecApartment == NULL )
	{
		hr = CreateUnSecuredApartment();
		if( !GfxCheckPtr(s_pIUnsecApartment,IUnsecuredApartment) || !CHECKHRESULT(hr) )
		{
			TRACE(_T("FAILED : CActionConfigListener::CreateUnSecuredApartment failed.\n"));
            ASSERT(FALSE);  // v-marfin 59492
			return false;
		}
	}

	ASSERT(s_pIUnsecApartment);

	// second, create the stub sink for this listener's IWbemObjectSink
	IUnknown* pStubUnk = NULL;

	ASSERT(s_pIUnsecApartment);

	hr = s_pIUnsecApartment->CreateObjectStub(pSink, &pStubUnk);

	if( pStubUnk == NULL || !CHECKHRESULT(hr) )
	{
    TRACE(_T("FAILED : Failed to create Stub Sink!\n"));  
    ASSERT(FALSE); // v-marfin 59492
		return false;
	}

	ASSERT(pStubUnk);

	hr = pStubUnk->QueryInterface(IID_IWbemObjectSink, (LPVOID*)&m_pStubSink);
	pStubUnk->Release();

	if( !GfxCheckPtr(m_pStubSink,IWbemObjectSink) || !CHECKHRESULT(hr) )
	{
    TRACE(_T("FAILED : Failed to QI for IWbemObjectSink !\n"));	
    ASSERT(FALSE); // v-marfin 59492
    return false;
  }

  ASSERT(m_pStubSink);

	CHMObject* pObject = GetObjectPtr();
	pObject->IncrementActiveSinkCount();
	
	return true;
}

void CActionConfigListener::Destroy()
{
	TRACEX(_T("CActionConfigListener::Destroy\n"));

    if( m_pStubSink )			
    {
		m_pStubSink->Release();
        m_pStubSink = NULL;
    }

	if( s_lObjCount == 0 && s_pIUnsecApartment )
    {
		s_pIUnsecApartment->Release();
        s_pIUnsecApartment = NULL;
    }

}

//////////////////////////////////////////////////////////////////////
// Event Processing Members
//////////////////////////////////////////////////////////////////////

HRESULT CActionConfigListener::ProcessEventClassObject(IWbemClassObject* pClassObject)
{
  ASSERT(pClassObject);
  if( pClassObject == NULL )
  {
    return E_FAIL;
  }
  
  HRESULT hr = S_OK;

	CWbemClassObject ac;

	if( ! CHECKHRESULT(hr = ac.Create(pClassObject)) )
	{
		return hr;
	}	

	CString sGuid;
	CString sName;
	CString sTypeGuid;
	CString sDescription;

	ac.GetProperty(IDS_STRING_MOF_GUID,sGuid);
	ac.GetLocaleStringProperty(IDS_STRING_MOF_NAME,sName);
	ac.GetProperty(IDS_STRING_MOF_TYPEGUID,sTypeGuid);
	sTypeGuid.TrimLeft(_T("{"));
	sTypeGuid.TrimRight(_T("}"));
	ac.GetLocaleStringProperty(IDS_STRING_MOF_DESCRIPTION,sDescription);

	// create a new CAction and add as a child
	if( ! GetObjectPtr()->GetChildByGuid(sGuid) )
	{
		CAction* pNewAction = new CAction;

        //-----------------------------------------------------------------------------
		// v-marfin : bug 59492 : Create listener when creating action since that is 
		//                        where the valid "this" object used to SetObjectPtr() is.
		if( ! pNewAction->m_pActionStatusListener )
		{
			pNewAction->m_pActionStatusListener = new CActionStatusListener;
			pNewAction->m_pActionStatusListener->SetObjectPtr(GetObjectPtr());  
			pNewAction->m_pActionStatusListener->Create();
		}
        //------------------------------------------------------------------------------


		pNewAction->SetName(sName);
		pNewAction->SetGuid(sGuid);
		pNewAction->SetTypeGuid(sTypeGuid);
		pNewAction->SetComment(sDescription);
		pNewAction->SetSystemName(GetObjectPtr()->GetSystemName());
		GetObjectPtr()->AddChild(pNewAction);

        //-----------------------------------------------------------------
        // v-marfin 59492 - set the action's initial state at load time
        int iState=0;
        CWbemClassObject* pStatus = pNewAction->GetStatusClassObject();
        if (pStatus)
        {
            HRESULT hr = pStatus->GetProperty(IDS_STRING_MOF_STATE,iState);
            if (CHECKHRESULT(hr))
            {
                pNewAction->SetState(CEvent::GetStatus(iState),true);
            }
        }
        if (pStatus)
        {
            delete pStatus;
        }
        //------------------------------------------------------------------
        

	}

  return hr;
}

inline HRESULT CActionConfigListener::OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam)
{
	TRACEX(_T("CActionConfigListener::OnSetStatus\n"));
	TRACEARGn(lFlags);
	TRACEARGn(hResult);
	TRACEARGs(strParam);
	TRACEARGn(pObjParam);

	if( lFlags == 0L && hResult == S_OK )
	{
		CHMObject* pObject = GetObjectPtr();
		pObject->DecrementActiveSinkCount();
	}

  return WBEM_NO_ERROR;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionconfiglistener.h ===
// ActionConfigListener.h: interface for the CActionConfigListener class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACTIONCONFIGLISTENER_H__EDDB0FF3_6DF8_11D3_BE5A_0000F87A3912__INCLUDED_)
#define AFX_ACTIONCONFIGLISTENER_H__EDDB0FF3_6DF8_11D3_BE5A_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemEventListener.h"

class CActionConfigListener : public CWbemEventListener  
{
DECLARE_DYNCREATE(CActionConfigListener)

// Construction/Destruction
public:
	CActionConfigListener();
	virtual ~CActionConfigListener();

// Create/Destroy
public:
	virtual bool Create();
	virtual void Destroy();

// Processing Operations
protected:
  virtual HRESULT ProcessEventClassObject(IWbemClassObject* pClassObject);
	virtual HRESULT OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam);
};

#endif // !defined(AFX_ACTIONCONFIGLISTENER_H__EDDB0FF3_6DF8_11D3_BE5A_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionemailpage.h ===
#if !defined(AFX_ACTIONEMAILPAGE_H__10AC0364_5D70_11D3_939D_00A0CC406605__INCLUDED_)
#define AFX_ACTIONEMAILPAGE_H__10AC0364_5D70_11D3_939D_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ActionEmailPage.h : header file
//

#include "HMPropertyPage.h"
#include "InsertionStringMenu.h"

/////////////////////////////////////////////////////////////////////////////
// CActionEmailPage dialog

class CActionEmailPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CActionEmailPage)

// Construction
public:
	CActionEmailPage();
	~CActionEmailPage();

// Dialog Data
	//{{AFX_DATA(CActionEmailPage)
	enum { IDD = IDD_ACTION_EMAIL };
	CEdit	m_MessageWnd;
	CEdit	m_SubjectWnd;
	CString	m_sMessage;
	CString	m_sServer;
	CString	m_sSubject;
	CString	m_sTo;
	//}}AFX_DATA
	CString m_sCc;
	CString m_sBcc;
	CInsertionStringMenu m_InsertionMenu;
	CInsertionStringMenu m_SubjectInsertionMenu;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CActionEmailPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CActionEmailPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditBcc();
	afx_msg void OnChangeEditCc();
	afx_msg void OnChangeEditMessage();
	afx_msg void OnChangeEditServer();
	afx_msg void OnChangeEditSubject();
	afx_msg void OnChangeEditTo();
	afx_msg void OnButtonBcc();
	afx_msg void OnButtonCc();
	afx_msg void OnButtonInsertion();
	afx_msg void OnButtonSubjectInsertion();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACTIONEMAILPAGE_H__10AC0364_5D70_11D3_939D_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actiongeneralpage.cpp ===
// ActionGeneralPage.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "ActionGeneralPage.h"
#include "HMObject.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CActionGeneralPage property page

IMPLEMENT_DYNCREATE(CActionGeneralPage, CHMPropertyPage)

CActionGeneralPage::CActionGeneralPage() : CHMPropertyPage(CActionGeneralPage::IDD)
{
	//{{AFX_DATA_INIT(CActionGeneralPage)
	m_sComment = _T("");
	m_sName = _T("");
	m_sCreationDate = _T("");
	m_sModifiedDate = _T("");
	//}}AFX_DATA_INIT

	CnxPropertyPageInit();

	m_sHelpTopic = _T("HMon21.chm::/dactgen.htm");
}

CActionGeneralPage::~CActionGeneralPage()
{
}

void CActionGeneralPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CActionGeneralPage)
	DDX_Text(pDX, IDC_EDIT_COMMENT, m_sComment);
	DDX_Text(pDX, IDC_EDIT_NAME, m_sName);
	DDX_Text(pDX, IDC_STATIC_DATE_CREATED, m_sCreationDate);
	DDX_Text(pDX, IDC_STATIC_DATE_LAST_MODIFIED, m_sModifiedDate);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CActionGeneralPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CActionGeneralPage)
	ON_WM_DESTROY()
	ON_EN_CHANGE(IDC_EDIT_COMMENT, OnChangeEditComment)
	ON_EN_CHANGE(IDC_EDIT_NAME, OnChangeEditName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CActionGeneralPage message handlers

BOOL CActionGeneralPage::OnInitDialog() 
{
	// unmarshal connmgr
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();

	m_sName = GetObjectPtr()->GetName();
	m_sComment = GetObjectPtr()->GetComment();
	GetObjectPtr()->GetCreateDateTime(m_sCreationDate);
	GetObjectPtr()->GetModifiedDateTime(m_sModifiedDate);

	UpdateData(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CActionGeneralPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();

	GetObjectPtr()->Rename(m_sName);
	GetObjectPtr()->UpdateComment(m_sComment);

  SetModified(FALSE);
	
	return TRUE;
}

void CActionGeneralPage::OnDestroy() 
{
	CHMPropertyPage::OnDestroy();
	
	CnxPropertyPageDestroy();	
}

void CActionGeneralPage::OnChangeEditComment() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionGeneralPage::OnChangeEditName() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionlogfilepage.cpp ===
// ActionLogFilePage.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
// 03/28/00 v-marfin bug 61030   Change Browse for file dialog to fix default extension. Also 
//                               changed conversion of filesize and other minor bugs.

#include "stdafx.h"
#include "snapin.h"
#include "ActionLogFilePage.h"
#include "Action.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CActionLogFilePage property page

IMPLEMENT_DYNCREATE(CActionLogFilePage, CHMPropertyPage)

CActionLogFilePage::CActionLogFilePage() : CHMPropertyPage(CActionLogFilePage::IDD)
{
	//{{AFX_DATA_INIT(CActionLogFilePage)
	m_sFileName = _T("");
	m_sText = _T("");
	m_iTextType = -1;
	m_iSize = 0;
	//}}AFX_DATA_INIT

	m_sHelpTopic = _T("HMon21.chm::/dlogact.htm");
}

CActionLogFilePage::~CActionLogFilePage()
{
}

void CActionLogFilePage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CActionLogFilePage)
	DDX_Control(pDX, IDC_EDIT_TEXT, m_TextWnd);
	DDX_Control(pDX, IDC_COMBO_LOGSIZE_UNITS, m_SizeUnits);
	DDX_Text(pDX, IDC_EDIT_LOGFILENAME, m_sFileName);
	DDX_Text(pDX, IDC_EDIT_TEXT, m_sText);
	DDX_Radio(pDX, IDC_RADIO_TEXT_TYPE_ASCII, m_iTextType);
	DDX_Text(pDX, IDC_EDIT_LOGSIZE, m_iSize);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CActionLogFilePage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CActionLogFilePage)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_FILE, OnButtonBrowseFile)
	ON_EN_CHANGE(IDC_EDIT_LOGFILENAME, OnChangeEditLogfilename)
	ON_EN_CHANGE(IDC_EDIT_TEXT, OnChangeEditText)
	ON_BN_CLICKED(IDC_RADIO_TEXT_TYPE_ASCII, OnRadioTextTypeAscii)
	ON_BN_CLICKED(IDC_RADIO_TEXT_TYPE_UNICODE, OnRadioTextTypeUnicode)
	ON_BN_CLICKED(IDC_BUTTON_INSERTION, OnButtonInsertion)
	ON_EN_CHANGE(IDC_EDIT_LOGSIZE, OnChangeEditLogsize)
	ON_CBN_SELENDOK(IDC_COMBO_LOGSIZE_UNITS, OnSelendokComboLogsizeUnits)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CActionLogFilePage message handlers

BOOL CActionLogFilePage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();


	CHMPropertyPage::OnInitDialog();

	if( ! m_InsertionMenu.Create(&m_TextWnd,GetObjectPtr(),false) )
	{
		GetDlgItem(IDC_BUTTON_INSERTION)->EnableWindow(FALSE);
	}
	
	CWbemClassObject* pConsumerObject = ((CAction*)GetObjectPtr())->GetConsumerClassObject();

	if( pConsumerObject )
	{
		pConsumerObject->GetProperty(_T("Filename"),m_sFileName);
		pConsumerObject->GetProperty(_T("Text"),m_sText);
		CString sSize;
		pConsumerObject->GetProperty(_T("MaximumFileSize"),sSize);
		m_iSize = (UINT)_ttol(sSize);  // v-marfin 61030
		m_SizeUnits.SetCurSel(0);
		bool bIsUnicode = false;
		pConsumerObject->GetProperty(_T("IsUnicode"),bIsUnicode);
		m_iTextType = bIsUnicode == true ? 1 : 0;
		delete pConsumerObject;
	}

	SendDlgItemMessage(IDC_SPIN1,UDM_SETRANGE32,0,999999999L);
	SendDlgItemMessage(IDC_SPIN3,UDM_SETRANGE32,0,999999999L);

	UpdateData(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CActionLogFilePage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();

	if( m_sFileName.IsEmpty() )
	{
		return FALSE;
	}

	// v-marfin 61030 : Store in proper units but leave UI unchanged.
	UINT nSize = m_iSize;
	switch( m_SizeUnits.GetCurSel() )
	{
		case 1: // kilobytes
		{
			// m_iSize *= 1024; // v-marfin 61030
			nSize *= 1024;
		}
		break;

		case 2: // megabytes
		{
			//m_iSize *= (1024*1024);  // v-marfin 61030
			nSize *= (1024*1024);
		}
		break;

	}

	CWbemClassObject* pConsumerObject = ((CAction*)GetObjectPtr())->GetConsumerClassObject();

	if( pConsumerObject )
	{
		pConsumerObject->SetProperty(_T("Filename"),m_sFileName);
		pConsumerObject->SetProperty(_T("Text"),m_sText);
		CString sSize;
		sSize.Format(_T("%lu"),nSize);  // v-marfin 61030
		pConsumerObject->SetProperty(_T("MaximumFileSize"),sSize);
		bool bIsUnicode = m_iTextType == 0 ? false : true;
		pConsumerObject->SetProperty(_T("IsUnicode"),bIsUnicode);
		pConsumerObject->SaveAllProperties();		
		delete pConsumerObject;
	}

  SetModified(FALSE);

	return TRUE;
}

void CActionLogFilePage::OnButtonBrowseFile() 
{
	CString sFilter;
	CString sTitle;

	sFilter.LoadString(IDS_STRING_FILTER);
	sTitle.LoadString(IDS_STRING_BROWSE_FILE);

	// v-marfin 61030 Change Browse for file dialog
	// CFileDialog fdlg(TRUE,_T("*.*"),NULL,OFN_FILEMUSTEXIST|OFN_SHAREAWARE|OFN_HIDEREADONLY,sFilter);
	CFileDialog fdlg(TRUE,			// Is FILEOPEN dialog?
					 NULL,			// default extension if no extension provided
					 NULL,			// initial filename
					 OFN_SHAREAWARE|OFN_HIDEREADONLY,  // flags
					 sFilter);		// filter

	fdlg.m_ofn.lpstrTitle = sTitle;

	if( fdlg.DoModal() == IDOK )
	{
		m_sFileName = fdlg.GetPathName();
		UpdateData(FALSE);
	}
}

void CActionLogFilePage::OnChangeEditLogfilename() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionLogFilePage::OnChangeEditText() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionLogFilePage::OnRadioTextTypeAscii() 
{
	SetModified();
	
}

void CActionLogFilePage::OnRadioTextTypeUnicode() 
{
	SetModified();	
}

void CActionLogFilePage::OnButtonInsertion() 
{
	CPoint pt;
	GetCursorPos(&pt);
	m_InsertionMenu.DisplayMenu(pt);
	UpdateData();
	SetModified();
}

void CActionLogFilePage::OnChangeEditLogsize() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	// TODO: Add your control notification handler code here
	SetModified();  // v-marfin 61030
	
}

void CActionLogFilePage::OnSelendokComboLogsizeUnits() 
{
	// TODO: Add your control notification handler code here
	SetModified();  // v-marfin 61030
}

void CActionLogFilePage::OnDestroy() 
{
	CHMPropertyPage::OnDestroy();

	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionemailpage.cpp ===
// ActionEmailPage.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.

#include "stdafx.h"
#include "snapin.h"
#include "ActionEmailPage.h"
#include "Action.h"
#include "BccDialog.h"
#include "CcDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CActionEmailPage property page

IMPLEMENT_DYNCREATE(CActionEmailPage, CHMPropertyPage)

CActionEmailPage::CActionEmailPage() : CHMPropertyPage(CActionEmailPage::IDD)
{
	//{{AFX_DATA_INIT(CActionEmailPage)
	m_sMessage = _T("");
	m_sServer = _T("");
	m_sSubject = _T("");
	m_sTo = _T("");
	//}}AFX_DATA_INIT

	m_sHelpTopic = _T("HMon21.chm::/demact.htm");
}

CActionEmailPage::~CActionEmailPage()
{
}

void CActionEmailPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CActionEmailPage)
	DDX_Control(pDX, IDC_EDIT_MESSAGE, m_MessageWnd);
	DDX_Text(pDX, IDC_EDIT_MESSAGE, m_sMessage);
	DDX_Text(pDX, IDC_EDIT_SERVER, m_sServer);
	DDX_Control(pDX, IDC_EDIT_SUBJECT, m_SubjectWnd);
	DDX_Text(pDX, IDC_EDIT_SUBJECT, m_sSubject);
	DDX_Text(pDX, IDC_EDIT_TO, m_sTo);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CActionEmailPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CActionEmailPage)
	ON_EN_CHANGE(IDC_EDIT_BCC, OnChangeEditBcc)
	ON_EN_CHANGE(IDC_EDIT_CC, OnChangeEditCc)
	ON_EN_CHANGE(IDC_EDIT_MESSAGE, OnChangeEditMessage)
	ON_EN_CHANGE(IDC_EDIT_SERVER, OnChangeEditServer)
	ON_EN_CHANGE(IDC_EDIT_SUBJECT, OnChangeEditSubject)
	ON_EN_CHANGE(IDC_EDIT_TO, OnChangeEditTo)
	ON_BN_CLICKED(IDC_BUTTON_BCC, OnButtonBcc)
	ON_BN_CLICKED(IDC_BUTTON_CC, OnButtonCc)
	ON_BN_CLICKED(IDC_BUTTON_INSERTION, OnButtonInsertion)
	ON_BN_CLICKED(IDC_BUTTON_SUBJECT_INSERTION, OnButtonSubjectInsertion)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CActionEmailPage message handlers

BOOL CActionEmailPage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();


	CHMPropertyPage::OnInitDialog();

	if( ! m_InsertionMenu.Create(&m_MessageWnd,GetObjectPtr(),false) )
	{
		GetDlgItem(IDC_BUTTON_INSERTION)->EnableWindow(FALSE);
	}


    // v-marfin : 61671
	if( ! m_SubjectInsertionMenu.Create(&m_SubjectWnd,GetObjectPtr(),false) )
	{
		GetDlgItem(IDC_BUTTON_SUBJECT_INSERTION)->EnableWindow(FALSE);
	}

	
	CWbemClassObject* pConsumerObject = ((CAction*)GetObjectPtr())->GetConsumerClassObject();

	if( pConsumerObject )
	{
		pConsumerObject->GetProperty(_T("ToLine"),m_sTo);
		pConsumerObject->GetProperty(_T("CcLine"),m_sCc);
		pConsumerObject->GetProperty(_T("BccLine"),m_sBcc);
		pConsumerObject->GetProperty(_T("SMTPServer"),m_sServer);
		if( ! m_sServer.CompareNoCase(_T("NOOP")) )
		{
			m_sServer.Empty();
		}
		pConsumerObject->GetProperty(_T("Message"),m_sMessage);
		pConsumerObject->GetProperty(_T("Subject"),m_sSubject);
		delete pConsumerObject;
	}

	SendDlgItemMessage(IDC_SPIN1,UDM_SETRANGE32,0,9999);

	UpdateData(FALSE);

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CActionEmailPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();


	CWbemClassObject* pConsumerObject = ((CAction*)GetObjectPtr())->GetConsumerClassObject();

	if( pConsumerObject )
	{
		pConsumerObject->SetProperty(_T("ToLine"),m_sTo);
		pConsumerObject->SetProperty(_T("CcLine"),m_sCc);
		pConsumerObject->SetProperty(_T("BccLine"),m_sBcc);
		pConsumerObject->SetProperty(_T("SMTPServer"),m_sServer);
		pConsumerObject->SetProperty(_T("Message"),m_sMessage);
		pConsumerObject->SetProperty(_T("Subject"),m_sSubject);
		pConsumerObject->SaveAllProperties();
		delete pConsumerObject;
	}

  SetModified(FALSE);

	return TRUE;
}

void CActionEmailPage::OnChangeEditBcc() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionEmailPage::OnChangeEditCc() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionEmailPage::OnChangeEditMessage() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionEmailPage::OnChangeEditServer() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionEmailPage::OnChangeEditSubject() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionEmailPage::OnChangeEditTo() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionEmailPage::OnButtonBcc() 
{
	CBccDialog dlg;

	dlg.m_sBcc = m_sBcc;
	if( dlg.DoModal() == IDOK )
	{
		m_sBcc = dlg.m_sBcc;
	}	
}

void CActionEmailPage::OnButtonCc() 
{
	CCcDialog dlg;

	dlg.m_sCc = m_sCc;
	if( dlg.DoModal() == IDOK )
	{
		m_sCc = dlg.m_sCc;
	}	
}

void CActionEmailPage::OnButtonInsertion() 
{
	CPoint pt;
	GetCursorPos(&pt);
	m_InsertionMenu.DisplayMenu(pt);
	UpdateData();
	SetModified();
}


void CActionEmailPage::OnButtonSubjectInsertion() 
{
	CPoint pt;
	GetCursorPos(&pt);
	m_SubjectInsertionMenu.DisplayMenu(pt);
	UpdateData();
	SetModified();
}

void CActionEmailPage::OnDestroy() 
{
	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionlogfilepage.h ===
#if !defined(AFX_ACTIONLOGFILEPAGE_H__10AC0366_5D70_11D3_939D_00A0CC406605__INCLUDED_)
#define AFX_ACTIONLOGFILEPAGE_H__10AC0366_5D70_11D3_939D_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ActionLogFilePage.h : header file
//

#include "HMPropertyPage.h"
#include "InsertionStringMenu.h"

/////////////////////////////////////////////////////////////////////////////
// CActionLogFilePage dialog

class CActionLogFilePage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CActionLogFilePage)

// Construction
public:
	CActionLogFilePage();
	~CActionLogFilePage();


	// v-marfin : 61030 : Make log filesize UINT
// Dialog Data
	//{{AFX_DATA(CActionLogFilePage)
	enum { IDD = IDD_ACTION_LOGFILE };
	CEdit	m_TextWnd;
	CComboBox	m_SizeUnits;
	CString	m_sFileName;
	CString	m_sText;
	int		m_iTextType;
	UINT	m_iSize;
	//}}AFX_DATA

	CInsertionStringMenu m_InsertionMenu;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CActionLogFilePage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CActionLogFilePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonBrowseFile();
	afx_msg void OnChangeEditLogfilename();
	afx_msg void OnChangeEditText();
	afx_msg void OnRadioTextTypeAscii();
	afx_msg void OnRadioTextTypeUnicode();
	afx_msg void OnButtonInsertion();
	afx_msg void OnChangeEditLogsize();
	afx_msg void OnSelendokComboLogsizeUnits();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACTIONLOGFILEPAGE_H__10AC0366_5D70_11D3_939D_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actiongeneralpage.h ===
#if !defined(AFX_ACTIONGENERALPAGE_H__10AC0365_5D70_11D3_939D_00A0CC406605__INCLUDED_)
#define AFX_ACTIONGENERALPAGE_H__10AC0365_5D70_11D3_939D_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ActionGeneralPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CActionGeneralPage dialog

class CActionGeneralPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CActionGeneralPage)

// Construction
public:
	CActionGeneralPage();
	~CActionGeneralPage();

// Dialog Data
	//{{AFX_DATA(CActionGeneralPage)
	enum { IDD = IDD_ACTION_GENERAL };
	CString	m_sComment;
	CString	m_sName;
	CString	m_sCreationDate;
	CString	m_sModifiedDate;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CActionGeneralPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CActionGeneralPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnChangeEditComment();
	afx_msg void OnChangeEditName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACTIONGENERALPAGE_H__10AC0365_5D70_11D3_939D_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionmanresultsview.cpp ===
// ActionManResultsView.cpp: implementation of the CActionManResultsView class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "ActionManResultsView.h"
#include "ResultsPane.h"
#include "HMListViewColumn.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CActionManResultsView,CSplitPaneResultsView)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CActionManResultsView::CActionManResultsView()
{

}

CActionManResultsView::~CActionManResultsView()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create/Destroy
//////////////////////////////////////////////////////////////////////

bool CActionManResultsView::Create(CScopePaneItem* pOwnerItem)
{
	TRACEX(_T("CActionManResultsView::Create\n"));
	TRACEARGn(pOwnerItem);

	if( ! CSplitPaneResultsView::Create(pOwnerItem) )
	{
		TRACE(_T("FAILED : CSplitPaneResultsView::Create failed.\n"));
		return false;
	}

	// add the upper columns
	CHMListViewColumn* pColumn = NULL;
	CString sTitle;
	DWORD dwFormat = LVCFMT_LEFT;

	// name
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NAME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);


	// last message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_LAST_MESSAGE);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// comment
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_COMMENT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// add the lower columns

	// Severity
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SEVERITY);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// ID
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_ID);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Date/Time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Component
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATA_POINT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// System
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SYSTEM);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_MESSAGE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// add the stats columns

	// time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// normal
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NORMAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// warning
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_WARNING);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// critical
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_CRITICAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// unknown
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_UNKNOWN);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);


	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionmanresultsview.h ===
// ActionManResultsView.h: interface for the CActionManResultsView class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACTIONMANRESULTSVIEW_H__71DD923E_CA88_11D2_BD8E_0000F87A3912__INCLUDED_)
#define AFX_ACTIONMANRESULTSVIEW_H__71DD923E_CA88_11D2_BD8E_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SplitPaneResultsView.h"

class CActionManResultsView : public CSplitPaneResultsView  
{
DECLARE_DYNCREATE(CActionManResultsView)

// Construction/Destruction
public:
	CActionManResultsView();
	virtual ~CActionManResultsView();

// Create/Destroy
public:
	virtual bool Create(CScopePaneItem* pOwnerItem);
};

#endif // !defined(AFX_ACTIONMANRESULTSVIEW_H__71DD923E_CA88_11D2_BD8E_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionmanscopeitem.cpp ===
// ActionManScopeItem.cpp: implementation of the CActionManScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "ActionManScopeItem.h"
#include "ActionManResultsView.h"
#include "ActionPolicyScopeItem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// {6751D765-CAA3-11d2-BD8E-0000F87A3912}
static GUID GUID_ActionMan = 
{ 0x6751d765, 0xcaa3, 0x11d2, { 0xbd, 0x8e, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

IMPLEMENT_DYNCREATE(CActionManScopeItem,CHMScopeItem)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CActionManScopeItem::CActionManScopeItem()
{
	m_lpguidItemType = &GUID_ActionMan;
}

CActionManScopeItem::~CActionManScopeItem()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Creation Members
//////////////////////////////////////////////////////////////////////

bool CActionManScopeItem::Create(CScopePane* pScopePane, CScopePaneItem* pParentItem)
{
	TRACEX(_T("CActionManScopeItem::Create\n"));
	TRACEARGn(pScopePane);
	TRACEARGn(pParentItem);

	// set up all the icons first
	m_IconResIds.Add(IDI_ICON_ACTIONMAN);
	m_OpenIconResIds.Add(IDI_ICON_ACTIONMAN);
	SetIconIndex(0);
	SetOpenIconIndex(0);

	// call base class Create method
	if( ! CScopePaneItem::Create(pScopePane,pParentItem) )
	{
		TRACE(_T("CScopePaneItem::Create failed.\n"));
		return false;
	}

	// set display names
	CString sName;
	sName.LoadString(IDS_STRING_ACTIONMAN);
	SetDisplayName(0,sName);

	// add a few random action policies
	CActionPolicyScopeItem* pItem = new CActionPolicyScopeItem;
	pItem->Create(GetScopePane(),this);
	pItem->SetDisplayName(0,_T("Default Action List"));
	m_Children.Add(pItem);

	// add a few random action policies
	pItem = new CActionPolicyScopeItem;
	pItem->Create(GetScopePane(),this);
	pItem->SetDisplayName(0,_T("Console Action List"));
	m_Children.Add(pItem);

	pItem = new CActionPolicyScopeItem;
	pItem->Create(GetScopePane(),this);
	pItem->SetDisplayName(0,_T("Action List 1"));
	m_Children.Add(pItem);

	pItem = new CActionPolicyScopeItem;
	pItem->Create(GetScopePane(),this);
	pItem->SetDisplayName(0,_T("Action List 2"));
	m_Children.Add(pItem);

	pItem = new CActionPolicyScopeItem;
	pItem->Create(GetScopePane(),this);
	pItem->SetDisplayName(0,_T("Action List 3"));
	m_Children.Add(pItem);

	return true;
}


//////////////////////////////////////////////////////////////////////	
// Results Pane View Members
//////////////////////////////////////////////////////////////////////

CResultsPaneView* CActionManScopeItem::CreateResultsPaneView()
{	
	TRACEX(_T("CActionManScopeItem::CreateResultsPaneView\n"));

	return new CActionManResultsView;
}

//////////////////////////////////////////////////////////////////////	
// MMC Notify Handlers
//////////////////////////////////////////////////////////////////////	

HRESULT CActionManScopeItem::OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed)
{
	TRACEX(_T("CActionManScopeItem::OnAddMenuItems\n"));
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

  HRESULT hr = S_OK;

  // Add New Menu Items
  if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed )
  {
	}

  // Add Task Menu Items
  if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_CLEAR_EVENTS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_CLEAR_EVENTS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_CLEAR_EVENTS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

		// separator
		cmi.strName           = NULL;
		cmi.strStatusBarText  = NULL;
		cmi.lCommandID        = NULL;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = MF_SEPARATOR;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
  }

  // Add View Menu Items
  if( CCM_INSERTIONALLOWED_VIEW & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_STATUS_ONLY);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_STATUS_ONLY_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_STATUS_ONLY;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_UNCHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    sResString.LoadString(IDS_STRING_ICONS_STATUS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ICONS_STATUS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ICONS_WITH_STATUS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_CHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    // icon legend
    sResString.LoadString(IDS_STRING_ICON_LEGEND);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ICON_LEGEND_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ICON_LEGEND;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
  }

	return hr;
}

HRESULT CActionManScopeItem::OnCommand(long lCommandID)
{
	TRACEX(_T("CActionManScopeItem::OnCommand\n"));
	TRACEARGn(lCommandID);

  HRESULT hr = S_OK;

	switch(lCommandID)
	{
		case IDM_CLEAR_EVENTS:
		{
		}
		break;
	}

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionmanscopeitem.h ===
// ActionManScopeItem.h: interface for the CActionManScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACTIONMANSCOPEITEM_H__71DD923D_CA88_11D2_BD8E_0000F87A3912__INCLUDED_)
#define AFX_ACTIONMANSCOPEITEM_H__71DD923D_CA88_11D2_BD8E_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMScopeItem.h"

class CActionManScopeItem : public CHMScopeItem  
{
DECLARE_DYNCREATE(CActionManScopeItem)

// Construction/Destruction
public:
	CActionManScopeItem();
	virtual ~CActionManScopeItem();

// Creation Members
public:
	virtual bool Create(CScopePane* pScopePane, CScopePaneItem* pParentItem);
	
// Results Pane View Members
public:
	virtual CResultsPaneView* CreateResultsPaneView();

// MMC Notify Handlers
public:
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed);
  virtual HRESULT OnCommand(long lCommandID);
	virtual HRESULT OnExpand(BOOL bExpand) { return CScopePaneItem::OnExpand(bExpand); }
};

#endif // !defined(AFX_ACTIONMANSCOPEITEM_H__71DD923D_CA88_11D2_BD8E_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionnteventlogpage.h ===
#if !defined(AFX_ACTIONNTEVENTLOGPAGE_H__10AC0367_5D70_11D3_939D_00A0CC406605__INCLUDED_)
#define AFX_ACTIONNTEVENTLOGPAGE_H__10AC0367_5D70_11D3_939D_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ActionNtEventLogPage.h : header file
//

#include "HMPropertyPage.h"
#include "InsertionStringMenu.h"

/////////////////////////////////////////////////////////////////////////////
// CActionNtEventLogPage dialog

class CActionNtEventLogPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CActionNtEventLogPage)

// Construction
public:
	CActionNtEventLogPage();
	~CActionNtEventLogPage();

// Dialog Data
	//{{AFX_DATA(CActionNtEventLogPage)
	enum { IDD = IDD_ACTION_NTEVENTLOG };
	CEdit	m_TextWnd;
	CComboBox	m_EventType;
	CString	m_sEventText;
	CString	m_sEventType;
	int		m_iEventID;
	//}}AFX_DATA

	CInsertionStringMenu m_InsertionMenu;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CActionNtEventLogPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CActionNtEventLogPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelendokComboEventType();
	afx_msg void OnChangeEditEventId();
	afx_msg void OnChangeEditEventText();
	afx_msg void OnButtonInsertion();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACTIONNTEVENTLOGPAGE_H__10AC0367_5D70_11D3_939D_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionnteventlogpage.cpp ===
// ActionNtEventLogPage.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
// 04/04/00 v-marfin bug 62880 : fix for help link


#include "stdafx.h"
#include "snapin.h"
#include "ActionNtEventLogPage.h"
#include "Action.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CActionNtEventLogPage property page

IMPLEMENT_DYNCREATE(CActionNtEventLogPage, CHMPropertyPage)

CActionNtEventLogPage::CActionNtEventLogPage() : CHMPropertyPage(CActionNtEventLogPage::IDD)
{
	//{{AFX_DATA_INIT(CActionNtEventLogPage)
	m_sEventText = _T("");
	m_sEventType = _T("");
	m_iEventID = 0;
	//}}AFX_DATA_INIT

	m_sHelpTopic = _T("HMon21.chm::/dNTevact.htm");  // v-marfin 62880
}

CActionNtEventLogPage::~CActionNtEventLogPage()
{
}

void CActionNtEventLogPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CActionNtEventLogPage)
	DDX_Control(pDX, IDC_EDIT_EVENT_TEXT, m_TextWnd);
	DDX_Control(pDX, IDC_COMBO_EVENT_TYPE, m_EventType);
	DDX_Text(pDX, IDC_EDIT_EVENT_TEXT, m_sEventText);
	DDX_CBString(pDX, IDC_COMBO_EVENT_TYPE, m_sEventType);
	DDX_Text(pDX, IDC_EDIT_EVENT_ID, m_iEventID);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CActionNtEventLogPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CActionNtEventLogPage)
	ON_CBN_SELENDOK(IDC_COMBO_EVENT_TYPE, OnSelendokComboEventType)
	ON_EN_CHANGE(IDC_EDIT_EVENT_ID, OnChangeEditEventId)
	ON_EN_CHANGE(IDC_EDIT_EVENT_TEXT, OnChangeEditEventText)
	ON_BN_CLICKED(IDC_BUTTON_INSERTION, OnButtonInsertion)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CActionNtEventLogPage message handlers

BOOL CActionNtEventLogPage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();

	if( ! m_InsertionMenu.Create(&m_TextWnd,GetObjectPtr(),false) )
	{
		GetDlgItem(IDC_BUTTON_INSERTION)->EnableWindow(FALSE);
	}
	
	CWbemClassObject* pConsumerObject = ((CAction*)GetObjectPtr())->GetConsumerClassObject();

	if( pConsumerObject )
	{
		int iEventType = 0;
		pConsumerObject->GetProperty(_T("EventType"),iEventType);
		m_EventType.SetCurSel(iEventType);
		pConsumerObject->GetProperty(_T("EventID"),m_iEventID);
		CStringArray saStrings;
		pConsumerObject->GetProperty(_T("InsertionStringTemplates"),saStrings);
		if( saStrings.GetSize() )
		{
			m_sEventText = saStrings[0];
		}
		delete pConsumerObject;
	}

	SendDlgItemMessage(IDC_SPIN1,UDM_SETRANGE32,0,9999);

	UpdateData(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CActionNtEventLogPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();

	CWbemClassObject* pConsumerObject = ((CAction*)GetObjectPtr())->GetConsumerClassObject();

	if( pConsumerObject )
	{
		int iEventType = m_EventType.GetCurSel();
		pConsumerObject->SetProperty(_T("EventType"),iEventType);		
		pConsumerObject->SetProperty(_T("EventID"),m_iEventID);
		CStringArray saStrings;
		saStrings.Add(m_sEventText);
		pConsumerObject->SetProperty(_T("InsertionStringTemplates"),saStrings);
		pConsumerObject->SetProperty(_T("NumberOfInsertionStrings"),1);
		pConsumerObject->SaveAllProperties();		
		delete pConsumerObject;
	}

  SetModified(FALSE);

	return TRUE;
}

void CActionNtEventLogPage::OnSelendokComboEventType() 
{
	SetModified();
	
}

void CActionNtEventLogPage::OnChangeEditEventId() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionNtEventLogPage::OnChangeEditEventText() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionNtEventLogPage::OnButtonInsertion() 
{
	CPoint pt;
	GetCursorPos(&pt);
	m_InsertionMenu.DisplayMenu(pt);
	UpdateData();
	SetModified();
}

void CActionNtEventLogPage::OnDestroy() 
{
	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionpolicy.cpp ===
// ActionPolicy.cpp: implementation of the CActionPolicy class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "ActionPolicy.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CActionPolicy,CHMObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CActionPolicy::CActionPolicy()
{
	m_sName.LoadString(IDS_STRING_ACTIONS);
	m_pActionListener = NULL;

	// create the GUID
	GUID ChildGuid;
	CoCreateGuid(&ChildGuid);

	OLECHAR szGuid[GUID_CCH];
	::StringFromGUID2(ChildGuid, szGuid, GUID_CCH);
	CString sGuid = OLE2CT(szGuid);
	SetGuid(sGuid);
}

CActionPolicy::~CActionPolicy()
{
	if( m_pActionListener )
	{
		delete m_pActionListener;
		m_pActionListener = NULL;
	}

	// TODO: Flush Statistics

	// TODO: Flush all events

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionpagingpage.h ===
#if !defined(AFX_ACTIONPAGINGPAGE1_H__10AC036E_5D70_11D3_939D_00A0CC406605__INCLUDED_)
#define AFX_ACTIONPAGINGPAGE1_H__10AC036E_5D70_11D3_939D_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ActionPagingPage1.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CActionPagingPage dialog

class CActionPagingPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CActionPagingPage)

// Construction
public:
	CActionPagingPage();
	~CActionPagingPage();

// Dialog Data
	//{{AFX_DATA(CActionPagingPage)
	enum { IDD = IDD_ACTION_PAGING };
	CComboBox	m_ThrottleUnits;
	int		m_iWait;
	CString	m_sMessage;
	CString	m_sPagerID;
	CString	m_sPhoneNumber;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CActionPagingPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CActionPagingPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonAdvanced();
	afx_msg void OnSelendokComboThrottleUnits();
	afx_msg void OnChangeEditAnswerWait();
	afx_msg void OnChangeEditMessage();
	afx_msg void OnChangeEditPagerId();
	afx_msg void OnChangeEditPhone();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACTIONPAGINGPAGE1_H__10AC036E_5D70_11D3_939D_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionpagingpage.cpp ===
// ActionPagingPage1.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.

#include "stdafx.h"
#include "snapin.h"
#include "ActionPagingPage.h"
#include "Action.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CActionPagingPage property page

IMPLEMENT_DYNCREATE(CActionPagingPage, CHMPropertyPage)

CActionPagingPage::CActionPagingPage() : CHMPropertyPage(CActionPagingPage::IDD)
{
	//{{AFX_DATA_INIT(CActionPagingPage)
	m_iWait = 0;
	m_sMessage = _T("");
	m_sPagerID = _T("");
	m_sPhoneNumber = _T("");
	//}}AFX_DATA_INIT

	m_sHelpTopic = _T("HMon21.chm::/Healthmon/dpageact.htm");
}

CActionPagingPage::~CActionPagingPage()
{
}

void CActionPagingPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CActionPagingPage)
	DDX_Control(pDX, IDC_COMBO_THROTTLE_UNITS, m_ThrottleUnits);
	DDX_Text(pDX, IDC_EDIT_ANSWER_WAIT, m_iWait);
	DDX_Text(pDX, IDC_EDIT_MESSAGE, m_sMessage);
	DDX_Text(pDX, IDC_EDIT_PAGER_ID, m_sPagerID);
	DDX_Text(pDX, IDC_EDIT_PHONE, m_sPhoneNumber);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CActionPagingPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CActionPagingPage)
	ON_BN_CLICKED(IDC_BUTTON_ADVANCED, OnButtonAdvanced)
	ON_CBN_SELENDOK(IDC_COMBO_THROTTLE_UNITS, OnSelendokComboThrottleUnits)
	ON_EN_CHANGE(IDC_EDIT_ANSWER_WAIT, OnChangeEditAnswerWait)
	ON_EN_CHANGE(IDC_EDIT_MESSAGE, OnChangeEditMessage)
	ON_EN_CHANGE(IDC_EDIT_PAGER_ID, OnChangeEditPagerId)
	ON_EN_CHANGE(IDC_EDIT_PHONE, OnChangeEditPhone)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CActionPagingPage message handlers

BOOL CActionPagingPage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();


	CHMPropertyPage::OnInitDialog();
	
	CWbemClassObject* pConsumerObject = ((CAction*)GetObjectPtr())->GetConsumerClassObject();

	if( pConsumerObject )
	{
		pConsumerObject->GetProperty(_T("PhoneNumber"),m_sPhoneNumber);
		pConsumerObject->GetProperty(_T("ID"),m_sPagerID);
		pConsumerObject->GetProperty(_T("Message"),m_sMessage);
		pConsumerObject->GetProperty(_T("AnswerTimeout"),m_iWait);
		delete pConsumerObject;
	}

	SendDlgItemMessage(IDC_SPIN1,UDM_SETRANGE32,0,INT_MAX-1);
	SendDlgItemMessage(IDC_SPIN2,UDM_SETRANGE32,0,INT_MAX-1);

	UpdateData(FALSE);

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CActionPagingPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();

	CWbemClassObject* pConsumerObject = ((CAction*)GetObjectPtr())->GetConsumerClassObject();

	if( pConsumerObject )
	{
		pConsumerObject->SetProperty(_T("PhoneNumber"),m_sPhoneNumber);
		pConsumerObject->SetProperty(_T("ID"),m_sPagerID);
		pConsumerObject->SetProperty(_T("Message"),m_sMessage);
		pConsumerObject->SetProperty(_T("AnswerTimeout"),m_iWait);
		pConsumerObject->SaveAllProperties();		
		delete pConsumerObject;
	}

  SetModified(FALSE);

	return TRUE;
}

void CActionPagingPage::OnButtonAdvanced() 
{
	SetModified();
	
}

void CActionPagingPage::OnSelendokComboThrottleUnits() 
{
	SetModified();
	
}

void CActionPagingPage::OnChangeEditAnswerWait() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionPagingPage::OnChangeEditMessage() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionPagingPage::OnChangeEditPagerId() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CActionPagingPage::OnChangeEditPhone() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}


void CActionPagingPage::OnDestroy() 
{
	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionpolicy.inl ===
// File: ActionPolicy.inl
//
// Copyright (c) 2000 Microsoft Corporation
//
//
// 3/20/00 v-marfin : bug 59492 : Create listener when creating action since that is 
//                                where the valid "this" object used to SetObjectPtr() is.



#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// WMI Operations
/////////////////////////////////////////////////////////////////////////////

inline HRESULT CActionPolicy::EnumerateChildren()
{
	TRACEX(_T("CActionPolicy::EnumerateChildren\n"));

	if( m_pActionListener == NULL )
	{
		m_pActionListener = new CActionConfigListener;
		m_pActionListener->SetObjectPtr(this);
		m_pActionListener->Create();
	}
	else
	{
		IncrementActiveSinkCount();
	}

	HRESULT hr = S_OK;
	CString sQuery = IDS_STRING_ACTIONCONFIG_QUERY;
	IWbemObjectSink* pSink = m_pActionListener->GetSink();
	
  if( !CHECKHRESULT(hr = CnxExecQueryAsync(GetSystemName(),sQuery,pSink)) )
  {
    TRACE(_T("FAILED : CConnectionManager::RegisterEventNotification failed!\n"));
  }

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Clipboard Operations
/////////////////////////////////////////////////////////////////////////////

inline bool CActionPolicy::Cut()
{
	TRACEX(_T("CActionPolicy::Cut\n"));
	return false;
}

inline bool CActionPolicy::Copy()
{
	TRACEX(_T("CActionPolicy::Copy\n"));
	return false;
}
	
inline bool CActionPolicy::Paste()
{
	TRACEX(_T("CActionPolicy::Paste\n"));
	return false;
}

/////////////////////////////////////////////////////////////////////////////
// Operations
/////////////////////////////////////////////////////////////////////////////

// v-marfin 59492 ---------------------------------------
inline CString CActionPolicy::GetObjectPath()
{
	TRACEX(_T("CActionPolicy::GetObjectPath\n"));

	CString sPath;
	sPath.Format(IDS_STRING_MOF_OBJECTPATH,IDS_STRING_MOF_HMACTION_STATUS,GetGuid());

	return sPath;
}
//-------------------------------------------------------

inline CString CActionPolicy::GetUITypeName()
{
	TRACEX(_T("CActionPolicy::GetUITypeName\n"));

	CString sTypeName;
	sTypeName.LoadString(IDS_STRING_ACTION_POLICY);

	return sTypeName;
}

/////////////////////////////////////////////////////////////////////////////
// Scope Item Members
/////////////////////////////////////////////////////////////////////////////

inline CScopePaneItem* CActionPolicy::CreateScopeItem()
{
	TRACEX(_T("CActionPolicy::CreateScopeItem\n"));

	CActionPolicyScopeItem * pNewItem = new CActionPolicyScopeItem;
	pNewItem->SetObjectPtr(this);

	return pNewItem;
}

/////////////////////////////////////////////////////////////////////////////
// New Child Creation Members
/////////////////////////////////////////////////////////////////////////////

inline bool CActionPolicy::CreateChild(CHMObject* pObject, const CString& sWMIClassName, const CString& sWMIAssociatorClassName)
{
	TRACEX(_T("CActionPolicy::CreateChild\n"));
	TRACEARGn(pObject);
	TRACEARGs(sWMIClassName);
	TRACEARGs(sWMIAssociatorClassName);

	if( ! GfxCheckObjPtr(pObject,CAction) )
	{
		return false;
	}

	pObject->SetSystemName(GetSystemName());

	// create the GUID
	GUID ChildGuid;
	CoCreateGuid(&ChildGuid);

	OLECHAR szGuid[GUID_CCH];
	::StringFromGUID2(ChildGuid, szGuid, GUID_CCH);
	CString sGuid = OLE2CT(szGuid);
	pObject->SetGuid(sGuid);

  // Add Child to this parent
  AddChild(pObject);

	// create child instance
	CWbemClassObject ChildClassObject;
	if( ! CHECKHRESULT(ChildClassObject.Create(GetSystemName())) )
	{
		return false;
	}

	BSTR bsTemp = sWMIClassName.AllocSysString();
	if( ! CHECKHRESULT(ChildClassObject.CreateInstance(bsTemp)) )
	{
		::SysFreeString(bsTemp);
		return false;
	}
	::SysFreeString(bsTemp);

	// Save the child instance properties for name, guid and typeguid
	ChildClassObject.SetProperty(IDS_STRING_MOF_NAME,pObject->GetName());
	ChildClassObject.SetProperty(IDS_STRING_MOF_GUID,sGuid);
	ChildClassObject.SetProperty(IDS_STRING_MOF_TYPEGUID,((CAction*)pObject)->GetTypeGuid());

	// for the action type we must create an instance of the standard event consumer as well
	// and we must associate the event consumer instance to the ActionConfiguration instance.
	CString sConsumerClassName = ((CAction*)pObject)->GetConsumerClassName();
	CWbemClassObject EventConsumerObject;

	if( ! CHECKHRESULT(EventConsumerObject.Create(GetSystemName())) )
	{
		return false;
	}

	bsTemp = sConsumerClassName.AllocSysString();
	if( ! CHECKHRESULT(EventConsumerObject.CreateInstance(bsTemp)) )
	{
		::SysFreeString(bsTemp);
		return false;
	}
	::SysFreeString(bsTemp);

	// the name of the event consumer will match the GUID of the HMActionConfiguration
	EventConsumerObject.SetProperty(IDS_STRING_MOF_NAME, _T("{") + pObject->GetGuid() + _T("}"));

	// commit the changes to WMI
	EventConsumerObject.SaveAllProperties();

	CString sEventConsumerPath;
	sEventConsumerPath.Format(_T("\\\\.\\root\\cimv2\\MicrosoftHealthmonitor:%s.Name=\"{%s}\""),sConsumerClassName,pObject->GetGuid());

	ChildClassObject.SetProperty(IDS_STRING_MOF_EVENTCONSUMER,sEventConsumerPath);

	// commit the changes to WMI
	ChildClassObject.SaveAllProperties();

//ERICVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
	//
	// create the __EventFilter instance and fill out the query
	//
	CWbemClassObject EventFilter;
	EventFilter.Create(GetSystemName());

	BSTR bsEventFilter = ::SysAllocString(L"__EventFilter");
	if( ! CHECKHRESULT(EventFilter.CreateInstance(bsEventFilter)) )
	{
		::SysFreeString(bsEventFilter);
		return false;
	}

	::SysFreeString(bsEventFilter);

	// create the GUID
//	GUID ChildGuid;
//	CoCreateGuid(&ChildGuid);

//	OLECHAR szGuid[GUID_CCH];
//	::StringFromGUID2(ChildGuid, szGuid, GUID_CCH);
//	CString sGuid = OLE2CT(szGuid);		

	EventFilter.SetProperty(_T("Name"),sGuid);
	EventFilter.SetProperty(_T("QueryLanguage"),CString(_T("WQL")));

// set event filter query to ActionStatus creation event
	CString sQuery;
	sQuery.Format(IDS_STRING_HMACTIONSTATUS_QUERY_FMT,sGuid);
	EventFilter.SetProperty(_T("Query"),sQuery);

	EventFilter.SaveAllProperties();

	//
	// create the __FilterToConsumerBinding instance and fill out the paths
	//
	CWbemClassObject FilterToConsumerBinding;
	FilterToConsumerBinding.Create(GetSystemName());

	BSTR bsFTCB = ::SysAllocString(L"__FilterToConsumerBinding");
	if( ! CHECKHRESULT(FilterToConsumerBinding.CreateInstance(bsFTCB)) )
	{
		::SysFreeString(bsFTCB);
		return false;
	}

	::SysFreeString(bsFTCB);

	FilterToConsumerBinding.SetProperty(_T("Consumer"),sEventConsumerPath);
	CString sEventFilterPath;
	sEventFilterPath.Format(_T("\\\\.\\root\\cimv2\\MicrosoftHealthmonitor:__EventFilter.Name=\"%s\""),sGuid);
	FilterToConsumerBinding.SetProperty(_T("Filter"),sEventFilterPath);

	FilterToConsumerBinding.SaveAllProperties();
	
//ERIC^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	return true;
}

inline void CActionPolicy::CreateNewChildAction(int iType)
{
	TRACEX(_T("CActionPolicy::CreateNewChildAction\n"));

	CAction* pNewAction = new CAction;	

	// v-marfin : bug 59492 : Create listener when creating action since that is 
	//                        where the valid "this" object used to SetObjectPtr() is.
	if( ! pNewAction->m_pActionStatusListener )
	{
		pNewAction->m_pActionStatusListener = new CActionStatusListener;
		pNewAction->m_pActionStatusListener->SetObjectPtr(this);
		pNewAction->m_pActionStatusListener->Create();
	}




	switch( iType )
	{
		case IDM_ACTION_CMDLINE:
		{
			pNewAction->SetName(GetUniqueChildName(IDS_STRING_ACTION_CMDLINE_FMT));	
			pNewAction->SetTypeGuid(IDS_STRING_MOF_HMAT_CMDLINE);
			CreateChild(pNewAction,IDS_STRING_MOF_HMA_CONFIG,_T(""));			
		}
		break;

		case IDM_ACTION_EMAIL:
		{
			pNewAction->SetName(GetUniqueChildName(IDS_STRING_ACTION_EMAIL_FMT));	
			pNewAction->SetTypeGuid(IDS_STRING_MOF_HMAT_EMAIL);
			CreateChild(pNewAction,IDS_STRING_MOF_HMA_CONFIG,_T(""));
		}
		break;

		case IDM_ACTION_LOGFILE:
		{
			pNewAction->SetName(GetUniqueChildName(IDS_STRING_ACTION_LOGFILE_FMT));	
			pNewAction->SetTypeGuid(IDS_STRING_MOF_HMAT_TEXTLOG);
			CreateChild(pNewAction,IDS_STRING_MOF_HMA_CONFIG,_T(""));
		}
		break;

		case IDM_ACTION_NTEVENT:
		{
			pNewAction->SetName(GetUniqueChildName(IDS_STRING_ACTION_NTEVENT_FMT));	
			pNewAction->SetTypeGuid(IDS_STRING_MOF_HMAT_NTEVENT);
			CreateChild(pNewAction,IDS_STRING_MOF_HMA_CONFIG,_T(""));
		}
		break;

		case IDM_ACTION_SCRIPT:
		{
			pNewAction->SetName(GetUniqueChildName(IDS_STRING_ACTION_SCRIPT_FMT));	
			pNewAction->SetTypeGuid(IDS_STRING_MOF_HMAT_SCRIPT);
			CreateChild(pNewAction,IDS_STRING_MOF_HMA_CONFIG,_T(""));
		}
		break;

		case IDM_ACTION_PAGING:
		{
			pNewAction->SetName(GetUniqueChildName(IDS_STRING_ACTION_PAGING_FMT));	
			pNewAction->SetTypeGuid(IDS_STRING_MOF_HMAT_PAGING);
			CreateChild(pNewAction,IDS_STRING_MOF_HMA_CONFIG,_T(""));
		}
		break;

	}

	if( pNewAction->GetScopeItemCount() )
	{
		CScopePaneItem* pItem = pNewAction->GetScopeItem(0);
		if( pItem )
		{
			pItem->SelectItem();
			pItem->InvokePropertySheet();
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionpolicyresultsview.cpp ===
// ActionPolicyResultsView.cpp: implementation of the CActionPolicyResultsView class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "ActionPolicyResultsView.h"
#include "ResultsPane.h"
#include "HMListViewColumn.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CActionPolicyResultsView,CSplitPaneResultsView)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CActionPolicyResultsView::CActionPolicyResultsView()
{

}

CActionPolicyResultsView::~CActionPolicyResultsView()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create/Destroy
//////////////////////////////////////////////////////////////////////

bool CActionPolicyResultsView::Create(CScopePaneItem* pOwnerItem)
{
	TRACEX(_T("CActionPolicyResultsView::Create\n"));
	TRACEARGn(pOwnerItem);

	if( ! CSplitPaneResultsView::Create(pOwnerItem) )
	{
		TRACE(_T("FAILED : CSplitPaneResultsView::Create failed.\n"));
		return false;
	}

	// add the upper columns
	CHMListViewColumn* pColumn = NULL;
	CString sTitle;
	DWORD dwFormat = LVCFMT_LEFT;

	// name
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NAME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);


	// last message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_LAST_MESSAGE);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// comment
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_COMMENT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// add the lower columns

	// Severity
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SEVERITY);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// ID
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_ID);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Date/Time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Component
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATA_POINT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// System
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SYSTEM);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_MESSAGE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// add the stats columns

	// time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// normal
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NORMAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// warning
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_WARNING);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// critical
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_CRITICAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// unknown
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_UNKNOWN);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionpolicyresultsview.h ===
// ActionPolicyResultsView.h: interface for the CActionPolicyResultsView class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACTIONPOLICYRESULTSVIEW_H__71DD9244_CA88_11D2_BD8E_0000F87A3912__INCLUDED_)
#define AFX_ACTIONPOLICYRESULTSVIEW_H__71DD9244_CA88_11D2_BD8E_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SplitPaneResultsView.h"

class CActionPolicyResultsView : public CSplitPaneResultsView  
{
DECLARE_DYNCREATE(CActionPolicyResultsView)

// Construction/Destruction
public:
	CActionPolicyResultsView();
	virtual ~CActionPolicyResultsView();

// Create/Destroy
public:
	virtual bool Create(CScopePaneItem* pOwnerItem);

};

#endif // !defined(AFX_ACTIONPOLICYRESULTSVIEW_H__71DD9244_CA88_11D2_BD8E_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionpolicyscopeitem.h ===
// ActionPolicyScopeItem.h: interface for the CActionPolicyScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACTIONPOLICYSCOPEITEM_H__71DD9243_CA88_11D2_BD8E_0000F87A3912__INCLUDED_)
#define AFX_ACTIONPOLICYSCOPEITEM_H__71DD9243_CA88_11D2_BD8E_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMScopeItem.h"

class CActionPolicyScopeItem : public CHMScopeItem  
{
DECLARE_DYNCREATE(CActionPolicyScopeItem)

// Construction/Destruction
public:
	CActionPolicyScopeItem();
	virtual ~CActionPolicyScopeItem();

// Creation Members
public:
	virtual bool Create(CScopePane* pScopePane, CScopePaneItem* pParentItem);
	
// Results Pane View Members
public:
	virtual CResultsPaneView* CreateResultsPaneView();

// MMC Notify Handlers
public:
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed);
  virtual HRESULT OnCommand(long lCommandID);
	virtual HRESULT OnExpand(BOOL bExpand) { return CHMScopeItem::OnExpand(bExpand); }

};

#endif // !defined(AFX_ACTIONPOLICYSCOPEITEM_H__71DD9243_CA88_11D2_BD8E_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionpolicy.h ===
// ActionPolicy.h: interface for the CActionPolicy class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACTIONPOLICY_H__10AC036B_5D70_11D3_939D_00A0CC406605__INCLUDED_)
#define AFX_ACTIONPOLICY_H__10AC036B_5D70_11D3_939D_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMObject.h"
#include "ActionPolicyScopeItem.h"
#include "Action.h"
#include "ActionConfigListener.h"

class CActionPolicy : public CHMObject  
{

DECLARE_DYNCREATE(CActionPolicy)

// Construction/Destruction
public:
	CActionPolicy();
	virtual ~CActionPolicy();

// WMI Operations
public:
	HRESULT EnumerateChildren();
    CString GetObjectPath();  // v-marfin 59492
protected:
	CActionConfigListener* m_pActionListener;

// Clipboard Operations
public:
	virtual bool Cut();
	virtual bool Copy();
	virtual bool Paste();

// Operations
public:
	virtual CString GetUITypeName();

// Scope Item Members
public:
	virtual CScopePaneItem* CreateScopeItem();

// New Child Creation Members
public:
	virtual bool CreateChild(CHMObject* pObject, const CString& sWMIClassName, const CString& sWMIAssociatorClassName);
	void CreateNewChildAction(int iType);
	
};

#include "ActionPolicy.inl"

#endif // !defined(AFX_ACTIONPOLICY_H__10AC036B_5D70_11D3_939D_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionpolicyscopeitem.cpp ===
// ActionPolicyScopeItem.cpp: implementation of the CActionPolicyScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "ActionPolicyScopeItem.h"
#include "ActionPolicyResultsView.h"
#include "ResultsPane.h"
#include "HMListViewColumn.h"
#include "ActionScopeItem.h"
#include "ActionPolicy.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// {EF423183-CA9B-11d2-BD8E-0000F87A3912}
static GUID GUID_ActionPolicy = 
{ 0xef423183, 0xca9b, 0x11d2, { 0xbd, 0x8e, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };


IMPLEMENT_DYNCREATE(CActionPolicyScopeItem,CHMScopeItem)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CActionPolicyScopeItem::CActionPolicyScopeItem()
{
	m_lpguidItemType = &GUID_ActionPolicy;
}

CActionPolicyScopeItem::~CActionPolicyScopeItem()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Creation Members
//////////////////////////////////////////////////////////////////////

bool CActionPolicyScopeItem::Create(CScopePane* pScopePane, CScopePaneItem* pParentItem)
{
	TRACEX(_T("CActionPolicyScopeItem::Create\n"));
	TRACEARGn(pScopePane);
	TRACEARGn(pParentItem);

	// set up all the icons first
	//m_IconResIds.Add(IDI_ICON_ACTION);
	//m_OpenIconResIds.Add(IDI_ICON_ACTION);

    // v-marfin 59492 : Since the icons are handled according to a state code sequence of:
    // 0 = good
    // 1 = collecting
    // 2 = reset
    // 3 = info
    // 4 = disabled
    // 5 = scheduled outage
    // 6 = unknown
    //
    // Set the icon table accordingly. Note that for Actions the only used icons are 
    // for position 0,4 and 5 so set the other icons to the normal state.
    for (int x=0;x<7; x++)
    {
	    m_IconResIds.SetAtGrow(x,IDI_ICON_ACTION);
	    m_OpenIconResIds.SetAtGrow(x,IDI_ICON_ACTION);
    }


    m_IconResIds.SetAtGrow(HMS_DISABLED,IDI_ICON_ACTIONS_DISABLED);
    m_OpenIconResIds.SetAtGrow(HMS_DISABLED,IDI_ICON_ACTIONS_DISABLED);
    //-------------------------------------------------------------------------------------------

	SetIconIndex(0);
	SetOpenIconIndex(0);

    // v-marfin: 59492 ---------------------------------------------------------------------------
    // Shouldn't this be set to the current state? -------------------------------------
    //SetIconIndex(GetObjectPtr()->GetState());
    //SetOpenIconIndex(GetObjectPtr()->GetState());
    // -------------------------------------------------------------------------------------------

	// call base class Create method
	if( ! CScopePaneItem::Create(pScopePane,pParentItem) )
	{
		TRACE(_T("CScopePaneItem::Create failed.\n"));
		return false;
	}

	// set display names
	CString sName;
	sName.LoadString(IDS_STRING_ACTIONPOLICY);
	SetDisplayName(0,sName);


	return true;
}


//////////////////////////////////////////////////////////////////////	
// Results Pane View Members
//////////////////////////////////////////////////////////////////////

CResultsPaneView* CActionPolicyScopeItem::CreateResultsPaneView()
{	
	TRACEX(_T("CActionPolicyScopeItem::CreateResultsPaneView\n"));

	return new CActionPolicyResultsView;
}

//////////////////////////////////////////////////////////////////////	
// MMC Notify Handlers
//////////////////////////////////////////////////////////////////////	

HRESULT CActionPolicyScopeItem::OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed)
{
	TRACEX(_T("CActionPolicyScopeItem::OnAddMenuItems\n"));
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

    HRESULT hr = S_OK;

    // Add New Menu Items
    if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed )
    {
		CONTEXTMENUITEM cmi;
        CString sResString;
        CString sResString2;

		// Command Line
        sResString.LoadString(IDS_STRING_ACTION_CMDLINE);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
		sResString2.LoadString(IDS_STRING_ACTION_CMDLINE_DESC);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ACTION_CMDLINE;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);

        if( !SUCCEEDED(hr) )
        {
            TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
            return hr;
        }

		// Email
        sResString.LoadString(IDS_STRING_ACTION_EMAIL);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
		sResString2.LoadString(IDS_STRING_ACTION_EMAIL_DESC);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ACTION_EMAIL;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
            TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
            return hr;
        }

		// LogFile
        sResString.LoadString(IDS_STRING_ACTION_LOGFILE);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
		sResString2.LoadString(IDS_STRING_ACTION_TEXTLOG_DESC);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ACTION_LOGFILE;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
            TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
            return hr;
        }

		// NT Event
        sResString.LoadString(IDS_STRING_ACTION_NTEVENT);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
		sResString2.LoadString(IDS_STRING_ACTION_NTEVENT_DESC);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ACTION_NTEVENT;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
            TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
            return hr;
        }

		// Script
        sResString.LoadString(IDS_STRING_ACTION_SCRIPT);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
		sResString2.LoadString(IDS_STRING_ACTION_SCRIPT_DESC);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ACTION_SCRIPT;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
            TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
            return hr;
        }
/*
		// Paging
        sResString.LoadString(IDS_STRING_ACTION_PAGING);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
		cmi.strStatusBarText  = NULL;
		cmi.lCommandID        = IDM_ACTION_PAGING;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
            TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
            return hr;
        }
*/
    } // if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed )


    // Add Task Menu Items
    if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed )
    {
		CONTEXTMENUITEM cmi;
        CString sResString;
        CString sResString2;

		// clear events
        sResString.LoadString(IDS_STRING_CLEAR_EVENTS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
        sResString2.LoadString(IDS_STRING_CLEAR_EVENTS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_CLEAR_EVENTS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
            TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
            return hr;
        }

        // v-marfin 59492 ----------------------------------------------------
		// Remove the 'disable' item from the Actions context menu for now.
        /* sResString.LoadString(IDS_STRING_DISABLE_ACTIONS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
        sResString2.LoadString(IDS_STRING_DISABLE_ACTIONS_DESC);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_DISABLE_ACTIONS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
            TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
            return hr;
        }*/
        //------------------------------------------------------------------

		// separator
		cmi.strName           = NULL;
		cmi.strStatusBarText  = NULL;
		cmi.lCommandID        = NULL;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = MF_SEPARATOR;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
            TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
            return hr;
        }
    } // if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed )



    // Add View Menu Items
    if( CCM_INSERTIONALLOWED_VIEW & *pInsertionAllowed )
    {
		CONTEXTMENUITEM cmi;
        CString sResString;
        CString sResString2;

        sResString.LoadString(IDS_STRING_STATUS_ONLY);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
        sResString2.LoadString(IDS_STRING_STATUS_ONLY_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_STATUS_ONLY;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_UNCHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
        TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
        return hr;
        }

        sResString.LoadString(IDS_STRING_ICONS_STATUS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
        sResString2.LoadString(IDS_STRING_ICONS_STATUS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ICONS_WITH_STATUS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_CHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
        TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
        return hr;
        }

        // icon legend
        sResString.LoadString(IDS_STRING_ICON_LEGEND);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
        sResString2.LoadString(IDS_STRING_ICON_LEGEND_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ICON_LEGEND;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
        if( !SUCCEEDED(hr) )
        {
        TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
        return hr;
        }
    }

	return hr;
}



HRESULT CActionPolicyScopeItem::OnCommand(long lCommandID)
{
	TRACEX(_T("CActionPolicyScopeItem::OnCommand\n"));
	TRACEARGn(lCommandID);

  HRESULT hr = S_OK;

	switch(lCommandID)
	{

		case IDM_ACTION_CMDLINE:
		case IDM_ACTION_EMAIL:
		case IDM_ACTION_LOGFILE:
		case IDM_ACTION_NTEVENT:
		case IDM_ACTION_SCRIPT:
		case IDM_ACTION_PAGING:
		{
			CActionPolicy* pPolicy = (CActionPolicy*)GetObjectPtr();
			if( ! GfxCheckObjPtr(pPolicy,CActionPolicy) )
			{
				return E_FAIL;
			}

			pPolicy->CreateNewChildAction(lCommandID);			
		}
		break;

		case IDM_CLEAR_EVENTS:
		{
            // v-marfin 59492
            TRACE(_T("CActionPolicyScopeItem::OnCommand - IDM_CLEAR_EVENTS Received\n"));
		}
		break;

		case IDM_DISABLE_ACTIONS:
		{
            // v-marfin 59492
            TRACE(_T("CActionPolicyScopeItem::OnCommand - IDM_DISABLE_ACTIONS Received\n"));
		}
		break;
	}

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionresultsview.cpp ===
// ActionResultsView.cpp: implementation of the CActionResultsView class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "ActionResultsView.h"
#include "HealthmonResultsPane.h"
#include "HMListViewColumn.h"
#include "Action.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CActionResultsView,CSplitPaneResultsView)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CActionResultsView::CActionResultsView()
{

}

CActionResultsView::~CActionResultsView()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create/Destroy
//////////////////////////////////////////////////////////////////////

bool CActionResultsView::Create(CScopePaneItem* pOwnerItem)
{
	TRACEX(_T("CActionResultsView::Create\n"));
	TRACEARGn(pOwnerItem);

	if( ! CSplitPaneResultsView::Create(pOwnerItem) )
	{
		TRACE(_T("FAILED : CSplitPaneResultsView::Create failed.\n"));
		return false;
	}

	// add the upper columns
	CHMListViewColumn* pColumn = NULL;
	CString sTitle;
	DWORD dwFormat = LVCFMT_LEFT;

	// name
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NAME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// GUID
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_GUID);
	pColumn->Create(this,sTitle,0,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// Type
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_TYPE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// Condition
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_CONDITION);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// comment
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_COMMENT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// add the lower columns

	// Severity
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SEVERITY);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// ID
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_ID);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Date/Time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Component
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATA_POINT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// System
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SYSTEM);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_MESSAGE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// add the stats columns

	// time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// normal
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NORMAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// warning
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_WARNING);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// critical
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_CRITICAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// unknown
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_UNKNOWN);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	return true;
}

//////////////////////////////////////////////////////////////////////
// MMC Notify Handlers
//////////////////////////////////////////////////////////////////////

HRESULT CActionResultsView::OnShow(CResultsPane* pPane, BOOL bSelecting, HSCOPEITEM hScopeItem)
{
	TRACEX(_T("CActionResultsView::OnShow\n"));
	TRACEARGn(pPane);
	TRACEARGn(bSelecting);
	TRACEARGn(hScopeItem);

	if( ! GfxCheckObjPtr(pPane,CHealthmonResultsPane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		return E_FAIL;
	}

	CHealthmonResultsPane* pHMRP = (CHealthmonResultsPane*)pPane;

	HRESULT hr = S_OK;

	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : CResultsPaneView::OnShow failed.\n"));
		return hr;
	}

	_DHMListView* pUpperList = NULL;

	// get upper list control
	pUpperList = pHMRP->GetUpperListCtrl();
	if( ! pUpperList )
	{
		TRACE(_T("FAILED : CHealthmonResultsPane::GetUpperListCtrl returned a NULL pointer.\n"));
		return E_FAIL;
	}

	_DHMListView* pLowerList = NULL;

	// get lower list control
	pLowerList = pHMRP->GetLowerListCtrl();
	if( ! pLowerList )
	{
		TRACE(_T("FAILED : CHealthmonResultsPane::GetLowerListCtrl returned a NULL pointer.\n"));
		return E_FAIL;
	}

	_DHMListView* pStatsList = NULL;

	// get stats list control
	pStatsList = pHMRP->GetStatsListCtrl();
	if( ! pLowerList )
	{
		TRACE(_T("FAILED : CHealthmonResultsPane::GetLowerListCtrl returned a NULL pointer.\n"));
		return E_FAIL;
	}

	for( int i = 0; i < m_ResultItems.GetSize(); i++ )
	{
		delete m_ResultItems[i];
	}
	m_ResultItems.RemoveAll();

	pUpperList->DeleteAllItems();
	pLowerList->DeleteAllItems();
	pStatsList->DeleteAllItems();

	CScopePaneItem* pOwnerScopeItem = GetOwnerScopeItem();
	if( ! pOwnerScopeItem || ! GfxCheckObjPtr(pOwnerScopeItem,CHMScopeItem) )
	{
		TRACE(_T("FAILED : CResultsPaneView::GetOwnerScopeItem returns NULL pointer.\n"));
		return S_OK;
	}

	CAction* pObject = (CAction*)((CHMScopeItem*)(pOwnerScopeItem))->GetObjectPtr();
	if( ! pObject || ! GfxCheckObjPtr(pObject,CAction) )
	{
		return S_OK;
	}

  if( bSelecting )
  {
		CString sText;
		sText.Format(IDS_STRING_ASSOCIATIONS_OF_FORMAT,pOwnerScopeItem->GetDisplayName());
		pUpperList->SetTitle(sText);

		// add the configs associated to this action object
		CWbemClassObject* pClassObject = pObject->GetAssociatedConfigObjects();
		ULONG ulReturned = 0L;		
		int iConfigCount = 0;

		while( pClassObject && pClassObject->GetNextObject(ulReturned) == S_OK && ulReturned > 0 )
		{
			CHMResultsPaneItem* pItem = new CHMResultsPaneItem;
			CStringArray saNames;

			CString sValue;
			pClassObject->GetLocaleStringProperty(IDS_STRING_MOF_NAME,sValue);
			saNames.Add(sValue);

			pClassObject->GetProperty(IDS_STRING_MOF_GUID,sValue);
			saNames.Add(sValue);

			CUIntArray iaIconIds;
			GetObjectTypeInfo(pClassObject,iaIconIds,sValue);
			saNames.Add(sValue);
			
			sValue = pObject->GetConditionString(saNames[1]);
			saNames.Add(sValue);

			pClassObject->GetLocaleStringProperty(IDS_STRING_MOF_DESCRIPTION,sValue);
			saNames.Add(sValue);

			if( ! pItem->Create(this,saNames,iaIconIds,0) )
			{
				TRACE(_T("FAILED : CHMResultsPaneItem::Create failed.\n"));

                if (pClassObject)  // v-marfin
                {
                    delete pClassObject;
                }

				return S_OK;
			}
			pItem->SetToUpperPane();
			m_ResultItems.Add(pItem);

			iConfigCount++;
		}

		if( pClassObject )
		{
			delete pClassObject;
		}

		sText.Format(IDS_STRING_COUNT_OF_FORMAT,iConfigCount);
		pUpperList->SetDescription(sText);

		hr = CResultsPaneView::OnShow(pPane,bSelecting,hScopeItem);
		
//		hr = AddEvents(pHMRP);

//		hr = AddStatistics(pHMRP);

		USES_CONVERSION;		
		CString sOrder = AfxGetApp()->GetProfileString(A2T(pObject->GetRuntimeClass()->m_lpszClassName),_T("UpperColumnOrder"));
		if( ! sOrder.IsEmpty() && sOrder != pUpperList->GetColumnOrder() )
		{
			pUpperList->SetColumnOrder(sOrder);
		}

		sOrder = AfxGetApp()->GetProfileString(A2T(pObject->GetRuntimeClass()->m_lpszClassName),_T("LowerColumnOrder"));
		if( ! sOrder.IsEmpty() && sOrder != pLowerList->GetColumnOrder() )
		{
			pLowerList->SetColumnOrder(sOrder);
		}

	}
  else
  {
		hr = CResultsPaneView::OnShow(pPane,bSelecting,hScopeItem);

		int iUpperColCount = 0;
		int iLowerColCount = 0;

    for( int i=0; i < GetColumnCount(); i++ )
    {
			CHMListViewColumn* pColumn = (CHMListViewColumn*)GetColumn(i);
			if( pColumn )
			{
				if( pColumn->IsUpperPane() )
				{
					pColumn->SaveWidth(pPane,iUpperColCount++);
				}

				if( pColumn->IsLowerPane() )
				{
					pColumn->SaveWidth(pPane,iLowerColCount++);
				}
			}
    }

		USES_CONVERSION;
		CString sOrder = pUpperList->GetColumnOrder();
		AfxGetApp()->WriteProfileString(A2T(pObject->GetRuntimeClass()->m_lpszClassName),_T("UpperColumnOrder"),sOrder);
		sOrder.Empty();

		sOrder = pLowerList->GetColumnOrder();
		AfxGetApp()->WriteProfileString(A2T(pObject->GetRuntimeClass()->m_lpszClassName),_T("LowerColumnOrder"),sOrder);
		sOrder.Empty();

		for( i = 0; i < GetColumnCount(); i++ )
		{
			CHMListViewColumn* pColumn = (CHMListViewColumn*)GetColumn(i);
			if( pColumn->IsUpperPane() )
			{
				pUpperList->DeleteColumn(0);
			}

			if( pColumn->IsLowerPane() )
			{
				pLowerList->DeleteColumn(0);
			}

			if( pColumn->IsStatsPane() )
			{
				pStatsList->DeleteColumn(0);
			}

		}

		// clean up lower list control
		pLowerList->DeleteAllItems();

		// clean up stats list control
		pStatsList->DeleteAllItems();
		
//		RemoveStatistics(pHMRP);
  }

  return S_OK;
}

inline void CActionResultsView::GetObjectTypeInfo(CWbemClassObject* pObject,CUIntArray& uia,CString& sType)
{
	CString sValue;
	pObject->GetProperty(_T("__CLASS"),sValue);
	sValue.MakeUpper();

	if( sValue.Find(_T("SYSTEM")) != -1 )
	{
		sType.LoadString(IDS_STRING_SYSTEM);
		uia.Add(IDI_ICON_SYSTEM);
	}
	else if( sValue.Find(_T("DATAGROUP")) != -1 )
	{
		sType.LoadString(IDS_STRING_DATA_GROUP);		
		uia.Add(IDI_ICON_COMPONENT);
	}
	else if( sValue.Find(_T("DATACOLLECTOR")) != -1 )
	{
		sType.LoadString(IDS_STRING_DATA_POINT);
		uia.Add(IDI_ICON_DATAPOINT);
	}
	else if( sValue.Find(_T("THRESHOLD")) != -1 )
	{
		sType.LoadString(IDS_STRING_RULE);
		uia.Add(IDI_ICON_THRESHOLD);
	}
	else
	{
		ASSERT(FALSE);
	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionschedulepage.cpp ===
// ActionSchedulePage.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "ActionSchedulePage.h"
#include "Action.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CActionSchedulePage property page

IMPLEMENT_DYNCREATE(CActionSchedulePage, CHMPropertyPage)

CActionSchedulePage::CActionSchedulePage() : CHMPropertyPage(CActionSchedulePage::IDD)
{
	//{{AFX_DATA_INIT(CActionSchedulePage)
	m_bFriday = FALSE;
	m_bMonday = FALSE;
	m_bSaturday = FALSE;
	m_bSunday = FALSE;
	m_bThursday = FALSE;
	m_bTuesday = FALSE;
	m_bWednesday = FALSE;
	m_EndTime_1 = CTime::GetCurrentTime();
	m_EndTime_2 = CTime::GetCurrentTime();
	m_StartTime_1 = CTime::GetCurrentTime();
	m_StartTime_2 = CTime::GetCurrentTime();
	m_iDataCollection = -1;
	//}}AFX_DATA_INIT

	m_sHelpTopic = _T("HMon21.chm::/dactsked.htm");
}

CActionSchedulePage::~CActionSchedulePage()
{
}

void CActionSchedulePage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CActionSchedulePage)
	DDX_Control(pDX, IDC_DATETIMEPICKER_START_2, m_StartTimeCtrl2);
	DDX_Control(pDX, IDC_DATETIMEPICKER_START_1, m_StartTimeCtrl1);
	DDX_Control(pDX, IDC_DATETIMEPICKER_END_2, m_EndTimeCtrl2);
	DDX_Control(pDX, IDC_DATETIMEPICKER_END_1, m_EndTimeCtrl1);
	DDX_Check(pDX, IDC_CHECK_FRIDAY, m_bFriday);
	DDX_Check(pDX, IDC_CHECK_MONDAY, m_bMonday);
	DDX_Check(pDX, IDC_CHECK_SATURDAY, m_bSaturday);
	DDX_Check(pDX, IDC_CHECK_SUNDAY, m_bSunday);
	DDX_Check(pDX, IDC_CHECK_THURSDAY, m_bThursday);
	DDX_Check(pDX, IDC_CHECK_TUESDAY, m_bTuesday);
	DDX_Check(pDX, IDC_CHECK_WEDNESDAY, m_bWednesday);
	DDX_DateTimeCtrl(pDX, IDC_DATETIMEPICKER_END_1, m_EndTime_1);
	DDX_DateTimeCtrl(pDX, IDC_DATETIMEPICKER_END_2, m_EndTime_2);
	DDX_DateTimeCtrl(pDX, IDC_DATETIMEPICKER_START_1, m_StartTime_1);
	DDX_DateTimeCtrl(pDX, IDC_DATETIMEPICKER_START_2, m_StartTime_2);
	DDX_Radio(pDX, IDC_RADIO_ALL_DAY, m_iDataCollection);
	//}}AFX_DATA_MAP

	if( pDX->m_bSaveAndValidate )
	{
		m_iActiveDays = 0;

		if( m_bSunday )
		{
			m_iActiveDays |= 0x00000001;
		}

		if( m_bMonday )
		{
			m_iActiveDays |= 0x00000002;
		}

		if( m_bTuesday )
		{
			m_iActiveDays |= 0x00000004;
		}

		if( m_bWednesday )
		{
			m_iActiveDays |= 0x00000008;
		}

		if( m_bThursday )
		{
			m_iActiveDays |= 0x00000010;
		}

		if( m_bFriday )
		{
			m_iActiveDays |= 0x00000020;
		}

		if( m_bSaturday )
		{
			m_iActiveDays |= 0x00000040;
		}
	}


	switch( m_iDataCollection )
	{
		case 0:
		{
			GetDlgItem(IDC_DATETIMEPICKER_START_2)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_END_2)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_START_1)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_END_1)->EnableWindow(FALSE);
		}
		break;

		case 1:
		{
			GetDlgItem(IDC_DATETIMEPICKER_START_2)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_END_2)->EnableWindow(FALSE);			
			GetDlgItem(IDC_DATETIMEPICKER_START_1)->EnableWindow(TRUE);
			GetDlgItem(IDC_DATETIMEPICKER_END_1)->EnableWindow(TRUE);
		}
		break;

		case 2:
		{
			GetDlgItem(IDC_DATETIMEPICKER_START_2)->EnableWindow(TRUE);
			GetDlgItem(IDC_DATETIMEPICKER_END_2)->EnableWindow(TRUE);			
			GetDlgItem(IDC_DATETIMEPICKER_START_1)->EnableWindow(FALSE);
			GetDlgItem(IDC_DATETIMEPICKER_END_1)->EnableWindow(FALSE);
		}
		break;

	}
}


BEGIN_MESSAGE_MAP(CActionSchedulePage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CActionSchedulePage)
	ON_BN_CLICKED(IDC_CHECK_FRIDAY, OnCheckFriday)
	ON_BN_CLICKED(IDC_CHECK_MONDAY, OnCheckMonday)
	ON_BN_CLICKED(IDC_CHECK_SATURDAY, OnCheckSaturday)
	ON_BN_CLICKED(IDC_CHECK_SUNDAY, OnCheckSunday)
	ON_BN_CLICKED(IDC_CHECK_THURSDAY, OnCheckThursday)
	ON_BN_CLICKED(IDC_CHECK_TUESDAY, OnCheckTuesday)
	ON_BN_CLICKED(IDC_CHECK_WEDNESDAY, OnCheckWednesday)
	ON_NOTIFY(DTN_DATETIMECHANGE, IDC_DATETIMEPICKER_END_1, OnDatetimechangeDatetimepickerEnd1)
	ON_NOTIFY(DTN_DATETIMECHANGE, IDC_DATETIMEPICKER_END_2, OnDatetimechangeDatetimepickerEnd2)
	ON_NOTIFY(DTN_DATETIMECHANGE, IDC_DATETIMEPICKER_ONCE, OnDatetimechangeDatetimepickerOnce)
	ON_NOTIFY(DTN_DATETIMECHANGE, IDC_DATETIMEPICKER_START_1, OnDatetimechangeDatetimepickerStart1)
	ON_NOTIFY(DTN_DATETIMECHANGE, IDC_DATETIMEPICKER_START_2, OnDatetimechangeDatetimepickerStart2)
	ON_BN_CLICKED(IDC_RADIO_ALL_DAY, OnRadioAllDay)
	ON_BN_CLICKED(IDC_RADIO_ALL_DAY_EXCEPT, OnRadioAllDayExcept)
	ON_BN_CLICKED(IDC_RADIO_ONCE_DAILY, OnRadioOnceDaily)
	ON_BN_CLICKED(IDC_RADIO_ONLY_FROM, OnRadioOnlyFrom)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CActionSchedulePage message handlers

BOOL CActionSchedulePage::OnInitDialog() 
{
	CHMPropertyPage::OnInitDialog();

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return FALSE;
	}
	
	// get the active days
	pClassObject->GetProperty(IDS_STRING_MOF_ACTIVEDAYS,m_iActiveDays);

	// get the begin time
	int iBeginHour;
	int iBeginMinute;
	CString sBeginTime;

	pClassObject->GetProperty(IDS_STRING_MOF_BEGINTIME,sBeginTime);

	if( sBeginTime.IsEmpty() )
	{
		iBeginHour = 0;
		iBeginMinute = 0;
	}
	else
	{
		sBeginTime = sBeginTime.Right(17);
		sBeginTime = sBeginTime.Left(4);
		_stscanf(sBeginTime,_T("%02d%02d"), &iBeginHour, &iBeginMinute);
	}	

	// get the end time
	int iEndHour;
	int iEndMinute;
	CString sEndTime;

	pClassObject->GetProperty(IDS_STRING_MOF_ENDTIME,sEndTime);

	if( sEndTime.IsEmpty() )
	{
		iEndHour = 23;
		iEndMinute = 59;
	}
	else
	{
		sEndTime = sEndTime.Right(17);
		sEndTime = sEndTime.Left(4);

		_stscanf(sEndTime,_T("%02d%02d"), &iEndHour, &iEndMinute);
	}

	delete pClassObject;
	pClassObject = NULL;

	if( iBeginHour == 0 && iBeginMinute == 0 && iEndHour == 23 && iEndMinute == 59 )
	{
		m_iDataCollection = 0;
	}
	else if( iBeginHour > iEndHour )
	{
		m_iDataCollection = 2;
		m_EndTime_2 = CTime(1999,12,31,iBeginHour,iBeginMinute,0);
		m_StartTime_2 = CTime(1999,12,31,iEndHour,iEndMinute,0);
	}
	else
	{
		m_iDataCollection = 1;
		m_StartTime_1 = CTime(1999,12,31,iBeginHour,iBeginMinute,0);
		m_EndTime_1 = CTime(1999,12,31,iEndHour,iEndMinute,0);
	}

	if( m_iActiveDays & 0x00000001 )
	{
		m_bSunday = TRUE;
	}

	if( m_iActiveDays & 0x00000002 )
	{
		m_bMonday = TRUE;
	}

	if( m_iActiveDays & 0x00000004 )
	{
		m_bTuesday = TRUE;
	}

	if( m_iActiveDays & 0x00000008 )
	{
		m_bWednesday = TRUE;
	}

	if( m_iActiveDays & 0x00000010 )
	{
		m_bThursday = TRUE;
	}

	if( m_iActiveDays & 0x00000020 )
	{
		m_bFriday = TRUE;
	}

	if( m_iActiveDays & 0x00000040 )
	{
		m_bSaturday = TRUE;
	}

	CString sTimeFormat;
	int iLen = GetLocaleInfo(LOCALE_USER_DEFAULT,LOCALE_STIMEFORMAT,NULL,0);
	GetLocaleInfo(LOCALE_USER_DEFAULT,LOCALE_STIMEFORMAT,sTimeFormat.GetBuffer(iLen+1),iLen);
	sTimeFormat.ReleaseBuffer();

	int iIndex = sTimeFormat.Find(_T(":ss"));
	if( iIndex != -1 )
	{
		sTimeFormat.Delete(iIndex,3);
	}

	iIndex = sTimeFormat.Find(_T(":s"));
	if( iIndex != -1 )
	{
		sTimeFormat.Delete(iIndex,2);
	}

	m_StartTimeCtrl2.SetFormat(sTimeFormat);
	m_StartTimeCtrl1.SetFormat(sTimeFormat);
	m_EndTimeCtrl2.SetFormat(sTimeFormat);
	m_EndTimeCtrl1.SetFormat(sTimeFormat);

	UpdateData(FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CActionSchedulePage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();

	int iBeginHour=0;
	int iBeginMinute=0;
	int iEndHour=0;
	int iEndMinute=0;

	switch( m_iDataCollection )
	{
		case 0: // all day
		{
			iBeginHour = iBeginMinute = 0;
			iEndHour = 23;
			iEndMinute = 59;
		}
		break;

		case 1:	// only from x to y
		{
			iBeginHour = m_StartTime_1.GetHour();
			iBeginMinute = m_StartTime_1.GetMinute();
			iEndHour = m_EndTime_1.GetHour();
			iEndMinute = m_EndTime_1.GetMinute();
		}
		break;

		case 2: // all day except x to y
		{
			iBeginHour = m_EndTime_2.GetHour();
			iBeginMinute = m_EndTime_2.GetMinute();
			iEndHour = m_StartTime_2.GetHour();
			iEndMinute = m_StartTime_2.GetMinute();
		}
		break;

	}

	// update the agent object
	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return FALSE;
	}
	
	// set the active days
	pClassObject->SetProperty(IDS_STRING_MOF_ACTIVEDAYS,m_iActiveDays);

	// set the begin time
	CString sTime;
	sTime.Format(_T("********%02d%02d**.******+***"),iBeginHour,iBeginMinute);

	pClassObject->SetProperty(IDS_STRING_MOF_BEGINTIME,sTime);

	// set the end time	
	sTime.Format(_T("********%02d%02d**.******+***"),iEndHour,iEndMinute);

	pClassObject->SetProperty(IDS_STRING_MOF_ENDTIME,sTime);

	pClassObject->SaveAllProperties();

	delete pClassObject;

  SetModified(FALSE);	

	return TRUE;
}

void CActionSchedulePage::OnCheckFriday() 
{
	UpdateData();
	SetModified();
}

void CActionSchedulePage::OnCheckMonday() 
{
	UpdateData();
	SetModified();
}

void CActionSchedulePage::OnCheckSaturday() 
{
	UpdateData();
	SetModified();
}

void CActionSchedulePage::OnCheckSunday() 
{
	UpdateData();
	SetModified();
}

void CActionSchedulePage::OnCheckThursday() 
{
	UpdateData();
	SetModified();
}

void CActionSchedulePage::OnCheckTuesday() 
{
	UpdateData();
	SetModified();
}

void CActionSchedulePage::OnCheckWednesday() 
{
	UpdateData();
	SetModified();
}

void CActionSchedulePage::OnDatetimechangeDatetimepickerEnd1(NMHDR* pNMHDR, LRESULT* pResult) 
{
	UpdateData();
	SetModified();
	*pResult = 0;
}

void CActionSchedulePage::OnDatetimechangeDatetimepickerEnd2(NMHDR* pNMHDR, LRESULT* pResult) 
{
	UpdateData();
	SetModified();
	*pResult = 0;
}

void CActionSchedulePage::OnDatetimechangeDatetimepickerOnce(NMHDR* pNMHDR, LRESULT* pResult) 
{
	UpdateData();
	SetModified();
	*pResult = 0;
}

void CActionSchedulePage::OnDatetimechangeDatetimepickerStart1(NMHDR* pNMHDR, LRESULT* pResult) 
{
	UpdateData();
	SetModified();
	*pResult = 0;
}

void CActionSchedulePage::OnDatetimechangeDatetimepickerStart2(NMHDR* pNMHDR, LRESULT* pResult) 
{
	UpdateData();
	SetModified();
	*pResult = 0;
}

void CActionSchedulePage::OnRadioAllDay() 
{
	UpdateData();
	SetModified();
}

void CActionSchedulePage::OnRadioAllDayExcept() 
{
	UpdateData();
	SetModified();	
}

void CActionSchedulePage::OnRadioOnceDaily() 
{
	UpdateData();
	SetModified();
}

void CActionSchedulePage::OnRadioOnlyFrom() 
{
	UpdateData();
	SetModified();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionresultsview.h ===
// ActionResultsView.h: interface for the CActionResultsView class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACTIONRESULTSVIEW_H__71DD9242_CA88_11D2_BD8E_0000F87A3912__INCLUDED_)
#define AFX_ACTIONRESULTSVIEW_H__71DD9242_CA88_11D2_BD8E_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SplitPaneResultsView.h"

class CActionResultsView : public CSplitPaneResultsView
{
DECLARE_DYNCREATE(CActionResultsView)

// Construction/Destruction
public:
	CActionResultsView();
	virtual ~CActionResultsView();

// Create/Destroy
public:
	virtual bool Create(CScopePaneItem* pOwnerItem);

// MMC Notify Handlers
public:
	virtual HRESULT OnShow(CResultsPane* pPane, BOOL bSelecting, HSCOPEITEM hScopeItem);

// Helpers
protected:
	void GetObjectTypeInfo(CWbemClassObject* pObject,CUIntArray& uia,CString& sType);
};

#endif // !defined(AFX_ACTIONRESULTSVIEW_H__71DD9242_CA88_11D2_BD8E_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionscopeitem.cpp ===
// ActionScopeItem.cpp: implementation of the CActionScopeItem class.
//
//////////////////////////////////////////////////////////////////////
//
// 03/04/00 v-marfin bug 59643 : Make the details page the default page.
// 04/02/00 v-marfin bug 59643b: Make General Page the first page, but set
//                               details page as the focus on a new data collector.
//
//
//
//
#include "stdafx.h"
#include "snapin.h"
#include "ResultsPane.h"
#include "ActionScopeItem.h"
#include "ActionResultsView.h"
#include "Action.h"
#include "ActionGeneralPage.h"
#include "ActionCmdLinePage.h"
#include "ActionEmailPage.h"
#include "ActionLogFilePage.h"
#include "ActionNtEventLogPage.h"
#include "ActionPagingPage.h"
#include "ActionScriptPage.h"
#include "ActionSchedulePage.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// {EF423181-CA9B-11d2-BD8E-0000F87A3912}
static GUID GUID_Action = 
{ 0xef423181, 0xca9b, 0x11d2, { 0xbd, 0x8e, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };


IMPLEMENT_DYNCREATE(CActionScopeItem,CHMScopeItem)

// icon table - associates state to icons
static UINT _Icons[] =
{
	//  0 = DEFAULT
	IDI_ICON_ACTION,

	//  1 = COMMAND LINE
	IDI_ICON_ACTION_CMDLINE,

	//  2 = EMAIL
	IDI_ICON_ACTION_EMAIL,

	//  3 = LOGFILE
	IDI_ICON_ACTION_LOGFILE,

	//  4 = NT EVENT
	IDI_ICON_ACTION_NTEVENT,

	//  5 = SCRIPT
	IDI_ICON_ACTION_SCRIPT,

	//  6 = PAGING
	IDI_ICON_ACTION_PAGER

};


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CActionScopeItem::CActionScopeItem()
{
	m_lpguidItemType = &GUID_Action;
}

CActionScopeItem::~CActionScopeItem()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Creation Members
//////////////////////////////////////////////////////////////////////

bool CActionScopeItem::Create(CScopePane* pScopePane, CScopePaneItem* pParentItem)
{
	TRACEX(_T("CActionScopeItem::Create\n"));
	TRACEARGn(pScopePane);
	TRACEARGn(pParentItem);

	// set up all the icons first
	CAction* pAction = (CAction*)GetObjectPtr();
	if( ! GfxCheckObjPtr(pAction,CAction) )
	{
		return false;
	}

	int iIconIndex = 0;

	switch( pAction->GetType() )
	{
		case IDM_ACTION_CMDLINE:
		{
			iIconIndex = 1;
		}
		break;

		case IDM_ACTION_EMAIL:
		{
			iIconIndex = 2;
		}
		break;

		case IDM_ACTION_LOGFILE:
		{
			iIconIndex = 3;
		}
		break;

		case IDM_ACTION_NTEVENT:
		{
			iIconIndex = 4;
		}
		break;

		case IDM_ACTION_SCRIPT:
		{
			iIconIndex = 5;
		}
		break;

		case IDM_ACTION_PAGING:
		{
			iIconIndex = 6;
		}
		break;

		default:
		{
			ASSERT(FALSE);
		}
		break;
	}

	m_IconResIds.Add(_Icons[iIconIndex]);
	m_OpenIconResIds.Add(_Icons[iIconIndex]);
    //------------------------------------------------------------------------------------------------------
    // v-marfin : 59492
    // Only 1 icon was being loaded above. So any attempt to set a different icon (based on its state for 
    // example), failed since its index would be out of range. 
    // Other scope pane items have icons associated with each state they can be in, and they are loaded
    // into their m_IconResIds array. When a state changes, the icon at the [state] index is selected.
    //
    // So here, when we determine the type of action this is (iIconIndex), we will load our own
    // m_IconResIds with icons associated with state. This presents one small problem however, the state
    // codes do not run in 0,1,2,3,4 etc order, so we have a choice of either just loading the state icons 
    // and converting the index at SetIconIndex time based on the state, or set just those positions represented 
    // by the possible states. At this late stage of the game I will choose the latter, not being intimately 
    // familiar with this system. Can always come back later and change to 1st choice once I am more 
    // comfortable with the system. For now, fix bugs.
	
    // v-marfin 59492 : Since the icons are handled according to a state code sequence of:
    // 0 = good
    // 1 = collecting
    // 2 = reset
    // 3 = info
    // 4 = disabled
    // 5 = scheduled outage
    // 6 = unknown
    //

    // Set the icon table accordingly. Note that for Actions the only used icons are 
    // for position 0,4 and 5 so set the other icons to the normal state.
    switch( pAction->GetType() )
	{
		case IDM_ACTION_CMDLINE:
		{
            // v-marfin 59492
            // Forget the preload that went on above...
            // First load all the occurrences with the normal icon
            for (int x=0;x<7; x++)
            {
	            m_IconResIds.SetAtGrow(x,IDI_ICON_ACTION_CMDLINE);
	            m_OpenIconResIds.SetAtGrow(x,IDI_ICON_ACTION_CMDLINE);
            }
            m_IconResIds.SetAtGrow(HMS_DISABLED,IDI_ICON_ACTION_CMDLINE_DISABLED);
            m_OpenIconResIds.SetAtGrow(HMS_DISABLED,IDI_ICON_ACTION_CMDLINE_DISABLED);
            m_IconResIds.SetAtGrow(HMS_SCHEDULEDOUT,IDI_ICON_ACTION_CMDLINE_OUTAGE);
            m_OpenIconResIds.SetAtGrow(HMS_SCHEDULEDOUT,IDI_ICON_ACTION_CMDLINE_OUTAGE);
		}
		break;

		case IDM_ACTION_EMAIL:
		{
            // v-marfin 59492
            // Forget the preload that went on above...
            // First load all the occurrences with the normal icon
            for (int x=0;x<7; x++)
            {
	            m_IconResIds.SetAtGrow(x,IDI_ICON_ACTION_EMAIL);
	            m_OpenIconResIds.SetAtGrow(x,IDI_ICON_ACTION_EMAIL);
            }
            m_IconResIds.SetAtGrow(HMS_DISABLED,IDI_ICON_ACTION_EMAIL_DISABLED);
            m_OpenIconResIds.SetAtGrow(HMS_DISABLED,IDI_ICON_ACTION_EMAIL_DISABLED);
            m_IconResIds.SetAtGrow(HMS_SCHEDULEDOUT,IDI_ICON_ACTION_EMAIL_OUTAGE);
            m_OpenIconResIds.SetAtGrow(HMS_SCHEDULEDOUT,IDI_ICON_ACTION_EMAIL_OUTAGE);
		}
		break;

		case IDM_ACTION_LOGFILE:
		{
            // v-marfin 59492
            // Forget the preload that went on above...
            // First load all the occurrences with the normal icon
            for (int x=0;x<7; x++)
            {
	            m_IconResIds.SetAtGrow(x,IDI_ICON_ACTION_LOGFILE);
	            m_OpenIconResIds.SetAtGrow(x,IDI_ICON_ACTION_LOGFILE);
            }
            m_IconResIds.SetAtGrow(HMS_DISABLED,IDI_ICON_ACTION_LOGFILE_DISABLED);
            m_OpenIconResIds.SetAtGrow(HMS_DISABLED,IDI_ICON_ACTION_LOGFILE_DISABLED);
            m_IconResIds.SetAtGrow(HMS_SCHEDULEDOUT,IDI_ICON_ACTION_LOGFILE_OUTAGE);
            m_OpenIconResIds.SetAtGrow(HMS_SCHEDULEDOUT,IDI_ICON_ACTION_LOGFILE_OUTAGE);
		}
		break;

		case IDM_ACTION_NTEVENT:
		{
            // v-marfin 59492
            // Forget the preload that went on above...
            // First load all the occurrences with the normal icon
            for (int x=0;x<7; x++)
            {
	            m_IconResIds.SetAtGrow(x,IDI_ICON_ACTION_NTEVENT);
	            m_OpenIconResIds.SetAtGrow(x,IDI_ICON_ACTION_NTEVENT);
            }
            m_IconResIds.SetAtGrow(HMS_DISABLED,IDI_ICON_ACTION_NTEVENT_DISABLED);
            m_OpenIconResIds.SetAtGrow(HMS_DISABLED,IDI_ICON_ACTION_NTEVENT_DISABLED);
            m_IconResIds.SetAtGrow(HMS_SCHEDULEDOUT,IDI_ICON_ACTION_NTEVENT_OUTAGE);
            m_OpenIconResIds.SetAtGrow(HMS_SCHEDULEDOUT,IDI_ICON_ACTION_NTEVENT_OUTAGE);
		}
		break;

		case IDM_ACTION_SCRIPT:
		{
            // v-marfin 59492
            // Forget the preload that went on above...
            // First load all the occurrences with the normal icon
            for (int x=0;x<7; x++)
            {
	            m_IconResIds.SetAtGrow(x,IDI_ICON_ACTION_SCRIPT);
	            m_OpenIconResIds.SetAtGrow(x,IDI_ICON_ACTION_SCRIPT);
            }
            m_IconResIds.SetAtGrow(HMS_DISABLED,IDI_ICON_ACTION_SCRIPT_DISABLED);
            m_OpenIconResIds.SetAtGrow(HMS_DISABLED,IDI_ICON_ACTION_SCRIPT_DISABLED);
            m_IconResIds.SetAtGrow(HMS_SCHEDULEDOUT,IDI_ICON_ACTION_SCRIPT_OUTAGE);
            m_OpenIconResIds.SetAtGrow(HMS_SCHEDULEDOUT,IDI_ICON_ACTION_SCRIPT_OUTAGE);
		}
		break;

		case IDM_ACTION_PAGING:
		{
			// Not using
		}
		break;

		default:
		{
			ASSERT(FALSE);
		}
		break;
	}
    //------------------------------------------------------------------------------------------------------


	SetIconIndex(0);
	SetOpenIconIndex(0);

    // v-marfin: 59492 ---------------------------------------------------------------------------
    // Shouldn't this be set to the current state? -------------------------------------
    SetIconIndex(GetObjectPtr()->GetState());
    SetOpenIconIndex(GetObjectPtr()->GetState());
    //--------------------------------------------------------------------------------------------


	// call base class Create method
	if( ! CScopePaneItem::Create(pScopePane,pParentItem) )
	{
		TRACE(_T("CScopePaneItem::Create failed.\n"));
		return false;
	}

	// set display names
	CString sName;
	sName.LoadString(IDS_STRING_ACTION);
	SetDisplayName(0,sName);

	return true;
}


//////////////////////////////////////////////////////////////////////	
// Results Pane View Members
//////////////////////////////////////////////////////////////////////

CResultsPaneView* CActionScopeItem::CreateResultsPaneView()
{	
	TRACEX(_T("CActionScopeItem::CreateResultsPaneView\n"));

	return new CActionResultsView;
}

//////////////////////////////////////////////////////////////////////	
// MMC Notify Handlers
//////////////////////////////////////////////////////////////////////	

HRESULT CActionScopeItem::OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed)
{
	TRACEX(_T("CActionScopeItem::OnAddMenuItems\n"));
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

  HRESULT hr = S_OK;

  // Add New Menu Items
  if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed )
  {
	}

  // Add Task Menu Items
  if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

		// clear events
    sResString.LoadString(IDS_STRING_CLEAR_EVENTS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_CLEAR_EVENTS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_CLEAR_EVENTS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

		// disable actions
    sResString.LoadString(IDS_STRING_DISABLE_ACTIONS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_DISABLE_ACTIONS_DESC);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_DISABLE_ACTIONS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

        // v-marfin 59492 : Indicate on menu whether is disabled or not
        //------------------------------------------------------------
	    CHMObject* pObject = GetObjectPtr();
        CHMScopeItem* pParentItem = (CHMScopeItem*)GetParent();        

        // disable menu item if null object ptr or parent is disabled
	    if( ! pObject || (pParentItem && pParentItem->GetObjectPtr()
                  && !pParentItem->GetObjectPtr()->IsEnabled()) )
                     
	    {
		    cmi.fFlags = MF_DISABLED|MF_GRAYED;
	    }
	    else
	    {
		    int iState = pObject->IsEnabled();
		    if( iState == -1 )
		    {
			    cmi.fFlags = MF_DISABLED|MF_GRAYED;
		    }
		    else if( iState == 0 )
		    {
			    cmi.fFlags = MF_CHECKED;
		    }
		    else if( iState == 1 )
		    {
			    cmi.fFlags = MF_UNCHECKED;
		    }
	    }
        //------------------------------------------------------------

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

		// separator
		cmi.strName           = NULL;
		cmi.strStatusBarText  = NULL;
		cmi.lCommandID        = NULL;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = MF_SEPARATOR;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
  }

  // Add View Menu Items
  if( CCM_INSERTIONALLOWED_VIEW & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_STATUS_ONLY);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_STATUS_ONLY_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_STATUS_ONLY;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_UNCHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    sResString.LoadString(IDS_STRING_ICONS_STATUS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ICONS_STATUS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ICONS_WITH_STATUS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_CHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    // icon legend
    sResString.LoadString(IDS_STRING_ICON_LEGEND);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ICON_LEGEND_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ICON_LEGEND;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
  }

	return hr;
}

HRESULT CActionScopeItem::OnCommand(long lCommandID)
{
	TRACEX(_T("CActionScopeItem::OnCommand\n"));
	TRACEARGn(lCommandID);

  HRESULT hr = S_OK;

	switch(lCommandID)
	{
		case IDM_CLEAR_EVENTS:
		{
		}
		break;

		case IDM_DISABLE_ACTIONS:
		{
			CHMObject* pObject = GetObjectPtr();
			if( ! pObject )
			{
				ASSERT(FALSE);
				return E_FAIL;
			}

			if( pObject->IsEnabled() )
			{
				pObject->Disable();
			}
			else
			{
				pObject->Enable();
			}
		}
		break;

		default:
		{
			hr = CHMScopeItem::OnCommand(lCommandID);
		}
		break;
	}

  return hr;
}

HRESULT CActionScopeItem::OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle)
{
	TRACEX(_T("CActionScopeItem::OnCreatePropertyPages\n"));
	TRACEARGn(lpProvider);
	TRACEARGn(handle);

	if( m_pScopePane == NULL )
	{
		return S_FALSE;
	}

	HRESULT hr = S_OK;

	CAction* pAction = (CAction*)GetObjectPtr();
	if( ! GfxCheckObjPtr(pAction,CAction) )
	{
		return E_FAIL;
	}


	// v-marfin bug 59643b : Make General Page the first page, but set
    //                       details page as the focus on a new data collector.
	CActionGeneralPage* pPage1 = new CActionGeneralPage;
	pPage1->SetObjectPtr(pAction);
	HPROPSHEETPAGE hPage1 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage1->m_psp) );
	hr = lpProvider->AddPage(hPage1);


	switch( pAction->GetType() )
	{
		case IDM_ACTION_CMDLINE:
		{
			CActionCmdLinePage* pPage2 = new CActionCmdLinePage;
			pPage2->SetObjectPtr(pAction);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);			
		}
		break;

		case IDM_ACTION_EMAIL:
		{
			CActionEmailPage* pPage2 = new CActionEmailPage;
			pPage2->SetObjectPtr(pAction);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);			
		}
		break;

		case IDM_ACTION_LOGFILE:
		{
			CActionLogFilePage* pPage2 = new CActionLogFilePage;
			pPage2->SetObjectPtr(pAction);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);
		}
		break;

		case IDM_ACTION_NTEVENT:
		{
			CActionNtEventLogPage* pPage2 = new CActionNtEventLogPage;
			pPage2->SetObjectPtr(pAction);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);
		}
		break;

		case IDM_ACTION_SCRIPT:
		{
			CActionScriptPage* pPage2 = new CActionScriptPage;
			pPage2->SetObjectPtr(pAction);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);
		}
		break;

		case IDM_ACTION_PAGING:
		{
			CActionPagingPage* pPage2 = new CActionPagingPage;
			pPage2->SetObjectPtr(pAction);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);
		}
		break;

		default:
		{
			ASSERT(FALSE);
		}
		break;
	}



	CActionSchedulePage* pPage3 = new CActionSchedulePage;
	pPage3->SetObjectPtr(pAction);
	HPROPSHEETPAGE hPage3 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage3->m_psp) );
	hr = lpProvider->AddPage(hPage3);


	return hr;
}

HRESULT CActionScopeItem::OnSelect(CResultsPane* pPane, BOOL bSelected)
{
	TRACEX(_T("CActionScopeItem::OnSelect\n"));
	TRACEARGn(pPane);
	TRACEARGn(bSelected);

	if( ! CHECKHRESULT(CHMScopeItem::OnSelect(pPane,bSelected)) )
	{
		TRACE(_T("FAILED : CHMScopeItem::OnSelect returns failure.\n"));
		return E_FAIL;
	}

	if( ! bSelected ) // we are being de-selected so do not do anything
	{
		return S_OK;
	}

	LPCONSOLEVERB lpConsoleVerb = pPane->GetConsoleVerbPtr();

  HRESULT hr = lpConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

	hr = lpConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetDefaultVerb failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_RENAME, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_CUT, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}
	
  hr = lpConsoleVerb->SetVerbState( MMC_VERB_COPY, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_PASTE, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}
	
	lpConsoleVerb->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionscriptpage.h ===
#if !defined(AFX_ACTIONSCRIPTPAGE_H__10AC0369_5D70_11D3_939D_00A0CC406605__INCLUDED_)
#define AFX_ACTIONSCRIPTPAGE_H__10AC0369_5D70_11D3_939D_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ActionScriptPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CActionScriptPage dialog

class CActionScriptPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CActionScriptPage)

// Construction
public:
	CActionScriptPage();
	~CActionScriptPage();

// Dialog Data
	//{{AFX_DATA(CActionScriptPage)
	enum { IDD = IDD_ACTION_SCRIPT };
	CComboBox	m_ScriptEngine;
	CComboBox	m_TimeoutUnits;
	CString	m_sFileName;
	int		m_iTimeout;
	int		m_iScriptEngine;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CActionScriptPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CActionScriptPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonBrowseFile();
	afx_msg void OnButtonOpen();
	afx_msg void OnSelendokComboScriptEngine();
	afx_msg void OnSelendokComboTimeoutUnits();
	afx_msg void OnChangeEditFileName();
	afx_msg void OnChangeEditText();
	afx_msg void OnChangeEditTimeout();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACTIONSCRIPTPAGE_H__10AC0369_5D70_11D3_939D_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionschedulepage.h ===
#if !defined(AFX_ACTIONSCHEDULEPAGE_H__7C918D5D_6F84_11D3_BE5C_0000F87A3912__INCLUDED_)
#define AFX_ACTIONSCHEDULEPAGE_H__7C918D5D_6F84_11D3_BE5C_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ActionSchedulePage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CActionSchedulePage dialog

class CActionSchedulePage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CActionSchedulePage)

// Construction
public:
	CActionSchedulePage();
	~CActionSchedulePage();

// Dialog Data
	//{{AFX_DATA(CActionSchedulePage)
	enum { IDD = IDD_ACTION_SCHEDULE };
	CDateTimeCtrl	m_StartTimeCtrl2;
	CDateTimeCtrl	m_StartTimeCtrl1;
	CDateTimeCtrl	m_EndTimeCtrl2;
	CDateTimeCtrl	m_EndTimeCtrl1;
	BOOL	m_bFriday;
	BOOL	m_bMonday;
	BOOL	m_bSaturday;
	BOOL	m_bSunday;
	BOOL	m_bThursday;
	BOOL	m_bTuesday;
	BOOL	m_bWednesday;
	CTime	m_EndTime_1;
	CTime	m_EndTime_2;
	CTime	m_StartTime_1;
	CTime	m_StartTime_2;	
	int		m_iDataCollection;
	//}}AFX_DATA

	int m_iActiveDays;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CActionSchedulePage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CActionSchedulePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckFriday();
	afx_msg void OnCheckMonday();
	afx_msg void OnCheckSaturday();
	afx_msg void OnCheckSunday();
	afx_msg void OnCheckThursday();
	afx_msg void OnCheckTuesday();
	afx_msg void OnCheckWednesday();
	afx_msg void OnDatetimechangeDatetimepickerEnd1(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDatetimechangeDatetimepickerEnd2(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDatetimechangeDatetimepickerOnce(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDatetimechangeDatetimepickerStart1(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDatetimechangeDatetimepickerStart2(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRadioAllDay();
	afx_msg void OnRadioAllDayExcept();
	afx_msg void OnRadioOnceDaily();
	afx_msg void OnRadioOnlyFrom();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACTIONSCHEDULEPAGE_H__7C918D5D_6F84_11D3_BE5C_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionscopeitem.h ===
// ActionScopeItem.h: interface for the CActionScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACTIONSCOPEITEM_H__71DD9241_CA88_11D2_BD8E_0000F87A3912__INCLUDED_)
#define AFX_ACTIONSCOPEITEM_H__71DD9241_CA88_11D2_BD8E_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMScopeItem.h"

class CActionScopeItem : public CHMScopeItem  
{
DECLARE_DYNCREATE(CActionScopeItem)

// Construction/Destruction
public:
	CActionScopeItem();
	virtual ~CActionScopeItem();

// Creation Members
public:
	virtual bool Create(CScopePane* pScopePane, CScopePaneItem* pParentItem);
	
// Results Pane View Members
public:
	virtual CResultsPaneView* CreateResultsPaneView();

// MMC Notify Handlers
public:
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed);
  virtual HRESULT OnCommand(long lCommandID);
	virtual HRESULT OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle);
	virtual HRESULT OnExpand(BOOL bExpand) { return CScopePaneItem::OnExpand(bExpand); }
	virtual HRESULT OnSelect(CResultsPane* pPane,BOOL bSelected);

};

#endif // !defined(AFX_ACTIONSCOPEITEM_H__71DD9241_CA88_11D2_BD8E_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionscriptpage.cpp ===
// ActionScriptPage.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
// 03/28/00 v-marfin 61030 Change Browse for file dialog to fix default extension

#include "stdafx.h"
#include "snapin.h"
#include "ActionScriptPage.h"
#include "Action.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CActionScriptPage property page

IMPLEMENT_DYNCREATE(CActionScriptPage, CHMPropertyPage)

CActionScriptPage::CActionScriptPage() : CHMPropertyPage(CActionScriptPage::IDD)
{
	//{{AFX_DATA_INIT(CActionScriptPage)
	m_sFileName = _T("");
	m_iTimeout = 0;
	m_iScriptEngine = -1;
	//}}AFX_DATA_INIT

	m_sHelpTopic = _T("HMon21.chm::/dscrpact.htm");
}

CActionScriptPage::~CActionScriptPage()
{
}

void CActionScriptPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CActionScriptPage)
	DDX_Control(pDX, IDC_COMBO_SCRIPT_ENGINE, m_ScriptEngine);
	DDX_Control(pDX, IDC_COMBO_TIMEOUT_UNITS, m_TimeoutUnits);
	DDX_Text(pDX, IDC_EDIT_FILE_NAME, m_sFileName);
	DDX_Text(pDX, IDC_EDIT_TIMEOUT, m_iTimeout);
	DDX_CBIndex(pDX, IDC_COMBO_SCRIPT_ENGINE, m_iScriptEngine);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CActionScriptPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CActionScriptPage)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_FILE, OnButtonBrowseFile)
	ON_BN_CLICKED(IDC_BUTTON_OPEN, OnButtonOpen)
	ON_CBN_SELENDOK(IDC_COMBO_SCRIPT_ENGINE, OnSelendokComboScriptEngine)
	ON_CBN_SELENDOK(IDC_COMBO_TIMEOUT_UNITS, OnSelendokComboTimeoutUnits)
	ON_EN_CHANGE(IDC_EDIT_FILE_NAME, OnChangeEditFileName)
	ON_EN_CHANGE(IDC_EDIT_TEXT, OnChangeEditText)
	ON_EN_CHANGE(IDC_EDIT_TIMEOUT, OnChangeEditTimeout)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CActionScriptPage message handlers

BOOL CActionScriptPage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();
	
	CWbemClassObject* pConsumerObject = ((CAction*)GetObjectPtr())->GetConsumerClassObject();

	if( pConsumerObject )
	{
		CString sScriptEngine;
		pConsumerObject->GetProperty(_T("ScriptingEngine"),sScriptEngine);
		sScriptEngine.MakeUpper();
		if( sScriptEngine == _T("VBSCRIPT") )
		{
			m_iScriptEngine = 0;
		}
		else if( sScriptEngine == _T("JSCRIPT") )
		{
			m_iScriptEngine = 1;
		}
		pConsumerObject->GetProperty(_T("ScriptFileName"),m_sFileName);
		pConsumerObject->GetProperty(_T("KillTimeout"),m_iTimeout);
		m_TimeoutUnits.SetCurSel(0);
		delete pConsumerObject;

	}

	SendDlgItemMessage(IDC_SPIN2,UDM_SETRANGE32,0,9999);
	SendDlgItemMessage(IDC_SPIN3,UDM_SETRANGE32,0,9999);

	UpdateData(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CActionScriptPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();

	if( m_sFileName.IsEmpty() )
	{
		return FALSE;
	}

	int iOldTimeout = m_iTimeout;
	switch( m_TimeoutUnits.GetCurSel() )
	{
		case 1: // minutes
		{
			m_iTimeout *= 60;
		}
		break;

		case 2: // hours
		{
			m_iTimeout *= 360;
		}
		break;
	}

	CWbemClassObject* pConsumerObject = ((CAction*)GetObjectPtr())->GetConsumerClassObject();

	if( pConsumerObject )
	{
		CString sScriptEngine;
		m_ScriptEngine.GetLBText(m_iScriptEngine,sScriptEngine);
		pConsumerObject->SetProperty(_T("ScriptingEngine"),sScriptEngine);
		pConsumerObject->SetProperty(_T("ScriptFileName"),m_sFileName);
		pConsumerObject->SetProperty(_T("KillTimeout"),m_iTimeout);		
		pConsumerObject->SaveAllProperties();
		delete pConsumerObject;
	}

	m_iTimeout = iOldTimeout;

  SetModified(FALSE);

	return TRUE;
}

void CActionScriptPage::OnButtonBrowseFile() 
{
	UpdateData();

	CString sFilter;
	CString sTitle;

	sFilter.LoadString(IDS_STRING_FILTER);
	sTitle.LoadString(IDS_STRING_BROWSE_FILE);

	// v-marfin 61030 Change Browse for file dialog to fix default extension
	// CFileDialog fdlg(TRUE,_T("*.*"),NULL,OFN_FILEMUSTEXIST|OFN_SHAREAWARE|OFN_HIDEREADONLY,sFilter);
	CFileDialog fdlg(TRUE,			// Is FILEOPEN dialog?
					 NULL,			// default extension if no extension provided
					 NULL,			// initial filename
					 OFN_FILEMUSTEXIST|OFN_SHAREAWARE|OFN_HIDEREADONLY,  // flags
					 sFilter);		// filter

	fdlg.m_ofn.lpstrTitle = sTitle;

	if( fdlg.DoModal() == IDOK )
	{
		m_sFileName = fdlg.GetPathName();
		UpdateData(FALSE);
	}

	SetModified();
	
}

void CActionScriptPage::OnButtonOpen() 
{
	if( ! m_sFileName.IsEmpty() )
	{
		CString sCmdLine = _T("notepad.exe ")+m_sFileName;		
		USES_CONVERSION;
		WinExec(T2A(sCmdLine),SW_SHOW);		
	}
}

void CActionScriptPage::OnSelendokComboScriptEngine() 
{
	SetModified();
	UpdateData();
	
}

void CActionScriptPage::OnSelendokComboTimeoutUnits() 
{
	SetModified();
	UpdateData();
}

void CActionScriptPage::OnChangeEditFileName() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	if( m_ScriptEngine.GetSafeHwnd() )
	{
		UpdateData();
	}

}

void CActionScriptPage::OnChangeEditText() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	if( m_ScriptEngine.GetSafeHwnd() )
	{
		UpdateData();
	}

}

void CActionScriptPage::OnChangeEditTimeout() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	if( m_ScriptEngine.GetSafeHwnd() )
	{
		UpdateData();
	}

}


void CActionScriptPage::OnDestroy() 
{
	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionstatuslistener.h ===
// ActionStatusListener.h: interface for the CActionStatusListener class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACTIONSTATUSLISTENER_H__30A5D5C8_0C6E_4A19_BDB7_235A2173A42F__INCLUDED_)
#define AFX_ACTIONSTATUSLISTENER_H__30A5D5C8_0C6E_4A19_BDB7_235A2173A42F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemEventListener.h"

class CActionStatusListener : public CWbemEventListener  
{

DECLARE_DYNCREATE(CActionStatusListener)

// Construction/Destruction
public:
	CActionStatusListener();
	virtual ~CActionStatusListener();

// Processing Operations
protected:
  virtual HRESULT ProcessEventClassObject(IWbemClassObject* pClassObject);
};

#endif // !defined(AFX_ACTIONSTATUSLISTENER_H__30A5D5C8_0C6E_4A19_BDB7_235A2173A42F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\alertpage.cpp ===
// AlertPage.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "AlertPage.h"
#include "ScopePane.h"
#include "HMListView.h"
#include "HMEventResultsPaneItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAlertPage property page

IMPLEMENT_DYNCREATE(CAlertPage, CPropertyPage)

CAlertPage::CAlertPage() : CPropertyPage(CAlertPage::IDD)
{
	//{{AFX_DATA_INIT(CAlertPage)
	m_sAlert = _T("");
	m_sComputer = _T("");
	m_sDataCollector = _T("");
	m_sDTime = _T("");
	m_sID = _T("");
	m_sSeverity = _T("");
	//}}AFX_DATA_INIT
}

CAlertPage::~CAlertPage()
{
}

void CAlertPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAlertPage)
	DDX_Text(pDX, IDC_EDIT_ALERT, m_sAlert);
	DDX_Text(pDX, IDC_EDIT_COMPUTER, m_sComputer);
	DDX_Text(pDX, IDC_EDIT_DATA_COLLECTOR, m_sDataCollector);
	DDX_Text(pDX, IDC_EDIT_DTIME, m_sDTime);
	DDX_Text(pDX, IDC_EDIT_ID, m_sID);
	DDX_Text(pDX, IDC_EDIT_SEVERITY, m_sSeverity);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAlertPage, CPropertyPage)
	//{{AFX_MSG_MAP(CAlertPage)
	ON_WM_HELPINFO()
	ON_BN_CLICKED(IDC_BUTTON_NEXT, OnButtonNext)
	ON_BN_CLICKED(IDC_BUTTON_PREVIOUS, OnButtonPrevious)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAlertPage message handlers

BOOL CAlertPage::OnInitDialog() 
{
	CDialog::OnInitDialog();  
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CAlertPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
  if( m_pScopePane )
  {
    m_pScopePane->ShowTopic(_T("HMon21.chm::/oHMon21.htm"));
  }	
  	
	return CDialog::OnHelpInfo(pHelpInfo);
}

void CAlertPage::OnButtonNext() 
{
  if( m_iIndex > m_pListView->GetItemCount() )
  {
	  return;
  }
  m_iIndex++;

  CHMEventResultsPaneItem* pItem = (CHMEventResultsPaneItem*)m_pListView->GetItem(m_iIndex);
  if( ! GfxCheckObjPtr(pItem,CHMEventResultsPaneItem) )
  {
    return;
  }

  m_sSeverity = pItem->GetDisplayName(0);
  m_sID = pItem->GetDisplayName(1);
  m_sDTime = pItem->GetDisplayName(2);
  m_sDataCollector = pItem->GetDisplayName(3);
  m_sComputer = pItem->GetDisplayName(4);
  m_sAlert = pItem->GetDisplayName(5);
  
  UpdateData(FALSE);
}

void CAlertPage::OnButtonPrevious() 
{
  if( m_iIndex == 0 )
  {
	  return;
  }
  m_iIndex--;

  CHMEventResultsPaneItem* pItem = (CHMEventResultsPaneItem*)m_pListView->GetItem(m_iIndex);
  if( ! GfxCheckObjPtr(pItem,CHMEventResultsPaneItem) )
  {
    return;
  }

  m_sSeverity = pItem->GetDisplayName(0);
  m_sID = pItem->GetDisplayName(1);
  m_sDTime = pItem->GetDisplayName(2);
  m_sDataCollector = pItem->GetDisplayName(3);
  m_sComputer = pItem->GetDisplayName(4);
  m_sAlert = pItem->GetDisplayName(5);
  
  UpdateData(FALSE);
}

LRESULT CAlertPage::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) 
{
	if( message == WM_COMMAND )
	{
		if( wParam == 57670 )
			OnHelpInfo(NULL);
	}

	return CPropertyPage::WindowProc(message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\allsystemsresultsview.h ===
// AllSystemsResultsView.h: interface for the CAllSystemsResultsView class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ALLSYSTEMSRESULTSVIEW_H__6A877572_B6D4_11D2_BD73_0000F87A3912__INCLUDED_)
#define AFX_ALLSYSTEMSRESULTSVIEW_H__6A877572_B6D4_11D2_BD73_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SplitPaneResultsView.h"

class CAllSystemsResultsView : public CSplitPaneResultsView  
{
DECLARE_DYNCREATE(CAllSystemsResultsView)

// Construction/Destruction
public:
	CAllSystemsResultsView();
	virtual ~CAllSystemsResultsView();

// Create/Destroy
public:
	virtual bool Create(CScopePaneItem* pOwnerItem);

};

#endif // !defined(AFX_ALLSYSTEMSRESULTSVIEW_H__6A877572_B6D4_11D2_BD73_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\allsystemsresultsview.cpp ===
// AllSystemsResultsView.cpp: implementation of the CAllSystemsResultsView class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "AllSystemsResultsView.h"
#include "HMListViewColumn.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CAllSystemsResultsView,CSplitPaneResultsView)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAllSystemsResultsView::CAllSystemsResultsView()
{

}

CAllSystemsResultsView::~CAllSystemsResultsView()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create/Destroy
//////////////////////////////////////////////////////////////////////

bool CAllSystemsResultsView::Create(CScopePaneItem* pOwnerItem)
{
	TRACEX(_T("CAllSystemsResultsView::Create\n"));
	TRACEARGn(pOwnerItem);

	if( ! CSplitPaneResultsView::Create(pOwnerItem) )
	{
		TRACE(_T("FAILED : CSplitPaneResultsView::Create failed.\n"));
		return false;
	}

	// add the upper columns
	CHMListViewColumn* pColumn = NULL;
	CString sTitle;
	DWORD dwFormat = LVCFMT_LEFT;

	// name
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NAME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// status
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_STATUS);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// Domain
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DOMAIN);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// OS
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_OS);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// WMI version
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_WMI_VERSION);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// normal
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NORMAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// warning
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_WARNING);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// critical
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_CRITICAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// unknown
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_UNKNOWN);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// last message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_LAST_MESSAGE);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// comment
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_COMMENT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// add the lower columns

	// Severity
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SEVERITY);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// ID
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_ID);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Date/Time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Component
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATA_POINT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// System
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SYSTEM);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_MESSAGE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// add the stats columns

	// time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// normal
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NORMAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// warning
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_WARNING);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// critical
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_CRITICAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// unknown
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_UNKNOWN);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\actionstatuslistener.cpp ===
// ActionStatusListener.cpp: implementation of the CActionStatusListener class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "ActionStatusListener.h"
#include "EventManager.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CActionStatusListener,CWbemEventListener)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CActionStatusListener::CActionStatusListener()
{
	SetEventQuery(IDS_STRING_ACTIONSTATUS_EVENTQUERY);
}

CActionStatusListener::~CActionStatusListener()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Event Processing Members
//////////////////////////////////////////////////////////////////////

HRESULT CActionStatusListener::ProcessEventClassObject(IWbemClassObject* pClassObject)
{
  ASSERT(pClassObject);
  if( pClassObject == NULL )
  {
    return E_FAIL;
  }
  
  HRESULT hr = S_OK;

	CWbemClassObject StatusObject;

	if( ! CHECKHRESULT(hr = StatusObject.Create(pClassObject)) )
	{
		return hr;
	}

	StatusObject.SetMachineName(GetObjectPtr()->GetSystemName());

	EvtGetEventManager()->ProcessActionEvent(&StatusObject);

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\allsystemsscopeitem.h ===
// AllSystemsScopeItem.h: interface for the CAllSystemsScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ALLSYSTEMSSCOPEITEM_H__6A877571_B6D4_11D2_BD73_0000F87A3912__INCLUDED_)
#define AFX_ALLSYSTEMSSCOPEITEM_H__6A877571_B6D4_11D2_BD73_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMScopeItem.h"

class CAllSystemsScopeItem : public CHMScopeItem
{

DECLARE_DYNCREATE(CAllSystemsScopeItem)

// Construction/Destruction
public:
	CAllSystemsScopeItem();
	virtual ~CAllSystemsScopeItem();

// Creation Members
public:
	virtual bool Create(CScopePane* pScopePane, CScopePaneItem* pParentItem);
	
// Results Pane View Members
public:
	virtual CResultsPaneView* CreateResultsPaneView();

// MMC Notify Handlers
public:
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed);
  virtual HRESULT OnCommand(long lCommandID);
	virtual HRESULT OnExpand(BOOL bExpand);
  virtual HRESULT OnSelect(CResultsPane* pPane,BOOL bSelected);
};

#endif // !defined(AFX_ALLSYSTEMSSCOPEITEM_H__6A877571_B6D4_11D2_BD73_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\allsystemsscopeitem.cpp ===
// AllSystemsScopeItem.cpp: implementation of the CAllSystemsScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "AllSystemsScopeItem.h"
#include "AllSystemsResultsView.h"
#include "HealthmonScopePane.h"
#include "SystemScopeItem.h"
#include "NewSystemDlg.h"
#include "SelectSystemsDlg.h"
#include "SystemGroup.h"
#include "System.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CAllSystemsScopeItem,CHMScopeItem)

// {AB5EA8C7-B6D5-11d2-BD73-0000F87A3912}
static GUID GUID_AllSystems = 
{ 0xab5ea8c7, 0xb6d5, 0x11d2, { 0xbd, 0x73, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

// icon table - associates state to icons
static UINT _Icons[HMS_MAX_STATES] =
{
	IDI_ICON_SYSTEMS,
	IDI_ICON_SYSTEMS_DISABLED,
	IDI_ICON_SYSTEMS_OUTAGE,
	IDI_ICON_SYSTEMS_UNKNOWN,
	IDI_ICON_SYSTEMS_NO_CONNECT,
	IDI_ICON_SYSTEMS_WARNING,
	IDI_ICON_SYSTEMS_CRITICAL

};

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAllSystemsScopeItem::CAllSystemsScopeItem()
{
	m_lpguidItemType = &GUID_AllSystems;
}

CAllSystemsScopeItem::~CAllSystemsScopeItem()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Creation Members
//////////////////////////////////////////////////////////////////////

bool CAllSystemsScopeItem::Create(CScopePane* pScopePane, CScopePaneItem* pParentItem)
{
	TRACEX(_T("CAllSystemsScopeItem::Create\n"));
	TRACEARGn(pScopePane);
	TRACEARGn(pParentItem);

	// set up all the icons first
	for( int i = 0; i < HMS_MAX_STATES; i++ )
	{
		UINT nId = _Icons[i];
		m_IconResIds.Add(nId);
		m_OpenIconResIds.Add(nId);
	}
	SetIconIndex(HMS_NORMAL);
	SetOpenIconIndex(HMS_NORMAL);

	// call base class Create method
	if( ! CHMScopeItem::Create(pScopePane,pParentItem) )
	{
		TRACE(_T("CHMScopeItem::Create failed.\n"));
		return false;
	}

	// set display names
	CString sName;
	sName.LoadString(IDS_STRING_ALL_SYSTEMS_NODE);
	SetDisplayName(0,sName);

	return true;
}


//////////////////////////////////////////////////////////////////////	
// Results Pane View Members
//////////////////////////////////////////////////////////////////////

CResultsPaneView* CAllSystemsScopeItem::CreateResultsPaneView()
{	
	TRACEX(_T("CAllSystemsScopeItem::CreateResultsPaneView\n"));

	return new CAllSystemsResultsView;
}

//////////////////////////////////////////////////////////////////////	
// MMC Notify Handlers
//////////////////////////////////////////////////////////////////////	

HRESULT CAllSystemsScopeItem::OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed)
{
	TRACEX(_T("CAllSystemsScopeItem::OnAddMenuItems\n"));
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

  HRESULT hr = S_OK;

	if( CCM_INSERTIONALLOWED_TOP & *pInsertionAllowed )
	{
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_NEW_SYSTEM);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_NEW_SYSTEM_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_NEW_SYSTEM;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
	}

  // Add New Menu Items
  if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed )
  {
	}

  // Add Task Menu Items
  if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_CLEAR_EVENTS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_CLEAR_EVENTS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_CLEAR_EVENTS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    sResString.LoadString(IDS_STRING_RESET_STATUS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_RESET_STATUS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_RESET_STATUS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

		// separator
		cmi.strName           = NULL;
		cmi.strStatusBarText  = NULL;
		cmi.lCommandID        = NULL;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = MF_SEPARATOR;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
  }

  // Add View Menu Items
  if( CCM_INSERTIONALLOWED_VIEW & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_STATUS_ONLY);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_STATUS_ONLY_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_STATUS_ONLY;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_UNCHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    sResString.LoadString(IDS_STRING_AUTO_FILTER);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_AUTO_FILTER_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_AUTO_FILTER;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_CHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    // icon legend
    sResString.LoadString(IDS_STRING_ICON_LEGEND);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ICON_LEGEND_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ICON_LEGEND;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
	}

	return hr;
}

HRESULT CAllSystemsScopeItem::OnCommand(long lCommandID)
{
	TRACEX(_T("CAllSystemsScopeItem::OnCommand\n"));
	TRACEARGn(lCommandID);

  HRESULT hr = S_OK;

	switch(lCommandID)
	{
		case IDM_NEW_SYSTEM:
		{
			CHealthmonScopePane* pPane = (CHealthmonScopePane*)GetScopePane();
			if( ! GfxCheckObjPtr(pPane,CHealthmonScopePane) )
			{
				TRACE(_T("FAILED : CGroupScopeItem::GetScopePane returns an invalid pointer.\n"));
				return E_FAIL;
			}
/*
			CNewSystemDlg dlg;

			if( dlg.DoModal() == IDOK )
			{
				CSystemGroup* pMSG = pPane->GetRootGroup();
				CHMObject* pASG = ((CHMObject*)pMSG)->GetChild(0);

				if( pASG->GetChild(dlg.m_sName) )
				{
					return S_OK;
				}

				CSystem* pNewSystem = new CSystem;
				pNewSystem->SetName(dlg.m_sName);
				pNewSystem->SetSystemName(dlg.m_sName);
				pNewSystem->SetScopePane(pPane);

				pASG->AddChild(pNewSystem);
				pNewSystem->Connect();
			}
	*/
			CSelectSystemsDlg dlg;

			if( dlg.DoModal() == IDOK )
			{
				CSystemGroup* pMSG = pPane->GetRootGroup();
				CHMObject* pASG = ((CHMObject*)pMSG)->GetChild(0);

				for( int i = 0; i < dlg.m_saSystems.GetSize(); i++ )
				{
					if( ! pASG->GetChild(dlg.m_saSystems[i]) )
					{
						IWbemServices* pServices = NULL;
						BOOL bAvail = FALSE;

						if( CnxGetConnection(dlg.m_saSystems[i],pServices,bAvail) == E_FAIL )
						{
							MessageBeep(MB_ICONEXCLAMATION);
						}

						if( pServices )
						{
							pServices->Release();
						}

						CSystem* pNewSystem = new CSystem;
						pNewSystem->SetName(dlg.m_saSystems[i]);
						pNewSystem->SetSystemName(dlg.m_saSystems[i]);
						pNewSystem->SetScopePane(pPane);

						pASG->AddChild(pNewSystem);
						pNewSystem->Connect();

						CActionPolicy* pPolicy = new CActionPolicy;
						pPolicy->SetSystemName(pNewSystem->GetName());
						pNewSystem->AddChild(pPolicy);
					}
				}				
			}

		}
		break;

		default:
		{
			hr = CHMScopeItem::OnCommand(lCommandID);
		}
	}

  return hr;
}

HRESULT CAllSystemsScopeItem::OnExpand(BOOL bExpand)
{
	TRACEX(_T("CAllSystemsScopeItem::OnExpand\n"));
	TRACEARGn(bExpand);

	CHMObject* pASG = GetObjectPtr();
	
	CString sLocalHost;
	DWORD dwLen = MAX_COMPUTERNAME_LENGTH;
	BOOL bResult = GetComputerName(sLocalHost.GetBuffer(MAX_COMPUTERNAME_LENGTH + 1),&dwLen);
	sLocalHost.ReleaseBuffer();
	
	if( pASG->GetChildCount() == 0 && bResult )
	{		
		IWbemServices* pServices = NULL;
		BOOL bAvail = FALSE;

		if( CnxGetConnection(sLocalHost,pServices,bAvail) == E_FAIL )
		{
			MessageBeep(MB_ICONEXCLAMATION);
		}

		if( pServices )
		{
			pServices->Release();
		}

		CSystem* pNewSystem = new CSystem;
		pNewSystem->SetName(sLocalHost);
		pNewSystem->SetSystemName(sLocalHost);
		pNewSystem->SetScopePane(GetScopePane());

		pASG->AddChild(pNewSystem);
		pNewSystem->Connect();

		CActionPolicy* pPolicy = new CActionPolicy;
		pPolicy->SetSystemName(pNewSystem->GetName());
		pNewSystem->AddChild(pPolicy);		
	}	

	return CScopePaneItem::OnExpand(bExpand);
}

HRESULT CAllSystemsScopeItem::OnSelect(CResultsPane* pPane, BOOL bSelected)
{
	TRACEX(_T("CAllSystemsScopeItem::OnSelect\n"));
	TRACEARGn(pPane);
	TRACEARGn(bSelected);

  static BOOL bSelectedOnce;

	CHMObject* pASG = GetObjectPtr();
	
	CString sLocalHost;
	DWORD dwLen = MAX_COMPUTERNAME_LENGTH;
	BOOL bResult = GetComputerName(sLocalHost.GetBuffer(MAX_COMPUTERNAME_LENGTH + 1),&dwLen);
	sLocalHost.ReleaseBuffer();
	
  if( bSelected && !bSelectedOnce && pASG->GetChildCount() == 1 && bResult )
  {
    if( pASG->GetChild(0)->GetSystemName().CompareNoCase(sLocalHost) == 0 )
    {
      for( int i = 0; i < pASG->GetChild(0)->GetScopeItemCount(); i++ )
      {
        pASG->GetChild(0)->GetScopeItem(i)->ExpandItem();
        bSelectedOnce = TRUE;
      }
      ExpandItem();
    }
  }

  return CScopePaneItem::OnSelect(pPane,bSelected);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\bccdialog.cpp ===
// BccDialog.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "BccDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBccDialog dialog


CBccDialog::CBccDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CBccDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CBccDialog)
	m_sBcc = _T("");
	//}}AFX_DATA_INIT
}


void CBccDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBccDialog)
	DDX_Text(pDX, IDC_EDIT_BCC, m_sBcc);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CBccDialog, CDialog)
	//{{AFX_MSG_MAP(CBccDialog)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBccDialog message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\alertpage.h ===
#if !defined(AFX_ALERTPAGE_H__60A8694A_3434_49CC_9BF6_E257E87400F0__INCLUDED_)
#define AFX_ALERTPAGE_H__60A8694A_3434_49CC_9BF6_E257E87400F0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AlertPage.h : header file
//

class CScopePane;
class _DHMListView;

/////////////////////////////////////////////////////////////////////////////
// CAlertPage Property Page

class CAlertPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CAlertPage)

// Construction
public:
	CAlertPage();
	~CAlertPage();

// Dialog Data
	//{{AFX_DATA(CAlertPage)
	enum { IDD = IDD_DIALOG_ALERT };
	CString	m_sAlert;
	CString	m_sComputer;
	CString	m_sDataCollector;
	CString	m_sDTime;
	CString	m_sID;
	CString	m_sSeverity;
	//}}AFX_DATA

  CScopePane* m_pScopePane;
  _DHMListView* m_pListView;
  int m_iIndex;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAlertPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAlertPage)
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnButtonNext();
	afx_msg void OnButtonPrevious();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ALERTPAGE_H__60A8694A_3434_49CC_9BF6_E257E87400F0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\ccdialog.cpp ===
// CcDialog.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "CcDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCcDialog dialog


CCcDialog::CCcDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CCcDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCcDialog)
	m_sCc = _T("");
	//}}AFX_DATA_INIT
}


void CCcDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCcDialog)
	DDX_Text(pDX, IDC_EDIT_CC, m_sCc);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCcDialog, CDialog)
	//{{AFX_MSG_MAP(CCcDialog)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCcDialog message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\ccdialog.h ===
#if !defined(AFX_CCDIALOG_H__342597AA_96F7_11D3_BE93_0000F87A3912__INCLUDED_)
#define AFX_CCDIALOG_H__342597AA_96F7_11D3_BE93_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CcDialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCcDialog dialog

class CCcDialog : public CDialog
{
// Construction
public:
	CCcDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCcDialog)
	enum { IDD = IDD_DIALOG_CC };
	CString	m_sCc;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCcDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCcDialog)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CCDIALOG_H__342597AA_96F7_11D3_BE93_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\cleareventsdlg.h ===
#if !defined(AFX_CLEAREVENTSDLG_H__3ADB0FD5_C4FA_11D2_BD83_0000F87A3912__INCLUDED_)
#define AFX_CLEAREVENTSDLG_H__3ADB0FD5_C4FA_11D2_BD83_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ClearEventsDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CClearEventsDlg dialog

class CClearEventsDlg : public CDialog
{
// Construction
public:
	CClearEventsDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CClearEventsDlg)
	enum { IDD = IDD_DIALOG_CLEAREVENTS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClearEventsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CClearEventsDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLEAREVENTSDLG_H__3ADB0FD5_C4FA_11D2_BD83_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\configcreationlistener.cpp ===
// ConfigCreationListener.cpp: implementation of the CConfigCreationListener class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Snapin.h"
#include "ConfigCreationListener.h"
#include "DataGroup.h"
#include "DataElement.h"
#include "Rule.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CConfigCreationListener,CWbemEventListener)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CConfigCreationListener::CConfigCreationListener()
{
	SetEventQuery(IDS_STRING_CONFIGCREATION_EVENTQUERY);
}

CConfigCreationListener::~CConfigCreationListener()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Event Processing Members
//////////////////////////////////////////////////////////////////////

HRESULT CConfigCreationListener::ProcessEventClassObject(IWbemClassObject* pClassObject)
{
  ASSERT(pClassObject);
  if( pClassObject == NULL )
  {
    return E_FAIL;
  }
  
  HRESULT hr = S_OK;

	CWbemClassObject EventObject;

	if( ! CHECKHRESULT(hr = EventObject.Create(pClassObject)) )
	{
		return hr;
	}

	EventObject.SetMachineName(GetObjectPtr()->GetSystemName());

  CString sClass;
  EventObject.GetProperty(_T("__CLASS"),sClass);
  
  CString sGuid;
  EventObject.GetProperty(IDS_STRING_MOF_GUID,sGuid);
  sGuid.TrimLeft(_T("{"));
  sGuid.TrimRight(_T("}"));

  CWbemClassObject ParentObject;
  
  ParentObject.SetMachineName(GetObjectPtr()->GetSystemName());

  CString sQuery;
  sQuery.Format(_T("ASSOCIATORS OF {Microsoft_HMConfiguration.GUID=\"{%s}\"} WHERE ResultClass=Microsoft_HMConfiguration Role=ChildPath"),sGuid);
  
  BSTR bsQuery = sQuery.AllocSysString();
  hr = ParentObject.ExecQuery(bsQuery);
  ::SysFreeString(bsQuery);
  
  if( !CHECKHRESULT(hr) )
  {
    return hr;
  }

  ULONG ulReturned = 0L;
  hr = ParentObject.GetNextObject(ulReturned);

  if( !CHECKHRESULT(hr) || ulReturned <= 0L )
  {
    return hr;
  }

  CString sParentGuid;
  ParentObject.GetProperty(IDS_STRING_MOF_GUID,sParentGuid);
  sParentGuid.TrimLeft(_T("{"));
  sParentGuid.TrimRight(_T("}"));

  CHMObject* pParentObject = GetObjectPtr()->GetDescendantByGuid(sParentGuid);

	// create a new and add as a child
	if( pParentObject && ! pParentObject->GetChildByGuid(sGuid) )
	{    
		CHMObject* pNewObject = NULL;
    if( sClass.Find(IDS_STRING_MOF_DATAELEMENT) != -1 )
    {
      pNewObject = new CDataElement;
    }
    else if( sClass.Find(IDS_STRING_MOF_DATAGROUP) != -1 )
    {
      pNewObject = new CDataGroup;
    }
    else if( sClass.Find(IDS_STRING_MOF_RULE) != -1 )
    {
      pNewObject = new CRule;
    }

    CString sName;
    CString sDescription;
    EventObject.GetProperty(IDS_STRING_MOF_NAME,sName);
		pNewObject->SetName(sName);
		pNewObject->SetGuid(sGuid);
    EventObject.GetProperty(IDS_STRING_MOF_DESCRIPTION,sDescription);
		pNewObject->SetComment(sDescription);
		pNewObject->SetSystemName(GetObjectPtr()->GetSystemName());
		pParentObject->AddChild(pNewObject);
    pNewObject->UpdateStatus();
	}


  return hr;
}

inline HRESULT CConfigCreationListener::OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam)
{
	TRACEX(_T("CConfigCreationListener::OnSetStatus\n"));
	TRACEARGn(lFlags);
	TRACEARGn(hResult);
	TRACEARGs(strParam);
	TRACEARGn(pObjParam);

  return WBEM_NO_ERROR;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\cleareventsdlg.cpp ===
// ClearEventsDlg.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "ClearEventsDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClearEventsDlg dialog


CClearEventsDlg::CClearEventsDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CClearEventsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CClearEventsDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CClearEventsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CClearEventsDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CClearEventsDlg, CDialog)
	//{{AFX_MSG_MAP(CClearEventsDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClearEventsDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\bccdialog.h ===
#if !defined(AFX_BCCDIALOG_H__342597A9_96F7_11D3_BE93_0000F87A3912__INCLUDED_)
#define AFX_BCCDIALOG_H__342597A9_96F7_11D3_BE93_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// BccDialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CBccDialog dialog

class CBccDialog : public CDialog
{
// Construction
public:
	CBccDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CBccDialog)
	enum { IDD = IDD_DIALOG_BCC };
	CString	m_sBcc;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBccDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CBccDialog)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_BCCDIALOG_H__342597A9_96F7_11D3_BE93_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\configcreationlistener.h ===
// ConfigCreationListener.h: interface for the CConfigCreationListener class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CONFIGCREATIONLISTENER_H__26C50DC6_EA67_48B9_9F38_6914B7A90CED__INCLUDED_)
#define AFX_CONFIGCREATIONLISTENER_H__26C50DC6_EA67_48B9_9F38_6914B7A90CED__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemEventListener.h"

class CConfigCreationListener : public CWbemEventListener  
{

DECLARE_DYNCREATE(CConfigCreationListener)

// Construction/Destruction
public:
	CConfigCreationListener();
	virtual ~CConfigCreationListener();

// Processing Operations
protected:
  virtual HRESULT ProcessEventClassObject(IWbemClassObject* pClassObject);
	virtual HRESULT OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam);
};

#endif // !defined(AFX_CONFIGCREATIONLISTENER_H__26C50DC6_EA67_48B9_9F38_6914B7A90CED__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\configdeletionlistener.cpp ===
// ConfigDeletionListener.cpp: implementation of the CConfigDeletionListener class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Snapin.h"
#include "ConfigDeletionListener.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CConfigDeletionListener,CWbemEventListener)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CConfigDeletionListener::CConfigDeletionListener()
{
	SetEventQuery(IDS_STRING_CONFIGDELETION_EVENTQUERY);
}

CConfigDeletionListener::~CConfigDeletionListener()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Event Processing Members
//////////////////////////////////////////////////////////////////////

HRESULT CConfigDeletionListener::ProcessEventClassObject(IWbemClassObject* pClassObject)
{
  ASSERT(pClassObject);
  if( pClassObject == NULL )
  {
    return E_FAIL;
  }
  
  HRESULT hr = S_OK;
/*
	CWbemClassObject EventObject;

	if( ! CHECKHRESULT(hr = EventObject.Create(pClassObject)) )
	{
		return hr;
	}

	EventObject.SetMachineName(GetObjectPtr()->GetSystemName());

  CString sGuid;
  EventObject.GetProperty(IDS_STRING_MOF_GUID,sGuid);
  sGuid.TrimLeft(_T("{"));
  sGuid.TrimRight(_T("}"));

  CHMObject* pObject = GetObjectPtr()->GetDescendantByGuid(sGuid);

  if( pObject )
  {
    if( pObject->GetScopeItemCount() )
    {
      CScopePaneItem* pSPI = pObject->GetScopeItem(0);
      if( pSPI )
      {
        pSPI->OnDelete();
      }
    }
  }
*/
  return hr;
}

inline HRESULT CConfigDeletionListener::OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam)
{
	TRACEX(_T("CConfigDeletionListener::OnSetStatus\n"));
	TRACEARGn(lFlags);
	TRACEARGn(hResult);
	TRACEARGs(strParam);
	TRACEARGn(pObjParam);


  return WBEM_NO_ERROR;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\configdeletionlistener.h ===
// ConfigDeletionListener.h: interface for the CConfigDeletionListener class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CONFIGDELETIONLISTENER_H__4A5E8D13_C2BA_4311_B49F_ED3F70C81328__INCLUDED_)
#define AFX_CONFIGDELETIONLISTENER_H__4A5E8D13_C2BA_4311_B49F_ED3F70C81328__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemEventListener.h"

class CConfigDeletionListener : public CWbemEventListener  
{

DECLARE_DYNCREATE(CConfigDeletionListener)

// Construction/Destruction
public:
	CConfigDeletionListener();
	virtual ~CConfigDeletionListener();

// Processing Operations
protected:
  virtual HRESULT ProcessEventClassObject(IWbemClassObject* pClassObject);
	virtual HRESULT OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam);

};

#endif // !defined(AFX_CONFIGDELETIONLISTENER_H__4A5E8D13_C2BA_4311_B49F_ED3F70C81328__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\configresultsview.h ===
// ConfigResultsView.h: interface for the CConfigResultsView class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CONFIGRESULTSVIEW_H__71DD923C_CA88_11D2_BD8E_0000F87A3912__INCLUDED_)
#define AFX_CONFIGRESULTSVIEW_H__71DD923C_CA88_11D2_BD8E_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SplitPaneResultsView.h"

class CConfigResultsView : public CSplitPaneResultsView  
{
DECLARE_DYNCREATE(CConfigResultsView)

// Construction/Destruction
public:
	CConfigResultsView();
	virtual ~CConfigResultsView();

// Create/Destroy
public:
	virtual bool Create(CScopePaneItem* pOwnerItem);

};

#endif // !defined(AFX_CONFIGRESULTSVIEW_H__71DD923C_CA88_11D2_BD8E_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\configresultsview.cpp ===
// ConfigResultsView.cpp: implementation of the CConfigResultsView class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "ConfigResultsView.h"
#include "HMListViewColumn.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CConfigResultsView,CSplitPaneResultsView)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CConfigResultsView::CConfigResultsView()
{

}

CConfigResultsView::~CConfigResultsView()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create/Destroy
//////////////////////////////////////////////////////////////////////

bool CConfigResultsView::Create(CScopePaneItem* pOwnerItem)
{
	TRACEX(_T("CConfigResultsView::Create\n"));
	TRACEARGn(pOwnerItem);

	if( ! CSplitPaneResultsView::Create(pOwnerItem) )
	{
		TRACE(_T("FAILED : CSplitPaneResultsView::Create failed.\n"));
		return false;
	}

	// add the upper columns
	CHMListViewColumn* pColumn = NULL;
	CString sTitle;
	DWORD dwFormat = LVCFMT_LEFT;

	// name
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NAME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);


	// last message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_LAST_MESSAGE);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// comment
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_COMMENT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// add the lower columns

	// Severity
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SEVERITY);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Date/Time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Component
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATA_POINT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// System
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SYSTEM);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_MESSAGE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\configscopeitem.h ===
// ConfigScopeItem.h: interface for the CConfigScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CONFIGSCOPEITEM_H__71DD923B_CA88_11D2_BD8E_0000F87A3912__INCLUDED_)
#define AFX_CONFIGSCOPEITEM_H__71DD923B_CA88_11D2_BD8E_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMScopeItem.h"

class CConfigScopeItem : public CHMScopeItem  
{
DECLARE_DYNCREATE(CConfigScopeItem)

// Construction/Destruction
public:
	CConfigScopeItem();
	virtual ~CConfigScopeItem();

// Creation Members
public:
	virtual bool Create(CScopePane* pScopePane, CScopePaneItem* pParentItem);
	
// Results Pane View Members
public:
	virtual CResultsPaneView* CreateResultsPaneView();

// MMC Notify Handlers
public:
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed);
  virtual HRESULT OnCommand(long lCommandID);
	virtual HRESULT OnExpand(BOOL bExpand) { return CScopePaneItem::OnExpand(bExpand); }
};

#endif // !defined(AFX_CONFIGSCOPEITEM_H__71DD923B_CA88_11D2_BD8E_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\connectionmanager.cpp ===
// ConnectionManager.cpp: implementation of the CConnectionManager class.
//
//////////////////////////////////////////////////////////////////////
//
// 03/05/00 v-marfin bug 59643 : Check for empty Marshal list before proceeding in
//                               UnMarshalCnxMgr()
// 04/05/00 v-marfin bug 62501 : Display appropriate msg when unable to connect to a server.
//
//
#include "stdafx.h"
#include "SnapIn.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

const IID IID_IConnectionManager = {0xFA84E6F2,0x0B7B,0x11D2,{0xBD,0xCB,0x00,0xC0,0x4F,0xA3,0x54,0x47}};


const IID LIBID_CONNMGRLib = {0xFA84E6E5,0x0B7B,0x11D2,{0xBD,0xCB,0x00,0xC0,0x4F,0xA3,0x54,0x47}};


const CLSID CLSID_ConnectionManager = {0xFA84E6F3,0x0B7B,0x11D2,{0xBD,0xCB,0x00,0xC0,0x4F,0xA3,0x54,0x47}};

//////////////////////////////////////////////////////////////////////
// CMarhsalledConnection

CMarshalledConnection::CMarshalledConnection()
{
	m_pIMarshalledConnectionManager = NULL;
	m_lpMarshalStream = NULL;
}

//////////////////////////////////////////////////////////////////////
// Operations
//////////////////////////////////////////////////////////////////////

HRESULT CMarshalledConnection::Marshal(IConnectionManager* pIConMgr)
{
	TRACEX(_T("CMarshalledConnection::Marshal\n"));
	TRACEARGn(pIConMgr);

	HRESULT hr = S_OK;

	if( m_lpMarshalStream == NULL )
	{
		hr = CoMarshalInterThreadInterfaceInStream(IID_IConnectionManager,pIConMgr,&m_lpMarshalStream);
		if( ! CHECKHRESULT(hr) )
		{
			TRACE(_T("FAILED : CoMarshalInterThreadInterfaceInStream failed.\n"));
		}
	}

	return hr;
}

HRESULT CMarshalledConnection::UnMarshal()
{
	TRACEX(_T("CMarshalledConnection::UnMarshal\n"));

	HRESULT hr = S_OK;

	if( m_pIMarshalledConnectionManager == NULL )
	{
		hr = CoGetInterfaceAndReleaseStream(m_lpMarshalStream,IID_IConnectionManager,(LPVOID*)(&m_pIMarshalledConnectionManager));
		if(!CHECKHRESULT(hr))
		{
			TRACE(_T("FAILED : CoGetInterfaceAndReleaseStream failed.\n"));			
		}
	}

	return hr;
}

IConnectionManager* CMarshalledConnection::GetConnection()
{
	TRACEX(_T("CMarshalledConnection::GetConnection\n"));

	// make certain the pointer has been unmarshalled
	HRESULT hr = UnMarshal();
	CHECKHRESULT(hr);
	ASSERT(m_pIMarshalledConnectionManager);

	return m_pIMarshalledConnectionManager;
}


//////////////////////////////////////////////////////////////////////
// CConnectionManager

IMPLEMENT_DYNCREATE(CConnectionManager,CObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CConnectionManager theCnxManager;

CConnectionManager::CConnectionManager()
{
	m_pIConnectionManager = NULL;
}

CConnectionManager::~CConnectionManager()
{
  Destroy();
}

BOOL CConnectionManager::Create()
{
  TRACEX(_T("CConnectionManager::Create\n"));

	// create the ConnectionManager object
	if( m_pIConnectionManager != NULL )
	{
		return TRUE;
	}

	HRESULT hr = CoCreateInstance(CLSID_ConnectionManager,NULL,CLSCTX_LOCAL_SERVER,IID_IConnectionManager,(LPVOID*)&m_pIConnectionManager);

	if( !CHECKHRESULT(hr) )
	{
    TRACE(_T("FAILED : Failed to create Connection Manager !\n"));    
    return FALSE;
  }

  ASSERT(m_pIConnectionManager);

  return TRUE;
}  

void CConnectionManager::Destroy()
{
  TRACEX(_T("CConnectionManager::Destroy\n"));

	// clean up any marshalled connections laying around
	POSITION pos = m_MarshalMap.GetStartPosition();
	CMarshalledConnection* pMC = NULL;
	DWORD dwKey = 0L;
	while( pos )
	{
		m_MarshalMap.GetNextAssoc(pos,dwKey,pMC);
		if( pMC )
		{
			delete pMC;
		}
	}
	m_MarshalMap.RemoveAll();

	// release the ConnectionManager object
	if( m_pIConnectionManager )
	{
		m_pIConnectionManager->Release();
		m_pIConnectionManager = NULL;
	}
}

//////////////////////////////////////////////////////////////////////
// Connection Operations
//////////////////////////////////////////////////////////////////////

HRESULT CConnectionManager::GetConnection(const CString& sMachineName, IWbemServices*& pIWbemServices, BOOL& bAvailable )
{
  TRACEX(_T("CConnectionManager::GetConnection\n"));
  TRACEARGs(sMachineName);

	ASSERT(m_pIConnectionManager);
	if( m_pIConnectionManager == NULL )
	{
		TRACE(_T("FAILED : CConnectionManager::GetConnection failed. m_pIConnectionManager is NULL.\n"));
		pIWbemServices = NULL;
		bAvailable = FALSE;
		return E_FAIL;
	}

	BSTR bsMachineName = sMachineName.AllocSysString();
	long lAvail = 0L;

	HRESULT hr = m_pIConnectionManager->GetConnection(bsMachineName,&pIWbemServices,&lAvail);

	if( HRESULT_CODE(hr) == RPC_S_SERVER_UNAVAILABLE )
	{
		HandleConnMgrException(hr);
		Destroy();
		Create();
		hr = m_pIConnectionManager->GetConnection(bsMachineName,&pIWbemServices,&lAvail);
	}

	if( hr == RPC_E_WRONG_THREAD )
	{
		CMarshalledConnection* pConnection = NULL;
		DWORD dwThreadID = GetCurrentThreadId();
		m_MarshalMap.Lookup(dwThreadID,pConnection);
		ASSERT(pConnection);
		if( pConnection == NULL )
		{
			TRACE(_T("FAILED : Could not find a marshalled connection for the calling thread!\n"));
			return E_FAIL;
		}

		IConnectionManager* pCnxMgr = pConnection->GetConnection();
		ASSERT(pCnxMgr);
		if( pCnxMgr == NULL )
		{
			TRACE(_T("FAILED : CMarshalledConnection::GetConnection returns NULL. Failed.\n"));
			return E_FAIL;
		}

		hr = pCnxMgr->GetConnection(bsMachineName,&pIWbemServices,&lAvail);
		
		if( HRESULT_CODE(hr) == RPC_S_SERVER_UNAVAILABLE )
		{
			HandleConnMgrException(hr);
		}

		if( !SUCCEEDED(hr) )
		{
			TRACE(_T("The marshalled connection manager's GetConnection failed.\n"));
		}
	}

	SysFreeString(bsMachineName);

	bAvailable = lAvail;

	if( !CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConnectionManager::GetConnection failed.\n"));
		
		return hr;
	}
	
	return hr;  
}

HRESULT CConnectionManager::ConnectToNamespace(const CString& sNamespace, IWbemServices*& pIWbemServices)
{
  TRACEX(_T("CConnectionManager::ConnectToNamespace\n"));
  TRACEARGs(sNamespace);

	ASSERT(m_pIConnectionManager);
	if( m_pIConnectionManager == NULL )
	{
		TRACE(_T("FAILED : CConnectionManager::ConnectToNamespace failed. m_pIConnectionManager is NULL.\n"));
		pIWbemServices = NULL;
		return E_FAIL;
	}

	BSTR bsNamespace = sNamespace.AllocSysString();

	HRESULT hr = m_pIConnectionManager->ConnectToNamespace(bsNamespace,&pIWbemServices);

	if( HRESULT_CODE(hr) == RPC_S_SERVER_UNAVAILABLE )
	{
		// v-marfin 62501 HandleConnMgrException(hr);
        CString sMsg;
        sMsg.Format(IDS_STRING_TRANSPORT_ERROR,sNamespace);
        AfxMessageBox(sMsg); 
		//Destroy();
		
        // v-marfin 62501 - This was here originally, so keep?? --------------------
        //Create();
        //hr = m_pIConnectionManager->ConnectToNamespace(bsNamespace,&pIWbemServices);
        //--------------------------------------------------------------------------
        
        SysFreeString(bsNamespace);  // v-marfin 62501
        return E_FAIL; // v-marfin 62501
	}

	if( hr == RPC_E_WRONG_THREAD )
	{
		CMarshalledConnection* pConnection = NULL;
		DWORD dwThreadID = GetCurrentThreadId();
		m_MarshalMap.Lookup(dwThreadID,pConnection);
		ASSERT(pConnection);
		if( pConnection == NULL )
		{
			TRACE(_T("FAILED : Could not find a marshalled connection for the calling thread!\n"));
			return E_FAIL;
		}

		IConnectionManager* pCnxMgr = pConnection->GetConnection();
		ASSERT(pCnxMgr);
		if( pCnxMgr == NULL )
		{
			TRACE(_T("FAILED : CMarshalledConnection::GetConnection returns NULL. Failed.\n"));
			return E_FAIL;
		}

		hr = pCnxMgr->ConnectToNamespace(bsNamespace,&pIWbemServices);
		
		if( HRESULT_CODE(hr) == RPC_S_SERVER_UNAVAILABLE )
		{
			HandleConnMgrException(hr);
		}

		if( !SUCCEEDED(hr) )
		{
			TRACE(_T("The marshalled connection manager's GetConnection failed.\n"));
		}
	}

	SysFreeString(bsNamespace);

	if( !CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConnectionManager::ConnectToNamespace failed.\n"));
		
		return hr;
	}
	
	return hr;  
}

HRESULT CConnectionManager::RemoveConnection(const CString& sMachineName, IWbemObjectSink* pSink)
{
  TRACEX(_T("CConnectionManager::RemoveConnection\n"));
  TRACEARGs(sMachineName);
	TRACEARGn(pSink);

	ASSERT(m_pIConnectionManager);
	if( m_pIConnectionManager == NULL )
	{
		TRACE(_T("FAILED : CConnectionManager::RemoveConnection failed. m_pIConnectionManager is NULL.\n"));
		return FALSE;
	}

	BSTR bsMachineName = sMachineName.AllocSysString();
	HRESULT hr = m_pIConnectionManager->RemoveConnection(bsMachineName,pSink);

	SysFreeString(bsMachineName);

	if( !CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConnectionManager::RemoveConnection failed.\n"));
		return hr;
	}
	
	return hr;  
}

//////////////////////////////////////////////////////////////////////
// Event Operations
//////////////////////////////////////////////////////////////////////

HRESULT CConnectionManager::ExecQueryAsync(const CString& sMachineName, const CString& sQuery, IWbemObjectSink*& pSink)
{
  TRACEX(_T("CConnectionManager::ExecQueryAsync\n"));
  TRACEARGs(sMachineName);
	TRACEARGs(sQuery);

	if( ! GfxCheckPtr(m_pIConnectionManager,IConnectionManager) )
	{
		TRACE(_T("FAILED : m_pIConnectionManager is not a valid pointer.\n"));
		return E_FAIL;
	}

	BSTR bsMachineName = sMachineName.AllocSysString();
	BSTR bsQuery = sQuery.AllocSysString();

	HRESULT hr = m_pIConnectionManager->ExecQueryAsync(bsMachineName,bsQuery,pSink);

	if( hr == RPC_E_WRONG_THREAD )
	{
		CMarshalledConnection* pConnection = NULL;
		DWORD dwThreadID = GetCurrentThreadId();
		m_MarshalMap.Lookup(dwThreadID,pConnection);
		ASSERT(pConnection);
		if( pConnection == NULL )
		{
			TRACE(_T("FAILED : Could not find a marshalled connection for the calling thread!\n"));
			return E_FAIL;
		}

		IConnectionManager* pCnxMgr = pConnection->GetConnection();
		ASSERT(pCnxMgr);
		if( pCnxMgr == NULL )
		{
			TRACE(_T("FAILED : CMarshalledConnection::GetConnection returns NULL. Failed.\n"));
			return E_FAIL;
		}

		hr = pCnxMgr->ExecQueryAsync(bsMachineName,bsQuery,pSink);
		
		if( HRESULT_CODE(hr) == RPC_S_SERVER_UNAVAILABLE )
		{
			HandleConnMgrException(hr);
		}

		if( !SUCCEEDED(hr) )
		{
			TRACE(_T("The marshalled connection manager's GetConnection failed.\n"));
		}
	}

	SysFreeString(bsMachineName);
	SysFreeString(bsQuery);

	if( !CHECKHRESULT(hr) )	
	{
		TRACE(_T("FAILED : IConnectionManager::ExecQueryAsync failed.\n"));
		return hr;
	}		

	return hr;
}

//////////////////////////////////////////////////////////////////////
// Event Operations
//////////////////////////////////////////////////////////////////////

HRESULT CConnectionManager::RegisterEventNotification(const CString& sMachineName, const CString& sQuery, IWbemObjectSink*& pSink)
{
  TRACEX(_T("CConnectionManager::RegisterEventNotification\n"));
  TRACEARGs(sMachineName);
	TRACEARGs(sQuery);

	if( ! GfxCheckPtr(m_pIConnectionManager,IConnectionManager) )
	{
		TRACE(_T("FAILED : m_pIConnectionManager is not a valid pointer.\n"));
		return E_FAIL;
	}

	BSTR bsMachineName = sMachineName.AllocSysString();
	BSTR bsQuery = sQuery.AllocSysString();

	HRESULT hr = m_pIConnectionManager->RegisterEventNotification(bsMachineName,bsQuery,pSink);
	if( HRESULT_CODE(hr) == RPC_S_SERVER_UNAVAILABLE )
	{
		HandleConnMgrException(hr);
		Destroy();
		Create();
		hr = m_pIConnectionManager->RegisterEventNotification(bsMachineName,bsQuery,pSink);
	}

	if( hr == RPC_E_WRONG_THREAD )
	{
		CMarshalledConnection* pConnection = NULL;
		DWORD dwThreadID = GetCurrentThreadId();
		m_MarshalMap.Lookup(dwThreadID,pConnection);
		ASSERT(pConnection);
		if( pConnection == NULL )
		{
			TRACE(_T("FAILED : Could not find a marshalled connection for the calling thread!\n"));
			SysFreeString(bsMachineName);
			SysFreeString(bsQuery);
			return E_FAIL;
		}

		IConnectionManager* pCnxMgr = pConnection->GetConnection();
		ASSERT(pCnxMgr);
		if( pCnxMgr == NULL )
		{
			TRACE(_T("FAILED : CMarshalledConnection::GetConnection returns NULL. Failed.\n"));
			SysFreeString(bsMachineName);
			SysFreeString(bsQuery);
			return E_FAIL;
		}

		hr = pCnxMgr->RegisterEventNotification(bsMachineName,bsQuery,pSink);
		
		if( HRESULT_CODE(hr) == RPC_S_SERVER_UNAVAILABLE )
		{
			HandleConnMgrException(hr);
		}

		if( !SUCCEEDED(hr) )
		{
			TRACE(_T("The marshalled connection manager's GetConnection failed.\n"));
		}
	}
		
	SysFreeString(bsMachineName);
	SysFreeString(bsQuery);

	if( !CHECKHRESULT(hr) )	
	{
		TRACE(_T("FAILED : IConnectionManager::RegisterEventNotification failed.\n"));
		return hr;
	}		

	return hr;
}

//////////////////////////////////////////////////////////////////////
// Error Display Operations
//////////////////////////////////////////////////////////////////////

void CConnectionManager::DisplayErrorMsgBox(HRESULT hr, const CString& sMachineName)
{
	TRACEX(_T("CConnectionManager::DisplayErrorMsgBox\n"));
	TRACEARGn(hr);
	TRACEARGs(sMachineName);

	CString sText;
	CString sTitle;

	GetErrorString(hr,sMachineName,sText);
	if( ! sText.IsEmpty() )
		AfxMessageBox(sText);
}

void CConnectionManager::GetErrorString(HRESULT hr, const CString& sMachineName, CString& sErrorText)
{
	TRACEX(_T("CConnectionManager::GetErrorString\n"));
	TRACEARGn(hr);
	TRACEARGs(sMachineName);
	TRACEARGs(sErrorText);

	if( hr == S_OK )
		return;

	switch( hr )
	{
		case E_FAIL:
		{
			sErrorText.Format(IDS_STRING_INVALID_MACHINE_NAME,sMachineName);
		}
		break;

		case WBEM_E_INVALID_CLASS:
		case E_NOTIMPL:
		{
			sErrorText.Format(IDS_STRING_INCORRECT_AGENT_VERSION,sMachineName);
		}
		break;

		case REGDB_E_CLASSNOTREG:
		{
			sErrorText.Format(IDS_STRING_WBEM_NOT_INSTALLED,sMachineName);
		}
		break;

		case E_ACCESSDENIED:
		case WBEM_E_ACCESS_DENIED:
		{
			sErrorText.Format(IDS_STRING_NO_CONNECT,sMachineName);
		}
		break;

		case WBEM_E_PROVIDER_FAILURE:
		{
			sErrorText.Format(IDS_STRING_PROVIDER_FAILURE,sMachineName,sMachineName);
		}
		break;

		case WBEM_E_PROVIDER_LOAD_FAILURE:
		{
			sErrorText.Format(IDS_STRING_PROVIDER_LOAD_FAILURE,sMachineName,sMachineName);
		}
		break;

		case WBEM_E_INVALID_NAMESPACE:		
		{
			sErrorText.Format(IDS_STRING_INVALID_NAMESPACE,sMachineName,sMachineName);
		}
		break;
		
		case WBEM_E_INVALID_PARAMETER:
		{
			sErrorText.Format(IDS_STRING_INVALID_PARAMETER,sMachineName);
		}
		break;
		
		case WBEM_E_OUT_OF_MEMORY:
		{
			sErrorText.Format(IDS_STRING_OUT_OF_MEMORY,sMachineName);
		}
		break;
		
		case WBEM_E_TRANSPORT_FAILURE:
		{
			sErrorText.Format(IDS_STRING_TRANSPORT_ERROR,sMachineName);
		}
		break;

		case WBEM_S_OPERATION_CANCELLED:
		{
			sErrorText.Format(IDS_STRING_OPERATION_CANCELLED,sMachineName);
		}
		break;

		case WBEMESS_E_REGISTRATION_TOO_PRECISE:
		{
			sErrorText.Format(IDS_STRING_REGISTRATION_TOO_PRECISE,sMachineName);
		}
		break;

		default:
		{
			if( HRESULT_CODE(hr) == RPC_S_CALL_FAILED || HRESULT_CODE(hr) == RPC_S_CALL_FAILED_DNE )
			{
				sErrorText.Format(IDS_STRING_WBEM_NOT_AVAILABLE,sMachineName);
				return;
			}

			TCHAR szFacility[_FACILITYLEN];
			TCHAR szErrorName[_ERRORNAMELEN];
			TCHAR szErrorDesc[_ERRORDESCLEN];
			ZeroMemory(szErrorName,sizeof(TCHAR)*_ERRORNAMELEN);
			ZeroMemory(szFacility,sizeof(TCHAR)*_FACILITYLEN);
			ZeroMemory(szErrorDesc,sizeof(TCHAR)*_ERRORDESCLEN);
			
			DecodeHResult(hr,szFacility,szErrorName,szErrorDesc);

			if( szFacility[0] == NULL || szErrorName[0] == NULL || szErrorDesc[0] == NULL )
			{
				sErrorText.Format(IDS_STRING_UNKNOWN_ERROR,sMachineName,hr);
			}
			else
			{
				CString sErrorDesc = szErrorDesc;
				sErrorDesc.TrimRight();
				sErrorText.Format(IDS_STRING_UNSPECIFIED_ERROR,sMachineName,sErrorDesc);
			}
		}
	}
}

#define CASE_FACILITY(f)  \
        case f: \
            _tcscpy((LPTSTR)szFacility, (LPTSTR)#f); \
            break;

#define CASE_HRESULT(hr)  \
        case hr: \
            _tcscpy((LPTSTR)szErrorName, (LPTSTR)#hr); \
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, \
                MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), \
                szErrorDesc, sizeof(TCHAR)*_ERRORDESCLEN, NULL);\
            break;

#define CASE_CODE(c) \
        case c: \
            _tcscpy((LPTSTR)szErrorName, (LPTSTR)#c); \
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, \
                MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), \
                szErrorDesc, sizeof(TCHAR)*_ERRORDESCLEN, NULL);\
            break; 

#pragma warning( disable : 4245 )

void CConnectionManager::DecodeHResult(HRESULT hr, LPTSTR pszFacility, LPTSTR pszErrorName, LPTSTR pszErrorDesc)
{
  TCHAR szFacility[_FACILITYLEN];
  TCHAR szErrorName[_ERRORNAMELEN];
  TCHAR szErrorDesc[_ERRORDESCLEN];
	ZeroMemory(szErrorName,sizeof(TCHAR)*_ERRORNAMELEN);
	ZeroMemory(szFacility,sizeof(TCHAR)*_FACILITYLEN);
	ZeroMemory(szErrorDesc,sizeof(TCHAR)*_ERRORDESCLEN);
  
  _tcscpy(szErrorDesc, _T(""));
  
  switch (HRESULT_FACILITY(hr))
  {
      CASE_FACILITY(FACILITY_WINDOWS)
      CASE_FACILITY(FACILITY_STORAGE)
      CASE_FACILITY(FACILITY_RPC)
      CASE_FACILITY(FACILITY_SSPI)
      CASE_FACILITY(FACILITY_WIN32)
      CASE_FACILITY(FACILITY_CONTROL)
      CASE_FACILITY(FACILITY_NULL)
			CASE_FACILITY(FACILITY_INTERNET)
      CASE_FACILITY(FACILITY_ITF)
      CASE_FACILITY(FACILITY_DISPATCH)
      CASE_FACILITY(FACILITY_CERT)

      default:
          _tcscpy(szFacility, _T(""));                
  }
  
  switch (hr) 
  {  
      CASE_HRESULT(E_UNEXPECTED)
      CASE_HRESULT(E_NOTIMPL)
      CASE_HRESULT(E_OUTOFMEMORY)
      CASE_HRESULT(E_INVALIDARG)
      CASE_HRESULT(E_NOINTERFACE)
      CASE_HRESULT(E_POINTER)
      CASE_HRESULT(E_HANDLE)
      CASE_HRESULT(E_ABORT)
      CASE_HRESULT(E_FAIL)
      CASE_HRESULT(E_ACCESSDENIED)
      CASE_HRESULT(E_PENDING)
      CASE_HRESULT(CO_E_INIT_TLS)
      CASE_HRESULT(CO_E_INIT_SHARED_ALLOCATOR)
      CASE_HRESULT(CO_E_INIT_MEMORY_ALLOCATOR)
      CASE_HRESULT(CO_E_INIT_CLASS_CACHE)
      CASE_HRESULT(CO_E_INIT_RPC_CHANNEL)
      CASE_HRESULT(CO_E_INIT_TLS_SET_CHANNEL_CONTROL)
      CASE_HRESULT(CO_E_INIT_TLS_CHANNEL_CONTROL)
      CASE_HRESULT(CO_E_INIT_UNACCEPTED_USER_ALLOCATOR)
      CASE_HRESULT(CO_E_INIT_SCM_MUTEX_EXISTS)
      CASE_HRESULT(CO_E_INIT_SCM_FILE_MAPPING_EXISTS)
      CASE_HRESULT(CO_E_INIT_SCM_MAP_VIEW_OF_FILE)
      CASE_HRESULT(CO_E_INIT_SCM_EXEC_FAILURE)
      CASE_HRESULT(CO_E_INIT_ONLY_SINGLE_THREADED)
      CASE_HRESULT(CO_E_CANT_REMOTE)
      CASE_HRESULT(CO_E_BAD_SERVER_NAME)
      CASE_HRESULT(CO_E_WRONG_SERVER_IDENTITY)
      CASE_HRESULT(CO_E_OLE1DDE_DISABLED)
      CASE_HRESULT(CO_E_RUNAS_SYNTAX)
      CASE_HRESULT(CO_E_CREATEPROCESS_FAILURE)
      CASE_HRESULT(CO_E_RUNAS_CREATEPROCESS_FAILURE)
      CASE_HRESULT(CO_E_RUNAS_LOGON_FAILURE)
      CASE_HRESULT(CO_E_LAUNCH_PERMSSION_DENIED)
      CASE_HRESULT(CO_E_START_SERVICE_FAILURE)
      CASE_HRESULT(CO_E_REMOTE_COMMUNICATION_FAILURE)
      CASE_HRESULT(CO_E_SERVER_START_TIMEOUT)
      CASE_HRESULT(CO_E_CLSREG_INCONSISTENT)
      CASE_HRESULT(CO_E_IIDREG_INCONSISTENT)
      CASE_HRESULT(CO_E_NOT_SUPPORTED)
      CASE_HRESULT(S_OK)
      CASE_HRESULT(S_FALSE)
      CASE_HRESULT(OLE_E_OLEVERB)
      CASE_HRESULT(OLE_E_ADVF)
      CASE_HRESULT(OLE_E_ENUM_NOMORE)
      CASE_HRESULT(OLE_E_ADVISENOTSUPPORTED)
      CASE_HRESULT(OLE_E_NOCONNECTION)
      CASE_HRESULT(OLE_E_NOTRUNNING)
      CASE_HRESULT(OLE_E_NOCACHE)
      CASE_HRESULT(OLE_E_BLANK)
      CASE_HRESULT(OLE_E_CLASSDIFF)
      CASE_HRESULT(OLE_E_CANT_GETMONIKER)
      CASE_HRESULT(OLE_E_CANT_BINDTOSOURCE)
      CASE_HRESULT(OLE_E_STATIC)
      CASE_HRESULT(OLE_E_PROMPTSAVECANCELLED)
      CASE_HRESULT(OLE_E_INVALIDRECT)
      CASE_HRESULT(OLE_E_WRONGCOMPOBJ)
      CASE_HRESULT(OLE_E_INVALIDHWND)
      CASE_HRESULT(OLE_E_NOT_INPLACEACTIVE)
      CASE_HRESULT(OLE_E_CANTCONVERT)
      CASE_HRESULT(OLE_E_NOSTORAGE)
      CASE_HRESULT(DV_E_FORMATETC)
      CASE_HRESULT(DV_E_DVTARGETDEVICE)
      CASE_HRESULT(DV_E_STGMEDIUM)
      CASE_HRESULT(DV_E_STATDATA)
      CASE_HRESULT(DV_E_LINDEX)
      CASE_HRESULT(DV_E_TYMED)
      CASE_HRESULT(DV_E_CLIPFORMAT)
      CASE_HRESULT(DV_E_DVASPECT)
      CASE_HRESULT(DV_E_DVTARGETDEVICE_SIZE)
      CASE_HRESULT(DV_E_NOIVIEWOBJECT)
      CASE_HRESULT(DRAGDROP_E_NOTREGISTERED)
      CASE_HRESULT(DRAGDROP_E_ALREADYREGISTERED)
      CASE_HRESULT(DRAGDROP_E_INVALIDHWND)
      CASE_HRESULT(CLASS_E_NOAGGREGATION)
      CASE_HRESULT(CLASS_E_CLASSNOTAVAILABLE)
      CASE_HRESULT(VIEW_E_DRAW)
      CASE_HRESULT(REGDB_E_READREGDB)
      CASE_HRESULT(REGDB_E_WRITEREGDB)
      CASE_HRESULT(REGDB_E_KEYMISSING)
      CASE_HRESULT(REGDB_E_INVALIDVALUE)
      CASE_HRESULT(REGDB_E_CLASSNOTREG)
      CASE_HRESULT(REGDB_E_IIDNOTREG)
      CASE_HRESULT(CACHE_E_NOCACHE_UPDATED)
      CASE_HRESULT(OLEOBJ_E_NOVERBS)
      CASE_HRESULT(OLEOBJ_E_INVALIDVERB)
      CASE_HRESULT(INPLACE_E_NOTUNDOABLE)
      CASE_HRESULT(INPLACE_E_NOTOOLSPACE)
      CASE_HRESULT(CONVERT10_E_OLESTREAM_GET)
      CASE_HRESULT(CONVERT10_E_OLESTREAM_PUT)
      CASE_HRESULT(CONVERT10_E_OLESTREAM_FMT)
      CASE_HRESULT(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB)
      CASE_HRESULT(CONVERT10_E_STG_FMT)
      CASE_HRESULT(CONVERT10_E_STG_NO_STD_STREAM)
      CASE_HRESULT(CONVERT10_E_STG_DIB_TO_BITMAP)
      CASE_HRESULT(CLIPBRD_E_CANT_OPEN)
      CASE_HRESULT(CLIPBRD_E_CANT_EMPTY)
      CASE_HRESULT(CLIPBRD_E_CANT_SET)
      CASE_HRESULT(CLIPBRD_E_BAD_DATA)
      CASE_HRESULT(CLIPBRD_E_CANT_CLOSE)
      CASE_HRESULT(MK_E_CONNECTMANUALLY)
      CASE_HRESULT(MK_E_EXCEEDEDDEADLINE)
      CASE_HRESULT(MK_E_NEEDGENERIC)
      CASE_HRESULT(MK_E_UNAVAILABLE)
      CASE_HRESULT(MK_E_SYNTAX)
      CASE_HRESULT(MK_E_NOOBJECT)
      CASE_HRESULT(MK_E_INVALIDEXTENSION)
      CASE_HRESULT(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED)
      CASE_HRESULT(MK_E_NOTBINDABLE)
      CASE_HRESULT(MK_E_NOTBOUND)
      CASE_HRESULT(MK_E_CANTOPENFILE)
      CASE_HRESULT(MK_E_MUSTBOTHERUSER)
      CASE_HRESULT(MK_E_NOINVERSE)
      CASE_HRESULT(MK_E_NOSTORAGE)
      CASE_HRESULT(MK_E_NOPREFIX)
      CASE_HRESULT(MK_E_ENUMERATION_FAILED)
      CASE_HRESULT(CO_E_NOTINITIALIZED)
      CASE_HRESULT(CO_E_ALREADYINITIALIZED)
      CASE_HRESULT(CO_E_CANTDETERMINECLASS)
      CASE_HRESULT(CO_E_CLASSSTRING)
      CASE_HRESULT(CO_E_IIDSTRING)
      CASE_HRESULT(CO_E_APPNOTFOUND)
      CASE_HRESULT(CO_E_APPSINGLEUSE)
      CASE_HRESULT(CO_E_ERRORINAPP)
      CASE_HRESULT(CO_E_DLLNOTFOUND)
      CASE_HRESULT(CO_E_ERRORINDLL)
      CASE_HRESULT(CO_E_WRONGOSFORAPP)
      CASE_HRESULT(CO_E_OBJNOTREG)
      CASE_HRESULT(CO_E_OBJISREG)
      CASE_HRESULT(CO_E_OBJNOTCONNECTED)
      CASE_HRESULT(CO_E_APPDIDNTREG)
      CASE_HRESULT(CO_E_RELEASED)
      CASE_HRESULT(OLE_S_USEREG)
      CASE_HRESULT(OLE_S_STATIC)
      CASE_HRESULT(OLE_S_MAC_CLIPFORMAT)
      CASE_HRESULT(DRAGDROP_S_DROP)
      CASE_HRESULT(DRAGDROP_S_CANCEL)
      CASE_HRESULT(DRAGDROP_S_USEDEFAULTCURSORS)
      CASE_HRESULT(DATA_S_SAMEFORMATETC)
      CASE_HRESULT(VIEW_S_ALREADY_FROZEN)
      CASE_HRESULT(CACHE_S_FORMATETC_NOTSUPPORTED)
      CASE_HRESULT(CACHE_S_SAMECACHE)
      CASE_HRESULT(CACHE_S_SOMECACHES_NOTUPDATED)
      CASE_HRESULT(OLEOBJ_S_INVALIDVERB)
      CASE_HRESULT(OLEOBJ_S_CANNOT_DOVERB_NOW)
      CASE_HRESULT(OLEOBJ_S_INVALIDHWND)
      CASE_HRESULT(INPLACE_S_TRUNCATED)
      CASE_HRESULT(CONVERT10_S_NO_PRESENTATION)
      CASE_HRESULT(MK_S_REDUCED_TO_SELF)
      CASE_HRESULT(MK_S_ME)
      CASE_HRESULT(MK_S_HIM)
      CASE_HRESULT(MK_S_US)
      CASE_HRESULT(MK_S_MONIKERALREADYREGISTERED)
      CASE_HRESULT(CO_E_CLASS_CREATE_FAILED)
      CASE_HRESULT(CO_E_SCM_ERROR)
      CASE_HRESULT(CO_E_SCM_RPC_FAILURE)
      CASE_HRESULT(CO_E_BAD_PATH)
      CASE_HRESULT(CO_E_SERVER_EXEC_FAILURE)
      CASE_HRESULT(CO_E_OBJSRV_RPC_FAILURE)
      CASE_HRESULT(MK_E_NO_NORMALIZED)
      CASE_HRESULT(CO_E_SERVER_STOPPING)
      CASE_HRESULT(MEM_E_INVALID_ROOT)
      CASE_HRESULT(MEM_E_INVALID_LINK)
      CASE_HRESULT(MEM_E_INVALID_SIZE)
      CASE_HRESULT(CO_S_NOTALLINTERFACES)
      CASE_HRESULT(DISP_E_UNKNOWNINTERFACE)
      CASE_HRESULT(DISP_E_MEMBERNOTFOUND)
      CASE_HRESULT(DISP_E_PARAMNOTFOUND)
      CASE_HRESULT(DISP_E_TYPEMISMATCH)
      CASE_HRESULT(DISP_E_UNKNOWNNAME)
      CASE_HRESULT(DISP_E_NONAMEDARGS)
      CASE_HRESULT(DISP_E_BADVARTYPE)
      CASE_HRESULT(DISP_E_EXCEPTION)
      CASE_HRESULT(DISP_E_OVERFLOW)
      CASE_HRESULT(DISP_E_BADINDEX)
      CASE_HRESULT(DISP_E_UNKNOWNLCID)
      CASE_HRESULT(DISP_E_ARRAYISLOCKED)
      CASE_HRESULT(DISP_E_BADPARAMCOUNT)
      CASE_HRESULT(DISP_E_PARAMNOTOPTIONAL)
      CASE_HRESULT(DISP_E_BADCALLEE)
      CASE_HRESULT(DISP_E_NOTACOLLECTION)
      CASE_HRESULT(TYPE_E_BUFFERTOOSMALL)
      CASE_HRESULT(TYPE_E_INVDATAREAD)
      CASE_HRESULT(TYPE_E_UNSUPFORMAT)
      CASE_HRESULT(TYPE_E_REGISTRYACCESS)
      CASE_HRESULT(TYPE_E_LIBNOTREGISTERED)
      CASE_HRESULT(TYPE_E_UNDEFINEDTYPE)
      CASE_HRESULT(TYPE_E_QUALIFIEDNAMEDISALLOWED)
      CASE_HRESULT(TYPE_E_INVALIDSTATE)
      CASE_HRESULT(TYPE_E_WRONGTYPEKIND)
      CASE_HRESULT(TYPE_E_ELEMENTNOTFOUND)
      CASE_HRESULT(TYPE_E_AMBIGUOUSNAME)
      CASE_HRESULT(TYPE_E_NAMECONFLICT)
      CASE_HRESULT(TYPE_E_UNKNOWNLCID)
      CASE_HRESULT(TYPE_E_DLLFUNCTIONNOTFOUND)
      CASE_HRESULT(TYPE_E_BADMODULEKIND)
      CASE_HRESULT(TYPE_E_SIZETOOBIG)
      CASE_HRESULT(TYPE_E_DUPLICATEID)
      CASE_HRESULT(TYPE_E_INVALIDID)
      CASE_HRESULT(TYPE_E_TYPEMISMATCH)
      CASE_HRESULT(TYPE_E_OUTOFBOUNDS)
      CASE_HRESULT(TYPE_E_IOERROR)
      CASE_HRESULT(TYPE_E_CANTCREATETMPFILE)
      CASE_HRESULT(TYPE_E_CANTLOADLIBRARY)
      CASE_HRESULT(TYPE_E_INCONSISTENTPROPFUNCS)
      CASE_HRESULT(TYPE_E_CIRCULARTYPE)
      CASE_HRESULT(STG_E_INVALIDFUNCTION)
      CASE_HRESULT(STG_E_FILENOTFOUND)
      CASE_HRESULT(STG_E_PATHNOTFOUND)
      CASE_HRESULT(STG_E_TOOMANYOPENFILES)
      CASE_HRESULT(STG_E_ACCESSDENIED)
      CASE_HRESULT(STG_E_INVALIDHANDLE)
      CASE_HRESULT(STG_E_INSUFFICIENTMEMORY)
      CASE_HRESULT(STG_E_INVALIDPOINTER)
      CASE_HRESULT(STG_E_NOMOREFILES)
      CASE_HRESULT(STG_E_DISKISWRITEPROTECTED)
      CASE_HRESULT(STG_E_SEEKERROR)
      CASE_HRESULT(STG_E_WRITEFAULT)
      CASE_HRESULT(STG_E_READFAULT)
      CASE_HRESULT(STG_E_SHAREVIOLATION)
      CASE_HRESULT(STG_E_LOCKVIOLATION)
      CASE_HRESULT(STG_E_FILEALREADYEXISTS)
      CASE_HRESULT(STG_E_INVALIDPARAMETER)
      CASE_HRESULT(STG_E_MEDIUMFULL)
      CASE_HRESULT(STG_E_PROPSETMISMATCHED)
      CASE_HRESULT(STG_E_ABNORMALAPIEXIT)
      CASE_HRESULT(STG_E_INVALIDHEADER)
      CASE_HRESULT(STG_E_INVALIDNAME)
      CASE_HRESULT(STG_E_UNKNOWN)
      CASE_HRESULT(STG_E_UNIMPLEMENTEDFUNCTION)
      CASE_HRESULT(STG_E_INVALIDFLAG)
      CASE_HRESULT(STG_E_INUSE)
      CASE_HRESULT(STG_E_NOTCURRENT)
      CASE_HRESULT(STG_E_REVERTED)
      CASE_HRESULT(STG_E_CANTSAVE)
      CASE_HRESULT(STG_E_OLDFORMAT)
      CASE_HRESULT(STG_E_OLDDLL)
      CASE_HRESULT(STG_E_SHAREREQUIRED)
      CASE_HRESULT(STG_E_NOTFILEBASEDSTORAGE)
      CASE_HRESULT(STG_E_EXTANTMARSHALLINGS)
      CASE_HRESULT(STG_E_DOCFILECORRUPT)
      CASE_HRESULT(STG_E_BADBASEADDRESS)
      CASE_HRESULT(STG_E_INCOMPLETE)
      CASE_HRESULT(STG_E_TERMINATED)
      CASE_HRESULT(STG_S_CONVERTED)
      CASE_HRESULT(STG_S_BLOCK)
      CASE_HRESULT(STG_S_RETRYNOW)
      CASE_HRESULT(STG_S_MONITORING)
      CASE_HRESULT(RPC_E_CALL_REJECTED)
      CASE_HRESULT(RPC_E_CALL_CANCELED)
      CASE_HRESULT(RPC_E_CANTPOST_INSENDCALL)
      CASE_HRESULT(RPC_E_CANTCALLOUT_INASYNCCALL)
      CASE_HRESULT(RPC_E_CANTCALLOUT_INEXTERNALCALL)
      CASE_HRESULT(RPC_E_CONNECTION_TERMINATED)
      CASE_HRESULT(RPC_E_SERVER_DIED)
      CASE_HRESULT(RPC_E_CLIENT_DIED)
      CASE_HRESULT(RPC_E_INVALID_DATAPACKET)
      CASE_HRESULT(RPC_E_CANTTRANSMIT_CALL)
      CASE_HRESULT(RPC_E_CLIENT_CANTMARSHAL_DATA)
      CASE_HRESULT(RPC_E_CLIENT_CANTUNMARSHAL_DATA)
      CASE_HRESULT(RPC_E_SERVER_CANTMARSHAL_DATA)
      CASE_HRESULT(RPC_E_SERVER_CANTUNMARSHAL_DATA)
      CASE_HRESULT(RPC_E_INVALID_DATA)
      CASE_HRESULT(RPC_E_INVALID_PARAMETER)
      CASE_HRESULT(RPC_E_CANTCALLOUT_AGAIN)
      CASE_HRESULT(RPC_E_SERVER_DIED_DNE)
      CASE_HRESULT(RPC_E_SYS_CALL_FAILED)
      CASE_HRESULT(RPC_E_OUT_OF_RESOURCES)
      CASE_HRESULT(RPC_E_ATTEMPTED_MULTITHREAD)
      CASE_HRESULT(RPC_E_NOT_REGISTERED)
      CASE_HRESULT(RPC_E_FAULT)
      CASE_HRESULT(RPC_E_SERVERFAULT)
      CASE_HRESULT(RPC_E_CHANGED_MODE)
      CASE_HRESULT(RPC_E_INVALIDMETHOD)
      CASE_HRESULT(RPC_E_DISCONNECTED)
      CASE_HRESULT(RPC_E_RETRY)
      CASE_HRESULT(RPC_E_SERVERCALL_RETRYLATER)
      CASE_HRESULT(RPC_E_SERVERCALL_REJECTED)
      CASE_HRESULT(RPC_E_INVALID_CALLDATA)
      CASE_HRESULT(RPC_E_CANTCALLOUT_ININPUTSYNCCALL)
      CASE_HRESULT(RPC_E_WRONG_THREAD)
      CASE_HRESULT(RPC_E_THREAD_NOT_INIT)
      CASE_HRESULT(RPC_E_VERSION_MISMATCH)
      CASE_HRESULT(RPC_E_INVALID_HEADER)
      CASE_HRESULT(RPC_E_INVALID_EXTENSION)
      CASE_HRESULT(RPC_E_INVALID_IPID)
      CASE_HRESULT(RPC_E_INVALID_OBJECT)
      CASE_HRESULT(RPC_S_CALLPENDING)
      CASE_HRESULT(RPC_S_WAITONTIMER)
      CASE_HRESULT(RPC_E_CALL_COMPLETE)
      CASE_HRESULT(RPC_E_UNSECURE_CALL)
      CASE_HRESULT(RPC_E_TOO_LATE)
      CASE_HRESULT(RPC_E_NO_GOOD_SECURITY_PACKAGES)
      CASE_HRESULT(RPC_E_ACCESS_DENIED)
      CASE_HRESULT(RPC_E_REMOTE_DISABLED)
      CASE_HRESULT(RPC_E_INVALID_OBJREF)
      CASE_HRESULT(RPC_E_UNEXPECTED)
      CASE_HRESULT(NTE_BAD_UID)
      CASE_HRESULT(NTE_BAD_HASH)
      CASE_HRESULT(NTE_BAD_KEY)
      CASE_HRESULT(NTE_BAD_LEN)
      CASE_HRESULT(NTE_BAD_DATA)
      CASE_HRESULT(NTE_BAD_SIGNATURE)
      CASE_HRESULT(NTE_BAD_VER)
      CASE_HRESULT(NTE_BAD_ALGID)
      CASE_HRESULT(NTE_BAD_FLAGS)
      CASE_HRESULT(NTE_BAD_TYPE)
      CASE_HRESULT(NTE_BAD_KEY_STATE)
      CASE_HRESULT(NTE_BAD_HASH_STATE)
      CASE_HRESULT(NTE_NO_KEY)
      CASE_HRESULT(NTE_NO_MEMORY)
      CASE_HRESULT(NTE_EXISTS)
      CASE_HRESULT(NTE_PERM)
      CASE_HRESULT(NTE_NOT_FOUND)
      CASE_HRESULT(NTE_DOUBLE_ENCRYPT)
      CASE_HRESULT(NTE_BAD_PROVIDER)
      CASE_HRESULT(NTE_BAD_PROV_TYPE)
      CASE_HRESULT(NTE_BAD_PUBLIC_KEY)
      CASE_HRESULT(NTE_BAD_KEYSET)
      CASE_HRESULT(NTE_PROV_TYPE_NOT_DEF)
      CASE_HRESULT(NTE_PROV_TYPE_ENTRY_BAD)
      CASE_HRESULT(NTE_KEYSET_NOT_DEF)
      CASE_HRESULT(NTE_KEYSET_ENTRY_BAD)
      CASE_HRESULT(NTE_PROV_TYPE_NO_MATCH)
      CASE_HRESULT(NTE_SIGNATURE_FILE_BAD)
      CASE_HRESULT(NTE_PROVIDER_DLL_FAIL)
      CASE_HRESULT(NTE_PROV_DLL_NOT_FOUND)
      CASE_HRESULT(NTE_BAD_KEYSET_PARAM)
      CASE_HRESULT(NTE_FAIL)
      CASE_HRESULT(NTE_SYS_ERR)
      CASE_HRESULT(TRUST_E_PROVIDER_UNKNOWN)
      CASE_HRESULT(TRUST_E_ACTION_UNKNOWN)
      CASE_HRESULT(TRUST_E_SUBJECT_FORM_UNKNOWN)
      CASE_HRESULT(TRUST_E_SUBJECT_NOT_TRUSTED)
      CASE_HRESULT(DIGSIG_E_ENCODE)
      CASE_HRESULT(DIGSIG_E_DECODE)
      CASE_HRESULT(DIGSIG_E_EXTENSIBILITY)
      CASE_HRESULT(DIGSIG_E_CRYPTO)
      CASE_HRESULT(PERSIST_E_SIZEDEFINITE)
      CASE_HRESULT(PERSIST_E_SIZEINDEFINITE)
      CASE_HRESULT(PERSIST_E_NOTSELFSIZING)
      CASE_HRESULT(TRUST_E_NOSIGNATURE)
      CASE_HRESULT(CERT_E_EXPIRED)
//      CASE_HRESULT(CERT_E_VALIDITYPERIODNESTING)
      CASE_HRESULT(CERT_E_ROLE)
      CASE_HRESULT(CERT_E_PATHLENCONST)
      CASE_HRESULT(CERT_E_CRITICAL)
      CASE_HRESULT(CERT_E_PURPOSE)
      CASE_HRESULT(CERT_E_ISSUERCHAINING)
      CASE_HRESULT(CERT_E_MALFORMED)
      CASE_HRESULT(CERT_E_UNTRUSTEDROOT)
      CASE_HRESULT(CERT_E_CHAINING)
              
      // OLE controls         
      CASE_HRESULT(CTL_E_ILLEGALFUNCTIONCALL)
      CASE_HRESULT(CTL_E_OVERFLOW)
      CASE_HRESULT(CTL_E_OUTOFMEMORY)
      CASE_HRESULT(CTL_E_DIVISIONBYZERO)
      CASE_HRESULT(CTL_E_OUTOFSTRINGSPACE)
      CASE_HRESULT(CTL_E_OUTOFSTACKSPACE)
      CASE_HRESULT(CTL_E_BADFILENAMEORNUMBER)
      CASE_HRESULT(CTL_E_FILENOTFOUND)
      CASE_HRESULT(CTL_E_BADFILEMODE)
      CASE_HRESULT(CTL_E_FILEALREADYOPEN)
      CASE_HRESULT(CTL_E_DEVICEIOERROR)
      CASE_HRESULT(CTL_E_FILEALREADYEXISTS)
      CASE_HRESULT(CTL_E_BADRECORDLENGTH)
      CASE_HRESULT(CTL_E_DISKFULL)
      CASE_HRESULT(CTL_E_BADRECORDNUMBER)
      CASE_HRESULT(CTL_E_BADFILENAME)
      CASE_HRESULT(CTL_E_TOOMANYFILES)
      CASE_HRESULT(CTL_E_DEVICEUNAVAILABLE)
      CASE_HRESULT(CTL_E_PERMISSIONDENIED)
      CASE_HRESULT(CTL_E_DISKNOTREADY)
      CASE_HRESULT(CTL_E_PATHFILEACCESSERROR)
      CASE_HRESULT(CTL_E_PATHNOTFOUND)
      CASE_HRESULT(CTL_E_INVALIDPATTERNSTRING)
      CASE_HRESULT(CTL_E_INVALIDUSEOFNULL)
      CASE_HRESULT(CTL_E_INVALIDFILEFORMAT)
      CASE_HRESULT(CTL_E_INVALIDPROPERTYVALUE)
      CASE_HRESULT(CTL_E_INVALIDPROPERTYARRAYINDEX)
      CASE_HRESULT(CTL_E_SETNOTSUPPORTEDATRUNTIME)
      CASE_HRESULT(CTL_E_SETNOTSUPPORTED)
      CASE_HRESULT(CTL_E_NEEDPROPERTYARRAYINDEX)
      CASE_HRESULT(CTL_E_SETNOTPERMITTED)
      CASE_HRESULT(CTL_E_GETNOTSUPPORTEDATRUNTIME)
      CASE_HRESULT(CTL_E_GETNOTSUPPORTED)
      CASE_HRESULT(CTL_E_PROPERTYNOTFOUND)
      CASE_HRESULT(CTL_E_INVALIDCLIPBOARDFORMAT)
      CASE_HRESULT(CTL_E_INVALIDPICTURE)
      CASE_HRESULT(CTL_E_PRINTERERROR)
      CASE_HRESULT(CTL_E_CANTSAVEFILETOTEMP)
      CASE_HRESULT(CTL_E_SEARCHTEXTNOTFOUND)
      CASE_HRESULT(CTL_E_REPLACEMENTSTOOLONG)
      CASE_HRESULT(CLASS_E_NOTLICENSED)

      default:
                      // Check if the HRESULT has FACILITY_WIN32. If so,
                      // extract the code and check against the codes in winerror.h
          if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
          {
              switch (HRESULT_CODE(hr)) 
              {
              CASE_CODE(ERROR_SUCCESS)
              CASE_CODE(ERROR_INVALID_FUNCTION)
              CASE_CODE(ERROR_FILE_NOT_FOUND)
              CASE_CODE(ERROR_PATH_NOT_FOUND)
              CASE_CODE(ERROR_TOO_MANY_OPEN_FILES)
              CASE_CODE(ERROR_ACCESS_DENIED)
              CASE_CODE(ERROR_INVALID_HANDLE)
              CASE_CODE(ERROR_ARENA_TRASHED)
              CASE_CODE(ERROR_NOT_ENOUGH_MEMORY)
              CASE_CODE(ERROR_INVALID_BLOCK)
              CASE_CODE(ERROR_BAD_ENVIRONMENT)
              CASE_CODE(ERROR_BAD_FORMAT)
              CASE_CODE(ERROR_INVALID_ACCESS)
              CASE_CODE(ERROR_INVALID_DATA)
              CASE_CODE(ERROR_OUTOFMEMORY)
              CASE_CODE(ERROR_INVALID_DRIVE)
              CASE_CODE(ERROR_CURRENT_DIRECTORY)
              CASE_CODE(ERROR_NOT_SAME_DEVICE)
              CASE_CODE(ERROR_NO_MORE_FILES)
              CASE_CODE(ERROR_WRITE_PROTECT)
              CASE_CODE(ERROR_BAD_UNIT)
              CASE_CODE(ERROR_NOT_READY)
              CASE_CODE(ERROR_BAD_COMMAND)
              CASE_CODE(ERROR_CRC)
              CASE_CODE(ERROR_BAD_LENGTH)
              CASE_CODE(ERROR_SEEK)
              CASE_CODE(ERROR_NOT_DOS_DISK)
              CASE_CODE(ERROR_SECTOR_NOT_FOUND)
              CASE_CODE(ERROR_OUT_OF_PAPER)
              CASE_CODE(ERROR_WRITE_FAULT)
              CASE_CODE(ERROR_READ_FAULT)
              CASE_CODE(ERROR_GEN_FAILURE)
              CASE_CODE(ERROR_SHARING_VIOLATION)
              CASE_CODE(ERROR_LOCK_VIOLATION)
              CASE_CODE(ERROR_WRONG_DISK)
              CASE_CODE(ERROR_SHARING_BUFFER_EXCEEDED)
              CASE_CODE(ERROR_HANDLE_EOF)
              CASE_CODE(ERROR_HANDLE_DISK_FULL)
              CASE_CODE(ERROR_NOT_SUPPORTED)
              CASE_CODE(ERROR_REM_NOT_LIST)
              CASE_CODE(ERROR_DUP_NAME)
              CASE_CODE(ERROR_BAD_NETPATH)
              CASE_CODE(ERROR_NETWORK_BUSY)
              CASE_CODE(ERROR_DEV_NOT_EXIST)
              CASE_CODE(ERROR_TOO_MANY_CMDS)
              CASE_CODE(ERROR_ADAP_HDW_ERR)
              CASE_CODE(ERROR_BAD_NET_RESP)
              CASE_CODE(ERROR_UNEXP_NET_ERR)
              CASE_CODE(ERROR_BAD_REM_ADAP)
              CASE_CODE(ERROR_PRINTQ_FULL)
              CASE_CODE(ERROR_NO_SPOOL_SPACE)
              CASE_CODE(ERROR_PRINT_CANCELLED)
              CASE_CODE(ERROR_NETNAME_DELETED)
              CASE_CODE(ERROR_NETWORK_ACCESS_DENIED)
              CASE_CODE(ERROR_BAD_DEV_TYPE)
              CASE_CODE(ERROR_BAD_NET_NAME)
              CASE_CODE(ERROR_TOO_MANY_NAMES)
              CASE_CODE(ERROR_TOO_MANY_SESS)
              CASE_CODE(ERROR_SHARING_PAUSED)
              CASE_CODE(ERROR_REQ_NOT_ACCEP)
              CASE_CODE(ERROR_REDIR_PAUSED)
              CASE_CODE(ERROR_FILE_EXISTS)
              CASE_CODE(ERROR_CANNOT_MAKE)
              CASE_CODE(ERROR_FAIL_I24)
              CASE_CODE(ERROR_OUT_OF_STRUCTURES)
              CASE_CODE(ERROR_ALREADY_ASSIGNED)
              CASE_CODE(ERROR_INVALID_PASSWORD)
              CASE_CODE(ERROR_INVALID_PARAMETER)
              CASE_CODE(ERROR_NET_WRITE_FAULT)
              CASE_CODE(ERROR_NO_PROC_SLOTS)
              CASE_CODE(ERROR_TOO_MANY_SEMAPHORES)
              CASE_CODE(ERROR_EXCL_SEM_ALREADY_OWNED)
              CASE_CODE(ERROR_SEM_IS_SET)
              CASE_CODE(ERROR_TOO_MANY_SEM_REQUESTS)
              CASE_CODE(ERROR_INVALID_AT_INTERRUPT_TIME)
              CASE_CODE(ERROR_SEM_OWNER_DIED)
              CASE_CODE(ERROR_SEM_USER_LIMIT)
              CASE_CODE(ERROR_DISK_CHANGE)
              CASE_CODE(ERROR_DRIVE_LOCKED)
              CASE_CODE(ERROR_BROKEN_PIPE)
              CASE_CODE(ERROR_OPEN_FAILED)
              CASE_CODE(ERROR_BUFFER_OVERFLOW)
              CASE_CODE(ERROR_DISK_FULL)
              CASE_CODE(ERROR_NO_MORE_SEARCH_HANDLES)
              CASE_CODE(ERROR_INVALID_TARGET_HANDLE)
              CASE_CODE(ERROR_INVALID_CATEGORY)
              CASE_CODE(ERROR_INVALID_VERIFY_SWITCH)
              CASE_CODE(ERROR_BAD_DRIVER_LEVEL)
              CASE_CODE(ERROR_CALL_NOT_IMPLEMENTED)
              CASE_CODE(ERROR_SEM_TIMEOUT)
              CASE_CODE(ERROR_INSUFFICIENT_BUFFER)
              CASE_CODE(ERROR_INVALID_NAME)
              CASE_CODE(ERROR_INVALID_LEVEL)
              CASE_CODE(ERROR_NO_VOLUME_LABEL)
              CASE_CODE(ERROR_MOD_NOT_FOUND)
              CASE_CODE(ERROR_PROC_NOT_FOUND)
              CASE_CODE(ERROR_WAIT_NO_CHILDREN)
              CASE_CODE(ERROR_CHILD_NOT_COMPLETE)
              CASE_CODE(ERROR_DIRECT_ACCESS_HANDLE)
              CASE_CODE(ERROR_NEGATIVE_SEEK)
              CASE_CODE(ERROR_SEEK_ON_DEVICE)
              CASE_CODE(ERROR_IS_JOIN_TARGET)
              CASE_CODE(ERROR_IS_JOINED)
              CASE_CODE(ERROR_IS_SUBSTED)
              CASE_CODE(ERROR_NOT_JOINED)
              CASE_CODE(ERROR_NOT_SUBSTED)
              CASE_CODE(ERROR_JOIN_TO_JOIN)
              CASE_CODE(ERROR_SUBST_TO_SUBST)
              CASE_CODE(ERROR_JOIN_TO_SUBST)
              CASE_CODE(ERROR_SUBST_TO_JOIN)
              CASE_CODE(ERROR_BUSY_DRIVE)
              CASE_CODE(ERROR_SAME_DRIVE)
              CASE_CODE(ERROR_DIR_NOT_ROOT)
              CASE_CODE(ERROR_DIR_NOT_EMPTY)
              CASE_CODE(ERROR_IS_SUBST_PATH)
              CASE_CODE(ERROR_IS_JOIN_PATH)
              CASE_CODE(ERROR_PATH_BUSY)
              CASE_CODE(ERROR_IS_SUBST_TARGET)
              CASE_CODE(ERROR_SYSTEM_TRACE)
              CASE_CODE(ERROR_INVALID_EVENT_COUNT)
              CASE_CODE(ERROR_TOO_MANY_MUXWAITERS)
              CASE_CODE(ERROR_INVALID_LIST_FORMAT)
              CASE_CODE(ERROR_LABEL_TOO_LONG)
              CASE_CODE(ERROR_TOO_MANY_TCBS)
              CASE_CODE(ERROR_SIGNAL_REFUSED)
              CASE_CODE(ERROR_DISCARDED)
              CASE_CODE(ERROR_NOT_LOCKED)
              CASE_CODE(ERROR_BAD_THREADID_ADDR)
              CASE_CODE(ERROR_BAD_ARGUMENTS)
              CASE_CODE(ERROR_BAD_PATHNAME)
              CASE_CODE(ERROR_SIGNAL_PENDING)
              CASE_CODE(ERROR_MAX_THRDS_REACHED)
              CASE_CODE(ERROR_LOCK_FAILED)
              CASE_CODE(ERROR_BUSY)
              CASE_CODE(ERROR_CANCEL_VIOLATION)
              CASE_CODE(ERROR_ATOMIC_LOCKS_NOT_SUPPORTED)
              CASE_CODE(ERROR_INVALID_SEGMENT_NUMBER)
              CASE_CODE(ERROR_INVALID_ORDINAL)
              CASE_CODE(ERROR_ALREADY_EXISTS)
              CASE_CODE(ERROR_INVALID_FLAG_NUMBER)
              CASE_CODE(ERROR_SEM_NOT_FOUND)
              CASE_CODE(ERROR_INVALID_STARTING_CODESEG)
              CASE_CODE(ERROR_INVALID_STACKSEG)
              CASE_CODE(ERROR_INVALID_MODULETYPE)
              CASE_CODE(ERROR_INVALID_EXE_SIGNATURE)
              CASE_CODE(ERROR_EXE_MARKED_INVALID)
              CASE_CODE(ERROR_BAD_EXE_FORMAT)
              CASE_CODE(ERROR_ITERATED_DATA_EXCEEDS_64k)
              CASE_CODE(ERROR_INVALID_MINALLOCSIZE)
              CASE_CODE(ERROR_DYNLINK_FROM_INVALID_RING)
              CASE_CODE(ERROR_IOPL_NOT_ENABLED)
              CASE_CODE(ERROR_INVALID_SEGDPL)
              CASE_CODE(ERROR_AUTODATASEG_EXCEEDS_64k)
              CASE_CODE(ERROR_RING2SEG_MUST_BE_MOVABLE)
              CASE_CODE(ERROR_RELOC_CHAIN_XEEDS_SEGLIM)
              CASE_CODE(ERROR_INFLOOP_IN_RELOC_CHAIN)
              CASE_CODE(ERROR_ENVVAR_NOT_FOUND)
              CASE_CODE(ERROR_NO_SIGNAL_SENT)
              CASE_CODE(ERROR_FILENAME_EXCED_RANGE)
              CASE_CODE(ERROR_RING2_STACK_IN_USE)
              CASE_CODE(ERROR_META_EXPANSION_TOO_LONG)
              CASE_CODE(ERROR_INVALID_SIGNAL_NUMBER)
              CASE_CODE(ERROR_THREAD_1_INACTIVE)
              CASE_CODE(ERROR_LOCKED)
              CASE_CODE(ERROR_TOO_MANY_MODULES)
              CASE_CODE(ERROR_NESTING_NOT_ALLOWED)
              CASE_CODE(ERROR_EXE_MACHINE_TYPE_MISMATCH)
              CASE_CODE(ERROR_BAD_PIPE)
              CASE_CODE(ERROR_PIPE_BUSY)
              CASE_CODE(ERROR_NO_DATA)
              CASE_CODE(ERROR_PIPE_NOT_CONNECTED)
              CASE_CODE(ERROR_MORE_DATA)
              CASE_CODE(ERROR_VC_DISCONNECTED)
              CASE_CODE(ERROR_INVALID_EA_NAME)
              CASE_CODE(ERROR_EA_LIST_INCONSISTENT)
              CASE_CODE(ERROR_NO_MORE_ITEMS)
              CASE_CODE(ERROR_CANNOT_COPY)
              CASE_CODE(ERROR_DIRECTORY)
              CASE_CODE(ERROR_EAS_DIDNT_FIT)
              CASE_CODE(ERROR_EA_FILE_CORRUPT)
              CASE_CODE(ERROR_EA_TABLE_FULL)
              CASE_CODE(ERROR_INVALID_EA_HANDLE)
              CASE_CODE(ERROR_EAS_NOT_SUPPORTED)
              CASE_CODE(ERROR_NOT_OWNER)
              CASE_CODE(ERROR_TOO_MANY_POSTS)
              CASE_CODE(ERROR_PARTIAL_COPY)
              CASE_CODE(ERROR_MR_MID_NOT_FOUND)
              CASE_CODE(ERROR_INVALID_ADDRESS)
              CASE_CODE(ERROR_ARITHMETIC_OVERFLOW)
              CASE_CODE(ERROR_PIPE_CONNECTED)
              CASE_CODE(ERROR_PIPE_LISTENING)
              CASE_CODE(ERROR_EA_ACCESS_DENIED)
              CASE_CODE(ERROR_OPERATION_ABORTED)
              CASE_CODE(ERROR_IO_INCOMPLETE)
              CASE_CODE(ERROR_IO_PENDING)
              CASE_CODE(ERROR_NOACCESS)
              CASE_CODE(ERROR_SWAPERROR)
              CASE_CODE(ERROR_STACK_OVERFLOW)
              CASE_CODE(ERROR_INVALID_MESSAGE)
              CASE_CODE(ERROR_CAN_NOT_COMPLETE)
              CASE_CODE(ERROR_INVALID_FLAGS)
              CASE_CODE(ERROR_UNRECOGNIZED_VOLUME)
              CASE_CODE(ERROR_FILE_INVALID)
              CASE_CODE(ERROR_FULLSCREEN_MODE)
              CASE_CODE(ERROR_NO_TOKEN)
              CASE_CODE(ERROR_BADDB)
              CASE_CODE(ERROR_BADKEY)
              CASE_CODE(ERROR_CANTOPEN)
              CASE_CODE(ERROR_CANTREAD)
              CASE_CODE(ERROR_CANTWRITE)
              CASE_CODE(ERROR_REGISTRY_RECOVERED)
              CASE_CODE(ERROR_REGISTRY_CORRUPT)
              CASE_CODE(ERROR_REGISTRY_IO_FAILED)
              CASE_CODE(ERROR_NOT_REGISTRY_FILE)
              CASE_CODE(ERROR_KEY_DELETED)
              CASE_CODE(ERROR_NO_LOG_SPACE)
              CASE_CODE(ERROR_KEY_HAS_CHILDREN)
              CASE_CODE(ERROR_CHILD_MUST_BE_VOLATILE)
              CASE_CODE(ERROR_NOTIFY_ENUM_DIR)
              CASE_CODE(ERROR_DEPENDENT_SERVICES_RUNNING)
              CASE_CODE(ERROR_INVALID_SERVICE_CONTROL)
              CASE_CODE(ERROR_SERVICE_REQUEST_TIMEOUT)
              CASE_CODE(ERROR_SERVICE_NO_THREAD)
              CASE_CODE(ERROR_SERVICE_DATABASE_LOCKED)
              CASE_CODE(ERROR_SERVICE_ALREADY_RUNNING)
              CASE_CODE(ERROR_INVALID_SERVICE_ACCOUNT)
              CASE_CODE(ERROR_SERVICE_DISABLED)
              CASE_CODE(ERROR_CIRCULAR_DEPENDENCY)
              CASE_CODE(ERROR_SERVICE_DOES_NOT_EXIST)
              CASE_CODE(ERROR_SERVICE_CANNOT_ACCEPT_CTRL)
              CASE_CODE(ERROR_SERVICE_NOT_ACTIVE)
              CASE_CODE(ERROR_FAILED_SERVICE_CONTROLLER_CONNECT)
              CASE_CODE(ERROR_EXCEPTION_IN_SERVICE)
              CASE_CODE(ERROR_DATABASE_DOES_NOT_EXIST)
              CASE_CODE(ERROR_SERVICE_SPECIFIC_ERROR)
              CASE_CODE(ERROR_PROCESS_ABORTED)
              CASE_CODE(ERROR_SERVICE_DEPENDENCY_FAIL)
              CASE_CODE(ERROR_SERVICE_LOGON_FAILED)
              CASE_CODE(ERROR_SERVICE_START_HANG)
              CASE_CODE(ERROR_INVALID_SERVICE_LOCK)
              CASE_CODE(ERROR_SERVICE_MARKED_FOR_DELETE)
              CASE_CODE(ERROR_SERVICE_EXISTS)
              CASE_CODE(ERROR_ALREADY_RUNNING_LKG)
              CASE_CODE(ERROR_SERVICE_DEPENDENCY_DELETED)
              CASE_CODE(ERROR_BOOT_ALREADY_ACCEPTED)
              CASE_CODE(ERROR_SERVICE_NEVER_STARTED)
              CASE_CODE(ERROR_DUPLICATE_SERVICE_NAME)
              CASE_CODE(ERROR_DIFFERENT_SERVICE_ACCOUNT)
              CASE_CODE(ERROR_END_OF_MEDIA)
              CASE_CODE(ERROR_FILEMARK_DETECTED)
              CASE_CODE(ERROR_BEGINNING_OF_MEDIA)
              CASE_CODE(ERROR_SETMARK_DETECTED)
              CASE_CODE(ERROR_NO_DATA_DETECTED)
              CASE_CODE(ERROR_PARTITION_FAILURE)
              CASE_CODE(ERROR_INVALID_BLOCK_LENGTH)
              CASE_CODE(ERROR_DEVICE_NOT_PARTITIONED)
              CASE_CODE(ERROR_UNABLE_TO_LOCK_MEDIA)
              CASE_CODE(ERROR_UNABLE_TO_UNLOAD_MEDIA)
              CASE_CODE(ERROR_MEDIA_CHANGED)
              CASE_CODE(ERROR_BUS_RESET)
              CASE_CODE(ERROR_NO_MEDIA_IN_DRIVE)
              CASE_CODE(ERROR_NO_UNICODE_TRANSLATION)
              CASE_CODE(ERROR_DLL_INIT_FAILED)
              CASE_CODE(ERROR_SHUTDOWN_IN_PROGRESS)
              CASE_CODE(ERROR_NO_SHUTDOWN_IN_PROGRESS)
              CASE_CODE(ERROR_IO_DEVICE)
              CASE_CODE(ERROR_SERIAL_NO_DEVICE)
              CASE_CODE(ERROR_IRQ_BUSY)
              CASE_CODE(ERROR_MORE_WRITES)
              CASE_CODE(ERROR_COUNTER_TIMEOUT)
              CASE_CODE(ERROR_FLOPPY_ID_MARK_NOT_FOUND)
              CASE_CODE(ERROR_FLOPPY_WRONG_CYLINDER)
              CASE_CODE(ERROR_FLOPPY_UNKNOWN_ERROR)
              CASE_CODE(ERROR_FLOPPY_BAD_REGISTERS)
              CASE_CODE(ERROR_DISK_RECALIBRATE_FAILED)
              CASE_CODE(ERROR_DISK_OPERATION_FAILED)
              CASE_CODE(ERROR_DISK_RESET_FAILED)
              CASE_CODE(ERROR_EOM_OVERFLOW)
              CASE_CODE(ERROR_NOT_ENOUGH_SERVER_MEMORY)
              CASE_CODE(ERROR_POSSIBLE_DEADLOCK)
              CASE_CODE(ERROR_MAPPED_ALIGNMENT)
              CASE_CODE(ERROR_SET_POWER_STATE_VETOED)
              CASE_CODE(ERROR_SET_POWER_STATE_FAILED)
              CASE_CODE(ERROR_TOO_MANY_LINKS)
              CASE_CODE(ERROR_OLD_WIN_VERSION)
              CASE_CODE(ERROR_APP_WRONG_OS)
              CASE_CODE(ERROR_SINGLE_INSTANCE_APP)
              CASE_CODE(ERROR_RMODE_APP)
              CASE_CODE(ERROR_INVALID_DLL)
              CASE_CODE(ERROR_NO_ASSOCIATION)
              CASE_CODE(ERROR_DDE_FAIL)
              CASE_CODE(ERROR_DLL_NOT_FOUND)
              CASE_CODE(ERROR_BAD_USERNAME)
              CASE_CODE(ERROR_NOT_CONNECTED)
              CASE_CODE(ERROR_OPEN_FILES)
              CASE_CODE(ERROR_ACTIVE_CONNECTIONS)
              CASE_CODE(ERROR_DEVICE_IN_USE)
              CASE_CODE(ERROR_BAD_DEVICE)
              CASE_CODE(ERROR_CONNECTION_UNAVAIL)
              CASE_CODE(ERROR_DEVICE_ALREADY_REMEMBERED)
              CASE_CODE(ERROR_NO_NET_OR_BAD_PATH)
              CASE_CODE(ERROR_BAD_PROVIDER)
              CASE_CODE(ERROR_CANNOT_OPEN_PROFILE)
              CASE_CODE(ERROR_BAD_PROFILE)
              CASE_CODE(ERROR_NOT_CONTAINER)
              CASE_CODE(ERROR_EXTENDED_ERROR)
              CASE_CODE(ERROR_INVALID_GROUPNAME)
              CASE_CODE(ERROR_INVALID_COMPUTERNAME)
              CASE_CODE(ERROR_INVALID_EVENTNAME)
              CASE_CODE(ERROR_INVALID_DOMAINNAME)
              CASE_CODE(ERROR_INVALID_SERVICENAME)
              CASE_CODE(ERROR_INVALID_NETNAME)
              CASE_CODE(ERROR_INVALID_SHARENAME)
              CASE_CODE(ERROR_INVALID_PASSWORDNAME)
              CASE_CODE(ERROR_INVALID_MESSAGENAME)
              CASE_CODE(ERROR_INVALID_MESSAGEDEST)
              CASE_CODE(ERROR_SESSION_CREDENTIAL_CONFLICT)
              CASE_CODE(ERROR_REMOTE_SESSION_LIMIT_EXCEEDED)
              CASE_CODE(ERROR_DUP_DOMAINNAME)
              CASE_CODE(ERROR_NO_NETWORK)
              CASE_CODE(ERROR_CANCELLED)
              CASE_CODE(ERROR_USER_MAPPED_FILE)
              CASE_CODE(ERROR_CONNECTION_REFUSED)
              CASE_CODE(ERROR_GRACEFUL_DISCONNECT)
              CASE_CODE(ERROR_ADDRESS_ALREADY_ASSOCIATED)
              CASE_CODE(ERROR_ADDRESS_NOT_ASSOCIATED)
              CASE_CODE(ERROR_CONNECTION_INVALID)
              CASE_CODE(ERROR_CONNECTION_ACTIVE)
              CASE_CODE(ERROR_NETWORK_UNREACHABLE)
              CASE_CODE(ERROR_HOST_UNREACHABLE)
              CASE_CODE(ERROR_PROTOCOL_UNREACHABLE)
              CASE_CODE(ERROR_PORT_UNREACHABLE)
              CASE_CODE(ERROR_REQUEST_ABORTED)
              CASE_CODE(ERROR_CONNECTION_ABORTED)
              CASE_CODE(ERROR_RETRY)
              CASE_CODE(ERROR_CONNECTION_COUNT_LIMIT)
              CASE_CODE(ERROR_LOGIN_TIME_RESTRICTION)
              CASE_CODE(ERROR_LOGIN_WKSTA_RESTRICTION)
              CASE_CODE(ERROR_INCORRECT_ADDRESS)
              CASE_CODE(ERROR_ALREADY_REGISTERED)
              CASE_CODE(ERROR_SERVICE_NOT_FOUND)
              CASE_CODE(ERROR_NOT_AUTHENTICATED)
              CASE_CODE(ERROR_NOT_LOGGED_ON)
              CASE_CODE(ERROR_CONTINUE)
              CASE_CODE(ERROR_ALREADY_INITIALIZED)
              CASE_CODE(ERROR_NO_MORE_DEVICES)
              CASE_CODE(ERROR_NOT_ALL_ASSIGNED)
              CASE_CODE(ERROR_SOME_NOT_MAPPED)
              CASE_CODE(ERROR_NO_QUOTAS_FOR_ACCOUNT)
              CASE_CODE(ERROR_LOCAL_USER_SESSION_KEY)
              CASE_CODE(ERROR_NULL_LM_PASSWORD)
              CASE_CODE(ERROR_UNKNOWN_REVISION)
              CASE_CODE(ERROR_REVISION_MISMATCH)
              CASE_CODE(ERROR_INVALID_OWNER)
              CASE_CODE(ERROR_INVALID_PRIMARY_GROUP)
              CASE_CODE(ERROR_NO_IMPERSONATION_TOKEN)
              CASE_CODE(ERROR_CANT_DISABLE_MANDATORY)
              CASE_CODE(ERROR_NO_LOGON_SERVERS)
              CASE_CODE(ERROR_NO_SUCH_LOGON_SESSION)
              CASE_CODE(ERROR_NO_SUCH_PRIVILEGE)
              CASE_CODE(ERROR_PRIVILEGE_NOT_HELD)
              CASE_CODE(ERROR_INVALID_ACCOUNT_NAME)
              CASE_CODE(ERROR_USER_EXISTS)
              CASE_CODE(ERROR_NO_SUCH_USER)
              CASE_CODE(ERROR_GROUP_EXISTS)
              CASE_CODE(ERROR_NO_SUCH_GROUP)
              CASE_CODE(ERROR_MEMBER_IN_GROUP)
              CASE_CODE(ERROR_MEMBER_NOT_IN_GROUP)
              CASE_CODE(ERROR_LAST_ADMIN)
              CASE_CODE(ERROR_WRONG_PASSWORD)
              CASE_CODE(ERROR_ILL_FORMED_PASSWORD)
              CASE_CODE(ERROR_PASSWORD_RESTRICTION)
              CASE_CODE(ERROR_LOGON_FAILURE)
              CASE_CODE(ERROR_ACCOUNT_RESTRICTION)
              CASE_CODE(ERROR_INVALID_LOGON_HOURS)
              CASE_CODE(ERROR_INVALID_WORKSTATION)
              CASE_CODE(ERROR_PASSWORD_EXPIRED)
              CASE_CODE(ERROR_ACCOUNT_DISABLED)
              CASE_CODE(ERROR_NONE_MAPPED)
              CASE_CODE(ERROR_TOO_MANY_LUIDS_REQUESTED)
              CASE_CODE(ERROR_LUIDS_EXHAUSTED)
              CASE_CODE(ERROR_INVALID_SUB_AUTHORITY)
              CASE_CODE(ERROR_INVALID_ACL)
              CASE_CODE(ERROR_INVALID_SID)
              CASE_CODE(ERROR_INVALID_SECURITY_DESCR)
              CASE_CODE(ERROR_BAD_INHERITANCE_ACL)
              CASE_CODE(ERROR_SERVER_DISABLED)
              CASE_CODE(ERROR_SERVER_NOT_DISABLED)
              CASE_CODE(ERROR_INVALID_ID_AUTHORITY)
              CASE_CODE(ERROR_ALLOTTED_SPACE_EXCEEDED)
              CASE_CODE(ERROR_INVALID_GROUP_ATTRIBUTES)
              CASE_CODE(ERROR_BAD_IMPERSONATION_LEVEL)
              CASE_CODE(ERROR_CANT_OPEN_ANONYMOUS)
              CASE_CODE(ERROR_BAD_VALIDATION_CLASS)
              CASE_CODE(ERROR_BAD_TOKEN_TYPE)
              CASE_CODE(ERROR_NO_SECURITY_ON_OBJECT)
              CASE_CODE(ERROR_CANT_ACCESS_DOMAIN_INFO)
              CASE_CODE(ERROR_INVALID_SERVER_STATE)
              CASE_CODE(ERROR_INVALID_DOMAIN_STATE)
              CASE_CODE(ERROR_INVALID_DOMAIN_ROLE)
              CASE_CODE(ERROR_NO_SUCH_DOMAIN)
              CASE_CODE(ERROR_DOMAIN_EXISTS)
              CASE_CODE(ERROR_DOMAIN_LIMIT_EXCEEDED)
              CASE_CODE(ERROR_INTERNAL_DB_CORRUPTION)
              CASE_CODE(ERROR_INTERNAL_ERROR)
              CASE_CODE(ERROR_GENERIC_NOT_MAPPED)
              CASE_CODE(ERROR_BAD_DESCRIPTOR_FORMAT)
              CASE_CODE(ERROR_NOT_LOGON_PROCESS)
              CASE_CODE(ERROR_LOGON_SESSION_EXISTS)
              CASE_CODE(ERROR_NO_SUCH_PACKAGE)
              CASE_CODE(ERROR_BAD_LOGON_SESSION_STATE)
              CASE_CODE(ERROR_LOGON_SESSION_COLLISION)
              CASE_CODE(ERROR_INVALID_LOGON_TYPE)
              CASE_CODE(ERROR_CANNOT_IMPERSONATE)
              CASE_CODE(ERROR_RXACT_INVALID_STATE)
              CASE_CODE(ERROR_RXACT_COMMIT_FAILURE)
              CASE_CODE(ERROR_SPECIAL_ACCOUNT)
              CASE_CODE(ERROR_SPECIAL_GROUP)
              CASE_CODE(ERROR_SPECIAL_USER)
              CASE_CODE(ERROR_MEMBERS_PRIMARY_GROUP)
              CASE_CODE(ERROR_TOKEN_ALREADY_IN_USE)
              CASE_CODE(ERROR_NO_SUCH_ALIAS)
              CASE_CODE(ERROR_MEMBER_NOT_IN_ALIAS)
              CASE_CODE(ERROR_MEMBER_IN_ALIAS)
              CASE_CODE(ERROR_ALIAS_EXISTS)
              CASE_CODE(ERROR_LOGON_NOT_GRANTED)
              CASE_CODE(ERROR_TOO_MANY_SECRETS)
              CASE_CODE(ERROR_SECRET_TOO_LONG)
              CASE_CODE(ERROR_INTERNAL_DB_ERROR)
              CASE_CODE(ERROR_TOO_MANY_CONTEXT_IDS)
              CASE_CODE(ERROR_LOGON_TYPE_NOT_GRANTED)
              CASE_CODE(ERROR_NT_CROSS_ENCRYPTION_REQUIRED)
              CASE_CODE(ERROR_NO_SUCH_MEMBER)
              CASE_CODE(ERROR_INVALID_MEMBER)
              CASE_CODE(ERROR_TOO_MANY_SIDS)
              CASE_CODE(ERROR_LM_CROSS_ENCRYPTION_REQUIRED)
              CASE_CODE(ERROR_NO_INHERITANCE)
              CASE_CODE(ERROR_FILE_CORRUPT)
              CASE_CODE(ERROR_DISK_CORRUPT)
              CASE_CODE(ERROR_NO_USER_SESSION_KEY)
              CASE_CODE(ERROR_LICENSE_QUOTA_EXCEEDED)
              CASE_CODE(ERROR_INVALID_WINDOW_HANDLE)
              CASE_CODE(ERROR_INVALID_MENU_HANDLE)
              CASE_CODE(ERROR_INVALID_CURSOR_HANDLE)
              CASE_CODE(ERROR_INVALID_ACCEL_HANDLE)
              CASE_CODE(ERROR_INVALID_HOOK_HANDLE)
              CASE_CODE(ERROR_INVALID_DWP_HANDLE)
              CASE_CODE(ERROR_TLW_WITH_WSCHILD)
              CASE_CODE(ERROR_CANNOT_FIND_WND_CLASS)
              CASE_CODE(ERROR_WINDOW_OF_OTHER_THREAD)
              CASE_CODE(ERROR_HOTKEY_ALREADY_REGISTERED)
              CASE_CODE(ERROR_CLASS_ALREADY_EXISTS)
              CASE_CODE(ERROR_CLASS_DOES_NOT_EXIST)
              CASE_CODE(ERROR_CLASS_HAS_WINDOWS)
              CASE_CODE(ERROR_INVALID_INDEX)
              CASE_CODE(ERROR_INVALID_ICON_HANDLE)
              CASE_CODE(ERROR_PRIVATE_DIALOG_INDEX)
              CASE_CODE(ERROR_LISTBOX_ID_NOT_FOUND)
              CASE_CODE(ERROR_NO_WILDCARD_CHARACTERS)
              CASE_CODE(ERROR_CLIPBOARD_NOT_OPEN)
              CASE_CODE(ERROR_HOTKEY_NOT_REGISTERED)
              CASE_CODE(ERROR_WINDOW_NOT_DIALOG)
              CASE_CODE(ERROR_CONTROL_ID_NOT_FOUND)
              CASE_CODE(ERROR_INVALID_COMBOBOX_MESSAGE)
              CASE_CODE(ERROR_WINDOW_NOT_COMBOBOX)
              CASE_CODE(ERROR_INVALID_EDIT_HEIGHT)
              CASE_CODE(ERROR_DC_NOT_FOUND)
              CASE_CODE(ERROR_INVALID_HOOK_FILTER)
              CASE_CODE(ERROR_INVALID_FILTER_PROC)
              CASE_CODE(ERROR_HOOK_NEEDS_HMOD)
              CASE_CODE(ERROR_GLOBAL_ONLY_HOOK)
              CASE_CODE(ERROR_JOURNAL_HOOK_SET)
              CASE_CODE(ERROR_HOOK_NOT_INSTALLED)
              CASE_CODE(ERROR_INVALID_LB_MESSAGE)
              CASE_CODE(ERROR_SETCOUNT_ON_BAD_LB)
              CASE_CODE(ERROR_LB_WITHOUT_TABSTOPS)
              CASE_CODE(ERROR_DESTROY_OBJECT_OF_OTHER_THREAD)
              CASE_CODE(ERROR_CHILD_WINDOW_MENU)
              CASE_CODE(ERROR_NO_SYSTEM_MENU)
              CASE_CODE(ERROR_INVALID_MSGBOX_STYLE)
              CASE_CODE(ERROR_INVALID_SPI_VALUE)
              CASE_CODE(ERROR_SCREEN_ALREADY_LOCKED)
              CASE_CODE(ERROR_HWNDS_HAVE_DIFF_PARENT)
              CASE_CODE(ERROR_NOT_CHILD_WINDOW)
              CASE_CODE(ERROR_INVALID_GW_COMMAND)
              CASE_CODE(ERROR_INVALID_THREAD_ID)
              CASE_CODE(ERROR_NON_MDICHILD_WINDOW)
              CASE_CODE(ERROR_POPUP_ALREADY_ACTIVE)
              CASE_CODE(ERROR_NO_SCROLLBARS)
              CASE_CODE(ERROR_INVALID_SCROLLBAR_RANGE)
              CASE_CODE(ERROR_INVALID_SHOWWIN_COMMAND)
              CASE_CODE(ERROR_NO_SYSTEM_RESOURCES)
              CASE_CODE(ERROR_NONPAGED_SYSTEM_RESOURCES)
              CASE_CODE(ERROR_PAGED_SYSTEM_RESOURCES)
              CASE_CODE(ERROR_WORKING_SET_QUOTA)
              CASE_CODE(ERROR_PAGEFILE_QUOTA)
              CASE_CODE(ERROR_COMMITMENT_LIMIT)
              CASE_CODE(ERROR_MENU_ITEM_NOT_FOUND)
              CASE_CODE(ERROR_INVALID_KEYBOARD_HANDLE)
              CASE_CODE(ERROR_HOOK_TYPE_NOT_ALLOWED)
              CASE_CODE(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION)
              CASE_CODE(ERROR_EVENTLOG_FILE_CORRUPT)
              CASE_CODE(ERROR_EVENTLOG_CANT_START)
              CASE_CODE(ERROR_LOG_FILE_FULL)
              CASE_CODE(ERROR_EVENTLOG_FILE_CHANGED)
              CASE_CODE(RPC_S_INVALID_STRING_BINDING)
              CASE_CODE(RPC_S_WRONG_KIND_OF_BINDING)
              CASE_CODE(RPC_S_INVALID_BINDING)
              CASE_CODE(RPC_S_PROTSEQ_NOT_SUPPORTED)
              CASE_CODE(RPC_S_INVALID_RPC_PROTSEQ)
              CASE_CODE(RPC_S_INVALID_STRING_UUID)
              CASE_CODE(RPC_S_INVALID_ENDPOINT_FORMAT)
              CASE_CODE(RPC_S_INVALID_NET_ADDR)
              CASE_CODE(RPC_S_NO_ENDPOINT_FOUND)
              CASE_CODE(RPC_S_INVALID_TIMEOUT)
              CASE_CODE(RPC_S_OBJECT_NOT_FOUND)
              CASE_CODE(RPC_S_ALREADY_REGISTERED)
              CASE_CODE(RPC_S_TYPE_ALREADY_REGISTERED)
              CASE_CODE(RPC_S_ALREADY_LISTENING)
              CASE_CODE(RPC_S_NO_PROTSEQS_REGISTERED)
              CASE_CODE(RPC_S_NOT_LISTENING)
              CASE_CODE(RPC_S_UNKNOWN_MGR_TYPE)
              CASE_CODE(RPC_S_UNKNOWN_IF)
              CASE_CODE(RPC_S_NO_BINDINGS)
              CASE_CODE(RPC_S_NO_PROTSEQS)
              CASE_CODE(RPC_S_CANT_CREATE_ENDPOINT)
              CASE_CODE(RPC_S_OUT_OF_RESOURCES)
              CASE_CODE(RPC_S_SERVER_UNAVAILABLE)
              CASE_CODE(RPC_S_SERVER_TOO_BUSY)
              CASE_CODE(RPC_S_INVALID_NETWORK_OPTIONS)
              CASE_CODE(RPC_S_NO_CALL_ACTIVE)
              CASE_CODE(RPC_S_CALL_FAILED)
              CASE_CODE(RPC_S_CALL_FAILED_DNE)
              CASE_CODE(RPC_S_PROTOCOL_ERROR)
              CASE_CODE(RPC_S_UNSUPPORTED_TRANS_SYN)
              CASE_CODE(RPC_S_UNSUPPORTED_TYPE)
              CASE_CODE(RPC_S_INVALID_TAG)
              CASE_CODE(RPC_S_INVALID_BOUND)
              CASE_CODE(RPC_S_NO_ENTRY_NAME)
              CASE_CODE(RPC_S_INVALID_NAME_SYNTAX)
              CASE_CODE(RPC_S_UNSUPPORTED_NAME_SYNTAX)
              CASE_CODE(RPC_S_UUID_NO_ADDRESS)
              CASE_CODE(RPC_S_DUPLICATE_ENDPOINT)
              CASE_CODE(RPC_S_UNKNOWN_AUTHN_TYPE)
              CASE_CODE(RPC_S_MAX_CALLS_TOO_SMALL)
              CASE_CODE(RPC_S_STRING_TOO_LONG)
              CASE_CODE(RPC_S_PROTSEQ_NOT_FOUND)
              CASE_CODE(RPC_S_PROCNUM_OUT_OF_RANGE)
              CASE_CODE(RPC_S_BINDING_HAS_NO_AUTH)
              CASE_CODE(RPC_S_UNKNOWN_AUTHN_SERVICE)
              CASE_CODE(RPC_S_UNKNOWN_AUTHN_LEVEL)
              CASE_CODE(RPC_S_INVALID_AUTH_IDENTITY)
              CASE_CODE(RPC_S_UNKNOWN_AUTHZ_SERVICE)
              CASE_CODE(EPT_S_INVALID_ENTRY)
              CASE_CODE(EPT_S_CANT_PERFORM_OP)
              CASE_CODE(EPT_S_NOT_REGISTERED)
              CASE_CODE(RPC_S_NOTHING_TO_EXPORT)
              CASE_CODE(RPC_S_INCOMPLETE_NAME)
              CASE_CODE(RPC_S_INVALID_VERS_OPTION)
              CASE_CODE(RPC_S_NO_MORE_MEMBERS)
              CASE_CODE(RPC_S_NOT_ALL_OBJS_UNEXPORTED)
              CASE_CODE(RPC_S_INTERFACE_NOT_FOUND)
              CASE_CODE(RPC_S_ENTRY_ALREADY_EXISTS)
              CASE_CODE(RPC_S_ENTRY_NOT_FOUND)
              CASE_CODE(RPC_S_NAME_SERVICE_UNAVAILABLE)
              CASE_CODE(RPC_S_INVALID_NAF_ID)
              CASE_CODE(RPC_S_CANNOT_SUPPORT)
              CASE_CODE(RPC_S_NO_CONTEXT_AVAILABLE)
              CASE_CODE(RPC_S_INTERNAL_ERROR)
              CASE_CODE(RPC_S_ZERO_DIVIDE)
              CASE_CODE(RPC_S_ADDRESS_ERROR)
              CASE_CODE(RPC_S_FP_DIV_ZERO)
              CASE_CODE(RPC_S_FP_UNDERFLOW)
              CASE_CODE(RPC_S_FP_OVERFLOW)
              CASE_CODE(RPC_X_NO_MORE_ENTRIES)
              CASE_CODE(RPC_X_SS_CHAR_TRANS_OPEN_FAIL)
              CASE_CODE(RPC_X_SS_CHAR_TRANS_SHORT_FILE)
              CASE_CODE(RPC_X_SS_IN_NULL_CONTEXT)
              CASE_CODE(RPC_X_SS_CONTEXT_DAMAGED)
              CASE_CODE(RPC_X_SS_HANDLES_MISMATCH)
              CASE_CODE(RPC_X_SS_CANNOT_GET_CALL_HANDLE)
              CASE_CODE(RPC_X_NULL_REF_POINTER)
              CASE_CODE(RPC_X_ENUM_VALUE_OUT_OF_RANGE)
              CASE_CODE(RPC_X_BYTE_COUNT_TOO_SMALL)
              CASE_CODE(RPC_X_BAD_STUB_DATA)
              CASE_CODE(ERROR_INVALID_USER_BUFFER)
              CASE_CODE(ERROR_UNRECOGNIZED_MEDIA)
              CASE_CODE(ERROR_NO_TRUST_LSA_SECRET)
              CASE_CODE(ERROR_NO_TRUST_SAM_ACCOUNT)
              CASE_CODE(ERROR_TRUSTED_DOMAIN_FAILURE)
              CASE_CODE(ERROR_TRUSTED_RELATIONSHIP_FAILURE)
              CASE_CODE(ERROR_TRUST_FAILURE)
              CASE_CODE(RPC_S_CALL_IN_PROGRESS)
              CASE_CODE(ERROR_NETLOGON_NOT_STARTED)
              CASE_CODE(ERROR_ACCOUNT_EXPIRED)
              CASE_CODE(ERROR_REDIRECTOR_HAS_OPEN_HANDLES)
              CASE_CODE(ERROR_PRINTER_DRIVER_ALREADY_INSTALLED)
              CASE_CODE(ERROR_UNKNOWN_PORT)
              CASE_CODE(ERROR_UNKNOWN_PRINTER_DRIVER)
              CASE_CODE(ERROR_UNKNOWN_PRINTPROCESSOR)
              CASE_CODE(ERROR_INVALID_SEPARATOR_FILE)
              CASE_CODE(ERROR_INVALID_PRIORITY)
              CASE_CODE(ERROR_INVALID_PRINTER_NAME)
              CASE_CODE(ERROR_PRINTER_ALREADY_EXISTS)
              CASE_CODE(ERROR_INVALID_PRINTER_COMMAND)
              CASE_CODE(ERROR_INVALID_DATATYPE)
              CASE_CODE(ERROR_INVALID_ENVIRONMENT)
              CASE_CODE(RPC_S_NO_MORE_BINDINGS)
              CASE_CODE(ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT)
              CASE_CODE(ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT)
              CASE_CODE(ERROR_NOLOGON_SERVER_TRUST_ACCOUNT)
              CASE_CODE(ERROR_DOMAIN_TRUST_INCONSISTENT)
              CASE_CODE(ERROR_SERVER_HAS_OPEN_HANDLES)
              CASE_CODE(ERROR_RESOURCE_DATA_NOT_FOUND)
              CASE_CODE(ERROR_RESOURCE_TYPE_NOT_FOUND)
              CASE_CODE(ERROR_RESOURCE_NAME_NOT_FOUND)
              CASE_CODE(ERROR_RESOURCE_LANG_NOT_FOUND)
              CASE_CODE(ERROR_NOT_ENOUGH_QUOTA)
              CASE_CODE(RPC_S_NO_INTERFACES)
              CASE_CODE(RPC_S_CALL_CANCELLED)
              CASE_CODE(RPC_S_BINDING_INCOMPLETE)
              CASE_CODE(RPC_S_COMM_FAILURE)
              CASE_CODE(RPC_S_UNSUPPORTED_AUTHN_LEVEL)
              CASE_CODE(RPC_S_NO_PRINC_NAME)
              CASE_CODE(RPC_S_NOT_RPC_ERROR)
              CASE_CODE(RPC_S_UUID_LOCAL_ONLY)
              CASE_CODE(RPC_S_SEC_PKG_ERROR)
              CASE_CODE(RPC_S_NOT_CANCELLED)
              CASE_CODE(RPC_X_INVALID_ES_ACTION)
              CASE_CODE(RPC_X_WRONG_ES_VERSION)
              CASE_CODE(RPC_X_WRONG_STUB_VERSION)
              CASE_CODE(RPC_X_INVALID_PIPE_OBJECT)
              CASE_CODE(RPC_X_INVALID_PIPE_OPERATION)
              CASE_CODE(RPC_X_WRONG_PIPE_VERSION)
              CASE_CODE(RPC_S_GROUP_MEMBER_NOT_FOUND)
              CASE_CODE(EPT_S_CANT_CREATE)
              CASE_CODE(RPC_S_INVALID_OBJECT)
              CASE_CODE(ERROR_INVALID_TIME)
              CASE_CODE(ERROR_INVALID_FORM_NAME)
              CASE_CODE(ERROR_INVALID_FORM_SIZE)
              CASE_CODE(ERROR_ALREADY_WAITING)
              CASE_CODE(ERROR_PRINTER_DELETED)
              CASE_CODE(ERROR_INVALID_PRINTER_STATE)
              CASE_CODE(ERROR_PASSWORD_MUST_CHANGE)
              CASE_CODE(ERROR_DOMAIN_CONTROLLER_NOT_FOUND)
              CASE_CODE(ERROR_ACCOUNT_LOCKED_OUT)
              CASE_CODE(OR_INVALID_OXID)
              CASE_CODE(OR_INVALID_OID)
              CASE_CODE(OR_INVALID_SET)
              CASE_CODE(RPC_S_SEND_INCOMPLETE)
              CASE_CODE(ERROR_NO_BROWSER_SERVERS_FOUND)
              CASE_CODE(ERROR_INVALID_PIXEL_FORMAT)
              CASE_CODE(ERROR_BAD_DRIVER)
              CASE_CODE(ERROR_INVALID_WINDOW_STYLE)
              CASE_CODE(ERROR_METAFILE_NOT_SUPPORTED)
              CASE_CODE(ERROR_TRANSFORM_NOT_SUPPORTED)
              CASE_CODE(ERROR_CLIPPING_NOT_SUPPORTED)
              CASE_CODE(ERROR_UNKNOWN_PRINT_MONITOR)
              CASE_CODE(ERROR_PRINTER_DRIVER_IN_USE)
              CASE_CODE(ERROR_SPOOL_FILE_NOT_FOUND)
              CASE_CODE(ERROR_SPL_NO_STARTDOC)
              CASE_CODE(ERROR_SPL_NO_ADDJOB)
              CASE_CODE(ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED)
              CASE_CODE(ERROR_PRINT_MONITOR_ALREADY_INSTALLED)
              CASE_CODE(ERROR_INVALID_PRINT_MONITOR)
              CASE_CODE(ERROR_PRINT_MONITOR_IN_USE)
              CASE_CODE(ERROR_PRINTER_HAS_JOBS_QUEUED)
              CASE_CODE(ERROR_SUCCESS_REBOOT_REQUIRED)
              CASE_CODE(ERROR_SUCCESS_RESTART_REQUIRED)
              CASE_CODE(ERROR_WINS_INTERNAL)
              CASE_CODE(ERROR_CAN_NOT_DEL_LOCAL_WINS)
              CASE_CODE(ERROR_STATIC_INIT)
              CASE_CODE(ERROR_INC_BACKUP)
              CASE_CODE(ERROR_FULL_BACKUP)
              CASE_CODE(ERROR_REC_NON_EXISTENT)
              CASE_CODE(ERROR_RPL_NOT_ALLOWED)

              default:
              _tcscpy(szErrorName, _T(""));
              FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), 
                      szErrorDesc, sizeof(TCHAR)*_ERRORDESCLEN, NULL);
              }
         }  // if FACILITY_WIN32
         else  if (HRESULT_FACILITY(hr) == FACILITY_CONTROL && HRESULT_CODE(hr) >= 600)
         {
              szErrorName[0] = _T('\0');
              _tcscpy(szErrorDesc, _T(""));
         }
         else  if (HRESULT_FACILITY(hr) == FACILITY_ITF && HRESULT_CODE(hr) >= 0x200)
         {
              szErrorName[0] = _T('\0');
              _tcscpy(szErrorDesc, _T(""));
         }
         else 
         {
            _tcscpy(szErrorName, _T(""));  // Not FACILITY_WIN32 or FACILITY_ITF(code >= 0x200) or FACILTY_CONTROL(code >= 600)
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), 
                           szErrorDesc, sizeof(TCHAR)*_ERRORDESCLEN, NULL);
         }
  }       
 
	_tcscpy(pszFacility,szFacility);
	_tcscpy(pszErrorName,szErrorName);
	_tcscpy(pszErrorDesc,szErrorDesc);
}

#pragma warning( default : 4245 )

inline void CConnectionManager::HandleConnMgrException(HRESULT hr)
{
	TRACEX(_T("CConnectionManager::HandleConnMgrException\n"));
	TRACEARGn(hr);

	AfxMessageBox(IDS_STRING_CONNMGR_DEAD);
}

//////////////////////////////////////////////////////////////////////
// Marshalling Operations
//////////////////////////////////////////////////////////////////////

// I support these only because we now need to use Property Pages in the
// snap-in. Since property pages run in their own thread and the snap-in
// architeture uses apartment threading model, ANY COM interface pointers
// to be used within the property page thread must be marshalled...fortunately
// I have only to marshal IConnectionManager.

HRESULT CConnectionManager::MarshalCnxMgr()
{
	TRACEX(_T("CConnectionManager::MarshalCnxMgr\n"));

	HRESULT hr = S_OK;

	// we are called from the snapin's main thread here in prep for marshalling

	CMarshalledConnection* pNewConnection = new CMarshalledConnection;
	hr = pNewConnection->Marshal(m_pIConnectionManager);
	if( !CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : CMarshalledConnection::Marshal failed.\n"));		
	}

	m_MarshalStack.AddHead(pNewConnection);

	return hr;
}

HRESULT CConnectionManager::UnMarshalCnxMgr()
{
	TRACEX(_T("CConnectionManager::UnMarshalCnxMgr\n"));

	HRESULT hr = S_OK;

	// unmarshal the connection now that we are in the new property page thread

	// v-marfin :  bug 59643
	// Check for empty list before proceeding.
	if (m_MarshalStack.IsEmpty())
	{
		TRACE(_T("WARNING : Could not find a connection waiting on the stack!\n"));
		return E_FAIL;
	}

	CMarshalledConnection* pConnection = m_MarshalStack.RemoveTail();
	ASSERT(pConnection);
	if( pConnection == NULL )
	{
		TRACE(_T("FAILED : Could not find a connection waiting on the stack!\n"));
		return E_FAIL;
	}

	// now insert the marshalled connection into the map of thread ids to connections.
	// first check if a connection has already been marshalled before inserting
	// the connection into the map
	DWORD dwThreadID = GetCurrentThreadId();
	CMarshalledConnection* pExistingConnection = NULL;
	if( m_MarshalMap.Lookup(dwThreadID,pExistingConnection) )
	{
		ASSERT(pExistingConnection);
		
		// delete the connection we were going to add, because it has already been
		// marshalled for this thread id
		delete pConnection;

		return hr;
	}
	else
	{
		m_MarshalMap.SetAt(dwThreadID,pConnection);
	}


	// unmarshal the connection now
	hr = pConnection->UnMarshal();
	if( !CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : CMarshalledConnection::UnMarshal failed.\n"));		
		return E_FAIL;
	}


	return hr;
}

void CConnectionManager::CleanUpMarshalCnxMgr()
{
	TRACEX(_T("CConnectionManager::CleanUpMarshalCnxMgr\n"));

	// we are called here by the dying thread of the property page which is about to be
	// destroyed. We must clean up by removing the marshalled connection from the map
	DWORD dwThreadID = GetCurrentThreadId();
	CMarshalledConnection* pConnection = NULL;

	m_MarshalMap.Lookup(dwThreadID,pConnection);
	
	if( pConnection == NULL )
	{
		TRACE(_T("FAILED : Could not find a connection for the calling thread!\n"));
		return;
	}
	
	if( ! m_MarshalMap.RemoveKey(dwThreadID) )
	{
		TRACE(_T("FAILED : Could not remove the key from the marshal map.\n"));
		return;
	}

	delete pConnection;

	return;
}

//////////////////////////////////////////////////////////////////////
// Implementation Operations
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\connectionmanager.h ===
// ConnectionManager.h: interface for the CConnectionManager class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CONNECTIONMANAGER_H__F0E5AFBD_0204_11D2_8355_0000F87A3912__INCLUDED_)
#define AFX_CONNECTIONMANAGER_H__F0E5AFBD_0204_11D2_8355_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <ConnMgr.h>

// error reporting defines
#define _ERRORDESCLEN _MAX_PATH*4
#define _ERRORNAMELEN _MAX_PATH
#define _FACILITYLEN	_MAX_PATH

//////////////////////////////////////////////////////////////////////
// class CMarshalledConnection
//////////////////////////////////////////////////////////////////////

class CMarshalledConnection
{

// Constructors
public:
	CMarshalledConnection();

// Operations
public:
	HRESULT Marshal(IConnectionManager* pIConMgr);
	HRESULT UnMarshal();
	IConnectionManager* GetConnection();

// Attributes
protected:
	IConnectionManager* m_pIMarshalledConnectionManager;
	LPSTREAM m_lpMarshalStream;

};


//////////////////////////////////////////////////////////////////////
// class CConnectionManager
//////////////////////////////////////////////////////////////////////

class CConnectionManager : public CObject  
{

DECLARE_DYNCREATE(CConnectionManager)

// Constructors
public:
	CConnectionManager();

// Destructor
public:
	virtual ~CConnectionManager();

// Create/Destroy
public:
  BOOL Create();
  void Destroy();

// Connection Operations
public:
  HRESULT GetConnection(const CString& sMachineName, IWbemServices*& pIWbemServices, BOOL& bAvailable );
	HRESULT ConnectToNamespace(const CString& sNamespace, IWbemServices*& pIWbemServices);
	HRESULT RemoveConnection(const CString& sMachineName, IWbemObjectSink* pSink);

// Query Operations
public:
	HRESULT ExecQueryAsync(const CString& sMachineName, const CString& sQuery, IWbemObjectSink*& pSink);

// Event Operations
public:
	HRESULT RegisterEventNotification(const CString& sMachineName, const CString& sQuery, IWbemObjectSink*& pSink);

// Error Display Operations
public:
	void DisplayErrorMsgBox(HRESULT hr, const CString& sMachineName);
	void GetErrorString(HRESULT hr, const CString& sMachineName, CString& sErrorText);

// Marshalling Operations
public:	
	HRESULT MarshalCnxMgr();
	HRESULT UnMarshalCnxMgr();
	void CleanUpMarshalCnxMgr();

// Implementation Operations
protected:
	void DecodeHResult(HRESULT hr, LPTSTR pszFacility, LPTSTR pszErrorName, LPTSTR pszErrorDesc);
	void HandleConnMgrException(HRESULT hr);

// Implementation Attributes
protected:
	IConnectionManager* m_pIConnectionManager;
	CMap<DWORD,DWORD,CMarshalledConnection*,CMarshalledConnection*> m_MarshalMap;
	CTypedPtrList<CPtrList,CMarshalledConnection*> m_MarshalStack;
};

extern CConnectionManager theCnxManager;

inline HRESULT CnxGetConnection(const CString& sMachineName, IWbemServices*& pIWbemServices, BOOL& bAvailable)
{
  return theCnxManager.GetConnection(sMachineName,pIWbemServices,bAvailable);
}

inline HRESULT CnxConnectToNamespace(const CString& sNamespace, IWbemServices*& pIWbemServices)
{
  return theCnxManager.ConnectToNamespace(sNamespace,pIWbemServices);
}

inline HRESULT CnxRemoveConnection(const CString& sMachineName, IWbemObjectSink* pSink)
{
	return theCnxManager.RemoveConnection(sMachineName,pSink);
}

inline BOOL CnxCreate()
{
  return theCnxManager.Create();
}

inline void CnxDestroy()
{
  theCnxManager.Destroy();
}

inline HRESULT CnxExecQueryAsync(const CString& sMachineName, const CString& sQuery, IWbemObjectSink*& pSink)
{
	return theCnxManager.ExecQueryAsync(sMachineName,sQuery,pSink);
}

inline HRESULT CnxRegisterEventNotification(const CString& sMachineName, const CString& sQuery, IWbemObjectSink*& pSink)
{
	return theCnxManager.RegisterEventNotification(sMachineName,sQuery,pSink);
}

inline void CnxPropertyPageInit()
{
	theCnxManager.MarshalCnxMgr();
}

inline void CnxPropertyPageCreate()
{
	theCnxManager.UnMarshalCnxMgr();
}

inline void CnxPropertyPageDestroy()
{
	theCnxManager.CleanUpMarshalCnxMgr();
}

inline void CnxDisplayErrorMsgBox(HRESULT hr, const CString& sMachineName)
{
	theCnxManager.DisplayErrorMsgBox(hr,sMachineName);
}

inline void CnxGetErrorString(HRESULT hr, const CString& sMachineName, CString& sErrorText)
{
	theCnxManager.GetErrorString(hr,sMachineName,sErrorText);
}

#endif // !defined(AFX_CONNECTIONMANAGER_H__F0E5AFBD_0204_11D2_8355_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\configscopeitem.cpp ===
// ConfigScopeItem.cpp: implementation of the CConfigScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "ConfigScopeItem.h"
#include "ConfigResultsView.h"
#include "ActionManScopeItem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// {33A7606E-CAA5-11d2-BD8E-0000F87A3912}
static GUID GUID_Config = 
{ 0x33a7606e, 0xcaa5, 0x11d2, { 0xbd, 0x8e, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

IMPLEMENT_DYNCREATE(CConfigScopeItem,CHMScopeItem)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CConfigScopeItem::CConfigScopeItem()
{
	m_lpguidItemType = &GUID_Config;
}

CConfigScopeItem::~CConfigScopeItem()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Creation Members
//////////////////////////////////////////////////////////////////////

bool CConfigScopeItem::Create(CScopePane* pScopePane, CScopePaneItem* pParentItem)
{
	TRACEX(_T("CConfigScopeItem::Create\n"));
	TRACEARGn(pScopePane);
	TRACEARGn(pParentItem);

	// set up all the icons first
	m_IconResIds.Add(IDI_ICON_CONFIG);
	m_OpenIconResIds.Add(IDI_ICON_CONFIG);
	SetIconIndex(0);
	SetOpenIconIndex(0);

	// call base class Create method
	if( ! CScopePaneItem::Create(pScopePane,pParentItem) )
	{
		TRACE(_T("CScopePaneItem::Create failed.\n"));
		return false;
	}

	// set display names
	CString sName;
	sName.LoadString(IDS_STRING_CONFIG);
	SetDisplayName(0,sName);

	// add children
	CActionManScopeItem* pAMItem = new CActionManScopeItem;
	if( ! pAMItem->Create(GetScopePane(),this) )
	{
		ASSERT(0);
		delete pAMItem;
		return false;
	}

	m_Children.Add(pAMItem);


	return true;
}


//////////////////////////////////////////////////////////////////////	
// Results Pane View Members
//////////////////////////////////////////////////////////////////////

CResultsPaneView* CConfigScopeItem::CreateResultsPaneView()
{	
	TRACEX(_T("CConfigScopeItem::CreateResultsPaneView\n"));

	return new CConfigResultsView;
}

//////////////////////////////////////////////////////////////////////	
// MMC Notify Handlers
//////////////////////////////////////////////////////////////////////	

HRESULT CConfigScopeItem::OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed)
{
	TRACEX(_T("CConfigScopeItem::OnAddMenuItems\n"));
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

  HRESULT hr = S_OK;

  // Add New Menu Items
  if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed )
  {
	}

  // Add Task Menu Items
  if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_CLEAR_EVENTS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_CLEAR_EVENTS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_CLEAR_EVENTS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
		// separator
		cmi.strName           = NULL;
		cmi.strStatusBarText  = NULL;
		cmi.lCommandID        = NULL;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = MF_SEPARATOR;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
  }

  // Add View Menu Items
  if( CCM_INSERTIONALLOWED_VIEW & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_STATUS_ONLY);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_STATUS_ONLY_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_STATUS_ONLY;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_UNCHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    sResString.LoadString(IDS_STRING_ICONS_STATUS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ICONS_STATUS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ICONS_WITH_STATUS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_CHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    // icon legend
    sResString.LoadString(IDS_STRING_ICON_LEGEND);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ICON_LEGEND_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ICON_LEGEND;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
  }

	return hr;
}

HRESULT CConfigScopeItem::OnCommand(long lCommandID)
{
	TRACEX(_T("CConfigScopeItem::OnCommand\n"));
	TRACEARGn(lCommandID);

  HRESULT hr = S_OK;

	switch(lCommandID)
	{
		case IDM_CLEAR_EVENTS:
		{
		}
		break;
	}

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dataelement.cpp ===
// DataElement.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "DataElement.h"
#include "EventManager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDataElement

IMPLEMENT_SERIAL(CDataElement, CHMObject, 1)

CDataElement::CDataElement(BOOL bSetStateToEnabledOnOK)
{
	EnableAutomation();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();
	
	m_pRuleListener = NULL;

	m_sTypeName = IDS_STRING_MOF_DATAELEMENT;
	m_iType = IDM_GENERIC_WMI_INSTANCE;
	m_nState = HMS_NODATA;

    m_bSetStateToEnabledOnOK = bSetStateToEnabledOnOK;  // v-marfin 62585 : Indicates if this is a 'new' data collector
}

CDataElement::~CDataElement()
{
	if( m_pRuleListener )
	{
		delete m_pRuleListener;
		m_pRuleListener = NULL;
	}

	// TODO: RemoveStatistics
	// TODO: Destroy all events

	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}

//****************************************************
// 62585 : SetStateToEnabledOnOK
//
// This sets the boolean to indicate that the collector this
// class represents is being created for the first time via
// the New _> Data Collector menu item. The property pages
// need to know this info since the new data collector is
// defined as Disabled to begin with, so the page sets it
// to Enabled when the user selects the OK button.
//****************************************************
void CDataElement::SetStateToEnabledOnOK(BOOL bSetStateToEnabledOnOK)
{
    m_bSetStateToEnabledOnOK = bSetStateToEnabledOnOK;
}

void CDataElement::UpdateStatus()
{
	TRACEX(_T("CDataElement::UpdateStatus\n"));

	CEventContainer* pContainer = NULL;
	EvtGetEventManager()->GetEventContainer(GetSystemName(),GetGuid(),pContainer);
	if( ! pContainer )	
	{
		ASSERT(FALSE);
		return;
	}

	SetState(CEvent::GetStatus(pContainer->m_iState));

	for( int i = 0; i < GetScopeItemCount(); i++ )
	{
		CScopePaneItem* pItem = GetScopeItem(i);
		if( pItem )
		{
			CStringArray saNames;
			CString sValue;

			// Name of Data Element
			saNames.Add(GetName());

			// Status
			CString sStatus;
			CEvent::GetStatus(pContainer->m_iState,sStatus);
			saNames.Add(sStatus);

			// Type
			saNames.Add(GetUITypeName());

			// Guid
			saNames.Add(GetGuid());

			// Normal
			sValue.Format(_T("%d"),pContainer->m_iNumberNormals);
			saNames.Add(sValue);

			// Warning
			sValue.Format(_T("%d"),pContainer->m_iNumberWarnings);
			saNames.Add(sValue);

			// Critical
			sValue.Format(_T("%d"),pContainer->m_iNumberCriticals);
			saNames.Add(sValue);

			// Unknown
			sValue.Format(_T("%d"),pContainer->m_iNumberUnknowns);
			saNames.Add(sValue);

			// Last Message
			CString sLastMessage = pContainer->GetLastEventDTime();
			if( sLastMessage.IsEmpty() )
			{
				sLastMessage.LoadString(IDS_STRING_NONE);
			}
			saNames.Add(sLastMessage);

			// Comment
			saNames.Add(GetComment());

			pItem->SetDisplayNames(saNames);
			pItem->SetIconIndex(CEvent::GetStatus(pContainer->m_iState));
			pItem->SetOpenIconIndex(CEvent::GetStatus(pContainer->m_iState));
			pItem->SetItem();
		}
	}

	m_lNormalCount = pContainer->m_iNumberNormals;
	m_lWarningCount = pContainer->m_iNumberWarnings;
	m_lCriticalCount = pContainer->m_iNumberCriticals;
	m_lUnknownCount = pContainer->m_iNumberUnknowns;
	
}


void CDataElement::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CHMObject::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CDataElement, CHMObject)
	//{{AFX_MSG_MAP(CDataElement)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CDataElement, CHMObject)
	//{{AFX_DISPATCH_MAP(CDataElement)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IDataElement to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {D9BF4FA5-F673-11D2-BDC4-0000F87A3912}
static const IID IID_IDataElement =
{ 0xd9bf4fa5, 0xf673, 0x11d2, { 0xbd, 0xc4, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CDataElement, CHMObject)
	INTERFACE_PART(CDataElement, IID_IDataElement, Dispatch)
END_INTERFACE_MAP()

// {D9BF4FA6-F673-11D2-BDC4-0000F87A3912}
IMPLEMENT_OLECREATE_EX(CDataElement, "SnapIn.DataElement", 0xd9bf4fa6, 0xf673, 0x11d2, 0xbd, 0xc4, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12)

BOOL CDataElement::CDataElementFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterServerClass(m_clsid, m_lpszProgID, m_lpszProgID, m_lpszProgID, OAT_DISPATCH_OBJECT);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

/////////////////////////////////////////////////////////////////////////////
// CDataElement message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\constants.h ===
#ifndef __CONSTANTS_H__
#define __CONSTANTS_H__

#define IDM_NEW_GROUP								5010
#define IDM_CLEAR_EVENTS						    5020
#define IDM_NEW_SYSTEM							    5030
#define IDM_ICONS_WITH_STATUS				        5040
#define IDM_STATUS_ONLY							    5050
#define IDM_SEPARATE_GROUP					        5060
#define IDM_REMOVE_SYSTEM						    5070
#define IDM_RESET_STATISTICS				        5080
#define IDM_RESET_STATUS						    5090
#define IDM_DISABLE_MONITORING			            5100
#define IDM_DISCONNECT							    5101
#define IDM_CHECK_NOW								5102
#define IDM_ICON_LEGEND                             5103
#define IDM_DATA_POINT							    5110

#define IDM_FILE_INFO								5120
#define IDM_GENERIC_WMI_INSTANCE		            5130
#define IDM_HTTP_ADDRESS						    5140
#define IDM_SERVICE									5150
#define IDM_NT_EVENTS								5160
#define IDM_PERFMON									5170
#define IDM_AUTO_FILTER						    	5180
#define IDM_NEW_DATA_GROUP					        5190
#define IDM_NEW_DATA_COLLECTOR					    5195  // v-marfin 61102
#define IDM_SNMP									5200
#define IDM_NEW_RULE								5210
#define IDM_GENERIC_WMI_QUERY				        5220
#define IDM_GENERIC_WMI_POLLED_QUERY 5230
#define IDM_IMPORT									5240
#define IDM_EXPORT									5250
#define IDM_SMTP									5260
#define IDM_FTP										5270
#define IDM_ICMP									5280
#define IDM_COM_PLUS                                5281

#define IDM_DISABLE_ACTIONS					        5300

#define IDM_ACTION_CMDLINE					        5500
#define IDM_ACTION_EMAIL						    5510
#define IDM_ACTION_LOGFILE					        5520
#define IDM_ACTION_NTEVENT					        5530
#define IDM_ACTION_SCRIPT						    5540
#define IDM_ACTION_PAGING						    5550

#define IDM_CUT										6000
#define IDM_COPY									6010
#define IDM_PASTE									6020
#define IDM_DELETE									6030
#define IDM_REFRESH									6040
#define IDM_PROPERTIES                              6041
#define IDM_HELP                                    6050

// results pane item enumerated type
enum SplitResultsPane { Lower = 0, Upper = 1, Stats = 2, Uninitialized = -1 };

// refresh enumerated type
enum TimeUnit { Minutes, Hours, Days };

// results pane item constants
#define HMLV_LOWER_DTIME_INDEX	2
#define HMLV_STATS_DTIME_INDEX	0

// HMGraphView constants
#define HMGVS_GROUP             0x01
#define HMGVS_ELEMENT           0x02

#define HMGVS_HISTORIC          0x04
#define HMGVS_CURRENT           0x08

// Healthmon object state codes
#define HMS_NORMAL				0
#define HMS_DISABLED			1
#define HMS_SCHEDULEDOUT	    2
#define HMS_UNKNOWN				3
#define HMS_NODATA				4
#define HMS_WARNING				5
#define HMS_CRITICAL			6
#define HMS_MAX_STATES		    7

#define HMS_INFO				10

#define _MAX_STATS_EVENTS	    10

// strings
#define IDS_STRING_HEALTHMON_ROOT				_T("\\\\%s\\root\\cimv2\\MicrosoftHealthMonitor")
#define IDS_STRING_SMCATSTATUS_QUERY			_T("select * from __InstanceModificationEvent where TargetInstance isa \"HMCatStatus\"")
#define IDS_STRING_SMSTATICCATSTATUS_QUERY      _T("select * from __InstanceModificationEvent where TargetInstance isa \"HMStaticCatStatus\"")
#define IDS_STRING_SMEVENT_QUERY				_T("select * from __InstanceCreationEvent where TargetInstance isa \"HMEvent\"")
#define IDS_STRING_SMMACHSTATUS_QUERY			_T("select * from __InstanceModificationEvent where TargetInstance isa \"HMMachStatus\"")

#define IDS_STRING_MOF_ENABLE					_T("Enabled")
#define IDS_STRING_MOF_GUID						_T("GUID")
#define IDS_STRING_MOF_PARENT_GUID              _T("ParentGUID")
#define IDS_STRING_MOF_STATUSGUID				_T("StatusGUID")
#define IDS_STRING_MOF_DCNAME                   _T("DataCollectorName")
#define IDS_STRING_MOF_DESCRIPTION				_T("Description")
#define IDS_STRING_MOF_USERNAME					_T("UserName")
#define IDS_STRING_MOF_PASSWORD					_T("Password")
#define IDS_STRING_MOF_TARGETNAMESPACE		    _T("TargetNamespace")
#define IDS_STRING_MOF_COLLECTIONINTERVAL	    _T("CollectionIntervalMultiple")
#define IDS_STRING_MOF_STATISTICSWINDOW		    _T("StatisticsWindowSize")
#define IDS_STRING_MOF_ACTIVEDAYS				_T("ActiveDays")
#define IDS_STRING_MOF_BEGINTIME				_T("BeginTime")
#define IDS_STRING_MOF_ENDTIME					_T("EndTime")
#define IDS_STRING_MOF_TYPEGUID					_T("TypeGUID")
#define IDS_STRING_MOF_REQUIRERESET				_T("RequireReset")
#define IDS_STRING_MOF_REPLICATE				_T("Replicate")
#define IDS_STRING_MOF_ID						_T("ID")
#define IDS_STRING_MOF_PROPERTYNAME				_T("PropertyName")
#define IDS_STRING_MOF_LASTUPDATE				_T("LastUpdate")
#define IDS_STRING_MOF_USEFLAG					_T("UseFlag")
#define IDS_STRING_MOF_RULEVALUE				_T("CompareValue")
#define IDS_STRING_MOF_DATAGROUPS				_T("DataGroups")
#define IDS_STRING_MOF_CREATIONDATE				_T("CreationDate")
#define IDS_STRING_MOF_MESSAGE					_T("Message")
#define IDS_STRING_MOF_RESETMESSAGE				_T("ResetMessage")
#define IDS_STRING_MOF_CONFIG_MESSAGE           _T("ConfigurationMessage")
#define IDS_STRING_MOF_STARTUPDELAY				_T("StartupDelay")
#define IDS_STRING_MOF_ACTIVETIME				_T("ActiveTime")
#define IDS_STRING_MOF_NUMBERNORMALS			_T("NumberNormals")
#define IDS_STRING_MOF_NUMBERWARNINGS			_T("NumberWarnings")
#define IDS_STRING_MOF_NUMBERCRITICALS		    _T("NumberCriticals")
#define IDS_STRING_MOF_DATAELEMENTS				_T("DataCollectors")
#define IDS_STRING_MOF_RULES					_T("Thresholds")
#define IDS_STRING_MOF_CURRENTVALUE				_T("CurrentValue")
#define	IDS_STRING_MOF_RULECONDITION			_T("TestCondition")
#define IDS_STRING_MOF_RULEDURATION				_T("ThresholdDuration")
#define IDS_STRING_MOF_COMPAREVALUE				_T("CompareValue")
#define	IDS_STRING_MOF_CONSOLEGUID				_T("ConsoleGUID")
#define IDS_STRING_MOF_PATH						_T("ObjectPath")
#define IDS_STRING_MOF_METHODNAME				_T("MethodName")
#define IDS_STRING_MOF_ARGUMENTS				_T("Arguments")
#define IDS_STRING_MOF_INSTANCEPROPERTYIDNAME   _T("InstanceIDPropertyName")
#define IDS_STRING_MOF_STATISTICSPROPERTYNAMES  _T("Properties")
#define IDS_STRING_MOF_QUERY					_T("Query")
#define IDS_STRING_MOF_TYPE						_T("Type")
#define IDS_STRING_MOF_EVENTID					_T("EventIdentifier")
#define IDS_STRING_MOF_SOURCENAME				_T("SourceName")
#define IDS_STRING_MOF_CATEGORYSTRING			_T("CategoryString")
#define IDS_STRING_MOF_USER						_T("User")
#define IDS_STRING_MOF_STATISTICS				_T("Properties")
#define IDS_STRING_MOF_INSTANCES				_T("Instances")
#define IDS_STRING_MOF_MINVALUE					_T("MinValue")
#define IDS_STRING_MOF_MAXVALUE					_T("MaxValue")
#define IDS_STRING_MOF_AVGVALUE					_T("AvgValue")
#define IDS_STRING_MOF_VALUES					_T("Value")
#define IDS_STRING_MOF_RULE_NAME				_T("Name")
#define IDS_STRING_MOF_EVENTCONSUMER			_T("EventConsumer")
#define IDS_STRING_MOF_EVENT_LOG_QUERY		    _T("select * from __instancecreationevent where targetinstance isa \"Win32_NtLogEvent\"")

#define IDS_STRING_S2DG_ASSOC_QUERY				_T("ASSOCIATORS OF {Microsoft_HMSystemConfiguration=@} WHERE ResultClass=Microsoft_HMDataGroupConfiguration")
#define IDS_STRING_DG2DG_ASSOC_QUERY			_T("ASSOCIATORS OF {Microsoft_HMDataGroupConfiguration.GUID=\"{%s}\"} WHERE ResultClass=Microsoft_HMDataGroupConfiguration Role=ParentPath")
#define IDS_STRING_DG2DE_ASSOC_QUERY			_T("ASSOCIATORS OF {Microsoft_HMDataGroupConfiguration.GUID=\"{%s}\"} WHERE ResultClass=Microsoft_HMDataCollectorConfiguration")
#define IDS_STRING_DE2R_ASSOC_QUERY				_T("ASSOCIATORS OF {Microsoft_HMDataCollectorConfiguration.GUID=\"{%s}\"} WHERE ResultClass=Microsoft_HMThresholdConfiguration")
#define IDS_STRING_R2DE_ASSOC_QUERY				_T("ASSOCIATORS OF {Microsoft_HMThresholdConfiguration.GUID=\"{%s}\"} WHERE ResultClass=Microsoft_HMDataCollectorConfiguration")
#define IDS_STRING_A2EC_ASSOC_QUERY				_T("ASSOCIATORS OF {Microsoft_HMActionConfiguration.GUID=\"{%s}\"} WHERE ResultClass=__EventConsumer")
#define IDS_STRING_C2A_ASSOC_QUERY				_T("ASSOCIATORS OF {Microsoft_HMConfiguration.GUID=\"{%s}\"} WHERE ResultClass=Microsoft_HMActionConfiguration")
#define IDS_STRING_A2C_ASSOC_QUERY				_T("ASSOCIATORS OF {Microsoft_HMActionConfiguration.GUID=\"{%s}\"} WHERE ResultClass=Microsoft_HMConfiguration")

#define IDS_STRING_DG2S_REF_QUERY					_T("REFERENCES OF {Microsoft_HMDataGroupConfiguration.GUID=\"{%s}\"} WHERE Role=ChildPath")
#define IDS_STRING_DE2DG_REF_QUERY				_T("REFERENCES OF {Microsoft_HMDataCollectorConfiguration.GUID=\"{%s}\"} WHERE Role=ChildPath")
#define IDS_STRING_R2DE_REF_QUERY				_T("REFERENCES OF {Microsoft_HMThresholdConfiguration.GUID=\"{%s}\"} WHERE Role=ChildPath")

#define IDS_STRING_STATUS_EVENTQUERY            _T("select * from __InstanceModificationEvent where TargetInstance isa \"Microsoft_HMSystemStatus\" OR TargetInstance isa \"Microsoft_HMDataGroupStatus\" OR TargetInstance isa \"Microsoft_HMDataCollectorStatus\" OR TargetInstance isa \"Microsoft_HMThresholdStatus\" OR TargetInstance isa \"Microsoft_HMThresholdStatusInstance\"")
#define IDS_STRING_STATUS_QUERY                 _T("select * from Microsoft_HMStatus")
#define IDS_STRING_ACTIONSTATUS_EVENTQUERY      _T("select * from __InstanceModificationEvent where TargetInstance isa \"Microsoft_HMActionStatus\"")
#define IDS_STRING_SYSTEMSTATUS_QUERY			_T("select * from Microsoft_HMSystemStatus")
#define IDS_STRING_SYSTEMCONFIG_QUERY			_T("select * from Microsoft_HMSystemConfiguration")
#define IDS_STRING_ACTIONCONFIG_QUERY			_T("select * from Microsoft_HMActionConfiguration")
#define IDS_STRING_STATUS_QUERY_FMT				_T("select * from %s where GUID=\"{%s}\"")
#define IDS_STRING_STATISTICS_EVENTQUERY	    _T("select * from __InstanceModificationEvent where TargetInstance isa \"Microsoft_HMDataCollectorStatistics\" and TargetInstance.GUID=\"{%s}\"")
#define IDS_STRING_HMSTATUS_QUERY_FMT			_T("select * from __InstanceModificationEvent where TargetInstance isa \"Microsoft_HM%sStatus\" AND TargetInstance.GUID=\"{%s}\"")
#define IDS_STRING_HMACTIONSTATUS_QUERY_FMT     _T("select * from __InstanceCreationEvent where TargetInstance isa \"Microsoft_HMActionStatus\" AND TargetInstance.GUID=\"%s\" AND (TargetInstance.State=0 OR TargetInstance.State=2 OR TargetInstance.State=3 OR TargetInstance.State=4 OR TargetInstance.State=5 OR TargetInstance.State=6 OR TargetInstance.State=7 OR TargetInstance.State=8 OR TargetInstance.State=9)")

#define IDS_STRING_CONFIGCREATION_EVENTQUERY    _T("select * from __InstanceCreationEvent where TargetInstance isa \"Microsoft_HMConfiguration\"")
#define IDS_STRING_CONFIGDELETION_EVENTQUERY    _T("select * from __InstanceDeletionEvent where TargetInstance isa \"Microsoft_HMConfiguration\"")

#define IDS_STRING_MOF_NAME						_T("Name")
#define IDS_STRING_MOF_ADMINLOCK				_T("HMAdminLock")
#define IDS_STRING_MOF_RESOURCEFILE				_T("ResourceFile")
#define IDS_STRING_MOF_CATEGORY					_T("Category")
#define IDS_STRING_MOF_CATEGORY_RID				_T("CatRID")
#define IDS_STRING_MOF_ICATEGORY				_T("iCategory");
#define IDS_STRING_MOF_STATE					_T("State")
#define IDS_STRING_MOF_CURRENTSTATE				_T("CurrentState")
#define IDS_STRING_MOF_PERCENT_NORMAL			_T("PercentNormal")
#define IDS_STRING_MOF_PERCENT_WARNING		    _T("PercentWarning")
#define IDS_STRING_MOF_PERCENT_CRITICAL		    _T("PercentCritical")
#define IDS_STRING_SMDATAPOINT_QUERY			_T("select * from HMDataPoint where iCategory = %i")
#define IDS_STRING_CATSTATUS_QUERY				_T("select * from HMStaticCatStatus where iCategory = %i")
#define IDS_STRING_MOF_PROPNAME					_T("PropName")
#define IDS_STRING_MOF_RESOURCEID				_T("ResourceID")
#define IDS_STRING_MOF_COUNTER					_T("Counter")
#define IDS_STRING_MOF_CRITICALVALUE			_T("CriticalValue")
#define IDS_STRING_MOF_CRITICALTEST				_T("CriticalTest")
#define IDS_STRING_MOF_CRITICALDURATION		    _T("CriticalDuration")
#define IDS_STRING_MOF_REARMC				    _T("RearmC")
#define IDS_STRING_MOF_REARMCTEST				_T("RearmCTest")
#define IDS_STRING_MOF_WARNINGVALUE				_T("WarningValue")
#define IDS_STRING_MOF_WARNINGTEST				_T("WarningTest")
#define IDS_STRING_MOF_WARNINGDURATION		    _T("WarningDuration")
#define IDS_STRING_MOF_REARMW					_T("RearmW")
#define IDS_STRING_MOF_REARMWTEST				_T("RearmWTest")
#define IDS_STRING_MOF_LOCALTIME				_T("LocalTime")
#define IDS_STRING_MOF_DTIME					_T("DTime")
#define IDS_STRING_DATETIME_FORMAT				_T("%04d%02d%02d%02d%02d%02d.%06d%04d")
#define IDS_STRING_DATETIME_FORMAT2				_T("%04d%02d%02d%02d%02d%02d.%06d%s")
#define IDS_STRING_MOF_MESSAGE					_T("Message")
#define IDS_STRING_MOF_RESOURCEFORMATID		    _T("ResourceFormatID")
#define IDS_STRING_MOF_VALUE					_T("Value")
#define IDS_STRING_MOF_CONDITION				_T("TestCondition")
#define IDS_STRING_MOF_DURATION					_T("Duration")
#define IDS_STRING_MOF_INSTANCENAME				_T("InstanceName")
#define IDS_STRING_MOF_PERCENT_UNKNOWN		    _T("PercentUnknown")
#define IDS_STRING_MOF_UPTIME					_T("Uptime")
#define IDS_STRING_MOF_NAMESPACE_FORMAT		    _T("root")
#define IDS_STRING_MOF_NAMESPACE				_T("__namespace")
#define IDS_STRING_MOF_CLASSNAME				_T("__class")
#define IDS_STRING_MOF_RELPATH					_T("__relpath")

#define IDS_STRING_MOF_PARENT_ASSOC				_T("ParentPath")
#define IDS_STRING_MOF_CHILD_ASSOC				_T("ChildPath")

#define IDS_STRING_MOF_SYSTEM					_T("System")
#define IDS_STRING_MOF_DATAGROUP				_T("DataGroup")
#define IDS_STRING_MOF_DATAELEMENT				_T("DataCollector")
#define IDS_STRING_MOF_RULE						_T("Threshold")

#define IDS_STRING_MOF_OBJECTPATH				_T("\\\\.\\root\\cimv2\\MicrosoftHealthmonitor:%s.GUID=\"{%s}\"")
#define IDS_STRING_MOF_SYSTEMOBJECTPATH		    _T("\\\\.\\root\\cimv2\\MicrosoftHealthmonitor:Microsoft_HMSystemConfiguration=@")
#define IDS_STRING_MOF_SYSTEMSTATUSOBJECTPATH	_T("\\\\.\\root\\cimv2\\MicrosoftHealthmonitor:Microsoft_HMSystemStatus=@")
#define IDS_STRING_MOF_COMPLUS_NAMESPACE        _T("\\\\%s\\root\\cimv2\\MicrosoftHealthmonitor") // 63011
#define IDS_STRING_MOF_SYSTEM_CONFIG			_T("Microsoft_HMSystemConfiguration")
#define IDS_STRING_MOF_SYSTEM_STATUS			_T("Microsoft_HMSystemStatus=@")
#define IDS_STRING_MOF_HMDG_CONFIG				_T("Microsoft_HMDataGroupConfiguration")
#define IDS_STRING_MOF_HMDG_STATUS				_T("Microsoft_HMDataGroupStatus")

// v-marfin 59492
#define IDS_STRING_MOF_HMACTION_STATUS			_T("Microsoft_HMActionStatus")

#define IDS_STRING_MOF_HMDE_CONFIG				_T("Microsoft_HMDataCollectorConfiguration")
#define IDS_STRING_MOF_HMDE_STATUS				_T("Microsoft_HMDataCollectorStatus")
#define IDS_STRING_MOF_HMDE_EVENT_CONFIG	    _T("Microsoft_HMEventQueryDataCollectorConfiguration")
#define IDS_STRING_MOF_HMDE_POLLEDINSTANCE_CONFIG _T("Microsoft_HMPolledGetObjectDataCollectorConfiguration")
#define IDS_STRING_MOF_HMDE_POLLEDQUERY_CONFIG _T("Microsoft_HMPolledQueryDataCollectorConfiguration")
#define IDS_STRING_MOF_HMDE_POLLEDMETHOD_CONFIG _T("Microsoft_HMPolledMethodDataCollectorConfiguration")
#define IDS_STRING_MOF_HMR_CONFIG				_T("Microsoft_HMThresholdConfiguration")
#define IDS_STRING_MOF_HMR_STATUS				_T("Microsoft_HMThresholdStatus")
#define IDS_STRING_MOF_HMC2C_ASSOC				_T("Microsoft_HMConfigurationAssociation")
#define	IDS_STRING_MOF_HMA_CONFIG				_T("Microsoft_HMActionConfiguration")
#define IDS_STRING_MOF_HMC2A_ASSOC				_T("Microsoft_HMConfigurationActionAssociation")
#define IDS_STRING_MOF_ACS_APPSTATS             _T("MicrosoftComPlus_AppStats")
#define IDS_STRING_MOF_ACS_APPSTATS_FMT         _T("MicrosoftComPlus_AppStats.AppName=\"%s\",MaxIdleTime=%d")

// data element type guids
#define IDS_STRING_MOF_HMDET_FILE_INFO		    _T("C90CD4C7-2297-11d3-BE00-0000F87A3912")
#define IDS_STRING_MOF_HMDET_WMI_INSTANCE	    _T("C90CD4CA-2297-11d3-BE00-0000F87A3912")
#define IDS_STRING_MOF_HMDET_WMI_QUERY		    _T("C90CD4CB-2297-11d3-BE00-0000F87A3912")
#define IDS_STRING_MOF_HMDET_WMI_POLLED_QUERY   _T("EF1D6A51-2759-11d3-9390-00A0CC406605")
#define IDS_STRING_MOF_HMDET_WMI_METHOD		    _T("AD3511B7-280C-11d3-BE08-0000F87A3912")
#define IDS_STRING_MOF_HMDET_SNMP				_T("C90CD4CC-2297-11d3-BE00-0000F87A3912")
#define IDS_STRING_MOF_HMDET_HTTP				_T("C90CD4CD-2297-11d3-BE00-0000F87A3912")
#define IDS_STRING_MOF_HMDET_INET				_T("C90CD4CE-2297-11d3-BE00-0000F87A3912")
#define IDS_STRING_MOF_HMDET_SERVICE			_T("C90CD4CF-2297-11d3-BE00-0000F87A3912")
#define IDS_STRING_MOF_HMDET_PERFMON			_T("03B9B361-2299-11d3-BE00-0000F87A3912")
#define IDS_STRING_MOF_HMDET_NTEVENT			_T("A89E51F1-229F-11d3-BE00-0000F87A3912")
#define IDS_STRING_MOF_HMDET_SMTP				_T("8D61BF2A-4138-11d3-BE26-0000F87A3912")
#define IDS_STRING_MOF_HMDET_FTP				_T("A39342EF-4138-11d3-BE26-0000F87A3912")
#define IDS_STRING_MOF_HMDET_ICMP				_T("D442E727-971E-11d3-BE93-0000F87A3912")
#define IDS_STRING_MOF_HMDET_COM_PLUS			_T("E2F3E715-AEE4-454e-AB05-D062DBBFAA0F")

//action type guids
#define IDS_STRING_MOF_HMAT_CMDLINE				_T("062E2ADF-6DFD-11d3-BE5A-0000F87A3912")
#define IDS_STRING_MOF_HMAT_EMAIL				_T("062E2AE0-6DFD-11d3-BE5A-0000F87A3912")
#define IDS_STRING_MOF_HMAT_TEXTLOG				_T("062E2AE1-6DFD-11d3-BE5A-0000F87A3912")
#define IDS_STRING_MOF_HMAT_NTEVENT				_T("062E2AE2-6DFD-11d3-BE5A-0000F87A3912")
#define IDS_STRING_MOF_HMAT_SCRIPT				_T("062E2AE3-6DFD-11d3-BE5A-0000F87A3912")
#define IDS_STRING_MOF_HMAT_PAGING				_T("062E2AE4-6DFD-11d3-BE5A-0000F87A3912")

// length of characters in a GUID string including NULL terminator
#define	GUID_CCH		39

#endif //__CONSTANTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dataelement.inl ===
// File DataElement.inl
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03/25/00 v-marfin : Added new function GetObjectPathBasedOnTypeGUID()
// 03/27/00 v-marfin : 62510 Modified CreateNewChildRule() so that when a new data collector
//					   is created, this function can be called to create a new
//					   threshold without showing the property pages. The new collector
//					   will set the default values.

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// WMI Operations
/////////////////////////////////////////////////////////////////////////////

inline HRESULT CDataElement::EnumerateChildren()
{
	TRACEX(_T("CDataElement::EnumerateChildren\n"));

	if( m_pRuleListener == NULL )
	{
		m_pRuleListener = new CRuleConfigListener;
		m_pRuleListener->SetObjectPtr(this);
		m_pRuleListener->Create();
	}
	else
	{
		IncrementActiveSinkCount();
	}

	HRESULT hr = S_OK;
	CString sQuery;
	sQuery.Format(IDS_STRING_DE2R_ASSOC_QUERY,GetGuid());
	IWbemObjectSink* pSink = m_pRuleListener->GetSink();
	
  if( !CHECKHRESULT(hr = CnxExecQueryAsync(GetSystemName(),sQuery,pSink)) )
  {
    TRACE(_T("FAILED : CConnectionManager::RegisterEventNotification failed!\n"));
  }

	return hr;
}

//*********************************************************
// GetObjectPathBasedOnTypeGUID  v-marfin : new function
//*********************************************************
inline CString CDataElement::GetObjectPathBasedOnTypeGUID()
{
	TRACEX(_T("CDataElement::GetObjectPath\n"));

	CString sPath;
	sPath.Format(IDS_STRING_MOF_OBJECTPATH,IDS_STRING_MOF_HMDE_CONFIG,GetTypeGuid());

	return sPath;
}



inline CString CDataElement::GetObjectPath()
{
	TRACEX(_T("CDataElement::GetObjectPath\n"));

	CString sPath;
	sPath.Format(IDS_STRING_MOF_OBJECTPATH,IDS_STRING_MOF_HMDE_CONFIG,GetGuid());

	return sPath;
}

inline CString CDataElement::GetStatusObjectPath()
{
	TRACEX(_T("CDataElement::GetStatusObjectPath\n"));

	CString sPath;
	sPath.Format(IDS_STRING_MOF_OBJECTPATH,IDS_STRING_MOF_HMDE_STATUS,GetGuid());

	return sPath;
}

inline CHMEvent* CDataElement::GetStatusClassObject()
{
	TRACEX(_T("CDataElement::GetStatusClassObject\n"));

	CHMEvent* pClassObject = new CHMDataElementStatus;

	pClassObject->SetMachineName(GetSystemName());

	if( ! CHECKHRESULT(pClassObject->GetObject(GetStatusObjectPath())) )
	{
		delete pClassObject;
		return NULL;
	}

	pClassObject->GetAllProperties();

	return pClassObject;
}
/*
inline void CDataElement::DeleteClassObject()
{
	TRACEX(_T("CDataElement::DeleteClassObject\n"));

	// get associator path
	CWbemClassObject Associator;

	Associator.SetMachineName(GetSystemName());

	CString sQuery;
	sQuery.Format(IDS_STRING_DE2DG_REF_QUERY,GetGuid());
	BSTR bsQuery = sQuery.AllocSysString();
	if( ! CHECKHRESULT(Associator.ExecQuery(bsQuery)) )
	{
		::SysFreeString(bsQuery);
		return;
	}
	::SysFreeString(bsQuery);

	ULONG ulReturned = 0L;
	if( Associator.GetNextObject(ulReturned) != S_OK )
	{
		ASSERT(FALSE);
		return;
	}

	CString sAssociatorPath;
	Associator.GetProperty(_T("__path"),sAssociatorPath);

	Associator.Destroy();

	// delete the instance
	Associator.SetMachineName(GetSystemName());
	
	BSTR bsInstanceName = sAssociatorPath.AllocSysString();
	CHECKHRESULT(Associator.DeleteInstance(bsInstanceName));
	::SysFreeString(bsInstanceName);
	
}
*/

/////////////////////////////////////////////////////////////////////////////
// Clipboard Operations
/////////////////////////////////////////////////////////////////////////////

inline bool CDataElement::Cut()
{
	TRACEX(_T("CDataElement::Cut\n"));
	return false;
}

inline bool CDataElement::Copy()
{
	TRACEX(_T("CDataElement::Copy\n"));
	return false;
}
	
inline bool CDataElement::Paste()
{
	TRACEX(_T("CDataElement::Paste\n"));
	return false;
}

/////////////////////////////////////////////////////////////////////////////
// Scope Item Members
/////////////////////////////////////////////////////////////////////////////

inline CScopePaneItem* CDataElement::CreateScopeItem()
{
	TRACEX(_T("CDataElement::CreateScopeItem\n"));

	CDataElementScopeItem * pNewItem = new CDataElementScopeItem;
	pNewItem->SetObjectPtr(this);

	return pNewItem;
}

/////////////////////////////////////////////////////////////////////////////
// New Child Creation Members
/////////////////////////////////////////////////////////////////////////////

inline void CDataElement::CreateNewChildRule(BOOL bJustCreateAndReturn, CRule** pCreatedRule, CString sThresholdName)
{
	TRACEX(_T("CDataElement::CreateNewChildRule\n"));

	CString sName = GetUniqueChildName(IDS_STRING_RULE_FMT);

	CRule* pNewRule = new CRule;

    // If a threshold name is passed, use it
    pNewRule->SetName((sThresholdName.IsEmpty()) ? sName : sThresholdName);

	CreateChild(pNewRule,IDS_STRING_MOF_HMR_CONFIG,IDS_STRING_MOF_HMC2C_ASSOC);

	// v-marfin : 62510 Added this check so that when a new data collector
	//            is created, this function can be called to create a new
	//            threshold without showing the property pages. The new collector
	//            will set the default values.
	if (bJustCreateAndReturn)
	{
		*pCreatedRule = pNewRule;
		return;
	}

	if( pNewRule->GetScopeItemCount() )
	{
		CScopePaneItem* pItem = pNewRule->GetScopeItem(0);
		if( pItem )
		{
			pItem->SelectItem();
			pItem->InvokePropertySheet();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// Type GUID
/////////////////////////////////////////////////////////////////////////////

inline CString CDataElement::GetTypeGuid()
{
	TRACEX(_T("CDataElement::GetTypeGuid\n"));	

	return m_sTypeGuid;
}

inline void CDataElement::SetTypeGuid(const CString& sGuid)
{
	TRACEX(_T("CDataElement::SetTypeGuid\n"));
	TRACEARGs(sGuid);

	m_sTypeGuid = sGuid;

	if( m_sTypeGuid == IDS_STRING_MOF_HMDET_FILE_INFO )
	{
		SetType(IDM_FILE_INFO);
	}
	else if( m_sTypeGuid == IDS_STRING_MOF_HMDET_WMI_INSTANCE )
	{
		SetType(IDM_GENERIC_WMI_INSTANCE);
	}
	else if( m_sTypeGuid == IDS_STRING_MOF_HMDET_WMI_QUERY )
	{
		SetType(IDM_GENERIC_WMI_QUERY);
	}
	else if( m_sTypeGuid == IDS_STRING_MOF_HMDET_WMI_POLLED_QUERY )
	{
		SetType(IDM_GENERIC_WMI_POLLED_QUERY);
	}
	else if( m_sTypeGuid == IDS_STRING_MOF_HMDET_SNMP )
	{
		SetType(IDM_SNMP);
	}
	else if( m_sTypeGuid == IDS_STRING_MOF_HMDET_HTTP )
	{
		SetType(IDM_HTTP_ADDRESS);
	}
	else if( m_sTypeGuid == IDS_STRING_MOF_HMDET_SERVICE )
	{
		SetType(IDM_SERVICE);
	}
	else if( m_sTypeGuid == IDS_STRING_MOF_HMDET_PERFMON )
	{
		SetType(IDM_PERFMON);
	}
	else if( m_sTypeGuid == IDS_STRING_MOF_HMDET_NTEVENT )
	{
		SetType(IDM_NT_EVENTS);
	}
	else if( m_sTypeGuid == IDS_STRING_MOF_HMDET_SMTP )
	{
		SetType(IDM_SMTP);
	}
	else if( m_sTypeGuid == IDS_STRING_MOF_HMDET_FTP )
	{
		SetType(IDM_FTP);
	}
	else if( m_sTypeGuid == IDS_STRING_MOF_HMDET_ICMP )
	{
		SetType(IDM_ICMP);
	}
  else if(m_sTypeGuid == IDS_STRING_MOF_HMDET_COM_PLUS )
  {
    SetType(IDM_COM_PLUS);
  }

}

inline int CDataElement::GetType()
{
	TRACEX(_T("CDataElement::GetType\n"));

	return m_iType;
}

inline void CDataElement::SetType(int iType)
{
	TRACEX(_T("CDataElement::SetType\n"));
	TRACEARGn(iType);

	m_iType = iType;
}

inline CString CDataElement::GetUITypeName()
{
	TRACEX(_T("CDataElement::GetUITypeName\n"));

	CString sTypeName;

	switch( GetType() )
	{
		case IDM_GENERIC_WMI_INSTANCE:
		{
			sTypeName.LoadString(IDS_STRING_WMI_INSTANCE_FMT);
		}
		break;

		case IDM_GENERIC_WMI_QUERY:
		{
			sTypeName.LoadString(IDS_STRING_WMI_EVENT_QUERY_FMT);	
		}
		break;

		case IDM_GENERIC_WMI_POLLED_QUERY:
		{
			sTypeName.LoadString(IDS_STRING_WMI_QUERY_FMT);	
		}
		break;

		case IDM_NT_EVENTS:
		{
			sTypeName.LoadString(IDS_STRING_EVENT_LOG_FMT);	
		}
		break;

		case IDM_PERFMON:
		{
			sTypeName.LoadString(IDS_STRING_PERFMON_FMT);	
		}
		break;

		case IDM_SERVICE:
		{
			sTypeName.LoadString(IDS_STRING_SERVICE_FMT);	
		}
		break;

		case IDM_HTTP_ADDRESS:
		{
			sTypeName.LoadString(IDS_STRING_HTTP_FMT);	
		}
		break;

		case IDM_SMTP:
		{
			sTypeName.LoadString(IDS_STRING_SMTP_FMT);	
		}
		break;

		case IDM_FTP:
		{
			sTypeName.LoadString(IDS_STRING_FTP_FMT);	
		}
		break;

		case IDM_FILE_INFO:
		{
			sTypeName.LoadString(IDS_STRING_FILE_INFO_FMT);	
		}
		break;

		case IDM_ICMP:
		{
			sTypeName.LoadString(IDS_STRING_ICMP_FMT);	
		}
		break;

		default:
		{
			sTypeName.LoadString(IDS_STRING_WMI_INSTANCE_FMT);	
		}
		break;
	}

	sTypeName = sTypeName.Left(sTypeName.GetLength()-3);

	return sTypeName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dataelementconfiglistener.cpp ===
// DataElementConfigListener.cpp: implementation of the CDataElementConfigListener class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "DataElementConfigListener.h"
#include "HMDataElementConfiguration.h"
#include "DataElement.h"
#include "System.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CDataElementConfigListener,CWbemEventListener)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataElementConfigListener::CDataElementConfigListener()
{
}

CDataElementConfigListener::~CDataElementConfigListener()
{
	Destroy();
}

/////////////////////////////////////////////////////////////////////////////
// Create/Destroy
/////////////////////////////////////////////////////////////////////////////

bool CDataElementConfigListener::Create()
{
	TRACEX(_T("CDataElementConfigListener::Create\n"));

	// first create the unsecured apartment
	HRESULT hr = S_OK;
  IWbemObjectSink* pSink = (IWbemObjectSink*)GetInterface(&IID_IWbemObjectSink);
  ASSERT(pSink);
	CString sSystemName = m_pHMObject->GetSystemName();

	if( s_pIUnsecApartment == NULL )
	{
		hr = CreateUnSecuredApartment();
		if( !GfxCheckPtr(s_pIUnsecApartment,IUnsecuredApartment) || !CHECKHRESULT(hr) )
		{
			TRACE(_T("FAILED : CDataElementConfigListener::CreateUnSecuredApartment failed.\n"));
            ASSERT(FALSE); // v-marfin 59492
			return false;
		}
	}

	ASSERT(s_pIUnsecApartment);

	// second, create the stub sink for this listener's IWbemObjectSink
	IUnknown* pStubUnk = NULL;

	ASSERT(s_pIUnsecApartment);

	hr = s_pIUnsecApartment->CreateObjectStub(pSink, &pStubUnk);

	if( pStubUnk == NULL || !CHECKHRESULT(hr) )
	{
    TRACE(_T("FAILED : Failed to create Stub Sink!\n"));
    ASSERT(FALSE); // v-marfin 59492
		return false;
	}

	ASSERT(pStubUnk);

	hr = pStubUnk->QueryInterface(IID_IWbemObjectSink, (LPVOID*)&m_pStubSink);
	pStubUnk->Release();

	if( !GfxCheckPtr(m_pStubSink,IWbemObjectSink) || !CHECKHRESULT(hr) )
	{
    TRACE(_T("FAILED : Failed to QI for IWbemObjectSink !\n"));	
    ASSERT(FALSE); // v-marfin 59492
    return false;
  }

  ASSERT(m_pStubSink);

	CHMObject* pObject = GetObjectPtr();
	pObject->IncrementActiveSinkCount();
	
	return true;
}

void CDataElementConfigListener::Destroy()
{
	TRACEX(_T("CDataElementConfigListener::Destroy\n"));

    if( m_pStubSink )			
    {
		m_pStubSink->Release();
        m_pStubSink = NULL;
    }

	if( s_lObjCount == 0 && s_pIUnsecApartment )
    {
		s_pIUnsecApartment->Release();
        s_pIUnsecApartment = NULL;
    }

}

//////////////////////////////////////////////////////////////////////
// Event Processing Members
//////////////////////////////////////////////////////////////////////

HRESULT CDataElementConfigListener::ProcessEventClassObject(IWbemClassObject* pClassObject)
{
  ASSERT(pClassObject);
  if( pClassObject == NULL )
  {
    return E_FAIL;
  }
  
  HRESULT hr = S_OK;

	CHMDataElementConfiguration dec;

	if( ! CHECKHRESULT(hr = dec.Create(pClassObject)) )
	{
		return hr;
	}

	dec.GetAllProperties();

	// create a new CDataElement and add as a child
	if( ! GetObjectPtr()->GetChildByGuid(dec.m_sGUID) )
	{
		CDataElement* pNewDE = new CDataElement;
		pNewDE->SetName(dec.m_sName);
		pNewDE->SetGuid(dec.m_sGUID);
		pNewDE->SetTypeGuid(dec.m_sTypeGUID);
		pNewDE->SetComment(dec.m_sDescription);
		pNewDE->SetSystemName(GetObjectPtr()->GetSystemName());
		GetObjectPtr()->AddChild(pNewDE);
    pNewDE->EnumerateChildren();
	}

  return hr;
}

inline HRESULT CDataElementConfigListener::OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam)
{
	TRACEX(_T("CDataElementConfigListener::OnSetStatus\n"));
	TRACEARGn(lFlags);
	TRACEARGn(hResult);
	TRACEARGs(strParam);
	TRACEARGn(pObjParam);

	if( lFlags == 0L && hResult == S_OK )
	{
		CHMObject* pObject = GetObjectPtr();
		pObject->DecrementActiveSinkCount();
	}

  return WBEM_NO_ERROR;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dataelementevent.cpp ===
// DataElementEvent.cpp: implementation of the CDataElementEvent class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "DataElementEvent.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CDataElementEvent,CEvent)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataElementEvent::CDataElementEvent()
{

}

CDataElementEvent::~CDataElementEvent()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dataelementconfiglistener.h ===
// DataElementConfigListener.h: interface for the CDataElementConfigListener class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATAELEMENTCONFIGLISTENER_H__6BD5F130_FE50_11D2_BDD4_0000F87A3912__INCLUDED_)
#define AFX_DATAELEMENTCONFIGLISTENER_H__6BD5F130_FE50_11D2_BDD4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemEventListener.h"

class CDataElementConfigListener : public CWbemEventListener  
{
DECLARE_DYNCREATE(CDataElementConfigListener)

// Construction/Destruction
public:
	CDataElementConfigListener();
	virtual ~CDataElementConfigListener();

// Create/Destroy
public:
	virtual bool Create();
	virtual void Destroy();

// Processing Operations
protected:
  virtual HRESULT ProcessEventClassObject(IWbemClassObject* pClassObject);
	virtual HRESULT OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam);

};

#endif // !defined(AFX_DATAELEMENTCONFIGLISTENER_H__6BD5F130_FE50_11D2_BDD4_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dataelement.h ===
#if !defined(AFX_DATAELEMENT_H__D9BF4FA7_F673_11D2_BDC4_0000F87A3912__INCLUDED_)
#define AFX_DATAELEMENT_H__D9BF4FA7_F673_11D2_BDC4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DataElement.h : header file
//

#include "HMObject.h"
#include "HMRuleConfiguration.h"
#include "Rule.h"
#include "DataElementScopeItem.h"
#include "RuleConfigListener.h"
#include "HMDataElementStatus.h"
#include "DataElementStatusListener.h"
#include "DataElementStatsListener.h"
#include "HMDataElementStatistics.h"

/////////////////////////////////////////////////////////////////////////////
// CDataElement command target

class CDataElement : public CHMObject
{

DECLARE_SERIAL(CDataElement)

// Construction/Destruction
public:

    // v-marfin 62585 Indicates if this is a brand new collector
	//CDataElement();
	CDataElement(BOOL bSetStateToEnabledOnOK=FALSE);
	virtual ~CDataElement();

// WMI Operations
public:
	HRESULT EnumerateChildren();
	CString GetObjectPath();
	CString GetObjectPathBasedOnTypeGUID();
	CString GetStatusObjectPath();
	CHMEvent* GetStatusClassObject();
//	void DeleteClassObject();
protected:
	CRuleConfigListener* m_pRuleListener;

    BOOL m_bSetStateToEnabledOnOK;        // v-marfin 62585 Indicates if this is a brand new collector
// Clipboard Operations
public:
	virtual bool Cut();
	virtual bool Copy();
	virtual bool Paste();

    // v-marfin 62585 Indicates if this is a brand new collector
    void SetStateToEnabledOnOK(BOOL bSetStateToEnabledOnOK);
    BOOL IsStateSetToEnabledOnOK() {return m_bSetStateToEnabledOnOK;}

// Scope Item Members
public:
	virtual CScopePaneItem* CreateScopeItem();

// New Child Creation Members
public:
	// v-marfin 62510 : Added default value. Now also returns the created 
	//                  rule. 
	void CreateNewChildRule(BOOL bJustCreateAndReturn=FALSE, CRule** pCreatedRule=NULL, CString sThresholdName="");

// DataElement Type Info
public:
	CString GetTypeGuid();
	void SetTypeGuid(const CString& sGuid);
	int GetType();
	void SetType(int iType);
	CString GetUITypeName();
protected:
	CString m_sTypeGuid;
	int m_iType;

// State Members
public:
	void UpdateStatus();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDataElement)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// MFC Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDataElement)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE_EX(CDataElement)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CDataElement)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()

};

/////////////////////////////////////////////////////////////////////////////

#include "DataElement.inl"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DATAELEMENT_H__D9BF4FA7_F673_11D2_BDC4_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dataelementevent.h ===
// DataElementEvent.h: interface for the CDataElementEvent class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATAELEMENTEVENT_H__5F72D13E_8D58_11D3_BE84_0000F87A3912__INCLUDED_)
#define AFX_DATAELEMENTEVENT_H__5F72D13E_8D58_11D3_BE84_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Event.h"

class CDataElementEvent : public CEvent  
{

DECLARE_DYNCREATE(CDataElementEvent)

// Construction/Destruction
public:
	CDataElementEvent();
	virtual ~CDataElementEvent();

// Message
public:
	CString m_sMessage;

// Result Pane Item Members
public:
	virtual CHMEventResultsPaneItem* CreateResultsPaneItem(CResultsPaneView* pView);

};

#include "DataElementEvent.inl"

#endif // !defined(AFX_DATAELEMENTEVENT_H__5F72D13E_8D58_11D3_BE84_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dataelementevent.inl ===
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Result Pane Item Members
//////////////////////////////////////////////////////////////////////

inline CHMEventResultsPaneItem* CDataElementEvent::CreateResultsPaneItem(CResultsPaneView* pView)
{
	if( ! pView )
	{
		ASSERT(FALSE);
		return NULL;
	}

	CHMEventResultsPaneItem* pItem = new CHMEventResultsPaneItem;
	pItem->SetDateTimeColumn(HMLV_LOWER_DTIME_INDEX);
	
	CStringArray saNames;
	CUIntArray uiaIconResIds;

	CString sState;
	CEvent::GetStatus(m_iState,sState);

	saNames.Add(sState);
  sState.LoadString(IDS_STRING_NONE);
  saNames.Add(sState);
	saNames.Add(GetEventLocalTime());
	saNames.Add(m_sName);
	saNames.Add(m_sSystemName);
	saNames.Add(m_sMessage);
	switch( CEvent::GetStatus(m_iState) )
	{
		case HMS_CRITICAL:
		{
			uiaIconResIds.Add(IDI_ICON_CRITICAL);
		}
		break;
		
		case HMS_WARNING:
		{
			uiaIconResIds.Add(IDI_ICON_WARNING);
		}
		break;
		
		case HMS_NODATA:
		{
			uiaIconResIds.Add(IDI_ICON_NO_CONNECT);
		}
		break;

		case HMS_UNKNOWN:
		{
			uiaIconResIds.Add(IDI_ICON_UNKNOWN);
		}
		break;

		case HMS_SCHEDULEDOUT:
		{
			uiaIconResIds.Add(IDI_ICON_OUTAGE);
		}
		break;

		case HMS_DISABLED:
		{
			uiaIconResIds.Add(IDI_ICON_DISABLED);
		}
		break;

		case HMS_NORMAL:
		{
			uiaIconResIds.Add(IDI_ICON_NORMAL);
		}
		break;

		default:
		{
			ASSERT(FALSE);
			uiaIconResIds.Add(IDI_ICON_NORMAL);
		}
	}

	pItem->m_st = m_st;
	pItem->m_sGuid = m_sStatusGuid;
	pItem->m_iState = CEvent::GetStatus(m_iState);			

	pItem->SetDisplayNames(saNames);
	pItem->SetIconIds(uiaIconResIds);
	pItem->SetIconIndex(0);
	pItem->SetToLowerPane();

	pItem->Create(pView);

	return pItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dataelementresultsview.cpp ===
// DataElementResultsView.cpp: implementation of the CDataElementResultsView class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "DataElementResultsView.h"
#include "HMListViewColumn.h"
#include "EventManager.h"
#include "HealthmonResultsPane.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CDataElementResultsView, CSplitPaneResultsView)


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataElementResultsView::CDataElementResultsView()
{

}

CDataElementResultsView::~CDataElementResultsView()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create/Destroy
//////////////////////////////////////////////////////////////////////

bool CDataElementResultsView::Create(CScopePaneItem* pOwnerItem)
{
	TRACEX(_T("CDataElementResultsView::Create\n"));
	TRACEARGn(pOwnerItem);

	if( ! CSplitPaneResultsView::Create(pOwnerItem) )
	{
		TRACE(_T("FAILED : CSplitPaneResultsView::Create failed.\n"));
		return false;
	}

	// add the upper columns
	CHMListViewColumn* pColumn = NULL;
	CString sTitle;
	DWORD dwFormat = LVCFMT_LEFT;

	// name
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NAME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// Status
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_STATUS);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// GUID
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_GUID);
	pColumn->Create(this,sTitle,0,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// Threshold
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_RULE);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// last message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_LAST_MESSAGE);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// comment
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_COMMENT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// add the lower columns

	// Severity
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SEVERITY);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// ID
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_ID);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Date/Time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Component
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATA_POINT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// System
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SYSTEM);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_MESSAGE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// add the stats columns

	// property
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_PROPERTY);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// instance
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_INSTANCE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// current
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_CURRENT);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// min
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_MINIMUM);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// max
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_MAXIMUM);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// avg
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_AVERAGE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// Last Update
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_LASTUPDATE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	return true;
}

//////////////////////////////////////////////////////////////////////
// Eventing and Statistics Members
//////////////////////////////////////////////////////////////////////

void CDataElementResultsView::AddStatistic(CEventContainer* pContainer, CStatistics* pStatistic, bool bUpdateGraph /*=true*/)
{
	TRACEX(_T("CDataElementResultsView::AddStatistic\n"));
	TRACEARGn(pContainer);
	TRACEARGn(pStatistic);	

	CDataPointStatistics* pDPStat = (CDataPointStatistics*)pStatistic;

  if( bUpdateGraph )
  {
	  CHMScopeItem* pHMItem = (CHMScopeItem*)GetOwnerScopeItem();

	  if( ! GfxCheckObjPtr(pHMItem,CHMScopeItem) )
	  {
		  TRACE(_T("FAILED : pHMItem is not a valid pointer.\n"));
		  return;
	  }

	  CHMObject* pObject = pHMItem->GetObjectPtr();
	  if( !pObject || ! GfxCheckObjPtr(pObject,CHMObject) )
	  {
		  return;
	  }

	  for( int j = 0; j < GetResultsPanesCount(); j++ )
	  {
		  CHealthmonResultsPane* pPane = (CHealthmonResultsPane*)GetResultsPane(j);
		  if( pPane )
		  {
			  _DHMGraphView* pGraphView  = pPane->GetGraphViewCtrl();

	      if( pGraphView )
	      {
		      pPane->GetGraphViewSink()->SetResultsViewPtr(this);

		      long lCurrentStyle = pGraphView->GetStyle();

		      pGraphView->Clear();

		      if( lCurrentStyle & HMGVS_CURRENT )
		      {
			      pGraphView->SetStyle(HMGVS_CURRENT|HMGVS_ELEMENT);
		      }

		      if( lCurrentStyle & HMGVS_HISTORIC )
		      {
			      pGraphView->SetStyle(HMGVS_HISTORIC|HMGVS_ELEMENT);
		      }

		      pGraphView->SetName(pObject->GetName());
	      }

	      CEventContainer* pContainer = NULL;
	      EvtGetEventManager()->GetEventContainer(pObject->GetSystemName(),pObject->GetGuid(),pContainer);
	      if( pContainer )
	      {
          CTypedPtrMap<CMapStringToPtr,CString,StatsArray*> StatMap;
		      for(int i = pContainer->GetStatisticsCount()-1; i >= 0; i-- )
		      {
			      CDataPointStatistics* pDPStat = (CDataPointStatistics*)pContainer->GetStatistic(i);
            CString sKey = pDPStat->m_sPropertyName+pDPStat->m_sInstanceName;
            StatsArray* pStats;
            if( ! StatMap.Lookup(sKey,pStats) )
            {
              pStats = new StatsArray;
              StatMap.SetAt(sKey,pStats);
              pStats->Add(pDPStat);
            }
            else
            {
              if( pStats->GetSize() < 6 )
              {
                pStats->Add(pDPStat);
              }
            }
		      }

          POSITION pos = StatMap.GetStartPosition();
          while( pos != NULL )
          {
            CString sKey;
            StatsArray* pStats = NULL;
            StatMap.GetNextAssoc(pos,sKey,pStats);
            for( i = (int)pStats->GetSize()-1; i >= 0; i--  )
            {
              pStats->GetAt(i)->UpdateGraph(pGraphView);
            }

            delete pStats;
          }
	      }
		  }
	  }
  }

	// if this statistic exists in the results pane already, just update the displaynames, then update the graph
	for( int i = 0; i < m_ResultItems.GetSize(); i++ )
	{
		CHMEventResultsPaneItem* pItem = (CHMEventResultsPaneItem*)m_ResultItems[i];
		if( pItem && pItem->IsStatsPane() )
		{			
			if( pItem->GetDisplayName(0) == pDPStat->m_sPropertyName &&
					pItem->GetDisplayName(1) == pDPStat->m_sInstanceName )
			{
				pDPStat->SetResultsPaneItem(pItem);
				UpdateItem(pItem);
				return;
			}
		}
	}

	AddItem(pStatistic->CreateResultsPaneItem(this));
}

inline HRESULT CDataElementResultsView::AddStatistics(CHealthmonResultsPane* pPane)
{
	TRACEX(_T("CDataElementResultsView::AddStatistics\n"));

	CScopePaneItem* pSPI = GetOwnerScopeItem();

	if( ! pSPI->IsKindOf(RUNTIME_CLASS(CHMScopeItem)) )
	{
		return S_FALSE;
	}

	CHMScopeItem* pHMItem = (CHMScopeItem*)pSPI;

	if( ! GfxCheckObjPtr(pPane,CHealthmonResultsPane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		return E_FAIL;
	}

	CString sText;
	sText.Format(IDS_STRING_STATISTICS_FOR,pSPI->GetDisplayName());
	pPane->GetStatsListCtrl()->SetTitle(sText);

	CHMObject* pObject = pHMItem->GetObjectPtr();
	if( !pObject || ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		return E_FAIL;
	}

	_DHMGraphView* pGraphView = pPane->GetGraphViewCtrl();
	if( pGraphView )
	{
		pPane->GetGraphViewSink()->SetResultsViewPtr(this);

		long lCurrentStyle = pGraphView->GetStyle();

		pGraphView->Clear();

		if( lCurrentStyle & HMGVS_CURRENT )
		{
			pGraphView->SetStyle(HMGVS_CURRENT|HMGVS_ELEMENT);
		}

		if( lCurrentStyle & HMGVS_HISTORIC )
		{
			pGraphView->SetStyle(HMGVS_HISTORIC|HMGVS_ELEMENT);
		}

		pGraphView->SetName(pObject->GetName());
	}

	CEventContainer* pContainer = NULL;
	EvtGetEventManager()->GetEventContainer(pObject->GetSystemName(),pObject->GetGuid(),pContainer);
	if( pContainer )
	{
    CTypedPtrMap<CMapStringToPtr,CString,StatsArray*> StatMap;
		for(int i = pContainer->GetStatisticsCount()-1; i >= 0; i-- )
		{
			CDataPointStatistics* pDPStat = (CDataPointStatistics*)pContainer->GetStatistic(i);
      CString sKey = pDPStat->m_sPropertyName+pDPStat->m_sInstanceName;
      StatsArray* pStats;
      if( ! StatMap.Lookup(sKey,pStats) )
      {
        pStats = new StatsArray;
        StatMap.SetAt(sKey,pStats);
        pStats->Add(pDPStat);
      }
      else
      {
        if( pStats->GetSize() < 6 )
        {
          pStats->Add(pDPStat);
        }
      }
		}

    POSITION pos = StatMap.GetStartPosition();
    while( pos != NULL )
    {
      CString sKey;
      StatsArray* pStats = NULL;
      StatMap.GetNextAssoc(pos,sKey,pStats);
      for( i = (int)pStats->GetSize()-1; i >= 0; i--  )
      {
        AddStatistic(pContainer,pStats->GetAt(i),i==pStats->GetSize()-1);
      }

      delete pStats;
    }
	}

	sText.Format(IDS_STRING_COUNT_OF_FORMAT,pContainer->GetStatisticsCount());
	pPane->GetStatsListCtrl()->SetDescription(sText);

	EvtGetEventManager()->ActivateStatisticsEvents(pObject->GetSystemName(),pObject->GetGuid());

	return S_OK;
}

inline HRESULT CDataElementResultsView::RemoveStatistics(CHealthmonResultsPane* pPane)
{
	TRACEX(_T("CDataElementResultsView::RemoveStatistics\n"));

	CScopePaneItem* pSPI = GetOwnerScopeItem();

	if( ! pSPI->IsKindOf(RUNTIME_CLASS(CHMScopeItem)) )
	{
		return S_FALSE;
	}

	CHMScopeItem* pHMItem = (CHMScopeItem*)pSPI;

	if( ! GfxCheckObjPtr(pPane,CHealthmonResultsPane) )
	{
		TRACE(_T("FAILED : pPane is not a valid pointer.\n"));
		return E_FAIL;
	}

	CHMObject* pObject = pHMItem->GetObjectPtr();
	if( !pObject || ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		return E_FAIL;
	}

	EvtGetEventManager()->DeactivateStatisticsEvents(pObject->GetSystemName(), pObject->GetGuid());

	pPane->GetGraphViewSink()->SetResultsViewPtr(NULL);

	if(pPane->GetGraphViewCtrl())
	{
		pPane->GetGraphViewCtrl()->Clear();
	}

	CString sWaiting;
	sWaiting.LoadString(IDS_STRING_WAITING);
	pPane->GetStatsListCtrl()->SetTitle(sWaiting);

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// GraphView Events Members
//////////////////////////////////////////////////////////////////////

void CDataElementResultsView::OnGraphViewStyleChange(_DHMGraphView* pGraphView)
{
	if( ! pGraphView )
	{
		ASSERT(FALSE);
		return;
	}

	CScopePaneItem* pSPI = GetOwnerScopeItem();

	if( ! pSPI->IsKindOf(RUNTIME_CLASS(CHMScopeItem)) )
	{
		return;
	}

	CHMScopeItem* pHMItem = (CHMScopeItem*)pSPI;

	CHMObject* pObject = pHMItem->GetObjectPtr();
	if( !pObject || ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		return;
	}

	pGraphView->SetName(pObject->GetName());

	CEventContainer* pContainer = NULL;
	EvtGetEventManager()->GetEventContainer(pObject->GetSystemName(),pObject->GetGuid(),pContainer);
	if( pContainer )
	{
    CTypedPtrMap<CMapStringToPtr,CString,StatsArray*> StatMap;
		for(int i = pContainer->GetStatisticsCount()-1; i >= 0; i-- )
		{
			CDataPointStatistics* pDPStat = (CDataPointStatistics*)pContainer->GetStatistic(i);
      CString sKey = pDPStat->m_sPropertyName+pDPStat->m_sInstanceName;
      StatsArray* pStats;
      if( ! StatMap.Lookup(sKey,pStats) )
      {
        pStats = new StatsArray;
        StatMap.SetAt(sKey,pStats);
        pStats->Add(pDPStat);
      }
      else
      {
        if( pStats->GetSize() < 6 )
        {
          pStats->Add(pDPStat);
        }
      }
		}

    POSITION pos = StatMap.GetStartPosition();
    while( pos != NULL )
    {
      CString sKey;
      StatsArray* pStats = NULL;
      StatMap.GetNextAssoc(pos,sKey,pStats);
      for( i = (int)pStats->GetSize()-1; i >= 0; i--  )
      {
        AddStatistic(pContainer,pStats->GetAt(i));
      }

      delete pStats;
    }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dataelementscopeitem.h ===
// DataElementScopeItem.h: interface for the CDataElementScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATAELEMENTSCOPEITEM_H__5CFA29C2_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_)
#define AFX_DATAELEMENTSCOPEITEM_H__5CFA29C2_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMScopeItem.h"

class CDataElementScopeItem : public CHMScopeItem  
{

DECLARE_DYNCREATE(CDataElementScopeItem)

// Construction/Destruction
public:
	CDataElementScopeItem();
	virtual ~CDataElementScopeItem();

// Creation Members
public:
	virtual bool Create(CScopePane* pScopePane, CScopePaneItem* pParentItem);
	
// Results Pane View Members
public:
	virtual CResultsPaneView* CreateResultsPaneView();

// MMC Notify Handlers
public:
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed);
  virtual HRESULT OnCommand(long lCommandID);
	virtual HRESULT OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle);
  virtual HRESULT OnSelect(CResultsPane* pPane,BOOL bSelected);

};

#endif // !defined(AFX_DATAELEMENTSCOPEITEM_H__5CFA29C2_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dataelementscopeitem.cpp ===
// DataElementScopeItem.cpp: implementation of the CDataElementScopeItem class.
//
//////////////////////////////////////////////////////////////////////
// 
// 03/04/00 v-marfin bug 59643 : Set details page as the starting page.
// 03/22/00 v-marfin bug 59675 : Rearranged data element context menu items
// 04/02/00 v-marfin bug 59643b: Make General Page the first page, but set
//                               details page as the focus on a new data collector.
//
//
//
#include "stdafx.h"
#include "snapin.h"
#include "DataElementScopeItem.h"
#include "DataElementResultsView.h"
#include "HealthmonScopePane.h"
#include "DataElement.h"
#include "DPGeneralPage.h"
#include "DPPerfMonPage.h"
#include "DPFileInfoPage.h"
#include "DPGenericPage.h"
#include "DPWmiQueryPage.h"
#include "DPWmiPolledQueryPage.h"
#include "DPHttpPage.h"
#include "DPNtEventPage.h"
#include "DPServicePage.h"
#include "DPInetProtocolPage.h"
#include "DPSchedulePage.h"
#include "DPSNMPDataPage.h"
#include "DPSmtpPage.h"
#include "DPFtpPage.h"
#include "DPIcmpPage.h"
#include "DPComPlusPage.h"
#include "ActionAssociationPage.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// {6121CC48-C9E2-11d2-BD8D-0000F87A3912}
static GUID GUID_DataElement = 
{ 0x6121cc48, 0xc9e2, 0x11d2, { 0xbd, 0x8d, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

IMPLEMENT_DYNCREATE(CDataElementScopeItem,CHMScopeItem)

// icon table - associates state to icons
static UINT _Icons[HMS_MAX_STATES] =
{
	IDI_ICON_DATAPOINT,
	IDI_ICON_DATAPOINT_DISABLED,
	IDI_ICON_DATAPOINT_OUTAGE,
	IDI_ICON_DATAPOINT_UNKNOWN,
	IDI_ICON_DATAPOINT_NO_CONNECT,
	IDI_ICON_DATAPOINT_WARNING,
	IDI_ICON_DATAPOINT_CRITICAL
};

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataElementScopeItem::CDataElementScopeItem()
{
	m_lpguidItemType = &GUID_DataElement;
}

CDataElementScopeItem::~CDataElementScopeItem()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Creation Members
//////////////////////////////////////////////////////////////////////

bool CDataElementScopeItem::Create(CScopePane* pScopePane, CScopePaneItem* pParentItem)
{
	TRACEX(_T("CDataElementScopeItem::Create\n"));
	TRACEARGn(pScopePane);
	TRACEARGn(pParentItem);

	// call base class Create method
	if( ! CHMScopeItem::Create(pScopePane,pParentItem) )
	{
		TRACE(_T("CHMScopeItem::Create failed.\n"));
		return false;
	}

	for( int i = 0; i < HMS_MAX_STATES; i++ )
	{
		UINT nId = _Icons[i];
		m_IconResIds.Add(nId);
		m_OpenIconResIds.Add(nId);
	}

	SetIconIndex(HMS_NORMAL);
	SetOpenIconIndex(HMS_NORMAL);

	return true;
}

//////////////////////////////////////////////////////////////////////	
// Results Pane View Members
//////////////////////////////////////////////////////////////////////

CResultsPaneView* CDataElementScopeItem::CreateResultsPaneView()
{	
	TRACEX(_T("CDataElementScopeItem::CreateResultsPaneView\n"));

	return new CDataElementResultsView;
}

//////////////////////////////////////////////////////////////////////	
// MMC Notify Handlers
//////////////////////////////////////////////////////////////////////	

HRESULT CDataElementScopeItem::OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed)
{
	TRACEX(_T("CDataElementScopeItem::OnAddMenuItems\n"));
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

  HRESULT hr = S_OK;

  // Add New Menu Items
  if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_NEW_THRESHOLD);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_NEW_THRESHOLD_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_NEW_RULE;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
	}

  // Add Task Menu Items
  if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_CLEAR_EVENTS);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_CLEAR_EVENTS_DESCRIPTION);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_CLEAR_EVENTS;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }


	// Reset Statistics
    sResString.LoadString(IDS_STRING_RESET_STATISTICS);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_RESET_STATISTICS_DESC);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_RESET_STATISTICS;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }


    // v-marfin : 59675 : Moved these items up.
	// separator
	cmi.strName           = NULL;
	cmi.strStatusBarText  = NULL;
	cmi.lCommandID        = NULL;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	cmi.fFlags            = MF_SEPARATOR;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }


    // Reset status
    sResString.LoadString(IDS_STRING_RESET_STATUS);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_RESET_STATUS_DESCRIPTION);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_RESET_STATUS;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }


	// Check Now
    sResString.LoadString(IDS_STRING_CHECK_NOW);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_CHECK_NOW_DESC);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_CHECK_NOW;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }


	// separator
	cmi.strName           = NULL;
	cmi.strStatusBarText  = NULL;
	cmi.lCommandID        = NULL;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	cmi.fFlags            = MF_SEPARATOR;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }


	// Disabled
    sResString.LoadString(IDS_STRING_ENABLE_ALL_THRESHOLDS);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ENABLE_ALL_THRESHOLDS_DESCRIPTION);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_DISABLE_MONITORING;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	CHMObject* pObject = GetObjectPtr();
    CHMScopeItem* pParentItem = (CHMScopeItem*)GetParent();        

    // disable menu item if null object ptr or parent is disabled
	if( ! pObject || (pParentItem && pParentItem->GetObjectPtr()
                  && !pParentItem->GetObjectPtr()->IsEnabled()) )
	{
		cmi.fFlags = MF_DISABLED|MF_GRAYED;
	}
	else
	{
		int iState = pObject->IsEnabled();
		if( iState == -1 )
		{
			cmi.fFlags = MF_DISABLED|MF_GRAYED;
		}
		else if( iState == 0 )
		{
			cmi.fFlags = MF_CHECKED;
		}
		else if( iState == 1 )
		{
			cmi.fFlags = MF_UNCHECKED;
		}
	}
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }


  }

  // Add View Menu Items
  if( CCM_INSERTIONALLOWED_VIEW & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_STATUS_ONLY);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_STATUS_ONLY_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_STATUS_ONLY;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_UNCHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    sResString.LoadString(IDS_STRING_AUTO_FILTER);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_AUTO_FILTER_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_AUTO_FILTER;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_CHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    // icon legend
    sResString.LoadString(IDS_STRING_ICON_LEGEND);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ICON_LEGEND_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ICON_LEGEND;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
  }

	return hr;
}

HRESULT CDataElementScopeItem::OnCommand(long lCommandID)
{
	TRACEX(_T("CDataElementScopeItem::OnCommand\n"));
	TRACEARGn(lCommandID);

  HRESULT hr = S_OK;

	switch(lCommandID)
	{
		case IDM_NEW_RULE:
		{
			CDataElement* pElement = (CDataElement*)GetObjectPtr();
			if( ! GfxCheckObjPtr(pElement,CDataElement) )
			{
				return E_FAIL;
			}

			pElement->CreateNewChildRule();
		}
		break;

		default:
		{
			hr = CHMScopeItem::OnCommand(lCommandID);
		}
	}

  return hr;
}

HRESULT CDataElementScopeItem::OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle)
{
	TRACEX(_T("CDataElementScopeItem::OnCreatePropertyPages\n"));
	TRACEARGn(lpProvider);
	TRACEARGn(handle);

	if( m_pScopePane == NULL )
	{
		return S_FALSE;
	}

	HRESULT hr = S_OK;

	CDataElement* pElement = (CDataElement*)GetObjectPtr();
	if( ! GfxCheckObjPtr(pElement,CDataElement) )
	{
		return E_FAIL;
	}

	// v-marfin bug 59643b : Make General Page the first page, but set
    //                       details page as the focus on a new data collector.
	CDPGeneralPage* pPage1 = new CDPGeneralPage;
	pPage1->SetObjectPtr(pElement);
	HPROPSHEETPAGE hPage1 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage1->m_psp) );
    hr = lpProvider->AddPage(hPage1);


	switch( pElement->GetType() )
	{
		case IDM_PERFMON:
		{
			CDPPerfMonPage* pPage2 = new CDPPerfMonPage;
			pPage2->SetObjectPtr(pElement);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);			
		}
		break;

		case IDM_FILE_INFO:
		{
			CDPFileInfoPage* pPage2 = new CDPFileInfoPage;
			pPage2->SetObjectPtr(pElement);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);			
		}
		break;

		case IDM_GENERIC_WMI_INSTANCE:
		{
			CDPWmiInstancePage* pPage2 = new CDPWmiInstancePage;
			pPage2->SetObjectPtr(pElement);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);
		}
		break;

		case IDM_GENERIC_WMI_QUERY:
		{
			CDPWmiQueryPage* pPage2 = new CDPWmiQueryPage;
			pPage2->SetObjectPtr(pElement);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);
		}
		break;

		case IDM_GENERIC_WMI_POLLED_QUERY:
		{
			CDPWmiPolledQueryPage* pPage2 = new CDPWmiPolledQueryPage;
			pPage2->SetObjectPtr(pElement);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);
		}
		break;

		case IDM_HTTP_ADDRESS:
		{
			CDPHttpPage* pPage2 = new CDPHttpPage;
			pPage2->SetObjectPtr(pElement);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);
		}
		break;

		case IDM_SERVICE:
		{
			CDPServicePage* pPage2 = new CDPServicePage;
			pPage2->SetObjectPtr(pElement);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);
		}
		break;

		case IDM_SNMP:
		{
			CDPSNMPDataPage* pPage2 = new CDPSNMPDataPage;
			pPage2->SetObjectPtr(pElement);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);
		}
		break;

		case IDM_NT_EVENTS:
		{
			CDPNtEventPage* pPage2 = new CDPNtEventPage;
			pPage2->SetObjectPtr(pElement);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);
		}
		break;		

		case IDM_SMTP:
		{
			CDPSmtpPage* pPage2 = new CDPSmtpPage;
			pPage2->SetObjectPtr(pElement);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);
		}
		break;

		case IDM_FTP:
		{
			CDPFtpPage* pPage2 = new CDPFtpPage;
			pPage2->SetObjectPtr(pElement);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);
		}
		break;

		case IDM_ICMP:
		{
			CDPIcmpPage* pPage2 = new CDPIcmpPage;
			pPage2->SetObjectPtr(pElement);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);
		}
		break;

		case IDM_COM_PLUS:
		{
			CDPComPlusPage* pPage2 = new CDPComPlusPage;
			pPage2->SetObjectPtr(pElement);
			HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );
			hr = lpProvider->AddPage(hPage2);
		}
		break;

	}




	CActionAssociationPage* pPage3 = new CActionAssociationPage;

	//---------------------------------------------------------------------------------------------
	// v-marfin 62192 : by default the action property page will load its threshold action help.
	//                  so we will override since this is a data group being shown properties, not
	//                  a threshold.
    // v-marfin 62515 : This is a data collector so use its help instead of the data group
	pPage3->m_sHelpTopic = _T("HMon21.chm::/dDCact.htm");  
	//----------------------------------------------------------------------------------------------
	pPage3->SetObjectPtr(GetObjectPtr());
	HPROPSHEETPAGE hPage3 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage3->m_psp) );
	hr = lpProvider->AddPage(hPage3);

	CDPSchedulePage* pPage4 = new CDPSchedulePage;
	pPage4->SetObjectPtr(pElement);
	HPROPSHEETPAGE hPage4 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage4->m_psp) );
	hr = lpProvider->AddPage(hPage4);
	

	return hr;
}

HRESULT CDataElementScopeItem::OnSelect(CResultsPane* pPane, BOOL bSelected)
{
	TRACEX(_T("CDataElementScopeItem::OnSelect\n"));
	TRACEARGn(pPane);
	TRACEARGn(bSelected);

	if( ! CHECKHRESULT(CHMScopeItem::OnSelect(pPane,bSelected)) )
	{
		TRACE(_T("FAILED : CHMScopeItem::OnSelect returns failure.\n"));
		return E_FAIL;
	}

	if( ! bSelected ) // we are being de-selected so do not do anything
	{
		return S_OK;
	}

	LPCONSOLEVERB lpConsoleVerb = pPane->GetConsoleVerbPtr();

  HRESULT hr = lpConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_RENAME, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_CUT, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}
	
  hr = lpConsoleVerb->SetVerbState( MMC_VERB_COPY, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_PASTE, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}
	
	lpConsoleVerb->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dataelementstatslistener.cpp ===
// DataElementStatsListener.cpp: implementation of the CDataElementStatsListener class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "DataElementStatsListener.h"
#include "EventManager.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CDataElementStatsListener,CWbemEventListener)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataElementStatsListener::CDataElementStatsListener()
{
	SetEventQuery(IDS_STRING_STATISTICS_EVENTQUERY);
}

CDataElementStatsListener::~CDataElementStatsListener()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Event Processing Members
//////////////////////////////////////////////////////////////////////

HRESULT CDataElementStatsListener::ProcessEventClassObject(IWbemClassObject* pClassObject)
{
  ASSERT(pClassObject);
  if( pClassObject == NULL )
  {
    return E_FAIL;
  }
  
  HRESULT hr = S_OK;

	CHMObject* pObject = GetObjectPtr();
	if( ! pObject )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	CWbemClassObject DEStatsObject;

	DEStatsObject.SetMachineName(pObject->GetSystemName());

	if( ! CHECKHRESULT(hr = DEStatsObject.Create(pClassObject)) )
	{
		return hr;
	}

	EvtGetEventManager()->ProcessStatisticEvent(&DEStatsObject);

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dataelementstatslistener.h ===
// DataElementStatsListener.h: interface for the CDataElementStatsListener class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATAELEMENTSTATSLISTENER_H__A28C24E5_348F_11D3_BE18_0000F87A3912__INCLUDED_)
#define AFX_DATAELEMENTSTATSLISTENER_H__A28C24E5_348F_11D3_BE18_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemEventListener.h"

class CDataElementStatsListener : public CWbemEventListener  
{

DECLARE_DYNCREATE(CDataElementStatsListener)

// Construction/Destruction
public:
	CDataElementStatsListener();
	virtual ~CDataElementStatsListener();

// Processing Operations
protected:
  virtual HRESULT ProcessEventClassObject(IWbemClassObject* pClassObject);


};

#endif // !defined(AFX_DATAELEMENTSTATSLISTENER_H__A28C24E5_348F_11D3_BE18_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dataelementresultsview.h ===
// DataElementResultsView.h: interface for the CDataElementResultsView class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATAELEMENTRESULTSVIEW_H__5CFA29C3_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_)
#define AFX_DATAELEMENTRESULTSVIEW_H__5CFA29C3_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SplitPaneResultsView.h"

class CDataElementResultsView : public CSplitPaneResultsView  
{

DECLARE_DYNCREATE(CDataElementResultsView)

// Construction/Destruction
public:
	CDataElementResultsView();
	virtual ~CDataElementResultsView();

// Create/Destroy
public:
	virtual bool Create(CScopePaneItem* pOwnerItem);

// Eventing and Statistics Members
public:
	virtual void AddStatistic(CEventContainer* pContainer, CStatistics* pStatistic, bool bUpdateGraph=true);
protected:
	virtual HRESULT AddStatistics(CHealthmonResultsPane* pPane);
	virtual HRESULT RemoveStatistics(CHealthmonResultsPane* pPane);

// GraphView Events Members
public:
	virtual void OnGraphViewStyleChange(_DHMGraphView* pGraphView);
};

#endif // !defined(AFX_DATAELEMENTRESULTSVIEW_H__5CFA29C3_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\datagroup.cpp ===
// DataGroup.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "DataGroup.h"
#include "EventManager.h"
#include "SystemScopeItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDataGroup

IMPLEMENT_SERIAL(CDataGroup, CHMObject, 1)

CDataGroup::CDataGroup()
{
	EnableAutomation();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();

	m_pDGListener = NULL;
	m_pDEListener = NULL;

	m_sTypeName = IDS_STRING_MOF_DATAGROUP;

	m_nState = HMS_NODATA;
}

CDataGroup::~CDataGroup()
{
	if( m_pDGListener )
	{
		delete m_pDGListener;
		m_pDGListener = NULL;
	}

	if( m_pDEListener )
	{
		delete m_pDEListener;
		m_pDEListener = NULL;
	}

	// TODO : Destroy all events

	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}

void CDataGroup::UpdateStatus()
{
	TRACEX(_T("CDataGroup::UpdateStatus\n"));

	CEventContainer* pContainer = NULL;
	EvtGetEventManager()->GetEventContainer(GetSystemName(),GetGuid(),pContainer);
	if( ! pContainer )	
	{
		ASSERT(FALSE);
		return;
	}

	SetState(CEvent::GetStatus(pContainer->m_iState));

	for( int i = 0; i < GetScopeItemCount(); i++ )
	{
		CScopePaneItem* pItem = GetScopeItem(i);
		if( pItem )
		{
			bool bParentIsSystem = false;

			if( pItem->GetParent()->IsKindOf(RUNTIME_CLASS(CSystemScopeItem)) )
			{
				bParentIsSystem = true;
			}
			
			CStringArray saNames;
			CString sValue;

			// Name of Data Group
			saNames.Add(GetName());

			// Status
			CString sStatus;
			CEvent::GetStatus(pContainer->m_iState,sStatus);
			saNames.Add(sStatus);

			// Type (only added for Data Group Results Views
			if( ! bParentIsSystem )
			{
				saNames.Add(GetUITypeName());
			}

			// Guid
			saNames.Add(GetGuid());

			// Normal
			sValue.Format(_T("%d"),pContainer->m_iNumberNormals);
			saNames.Add(sValue);

			// Warning
			sValue.Format(_T("%d"),pContainer->m_iNumberWarnings);
			saNames.Add(sValue);

			// Critical
			sValue.Format(_T("%d"),pContainer->m_iNumberCriticals);
			saNames.Add(sValue);

			// Unknown
			sValue.Format(_T("%d"),pContainer->m_iNumberUnknowns);
			saNames.Add(sValue);

			// Last Message
			CString sLastMessage = pContainer->GetLastEventDTime();
			if( sLastMessage.IsEmpty() )
			{
				sLastMessage.LoadString(IDS_STRING_NONE);
			}
			saNames.Add(sLastMessage);

			// Comment
			saNames.Add(GetComment());

			pItem->SetDisplayNames(saNames);
			pItem->SetIconIndex(CEvent::GetStatus(pContainer->m_iState));
			pItem->SetOpenIconIndex(CEvent::GetStatus(pContainer->m_iState));
			pItem->SetItem();
		}
	}

	m_lNormalCount = pContainer->m_iNumberNormals;
	m_lWarningCount = pContainer->m_iNumberWarnings;
	m_lCriticalCount = pContainer->m_iNumberCriticals;
	m_lUnknownCount = pContainer->m_iNumberUnknowns;
}

void CDataGroup::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CHMObject::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CDataGroup, CHMObject)
	//{{AFX_MSG_MAP(CDataGroup)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CDataGroup, CHMObject)
	//{{AFX_DISPATCH_MAP(CDataGroup)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IDataGroup to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {D9BF4FA2-F673-11D2-BDC4-0000F87A3912}
static const IID IID_IDataGroup =
{ 0xd9bf4fa2, 0xf673, 0x11d2, { 0xbd, 0xc4, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

BEGIN_INTERFACE_MAP(CDataGroup, CHMObject)
	INTERFACE_PART(CDataGroup, IID_IDataGroup, Dispatch)
END_INTERFACE_MAP()

// {D9BF4FA3-F673-11D2-BDC4-0000F87A3912}
IMPLEMENT_OLECREATE_EX(CDataGroup, "SnapIn.DataGroup", 0xd9bf4fa3, 0xf673, 0x11d2, 0xbd, 0xc4, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12)

BOOL CDataGroup::CDataGroupFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterServerClass(m_clsid, m_lpszProgID, m_lpszProgID, m_lpszProgID, OAT_DISPATCH_OBJECT);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

/////////////////////////////////////////////////////////////////////////////
// CDataGroup message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\datagroup.h ===
#if !defined(AFX_DATAGROUP_H__D9BF4FA4_F673_11D2_BDC4_0000F87A3912__INCLUDED_)
#define AFX_DATAGROUP_H__D9BF4FA4_F673_11D2_BDC4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DataGroup.h : header file
//

#include "HMObject.h"
#include "HMDataGroupConfiguration.h"
#include "HMDataElementConfiguration.h"
#include "DataElement.h"
#include "DataGroupScopeItem.h"
#include "DataGroupConfigListener.h"
#include "DataElementConfigListener.h"
#include "HMDataGroupStatus.h"
#include "HMDataElementStatus.h"
#include "DataGroupStatusListener.h"

/////////////////////////////////////////////////////////////////////////////
// CDataGroup command target

class CDataGroup : public CHMObject
{

DECLARE_SERIAL(CDataGroup)

// Construction/Destruction
public:
	CDataGroup();
	virtual ~CDataGroup();

// WMI Operations
public:
	HRESULT EnumerateChildren();
	CString GetObjectPath();
	CString GetStatusObjectPath();
	CHMEvent* GetStatusClassObject();
//	void DeleteClassObject();
protected:
	CDataGroupConfigListener* m_pDGListener;
	CDataElementConfigListener* m_pDEListener;

private:
	// v-marfin 62510 
	void CreateAnyDefaultThresholdsForCollector(CDataElement* pDataElement);

// Clipboard Operations
public:
	virtual bool Cut();
	virtual bool Copy();
	virtual bool Paste();

// Operations
public:
	virtual CString GetUITypeName();

// Scope Item Members
public:
	virtual CScopePaneItem* CreateScopeItem();

// New Child Creation Members
public:
	virtual bool CreateChild(CHMObject* pObject, const CString& sWMIClassName, const CString& sWMIAssociatorClassName);
	void CreateNewChildDataGroup();
	void CreateNewChildDataElement(int iType);

// State Members
public:
	void UpdateStatus();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDataGroup)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:


	// Generated message map functions
	//{{AFX_MSG(CDataGroup)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE_EX(CDataGroup)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CDataGroup)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#include "DataGroup.inl"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DATAGROUP_H__D9BF4FA4_F673_11D2_BDC4_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\datagroupconfiglistener.cpp ===
// DataGroupConfigListener.cpp: implementation of the CDataGroupConfigListener class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "DataGroupConfigListener.h"
#include "HMDataGroupConfiguration.h"
#include "DataGroup.h"
#include "System.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CDataGroupConfigListener,CWbemEventListener)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataGroupConfigListener::CDataGroupConfigListener()
{
}

CDataGroupConfigListener::~CDataGroupConfigListener()
{
	Destroy();
}

/////////////////////////////////////////////////////////////////////////////
// Create/Destroy
/////////////////////////////////////////////////////////////////////////////

bool CDataGroupConfigListener::Create()
{
	TRACEX(_T("CDataGroupConfigListener::Create\n"));

	// first create the unsecured apartment
	HRESULT hr = S_OK;
  IWbemObjectSink* pSink = (IWbemObjectSink*)GetInterface(&IID_IWbemObjectSink);
  ASSERT(pSink);
	CString sSystemName = m_pHMObject->GetSystemName();

	if( s_pIUnsecApartment == NULL )
	{
		hr = CreateUnSecuredApartment();
		if( !GfxCheckPtr(s_pIUnsecApartment,IUnsecuredApartment) || !CHECKHRESULT(hr) )
		{
			TRACE(_T("FAILED : CDataGroupConfigListener::CreateUnSecuredApartment failed.\n"));
            ASSERT(FALSE); // v-marfin 59492
			return false;
		}
	}

	ASSERT(s_pIUnsecApartment);

	// second, create the stub sink for this listener's IWbemObjectSink
	IUnknown* pStubUnk = NULL;

	ASSERT(s_pIUnsecApartment);

	hr = s_pIUnsecApartment->CreateObjectStub(pSink, &pStubUnk);

	if( pStubUnk == NULL || !CHECKHRESULT(hr) )
	{
        TRACE(_T("FAILED : Failed to create Stub Sink!\n"));
        ASSERT(FALSE); // v-marfin 59492
		return false;
	}

	ASSERT(pStubUnk);

	hr = pStubUnk->QueryInterface(IID_IWbemObjectSink, (LPVOID*)&m_pStubSink);
	pStubUnk->Release();

	if( !GfxCheckPtr(m_pStubSink,IWbemObjectSink) || !CHECKHRESULT(hr) )
	{
        TRACE(_T("FAILED : Failed to QI for IWbemObjectSink !\n"));	
        ASSERT(FALSE); // v-marfin 59492
        return false;
    }

    ASSERT(m_pStubSink);

	CHMObject* pObject = GetObjectPtr();
	pObject->IncrementActiveSinkCount();
	
	return true;
}

void CDataGroupConfigListener::Destroy()
{
	TRACEX(_T("CDataGroupConfigListener::Destroy\n"));

    if( m_pStubSink )			
    {
		m_pStubSink->Release();
        m_pStubSink = NULL;
    }

	if( s_lObjCount == 0 && s_pIUnsecApartment )
    {
		s_pIUnsecApartment->Release();
        s_pIUnsecApartment = NULL;
    }

}

//////////////////////////////////////////////////////////////////////
// Event Processing Members
//////////////////////////////////////////////////////////////////////

HRESULT CDataGroupConfigListener::ProcessEventClassObject(IWbemClassObject* pClassObject)
{
  ASSERT(pClassObject);
  if( pClassObject == NULL )
  {
    return E_FAIL;
  }
  
  HRESULT hr = S_OK;

	CHMDataGroupConfiguration dgc;

	if( ! CHECKHRESULT(hr = dgc.Create(pClassObject)) )
	{
		return hr;
	}

	dgc.GetAllProperties();

	// create a new CDataGroup and add as a child
	if( ! GetObjectPtr()->GetChildByGuid(dgc.m_sGUID) )
	{
		CDataGroup* pNewDG = new CDataGroup;
		pNewDG->SetName(dgc.m_sName);
		pNewDG->SetGuid(dgc.m_sGUID);
		pNewDG->SetComment(dgc.m_sDescription);
		pNewDG->SetSystemName(GetObjectPtr()->GetSystemName());
		GetObjectPtr()->AddChild(pNewDG);
    pNewDG->EnumerateChildren();
	}
  return hr;
}

inline HRESULT CDataGroupConfigListener::OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam)
{
	TRACEX(_T("CWbemEventListener::OnSetStatus\n"));
	TRACEARGn(lFlags);
	TRACEARGn(hResult);
	TRACEARGs(strParam);
	TRACEARGn(pObjParam);

	if( lFlags == 0L && hResult == S_OK )
	{
		CHMObject* pObject = GetObjectPtr();
		pObject->DecrementActiveSinkCount();
	}

  return WBEM_NO_ERROR;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\datagroup.inl ===
// File DataGroup.inl
//
// Copyright (c) 2000 Microsoft Corporation
//
// v-marfin 62510 : Query for any default thresholds for this collector and for 
//                  all that are found, create a new threshold and assign it the 
//                  default values.




#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// WMI Operations
/////////////////////////////////////////////////////////////////////////////

inline HRESULT CDataGroup::EnumerateChildren()
{
	TRACEX(_T("CDataGroup::EnumerateChildren\n"));

	if( m_pDGListener == NULL )
	{
		m_pDGListener = new CDataGroupConfigListener;
		m_pDGListener->SetObjectPtr(this);
		m_pDGListener->Create();
	}
	else
	{
		IncrementActiveSinkCount();
	}

	if( m_pDEListener == NULL )
	{
		m_pDEListener = new CDataElementConfigListener;
		m_pDEListener->SetObjectPtr(this);
		m_pDEListener->Create();
	}
	else
	{
		IncrementActiveSinkCount();
	}

	HRESULT hr = S_OK;
	CString sQuery;
	sQuery.Format(IDS_STRING_DG2DG_ASSOC_QUERY,GetGuid());
	IWbemObjectSink* pSink = m_pDGListener->GetSink();
	
  if( !CHECKHRESULT(hr = CnxExecQueryAsync(GetSystemName(),sQuery,pSink)) )
  {
    TRACE(_T("FAILED : CConnectionManager::RegisterEventNotification failed!\n"));
  }


	hr = S_OK;
	sQuery.Format(IDS_STRING_DG2DE_ASSOC_QUERY,GetGuid());
	pSink = m_pDEListener->GetSink();
	
  if( !CHECKHRESULT(hr = CnxExecQueryAsync(GetSystemName(),sQuery,pSink)) )
  {
    TRACE(_T("FAILED : CConnectionManager::RegisterEventNotification failed!\n"));
  }

	return hr;
}

inline CString CDataGroup::GetObjectPath()
{
	TRACEX(_T("CDataGroup::GetObjectPath\n"));

	CString sPath;
	sPath.Format(IDS_STRING_MOF_OBJECTPATH,IDS_STRING_MOF_HMDG_CONFIG,GetGuid());

	return sPath;
}

inline CString CDataGroup::GetStatusObjectPath()
{
	TRACEX(_T("CDataGroup::GetStatusObjectPath\n"));

	CString sPath;
	sPath.Format(IDS_STRING_MOF_OBJECTPATH,IDS_STRING_MOF_HMDG_STATUS,GetGuid());

	return sPath;
}

inline CHMEvent* CDataGroup::GetStatusClassObject()
{
	TRACEX(_T("CDataGroup::GetStatusClassObject\n"));

	CHMEvent* pClassObject = new CHMDataGroupStatus;

	pClassObject->SetMachineName(GetSystemName());

	if( ! CHECKHRESULT(pClassObject->GetObject(GetStatusObjectPath())) )
	{
		delete pClassObject;
		return NULL;
	}

	pClassObject->GetAllProperties();

	return pClassObject;
}
/*
inline void CDataGroup::DeleteClassObject()
{
	TRACEX(_T("CDataGroup::DeleteClassObject\n"));

	// get associator path
	CWbemClassObject Associator;

	Associator.SetMachineName(GetSystemName());

	CString sQuery;
	sQuery.Format(IDS_STRING_DG2S_REF_QUERY,GetGuid());
	BSTR bsQuery = sQuery.AllocSysString();
	if( ! CHECKHRESULT(Associator.ExecQuery(bsQuery)) )
	{
		::SysFreeString(bsQuery);
		return;
	}
	::SysFreeString(bsQuery);

	ULONG ulReturned = 0L;
	if( Associator.GetNextObject(ulReturned) != S_OK )
	{
		ASSERT(FALSE);
		return;
	}

	CString sAssociatorPath;
	Associator.GetProperty(_T("__path"),sAssociatorPath);

	Associator.Destroy();

	// delete the instance
	Associator.SetMachineName(GetSystemName());
	
	BSTR bsInstanceName = sAssociatorPath.AllocSysString();
	CHECKHRESULT(Associator.DeleteInstance(bsInstanceName));
	::SysFreeString(bsInstanceName);
	
}
*/

/////////////////////////////////////////////////////////////////////////////
// Clipboard Operations
/////////////////////////////////////////////////////////////////////////////

inline bool CDataGroup::Cut()
{
	TRACEX(_T("CDataGroup::Cut\n"));
	return false;
}

inline bool CDataGroup::Copy()
{
	TRACEX(_T("CDataGroup::Copy\n"));
	return false;
}
	
inline bool CDataGroup::Paste()
{
	TRACEX(_T("CDataGroup::Paste\n"));
	return false;
}

/////////////////////////////////////////////////////////////////////////////
// Operations
/////////////////////////////////////////////////////////////////////////////

inline CString CDataGroup::GetUITypeName()
{
	TRACEX(_T("CDataGroup::GetUITypeName\n"));

	CString sTypeName;
	sTypeName.LoadString(IDS_STRING_DATA_GROUP);

	return sTypeName;
}

/////////////////////////////////////////////////////////////////////////////
// Scope Item Members
/////////////////////////////////////////////////////////////////////////////

inline CScopePaneItem* CDataGroup::CreateScopeItem()
{
	TRACEX(_T("CDataGroup::CreateScopeItem\n"));

	CDataGroupScopeItem * pNewItem = new CDataGroupScopeItem;
	pNewItem->SetObjectPtr(this);

	return pNewItem;
}

/////////////////////////////////////////////////////////////////////////////
// New Child Creation Members
/////////////////////////////////////////////////////////////////////////////

inline bool CDataGroup::CreateChild(CHMObject* pObject, const CString& sWMIClassName, const CString& sWMIAssociatorClassName)
{
	TRACEX(_T("CDataGroup::CreateChild\n"));
	TRACEARGn(pObject);
	TRACEARGs(sWMIClassName);
	TRACEARGs(sWMIAssociatorClassName);

	if( ! GfxCheckObjPtr(pObject,CHMObject) )
	{
		return false;
	}

	pObject->SetSystemName(GetSystemName());

	// create the GUID
	GUID ChildGuid;
	CoCreateGuid(&ChildGuid);

	OLECHAR szGuid[GUID_CCH];
	::StringFromGUID2(ChildGuid, szGuid, GUID_CCH);
	CString sGuid = OLE2CT(szGuid);
	pObject->SetGuid(sGuid);

  // Add Child
  AddChild(pObject);

	// create child instance
	CWbemClassObject ChildClassObject;
	if( ! CHECKHRESULT(ChildClassObject.Create(GetSystemName())) )
	{
		return false;
	}

	BSTR bsTemp = sWMIClassName.AllocSysString();
	if( ! CHECKHRESULT(ChildClassObject.CreateInstance(bsTemp)) )
	{
		::SysFreeString(bsTemp);
		return false;
	}
	::SysFreeString(bsTemp);


	// Save the child instance properties for name and guid
	ChildClassObject.SetProperty(IDS_STRING_MOF_NAME,pObject->GetName());
	ChildClassObject.SetProperty(IDS_STRING_MOF_GUID,sGuid);

	// if the child is a data element, save its type guid
	if( GfxCheckObjPtr(pObject,CDataElement) )
	{
		ChildClassObject.SetProperty(IDS_STRING_MOF_TYPEGUID,((CDataElement*)pObject)->GetTypeGuid());



		//--------------------------------------------------------------------------------------------------------
		// v-marfin : fetch default values for this type which are defined in defaults.mof, and load
		//            this data element with any values present.

		// Get the default object for this data element based on its TYPEGUID, not its GUID
		CString sPath = ((CDataElement*)pObject)->GetObjectPathBasedOnTypeGUID();

		CWbemClassObject DefaultInfo;
		DefaultInfo.SetNamespace(_T("\\\\") + GetSystemName() + _T("\\root\\cimv2\\MicrosoftHealthMonitor"));
		if(CHECKHRESULT(DefaultInfo.Create(GetSystemName())) )
		{
			if(CHECKHRESULT(DefaultInfo.GetObject(sPath)))
			{
				// read in the properties and set the new object's properties to the defaults
				CStringArray saPropertyNames;

				DefaultInfo.GetPropertyNames(saPropertyNames);

				CString sName;
				CIMTYPE ctType=0;

				// We do not want to set certain properties such as HIDDEN etc.
				int nSize = (int)saPropertyNames.GetSize();
				for( int i = 0; i < nSize; i++ )
				{
					// Get the property name
					sName = saPropertyNames[i];

					// Is it a property we do NOT want to set? If so, skip to next property.

					// HIDDEN property - skip it
					if (sName.CompareNoCase(_T("HIDDEN"))==0)
						continue;

					// NAME property - skip it
					if (sName.CompareNoCase(IDS_STRING_MOF_NAME)==0)
						continue;

					// GUID property - skip it
					if (sName.CompareNoCase(IDS_STRING_MOF_GUID)==0)
						continue;

					// TYPEGUID property - skip it, it was already set above...
					if (sName.CompareNoCase(IDS_STRING_MOF_TYPEGUID)==0)
						continue;

					// OK, set this property on the new object
					// Determine its type in order to call the correct Get/Set property methods.
					DefaultInfo.GetPropertyType(sName,ctType);
					
/* From WbemCli.h
typedef 
enum tag_CIMTYPE_ENUMERATION
    {	CIM_ILLEGAL	= 0xfff,
	CIM_EMPTY	= 0,
	CIM_SINT8	= 16,
	CIM_UINT8	= 17,
	CIM_SINT16	= 2,
	CIM_UINT16	= 18,
	CIM_SINT32	= 3,
	CIM_UINT32	= 19,
	CIM_SINT64	= 20,
	CIM_UINT64	= 21,
	CIM_REAL32	= 4,
	CIM_REAL64	= 5,
	CIM_BOOLEAN	= 11,
	CIM_STRING	= 8,
	CIM_DATETIME	= 101,
	CIM_REFERENCE	= 102,
	CIM_CHAR16	= 103,
	CIM_OBJECT	= 13,
	CIM_FLAG_ARRAY	= 0x2000
    }	CIMTYPE_ENUMERATION;

typedef long CIMTYPE;


*/
					switch( ctType )
					{
						case CIM_ILLEGAL:
						case CIM_EMPTY:
						case CIM_DATETIME:
						{
							continue;
						}
						break;

						default:
						{
							// Do a get from the "defaults" object and set the new object's value with it.
							VARIANT vPropValue;
							VariantInit(&vPropValue);
							HRESULT hr=S_OK;

							// We get the RAW property. That is, no conversion or formatting has
							// been done on it at all.
							hr = DefaultInfo.GetRawProperty(sName,vPropValue);
							if(CHECKHRESULT(hr))
							{
								hr = ChildClassObject.SetRawProperty(sName,vPropValue);
								if(!CHECKHRESULT(hr))
								{
									TRACE(_T("ERROR: Failed to SetRawProperty() on new default data collector\n"));
								}
							}
							else
							{
								TRACE(_T("ERROR: Failed to GetRawProperty() from default data collector\n"));
							}

							VariantClear(&vPropValue);
						}
					} // switch
						
					continue; // get next property
				}


			} // if(CHECKHRESULT(DefaultInfo.GetObject(sPath)))
			else
			{
				// No default mof has been created for this data collector. OK to proceed, 
				// we just don't have any default values to set the new data collector's 
				// default values from the defaults.mof.
				TRACE(_T("INFO : No default values defined for this collector.\n"));
			}
		} //if(CHECKHRESULT(DefaultInfo.Create(GetSystemName())) )
		else
		{
			// Could not create CWbemClassObject. OK to proceed, we just won't be able
			// to set the new data collector's default values from the defaults.mof.
			TRACE(_T("FAILED : CDataGroup::CreateChild could not Create CWbemClassObject.\n"));
		}



		// v-marfin (end) --------------------------------------------------------------------------

	}

	// create the association class instance
	CWbemClassObject Associator;
	if( ! CHECKHRESULT(Associator.Create(GetSystemName())) )
	{
		return false;
	}

	bsTemp = sWMIAssociatorClassName.AllocSysString();
	if( ! CHECKHRESULT(Associator.CreateInstance(bsTemp)) )
	{
		::SysFreeString(bsTemp);
		return false;
	}
	::SysFreeString(bsTemp);

	// set path properties for the association class instance
	CString sProperty;
	sProperty.Format(IDS_STRING_MOF_PARENT_ASSOC,GetTypeName());
	Associator.SetProperty(sProperty,GetObjectPath());

	sProperty.Format(IDS_STRING_MOF_CHILD_ASSOC,pObject->GetTypeName());
	Associator.SetProperty(sProperty,pObject->GetObjectPath());

	// commit the changes to WMI
	ChildClassObject.SaveAllProperties();
	Associator.SaveAllProperties();

	// Add the child
	return true;
}

inline void CDataGroup::CreateNewChildDataGroup()
{
	TRACEX(_T("CDataGroup::CreateNewChildDataGroup\n"));

	CString sName = GetUniqueChildName(IDS_STRING_DATA_GROUP_FMT);

	CDataGroup* pNewGroup = new CDataGroup;
	pNewGroup->SetName(sName);
	CreateChild(pNewGroup,IDS_STRING_MOF_HMDG_CONFIG,IDS_STRING_MOF_HMC2C_ASSOC);

	if( pNewGroup->GetScopeItemCount() )
	{
		CScopePaneItem* pItem = pNewGroup->GetScopeItem(0);
		if( pItem )
		{
			pItem->SelectItem();
			pItem->InvokePropertySheet();
		}
	}


}

inline void CDataGroup::CreateNewChildDataElement(int iType)
{
	TRACEX(_T("CDataGroup::CreateNewChildDataElement\n"));
	TRACEARGn(iType);

    // v-marfin : 62585 : Create with constructor that indicates that this is a 'new'
    //                    data collector
	CDataElement* pNewElement = new CDataElement(TRUE);	

	switch( iType )
	{
		case IDM_GENERIC_WMI_INSTANCE:
		{
			pNewElement->SetName(GetUniqueChildName(IDS_STRING_WMI_INSTANCE_FMT));	
			pNewElement->SetTypeGuid(IDS_STRING_MOF_HMDET_WMI_INSTANCE);
			CreateChild(pNewElement,IDS_STRING_MOF_HMDE_POLLEDINSTANCE_CONFIG,IDS_STRING_MOF_HMC2C_ASSOC);			
		}
		break;

		case IDM_GENERIC_WMI_QUERY:
		{
			pNewElement->SetName(GetUniqueChildName(IDS_STRING_WMI_EVENT_QUERY_FMT));	
			pNewElement->SetTypeGuid(IDS_STRING_MOF_HMDET_WMI_QUERY);
			CreateChild(pNewElement,IDS_STRING_MOF_HMDE_EVENT_CONFIG,IDS_STRING_MOF_HMC2C_ASSOC);			
		}
		break;

		case IDM_GENERIC_WMI_POLLED_QUERY:
		{
			pNewElement->SetName(GetUniqueChildName(IDS_STRING_WMI_QUERY_FMT));	
			pNewElement->SetTypeGuid(IDS_STRING_MOF_HMDET_WMI_POLLED_QUERY);
			CreateChild(pNewElement,IDS_STRING_MOF_HMDE_POLLEDQUERY_CONFIG,IDS_STRING_MOF_HMC2C_ASSOC);			
		}
		break;

		case IDM_NT_EVENTS:
		{
			pNewElement->SetName(GetUniqueChildName(IDS_STRING_EVENT_LOG_FMT));	
			pNewElement->SetTypeGuid(IDS_STRING_MOF_HMDET_NTEVENT);
			CreateChild(pNewElement,IDS_STRING_MOF_HMDE_EVENT_CONFIG,IDS_STRING_MOF_HMC2C_ASSOC);			
		}
		break;

		case IDM_PERFMON:
		{
			pNewElement->SetName(GetUniqueChildName(IDS_STRING_PERFMON_FMT));	
			pNewElement->SetTypeGuid(IDS_STRING_MOF_HMDET_PERFMON);
			CreateChild(pNewElement,IDS_STRING_MOF_HMDE_POLLEDINSTANCE_CONFIG,IDS_STRING_MOF_HMC2C_ASSOC);
		}
		break;

		case IDM_SERVICE:
		{
			pNewElement->SetName(GetUniqueChildName(IDS_STRING_SERVICE_FMT));	
			pNewElement->SetTypeGuid(IDS_STRING_MOF_HMDET_SERVICE);
			CreateChild(pNewElement,IDS_STRING_MOF_HMDE_POLLEDQUERY_CONFIG,IDS_STRING_MOF_HMC2C_ASSOC);
		}
		break;

		case IDM_HTTP_ADDRESS:
		{
			pNewElement->SetName(GetUniqueChildName(IDS_STRING_HTTP_FMT));	
			pNewElement->SetTypeGuid(IDS_STRING_MOF_HMDET_HTTP);
			CreateChild(pNewElement,IDS_STRING_MOF_HMDE_POLLEDINSTANCE_CONFIG,IDS_STRING_MOF_HMC2C_ASSOC);
		}
		break;

		case IDM_SMTP:
		{
			pNewElement->SetName(GetUniqueChildName(IDS_STRING_SMTP_FMT));	
			pNewElement->SetTypeGuid(IDS_STRING_MOF_HMDET_SMTP);
			CreateChild(pNewElement,IDS_STRING_MOF_HMDE_POLLEDMETHOD_CONFIG,IDS_STRING_MOF_HMC2C_ASSOC);
		}
		break;

		case IDM_FTP:
		{
			pNewElement->SetName(GetUniqueChildName(IDS_STRING_FTP_FMT));	
			pNewElement->SetTypeGuid(IDS_STRING_MOF_HMDET_FTP);
			CreateChild(pNewElement,IDS_STRING_MOF_HMDE_POLLEDMETHOD_CONFIG,IDS_STRING_MOF_HMC2C_ASSOC);
		}
		break;

		case IDM_FILE_INFO:
		{
			pNewElement->SetName(GetUniqueChildName(IDS_STRING_FILE_INFO_FMT));	
			pNewElement->SetTypeGuid(IDS_STRING_MOF_HMDET_FILE_INFO);
			CreateChild(pNewElement,IDS_STRING_MOF_HMDE_POLLEDQUERY_CONFIG,IDS_STRING_MOF_HMC2C_ASSOC);
		}
		break;

		case IDM_ICMP:
		{
			pNewElement->SetName(GetUniqueChildName(IDS_STRING_ICMP_FMT));	
			pNewElement->SetTypeGuid(IDS_STRING_MOF_HMDET_ICMP);
			CreateChild(pNewElement,IDS_STRING_MOF_HMDE_POLLEDMETHOD_CONFIG,IDS_STRING_MOF_HMC2C_ASSOC);
		}
		break;

		case IDM_COM_PLUS:
		{
			pNewElement->SetName(GetUniqueChildName(IDS_STRING_COM_PLUS_FMT));	
			pNewElement->SetTypeGuid(IDS_STRING_MOF_HMDET_COM_PLUS);
			CreateChild(pNewElement,IDS_STRING_MOF_HMDE_POLLEDINSTANCE_CONFIG,IDS_STRING_MOF_HMC2C_ASSOC);
		}
		break;

		default:
		{
			pNewElement->SetName(GetUniqueChildName(IDS_STRING_WMI_INSTANCE_FMT));	
			pNewElement->SetTypeGuid(IDS_STRING_MOF_HMDET_WMI_INSTANCE);
			CreateChild(pNewElement,IDS_STRING_MOF_HMDE_POLLEDINSTANCE_CONFIG,IDS_STRING_MOF_HMC2C_ASSOC);
		}
		break;
	}	

	if( pNewElement->GetScopeItemCount() )
	{
		CScopePaneItem* pItem = pNewElement->GetScopeItem(0);
		if( pItem )
		{
			pItem->SelectItem();
			pItem->InvokePropertySheet();
		}
	}

	//---------------------------------------------------------------------------------------------------
	// v-marfin 62510 : Check for existence of any default thresholds. Just as we did for data collectors
	//                  above in CreateChild().

	// Is this a data collector?
	if(GfxCheckObjPtr(pNewElement,CDataElement))
	{
		CreateAnyDefaultThresholdsForCollector((CDataElement*)pNewElement);
	}

	//---------------------------------------------------------------------------------------------------



}

//****************************************************************************************
// CreateAnyDefaultThresholdsForCollector
//
// v-marfin 62510 : Query for any default thresholds for this collector and for 
//                  all that are found, create a new threshold and assign it the 
//                  default values.
//****************************************************************************************
inline void CDataGroup::CreateAnyDefaultThresholdsForCollector(CDataElement* pDataElement)
{

	// Get the default thresholds associated with the data collector, based on its TYPEGUID, not its GUID.
	//#define IDS_STRING_DE2R_ASSOC_QUERY  _T("ASSOCIATORS OF {Microsoft_HMDataCollectorConfiguration.GUID=\"{%s}\"} WHERE ResultClass=Microsoft_HMThresholdConfiguration")
	CString sPath; 
	sPath.Format(IDS_STRING_DE2R_ASSOC_QUERY,pDataElement->GetTypeGuid());

	CWbemClassObject DefaultInfo;
	DefaultInfo.SetNamespace(_T("\\\\") + GetSystemName() + _T("\\root\\cimv2\\MicrosoftHealthMonitor"));
	if(!CHECKHRESULT(DefaultInfo.Create(GetSystemName())) )
	{
		// Could not create CWbemClassObject. OK to proceed, we just won't be able
		// to set the new data collector's default values from the defaults.mof.
		TRACE(_T("FAILED : CDataGroup::CreateChild could not Create CWbemClassObject.\n"));
		return;
	}

	BSTR bsTemp = sPath.AllocSysString();
	if( ! CHECKHRESULT(DefaultInfo.ExecQuery(bsTemp)) )
	{		
		::SysFreeString(bsTemp);
		return;
	}
	::SysFreeString(bsTemp);

	ULONG ulReturned = 0L;

	while( DefaultInfo.GetNextObject(ulReturned) == S_OK && ulReturned )
	{

        // Get the threshold name 
        CString sThresholdName;
        HRESULT hr = DefaultInfo.GetProperty(_T("Name"),sThresholdName);
        if (!CHECKHRESULT(hr))
            sThresholdName.Empty();

		// Tell the collector to add a new rule, WITHOUT showing its property pages.
		CRule* pRule=NULL;
		((CDataElement*)pDataElement)->CreateNewChildRule(TRUE,&pRule,(LPCTSTR)sThresholdName);

		if (!pRule)
		{
			TRACE(_T("ERROR: Collector was unable to create new default threshold\n"));
			return;
		}

		CWbemClassObject* pClassObject = pRule->GetClassObject();
		if( ! pClassObject )
		{
			TRACE(_T("ERROR: Unable to get class object pointer from newly created default threshold\n"));
			return;
		}


		// read in the properties and set the new object's properties to the defaults
		CStringArray saPropertyNames;

		DefaultInfo.GetPropertyNames(saPropertyNames);

		CString sName;
		CIMTYPE ctType=0;

		// We do not want to set certain properties such as HIDDEN etc.
		int nSize = (int)saPropertyNames.GetSize();
		for( int i = 0; i < nSize; i++ )
		{
			// Get the property name
			sName = saPropertyNames[i];

			// Is it a property we do NOT want to set? If so, skip to next property.

			// HIDDEN property - skip it
			if (sName.CompareNoCase(_T("HIDDEN"))==0)
				continue;

			// NAME property - skip it
            // 62510 : Modification - use default name as well.
			//if (sName.CompareNoCase(IDS_STRING_MOF_NAME)==0)
			//	continue;

			// GUID property - skip it
			if (sName.CompareNoCase(IDS_STRING_MOF_GUID)==0)
				continue;

			// TYPEGUID property - skip it, it was already set above...
			if (sName.CompareNoCase(IDS_STRING_MOF_TYPEGUID)==0)
				continue;

			// OK, set this property on the new object
			// Determine its type in order to call the correct Get/Set property methods.
			DefaultInfo.GetPropertyType(sName,ctType);
			
	/* From WbemCli.h
	typedef 
	enum tag_CIMTYPE_ENUMERATION
	{	CIM_ILLEGAL	= 0xfff,
	CIM_EMPTY	= 0,
	CIM_SINT8	= 16,
	CIM_UINT8	= 17,
	CIM_SINT16	= 2,
	CIM_UINT16	= 18,
	CIM_SINT32	= 3,
	CIM_UINT32	= 19,
	CIM_SINT64	= 20,
	CIM_UINT64	= 21,
	CIM_REAL32	= 4,
	CIM_REAL64	= 5,
	CIM_BOOLEAN	= 11,
	CIM_STRING	= 8,
	CIM_DATETIME	= 101,
	CIM_REFERENCE	= 102,
	CIM_CHAR16	= 103,
	CIM_OBJECT	= 13,
	CIM_FLAG_ARRAY	= 0x2000
	}	CIMTYPE_ENUMERATION;

	typedef long CIMTYPE;


	*/
			switch( ctType )
			{
				case CIM_ILLEGAL:
				case CIM_EMPTY:
				case CIM_DATETIME:
				{
					continue;
				}
				break;

				default:
				{
					// Do a get from the "defaults" object and set the new object's value with it.
					VARIANT vPropValue;
					VariantInit(&vPropValue);
					HRESULT hr=S_OK;

					// We get the RAW property. That is, no conversion or formatting has
					// been done on it at all.
					hr = DefaultInfo.GetRawProperty(sName,vPropValue);
					if(CHECKHRESULT(hr))
					{
						hr = pClassObject->SetRawProperty(sName,vPropValue);

						if(!CHECKHRESULT(hr))
						{
							TRACE(_T("ERROR: Failed to SetRawProperty() on new default threshold\n"));
						}
					}
					else
					{
						TRACE(_T("ERROR: Failed to GetRawProperty() from default threshold\n"));
					}

					VariantClear(&vPropValue);
				}
			} // switch
				
			continue; // get next property
		}

		// Save the new threshold's new properties.
		if (pClassObject)
		{
			pClassObject->SaveAllProperties();
		}


	} // while( DefaultInfo.GetNextObject 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dataelementstatuslistener.h ===
// DataElementStatusListener.h: interface for the CDataElementStatusListener class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATAELEMENTSTATUSLISTENER_H__25364FEE_2D9A_11D3_BE0E_0000F87A3912__INCLUDED_)
#define AFX_DATAELEMENTSTATUSLISTENER_H__25364FEE_2D9A_11D3_BE0E_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemEventListener.h"

class CDataElementStatusListener : public CWbemEventListener  
{

DECLARE_DYNCREATE(CDataElementStatusListener)

// Construction/Destruction
public:
	CDataElementStatusListener();
	virtual ~CDataElementStatusListener();

// Create/Destroy
public:
	virtual bool Create();
	virtual void Destroy();

// Processing Operations
protected:
  virtual HRESULT ProcessEventClassObject(IWbemClassObject* pClassObject);

};

#endif // !defined(AFX_DATAELEMENTSTATUSLISTENER_H__25364FEE_2D9A_11D3_BE0E_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\datagroupconfiglistener.h ===
// DataGroupConfigListener.h: interface for the CDataGroupConfigListener class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATAGROUPCONFIGLISTENER_H__6BD5F12F_FE50_11D2_BDD4_0000F87A3912__INCLUDED_)
#define AFX_DATAGROUPCONFIGLISTENER_H__6BD5F12F_FE50_11D2_BDD4_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemEventListener.h"

class CDataGroupConfigListener : public CWbemEventListener  
{

DECLARE_DYNCREATE(CDataGroupConfigListener)

// Construction/Destruction
public:
	CDataGroupConfigListener();
	virtual ~CDataGroupConfigListener();

// Create/Destroy
public:
	virtual bool Create();
	virtual void Destroy();

// Processing Operations
protected:
  virtual HRESULT ProcessEventClassObject(IWbemClassObject* pClassObject);
	virtual HRESULT OnSetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject __RPC_FAR *pObjParam);


};

#endif // !defined(AFX_DATAGROUPCONFIGLISTENER_H__6BD5F12F_FE50_11D2_BDD4_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dataelementstatuslistener.cpp ===
// DataElementStatusListener.cpp: implementation of the CDataElementStatusListener class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "DataElementStatusListener.h"
#include "HMDataElementStatus.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CDataElementStatusListener,CWbemEventListener)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataElementStatusListener::CDataElementStatusListener()
{
}

CDataElementStatusListener::~CDataElementStatusListener()
{
	Destroy();
}

/////////////////////////////////////////////////////////////////////////////
// Create/Destroy
/////////////////////////////////////////////////////////////////////////////

bool CDataElementStatusListener::Create()
{
	TRACEX(_T("CDataElementStatusListener::Create\n"));

	// first create the unsecured apartment
	HRESULT hr = S_OK;
  IWbemObjectSink* pSink = (IWbemObjectSink*)GetInterface(&IID_IWbemObjectSink);
  ASSERT(pSink);
	CString sSystemName = m_pHMObject->GetSystemName();

	if( s_pIUnsecApartment == NULL )
	{
		hr = CreateUnSecuredApartment();
		if( !GfxCheckPtr(s_pIUnsecApartment,IUnsecuredApartment) || !CHECKHRESULT(hr) )
		{
			TRACE(_T("FAILED : CDataElementStatusListener::CreateUnSecuredApartment failed.\n"));
			return false;
		}
	}

	ASSERT(s_pIUnsecApartment);

	// second, create the stub sink for this listener's IWbemObjectSink
	IUnknown* pStubUnk = NULL;

	ASSERT(s_pIUnsecApartment);

	hr = s_pIUnsecApartment->CreateObjectStub(pSink, &pStubUnk);

	if( pStubUnk == NULL || !CHECKHRESULT(hr) )
	{
    TRACE(_T("FAILED : Failed to create Stub Sink!\n"));    
		return false;
	}

	ASSERT(pStubUnk);

	hr = pStubUnk->QueryInterface(IID_IWbemObjectSink, (LPVOID*)&m_pStubSink);
	pStubUnk->Release();

	if( !GfxCheckPtr(m_pStubSink,IWbemObjectSink) || !CHECKHRESULT(hr) )
	{
    TRACE(_T("FAILED : Failed to QI for IWbemObjectSink !\n"));		
    return false;
  }

  ASSERT(m_pStubSink);
	
	// third, call connection manager to execute the query
	CString sQuery;
	sQuery.Format(IDS_STRING_STATUS_QUERY_FMT,IDS_STRING_MOF_HMDE_STATUS,GetObjectPtr()->GetGuid());
	
  if( !CHECKHRESULT(hr = CnxExecQueryAsync(sSystemName,sQuery,m_pStubSink)) )
  {
    TRACE(_T("FAILED : CConnectionManager::RegisterEventNotification failed!\n"));
  }

	return true;
}

void CDataElementStatusListener::Destroy()
{
	TRACEX(_T("CDataElementStatusListener::Destroy\n"));

  if( m_pStubSink )			
  {
		CnxRemoveConnection(m_pHMObject->GetName(),m_pStubSink);
		m_pStubSink->Release();
    m_pStubSink = NULL;
  }

	if( s_lObjCount == 0 && s_pIUnsecApartment )
  {
		s_pIUnsecApartment->Release();
    s_pIUnsecApartment = NULL;
  }

}

//////////////////////////////////////////////////////////////////////
// Event Processing Members
//////////////////////////////////////////////////////////////////////

HRESULT CDataElementStatusListener::ProcessEventClassObject(IWbemClassObject* pClassObject)
{
  ASSERT(pClassObject);
  if( pClassObject == NULL )
  {
    return E_FAIL;
  }
  
  HRESULT hr = S_OK;

	CHMDataElementStatus des;

	if( ! CHECKHRESULT(hr = des.Create(pClassObject)) )
	{
		return hr;
	}

	des.m_sSystemName = GetObjectPtr()->GetSystemName();

	des.GetAllProperties();

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\datagroupresultsview.cpp ===
// DataGroupResultsView.cpp: implementation of the CDataGroupResultsView class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "DataGroupResultsView.h"
#include "HMListViewColumn.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CDataGroupResultsView,CSplitPaneResultsView)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataGroupResultsView::CDataGroupResultsView()
{

}

CDataGroupResultsView::~CDataGroupResultsView()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Create/Destroy
//////////////////////////////////////////////////////////////////////

bool CDataGroupResultsView::Create(CScopePaneItem* pOwnerItem)
{
	TRACEX(_T("CDataGroupResultsView::Create\n"));
	TRACEARGn(pOwnerItem);

	if( ! CSplitPaneResultsView::Create(pOwnerItem) )
	{
		TRACE(_T("FAILED : CSplitPaneResultsView::Create failed.\n"));
		return false;
	}

	// add the upper columns

	CHMListViewColumn* pColumn = NULL;
	CString sTitle;
	DWORD dwFormat = LVCFMT_LEFT;

	// name
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NAME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// Status
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_STATUS);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// type
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_TYPE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// GUID
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_GUID);
	pColumn->Create(this,sTitle,0,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// normal
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NORMAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// warning
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_WARNING);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// critical
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_CRITICAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// unknown
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_UNKNOWN);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// last message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_LAST_MESSAGE);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// comment
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_COMMENT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToUpperPane();
	AddColumn(pColumn);

	// add the lower columns

	// Severity
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SEVERITY);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// ID
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_ID);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Date/Time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,175,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Component
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATA_POINT);
	pColumn->Create(this,sTitle,125,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// System
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_SYSTEM);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// Message
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_MESSAGE);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToLowerPane();
	AddColumn(pColumn);

	// add the stats columns

	// time
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_DATETIME);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// normal
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_NORMAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// warning
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_WARNING);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// critical
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_CRITICAL);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	// unknown
	pColumn = new CHMListViewColumn;
	sTitle.LoadString(IDS_STRING_UNKNOWN);
	pColumn->Create(this,sTitle,75,dwFormat);
	pColumn->SetToStatsPane();
	AddColumn(pColumn);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\datagroupstatuslistener.h ===
// DataGroupStatusListener.h: interface for the CDataGroupStatusListener class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATAGROUPSTATUSLISTENER_H__25364FED_2D9A_11D3_BE0E_0000F87A3912__INCLUDED_)
#define AFX_DATAGROUPSTATUSLISTENER_H__25364FED_2D9A_11D3_BE0E_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "WbemEventListener.h"

class CDataGroupStatusListener : public CWbemEventListener  
{

DECLARE_DYNCREATE(CDataGroupStatusListener)

// Construction/Destruction
public:
	CDataGroupStatusListener();
	virtual ~CDataGroupStatusListener();

// Create/Destroy
public:
	virtual bool Create();
	virtual void Destroy();

// Processing Operations
protected:
  virtual HRESULT ProcessEventClassObject(IWbemClassObject* pClassObject);


};

#endif // !defined(AFX_DATAGROUPSTATUSLISTENER_H__25364FED_2D9A_11D3_BE0E_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\datapointstatistics.cpp ===
// DataPointStatistics.cpp: implementation of the CDataPointStatistics class.
//
//////////////////////////////////////////////////////////////////////
// 04/09/00 v-marfin 63119 : converted m_iCurrent to string
//
//
#include "stdafx.h"
#include "snapin.h"
#include "DataPointStatistics.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CDataPointStatistics,CStatistics)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataPointStatistics::CDataPointStatistics()
{
	// 63119 m_iCurrent = 0;	
	m_iMin = 0;
	m_iMax = 0;
	m_iAvg = 0;
}

CDataPointStatistics::~CDataPointStatistics()
{
	// 63119 m_iCurrent = 0;	
	m_iMin = 0;
	m_iMax = 0;
	m_iAvg = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\datagroupscopeitem.h ===
// DataGroupScopeItem.h: interface for the CDataGroupScopeItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATAGROUPSCOPEITEM_H__5CFA29BB_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_)
#define AFX_DATAGROUPSCOPEITEM_H__5CFA29BB_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HMScopeItem.h"

class CDataGroupScopeItem : public CHMScopeItem  
{

DECLARE_DYNCREATE(CDataGroupScopeItem)

// Construction/Destruction
public:
	CDataGroupScopeItem();
	virtual ~CDataGroupScopeItem();

// Creation Members
public:
	virtual bool Create(CScopePane* pScopePane, CScopePaneItem* pParentItem);
	
// Results Pane View Members
public:
	virtual CResultsPaneView* CreateResultsPaneView();

// Component Id Members
public:
	int GetComponentId();
	void SetComponentId(int iComponentId);
protected:
	int m_iComponentId;

// MMC Notify Handlers
public:
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed);
  virtual HRESULT OnCommand(long lCommandID);
	virtual HRESULT OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle);
  virtual HRESULT OnSelect(CResultsPane* pPane,BOOL bSelected);

};

#endif // !defined(AFX_DATAGROUPSCOPEITEM_H__5CFA29BB_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\datagroupstatuslistener.cpp ===
// DataGroupStatusListener.cpp: implementation of the CDataGroupStatusListener class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "snapin.h"
#include "DataGroupStatusListener.h"
#include "HMDataGroupStatus.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CDataGroupStatusListener,CWbemEventListener)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataGroupStatusListener::CDataGroupStatusListener()
{
}

CDataGroupStatusListener::~CDataGroupStatusListener()
{
	Destroy();
}

/////////////////////////////////////////////////////////////////////////////
// Create/Destroy
/////////////////////////////////////////////////////////////////////////////

bool CDataGroupStatusListener::Create()
{
	TRACEX(_T("CDataGroupStatusListener::Create\n"));

	// first create the unsecured apartment
	HRESULT hr = S_OK;
  IWbemObjectSink* pSink = (IWbemObjectSink*)GetInterface(&IID_IWbemObjectSink);
  ASSERT(pSink);
	CString sSystemName = m_pHMObject->GetSystemName();

	if( s_pIUnsecApartment == NULL )
	{
		hr = CreateUnSecuredApartment();
		if( !GfxCheckPtr(s_pIUnsecApartment,IUnsecuredApartment) || !CHECKHRESULT(hr) )
		{
			TRACE(_T("FAILED : CDataGroupStatusListener::CreateUnSecuredApartment failed.\n"));
			return false;
		}
	}

	ASSERT(s_pIUnsecApartment);

	// second, create the stub sink for this listener's IWbemObjectSink
	IUnknown* pStubUnk = NULL;

	ASSERT(s_pIUnsecApartment);

	hr = s_pIUnsecApartment->CreateObjectStub(pSink, &pStubUnk);

	if( pStubUnk == NULL || !CHECKHRESULT(hr) )
	{
    TRACE(_T("FAILED : Failed to create Stub Sink!\n"));    
		return false;
	}

	ASSERT(pStubUnk);

	hr = pStubUnk->QueryInterface(IID_IWbemObjectSink, (LPVOID*)&m_pStubSink);
	pStubUnk->Release();

	if( !GfxCheckPtr(m_pStubSink,IWbemObjectSink) || !CHECKHRESULT(hr) )
	{
    TRACE(_T("FAILED : Failed to QI for IWbemObjectSink !\n"));		
    return false;
  }

  ASSERT(m_pStubSink);
	
	// third, call connection manager to execute the query
	CString sQuery;
	sQuery.Format(IDS_STRING_STATUS_QUERY_FMT,IDS_STRING_MOF_HMDG_STATUS,GetObjectPtr()->GetGuid());
	
  if( !CHECKHRESULT(hr = CnxExecQueryAsync(sSystemName,sQuery,m_pStubSink)) )
  {
    TRACE(_T("FAILED : CConnectionManager::RegisterEventNotification failed!\n"));
  }

	return true;
}

void CDataGroupStatusListener::Destroy()
{
	TRACEX(_T("CDataGroupStatusListener::Destroy\n"));

  if( m_pStubSink )			
  {
		CnxRemoveConnection(m_pHMObject->GetName(),m_pStubSink);
		m_pStubSink->Release();
    m_pStubSink = NULL;
  }

	if( s_lObjCount == 0 && s_pIUnsecApartment )
  {
		s_pIUnsecApartment->Release();
    s_pIUnsecApartment = NULL;
  }

}

//////////////////////////////////////////////////////////////////////
// Event Processing Members
//////////////////////////////////////////////////////////////////////

HRESULT CDataGroupStatusListener::ProcessEventClassObject(IWbemClassObject* pClassObject)
{
  ASSERT(pClassObject);
  if( pClassObject == NULL )
  {
    return E_FAIL;
  }
  
  HRESULT hr = S_OK;

	CHMDataGroupStatus dgs;

	if( ! CHECKHRESULT(hr = dgs.Create(pClassObject)) )
	{
		return hr;
	}

	dgs.m_sSystemName = GetObjectPtr()->GetSystemName();

	dgs.GetAllProperties();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\datagroupresultsview.h ===
// DataGroupResultsView.h: interface for the CDataGroupResultsView class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATAGROUPRESULTSVIEW_H__5CFA29C1_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_)
#define AFX_DATAGROUPRESULTSVIEW_H__5CFA29C1_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SplitPaneResultsView.h"

class CDataGroupResultsView : public CSplitPaneResultsView  
{
DECLARE_DYNCREATE(CDataGroupResultsView)

// Construction/Destruction
public:
	CDataGroupResultsView();
	virtual ~CDataGroupResultsView();

// Create/Destroy
public:
	virtual bool Create(CScopePaneItem* pOwnerItem);

};

#endif // !defined(AFX_DATAGROUPRESULTSVIEW_H__5CFA29C1_FBF4_11D2_BDCB_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\datapointeventcontainer.cpp ===
// DataPointEventContainer.cpp: implementation of the CDataPointEventContainer class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Snapin.h"
#include "DataPointEventContainer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CDataPointEventContainer,CEventContainer)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataPointEventContainer::CDataPointEventContainer()
{
	m_pDEStatsListener = NULL;
}

CDataPointEventContainer::~CDataPointEventContainer()
{
	if( m_pDEStatsListener )
	{
		delete m_pDEStatsListener;
		m_pDEStatsListener = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\datagroupscopeitem.cpp ===
// DataGroupScopeItem.cpp: implementation of the CDataGroupScopeItem class.
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03/22/00 v-marfin 61102 : Add new menu item "Data Collector" as a submenu and add all 
//                           subsequent menu items under it that used to be standalone.
// 03/22/00 v-marfin 59675 : Rearrange menu items for data group submenu.
// 04/07/00 v-marfin         Removed FTP menu item
//
#include "stdafx.h"
#include "snapin.h"
#include "DataGroupScopeItem.h"
#include "DataGroupResultsView.h"
#include "HealthmonScopePane.h"
#include "DataGroup.h"
#include "GroupGeneralPage.h"
#include "ActionAssociationPage.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// {75CEABD7-C04F-11d2-BD7E-0000F87A3912}
static GUID GUID_DataGroup = 
{ 0x75ceabd7, 0xc04f, 0x11d2, { 0xbd, 0x7e, 0x0, 0x0, 0xf8, 0x7a, 0x39, 0x12 } };

// icon table - associates state to icons
static UINT _Icons[][HMS_MAX_STATES] =
{
	{ //  0 = NULL

		IDI_ICON_COMPONENT,
		IDI_ICON_COMPONENT_DISABLED,
		IDI_ICON_COMPONENT_OUTAGE,
		IDI_ICON_COMPONENT_UNKNOWN,
		IDI_ICON_COMPONENT_NO_CONNECT,
		IDI_ICON_COMPONENT_WARNING,
		IDI_ICON_COMPONENT_CRITICAL
	},

	{ //  1 = PROCESSOR
		IDI_ICON_PROCESSOR,
		IDI_ICON_PROCESSOR_WARNING,
		IDI_ICON_PROCESSOR_CRITICAL,
		IDI_ICON_PROCESSOR_UNKNOWN,
		IDI_ICON_PROCESSOR_DISABLED
	},

	{ //  2 = MEMORY
		IDI_ICON_MEMORY,
		IDI_ICON_MEMORY_WARNING,
		IDI_ICON_MEMORY_CRITICAL,
		IDI_ICON_MEMORY_UNKNOWN,
		IDI_ICON_MEMORY_DISABLED
	},

	{ //  3 = PAGING FILE
		IDI_ICON_PAGINGFILE,
		IDI_ICON_PAGINGFILE_WARNING,
		IDI_ICON_PAGINGFILE_CRITICAL,
		IDI_ICON_PAGINGFILE_UNKNOWN,
		IDI_ICON_PAGINGFILE_DISABLED
	},

	{ //  4 = LOGICAL DISK
		IDI_ICON_LOGICALDISK,
		IDI_ICON_LOGICALDISK_WARNING,
		IDI_ICON_LOGICALDISK_CRITICAL,
		IDI_ICON_LOGICALDISK_UNKNOWN,
		IDI_ICON_LOGICALDISK_DISABLED
	},

	{ //  5 = PHYSICAL DISK
		IDI_ICON_PHYSICALDISK,
		IDI_ICON_PHYSICALDISK_WARNING,
		IDI_ICON_PHYSICALDISK_CRITICAL,
		IDI_ICON_PHYSICALDISK_UNKNOWN,
		IDI_ICON_PHYSICALDISK_DISABLED
	},

	{ //  6 = NIC
		IDI_ICON_NIC,
		IDI_ICON_NIC_WARNING,
		IDI_ICON_NIC_CRITICAL,
		IDI_ICON_NIC_UNKNOWN,
		IDI_ICON_NIC_DISABLED
	},

	{ //  7 = SERVERQUEUE
		IDI_ICON_SERVERQUEUE,
		IDI_ICON_SERVERQUEUE_WARNING,
		IDI_ICON_SERVERQUEUE_CRITICAL,
		IDI_ICON_SERVERQUEUE_UNKNOWN,
		IDI_ICON_SERVERQUEUE_DISABLED
	},

	{ //  8 = SECURITY
		IDI_ICON_SECURITY,
		IDI_ICON_SECURITY_WARNING,
		IDI_ICON_SECURITY_CRITICAL,
		IDI_ICON_SECURITY_UNKNOWN,
		IDI_ICON_SECURITY_DISABLED
	},

	{ //  9 = FAULT
		IDI_ICON_FAULT,
		IDI_ICON_FAULT_WARNING,
		IDI_ICON_FAULT_CRITICAL,
		IDI_ICON_FAULT_UNKNOWN,
		IDI_ICON_FAULT_DISABLED
	},

	{ //  10 = SQLSERVER
		IDI_ICON_SQLSERVER,
		IDI_ICON_SQLSERVER_WARNING,
		IDI_ICON_SQLSERVER_CRITICAL,
		IDI_ICON_SQLSERVER_UNKNOWN,
		IDI_ICON_SQLSERVER_DISABLED
	},

	{ //  11 = IIS
		IDI_ICON_IIS,
		IDI_ICON_IIS_WARNING,
		IDI_ICON_IIS_CRITICAL,
		IDI_ICON_IIS_UNKNOWN,
		IDI_ICON_IIS_DISABLED
	},

	{ //  12 = EXCHANGE
		IDI_ICON_EXCHANGE,
		IDI_ICON_EXCHANGE_WARNING,
		IDI_ICON_EXCHANGE_CRITICAL,
		IDI_ICON_EXCHANGE_UNKNOWN,
		IDI_ICON_EXCHANGE_DISABLED
	},

	{ //  13 = SNA
		IDI_ICON_SNA,
		IDI_ICON_SNA_WARNING,
		IDI_ICON_SNA_CRITICAL,
		IDI_ICON_SNA_UNKNOWN,
		IDI_ICON_SNA_DISABLED
	},

	{ //  14 = SMS
		IDI_ICON_SMS,
		IDI_ICON_SMS_WARNING,
		IDI_ICON_SMS_CRITICAL,
		IDI_ICON_SMS_UNKNOWN,
		IDI_ICON_SMS_DISABLED
	}
};


IMPLEMENT_DYNCREATE(CDataGroupScopeItem,CHMScopeItem)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataGroupScopeItem::CDataGroupScopeItem()
{
	m_lpguidItemType = &GUID_DataGroup;
	m_iComponentId = 0;
}

CDataGroupScopeItem::~CDataGroupScopeItem()
{
	Destroy();
}

//////////////////////////////////////////////////////////////////////
// Creation Members
//////////////////////////////////////////////////////////////////////

bool CDataGroupScopeItem::Create(CScopePane* pScopePane, CScopePaneItem* pParentItem)
{
	TRACEX(_T("CDataGroupScopeItem::Create\n"));
	TRACEARGn(pScopePane);
	TRACEARGn(pParentItem);

	// call base class Create method
	if( ! CHMScopeItem::Create(pScopePane,pParentItem) )
	{
		TRACE(_T("CHMScopeItem::Create failed.\n"));
		return false;
	}

	SetComponentId(0);

	return true;
}

//////////////////////////////////////////////////////////////////////	
// Results Pane View Members
//////////////////////////////////////////////////////////////////////

CResultsPaneView* CDataGroupScopeItem::CreateResultsPaneView()
{	
	TRACEX(_T("CDataGroupScopeItem::CreateResultsPaneView\n"));

	return new CDataGroupResultsView;
}

//////////////////////////////////////////////////////////////////////	
// Component Id Members
//////////////////////////////////////////////////////////////////////	

int CDataGroupScopeItem::GetComponentId()
{
	return m_iComponentId;
}

void CDataGroupScopeItem::SetComponentId(int iComponentId)
{
	m_iComponentId = iComponentId;	

	for( int i = 0; i < HMS_MAX_STATES; i++ )
	{
		UINT nId = _Icons[iComponentId][i];
		m_IconResIds.Add(nId);
		m_OpenIconResIds.Add(nId);
	}

	SetIconIndex(HMS_NORMAL);
	SetOpenIconIndex(HMS_NORMAL);
}


//////////////////////////////////////////////////////////////////////	
// MMC Notify Handlers
//////////////////////////////////////////////////////////////////////	

HRESULT CDataGroupScopeItem::OnAddMenuItems(LPCONTEXTMENUCALLBACK piCallback,long __RPC_FAR *pInsertionAllowed)
{
	TRACEX(_T("CDataGroupScopeItem::OnAddMenuItems\n"));
	TRACEARGn(piCallback);
	TRACEARGn(pInsertionAllowed);

  HRESULT hr = S_OK;

  // Add New Menu Items
  if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    // Data Group...
    sResString.LoadString(IDS_STRING_NEW_COMPONENT);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_NEW_COMPONENT_DESCRIPTION);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_NEW_DATA_GROUP;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }


    //----------------------------------------------------------------------------------------
    // v-marfin 61102 : Add new menu item as a submenu and add all subsequent menu items under it
    // Data Collector
    sResString.LoadString(IDS_STRING_NEW_DATA_COLLECTOR);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_NEW_DATA_COLLECTOR_DESC);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_NEW_DATA_COLLECTOR;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
	cmi.fFlags            = MF_POPUP;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }


	// Windows NT Performance Counter
    sResString.LoadString(IDS_STRING_PERFMON);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_PERFMON_DESC);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_PERFMON;
	cmi.lInsertionPointID = IDM_NEW_DATA_COLLECTOR; // use lCommandID of the submenu "Data Collector" above;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }



	// Service
    sResString.LoadString(IDS_STRING_SERVICE);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_SERVICE_DESC);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_SERVICE;
	cmi.lInsertionPointID = IDM_NEW_DATA_COLLECTOR; // use lCommandID of the submenu "Data Collector" above;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }



	// NT Events
    sResString.LoadString(IDS_STRING_NT_EVENTS);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_EVENTLOG_DESC);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_NT_EVENTS;
	cmi.lInsertionPointID = IDM_NEW_DATA_COLLECTOR; // use lCommandID of the submenu "Data Collector" above;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }



	// COM+ Application
    sResString.LoadString(IDS_STRING_COM_PLUS);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_COM_PLUS_DESC);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_COM_PLUS;
	cmi.lInsertionPointID = IDM_NEW_DATA_COLLECTOR; // use lCommandID of the submenu "Data Collector" above;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }


	// File Information
    sResString.LoadString(IDS_STRING_FILE_INFORMATION);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_FILEINFO_DESC);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_FILE_INFO;
	cmi.lInsertionPointID = IDM_NEW_DATA_COLLECTOR; // use lCommandID of the submenu "Data Collector" above;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }


	// Separator
	cmi.strName           = NULL;
	cmi.strStatusBarText  = NULL;
	cmi.lCommandID        = 0;
	cmi.lInsertionPointID = IDM_NEW_DATA_COLLECTOR; // use lCommandID of the submenu "Data Collector" above;
	cmi.fFlags            = MF_SEPARATOR;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }


	// HTTP Address
    sResString.LoadString(IDS_STRING_HTTP_ADDRESS);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_HTTP_DESC);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_HTTP_ADDRESS;
	cmi.lInsertionPointID = IDM_NEW_DATA_COLLECTOR; // use lCommandID of the submenu "Data Collector" above;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }



	// ICMP
    sResString.LoadString(IDS_STRING_ICMP);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ICMP_DESC);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_ICMP;
	cmi.lInsertionPointID = IDM_NEW_DATA_COLLECTOR; // use lCommandID of the submenu "Data Collector" above;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }



	// v-marfin : Removed FTP
    /*sResString.LoadString(IDS_STRING_FTP);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_FTP_DESC);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_FTP;
	cmi.lInsertionPointID = IDM_NEW_DATA_COLLECTOR; // use lCommandID of the submenu "Data Collector" above;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }*/



	// SMTP
    sResString.LoadString(IDS_STRING_SMTP);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_SMTP_DESC);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_SMTP;
	cmi.lInsertionPointID = IDM_NEW_DATA_COLLECTOR; // use lCommandID of the submenu "Data Collector" above;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }



	// Separator
	cmi.strName           = NULL;
	cmi.strStatusBarText  = NULL;
	cmi.lCommandID        = 0;
	cmi.lInsertionPointID = IDM_NEW_DATA_COLLECTOR; // use lCommandID of the submenu "Data Collector" above;
	cmi.fFlags            = MF_SEPARATOR;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }



	// Generic WMI Instance
    sResString.LoadString(IDS_STRING_GENERIC_WMI_INSTANCE);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_WMI_INSTANCE_DESC);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_GENERIC_WMI_INSTANCE;
	cmi.lInsertionPointID = IDM_NEW_DATA_COLLECTOR; // use lCommandID of the submenu "Data Collector" above;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

	// Generic WMI Event Query
    sResString.LoadString(IDS_STRING_GENERIC_WMI_QUERY);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_WMI_EVTQUERY_DESC);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_GENERIC_WMI_QUERY;
	cmi.lInsertionPointID = IDM_NEW_DATA_COLLECTOR; // use lCommandID of the submenu "Data Collector" above;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }



	// Generic WMI Data Query
    sResString.LoadString(IDS_STRING_GENERIC_WMI_POLLED_QUERY);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_WMI_QUERY_DESC);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_GENERIC_WMI_POLLED_QUERY;
	cmi.lInsertionPointID = IDM_NEW_DATA_COLLECTOR; // use lCommandID of the submenu "Data Collector" above;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }



/*
		// SNMP
    sResString.LoadString(IDS_STRING_SNMP);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
		cmi.strStatusBarText  = NULL;
		cmi.lCommandID        = IDM_SNMP;
		cmi.lInsertionPointID = IDM_NEW_DATA_COLLECTOR; // use lCommandID of the submenu "Data Collector" above;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
*/
    //----------------------------------------------------------------------------------------



    // Original menu items below





	}

  // Add Task Menu Items
  if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_CLEAR_EVENTS);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_CLEAR_EVENTS_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_CLEAR_EVENTS;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }


	// Reset Statistics
    sResString.LoadString(IDS_STRING_RESET_STATISTICS);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_RESET_STATISTICS_DESC);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_RESET_STATISTICS;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }


    // v-marfin : 59675 : Rearrange menu items
	// separator
	cmi.strName           = NULL;
	cmi.strStatusBarText  = NULL;
	cmi.lCommandID        = NULL;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	cmi.fFlags            = MF_SEPARATOR;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }


    // Reset Status
    sResString.LoadString(IDS_STRING_RESET_STATUS);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_RESET_STATUS_DESCRIPTION);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_RESET_STATUS;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }


	// check now
    sResString.LoadString(IDS_STRING_CHECK_NOW);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_CHECK_NOW_DESC);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_CHECK_NOW;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	cmi.fFlags            = 0;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }


	// separator
	cmi.strName           = NULL;
	cmi.strStatusBarText  = NULL;
	cmi.lCommandID        = NULL;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	cmi.fFlags            = MF_SEPARATOR;
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }



	// Disabled
    sResString.LoadString(IDS_STRING_ENABLE_ALL_THRESHOLDS);
	cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ENABLE_ALL_THRESHOLDS_DESCRIPTION);
	cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
	cmi.lCommandID        = IDM_DISABLE_MONITORING;
	cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	CHMObject* pObject = GetObjectPtr();
    CHMScopeItem* pParentItem = (CHMScopeItem*)GetParent();        

    // disable menu item if null object ptr or parent is disabled
	if( ! pObject || (pParentItem && pParentItem->GetObjectPtr()
                  && !pParentItem->GetObjectPtr()->IsEnabled()) )
	{
		cmi.fFlags = MF_DISABLED|MF_GRAYED;
	}
	else
	{
		int iState = pObject->IsEnabled();
		if( iState == -1 )
		{
			cmi.fFlags = MF_DISABLED|MF_GRAYED;
		}
		else if( iState == 0 )
		{
			cmi.fFlags = MF_CHECKED;
		}
		else if( iState == 1 )
		{
			cmi.fFlags = MF_UNCHECKED;
		}
	}
	cmi.fSpecialFlags     = 0;

	hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

  }

  // Add View Menu Items
  if( CCM_INSERTIONALLOWED_VIEW & *pInsertionAllowed )
  {
		CONTEXTMENUITEM cmi;
    CString sResString;
    CString sResString2;

    sResString.LoadString(IDS_STRING_STATUS_ONLY);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_STATUS_ONLY_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_STATUS_ONLY;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_UNCHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    sResString.LoadString(IDS_STRING_AUTO_FILTER);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_AUTO_FILTER_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_AUTO_FILTER;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = MF_CHECKED;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }

    // icon legend
    sResString.LoadString(IDS_STRING_ICON_LEGEND);
		cmi.strName           = LPTSTR(LPCTSTR(sResString));
    sResString2.LoadString(IDS_STRING_ICON_LEGEND_DESCRIPTION);
		cmi.strStatusBarText  = LPTSTR(LPCTSTR(sResString2));
		cmi.lCommandID        = IDM_ICON_LEGEND;
		cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		cmi.fFlags            = 0;
		cmi.fSpecialFlags     = 0;

		hr = piCallback->AddItem(&cmi);
    if( !SUCCEEDED(hr) )
    {
      TRACE(_T("FAILED : IContextMenuCallback::AddItem failed.\n"));
      return hr;
    }
  }

	return hr;
}

HRESULT CDataGroupScopeItem::OnCommand(long lCommandID)
{
	TRACEX(_T("CDataGroupScopeItem::OnCommand\n"));
	TRACEARGn(lCommandID);

  HRESULT hr = S_OK;

	CHealthmonScopePane* pPane = (CHealthmonScopePane*)GetScopePane();
	if( ! GfxCheckObjPtr(pPane,CHealthmonScopePane) )
	{
		TRACE(_T("FAILED : CDataGroupScopeItem::GetScopePane returns an invalid pointer.\n"));
		return E_FAIL;
	}


	switch(lCommandID)
	{
		case IDM_NEW_DATA_GROUP:
		{
			CDataGroup* pDataGroup = (CDataGroup*)GetObjectPtr();
			if( ! GfxCheckObjPtr(pDataGroup,CDataGroup) )
			{
				return E_FAIL;
			}

			pDataGroup->CreateNewChildDataGroup();			
		}
		break;
		
		case IDM_SNMP:
		{
			AfxMessageBox(IDS_ERR_FEATURE_NOT_IMPLEMENTED);
		}
		break;

		case IDM_HTTP_ADDRESS:
		case IDM_NT_EVENTS:
		case IDM_PERFMON:
		case IDM_SERVICE:
		case IDM_GENERIC_WMI_INSTANCE:
		case IDM_GENERIC_WMI_QUERY:
		case IDM_GENERIC_WMI_POLLED_QUERY:
		case IDM_FTP:
		case IDM_SMTP:
		case IDM_FILE_INFO:
		case IDM_ICMP:
    case IDM_COM_PLUS:
		{
			CDataGroup* pDataGroup = (CDataGroup*)GetObjectPtr();
			if( ! GfxCheckObjPtr(pDataGroup,CDataGroup) )
			{
				return E_FAIL;
			}

			pDataGroup->CreateNewChildDataElement(lCommandID);
		}
		break;
/*
		case IDM_EXPORT:
		{
			CString sFilter;
			sFilter.LoadString(IDS_STRING_MOF_FILTER);
			CFileDialog fd(FALSE,_T("MOF"),NULL,OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT,sFilter);

			if( fd.DoModal() == IDOK )
			{
				CFile file;
				if( ! file.Open(fd.GetPathName(),CFile::modeCreate|CFile::modeWrite|CFile::shareExclusive|CFile::typeText) )
				{
					return S_OK;
				}

				CArchive ar(&file,CArchive::store);
				CHMObject* pObject = GetObjectPtr();
				if( pObject )
				{
					pObject->ExportMofFile(ar);
				}
			}
		}
		break;
*/
		default:
		{
			hr = CHMScopeItem::OnCommand(lCommandID);
		}

	}

  return hr;
}

HRESULT CDataGroupScopeItem::OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, INT_PTR handle)
{
	TRACEX(_T("CDataGroupScopeItem::OnCreatePropertyPages\n"));
	TRACEARGn(lpProvider);
	TRACEARGn(handle);

	if( m_pScopePane == NULL )
	{
		return S_FALSE;
	}

	CDataGroup* pGroup = (CDataGroup*)GetObjectPtr();
	if( ! GfxCheckObjPtr(pGroup,CDataGroup) )
	{
		return E_FAIL;
	}
	
	HRESULT hr = S_OK;

	CGroupGeneralPage* pPage1 = new CGroupGeneralPage;

	pPage1->SetObjectPtr(pGroup);

  HPROPSHEETPAGE hPage1 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage1->m_psp) );

  hr = lpProvider->AddPage(hPage1);

	CActionAssociationPage* pPage2 = new CActionAssociationPage;

	//---------------------------------------------------------------------------------------------
	// v-marfin 62192 : by default the action property page will load its threshold action help.
	//                  so we will override since this is a data group being shown properties, not
	//                  a threshold.
	pPage2->m_sHelpTopic = _T("HMon21.chm::/dDGact.htm");  // v-marfin 62192 : help link fix
	//----------------------------------------------------------------------------------------------


	pPage2->SetObjectPtr(GetObjectPtr());
	
  HPROPSHEETPAGE hPage2 = CreatePropertySheetPage( reinterpret_cast<LPCPROPSHEETPAGE>(&pPage2->m_psp) );

  hr = lpProvider->AddPage(hPage2);

	return hr;
}

HRESULT CDataGroupScopeItem::OnSelect(CResultsPane* pPane, BOOL bSelected)
{
	TRACEX(_T("CDataGroupScopeItem::OnSelect\n"));
	TRACEARGn(pPane);
	TRACEARGn(bSelected);

	if( ! CHECKHRESULT(CHMScopeItem::OnSelect(pPane,bSelected)) )
	{
		TRACE(_T("FAILED : CHMScopeItem::OnSelect returns failure.\n"));
		return E_FAIL;
	}

	if( ! bSelected ) // we are being de-selected so do not do anything
	{
		return S_OK;
	}

	LPCONSOLEVERB lpConsoleVerb = pPane->GetConsoleVerbPtr();

  HRESULT hr = lpConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_RENAME, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_CUT, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}
	
  hr = lpConsoleVerb->SetVerbState( MMC_VERB_COPY, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_PASTE, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}

  hr = lpConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );
	if( ! CHECKHRESULT(hr) )
	{
		TRACE(_T("FAILED : IConsoleVerb::SetVerbState failed.\n"));
		lpConsoleVerb->Release();
		return hr;
	}
	
	lpConsoleVerb->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\datapointeventcontainer.h ===
// DataPointEventContainer.h: interface for the CDataPointEventContainer class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATAPOINTEVENTCONTAINER_H__C65C8863_9484_11D3_93A7_00A0CC406605__INCLUDED_)
#define AFX_DATAPOINTEVENTCONTAINER_H__C65C8863_9484_11D3_93A7_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "EventContainer.h"
#include "DataElementStatsListener.h"

class CDataPointEventContainer : public CEventContainer  
{

DECLARE_DYNCREATE(CDataPointEventContainer)

// Construction/Destruction
public:
	CDataPointEventContainer();
	virtual ~CDataPointEventContainer();

// Stats Listener
public:
	CDataElementStatsListener* m_pDEStatsListener;

};

#endif // !defined(AFX_DATAPOINTEVENTCONTAINER_H__C65C8863_9484_11D3_93A7_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\disablethresholddlg.cpp ===
// DisableThresholdDlg.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "DisableThresholdDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDisableThresholdDlg dialog


CDisableThresholdDlg::CDisableThresholdDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDisableThresholdDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDisableThresholdDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDisableThresholdDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDisableThresholdDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDisableThresholdDlg, CDialog)
	//{{AFX_MSG_MAP(CDisableThresholdDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDisableThresholdDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\datapointstatistics.inl ===
// 04/09/00 v-marfin 63119 : converted m_iCurrent to string

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Equivalency operator
//////////////////////////////////////////////////////////////////////

inline int CDataPointStatistics::CompareTo(CStatistics* pStat)
{
	CDataPointStatistics* pDPStat = (CDataPointStatistics*)pStat;

	CTime time1 = m_st;
	CTime time2 = pDPStat->m_st;

	return	time1 == time2 && 
					m_sPropertyName == pDPStat->m_sPropertyName &&
					m_sInstanceName == pDPStat->m_sInstanceName &&
					// 63119 m_iCurrent == pDPStat->m_iCurrent &&
                    m_strCurrent == pDPStat->m_strCurrent && // 63119
					m_iMin == pDPStat->m_iMin &&
					m_iMax == pDPStat->m_iMax &&
					m_iAvg == pDPStat->m_iAvg;
}

//////////////////////////////////////////////////////////////////////
// Copy
//////////////////////////////////////////////////////////////////////

inline CStatistics* CDataPointStatistics::Copy()
{
	CDataPointStatistics* pCopy = new CDataPointStatistics;
	CopyMemory(&(pCopy->m_st),&m_st,sizeof(SYSTEMTIME));
	pCopy->m_sPropertyName = m_sPropertyName;
	pCopy->m_sInstanceName = m_sInstanceName;

	// 63119 pCopy->m_iCurrent = m_iCurrent;
    pCopy->m_strCurrent = m_strCurrent; // 63119 

	pCopy->m_iMin = m_iMin;
	pCopy->m_iMax = m_iMax;
	pCopy->m_iAvg = m_iAvg;
	return pCopy;
}

//////////////////////////////////////////////////////////////////////
// Result Pane Item Members
//////////////////////////////////////////////////////////////////////

inline CHMEventResultsPaneItem* CDataPointStatistics::CreateResultsPaneItem(CResultsPaneView* pView)
{
	ASSERT(pView);
	if( ! pView )
	{
		return NULL;
	}

	CHMEventResultsPaneItem* pItem = new CHMEventResultsPaneItem;
	pItem->SetDateTimeColumn(7);

	CStringArray saNames;
	CUIntArray uiaIconResIds;
	CString sValue;

	saNames.Add(m_sPropertyName);

	saNames.Add(m_sInstanceName);

	/* 63119 sValue.Format(_T("%d"),m_iCurrent);
	saNames.Add(sValue);*/
    saNames.Add(m_strCurrent); // 63119


	sValue.Format(_T("%d"),m_iMin);
	saNames.Add(sValue);

	sValue.Format(_T("%d"),m_iMax);
	saNames.Add(sValue);

	sValue.Format(_T("%d"),m_iAvg);
	saNames.Add(sValue);

	saNames.Add(GetStatLocalTime());

	pItem->m_st = m_st;
			
	pItem->SetDisplayNames(saNames);
	pItem->SetToStatsPane();

	pItem->Create(pView);

	return pItem;
}

inline void CDataPointStatistics::SetResultsPaneItem(CHMEventResultsPaneItem* pItem)
{
	CStringArray saNames;
	CUIntArray uiaIconResIds;
	CString sValue;


	saNames.Add(m_sPropertyName);

	saNames.Add(m_sInstanceName);

	/* 63119 sValue.Format(_T("%d"),m_iCurrent);
	saNames.Add(sValue);*/
    saNames.Add(m_strCurrent); // 63119 

	sValue.Format(_T("%d"),m_iMin);
	saNames.Add(sValue);

	sValue.Format(_T("%d"),m_iMax);
	saNames.Add(sValue);

	sValue.Format(_T("%d"),m_iAvg);
	saNames.Add(sValue);

	saNames.Add(GetStatLocalTime());

	pItem->m_st = m_st;
			
	pItem->SetDisplayNames(saNames);
}

//////////////////////////////////////////////////////////////////////
// Graph Members
//////////////////////////////////////////////////////////////////////

inline void CDataPointStatistics::UpdateGraph(_DHMGraphView* pGraphView)
{
	// v-marfin : Graph view is removed so comment this out to assist 
	//            in debugging without having to deal with the assert all the time
	//ASSERT(pGraphView);
	
    /* 63119 if( ! pGraphView )
	{
		return;
	}

	long lStyle = pGraphView->GetStyle();
	ASSERT(lStyle & HMGVS_ELEMENT);
	if( lStyle & HMGVS_CURRENT )
	{
		pGraphView->InsertCurrentElementStats(m_sPropertyName,
																					m_sInstanceName,
																					m_iCurrent,
																					m_iMin,
																					m_iMax,
																					m_iAvg);
	}

	if( lStyle & HMGVS_HISTORIC )
	{
		CString sLocalTime = GetStatLocalTime();
		int iIndex = sLocalTime.Find(_T(" "));
		if( iIndex != -1 )
		{
			sLocalTime = sLocalTime.Right(sLocalTime.GetLength()-iIndex-1);
		}

		pGraphView->InsertHistoricElementStats( m_sPropertyName,
																						m_sInstanceName,
																						sLocalTime,
																						m_iCurrent);
	}*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\datapointstatistics.h ===
// DataPointStatistics.h: interface for the CDataPointStatistics class.
//
//////////////////////////////////////////////////////////////////////
// 04/09/00 v-marfin 63119 : converted m_iCurrent to string



#if !defined(AFX_DATAPOINTSTATISTICS_H__C65C8864_9484_11D3_93A7_00A0CC406605__INCLUDED_)
#define AFX_DATAPOINTSTATISTICS_H__C65C8864_9484_11D3_93A7_00A0CC406605__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Statistics.h"

class CDataPointStatistics : public CStatistics  
{

DECLARE_DYNCREATE(CDataPointStatistics)

// Construction/Destruction
public:
	CDataPointStatistics();
	virtual ~CDataPointStatistics();

// Statistic Information
public:
	CString m_sPropertyName;
	CString m_sInstanceName;

	// 63119 int m_iCurrent;	
    CString m_strCurrent;  // 63119

	int m_iMin;
	int m_iMax;
	int m_iAvg;

// Result Pane Item Members
public:
	virtual CHMEventResultsPaneItem* CreateResultsPaneItem(CResultsPaneView* pView);
	virtual void SetResultsPaneItem(CHMEventResultsPaneItem* pItem);

// Graph Members
public:
	virtual void UpdateGraph(_DHMGraphView* pGraphView);

// CompareTo
public:
	virtual int CompareTo(CStatistics* pStat);

// Copy
public:
	virtual CStatistics* Copy();

};

#include "DataPointStatistics.inl"

#endif // !defined(AFX_DATAPOINTSTATISTICS_H__C65C8864_9484_11D3_93A7_00A0CC406605__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\debug.cpp ===
////////////////////////////////////////////////////////////////
//
// General purpose debugging utilities
// 
#include "StdAfx.h"
#include "Debug.h"
#include <afxpriv.h>	// for MFC WM_ messages

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;

int CTraceEx::nIndent=-1;	    // current indent level

#define _countof(array) (sizeof(array)/sizeof(array[0]))

////////////////
// These functions are copied from dumpout.cpp in the MFC source,
// with my modification to do indented TRACEing
//
void AFXAPI AfxDump(const CObject* pOb)
{
	afxDump << pOb;
}

void AFX_CDECL AfxTrace(LPCTSTR lpszFormat, ...)
{
#ifdef _DEBUG // all AfxTrace output is controlled by afxTraceEnabled
	if (!afxTraceEnabled)
		return;
#endif

	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	TCHAR szBuffer[512];

	nBuf = _vstprintf(szBuffer, lpszFormat, args);
	ASSERT(nBuf < _countof(szBuffer));

	// PD: Here are my added lines to do the indenting. Search
	// for newlines and insert prefix before each one. Yawn.
	//
	static BOOL bStartNewLine = TRUE;
	TCHAR* nextline;
	for (TCHAR* start = szBuffer; *start; start=nextline+1)
	{
		if (bStartNewLine)
		{
			if ((afxTraceFlags & traceMultiApp) && (AfxGetApp() != NULL))
			{
				afxDump << AfxGetApp()->m_pszExeName << _T(": ");
			}
			afxDump << CString(_T(' '),CTraceEx::nIndent*2);
			bStartNewLine = FALSE;
		}
		nextline = _tcschr(start, _T('\n'));
		if (nextline)
		{
			*nextline = 0; // terminate string at newline
			bStartNewLine = TRUE;
		}
		afxDump << start;
		if (!nextline)
			break;
		afxDump << _T("\n"); // the one I terminated
	}
		
	va_end(args);
}

//////////////////
// Get window name in the form classname[HWND,title]
// Searches all the parents for a window with a title.
//
CString sDbgName(CWnd* pWnd)
{
	CString sTitle;
	HWND hwnd = pWnd->GetSafeHwnd();
	if (hwnd==NULL)
	{
		sTitle = _T("NULL");
	}
	else if (!::IsWindow(hwnd))
	{
		sTitle = _T("[bad window]");
	}
	else
	{
		sTitle = _T("[no title]");
		for (CWnd* pw = pWnd; pw; pw = pw->GetParent())
		{
			if (pw->GetWindowTextLength() > 0)
			{
				pw->GetWindowText(sTitle);
				break;
			}
		}
	}
	CString s;
	CString s2;
	USES_CONVERSION;
	s2 = pWnd ? A2T(pWnd->GetRuntimeClass()->m_lpszClassName) : _T("NULL");

	s.Format(_T("%s[0x%04x,\"%s\"]"), s2,	hwnd, (LPCTSTR)sTitle);
	return s;
}

struct {
	UINT		msg;
	LPCTSTR	name;
} MsgData[] = {
	{ WM_CREATE,_T("WM_CREATE") },
	{ WM_DESTROY,_T("WM_DESTROY") },
	{ WM_MOVE,_T("WM_MOVE") },
	{ WM_SIZE,_T("WM_SIZE") },
	{ WM_ACTIVATE,_T("WM_ACTIVATE") },
	{ WM_SETFOCUS,_T("WM_SETFOCUS") },
	{ WM_KILLFOCUS,_T("WM_KILLFOCUS") },
	{ WM_ENABLE,_T("WM_ENABLE") },
	{ WM_SETREDRAW,_T("WM_SETREDRAW") },
	{ WM_SETTEXT,_T("WM_SETTEXT") },
	{ WM_GETTEXT,_T("WM_GETTEXT") },
	{ WM_GETTEXTLENGTH,_T("WM_GETTEXTLENGTH") },
	{ WM_PAINT,_T("WM_PAINT") },
	{ WM_CLOSE,_T("WM_CLOSE") },
	{ WM_QUERYENDSESSION,_T("WM_QUERYENDSESSION") },
	{ WM_QUIT,_T("WM_QUIT") },
	{ WM_QUERYOPEN,_T("WM_QUERYOPEN") },
	{ WM_ERASEBKGND,_T("WM_ERASEBKGND") },
	{ WM_SYSCOLORCHANGE,_T("WM_SYSCOLORCHANGE") },
	{ WM_ENDSESSION,_T("WM_ENDSESSION") },
	{ WM_SHOWWINDOW,_T("WM_SHOWWINDOW") },
	{ WM_WININICHANGE,_T("WM_WININICHANGE") },
	{ WM_SETTINGCHANGE,_T("WM_SETTINGCHANGE") },
	{ WM_DEVMODECHANGE,_T("WM_DEVMODECHANGE") },
	{ WM_ACTIVATEAPP,_T("WM_ACTIVATEAPP") },
	{ WM_FONTCHANGE,_T("WM_FONTCHANGE") },
	{ WM_TIMECHANGE,_T("WM_TIMECHANGE") },
	{ WM_CANCELMODE,_T("WM_CANCELMODE") },
	{ WM_SETCURSOR,_T("WM_SETCURSOR") },
	{ WM_MOUSEACTIVATE,_T("WM_MOUSEACTIVATE") },
	{ WM_CHILDACTIVATE,_T("WM_CHILDACTIVATE") },
	{ WM_QUEUESYNC,_T("WM_QUEUESYNC") },
	{ WM_GETMINMAXINFO,_T("WM_GETMINMAXINFO") },
	{ WM_PAINTICON,_T("WM_PAINTICON") },
	{ WM_ICONERASEBKGND,_T("WM_ICONERASEBKGND") },
	{ WM_NEXTDLGCTL,_T("WM_NEXTDLGCTL") },
	{ WM_SPOOLERSTATUS,_T("WM_SPOOLERSTATUS") },
	{ WM_DRAWITEM,_T("WM_DRAWITEM") },
	{ WM_MEASUREITEM,_T("WM_MEASUREITEM") },
	{ WM_DELETEITEM,_T("WM_DELETEITEM") },
	{ WM_VKEYTOITEM,_T("WM_VKEYTOITEM") },
	{ WM_CHARTOITEM,_T("WM_CHARTOITEM") },
	{ WM_SETFONT,_T("WM_SETFONT") },
	{ WM_GETFONT,_T("WM_GETFONT") },
	{ WM_SETHOTKEY,_T("WM_SETHOTKEY") },
	{ WM_GETHOTKEY,_T("WM_GETHOTKEY") },
	{ WM_QUERYDRAGICON,_T("WM_QUERYDRAGICON") },
	{ WM_COMPAREITEM,_T("WM_COMPAREITEM") },
	{ WM_COMPACTING,_T("WM_COMPACTING") },
	{ WM_COMMNOTIFY,_T("WM_COMMNOTIFY") },
	{ WM_WINDOWPOSCHANGING,_T("WM_WINDOWPOSCHANGING") },
	{ WM_WINDOWPOSCHANGED,_T("WM_WINDOWPOSCHANGED") },
	{ WM_POWER,_T("WM_POWER") },
	{ WM_COPYDATA,_T("WM_COPYDATA") },
	{ WM_CANCELJOURNAL,_T("WM_CANCELJOURNAL") },
#if(WINVER >= 0x0400)
	{ WM_NOTIFY,_T("WM_NOTIFY") },
	{ WM_INPUTLANGCHANGEREQUEST,_T("WM_INPUTLANGCHANGEREQUEST") },
	{ WM_INPUTLANGCHANGE,_T("WM_INPUTLANGCHANGE") },
	{ WM_TCARD,_T("WM_TCARD") },
	{ WM_HELP,_T("WM_HELP") },
	{ WM_USERCHANGED,_T("WM_USERCHANGED") },
	{ WM_NOTIFYFORMAT,_T("WM_NOTIFYFORMAT") },
	{ WM_CONTEXTMENU,_T("WM_CONTEXTMENU") },
	{ WM_STYLECHANGING,_T("WM_STYLECHANGING") },
	{ WM_STYLECHANGED,_T("WM_STYLECHANGED") },
	{ WM_DISPLAYCHANGE,_T("WM_DISPLAYCHANGE") },
	{ WM_GETICON,_T("WM_GETICON") },
	{ WM_SETICON,_T("WM_SETICON") },
#endif /* WINVER >= 0x0400 */
	{ WM_NCCREATE,_T("WM_NCCREATE") },
	{ WM_NCDESTROY,_T("WM_NCDESTROY") },
	{ WM_NCCALCSIZE,_T("WM_NCCALCSIZE") },
	{ WM_NCHITTEST,_T("WM_NCHITTEST") },
	{ WM_NCPAINT,_T("WM_NCPAINT") },
	{ WM_NCACTIVATE,_T("WM_NCACTIVATE") },
	{ WM_GETDLGCODE,_T("WM_GETDLGCODE") },
	{ WM_NCMOUSEMOVE,_T("WM_NCMOUSEMOVE") },
	{ WM_NCLBUTTONDOWN,_T("WM_NCLBUTTONDOWN") },
	{ WM_NCLBUTTONUP,_T("WM_NCLBUTTONUP") },
	{ WM_NCLBUTTONDBLCLK,_T("WM_NCLBUTTONDBLCLK") },
	{ WM_NCRBUTTONDOWN,_T("WM_NCRBUTTONDOWN") },
	{ WM_NCRBUTTONUP,_T("WM_NCRBUTTONUP") },
	{ WM_NCRBUTTONDBLCLK,_T("WM_NCRBUTTONDBLCLK") },
	{ WM_NCMBUTTONDOWN,_T("WM_NCMBUTTONDOWN") },
	{ WM_NCMBUTTONUP,_T("WM_NCMBUTTONUP") },
	{ WM_NCMBUTTONDBLCLK,_T("WM_NCMBUTTONDBLCLK") },
	{ WM_KEYDOWN,_T("WM_KEYDOWN") },
	{ WM_KEYUP,_T("WM_KEYUP") },
	{ WM_CHAR,_T("WM_CHAR") },
	{ WM_DEADCHAR,_T("WM_DEADCHAR") },
	{ WM_SYSKEYDOWN,_T("WM_SYSKEYDOWN") },
	{ WM_SYSKEYUP,_T("WM_SYSKEYUP") },
	{ WM_SYSCHAR,_T("WM_SYSCHAR") },
	{ WM_SYSDEADCHAR,_T("WM_SYSDEADCHAR") },
	{ WM_KEYDOWN,_T("WM_KEYDOWN") },
	{ WM_KEYUP,_T("WM_KEYUP") },
	{ WM_CHAR,_T("WM_CHAR") },
	{ WM_DEADCHAR,_T("WM_DEADCHAR") },
	{ WM_SYSKEYDOWN,_T("WM_SYSKEYDOWN") },
	{ WM_SYSKEYUP,_T("WM_SYSKEYUP") },
	{ WM_SYSCHAR,_T("WM_SYSCHAR") },
	{ WM_SYSDEADCHAR,_T("WM_SYSDEADCHAR") },
#if(WINVER >= 0x0400)
	{ WM_IME_STARTCOMPOSITION,_T("WM_IME_STARTCOMPOSITION") },
	{ WM_IME_ENDCOMPOSITION,_T("WM_IME_ENDCOMPOSITION") },
	{ WM_IME_COMPOSITION,_T("WM_IME_COMPOSITION") },
	{ WM_IME_KEYLAST,_T("WM_IME_KEYLAST") },
#endif
	{ WM_INITDIALOG,_T("WM_INITDIALOG") },
	{ WM_COMMAND,_T("WM_COMMAND") },
	{ WM_SYSCOMMAND,_T("WM_SYSCOMMAND") },
	{ WM_TIMER,_T("WM_TIMER") },
	{ WM_HSCROLL,_T("WM_HSCROLL") },
	{ WM_VSCROLL,_T("WM_VSCROLL") },
	{ WM_INITMENU,_T("WM_INITMENU") },
	{ WM_INITMENUPOPUP,_T("WM_INITMENUPOPUP") },
	{ WM_MENUSELECT,_T("WM_MENUSELECT") },
	{ WM_MENUCHAR,_T("WM_MENUCHAR") },
	{ WM_ENTERIDLE,_T("WM_ENTERIDLE") },
	{ WM_CTLCOLORMSGBOX,_T("WM_CTLCOLORMSGBOX") },
	{ WM_CTLCOLOREDIT,_T("WM_CTLCOLOREDIT") },
	{ WM_CTLCOLORLISTBOX,_T("WM_CTLCOLORLISTBOX") },
	{ WM_CTLCOLORBTN,_T("WM_CTLCOLORBTN") },
	{ WM_CTLCOLORDLG,_T("WM_CTLCOLORDLG") },
	{ WM_CTLCOLORSCROLLBAR,_T("WM_CTLCOLORSCROLLBAR") },
	{ WM_CTLCOLORSTATIC,_T("WM_CTLCOLORSTATIC") },
	{ WM_MOUSEMOVE,_T("WM_MOUSEMOVE") },
	{ WM_LBUTTONDOWN,_T("WM_LBUTTONDOWN") },
	{ WM_LBUTTONUP,_T("WM_LBUTTONUP") },
	{ WM_LBUTTONDBLCLK,_T("WM_LBUTTONDBLCLK") },
	{ WM_RBUTTONDOWN,_T("WM_RBUTTONDOWN") },
	{ WM_RBUTTONUP,_T("WM_RBUTTONUP") },
	{ WM_RBUTTONDBLCLK,_T("WM_RBUTTONDBLCLK") },
	{ WM_MBUTTONDOWN,_T("WM_MBUTTONDOWN") },
	{ WM_MBUTTONUP,_T("WM_MBUTTONUP") },
	{ WM_MBUTTONDBLCLK,_T("WM_MBUTTONDBLCLK") },
	{ WM_MOUSEMOVE,_T("WM_MOUSEMOVE") },
	{ WM_LBUTTONDOWN,_T("WM_LBUTTONDOWN") },
	{ WM_LBUTTONUP,_T("WM_LBUTTONUP") },
	{ WM_LBUTTONDBLCLK,_T("WM_LBUTTONDBLCLK") },
	{ WM_RBUTTONDOWN,_T("WM_RBUTTONDOWN") },
	{ WM_RBUTTONUP,_T("WM_RBUTTONUP") },
	{ WM_RBUTTONDBLCLK,_T("WM_RBUTTONDBLCLK") },
	{ WM_MBUTTONDOWN,_T("WM_MBUTTONDOWN") },
	{ WM_MBUTTONUP,_T("WM_MBUTTONUP") },
	{ WM_MBUTTONDBLCLK,_T("WM_MBUTTONDBLCLK") },
	{ WM_PARENTNOTIFY,_T("WM_PARENTNOTIFY") },
	{ WM_ENTERMENULOOP,_T("WM_ENTERMENULOOP") },
	{ WM_EXITMENULOOP,_T("WM_EXITMENULOOP") },
#if(WINVER >= 0x0400)
	{ WM_NEXTMENU,_T("WM_NEXTMENU") },
	{ WM_SIZING,_T("WM_SIZING") },
	{ WM_CAPTURECHANGED,_T("WM_CAPTURECHANGED") },
	{ WM_MOVING,_T("WM_MOVING") },
	{ WM_POWERBROADCAST,_T("WM_POWERBROADCAST") },
	{ WM_DEVICECHANGE,_T("WM_DEVICECHANGE") },
	{ WM_IME_SETCONTEXT,_T("WM_IME_SETCONTEXT") },
	{ WM_IME_NOTIFY,_T("WM_IME_NOTIFY") },
	{ WM_IME_CONTROL,_T("WM_IME_CONTROL") },
	{ WM_IME_COMPOSITIONFULL,_T("WM_IME_COMPOSITIONFULL") },
	{ WM_IME_SELECT,_T("WM_IME_SELECT") },
	{ WM_IME_CHAR,_T("WM_IME_CHAR") },
	{ WM_IME_KEYDOWN,_T("WM_IME_KEYDOWN") },
	{ WM_IME_KEYUP,_T("WM_IME_KEYUP") },
#endif
	{ WM_MDICREATE,_T("WM_MDICREATE") },
	{ WM_MDIDESTROY,_T("WM_MDIDESTROY") },
	{ WM_MDIACTIVATE,_T("WM_MDIACTIVATE") },
	{ WM_MDIRESTORE,_T("WM_MDIRESTORE") },
	{ WM_MDINEXT,_T("WM_MDINEXT") },
	{ WM_MDIMAXIMIZE,_T("WM_MDIMAXIMIZE") },
	{ WM_MDITILE,_T("WM_MDITILE") },
	{ WM_MDICASCADE,_T("WM_MDICASCADE") },
	{ WM_MDIICONARRANGE,_T("WM_MDIICONARRANGE") },
	{ WM_MDIGETACTIVE,_T("WM_MDIGETACTIVE") },
	{ WM_MDISETMENU,_T("WM_MDISETMENU") },
	{ WM_ENTERSIZEMOVE,_T("WM_ENTERSIZEMOVE") },
	{ WM_EXITSIZEMOVE,_T("WM_EXITSIZEMOVE") },
	{ WM_DROPFILES,_T("WM_DROPFILES") },
	{ WM_MDIREFRESHMENU,_T("WM_MDIREFRESHMENU") },
	{ WM_CUT,_T("WM_CUT") },
	{ WM_COPY,_T("WM_COPY") },
	{ WM_PASTE,_T("WM_PASTE") },
	{ WM_CLEAR,_T("WM_CLEAR") },
	{ WM_UNDO,_T("WM_UNDO") },
	{ WM_RENDERFORMAT,_T("WM_RENDERFORMAT") },
	{ WM_RENDERALLFORMATS,_T("WM_RENDERALLFORMATS") },
	{ WM_DESTROYCLIPBOARD,_T("WM_DESTROYCLIPBOARD") },
	{ WM_DRAWCLIPBOARD,_T("WM_DRAWCLIPBOARD") },
	{ WM_PAINTCLIPBOARD,_T("WM_PAINTCLIPBOARD") },
	{ WM_VSCROLLCLIPBOARD,_T("WM_VSCROLLCLIPBOARD") },
	{ WM_SIZECLIPBOARD,_T("WM_SIZECLIPBOARD") },
	{ WM_ASKCBFORMATNAME,_T("WM_ASKCBFORMATNAME") },
	{ WM_CHANGECBCHAIN,_T("WM_CHANGECBCHAIN") },
	{ WM_HSCROLLCLIPBOARD,_T("WM_HSCROLLCLIPBOARD") },
	{ WM_QUERYNEWPALETTE,_T("WM_QUERYNEWPALETTE") },
	{ WM_PALETTEISCHANGING,_T("WM_PALETTEISCHANGING") },
	{ WM_PALETTECHANGED,_T("WM_PALETTECHANGED") },
	{ WM_HOTKEY,_T("WM_HOTKEY") },
#if(WINVER >= 0x0400)
	{ WM_PRINT,_T("WM_PRINT") },
	{ WM_PRINTCLIENT,_T("WM_PRINTCLIENT") },
#endif
	// Below are MFC messages
	{ WM_QUERYAFXWNDPROC,_T("*WM_QUERYAFXWNDPROC") },
	{ WM_SIZEPARENT,_T("*WM_SIZEPARENT") },
	{ WM_SETMESSAGESTRING,_T("*WM_SETMESSAGESTRING") },
	{ WM_IDLEUPDATECMDUI,_T("*WM_IDLEUPDATECMDUI") },
	{ WM_INITIALUPDATE,_T("*WM_INITIALUPDATE") },
	{ WM_COMMANDHELP,_T("*WM_COMMANDHELP") },
	{ WM_HELPHITTEST,_T("*WM_HELPHITTEST") },
	{ WM_EXITHELPMODE,_T("*WM_EXITHELPMODE") },
	{ WM_RECALCPARENT,_T("*WM_RECALCPARENT") },
	{ WM_SIZECHILD,_T("*WM_SIZECHILD") },
	{ WM_KICKIDLE,_T("*WM_KICKIDLE") },
	{ WM_QUERYCENTERWND,_T("*WM_QUERYCENTERWND") },
	{ WM_DISABLEMODAL,_T("*WM_DISABLEMODAL") },
	{ WM_FLOATSTATUS,_T("*WM_FLOATSTATUS") },
	{ WM_ACTIVATETOPLEVEL,_T("*WM_ACTIVATETOPLEVEL") },
	{ WM_QUERY3DCONTROLS,_T("*WM_QUERY3DCONTROLS") },
	{ WM_SOCKET_NOTIFY,_T("*WM_SOCKET_NOTIFY") },
	{ WM_SOCKET_DEAD,_T("*WM_SOCKET_DEAD") },
	{ WM_POPMESSAGESTRING,_T("*WM_POPMESSAGESTRING") },
	{ WM_OCC_LOADFROMSTREAM,_T("*WM_OCC_LOADFROMSTREAM") },
	{ WM_OCC_LOADFROMSTORAGE,_T("*WM_OCC_LOADFROMSTORAGE") },
	{ WM_OCC_INITNEW,_T("*WM_OCC_INITNEW") },
	{ WM_QUEUE_SENTINEL,_T("*WM_QUEUE_SENTINEL") },
	{ 0,NULL }
};

////////////////
// This class is basically just an array of 1024 strings,
// the names of each WM_ message. Constructor initializes it.
//
class CWndMsgMap {
	static LPCTSTR Names[];				// array of WM_ message names
public:
	CWndMsgMap();							// constructor initializes them
	CString GetMsgName(UINT msg);		// get name of message
};
LPCTSTR CWndMsgMap::Names[WM_USER];	// name of each WM_ message

//////////////////
// Initialize array from sparse data
//
CWndMsgMap::CWndMsgMap()
{
	// copy sparse MsgData into table
	memset(Names, 0, sizeof(Names));
	for (int i=0; MsgData[i].msg; i++)		
		Names[MsgData[i].msg] = MsgData[i].name;
}

////////////////
// Get the name of a WM_ message
//
CString CWndMsgMap::GetMsgName(UINT msg)
{
	CString name;
	if (msg>=WM_USER)
		name.Format(_T("WM_USER+%d"), msg-WM_USER);
	else if (Names[msg])
		name = Names[msg];
	else
		name.Format(_T("0x%04x"), msg);
	return name;
}

//////////////////
// Get name of WM_ message.
//
CString sDbgName(UINT uMsg)
{
	static CWndMsgMap wndMsgMap; // instantiate 1st time called
	return wndMsgMap.GetMsgName(uMsg);
}

#ifdef REFIID

// Most apps don't need to use DbgName(REFIID)
// Apps that do can set this static global to a table of
// DBGINTERFACENAME's it wants to TRACE with DbgName(REFIID)
//
DBGINTERFACENAME* _pDbgInterfaceNames = NULL;

//////////////////
// Get OLE interface name.
//
CString sDbgName(REFIID iid)
{
	if (_pDbgInterfaceNames)
	{
		for (int i=0; _pDbgInterfaceNames[i].name; i++)
		{
			if (memcmp(_pDbgInterfaceNames[i].piid, &iid, sizeof(IID))==0)
				return _pDbgInterfaceNames[i].name;
		}
	}
	static CString s;
	s.Format(_T("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
		iid.Data1, iid.Data2, iid.Data3,
		iid.Data4[0], iid.Data4[1], iid.Data4[2], iid.Data4[3],
		iid.Data4[4], iid.Data4[5], iid.Data4[6], iid.Data4[7]);
	return s;
}

#endif // REFIID

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\disablethresholddlg.h ===
#if !defined(AFX_DISABLETHRESHOLDDLG_H__3ADB0FD6_C4FA_11D2_BD83_0000F87A3912__INCLUDED_)
#define AFX_DISABLETHRESHOLDDLG_H__3ADB0FD6_C4FA_11D2_BD83_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DisableThresholdDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDisableThresholdDlg dialog

class CDisableThresholdDlg : public CDialog
{
// Construction
public:
	CDisableThresholdDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDisableThresholdDlg)
	enum { IDD = IDD_DIALOG_DISABLETHRESHOLD };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDisableThresholdDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDisableThresholdDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DISABLETHRESHOLDDLG_H__3ADB0FD6_C4FA_11D2_BD83_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\debug.h ===
// Debug.h: generic debugging facilities.
//
//////////////////////////////////////////////////////////////////////

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef _DEBUG

//////////////////////////////////////////////////////////////////////
// Class CTraceEx
//
// Implements TRACEX macro.
// Don't ever use directly, just use TRACEX
//

class CTraceEx
{

// Construction/Destruction
public:
	CTraceEx()  { nIndent++; }
	~CTraceEx() { nIndent--; }

private:
	static int	nIndent;	// current indent level
	friend void AFX_CDECL AfxTrace(LPCTSTR lpszFormat, ...);

};

// NOTE: YOU MUST NOT USE TRACEX IN A ONE-LINE IF STATEMENT!
// This will fail:
//
// if (foo)
//    TRACEX(...)
//
// Instead, you must enclose the TRACE in squiggle-brackets
//
// if (foo) {
//		TRACEX(...)
// }
//
#define TRACEX CTraceEx __fooble; TRACE(_T("->")); TRACE

// Goodies to get names of things.
//
extern CString sDbgName(CWnd* pWnd); // get name of window
extern CString sDbgName(UINT uMsg);	 // get name of WM_ message

#ifdef REFIID

struct DBGINTERFACENAME {
	const IID* piid;	// ptr to GUID
	LPCSTR name;		// human-readable name of interface
};

// Change this to whatever interfaces you want to track
// Default is none
//
extern DBGINTERFACENAME* _pDbgInterfaceNames; 

extern CString sDbgName(REFIID iid);	// get name of COM interface

#endif // REFIID

#else // Not _DEBUG

#define sDbgName(x)	CString()
#define TRACEX TRACE

#endif

// Macro casts to LPCTSTR for use with TRACE/printf/CString::Format
//
#define DbgName(x) (LPCTSTR)sDbgName(x)

//////////////////////////////////////////////////////////////////////
// Inlines

inline bool CHECKOBJPTR(CObject* pObj, const CRuntimeClass* pClass, size_t size)
{
	ASSERT(pObj);

	if( pObj == NULL )
	{
		TRACE(_T("WARNING : object pointer is NULL !\n"));
		return false;
	}

	if( ! AfxIsValidAddress((LPVOID)pObj,size) )
	{
		TRACE(_T("FAILED : object pointer points to invalid memory !\n"));
		return false;
	}

	ASSERT_VALID(pObj);

	if( ! pObj->IsKindOf(pClass) )
	{
		TRACE(_T("FAILED : object pointer is not of type %s !\n"),pClass->m_lpszClassName);
		return false;
	}

	return true;
}

inline bool CHECKPTR(LPVOID pVoid, size_t size)
{
	ASSERT(pVoid);

	if( pVoid == NULL )
	{
		TRACE(_T("WARNING : pointer is NULL !\n"));
		return false;
	}

	if( ! AfxIsValidAddress((LPVOID)pVoid,size) )
	{
		TRACE(_T("FAILED : pointer points to invalid memory !\n"));
		return false;
	}

	return true;
}

inline bool CHECKHRESULT(HRESULT hr)
{
	ASSERT(hr != E_FAIL);

	if( hr != S_OK )
	{
		TRACE(_T("FAILED : HRESULT=%X\n"),hr);
//		ASSERT(FALSE);
		return false;
	}

	return true;
}

#define TRACEARGn(Arg) (TRACE(_T("[")_T(#Arg)_T("]=%d\n"),Arg))

#define TRACEARGs(Arg) (TRACE(_T("[")_T(#Arg)_T("]=%s\n"),Arg))

#define GfxCheckObjPtr(p,classname) (CHECKOBJPTR(p,RUNTIME_CLASS(classname),sizeof(#classname)))

#define GfxCheckPtr(p,classname) (CHECKPTR(p,sizeof(#classname)))

#endif //__DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpcompluspage.cpp ===
// DPComPlusPage.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
// 03/29/00 v-marfin bug 62585 : Set new Data collector's ENABLED to TRUE if user presses OK.
// 03/30/00 v-marfin bug 59237 : If user does not change the default name of the data
//                               collector when they first create it, change it for 
//                               them to a more meaningful name based on the data
//                               they select in the property pages.
// 04/07/00 v-marfin bug 63011   Changed path to Com+ namespace
#include "stdafx.h"
#include "snapin.h"
#include "DPComPlusPage.h"
#include "WMIBrowseDlg.h"
#include "HMObject.h"

#include "DataElement.h"
#include "DataGroupScopeItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDPComPlusPage property page

IMPLEMENT_DYNCREATE(CDPComPlusPage, CHMPropertyPage)

CDPComPlusPage::CDPComPlusPage() : CHMPropertyPage(CDPComPlusPage::IDD)
{
	//{{AFX_DATA_INIT(CDPComPlusPage)
	m_sAppName = _T("");
	m_bRequireReset = FALSE;
	//}}AFX_DATA_INIT
}

CDPComPlusPage::~CDPComPlusPage()
{
}

void CDPComPlusPage::UpdateProperties()
{
	m_Properties.DeleteAllItems();

	CWbemClassObject classobject;

    CString sNamespace;
    sNamespace.Format(IDS_STRING_MOF_COMPLUS_NAMESPACE,GetObjectPtr()->GetSystemName()); // 63011b
	classobject.SetNamespace(sNamespace);

	HRESULT hr = classobject.GetObject(IDS_STRING_MOF_ACS_APPSTATS);

	if( hr != S_OK )
	{
		return;
	}

	CStringArray saNames;
	classobject.GetPropertyNames(saNames);
	classobject.Destroy();

	for( int i = 0; i < saNames.GetSize(); i++ )
	{
		m_Properties.InsertItem(0,saNames[i]);
	}

	m_Properties.SetColumnWidth(0,LVSCW_AUTOSIZE_USEHEADER);
}

void CDPComPlusPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDPComPlusPage)
	DDX_Control(pDX, IDC_LIST_PROPERTIES, m_Properties);
	DDX_Text(pDX, IDC_EDIT_NAME, m_sAppName);
	DDX_Check(pDX, IDC_CHECK_REQUIRE_RESET, m_bRequireReset);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDPComPlusPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CDPComPlusPage)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_NAMESPACE, OnButtonBrowseNamespace)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDPComPlusPage message handlers

void CDPComPlusPage::OnButtonBrowseNamespace() 
{
	CWmiInstanceBrowseDlg dlg;	

	// set the dialog window title
	CString sItem;
	sItem.LoadString(IDS_STRING_INSTANCES);
	dlg.m_sDlgTitle.Format(IDS_STRING_WMI_BROWSE_TITLE,sItem,GetObjectPtr()->GetSystemName());

  // set the namespace
  CString sNamespace;
  sNamespace.Format(IDS_STRING_MOF_COMPLUS_NAMESPACE,GetObjectPtr()->GetSystemName()); // 63011b
  dlg.m_ClassObject.SetNamespace(sNamespace);

  BSTR bsTemp = ::SysAllocString(L"MicrosoftComPlus_AppName");
	if( ! CHECKHRESULT(dlg.m_ClassObject.CreateEnumerator(bsTemp)) )
	{
		::SysFreeString(bsTemp);
		return;
	}
	::SysFreeString(bsTemp);

	// set the listbox title
	dlg.m_sTitle.LoadString(IDS_STRING_COM_PLUS_APPS);

	// display the dialog	
	if( dlg.DoModal() == IDOK )
	{
		m_sAppName = dlg.m_sSelectedItem;
    int iIndex = m_sAppName.Find(_T("\""));
    if( iIndex != -1 )
    {
      m_sAppName = m_sAppName.Right(m_sAppName.GetLength()-iIndex);
      m_sAppName.TrimLeft(_T("\""));
      m_sAppName.TrimRight(_T("\""));
    }
		UpdateData(FALSE);		
		SetModified();
	}
		
}

BOOL CDPComPlusPage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();


	CHMPropertyPage::OnInitDialog();

	// initialize the list view
	m_Properties.SetExtendedStyle(LVS_EX_CHECKBOXES);

	CString sColumnTitle;
	sColumnTitle.LoadString(IDS_STRING_NAME);
	m_Properties.InsertColumn(0,sColumnTitle);

  UpdateProperties();

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return TRUE;
	}
	
    //-------------------------------------------------------------------------
    // v-marfin 59237 : Store original name in case this data collector is
    //                  just being created. When they save, we will modify the 
    //                  name if they haven't.
	pClassObject->GetProperty(IDS_STRING_MOF_NAME,m_sOriginalName);
    //-------------------------------------------------------------------------


	pClassObject->GetProperty(IDS_STRING_MOF_PATH,m_sAppName);
  int iIndex = m_sAppName.Find(_T("AppName="));
  if( iIndex != -1 )
  {
    m_sAppName = m_sAppName.Right(m_sAppName.GetLength()-iIndex-8);
    iIndex = m_sAppName.Find(_T(","));
    if( iIndex != -1 )
    {
      m_sAppName = m_sAppName.Left(iIndex);
    }
    m_sAppName.TrimLeft(_T("\""));
    m_sAppName.TrimRight(_T("\""));
  }

	CStringArray saProperties;
	pClassObject->GetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saProperties);
	for( int i=0; i < saProperties.GetSize(); i++ )
	{
		LVFINDINFO lvfi;
		ZeroMemory(&lvfi,sizeof(LVFINDINFO));
		lvfi.flags = LVFI_WRAP|LVFI_STRING;
		lvfi.psz = saProperties[i];
		int iListIndex = m_Properties.FindItem(&lvfi);
		if( iListIndex >= 0 )
		{
			m_Properties.SetCheck(iListIndex);
		}
	}

  delete pClassObject;

	UpdateData(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CDPComPlusPage::OnApply() 
{
  if( ! CHMPropertyPage::OnApply() )
  {
    return FALSE;
  }

    // v-marfin 62585 : So we can set the collector's state to enabled when OK pressed.
    m_bOnApplyUsed=TRUE;

    UpdateData();

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return TRUE;
	}
	
	// 63011 : Change path
    // pClassObject->SetProperty(IDS_STRING_MOF_TARGETNAMESPACE,CString(_T("\\\\.\\root\\cimv2\\applications\\MicrosoftACS")));
	// 63011b
    CString sNamespace;
    sNamespace.Format(IDS_STRING_MOF_COMPLUS_NAMESPACE,GetObjectPtr()->GetSystemName());
    
    // 63011b pClassObject->SetProperty(IDS_STRING_MOF_TARGETNAMESPACE,CString(_T("\\\\.\\root\\cimv2\\MicrosoftHealthmonitor")));
    pClassObject->SetProperty(IDS_STRING_MOF_TARGETNAMESPACE,sNamespace);

    CString sPath;
    sPath.Format(IDS_STRING_MOF_ACS_APPSTATS_FMT,m_sAppName,180);
	pClassObject->SetProperty(IDS_STRING_MOF_PATH,sPath);

	CStringArray saProperties;

	for( int i = 0; i < m_Properties.GetItemCount(); i++ )
	{
		if( m_Properties.GetCheck(i) )
		{			
			saProperties.Add(m_Properties.GetItemText(i,0));
		}
	}

	pClassObject->SetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saProperties);

	bool bReset = m_bRequireReset ? true : false;
	pClassObject->SetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);

	pClassObject->SaveAllProperties();

  delete pClassObject;  

  SetModified(FALSE);

  return TRUE;
}


void CDPComPlusPage::OnDestroy() 
{
    // v-marfin 62585 : For this new data collector, set its Enabled property to TRUE, but
    //                  only if the user is not cancelling these property pages.
    if (m_bOnApplyUsed)
    {
        ClearStatistics(); // 62548

        CDataElement* pElement = (CDataElement*)GetObjectPtr();
        if (pElement && pElement->IsStateSetToEnabledOnOK())
        {
            TRACE(_T("CDPComPlusPage::OnDestroy - New Perfmon Collector: Setting to Enabled\n"));

            pElement->SetStateToEnabledOnOK(FALSE); // don't do this again
	        
	        CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	        if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	        {
                TRACE(_T("ERROR: CDPComPlusPage::OnDestroy - Failed to GetClassObject()\n"));
		        return;
	        }

            // Set the new collector to enabled.
            BOOL bEnabled=TRUE;
	        HRESULT hr = pClassObject->GetProperty(IDS_STRING_MOF_ENABLE,bEnabled);
	        hr = pClassObject->SetProperty(IDS_STRING_MOF_ENABLE,TRUE);
            
            if (!CHECKHRESULT(hr))
            {   
                TRACE(_T("ERROR: CDPComPlusPage::OnDestroy - Failed to set ENABLED property on new collector\n"));
            }
            
            //-------------------------------------------------------------------
            // v-marfin 59237 : If the user has not changed the original default
            //                  name, do so for them. Compare against original
            //                  name we fetched during OnInitDialog.
            CString sName;
	        pClassObject->GetProperty(IDS_STRING_MOF_NAME,sName);

            // Did the user change the default name?
            if (m_sOriginalName.CompareNoCase(sName)==0)
            {       
                // No, so set the new name 
                if (!m_sAppName.IsEmpty())
                {
                    // Use parent to ensure name is unique
                    //CDataGroup* pParent = (CDataGroup*) pElement->GetCollectorsParentClassObject();
	                if(pElement->GetScopeItemCount())
	                {
		                CDataElementScopeItem* pItem = (CDataElementScopeItem*)pElement->GetScopeItem(0);
		                if( pItem )
                        {
                            CDataGroupScopeItem* pDGItem = (CDataGroupScopeItem*)pItem->GetParent();
                            sName = pDGItem->GetUniqueDisplayName(m_sAppName);
                        }
                    }

                    // Set the local element's object data
                    pElement->SetName(sName);
                    // Set its WMI property
                    pClassObject->SetProperty(IDS_STRING_MOF_NAME,sName);

                    // Refresh to show the new name in the IU
                    //pElement->Refresh();      // 63005
                    pElement->UpdateStatus();   // 63005
                }
            }
            //-------------------------------------------------------------------



            pClassObject->SaveAllProperties();
            delete pClassObject;

        } // if (pElement && pElement->IsStateSetToEnabledOnOK())
    } // if (m_bOnApplyUsed)

	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpcompluspage.h ===
#if !defined(AFX_DPCOMPLUSPAGE_H__EC08946D_DFED_4E85_AC72_84E7BE940029__INCLUDED_)
#define AFX_DPCOMPLUSPAGE_H__EC08946D_DFED_4E85_AC72_84E7BE940029__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DPComPlusPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDPComPlusPage dialog

class CDPComPlusPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CDPComPlusPage)

// Construction
public:
	CDPComPlusPage();
	~CDPComPlusPage();

// Operations
protected:
  void UpdateProperties();

// Dialog Data
	//{{AFX_DATA(CDPComPlusPage)
	enum { IDD = IDD_DATAPOINT_COM_PLUS };
	CListCtrl	m_Properties;
	CString	m_sAppName;
	BOOL	m_bRequireReset;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDPComPlusPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDPComPlusPage)
	afx_msg void OnButtonBrowseNamespace();
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPCOMPLUSPAGE_H__EC08946D_DFED_4E85_AC72_84E7BE940029__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpfileinfopage.cpp ===
// DPFileInfoPage.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
// 03/23/00 v-marfin bug 61680 : escape and unescape special chars.
// 03/28/00 v-marfin 61030 Change Browse for file dialog to fix default extension.
// 03/29/00 v-marfin 62585 Set new Data collector's ENABLED to TRUE if user presses OK.
// 03/30/00 v-marfin bug 59237 : If user does not change the default name of the data
//                               collector when they first create it, change it for 
//                               them to a more meaningful name based on the data
//                               they select in the property pages.

#include "stdafx.h"
#include "snapin.h"
#include "DPFileInfoPage.h"
#include "HMObject.h"
#include "WmiBrowseDlg.h"
#include "WmiPropertyBrowseDlg.h"
#include "DataElement.h"
#include "DataGroupScopeItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDPFileInfoPage property page

IMPLEMENT_DYNCREATE(CDPFileInfoPage, CHMPropertyPage)

CDPFileInfoPage::CDPFileInfoPage() : CHMPropertyPage(CDPFileInfoPage::IDD)
{
	//{{AFX_DATA_INIT(CDPFileInfoPage)
	m_bRequireReset = FALSE;
	m_sFile = _T("");
	m_sFolder = _T("");
	m_iType = 0;
	//}}AFX_DATA_INIT

	m_sHelpTopic = _T("HMon21.chm::/dDEfile.htm");
}

CDPFileInfoPage::~CDPFileInfoPage()
{
}

void CDPFileInfoPage::UpdateProperties(CListCtrl& Properties, const CString& sNamespace, const CString& sClass)
{
	Properties.DeleteAllItems();

	if( sClass.IsEmpty() )
	{
		return;
	}

	CWbemClassObject classobject;

	classobject.SetNamespace(_T("\\\\") + GetObjectPtr()->GetSystemName() + _T("\\") + sNamespace);

	HRESULT hr = classobject.GetObject(sClass);

	if( hr != S_OK )
	{
		return;
	}

	CStringArray saNames;
	classobject.GetPropertyNames(saNames);
	classobject.Destroy();

	for( int i = 0; i < saNames.GetSize(); i++ )
	{
		Properties.InsertItem(0,saNames[i]);
	}

	Properties.SetColumnWidth(0,LVSCW_AUTOSIZE);
}

void CDPFileInfoPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDPFileInfoPage)
	DDX_Control(pDX, IDC_LIST_FOLDER_PROPERTIES, m_FolderProperties);
	DDX_Control(pDX, IDC_LIST_FILE_PROPERTIES, m_FileProperties);
	DDX_Check(pDX, IDC_CHECK_REQUIRE_RESET, m_bRequireReset);
	DDX_Text(pDX, IDC_EDIT_FILE, m_sFile);
	DDX_Text(pDX, IDC_EDIT_FOLDER, m_sFolder);
	DDX_Radio(pDX, IDC_RADIO1, m_iType);
	//}}AFX_DATA_MAP

	if( m_iType == 0 )
	{
		GetDlgItem(IDC_EDIT_FOLDER)->EnableWindow();
		GetDlgItem(IDC_BUTTON_BROWSE_FOLDER)->EnableWindow();
		GetDlgItem(IDC_LIST_FOLDER_PROPERTIES)->EnableWindow();
		GetDlgItem(IDC_BUTTON_BROWSE_FILE)->EnableWindow(FALSE);
		GetDlgItem(IDC_EDIT_FILE)->EnableWindow(FALSE);
		GetDlgItem(IDC_LIST_FILE_PROPERTIES)->EnableWindow(FALSE);
	}
	else if( m_iType == 1 )
	{
		GetDlgItem(IDC_EDIT_FOLDER)->EnableWindow(FALSE);
		GetDlgItem(IDC_BUTTON_BROWSE_FOLDER)->EnableWindow(FALSE);
		GetDlgItem(IDC_LIST_FOLDER_PROPERTIES)->EnableWindow(FALSE);
		GetDlgItem(IDC_BUTTON_BROWSE_FILE)->EnableWindow();
		GetDlgItem(IDC_EDIT_FILE)->EnableWindow();
		GetDlgItem(IDC_LIST_FILE_PROPERTIES)->EnableWindow();
	}
}

BEGIN_MESSAGE_MAP(CDPFileInfoPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CDPFileInfoPage)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_FILE, OnButtonBrowseFile)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_FOLDER, OnButtonBrowseFolder)
	ON_BN_CLICKED(IDC_CHECK_REQUIRE_RESET, OnCheckRequireReset)
	ON_EN_CHANGE(IDC_EDIT_FILE, OnChangeEditFile)
	ON_EN_CHANGE(IDC_EDIT_FOLDER, OnChangeEditFolder)
	ON_BN_CLICKED(IDC_RADIO1, OnRadio1)
	ON_BN_CLICKED(IDC_RADIO2, OnRadio2)
	ON_NOTIFY(NM_CLICK, IDC_LIST_FILE_PROPERTIES, OnClickListFileProperties)
	ON_NOTIFY(NM_CLICK, IDC_LIST_FOLDER_PROPERTIES, OnClickListFolderProperties)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDPFileInfoPage message handlers

BOOL CDPFileInfoPage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();

	// initialize the list view
	m_FileProperties.SetExtendedStyle(LVS_EX_CHECKBOXES);
	m_FolderProperties.SetExtendedStyle(LVS_EX_CHECKBOXES);


	CString sColumnTitle;
	sColumnTitle.LoadString(IDS_STRING_NAME);
	m_FileProperties.InsertColumn(0,sColumnTitle);
	m_FolderProperties.InsertColumn(0,sColumnTitle);


	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return TRUE;
	}
		
	UpdateProperties(m_FileProperties,_T("root\\cimv2"),_T("CIM_DATAFILE"));
	UpdateProperties(m_FolderProperties,_T("root\\cimv2"),_T("WIN32_DIRECTORY"));
	
    //-------------------------------------------------------------------------
    // v-marfin 59237 : Store original name in case this data collector is
    //                  just being created. When they save, we will modify the 
    //                  name if they haven't.
	pClassObject->GetProperty(IDS_STRING_MOF_NAME,m_sOriginalName);
    //-------------------------------------------------------------------------

	CString sQuery;
	pClassObject->GetProperty(IDS_STRING_MOF_QUERY,sQuery);
	sQuery.MakeUpper();

	int iIndex = -1;

    CSnapInApp* pApp = (CSnapInApp*) AfxGetApp();

	if( (iIndex = sQuery.Find(_T("WIN32_DIRECTORY"))) != -1 )
	{
		CString sDrive;
		CString sPath;

		CWbemClassObject::GetPropertyValueFromString(sQuery,_T("NAME"),m_sFolder);

        // v-marfin 61680 : unescape special chars
        m_sFolder = pApp->UnEscapeSpecialChars(m_sFolder); 

		m_iType = 0;
	}
	else if( (iIndex = sQuery.Find(_T("CIM_DATAFILE"))) != -1 )
	{
		CWbemClassObject::GetPropertyValueFromString(sQuery,_T("NAME"),m_sFile);

        // v-marfin 61680 : unescape special chars
        m_sFile = pApp->UnEscapeSpecialChars(m_sFile); 

		m_iType = 1;		
	}

	CStringArray saProperties;
	CString sProperties;

	pClassObject->GetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saProperties);

	if( m_iType == 0 )
	{
		for( int i=0; i < saProperties.GetSize(); i++ )
		{
			LVFINDINFO lvfi;
			ZeroMemory(&lvfi,sizeof(LVFINDINFO));
			lvfi.flags = LVFI_WRAP|LVFI_STRING;
			lvfi.psz = saProperties[i];
			int iListIndex = m_FolderProperties.FindItem(&lvfi);
			if( iListIndex >= 0 )
			{
				m_FolderProperties.SetCheck(iListIndex);
			}
		}
	}
	else if( m_iType == 1 )
	{
		for( int i=0; i < saProperties.GetSize(); i++ )
		{
			LVFINDINFO lvfi;
			ZeroMemory(&lvfi,sizeof(LVFINDINFO));
			lvfi.flags = LVFI_WRAP|LVFI_STRING;
			lvfi.psz = saProperties[i];
			int iListIndex = m_FileProperties.FindItem(&lvfi);
			if( iListIndex >= 0 )
			{
				m_FileProperties.SetCheck(iListIndex);
			}
		}
	}

	bool bReset;
	pClassObject->GetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);
	m_bRequireReset = bReset;

	delete pClassObject;

	UpdateData(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CDPFileInfoPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

    // v-marfin 62585 : So we can set the collector's state to enabled when OK pressed.
    m_bOnApplyUsed=TRUE;

	UpdateData();

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return FALSE;
	}

	CStringArray saCounters;

	if( m_iType == 0 )
	{
		if( m_FolderProperties.GetItemCount() <= 0 )
		{
			return FALSE;
		}

		for( int i = 0; i < m_FolderProperties.GetItemCount(); i++ )
		{
			if( m_FolderProperties.GetCheck(i) )
			{			
				saCounters.Add(m_FolderProperties.GetItemText(i,0));
			}
		}
	}
	else if( m_iType == 1 )
	{
		if( m_FileProperties.GetItemCount() <= 0 )
		{
			return FALSE;
		}

		for( int i = 0; i < m_FileProperties.GetItemCount(); i++ )
		{
			if( m_FileProperties.GetCheck(i) )
			{			
				saCounters.Add(m_FileProperties.GetItemText(i,0));
			}
		}
	}

//	if( ! saCounters.GetSize() )
//	{
//		return FALSE;
//	}

	CString sNamespace = _T("root\\cimv2");
	pClassObject->SetProperty(IDS_STRING_MOF_TARGETNAMESPACE,sNamespace);

    CSnapInApp* pApp = (CSnapInApp*) AfxGetApp();

	CString sQuery;	
	if( m_iType == 0 )
	{
        // v-marfin: 61680  escape backslashes
        CString sFolder = pApp->EscapeSpecialChars(m_sFolder);
		sQuery.Format(_T("select * from Win32_Directory where Name=\"%s\""),sFolder);
		pClassObject->SetProperty(IDS_STRING_MOF_QUERY,sQuery);
		
	}
	else if( m_iType == 1 )
	{
        // v-marfin: 61680  escape backslashes
        CString sFile = pApp->EscapeSpecialChars(m_sFile);

		sQuery.Format(_T("select * from CIM_DataFile where Name=\"%s\""),sFile);
		pClassObject->SetProperty(IDS_STRING_MOF_QUERY,sQuery);
		
	}

	pClassObject->SetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saCounters);

	bool bReset = m_bRequireReset ? true : false;
	pClassObject->SetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);

	pClassObject->SaveAllProperties();

	delete pClassObject;

  SetModified(FALSE);
	
	return TRUE;
}

void CDPFileInfoPage::OnButtonBrowseFile() 
{
	CString sFilter;
	CString sTitle;

	sFilter.LoadString(IDS_STRING_FILTER);
	sTitle.LoadString(IDS_STRING_BROWSE_FILE);

	// v-marfin 61030 Change Browse for file dialog to fix default extension
	// CFileDialog fdlg(TRUE,_T("*.*"),NULL,OFN_FILEMUSTEXIST|OFN_SHAREAWARE|OFN_HIDEREADONLY,sFilter);
	CFileDialog fdlg(TRUE,			// Is FILEOPEN dialog?
					 NULL,			// default extension if no extension provided
					 NULL,			// initial filename
					 OFN_FILEMUSTEXIST|OFN_SHAREAWARE|OFN_HIDEREADONLY,  // flags
					 sFilter);		// filter

	fdlg.m_ofn.lpstrTitle = sTitle;

	if( fdlg.DoModal() == IDOK )
	{
		m_sFile = fdlg.GetPathName();
		UpdateData(FALSE);
		SetModified();
	}
}

void CDPFileInfoPage::OnButtonBrowseFolder() 
{
	LPMALLOC pMalloc;
	if( ::SHGetMalloc(&pMalloc) == NOERROR )
	{
		BROWSEINFO bi;
		TCHAR szBuffer[MAX_PATH];
		LPITEMIDLIST pidlDesktop;
		LPITEMIDLIST pidl;
		
		if( ::SHGetSpecialFolderLocation(GetSafeHwnd(),CSIDL_DESKTOP,&pidlDesktop) != NOERROR )
			return;

    CString sResString;
    sResString.LoadString(IDS_STRING_BROWSE_FOLDER);

		bi.hwndOwner = GetSafeHwnd();
		bi.pidlRoot = pidlDesktop;
		bi.pszDisplayName = szBuffer;
		bi.lpszTitle = LPCTSTR(sResString);
		bi.ulFlags = BIF_RETURNONLYFSDIRS;
		bi.lpfn = NULL;
		bi.lParam = 0;

		if( (pidl = ::SHBrowseForFolder(&bi)) != NULL )
		{
			if (SUCCEEDED(::SHGetPathFromIDList(pidl, szBuffer)))
			{
				m_sFolder = szBuffer;
				UpdateData(FALSE);
				SetModified();
			}

			pMalloc->Free(pidl);
		}
		pMalloc->Free(pidlDesktop);
		pMalloc->Release();
	}
}


void CDPFileInfoPage::OnCheckRequireReset() 
{
	SetModified();	
}

void CDPFileInfoPage::OnChangeEditFile() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();	
	
}

void CDPFileInfoPage::OnChangeEditFolder() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CDPFileInfoPage::OnRadio1() 
{
	UpdateData();	
}

void CDPFileInfoPage::OnRadio2() 
{
	UpdateData();	
}

void CDPFileInfoPage::OnClickListFileProperties(NMHDR* pNMHDR, LRESULT* pResult) 
{
	SetModified();	
	*pResult = 0;
}

void CDPFileInfoPage::OnClickListFolderProperties(NMHDR* pNMHDR, LRESULT* pResult) 
{
	SetModified();	
	*pResult = 0;
}

void CDPFileInfoPage::OnDestroy() 
{
    // v-marfin 62585 : For this new data collector, set its Enabled property to TRUE, but
    //                  only if the user is not cancelling these property pages.
    if (m_bOnApplyUsed)
    {
        ClearStatistics(); // 62548

        CDataElement* pElement = (CDataElement*)GetObjectPtr();
        if (pElement && pElement->IsStateSetToEnabledOnOK())
        {
            TRACE(_T("CDPFileInfoPage::OnDestroy - New Perfmon Collector: Setting to Enabled\n"));

            pElement->SetStateToEnabledOnOK(FALSE); // don't do this again
	        
	        CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	        if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	        {
                TRACE(_T("ERROR: CDPPerfMonPage::OnOK - Failed to GetClassObject()\n"));
		        return;
	        }

            // Set the new collector to enabled.
            BOOL bEnabled=TRUE;
	        HRESULT hr = pClassObject->GetProperty(IDS_STRING_MOF_ENABLE,bEnabled);
	        hr = pClassObject->SetProperty(IDS_STRING_MOF_ENABLE,TRUE);
            
            if (!CHECKHRESULT(hr))
            {   
                TRACE(_T("ERROR: CDPFileInfoPage::OnDestroy - Failed to set ENABLED property on new collector\n"));
            }
            
            //-------------------------------------------------------------------
            // v-marfin 59237 : If the user has not changed the original default
            //                  name, do so for them. Compare against original
            //                  name we fetched during OnInitDialog.
            CString sName;
	        pClassObject->GetProperty(IDS_STRING_MOF_NAME,sName);

            // Did the user change the default name?
            if (m_sOriginalName.CompareNoCase(sName)==0)
            {       
                CString sObject = m_sFile.IsEmpty() ? m_sFolder : m_sFile;

                // No, so set the new name 
                if (!sObject.IsEmpty())
                {
                    // Use parent to ensure name is unique
                    //CDataGroup* pParent = (CDataGroup*) pElement->GetCollectorsParentClassObject();
	                if(pElement->GetScopeItemCount())
	                {
		                CDataElementScopeItem* pItem = (CDataElementScopeItem*)pElement->GetScopeItem(0);
		                if( pItem )
                        {
                            CDataGroupScopeItem* pDGItem = (CDataGroupScopeItem*)pItem->GetParent();
                            sName = pDGItem->GetUniqueDisplayName(sObject);
                        }
                    }

                    // Set the local element's object data
                    pElement->SetName(sName);
                    // Set its WMI property
                    pClassObject->SetProperty(IDS_STRING_MOF_NAME,sName);

                    // Refresh to show the new name in the IU
                    //pElement->Refresh();      // 63005
                    pElement->UpdateStatus();   // 63005
                }
            }
            //-------------------------------------------------------------------


            pClassObject->SaveAllProperties();
            delete pClassObject;

        } // if (pElement && pElement->IsStateSetToEnabledOnOK())
    } // if (m_bOnApplyUsed)


	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpftppage.h ===
#if !defined(AFX_DPFTPPAGE_H__F0D58772_43A8_11D3_BE28_0000F87A3912__INCLUDED_)
#define AFX_DPFTPPAGE_H__F0D58772_43A8_11D3_BE28_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DPFtpPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDPFtpPage dialog

class CDPFtpPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CDPFtpPage)

// Construction
public:
	CDPFtpPage();
	~CDPFtpPage();

// Dialog Data
	//{{AFX_DATA(CDPFtpPage)
	enum { IDD = IDD_DATAPOINT_FTP };
	BOOL	m_bUseAscii;
	CString	m_sFile;
	CString	m_sPassword;
	CString	m_sServer;
	CString	m_sTimeout;
	CString	m_sUser;
	BOOL	m_bRequireReset;
	CString	m_sDownloadDir;
	//}}AFX_DATA
	CString m_sProxy;
	CString m_sPort;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDPFtpPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDPFtpPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckRequireReset();
	afx_msg void OnCheckUseAscii();
	afx_msg void OnChangeEditFile();
	afx_msg void OnChangeEditPassword();
	afx_msg void OnChangeEditTimeout();
	afx_msg void OnChangeEditUser();
	afx_msg void OnButtonProxy();
	afx_msg void OnChangeEditServer();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPFTPPAGE_H__F0D58772_43A8_11D3_BE28_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpgeneralpage.cpp ===
// DPGeneralPage.cpp : implementation file
//
// Copyright (c) 2000 Microsoft Corporation
//
// 03/24/00 v-marfin   Fixed help link.
//


#include "stdafx.h"
#include "snapin.h"
#include "DPGeneralPage.h"
#include "HMObject.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDPGeneralPage property page

IMPLEMENT_DYNCREATE(CDPGeneralPage, CHMPropertyPage)

CDPGeneralPage::CDPGeneralPage() : CHMPropertyPage(CDPGeneralPage::IDD)
{
	//{{AFX_DATA_INIT(CDPGeneralPage)
	m_sName = _T("");
	m_sComment = _T("");
	m_sCreationDate = _T("");
	m_sModifiedDate = _T("");
	//}}AFX_DATA_INIT

	CnxPropertyPageInit();

	// v-marfin 60145 : Fixed help link
	m_sHelpTopic = _T("HMon21.chm::/dDEgen.htm");

}

CDPGeneralPage::~CDPGeneralPage()
{
}

void CDPGeneralPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDPGeneralPage)
	DDX_Text(pDX, IDC_EDIT_NAME, m_sName);
	DDX_Text(pDX, IDC_EDIT_COMMENT, m_sComment);
	DDX_Text(pDX, IDC_STATIC_CREATED, m_sCreationDate);
	DDX_Text(pDX, IDC_STATIC_MODIFIED, m_sModifiedDate);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDPGeneralPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CDPGeneralPage)
	ON_WM_DESTROY()
	ON_EN_CHANGE(IDC_EDIT_COMMENT, OnChangeEditComment)
	ON_EN_CHANGE(IDC_EDIT_NAME, OnChangeEditName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDPGeneralPage message handlers

BOOL CDPGeneralPage::OnInitDialog() 
{
	// unmarshal connmgr
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();

	m_sName = GetObjectPtr()->GetName();
	m_sComment = GetObjectPtr()->GetComment();
	GetObjectPtr()->GetCreateDateTime(m_sCreationDate);
	GetObjectPtr()->GetModifiedDateTime(m_sModifiedDate);

	UpdateData(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDPGeneralPage::OnDestroy() 
{
	CHMPropertyPage::OnDestroy();
	
	CnxPropertyPageDestroy();		
}

void CDPGeneralPage::OnOK() 
{
	CHMPropertyPage::OnOK();
}

BOOL CDPGeneralPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

	UpdateData();

	GetObjectPtr()->Rename(m_sName);
	GetObjectPtr()->UpdateComment(m_sComment);

  SetModified(FALSE);
	
	return TRUE;
}

void CDPGeneralPage::OnChangeEditComment() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	UpdateData();
	SetModified();
	
}

void CDPGeneralPage::OnChangeEditName() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	UpdateData();
	SetModified();
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpftppage.cpp ===
// DPFtpPage.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
// 03/24/00 v-marfin bug 62447 : Fix for proxy parsing 
// 03/29/00 v-marfin bug 62585 : Set new Data collector's ENABLED to TRUE if user presses OK.
// 03/30/00 v-marfin bug 59237 : If user does not change the default name of the data
//                               collector when they first create it, change it for 
//                               them to a more meaningful name based on the data
//                               they select in the property pages.


#include "stdafx.h"
#include "snapin.h"
#include "DPFtpPage.h"
#include "HMDataElementConfiguration.h"
#include "HMObject.h"
#include "ProxyDialog.h"
#include "DataElement.h"
#include "DataGroupScopeItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDPFtpPage property page

IMPLEMENT_DYNCREATE(CDPFtpPage, CHMPropertyPage)

CDPFtpPage::CDPFtpPage() : CHMPropertyPage(CDPFtpPage::IDD)
{
	//{{AFX_DATA_INIT(CDPFtpPage)
	m_bUseAscii = FALSE;
	m_sFile = _T("");
	m_sPassword = _T("");
	m_sServer = _T("");
	m_sTimeout = _T("");
	m_sUser = _T("");
	m_bRequireReset = FALSE;
	m_sDownloadDir = _T("");
	//}}AFX_DATA_INIT

	m_sHelpTopic = _T("HMon21.chm::/dDEftp.htm");
}

CDPFtpPage::~CDPFtpPage()
{
}

void CDPFtpPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDPFtpPage)
	DDX_Check(pDX, IDC_CHECK_USE_ASCII, m_bUseAscii);
	DDX_Text(pDX, IDC_EDIT_FILE, m_sFile);
	DDX_Text(pDX, IDC_EDIT_PASSWORD, m_sPassword);
	DDX_Text(pDX, IDC_EDIT_SERVER, m_sServer);
	DDX_Text(pDX, IDC_EDIT_TIMEOUT, m_sTimeout);
	DDX_Text(pDX, IDC_EDIT_USER, m_sUser);
	DDX_Check(pDX, IDC_CHECK_REQUIRE_RESET, m_bRequireReset);
	DDX_Text(pDX, IDC_EDIT_DOWNLOAD_DIRECTORY, m_sDownloadDir);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDPFtpPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CDPFtpPage)
	ON_BN_CLICKED(IDC_CHECK_REQUIRE_RESET, OnCheckRequireReset)
	ON_BN_CLICKED(IDC_CHECK_USE_ASCII, OnCheckUseAscii)
	ON_EN_CHANGE(IDC_EDIT_FILE, OnChangeEditFile)
	ON_EN_CHANGE(IDC_EDIT_PASSWORD, OnChangeEditPassword)
	ON_EN_CHANGE(IDC_EDIT_TIMEOUT, OnChangeEditTimeout)
	ON_EN_CHANGE(IDC_EDIT_USER, OnChangeEditUser)
	ON_BN_CLICKED(IDC_BUTTON_PROXY, OnButtonProxy)
	ON_EN_CHANGE(IDC_EDIT_SERVER, OnChangeEditServer)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDPFtpPage message handlers

BOOL CDPFtpPage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();


	CHMPropertyPage::OnInitDialog();
	
	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return TRUE;
	}

    //-------------------------------------------------------------------------
    // v-marfin 59237 : Store original name in case this data collector is
    //                  just being created. When they save, we will modify the 
    //                  name if they haven't.
	pClassObject->GetProperty(IDS_STRING_MOF_NAME,m_sOriginalName);
    //-------------------------------------------------------------------------


	bool bReset;
	pClassObject->GetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);
	m_bRequireReset = bReset;

	COleSafeArray arguments;
	HMContextArray Arguments;
	HRESULT hr = pClassObject->GetProperty(IDS_STRING_MOF_ARGUMENTS,arguments);

	if( hr != S_FALSE )
	{
		CHMPolledMethodDataElementConfiguration::CopyArgsFromSafeArray(arguments,Arguments);
	}

	if( Arguments.GetSize() == 8 )
	{
		m_sServer = Arguments[0]->m_sValue;
		m_sProxy = Arguments[1]->m_sValue;
		m_sUser = Arguments[2]->m_sValue;
		m_sPassword = Arguments[3]->m_sValue;
		m_sFile = Arguments[4]->m_sValue + Arguments[5]->m_sValue;
		m_sTimeout = Arguments[6]->m_sValue;
		m_bUseAscii = Arguments[7]->m_sValue != _T("0");

		int iIndex = m_sProxy.Find(_T(":"));
		if( iIndex != -1 )  // v-marfin 62447 : should read != instead of ==
		{
			m_sPort = m_sProxy.Right((m_sProxy.GetLength()-iIndex)-1);
			m_sProxy = m_sProxy.Left(iIndex);
		}
	}

	CHMPolledMethodDataElementConfiguration::DestroyArguments(Arguments);

	delete pClassObject;

	UpdateData(FALSE);	

	SendDlgItemMessage(IDC_SPIN9,UDM_SETRANGE32,0,INT_MAX-1);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CDPFtpPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}
	
    // v-marfin 62585 : So we can set the collector's state to enabled when OK pressed.
    m_bOnApplyUsed=TRUE;

	UpdateData();

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return FALSE;
	}

	HRESULT hr = S_OK;
	HMContextArray Arguments;

	CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("Server"),CIM_STRING,m_sServer);
	
	if( ! m_sProxy.IsEmpty() && !m_sPort.IsEmpty() )	
	{
		CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("Proxy"),CIM_STRING,m_sProxy+_T(":")+m_sPort);
	}
	else
	{
		CString sEmpty;
		CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("Proxy"),CIM_STRING,sEmpty);
	}
	
	CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("User"),CIM_STRING,m_sUser);

	CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("Password"),CIM_STRING,m_sPassword);

  TCHAR szDir[_MAX_DIR];
  TCHAR szFname[_MAX_FNAME];
  TCHAR szExt[_MAX_EXT];

  _tsplitpath( m_sFile, NULL, szDir, szFname, szExt );  

	CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("Directory"),CIM_STRING,szDir);

	CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("File"),CIM_STRING,CString(szFname) + CString(szExt));

	CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("Timeout"),CIM_UINT32,m_sTimeout);

	CString sUseAscii = m_bUseAscii ? _T("65535") : _T("0");
	CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("UseAscii"),CIM_BOOLEAN,sUseAscii);

	COleSafeArray arguments;
	CHMPolledMethodDataElementConfiguration::CopyArgsToSafeArray(Arguments,arguments);

	hr = pClassObject->SetProperty(IDS_STRING_MOF_ARGUMENTS,arguments);

	CHMPolledMethodDataElementConfiguration::DestroyArguments(Arguments);

	CString sNamespace = _T("root\\cimv2\\MicrosoftHealthmonitor");
	pClassObject->SetProperty(IDS_STRING_MOF_TARGETNAMESPACE,sNamespace);

	pClassObject->SetProperty(IDS_STRING_MOF_PATH,CString(_T("Microsoft_IPPExecution")));

	pClassObject->SetProperty(IDS_STRING_MOF_METHODNAME,CString(_T("ExecuteFTP")));

	CStringArray saProperties;	
	saProperties.Add(_T("ResponseTime"));
	saProperties.Add(_T("OverallResultCode"));
	pClassObject->GetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saProperties);

	bool bReset = m_bRequireReset ? true : false;
	pClassObject->SetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);

	pClassObject->SaveAllProperties();
	
	delete pClassObject;	

  SetModified(FALSE);

	return TRUE;
}

void CDPFtpPage::OnCheckRequireReset() 
{
	SetModified();
	
}

void CDPFtpPage::OnCheckUseAscii() 
{
	SetModified();
	
}

void CDPFtpPage::OnChangeEditFile() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CDPFtpPage::OnChangeEditPassword() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CDPFtpPage::OnChangeEditServer() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CDPFtpPage::OnChangeEditTimeout() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CDPFtpPage::OnChangeEditUser() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();
	
}

void CDPFtpPage::OnButtonProxy() 
{
	CProxyDialog dlg;

	dlg.m_bUseProxy = !m_sProxy.IsEmpty() && !m_sPort.IsEmpty();
	dlg.m_sAddress = m_sProxy;
	dlg.m_sPort = m_sPort;

	if( dlg.DoModal() == IDOK )
	{
		if( dlg.m_bUseProxy )
		{
			m_sProxy = dlg.m_sAddress;
			m_sPort = dlg.m_sPort;
		}
		else
		{
			m_sProxy.Empty();
			m_sPort.Empty();
		}
		UpdateData(FALSE);
	}
}

void CDPFtpPage::OnDestroy() 
{
    // v-marfin 62585 : For this new data collector, set its Enabled property to TRUE, but
    //                  only if the user is not cancelling these property pages.
    if (m_bOnApplyUsed)
    {
        ClearStatistics(); // 62548

        CDataElement* pElement = (CDataElement*)GetObjectPtr();
        if (pElement && pElement->IsStateSetToEnabledOnOK())
        {
            TRACE(_T("CDPFtpPage::OnDestroy - New Perfmon Collector: Setting to Enabled\n"));

            pElement->SetStateToEnabledOnOK(FALSE); // don't do this again
	        
	        CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	        if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	        {
                TRACE(_T("ERROR: CDPFtpPage::OnDestroy - Failed to GetClassObject()\n"));
		        return;
	        }

            // Set the new collector to enabled.
            BOOL bEnabled=TRUE;
	        HRESULT hr = pClassObject->GetProperty(IDS_STRING_MOF_ENABLE,bEnabled);
	        hr = pClassObject->SetProperty(IDS_STRING_MOF_ENABLE,TRUE);
            
            if (!CHECKHRESULT(hr))
            {   
                TRACE(_T("ERROR: CDPFtpPage::OnDestroy - Failed to set ENABLED property on new collector\n"));
            }
            

            //-------------------------------------------------------------------
            // v-marfin 59237 : If the user has not changed the original default
            //                  name, do so for them. Compare against original
            //                  name we fetched during OnInitDialog.
            CString sName;
	        pClassObject->GetProperty(IDS_STRING_MOF_NAME,sName);

            // Did the user change the default name?
            if (m_sOriginalName.CompareNoCase(sName)==0)
            {       
                // No, so set the new name 
                if (!m_sServer.IsEmpty())
                {
                    // Use parent to ensure name is unique
                    //CDataGroup* pParent = (CDataGroup*) pElement->GetCollectorsParentClassObject();
	                if(pElement->GetScopeItemCount())
	                {
		                CDataElementScopeItem* pItem = (CDataElementScopeItem*)pElement->GetScopeItem(0);
		                if( pItem )
                        {
                            CDataGroupScopeItem* pDGItem = (CDataGroupScopeItem*)pItem->GetParent();
                            sName = pDGItem->GetUniqueDisplayName(m_sServer);
                        }
                    }

                    // Set the local element's object data
                    pElement->SetName(sName);
                    // Set its WMI property
                    pClassObject->SetProperty(IDS_STRING_MOF_NAME,sName);

                    // Refresh to show the new name in the IU
                    //pElement->Refresh();      // 63005
                    pElement->UpdateStatus();   // 63005
                }
            }
            //-------------------------------------------------------------------

            pClassObject->SaveAllProperties();
            delete pClassObject;

        } // if (pElement && pElement->IsStateSetToEnabledOnOK())
    } // if (m_bOnApplyUsed)

	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpfileinfopage.h ===
#if !defined(AFX_DPFILEINFOPAGE_H__0708329F_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_)
#define AFX_DPFILEINFOPAGE_H__0708329F_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DPFileInfoPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDPFileInfoPage dialog

class CDPFileInfoPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CDPFileInfoPage)

// Construction
public:
	CDPFileInfoPage();
	~CDPFileInfoPage();

// Dialog Data
	//{{AFX_DATA(CDPFileInfoPage)
	enum { IDD = IDD_DATAPOINT_FILEINFORMATION };
	CListCtrl	m_FolderProperties;
	CListCtrl	m_FileProperties;
	BOOL	m_bRequireReset;
	CString	m_sFile;
	CString	m_sFolder;
	int		m_iType;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDPFileInfoPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void UpdateProperties(CListCtrl& Properties, const CString& sNamespace, const CString& sClass);
	// Generated message map functions
	//{{AFX_MSG(CDPFileInfoPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonBrowseFile();
	afx_msg void OnButtonBrowseFolder();
	afx_msg void OnCheckRequireReset();
	afx_msg void OnChangeEditFile();
	afx_msg void OnChangeEditFolder();
	afx_msg void OnRadio1();
	afx_msg void OnRadio2();
	afx_msg void OnClickListFileProperties(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnClickListFolderProperties(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPFILEINFOPAGE_H__0708329F_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpgeneralpage.h ===
#if !defined(AFX_DPGENERALPAGE_H__52566157_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_)
#define AFX_DPGENERALPAGE_H__52566157_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DPGeneralPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDPGeneralPage dialog

class CDPGeneralPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CDPGeneralPage)

// Construction
public:
	CDPGeneralPage();
	~CDPGeneralPage();

// Dialog Data
	//{{AFX_DATA(CDPGeneralPage)
	enum { IDD = IDD_DATAPOINT_GENERAL };
	CString	m_sName;
	CString	m_sComment;
	CString	m_sCreationDate;
	CString	m_sModifiedDate;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDPGeneralPage)
	public:
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDPGeneralPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnChangeEditComment();
	afx_msg void OnChangeEditName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPGENERALPAGE_H__52566157_C9D1_11D2_BD8D_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpgenericpage.cpp ===
// DPGenericPage.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
// 03/27/00 v-marfin bug 62317 : Require user to select at least 1 property before saving
// 03/27/00 v-marfin bug 60014 : Ensure instance exists before letting user save value.
// 03/29/00 v-marfin bug 62585 : Set new Data collector's ENABLED to TRUE if user presses OK.
// 03/30/00 v-marfin bug 59237 : If user does not change the default name of the data
//                               collector when they first create it, change it for 
//                               them to a more meaningful name based on the data
//                               they select in the property pages.
//
#include "stdafx.h"
#include "snapin.h"
#include "DPGenericPage.h"
#include "HMObject.h"
#include "HMDataElementConfiguration.h"
#include "WmiBrowseDlg.h"
#include "WmiPropertyBrowseDlg.h"
#include "DataElement.h"
#include "DataGroupScopeItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDPWmiInstancePage property page

// static array

IMPLEMENT_DYNCREATE(CDPWmiInstancePage, CHMPropertyPage)

CDPWmiInstancePage::CDPWmiInstancePage() : CHMPropertyPage(CDPWmiInstancePage::IDD)
{
	//{{AFX_DATA_INIT(CDPWmiInstancePage)
	m_bManualReset = FALSE;
	m_sClass = _T("");
	m_sInstance = _T("");
	m_sNamespace = _T("");
	//}}AFX_DATA_INIT

	m_sHelpTopic = _T("HMon21.chm::/dDEinst.htm");
}

CDPWmiInstancePage::~CDPWmiInstancePage()
{
}

void CDPWmiInstancePage::UpdateProperties()
{
	m_Properties.DeleteAllItems();

	if( m_sClass.IsEmpty() )
	{
		return;
	}

	CWbemClassObject classobject;

	classobject.SetNamespace(_T("\\\\") + GetObjectPtr()->GetSystemName() + _T("\\") + m_sNamespace);

	HRESULT hr = classobject.GetObject(m_sClass);

	if( hr != S_OK )
	{
		return;
	}

	CStringArray saNames;
	classobject.GetPropertyNames(saNames);
	classobject.Destroy();

	for( int i = 0; i < saNames.GetSize(); i++ )
	{
		m_Properties.InsertItem(0,saNames[i]);
	}

	m_Properties.SetColumnWidth(0,LVSCW_AUTOSIZE);
}

void CDPWmiInstancePage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDPWmiInstancePage)
	DDX_Control(pDX, IDC_LIST_PROPERTIES, m_Properties);
	DDX_Check(pDX, IDC_CHECK_MANUAL_RESET, m_bManualReset);
	DDX_Text(pDX, IDC_EDIT_CLASS, m_sClass);
	DDX_Text(pDX, IDC_EDIT_INSTANCE, m_sInstance);
	DDX_Text(pDX, IDC_EDIT_NAMESPACE, m_sNamespace);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDPWmiInstancePage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CDPWmiInstancePage)
	ON_BN_CLICKED(IDC_CHECK_MANUAL_RESET, OnCheckManualReset)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_NAMESPACE, OnButtonBrowseNamespace)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_CLASS, OnButtonBrowseClass)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_INSTANCE, OnButtonBrowseInstance)
	ON_EN_CHANGE(IDC_EDIT_NAMESPACE, OnChangeEditNamespace)
	ON_EN_CHANGE(IDC_EDIT_CLASS, OnChangeEditClass)
	ON_EN_CHANGE(IDC_EDIT_INSTANCE, OnChangeEditInstance)
	ON_NOTIFY(NM_CLICK, IDC_LIST_PROPERTIES, OnClickListProperties)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDPWmiInstancePage message handlers

BOOL CDPWmiInstancePage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();	

	// initialize the list view
	m_Properties.SetExtendedStyle(LVS_EX_CHECKBOXES);


	CString sColumnTitle;
	sColumnTitle.LoadString(IDS_STRING_NAME);
	m_Properties.InsertColumn(0,sColumnTitle);

    //-------------------------------------------------------------------------
	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();
	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return TRUE;
	}
    // v-marfin 59237 : Store original name in case this data collector is
    //                  just being created. When they save, we will modify the 
    //                  name if they haven't.
	pClassObject->GetProperty(IDS_STRING_MOF_NAME,m_sOriginalName);
    delete pClassObject;

    //-------------------------------------------------------------------------

	CString sObjectPath = GetObjectPtr()->GetObjectPath();

	CHMPolledGetObjectDataElementConfiguration pgodec;

	pgodec.Create(GetObjectPtr()->GetSystemName());

	pgodec.GetObject(GetObjectPtr()->GetObjectPath());

	pgodec.GetAllProperties();

	m_sNamespace = pgodec.m_sTargetNamespace;
	m_sClass = pgodec.m_sObjectPath;

	int iIndex = -1;
	if( (iIndex = m_sClass.Find(_T("."))) != -1 )
	{
		m_sInstance = m_sClass;
		m_sClass = m_sClass.Left(iIndex);
	}

	m_bManualReset = pgodec.m_bRequireManualReset;

	UpdateProperties();

	for( int i=0; i < pgodec.m_saStatisticsPropertyNames.GetSize(); i++ )
	{
		LVFINDINFO lvfi;
		ZeroMemory(&lvfi,sizeof(LVFINDINFO));
		lvfi.flags = LVFI_WRAP|LVFI_STRING;
		lvfi.psz = pgodec.m_saStatisticsPropertyNames[i];
		int iListIndex = m_Properties.FindItem(&lvfi);
		if( iListIndex >= 0 )
		{
			m_Properties.SetCheck(iListIndex);
		}
	}


	UpdateData(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDPWmiInstancePage::OnCheckManualReset() 
{
	UpdateData();
	SetModified();	
}

void CDPWmiInstancePage::OnOK() 
{
	CHMPropertyPage::OnOK();
}

void CDPWmiInstancePage::OnButtonBrowseNamespace() 
{
	CWmiNamespaceBrowseDlg dlg;

	// set the dialog window title
	CString sItem;
	sItem.LoadString(IDS_STRING_NAMESPACES);
	dlg.m_sDlgTitle.Format(IDS_STRING_WMI_BROWSE_TITLE,sItem,GetObjectPtr()->GetSystemName());

	// create the namespace enumerator
	if( ! CHECKHRESULT(dlg.m_ClassObject.Create(GetObjectPtr()->GetSystemName())) )
	{
		return;
	}

	if( m_sNamespace.IsEmpty() )
	{
		m_sNamespace.Format(IDS_STRING_MOF_NAMESPACE_FORMAT,GetObjectPtr()->GetSystemName());
	}

	dlg.m_sTitle.Format(_T("\\\\%s\\%s"),GetObjectPtr()->GetSystemName(),m_sNamespace);
	dlg.m_ClassObject.SetNamespace(dlg.m_sTitle);

	// set the listbox title
	dlg.m_sTitle = m_sNamespace;

	// display dialog
	if( dlg.DoModal() == IDOK )
	{
		m_sNamespace = dlg.m_sSelectedItem;
		m_sClass.Empty();
		m_sInstance.Empty();
		UpdateData(FALSE);
		UpdateProperties();
		SetModified();
	}
}

void CDPWmiInstancePage::OnButtonBrowseClass() 
{

	//-----------------------------------------------------------------------------
	// v-marfin : 60754 : Validate namespace before attempting to browse for class.
	UpdateData();
	CSnapInApp* pApp = (CSnapInApp*)AfxGetApp();
	if ((pApp) && (!pApp->ValidNamespace(m_sNamespace,GetObjectPtr()->GetSystemName())))
	{
		AfxMessageBox(IDS_ERR_INVALID_NAMESPACE);
		GetDlgItem(IDC_EDIT_NAMESPACE)->SetFocus();
		return;
	}
	//------------------------------------------------------------------------------

	CWmiClassBrowseDlg dlg;	

	// set the dialog window title
	CString sItem;
	sItem.LoadString(IDS_STRING_CLASSES);
	dlg.m_sDlgTitle.Format(IDS_STRING_WMI_BROWSE_TITLE,sItem,GetObjectPtr()->GetSystemName());

	// create the class enumerator
	if( ! CHECKHRESULT(dlg.m_ClassObject.Create(GetObjectPtr()->GetSystemName())) )
	{
		return;
	}

	CString sTemp;
	sTemp.Format(_T("\\\\%s\\%s"),GetObjectPtr()->GetSystemName(),m_sNamespace);

	dlg.m_ClassObject.SetNamespace(sTemp);

	if( ! CHECKHRESULT(dlg.m_ClassObject.CreateClassEnumerator(NULL)) )
	{
		return;
	}

	// set the listbox title
	dlg.m_sTitle = m_sNamespace;

	// display the dialog	
	if( dlg.DoModal() == IDOK )
	{
		m_sClass = dlg.m_sSelectedItem;
		m_sInstance.Empty();
		UpdateData(FALSE);
		UpdateProperties();
		SetModified();
	}	
}

void CDPWmiInstancePage::OnButtonBrowseInstance() 
{
	//----------------------------------------------------------
	// v-marfin 60014 : Ensure the class exists before attempting to read for instance
	UpdateData();

	m_sClass.TrimRight();
	m_sClass.TrimLeft();
	if (m_sClass.IsEmpty())
	{
		AfxMessageBox(IDS_ERR_CLASS_REQUIRED_FOR_INSTANCE);
		GetDlgItem(IDC_EDIT_CLASS)->SetFocus();
		return;
	}
	//----------------------------------------------------------

	//----------------------------------------
	// v-marfin 60754 : Validate the namespace
	CSnapInApp* pApp = (CSnapInApp*)AfxGetApp();
	if ((pApp) && (!pApp->ValidNamespace(m_sNamespace,GetObjectPtr()->GetSystemName())))
	{
		AfxMessageBox(IDS_ERR_INVALID_NAMESPACE);
		GetDlgItem(IDC_EDIT_NAMESPACE)->SetFocus();
		return;
	}
	//-----------------------------------------


	CWmiInstanceBrowseDlg dlg;	

	// set the dialog window title
	CString sItem;
	sItem.LoadString(IDS_STRING_INSTANCES);
	dlg.m_sDlgTitle.Format(IDS_STRING_WMI_BROWSE_TITLE,sItem,GetObjectPtr()->GetSystemName());

	// create the instance enumerator
	if( ! CHECKHRESULT(dlg.m_ClassObject.Create(GetObjectPtr()->GetSystemName())) )
	{
		return;
	}

	CString sTemp;
	sTemp.Format(_T("\\\\%s\\%s"),GetObjectPtr()->GetSystemName(),m_sNamespace);

	dlg.m_ClassObject.SetNamespace(sTemp);

	BSTR bsTemp = m_sClass.AllocSysString();
	if( ! CHECKHRESULT(dlg.m_ClassObject.CreateEnumerator(bsTemp)) )
	{
		::SysFreeString(bsTemp);
		return;
	}
	::SysFreeString(bsTemp);

	// set the listbox title
	dlg.m_sTitle = m_sNamespace;

	// display the dialog	
	if( dlg.DoModal() == IDOK )
	{
		m_sInstance = dlg.m_sSelectedItem;
		UpdateData(FALSE);		
		SetModified();
	}	
}


void CDPWmiInstancePage::OnChangeEditNamespace() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

  if( m_sNamespace.Find(_T("\\\\")) != -1 )
  {
    AfxMessageBox(IDS_STRING_NO_REMOTE_NAMESPACES);
    GetDlgItem(IDC_EDIT_NAMESPACE)->SetWindowText(_T(""));
  }

	GetDlgItem(IDC_EDIT_CLASS)->SetWindowText(_T(""));	
	GetDlgItem(IDC_EDIT_INSTANCE)->SetWindowText(_T(""));	
	UpdateData();
	UpdateProperties();
	SetModified();
}

void CDPWmiInstancePage::OnChangeEditClass() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	GetDlgItem(IDC_EDIT_INSTANCE)->SetWindowText(_T(""));	
	UpdateData();
	UpdateProperties();
	SetModified();
}

void CDPWmiInstancePage::OnChangeEditInstance() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

    // 60014b------------------------------------------------------------------
	m_sClass.TrimLeft();
	m_sInstance.TrimLeft();
	int i = 0;
	for (LPCTSTR p = (LPCTSTR)m_sInstance; *p; p++, i++)
	{
		if (iswspace(*p))
			continue;
		if (!iswalnum(*p) || *p == _T('_'))
		{
			// if this, the first non-alphanum character, is 
			// a ".", then the string before us is the class name.  If
			// the current class name does not match this, fill it in
			// automatically.
			if (*p == _T('.'))
			{
				CString strClass(m_sInstance, i);	// first "i" chars
				if (strClass != m_sClass)
				{
					GetDlgItem (IDC_EDIT_CLASS)->SetWindowText(strClass);
					UpdateData();
				}
			}

			// since we've reached the end of the first "word", we know
			// that the class name can't be here.  leave the loop
			break;
		}
	}

    //-------------------------------------------------------------------------


	UpdateData();
	SetModified();
}


BOOL CDPWmiInstancePage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

    // v-marfin 62585 : So we can set the collector's state to enabled when OK pressed.
    m_bOnApplyUsed=TRUE;

	//------------------------------------------------------------------
	// v-marfin 60014 : Ensure the instance specified exists if specified
	UpdateData();

	m_sClass.TrimRight();
	m_sClass.TrimLeft();
	if (m_sClass.IsEmpty())
	{
        // 60014b : Changed msgbox to MB_OKCANCEL
		AfxMessageBox(IDS_ERR_CLASS_REQUIRED);
		GetDlgItem(IDC_EDIT_CLASS)->SetFocus();
		return FALSE;
	}

    // Class must exist
	if (!ObjectExists(m_sClass))
	{
        // 60014b : Changed msgbox to MB_OKCANCEL
		AfxMessageBox(IDS_ERR_CLASS_REQUIRED);
		GetDlgItem(IDC_EDIT_CLASS)->SetFocus();
		return FALSE;
	}

	m_sInstance.TrimRight();
	m_sInstance.TrimLeft();
    BOOL bInstanceExists=TRUE;

	if (!m_sInstance.IsEmpty())
	{
		if (!ObjectExists(m_sInstance))
		{
            // 60014b : Changed msgbox to MB_OKCANCEL
			if (AfxMessageBox(IDS_ERR_INSTANCE_NOT_EXISTS,MB_OKCANCEL) == IDCANCEL)
            {
			    GetDlgItem(IDC_EDIT_INSTANCE)->SetFocus();
			    return FALSE;
            }

            bInstanceExists=FALSE;
		}
	}
	//------------------------------------------------------------------


	CStringArray saProperties;

	for( int i = 0; i < m_Properties.GetItemCount(); i++ )
	{
		if( m_Properties.GetCheck(i) )
		{			
			saProperties.Add(m_Properties.GetItemText(i,0));
		}
	}

    // 62317b Only present err if there were any properties to begin with.
	if ((saProperties.GetSize()==0) && (m_Properties.GetItemCount()>0) )
	{
		// v-marfin 62317 : Add err msg so user knows what is going on.
		AfxMessageBox(IDS_ERR_MUST_SELECT_ATLEAST_ONE_PROPERTY);
		return FALSE;
	}

	CString sObjectPath = GetObjectPtr()->GetObjectPath();

	CHMPolledGetObjectDataElementConfiguration pgodec;

	pgodec.Create(GetObjectPtr()->GetSystemName());

	pgodec.GetObject(GetObjectPtr()->GetObjectPath());

	pgodec.GetAllProperties();

	pgodec.m_saStatisticsPropertyNames.RemoveAll();

	pgodec.m_sTargetNamespace = m_sNamespace;
	if ((m_sInstance.IsEmpty()) || (!bInstanceExists))
	{
		pgodec.m_sObjectPath = m_sClass;
	}
	else
	{
		pgodec.m_sObjectPath = m_sInstance;
	}

	pgodec.m_saStatisticsPropertyNames.Copy(saProperties);

	pgodec.SaveAllProperties();

  SetModified(FALSE);
	
	return TRUE;
}

void CDPWmiInstancePage::OnClickListProperties(NMHDR* pNMHDR, LRESULT* pResult) 
{
	SetModified();
	
	*pResult = 0;
}

void CDPWmiInstancePage::OnDestroy() 
{
    // v-marfin 62585 : For this new data collector, set its Enabled property to TRUE, but
    //                  only if the user is not cancelling these property pages.
    if (m_bOnApplyUsed)
    {
        ClearStatistics(); // 62548

        CDataElement* pElement = (CDataElement*)GetObjectPtr();
        if (pElement && pElement->IsStateSetToEnabledOnOK())
        {
            TRACE(_T("CDPWmiInstancePage::OnDestroy - New Perfmon Collector: Setting to Enabled\n"));

            pElement->SetStateToEnabledOnOK(FALSE); // don't do this again
	        
	        CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	        if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	        {
                TRACE(_T("ERROR: CDPWmiInstancePage::OnDestroy - Failed to GetClassObject()\n"));
		        return;
	        }

            // Set the new collector to enabled.
            BOOL bEnabled=TRUE;
	        HRESULT hr = pClassObject->GetProperty(IDS_STRING_MOF_ENABLE,bEnabled);
	        hr = pClassObject->SetProperty(IDS_STRING_MOF_ENABLE,TRUE);
            
            if (!CHECKHRESULT(hr))
            {   
                TRACE(_T("ERROR: CDPWmiInstancePage::OnDestroy - Failed to set ENABLED property on new collector\n"));
            }
            
            //-------------------------------------------------------------------
            // v-marfin 59237 : If the user has not changed the original default
            //                  name, do so for them. Compare against original
            //                  name we fetched during OnInitDialog.
            CString sName;
	        pClassObject->GetProperty(IDS_STRING_MOF_NAME,sName);

            // Did the user change the default name?
            if (m_sOriginalName.CompareNoCase(sName)==0)
            {       
                // 62981 : set new name to instance, or class if instance is empty
                CString sObject = m_sInstance.IsEmpty() ? m_sClass : m_sInstance;

                // No, so set the new name 
                if (!sObject.IsEmpty())
                {
                    // Use parent to ensure name is unique
                    //CDataGroup* pParent = (CDataGroup*) pElement->GetCollectorsParentClassObject();
	                if(pElement->GetScopeItemCount())
	                {
		                CDataElementScopeItem* pItem = (CDataElementScopeItem*)pElement->GetScopeItem(0);
		                if( pItem )
                        {
                            CDataGroupScopeItem* pDGItem = (CDataGroupScopeItem*)pItem->GetParent();
                            sName = pDGItem->GetUniqueDisplayName(sObject);
                        }
                    }

                    // Set the local element's object data
                    pElement->SetName(sName);
                    // Set its WMI property
                    pClassObject->SetProperty(IDS_STRING_MOF_NAME,sName);

                    // Refresh to show the new name in the IU
                    //pElement->Refresh();      // 63005
                    pElement->UpdateStatus();   // 63005
                }
            }
            //-------------------------------------------------------------------

            pClassObject->SaveAllProperties();
            delete pClassObject;

        } // if (pElement && pElement->IsStateSetToEnabledOnOK())
    } // if (m_bOnApplyUsed)


	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}

// v-marfin : 60014
//******************************************************************
// InstanceExists
//******************************************************************
BOOL CDPWmiInstancePage::ObjectExists(const CString &refObjectPath)
{
    CString sNamespace;

	if (refObjectPath.IsEmpty())
		return FALSE;

	ULONG ulReturned = 0L;
	int i = 0;

	CWbemClassObject* pClassObject = new CWbemClassObject;
    if (!pClassObject)
        return TRUE;

	pClassObject->SetNamespace(_T("\\\\") + GetObjectPtr()->GetSystemName() + _T("\\") + m_sNamespace);
	HRESULT hr = pClassObject->GetObject(refObjectPath);

    delete pClassObject;
    return (hr == S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpgenericpage.h ===
#if !defined(AFX_DPGENERICPAGE_H__07083299_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_)
#define AFX_DPGENERICPAGE_H__07083299_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DPGenericPage.h : header file
//

#include "HMPropertyPage.h"
#include "WbemClassObject.h"	// Added by ClassView

/////////////////////////////////////////////////////////////////////////////
// CDPWmiInstancePage dialog

class CDPWmiInstancePage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CDPWmiInstancePage)

// Construction
public:
	BOOL ObjectExists(const CString &refPath);
	CDPWmiInstancePage();
	~CDPWmiInstancePage();

// Dialog Data
	//{{AFX_DATA(CDPWmiInstancePage)
	enum { IDD = IDD_DATAPOINT_WMI_INSTANCE };
	CListCtrl	m_Properties;
	BOOL	m_bManualReset;
	CString	m_sClass;
	CString	m_sInstance;
	CString	m_sNamespace;
	//}}AFX_DATA

// operations
protected:
// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDPWmiInstancePage)
	public:
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void UpdateProperties();
	// Generated message map functions
	//{{AFX_MSG(CDPWmiInstancePage)
	afx_msg void OnCheckManualReset();
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonBrowseNamespace();
	afx_msg void OnButtonBrowseClass();
	afx_msg void OnButtonBrowseInstance();
	afx_msg void OnChangeEditNamespace();
	afx_msg void OnChangeEditClass();
	afx_msg void OnChangeEditInstance();
	afx_msg void OnClickListProperties(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPGENERICPAGE_H__07083299_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpicmppage.cpp ===
// DPIcmpPage.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
// 03/24/00 v-marfin bug 60651 : Removed Hope Count from dialog.
// 03/29/00 v-marfin bug 62585 : Set new Data collector's ENABLED to TRUE if user presses OK.
// 03/30/00 v-marfin bug 59237 : If user does not change the default name of the data
//                               collector when they first create it, change it for 
//                               them to a more meaningful name based on the data
//                               they select in the property pages.

#include "stdafx.h"
#include "snapin.h"
#include "DPIcmpPage.h"
#include "HMObject.h"
#include "HMDataElementConfiguration.h"
#include "DataElement.h"
#include "DataGroupScopeItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDPIcmpPage property page

IMPLEMENT_DYNCREATE(CDPIcmpPage, CHMPropertyPage)

CDPIcmpPage::CDPIcmpPage() : CHMPropertyPage(CDPIcmpPage::IDD)
{
	//{{AFX_DATA_INIT(CDPIcmpPage)
	m_bRequireReset = FALSE;
	m_sRetryCount = _T("4");
	m_sServer = _T("");
	m_sTimeout = _T("10");
	//}}AFX_DATA_INIT
}

CDPIcmpPage::~CDPIcmpPage()
{
}

void CDPIcmpPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDPIcmpPage)
	DDX_Check(pDX, IDC_CHECK_REQUIRE_RESET, m_bRequireReset);
	DDX_Text(pDX, IDC_EDIT_RETRY_COUNT, m_sRetryCount);
	DDX_Text(pDX, IDC_EDIT_SERVER, m_sServer);
	DDX_Text(pDX, IDC_EDIT_TIMEOUT, m_sTimeout);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDPIcmpPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CDPIcmpPage)
	ON_BN_CLICKED(IDC_CHECK_REQUIRE_RESET, OnCheckRequireReset)
	ON_EN_CHANGE(IDC_EDIT_SERVER, OnChangeEditServer)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_SYSTEM, OnButtonBrowseSystem)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDPIcmpPage message handlers

BOOL CDPIcmpPage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();

	CHMPropertyPage::OnInitDialog();

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return TRUE;
	}

	bool bReset;
	pClassObject->GetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);
	m_bRequireReset = bReset;

    //-------------------------------------------------------------------------
    // v-marfin 59237 : Store original name in case this data collector is
    //                  just being created. When they save, we will modify the 
    //                  name if they haven't.
	pClassObject->GetProperty(IDS_STRING_MOF_NAME,m_sOriginalName);
    //-------------------------------------------------------------------------


	COleSafeArray arguments;
	HMContextArray Arguments;
	HRESULT hr = pClassObject->GetProperty(IDS_STRING_MOF_ARGUMENTS,arguments);

	if( hr != S_FALSE )
	{
		CHMPolledMethodDataElementConfiguration::CopyArgsFromSafeArray(arguments,Arguments);
	}

	if( Arguments.GetSize() == 3 )
	{
		m_sServer = Arguments[0]->m_sValue;
		m_sTimeout = Arguments[1]->m_sValue;
		m_sRetryCount = Arguments[2]->m_sValue;
	}

	CHMPolledMethodDataElementConfiguration::DestroyArguments(Arguments);

	delete pClassObject;

	UpdateData(FALSE);

	SendDlgItemMessage(IDC_SPIN1,UDM_SETRANGE32,0,999999);	
	SendDlgItemMessage(IDC_SPIN2,UDM_SETRANGE32,0,999999);	
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CDPIcmpPage::OnApply() 
{
	if( ! CHMPropertyPage::OnApply() )
	{
		return FALSE;
	}

    // v-marfin 62585 : So we can set the collector's state to enabled when OK pressed.
    m_bOnApplyUsed=TRUE;
	
	UpdateData();

	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return FALSE;
	}

	HRESULT hr = S_OK;
	HMContextArray Arguments;


	CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("IPAddress"),CIM_STRING,m_sServer);

	CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("TimeOut"),CIM_UINT32,m_sTimeout);

	CHMPolledMethodDataElementConfiguration::AddArgument(Arguments,GetObjectPtr()->GetSystemName(),_T("Tries"),CIM_UINT32,m_sRetryCount);

	COleSafeArray arguments;
	CHMPolledMethodDataElementConfiguration::CopyArgsToSafeArray(Arguments,arguments);

	hr = pClassObject->SetProperty(IDS_STRING_MOF_ARGUMENTS,arguments);

	CHMPolledMethodDataElementConfiguration::DestroyArguments(Arguments);

	CString sNamespace = _T("root\\cimv2\\MicrosoftHealthmonitor");
	pClassObject->SetProperty(IDS_STRING_MOF_TARGETNAMESPACE,sNamespace);

	pClassObject->SetProperty(IDS_STRING_MOF_PATH,CString(_T("PingPoller")));

	pClassObject->SetProperty(IDS_STRING_MOF_METHODNAME,CString(_T("Ping")));

	/* 63128 
    CStringArray saProperties;	
	saProperties.Add(_T("Status"));
	pClassObject->SetProperty(IDS_STRING_MOF_STATISTICSPROPERTYNAMES,saProperties);*/

	bool bReset = m_bRequireReset ? true : false;
	pClassObject->SetProperty(IDS_STRING_MOF_REQUIRERESET,bReset);

	pClassObject->SaveAllProperties();
	
	delete pClassObject;	

  SetModified(FALSE);

	return TRUE;
}

void CDPIcmpPage::OnCheckRequireReset() 
{
	SetModified();	
}

void CDPIcmpPage::OnChangeEditServer() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CHMPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetModified();	
}

void CDPIcmpPage::OnButtonBrowseSystem() 
{
	UpdateData();

	LPMALLOC pMalloc;
	if( ::SHGetMalloc(&pMalloc) == NOERROR )
	{
		BROWSEINFO bi;
		TCHAR szBuffer[MAX_PATH];
		LPITEMIDLIST pidlNet;
		LPITEMIDLIST pidl;
		
		if( ::SHGetSpecialFolderLocation(GetSafeHwnd(),CSIDL_NETWORK,&pidlNet) != NOERROR )
			return;

    CString sResString;
    sResString.LoadString(IDS_STRING_BROWSE_SYSTEM);

		bi.hwndOwner = GetSafeHwnd();
		bi.pidlRoot = pidlNet;
		bi.pszDisplayName = szBuffer;
		bi.lpszTitle = LPCTSTR(sResString);
		bi.ulFlags = BIF_BROWSEFORCOMPUTER;
		bi.lpfn = NULL;
		bi.lParam = 0;

		if( (pidl = ::SHBrowseForFolder(&bi)) != NULL )
		{			
			m_sServer = szBuffer;
			UpdateData(FALSE);			
			pMalloc->Free(pidl);
		}
		pMalloc->Free(pidlNet);
		pMalloc->Release();
	}
}

void CDPIcmpPage::OnDestroy() 
{
    // v-marfin 62585 : For this new data collector, set its Enabled property to TRUE, but
    //                  only if the user is not cancelling these property pages.
    if (m_bOnApplyUsed)
    {
        ClearStatistics(); // 62548

        CDataElement* pElement = (CDataElement*)GetObjectPtr();
        if (pElement && pElement->IsStateSetToEnabledOnOK())
        {
            TRACE(_T("CDPIcmpPage::OnDestroy - New Perfmon Collector: Setting to Enabled\n"));

            pElement->SetStateToEnabledOnOK(FALSE); // don't do this again
	        
	        CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	        if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	        {
                TRACE(_T("ERROR: CDPPerfMonPage::OnOK - Failed to GetClassObject()\n"));
		        return;
	        }

            // Set the new collector to enabled.
            BOOL bEnabled=TRUE;
	        HRESULT hr = pClassObject->GetProperty(IDS_STRING_MOF_ENABLE,bEnabled);
	        hr = pClassObject->SetProperty(IDS_STRING_MOF_ENABLE,TRUE);
            
            if (!CHECKHRESULT(hr))
            {   
                TRACE(_T("ERROR: CDPIcmpPage::OnDestroy - Failed to set ENABLED property on new collector\n"));
            }
            

            //-------------------------------------------------------------------
            // v-marfin 59237 : If the user has not changed the original default
            //                  name, do so for them. Compare against original
            //                  name we fetched during OnInitDialog.
            CString sName;
	        pClassObject->GetProperty(IDS_STRING_MOF_NAME,sName);

            // Did the user change the default name?
            if (m_sOriginalName.CompareNoCase(sName)==0)
            {       
                CString sObject;
                sObject.Format(IDS_STRING_FORMAT_ICMPNAME,m_sServer);

                // No, so set the new name 
                if (!sObject.IsEmpty())
                {
                    // Use parent to ensure name is unique
                    //CDataGroup* pParent = (CDataGroup*) pElement->GetCollectorsParentClassObject();
	                if(pElement->GetScopeItemCount())
	                {
		                CDataElementScopeItem* pItem = (CDataElementScopeItem*)pElement->GetScopeItem(0);
		                if( pItem )
                        {
                            CDataGroupScopeItem* pDGItem = (CDataGroupScopeItem*)pItem->GetParent();
                            sName = pDGItem->GetUniqueDisplayName(sObject);
                        }
                    }

                    // Set the local element's object data
                    pElement->SetName(sName);
                    // Set its WMI property
                    pClassObject->SetProperty(IDS_STRING_MOF_NAME,sName);

                    // Refresh to show the new name in the IU
                    //pElement->Refresh();      // 63005
                    pElement->UpdateStatus();   // 63005
                }
            }
            //-------------------------------------------------------------------


            pClassObject->SaveAllProperties();
            delete pClassObject;

        } // if (pElement && pElement->IsStateSetToEnabledOnOK())
    } // if (m_bOnApplyUsed)

	CHMPropertyPage::OnDestroy();
	
	// v-marfin : bug 59643 : CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	CnxPropertyPageDestroy();	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpinetprotocolpage.cpp ===
// DPInetProtocolPage.cpp : implementation file
//

#include "stdafx.h"
#include "snapin.h"
#include "DPInetProtocolPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDPInetProtocolPage property page

IMPLEMENT_DYNCREATE(CDPInetProtocolPage, CHMPropertyPage)

CDPInetProtocolPage::CDPInetProtocolPage() : CHMPropertyPage(CDPInetProtocolPage::IDD)
{
	//{{AFX_DATA_INIT(CDPInetProtocolPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

}

CDPInetProtocolPage::~CDPInetProtocolPage()
{
}

void CDPInetProtocolPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDPInetProtocolPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDPInetProtocolPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CDPInetProtocolPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDPInetProtocolPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dphttppage.h ===
#if !defined(AFX_DPHTTPPAGE_H__0708329A_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_)
#define AFX_DPHTTPPAGE_H__0708329A_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DPHttpPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDPHttpPage dialog

class CDPHttpPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CDPHttpPage)

// Construction
public:
	CString UnconvertSpecialChars(const CString& sString);
	CString ConvertSpecialChars(const CString& sString);
	BOOL GetAuthTypeFromCombo();
	void LoadAuthTypeCombo();
	CDPHttpPage();
	~CDPHttpPage();

// Dialog Data
	//{{AFX_DATA(CDPHttpPage)
	enum { IDD = IDD_DATAPOINT_HTTP };
	BOOL	m_bRequireReset;
	BOOL	m_bUseProxy;
	CString	m_sAuthentication;
	CString	m_sPassword;
	CString	m_sProxyAddress;
	CString	m_sProxyPort;
	float	m_fTimeout;
	CString	m_sURL;
	CString	m_sUserName;
	//}}AFX_DATA

	CString m_sMethod;
	CString m_sExtraHeaders;
	CString m_sPostData;
	BOOL m_bFollowRedirects;

	// v-marfin Bug 61451 
	int		m_iAuthType;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDPHttpPage)
	public:
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL SetAuthTypeCombo();
	// Generated message map functions
	//{{AFX_MSG(CDPHttpPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnButtonAdvanced();
	afx_msg void OnCheckUseProxy();
	afx_msg void OnCheckRequireReset();
	afx_msg void OnEditchangeComboAuthentication();
	afx_msg void OnChangeEditPassword();
	afx_msg void OnChangeEditProxyAddress();
	afx_msg void OnChangeEditProxyPort();
	afx_msg void OnChangeEditTimeout();
	afx_msg void OnChangeEditUrl();
	afx_msg void OnChangeEditUserName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPHTTPPAGE_H__0708329A_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpinetprotocolpage.h ===
#if !defined(AFX_DPINETPROTOCOLPAGE_H__0708329C_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_)
#define AFX_DPINETPROTOCOLPAGE_H__0708329C_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DPInetProtocolPage.h : header file
//

#include "HMPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDPInetProtocolPage dialog

class CDPInetProtocolPage : public CHMPropertyPage
{
	DECLARE_DYNCREATE(CDPInetProtocolPage)

// Construction
public:
	CDPInetProtocolPage();
	~CDPInetProtocolPage();

// Dialog Data
	//{{AFX_DATA(CDPInetProtocolPage)
	enum { IDD = IDD_DATAPOINT_INTERNETPROTOCOL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDPInetProtocolPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDPInetProtocolPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPINETPROTOCOLPAGE_H__0708329C_CF6B_11D2_9F01_00A0C986B7A0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\hmonitor\snapin\dpnteventpage.cpp ===
// DPNtEventPage.cpp : implementation file
//
// 03/05/00 v-marfin bug 59643 : Make this the default starting page.
// 03/29/00 v-marfin bug 62585 : Set new Data collector's ENABLED to TRUE if user presses OK.
// 03/30/00 v-marfin bug 59237 : If user does not change the default name of the data
//                               collector when they first create it, change it for 
//                               them to a more meaningful name based on the data
//                               they select in the property pages.


#include "stdafx.h"
#include "snapin.h"
#include "DPNtEventPage.h"
#include "HMObject.h"
#include "DataElement.h"
#include "DataGroupScopeItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDPNtEventPage property page

IMPLEMENT_DYNCREATE(CDPNtEventPage, CHMPropertyPage)

CDPNtEventPage::CDPNtEventPage() : CHMPropertyPage(CDPNtEventPage::IDD)
{
	//{{AFX_DATA_INIT(CDPNtEventPage)
	m_bCategory = FALSE;
	m_bError = FALSE;
	m_bEventID = FALSE;
	m_bFailure = FALSE;
	m_bInformation = FALSE;
	m_bRequireReset = TRUE;
	m_bSource = FALSE;
	m_bSuccess = FALSE;
	m_bUser = FALSE;
	m_bWarning = FALSE;
	m_sCategory = _T("");
	m_sEventID = _T("");
	m_sSource = _T("");
	m_sUser = _T("");
	m_sLogFile = _T("");
	//}}AFX_DATA_INIT

	m_sHelpTopic = _T("HMon21.chm::/dDEntev.htm");
}

CDPNtEventPage::~CDPNtEventPage()
{
}

void CDPNtEventPage::DoDataExchange(CDataExchange* pDX)
{
	CHMPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDPNtEventPage)
	DDX_Control(pDX, IDC_COMBO_LOG_FILE, m_LogFile);
	DDX_Check(pDX, IDC_CHECK_CATEGORY, m_bCategory);
	DDX_Check(pDX, IDC_CHECK_ERROR, m_bError);
	DDX_Check(pDX, IDC_CHECK_EVENTID, m_bEventID);
	DDX_Check(pDX, IDC_CHECK_FAILURE, m_bFailure);
	DDX_Check(pDX, IDC_CHECK_INFORMATION, m_bInformation);
	DDX_Check(pDX, IDC_CHECK_REQUIRE_RESET, m_bRequireReset);
	DDX_Check(pDX, IDC_CHECK_SOURCE, m_bSource);
	DDX_Check(pDX, IDC_CHECK_SUCCESS, m_bSuccess);
	DDX_Check(pDX, IDC_CHECK_USER, m_bUser);
	DDX_Check(pDX, IDC_CHECK_WARNING, m_bWarning);
	DDX_Text(pDX, IDC_EDIT_CATEGORY, m_sCategory);
	DDX_Text(pDX, IDC_EDIT_EVENTID, m_sEventID);
	DDX_Text(pDX, IDC_EDIT_SOURCE, m_sSource);
	DDX_Text(pDX, IDC_EDIT_USER, m_sUser);
	DDX_CBString(pDX, IDC_COMBO_LOG_FILE, m_sLogFile);
	//}}AFX_DATA_MAP

	GetDlgItem(IDC_EDIT_CATEGORY)->EnableWindow(m_bCategory);
	GetDlgItem(IDC_EDIT_EVENTID)->EnableWindow(m_bEventID);
	GetDlgItem(IDC_EDIT_SOURCE)->EnableWindow(m_bSource);
	GetDlgItem(IDC_EDIT_USER)->EnableWindow(m_bUser);
	
}

BEGIN_MESSAGE_MAP(CDPNtEventPage, CHMPropertyPage)
	//{{AFX_MSG_MAP(CDPNtEventPage)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_BUTTON_TEST, OnButtonTest)
	ON_BN_CLICKED(IDC_CHECK_CATEGORY, OnCheckCategory)
	ON_BN_CLICKED(IDC_CHECK_EVENTID, OnCheckEventid)
	ON_BN_CLICKED(IDC_CHECK_SOURCE, OnCheckSource)
	ON_BN_CLICKED(IDC_CHECK_USER, OnCheckUser)
	ON_BN_CLICKED(IDC_CHECK_ERROR, OnCheckError)
	ON_BN_CLICKED(IDC_CHECK_FAILURE, OnCheckFailure)
	ON_BN_CLICKED(IDC_CHECK_INFORMATION, OnCheckInformation)
	ON_BN_CLICKED(IDC_CHECK_REQUIRE_RESET, OnCheckRequireReset)
	ON_BN_CLICKED(IDC_CHECK_SUCCESS, OnCheckSuccess)
	ON_BN_CLICKED(IDC_CHECK_WARNING, OnCheckWarning)
	ON_CBN_EDITCHANGE(IDC_COMBO_LOG_FILE, OnEditchangeComboLogFile)
	ON_EN_CHANGE(IDC_EDIT_CATEGORY, OnChangeEditCategory)
	ON_EN_CHANGE(IDC_EDIT_EVENTID, OnChangeEditEventid)
	ON_EN_CHANGE(IDC_EDIT_SOURCE, OnChangeEditSource)
	ON_EN_CHANGE(IDC_EDIT_USER, OnChangeEditUser)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDPNtEventPage message handlers

BOOL CDPNtEventPage::OnInitDialog() 
{
	// v-marfin : bug 59643 : This will be the default starting page for the property
	//                        sheet so call CnxPropertyPageCreate() to unmarshal the 
	//                        connection for this thread. This function must be called
	//                        by the first page of the property sheet. It used to 
	//                        be called by the "General" page and its call still remains
	//                        there as well in case the general page is loaded by a 
	//                        different code path that does not also load this page.
	//                        The CnxPropertyPageCreate function has been safeguarded
	//                        to simply return if the required call has already been made.
	//                        CnxPropertyPageDestory() must be called from this page's
	//                        OnDestroy function.
	// unmarshal connmgr
	CnxPropertyPageCreate();


	CHMPropertyPage::OnInitDialog();
	
	CWbemClassObject* pClassObject = GetObjectPtr()->GetClassObject();

	if( ! GfxCheckObjPtr(pClassObject,CWbemClassObject) )
	{
		return TRUE;
	}
	
    //-------------------------------------------------------------------------
    // v-marfin 59237 : Store original name in case this data collector is
    //                  just being created. When they save, we will modify the 
    //                  name if they haven't.
	pClassObject->GetProperty(IDS_STRING_MOF_NAME,m_sOriginalName);
    //-------------------------------------------------------------------------

	CString sQuery;
	pClassObject->GetProperty(IDS_STRING_MOF_QUERY,sQuery);

	if( ! sQuery.IsEmpty() )
	{
		// parse out the Type phrases
		CString sTemp = IDS_STRING_MOF_TYPE;		
		if( sQuery.Find(sTemp + _T("=\"error\"")) != -1 )
		{
			m_bError = TRUE;
		}

		if( sQuery.Find(sTemp + _T("=\"warning\"")) != -1 )
		{
			m_bWarning = TRUE;
		}

		if( sQuery.Find(sTemp + _T("=\"information\"")) != -1 )
		{
			m_bInformation = TRUE;
		}

		if( sQuery.Find(sTemp + _T("=\"audit success\"")) != -1 )
		{
			m_bSuccess = TRUE;
		}

		if( sQuery.Find(sTemp + _T("=\"audit failure\"")) != -1 )
		{
			m_bFailure = TRUE;
		}

		// parse out the LogFile
		CWbemClassObject::GetPropertyValueFromString(sQuery,_T("Logfile"),m_sLogFile);

		