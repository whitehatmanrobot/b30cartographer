 Index++ ) {

        if ( IsDs &&
             ObjectTypeList[Index].Level == ACCESS_OBJECT_GUID &&
             NewObjectTypeName->Length == 0 ) {

            (VOID) LsapDsGuidToString( &ObjectTypeList[Index].ObjectType,
                                      NewObjectTypeName );
        }

        //
        // If this entry simply represents the object itself,
        //  skip it.

        if ( ObjectTypeList[Index].Flags & SE_ADT_OBJECT_ONLY ) {
            continue;
        }

        //
        // If this access mask is different than the one for the previous
        //  object,
        //  output a new copy of the access mask.
        //

        if ( ObjectTypeList[Index].AccessMask != PreviousAccessMask ) {

            PreviousAccessMask = ObjectTypeList[Index].AccessMask;

            if ( ObjectTypeList[Index].AccessMask == 0 ) {
                RtlInitUnicodeString( &LocalString,
                                      L"---" LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
                LocalFreeWhenDone = FALSE;
            } else {

                //
                // Build a string with the access mask in it.
                //

                Status = LsapAdtBuildAccessesString(
                                  SourceModule,
                                  ObjectTypeName,
                                  ObjectTypeList[Index].AccessMask,
                                  FALSE,
                                  &LocalString,
                                  &LocalFreeWhenDone );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }
            }

            //
            // Append it to the output string.
            //

            Status = LsapAdtAppendString(
                        ResultantString,
                        FreeWhenDone,
                        &LocalString,
                        &ResultantStringIndex );

            if ( LocalFreeWhenDone ) {
                LsapFreeLsaHeap( LocalString.Buffer );
            }

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }
        }

        IndentLevel = ObjectTypeList[Index].Level;

        if (IndentLevel >= cTabs) {
            IndentLevel = cTabs-1;
        }
        
        //
        // Indent the GUID.
        //

        Status = LsapAdtAppendZString(
            ResultantString,
            FreeWhenDone,
            Tabs[IndentLevel],
            &ResultantStringIndex );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // If this is the DS,
        //  convert the GUID to a name from the schema.
        //

        Status = LsapDsGuidToString( &ObjectTypeList[Index].ObjectType,
                                     &LocalString );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // Append the GUID string to the output strings.
        //

        Status = LsapAdtAppendString(
                    ResultantString,
                    FreeWhenDone,
                    &LocalString,
                    &ResultantStringIndex );

        LsapFreeLsaHeap( LocalString.Buffer );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // Put the GUID on a line by itself.
        //

        Status = LsapAdtAppendZString(
                    ResultantString,
                    FreeWhenDone,
                    LSAP_ADT_ACCESS_NAME_FORMATTING_NL,
                    &ResultantStringIndex );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

    }

    Status = STATUS_SUCCESS;
Cleanup:
    return Status;
}




NTSTATUS
LsapAdtBuildAccessesString(
    IN PUNICODE_STRING SourceModule,
    IN PUNICODE_STRING ObjectTypeName,
    IN ACCESS_MASK Accesses,
    IN BOOLEAN Indent,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string containing parameter
    file replacement parameters (e.g. %%1043) separated by carriage
    return and tab characters suitable for display via the event viewer.


    The buffer returned by this routine must be deallocated when no
    longer needed if FreeWhenDone is true.


    NOTE: To enhance performance, each time a target source module
          descriptor is found, it is moved to the beginning of the
          source module list.  This ensures frequently accessed source
          modules are always near the front of the list.

          Similarly, target object descriptors are moved to the front
          of their lists when found.  This further ensures high performance
          by quicly locating



Arguments:

    SourceModule - The module (ala event viewer modules) defining the
        object type.

    ObjectTypeName - The type of object to which the access mask applies.

    Accesses - The access mask to be used in building the display string.

    Indent - Access Mask should be indented.

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.


    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.

Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AccessCount = 0;
    ULONG BaseOffset;
    ULONG i;
    ACCESS_MASK Mask;
    PLSAP_ADT_SOURCE Source;
    PLSAP_ADT_SOURCE FoundSource = NULL;
    PLSAP_ADT_OBJECT Object;
    PLSAP_ADT_OBJECT FoundObject = NULL;
    BOOLEAN Found;

#ifdef LSAP_ADT_TEST_DUMP_SOURCES
    printf("Module:\t%wS\n", SourceModule);
    printf("\t   Object:\t%wS\n", ObjectTypeName);
    printf("\t Accesses:\t0x%lx\n", Accesses);
#endif

    //
    // If we have no accesses, return "-"
    //

    if (Accesses == 0) {

        RtlInitUnicodeString( ResultantString, L"-" );
        (*FreeWhenDone) = FALSE;
        return(STATUS_SUCCESS);
    }

    //
    // First figure out how large a buffer we need
    //

    Mask = Accesses;

    //
    // Count the number of set bits in the
    // passed access mask.
    //

    while ( Mask != 0 ) {
        Mask = Mask & (Mask - 1);
        AccessCount++;
    }


#ifdef LSAP_ADT_TEST_DUMP_SOURCES
    printf("\t          \t%d bits set in mask.\n", AccessCount);
#endif


    //
    // We have accesses, allocate a string large enough to deal
    // with them all.  Strings will be of the format:
    //
    //      %%nnnnnnnnnn\n\r\t\t%%nnnnnnnnnn\n\r\t\t ... %nnnnnnnnnn\n\r\t\t
    //
    // where nnnnnnnnnn - is a decimal number 10 digits long or less.
    //
    // So, a typical string will look like:
    //
    //      %%601\n\r\t\t%%1604\n\r\t\t%%1608\n
    //
    // Since each such access may use at most:
    //
    //          10  (for the nnnnnnnnnn digit)
    //        +  2  (for %%)
    //        +  8  (for \n\t\t)
    //        --------------------------------
    //          20  wide characters
    //
    // The total length of the output string will be:
    //
    //           AccessCount    (number of accesses)
    //         x          20    (size of each entry)
    //         -------------------------------------
    //                          wchars
    //
    // Throw in 1 more WCHAR for null termination, and we are all set.
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = (USHORT)AccessCount * (20 * sizeof(WCHAR)) +
                                 sizeof(WCHAR);  //for the null termination

#ifdef LSAP_ADT_TEST_DUMP_SOURCES
    printf("\t          \t%d byte buffer allocated.\n", ResultantString->MaximumLength);
#endif
    ResultantString->Buffer = LsapAllocateLsaHeap( ResultantString->MaximumLength );


    if (ResultantString->Buffer == NULL) {

        return(STATUS_NO_MEMORY);
    }

    (*FreeWhenDone) = TRUE;

    //
    // Special case standard and special access types.
    // Walk the lists for specific access types.
    //

    if (Accesses & STANDARD_RIGHTS_ALL) {

        if (Accesses & DELETE) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringDelete);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));

        }


        if (Accesses & READ_CONTROL) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringReadControl);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));
        }


        if (Accesses & WRITE_DAC) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringWriteDac);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));
        }


        if (Accesses & WRITE_OWNER) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringWriteOwner);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));
        }

        if (Accesses & SYNCHRONIZE) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringSynchronize);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));
        }
    }


    if (Accesses & ACCESS_SYSTEM_SECURITY) {

        Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
        ASSERT( NT_SUCCESS( Status ));

        Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringAccessSysSec);
        ASSERT( NT_SUCCESS( Status ));

        if ( Indent ) {
            Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
        } else {
            Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
        }
        ASSERT( NT_SUCCESS( Status ));
    }

    if (Accesses & MAXIMUM_ALLOWED) {

        Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
        ASSERT( NT_SUCCESS( Status ));

        Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringMaxAllowed);
        ASSERT( NT_SUCCESS( Status ));

        if ( Indent ) {
            Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
        } else {
            Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
        }
        ASSERT( NT_SUCCESS( Status ));
    }


    //
    // If there are any specific access bits set, then get
    // the appropriate source module and object type base
    // message ID offset.  If there is no module-specific
    // object definition, then use SE_ACCESS_NAME_SPECIFIC_0
    // as the base.
    //

    if ((Accesses & SPECIFIC_RIGHTS_ALL) == 0) {
        return(Status);
    }

    LsapAdtSourceModuleLock();

    Source = (PLSAP_ADT_SOURCE)&LsapAdtSourceModules;
    Found  = FALSE;

    while ((Source->Next != NULL) && !Found) {

        if (RtlEqualUnicodeString(&Source->Next->Name, SourceModule, TRUE)) {

            Found = TRUE;
            FoundSource = Source->Next;

            //
            // Move to front of list of source modules.
            //

            Source->Next = FoundSource->Next;    // Remove from list
            FoundSource->Next = LsapAdtSourceModules; // point to first element
            LsapAdtSourceModules = FoundSource;       // Make it the first element

#ifdef LSAP_ADT_TEST_DUMP_SOURCES
printf("\t          \tModule Found.\n");
#endif

        } else {

            Source = Source->Next;
        }
    }


    if (Found == TRUE) {

        //
        // Find the object
        //

        Object = (PLSAP_ADT_OBJECT)&(FoundSource->Objects);
        Found  = FALSE;

        while ((Object->Next != NULL) && !Found) {

            if (RtlEqualUnicodeString(&Object->Next->Name, ObjectTypeName, TRUE)) {

                Found = TRUE;
                FoundObject = Object->Next;

                //
                // Move to front of list of soure modules.
                //

                Object->Next = FoundObject->Next;          // Remove from list
                FoundObject->Next = FoundSource->Objects;  // point to first element
                FoundSource->Objects = FoundObject;        // Make it the first element

            } else {

                Object = Object->Next;
            }
        }
    }


    //
    // We are done playing with link fields of the source modules
    // and objects.  Free the lock.
    //

    LsapAdtSourceModuleUnlock();

    //
    // If we have found an object, use it as our base message
    // ID.  Otherwise, use SE_ACCESS_NAME_SPECIFIC_0.
    //

    if (Found) {

        BaseOffset = FoundObject->BaseOffset;
#ifdef LSAP_ADT_TEST_DUMP_SOURCES
printf("\t          \tObject Found.  Base Offset: 0x%lx\n", BaseOffset);
#endif

    } else {

        BaseOffset = SE_ACCESS_NAME_SPECIFIC_0;
#ifdef LSAP_ADT_TEST_DUMP_SOURCES
printf("\t          \tObject NOT Found.  Base Offset: 0x%lx\n", BaseOffset);
#endif
    }


    //
    // At this point, we have a base offset (even if we had to use our
    // default).
    //
    // Now cycle through the specific access bits and see which ones need
    // to be added to ResultantString.
    //

    {
        UNICODE_STRING  IntegerString;
        WCHAR           IntegerStringBuffer[10]; //must be 10 wchar bytes long
        ULONG           NextBit;

        IntegerString.Buffer = (PWSTR)IntegerStringBuffer;
        IntegerString.MaximumLength = 10*sizeof(WCHAR);
        IntegerString.Length = 0;

        for ( i=0, NextBit=1  ; i<16 ;  i++, NextBit <<= 1 ) {

            //
            // specific access flags are in the low-order bits of the mask
            //

            if ((NextBit & Accesses) != 0) {

                //
                // Found one  -  add it to ResultantString
                //

                Status = RtlIntegerToUnicodeString (
                             (BaseOffset + i),
                             10,        //Base
                             &IntegerString
                             );

                if (NT_SUCCESS(Status)) {

                    Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
                    ASSERT( NT_SUCCESS( Status ));

                    Status = RtlAppendUnicodeStringToString( ResultantString, &IntegerString);
                    ASSERT( NT_SUCCESS( Status ));

                    if ( Indent ) {
                        Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
                    } else {
                        Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
                    }
                    ASSERT( NT_SUCCESS( Status ));
                }
            }
        }
    }

    return(Status);


//ErrorAfterAlloc:
//
//    LsapFreeLsaHeap( ResultantString->Buffer );
//    ResultantString->Buffer = NULL;
//    (*FreeWhenDone) = FALSE;
//    return(Status);
}

// ======================================================================
// dbpriv.c
// ======================================================================

NTSTATUS
LsapBuildPrivilegeAuditString(
    IN PPRIVILEGE_SET PrivilegeSet,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING DashString;
    BOOLEAN FreeDash;
    
    
    Status= LsapAdtBuildDashString(
                &DashString,
                &FreeDash
                );

    if ( !NT_SUCCESS( Status )) {
        return( Status );
    }

    *ResultantString = DashString;
    *FreeWhenDone = FALSE;
    
    return Status;
}

NTSTATUS
LsapAdtWriteLog(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters OPTIONAL,
    IN ULONG Options
    )
{
    return LsapAdtDemarshallAuditInfo( AuditParameters );
}

BOOLEAN
LsapAdtIsAuditingEnabledForCategory(
    IN POLICY_AUDIT_EVENT_TYPE AuditCategory,
    IN UINT AuditEventType
    )
{
    return TRUE;
}

VOID
LsapAuditFailed(
    IN NTSTATUS AuditStatus
    )
{
    UNREFERENCED_PARAMETER(AuditStatus);
}


#endif // !defined(lint)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\benchmark\azaccess.h ===
EXTERN_C
DWORD InitAuthzAccessChecks();

EXTERN_C
DWORD
AuthzDoAccessCheck(
    IN ULONG NumAccessChecks, 
    IN DWORD Flags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\benchmark\benchmrk.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       B E N C H M R K . C P P
//
//  Contents:   Benchmarking class
//
//  Notes:
//
//  Author:     billbe   13 Oct 1997
//
//---------------------------------------------------------------------------

#include "pch.h"

#pragma hdrstop

#include "benchmrk.h"

CBenchmark::CBenchmark()
: m_i64Frequency(1000),
  m_sznDescription(NULL),
  m_i64TotalTime(0),
  m_fStarted(FALSE)
{
    LARGE_INTEGER li1;

    // Check if QueryPerformanceCounter is supported
    if (QueryPerformanceCounter(&li1))
    {
        // Now get # of ticks per second
        QueryPerformanceFrequency(reinterpret_cast<LARGE_INTEGER*>
                (&m_i64Frequency));

        //wprintf(L"QueryPerformanceFrequency: %I64d\n", m_i64Frequency);
        m_fSupported = TRUE;
    }
    else
    {
        //        TraceTag(ttidBenchmark, "High performance counter is not supported.");
        m_fSupported = FALSE;
        wprintf(L"QueryPerformanceFrequency: not supported!!\n");
    }
}

CBenchmark::~CBenchmark()
{
    delete [] m_sznDescription;
}


void
CBenchmark::Start(PCWSTR sznDescription)
{
    // If QueryPerformanceCounter is supported
    if (m_fSupported)
    {
        // replace with new one if specified
        if (sznDescription)
        {
            // delete the old description
            delete [] m_sznDescription;

            m_sznDescription = new WCHAR[lstrlen(sznDescription) + 1];
            if (m_sznDescription)
            {
                lstrcpy(m_sznDescription, sznDescription);
            }
        }
        else
        {
            // no description specified clear the member variable
            m_sznDescription = NULL;
        }
        m_fStarted = TRUE;
        m_i64TotalTime = 0;

        // Record our start time
        QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>
                (&m_i64StartTime));
    }
}

void
CBenchmark::Stop()
{
    __int64 i64Stop;
    // Record our stop time
    QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&i64Stop));

    // If start was called prior to stop, then record the total time and
    // reset our m_fStarted flag
    //
    if (m_fStarted)
    {
        m_fStarted = FALSE;
        m_i64TotalTime = i64Stop - m_i64StartTime;
    }
    else
    {
        // invalidate previous benchmark since stop was called before start
        m_i64TotalTime = 0;
    }
}

PCWSTR
CBenchmark::SznBenchmarkSeconds(unsigned short usPrecision)
{
    WCHAR sznFmt[10];
    swprintf(sznFmt, L"%%.%df", usPrecision);
    swprintf(m_sznSeconds, sznFmt, DblBenchmarkSeconds());
    return m_sznSeconds;
}

CBenchmark g_timer;

void timer_start()
{
    g_timer.Start(NULL);
}

void timer_stop()
{
    g_timer.Stop();
}

PCWSTR timer_secs()
{
    return g_timer.SznBenchmarkSeconds(5);
}

double timer_time()
{
    return g_timer.DblBenchmarkSeconds();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\benchmark\benchmrk.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       B E N C H M R K . H
//
//  Contents:   Benchmark class.
//
//  Notes:
//
//  Author:     billbe   13 Oct 1997
//
//---------------------------------------------------------------------------


#pragma once

const WCHAR c_sznEmpty[] = {'\0'};

class CBenchmark
{
public:
    CBenchmark();
    ~CBenchmark();
    void Start(PCWSTR sznDescription);
    void Stop();
    double DblBenchmarkSeconds()
    {
        return m_i64TotalTime / static_cast<double>(m_i64Frequency);
    }
    PCWSTR SznDescription(){return m_sznDescription ? m_sznDescription : c_sznEmpty;}
    PCWSTR SznBenchmarkSeconds(unsigned short usPrecision);
private:
    __int64 m_i64Frequency;
    PWSTR m_sznDescription;
    __int64 m_i64StartTime;
    __int64 m_i64TotalTime;
    BOOL m_fStarted;
    BOOL m_fSupported;
    WCHAR m_sznSeconds[50];

};

extern "C" void timer_start();
extern "C" void timer_stop();
extern "C" PCWSTR timer_secs();
EXTERN_C double timer_time();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\benchmark\azaccess.c ===
#include "pch.h"
#pragma hdrstop

#include "bmcommon.h"

//
// S-1-5-21-397955417-626881126-188441444-2908314 (kumarp)
//
//WCHAR szSid[] = L"S-1-5-21-397955417-626881126-188441444-2908314";
WCHAR szSid[] = L"S-1-5-21-397955417-626881126-188441444-2101332";

//ULONG Sid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00201054};

// S-1-5-21-397955417-626881126-188441444-2101332
//ULONG Sid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00201054};

BOOL b;
DWORD AuthzRmAuditFlags = 0;
HANDLE hProcessToken=NULL;
static HANDLE hToken;
DWORD AuthzAuditFlags = 0;
PCWSTR ResourceManagerName = L"Speed Test Resource Manager";
AUTHZ_RM_AUDIT_INFO_HANDLE hRmAuditInfo = NULL;
AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager = NULL;
DWORD AuthzRmFlags = 0;
AUDIT_EVENT_INFO AuditEventInfo;
PCWSTR szOperationType = L"Access Check";
PCWSTR szObjectName = L"Joe";
PCWSTR szObjectType = L"Kernel Hacker";
PCWSTR szAdditionalInfo = L"None";
AUTHZ_AUDIT_INFO_HANDLE hAuditInfo = NULL;
AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext = NULL;
LUID luid = {0xdead,0xbeef};
ULONG i;

ULONG NumAccessChecks = 10;
AUTHZ_ACCESS_REQUEST RequestOT;
AUTHZ_ACCESS_REQUEST Request;
UCHAR Buffer[1024];
UCHAR Buffer2[1024];
UCHAR TypeListBuffer[1024];
PAUTHZ_ACCESS_REPLY pReply = (PAUTHZ_ACCESS_REPLY) Buffer;
PAUTHZ_ACCESS_REPLY pReplyOT = (PAUTHZ_ACCESS_REPLY) Buffer2;
PSECURITY_DESCRIPTOR pSD = NULL;
AUTHZ_HANDLE AuthzHandle = 0;
AUDIT_PARAMS AuditParams;
AUDIT_PARAM ParamArray[11];

PSID pSid;
PSID pUserSid;

BOOL
AuthzInit( )
{
    BOOL b;

    if (!ConvertStringSidToSid( szSid, &pSid ))
    {
        return FALSE;
    }

    AuditEventInfo.Version                 = AUDIT_TYPE_LEGACY;
    AuditEventInfo.u.Legacy.CategoryId     = SE_CATEGID_OBJECT_ACCESS;
    AuditEventInfo.u.Legacy.AuditId        = SE_AUDITID_OBJECT_OPERATION;
    AuditEventInfo.u.Legacy.ParameterCount = 3;

    //
    // init request for obj-type access check
    //
    
    RequestOT.DesiredAccess        = DESIRED_ACCESS;
    RequestOT.ObjectTypeList       = ObjectTypeList;
    RequestOT.ObjectTypeListLength = ObjectTypeListLength;
    RequestOT.OptionalArguments    = NULL;
    RequestOT.PrincipalSelfSid     = NULL;
    //RequestOT.PrincipalSelfSid = g_Sid1;

    //
    // init non obj-type request 
    //

    Request.DesiredAccess        = DESIRED_ACCESS;
    Request.ObjectTypeList       = NULL;
    Request.ObjectTypeListLength = 0;
    Request.OptionalArguments    = NULL;
    Request.PrincipalSelfSid     = NULL;
    //Request.PrincipalSelfSid = g_Sid1;

    //
    // init reply for obj type list
    //
    pReplyOT->ResultListLength  = ObjectTypeListLength;
    pReplyOT->Error             = (PDWORD) (((PCHAR) pReplyOT) + sizeof(AUTHZ_ACCESS_REPLY));
    pReplyOT->GrantedAccessMask = (PACCESS_MASK) (pReplyOT->Error + pReplyOT->ResultListLength);

    //
    // init reply 
    //

    pReply->ResultListLength  = 1;
    pReply->Error             = (PDWORD) (((PCHAR) pReply) + sizeof(AUTHZ_ACCESS_REPLY));
    pReply->GrantedAccessMask = (PACCESS_MASK) (pReply->Error + pReply->ResultListLength);

    b = AuthzInitializeResourceManager(
            NULL,
            NULL,
            NULL,
            L"Benchmark RM",
            AuthzRmFlags,
            &hAuthzResourceManager
            );

    if (!b)
    {
        printf("AuthzInitializeResourceManager\n");
        return FALSE;
    }

    AuditParams.Parameters = ParamArray;

    AuthzInitializeAuditParams(
        &AuditParams,
        &pUserSid,
        L"Authz Speed Tests",
        APF_AuditSuccess,
        1,
        APT_String, L"Test operation"
        );

    b = AuthzInitializeAuditInfo(
            &hAuditInfo,
            0,
            hAuthzResourceManager,
            &AuditEventInfo,
            &AuditParams,
            NULL,
            INFINITE,
            L"blah",
            L"blah",
            L"and",
            L"blah"
            );

    if (!b)
    {
        printf("AuthzInitAuditInfo FAILED with %d.\n", GetLastError());
        return 0;
    }

    b = AuthzModifyAuditQueue(
            NULL,
            AUTHZ_AUDIT_QUEUE_THREAD_PRIORITY,
            0,
            0,
            0,
            THREAD_PRIORITY_LOWEST
            );
    if (!b)
    {
        printf("AuthzModifyAuditQueue FAILED with %d.\n", GetLastError());
        return 0;
    }

    if ( !OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY,
                            &hProcessToken ) )
    {
        wprintf(L"OpenProcessToken failed %d\n", GetLastError());
        return 0;
    }


    b = AuthzInitializeContextFromToken(
            hProcessToken,
            hAuthzResourceManager,
            NULL,
            luid,
            0,
            NULL,
            &hAuthzClientContext
            );
    
    if (!b)
    {
        printf("AuthzInitializeContextFromToken failed %d\n", GetLastError());
        return FALSE;
    }

    if ( !OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ) )
    {
        return GetLastError();
    }

    b = ConvertStringSecurityDescriptorToSecurityDescriptorW(g_szSd, SDDL_REVISION_1, &pSD, NULL);

    if (!b)
    {
        wprintf(L"SDDL failed with %d\n", GetLastError());
        return FALSE;
    }
    return TRUE;
}


DWORD
InitAuthzAccessChecks()
{
    if (!AuthzInit())
    {
        return GetLastError();
    }

    return NO_ERROR;
}

DWORD
AuthzDoAccessCheck(
    IN ULONG NumAccessChecks, 
    IN DWORD Flags
    )
{
    AUTHZ_AUDIT_INFO_HANDLE AdtInfo = Flags & BMF_GenerateAudit ? hAuditInfo : NULL;

    if ( Flags & BMF_UseObjTypeList )
    {
        for (i = 0; i < NumAccessChecks; i ++)
        {
            b = AuthzAccessCheck(
                hAuthzClientContext,
                &RequestOT,
                AdtInfo,
                pSD,
                NULL,
                0,
                pReplyOT,
                //&AuthzHandle
                NULL
                );
            if (!b)
            {
                printf("AuthzAccessCheck failed.\n");
                return GetLastError();
            }
//             else
//             {
//                 AuthzFreeHandle( AuthzHandle );
//             }
        }
    }
    else
    {
        for (i = 0; i < NumAccessChecks; i ++)
        {
            b = AuthzAccessCheck(
                hAuthzClientContext,
                &Request,
                AdtInfo,
                pSD,
                NULL,
                0,
                pReply,
                //&AuthzHandle
                NULL
                );
            if (!b)
            {
                printf("AuthzAccessCheck failed.\n");
                return GetLastError();
            }
//             else
//             {
//                 AuthzFreeHandle( AuthzHandle );
//             }
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\benchmark\bmcommon.h ===
#define BMF_GenerateAudit  1
#define BMF_UseObjTypeList 2


EXTERN_C DWORD ObjectTypeListLength;
EXTERN_C OBJECT_TYPE_LIST ObjectTypeList[];

EXTERN_C DWORD fNtAccessCheckResult[];
//EXTERN_C BOOL fAzAccessCheckResult[];

EXTERN_C DWORD dwNtGrantedAccess[];
//EXTERN_C DWORD dwAzGrantedAccess[];

//#define DESIRED_ACCESS MAXIMUM_ALLOWED
//#define DESIRED_ACCESS 0xff
//#define DESIRED_ACCESS 0x1000
#define DESIRED_ACCESS g_DesiredAccess

EXTERN_C PSID g_Sid1;

EXTERN_C ACCESS_MASK g_DesiredAccess;

EXTERN_C PWCHAR g_szSd;

EXTERN_C PWCHAR g_aszSd[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\benchmark\bmcommon.c ===
#include "pch.h"

#pragma hdrstop

#include "bmcommon.h"


PWCHAR g_aszSd[] =
{
    L"O:BAG:BAD:(OA;;GA;;;WD)S:(AU;FASA;GA;;;WD)",

    L"O:BAG:DUD:(A;;0x40;;;s-1-2-2)(A;;0x1;;;BA)(OA;;0x2;6da8a4ff-0e52-11d0-a286-00aa00304900;;BA)(OA;;0x4;6da8a4ff-0e52-11d0-a286-00aa00304901;;BA)(OA;;0x8;6da8a4ff-0e52-11d0-a286-00aa00304903;;AU)(OA;;0x10;6da8a4ff-0e52-11d0-a286-00aa00304904;;BU)(OA;;0x20;6da8a4ff-0e52-11d0-a286-00aa00304905;;AU)(A;;0x40;;;PS)S:(AU;IDSAFA;0xFFFFFF;;;WD)",

    //
    // mkdit.ini : [User]
    //
    L"O:BAG:DUD:(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;WD)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;AO)(A;;RPLCLORC;;;PS)(OA;;CR;ab721a53-1e2f-11d0-9819-00aa0040529b;;PS)(OA;;CR;ab721a54-1e2f-11d0-9819-00aa0040529b;;PS)(OA;;CR;ab721a56-1e2f-11d0-9819-00aa0040529b;;PS)(OA;;RPWP;77B5B886-944A-11d1-AEBD-0000F80367C1;;PS)(OA;;RPWP;E45795B2-9455-11d1-AEBD-0000F80367C1;;PS)(OA;;RPWP;E45795B3-9455-11d1-AEBD-0000F80367C1;;PS)(OA;;RP;037088f8-0ae1-11d2-b422-00a0c968f939;;RS)(OA;;RP;4c164200-20c0-11d0-a768-00aa006e0529;;RS)(OA;;RP;bc0ac240-79a9-11d0-9020-00c04fc2d4cf;;RS)(A;;RC;;;AU)(OA;;RP;59ba2f42-79a2-11d0-9020-00c04fc2d3cf;;AU)(OA;;RP;77B5B886-944A-11d1-AEBD-0000F80367C1;;AU)(OA;;RP;E45795B3-9455-11d1-AEBD-0000F80367C1;;AU)(OA;;RP;e48d0154-bcf8-11d1-8702-00c04fb96050;;AU)(OA;;CR;ab721a53-1e2f-11d0-9819-00aa0040529b;;WD)(OA;;RP;5f202010-79a5-11d0-9020-00c04fc2d4cf;;RS)(OA;;RPWP;bf967a7f-0de6-11d0-a285-00aa003049e2;;CA)S:(AU;IDSAFA;0xFFFFFF;;;WD)",

    //
    // mkdit.ini : [Computer]
    //
    L"O:BAG:DUD:(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;DA)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;AO)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)(A;;RPCRLCLORCSDDT;;;CO)(OA;;WP;4c164200-20c0-11d0-a768-00aa006e0529;;CO)(A;;RPLCLORC;;;AU)(OA;;CR;ab721a53-1e2f-11d0-9819-00aa0040529b;;WD)(OA;;CCDC;;;PS)(OA;;CCDC;bf967aa8-0de6-11d0-a285-00aa003049e2;;PO)(OA;;RPWP;bf967a7f-0de6-11d0-a285-00aa003049e2;;CA)(OA;;SW;f3a64788-5306-11d1-a9c5-0000f80367c1;;PS)(OA;;RPWP;77B5B886-944A-11d1-AEBD-0000F80367C1;;PS)(OA;;SW;72e39547-7b18-11d1-adef-00c04fd8d5cd;;PS)(OA;;SW;72e39547-7b18-11d1-adef-00c04fd8d5cd;;CO)(OA;;SW;f3a64788-5306-11d1-a9c5-0000f80367c1;;CO)"
    
    //
    // Domain-DNS (from Praerit)
    //
    //L"D:(A;;RP;;;WD)(OA;;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6ab-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6ac-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;1131f6ab-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;1131f6ac-9c07-11d1-f79f-00c04fc2dcd2;;BA)(A;;RPLCLORC;;;AU)(A;;RPWPCRLCLOCCRCWDWOSW;;;DA)(A;CI;RPWPCRLCLOCCRCWDWOSDSW;;;BA)(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)(A;CI;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;EA)(A;CI;LC;;;RU)(OA;CIIO;RP;037088f8-0ae1-11d2-b422-00a0c968f939;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RP;59ba2f42-79a2-11d0-9020-00c04fc2d3cf;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RP;bc0ac240-79a9-11d0-9020-00c04fc2d4cf;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RP;4c164200-20c0-11d0-a768-00aa006e0529;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RP;5f202010-79a5-11d0-9020-00c04fc2d4cf;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RPLCLORC;;bf967a9c-0de6-11d0-a285-00aa003049e2;RU)(A;;RC;;;RU)(OA;CIIO;RPLCLORC;;bf967aba-0de6-11d0-a285-00aa003049e2;RU)S:(AU;CISAFA;WDWOSDDTWPCRCCDCSW;;;WD)"

};

PWCHAR g_szSd;

GUID Guid0 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x00}};
GUID Guid1 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x01}};
GUID Guid2 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x02}};
GUID Guid3 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x03}};
GUID Guid4 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x04}};
GUID Guid5 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x05}};
GUID Guid6 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x06}};
GUID Guid7 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x07}};
GUID Guid8 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x08}};


DWORD ObjectTypeListLength= 8;
OBJECT_TYPE_LIST ObjectTypeList[] =
{
    { 0, 0, &Guid0 },
    { 1, 0, &Guid1 },
    { 2, 0, &Guid2 },
    { 2, 0, &Guid3 },
    { 1, 0, &Guid4 },
    { 2, 0, &Guid5 },
    { 3, 0, &Guid6 },
    { 2, 0, &Guid7 }
};

DWORD fNtAccessCheckResult[200] = { 2 };
BOOL fAzAccessCheckResult[200];

DWORD dwNtGrantedAccess[200] = { 0xaabbccdd };
DWORD dwAzGrantedAccess[200];

// S-1-5-21-397955417-626881126-188441444-2101332
ULONG _Sid1[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00201054};
PSID g_Sid1 = (PSID) _Sid1;

ACCESS_MASK g_DesiredAccess;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\benchmark\ntaccess.h ===
EXTERN_C
DWORD 
InitNtAccessChecks();

EXTERN_C
DWORD 
DoNtAccessChecks(
    IN ULONG NumChecks,
    IN DWORD Flags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\benchmark\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include "windows.h"
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>

#include <ntlsa.h>
#include <msaudite.h>
// #include <rpc.h>
// #include <msobjs.h>

#define SECURITY_WIN32

// #include "sspi.h"
// #include "secint.h"
#include <sddl.h>

#include <authz.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\benchmark\ntaccess.c ===
#include "pch.h"
#pragma hdrstop

#include "bmcommon.h"

static GENERIC_MAPPING FileGenericMapping =
{
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};

static PSECURITY_DESCRIPTOR pSD;
static HANDLE hToken;


EXTERN_C
DWORD 
InitNtAccessChecks()
{
    DWORD dwError=NO_ERROR;
    BOOL b;
    PWCHAR szMsg=NULL;
    HANDLE hProcessToken=NULL;
    
    b = ConvertStringSecurityDescriptorToSecurityDescriptorW(g_szSd,
                                                             SDDL_REVISION_1,
                                                             &pSD, NULL);

    if (!b)
    {
        szMsg = L"SDDL";
        goto GetError;
    }

    if ( !OpenProcessToken( GetCurrentProcess(), TOKEN_DUPLICATE,
                            &hProcessToken ) )
    {
        szMsg = L"OpenProcessToken";
        goto GetError;
    }

    
    if ( !DuplicateToken( hProcessToken, SecurityImpersonation, &hToken ) )
    {
        szMsg = L"DuplicateToken";
        goto GetError;
    }

    
    if ( !SetThreadToken( NULL, hToken ) )
    {
        szMsg = L"SetThreadToken";
        goto GetError;
    }
    
Cleanup:

    if ( hProcessToken )
    {
        CloseHandle( hProcessToken );
    }

    if ( szMsg )
    {
        wprintf (L"InitNtAccessChecks: %s: %x\n", szMsg, dwError);
    }

    return dwError;

GetError:
    dwError = GetLastError();
    goto Cleanup;
    
}

EXTERN_C
DWORD 
DoNtAccessChecks(
    IN ULONG NumChecks,
    IN DWORD Flags
    )
{
    DWORD dwError=NO_ERROR;
    PWCHAR StringSD = L"O:BAG:BAD:(OA;;GA;;;WD)S:(AU;FASA;GA;;;WD)";
    BOOL b;
    ULONG i;
    PRIVILEGE_SET Privs = { 0 };
    DWORD dwPrivLength=20*sizeof(LUID_AND_ATTRIBUTES);
    BOOL fGenOnClose[100];
    PWCHAR szMsg=NULL;
    HANDLE hObj= (HANDLE) 333444;

    if ( Flags & BMF_GenerateAudit )
    {
        if ( Flags & BMF_UseObjTypeList )
        {
            for (i=0; i < NumChecks; i++)
            {
                if (!AccessCheckByTypeResultListAndAuditAlarm(
                        L"supersystemwithaudit",
                        hObj,
                        L"Kernel speed test",
                        L"sample operation",
                        pSD,
                        g_Sid1,
                        DESIRED_ACCESS,
                        AuditEventObjectAccess,
                        0,
                        ObjectTypeList,
                        ObjectTypeListLength,
                        &FileGenericMapping,
                        FALSE,
                        dwNtGrantedAccess,
                        fNtAccessCheckResult,
                        fGenOnClose ))
                {
                    szMsg = L"AccessCheck";
                    goto GetError;
                }
            }
        }
        else
        {
            for (i=0; i < NumChecks; i++)
            {
                if (!AccessCheckAndAuditAlarm(
                        L"mysystem",
                        hObj,
                        L"File",
                        L"file-object",
                        pSD, DESIRED_ACCESS,
                        &FileGenericMapping,
                        FALSE,
                        &dwNtGrantedAccess[0],
                        &fNtAccessCheckResult[0],
                        &fGenOnClose[0] ))
                {
                    szMsg = L"AccessCheck";
                    goto GetError;
                }
            }
        }
    }
    else
    {
        if ( Flags & BMF_UseObjTypeList )
        {
            for (i=0; i < NumChecks; i++)
            {
                if (!AccessCheckByTypeResultList(
                    pSD,
                    g_Sid1,
                    hToken, DESIRED_ACCESS,
                    ObjectTypeList,
                    ObjectTypeListLength,
                    &FileGenericMapping,
                    &Privs, &dwPrivLength,
                    dwNtGrantedAccess,
                    fNtAccessCheckResult ))
                {
                    szMsg = L"AccessCheck";
                    goto GetError;
                }
            }
        }
        else
        {
            for (i=0; i < NumChecks; i++)
            {
                if (!AccessCheck( pSD, hToken, DESIRED_ACCESS,
                                  &FileGenericMapping,
                                  &Privs, &dwPrivLength,
                                  &dwNtGrantedAccess[0],
                                  &fNtAccessCheckResult[0] ))
                {
                    szMsg = L"AccessCheck";
                    goto GetError;
                }
            }
        }
    }
    
Cleanup:
    if ( szMsg )
    {
        wprintf (L"%s: %x\n", szMsg, dwError);
    }

    return dwError;

GetError:
    dwError = GetLastError();
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\fundsrm\fundsrm.h ===
#include "pch.h"

//
// Personal expenditures
//

#define ACCESS_FUND_PERSONAL 	 0x00000001

//
// Company spending
//

#define ACCESS_FUND_CORPORATE	 0x00000002

//
// Transfer to other funds
//

#define ACCESS_FUND_TRANSFER	 0x00000004



/*++

    Class Description
    
        This class handles the access control for a fund, using AuthZ and
        internal logic to determine whether certain users should be permitted
        certain types of actions on the fund.

--*/        

class FundsRM {
private:

	//
	// The amount of money available in the fund
	//
	
	DWORD _dwFundsAvailable; 
	
	//
	// The resource manager, initialized with the callback functions
	//
	
	AUTHZ_RESOURCE_MANAGER_HANDLE _hRM;
	
	//
	// The security descriptor for the fund, containing a callback ACE
	// which causes the resource manager callbacks to be used
	//
	
	SECURITY_DESCRIPTOR _SD;
	
public:

	//
	// Constructor for the resource manager
	// dwFundsAvailable is the initial funds deposited
	//
	
	FundsRM(DWORD dwFundsAvailable);
	
	//
	// Destructor
	//
	
	~FundsRM();
	
	// 
	// This function is called by a user who needs approval of a given amount
    // of spending in a given spending type. If the spending is approved, it
    // is deducted from the fund's total. If the spending is approved, TRUE
    // is returned. Otherwise FALSE is returned.
    //
    //   LPTSTR szwUsername - The name of the user, currently limited to 
    //    					 Bob, Martha, or Joe
    //    					 
	//	 DWORD dwRequestAmount - The amount of spending requested, in cents
	//	
	//	 DWORD dwSpendingType - The type of spending, ACCESS_FUND_PERSONAL,
	//						   ACCESS_FUND_TRANSFER, or ACCESS_FUND_CORPORATE
	//
	
	BOOL Authorize(LPTSTR szwUsername, DWORD RequestAmount, DWORD SpendingType);
	
	//
	// Returns the amount of funds still available
	//
	
	DWORD FundsAvailable();
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\benchmark\main.cpp ===
#include "pch.h"
#pragma hdrstop

#include "ntaccess.h"
#include "azaccess.h"
#include "bmcommon.h"
#include "benchmrk.h"

EXTERN_C AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager;
EXTERN_C AUTHZ_RM_AUDIT_INFO_HANDLE hRmAuditInfo;
double az_time, nt_time;
EXTERN_C PAUTHZ_ACCESS_REPLY pReply, pReplyOT;
EXTERN_C AUTHZ_AUDIT_INFO_HANDLE hAuditInfo;
void DoBenchMarks( IN ULONG NumIter, IN DWORD Flags )
{
    DWORD dwError=NO_ERROR;

    //
    // do NT access checks
    //
    dwError = InitNtAccessChecks();

    if ( dwError != NO_ERROR )
    {
        goto Cleanup;
    }

    wprintf(L"NtAccessChecks     : ");
    fflush(stdout);

    timer_start();
    
    dwError = DoNtAccessChecks( NumIter, Flags );

    if ( dwError != NO_ERROR )
    {
        goto Cleanup;
    }

    timer_stop();
    nt_time = timer_time();
    wprintf(L"%.2f sec\n", nt_time);
    
    //
    // do authz access checks
    //

    dwError = InitAuthzAccessChecks();

    if ( dwError != NO_ERROR )
    {
        goto Cleanup;
    }

    wprintf(L"AzAccessChecks     : ");
    fflush(stdout);

    timer_start();
    
    dwError = AuthzDoAccessCheck( NumIter, Flags );

    if ( dwError != NO_ERROR )
    {
        goto Cleanup;
    }

    timer_stop();
    az_time = timer_time();
    wprintf(L"%.2f sec\n", az_time);
    wprintf(L"perf ratio    : %2.2f \n", nt_time/az_time);
    
    //
    // make sure that both az and nt returned the same results
    //
    UINT len;
    
    if ( Flags & BMF_UseObjTypeList )
    {
        len = ObjectTypeListLength;

        for (UINT i=0; i < len; i++)
        {
            if ((pReplyOT->Error[i] != fNtAccessCheckResult[i]) ||
                ((pReplyOT->Error[i] == ERROR_SUCCESS) && (pReplyOT->GrantedAccessMask[i] != dwNtGrantedAccess[i])))
            {
                wprintf(L"AccessCheck mismatch @ %d\n", i);
                wprintf(L"AGA: %08lx\tAE: %08lx\nNGA: %08lx\tNE: %08lx\n",
                        pReplyOT->GrantedAccessMask[i],
                        pReplyOT->Error[i],
                        dwNtGrantedAccess[i],
                        fNtAccessCheckResult[i]);
            }
        }
    
    }
    else
    {
        if (
            ((pReply->Error[0] == ERROR_SUCCESS) && (0 == fNtAccessCheckResult[0])) ||
            ((pReply->Error[0] != ERROR_SUCCESS) && (1 == fNtAccessCheckResult[0])) ||
            ((pReply->Error[0] == ERROR_SUCCESS) && (pReply->GrantedAccessMask[0] != dwNtGrantedAccess[0]))
           )
        {
            wprintf(L"AccessCheck mismatch\n");
            wprintf(L"AGA: %08lx\tAE: %08lx\nNGA: %08lx\tNE: %08lx\n",
                    pReply->GrantedAccessMask[0],
                    pReply->Error[0],
                    dwNtGrantedAccess[0],
                    fNtAccessCheckResult[0]);
        }
    }

    //
    // make sure that both az and nt returned the same results
    //
    
    if ( Flags & BMF_UseObjTypeList )
    {
        len = ObjectTypeListLength;

        for (UINT i=0; i < len; i++)
        {

            if ((pReplyOT->Error[i] != fNtAccessCheckResult[i]) ||
                ((pReplyOT->Error[i] == ERROR_SUCCESS) && (pReplyOT->GrantedAccessMask[i] != dwNtGrantedAccess[i])))
            {
                wprintf(L"AccessCheck mismatch @ %d\n", i);
                wprintf(L"AGA: %08lx\tAE: %08lx\nNGA: %08lx\tNE: %08lx\n",
                        pReplyOT->GrantedAccessMask[i],
                        pReplyOT->Error[i],
                        dwNtGrantedAccess[i],
                        fNtAccessCheckResult[i]);
            }
        }
    
    }
    else
    {

        if (
            ((pReply->Error[0] == ERROR_SUCCESS) && (0 == fNtAccessCheckResult[0])) ||
            ((pReply->Error[0] != ERROR_SUCCESS) && (1 == fNtAccessCheckResult[0])) ||
            ((pReply->Error[0] == ERROR_SUCCESS) && (pReply->GrantedAccessMask[0] != dwNtGrantedAccess[0]))
           )
        {
            wprintf(L"AccessCheck mismatch\n");
            wprintf(L"AGA: %08lx\tAE: %08lx\nNGA: %08lx\tNE: %08lx\n",
                    pReply->GrantedAccessMask[0],
                    pReply->Error[0],
                    dwNtGrantedAccess[0],
                    fNtAccessCheckResult[0]);
        }
    }

    return;
    
Cleanup:
    wprintf(L"DoBenchMarks failed: %lx\n", dwError);
}


#define OTO_OT   1
#define OTO_SO   2
#define OTO_OTSO 3

PWCHAR szUsage = L"Usage: azbm iter-count ot-option access-mask sd-index audit-flag";


extern "C" int __cdecl wmain(int argc, PWSTR argv[])
{
    NTSTATUS Status;
    ULONG NumChecks = 10000;
    BOOLEAN WasEnabled;
    ULONG OtOptions;
    ACCESS_MASK DesiredAccess;
    ULONG SdIndex;
    DWORD fGenAudit;

    if ( argc != 6 )
    {
        wprintf(szUsage);
        exit(-1);
    }

    if (1 != swscanf(argv[1], L"%d", &NumChecks))
    {
        wprintf(L"Bad iteration-count");
        exit(-1);
    }
    
    if (1 != swscanf(argv[2], L"%d", &OtOptions))
    {
        wprintf(L"Bad ot-option");
        exit(-1);
    }
    
    if (1 != swscanf(argv[3], L"%x", &DesiredAccess))
    {
        wprintf(L"Bad access-mask");
        exit(-1);
    }
    g_DesiredAccess = DesiredAccess;

    
    if (1 != swscanf(argv[4], L"%d", &SdIndex))
    {
        wprintf(L"Bad sd-index");
        exit(-1);
    }
    g_szSd = g_aszSd[SdIndex];
    
    if (1 != swscanf(argv[5], L"%d", &fGenAudit))
    {
        wprintf(L"Bad audit-flag");
        exit(-1);
    }
    
    Status = RtlAdjustPrivilege(
                SE_AUDIT_PRIVILEGE,
                TRUE,                   // enable
                FALSE,                   // do it on the thread token
                &WasEnabled
                );
    if (!NT_SUCCESS(Status))
    {
        wprintf(L"RtlAdjustPrivilege: %lx\n", Status);
    }

    if ( fGenAudit )
    {
        if ( OtOptions & OTO_SO )
        {
            wprintf(L"regular access checks with audit\n");
            wprintf(L"---------------------\n");
            DoBenchMarks( NumChecks, BMF_GenerateAudit );
        }

        if ( OtOptions & OTO_OT )
        {
            wprintf(L"\n\naccess checks with obj-type list with audit\n");
            wprintf(L"--------------------------------\n");
            DoBenchMarks( NumChecks, BMF_UseObjTypeList | BMF_GenerateAudit );
        }
    }
    else
    {
        if ( OtOptions & OTO_SO )
        {
            wprintf(L"regular access checks\n");
            wprintf(L"---------------------\n");
            DoBenchMarks( NumChecks, 0 );
        }

        if ( OtOptions & OTO_OT )
        {
            wprintf(L"\n\naccess checks with obj-type list\n");
            wprintf(L"--------------------------------\n");
            DoBenchMarks( NumChecks, BMF_UseObjTypeList );
        }
    }
    AuthzFreeAuditInfo(hAuditInfo);
    AuthzFreeAuditQueue(NULL);
    AuthzFreeResourceManager(hAuthzResourceManager);
    
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\fundsrm\fundsrm.cpp ===
#include "fundsrm.h"
#include "fundsrmp.h"

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))


FundsRM::FundsRM(DWORD dwFundsAvailable) {
/*++

    Routine Description
    
        The constructor for the Funds resource manager.
        It initializes an instance of an Authz Resource Manager, providing it
        with the appropriate callback functions.
        It also creates a security descriptor for the fund, allowing only
        corporate and transfer expenditures, not personal. Additional logic
        could be added to allow VPs to override these restrictions, etc.

    Arguments
    
        DWORD dwFundsAvailable - The amount of money in the fund managed by this
        						 resource manager
    
    Return Value
        None.                       
--*/        
	
	//
	// The amount of money in the fund
	//
	
	_dwFundsAvailable = dwFundsAvailable;
	 
	//
	// Initialize the fund's resource manager
	//
	
	AuthzInitializeResourceManager(
        FundsAccessCheck,
        FundsComputeDynamicGroups,
        FundsFreeDynamicGroups,
        NULL, // no auditing
        0,    // no flags        
        &_hRM
        );

	//
	// Create the fund's security descriptor
	// 
	
    InitializeSecurityDescriptor(&_SD, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorGroup(&_SD, NULL, FALSE);
    SetSecurityDescriptorSacl(&_SD, FALSE, NULL, FALSE);
    SetSecurityDescriptorOwner(&_SD, NULL, FALSE);

	//
	// Initialize the DACL for the fund
	//
	
	PACL pDaclFund = (PACL)malloc(1024);
	InitializeAcl(pDaclFund, 1024, ACL_REVISION_DS);
	
	//
	// Add an access-allowed ACE for Everyone
	// Only company spending and transfers are allowed for this fund
	//
	
	AddAccessAllowedAce(pDaclFund,
						ACL_REVISION_DS,
						ACCESS_FUND_CORPORATE | ACCESS_FUND_TRANSFER, 
						EveryoneSid);
	
	//
	// Now set that ACE to a callback ACE
	//
	
	((PACE_HEADER)FirstAce(pDaclFund))->AceType = 
									ACCESS_ALLOWED_CALLBACK_ACE_TYPE;
	
	//
	// Add that ACL as the security descriptor's DACL
	//
	
	SetSecurityDescriptorDacl(&_SD, TRUE, pDaclFund, FALSE);
}

FundsRM::~FundsRM() {
/*++

    Routine Description
    
        The destructor for the Funds resource manager.
        Frees any dynamically allocated memory used.

    Arguments
    
        None.
    
    Return Value
        None.                       
--*/        
	
	//
	// Deallocate the DACL in the security descriptor
	//
	
	PACL pDaclFund = NULL;
	BOOL fDaclPresent;
	BOOL fDaclDefaulted;
	GetSecurityDescriptorDacl(&_SD,
							  &fDaclPresent,
							  &pDaclFund,
							  &fDaclDefaulted);
	
	if( pDaclFund != NULL )
	{
		free(pDaclFund);
	}
	
	//
	// Deallocate the resource manager
	//
	
	AuthzFreeResourceManager(_hRM);
}



BOOL FundsRM::Authorize(LPTSTR szwUsername,
						DWORD dwRequestAmount,
						DWORD dwSpendingType) {
/*++

    Routine Description
    
        This function is called by a user who needs approval of a given amount
        of spending in a given spending type. Internally, this uses the 
        AuthzAccessCheck function to determine whether the given user
        should be allowed the requested spending.
        If the spending is approved, it is deducted from the fund's total.

    Arguments
    
        LPTSTR szwUsername - The name of the user, currently limited to 
        					 Bob, Martha, or Joe
        					 
		DWORD dwRequestAmount - The amount of spending requested, in cents
		
		DWORD dwSpendingType - The type of spending, ACCESS_FUND_PERSONAL,
							   ACCESS_FUND_TRANSFER, or ACCESS_FUND_CORPORATE
    
    Return Value
        BOOL - True if the spending was approved, FALSE otherwise                       
--*/        
	

	//
	// No need to check access if not enough money in fund
	//
	
	if( dwRequestAmount > _dwFundsAvailable ) 
	{
		return FALSE;
	}

	//
	// This would normally impersonate the RPC user and create the 
	// client context from the token. However, we can just use strings for now.
	//
	
	PSID pUserSid = NULL;
	
	if( wcscmp(szwUsername, L"Bob") == 0 ) 
	{
		pUserSid = BobSid;
	}
	else if( wcscmp(szwUsername, L"Martha") == 0 ) 
	{
		pUserSid = MarthaSid;
	} 
	else if( wcscmp(szwUsername, L"Joe") == 0 ) 
	{
		pUserSid = JoeSid;
	}
	
	//
	// Only the above usernames are supported
	//
	
	if( pUserSid == NULL ) {
		return FALSE;
	}
	
	
	//
	// Now we create a client context from the SID
	//
	
	AUTHZ_CLIENT_CONTEXT_HANDLE hCC = NULL;
	LUID ZeroLuid = { 0, 0};
	
 	AuthzInitializeContextFromSid(pUserSid,
 								  NULL, // this is local, no need for server
 								  _hRM, // Using the Fund resource manager
 								  NULL, // no expiration
 								  ZeroLuid,    // no need for unique luid
 								  0,	// no flags,
 								  NULL, // no args for ComputeDynamicGroups
 								  &hCC);
		
	

	//
	// Initialize the access check result structure
	//
	
	DWORD dwGrantedAccessMask = 0;
	DWORD dwErr = ERROR_ACCESS_DENIED; // default to deny
	AUTHZ_ACCESS_REPLY AccessReply = {0};
	
	AccessReply.ResultListLength = 1;
	AccessReply.GrantedAccessMask = &dwGrantedAccessMask;
	AccessReply.Error = &dwErr;
	
	//
	// Initialize the access check request
	//
	
	AUTHZ_ACCESS_REQUEST AccessRequest = {0};
	
	AccessRequest.DesiredAccess = dwSpendingType;
	AccessRequest.PrincipalSelfSid = NULL;
	AccessRequest.ObjectTypeList = NULL;
	AccessRequest.ObjectTypeListLength = 0;
	AccessRequest.OptionalArguments = &dwRequestAmount;	
	
	AuthzAccessCheck(hCC, 			// Bob is requesting the transfer
					 &AccessRequest,
					 NULL, 				// no auditing
					 &_SD,
					 NULL, 				// only one SD and one object
					 0, 				// no additional SDs
					 &AccessReply,
					 NULL 				// no need to cache the access check
					 );
	
	//
	// Now free the client context
	//
	
	AuthzFreeContext(hCC);
					 
	//
	// AuthzAccessCheck sets ERROR_SUCCESS if all acces bits are granted
	//
	
	if( dwErr == ERROR_SUCCESS ) 
	{
		
		_dwFundsAvailable -= dwRequestAmount;
		return TRUE;
	} 
	else 
	{
		return FALSE;
	}
}



DWORD FundsRM::FundsAvailable() {
/*++

    Routine Description
    
       Accessor for the funds available

    Arguments
    
        None.
    
    Return Value
        DWORD - The amount of money available in the fund
--*/        

	return _dwFundsAvailable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\fundsrm\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <sddl.h>
#include <seopaque.h>
#include <sertlp.h>
#include <authz.h>

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\fundsrm\main.cpp ===
#include "fundsrm.h"


#define BUFFER_SIZE 1024

LPTSTR BobName = L"Bob";
LPTSTR MarthaName = L"Martha";
LPTSTR JoeName = L"Joe";

LPTSTR CorporateName = L"Corporate";
LPTSTR TransferName = L"Transfer";
LPTSTR PersonalName = L"Personal";

typedef struct {
	LPTSTR Name;
	DWORD Amount;
	DWORD Type;
} TestStruct;

#define NUM_TESTS 12
TestStruct Tests[NUM_TESTS] = 
	{
		{ BobName, 5000000, ACCESS_FUND_CORPORATE },
		{ MarthaName, 5000000, ACCESS_FUND_CORPORATE },
		{ JoeName, 4000000, ACCESS_FUND_TRANSFER },
		{ BobName, 600000, ACCESS_FUND_PERSONAL },
		{ MarthaName, 200000, ACCESS_FUND_CORPORATE },
		{ JoeName, 300000, ACCESS_FUND_TRANSFER },
		{ BobName, 10000, ACCESS_FUND_CORPORATE },
		{ MarthaName, 70000, ACCESS_FUND_TRANSFER },
		{ JoeName, 40000, ACCESS_FUND_TRANSFER },
		{ BobName, 2000, ACCESS_FUND_CORPORATE },
		{ MarthaName, 7000, ACCESS_FUND_PERSONAL },
		{ JoeName, 1000, ACCESS_FUND_CORPORATE }
	
	};
	
 
void __cdecl wmain(int argc, char *argv[]) {
	
	//
	// Initialize the resource manager object
	//
	
	FundsRM *pFRM = new FundsRM(2000000000);

	/* 
		Now we are ready to request fund approvals
		Again, Bob is a VP, therefore he can approve up to 100000000 cents in spending
		Martha is a Manager, so she can approve up to 1000000 cents
		Joe is an employee, so he is limited to 50000 in approvals
		
		We have a fund which allows company expenditures and transfers, but does not allow
		funds for personal use.
	
		Bob will attempt to get approval for a 50000000 cent ($500k) transfer, he should
		succeed.
		
		Bob will also attempt a 20000 cent ($200) personal withdrawal. He should fail,
		since the fund does not allow personal use.
		
		Martha will attempt a 500000 ($5k) company spending approval. She should succeed.
		
		Finally, Joe will attempt a 50001 cent ($500.01) transfer. He should fail, since
		he is limited to $500 approvals.
	
	*/
	
	for(int i=0; i<NUM_TESTS; i++) {
		
		wprintf(L"%s ", Tests[i].Name);
		
		if( pFRM->Authorize(Tests[i].Name, Tests[i].Amount, Tests[i].Type) ) {
			
			wprintf(L"approved for a ");
		
		} else {
			
			wprintf(L"NOT approved for a ");
		}
		
		switch(Tests[i].Type) {
			case ACCESS_FUND_CORPORATE:
				wprintf(L"%s ", CorporateName);
				break;
			case ACCESS_FUND_TRANSFER:
				wprintf(L"%s ", TransferName);
				break;
			case ACCESS_FUND_PERSONAL:
				wprintf(L"%s ", PersonalName);
				break;
			default:
				wprintf(L"unknown ");
		}
		
		wprintf(L"expenditure of $%u.%2.2u, $%u.%2.2u left\n", 
										Tests[i].Amount/100,
										Tests[i].Amount%100,
										pFRM->FundsAvailable()/100,
										pFRM->FundsAvailable()%100);
	}
															
	
	

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\fundsrm\fundsrmp.h ===
#pragma once

EXTERN_C BOOL
FundsAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable
    );

EXTERN_C BOOL
FundsComputeDynamicGroups(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
    IN PVOID Args,
    OUT PSID_AND_ATTRIBUTES *pSidAttrArray,
    OUT PDWORD pSidCount,
    OUT PSID_AND_ATTRIBUTES *pRestrictedSidAttrArray,
    OUT PDWORD pRestrictedSidCount
    );

EXTERN_C VOID
FundsFreeDynamicGroups (
    IN PSID_AND_ATTRIBUTES pSidAttrArray
    );
    

EXTERN_C PSID BobSid;
EXTERN_C PSID MarthaSid;
EXTERN_C PSID JoeSid;
EXTERN_C PSID VPSid;
EXTERN_C PSID ManagerSid;
EXTERN_C PSID EmployeeSid;
EXTERN_C PSID EveryoneSid;

EXTERN_C DWORD MaxSpendingVP;
EXTERN_C DWORD MaxSpendingManager;
EXTERN_C DWORD MaxSpendingEmployee;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\mailrm\mailrm.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mailrm.cpp

Abstract:

   The implementation of the Mail resource manager

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#include "pch.h"
#include "mailrm.h"
#include "mailrmp.h"
#include <time.h>





MailRM::MailRM()
/*++

    Routine Description
    
        The constructor for the Mail resource manager.
        It initializes an instance of an Authz Resource Manager, providing it
        with the appropriate callback functions.
        It also creates a security descriptor for the mail RM, with a
        SACL and DACL.

    Arguments
    
        None.
    
    Return Value
        None.                       
--*/        
{
    //
    // Initialize the audit information
    //

    AUTHZ_RM_AUDIT_INFO_HANDLE hRMAuditInfo;

    if( FALSE == AuthzInitializeRMAuditInfo(&hRMAuditInfo,
                                            0,
                                            0,
                                            0,
                                            L"MailRM") )
    {
        throw (DWORD)ERROR_INTERNAL_ERROR;
    }

    if( FALSE == AuthzInitializeResourceManager(
        MailRM::AccessCheck,
        MailRM::ComputeDynamicGroups,
        MailRM::FreeDynamicGroups,
        hRMAuditInfo, 
        0,    // no flags        
        &_hRM
        ) )
    {
        AuthzFreeRMAuditInfo(hRMAuditInfo);

        throw (DWORD)ERROR_INTERNAL_ERROR;

    }

    //
    // Create the security descriptor
    // 

    try {
        InitializeMailSecurityDescriptor();    
    }
    catch(...)
    {
        AuthzFreeRMAuditInfo(hRMAuditInfo);
        AuthzFreeResourceManager(_hRM);
        throw;
    }

}



MailRM::~MailRM() 
/*++

    Routine Description
    
        The destructor for the Mail resource manager.
        Frees any dynamically allocated memory used, including
        deleting any registered mailboxes.

    Arguments
    
        None.
    
    Return Value
        None.                       
--*/        
{
    //
    // Deallocate the DACL and SACL in the security descriptor
    //
    
    PACL pAclMail = NULL;
    BOOL fPresent;
    BOOL fDefaulted;

    DWORD dwTmp;

    AUTHZ_RM_AUDIT_INFO_HANDLE hAuditInfo;

    if( FALSE != AuthzGetInformationFromResourceManager(
                                           _hRM,
                                           AuthzRMInfoRMAuditInfo,
                                           &hAuditInfo,
                                           sizeof(AUTHZ_RM_AUDIT_INFO_HANDLE),
                                           &dwTmp
                                           ) )
    {
        AuthzFreeRMAuditInfo(hAuditInfo);
    }

    GetSecurityDescriptorDacl(&_sd,
                              &fPresent,
                              &pAclMail,
                              &fDefaulted);
    
    if( pAclMail != NULL )
    {
        delete[] (PBYTE)pAclMail;
        pAclMail = NULL;
    }

    GetSecurityDescriptorSacl(&_sd,
                              &fPresent,
                              &pAclMail,
                              &fDefaulted);

    if( pAclMail != NULL )
    {
        delete[] (PBYTE)pAclMail;
    }

    //
    // Deallocate the resource manager
    //

    AuthzFreeResourceManager(_hRM);

    //
    // Delete the mailboxes
    //

    while( ! _mapSidMailbox.empty() )
    {
        delete (*(_mapSidMailbox.begin())).second;
        _mapSidMailbox.erase(_mapSidMailbox.begin());
    }

    //
    // Free the AuthZ client contexts
    //
    
    while( ! _mapSidContext.empty() )
    {
        AuthzFreeContext((*(_mapSidContext.begin())).second);
        _mapSidContext.erase(_mapSidContext.begin());
    }
}


void MailRM::InitializeMailSecurityDescriptor()
/*++

    Routine Description
    
        This private method initializes the MailRM's security descriptor.
        It should be called exactly once, and only by the constructor.
        
        It creates a security descriptor with the following DACL:
        
        CallbackDeny    READ                Insecure    11pm-5am OR Sensitive
        Allow           READ, WRITE         PrincipalSelf
        Allow           READ, WRITE, ADMIN  MailAdmins
        
        And the following SACL
        
        CallbackAudit   READ                Insecure    11pm-5am OR Sensitive
        (audit on both success and failure)

    Arguments
    
        None.
    
    Return Value
        None.                       
--*/        
{
    DWORD dwAclSize = sizeof(ACL);
    DWORD dwAceSize = 0;
    
    PMAILRM_OPTIONAL_DATA pOptionalData = NULL;

    //
    // Initialize the security descriptor
    // No need for owner or group
    //
    
    InitializeSecurityDescriptor(&_sd, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorGroup(&_sd, NULL, FALSE);
    SetSecurityDescriptorOwner(&_sd, MailAdminsSid, FALSE);

    // 
    // Callback deny ace RWA for Insecure group SID
    // Optional data: Sensitive mailbox OR 11pm-5am
    // Any users coming in over an insecure connection between 11pm and 5am
    // should be denied read access.
    // Also any users coming in over insecure connections to sensitive mailboxes
    // should be denied read access.
    //

    PACCESS_DENIED_CALLBACK_ACE pDenyAce = NULL;

    //
    // This audit ACE has the same conditions as the above deny ACE. It audits
    // any successful (should not happen with the above deny) or failed
    // authentications which fit the callback parameters.
    //

    PSYSTEM_AUDIT_CALLBACK_ACE pAuditAce = NULL;

    //
    // DACL for the security descriptor
    //
    
    PACL pDacl = NULL;

    //
    // SACL for the security descriptor
    //

    PACL pSacl = NULL;




    //
    // We allocate and initialize the callback deny ACE
    //

    //
    // Size of the callback access denied ACE with the optional data
    //

    dwAceSize   = sizeof(ACCESS_DENIED_CALLBACK_ACE) // ACE and 1 DWORD of SID
                - sizeof(DWORD)                      // minus the dword
                + GetLengthSid(InsecureSid)          // length of the SID
                + sizeof(MAILRM_OPTIONAL_DATA);      // size of optional data

    
    pDenyAce = (PACCESS_DENIED_CALLBACK_ACE)new BYTE[dwAceSize];

    if( pDenyAce == NULL )
    {
        throw (DWORD)ERROR_OUTOFMEMORY;
    }

    
    //
    // Manually initialize the ACE structure
    //

    pDenyAce->Header.AceFlags = 0;
    pDenyAce->Header.AceSize = dwAceSize;
    pDenyAce->Header.AceType = ACCESS_DENIED_CALLBACK_ACE_TYPE;
    pDenyAce->Mask = ACCESS_MAIL_READ;

    //
    // Copy the Insecure SID into the ACE
    //

    memcpy(&(pDenyAce->SidStart), InsecureSid, GetLengthSid(InsecureSid));

    // 
    // Our optional data is at the end of the ACE
    //

    pOptionalData = (PMAILRM_OPTIONAL_DATA)( (PBYTE)pDenyAce 
                                           + dwAceSize
                                           - sizeof(MAILRM_OPTIONAL_DATA) );

    
    //
    // Initialize the optional data as described above
    //
    
    pOptionalData->bIsSensitive =   MAILRM_SENSITIVE;
    pOptionalData->bLogicType =     MAILRM_USE_OR;
    pOptionalData->bStartHour =     MAILRM_DEFAULT_START_TIME;
    pOptionalData->bEndHour =       MAILRM_DEFAULT_END_TIME;

    
    
    //
    // Add the size of the callback ACE to the expected ACL size
    //
    
    dwAclSize += dwAceSize;

    //
    // We also need to add non-callback ACEs
    //

    dwAclSize += (   sizeof(ACCESS_ALLOWED_ACE)
                   - sizeof(DWORD) 
                   + GetLengthSid(PrincipalSelfSid)  );

    dwAclSize += (   sizeof(ACCESS_ALLOWED_ACE)
                   - sizeof(DWORD) 
                   + GetLengthSid(MailAdminsSid)     );


    

    // 
    // Now we can allocate the DACL
    //

    pDacl = (PACL) (new BYTE[dwAclSize]);
    
    if( pDacl == NULL )
    {
        delete[] (PBYTE)pDenyAce;
        throw (DWORD)ERROR_OUTOFMEMORY;
    }

    //
    // Finally, initialize the ACL and copy the ACEs into it
    //
    
    InitializeAcl(pDacl, dwAclSize, ACL_REVISION_DS);
    
    // 
    // Copy the ACE into the ACL
    //

    AddAce(pDacl,
           ACL_REVISION_DS,
           0xFFFFFFFF,      // Add to end
           pDenyAce,
           dwAceSize);

    delete[] (PBYTE)pDenyAce;

    //
    // Add a PRINCIPAL_SELF_SID allow read and write ace
    //

    AddAccessAllowedAce(pDacl,
                        ACL_REVISION_DS,
                        ACCESS_MAIL_READ | ACCESS_MAIL_WRITE,
                        PrincipalSelfSid);

    //
    // Add an allow mail administrators group full access
    //

    AddAccessAllowedAce(pDacl,
                    ACL_REVISION_DS,
                    ACCESS_MAIL_READ | ACCESS_MAIL_WRITE | ACCESS_MAIL_ADMIN,
                    MailAdminsSid);



    //
    // Now create the SACL, which will onlye have a single callback ACE
    //

    dwAclSize = sizeof(ACL);
    
    dwAceSize   = sizeof(SYSTEM_AUDIT_CALLBACK_ACE) // ACE and 1 DWORD of SID
                - sizeof(DWORD)                      // minus the dword
                + GetLengthSid(InsecureSid)          // length of the SID
                + sizeof(MAILRM_OPTIONAL_DATA);      // size of optional data

    //
    // Allocate the callback audit ACE
    //

    pAuditAce = (PSYSTEM_AUDIT_CALLBACK_ACE)new BYTE[dwAceSize];

    if( pAuditAce == NULL )
    {
        delete[] (PBYTE)pDacl;
        throw (DWORD)ERROR_OUTOFMEMORY;
    }

    //
    // Initialize the ACE structure
    //

    pAuditAce->Header.AceFlags  = FAILED_ACCESS_ACE_FLAG 
                                | SUCCESSFUL_ACCESS_ACE_FLAG;

    pAuditAce->Header.AceSize = dwAceSize;
    pAuditAce->Header.AceType = SYSTEM_AUDIT_CALLBACK_ACE_TYPE;
    pAuditAce->Mask = ACCESS_MAIL_READ;

    //
    // Copy the Insecure SID into the ACE
    //

    memcpy(&(pAuditAce->SidStart), InsecureSid, GetLengthSid(InsecureSid));

    pOptionalData = (PMAILRM_OPTIONAL_DATA)( (PBYTE)pAuditAce 
                                           + dwAceSize
                                           - sizeof(MAILRM_OPTIONAL_DATA) );

    //
    // Initialize the optional data as described above
    //
    
    pOptionalData->bIsSensitive =   MAILRM_SENSITIVE;
    pOptionalData->bLogicType =     MAILRM_USE_OR;
    pOptionalData->bStartHour =     MAILRM_DEFAULT_START_TIME;
    pOptionalData->bEndHour =       MAILRM_DEFAULT_END_TIME;


    dwAclSize += dwAceSize;

    //
    // Allocate the SACL
    //

    pSacl = (PACL)new BYTE[dwAclSize];

    if( pSacl == NULL )
    {
        delete[] (PBYTE)pDacl;
        throw (DWORD)ERROR_OUTOFMEMORY;
    }

    InitializeAcl(pSacl, dwAclSize, ACL_REVISION_DS);

    //
    // Now add the audit ACE to the SACL
    //

    AddAce(pSacl,
           ACL_REVISION_DS,
           0xFFFFFFFF,      // Add to end
           pAuditAce,
           dwAceSize);

    delete[] (PBYTE)pAuditAce;

    //
    // We now have the DACL and the SACL, set them
    // in the  security descriptor
    //

    SetSecurityDescriptorDacl(&_sd, TRUE, pDacl, FALSE);

    SetSecurityDescriptorSacl(&_sd, TRUE, pSacl, FALSE);

}



void MailRM::AddMailbox(Mailbox *pMailbox)
/*++

    Routine Description
    
        Registers a mailbox (and its user) with the resource manager.   

    Arguments
    
        pMailbox    -   Pointer to an allocated and initialized mailbox
    
    Return Value
        None.                       
--*/        
{
    _mapSidMailbox[pMailbox->GetOwnerSid()] = pMailbox;
}


Mailbox * MailRM::GetMailboxAccess(
                                const PSID psMailbox,
                                const PSID psUser,
                                DWORD dwIncomingIp,
                                ACCESS_MASK amAccessRequested
                                  )
/*++

    Routine Description
    
        This routine checks whether the user with SID psUser should
        be allowed access to the mailbox of user psMailbox. psUser
        is coming from dwIncomingIp, and desires amAccessRequested
        access mask.
        
    Arguments
    
        psMailbox   -   PSID of the user whose mailbox will be accessed
        
        psUser      -   PSID of the user accessing the mailbox
        
        dwIncomingIp-   IP address of the user accessing the mailbox
        
        amAccessRequested - Requested access type to the mailbox
    
    Return Value
        
        Non-NULL Mailbox * if access is granted.
        
        NULL if mailbox does not exist or access is denied.                       
--*/        

{

    AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClient;

    AUTHZ_ACCESS_REQUEST AuthzAccessRequest;

    AUTHZ_ACCESS_REPLY AuthzAccessReply;

    AUTHZ_AUDIT_INFO_HANDLE hAuthzAuditInfo = NULL;
    
    PAUDIT_EVENT_INFO pAuditEventInfo = NULL;

    wstring wsAccessType;

    DWORD dwErr = ERROR_SUCCESS;

    ACCESS_MASK amAccessGranted = 0;

    WCHAR szIP[20];

    // 
    // Find the correct mailbox
    //

    Mailbox *pMbx = _mapSidMailbox[psMailbox];

    //
    // Initialize the auditing info for a Generic object
    //

	if( FALSE == AuthzInitializeAuditEvent(	&pAuditEventInfo,
											AUTHZ_INIT_GENERIC_AUDIT_EVENT,
											0,
											0,
											0) )
	{
		throw (DWORD)ERROR_INTERNAL_ERROR;
	}

	try {
		if( amAccessRequested & ACCESS_MAIL_READ )
		{
			wsAccessType.append(L"Read ");
		}
		
		if( amAccessRequested & ACCESS_MAIL_WRITE )
		{
			wsAccessType.append(L"Write ");
		}
	
		if( amAccessRequested & ACCESS_MAIL_ADMIN )
		{
			wsAccessType.append(L"Administer");
		}
	}
	catch(...)
	{
		throw (DWORD)ERROR_INTERNAL_ERROR;
	}

    wsprintf(szIP, L"IP: %d.%d.%d.%d",  (dwIncomingIp >> 24) & 0x000000FF,
                                        (dwIncomingIp >> 16) & 0x000000FF,
                                        (dwIncomingIp >> 8 ) & 0x000000FF,
                                        (dwIncomingIp      ) & 0x000000FF );

    if( NULL == AuthzInitializeAuditInfo(
							 &hAuthzAuditInfo,
                             0,
                             pAuditEventInfo,
                             NULL,
                             INFINITE,
                             wsAccessType.c_str(),
                             L"Mailbox",
                             pMbx->GetOwnerName(),
                             szIP) )
	{
		AuthzFreeAuditEvent(pAuditEventInfo);
		throw (DWORD)ERROR_INTERNAL_ERROR;
	}

	//
	// The audit event info is only needed for the above call, we can
	// deallocate it immediately after
	//

	AuthzFreeAuditEvent(pAuditEventInfo);


    //
    // Set up the Authz access request
    //

    AuthzAccessRequest.DesiredAccess = amAccessRequested;
    AuthzAccessRequest.ObjectTypeList = NULL;
    AuthzAccessRequest.ObjectTypeListLength = 0;
    AuthzAccessRequest.OptionalArguments = pMbx;

    //
    // The PrincipalSelf SID is the SID of the mailbox owner
    // This way, the PRINCIPAL_SELF_SID allow ACE grants access
    // only to the owner. PrincipalSelfSid in the ACE will be replaced
    // by this value for access check purposes. The owner of this mailbox
    // will have the same SID in his context. Therefore, the two SIDs will
    // match if there is a PrincipalSelfSid ACE in the ACL.
    //

    AuthzAccessRequest.PrincipalSelfSid = pMbx->GetOwnerSid();
    
    //
    // Prepare the reply structure
    //

    AuthzAccessReply.Error = &dwErr;
    AuthzAccessReply.GrantedAccessMask = &amAccessGranted;
    AuthzAccessReply.ResultListLength = 1;

    //
    // Create or retrieve the client context
    //

    if( _mapSidContext.find(pair<PSID, DWORD>(psUser, dwIncomingIp))
        == _mapSidContext.end())
    {
        //
        // No context available, initialize
        //

        LUID lIdentifier = {0L, 0L};

        //
        // Since we are using SIDs which are not generated by NT,
        // it would be pointless to resolve group memberships, since
        // the SIDs will not be recognized by any machine in the domain,
        // and none of our ACLs use actual NT account SIDs. Therefore,
        // we use the SKIP_LOCAL_GROUPS and SKIP_TOKEN_GROUPS flags,
        // the LOCAL prevents a check for groups on the local machine, 
        // and TOKEN prevents a search on the domain
        //

        if( FALSE == AuthzInitializeContextFromSid(
                            psUser,
                            NULL,
                            _hRM,
                            NULL,
                            lIdentifier,
                            AUTHZ_SKIP_LOCAL_GROUPS | AUTHZ_SKIP_TOKEN_GROUPS,
                            &dwIncomingIp,
                            &hAuthzClient) )
        {
            AuthzFreeAuditInfo(hAuthzAuditInfo, _hRM);
            throw (DWORD)ERROR_INTERNAL_ERROR;

        }

        _mapSidContext[pair<PSID, DWORD>(psUser, dwIncomingIp)] = 
                                                                hAuthzClient;
    }
    else
    {
        //
        // Use existing context
        //

        hAuthzClient = _mapSidContext[pair<PSID, DWORD>(psUser, dwIncomingIp)];

    }

    BOOL bTmp;

    //
    // Perform the access check
    //

    bTmp = AuthzAccessCheck(
                     hAuthzClient,
                     &AuthzAccessRequest,
                     hAuthzAuditInfo,
                     &_sd,
                     NULL,
                     0,
                     &AuthzAccessReply,
                     NULL
                     );

    AuthzFreeAuditInfo(hAuthzAuditInfo, _hRM);

    //
    // Determine whether to grant access
    // On AccessCheck error, deny access
    //

    if( dwErr == ERROR_SUCCESS && bTmp != FALSE)
    {
        return pMbx;
    }
    else
    {
        return NULL;
    }

}




BOOL MailRM::GetMultipleMailboxAccess(
                            IN      const PMAILRM_MULTI_REQUEST pRequest,
                            IN OUT  PMAILRM_MULTI_REPLY pReply
                            )
/*++

    Routine Description
    
        This routine performs a set of cached access checks in order to request
        access to a set of mailboxes for a single user (for example, mail admin
        sending out a message to all users). 
                
        No need to audit, since this type of access would be only done by an
        administrator, and multiple audits would most likely flood the mailbox.
        Something like this would be use, for example, to send out a message
        to all users.
		
		The cached access check first assumes all callback deny ACEs which match
        SIDs in the user's context apply, and no allow callback ACEs apply.
		Therefore, the cached access check may initially deny access when it
        should be granted. If a cached access check results
        in access denied, a regular access check is performed automatically
        by AuthZ. As a result, the cached access check is guaranteed to have
        the same results as a normal access check, though it will take
        significantly more time if many denies are encountered than if most
        access requests succeed.

    Arguments
    
        pRequest    -   Request structure describing the user and the mailboxes
        
        pReply      -   Reply structure returning mailbox pointers and granted
                        access masks. If the access check fails, a NULL pointer
                        is returned for the given mailbox. This is allocated
                        by the caller, and should have the same number of
                        elements as the request.
                                
    
    Return Value
    
        TRUE on success
        
        FALSE on failure. If failure, pReply may not be completely filled
        
--*/        


{

    AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClient;

    AUTHZ_ACCESS_REQUEST AuthzAccessRequest;

    AUTHZ_ACCESS_REPLY AuthzAccessReply;

    DWORD dwErr = ERROR_SUCCESS;

    ACCESS_MASK amAccessGranted = 0;

    AUTHZ_HANDLE hAuthzCached;

    //
    // Set up the Authz access request
    // Only the DesiredAccess and PrincipalSelfSid parameters will change
    // per mailbox. Initial access check is MAXIMUM_ALLOWED.
    //

    AuthzAccessRequest.ObjectTypeList = NULL;
    AuthzAccessRequest.ObjectTypeListLength = 0;

    //
    // Initial access check will be caching, therefore optional parameters
    // will not be used
    //

    AuthzAccessRequest.OptionalArguments = NULL;

    //
    // The PrincipalSelf SID is the SID of the mailbox owner
    // This way, the PRINCIPAL_SELF_SID allow ACE grants access
    // only to the owner
    //

    AuthzAccessRequest.PrincipalSelfSid = NULL;

    //
    // Initially ask for MAXIMUM_ALLOWED access
    //

    AuthzAccessRequest.DesiredAccess = MAXIMUM_ALLOWED;
    
    //
    // Prepare the reply structure
    //

    AuthzAccessReply.Error = &dwErr;
    AuthzAccessReply.GrantedAccessMask = &amAccessGranted;
    AuthzAccessReply.ResultListLength = 1;

    //
    // Create or retrieve the client context
    //

    if( _mapSidContext.find(
           pair<PSID, DWORD>(pRequest->psUser , pRequest->dwIp)) 
        == _mapSidContext.end())
    {
        //
        // No context available, initialize
        //

        LUID lIdentifier = {0L, 0L};

        //
        // The SIDs are not real, therefore do not attempt to resolve
        // local or domain group memberships for the token
        //

        AuthzInitializeContextFromSid(
                            pRequest->psUser,
                            NULL,
                            _hRM,
                            NULL,
                            lIdentifier,
                            AUTHZ_SKIP_LOCAL_GROUPS | AUTHZ_SKIP_TOKEN_GROUPS,
                            &(pRequest->dwIp),
                            &hAuthzClient);

       
        _mapSidContext[pair<PSID, DWORD>(pRequest->psUser,
                                         pRequest->dwIp)] = hAuthzClient;
    }
    else
    {
        //
        // Use existing context
        //

        hAuthzClient = _mapSidContext[pair<PSID, DWORD>(pRequest->psUser,
                                                        pRequest->dwIp)];
        
    }

    //
    // Perform a single AuthZ access check to get the cached handle
    //

    if( FALSE == AuthzAccessCheck(
                         hAuthzClient,
                         &AuthzAccessRequest,
                         NULL,
                         &_sd,
                         NULL,
                         0,
                         &AuthzAccessReply,
                         &hAuthzCached
                         ))
    {
        return FALSE;
    }

    //
    // Now use the cached access check for all of the access requests
    //

    DWORD i;
    Mailbox * mbx;

    for( i = 0; i < pRequest->dwNumElems; i++ )
    {
        mbx = _mapSidMailbox[pRequest->pRequestElem[i].psMailbox];

        AuthzAccessRequest.DesiredAccess = 
                                    pRequest->pRequestElem[i].amAccessRequested;

        AuthzAccessRequest.PrincipalSelfSid = mbx->GetOwnerSid();

        AuthzAccessRequest.OptionalArguments = mbx;
            

        if( FALSE == AuthzCachedAccessCheck(
                            hAuthzCached,
                            &AuthzAccessRequest,
                            NULL,
                            &AuthzAccessReply
                            ))
        {
            return FALSE;
        }

        //
        // Access check done, now fill in the access array element
        //

        if( dwErr == ERROR_SUCCESS )
        {
            pReply[i].pMailbox = mbx;

            pReply[i].amAccessGranted = amAccessGranted;
        }
        else
        {
            pReply[i].pMailbox = NULL;

            pReply[i].amAccessGranted = 0;
        }

    }

    return TRUE;

}




BOOL CALLBACK MailRM::AccessCheck(
                        IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
                        IN PACE_HEADER pAce,
                        IN PVOID pArgs OPTIONAL,
                        IN OUT PBOOL pbAceApplicable
                        )
/*++

    Routine Description
    
        This is the Authz callback access check for the mail resource manager.
        
        It determines whether the given callback ACE applies based on whether
        the mailbox contains sensitive information and the current time.
            
    Arguments
    
        pAuthzClientContext -   the AuthZ client context of the user accessing
                                the mailbox, with dynamic groups already
                                computed
        
        pAce                -   Pointer to the start of the callback ACE
                                The optional ACE data is in the last 4
                                bytes of the ACE
        
        pArgs               -   The optional argument passed to the
                                AuthzAccessCheck, pointer to the Mailbox
                                being accessed
        
        pbAceApplicable     -   Set to TRUE iff the ACE should be used in the
                                access check.
    
    Return Value
        
        TRUE on success
        
        FALSE on failure                       
--*/        
{

    BOOL bTimeApplies;
    BOOL bSensitiveApplies;

 
    //
    // If pArgs are not present, ACE is never applicable
    //

    if( pArgs == NULL )
    {
        *pbAceApplicable = FALSE;
        return TRUE;
    }

    //
    // Offset of the optional data, last 4 bytes of the callback ACE
    //

    PMAILRM_OPTIONAL_DATA pOptData = (PMAILRM_OPTIONAL_DATA) (
                                             (PBYTE)pAce 
                                           + pAce->AceSize
                                           - sizeof(MAILRM_OPTIONAL_DATA));

    //
    // Get current time and check if the ACE time restriction applies
    //

    time_t tTime;
    struct tm * tStruct;
    
    time(&tTime);
    tStruct = localtime(&tTime);

    if( WITHIN_TIMERANGE(tStruct->tm_hour,
                         pOptData->bStartHour,
                         pOptData->bEndHour) )
    {
        bTimeApplies = TRUE;
    }
    else
    {
        bTimeApplies = FALSE;
    }

    //
    // Check whether the mailbox is sensitive and the ACE applies to sensitive
    // mailboxes
    //

    if(    ((Mailbox *)pArgs)->IsSensitive() 
        && pOptData->bIsSensitive == MAILRM_SENSITIVE )
    {
        bSensitiveApplies = TRUE;
    }
    else
    {
        bSensitiveApplies = FALSE;
    }
    
    //
    // Make the final decision based on whether the optional argument
    // calls for an AND or OR condition
    //

    if( pOptData->bLogicType == MAILRM_USE_AND )
    {
        *pbAceApplicable = bSensitiveApplies && bTimeApplies;
    }
    else
    {
        *pbAceApplicable = bSensitiveApplies || bTimeApplies;

    }

    //
    // AccessCheck succeeded
    //

    return TRUE;
    
}







BOOL CALLBACK MailRM::ComputeDynamicGroups(
                        IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
                        IN PVOID Args,
                        OUT PSID_AND_ATTRIBUTES *pSidAttrArray,
                        OUT PDWORD pSidCount,
                        OUT PSID_AND_ATTRIBUTES *pRestrictedSidAttrArray,
                        OUT PDWORD pRestrictedSidCount
                        )
/*++

    Routine Description
    
        This is the Authz callback which computes additional dynamic groups
        for the user context.
        
        If the user is originating at an IP address outside the company lan
        (company lan assumed to be 192.*), the InsecureSid SID is added
        to the client's context, signifying that the connection is not 
        secure. This enables callback ACEs which prohibit sensitive
        information from being sent over insecure connections.
            
    Arguments
    
        pAuthzClientContext -   the AuthZ client context of the user 
                
        pArgs               -   The optional argument passed to the
                                AuthzCreateContext, pointer to a DWORD
                                containing the user's IP address
                                        
        pSidAttrArray *     -   The additional SIDs, if any are assigned,
                                are returned here.
        
        pSidCount           -   Number of entries in pSidAttrArray
        
        pRestrictedSidAttrArray *   -   The additional restricted SIDs, if any 
                                        are assigned, are returned here.
        
        pRestrictedSidCount         -   Number of entries in pSidAttrArray

    
    Return Value
        
        TRUE on success
        
        FALSE on failure                       
--*/        

{

    //
    // No restrict-only groups used
    //

    *pRestrictedSidCount = 0;
    *pRestrictedSidAttrArray = NULL;

    //
    // Internal company network (secure) is 192.*, anything else is insecure
    //

    if( *( (DWORD *) Args) >= 0xC0000000 && *( (DWORD *) Args) < 0xC1000000 )
    {   
        //
        // Secure, within the company IP range, no restricted groups
        //

        *pSidCount = 0;
        *pSidAttrArray = NULL;

    }
    else
    {
        //
        // Insecure external connection, add the Insecure group SID
        //

        *pSidCount = 1;
        *pSidAttrArray = 
                    (PSID_AND_ATTRIBUTES)malloc( sizeof(SID_AND_ATTRIBUTES) );

        if( pSidAttrArray == NULL )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        (*pSidAttrArray)[0].Attributes = SE_GROUP_ENABLED;

        (*pSidAttrArray)[0].Sid = InsecureSid;


    }

                                              
    return TRUE;    
                                           
}


VOID CALLBACK MailRM::FreeDynamicGroups (
                        IN PSID_AND_ATTRIBUTES pSidAttrArray
                        )
/*++

    Routine Description
    
        This routine frees any memory allocated by ComputeDynamicGroups
                    
    Arguments
    
        pSidAttrArray   -   Pointer to the memory to be freed
    
    Return Value
        
        None

--*/        

{
    

    free(pSidAttrArray);

}



bool CompareSidStruct::operator()(const PSID pSid1, const PSID pSid2) const
/*++

    Routine Description

        This is a less-than function which places a complete ordering on
        a set of PSIDs by value, NULL PSIDs are valid. This is used by the 
        STL map.
        
        Since the number of subauthorities appears before the subauthorities
		themselves, that difference will be noticed for two SIDs of different
		size before the memcmp tries to access the nonexistant subauthority
		in the shorter SID, therefore an access violation will not occur.
                    
    Arguments
    
        pSid1   -   The first PSID
        pSid2   -   The second PSID
    
    Return Value
        
        true IFF pSid1 < pSid2

--*/        

{

    //
    // If both are NULL, false should be returned for complete ordering
    //

    if(pSid2 == NULL)
    {
        return false;
    }

    if(pSid1 == NULL)
    {
        return true;
    }

    if( memcmp(pSid1, pSid2, GetLengthSid(pSid1)) < 0 )
    {
        return true;
    }
    else
    {
        return false;
    }
}



bool CompareSidPairStruct::operator()(const pair<PSID, DWORD > pair1, 
                                      const pair<PSID, DWORD > pair2) const
/*++

    Routine Description

        This is a less-than function which places a complete ordering on
        a set of <PSID, DWORD> pairs by value, NULL PSIDs are valid. This
        is used by the STL map
                    
    Arguments
    
        pair1   -   The first pair
        pair2   -   The second pair
    
    Return Value
        
        true IFF pSid1 < pSid2 OR (pSid1 = pSid2 AND DWORD1 < DWORD2)

--*/        
{
    CompareSidStruct SidComp;
    
    if( pair1.second < pair2.second )
    {
        return true;
    }

    if( pair1.second > pair2.second )
    {
        return false;
    }

    return SidComp.operator()(pair1.first, pair2.first);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\fundsrm\fundsrmp.c ===
#include "pch.h"
#include "fundsrmp.h"

//
// The various SIDs, the easy way
//

DWORD BobGuid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00020001};
DWORD MarthaGuid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00020002};
DWORD JoeGuid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00020003};
DWORD VPGuid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00010001};
DWORD ManagerGuid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00010002};
DWORD EmployeeGuid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00010003};
DWORD EveryoneGuid[] = {0x101, 0x01000000, 0};
PSID BobSid = (PSID)BobGuid;
PSID MarthaSid= (PSID)MarthaGuid;
PSID JoeSid = (PSID)JoeGuid;
PSID VPSid = (PSID)VPGuid;
PSID ManagerSid = (PSID)ManagerGuid;
PSID EmployeeSid = (PSID)EmployeeGuid;
PSID EveryoneSid = (PSID)EveryoneGuid;

//
// Maximum spending approvals, in cents
//

DWORD MaxSpendingVP = 100000000;
DWORD MaxSpendingManager = 1000000;
DWORD MaxSpendingEmployee = 50000;


//
// The callback routines used with AuthZ
//

BOOL
FundsAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable
    )

/*++

    Routine Description
    
    	This is the callback access check. It is registered with a 
    	resource manager. AuthzAccessCheck calls this function when it
    	encounters a callback type ACE, one of:
    	ACCESS_ALLOWED_CALLBACK_ACE_TYPE 
    	ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE
    	ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE
    	
    	This function determines if the given callback ACE applies to the
    	client context (which has already had dynamic groups computed) and
    	the optional arguments, in this case the request amount.
    	
    	The list of groups which apply to the user is traversed. If a group
    	is found which allows the user the requested access, pbAceApplicable
    	is set to true and the function returns. If the end of the group list
    	is reached, pbAceApplicable is set to false and the function returns.
        
    Arguments
    
        hAuthzClientContext - handle to the AuthzClientContext.
        
        pAce - pointer to the Ace header.
        
        pArgs - optional arguments, in this case DWORD*, DWORD is  the spending
        	request amount in cents
        
        pbAceApplicable - returns true iff the ACE allows the client's request

    Return value
    
        Bool, true on success, false on error
        
    Error checking
    
    	Sample code, no error checking
    	
--*/
{
	//
	// First, look up the user's SID from the context
	//
	
	DWORD dwTokenGroupsSize = 0;
	PVOID pvTokenGroupsBuf = NULL;
	DWORD i;
	PDWORD pAccessMask = NULL;
	
	//
	// The requested spending amount, in cents
	//
	
	DWORD dwRequestedSpending = ((PDWORD)pArgs)[0];

	//
	// By default, the ACE does not apply to the request
	//
	
	*pbAceApplicable = FALSE;

	//
	// The object's access mask (right after the ACE_HEADER)
	// The access mask determines types of expenditures allowed
	// from this fund
	//
	
	pAccessMask = (PDWORD) (pAce + sizeof(ACE_HEADER));
	
	//
	// Get needed buffer size
	//
	
	AuthzGetContextInformation(hAuthzClientContext,
							   AuthzContextInfoGroupsSids,
							   NULL,
							   0, 
							   &dwTokenGroupsSize
							   );

	pvTokenGroupsBuf = malloc(dwTokenGroupsSize);
	
	//
	// Get the actual TOKEN_GROUPS array 
	//
	
	AuthzGetContextInformation(hAuthzClientContext,
							   AuthzContextInfoGroupsSids,
							   pvTokenGroupsBuf,
							   dwTokenGroupsSize,
							   &dwTokenGroupsSize
							   );
	
	
	//
	// Go through the groups until end is reached or a group applying to the
	// request is found
	//
	
	for( i = 0; 
		 i < ((PTOKEN_GROUPS)pvTokenGroupsBuf)->GroupCount 
		 && *pbAceApplicable != TRUE;
		 i++ ) 
	{
		//
		//	Again, this is the business logic.
		//	Each level of employee can approve different amounts.
		//
		
		//
		// VP
		//
		
		if( dwRequestedSpending <= MaxSpendingVP &&
			EqualSid(VPSid, ((PTOKEN_GROUPS)pvTokenGroupsBuf)->Groups[i].Sid) )
		{
			*pbAceApplicable = TRUE;

		}
			
		//	
		// Manager
		//
		
		if( dwRequestedSpending <= MaxSpendingManager &&
			EqualSid(ManagerSid, ((PTOKEN_GROUPS)pvTokenGroupsBuf)->Groups[i].Sid) )
		{
			*pbAceApplicable = TRUE;
		}
			
		//
		// Employee
		//
		
		if( dwRequestedSpending <= MaxSpendingEmployee &&
			EqualSid(EmployeeSid, ((PTOKEN_GROUPS)pvTokenGroupsBuf)->Groups[i].Sid) )
		{
			*pbAceApplicable = TRUE;
		}
	}
	
	return TRUE;
}



BOOL
FundsComputeDynamicGroups(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
    IN PVOID Args,
    OUT PSID_AND_ATTRIBUTES *pSidAttrArray,
    OUT PDWORD pSidCount,
    OUT PSID_AND_ATTRIBUTES *pRestrictedSidAttrArray,
    OUT PDWORD pRestrictedSidCount
    )

/*++

    Routine Description
    
        Resource manager callback to compute dynamic groups.  This is used by the RM
        to decide if the specified client context should be included in any RM defined groups.
        
        In this example, the employees are hardcoded into their roles. However, this is the 
        place you would normally retrieve data from an external source to determine the 
        users' additional roles.
        
    Arguments
    
        hAuthzClientContext - handle to client context.
        Args - optional parameter to pass information for evaluating group membership.
        pSidAttrArray - computed group membership SIDs
        pSidCount - count of SIDs
        pRestrictedSidAttrArray - computed group membership restricted SIDs
        pRestrictedSidCount - count of restricted SIDs
        
    Return Value 
        
        Bool, true for success, false on failure.

    Error checking
    
    	Sample code, no error checking

--*/    
{
	//
	// First, look up the user's SID from the context
	//
	
	DWORD dwSidSize = 0;
	PVOID pvSidBuf = NULL;
	PSID  psSidPtr = NULL;

	//
	// Get needed buffer size
	//
	
	AuthzGetContextInformation(hAuthzClientContext,
							   AuthzContextInfoUserSid,
							   NULL,
							   0, 
							   &dwSidSize
							   );

	pvSidBuf = malloc(dwSidSize);
	
	//
	// Get the actual SID (inside a TOKEN_USER structure)
	//
	
	AuthzGetContextInformation(hAuthzClientContext,
							   AuthzContextInfoUserSid,
							   pvSidBuf,
							   dwSidSize,
							   &dwSidSize
							   );

	psSidPtr = ((PTOKEN_USER)pvSidBuf)->User.Sid;
	
	//
	// Allocate the memory for the returns, which will be deallocated by FreeDynamicGroups
	// Only a single group will be returned, determining the employee type
	//
	
	*pSidCount = 1;
	*pSidAttrArray = (PSID_AND_ATTRIBUTES)malloc( sizeof(SID_AND_ATTRIBUTES) );
	
	//
	// No restricted group sids
	//
	
	pRestrictedSidCount = 0;
	*pRestrictedSidAttrArray = NULL;
	
	(*pSidAttrArray)[0].Attributes = SE_GROUP_ENABLED;
	
	//
	// 		The hardcoded logic: 
	//		Bob is a VP
	//		Martha is a Manager
	//		Joe is an Employee
	//
	
	if( EqualSid(psSidPtr, BobSid) ) 
	{
		(*pSidAttrArray)[0].Sid = VPSid;
	} 
	else if( EqualSid(psSidPtr, MarthaSid) ) 
	{
		(*pSidAttrArray)[0].Sid = ManagerSid;
	}
	else if( EqualSid(psSidPtr, JoeSid) )
	{
		(*pSidAttrArray)[0].Sid = EmployeeSid;		
	}

	free(pvSidBuf);
	return TRUE;	
}

VOID
FundsFreeDynamicGroups (
    IN PSID_AND_ATTRIBUTES pSidAttrArray
    )

/*++

    Routine Description
    
        Frees memory allocated for the dynamic group array.

    Arguments
    
        pSidAttrArray - array to free.
    
    Return Value
        None.                       
--*/        
{
    if (pSidAttrArray != NULL)
    {
    	free(pSidAttrArray);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\mailrm\mailrmp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mailrmp.h

Abstract:

	Private header file for the resource manager

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#pragma once

#include "pch.h"




//
// Statically initialize the SIDs used
// We only need our own identifier authority (so as not to collide with 
// NT's accounts if we eventually allow the use of NT domain SIDs) and
// a single relative ID (the last number) identifying the user/group,
// since we are not using multiple domains. Mail domains could be added
// by adding a domain GUID to the user's SIDs before the user's RID.
//

#define MAILRM_IDENTIFIER_AUTHORITY { 0, 0, 0, 0, 0, 42 }

SID sInsecureSid = 		 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 1 };
SID sBobSid = 			 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 2 };
SID sMarthaSid= 		 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 3 };
SID sJoeSid = 			 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 4 };
SID sJaneSid = 			 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 5 };
SID sMailAdminsSid = 	 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 6 };

PSID InsecureSid = 	&sInsecureSid;
PSID BobSid = &sBobSid;
PSID MarthaSid= &sMarthaSid;
PSID JoeSid = &sJoeSid;
PSID JaneSid = &sJaneSid;
PSID MailAdminsSid = &sMailAdminsSid;

//
// Principal self SID. When used in an ACE, the Authz access check replaces it
// by the passed in PrincipalSelfSid parameter during the access check. In this
// case, it is replaced by the owner's SID retrieved from the mailbox.
//

SID sPrincipalSelfSid =   { 
							SID_REVISION,
							1,
							SECURITY_NT_AUTHORITY,
							SECURITY_PRINCIPAL_SELF_RID
						  };

PSID PrincipalSelfSid = &sPrincipalSelfSid;

//
// A callback ACE can contain additional policy data after the regular ACE
// fields. This structure is appended to the end of every callback ACE used
// by the mail resource manager, enabling the access check algorithm to make
// policy-based access decisions, instead of the solely identity-based decisions
// used in standard ACE types. If the SID in a callback ACE matches the SID
// in the user's AuthZ context, verification is done whether this policy applies
// (verification done by the AccessCheck callback function in the MailRM class)
// Therefore, an ACE applies if and only if the ACE SID matches a SID in the 
// user's context AND the policy below applies
//

typedef struct
{
    //
    // Whether this ACE should apply to sensitive mailboxes
    // set to MAILRM_SENSITIVE if it shoult apply, 0 if not
	//
	
	BYTE bIsSensitive;

	//
	// Whether the Sensitive and Time conditions should be treated
	// with a logical AND or OR. If AND, both conditions have to be satisfied
	// for the ACE to apply. If OR, one or both conditions satisfied will
	// result in the ACE being applied
	//
	
	BYTE bLogicType;
	
	//
	// Start hour of time range to use (in the 24-hour format) to decide
	// whether the ACE should apply. Valid values are from 0 to 23. The
	// actual time must be within the defined time range for the time condition
	// to apply. In other words, bStartHour <= CurrentHour < EndHour
	//

	BYTE bStartHour;

	//
	// End hour of the time range
	//

	BYTE bEndHour;
} MAILRM_OPTIONAL_DATA, *PMAILRM_OPTIONAL_DATA;


//
// Flags used in the optional data structure for the callback ACEs
//


//
// If the sensitive field in the optional data is set with this, and the
// mailbox contains sensitive data, this condition applies
//

#define MAILRM_SENSITIVE 1

//
// Type of boolean logic to use on the time and sensitive conditions
// time applies AND sensitive applies
// time applies OR sensitive applies
//

#define MAILRM_USE_AND 0

#define MAILRM_USE_OR 1

//
// Default starting time for the callback ACEs: 11pm
//

#define MAILRM_DEFAULT_START_TIME 23

//
// Default end time for the callback ACEs: 5am
//

#define MAILRM_DEFAULT_END_TIME 5


//
// Macro to determine whether a time falls within a given time range
//

#define WITHIN_TIMERANGE(HOUR, START_HOUR, END_HOUR) \
	( ( (START_HOUR) > (END_HOUR) ) ^ \
	( (HOUR) >= min((START_HOUR), (END_HOUR)) && \
	  (HOUR) <  max((START_HOUR), (END_HOUR))))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\mailrm\mailrm.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mailrm.h

Abstract:

   The header file for the sample AuthZ resource manager for mailboxes

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/

#pragma once

#include "pch.h"

#include <string>
#include <map>

using namespace std;

//
// RM-specific access masks used in the ACEs inside the mail RM. 
// The lower 16 bits of the access mask are for user-specified rights
// such as these
//

//
// Access mask needed to read the contents of a mailbox
//

#define ACCESS_MAIL_READ     0x00000001

//
// Access mask needed to delete messages from a mailbox
//

#define ACCESS_MAIL_WRITE    0x00000002

//
// Access mask for Administrative access to a mailbox
//

#define ACCESS_MAIL_ADMIN    0x00000004

//
// The SIDs used in the RM, allocated elsewhere
//

extern PSID InsecureSid;
extern PSID BobSid;
extern PSID MarthaSid;
extern PSID JoeSid;
extern PSID JaneSid;
extern PSID MailAdminsSid;
extern PSID PrincipalSelfSid;


//
// Forward declarations
// 

class Mailbox;
class MailRM;

//
// Comparison for PSIDs which works with STL map and multimap
// These are needed to impose a total ordering on the SIDs by value
//

struct CompareSidStruct 
{
    bool operator()(const PSID pSid1, const PSID pSid2) const;
};

struct CompareSidPairStruct 
{
    bool operator()(const pair<PSID, DWORD > pair1, 
                    const pair<PSID, DWORD > pair2) const;
};


//
// Element of the multiple mailbox access request
//

typedef struct 
{
    //
    // Mailbox to access
    //

    PSID psMailbox;

    //
    // Access mask requested for mailbox
    //

    ACCESS_MASK amAccessRequested;

} MAILRM_MULTI_REQUEST_ELEM, *PMAILRM_MULTI_REQUEST_ELEM;


//
// Used for multiple mailbox access request
//

typedef struct 
{

    //
    // SID of the user getting access
    //

    PSID psUser;

    //
    // IP address of the user
    //

    DWORD dwIp;

    //
    // Number of MAILRM_MULTI_REQUEST_ELEM's
    //

    DWORD dwNumElems;

    //
    // Pointer to the first element
    //

    PMAILRM_MULTI_REQUEST_ELEM pRequestElem;

} MAILRM_MULTI_REQUEST, *PMAILRM_MULTI_REQUEST;


//
// Reply to a multiple mailbox access request is returned
// as an array of these. 
//

typedef struct 
{
    //
    // Pointer to mailbox, or NULL on failure
    //

    Mailbox * pMailbox;

    //
    // Granted access mask
    //

    ACCESS_MASK amAccessGranted;


} MAILRM_MULTI_REPLY, *PMAILRM_MULTI_REPLY;




class Mailbox
/*++
   
   Class:              Mailbox
   
   Description:        
        
        This class is the mailbox container for a user's mail. It contains the
        SID of the mailbox owner, and also keeps track of whether any sensitive
        information is contained in the mailbox.
 
   Base Classes:       none
 
   Friend Classes:     none
 
--*/
{

private:

    //
    // Whether the mailbox contains sensitive data
    //

    BOOL _bIsSensitive;

    //
    // Owner of the mailbox, for PRINCIPAL_SELF evaluation
    //

    PSID _pOwnerSid;

    //
    // All messages in the mailbox
    //

    wstring _MailboxData;

    //
    // Name of the mailbox/mail owner
    //

    wstring _MailboxOwner;

public:
    
    Mailbox(IN  PSID pOwnerSid,
            IN  BOOL bIsSensitive,
            IN  WCHAR *szOwner) 
        {   
            _bIsSensitive = bIsSensitive;
            _pOwnerSid = pOwnerSid;
            _MailboxOwner.append(szOwner); 
        }

    //
    // Accessors
    //

    BOOL IsSensitive() const 
        { return _bIsSensitive; }

    const PSID GetOwnerSid() const 
        { return _pOwnerSid; }

    const WCHAR * GetOwnerName() const 
        { return _MailboxOwner.c_str(); }

    const WCHAR * GetMail() const 
        { return _MailboxData.c_str(); }


public:

    //
    // Manipulate the stored mail
    //

    void SendMail(IN const WCHAR *szMessage,
                  IN BOOL bIsSensitive )
        { _MailboxData.append(szMessage); _bIsSensitive |= bIsSensitive; }

    void Flush() 
        { _MailboxData.erase(0, _MailboxData.length()); _bIsSensitive = FALSE; }
                                                                                       
};



class MailRM
/*++
   
   Class:              MailRM
   
   Description:        
        
        This class manages a set of mailboxes, granting access to the mailboxes
        based on a single internally stored security descriptor containing
        callback and regular ACEs. It also audits certain mailbox activity.
        
   Base Classes:       none
 
   Friend Classes:     none
 
--*/
{

private:

    //
    // Security descriptor common to all mailboxes
    //

    SECURITY_DESCRIPTOR _sd;
    

    //
    // Mapping of SIDs to mailboxes
    //

    //map<const PSID, Mailbox *, CompareSidStruct> _mapSidMailbox;
    map<const PSID, Mailbox *> _mapSidMailbox;
    //
    // AuthZ contexts should only be created once for a given SID,IP pair
    // This stores the contexts once they are created
    //

    map<pair<PSID, DWORD >,
        AUTHZ_CLIENT_CONTEXT_HANDLE,
        CompareSidPairStruct> _mapSidContext;

    //
    // Handle to the resource manager to be initialized with the callbacks
    //

    AUTHZ_RESOURCE_MANAGER_HANDLE _hRM;

public:

    //
    // Constructor, initializes resource manager
    //

    MailRM();
    
    //
    // Destructor, frees RM's memory
    //

    ~MailRM();


public:

    //
    // Attempts to access the mailbox as psUser from the given IP address, 
    // requesting amAccessRequested access mask. If access is granted and the
    // mailbox exists, the pointer to the mailbox is returned. 
    //

    Mailbox * GetMailboxAccess(
                            IN const PSID psMailbox,
                            IN const PSID psUser,
                            IN DWORD dwIncomingIp,
                            IN ACCESS_MASK amAccessRequested
                            );
    //
    // Attempt to access a set of mailboxes using a cached access check
    // pReply should be an allocated array with the same number of elements
    // as the request
    //

    BOOL GetMultipleMailboxAccess(
                            IN      const PMAILRM_MULTI_REQUEST pRequest,
                            IN OUT  PMAILRM_MULTI_REPLY pReply
                            );


    //
    // Adds a mailbox to be controlled by the RM
    //

    void AddMailbox(Mailbox * pMailbox);

private:

    //
    // Internal function to completely set up the security descriptor
    // Should only be called once per instance, by the contructor
    //

    void InitializeMailSecurityDescriptor();

    //
    // Resource manager callbacks
    // These must be static, since they are called as C functions.
    // Non-static member functions expect a this pointer as the first
    // argument on the stack, and therefore cannot be called as C 
    // functions. These callbacks do not depend on any instance-specific
    // data, and therefore can and should be static.
    //
            
    static BOOL CALLBACK AccessCheck(
                            IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
                            IN PACE_HEADER pAce,
                            IN PVOID pArgs OPTIONAL,
                            IN OUT PBOOL pbAceApplicable
                            );

    static BOOL CALLBACK ComputeDynamicGroups(
                            IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
                            IN PVOID Args,
                            OUT PSID_AND_ATTRIBUTES *pSidAttrArray,
                            OUT PDWORD pSidCount,
                            OUT PSID_AND_ATTRIBUTES *pRestrictedSidAttrArray,
                            OUT PDWORD pRestrictedSidCount
                            );

    static VOID CALLBACK FreeDynamicGroups (
                            IN PSID_AND_ATTRIBUTES pSidAttrArray
                            );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\mailrm\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <authz.h>


#define SECURITY_WIN32

//#include "sspi.h"
//#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\mailrm\main.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

   The test for the Mail resource manager

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#include "mailrm.h"
#include "main.h"


//
// The set of mailboxes to create
//

mailStruct pMailboxes[] =
{
    { BobSid, TRUE, L"Bob" },
    { MarthaSid, FALSE, L"Martha" },
    { JoeSid, FALSE, L"Joe" },
    { JaneSid, FALSE, L"Jane" },
    { MailAdminsSid, FALSE, L"Admin" },
    { NULL, FALSE, NULL }
};


//
// The set of single access attempts to run
//

testStruct pTests[] =
{
    { MailAdminsSid, BobSid, ACCESS_MAIL_READ, 0xC0000001 },
    { BobSid, BobSid, ACCESS_MAIL_READ, 0xD0000001 },
    { BobSid, BobSid, ACCESS_MAIL_WRITE, 0xD0000001 },
    { MarthaSid, BobSid, ACCESS_MAIL_READ, 0xC0000001 },
    { JaneSid, JaneSid, ACCESS_MAIL_READ, 0xC0000001 },
    { NULL, NULL, 0, 0 }
};



//
// The set of mailboxes to attempt to access for the multiple mailbox access
// check, and the access type to request
//

MAILRM_MULTI_REQUEST_ELEM pRequestElems[] = 
{
    { BobSid, ACCESS_MAIL_WRITE},
    { MarthaSid, ACCESS_MAIL_WRITE},
    { MarthaSid, ACCESS_MAIL_READ},
    { JaneSid, ACCESS_MAIL_WRITE}
};

//
// The rest of the information for the multiple access check
//

MAILRM_MULTI_REQUEST mRequest =
{
    MailAdminsSid, // Administrator performing the access
    0xC1000001, // Administrators coming from insecure 193.0.0.1
    4, // 4 mailboxes to access, as above
    pRequestElems // The list of mailboxes
};


void __cdecl wmain(int argc, char *argv[])
/*++

    Routine Description

        This runs a set of sample tests on the MailRM object.
        
        It first tries to enable the Audit privilege in the current process's
        token. If you would like to test auditing, make sure to run this with
        an account which has this privilege. Otherwise, the audits will be
        ignored (however, the rest of the example will still work).
        
        It then constructs the MailRM instance, and adds the set of managed
        mailboxes declared in main.h to the resource manager.
        
        Then it performs the set of access attempts listed in main.h on the
        resource manager.
        
        Finally, it attempts a multiple access check by administrators. The
        mailboxes accessed are listed above. Successfuly accessed mailboxes
        receive administrative notifications.
        

    Arguments
    
        None.
    
    Return Value
        None.                       
--*/        
{
    DWORD dwIdx;

    MailRM * pMRM;

    Mailbox * pMbx;

    //
    // Enable the Audit privilege in the process token
    // To disable audit generation, comment this out
    //
    
    try {
        GetAuditPrivilege();
    }
    catch(...)
    {
        wprintf(L"Error enabling Audit privilege, audits will not be logged\n");
    }

    //
    // Initialize the resource manager object
    //
    
    try {
        pMRM = new MailRM();
    }
    catch(...)
    {
        wprintf(L"Fatal exception while instantiating MailRM, exiting\n");
        exit(1);
    }
    


    //
    // Create mailboxes and register them with the resource manager
    //
    
    for( dwIdx = 0; pMailboxes[dwIdx].psUser != NULL; dwIdx++ )
    {
        pMRM->AddMailbox( new Mailbox(pMailboxes[dwIdx].psUser,
                                      pMailboxes[dwIdx].bIsSensitive,
                                      pMailboxes[dwIdx].szName) );

    }



    //
    // Run the access checks
    //

    wprintf(L"\n\nIndividual access checks\n");
    
    try {
		for( dwIdx =0; pTests[dwIdx].psUser != NULL; dwIdx++ )
		{
			pMbx = pMRM->GetMailboxAccess(pTests[dwIdx].psMailbox,
										  pTests[dwIdx].psUser,
										  pTests[dwIdx].dwIP,
										  pTests[dwIdx].amAccess);
			if( pMbx != NULL )
			{
				wprintf(L"Granted: ");
			}
			else
			{
				wprintf(L"Denied: ");
			}
	
			PrintTest(pTests[dwIdx]);
		}
	}
	catch(...)
	{
		wprintf(L"Failed on individual access checks\n");
	}

    //
    // Now perform the access check using the GetMultipleAccess, which
    // uses a cached access check internally.
    // For every mailbox successfuly opened for write,
    // we send an administrative note.
    //

    wprintf(L"\n\nMultiple cached access checks\n");

	PMAILRM_MULTI_REPLY pReply = new MAILRM_MULTI_REPLY[mRequest.dwNumElems];

	if( pReply == NULL )
	{
		wprintf(L"Out of memory, exiting\n");
		exit(1);
	}
    
	try {
		if( FALSE == pMRM->GetMultipleMailboxAccess(&mRequest, pReply) )
		{
			wprintf(L"Failed on multiple access check\n");
		}
		else
		{
	
			for( dwIdx = 0; dwIdx < mRequest.dwNumElems; dwIdx++ )
			{
	
				if(     pReply[dwIdx].pMailbox != NULL 
                    &&  (   mRequest.pRequestElem[dwIdx].amAccessRequested 
                          & ACCESS_MAIL_WRITE ) )
				{
					pReply[dwIdx].pMailbox->SendMail(
								L"Note: Mail server will be down for 1 hour\n\n",
								FALSE
								);
	
					wprintf(L"Granted: ");
				}
				else
				{
					wprintf(L"Denied: ");
				}
	
				PrintMultiTest(&mRequest, pReply, dwIdx);
	
			}
		}
	}
	catch(...)
	{
		wprintf(L"Multiple access check failed, exiting\n");
		exit(1);
	}


	//
	// Clean up
	//

	//
	// This also deletes all managed mailboxes
	//

    delete pMRM;                                                            

    delete[] pReply;

}

void GetAuditPrivilege()
/*++

    Routine Description

        This attempts to enable the AUDIT privilege in the current process's
        token, which will allow the process to generate audits.
        
        Failure to enable the privilege is ignored. Audits will simply not
        be generated, but the rest of the example will not be effected.
        
        The privilege is enabled for the duration of this process, since
        the process's token is modified, not the user's token. Therefore,
        there is no need to set the privileges back to their initial state.
        
        If this were a part of a larger system, it would be a good idea
        to only enable the Audit privilege when needed, and restore the
        original privileges afterwards. This can be done by passing
        a previous state parameter to AdjustTokenPrivileges, which 
        would save the original state (to be restored later).

    Arguments
    
        None.
    
    Return Value
        None.                       
--*/        
{
    HANDLE hProcess;
    HANDLE hToken;

    //
    // First, we get a handle to the process we are running in, requesting
    // the right to read process information
    //

    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION,
                           FALSE,
                           GetCurrentProcessId()
                           );
    
    if( hProcess == NULL )
    {
        throw (DWORD)ERROR_INTERNAL_ERROR ;
    }

    //
    // We need to be able to read the current privileges and set new privileges,
    // as required by AdjustTokenPrivileges
    //

    OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken);

    if( hProcess == NULL )
    {
        CloseHandle(hProcess);
        throw (DWORD)ERROR_INTERNAL_ERROR;
    }

    //
    // We have the token handle, no need for the process anymore
    //

    CloseHandle(hProcess);
    
    LUID lPrivAudit;
    
    LookupPrivilegeValue(NULL, SE_AUDIT_NAME, &lPrivAudit);
    
    // 
    // Only 1 privilege to enable
    //

    TOKEN_PRIVILEGES NewPrivileges;
    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    NewPrivileges.Privileges[0].Luid = lPrivAudit;

    //
    // Now adjust the privileges in the process token
    //

    AdjustTokenPrivileges(hToken, FALSE, &NewPrivileges, 0, NULL, NULL);

    //
    // And we're done with the token handle
    //

    CloseHandle(hToken);

}
        


//
// Functions to print the test output
//

void PrintUser(const PSID psUser)
{
    DWORD i;

    for(i=0; pMailboxes[i].psUser != NULL; i++)
    {
        if(EqualSid(psUser, pMailboxes[i].psUser))
        {
            wprintf(pMailboxes[i].szName);         
            return;
        }
    }
    wprintf(L"UnknownUser");
}

void PrintPerm(ACCESS_MASK am)
{
    wprintf(L" (");

    if( am & ACCESS_MAIL_READ ) wprintf(L" Read");
    if( am & ACCESS_MAIL_WRITE ) wprintf(L" Write");
    if( am & ACCESS_MAIL_ADMIN ) wprintf(L" Admin");

    wprintf(L" ) ");
}

void PrintTest(testStruct tst)
{
    wprintf(L"[ User: ");
    PrintUser(tst.psUser);
    wprintf(L", Mailbox: ");
    PrintUser(tst.psMailbox);
    PrintPerm(tst.amAccess);

    wprintf(L"IP: %d.%d.%d.%d ]\n", (tst.dwIP >> 24) & 0x000000FF,
                                  (tst.dwIP >> 16) & 0x000000FF,
                                  (tst.dwIP >> 8)  & 0x000000FF,
                                   tst.dwIP        & 0x000000FF );

}

void PrintMultiTest(PMAILRM_MULTI_REQUEST pRequest,
               PMAILRM_MULTI_REPLY pReply,
               DWORD dwIdx)
{
    wprintf(L"[ User: ");
    PrintUser(pRequest->psUser);
    wprintf(L", Mailbox: ");
    PrintUser(pRequest->pRequestElem[dwIdx].psMailbox);
    PrintPerm(pRequest->pRequestElem[dwIdx].amAccessRequested);

    wprintf(L"IP: %d.%d.%d.%d ]\n",   (pRequest->dwIp >> 24) & 0x000000FF,
                                      (pRequest->dwIp >> 16) & 0x000000FF,
                                      (pRequest->dwIp >> 8)  & 0x000000FF,
                                       pRequest->dwIp        & 0x000000FF );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\makesd\main.c ===
#include "pch.h"
#include "makesd.h"

#include <stdio.h>

#define MAILRM_IDENTIFIER_AUTHORITY { 0, 0, 0, 0, 0, 42 }

SID sInsecureSid = 		 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 1 };
SID sBobSid = 			 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 2 };
SID sMarthaSid= 		 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 3 };
SID sJoeSid = 			 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 4 };
SID sJaneSid = 			 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 5 };
SID sMailAdminsSid = 	 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 6 };

PSID InsecureSid = 	&sInsecureSid;
PSID BobSid = &sBobSid;
PSID MarthaSid= &sMarthaSid;
PSID JoeSid = &sJoeSid;
PSID JaneSid = &sJaneSid;
PSID MailAdminsSid = &sMailAdminsSid;

//
// Principal self SID. When used in an ACE, the Authz access check replaces it
// by the passed in PrincipalSelfSid parameter during the access check. In this
// case, it is replaced by the owner's SID retrieved from the mailbox.
//

SID sPrincipalSelfSid =   { 
							SID_REVISION,
							1,
							SECURITY_NT_AUTHORITY,
							SECURITY_PRINCIPAL_SELF_RID
						  };

SID sNetworkSid =   { 
							SID_REVISION,
							1,
							SECURITY_NT_AUTHORITY,
							SECURITY_NETWORK_RID
						  };

SID sAuthenticatedSid =   { 
							SID_REVISION,
							1,
							SECURITY_NT_AUTHORITY,
							SECURITY_AUTHENTICATED_USER_RID,
						  };

SID sDialupSid =   { 
							SID_REVISION,
							1,
							SECURITY_NT_AUTHORITY,
							SECURITY_DIALUP_RID,
						  };

PSID PrincipalSelfSid = &sPrincipalSelfSid;
PSID NetworkSid = &sNetworkSid;
PSID AuthenticatedSid = &sAuthenticatedSid;
PSID DialupSid = &sDialupSid;



void __cdecl wmain(int argc, WCHAR *argv[])
{
    
    PSECURITY_DESCRIPTOR pSd;

    BOOL bSuccess;

    if( argc != 2 )
    {
        printf("Error: makesd <filename>\n");
    }

    bSuccess = CreateSecurityDescriptor2(
                        &pSd, // SD
                        0, // SD Control
                        PrincipalSelfSid, // owner
                        NULL, // group
                        TRUE, // DACL present
                        3, // 3 DACL ACEs
                        FALSE, // SACL not present
                        0, // 0 SACL ACEs
                        
                        // Var argl list
                        ACCESS_DENIED_ACE_TYPE,
                        OBJECT_INHERIT_ACE,
                        DialupSid,
                        FILE_GENERIC_READ,

                        ACCESS_ALLOWED_ACE_TYPE,
                        OBJECT_INHERIT_ACE,
                        AuthenticatedSid,
                        FILE_GENERIC_READ,

                        ACCESS_ALLOWED_CALLBACK_ACE_TYPE,
                        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                        PrincipalSelfSid,
                        FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE,
                        0,
                        NULL
                        
                        );

    if( !bSuccess )
    {
        printf("Error: %u\n", GetLastError());
        exit(0);
    }

    bSuccess = IsValidSecurityDescriptor(pSd);

    if( !bSuccess )
    {
        printf("Error: Invalid security descriptor\n");
        exit(0);
    }


    bSuccess = SetFileSecurity(
                    argv[1], 
                    DACL_SECURITY_INFORMATION,
                    pSd);

    if( !bSuccess )
    {
        printf("Error setting sec: %u\n", GetLastError());
        exit(0);
    }

    FreeSecurityDescriptor2(pSd);
    printf("Success\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\mailrm\main.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.h

Abstract:

   The header file for the sample AuthZ mail resource manager test

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/



//
// This structure defines an access attempt by psUser to access the mailbox of
// the user psMailbox with amAccess access mask. psUser is coming in from dwIP
// IP address
//

typedef struct
{
    PSID psUser;
    PSID psMailbox;
    ACCESS_MASK amAccess;
    DWORD dwIP;
} testStruct;


//
// This structure defines a mailbox to create, owned by psUser (with name szName
// which is used for auditing). If bIsSensitive is true, the mailbox initially
// is marked as containing sensitive data
//

typedef struct
{
    PSID psUser;
    BOOL bIsSensitive;
    WCHAR * szName;   
} mailStruct;


//
// Forward declarations for functions in main.cpp
//

void PrintUser(const PSID psUser);
void PrintPerm(ACCESS_MASK am);
void PrintTest(testStruct tst);
void GetAuditPrivilege();
void PrintMultiTest(PMAILRM_MULTI_REQUEST pRequest,
                    PMAILRM_MULTI_REPLY pReply,
                    DWORD dwIdx);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\qt\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <sddl.h>
#include <seopaque.h>
#include <sertlp.h>
#include <authz.h>
#include <authzi.h>

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\qt\main.c ===
#include "pch.h"

AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET;
UCHAR                Buffer[2048];
AUTHZ_ACCESS_REQUEST Request       = {0};
PAUTHZ_ACCESS_REPLY  pReply        = (PAUTHZ_ACCESS_REPLY) Buffer;
BOOL                 b             = TRUE;
HANDLE               hToken        = NULL;
LUID                 Luid          = {0xdead,0xbeef};
NTSTATUS             Status        = STATUS_SUCCESS;
PAUDIT_PARAMS        pParams = NULL;

PHANDLE     pThreads           = NULL;
ACCESS_MASK DesiredAccess      = 0;
DWORD       dwThreads          = 0;
DWORD       dwThreadsRemaining = 0;
DWORD       dwAuditsPerThread  = 0;
BOOL        bAudit             = 0;
DWORD       i                  = 0;

PSECURITY_DESCRIPTOR pSD      = NULL;
PWCHAR               StringSD = L"O:BAG:DUD:(A;;0x40;;;s-1-2-2)(A;;0x1;;;BA)(OA;;0x2;6da8a4ff-0e52-11d0-a286-00aa00304900;;BA)(OA;;0x4;6da8a4ff-0e52-11d0-a286-00aa00304901;;BA)(OA;;0x8;6da8a4ff-0e52-11d0-a286-00aa00304903;;AU)(OA;;0x10;6da8a4ff-0e52-11d0-a286-00aa00304904;;BU)(OA;;0x20;6da8a4ff-0e52-11d0-a286-00aa00304905;;AU)(A;;0x40;;;PS)S:(AU;IDSAFA;0xFFFFFF;;;WD)";

AUTHZ_AUDIT_EVENT_HANDLE       hAuditEvent1  = NULL;
AUTHZ_AUDIT_EVENT_HANDLE       hAuditEvent2  = NULL;
AUTHZ_RESOURCE_MANAGER_HANDLE  hRM          = NULL;
AUTHZ_CLIENT_CONTEXT_HANDLE    hCC          = NULL;
AUTHZ_ACCESS_CHECK_RESULTS_HANDLE hAuthzCache  = NULL;
AUTHZ_AUDIT_QUEUE_HANDLE       hAAQ         = NULL;    


ULONG                      
AccessCheckAuditWork(
    LPVOID lpParameter
    )
{
    
    DWORD i   = 0;
    DWORD num = *((PDWORD)lpParameter);

    for (i = 0; i < dwAuditsPerThread; i++)
    {
        b = AuthzAccessCheck(
                0,
                hCC,
                &Request,
                hAuditEvent2,
                pSD,
                NULL,
                0,
                pReply,
                NULL
                );

        b = AuthzAccessCheck(
                0,
                hCC,
                &Request,
                hAuditEvent1,
                pSD,
                NULL,
                0,
                pReply,
                NULL
                );

    }

    InterlockedDecrement( 
        &dwThreadsRemaining
        );

    wprintf(L"Thread Done %d (%d left).\n", num, dwThreadsRemaining);
    return TRUE;
}


void _cdecl wmain(int argc, WCHAR * argv[])
{
    if (argc != 5)
    {
        wprintf(L"usage: %s AccessMask dwThreads dwAuditsPerThread bAudit\n", argv[0]);
        exit(0);
    }

    DesiredAccess      = wcstol(argv[1], NULL, 16);
    dwThreads          = wcstol(argv[2], NULL, 10);
    dwAuditsPerThread  = wcstol(argv[3], NULL, 10);
    bAudit             = wcstol(argv[4], NULL, 10);

    dwThreadsRemaining = dwThreads;

    pThreads = LocalAlloc(
                   0, 
                   sizeof(HANDLE) * dwThreads
                   );

    if (NULL == pThreads)
    {
        wprintf(L"LocalAlloc failed with %d\n", GetLastError());
        return;
    }

    //
    // Create the SD for the access checks
    //

    b = ConvertStringSecurityDescriptorToSecurityDescriptorW(
            StringSD, 
            SDDL_REVISION_1, 
            &pSD, 
            NULL
            );

    if (!b)
    {
        wprintf(L"SDDL failed with %d\n", GetLastError());
        return;
    }



    //
    // Authz stuff
    //

    b = AuthzInitializeResourceManager(
            0,
            NULL,
            NULL,
            NULL,
            L"Jeff's RM",
            &hRM
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeResourceManager failed with %d\n", GetLastError());
        return;
    }
    
    b = AuthziInitializeAuditQueue(
            AUTHZ_MONITOR_AUDIT_QUEUE_SIZE,
            10000,
            500,
            NULL,
            &hAAQ
            );

    if (!b)
    {
        printf("AuthzInitializeAuditQueue failed with %d.\n", GetLastError());
        return;
    }

    b = AuthziInitializeAuditEventType(
            0,
            SE_CATEGID_OBJECT_ACCESS,
            777,
            1,
            &hAET
            );

    if (!b)
    {
        wprintf(L"initaet returned %d\n", GetLastError());
        return;
    }

    b = AuthziAllocateAuditParams(
            &pParams,
            1
            );

    AuthziInitializeAuditParamsWithRM(
        0,
        hRM,
        1,
        pParams,
        APT_String, L"Hello???"
        );

    b = AuthziInitializeAuditEvent(
            AUTHZ_NO_ALLOC_STRINGS,
            hRM,
            hAET, //NULL,     // event
            pParams, //NULL,     // params
            hAAQ,     // queue
            INFINITE, // timeout
            L"op type",
            L"object type",
            L"object name",
            L"some additional info",
            &hAuditEvent2
            );

    b = AuthziInitializeAuditEvent(
            0,
            hRM,
            NULL,     // event
            NULL,     // params
            NULL,     // queue
            INFINITE, // timeout
            L"op type1",
            L"object type1",
            L"object name1",
            L"some additional info1",
            &hAuditEvent1
            );
    if (!b)
    {
        printf("AuthzInitializeAuditInfo failed with %d.\n", GetLastError());
        return;
    }

    //
    // Create a client context from the current token.
    //

    OpenProcessToken( 
        GetCurrentProcess(), 
        TOKEN_QUERY, 
        &hToken
        );

    b = AuthzInitializeContextFromToken(
            0,
            hToken,
            hRM,
            NULL,
            Luid,
            NULL,
            &hCC
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeContextFromToken failed with 0x%x\n", GetLastError());
        return;
    }            

    //
    // Now do the access check.
    //

    Request.ObjectTypeList = NULL;
    Request.PrincipalSelfSid = NULL;
    Request.DesiredAccess = DesiredAccess;

    pReply->ResultListLength = 1;
    pReply->Error = (PDWORD) (((PCHAR) pReply) + sizeof(AUTHZ_ACCESS_REPLY));
    pReply->GrantedAccessMask = (PACCESS_MASK) (pReply->Error + pReply->ResultListLength);
    pReply->SaclEvaluationResults = (PDWORD) (pReply->GrantedAccessMask + (pReply->ResultListLength * sizeof(ACCESS_MASK)));

    wprintf(L"* AccessCheck (PrincipalSelfSid == NULL, ResultListLength == 8)\n");
    
    b = AuthzAccessCheck(
            0,
            hCC,
            &Request,
            NULL,
            pSD,
            NULL,
            0,
            pReply,
            &hAuthzCache
            );

    if (!b)
    {
        wprintf(L"Initial AuthzAccessCheck failed with %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"Initial AuthzAccessCheck succeeded.  Here are results:\n");

        for (i = 0; i < pReply->ResultListLength; i++)
        {
            wprintf(L"ObjectType %d :: AccessMask = 0x%x, Error = %d\n",
                    i, pReply->GrantedAccessMask[i], pReply->Error[i]);
        }
    }

    wprintf(L"\nBeginning creation of audit threads.\n");

    for (i = 0; i < dwThreads; i++)
    {
        pThreads[i] = CreateThread(
                          NULL,
                          0,
                          AccessCheckAuditWork,
                          &i,
                          CREATE_SUSPENDED,
                          NULL
                          );
        
        if (pThreads[i] == NULL)
        {
            wprintf(L"CreateThread failed for thread %d with %d\n", i, GetLastError());
            return;
        }
    }

    for (i = 0; i < dwThreads; i++)
    {
        if (-1 == ResumeThread(
                      pThreads[i]
                      ))
        {
            wprintf(L"ResumeThread failed on thread %d with %d\n", i, GetLastError());
            fflush(stdout);
        }
    }

    Status = WaitForMultipleObjects(
                i, 
                pThreads, 
                TRUE, 
                INFINITE
                );

    if (!NT_SUCCESS(Status))
    {
        wprintf(L"Wait failed %d.\n", GetLastError());
    }

    wprintf(L"Done waiting for all threads.\n");
    
    AuthzFreeAuditEvent(
        hAuditEvent2
        );

    AuthziFreeAuditQueue(hAAQ);

    AuthzFreeContext(hCC);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\makesd\makesd.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    createsd.c

Abstract:

   Variable argument list function for creating a security descriptor
   
Author:

    t-eugenz - September 2000

Environment:

    User mode only.

Revision History:

    Created                 - September 2000

--*/

#include "pch.h"
#include "makesd.h"

#include <stdarg.h>
#include <stdio.h>

//
// ISSUE: Which public header is this in?
//

#define MAX_WORD 0xFFFF

#define FLAG_ON(flags,bit)        ((flags) & (bit))

void FreeSecurityDescriptor2(
                          IN            PSECURITY_DESCRIPTOR pSd
                          )
/*++

Routine Description:

    This frees a security descriptor created by CreateSecurityDescriptor    
    
Arguments:

    pSd             -   The pointer to the security descriptor to be freed
    
Return Value:

    none
    
--*/
{
    ASSERT( pSd != NULL );
    free(pSd);
}


#define F_IS_DACL_ACE           0x00000001
#define F_IS_CALLBACK           0x00000002
#define F_IS_OBJECT             0x00000004
#define F_RETURN_ALL_DATA       0x00000010

typedef struct
{
    DWORD           dwFlags;
    ACE_HEADER      pAce;
    ACCESS_MASK     amMask;
    PSID            pSid;
    DWORD           dwOptDataSize;
    PVOID           pvOptData;
    GUID *          pgObject;
    GUID *          pgInherit;
} ACE_REQUEST_STRUCT, *PACE_REQUEST_STRUCT;



BOOL GetNextAceInfo( IN OUT     va_list             *varArgList,
                     IN OUT     PACE_REQUEST_STRUCT pAceRequest
                     )
{

    DWORD dwAceSize = 0;
    BYTE bAceType = 0;
    BYTE bAceFlags = 0;
    DWORD amAccessMask = 0;
    PSID pSid = NULL;
    GUID * pgObject = NULL;
    GUID * pgInherit = NULL;
    DWORD dwOptDataSize = 0;
    PVOID pvOptData = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwMask = 0;
    DWORD dwFlags = 0;


    //
    // Read the first arg to determine the ACE type, 
    //

    bAceType = va_arg(*varArgList, BYTE);

    //
    // Different sets for DACL and SACL
    //

    if( pAceRequest->dwFlags & F_IS_DACL_ACE )
    {
        //
        // Calculate the size of the DACL ACE
        //

        switch( bAceType )
        {
        
        case ACCESS_ALLOWED_ACE_TYPE:

            dwAceSize += (
                             sizeof(ACCESS_ALLOWED_ACE) 
                           - sizeof(DWORD) 
                         );

            break;

        case ACCESS_DENIED_ACE_TYPE:

            dwAceSize += (
                             sizeof(ACCESS_DENIED_ACE) 
                           - sizeof(DWORD) 
                         );

            break;

        case ACCESS_ALLOWED_CALLBACK_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(ACCESS_ALLOWED_CALLBACK_ACE) 
                           - sizeof(DWORD)
                          );

            dwFlags |= F_IS_CALLBACK;

            break;

        case ACCESS_DENIED_CALLBACK_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(ACCESS_DENIED_CALLBACK_ACE) 
                           - sizeof(DWORD)
                          );

            dwFlags |= F_IS_CALLBACK;
            
            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(ACCESS_ALLOWED_OBJECT_ACE) 
                           - sizeof(DWORD)
                           - 2 * sizeof(GUID)
                          );

            dwFlags |= F_IS_OBJECT;
            
            break;

        case ACCESS_DENIED_OBJECT_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(ACCESS_DENIED_OBJECT_ACE) 
                           - sizeof(DWORD)
                           - 2 * sizeof(GUID)
                          );

            dwFlags |= F_IS_OBJECT;
            
            break;

        case ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(ACCESS_ALLOWED_CALLBACK_OBJECT_ACE) 
                           - sizeof(DWORD)
                           - 2 * sizeof(GUID)
                          );

            dwFlags |= F_IS_OBJECT;
            dwFlags |= F_IS_CALLBACK;
            
            break;

        case ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(ACCESS_DENIED_CALLBACK_OBJECT_ACE) 
                           - sizeof(DWORD)
                           - 2 * sizeof(GUID)
                          );

            dwFlags |= F_IS_OBJECT;
            dwFlags |= F_IS_CALLBACK;
            
            break;

        default:

            dwErr = ERROR_INVALID_PARAMETER;

            goto error;
        }

    }
    else
    {

        switch( bAceType )
        {
        case SYSTEM_AUDIT_ACE_TYPE:

            dwAceSize += (
                             sizeof(SYSTEM_AUDIT_ACE) 
                           - sizeof(DWORD) 
                         );

            break;

        case SYSTEM_AUDIT_CALLBACK_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(SYSTEM_AUDIT_CALLBACK_ACE) 
                           - sizeof(DWORD)
                          );

            dwFlags |= F_IS_CALLBACK;
            
            break;


        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(SYSTEM_AUDIT_OBJECT_ACE) 
                           - sizeof(DWORD)
                           - 2 * sizeof(GUID)
                          );

            dwFlags |= F_IS_OBJECT;
            
            break;

        case SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(SYSTEM_AUDIT_CALLBACK_OBJECT_ACE) 
                           - sizeof(DWORD)
                           - 2 * sizeof(GUID)
                          );

            dwFlags |= F_IS_OBJECT;
            dwFlags |= F_IS_CALLBACK;
            
            break;

        default:

            dwErr = ERROR_INVALID_PARAMETER;

            goto error;
        }
    }

    //
    // Now we know the arguments contained
    //

    //
    // The flags
    //

    bAceFlags = va_arg(*varArgList, BYTE);
    
    //
    // The SID
    //

    pSid = va_arg(*varArgList, PSID);
    
    dwAceSize += GetLengthSid( pSid );

    //
    // Access mask
    //

    amAccessMask = va_arg(*varArgList, ACCESS_MASK);

    //
    // If callback, next two arguments are optional data size and data
    //

    if( dwFlags & F_IS_CALLBACK )
    {
        dwOptDataSize = va_arg(*varArgList, DWORD);

        pvOptData = va_arg(*varArgList, PVOID);

        dwAceSize += dwOptDataSize;
    }

    //
    // May contain GUIDs if object ACE
    //

    if( dwFlags & F_IS_OBJECT )
    {
        //
        // Up to 2 GUIDs if both are not NULL
        //

        pgObject = va_arg(*varArgList, GUID *);

        pgInherit = va_arg(*varArgList, GUID *);

        if( pgObject != NULL )
        {
            dwAceSize += sizeof(GUID);
        }

        if( pgInherit != NULL )
        {
            dwAceSize += sizeof(GUID);
        }
    }

    //
    // Finally, verify the ACE is within max size
    //

    if( dwAceSize > MAX_WORD )
    { 
        dwErr = ERROR_INVALID_PARAMETER;
    }


    error:;
    

    if( dwErr != ERROR_SUCCESS )
    {
        SetLastError(dwErr);
        
        return 0;
    }
    else
    {
        //
        // Fill in the requested return values
        //

        if( pAceRequest->dwFlags & F_RETURN_ALL_DATA )
        {
            pAceRequest->dwFlags = dwFlags;
            pAceRequest->pAce.AceFlags = bAceFlags;
            pAceRequest->pAce.AceSize = (WORD)dwAceSize;
            pAceRequest->pAce.AceType = bAceType;
            pAceRequest->amMask = amAccessMask;
            pAceRequest->pSid = pSid;
            
            if( dwFlags & F_IS_CALLBACK )
            {
                pAceRequest->dwOptDataSize = dwOptDataSize;
                pAceRequest->pvOptData = pvOptData;
            }

            if( dwFlags & F_IS_OBJECT )
            {
                pAceRequest->pgObject = pgObject;
                pAceRequest->pgInherit = pgInherit;
            }

        }

        return dwAceSize;
    }
}


BOOL 
WINAPI
CreateSecurityDescriptor2(
         OUT           PSECURITY_DESCRIPTOR * ppSd,
         IN    const   DWORD dwOptions,
         IN    const   SECURITY_DESCRIPTOR_CONTROL sControl,
         IN    const   PSID  psOwner,
         IN    const   PSID  psGroup,
         IN    const   DWORD dwNumDaclAces,
         IN    const   DWORD dwNumSaclAces,
         ...
         )
/*++

Routine Description:

    Creates a security descriptor with a DACL and a SACL using a variable
    argument list as input. Following the above fixed arguments, the ACEs
    should be specified by using 4 arguments for any ACE, with 2 additional
    arguments if the ACE is a callback, and 2 more arguments if it's an
    object ACE.
    
    Any number of ACEs can be specified. First, dwNumDaclAces
    ACEs will be read into the DACL for the security descriptor, then
    dwNumSaclAces will be read into the SACL.
    
    ACCESS_ALLOWED_ACE, ACCESS_DENIED_ACE: 4 arguments in this sequence
    
        BYTE bAceType           -   The ACE type
        
        BYTE bAceFlags          -   The ACE flags
        
        PSID pSid               -   The SID for the ACE
        
        ACCESS_MASK amMask      -   The access mask for the ACE
    
    Callback ACEs have the above 4 arguments, and 2 additional arguments
    which immediately follow the above:
    
        DWORD dwOptDataSize     -   The size (in bytes) of the optional
                                    data to be appended to the end of the ACE

        PVOID pvOptData         -   Pointer to the optional data
        
    Object ACEs have the appropriate arguments from above, and 2 additional 
    arguments:
        
        GUID * pgObjectType     -   Pointer to the object guid, or NULL for none
        
        GUID * pgInheritType    -   Pointer to the inheritance guid, or NULL
                                    for none
    
        
    ISSUE: Should ACE flags be verified? SIDs?
           Should ACL size be verified, since max ACL size is a SHORT?
    
    
Arguments:

    ppSd            -   The pointer to the allocated security descriptor is 
                        stored here, and should be freed using 
                        FreeSecurityDescriptor()
                        
    sControl        -   Only allowed bits are 
                        SE_DACL_AUTO_INHERITED 
                        SE_SACL_AUTO_INHERITED                        
                        SE_SACL_PROTECTED
                    
    psOwner         -   SID of the owner for the security descriptor
    
    psGroup         -   SID of the group for the security descriptor
    
    bDaclPresent    -   Whether the DACL should be non-NULL
                        If this is FALSE, no ACEs should be passed in the
                        variable args section for the DACL.
    
    dwNumDaclAces   -   Number of ACEs in the variable arguments for the DACL
    
    bSaclPresent    -   Whether the SACL should be non-NULL
                        If this is FALSE, no ACEs should be passed in the
                        variable args section for the SACL.
    
    dwNumSaclAces   -   Number of ACEs in the variable arguments for the SACL
    
    ...             -   The rest of the arguments for the ACEs, variable list
    
Return Value:

    TRUE on success
    FALSE on failure, more information available with GetLastError()
        
--*/
{

    DWORD dwIdx = 0;
    DWORD dwTmp = 0;
    DWORD dwTempFlags = 0;

    //
    // Size of the security descriptor and ACLs
    //

    DWORD dwSizeSd = 0;
    DWORD dwDaclSize = 0;
    DWORD dwSaclSize = 0;

    //
    // Start of the security descriptor, must be a pointer
    // to a type with sizeof(type) = 1, such as BYTE, so that
    // adding a size offset will work.
    //

    PBYTE pSd = NULL;

    //
    // Current offset in the security descriptor, incremented while filling
    // in the security descriptor
    //

    DWORD dwCurOffset = 0;

    //
    // Temporary ACL header
    //

    ACL aclTemp;

    //
    // Output for the GetNextAceInfo
    //

    ACE_REQUEST_STRUCT AceRequest;

    //
    // Variable argument list
    //

    va_list varArgList;

    BOOL bArglistStarted = FALSE;

    DWORD dwErr = ERROR_SUCCESS;

    
    //
    // Verify the arguments we can verify
    //

    if(     ( ppSd == NULL )
        ||  ( sControl & ~(  SE_DACL_AUTO_INHERITED 
                           | SE_SACL_AUTO_INHERITED
                           | SE_SACL_PROTECTED ) )
        ||  ( !FLAG_ON( dwOptions, CREATE_SD_DACL_PRESENT) && (dwNumDaclAces != 0))
        ||  ( !FLAG_ON( dwOptions, CREATE_SD_SACL_PRESENT) && (dwNumSaclAces != 0))
        ||  ( dwNumDaclAces > MAX_WORD )
        ||  ( dwNumSaclAces > MAX_WORD )                )
       
            
    {
        dwErr = ERROR_INVALID_PARAMETER;

        goto error;
    }

    //
    // First, we need to calculate the size of the security descriptor and the
    // ACLs, if any
    //

    pSd = NULL;

    dwSizeSd = sizeof(SECURITY_DESCRIPTOR);

    dwDaclSize = 0;

    dwSaclSize = 0;

    if( psOwner != NULL )
    {
        dwSizeSd += GetLengthSid(psOwner);
    }
    
    if( psGroup != NULL )
    {
        dwSizeSd += GetLengthSid(psGroup);
    }
    
    //
    // Start the variable args with the last non-varibale arg
    //

    va_start(varArgList, dwNumSaclAces);

    bArglistStarted = TRUE;


    //
    // Calculate the sizes of the DACL ACEs and the DACL itself
    //

    if ( FLAG_ON( dwOptions, CREATE_SD_DACL_PRESENT ))
    {

        dwDaclSize += sizeof(ACL);

        //
        // Now add all the ACEs (including SIDs)
        //

        for( dwIdx = 0; dwIdx < dwNumDaclAces; dwIdx++ )
        {
            //
            // Request next DACL ACE type, no additional data
            //

            AceRequest.dwFlags = F_IS_DACL_ACE;

            dwTmp = GetNextAceInfo( &varArgList, &AceRequest );

            if( dwTmp == 0 )
            {
                dwErr = ERROR_INVALID_PARAMETER;

                goto error;
            }
            else
            {
                dwDaclSize += dwTmp;
            }
        }

    }


    //
    // Calculate the sizes of the SACL ACEs and the SACL itself
    //

    if ( FLAG_ON( dwOptions, CREATE_SD_SACL_PRESENT ))
    {
        dwSaclSize += sizeof(ACL);

        //
        // Now add all the ACEs (including SIDs)
        //

        for( dwIdx = 0; dwIdx < dwNumSaclAces; dwIdx++ )
        {
            //
            // Request next SACL ACE type, no additional data
            //

            AceRequest.dwFlags = 0;

            dwTmp = GetNextAceInfo( &varArgList, &AceRequest );

            if( dwTmp == 0 )
            {
                dwErr = ERROR_INVALID_PARAMETER;

                goto error;
            }
            else
            {
                dwSaclSize += dwTmp;
            }
        }

    }

    //
    // Done with first pass through argument list
    //

    va_end(varArgList);

    bArglistStarted = FALSE;

    //
    // Verify that the ACLs will fit in the size limits (since ACL size
    // is a WORD)
    //

    if(    ( dwDaclSize > MAX_WORD )
        || ( dwSaclSize > MAX_WORD )   )
    {
        dwErr = ERROR_INVALID_PARAMETER;

        goto error;
    }

    //
    // At this point we know the size of the security descriptor,
    // which is the sum of dwSizeSd, dwDaclSize, and dwSaclSize.
    // Therefore, we can allocate the memory and determine the offsets of
    // the two ACLs in the security descriptor, which will be self-relative.
    //

    pSd = malloc( dwSizeSd + dwDaclSize + dwSaclSize );

    if( pSd == NULL )
    {
        *ppSd = NULL;

        SetLastError(ERROR_OUTOFMEMORY);

        return FALSE;
    }


    //
    // Everything resides in the same memory block, so we can simply walk the
    // memory block and fill it in. We start just past the end of the
    // fixed size security descriptor structure. As we copy things into this
    // memory blocks, we also initialize the matching offsets in the 
    // SECURITY_DESCRIPTOR (which is at the head of the block)
    //

    //
    // Revision
    //

    ((SECURITY_DESCRIPTOR *)pSd)->Revision = SECURITY_DESCRIPTOR_REVISION;

    //
    // Padding
    //

    ((SECURITY_DESCRIPTOR *)pSd)->Sbz1 = 0;

    //
    // SECURITY_DESCRIPTOR_CONTROL should reflect the fact that it is
    // self-relative. DACL and SACL are always present and not defaulted,
    // thought they may be NULL. User-specified inheritance flags are
    // also considered. The SD must be self relative. sControl is 
    // verified earlier
    //

    ((SECURITY_DESCRIPTOR *)pSd)->Control =     sControl
                                            |   SE_DACL_PRESENT
                                            |   SE_SACL_PRESENT
                                            |   SE_SELF_RELATIVE;

    //
    // We start with the owner SID, which is right after the SECURITY_DESCRIPTOR
    // structure
    //

    dwCurOffset = sizeof(SECURITY_DESCRIPTOR);

    if( psOwner == NULL )
    {
        ((SECURITY_DESCRIPTOR *)pSd)->Owner = NULL;
    }
    else
    {
        ((SECURITY_DESCRIPTOR *)pSd)->Owner = (PSID)dwCurOffset;

        dwTmp = GetLengthSid(psOwner);

        memcpy( pSd + dwCurOffset, psOwner, dwTmp );

        dwCurOffset += dwTmp;
    }

    //
    // Following that, the group SID
    //

    if( psGroup == NULL )
    {
        ((SECURITY_DESCRIPTOR *)pSd)->Group = NULL;
    }
    else
    {
        ((SECURITY_DESCRIPTOR *)pSd)->Group = (PSID)dwCurOffset;

        dwTmp = GetLengthSid(psGroup);

        memcpy( pSd + dwCurOffset, psGroup, dwTmp );

        dwCurOffset += dwTmp;
    }

    
    //
    // Second pass through the optional arguments, this time
    // we copy the given ACEs into the security descriptor
    //

    va_start(varArgList, dwNumSaclAces);

    bArglistStarted = TRUE;

    //
    // Now we handle the DACL. If the DACL is not present, offset is NULL.
    // Otherwise, even if 0 ACEs, add the ACL structure
    //
    // ISSUE: In self-relative SD, is a 0 offset enough for no ACL, or must
    // the SE_DACL_PRESENT flag not be set?
    //

    if ( !FLAG_ON( dwOptions, CREATE_SD_DACL_PRESENT ))
    {
        ((SECURITY_DESCRIPTOR *)pSd)->Dacl = NULL;
    }
    else
    {
        //
        // Set the DACL offset to the current offset
        //

        ((SECURITY_DESCRIPTOR *)pSd)->Dacl = (PACL)dwCurOffset;

        //
        // First, copy in the ACL structure as the header
        //

        aclTemp.AceCount = (WORD)dwNumDaclAces;

        aclTemp.AclRevision = ACL_REVISION_DS;

        aclTemp.AclSize = (SHORT)dwDaclSize;

        aclTemp.Sbz1 = 0;

        aclTemp.Sbz2 = 0;

        memcpy( pSd + dwCurOffset, &aclTemp, sizeof(ACL) );

        dwCurOffset += sizeof(ACL);

        //
        // Now go through all the optional arguments for the DACL
        // and add the matching ACEs
        //

       
        for( dwIdx = 0; dwIdx < dwNumDaclAces; dwIdx++ )
        {
            
            //
            // This time, retrieve all the data
            //

            AceRequest.dwFlags = F_IS_DACL_ACE | F_RETURN_ALL_DATA;

            dwTmp = GetNextAceInfo( &varArgList, &AceRequest );

            if( dwTmp == 0 )
            {
                dwErr = GetLastError();

                goto error;
            }

            //
            // The ACE header is already filled in, and contains the ACE size
            //

            memcpy( pSd + dwCurOffset, &(AceRequest.pAce), sizeof(ACE_HEADER) );

            dwCurOffset += sizeof(ACE_HEADER);

            //
            // Set the access mask
            //

            *((PACCESS_MASK)( pSd + dwCurOffset )) = AceRequest.amMask;

            dwCurOffset += sizeof(ACCESS_MASK);


            //
            // If object ACE, set the object flags and GUIDs
            //

            if( AceRequest.dwFlags & F_IS_OBJECT )
            {
                dwTmp = 0;

                if( AceRequest.pgObject != NULL )
                {
                    dwTmp |= ACE_OBJECT_TYPE_PRESENT;
                }

                if( AceRequest.pgInherit != NULL )
                {
                    dwTmp |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
                }

                //
                // Set the object ACE flags
                //

                *((PDWORD)(pSd + dwCurOffset )) = dwTmp;

                dwCurOffset += sizeof(DWORD);

                //
                // Copy the GUIDs, if any
                //

                if( AceRequest.pgObject != NULL )
                {
                    memcpy( pSd + dwCurOffset,
                            AceRequest.pgObject, 
                            sizeof(GUID) );

                    dwCurOffset += sizeof(GUID);
                }
                
                if( AceRequest.pgInherit != NULL )
                {
                    memcpy( pSd + dwCurOffset, 
                            AceRequest.pgInherit, 
                            sizeof(GUID) );

                    dwCurOffset += sizeof(GUID);
                }
            }

            //
            // Copy the SID
            //

            dwTmp = GetLengthSid( AceRequest.pSid );

            memcpy( pSd + dwCurOffset, AceRequest.pSid, dwTmp );

            dwCurOffset += dwTmp;

            //
            // If callback ACE, copy the optional data, if any
            //

            if(     AceRequest.dwFlags & F_IS_CALLBACK
                &&  AceRequest.dwOptDataSize > 0    )
            {
                memcpy( pSd + dwCurOffset, 
                        AceRequest.pvOptData, 
                        AceRequest.dwOptDataSize );

                dwCurOffset += AceRequest.dwOptDataSize;
            }

            //
            // Done with the ACE
            //
        }

        //
        // Done with the DACL
        //
    }

    //
    // Now we handle the SACL
    //

    if ( !FLAG_ON( dwOptions, CREATE_SD_SACL_PRESENT ))
    {
        ((SECURITY_DESCRIPTOR *)pSd)->Sacl = NULL;
    }
    else
    {
        //
        // Set the SACL offset to the current offset
        //

        ((SECURITY_DESCRIPTOR *)pSd)->Sacl = (PACL)dwCurOffset;

        //
        // First, copy in the ACL structure as the header
        //

        aclTemp.AceCount = (WORD) dwNumDaclAces;

        aclTemp.AclRevision = ACL_REVISION_DS;

        aclTemp.AclSize = (WORD) dwSaclSize;

        aclTemp.Sbz1 = 0;

        aclTemp.Sbz2 = 0;

        memcpy( pSd + dwCurOffset, &aclTemp, sizeof(ACL) );

        dwCurOffset += sizeof(ACL);

        //
        // Now go through all the optional arguments for the DACL
        // and add the matching ACEs
        //

        for( dwIdx = 0; dwIdx < dwNumSaclAces; dwIdx++ )
        {
            //
            // This time, retrieve all the data
            //

            AceRequest.dwFlags = F_RETURN_ALL_DATA;

            dwTmp = GetNextAceInfo( &varArgList, &AceRequest );

            if( dwTmp == 0 )
            {
                dwErr = GetLastError();

                goto error;
            }

            //
            // The ACE header is already filled in, and contains the ACE size
            //

            memcpy( pSd + dwCurOffset, &(AceRequest.pAce), sizeof(ACE_HEADER) );

            dwCurOffset += sizeof(ACE_HEADER);

            //
            // Set the access mask
            //

            *((PACCESS_MASK)( pSd + dwCurOffset )) = AceRequest.amMask;

            dwCurOffset += sizeof(ACCESS_MASK);


            //
            // If object ACE, set the object flags and GUIDs
            //

            if( AceRequest.dwFlags & F_IS_OBJECT )
            {
                dwTmp = 0;

                if( AceRequest.pgObject != NULL )
                {
                    dwTmp |= ACE_OBJECT_TYPE_PRESENT;
                }

                if( AceRequest.pgInherit != NULL )
                {
                    dwTmp |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
                }

                //
                // Set the object ACE flags
                //

                *((PDWORD)(pSd + dwCurOffset )) = dwTmp;

                dwCurOffset += sizeof(DWORD);

                //
                // Copy the GUIDs, if any
                //

                if( AceRequest.pgObject != NULL )
                {
                    memcpy( pSd + dwCurOffset,
                            AceRequest.pgObject, 
                            sizeof(GUID) );

                    dwCurOffset += sizeof(GUID);
                }
                
                if( AceRequest.pgInherit != NULL )
                {
                    memcpy( pSd + dwCurOffset, 
                            AceRequest.pgInherit, 
                            sizeof(GUID) );

                    dwCurOffset += sizeof(GUID);
                }
            }

            //
            // Copy the SID
            //

            dwTmp = GetLengthSid( AceRequest.pSid );

            memcpy( pSd + dwCurOffset, AceRequest.pSid, dwTmp );

            dwCurOffset += dwTmp;

            //
            // If callback ACE, copy the optional data, if any
            //

            if(     AceRequest.dwFlags & F_IS_CALLBACK
                &&  AceRequest.dwOptDataSize > 0    )
            {
                memcpy( pSd + dwCurOffset, 
                        AceRequest.pvOptData, 
                        AceRequest.dwOptDataSize );

                dwCurOffset += AceRequest.dwOptDataSize;
            }

            //
            // Done with the ACE
            //
        }
        
        //
        // Done with the SACL
        //
    }
            

    //
    // Done with the variable arg list
    //

    va_end(varArgList);

    bArglistStarted = FALSE;

    error:;

    if( dwErr != ERROR_SUCCESS )
    {
        if( bArglistStarted )
        {
            va_end(varArgList);
        }

        if( pSd != NULL )
        {
            free(pSd);
        }

        SetLastError(dwErr);

        return FALSE;
    }
    else
    {
        //
        // Make sure the sizes match
        //

        ASSERT( dwCurOffset == ( dwSizeSd + dwDaclSize + dwSaclSize ) );

        *ppSd = pSd;

        return TRUE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\makesd\makesd.h ===
#pragma once

#include "pch.h"

void FreeSecurityDescriptor2(
         IN            PSECURITY_DESCRIPTOR pSd
         );

#define CREATE_SD_DACL_PRESENT 0x0001
#define CREATE_SD_SACL_PRESENT 0x0002

EXTERN_C
BOOL 
WINAPI
CreateSecurityDescriptor2(
         OUT           PSECURITY_DESCRIPTOR * ppSd,
         IN    const   DWORD dwOptions,
         IN    const   SECURITY_DESCRIPTOR_CONTROL sControl,
         IN    const   PSID  psOwner,
         IN    const   PSID  psGroup,
         IN    const   DWORD dwNumDaclAces,
         IN    const   DWORD dwNumSaclAces,
         ...
         );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\makesd\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <aclapi.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <guiddef.h>

#define SECURITY_WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\samplerm\guids.c ===
#include "pch.h"

GUID Guid0 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x00}};
GUID Guid1 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x01}};
GUID Guid2 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x02}};
GUID Guid3 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x03}};
GUID Guid4 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x04}};
GUID Guid5 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x05}};
GUID Guid6 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x06}};
GUID Guid7 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x07}};
GUID Guid8 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x08}};

ULONG WorldSid[] = {0x101, 0x1000000, 0};

// S-1-5-21-397955417-626881126-188441444-2791022
ULONG KedarSid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x002a966e};

// S-1-5-21-397955417-626881126-188441444-2204519
ULONG RahulSid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x0021a367};

// S-1-5-21-397955417-626881126-188441444-2101332
ULONG RobertreSid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00201054};

ULONG SpecialSid[] = {0x101, 0x2000000, 2};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\stress\ac\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <sddl.h>
#include <seopaque.h>
#include <sertlp.h>
#include <authz.h>

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\stress\ai\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <sddl.h>
#include <seopaque.h>
#include <sertlp.h>
#include <authz.h>

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\stress\logq\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <sddl.h>
#include <seopaque.h>
#include <sertlp.h>
#include <authz.h>
#include <authzi.h>

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\samplerm\samplerm.h ===
#pragma once

extern GUID Guid0;
extern GUID Guid1;
extern GUID Guid2;
extern GUID Guid3;
extern GUID Guid4;
extern GUID Guid5;
extern GUID Guid6;
extern GUID Guid7;
extern GUID Guid8;

extern ULONG WorldSid[];
extern ULONG KedarSid[];
extern ULONG RahulSid[];
extern ULONG RobertreSid[];
extern ULONG SpecialSid[];

#define BUFFERMAX 1024
#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))
#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

CHAR Buffer[BUFFERMAX];
CHAR TypeListBuffer[BUFFERMAX];

BOOL
MyAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable
    );

BOOL
MyComputeDynamicGroups(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
    IN PVOID Args,
    OUT PSID_AND_ATTRIBUTES *pSidAttrArray,
    OUT PDWORD pSidCount,
    OUT PSID_AND_ATTRIBUTES *pRestrictedSidAttrArray,
    OUT PDWORD pRestrictedSidCount
    );

VOID
MyFreeDynamicGroups (
    IN PSID_AND_ATTRIBUTES pSidAttrArray
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\samplerm\samplerm.c ===
#include "pch.h"

BOOL
MyAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable
    )

/*++

    Routine Description
    
        This is a very trivial example of a callback access check routine.  Here we randomly decide 
        if the ACE applies to the given client context.  
        
    Arguments
    
        hAuthzClientContext - handle to AuthzClientContext.
        pAce - pointer to Ace header.
        pArgs - optional arguments that can be used in evaluating the ACE.  
        pbAceApplicable - returns the result of the evaluation.

    Return value
    
        Bool, true if ACE is applicable, false otherwise.
--*/
{
    *pbAceApplicable = (BOOL) rand() % 2;

    return TRUE;
}

BOOL
MyComputeDynamicGroups(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
    IN PVOID Args,
    OUT PSID_AND_ATTRIBUTES *pSidAttrArray,
    OUT PDWORD pSidCount,
    OUT PSID_AND_ATTRIBUTES *pRestrictedSidAttrArray,
    OUT PDWORD pRestrictedSidCount
    )

/*++

    Routine Description
    
        Resource manager callback to compute dynamic groups.  This is used by the RM
        to decide if the specified client context should be included in any RM defined groups.
        
    Arguments
    
        hAuthzClientContext - handle to client context.
        Args - optional parameter to pass information for evaluating group membership.
        pSidAttrArray - computed group membership SIDs
        pSidCount - count of SIDs
        pRestrictedSidAttrArray - computed group membership restricted SIDs
        pRestrictedSidCount - count of restricted SIDs
        
    Return Value 
        
        Bool, true for success, false on failure.

--*/    
{
    ULONG Length = 0;

    if (Args == -1)
    {
        return TRUE;
    }

    *pSidCount = 2;
    *pRestrictedSidCount = 0;

    *pRestrictedSidAttrArray = 0;

    Length = RtlLengthSid((PSID) KedarSid);
    Length += RtlLengthSid((PSID) RahulSid);

    if (!(*pSidAttrArray = malloc(sizeof(SID_AND_ATTRIBUTES) * 2 + Length)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    (*pSidAttrArray)[0].Attributes = SE_GROUP_ENABLED;
    (*pSidAttrArray)[0].Sid = ((PUCHAR) (*pSidAttrArray)) + 2 * sizeof(SID_AND_ATTRIBUTES);
    RtlCopySid(Length/2, (*pSidAttrArray)[0].Sid, (PSID) KedarSid);

    (*pSidAttrArray)[1].Attributes = SE_GROUP_USE_FOR_DENY_ONLY;
    (*pSidAttrArray)[1].Sid = ((PUCHAR) (*pSidAttrArray)) + 2 * sizeof(SID_AND_ATTRIBUTES) + Length/2;
    RtlCopySid(Length/2, (*pSidAttrArray)[1].Sid, (PSID) RahulSid);

    return TRUE;
}

VOID
MyFreeDynamicGroups (
    IN PSID_AND_ATTRIBUTES pSidAttrArray
    )

/*++

    Routine Description
    
        Frees memory allocated for the dynamic group array.

    Arguments
    
        pSidAttrArray - array to free.
    
    Return Value
        None.                       
--*/        
{
    if (pSidAttrArray) free(pSidAttrArray);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\samplerm\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <sddl.h>
#include <seopaque.h>
#include <sertlp.h>
#include <authz.h>
#include "samplerm.h"

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\stress\rm\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <sddl.h>
#include <seopaque.h>
#include <sertlp.h>
#include <authz.h>

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\stress\ai\main.c ===
#include "pch.h"


void _cdecl wmain(int argc, WCHAR * argv[])
{
    LONG                          i          = 0;
    LONG                          Iterations = 0;
    BOOL                          b          = TRUE;
    AUTHZ_AUDIT_INFO_HANDLE       hAAI       = NULL;
    AUTHZ_RESOURCE_MANAGER_HANDLE hRM        = NULL;

    if (argc != 2)
    {
        wprintf(L"usage: %s iterations\n", argv[0]);
        exit(0);
    }

    Iterations = wcstol(argv[1], NULL, 10);

    wprintf(L"AI Stress.  Init / Free AI for %d iters.  Press a key to start.\n", Iterations);
    getchar();

    b = AuthzInitializeResourceManager(
            NULL,
            NULL,
            NULL,
            L"Jeff's RM",
            0,            // Flags
            &hRM
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeResourceManager failed with %d\n", GetLastError());
        return;
    }

    for (i = 0; i < Iterations; i++)
    {
        b = AuthzInitializeAuditInfo(
                &hAAI,
                0,
                hRM,
                NULL,
                NULL,
                NULL,
                INFINITE,
                L"",
                L"",
                L"",
                L""
                );

        if (!b)
        {
            wprintf(L"AuthzInitializeAuditInfo failed with %d\n", GetLastError());
            return;
        }

        b = AuthzFreeAuditInfo(
                hAAI
                );
    
        if (!b)
        {
            wprintf(L"AuthzFreeAuditInfo failed with %d\n", GetLastError());
            return;
        }
    }

    b = AuthzFreeResourceManager(
            hRM
            );

    if (!b)
    {
        wprintf(L"AuthzFreeResourceManager failed with %d\n", GetLastError());
        return;
    }

    wprintf(L"Done.  Press a key.\n");
    getchar();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\samplerm\main.c ===
#include "pch.h"
#include "samplerm.h"



void _cdecl wmain( int argc, WCHAR * argv[] )
{
    NTSTATUS Status = STATUS_SUCCESS;

    BOOL b = TRUE;
    DWORD DesiredAccess;
    DWORD Callback;
    DWORD Iteration;

    AUTHZ_RESOURCE_MANAGER_HANDLE hRM = NULL;
    HANDLE hToken = NULL;
    LUID luid = {0xdead,0xbeef};
    AUTHZ_CLIENT_CONTEXT_HANDLE hCC1 = NULL;
    AUTHZ_CLIENT_CONTEXT_HANDLE hCC2 = NULL;
    AUTHZ_CLIENT_CONTEXT_HANDLE hCC3 = NULL;
    AUTHZ_ACCESS_REQUEST Request;
    PAUTHZ_ACCESS_REPLY pReply = (PAUTHZ_ACCESS_REPLY) Buffer;
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD dwErr;
    ULONG i = 0, jj = 0;
    PACE_HEADER Ace = NULL;
    DWORD AceCount = 0;
    DWORD Len = 0;
    SID_AND_ATTRIBUTES SidAttr[1];
    AUTHZ_AUDIT_INFO_HANDLE hAuditInfo = NULL;
    AUTHZ_RM_AUDIT_INFO_HANDLE hRmAuditInfo;
    PAUDIT_PARAMS pAuditParams;

    AUTHZ_HANDLE AuthHandle = 0;
    PACL pAcl = NULL;
    AUDIT_EVENT_INFO AuditEventInfo;
    PSID pUserSid = NULL;
    AUTHZ_AUDIT_QUEUE_HANDLE hQueue;

    PWCHAR StringSD = L"O:BAG:DUD:(A;;0x40;;;s-1-2-2)(A;;0x1;;;BA)(OA;;0x2;6da8a4ff-0e52-11d0-a286-00aa00304900;;BA)(OA;;0x4;6da8a4ff-0e52-11d0-a286-00aa00304901;;BA)(OA;;0x8;6da8a4ff-0e52-11d0-a286-00aa00304903;;AU)(OA;;0x10;6da8a4ff-0e52-11d0-a286-00aa00304904;;BU)(OA;;0x20;6da8a4ff-0e52-11d0-a286-00aa00304905;;AU)(A;;0x40;;;PS)S:(AU;IDSAFA;0xFFFFFF;;;WD)";
    //PWCHAR StringSD = L"O:BAG:DUD:(A;;0x100;;;SY)(A;;0x100;;;PS)S:(AU;IDSA;SD;;;DU)";

    if (argc != 4)
    {
        wprintf(L"usage: %s access iter [callback]\n", argv[0]);
        exit(0);
    }


    DesiredAccess = wcstol(argv[1], NULL, 16);
    Iteration = wcstol(argv[2], NULL, 16);
    Callback = wcstol(argv[3], NULL, 16);

    //
    // Create the SD for the access checks
    //

    b = ConvertStringSecurityDescriptorToSecurityDescriptorW(StringSD, SDDL_REVISION_1, &pSD, NULL);

    if (!b)
    {
        wprintf(L"SDDL failed with %d\n", GetLastError());
        return;
    }

    //
    // If Callback aces are specified, change the DACL to use them
    //

    if (Callback)
    {
        pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSD);
        AceCount = pAcl->AceCount;
        
        for (i = 0, Ace = FirstAce(pAcl); i < AceCount; i++, Ace = NextAce(Ace))
        {
            switch(Ace->AceType)
            {
            case ACCESS_ALLOWED_ACE_TYPE:
                Ace->AceType = ACCESS_ALLOWED_CALLBACK_ACE_TYPE;
                break;
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                Ace->AceType = ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE;
                break;
            }
        }
    }


    AuditEventInfo.Version                 = AUDIT_TYPE_LEGACY;
    AuditEventInfo.u.Legacy.CategoryId     = SE_CATEGID_OBJECT_ACCESS;
    AuditEventInfo.u.Legacy.AuditId        = SE_AUDITID_OBJECT_OPERATION;
    AuditEventInfo.u.Legacy.ParameterCount = 11;

    b = AuthzInitializeAuditQueue(
        &hQueue,
        0,
        1000,
        100,
        NULL
        );

    if (!b)
    {
        wprintf(L"authzinitauditqueueueueue %d\n", GetLastError());
        return;
    }

    if (!b)
    {
        printf("AuthzAllocInitRmAuditInfoHandle FAILED.\n");
        return;
    }

    b = AuthzInitializeResourceManager(
            MyAccessCheck,
            MyComputeDynamicGroups,
            MyFreeDynamicGroups,
            L"some rm",
            0,                          // Flags
            &hRM
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeResourceManager failed with %d\n", GetLastError());
        return;
    }

//     AuthzInitializeAuditParamsWithRM(
//         &pAuditParams,
//         hRM,
//         APF_AuditSuccess,
//         1,
//         APT_String, L"Jeff operation"
//         );
//
//
    b = AuthzInitializeAuditInfo(
            &hAuditInfo,
            0,
            hRM,
            &AuditEventInfo,
            NULL,//pAuditParams,
            hQueue,
            INFINITE,
            L"Cleaning",
            L"Toothbrush",
            L"Oral B",
            L"Rinse after brushing."
            );
    
    if (!b)
    {
        printf("AuthzInitAuditInfo FAILED with %d.\n", GetLastError());
        return;
    }

    OpenProcessToken( 
        GetCurrentProcess(), 
        TOKEN_QUERY, 
        &hToken
        );

    b = AuthzInitializeContextFromToken(
            hToken,
            hRM,
            NULL,
            luid,
            0,
            NULL,
            &hCC1
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeContextFromSid failed with 0x%x\n", GetLastError());
        return;
    }

    Request.ObjectTypeList = (POBJECT_TYPE_LIST) TypeListBuffer;
    Request.ObjectTypeList[0].Level = 0;
    Request.ObjectTypeList[0].ObjectType = &Guid0;
    Request.ObjectTypeList[0].Sbz = 0;
    Request.ObjectTypeListLength = 1;
    Request.OptionalArguments = NULL;
    Request.PrincipalSelfSid = NULL;
    Request.DesiredAccess = 0x100;

    //
    // The ResultListLength is set to the number of ObjectType GUIDs in the Request, indicating
    // that the caller would like detailed information about granted access to each node in the
    // tree.
    //
    RtlZeroMemory(Buffer, sizeof(Buffer));
    pReply->ResultListLength = 1;
    pReply->Error = (PDWORD) (((PCHAR) pReply) + sizeof(AUTHZ_ACCESS_REPLY));
    pReply->GrantedAccessMask = (PACCESS_MASK) (pReply->Error + pReply->ResultListLength);


    wprintf(L"* AccessCheck (PSS == NULL, ResultListLength == 1 with cache handle)\n");
    b = AuthzAccessCheck(
            hCC1,
            &Request,
            hAuditInfo,
            pSD,
            NULL,
            0,
            pReply,
            &AuthHandle
            );

    if (!b)
    {
        wprintf(L"\tFailed. LastError = %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"\tSucceeded.  Granted Access Masks:\n");

        for (i = 0; i < pReply->ResultListLength; i++)
        {
            wprintf(L"\t\tObjectType %d :: AccessMask = 0x%x, Error = %d\n",
                    i, pReply->GrantedAccessMask[i], pReply->Error[i]);
        }
    }

    AuthzFreeAuditInfo(hAuditInfo);
    AuthzFreeAuditQueue(hQueue);
    return;

    RtlZeroMemory(Buffer, sizeof(Buffer));
    pReply->ResultListLength = 1;
    pReply->Error = (PDWORD) (((PCHAR) pReply) + sizeof(AUTHZ_ACCESS_REPLY));
    pReply->GrantedAccessMask = (PACCESS_MASK) (pReply->Error + pReply->ResultListLength);

    wprintf(L"* AccessCheck (PSS == NULL, ResultListLength == 1 without cache handle)\n");
    b = AuthzAccessCheck(
            hCC1,
            &Request,
            hAuditInfo,
            pSD,
            NULL,
            0,
            pReply,
            NULL
            );

    if (!b)
    {
        wprintf(L"\tFailed. LastError = %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"\tSucceeded.  Granted Access Masks:\n");

        for (i = 0; i < pReply->ResultListLength; i++)
        {
            wprintf(L"\t\tObjectType %d :: AccessMask = 0x%x, Error = %d\n",
                    i, pReply->GrantedAccessMask[i], pReply->Error[i]);
        }
    }

    AuthzFreeAuditParams(pAuditParams);

    Request.ObjectTypeList = (POBJECT_TYPE_LIST) TypeListBuffer;

    Request.ObjectTypeList[0].Level = 0;
    Request.ObjectTypeList[0].ObjectType = &Guid0;
    Request.ObjectTypeList[0].Sbz = 0;

    Request.ObjectTypeList[1].Level = 1;
    Request.ObjectTypeList[1].ObjectType = &Guid1;
    Request.ObjectTypeList[1].Sbz = 0;

    Request.ObjectTypeList[2].Level = 2;
    Request.ObjectTypeList[2].ObjectType = &Guid2;
    Request.ObjectTypeList[2].Sbz = 0;

    Request.ObjectTypeList[3].Level = 2;
    Request.ObjectTypeList[3].ObjectType = &Guid3;
    Request.ObjectTypeList[3].Sbz = 0;

    Request.ObjectTypeList[4].Level = 1;
    Request.ObjectTypeList[4].ObjectType = &Guid4;
    Request.ObjectTypeList[4].Sbz = 0;

    Request.ObjectTypeList[5].Level = 2;
    Request.ObjectTypeList[5].ObjectType = &Guid5;
    Request.ObjectTypeList[5].Sbz = 0;

    Request.ObjectTypeList[6].Level = 3;
    Request.ObjectTypeList[6].ObjectType = &Guid6;
    Request.ObjectTypeList[6].Sbz = 0;

    Request.ObjectTypeList[7].Level = 2;
    Request.ObjectTypeList[7].ObjectType = &Guid7;
    Request.ObjectTypeList[7].Sbz = 0;

    Request.ObjectTypeListLength = 8;
    Request.OptionalArguments = NULL;

    Request.PrincipalSelfSid = NULL;
    Request.DesiredAccess = DesiredAccess;

    //
    // The ResultListLength is set to the number of ObjectType GUIDs in the Request, indicating
    // that the caller would like detailed information about granted access to each node in the
    // tree.
    //

    pReply->ResultListLength = 8;
    pReply->Error = (PDWORD) (((PCHAR) pReply) + sizeof(AUTHZ_ACCESS_REPLY));
    pReply->GrantedAccessMask = (PACCESS_MASK) (pReply->Error + pReply->ResultListLength);

    wprintf(L"* AccessCheck (PrincipalSelfSid == NULL, ResultListLength == 8)\n");
    b = AuthzAccessCheck(
            hCC1,
            &Request,
            hAuditInfo,
            pSD,
            NULL,
            0,
            pReply,
            &AuthHandle
            );

    if (!b)
    {
        wprintf(L"\tFailed. LastError = %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"\tSucceeded.  Granted Access Masks:\n");

        for (i = 0; i < pReply->ResultListLength; i++)
        {
            wprintf(L"\t\tObjectType %d :: AccessMask = 0x%x, Error = %d\n",
                    i, pReply->GrantedAccessMask[i], pReply->Error[i]);
        }
    }


    //
    // In the original AuthzAccessCheck call, we passed in a handle to store caching information.  Now we
    // can use this handle to perform an AccessCheck on the same object.
    //

    if (AuthHandle)
    {
        wprintf(L"* Cached AccessCheck (PrincipalSelfSid == NULL, ResultListLength = 8)\n");
        b = AuthzCachedAccessCheck(
                AuthHandle,
                &Request,
                hAuditInfo,
                pReply
                );

        if (!b)
        {
            wprintf(L"\tFailed. LastError = %d\n", GetLastError());
            return;
        }
        else
        {
            wprintf(L"\tSucceeded.  Granted Access Masks:\n");

            for (i = 0; i < pReply->ResultListLength; i++)
            {
                wprintf(L"\t\tObjectType %d :: AccessMask = 0x%x, Error = %d\n",
                        i, pReply->GrantedAccessMask[i], pReply->Error[i]);
            }
        }

        //
        // Since we will no longer use this caching handle, free it.
        //

        AuthzFreeHandle(AuthHandle);
    }
    else
    {
        wprintf(L"No CachedAccessCheck done since NULL = AuthHandle\n");
    }

    //
    // We set the PrincipalSelfSid in the Request, and leave all other parameters the same.
    //

    Request.PrincipalSelfSid = (PSID) KedarSid;

    wprintf(L"* AccessCheck (PrincipalSelfSid == Kedard, ResultListLength == 8)\n");
    b = AuthzAccessCheck(
            hCC1,
            &Request,
            hAuditInfo,
            pSD,
            NULL,
            0,
            pReply,
            &AuthHandle
            );

    if (!b)
    {
        wprintf(L"\tFailed. LastError = %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"\tSucceeded.  Granted Access Masks:\n");

        for (i = 0; i < pReply->ResultListLength; i++)
        {
            wprintf(L"\t\tObjectType %d :: AccessMask = 0x%x, Error = %d\n",
                    i, pReply->GrantedAccessMask[i], pReply->Error[i]);
        }
    }
               
    //
    // Use our caching handle to perform the same AccessCheck with speed.
    //

    if (AuthHandle)
    {
        wprintf(L"* Cached AccessCheck (PrincipalSelfSid == Kedard, ResultListLength = 8)\n");
        b = AuthzCachedAccessCheck(
                AuthHandle,
                &Request,
                hAuditInfo,
                pReply
                );

        if (!b)
        {
            wprintf(L"\tFailed. LastError = %d\n", GetLastError());
            return;
        }
        else
        {
            wprintf(L"\tSucceeded.  Granted Access Masks:\n");

            for (i = 0; i < pReply->ResultListLength; i++)
            {
                wprintf(L"\t\tObjectType %d :: AccessMask = 0x%x, Error = %d\n",
                        i, pReply->GrantedAccessMask[i], pReply->Error[i]);
            }
        }

        //
        // Free the handle, since it will not be used again.
        //
        
        AuthzFreeHandle(AuthHandle);
    }
    else
    {
        wprintf(L"No CachedAccessCheck done since NULL = AuthHandle\n");
    }


    //
    // Set the ResultListLength to 1, indicating that we do not care about the results
    // of the AccessCheck at the individual nodes in the tree.  Rather, we care about
    // our permissions to the entire tree.  The returned access indicates if we have 
    // access to the whole thing.
    //

    pReply->ResultListLength = 1;

    wprintf(L"* AccessCheck (PrincipalSelfSid == Kedard, ResultListLength == 1)\n");
    b = AuthzAccessCheck(
            hCC1,
            &Request,
            hAuditInfo,
            pSD,
            NULL,
            0,
            pReply,
            NULL
            );

    if (!b)
    {
        wprintf(L"\tFailed. LastError = %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"\tSucceeded.  Granted Access Masks:\n");

        for (i = 0; i < pReply->ResultListLength; i++)
        {
            wprintf(L"\t\tObjectType %d :: AccessMask = 0x%x, Error = %d\n",
                    i, pReply->GrantedAccessMask[i], pReply->Error[i]);
        }
    }
    
//     for (i = 0; i < 10; i ++)
//     {
//        AuthzOpenObjectAuditAlarm(
//            hCC1,
//            &Request,
//            hAuditInfo,
//            pSD,
//            NULL,
//            0,
//            pReply
//            );
//
//        if (!b)
//        {
//            wprintf(L"AuthzOpenObjectAuditAlarm failed with %d\n", GetLastError);
//        }
//     }
    
    //
    // Free the RM auditing data before exiting.  This call is importants, as it also waits on 
    // threads used by the Authzs auditing component to complete.
    //

    //AuthzFreeRmAuditInfoHandle(hRmAuditInfo);
    
    //
    // Free the contexts that the RM created.
    //

    AuthzFreeContext(hCC1);
    AuthzFreeAuditQueue(hQueue);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\stress\logq\main.c ===
#include "pch.h"


void _cdecl wmain(int argc, WCHAR * argv[])
{
    AUTHZ_RESOURCE_MANAGER_HANDLE hRM         = NULL;
    AUTHZ_AUDIT_EVENT_HANDLE      hAE         = NULL;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET        = NULL;
    LONG                          i           = 0;
    LONG                          Iterations  = 0;
    BOOL                          b           = TRUE;
    PAUDIT_PARAMS                 pParams     = NULL;

    b = AuthzInitializeResourceManager(
            0,
            NULL,
            NULL,
            NULL,
            L"3rd Party",
            &hRM
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeResourceManager failed with %d\n", GetLastError());
        return;
    }

#define SE_AUDITID_THIRD_PARTY_AUDIT 0x259
    b = AuthziInitializeAuditEventType(
            0,
            SE_CATEGID_DETAILED_TRACKING,
            SE_AUDITID_THIRD_PARTY_AUDIT,
            2,
            &hAET
            );

    if (!b)
    {
        wprintf(L"AuthziInitializeAuditEventType failed with %d\n", GetLastError());
        return;
    }

    b = AuthziAllocateAuditParams(
            &pParams,
            2
            );

    if (!b)
    {
        wprintf(L"AuthzAllocateAuditParams failed with %d\n", GetLastError());
    }

    b = AuthziInitializeAuditParamsWithRM(
            0,
            hRM,
            2,
            pParams,
            APT_String, L"I am the 3rd Party, and the next param is a number.",
            APT_Ulong,  5
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeAuditParamsWithRM failed with %d\n", GetLastError());
    }

    b = AuthziInitializeAuditEvent(
            0,
            hRM,
            hAET,
            pParams,
            NULL,
            INFINITE,
            L"",
            L"",
            L"",
            L"",
            &hAE
            );

    if (!b)
    {
        wprintf(L"AuthziInitializeAuditEvent failed with %d\n", GetLastError());
        return;
    }

    for (i = 0; i < 1000; i++)
    {
    b = AuthziLogAuditEvent(
            0,
            hAE,
            NULL
            );

    if (!b)
    {
        wprintf(L"AuthzLogAuditEvent (no queue) failed with %d\n", GetLastError());
    }
    }

    b = AuthzFreeAuditEvent(
            hAE
            );

    if (!b)
    {
        wprintf(L"AuthziFreeAuditEvent failed with %d\n", GetLastError());
        return;
    }

    b = AuthziFreeAuditEventType(
            hAET
            );

    if (!b)
    {
        wprintf(L"AuthziFreeAuditEventType failed with %d\n", GetLastError());
        return;
    }
    b = AuthziFreeAuditParams(
            pParams
            );

    if (!b)
    {
        wprintf(L"AuthziFreeAuditParams failed with %d\n", GetLastError());
        return;
    }

    b = AuthzFreeResourceManager(
            hRM
            );

    if (!b)
    {
        wprintf(L"AuthzFreeResourceManager failed with %d\n", GetLastError());
        return;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\stress\ac\main.c ===
#include "pch.h"
#include <authzi.h>

PSID pSid = NULL;


void _cdecl wmain(int argc, WCHAR * argv[])
{
    LONG                          i           = 0;
    LONG                          ii          = 0;
    LONG                          j           = 0;
    LONG                          Iterations  = 0;
    BOOL                          b           = TRUE;
    AUTHZ_AUDIT_EVENT_HANDLE      hAAI1       = NULL;
    AUTHZ_AUDIT_EVENT_HANDLE      hAAI2       = NULL;
    AUTHZ_AUDIT_EVENT_HANDLE      hOA         = NULL;
    AUTHZ_RESOURCE_MANAGER_HANDLE hRM         = NULL;
    AUTHZ_AUDIT_QUEUE_HANDLE      hAAQ        = NULL;
    AUTHZ_CLIENT_CONTEXT_HANDLE   hCC         = NULL;
    PSECURITY_DESCRIPTOR          pSD         = NULL;
    PSECURITY_DESCRIPTOR          pSD2         = NULL;
    PSECURITY_DESCRIPTOR          pASD[2];
    PWCHAR                        StringSD    = L"O:BAG:BUD:(A;;0x40;;;s-1-2-2)(A;;0x1;;;BA)(OA;;0x2;6da8a4ff-0e52-11d0-a286-00aa00304900;;BA)(OA;;0x4;6da8a4ff-0e52-11d0-a286-00aa00304901;;BA)(OA;;0x8;6da8a4ff-0e52-11d0-a286-00aa00304903;;AU)(OA;;0x10;6da8a4ff-0e52-11d0-a286-00aa00304904;;BU)(OA;;0x20;6da8a4ff-0e52-11d0-a286-00aa00304905;;AU)(A;;0x40;;;PS)S:(AU;IDSAFA;0xFFFFFF;;;WD)";
    HANDLE                        hToken      = NULL;
    UCHAR                         Buffer[256];
    AUTHZ_ACCESS_REQUEST          Request     = {0};
    PAUTHZ_ACCESS_REPLY           pReply      = (PAUTHZ_ACCESS_REPLY) Buffer;
    LUID                          Luid        = {0xdead,0xbeef};
    PAUDIT_PARAMS                 pParams     = NULL;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE pAEI        = NULL;
    AUTHZ_ACCESS_CHECK_RESULTS_HANDLE hCache = NULL;
    
    if (argc != 2)
    {
        wprintf(L"usage: %s iterations\n", argv[0]);
        exit(0);
    }

    Iterations = wcstol(argv[1], NULL, 10);

    wprintf(L"Log Stress with queues.  Default and specific queue each with %d audits.  Press a key to start.\n", Iterations);
    getchar();

    if (!b)
    {
        wprintf(L"SDDL failed with %d\n", GetLastError());
        return;
    }

    b = AuthzInitializeResourceManager(
            0,
            NULL,
            NULL,
            NULL,
            L"Jeff's RM",
            &hRM
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeResourceManager failed with %d\n", GetLastError());
        return;
    }

    //
    // Create a client context from the current token.
    //

    OpenProcessToken( 
        GetCurrentProcess(), 
        TOKEN_QUERY, 
        &hToken
        );

    b = AuthzInitializeContextFromToken(
            0,
            hToken,
            hRM,
            NULL,
            Luid,
            NULL,
            &hCC
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeContextFromToken failed with 0x%x\n", GetLastError());
        return;
    }            

    for (i = 0; i < Iterations; i++)
    {

        //
        // Create the SD for the access checks
        //

        b = ConvertStringSecurityDescriptorToSecurityDescriptorW(
                StringSD, 
                SDDL_REVISION_1, 
                &pSD, 
                NULL
                );

        pASD[0] = pSD;
        pASD[1] = pSD;

        AuthzInitializeObjectAccessAuditEvent(
            0,
            NULL,
            L"op",
            L"object type",
            L"object name",
            L"info",
            &hOA,
            0
            );
              
        if (!b)
        {
            wprintf(L"AuthzInitializeObjectAccessAuditEvent failed with %d\n", GetLastError());
            return;
        }

        b = AuthziInitializeAuditEvent(
                AUTHZ_NO_ALLOC_STRINGS | AUTHZ_DS_CATEGORY_FLAG,
                hRM,
                NULL,
                NULL,
                NULL,
                INFINITE,
                L"This is with the default RM queue.",
                L"This is with the default RM queue.",
                L"This is with the default RM queue.",
                L"This is with the default RM queue.",
                &hAAI1
                );

        if (!b)
        {
            wprintf(L"AuthzInitializeAuditInfo (no queue) failed with %d\n", GetLastError());
            return;
        }

        b = AuthziInitializeAuditQueue(
                AUTHZ_MONITOR_AUDIT_QUEUE_SIZE,
                1000,
                100,
                NULL,
                &hAAQ
                );

        if (!b)
        {
            wprintf(L"AuthziInitializeAuditQueue failed with %d\n", GetLastError());
            return;
        }

        b = AuthziAllocateAuditParams(
                &pParams,
                1
                );

        if (!b)
        {
            wprintf(L"AuthzAllocateAuditParams failed with %d\n", GetLastError());
        }

        b = AuthziInitializeAuditParams(
                0,
                pParams,
                &pSid,
                L"foo",
                1,
                APT_String, L"This audit was with a custom AUDIT_EVENT_INFO, AUDIT_PARAMS, and queue."
                );

//         b = AuthziInitializeAuditParamsWithRM(
//                 0,
//                 hRM,
//                 1,
//                 pParams,
//                 APT_String, L"This audit was with a custom AUDIT_EVENT_INFO, AUDIT_PARAMS, and queue."
//                 );

        if (!b)
        {
            wprintf(L"AuthzInitializeAuditParamsWithRM failed with %d\n", GetLastError());
        }

        b = AuthziInitializeAuditEventType(
                0,
                SE_CATEGID_OBJECT_ACCESS,
                567,
                1,
                &pAEI
                );

        if (!b)
        {
            wprintf(L"AuthzInitializeAuditEvent failed with %d\n", GetLastError());
        }

        b = AuthziInitializeAuditEvent(
                AUTHZ_NO_RM_AUDIT,
                NULL, //hRM,
                pAEI,
                pParams,
                NULL,
                INFINITE,
                L"This is with a specific queue and params.",
                L"This is with a specific queue and params.",
                L"This is with a specific queue and params.",
                L"This is with a specific queue and params.",
                &hAAI2
                );

        if (!b)
        {
            wprintf(L"AuthziInitializeAuditEvent (with queue) failed with %d\n", GetLastError());
            return;
        }

        for (ii = 0; ii < 100; ii++)
        {
           b = AuthziLogAuditEvent(
                0,
                hAAI2,
                NULL
                );
           if (!b)
           {
               wprintf(L"log failed with %d \n", GetLastError());
               return;
           }

        }
        Request.ObjectTypeList = NULL;
        Request.PrincipalSelfSid = NULL;
        Request.DesiredAccess = MAXIMUM_ALLOWED;

        pReply->ResultListLength = 1;
        pReply->Error = (PDWORD) (((PCHAR) pReply) + sizeof(AUTHZ_ACCESS_REPLY));
        pReply->GrantedAccessMask = (PACCESS_MASK) (pReply->Error + pReply->ResultListLength);
        pReply->SaclEvaluationResults = (PDWORD) pReply->GrantedAccessMask + (sizeof(ACCESS_MASK) * pReply->ResultListLength);


        b = AuthzAccessCheck(
                0,
                hCC,
                &Request,
                hOA,
                pSD,
                pASD,
                2,
                pReply,
                &hCache
                );

        if (!b)
        {
            wprintf(L"AuthzAccessCheck (with queue) failed with %d\n", GetLastError());
            return;
        }

        pSD2 = pSD;
        pSD = NULL;

        for (j = 0; j < 100; j++)
        {

            b = AuthzCachedAccessCheck(
                    0,
                    hCache,
                    &Request,
                    hOA,
                    pReply
                    );
            b = AuthzCachedAccessCheck(
                    0,
                    hCache,
                    &Request,
                    hAAI1,
                    pReply
                    );
            b = AuthzCachedAccessCheck(
                    0,
                    hCache,
                    &Request,
                    hAAI1,
                    pReply
                    );

            if (!b)
            {
                wprintf(L"CachedAuthzAccessCheck (no queue) failed with %d\n", GetLastError());
                return;
            }
        }
        
        b = AuthzFreeAuditEvent(
                hAAI2
                );

        b = AuthzFreeAuditEvent(
                hAAI1
                );
        
        b = AuthzFreeAuditEvent(
                hOA
                );

        if (!b)
        {
            wprintf(L"AuthzFreeAuditInfo (no queue) failed with %d\n", GetLastError());
            return;
        }

        b = AuthziFreeAuditEventType(
                pAEI
                );

        if (!b)
        {
            wprintf(L"AuthzFreeAuditEventType failed with %d\n", GetLastError());
            return;
        }

        b = AuthziFreeAuditParams(
                pParams
                );

        if (!b)
        {
            wprintf(L"AuthzFreeAuditParams failed with %d\n", GetLastError());
            return;
        }

        b = AuthziFreeAuditQueue(
                hAAQ
                );

        if (!b)
        {
            wprintf(L"AuthzFreeAuditQueue failed with %d\n", GetLastError());
            return;
        }

        b = AuthzFreeHandle(
                hCache
                );

        if (!b)
        {
            wprintf(L"AuthzFreeHandle failed with %d\n", GetLastError());
            return;
        }
    }
    
    b = AuthzFreeContext(
            hCC
            );

    if (!b)
    {
        wprintf(L"AuthzFreeContext failed with %d\n", GetLastError());
        return;
    }

    b = AuthzFreeResourceManager(
            hRM
            );

    if (!b)
    {
        wprintf(L"AuthzFreeResourceManager failed with %d\n", GetLastError());
        return;
    }

    wprintf(L"Done.  Press a key.\n");
    getchar();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\wmiaudit\wmi-azaudit.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A Z E V E N T . H
//
// Contents:    Functions to construct and report Authz audit event
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------

#define AUTHZ_RM_AUDIT_USE_GIVEN_EVENT 0x0001

struct _AUTHZ_RM_AUDIT_INFO
{
    DWORD  dwFlags;

    PCWSTR szResourceManagerName;
    PSID   psidRmProcess;
    DWORD  dwRmProcessSidSize;

    HANDLE hEventSource;
    HANDLE hAuditEvent;
    HANDLE hAuditEventPropSubset;

    PVOID  pReserved;
};
typedef struct _AUTHZ_RM_AUDIT_INFO  AUTHZ_RM_AUDIT_INFO, 
                                    *PAUTHZ_RM_AUDIT_INFO;

#define AUTHZ_CLIENT_AUDIT_USE_OWN_EVENT   0x0001
#define AUTHZ_CLIENT_AUDIT_USE_GIVEN_EVENT 0x0002

struct _AUTHZ_CLIENT_AUDIT_INFO
{
    DWORD  dwFlags;
    HANDLE hAuditEvent;
    HANDLE hAuditEventPropSubset;

    PSID   psidClient;
    DWORD  dwClientSidSize;

    DWORD  dwProcessId; 
    PVOID  pReserved;
};
typedef struct _AUTHZ_CLIENT_AUDIT_INFO  AUTHZ_CLIENT_AUDIT_INFO,
                                        *PAUTHZ_CLIENT_AUDIT_INFO;

#define AUTHZ_AUDIT_USE_GIVEN_EVENT 0x0001

struct _AUTHZ_AUDIT_INFO
{
    DWORD  dwFlags;
    HANDLE hAuditEvent;
    HANDLE hAuditEventPropSubset;

    PCWSTR szOperationType;
    PCWSTR szObjectType;
    PCWSTR szObjectName;

    PVOID  pReserved;
};
typedef struct _AUTHZ_AUDIT_INFO  AUTHZ_AUDIT_INFO, 
                                 *PAUTHZ_AUDIT_INFO;

// struct AzAuditInfoInternalTag
// {
//     PCWSTR szResourceManagerName;
//     DWORD  dwFlags;
//     PVOID  pReserved;

//     HANDLE hEventSource;
//     HANDLE hAuditEvent;
//     HANDLE hAuditEventPropSubset;
// };
// typedef struct AzAuditInfoInternalTag AzAuditInfoInternal;

DWORD AzpInitRmAuditInfo(
    IN PAUTHZ_RM_AUDIT_INFO pRmAuditInfo
    );


DWORD AzpInitClientAuditInfo(
    IN PAUTHZ_RM_AUDIT_INFO pRmAuditInfo,
    IN PAUTHZ_CLIENT_AUDIT_INFO    pClientAuditInfo
    );

DWORD
AzpGenerateAuditEvent(
    IN PAUTHZ_RM_AUDIT_INFO     pRmAuditInfo,
    IN PAUTHZ_CLIENT_AUDIT_INFO pClientAuditInfo,
    IN PAUTHZI_CLIENT_CONTEXT   pClientContext,
    IN PAUTHZ_AUDIT_INFO        pAuditInfo,
    IN DWORD                    dwAccessMask
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\stress\rm\main.c ===
#include "pch.h"
#include "\nt\public\internal\ds\inc\authzi.h"


void _cdecl wmain(int argc, WCHAR * argv[])
{
    LONG                          i          = 0;
    LONG                          j          = 0;
    LONG                          Iterations = 0;
    BOOL                          b          = TRUE;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET       = NULL;
    AUTHZ_AUDIT_EVENT_HANDLE      hAE        = NULL;
    AUTHZ_RESOURCE_MANAGER_HANDLE hRM        = NULL;

    if (argc != 2)
    {
        wprintf(L"usage: %s iterations\n", argv[0]);
        exit(0);
    }

    Iterations = wcstol(argv[1], NULL, 10);

    wprintf(L"RM Stress.  Init / Free RM for %d iters.  Press a key to start.\n", Iterations);
    getchar();

    b = AuthzInitializeResourceManager(
            0,            // Flags
            NULL,
            NULL,
            NULL,
            L"Jeff's RM",
            &hRM
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeResourceManager failed with %d\n", GetLastError());
        return;
    }

    for (i = 0; i < Iterations; i++)
    {

        b = AuthziInitializeAuditEventType(
                0,
                3,
                666,
                1,
                &hAET
                );

        if (!b)
        {
            wprintf(L"AuthziInitializeAuditEventType failed with %d\n", GetLastError());
            return;
        }

        b = AuthziInitializeAuditEvent(
                0,
                hRM,
                hAET,
                NULL,
                NULL,
                INFINITE,
                L"foo",
                L"foo",
                L"foo",
                L"foo",
                &hAE
                );

        if (!b)
        {
            wprintf(L"AuthziInitializeAuditEvent failed with %d\n", GetLastError());
            return;
        }

//         for (j = 0; j < 100; j++)
//         {
//             b = AuthziLogAuditEvent(
//                     0,
//                     hAE,
//                     NULL
//                     );
//         }

        b = AuthzFreeAuditEvent(
                hAE
                );

        if (!b)
        {
            wprintf(L"AuthzFreeAuditEvent failed with %d\n", GetLastError());
            return;
        }

        b = AuthziFreeAuditEventType(
                hAET
                );

        if (!b)
        {
            wprintf(L"AuthziFreeAuditEventType failed with %d\n", GetLastError());
            return;
        }

    }

    b = AuthzFreeResourceManager(
            hRM
            );

    if (!b)
    {
        wprintf(L"AuthzFreeResourceManager failed with %d\n", GetLastError());
        return;
    }
    wprintf(L"Done.  Press a key.\n");
    getchar();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\wmiaudit\wmi-azaudit.cpp ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A Z E V E N T . C P P
//
// Contents:    Functions to construct and report Authz audit event
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------

/*
  - how to create an event buffer without creating hEventSource?

  - need to protect rm->hAuditEvent using a critsec

 */

#include "pch.h"
#pragma hdrstop

// #include <nt.h>
// #include <ntrtl.h>
// #include <nturtl.h>

// #include <windows.h>
// #include <msaudite.h>

#include "authzp.h"

#include "adtdef.h"
//#include "p2prov.h"
#include "ncevent.h"
#include "azaudit.h"


// static AzAuditInfoInternal g_RmAuditInfo;

HRESULT WINAPI AuthzEventSourceCallback(
    HANDLE hEventSource,
    EVENT_SOURCE_MSG msg,
    PVOID pUser,
    PVOID pData
    )
{
    HRESULT hr = S_OK;

    switch (msg)
    {
        case ESM_START_SENDING_EVENTS:
            break;
            
        case ESM_STOP_SENDING_EVENTS:
            break;
            
        case ESM_NEW_QUERY:
            break;
            
        case ESM_CANCEL_QUERY:
            break;
            
        case ESM_ACCESS_CHECK:
            break;

        default:
            hr = E_FAIL;
            break;
    }
    
    UNREFERENCED_PARAMETER(hEventSource);
    UNREFERENCED_PARAMETER(pUser);
    UNREFERENCED_PARAMETER(pData);

    return hr;
}

PCWSTR c_aAzpAccessEventPropertyNames[] =
{
    L"OperationType",
    L"Objecttype",
    L"ObjectName",
//     L"HandleId",
//     L"OperationId",
    L"PrimaryUserSid",
    L"ClientUserSid",
    L"AccessMask",
};
const UINT c_cAzAccessProperties =
    sizeof(c_aAzpAccessEventPropertyNames) / sizeof(PCWSTR);

CIMTYPE c_aAzpAccessEventPropertyTypes[] =
{
    CIM_STRING,
    CIM_STRING,
    CIM_STRING,
//     CIM_UINT64,
//     CIM_UINT64,
    CIM_UINT8 | CIM_FLAG_ARRAY,
    CIM_UINT8 | CIM_FLAG_ARRAY,
    CIM_UINT32,
};
const UINT c_cAzAccessPropertyTypes =
    sizeof(c_aAzpAccessEventPropertyTypes) / sizeof(CIMTYPE);

const DWORD c_aAzAccessPropIndexes[c_cAzAccessProperties] =
{ 0, 1, 2, 3, 4, 5 }; //, 6, 7 };

DWORD AzpCreateAuditEvent(
    IN  HANDLE  hEventSource,
    OUT HANDLE* phAuditEvent,
    OUT HANDLE* phAuditEventPropSubset
    )
{
    DWORD dwError = NO_ERROR;
    HANDLE hAuditEvent = INVALID_HANDLE_VALUE;
    HANDLE hAuditEventPropSubset = INVALID_HANDLE_VALUE;

    //
    // initialize out params
    //
    *phAuditEvent = INVALID_HANDLE_VALUE;
    *phAuditEventPropSubset = INVALID_HANDLE_VALUE;
    
    //
    // create the audit event
    //
    ASSERT(c_cAzAccessProperties == c_cAzAccessPropertyTypes);
    
    hAuditEvent =
    //WmiCreateEventWithProps( hEventSource,
        WmiCreateObjectWithProps( hEventSource,
                                  L"AuditEvent_AuthzAccess",
                                  WMI_CREATEOBJ_LOCKABLE,
                                  c_cAzAccessProperties,
                                  c_aAzpAccessEventPropertyNames,
                                  c_aAzpAccessEventPropertyTypes );

    if (hAuditEvent == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    hAuditEventPropSubset =
    //        WmiCreateEventPropSubset( hAuditEvent,
        WmiCreateObjectPropSubset( hAuditEvent,
                                   //WMI_CREATEOBJ_LOCKABLE,
                                   0,
                                   c_cAzAccessProperties,
                                   (DWORD*) c_aAzAccessPropIndexes );
    
    if (hAuditEventPropSubset == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    *phAuditEvent = hAuditEvent;
    *phAuditEventPropSubset = hAuditEventPropSubset;
    
Cleanup:

    if (dwError != NO_ERROR)
    {
        if (hAuditEvent != INVALID_HANDLE_VALUE)
        {
            (void) WmiDestroyObject( hAuditEvent );
        }

        if (hAuditEventPropSubset != INVALID_HANDLE_VALUE)
        {
            (void) WmiDestroyObject( hAuditEventPropSubset );
        }
    }

    return dwError;
}

DWORD AzpInitRmAuditInfo(
    IN PAUTHZ_RM_AUDIT_INFO pRmAuditInfo
    )
{
    DWORD dwError = NO_ERROR;
    HANDLE hEventSource=NULL;

    //
    // connect to the WMI event server
    //
    hEventSource =
        WmiEventSourceConnect( L"root\\default",
                               L"AuthzAuditEventProvider", //kk
                               0, 0, 0, NULL, 
                               AuthzEventSourceCallback );
    if (hEventSource == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();;
        goto Cleanup;
    }
    

    //
    // if the RM does not want to provide its own event,
    // create a default one
    //
    if (!FLAG_ON(pRmAuditInfo->dwFlags, AUTHZ_RM_AUDIT_USE_GIVEN_EVENT))
    {
        ASSERT(pRmAuditInfo->hAuditEvent == INVALID_HANDLE_VALUE);

        dwError = AzpCreateAuditEvent( hEventSource,
                                       &pRmAuditInfo->hAuditEvent,
                                       &pRmAuditInfo->hAuditEventPropSubset );
        if (dwError != NO_ERROR)
        {
            goto Cleanup;
        }
    }

Cleanup:
    
    return dwError;
}

DWORD AzpInitClientAuditInfo(
    IN  PAUTHZ_RM_AUDIT_INFO     pRmAuditInfo,
    OUT PAUTHZ_CLIENT_AUDIT_INFO pClientAuditInfo
    )
{
    DWORD dwError = NO_ERROR;

    //
    // if the client wants us to create a separate event, create one.
    //
    if ( FLAG_ON( pClientAuditInfo->dwFlags, AUTHZ_CLIENT_AUDIT_USE_OWN_EVENT ))
    {
        ASSERT(FALSE); // nyi
        ASSERT(pClientAuditInfo->hAuditEvent == INVALID_HANDLE_VALUE);

        dwError = AzpCreateAuditEvent( pRmAuditInfo->hEventSource,
                                       &pClientAuditInfo->hAuditEvent,
                                       &pClientAuditInfo->hAuditEventPropSubset );
        if (dwError != NO_ERROR)
        {
            goto Cleanup;
        }
    }

Cleanup:
    
    return dwError;
}

DWORD
AzpGenerateAuditEvent(
    IN PAUTHZ_RM_AUDIT_INFO     pRmAuditInfo,
    IN PAUTHZ_CLIENT_AUDIT_INFO pClientAuditInfo,
    IN PAUTHZI_CLIENT_CONTEXT   pClientContext,
    IN PAUTHZ_AUDIT_INFO        pAuditInfo,
    IN DWORD                    dwAccessMask
    )
{
    DWORD dwError = NO_ERROR;
    BOOL fResult = 0;
    HANDLE hAuditEvent = NULL;
    HANDLE hAuditEventPropSubset = NULL;
    PSID psidPrimaryUser = NULL;
    PSID psidResourceManager = NULL;
    DWORD dwPrimaryUserSidSize = 0;
    DWORD dwRmSidSize = 0;
    
    //
    // kk code to get to client and rm audit info
    //

    
    //
    // determine which audit-event-handle to use
    //
    if (pAuditInfo->dwFlags & AUTHZ_AUDIT_USE_GIVEN_EVENT)
    {
        ASSERT(FALSE);
        hAuditEvent = pAuditInfo->hAuditEvent;
        hAuditEventPropSubset = pAuditInfo->hAuditEventPropSubset;
    }
    else if (pClientAuditInfo->dwFlags & (AUTHZ_CLIENT_AUDIT_USE_OWN_EVENT |
                                          AUTHZ_CLIENT_AUDIT_USE_GIVEN_EVENT))
    {
        hAuditEvent = pClientAuditInfo->hAuditEvent;
        hAuditEventPropSubset = pClientAuditInfo->hAuditEventPropSubset;
    }
    else
    {
        hAuditEvent = pRmAuditInfo->hAuditEvent;
        hAuditEventPropSubset = pRmAuditInfo->hAuditEventPropSubset;
    }

    ASSERT(hAuditEvent != INVALID_HANDLE_VALUE);
    ASSERT(hAuditEventPropSubset != INVALID_HANDLE_VALUE);

    //ASSERT(pClientContext->SidCount);
    //psidPrimaryUser = pClientContext->Sids[0].Sid;
    psidPrimaryUser = pClientAuditInfo->psidClient;
    dwPrimaryUserSidSize = pClientAuditInfo->dwClientSidSize;
    
    psidResourceManager = pRmAuditInfo->psidRmProcess;
    dwRmSidSize = pRmAuditInfo->dwRmProcessSidSize;

    //    fResult = WmiSetEventProps( hAuditEventPropSubset,
    fResult = WmiSetObjectProps( hAuditEventPropSubset,
                                pAuditInfo->szOperationType,
                                pAuditInfo->szObjectType,
                                pAuditInfo->szObjectName,
                                psidPrimaryUser,
                                dwPrimaryUserSidSize,
                                psidResourceManager,
                                dwRmSidSize,
                                dwAccessMask
                                );
    if (!fResult)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    //
    // call LSA and send the event to it
    //

    fResult = WmiCommitObject( hAuditEvent );
    if (!fResult)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    
Cleanup:    

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\wmiaudit\adtdef.h ===
#ifndef _ADTDEF_H_
#define _ADTDEF_H_

//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T D E F . H
//
// Contents:    Audit related defs
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------


#define NYI FALSE

#define AdtWMINameSpace L"root\\default"

// typedef enum tag_CIMTYPE
//     {
//         CIM_ILLEGAL	= 0xfff,
//         CIM_EMPTY	= 0,
//         CIM_SINT8	= 16,
//         CIM_UINT8	= 17,
//         CIM_SINT16	= 2,
//         CIM_UINT16	= 18,
//         CIM_SINT32	= 3,
//         CIM_UINT32	= 19,
//         CIM_SINT64	= 20,
//         CIM_UINT64	= 21,
//         CIM_REAL32	= 4,
//         CIM_REAL64	= 5,
//         CIM_BOOLEAN	= 11,
//         CIM_STRING	= 8,
//         CIM_DATETIME	= 101,
//         CIM_REFERENCE	= 102,
//         CIM_CHAR16	= 103,
//         CIM_OBJECT	= 13,
//         CIM_FLAG_ARRAY	= 0x2000
//     }	CIMTYPE;

//typedef ULONG WMITYPE;

#endif // _ADTDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\wmiaudit\wmi2evt.cpp ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        W M I 2 E V T . C P P
//
// Contents:    Functions to convert WMI event into eventlog event format
//
//
// History:     
//   06-January-2000  kumarp        created
//
//------------------------------------------------------------------------

/*
   - how to find out the event name from hAuditEvent
   
   - 
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
//#include <winnt.h>
//#include <ntdef.h>
#include <stdio.h>
#include <msaudite.h>
#include <sddl.h>

#include "authzp.h"
#include "adtdef.h"
//#include "p2prov.h"
#include "ncevent.h"
#include "lsaptmp.h"

//
// Property conversion flags
//
const DWORD PCF_None = 0x00000000;
const DWORD PCF_Sid  = 0x00000001;
const DWORD PCF_  = 0x00000000;

struct _LsapAdtEventProperty
{
    PCWSTR   szName;
    CIMTYPE  Type;
    DWORD    dwFlag;
};
typedef struct _LsapAdtEventProperty LsapAdtEventProperty;


struct _LsapAdtEventMapEntry
{
    WORD     wCategory;
    DWORD    dwEventId;

    LsapAdtEventProperty* Properties;
};
typedef struct _LsapAdtEventMapEntry LsapAdtEventMapEntry;

LsapAdtEventProperty Properties_SE_AUDITID_AUTHZ[] =
{
    { L"ObjectServer",    CIM_STRING,  PCF_None },
    { L"ProcessId",       CIM_UINT32,  PCF_None },
    { L"OperationType",   CIM_STRING,  PCF_None },
    { L"Objecttype",      CIM_STRING,  PCF_None },
    { L"ObjectName",      CIM_STRING,  PCF_None },
    { L"HandleId",        CIM_UINT64,  PCF_None },
    { L"OperationId",     CIM_UINT64,  PCF_None },

    { L"PrimaryUserSid",  CIM_UINT8 | CIM_FLAG_ARRAY,  PCF_Sid },
    //             { L"PrimaryUserName", CIM_STRING,  PCF_None },
    //             { L"PrimaryDomain",   CIM_STRING,  PCF_None },
    //             { L"PrimaryLogonId",  CIM_UINT64,  PCF_None },

    { L"ClientUserSid",   CIM_UINT8 | CIM_FLAG_ARRAY,  PCF_Sid },
    //             { L"ClientUserName",  CIM_STRING,  PCF_None },
    //             { L"ClientDomain",    CIM_STRING,  PCF_None },
    //             { L"ClientLogonId",   CIM_UINT64,  PCF_None },

    { L"AccessMask",      CIM_UINT32,  PCF_None },
    { L"AdditionalInfo",  CIM_STRING,  PCF_None },
    
    { NULL,               CIM_ILLEGAL,  PCF_None },
};


LsapAdtEventMapEntry LsapAdtEvents[] =
{
    {
        SE_CATEGID_OBJECT_ACCESS,
        SE_AUDITID_OPEN_HANDLE, //kk        SE_AUDITID_AUTHZ,
        Properties_SE_AUDITID_AUTHZ
    }
};
const USHORT c_cEventMapEntries = sizeof(LsapAdtEvents) / sizeof(LsapAdtEventMapEntry);

const USHORT SE_AUDITID_FIRST = 0x200;
const USHORT SE_AUDITID_LAST = 0x2ff;
const USHORT SE_NUM_AUDITID = SE_AUDITID_LAST - SE_AUDITID_FIRST + 1;

USHORT g_EventMapRedir[SE_NUM_AUDITID];

VOID
LsapAdtInitEventMapRedir( )
{
    DWORD dwEventId;

    for (USHORT i=0; i < SE_NUM_AUDITID; i++)
    {
        dwEventId = SE_AUDITID_FIRST + i;
        g_EventMapRedir[i] = c_cEventMapEntries;
        
        for (USHORT j=0; j < c_cEventMapEntries; j++)
        {
            if ( LsapAdtEvents[j].dwEventId == dwEventId )
            {
                g_EventMapRedir[i] = j;
                break;
            }
        }
    }
}

NTSTATUS
LsapAdtInitEventMap( )
{
    NTSTATUS Status = STATUS_SUCCESS;

    LsapAdtInitEventMapRedir();
    
    return Status;
}

NTSTATUS
LsapAdtGetEventMapEntry(
    IN  DWORD dwEventId,
    OUT LsapAdtEventMapEntry** pEventMapEntry
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT usIndex;

    usIndex = g_EventMapRedir[dwEventId - SE_AUDITID_FIRST];
    ASSERT(usIndex <= c_cEventMapEntries);
    
    if ( usIndex < c_cEventMapEntries )
    {
        *pEventMapEntry = &LsapAdtEvents[usIndex];
    }
    else
    {
        *pEventMapEntry = NULL;
        Status = STATUS_NOT_FOUND;
    }

    return Status;
}

NTSTATUS
LsapAdtGetEventProperty(
    IN  HANDLE  hEvent,
    IN  PCWSTR  szPropertyName,
    IN  CIMTYPE PropertyType,
    IN  LPVOID  pData,
    IN  DWORD   dwBufferSize,
    IN  DWORD  *pdwBytesRead
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD dwIndex;
    DWORD dwError = NO_ERROR;

    //    if (!WmiAddEventProp( hEvent, szPropertyName, PropertyType, &dwIndex ))
    if (!WmiAddObjectProp( hEvent, szPropertyName, PropertyType, &dwIndex ))
    {
        goto WinErrorCleanup;
    }
    
    //if (!WmiGetEventProp( hEvent, dwIndex,
    if (!WmiGetObjectProp( hEvent, dwIndex,
                          pData, dwBufferSize, pdwBytesRead ))
    {
        goto WinErrorCleanup;
    }

Cleanup:    
    return Status;
    
WinErrorCleanup:
    dwError = GetLastError();
    //kkStatus = mapit();
    goto Cleanup;
}


NTSTATUS
LsapAdtConvertPropertyToString(
    IN  LsapAdtEventProperty* pEventProperty,
    IN  PVOID  pValue,
    IN  DWORD  dwSize,
    OUT PWSTR  szStrValue,
 IN OUT DWORD *pdwRequiredSize
    )
{
    //
    // perf: use better string allocation scheme
    //

    NTSTATUS Status = STATUS_SUCCESS;
    DWORD    dwError = NO_ERROR;
    CIMTYPE  PropertyType;
    BOOL     fIsArrary=FALSE;
    DWORD    dwRequiredSize = 0xffffffff;
    USHORT   usUnitSize = 0xffff;
    DWORD    dwPropertyFlag;
    
    PropertyType = pEventProperty->Type;
    fIsArrary = FLAG_ON( PropertyType, CIM_FLAG_ARRAY );
    PropertyType &= ~CIM_FLAG_ARRAY;
    dwPropertyFlag = pEventProperty->dwFlag;

    if ( FLAG_ON( dwPropertyFlag, PCF_Sid ))
    {
        dwRequiredSize = 256;
    }
    else
    {
        switch (PropertyType)
        {
            default:
                ASSERT(FALSE);
                break;
                
            case CIM_SINT8:
            case CIM_UINT8:
                dwRequiredSize = 4;
                usUnitSize     = 1;
                if ( fIsArrary )
                {
                    ASSERT(NYI);
                }
                break;
            
            case CIM_SINT16:
            case CIM_UINT16:
                dwRequiredSize = 8;
                usUnitSize     = 2;
                if ( fIsArrary )
                {
                    ASSERT(NYI);
                }
                break;
            
            case CIM_SINT32:
            case CIM_UINT32:
                dwRequiredSize = 12;
                usUnitSize     = 4;
                if ( fIsArrary )
                {
                    ASSERT(NYI);
                }
                break;
            
            case CIM_SINT64:
            case CIM_UINT64:
                dwRequiredSize = 24;
                usUnitSize     = 8;
                if ( fIsArrary )
                {
                    ASSERT(NYI);
                }
                break;
            
            case CIM_STRING:
                dwRequiredSize = (dwSize / sizeof(WCHAR)) + 1;
                usUnitSize     = 1;
                if ( fIsArrary )
                {
                    ASSERT(NYI);
                }
                break;
            
            case CIM_BOOLEAN:
            case CIM_REAL32:
            case CIM_REAL64:
            case CIM_DATETIME:
            case CIM_REFERENCE:
            case CIM_CHAR16:
            case CIM_OBJECT:
                ASSERT(NYI);
                break;
        }
    }

    ASSERT(dwRequiredSize < 0xffffffff);

    if (*pdwRequiredSize < dwRequiredSize)
    {
        Status = STATUS_BUFFER_OVERFLOW;
        *pdwRequiredSize = dwRequiredSize;
        goto Cleanup;
    }

    dwRequiredSize = *pdwRequiredSize;
    
    if ( FLAG_ON( dwPropertyFlag, PCF_Sid ))
    {
        Status = LsapRtlConvertSidToString( (PSID) pValue, szStrValue,
                                            &dwRequiredSize );
        
        if ( !NT_SUCCESS( Status ))
        {
            goto WinErrorCleanup;
        }
    }
    else
    {
        switch (PropertyType)
        {
            default:
                ASSERT(FALSE);
                break;
                
            case CIM_SINT8:
                wsprintf( szStrValue, L"%d", (INT) *((CHAR *) pValue));
                break;
            
            case CIM_UINT8:
                wsprintf( szStrValue, L"%d", (UINT) *((UCHAR *) pValue));
                break;
            
            case CIM_SINT16:
                wsprintf( szStrValue, L"%d", (INT) *((SHORT *) pValue));
                break;
            
            case CIM_UINT16:
                wsprintf( szStrValue, L"%d", (UINT) *((USHORT *) pValue));
                break;
            
            case CIM_SINT32:
                wsprintf( szStrValue, L"%d", *((INT *) pValue));
                break;
            
            case CIM_UINT32:
                wsprintf( szStrValue, L"%d", *((UINT *) pValue));
                break;
            
            case CIM_SINT64:
                wsprintf( szStrValue, L"%I64d", (INT64) *((UCHAR *) pValue));
                break;
            
            case CIM_UINT64:
                wsprintf( szStrValue, L"%I64d", (UINT64) *((UCHAR *) pValue));
                break;
            
            case CIM_STRING:
                dwRequiredSize = (dwSize / sizeof(WCHAR)) + 1;
                usUnitSize     = 1;
                if ( fIsArrary )
                {
                    ASSERT(NYI);
                }
                break;
            
            case CIM_BOOLEAN:
            case CIM_REAL32:
            case CIM_REAL64:
            case CIM_DATETIME:
            case CIM_REFERENCE:
            case CIM_CHAR16:
            case CIM_OBJECT:
                ASSERT(NYI);
                break;
        }
    }


    
Cleanup:
    
    return Status;

WinErrorCleanup:
    dwError = GetLastError();
    //kk Status = mapit();
    goto Cleanup;
}
    
#define MAX_NUM_EVENTLOG_STRINGS 32
#define MAX_PROPERTY_SIZE 512

NTSTATUS
LsapAdtConvertAndReportEvent(
    IN  HANDLE hAuditEvent,
    IN  HANDLE hEventLog
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD    dwError = NO_ERROR;
    WORD     wEventType = 0;
    WORD     wCategory = 0;
    DWORD    dwEventId = 0;
    PSID     pUserSid = NULL;
    WORD     wNumStrings = 0;
    DWORD    dwDataSize = 0;
    PWSTR    pStrings[MAX_NUM_EVENTLOG_STRINGS] = { 0 };
    PVOID    pRawData = NULL;
    DWORD    dwEventIdIndex = 0;
    DWORD    dwNumBytesRead;
    DWORD    dwPropertyIndex = 0;
    PCWSTR   szPropertyName;
    CIMTYPE  PropertyType;
    BYTE     PropertyVal[MAX_PROPERTY_SIZE];
    WORD     wStringIndex=0;
    DWORD    dwRequiredSize;
    
    LsapAdtEventMapEntry* pEventMapEntry = NULL;
    LsapAdtEventProperty* pEventProperty = NULL;

    Status = LsapAdtGetEventProperty( hAuditEvent, L"AuditId", CIM_UINT32,
                                      &dwEventId, sizeof(dwEventId),
                                      &dwNumBytesRead );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = LsapAdtGetEventMapEntry( dwEventId, &pEventMapEntry );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    ASSERT( pEventMapEntry->dwEventId == dwEventId );
    
    pEventProperty = pEventMapEntry->Properties;
    
    while ( ( szPropertyName = pEventProperty->szName ) != NULL )
    {
        PropertyType = pEventProperty->Type;

        Status = LsapAdtGetEventProperty( hAuditEvent,
                                          szPropertyName,
                                          PropertyType,
                                          PropertyVal, MAX_PROPERTY_SIZE,
                                          &dwNumBytesRead );
        
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        // kk alloc strings, init dwRequiredSize
        Status = LsapAdtConvertPropertyToString( pEventProperty,
                                                 PropertyVal,
                                                 dwNumBytesRead,
                                                 pStrings[wNumStrings],
                                                 &dwRequiredSize );
        
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        pEventProperty++;
        wNumStrings++;
    }
                                      
        
    dwError = ReportEvent( hEventLog, wEventType, wCategory, dwEventId,
                           pUserSid, wNumStrings, dwDataSize,
                           (PCWSTR*) pStrings, pRawData );
    
    if (!dwError)
    {
        goto WinErrorCleanup;
    }

    
Cleanup:
    
    return Status;

WinErrorCleanup:
    dwError = GetLastError();
    //kkStatus = mapit();
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\adstore.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    adstore.cxx

Abstract:

    This file implements a AD policy store provider

Author:

    Chaitanya Upadhyay (chaitu) Aug-2001

--*/


#include "pch.hxx"

#define AZD_COMPONENT     AZD_AD
#include <ntldap.h>
#include <ntdsapi.h>
#include <wininet.h>
#include <string.h>
#include <stdlib.h>
#include <ntsam.h>
#include <iads.h>
#include "stdafx.h"
#include "resource.h"
#include "azdisp.h"
#include "adstore.hxx"


//
// Procedures implemented by the LDAP provider and exported to the core
//



DWORD
WINAPI
AzpADPersistOpen(
    IN LPCWSTR PolicyUrl,
    IN AZPE_OBJECT_HANDLE pAzAuthorizationStore,
    IN ULONG lFlags,
    IN BOOL bCreatePolicy,
    OUT PAZPE_PERSIST_CONTEXT PersistContext,
    OUT LPWSTR *pwszTargetMachine
    );

DWORD
WINAPI
AzpADPersistUpdateCache(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN ULONG lPersistFlags,
    OUT ULONG * pulUpdated
    );

DWORD
WINAPI
AzpADPersistUpdateChildrenCache(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags
    );

VOID
WINAPI
AzpADPersistClose(
    IN AZPE_PERSIST_CONTEXT PersistContext
    );

DWORD
WINAPI
AzpADPersistSubmit(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN AZPE_OBJECT_HANDLE pObject,
    IN ULONG lFlags,
    IN BOOLEAN bDelete
    );

DWORD
WINAPI
AzpADPersistRefresh(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags
    );

DWORD
AdCheckSecurityPrivilege(
    IN PAZP_AD_CONTEXT pContext
    );
    
DWORD
AzpADBuildNameSearchFilter(
    IN AZPE_OBJECT_HANDLE pObject,
    IN ULONG lPersistFlags,
    OUT PWSTR * ppSearchFilter
    );

//
// Define a provider info telling the core our interface
//
AZPE_PROVIDER_INFO LdapProviderInfo = {
    AZPE_PROVIDER_INFO_VERSION_2,
    AZ_AD_PROVIDER_NAME,

    AzpADPersistOpen,
    AzpADPersistUpdateCache,
    AzpADPersistClose,
    AzpADPersistSubmit,
    AzpADPersistRefresh,
    AzpADPersistUpdateChildrenCache
};

PAZPE_AZROLES_INFO AdAzrolesInfo;

//
// AD store APIs exposed to the persistence manager layer
//

DWORD
AdProviderInitialize(
    IN PAZPE_AZROLES_INFO AzrolesInfo,
    OUT PAZPE_PROVIDER_INFO *ProviderInfo
    )
/*++

Routine Description

    Routine to initialize the XML provider

Arguments

    AzrolesInfo - Specifies the interface to routines in azroles.dll

    ProviderInfo - Returns a pointer to the provider info for the provider

Return Value

    NO_ERROR - Provider was properly initialized
    ERROR_UNKNOWN_REVISION - AzrolesInfo is a version the provider doesn't support

--*/
{
    //
    // Ensure the azroles info is a version we understand
    //

    if ( AzrolesInfo->AzrolesInfoVersion < AZPE_AZROLES_INFO_VERSION_2 ) {
        return ERROR_UNKNOWN_REVISION;
    }


    AdAzrolesInfo = AzrolesInfo;
    *ProviderInfo = &LdapProviderInfo;
    return NO_ERROR;
}

BOOL
AzpPressOn (
    IN DWORD dwStatusCode,
    IN ULONG ulPersistFlags,
    IN OUT LPDWORD SavedStatusCode
    )
/*++

Routine Description:

    This routine test if we should presson in case of errors.

Arguments:

    dwStatusCode    - The status code

    ulPersistFlags  - Our persist flag. At current implementation, presson
                      should only happen if we are updating cache.

    SavedStatusCode - Specifies the status code that will eventually be returned to
        the AzRoles persist engine.  On input, specifies the status from prior operations.
        On output, is updated to include dwStatusCode.


Return Value:

    True if the condition indicates that we should presson. False otherwise.

Note:

    1. Presson should only happen when we are out of resource and the persistence
       operation is a cache update.
    2. We will need to add more "out of resource" error codes as we discover more.
    3. Caller, in general, should return the error code even though we presson.

--*/
{
    //
    // If the previous status code is success,
    //  update it to reflect the new error.
    //

    if ( *SavedStatusCode == NO_ERROR ) {
        *SavedStatusCode = dwStatusCode;
    }

    //
    // Tell the caller whether to continue or not
    //

    if ( dwStatusCode == NO_ERROR ||
         (ulPersistFlags & AZPE_FLAGS_PERSIST_UPDATE_CACHE) ||
         (ulPersistFlags & AZPE_FLAGS_PERSIST_UPDATE_CHILDREN_CACHE) &&
         dwStatusCode != ERROR_NOT_ENOUGH_MEMORY &&
         dwStatusCode != ERROR_OUTOFMEMORY &&
         dwStatusCode != NTE_NO_MEMORY         // crypto service provider
         )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

DWORD
AzpADSetObjectOptions(
    IN PAZP_AD_CONTEXT pContext,
    IN AZPE_OBJECT_HANDLE pObject,
    IN ULONG lPersistFlags,
    IN BOOL IsWritable,
    IN BOOL CanCreateChildren
    )
/*++

Routine Description:

        This routine creates a new object of type object type (if not
        AzAuthorizationStore) and populates it with common data information such as
        description, GUID (for non authorization store objects).

Arguments:

        pContext - Context describing the store

        pObject - Handle to the to set options on

        lPersistFlags - lPersistFlags from the persist engine describing the
                operation

        IsWritable - TRUE if the current caller can write the object

        CanCreateChildren - TRUE is the current caller can create children under the object

Return Values:

        NO_ERROR - The object was created and populated successfully

--*/
{
    DWORD WinStatus = 0;

    ULONG ObjectOptions = 0;
    ULONG ObjectType = AdAzrolesInfo->AzpeObjectType(pObject);


    if ( IsWritable ) {
        ObjectOptions |= AZPE_OPTIONS_WRITABLE;
    }

    if ( IsContainerObject( ObjectType )) {
        ObjectOptions |= AZPE_OPTIONS_SUPPORTS_DACL;
        ObjectOptions |= AZPE_OPTIONS_SUPPORTS_SACL;
    }

    if ( IsDelegatorObject( ObjectType )) {
        ObjectOptions |= AZPE_OPTIONS_SUPPORTS_DELEGATION;
    }

    if ( ObjectType == OBJECT_TYPE_AZAUTHSTORE && pContext->HasSecurityPrivilege ) {
        ObjectOptions |= AZPE_OPTIONS_HAS_SECURITY_PRIVILEGE;
    }

    if ( ObjectType == OBJECT_TYPE_AZAUTHSTORE ) {
        ObjectOptions |= AZPE_OPTIONS_SUPPORTS_LAZY_LOAD;
    }

    if ( IsContainerObject( ObjectType ) && CanCreateChildren ) {
        ObjectOptions |= AZPE_OPTIONS_CREATE_CHILDREN;
    }

    //
    // Set the various object options
    //

    WinStatus = AdAzrolesInfo->AzpeSetObjectOptions(
        pObject,
        lPersistFlags,
        ObjectOptions );

    if ( WinStatus != NO_ERROR ) {

        AzPrint(( AZD_AD,
                  "AzpADSetObjectOptions: AzpeSetObjectOptions failed"
                  ": %ld\n",
                  WinStatus
                  ));

    }

    return WinStatus;
}

DWORD
AzpADPersistOpenEx(
    IN LPCWSTR PolicyUrl,
    IN PAZP_AD_CONTEXT OldAdContext,
    IN AZPE_OBJECT_HANDLE pAzAuthorizationStore,
    IN ULONG lPersistFlags,
    IN BOOL bCreatePolicy,
    OUT PAZPE_PERSIST_CONTEXT PersistContext OPTIONAL,
    OUT LPWSTR *pwszTargetMachine OPTIONAL
    )
/*++

Routine Description:

    This routine is shared betwen AzpADPersistOpen and AzpADPersistUpdateCache.

    This routine reads the authorization policy from the database, or
    initializes the pAzAuthorizationStore object for policy to be written to the
    object.

    Check for existing LDAP handles in the cache.

    On entry, pAzAuthorizationStore->PersistCritSect must be locked.

Arguments:

    PolicyUrl - Specifies the location of the policy store

    OldADContext - On AzUpdateCache, specifies a context from a previous call

    pAzAuthorizationStore - Specifies the policy database that is to be read.

    lPersistFlags - lPersistFlags from the persist engine describing the
                    operation
                    AZPE_FLAGS_PERSIST_OPEN - Call is the original AzInitialize
                    AZPE_FLAGS_PERSIST_UPDATE_CACHE - Call is an AzUpdateCache

    bCreatePolicy - TRUE if the policy database is to be created.
                    FALSE if the policy database already exists

    PersistContext - On Success, returns a context that should be passed on all
        subsequent calls.
        The caller should call XMLPersistClose to free this context.
        This parameter is only returned for AzInitialize calls

    pwszTargetMachine - pointer to the target machine name where account resolution
                        should occur. This should be the machine where the ldap data
                        is stored.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    ERROR_CURRENT_DOMAIN_NOT_ALLOWED - The current domain will not work for
               this version of azroles.  This may be because of two
               reasons:
                    1) The domain is not .Net native
                    2) The schema is incompatible
    Other status codes

--*/
{
    DWORD WinStatus = 0;

    PAZP_AD_CONTEXT pADContext = NULL;
    BOOL bCloseADContext = FALSE;

    ULONG LdapStatus = 0;

    ULONG i = 0;

    ULONG PolicyUrlSize;
    LDAP_URL_COMPONENTS LdapUrlComponents;

    BOOL bFreeLdapUrlComps = FALSE;

    //
    // Validation
    //

    ASSERT( pAzAuthorizationStore != NULL );

    //
    // On an Open, allocate a new AD context
    //

    if ( lPersistFlags & AZPE_FLAGS_PERSIST_OPEN ) {

        //
        // Initialization of context describing this provider
        //

        PolicyUrlSize = (ULONG)((wcslen(PolicyUrl) + 1) * sizeof(WCHAR));
        pADContext = (PAZP_AD_CONTEXT) AzpAllocateHeap(
                                           sizeof( AZP_AD_CONTEXT ) + PolicyUrlSize,
                                           "AdPlCtxt" );

        if ( pADContext == NULL ) {

            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;

        }

        RtlZeroMemory( pADContext, sizeof( AZP_AD_CONTEXT ) );
        pADContext->referenceCount = 1;
        bCloseADContext = TRUE;

        //
        // Cache the PolicyUrl
        //

        pADContext->PolicyUrl = (LPWSTR)(pADContext+1);
        RtlCopyMemory( pADContext->PolicyUrl,
                       PolicyUrl,
                       PolicyUrlSize );

        //
        // Cache the authorization store handle
        //

        pADContext->AzStoreHandle = pAzAuthorizationStore;

        //
        // Set the server controls
        //

        for ( i = 0; i < AZ_AD_MAX_SERVER_CONTROLS; i++ ) {

            pADContext->pLdapControls[i] =
                (PLDAPControl) AzpAllocateHeap( sizeof( LDAPControl ), "AdLdapCt" );

            if ( pADContext->pLdapControls[i] == NULL ) {

                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            pADContext->pLdapControls[i]->ldctl_oid = AZ_AD_SERVER_CONTROLS[i];
            pADContext->pLdapControls[i]->ldctl_iscritical = TRUE;
            pADContext->pLdapControls[i]->ldctl_value.bv_len = 0;
            pADContext->pLdapControls[i]->ldctl_value.bv_val = NULL;
        }

        pADContext->pLdapControls[i] = NULL;

        //
        // On an UpdateCache, use the existing AD context
        //
    } else {

        //
        // Simply increment the reference count to it
        //

        if (NULL != OldAdContext)
        {
            pADContext = OldAdContext;
            pADContext->referenceCount++;
            bCloseADContext = TRUE;
        }
        else
        {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }


    //
    // Check context for existing LDAP handle to DC.
    //
    // If none exists (or CreatePolicy is TRUE), create a new handle
    // and bind to it.
    // Cache the new handle. Set the reference count to it.
    // If it does exist already in cache, simply increment
    // the reference count.
    // The LDAP handle is cached in the PersistContext.
    //

    if ( pADContext->ld == NULL ) {

        //
        // Crack the policy URL
        //
        RtlZeroMemory( &LdapUrlComponents, sizeof( LDAP_URL_COMPONENTS ) );

        if ( !AzpLdapCrackUrl( &pADContext->PolicyUrl,
                               &LdapUrlComponents ) ) {

            WinStatus = GetLastError();
            AzPrint(( AZD_AD,
                      "AzpADPersistOpenEx: AzpLdapCrackUrl failed on %ws: %ld\n",
                      PolicyUrl,
                      WinStatus
                      ));
            goto Cleanup;
        }

        bFreeLdapUrlComps = TRUE;

        //
        // Now initialize the LDAP handle
        //

        pADContext->ld = ldap_init(
                             LdapUrlComponents.pszHost,
                             LdapUrlComponents.Port
                             );

        if ( pADContext->ld == NULL ) {

            LdapStatus = LdapGetLastError();

            AzPrint(( AZD_AD,
                      "AzpADPersistOpenEx: ldap_init failed on %ws: %ld: %s\n",
                      LdapUrlComponents.pszHost,
                      LdapStatus,
                      ldap_err2stringA( LdapStatus )
                      ));

            WinStatus = LdapMapErrorToWin32( LdapStatus );
            goto Cleanup;
        }

        //
        // Set our default options
        //

        WinStatus = AzpADSetDefaultLdapOptions(pADContext->ld,
                                               NULL // no domain name available
                                               );
        if (WinStatus != NO_ERROR)
        {
            AzPrint(( AZD_AD,
                      "AzpADPersistOpenEx: AzpADSetDefaultLdapOptions failed on %ws: %ld\n",
                      LdapUrlComponents.pszHost,
                      WinStatus
                      ));

            goto Cleanup;
        }

        //
        // Bind to the DC
        //

        LdapStatus = ldap_bind_s( pADContext->ld,
                                  NULL, // No DN of account to authenticate as
                                  NULL, // Default credentials
                                  LDAP_AUTH_NEGOTIATE
                                  );

        if ( LdapStatus != LDAP_SUCCESS ) {


            WinStatus = LdapMapErrorToWin32( LdapStatus );
            AzPrint(( AZD_AD,
                      "AzpADPersistOpenEx: ldap_bind failed on %ws: %ld\n",
                      LdapUrlComponents.pszHost,
                      WinStatus
                      ));

            goto Cleanup;
        }

        //
        // We need to make sure that the DC is in a .Net native domain at least
        // It is also needed that the proper schema has been installed in the
        // DC.  If either of these is not true, the error needs to be reported
        // back to the user.
        //

        WinStatus = AzpADCheckCompatibility(
                        pADContext->ld
                        );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpADPersistOpenEx: AzpCheckDomainVersion failed"
                      " on %ws: %ld",
                      LdapUrlComponents.pszDN,
                      WinStatus
                      ));

            goto Cleanup;
        }

        //
        // Check for Policy existence
        // Should not exist if bCreatePolicy is TRUE and should exist
        // if bCreatePolicy is FALSE
        //

        WinStatus = AzpCheckPolicyExistence(
                        pADContext->ld,
                        LdapUrlComponents.pszDN,
                        bCreatePolicy
                        );

        if ( WinStatus != NO_ERROR ) {

            goto Cleanup;
        }

        //
        // Now cache the DN
        //

        if ( pADContext->pContextInfo == NULL ) {
            pADContext->pContextInfo = (PWCHAR)
                AzpAllocateHeap( (wcslen( LdapUrlComponents.pszDN ) + 1) *
                                 sizeof( WCHAR ), "AdCtxIn" );

            if ( pADContext->pContextInfo == NULL ) {

                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            wcscpy( pADContext->pContextInfo, LdapUrlComponents.pszDN );
        }
    }

    //
    // pwszTargetMachine is an optional parameter to this function
    // if target machine name is requested, get the information from ldap (pADContext->ld)
    //

    if ( pwszTargetMachine ) {

        //
        // the host name that ldap_init connected to should be available from ldap_get_option
        // pwszServerName points to the internal structure of ldap ID. No memory is allocated
        //
        PWCHAR pwszServerName=NULL;

        LdapStatus = ldap_get_optionW(pADContext->ld,
                                      LDAP_OPT_HOST_NAME,
                                      &pwszServerName
                                      );

        if ( LdapStatus != LDAP_SUCCESS ) {


            WinStatus = LdapMapErrorToWin32( LdapStatus );
            AzPrint(( AZD_AD,
                      "AzpADPersistOpenEx: ldap_get_option failed : %ld\n",
                      WinStatus
                      ));

            goto Cleanup;

        } else {

            *pwszTargetMachine = (PWSTR)
                AdAzrolesInfo->AzpeAllocateMemory( (wcslen(pwszServerName) + 1) * sizeof( WCHAR ) );

            if ( *pwszTargetMachine ) {

                wcscpy( *pwszTargetMachine, pwszServerName );

            } else {

                WinStatus = ERROR_NOT_ENOUGH_MEMORY;

                goto Cleanup;
            }
        }
    }

    //
    // On an open,
    //  determine whether the current user has SE_SECURITY_PRIVILEGE on the target machine
    //

    if ( lPersistFlags & AZPE_FLAGS_PERSIST_OPEN ) {
        WinStatus = AdCheckSecurityPrivilege( pADContext );

        if ( WinStatus == NO_ERROR ) {
            pADContext->HasSecurityPrivilege = TRUE;
        } else if ( WinStatus == ERROR_DS_INSUFF_ACCESS_RIGHTS ) {
            pADContext->HasSecurityPrivilege = FALSE;
        } else {
            goto Cleanup;
        }
    }

    //
    // Start reading the AD policy store if bCreatePolicy is FALSE or
    // if we want to update the cache
    //

    if ( (!bCreatePolicy && (lPersistFlags & AZPE_FLAGS_PERSIST_OPEN) != 0) ||
         (lPersistFlags & AZPE_FLAGS_PERSIST_UPDATE_CACHE) != 0 ) {

        WinStatus = AzpReadADStore( pADContext,
                                    pAzAuthorizationStore,
                                    lPersistFlags
                                    );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpADPersistOpenEx: AzpReadADStore failed: %ld\n",
                      WinStatus
                      ));

            goto Cleanup;

        }

        //
        // If we didn't read the adstore,
        //  we still need to tell the core about the authorization store object
        //

    } else {
        LONG MajorVersion = 1;
        LONG MinorVersion = 0;

        //
        // Tell the core that this is a version 1.0 store
        //

        WinStatus = AdAzrolesInfo->AzpeSetProperty(
                                       pAzAuthorizationStore,
                                       lPersistFlags,
                                       AZ_PROP_AZSTORE_MAJOR_VERSION,
                                       &MajorVersion );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = AdAzrolesInfo->AzpeSetProperty(
                                       pAzAuthorizationStore,
                                       lPersistFlags,
                                       AZ_PROP_AZSTORE_MINOR_VERSION,
                                       &MinorVersion );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        //
        // Tell the core the object options
        //
        WinStatus = AzpADSetObjectOptions(
                        pADContext,
                        pAzAuthorizationStore,
                        lPersistFlags,
                        TRUE,  // A created ADstore is assumed to be writable
                        TRUE
                        );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }
    }

    //
    // On an Initialize,
    //  return the context to the caller.
    //

    if (AZPE_FLAGS_PERSIST_OPEN & lPersistFlags) {

        // return the persist context to the caller
        *PersistContext = (AZPE_PERSIST_CONTEXT) pADContext;
        bCloseADContext = FALSE;

    }
    WinStatus = NO_ERROR;

 Cleanup:
    //
    // On error,
    //  close the LDAP handle
    //

    if ( WinStatus != NO_ERROR &&
         pADContext != NULL &&
         pADContext->ld != NULL ) {

        ldap_unbind_s ( pADContext->ld );
        pADContext->ld = NULL;
    }

    if ( bCloseADContext ) {
        AzpADPersistClose( (AZPE_PERSIST_CONTEXT)pADContext );
    }


    if ( bFreeLdapUrlComps ) {

        AzpLdapFreeUrlComponents( &LdapUrlComponents );
    }

    if ( WinStatus != NO_ERROR &&
         pwszTargetMachine && *pwszTargetMachine ) {

        AdAzrolesInfo->AzpeFreeMemory( *pwszTargetMachine );
        *pwszTargetMachine = NULL;
    }

    AdAzrolesInfo->AzpeObjectFinished( pAzAuthorizationStore, WinStatus );

    return WinStatus;
}

DWORD
AzpADPersistOpen(
    IN LPCWSTR PolicyUrl,
    IN AZPE_OBJECT_HANDLE pAzAuthorizationStore,
    IN ULONG lPersistFlags,
    IN BOOL fCreatePolicy,
    OUT PAZPE_PERSIST_CONTEXT PersistContext,
    OUT LPWSTR *pwszTargetMachine
    )
/*++

Routine Description:

    This routine submits reads the authz policy database from storage.
    This routine also reads the policy database into cache.

    On Success, the caller should call AzpADPersistClose to free any resources
        consumed by the open.

    On entry, AzAuthorizationStore->PersistCritSect must be locked.

Arguments:

    PolicyUrl - Specifies the location of the policy store

    pAzAuthorizationStore - Specifies the policy database that is to be read.

    lPersistFlags - lPersistFlags from the persist engine describing the operation
        AZPE_FLAGS_PERSIST_OPEN - Call is the original AzInitialize

    fCreatePolicy - TRUE if the policy database is to be created.
        FALSE if the policy database already exists

    PersistContext - On Success, returns a context that should be passed on all
        subsequent calls.
        The caller should call AzpADPersistClose to free this context.

    pwszTargetMachine - pointer to the target machine name where account resolution
                        should occur. This should be the machine where the ldap data
                        is stored.
Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    ERROR_CURRENT_DOMAIN_NOT_ALLOWED - The current domain will not work for
               this version of azroles.  This may be because of two
               reasons:
                    1) The domain is not .Net native
                    2) The schema is incompatible
    Other status codes

--*/
{

    //
    // Call the worker routine
    //

    AZASSERT(AZPE_FLAGS_PERSIST_OPEN & lPersistFlags);

    return AzpADPersistOpenEx(
               PolicyUrl,
               NULL,    // No previous context
               pAzAuthorizationStore,
               lPersistFlags,
               fCreatePolicy,
               PersistContext,
               pwszTargetMachine );

}

DWORD
AzpADPersistUpdateCache(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN ULONG lPersistFlags,
    OUT ULONG * pulUpdatedFlag
    )
/*++

Routine Description:

    This routine updates the cache to reflect the current contents of the
    policy database.

    On entry, AzAuthorizationStore->PersistCritSect must be locked.

Arguments:

    PersistContext - Specifies the policy database that is to be updated

    lPersistFlags - lPersistFlags from the persist engine describing the operation
        AZPE_FLAGS_PERSIST_UPDATE_CACHE - Call is an AzUpdateCache

    pulUpdatedFlag - Passing back information whether the function call has truly
                    caused an update. Due to possible efficient updateCache
                    implementation by providers, it may decide to do nothing.
                    Currently, we only one bit (AZPE_FLAG_CACHE_UPDATE_STORE_LEVEL) to
                    indicate that the update is actually carried out.


Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    PAZP_AD_CONTEXT pADContext = (PAZP_AD_CONTEXT)PersistContext;

    //
    // Call the worker routine
    //

    AZASSERT(AZPE_FLAGS_PERSIST_UPDATE_CACHE & lPersistFlags);
    AZASSERT( pADContext != NULL );
    AZASSERT( pulUpdatedFlag != NULL );

    //
    // Assume no real update
    //

    *pulUpdatedFlag = 0;

    BOOL bNeedUpdate;

    //
    // This call will also update our context's uSNChanged attribute
    // because we know that this needs to be updated.
    //

    DWORD dwStatus = AzpADStoreHasUpdate(TRUE, pADContext, &bNeedUpdate);

    if (NO_ERROR != dwStatus)
    {
        goto error;
    }
    else if (bNeedUpdate)
    {
        //
        // Call the worker routine
        //

        dwStatus = AzpADPersistOpenEx(
                                    pADContext->PolicyUrl,
                                    pADContext,
                                    pADContext->AzStoreHandle,
                                    lPersistFlags,
                                    FALSE, // Don't create the store
                                    NULL,
                                    NULL ); // Don't return a new persist context

        if (NO_ERROR == dwStatus)
        {
            *pulUpdatedFlag = AZPE_FLAG_CACHE_UPDATE_STORE_LEVEL;
        }
    }

error:

    return dwStatus;
}

DWORD
AzpADPersistUpdateChildrenCache(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags
    )
/*++

Routine Description:

    This routine updates the children (upto one level) into the cache.

Arguments:

    PersistContext - Specifies the policy database's context

    AzpeObjectHandle - Handle to the objects whose children need to be updated

    lPersistFlags - lPersistFlags from the persist engine describing the operation
        AZPE_FLAGS_PERSIST_UPDATE_CHILDREN_CACHE - Call is an AzUpdateChildrenCache

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status code

--*/
{
    DWORD WinStatus = 0;
    DWORD WinStatusActual = 0;

    LDAPSearch*  pSearchHandle = NULL;

    PWCHAR pDN = NULL;

    AZ_AD_CHILD_FILTERS ChildFilters;

    PAZP_AD_CONTEXT pADContext = (PAZP_AD_CONTEXT) PersistContext;

    ULONG ObjectType = AdAzrolesInfo->AzpeObjectType( AzpeObjectHandle );

    ULONG i = 0;

    //
    // Build the DN for the parent object
    //

    WinStatus = AzpADBuildDN(
        pADContext,
        AzpeObjectHandle,
        &pDN,
        NULL, // no parent DN
        FALSE, // parent DN of AzAuthorizationStore object not needed
        NULL // no child object container needs to be built
        );

    if ( WinStatus != NO_ERROR ) {

        AzPrint(( AZD_AD,
                  "AzpADPersistUpdateChildrenCache: AzpADBuildDN failed: %ld\n",
                  WinStatus
                  ));
        goto Cleanup;
    }

    //
    // If the current object is an AzApplication object, then read the Scope object
    // children if there are any
    //

    if ( ObjectType == OBJECT_TYPE_APPLICATION ) {

        pSearchHandle = ldap_search_init_page(
            pADContext->ld,
            pDN,
            LDAP_SCOPE_ONELEVEL,
            ApplicationChildFilters[0].Filter,
            AllObjectReadAttrs[ApplicationChildFilters[0].lObjectType],
            FALSE,
            pADContext->pLdapControls,
            NULL,
            0,
            0,
            NULL
            );

        if ( pSearchHandle == NULL ) {

            WinStatus = LdapMapErrorToWin32( LdapGetLastError() );

            if (!AzpPressOn(WinStatus, lPersistFlags, &WinStatusActual) ) {

                AzPrint(( AZD_AD,
                          "AzpADPersistUpdateChildrenCache: failed to init paged search handle: %ld\n",
                          WinStatus
                          ));

                goto Cleanup;

            }
        } else {

            WinStatus = AzpADReadPagedResult(
                pADContext,
                pSearchHandle,
                AzpeObjectHandle,
                ApplicationChildFilters[0].lObjectType,
                lPersistFlags
                );

            if ( !AzpPressOn( WinStatus, lPersistFlags, &WinStatusActual) ) {

                AzPrint(( AZD_AD,
                          "AzpADPersistUpdateChildrenCache: failed to read paged results: %ld\n",
                          WinStatus
                          ));

                goto Cleanup;

            }

            ldap_search_abandon_page( pADContext->ld, pSearchHandle );
            pSearchHandle = NULL;

        } // if ( pSearchHandle )

        i = 1;

        ChildFilters = ApplicationChildFilters[i];

    } else { // if ( OBJECT_TYPE_APPlCATION )

        ChildFilters = ScopeChildFilters[i];
    }

    while ( ChildFilters.Filter != NULL ) {

        WinStatus = AzpReadADObjectContainer(
            pADContext,
            pDN,
            ChildFilters.pContainerPrefix,
            ChildFilters.lPrefixLength,
            ChildFilters.Filter,
            ChildFilters.lObjectType,
            AzpeObjectHandle,
            lPersistFlags
            );

        if ( !AzpPressOn(WinStatus, lPersistFlags, &WinStatusActual) ) {

            AzPrint(( AZD_AD,
                      "AzpADReadHasChildrenObject: Reading of Child container object"
                      "failed: %ld\n",
                      WinStatus
                      ));

            goto Cleanup;
        }

        i++;

        if ( ObjectType == OBJECT_TYPE_APPLICATION ) {

            ChildFilters = ApplicationChildFilters[i];

        } else {

            ChildFilters = ScopeChildFilters[i];

        }

    } // while ( ChildFilters != NULL )

 Cleanup:

    //
    // Need to release these resources
    //

    if ( pSearchHandle != NULL ) {

        ldap_search_abandon_page( pADContext->ld, pSearchHandle );
    }

    if ( pDN != NULL ) {

        AzpFreeHeap( pDN );
    }

    return WinStatusActual;
}

VOID
AzpADPersistClose(
    IN AZPE_PERSIST_CONTEXT PersistContext
    )
/*++

Routine Description:

        This routine closes LDAP handle to the AD policy store.
        The reference count to the LDAP handle is simply decremented.
        If the reference count is 0, unbind from the AD policy store and
        release the memory allocated for the handle.

        On entry, pAzAuthorizationStore->PersistCritSect must be locked.

Arguments:

        pAzAuthorizationStore - Handle to the AzAuthorizationManager object caching the
                        LDAP handle

Return Value:

        None
--*/
{
    PAZP_AD_CONTEXT pADContext = NULL;

    ULONG i = 0;

    //
    // Validation
    //

    pADContext = (PAZP_AD_CONTEXT)PersistContext;

    ASSERT( pADContext != NULL );


    //
    // Decrement the reference count
    //

    pADContext->referenceCount--;

    //
    // If it is zero, then unbind from the AD policy store, and
    // release allocated memory to context
    //

    if ( pADContext->referenceCount == 0 ) {

        if ( pADContext->ld != NULL ) {
            ldap_unbind_s ( pADContext->ld );
        }

        for ( i = 0; i < AZ_AD_MAX_SERVER_CONTROLS; i++ ) {

            if ( pADContext->pLdapControls[i] != NULL ) {

                AzpFreeHeap( pADContext->pLdapControls[i] );
            }
        }

        if ( pADContext->pContextInfo != NULL ) {

            AzpFreeHeap( pADContext->pContextInfo );
        }

        AzpFreeHeap( pADContext );

    }
}

DWORD
AzpADPersistSubmit(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN AZPE_OBJECT_HANDLE pObject,
    IN ULONG lPersistFlags,
    IN BOOLEAN bDelete
    )
/*++

Routine Description:

        This routine submits changes made to the policy to the policy store.

        If the object is being created, GenericObject->PersistenceGuid will be
        zero.  Once the object has been added to the DS, try to read the
        objectGUID attribute of the newly created object in DS to get the GUID
        to set the PersistenceGuid of the object in cache.  If the read fails,
        ignore the problem.  It is assumed that the GUID will be populated during
        a refresh at a future point of time.

        On entry, PersistCritSect must be locked

Arguments:

        PersistContext - Specifies the policy database that is to be manipulated

        pObject - Specifies the object in the database that is to be updated
                in the underlying store.

        lPersistFlags - lPersistFlags from the persist engine describing the
                operation.
                AZPE_FLAGS_PERSIST_SUBMIT - Call is the AzPersistSubmit

        bDelete - TRUE if the object and all of its children are to be deleted.
                FALSE if the object is to be updated.

Return Values:

        NO_ERROR - The operation was successful
        Other status codes

--*/
{
    DWORD WinStatus = 0;
    ULONG LdapStatus = 0;

    PWCHAR pDN = NULL;

    PAZP_AD_CONTEXT pContext = (PAZP_AD_CONTEXT)PersistContext;
    ULONG lObjectType = AdAzrolesInfo->AzpeObjectType(pObject);

    BOOL bDeleteStore = bDelete && (OBJECT_TYPE_AZAUTHSTORE == lObjectType);

    //
    // Validation
    //

    ASSERT( pObject != NULL );

    ASSERT( pContext != NULL );

    BOOL bChangeSubmitted = FALSE;
    BOOL bNeedReadBackUSN;
    BOOL bUpdateStoreObject = AzpADNeedUpdateStoreUSN(pContext, pObject, &bNeedReadBackUSN);
    
    //
    // For a new (or renamed) object, if it is an application or scope,
    // then we need to make sure that the same name object hasn't been
    // created since this cache is updated. Other types of object
    // are fine because the name is part of the DN and we will get
    // flagged by AD upon submitting that the object already exists.
    //
    
    if ( (AdAzrolesInfo->AzpeDirtyBits(pObject) & (AZ_DIRTY_CREATE | AZ_DIRTY_NAME) ) &&
         ( lObjectType == OBJECT_TYPE_APPLICATION || lObjectType == OBJECT_TYPE_SCOPE)
       )
    {
        BOOL bHasUpdate = FALSE;
        WinStatus = AzpADStoreHasUpdate(FALSE, pContext, &bHasUpdate);
        if ( WinStatus != NO_ERROR )
        {
            AzPrint(( AZD_AD,
                    "AzpADPersistSubmit: AzpADStoreHasUpdate failed: %ld\n",
                    WinStatus
                    ));
            goto Cleanup;
        }
        
        //
        // somebody has updated the store outside of us. We need to 
        // make sure the same object doesn't exist yet.
        //
        
        if (bHasUpdate)
        {
            LDAPMessage * pResult = NULL;
            
            //
            // Get the store handle
            //
            
            AZPE_OBJECT_HANDLE hStore = AdAzrolesInfo->AzpeGetAuthorizationStore(pObject);
             
            //
            // Build the store DN for search
            //
            
            PWSTR pStoreDN = NULL;
            PWSTR pSearchFilter = NULL;
           
            WinStatus = AzpADBuildDN(pContext,
                            hStore,
                            &pStoreDN,
                            NULL,
                            TRUE,
                            NULL
                            );

            if ( WinStatus != NO_ERROR ) 
            {
                AzPrint(( AZD_AD,
                        "AzpADPersistSubmit: AzpADBuildDN failed:"
                        "%ld\n",
                        WinStatus
                        ));
                        
                goto Cleanup;
            }
            
            //
            // Build the search filter
            //

            WinStatus = AzpADBuildNameSearchFilter(pObject, lPersistFlags, &pSearchFilter);
            if ( WinStatus != NO_ERROR ) 
            {
                AzPrint(( AZD_AD,
                        "AzpADPersistSubmit: AzpADBuildNameSearchFilter failed:"
                        "%ld\n",
                        WinStatus
                        ));
                        
                goto Cleanup;
            }
            else
            {
                //
                // See if there is any object of this class and this name
                //
                
                LdapStatus = ldap_search_s(
                                pContext->ld,
                                pStoreDN,
                                LDAP_SCOPE_SUBTREE,
                                pSearchFilter,
                                NULL,
                                0,
                                &pResult
                                );
                                
                if (LdapStatus != LDAP_SUCCESS)
                {
                    WinStatus = LdapMapErrorToWin32( LdapStatus );
                }
                else
                {
                    LDAPMessage * pEntry = ldap_first_entry( pContext->ld, pResult );
                    
                    //
                    // It is bad if we find any entry
                    //
                    
                    if ( pEntry != NULL )
                    {
                        WinStatus = ERROR_ALREADY_EXISTS;
                    }
                }
            }
            
            if (pResult != NULL)
            {
                ldap_msgfree( pResult );
                pResult = NULL;
            }
            
            if (pStoreDN != NULL)
            {
                AzpFreeHeap(pStoreDN);
                pStoreDN = NULL;
            }
            
            if (pSearchFilter != NULL)
            {
                AdAzrolesInfo->AzpeFreeMemory(pSearchFilter);
                pSearchFilter = NULL;
            }
            
            if ( WinStatus != NO_ERROR )
            {
                AzPrint(( AZD_AD, "Submitting a new object with name that has been submitted by other instances of azstore object",
                        WinStatus ));
                goto Cleanup;
            }
        }
    }

    //
    // Build the DN for the object
    //

    WinStatus = AzpADBuildDN(
                    pContext,
                    pObject,
                    &pDN,
                    NULL, // do not have parent DN
                    FALSE, // parent DN of authorization store object not needed
                    NULL // not a call to create child object container DN
                    );

    if ( WinStatus != NO_ERROR ) {

        AzPrint(( AZD_AD,
                  "AzpADPersistSubmit: AzpADBuildDN failed: %ld\n",
                  WinStatus
                  ));

        goto Cleanup;
    }

    //
    // If the object needs to be deleted from the AD policy store,
    // then simply use the server side control to tree delete
    // so that non-leaf objects may be deleted successfully,
    // and call the LDAP API to delete the object
    //

    if ( bDelete ) {

        LdapStatus = ldap_delete_ext_s(
                         pContext->ld,
                         pDN,
                         pContext->pLdapControls,
                         NULL
                         );

        if ( LdapStatus != LDAP_NO_SUCH_OBJECT &&
             LdapStatus != LDAP_SUCCESS ) {

            WinStatus = LdapMapErrorToWin32( LdapStatus );

            AzPrint(( AZD_AD,
                      "AzpADPersistSubmit: Failed to delete object"
                      " %ws: %ld\n",
                      pDN,
                      WinStatus
                      ));
            goto Cleanup;
        }
        else if (LdapStatus == LDAP_SUCCESS)
        {
            bChangeSubmitted = TRUE;
        }

    } else {

        //
        // Submit changes to AD
        //

        //
        // Check if any attributes are dirty at all
        // If none are dirty, then simply return to the calling
        // function with NO_ERROR
        //

        if ( AdAzrolesInfo->AzpeDirtyBits(pObject) == 0x0 ) {

            WinStatus = NO_ERROR;
            goto Cleanup;

        }

        //
        // Call update routine with different argument values
        // for different objects
        //

        WinStatus = AzpUpdateADObject(
                        pContext,
                        pContext->ld,
                        pObject,
                        pDN,
                        ObjectAttributes[lObjectType].pObjectClass,
                        ObjectAttributes[lObjectType].pObjectAttrs,
                        lPersistFlags
                        );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpADPersistSubmit: Update "
                      "failed for object %ws: %ld\n",
                      pDN,
                      WinStatus
                      ));
            goto Cleanup;
        }

        bChangeSubmitted = TRUE;

    } // if (bDelete) ... else

    WinStatus = NO_ERROR;

    //
    // There is really nothing to update if the store has been deleted
    //

    if (!bDeleteStore)
    {
        if (bChangeSubmitted && bUpdateStoreObject)
        {
            WinStatus = AzpADUpdateStoreObjectForUSN(bNeedReadBackUSN, pObject, pContext);
        }
        else if (bChangeSubmitted && bNeedReadBackUSN)
        {
            //
            // change has submitted, but we don't need to update the store object
            // because there is an outside change, or we have just updated the store object
            // by ourselves, but we have determiend that we need to update our USN.
            //

            BOOL bIgnored;
            WinStatus = AzpADStoreHasUpdate(TRUE, pContext, &bIgnored);
        }
    }

 Cleanup:

    //
    // Free resources
    //

    if ( pDN != NULL ) {

        AzpFreeHeap( pDN );
    }

    return WinStatus;

}

DWORD
AzpADPersistRefresh(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN AZPE_OBJECT_HANDLE pObject,
    IN ULONG lPersistFlags
    )
/*++

Routine Description:

    This routine updates the attributes of the object from the policy database.

    On entry, PersistCritSect must be locked.

Arguments:

    PersistContext - Specifies the policy database that is to be manipulated

    pObject - Specifies the object in the database whose cache entry is to be
        updated
        The pObject->PersistenceGuid field should be non-zero on

    lPersistFlags - lPersistFlags from the persist engine describing the
                operation
                AZPE_FLAGS_PERSIST_REFRESH - Call is an AzPersistRefresh

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{

    DWORD WinStatus = 0;
    ULONG LdapStatus = 0;

    LDAPMessage *pResult = NULL;
    LDAPMessage *pEntry = NULL;

    PWCHAR pDN = NULL;

    AZPE_OBJECT_HANDLE pParentObject = NULL;

    PAZP_AD_CONTEXT pContext = (PAZP_AD_CONTEXT)PersistContext;
    ULONG lObjectType = AdAzrolesInfo->AzpeObjectType(pObject);

    //
    // Validation
    //

    ASSERT( pObject != NULL );
    ASSERT( pContext != NULL );


    //
    // If the object has never been submitted,
    //  there is no need to refresh.
    //

    if ( AdAzrolesInfo->AzpeDirtyBits( pObject ) & AZ_DIRTY_CREATE ) {
        goto Cleanup;
    }


    //
    // Build the DN for the object
    //

    WinStatus = AzpADBuildDN(
                    pContext,
                    pObject,
                    &pDN,
                    NULL,
                    FALSE,
                    NULL
                    );

    if ( WinStatus != NO_ERROR ) {

        AzPrint(( AZD_AD,
                  "AzpADPersistRefresh: AzpADBuildDN failed: %ld\n",
                  WinStatus
                  ));

        goto Cleanup;
    }

    //
    // Now read the object from the AD store and pass the returned
    // result to AzpReadADStoreObject to read in the attributes
    //

    LdapStatus = ldap_search_ext_s(
                     pContext->ld,
                     pDN,
                     LDAP_SCOPE_BASE,
                     AZ_AD_ALL_CLASSES,
                     AllObjectReadAttrs[lObjectType],
                     0,
                     pContext->pLdapControls,
                     NULL,
                     NULL,
                     0,
                     &pResult
                     );

    if ( LdapStatus != LDAP_SUCCESS ) {

        WinStatus = LdapMapErrorToWin32( LdapStatus );

        AzPrint(( AZD_AD,
                  "AzpADPersistRefresh: Search on object failed"
                  ":%ld\n",
                  WinStatus
                  ));

        goto Cleanup;
    }

    pEntry = ldap_first_entry( pContext->ld, pResult );

    if ( pEntry != NULL ) {

        //
        // get parent object of this object
        // for AzAuthorizationStore, it will return NULL which is ok
        // no need to free the handle
        //
        pParentObject = AdAzrolesInfo->AzpeParentOfChild(pObject);

        WinStatus = AzpReadADStoreObject(
                        pContext,
                        pContext->ld,
                        pEntry,
                        &pObject,
                        lObjectType,
                        pParentObject,
                        ObjectAttributes[lObjectType].pObjectAttrs,
                        lPersistFlags
                        );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpADPersistRefresh: AzpReadADStoreObject failed"
                      "for %s: %ld\n",
                      pDN,
                      WinStatus
                      ));

            goto Cleanup;
        }
    }

    WinStatus = NO_ERROR;

 Cleanup:

    AdAzrolesInfo->AzpeObjectFinished( pObject, WinStatus );

    if ( pDN != NULL ) {

        AzpFreeHeap( pDN );
    }

    if ( pResult != NULL ) {

        ldap_msgfree( pResult );
    }

    return WinStatus;
}

DWORD
AzpADPersistChildCreate(
    IN PAZP_AD_CONTEXT pContext,
    IN LDAPMessage *pAttrEntry,
    OUT PBOOL pbChildCreate
    )
/*++

Routine Description:

    This routine determines if children can be created under a particular object.  Currently,
    this is only called for the AzScope objects.  If the AzScope is delegated, then the AzScope
    object is not writable, but children can be created under it.

Arguments:

        pContext - Specifies the policy database that is to be manipulated

        //pObject - object that is queried for writable attribute

        pAttrEntry - Structure containing read in attribute values

        pbChildCreate - pointer to return the boolean in

Return Value:

        NO_ERROR - The operation was successful

--*/
{

    DWORD WinStatus = NO_ERROR;

    PWCHAR *ppValueList = NULL;
    PWCHAR pSearchString = NULL;

    ULONG lValueCount = 0;

    ULONG i = 0;

    //
    // Validation
    //

    ASSERT( pContext != NULL );

    //
    // Set pbChildCreate to a default value
    //

    *pbChildCreate = FALSE;

    ppValueList = ldap_get_values( pContext->ld,
                                   pAttrEntry,
                                   AZ_AD_OBJECT_CHILD_CREATE
                                   );

    if ( ppValueList != NULL ) {

        lValueCount = ldap_count_values( ppValueList );

        for ( i=0; i<lValueCount; i++) {

            pSearchString = ppValueList[i];

            if ( _wcsicmp( pSearchString, AZ_AD_OBJECT_CONTAINER ) ) {

                *pbChildCreate = TRUE;
                break;
            }

        }

    } else {

        WinStatus = LdapMapErrorToWin32( LdapGetLastError() );

        if ( WinStatus == ERROR_INVALID_PARAMETER ) {
            WinStatus = NO_ERROR;
        }
    }

    if ( ppValueList != NULL ) {

        ldap_value_free( ppValueList );
    }

    return WinStatus;
}


DWORD
AzpADPersistWritable(
    IN PAZP_AD_CONTEXT pContext,
    IN AZPE_OBJECT_HANDLE pObject,
    IN LDAPMessage *pAttrEntry,
    OUT PBOOL pbWritable,
    OUT PBOOL pbCanCreateChildren
    )
/*++

Routine Description:

        This routine determines if the persist object is writable.  If the object
        is a parent object, then the allowedAttributesEffective field is read.  If
        not, then the object's parent object's CanCreateChildren value is returned.
        If the child can be created, then it is Writable.

Arguments:

        pContext - Specifies the policy database that is to be manipulated

        pObject - object that is queried for writable attribute

        pAttrEntry - Structure containing read in attribute values

        pbWritable - pointer to return the boolean in

        pbCanCreateChildren - pointer to return boolen specifying if children can be created

Return Value:

        NO_ERROR - The operation was successful

--*/
{

    DWORD WinStatus = 0;

    PWCHAR *ppValueList = NULL;

    ULONG lValueCount = 0;

    ULONG i = 0;

    PWCHAR *ppResultString = NULL;

    PWCHAR pSearchAttribute = NULL;

    ULONG lObjectType = AdAzrolesInfo->AzpeObjectType(pObject);

    //
    // Validation
    //

    ASSERT( pObject != NULL );
    ASSERT( pContext != NULL );

    //
    // Set pbWritable to a default value
    //

    *pbWritable = FALSE;

    if ( IsContainerObject(lObjectType) ) {


        ppValueList = ldap_get_values( pContext->ld,
                                       pAttrEntry,
                                       AZ_AD_OBJECT_WRITEABLE
                                       );

        if ( ppValueList != NULL ) {

            lValueCount = ldap_count_values( ppValueList );

            //
            // sort the retrieved attributes
            //

            qsort( (PVOID)ppValueList,
                   (size_t)lValueCount,
                   sizeof( PWCHAR ),
                   AzpCompareSortStrings
                   );

            //
            // Now check if the common object attributes are present in the
            // sorted list or not
            //

            *pbWritable = TRUE;

            for ( i = 0; i < AZ_AD_MAX_ATTRS; i++ ) {

                if ( i < AZ_AD_COMMON_ATTRS ) {

                    //
                    // for AzApplication and AzScope attributes, check the
                    // msDS-AzApplicationName/msDS-AzScopeName attribute
                    // For others check the name attribute
                    //

                    if ( (lObjectType == OBJECT_TYPE_APPLICATION ||
                          lObjectType == OBJECT_TYPE_SCOPE) &&
                         (CommonAttrs[i].AttrType == AZ_PROP_NAME) ) {

                        pSearchAttribute =
                            AZ_AD_OBJECT_NAMES[lObjectType];


                        //
                        // Group objects don't support the application data attribute
                        //

                    } else if ( lObjectType == OBJECT_TYPE_GROUP &&
                                CommonAttrs[i].AttrType == AZ_PROP_APPLICATION_DATA ) {

                        continue;

                        //
                        // All others use the attribute name in the table
                        //
                    } else {

                        pSearchAttribute = CommonAttrs[i].Attr;
                    }

                } else if ( ObjectAttributes[lObjectType].
                            pObjectAttrs[i-AZ_AD_COMMON_ATTRS].AttrType ==
                            AZ_AD_END_LIST ) {

                    break;

                } else {

                    pSearchAttribute =
                        ObjectAttributes[lObjectType].
                        pObjectAttrs[i-AZ_AD_COMMON_ATTRS].Attr;
                }

                //
                // Perform a binary search on the sorted strings
                //

                ppResultString = (PWCHAR *) bsearch(
                    (PWCHAR) &pSearchAttribute,
                    (PWCHAR) ppValueList,
                    lValueCount,
                    sizeof( PWCHAR ),
                    AzpCompareSortStrings
                    );

                if ( ppResultString == NULL ) {

                    AzPrint(( AZD_AD,
                              "AzpADPersistWritable: %ws attribute isn't writable\n",
                              pSearchAttribute ));

                    *pbWritable = FALSE;
                    break;
                }

            } // for (i = 0; i < AZ_AD_MAX_ATTRS; i++ )
        }

        //
        // Now check if children can be created under this object.
        //

        WinStatus = AzpADPersistChildCreate(
            pContext,
            pAttrEntry,
            pbCanCreateChildren
            );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpADPersistWritable: Error calling AzpADPersistChildCreate: %ld\n",
                      WinStatus
                      ));

            goto Cleanup;
        }

    }  else { // if ( IsContainerObject(lObjectType) )

        *pbWritable = AdAzrolesInfo->AzpeCanCreateChildren(pObject);
    }

    WinStatus = NO_ERROR;

Cleanup:

    if ( ppValueList != NULL ) {

        ldap_value_free( ppValueList );
    }

    return WinStatus;
}

DWORD
AdCheckSecurityPrivilege(
    IN PAZP_AD_CONTEXT pContext
    )
/*++

Routine Description:


    Determine whether the caller has SE_SECURITY_PRIVILEGE on the machine containing
    the AD store.

Arguments:

    pContext - context for the store

Return Value:

    NO_ERROR - The caller has privilege
    ERROR_DS_INSUFF_ACCESS_RIGHTS - The security descriptor could not be read
    Other errors

--*/
{
    DWORD WinStatus;

    PSECURITY_DESCRIPTOR pSD = NULL;

    //
    // Validation
    //

    ASSERT( pContext != NULL );

    //
    // Get the NTSecurityDescriptor for the object
    //

    WinStatus = AzpADReadNTSecurityDescriptor(
                    pContext,
                    pContext->AzStoreHandle,
                    NULL,
                    TRUE, // need to read authorization store's AD parent
                    &pSD,
                    TRUE,  // read SACL
                    FALSE
                    );

    if ( WinStatus != NO_ERROR ) {

        AzPrint(( AZD_AD,
                  "AdCheckSecurityPrivilege: AzpADReadNTSecurityDescriptor"
                  " failed: %ld\n",
                  WinStatus
                  ));
        goto Cleanup;
    }

    WinStatus = NO_ERROR;

 Cleanup:

    //
    // free local resources
    //

    if ( pSD != NULL ) {

        AzpFreeHeap( pSD );
    }

    return WinStatus;
}


//
// Routines used by AzpADPersistOpen to open
// a policy store into the core cache
//


DWORD
AzpReadADStore(
    IN PAZP_AD_CONTEXT pContext,
    IN AZPE_OBJECT_HANDLE pAzAuthorizationStore,
    IN ULONG lPersistFlags
    )
/*++

Routine Description:

        This routine is called if there is a new policy not being created and
        there does not exist a policy in cache already.  This routine will read
        the policy from the AD store into the cache.

Arguments:

        pContext - context for the store

        pAzAuthorizationStore - Structure to start reading policy from.  This structure
                also contains a handle to the AD store for LDAP communication to
                occur.

        lPersistFlags - lPersistFlags from the persist engine describing the
                operation

Return Value:

        NO_ERROR - The policy was successfully read into the cache
        Other status code - There was problem reading the policy into the cache
--*/
{

    DWORD WinStatus = 0;
    DWORD WinStatusActual = 0;
    ULONG LdapStatus = 0;

    LDAP *pLdapHandle = NULL;
    LDAPMessage *pResult = NULL;
    LDAPMessage *pObjectEntry = NULL;

    AZPE_OBJECT_HANDLE pObject = NULL;

    PWCHAR *ppValueList = NULL;

    //
    // Validation
    //

    ASSERT( pAzAuthorizationStore != NULL );

    //
    // Start by reading in the AzAuthorizationStore object properties
    // into the cache, and then traverse the tree reading in
    // the various objects
    //

    pLdapHandle = pContext->ld;

    //
    // Search for the base DN to start reading the policy from
    // the base level.  This will return us the attributes for
    // the AzAuthorizationStore object only.  From there, we can search
    // the base DN for application and application groups individually
    //

    LdapStatus = ldap_search_ext_s(
                     pLdapHandle,
                     pContext->pContextInfo,
                     LDAP_SCOPE_BASE,
                     AZ_AD_AZSTORE_FILTER,
                     AuthorizationStoreReadAttrs,
                     0,
                     pContext->pLdapControls,
                     NULL,
                     NULL,
                     0,
                     &pResult // buffer to store read attributes
                     );

    if ( LdapStatus == LDAP_NO_SUCH_OBJECT ) {

        WinStatusActual = ERROR_FILE_NOT_FOUND;
        goto Cleanup;

    } else if ( LdapStatus != LDAP_SUCCESS ) {

        WinStatusActual = LdapMapErrorToWin32( LdapStatus );
        goto Cleanup;

    }

    pObjectEntry = ldap_first_entry( pLdapHandle, pResult );

    //
    // We have a handle to the first entry in the DS policy (AzAuthorizationStore
    // object)
    //

    //
    // Read AD store if there are entries
    //

    if ( pObjectEntry != NULL ) {

        //
        // if we are reading an existing poicy, let's check the versions
        // to determine if we can continue reading
        //

        WinStatus = AzpCheckVersions (pLdapHandle, pResult);

        if ( NO_ERROR != WinStatus ) {

            AzPrint(( AZD_AD,
                      "AzpADPersistOpenEx: AzpCheckVersions failed with error: %ld\n",
                      WinStatus
                      ));

            goto Cleanup;
        }

        //
        // populate the AzAuthorizationStore object in the cache
        //

        pObject = pAzAuthorizationStore;

        WinStatus = AzpReadADStoreObject( pContext,
                                          pLdapHandle,
                                          pObjectEntry,
                                          &pObject,
                                          OBJECT_TYPE_AZAUTHSTORE,
                                          NULL,
                                          AzStoreAttrs,
                                          lPersistFlags
                                          );

        //
        // If there were not enough resources and we are opening the policy
        // for the first time, then return error.
        // Else, remember the error and press on
        //

        if ( !AzpPressOn(WinStatus, lPersistFlags, &WinStatusActual) ) {

            AzPrint(( AZD_AD,
                      "AzpReadADStoreObject failed: %ld\n",
                      WinStatus
                      ));

            goto Cleanup;

        }

        WinStatus = AzpADReadAzStoreChildren(
            pContext,
            pObject,
            lPersistFlags
            );

        //
        // If insufficient resources and AZPE_FLAGS_PERSIST_OPEN
        // then return error.  Else press on.
        //

        if (!AzpPressOn(WinStatus, lPersistFlags, &WinStatusActual)) {

            AzPrint(( AZD_AD,
                      "AzpReadADStore: AzpADReadAzStoreChildren failed: %ld\n",
                      WinStatus
                      ));

            goto Cleanup;

        }

    } else { // if ( pObjectEntry != NULL )

        //
        // If the entries returned for the authorization store search
        // are null, then the user has not been able to read the
        // authorization store object.  We need to return with an error
        // ERROR_DS_INSUFF_ACCESS_RIGHTS
        //

        WinStatusActual = ERROR_DS_INSUFF_ACCESS_RIGHTS;
    }

 Cleanup:

    pContext = NULL;

    pObject = NULL;

    //
    // Need to release these resources
    //

    if ( ppValueList != NULL ) {

        ldap_value_free( ppValueList );

    }

    if ( pResult != NULL ) {

        ldap_msgfree( pResult );

    }

    return WinStatusActual;
}


DWORD
AzpADReadAzStoreChildren(
    IN PAZP_AD_CONTEXT pContext,
    IN AZPE_OBJECT_HANDLE pParentObject,
    IN ULONG lPersistFlags
    )
/*++

Routine Description:

        This routine reads in childern of the authorization store object

Argumetns:

        pContext - Context for the LDAP AD provider

        pChildFilter - Child filter to search the base DN on

        ObjectType - Identifies the object type that we are trying to read

        pParentObject - Pointer to the parent object, AzAuthorizationStore

        lPersistFlags - lPersistFlags from the persist engine describing the
                operation

Return Values:

        NO_ERROR - The object was read from the DS and into the cache successfully
        Other status codes (ERROR_NOT_ENOUGH_MEMORY, Ldap status codes)

--*/
{

    DWORD WinStatus = 0;
    DWORD WinStatusActual = 0;

    PLDAPSearch pSearchHandle = NULL;

    //
    // Validation
    //

    ASSERT( pContext != NULL );

    //
    // Read in the AzApplicationGroup objects under the AzAuthorizationStore
    // object from the Applicaton Group container that exists in AD store.
    //

    WinStatus = AzpReadADObjectContainer(
        pContext,
        pContext->pContextInfo,
        GROUP_OBJECT_CONTAINER_NAME_PREFIX,
        GROUP_OBJECT_CONTAINER_NAME_PREFIX_LENGTH,
        AZ_AD_APP_GROUP_FILTER,
        OBJECT_TYPE_GROUP,
        pParentObject,
        lPersistFlags
        );

    if (!AzpPressOn(WinStatus, lPersistFlags, &WinStatusActual)) {

        AzPrint((
                 AZD_AD,
                 "AzpADReadAzStoreChildren: Failed to read Application Groups: %ld\n",
                 WinStatus
                 ));
    }

    //
    // Search the AzAuthorizationStore object for all Application objects
    //

    pSearchHandle = ldap_search_init_page(
        pContext->ld,
        pContext->pContextInfo,
        LDAP_SCOPE_ONELEVEL,
        AZ_AD_APPLICATION_FILTER,
        AllObjectReadAttrs[OBJECT_TYPE_APPLICATION],
        FALSE,
        pContext->pLdapControls,
        NULL,
        0,
        0,
        NULL
        );

    if ( pSearchHandle == NULL ) {

        WinStatus = LdapMapErrorToWin32( LdapGetLastError() );
        if (!AzpPressOn(WinStatus, lPersistFlags, &WinStatusActual)) {

            AzPrint(( AZD_AD,
                      "AzpADReadAzStoreChildren: Failed to create paged result handle: %ld\n",
                      WinStatus
                      ));
            goto Cleanup;
        }

    } else {

        WinStatus = AzpADReadPagedResult(
            pContext,
            pSearchHandle,
            pParentObject,
            OBJECT_TYPE_APPLICATION,
            lPersistFlags
            );

        //
        // If insufficient resources and AZPE_FLAGS_PERSIST_OPEN
        // then return error.  Else press on.
        //

        if (!AzpPressOn(WinStatus, lPersistFlags, &WinStatusActual)) {

            AzPrint(( AZD_AD,
                      "AzpADReadAzStoreChildren: AzpADReadPagedResult failed: %ld\n",
                      WinStatus
                      ));

            goto Cleanup;

        }

        ldap_search_abandon_page( pContext->ld, pSearchHandle );
        pSearchHandle = NULL;

    } // if ( pSearchHandle )

Cleanup:

    if ( pSearchHandle != NULL ) {

        ldap_search_abandon_page( pContext->ld, pSearchHandle );
    }

    return WinStatusActual;
}

DWORD
AzpADReadPagedResult(
    IN PAZP_AD_CONTEXT pADContext,
    IN LDAPSearch *pSearchHandle,
    IN AZPE_OBJECT_HANDLE ParentObjectHandle,
    IN ULONG ChildObjectType,
    IN ULONG lPersistFlags
    )
/*++

Routine Description:

    This routine reads in the page results for the passed in LDAP search handle

Arguments:

    pADContext - Context for the AD store provider

    pSearchHandle - Handle to the page search results

    ParentObjectHandle - Handle to the object on which the search was initially performed

    ChildObjectType - Type of object for child

    lPersistFlags - Flags from the persistence provider

Return Value:

    NO_ERROR - The operation succeeded
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status code

--*/
{

    DWORD WinStatus = 0;
    DWORD WinStatusActual = 0;
    ULONG LdapStatus = 0;

    LDAPMessage *pObjectResult = NULL;
    LDAPMessage *pObjectEntry = NULL;

    ULONG NumberOfEntries = 0;

    AZPE_OBJECT_HANDLE pObject = NULL;

    //
    // Validation
    //

    AZASSERT( pADContext != NULL || pSearchHandle != NULL );

    //
    // Loop reading all the paged results from the DS
    //

    while ( (LdapStatus = ldap_get_next_page_s( pADContext->ld,
                                                pSearchHandle,
                                                NULL,
                                                AZ_AD_PAGE_SEARCH_COUNT,
                                                NULL,
                                                &pObjectResult
                                                )) == LDAP_SUCCESS ) {


        NumberOfEntries = ldap_count_entries( pADContext->ld, pObjectResult );

        if ( NumberOfEntries > 0 ) {

            //
            // get a handle to the first object
            //

            pObjectEntry = ldap_first_entry( pADContext->ld, pObjectResult );

            while ( pObjectEntry != NULL ) {

                WinStatus = AzpReadADStoreObject(
                    pADContext,
                    pADContext->ld,
                    pObjectEntry,
                    &pObject,
                    ChildObjectType,
                    ParentObjectHandle,
                    ObjectAttributes[ChildObjectType].pObjectAttrs,
                    lPersistFlags
                    );

                if ( !AzpPressOn(WinStatus, lPersistFlags, &WinStatusActual) ) {

                    AzPrint(( AZD_AD,
                              "AzpADReadPagedResult: Reading of child object"
                              "failed: %ld\n",
                              WinStatus
                              ));

                    goto Cleanup;

                }

                //
                // if we are updating the cache, and the object's children have
                // been lazy loaded, then update the children as well
                //

                if ( (lPersistFlags & AZPE_FLAGS_PERSIST_UPDATE_CACHE)!=0 &&
                     AdAzrolesInfo->AzpeUpdateChildren(pObject)) {

                    WinStatus = AzpADPersistUpdateChildrenCache(
                        (AZPE_PERSIST_CONTEXT) pADContext,
                        pObject,
                        lPersistFlags
                        );

                    if ( !AzpPressOn(WinStatus, lPersistFlags, &WinStatusActual) ) {

                        AzPrint(( AZD_AD,
                                  "AzpADReadPagedResult: Updating children failed: %ld\n",
                                  WinStatus
                                  ));

                        goto Cleanup;
                    }
                }

                if ( pObject != NULL ) {

                    AdAzrolesInfo->AzpeObjectFinished( pObject, WinStatus );
                    pObject = NULL;
                }

                pObjectEntry = ldap_next_entry( pADContext->ld, pObjectEntry );

            } //while ( pObjectEntry != NULL )

        } // if ( NumberOfEntries > 0 )

        if ( pObjectResult != NULL ) {

            ldap_msgfree( pObjectResult );
            pObjectResult = NULL;
        }

    } // while ( ldap_get_next_page_s() )

    if ( LdapStatus != LDAP_SUCCESS && LdapStatus != LDAP_NO_RESULTS_RETURNED ) {

        WinStatus = LdapMapErrorToWin32( LdapStatus );

        if (!AzpPressOn(WinStatus, lPersistFlags, &WinStatusActual)) {

            AzPrint(( AZD_AD,
                      "AzpADReadPagedResult: Failed to read paged LDAP result: %ld\n",
                      WinStatus
                      ));

            goto Cleanup;
        }

    }

Cleanup:

    if ( pObjectResult != NULL ) {

        ldap_msgfree( pObjectResult );
    }

    if ( pObject != NULL ) {

        AdAzrolesInfo->AzpeObjectFinished( pObject, WinStatus );
        pObject = NULL;
    }

    return WinStatusActual;
}

DWORD
AzpReadADObjectContainer(
    IN PAZP_AD_CONTEXT pContext,
    IN PWCHAR pParentDN,
    IN PWCHAR pContainerPrefix,
    IN ULONG lPrefixLength,
    IN PWCHAR pChildFilter,
    IN ULONG lObjectType,
    IN AZPE_OBJECT_HANDLE pParentObject,
    IN ULONG lPersistFlags
    )
/*++

Routine Description:

    This routine reads containers for objects such as AzOperation,
    AzTask, AzRole, and AzApplicationGroup

Arguments:

    pContext -  Context for the store

    pParentDN - DN for the parent

    pContainerPrefix - Prefix for the container that needs to be read

    lPrefixLength - Length of the container prefix

    pChildFilter - Filter for the child objects that need to be read

    lObjectType - Type of object to be read

    pParentObject - Handle to the parent object

    lPersistFlags - Flags from the persist engine describing the operation

Return Values:

    NO_ERROR - The object(s) were read successfully
    ERROR_NOR_ENOUGH_MEMORY
    ERROR_DS_NO_SUCH_OBJECT - The container does not exist and the AD store is in
               a corrupted state
    Other status codes from LDAP routines

--*/
{
    UNREFERENCED_PARAMETER(lPrefixLength);

    DWORD WinStatus = 0;
    DWORD WinStatusActual = 0;

    LPWSTR pContainerDN = NULL;
    LPCWSTR pParentStart = NULL;
    LPCWSTR pParentEnd = NULL;

    LDAPSearch  *pSearchHandle = NULL;

    //
    // Build the DN for the Container object using the passed in prefix
    //

    pParentStart = pParentDN + BUILD_CN_PREFIX_LENGTH;

    pParentEnd = AzpGetAuthorizationStoreParent( pParentStart );

    if (NULL == pParentEnd)
    {
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    pParentEnd--;

    pContainerDN = (PWCHAR) AzpAllocateHeap( (BUILD_CN_PREFIX_LENGTH + wcslen(pContainerPrefix) +
                                              (pParentEnd-pParentStart) + BUILD_CN_SUFFIX_LENGTH +
                                              wcslen(pParentDN) + 1) * sizeof( WCHAR ),
                                             "CONTDN" );

    if ( pContainerDN == NULL ) {

        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    wcscpy( pContainerDN, BUILD_CN_PREFIX );
    wcscat( pContainerDN, pContainerPrefix );
    wcsncat( pContainerDN, pParentStart, (pParentEnd-pParentStart));
    wcscat( pContainerDN, BUILD_CN_SUFFIX );
    wcscat( pContainerDN, pParentDN );

    //
    // Now search the Container for AzMan objects specified in filter
    //

    pSearchHandle = ldap_search_init_page(
        pContext->ld,
        pContainerDN,
        LDAP_SCOPE_ONELEVEL,
        pChildFilter,
        AllObjectReadAttrs[lObjectType],
        FALSE,
        pContext->pLdapControls,
        NULL,
        0,
        0,
        NULL
        );

    if ( pSearchHandle == NULL ) {

        WinStatus = LdapMapErrorToWin32( LdapGetLastError() );

        goto Cleanup;

    } else {

        WinStatus = AzpADReadPagedResult(
            pContext,
            pSearchHandle,
            pParentObject,
            lObjectType,
            lPersistFlags
            );

        if ( !AzpPressOn(WinStatus, lPersistFlags, &WinStatusActual) ) {

            AzPrint(( AZD_AD,
                      "AzpReadADObjectContainer: Reading of child object"
                      "failed: %ld\n",
                      WinStatus
                      ));

            goto Cleanup;

        }

        ldap_search_abandon_page( pContext->ld, pSearchHandle );
        pSearchHandle = NULL;

    } // if ( pSearchHandle )

    WinStatusActual = WinStatus;

Cleanup:

    if ( pSearchHandle != NULL ) {

        ldap_search_abandon_page( pContext->ld, pSearchHandle );
    }

    if ( pContainerDN != NULL ) {

        AzpFreeHeap( pContainerDN );
    }

    return WinStatusActual;
}


DWORD
AzpReadADStoreForCommonData(
    IN PAZP_AD_CONTEXT pContext,
    IN LDAP* pLdapHandle,
    IN LDAPMessage* pEntry,
    IN ULONG ObjectType,
    IN AZPE_OBJECT_HANDLE pParentObject,
    OUT AZPE_OBJECT_HANDLE *ppObject,
    IN ULONG lPersistFlags
    )
/*++

Routine Description:

        This routine creates a new object of type object type (if not
        AzAuthorizationStore) and populates it with common data information such as
        description, GUID (for non authorization store objects).

Arguments:

        pContext - context for the store

        pLdapHandle - Handle to the DS policy store

        pEntry - LDAPMessage structure containing all the property information

        ObjectType - Type of object to be created

        pParentObject - Handle to the parent object in the cache

        ppObject - Handle to the object to be created and populated

        lPersistFlags - lPersistFlags from the persist engine describing the
                operation

Return Values:

        NO_ERROR - The object was created and populated successfully

        ERROR_OBJECT_ALREADY_EXISTS - An object with the same name already
                exists
--*/
{
    DWORD WinStatus = 0;

    LPWSTR ObjectName = NULL;

    LDAP_BERVAL **ppBerVal = NULL;

    PWCHAR *ppValueList = NULL;

    ULONG i = 1; // to read desciption and application data

    //
    // Validation
    //

    ASSERT( pEntry != NULL );

    //
    // Initialization
    //

    //
    // No need to create object if it is an AzAuthorizationStore type
    // This object has already been created by the core
    //

    if ( ObjectType != OBJECT_TYPE_AZAUTHSTORE ) {

        //
        // Validate parent object
        //

        ASSERT( pParentObject != NULL );

        //
        // Obtain the name of the object from
        // DS to pass to the object creation in cache routine
        //

        WinStatus = AzpInitializeObjectName( pLdapHandle,
                                             &ObjectName,
                                             pEntry,
                                             ObjectType );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpReadADStoreForCommonData: AzpInitializeObjectName failed"
                      ": %ld\n",
                      WinStatus
                      ));

            goto Cleanup;

        }

        //
        // Get the GUID for this object
        //

        ppBerVal = ldap_get_values_len( pLdapHandle,
                                        pEntry,
                                        AZ_AD_OBJECT_GUID
                                        );

        if ( ppBerVal == NULL ) { // error in recovering GUID

            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;

        }

        //
        // Create object in the cache
        //

        WinStatus = AdAzrolesInfo->AzpeCreateObject(
                                       pParentObject,
                                       ObjectType,
                                       ObjectName,
                                       (GUID*)(ppBerVal[0]->bv_val),
                                       lPersistFlags,
                                       ppObject
                                       );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpReadADStoreForCommonData: AzpeCreateObject failed"
                      ": %ld\n",
                      WinStatus
                      ));

            goto Cleanup;

        }

        //
        // make sure that the object was infact created in the cache
        //

        ASSERT ( *ppObject != NULL );

        //
        // for AzApplication and AzScope objects, set the pGuidCN
        // attribute so that it may be used to identify them later on
        // This is done if the objects are being created (no need for
        // when just the object is being refreshed).
        //

        if ( (lPersistFlags & AZPE_FLAGS_PERSIST_OPEN) &&
             (ObjectType == OBJECT_TYPE_APPLICATION ||
              ObjectType == OBJECT_TYPE_SCOPE) ) {

            //
            // Get the CN
            //

            ppValueList = ldap_get_values(
                              pLdapHandle,
                              pEntry,
                              AZ_AD_OBJECT_CN
                              );

            if ( ppValueList == NULL ) {

                //
                // Error in recovering CN
                //

                WinStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }

            LPWSTR TempString;

            WinStatus = AzpCreateGuidCN(
                &TempString,
                *ppValueList
                );

            AdAzrolesInfo->AzpeSetProviderData( *ppObject, (PVOID)TempString );

            if ( WinStatus != NO_ERROR ) {

                AzPrint(( AZD_AD,
                          "AzpReadADStoreForCommonData: AzpADCreateGuidCN failed"
                          " for %ws: %ld\n",
                          ObjectName,
                          WinStatus
                          ));

                goto Cleanup;
            }
        }

    } // if ( ObjectType != OBJECT_TYPE_AZAUTHSTORE )

    //
    // Get the description and application data and populate those
    // properties for the newly created object in cache.  Applicatio
    // data does not exist AzApplicationGroup objects, and hence no need
    // to read that attribute if object is AzApplicationGroup
    //

    while ( CommonAttrs[i].AttrType != AZ_AD_END_LIST ) {

        if ( (CommonAttrs[i].AttrType == AZ_PROP_APPLICATION_DATA &&
              ObjectType != OBJECT_TYPE_GROUP) ||

             (CommonAttrs[i].AttrType != AZ_PROP_APPLICATION_DATA) ) {

            WinStatus = AzpReadAttributeAndSetProperty(
                            pContext,
                            pEntry,
                            pLdapHandle,
                            *ppObject,
                            CommonAttrs[i].AttrType,
                            CommonAttrs[i].Attr,
                            ENUM_AZ_BSTR,
                            lPersistFlags
                            );

            if ( WinStatus != NO_ERROR ) {

                AzPrint(( AZD_AD,
                          "AzpReadADStoreForCommonData: Read description failed"
                          ": %ld\n",
                          WinStatus
                          ));

                goto Cleanup;

            }
        }

        i++;
    }


    WinStatus = NO_ERROR;

Cleanup:

    //
    // release resources
    //

    AdAzrolesInfo->AzpeFreeMemory( ObjectName );

    if ( ppBerVal != NULL ) {

        ldap_value_free_len( ppBerVal );
    }

    if ( ppValueList != NULL ) {

        ldap_value_free( ppValueList );
    }

    return WinStatus;
}

DWORD
AzpInitializeObjectName(
    IN LDAP* pLdapH,
    OUT LPWSTR *pObjectName,
    IN LDAPMessage* pEntry,
    IN ULONG ObjectType
    )
/*++

Routine Description:

        This routine gets the name of the object from AD so that the object
        may be created in cache

Arguments:

        pLdapH - Handle to the DS policy store
        pObjectName - The retrieved object name
        pEntry - LDAPMessage structure from which to retrieve the name
        ObjectType - Type of object whose name is to be retrieved.  For
                AzApplication, AzScope, retrieve AZ_AD_APPLICATION_NAME,
                AZ_AD_SCOPE_NAME.
                For all other objects retrieve AZ_AD_OBJECT_CN.

Returns:

        NO_ERROR - There was no error in retrieving the name
        Other status codes
--*/
{
    DWORD WinStatus = 0;
    ULONG StringSize;

    PWCHAR *ppValueList = NULL;

    PWCHAR pTempObjectName = NULL;

    //
    // Depending on type of objects, retrieve name attribute
    // accordingly
    //

    pTempObjectName = AZ_AD_OBJECT_NAMES[ObjectType];

    //
    // Get the list of values for the attribute entry "cn"
    // For AzApplication, AzScope, we need to get
    // the attributes msDS-AzApplicationName, msDS-AzScopeName
    //

    ppValueList = ldap_get_values(
                      pLdapH,
                      pEntry,
                      pTempObjectName
                      );

    if ( ppValueList == NULL ) {

        //
        // error in recovering name
        //

        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Allocate a buffer to return the string in

    StringSize = (ULONG)((wcslen( *ppValueList )+1) * sizeof(WCHAR));

    *pObjectName = (LPWSTR) AdAzrolesInfo->AzpeAllocateMemory( StringSize );

    if ( *pObjectName == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( *pObjectName, *ppValueList, StringSize );

    WinStatus = NO_ERROR;

Cleanup:

    //
    // Release the resource
    //

    if ( ppValueList != NULL ) {

        ldap_value_free( ppValueList );

    }

    return WinStatus;
}

DWORD
AzpReadADStoreObject(
    IN PAZP_AD_CONTEXT pContext,
    IN LDAP* pLdapHandle,
    IN LDAPMessage* pEntry,
    IN OUT AZPE_OBJECT_HANDLE *ppObject,
    IN ULONG ObjectType,
    IN AZPE_OBJECT_HANDLE pParentObject,
    IN AZ_AD_ATTRS Attrs[],
    IN ULONG lPersistFlags
    )
/*++

Routine Description:

        This routine reads & creates an object in cache (if needed) and then
        reads in the values of the attributes for Az object
        from the AD store into the local cache.

Arguments:

        pLdapHandle - A handle to the AD store to read in the attributes into
                the cache

        pEntry - Buffer storing the read attributes from the calling function

        ppObject - Handle to the object in the cache

        ObjectType - Type of the object

        pParentObject - Pointer to the parent object

        Attrs - List of attributes that need to read for the object of type
                objectType

        lPersistFlags - lPersistFlags from the persist engine describing the
                operation

Return Value:

        NO_ERROR - The values were read into the cache successfully
        Other status code returned from called functions
--*/
{
    DWORD WinStatus = 0;
    DWORD WinStatusActual = 0;
    BOOL IsWritable;
    BOOL CanCreateChildren = FALSE;

    ULONG i; // to traverse the list of attributes to be read

    PWCHAR *ppValueList = NULL;

    //
    // Create/read an object into cache and populate
    // it with property types common to all objects
    //

    WinStatus = AzpReadADStoreForCommonData(
                    pContext,
                    pLdapHandle,
                    pEntry,
                    ObjectType,
                    pParentObject,
                    ppObject,
                    lPersistFlags
                    );

    if ( !AzpPressOn(WinStatus, lPersistFlags, &WinStatusActual) ||
         *ppObject == NULL ) {

        AzPrint(( AZD_AD,
                  "AzpReadADStoreObject: Object creation and common"
                  " data read failed: %ld\n",
                  WinStatus
                  ));

        goto Cleanup;

    }

    //
    // will read the uSNChanged attributes
    //

    if (ObjectType == OBJECT_TYPE_AZAUTHSTORE && lPersistFlags & AZPE_FLAGS_PERSIST_OPEN)
    {
        pContext->ullUSNChanged = AzpADReadUSNChanged(pLdapHandle, pEntry, &(pContext->HasObjectVersion) );
    }

    //
    // Object was created/read successfully.
    // Now read in other properties for it.
    //

    for ( i = 0; Attrs[i].AttrType != AZ_AD_END_LIST; i++ ) {

        WinStatus = AzpReadAttributeAndSetProperty( pContext,
                                                    pEntry,
                                                    pLdapHandle,
                                                    *ppObject,
                                                    Attrs[i].AttrType,
                                                    Attrs[i].Attr,
                                                    Attrs[i].DataType,
                                                    lPersistFlags
                                                    );

        //
        // If there were insufficient resources, then fail for
        // AZPE_FLAGS_PERSIST_OPEN.  Update should press on, toherwise
        // no progress would ever be made in updating the cache.
        //

        if ( !AzpPressOn(WinStatus, lPersistFlags, &WinStatusActual) ) {

            AzPrint(( AZD_AD,
                      "AzpReadAttributeAndSetProperty failed: %ld\n",
                      WinStatus
                      ));

            goto Cleanup;

        }
    }

    //
    // Get the DN of the object from the LDAPMessage structure.  If
    // the GUIDized CN name of an AzApplication or AzScope object is
    // NULL, then we have reached here from a code path for an update
    // cache.  Extract the Guidized CN name from the DN and store it
    // for AzApplication and AzScope objects
    //
    // Populate the policy admins/readers for the container
    // objects
    //

    if ( IsContainerObject( ObjectType ) ) {

        PWCHAR RealDn = NULL;

        //
        // Get the DN
        //

        ppValueList = ldap_get_values(
                          pLdapHandle,
                          pEntry,
                          AZ_AD_OBJECT_DN
                          );

        if ( ppValueList == NULL ) {
            //
            // There should be a Distinguished name for every object
            // If we failed to retrieve it, that means there was a lack of
            // memory is storing/retrieving the value
            //

            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            if ( !AzpPressOn(WinStatus, lPersistFlags, &WinStatusActual) ) {
                goto Cleanup;
            }
        }


        if ( ppValueList != NULL ) {

            //
            // the DN could be in the format of <GUID=...>;CN=...
            // extract the <GUID part out before passing over to the next function
            //
            RealDn = wcschr(*ppValueList, L';');

            if ( RealDn == NULL ) {
                //
                // if <GUID...>; format is not there, use the whole string as DN
                //
                RealDn = *ppValueList;
            } else {
                //
                // move to the next char for CN=...
                //
                RealDn++;
            }

            WinStatus = AzpApplyPolicyAcls(
                            pContext,
                            *ppObject,
                            RealDn,
                            lPersistFlags,
                            FALSE );    // Don't just do PolicyAdmins

            if ( !AzpPressOn(WinStatus, lPersistFlags, &WinStatusActual) ) {
                AzPrint(( AZD_AD,
                          "AzpReadADStoreObject: Failed to apply"
                          " policy ACLs: %ld\n",
                          WinStatus
                          ));
                goto Cleanup;
            }

        }

        //
        // Compute the GUIDized CN name of the object we read.
        //

        if ( ObjectType == OBJECT_TYPE_APPLICATION ||
             ObjectType == OBJECT_TYPE_SCOPE ) {

            LPWSTR TempString;

            //
            // If we don't already know the GUIDized CN,
            //  build it from the DN we read.
            //
            TempString = (LPWSTR) AdAzrolesInfo->AzpeGetProviderData( *ppObject );

            if ( TempString == NULL ) {
                LPWSTR CnEnd;
                ULONG CnLen;

                //
                // If the DN couldn't be read,
                //  that's fatal.  We really nead the name.
                //

                if ( RealDn == NULL ) {
                    if ( WinStatusActual == NO_ERROR ) {
                        WinStatusActual = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    goto Cleanup;
                }

                //
                // Truncate the extraneous data from the DN
                //
                // RealDn is of the form CN=Guid,...
                // Truncate the ...
                //

                CnEnd = wcschr( RealDn, L',' );

                if ( CnEnd == NULL ) {
                    if ( WinStatusActual == NO_ERROR ) {
                        WinStatusActual = ERROR_INVALID_NAME;
                    }
                    goto Cleanup;
                }

                CnEnd ++;
                CnLen = (ULONG)(CnEnd-RealDn);

                //
                // Allocate a buffer for the string
                //

                TempString = (LPWSTR) AzpAllocateHeap( (CnLen+1) * sizeof(WCHAR), "BLDCN4" );

                if ( TempString == NULL ) {
                    if ( WinStatusActual == NO_ERROR ) {
                        WinStatusActual = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    goto Cleanup;
                }

                //
                // Save the CN for later use
                //
                wcsncpy( TempString, RealDn, CnLen );
                TempString[CnLen] = '\0';

                AdAzrolesInfo->AzpeSetProviderData( *ppObject, (PVOID)TempString );

            }

        }

    } // if IsContainerObject


    //
    // A check is made if the object is writable or not.  If the object is of a non-container type, then
    // the parents IsWritable property is read.  If that is true, then the thought is that if the parent
    // object is writable, then all its children object are writable as well.
    //
    // However, for delegated scope objects, the object is not writable but children for it can
    // be created.  Figure this out.
    //

    WinStatus = AzpADPersistWritable(
                    pContext,
                    *ppObject,
                    pEntry,
                    &IsWritable,
                    &CanCreateChildren );

    if ( !AzpPressOn(WinStatus, lPersistFlags, &WinStatusActual) ) {

        AzPrint(( AZD_AD,
                  "AzpReadADStoreObject: AzpADPersistWritable failed: %ld\n",
                  WinStatus
                  ));

        goto Cleanup;

    }

    //
    // Tell the core about the object options
    //

    WinStatus = AzpADSetObjectOptions(
                    pContext,
                    *ppObject,
                    lPersistFlags,
                    IsWritable,
                    CanCreateChildren );

    if ( !AzpPressOn(WinStatus, lPersistFlags, &WinStatusActual) ) {

        AzPrint(( AZD_AD,
                  "AzpADSetObjectOptions failed: %ld\n",
                  WinStatus
                  ));

        goto Cleanup;

    }

Cleanup:

    //
    // If error has occured, return to calling function with WinStatus
    // for cleanup
    //

    return WinStatusActual;
}

DWORD
AzpReadAttributeAndSetProperty(
    IN PAZP_AD_CONTEXT pContext,
    IN LDAPMessage *pAttrEntry,
    IN LDAP* pLdapH,
    IN OUT AZPE_OBJECT_HANDLE pObject,
    IN ULONG AttrType,
    IN LPWSTR pAttr,
    IN ULONG DataType,
    IN ULONG lPersistFlags
    )
/*++

Routine Description:

        This routine reads the values from a passed LDAPMessage structure, and
        calls persistence layer API to update the cache.  Link attributes need
        to be handled in a different way.  When a link attribute is encountered,
        it is assumed that the linked object is already loaded in cache
        (sequence of loading objects followed).
        Set the object list accordingly and add the object referenced by
        AZ_AD_OBJECT_NAME accordingly.

Arguments:

        pContext - context for the store

        pAttrEntry - Pointer to LDAPMessage to read values from

        pLdapH - Handle to the AD store from where the policy was read

        pObject - Pointer to the object in the cache under which
                which needs to be modified

        AttrType - Property ID of attribute of object of type ObjectType that
                needs to to filled in

        pAttr - Value for attribute of type AttrType that will be filled in

        DataType - Data type of attribute value

        lPersistFlags - lPersistFlags from the persist engine describing the
                operation


Return Value:

        NO_ERROR - The attribute for the particular object was successfully
                populated
        Other status codes returned from ldap_* and object set property calls
--*/
{
    DWORD WinStatus = 0;

    PWCHAR *ppValueList = NULL;

    LONG LongTypeData = 0;
    PVOID pVoidTypeData = NULL;
    BOOL bBoolTypeData = FALSE;

    //
    // Check if this is a linked attribute, and then call the routine to set
    // the linked attribute
    //

    switch ( AttrType ) {

        case AZ_PROP_TASK_OPERATIONS:
        case AZ_PROP_TASK_TASKS:
        case AZ_PROP_ROLE_MEMBERS:
        case AZ_PROP_ROLE_OPERATIONS:
        case AZ_PROP_ROLE_TASKS:
        case AZ_PROP_GROUP_MEMBERS:
        case AZ_PROP_GROUP_NON_MEMBERS:

            WinStatus = AzpReadLinkedAttribute(
                            pContext,
                            pLdapH,
                            pAttrEntry,
                            pObject,
                            AttrType,
                            pAttr,
                            lPersistFlags
                            );

            if ( WinStatus != NO_ERROR ) {

                AzPrint(( AZD_AD,
                          "AzpReadAttributeAndSetProperty:"
                          "AzpADReadLinkedAttribute failed for attribute %ws "
                          "of %ws: %ld\n",
                          pAttr,
                          L"<Unknown>", // AzpeObjectName(pObject),
                          WinStatus
                          ));
            }

            goto Cleanup;

        default:

            break;
    }

    //
    // Get the list of values for the attribute entry
    //

    ppValueList = ldap_get_values(
                      pLdapH,
                      pAttrEntry,
                      pAttr
                      );

    if ( ppValueList != NULL ) {

        //
        // Need to convert the PWCHAR attribute value to its true
        // type to be stored in the cache.
        //

        switch (DataType) {

            case ENUM_AZ_LONG:

                LongTypeData = _wtol( *ppValueList );

                pVoidTypeData = (PVOID) &LongTypeData;
                break;

            case ENUM_AZ_GROUP_TYPE:

                LongTypeData = _wtol( *ppValueList );

                if ( LongTypeData == AZ_AD_BASIC_GROUP ) {

                    LongTypeData = AZ_GROUPTYPE_BASIC;

                } else {

                    LongTypeData = AZ_GROUPTYPE_LDAP_QUERY;

                }

                pVoidTypeData = (PVOID) &LongTypeData;
                break;

            case ENUM_AZ_BSTR:

                pVoidTypeData = (PVOID) *ppValueList;
                break;

            case ENUM_AZ_BOOL:

                if ( !_wcsicmp( *ppValueList, L"TRUE" ) ) {

                    bBoolTypeData = TRUE;

                    pVoidTypeData = (PVOID) &bBoolTypeData;

                } else {

                    bBoolTypeData = FALSE;

                    pVoidTypeData = (PVOID) &bBoolTypeData;
                }

                break;

            default:

                WinStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
        }

        WinStatus = AdAzrolesInfo->AzpeSetProperty(
                                       pObject,
                                       lPersistFlags,
                                       AttrType,
                                       pVoidTypeData
                                       );

        if ( WinStatus != NO_ERROR ) {

            goto Cleanup;
        }

    } // if ( ppValueList != NULL )

    WinStatus = NO_ERROR;

 Cleanup:

    //
    // Free up used resource
    //

    if ( ppValueList != NULL ) {

        ldap_value_free( ppValueList );
    }

    return WinStatus;
}

DWORD
AzpReadLinkedAttribute(
    IN PAZP_AD_CONTEXT pContext,
    IN LDAP* pLdapH,
    IN LDAPMessage *pAttrEntry,
    IN OUT AZPE_OBJECT_HANDLE pObject,
    IN ULONG AttrType,
    IN LPWSTR pAttr,
    IN ULONG lPersistFlags
    )
/*++

Routine Description:

      This routine reads the linked attributes of objects and stores the
      SID or GUID value in the linked attribute of the cache object linking
      to them.

Arguments:
      pContext - context for the store

      pAttrEntry - Pointer to LDAPMessage to read values from

      pLdapH - Handle to the AD store from where the policy was read

      pObject - Handle to the object in the cache under which
              which needs to be modified

      AttrType - Property ID of attribute of object of type ObjectType that needs
              to filled in

      pAttr - Value for attribute of type AttrType that will be filled in

      DataType - Data type of attribute value

      lPersistFlags - lPersistFlags from the persist engine describing the
                operation

Return Value:

      NO_ERROR - The attribute for the particular object was successfully
         populated

      Other status codes

--*/
{
    DWORD WinStatus = 0;

    PWCHAR *ppValueList = NULL;
    PWCHAR *ppV = NULL;

    GUID guid;

    PSID pSid = NULL;

    ULONG lTempAttrType = 0;

    //
    // Validation
    //

    ASSERT( pObject != NULL );
    ASSERT( pAttrEntry != NULL );


    //
    // Get the list of values for the attribute entry
    //

    DWORD dwCurrentStart = 0;
    DWORD dwReadCount = 0;

    LDAPMessage *pResult = NULL;
    LDAPMessage *pObjectEntry = NULL;

    LPWSTR pObjectDN = NULL;

    //
    // We may have to read ranged attribute
    //

    LPCWSTR pwsFmt = L"%s;range=%d-%d";
    LPCTSTR pwsFmtRem = L"%s;range=%d-*";

    //
    // Here 21 is for the 2 maximum lengths DWORD decimal integer (10 each) and 1 for zero terminator
    // Actually, this length is more than needed.
    //

    size_t Length = wcslen(pAttr) + wcslen(pwsFmt) + 21;

    LPWSTR pwszRangedAttr = (LPWSTR) AzpAllocateHeap( sizeof(WCHAR) * Length, "RNGATTR" );

    if (pwszRangedAttr == NULL)
    {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    while (WinStatus == NO_ERROR)
    {
        memset(pwszRangedAttr, 0, sizeof(WCHAR) * Length);
        wnsprintf(pwszRangedAttr, (int)Length, pwsFmt, pAttr, dwCurrentStart, dwCurrentStart + MAX_RANGE_ATTR_READ_ATTEMPT - 1);
        BOOL bTryRange = (dwReadCount == MAX_RANGE_ATTR_READ_ATTEMPT);

        dwReadCount = 0;

        if (!bTryRange)
        {
            ppValueList = ldap_get_values(
                            pLdapH,
                            pAttrEntry,
                            pAttr
                            );
        }
        else
        {
            PWCHAR pwszRangedAttrList[] = {pwszRangedAttr, NULL};

            if ( pResult != NULL )
            {
                ldap_msgfree( pResult );
                pResult = NULL;
            }

            if (pObjectDN == NULL)
            {
                //
                // build only once.
                //

                WinStatus = AzpADBuildDN(
                    pContext,
                    pObject,
                    &pObjectDN,
                    NULL,
                    FALSE,
                    NULL
                    );

                if (WinStatus != NO_ERROR)
                {
                    goto Cleanup;
                }
            }

            //
            // we need to do ranged search using the current ranged attribute
            //

            BOOL bAlreadyRetried = FALSE;

            TryAgain:

            LONG LdapStatus = ldap_search_ext_s(
                        pLdapH,
                        pObjectDN,
                        LDAP_SCOPE_BASE,
                        AZ_AD_ALL_CLASSES,
                        pwszRangedAttrList,
                        0,
                        pContext->pLdapControls,
                        NULL,
                        NULL,
                        0,
                        &pResult
                        );

            if ( LdapStatus != LDAP_SUCCESS )
            {
                if (LdapStatus != LDAP_OPERATIONS_ERROR && 
                    LdapStatus != LDAP_NO_RESULTS_RETURNED &&
                    bAlreadyRetried)
                {
                    WinStatus = LdapMapErrorToWin32( LdapStatus );
                    goto Cleanup;
                }
            }
            else
            {
                pObjectEntry = ldap_first_entry( pLdapH, pResult );
            }

            if (pObjectEntry != NULL)
            {
                ppValueList = ldap_get_values( pLdapH, pObjectEntry, pwszRangedAttr );
            }

            if ( (ppValueList == NULL || *ppValueList == NULL) && !bAlreadyRetried )
            {
                //
                // Believe or not, we may fail to read the last batch when the batch
                // has less than 1500 values. Only in this case can we read the values
                // with open ended wildcard. Not well designed implementation
                //

                //
                // Re-build the wildcard attribute
                //

                memset(pwszRangedAttr, 0, sizeof(WCHAR) * Length);
                wnsprintf(pwszRangedAttr, (int)Length, pwsFmtRem, pAttr, dwCurrentStart);

                //
                // don't leak our last search result
                //

                if ( pResult != NULL )
                {
                    ldap_msgfree( pResult );
                    pResult = NULL;
                }
                bAlreadyRetried = TRUE;

                goto TryAgain;  // i feel this is a good use of goto.
            }
        }

        if ( ppValueList != NULL ) {

            ppV = ppValueList;

            if (*ppV == NULL)
            {
                //
                // When we start reading the first batch, we don't know that we need
                // to read the ranged attribute. But a non-null empty list indicates
                // that we need to try the ranged reading. After this, we will already
                // know that we need to do ranged reading.
                //

                ppValueList = ldap_get_values( pLdapH, pAttrEntry, pwszRangedAttr );
                if ( ppValueList != NULL )
                {
                    ppV = ppValueList;
                }
            }

            while ( *ppV != NULL ) {

                //
                // value(s) exist for this attribute
                // Need to save the current attribute type.  This is needed
                // because of maintenance of group app members/non-members and
                // role app members in the core cache, but no such attribute exists
                // in the DS.  Both SID (non)members in DS are stored under the same
                // attribute.  Restore the AttrType for next value at the end of the
                // while loop.
                //

                lTempAttrType = AttrType;

                WinStatus = AzpADParseLinkedAttributeValue(
                                *ppV,
                                &pSid,
                                &guid,
                                &AttrType,
                                pContext
                                );

                if ( WinStatus != NO_ERROR ) {

                    AzPrint(( AZD_AD,
                            "AzpReadLinkedAttribute:"
                            "AzpADParseLinkedAttributeValue failed for %ws: %ld\n",
                            *ppV,
                            WinStatus
                            ));

                    goto Cleanup;
                }

                //
                // Now add the linked object to the link property
                // for this object
                //

                if ( pSid != NULL ) {


                    WinStatus = AdAzrolesInfo->AzpeAddPropertyItemSid(
                                                pObject,
                                                lPersistFlags,
                                                AttrType,
                                                pSid );

                    if ( WinStatus != NO_ERROR ) {

                        AzPrint(( AZD_AD,
                                "AzpReadAttributeAndSetProperty: "
                                "AzpeAddPropertyItem failed"
                                ": %ld\n",
                                WinStatus ));
                        goto Cleanup;
                    }

                    LocalFree( pSid );

                    pSid = NULL;


                } else { // if ( pSid!=NULL )

                    //
                    // Add the linked object to the link property
                    // for this object
                    //

                    //
                    // In anticipation for NDNC, we will add all objects without
                    // SID using its GUIDs.
                    //

                    WinStatus = AdAzrolesInfo->AzpeAddPropertyItemGuid(
                                                pObject,
                                                lPersistFlags,
                                                AttrType,
                                                &guid
                                                );

                    if ( WinStatus != NO_ERROR ) {

                        AzPrint(( AZD_AD,
                                "AzpADReadAttributeAndSetProperty:"
                                "AzpeAddPropertyItemGuid failed on"
                                ": %ld\n",
                                WinStatus ));
                        goto Cleanup;
                    }

                } // if ( bSidObject ) ... else

                //
                // increment to the next attribute value
                //

                dwReadCount++;
                ppV++;

                AttrType = lTempAttrType;

            } // while ( *ppValueList != NULL )


        } // if ( ppValueList != NULL )

        if ( ppValueList != NULL )
        {
            ldap_value_free ( ppValueList );
            ppValueList = NULL;
        }

        if (dwReadCount < MAX_RANGE_ATTR_READ_ATTEMPT)
        {
            break;
        }
        else
        {
            dwCurrentStart += MAX_RANGE_ATTR_READ_ATTEMPT;
        }

    }

    WinStatus = NO_ERROR;

 Cleanup:

    //
    // Free up used resource
    //

    if ( pSid != NULL ) {

        LocalFree( pSid );

    }

    if ( ppValueList != NULL )
    {
        ldap_value_free ( ppValueList );
    }

    if ( pResult != NULL )
    {
        ldap_msgfree( pResult );
    }

    if (pwszRangedAttr != NULL)
    {
        AzpFreeHeap(pwszRangedAttr);
    }

    if (pObjectDN != NULL)
    {
        AzpFreeHeap(pObjectDN);
    }

    return WinStatus;
}

DWORD
AzpADParseLinkedAttributeValue(
    IN  PWCHAR pValue,
    OUT PSID   *ppSid,
    OUT GUID   *pGuid,
    IN  OUT PULONG  pAttrType,
    IN  PAZP_AD_CONTEXT pContext
    )
/*++

Routine Description:

        This routine parses a linked attribute value to return the GUID or SID.

Arguments:

        pValue   - The linked attribute value to be parsed

        ppSid    - Pointer to returned SID if SID exists

        pGuid    - The returned GUID if SID does not exist

        pAttrType - Pointer to type of attribute that is being parsed

        pContext - Context for the LDAP provider

Return Values:

        NO_ERROR - The value was parsed successfully

        ERROR_NOT_ENOUGH_MEMORY

--*/
{
    DWORD  WinStatus = 0;
    ULONG  LdapStatus = 0;

    LDAPMessage *pResult = NULL;
    LDAPMessage *pEntry = NULL;

    PWCHAR *ppValueList = NULL;

    PWCHAR pSearchDN = NULL;

    ULONG lGroupType = 0;

    //
    // Validation
    //

    ASSERT( pValue != NULL );

    //
    // Parse the guid and sid (if any)
    //

    WinStatus = AzpADGetGuidAndSID(pValue, pGuid, ppSid, &pSearchDN);

    if (NO_ERROR != WinStatus)
    {
        goto Cleanup;
    }

    //
    // If the attribute we are reading happens to be AZ_PROP_*_MEMBERS
    // or AZ_PROP_GROUP_NON_MEMBERS, then we need to read the object
    // with the specified DN to check their objectType.  If they are groups,
    // and they are ldap-query based, then their GUID needs to be read, else
    // read their SID
    //

    if ( *pAttrType == AZ_PROP_GROUP_MEMBERS ||
         *pAttrType == AZ_PROP_GROUP_NON_MEMBERS ||
         *pAttrType == AZ_PROP_ROLE_MEMBERS ) {

        //
        // Perform a base level search on the DN we are parsing
        // The DN is in the form <GUID=xxxxx>;<SID=yyyyy>;<DN>
        // We need to extract the <DN> and perform the search on that
        //

        LdapStatus = ldap_search_s(
                            pContext->ld,
                            pSearchDN,
                            LDAP_SCOPE_BASE,
                            AZ_AD_ALL_CLASSES,
                            NULL,
                            0,
                            &pResult
                            );

        if ( LdapStatus != LDAP_SUCCESS ) {

            WinStatus = LdapMapErrorToWin32( LdapStatus );

            AzPrint(( AZD_AD,
                        "AzpADParseLinkedAttributeValue: Failed to run search for"
                        " group type for %ws: %ld\n",
                        pSearchDN,
                        WinStatus
                        ));
            goto Cleanup;
        }

        pEntry = ldap_first_entry( pContext->ld, pResult );

        if ( pEntry != NULL ) {

            ppValueList = ldap_get_values( pContext->ld,
                                            pEntry,
                                            AZ_AD_GROUP_TYPE
                                            );

            if ( ppValueList != NULL ) {

                //
                // We have the group type.  Compare it with known
                // group types to identify whether SID should be read
                // or GUID
                //

                lGroupType = _wtol( *ppValueList );

                if ( lGroupType == AZ_AD_BASIC_GROUP ||
                     lGroupType == AZ_AD_QUERY_GROUP ) {

                    //
                    // we have no need for the SID, free it
                    //

                    if (NULL != *ppSid)
                    {
                        LocalFree((HLOCAL)*ppSid);
                        *ppSid = NULL;
                    }

                    if ( *pAttrType == AZ_PROP_GROUP_MEMBERS ) {

                        *pAttrType = AZ_PROP_GROUP_APP_MEMBERS;

                    } else if ( *pAttrType == AZ_PROP_GROUP_NON_MEMBERS ) {

                        *pAttrType = AZ_PROP_GROUP_APP_NON_MEMBERS;

                    } else if ( *pAttrType == AZ_PROP_ROLE_MEMBERS ) {

                        *pAttrType = AZ_PROP_ROLE_APP_MEMBERS;

                    }
                }

            }
        }

    } // if AttrType is member/non-member/role member

    WinStatus = NO_ERROR;

 Cleanup:

    //
    // release local memory
    //

    if ( ppValueList != NULL ) {

        ldap_value_free( ppValueList );
    }

    if ( pResult != NULL ) {

        ldap_msgfree( pResult );
    }

    return WinStatus;
}

DWORD
AzpADGetGuidAndSID (
    IN  LPCWSTR  pwstrValue,
    OUT GUID   * pGuid,
    OUT PSID   * ppSid OPTIONAL,
    OUT LPWSTR * ppwstrDN
    )
/*

Description:

    This routine parses a linked attribute value to return the
    GUID and SID (if present and requested).

Arguments:

    pwstrValue  - The linked attribute value to be parsed

    pGuid       - Receives GUID

    ppSid       - Receives the SID if requested and present in pwstrValue

    ppwstrDN    - Point to the DN portion when this function successfully returns.

Return Values:

    NO_ERROR - The value was parsed successfully

    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

Note:
    1. The returned SID must be released by LocalFree.
    2. On error, the passed back ppwstrDN can't be trusted.

*/
{
    if ( NULL == pwstrValue || NULL == pGuid || NULL == ppwstrDN )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Some good clean initial values
    //

    if (NULL != ppSid)
    {
        *ppSid = NULL;
    }

    *pGuid = GUID_NULL;
    *ppwstrDN = NULL;

    //
    // These tiny array will be used for converting double wchars to
    // a BYTE for both binary GUID and SID
    //

    WCHAR hexByte[3];
    hexByte[2] = L'\0';

    DWORD dwStatus = NO_ERROR;

    //
    // We require that GUID is present
    //

    LPWSTR pwszCur = wcsstr( pwstrValue, GUID_LINK_PREFIX );
    if (NULL == pwszCur)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // skip over the prefix itself
    //

    pwszCur += GUID_LINK_PREFIX_LENGTH;

    //
    // Get to the matching suffix
    //

    LPWSTR pwszEnd = wcsstr( pwszCur, GUIDSID_LINK_SUFFIX );

    if (NULL == pwszEnd)
    {
        return ERROR_INVALID_PARAMETER;
    }
    else
    {
        AZASSERT( pwszEnd - pwszCur == sizeof(GUID) * 2 );

        PBYTE pbguid = (PBYTE)pGuid;

        //
        // Decode hex digit stream
        //

        for ( int i = 0; i < sizeof (GUID); i++ )
        {
            hexByte[0] = towlower( pwszCur[2 * i] );
            hexByte[1] = towlower( pwszCur[2 * i + 1] );

            if ( iswxdigit( hexByte[0] ) && iswxdigit( hexByte[1] ) )
            {
                *pbguid = (BYTE) wcstol( hexByte, NULL , 16 );
                pbguid++;
            }
            else
            {
                //
                // If the byte is not a hex digit, then some error has occured
                // Return this to the caller
                //

                return ERROR_INVALID_PARAMETER;
            }
        }
    }

    //
    // move pass the suffix and the delimiting ';'
    //

    pwszCur = pwszEnd + GUIDSID_LINK_SUFFIX_LENGTH + 1;

    //
    // If no SID is present, then this will be where DN portion starts
    //

    *ppwstrDN = pwszCur;

    //
    // Find the SID prefix
    //

    pwszCur = wcsstr( pwstrValue, SID_LINK_PREFIX );

    if ( NULL != pwszCur )
    {
        pwszCur += SID_LINK_PREFIX_LENGTH;
        pwszEnd = wcsstr( pwszCur, GUIDSID_LINK_SUFFIX );

        if (NULL == pwszEnd)
        {
            //
            // no matching suffix is invalid
            //

            dwStatus = ERROR_INVALID_PARAMETER;
        }
        else
        {
            //
            // if SID requested, then we need to generate the binary SID
            // using the byte string.
            //

            if (NULL != ppSid)
            {
                BYTE byteSid[SECURITY_MAX_SID_SIZE];

                PBYTE pbDest = byteSid;

                while ( pwszCur < (pwszEnd - 1) )
                {
                    hexByte[0] = towlower( *pwszCur );
                    hexByte[1] = towlower( *(pwszCur + 1) );

                    if ( iswxdigit( hexByte[0] ) && iswxdigit( hexByte[1] ) )
                    {
                        *pbDest = (BYTE) wcstol( hexByte, NULL , 16 );
                        pbDest++;
                    }
                    else
                    {
                        //
                        // If the byte is not a hex digit, then some error has occured
                        // Return this to the caller
                        //

                        return ERROR_INVALID_PARAMETER;
                    }

                    pwszCur += 2;

                    //
                    // We will terminate if we have already passed the max we can take
                    //

                    if ( pbDest > byteSid + SECURITY_MAX_SID_SIZE )
                    {
                        break;
                    }
                }

                DWORD cbSid = GetLengthSid( (PSID)byteSid );

                //
                // Call LocalFree in calling function
                //

                *ppSid = (PSID) LocalAlloc( LPTR, cbSid );

                if ( *ppSid == NULL )
                {
                    dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    CopyMemory( *ppSid, (PSID)byteSid, cbSid );
                }
            }

            //
            // move pass the suffix and the delimiting ';'.
            // Just in case, GUID follows SID, we don't update the DN position blindly
            //

            if (*ppwstrDN < pwszEnd)
            {
                *ppwstrDN = pwszEnd + GUIDSID_LINK_SUFFIX_LENGTH + 1;
            }
        }
    }

    return dwStatus;
}

DWORD
AzpApplyPolicyAcls(
    IN PAZP_AD_CONTEXT pContext,
    IN OUT AZPE_OBJECT_HANDLE pObject,
    IN PWCHAR pDN,
    IN ULONG lPersistFlags,
    IN BOOL OnlyAddPolicyAdmins
    )
/*++

Routine Description:

        This routine applies the store ACLs into the policy admins and readers
        list for the passed in object.  If the object is one that can give delegation
        rights, then reads in the delegated user's list as well.

Arguments:

        pContext - context for the store

        pObject - Pointer to object on whom the store ACLs need to be applied

        pDN - DN of the object to the ACLs off from.

        lPersistFlags - Flags from the persist engine

        OnlyAddPolicyAdmins - TRUE if only PolicyAdmins is to be updated in azroles

Return Values:

        NO_ERROR - The ACLs were loaded successfully

        Other status codes

--*/
{

    DWORD WinStatus = 0;
    BOOLEAN DoSacl;

    ULONG lObjectType = AdAzrolesInfo->AzpeObjectType(pObject);

    PSECURITY_DESCRIPTOR pSD = NULL;

    //
    // Validation
    //

    ASSERT( pObject != NULL );
    ASSERT( pDN != NULL );

    //
    // Only do the SACL if requested and the caller has privilege
    //

    DoSacl = !OnlyAddPolicyAdmins && pContext->HasSecurityPrivilege;

    //
    // Get the AZ_AD_NT_SECURITY_DESCRIPTOR for the object
    //

    WinStatus = AzpADReadNTSecurityDescriptor(
                    pContext,
                    pObject,
                    pDN,
                    FALSE, // no need to read authorization store's DS parent
                    &pSD,
                    DoSacl, // Optionally read SACL
                    TRUE  // read DACL
                    );

    if ( WinStatus != NO_ERROR ) {

        AzPrint(( AZD_AD,
                  "AzpApplyPolicyAcls: AzpADReadNTSecurityDescriptor failed"
                  " :%ld\n",
                  WinStatus
                  ));
        goto Cleanup;
    }

    //
    // Set the policy readers, admins and delegated users
    //

    WinStatus = AdAzrolesInfo->AzpeSetSecurityDescriptorIntoCache(
                                   pObject,
                                   pSD,
                                   lPersistFlags,
                                   (lObjectType == OBJECT_TYPE_SCOPE)?&DelegatedScopeAdminsRights:&PolicyAdminsRights,
                                   OnlyAddPolicyAdmins ? NULL : &PolicyReadersRights,
                                   OnlyAddPolicyAdmins ? NULL : &DelegatedParentReadersInheritRights,
                                   (DoSacl ? &AdSaclRights : NULL)
                                   );

    if ( WinStatus != NO_ERROR ) {

        AzPrint(( AZD_AD,
                  "AzpADApplyPolicyAcls: AzpeSetSecurityDescriptorIntoCache failed:"
                  ": %ld\n",
                  WinStatus
                  ));

        goto Cleanup;
    }

    WinStatus = NO_ERROR;

 Cleanup:

    //
    // Free local resources
    //

    AdAzrolesInfo->AzpeFreeMemory( pSD );

    return WinStatus;

}

//
// Routines used by AzpADPersistSubmit to submit
// objects in the cache to the AD policy store
//

DWORD
AzpUpdateADObject(
    IN PAZP_AD_CONTEXT pContext,
    IN LDAP* pLdapHandle,
    IN OUT AZPE_OBJECT_HANDLE pObject,
    IN PWCHAR pDN,
    IN PWCHAR pObjectClass,
    IN AZ_AD_ATTRS ObjectAttrs[],
    IN ULONG lPersistFlags
    )
/*++

Routine Description:

        This routine updates the DS for a object according
        to the dirty bits of the object.

Arguments:

        pContext - context for the store

        pLdapHandle - Handle to the DS policy store

        pObject - Object that needs to be updated in the DS.  If it is a newly
                created object then the DS is read for the GUID value of this
                object, and the GUID for this object in the cache is set.

        pDN - The DN of the object

        pObjectClass - Class of the object in DS

        ObjectAttrs - A NULL terminated list of attributes to be updated.  Pass
                NULL if there are no specific attributes that need to be read

        lPersistFlags - lPersistFlags from the persist engine describing the
                operation

Return Values:

        NO_ERROR - The object was successfully added/modified in the DS
        Other status codes (LDAP)
--*/
{

    DWORD WinStatus = 0;
    ULONG LdapStatus = 0;

    LDAPMod **ppAttributeList = NULL;

    ULONG i = 0;

    LDAPMessage* pResult = NULL;
    LDAPMessage* pEntry = NULL;
    LDAP_BERVAL **ppBerVal = NULL;

    LDAPControl **ppLdapServerControl = NULL;

    ULONG lObjectType = AdAzrolesInfo->AzpeObjectType(pObject);
    ULONG lDirtyBits = AdAzrolesInfo->AzpeDirtyBits(pObject);

    BOOL IsWritable;
    BOOL CanCreateChildren = FALSE;

    PWCHAR pObjectContainerDN = NULL;

    ULONG lIndex = 0;

    BOOL bCreateFlag = lDirtyBits & AZ_DIRTY_CREATE;

    //
    // Validation
    //

    ASSERT( pObject != NULL );
    ASSERT( pDN != NULL );

    //
    // Initialize the attribute list.  If nay linked attribute is being updated,
    // then
    //

    WinStatus = AzpADAllocateAttrHeap(
                    AZ_AD_MAX_ATTRS,
                    &ppAttributeList
                    );

    if ( WinStatus != NO_ERROR ) {

        goto Cleanup;

    }

    //
    // Get server controls
    //

    ppLdapServerControl = pContext->pLdapControls;

    //
    // Check if this is a new object.  If so, then set the
    // objectClass of the object being added to DS
    //

    if ( bCreateFlag ) {

        WinStatus = AzpGetAttrsForCreateObject(
                        pObjectClass,
                        ppAttributeList
                        );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpUpdateADObject: AzpGetAttrsForCreateObject failed for"
                      " %ws: %ld\n",
                      pDN,
                      WinStatus
                      ));
            goto Cleanup;
        }

        lIndex++;
    }

    //
    // Check if any of the common attributes need to be updated
    //

    if ( lDirtyBits & AZ_DIRTY_COMMON_ATTRS ) {

        WinStatus = AzpGetADCommonAttrs(
                        pLdapHandle,
                        pObject,
                        CommonAttrs,
                        lPersistFlags,
                        ppAttributeList,
                        &lIndex,
                        bCreateFlag
                        );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpUpdateADObject: AzpGetADCommonAttrs failed"
                      ": %ld\n",
                      WinStatus
                      ));
            goto Cleanup;
        }
    }

    //
    // Loop through the attributes.  Best is to know what the
    // maximum number of attributes any object may have, and break when
    // you encounter the end of list attribute for the object
    //

    for ( i = 0; i < (AZ_AD_MAX_NON_COMMON_ATTRS + 1); i++ ) {

        if ( ObjectAttrs[i].AttrType == AZ_AD_END_LIST ) {

            //
            // No more attributes to be read
            //

            break;
        }

        //
        // Update only if the particular object attribute is dirty
        // If during create, the group type of an AzApplicationGroup
        // has not been set dirty, we need to add that to the
        // attribute structure.  Also during create, for AzOperation objects,
        // it might not be necessary that an operation Id be present.  However,
        // DS expects an operation ID to be present.
        //

        if ( AzpIsAttrDirty( pObject, ObjectAttrs[i] ) ||
             ( bCreateFlag &&
               ( (ObjectAttrs[i].AttrType == AZ_PROP_GROUP_TYPE) ||
                 (ObjectAttrs[i].AttrType == AZ_PROP_OPERATION_ID) ) ) ) {


            //
            // Get specific object properties
            //

            WinStatus  = AzpGetSpecificProperty(
                             pObject,
                             ppAttributeList,
                             &lIndex,
                             ObjectAttrs[i],
                             lPersistFlags,
                             bCreateFlag
                             );

            if ( WinStatus != NO_ERROR ) {

                AzPrint(( AZD_AD,
                          "AzpUpdateADObject: Get property failed "
                          " for %s: %ld\n",
                          pDN,
                          WinStatus ));
                goto Cleanup;
            }

            if ( ppAttributeList[lIndex] != NULL ) {

                ppAttributeList[lIndex]->mod_op = bCreateFlag ? LDAP_MOD_ADD : LDAP_MOD_REPLACE;

                ppAttributeList[lIndex]->mod_type = ObjectAttrs[i].Attr;

                lIndex++;
            }

        } // if ( lDirtyBits & ObjectAttrs[i].lDirtyBit )

    } // for (i<AZ_AD_MAX_ATTRS)

    //
    // Create/modify the DS object with the properties read from cache
    // Do so only if scalar properties have changed
    //

    if ( ppAttributeList[0] != NULL ) {

        if ( bCreateFlag ) {

            LdapStatus = ldap_add_s(
                             pLdapHandle,
                             pDN,
                             ppAttributeList
                             );

        } else {

            LdapStatus = ldap_modify_ext_s(
                             pLdapHandle,
                             pDN,
                             ppAttributeList,
                             ppLdapServerControl,
                             NULL
                             );
        }

        if ( LdapStatus != LDAP_SUCCESS ) {

            WinStatus = LdapMapErrorToWin32( LdapStatus );

            AzPrint(( AZD_AD,
                      "AzpUpdateADObject: Failed to add/modify"
                      " %ws : %ld %ld\n",
                      pDN,
                      WinStatus,
                      LdapStatus ));
            goto Cleanup;
        }

        PWCHAR Attrs[] = {
            AZ_AD_OBJECT_GUID,
            AZ_AD_OBJECT_WRITEABLE,
            AZ_AD_OBJECT_CHILD_CREATE,
            NULL
        };

        //
        // Search the object for base scope level
        //

        LdapStatus = ldap_search_s(
                         pLdapHandle,
                         pDN,
                         LDAP_SCOPE_BASE,
                         AZ_AD_ALL_CLASSES,
                         Attrs,
                         0,
                         &pResult
                         );

        if ( LdapStatus != LDAP_SUCCESS ) {

            WinStatus = LdapMapErrorToWin32( LdapStatus );
            AzPrint(( AZD_AD,
                      "AzpUpdateADObject: Failed to search object"
                      " %s: %ld\n",
                      pDN,
                      WinStatus
                      ));
            goto Cleanup;
        }

        pEntry = ldap_first_entry( pLdapHandle, pResult );

        if ( pEntry == NULL ) {

            //
            // should have a value
            //

            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }


        //
        // Now read the GUID of the object in DS and set it for the cached object
        // This is read only if the object has been added to the DS and the object is
        // not AzAuthorizationStore
        //

        if ( lObjectType != OBJECT_TYPE_AZAUTHSTORE && bCreateFlag ) {

            //
            // Retrieve the GUID
            //

            ppBerVal = ldap_get_values_len(
                           pLdapHandle,
                           pEntry,
                           AZ_AD_OBJECT_GUID
                           );

            //
            // There should be no error in recovering the GUID
            //

            if ( ppBerVal == NULL ) {

                WinStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }

            //
            // Assign the GUID to the object
            //

            *AdAzrolesInfo->AzpePersistenceGuid(pObject) = *( (GUID*)ppBerVal[0]->bv_val);
        }

        //
        // Tell azroles whether this object is writable
        //
        // Also, figure out if children can be created under it
        //


        WinStatus = AzpADPersistWritable(
                        pContext,
                        pObject,
                        pEntry,
                        &IsWritable,
                        &CanCreateChildren );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpUpdateADObject: Read writable failed"
                      ": %ld\n",
                      WinStatus
                      ));
            goto Cleanup;
        }

        //
        // Tell the core about the object options
        //

        WinStatus = AzpADSetObjectOptions(
                        pContext,
                        pObject,
                        lPersistFlags,
                        IsWritable,
                        CanCreateChildren );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }
    }

    if ( bCreateFlag &&
         (lObjectType == OBJECT_TYPE_APPLICATION ||
          lObjectType == OBJECT_TYPE_AZAUTHSTORE ||
          lObjectType == OBJECT_TYPE_SCOPE) ) {

        //
        // If this newly created DS object is an AzApplication/AzAuthorizationStore/AzScope
        // object, then we need to create a child container objects under it that will
        // hold child objects such as AzOperation, AzTask, etc except child AzScope
        // object, and all AzAuthorizationStore AzApplicationGroup children
        //

        for ( i = 0; i < OBJECT_TYPE_COUNT; i++ ) {

            //
            // Since we do not have Op, Task, Role objects as children of
            // authorization store, create only container for groups if object is
            // authorization store.  Also, there are no containers for authorization store,
            // application and scope objects.  Scope objects do not have any containers
            // for operation objects.
            //

            if ( (!IsContainerObject(i)) &&
                 ( ( i == OBJECT_TYPE_GROUP && lObjectType == OBJECT_TYPE_AZAUTHSTORE ) ||
                   ( i != OBJECT_TYPE_OPERATION && lObjectType == OBJECT_TYPE_SCOPE ) ||
                   ( lObjectType == OBJECT_TYPE_APPLICATION ) ) ) {

                WinStatus = AzpADBuildDN(
                                pContext,
                                pObject,
                                &pObjectContainerDN,
                                pDN,
                                FALSE, // no AzAuthStore parent DN needed
                                &AdChildObjectContainers[i]
                                );

                if ( WinStatus != NO_ERROR ) {

                    goto Cleanup;

                }

                WinStatus = AzpCreateADObject(
                                pLdapHandle,
                                pObjectContainerDN
                                );

                if ( WinStatus != NULL ) {

                    goto Cleanup;

                }

                AzpFreeHeap( pObjectContainerDN );

                pObjectContainerDN = NULL;
            }
        } // for loop
    }

    //
    // If the object is of type AzAuthorizationStore or AzApplication or AzScope,
    // then stamp it with an updated DACL and SACL on the object.
    // If the object is of type AzScope, then stamp it with scope admin
    // rights (This is so that scope admins are not able to change properties
    // of the scope objects.  They should be able to read the scope object, and
    // create and delete children.  No DACL writing is allowed)
    //

    if ( IsContainerObject( lObjectType ) ) {

        WinStatus = AzpUpdateObjectAcls(
                        pContext,
                        pObject,
                        pDN,
                        lPersistFlags,
                        TRUE,
                        (lObjectType==OBJECT_TYPE_SCOPE)?
                        (PAZP_POLICY_USER_RIGHTS *)&ADDelegatedScopeAdminsRights:(PAZP_POLICY_USER_RIGHTS *)&ADPolicyAdminsRights,
                        (PAZP_POLICY_USER_RIGHTS *)&ADPolicyReadersRights,
                        (lObjectType ==
                         OBJECT_TYPE_SCOPE)?NULL:(PAZP_POLICY_USER_RIGHTS *)&ADDelegatedParentReadersRights
                        );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpUpdateADObject: AzpADUpdateObjectAcls failed for"
                      " %ws: %ld\n",
                      pDN,
                      WinStatus
                      ));
            goto Cleanup;
        }
    }

    WinStatus = NO_ERROR;

 Cleanup:

    //
    // Free up resources
    //

    if ( pObjectContainerDN != NULL ) {

        AzpFreeHeap( pObjectContainerDN );
    }

    if ( ppAttributeList != NULL ) {

        AzpADFreeAttrHeap( &ppAttributeList, TRUE );
    }

    if ( ppBerVal != NULL ) {

        ldap_value_free_len( ppBerVal );
    }

    if ( pResult != NULL ) {

        ldap_msgfree( pResult );
    }

    return WinStatus;
}

DWORD
AzpCreateADObject(
    IN LDAP *pLdapHandle,
    IN PWCHAR pDN
    )
/*++

Routine Description:

    This routine creates child container object for operation, task,
    group or role objects.  These container objects are children of
    either application or scope objects.

Arguments:

    pLdapHandle - Handle to the DS store

    pDN - DN of the container object being created

Return Values:

    NO_ERROR - object was created successfully in DS
    Other Ldap Status codes

--*/
{

    DWORD WinStatus = 0;

    ULONG LdapStatus = 0;

    ULONG i = 0;

    LDAPMod **ppAttributeList = NULL;

    //
    // validation
    //

    ASSERT( pDN != NULL );

    //
    // Set the mandatory attribute needed before adding the object
    // to AD store - the objectClass of the object
    //

    ppAttributeList = (LDAPMod **) AzpAllocateHeap(
                                       sizeof( LDAPMod *) * 2, "ATRLST" );

    if ( ppAttributeList == NULL ) {

        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    ppAttributeList[0] = NULL;
    ppAttributeList[1] = NULL;

    WinStatus = AzpADAllocateAttrHeapModVals(
                    &ppAttributeList[0], 2
                    );

    if ( WinStatus != NO_ERROR ) {

        goto Cleanup;
    }

    ppAttributeList[0]->mod_type = AZ_AD_OBJECT_CLASS;

    ppAttributeList[0]->mod_values[0] =
        (PWCHAR) AzpAllocateHeap( ( wcslen( AZ_AD_OBJECT_CONTAINER ) + 1 ) *
                                  sizeof( WCHAR ), "MODVALi" );

    if ( ppAttributeList[0]->mod_values[0] == NULL ) {

        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    wcscpy( ppAttributeList[i]->mod_values[0], AZ_AD_OBJECT_CONTAINER );

    ppAttributeList[0]->mod_op = LDAP_MOD_ADD;

    //
    // Now add the object to DS
    //

    LdapStatus = ldap_add_s(
                     pLdapHandle,
                     pDN,
                     ppAttributeList
                     );

    if ( LdapStatus != LDAP_SUCCESS ) {

        WinStatus = LdapMapErrorToWin32( LdapStatus );

        AzPrint(( AZD_AD,
                  "AzpCreateADObject: Failed to add object %ws: %ld %ld\n",
                  pDN,
                  WinStatus,
                  LdapStatus
                  ));

        goto Cleanup;
    }

    WinStatus = NO_ERROR;

 Cleanup:

    //
    // Release allocated memory
    //

    if ( ppAttributeList != NULL ) {

        AzpADFreeAttrHeap( &ppAttributeList, TRUE );
    }


    return WinStatus;
}

DWORD
AzpGetAttrsForCreateObject(
    IN PWCHAR pObjectClass,
    IN LDAPMod **ppAttributeList
    )
/*++

Routine Description:

        This routine populates the attribute structure for creation of an object in AD

Arguments:

        pObjectClass - Class name for the object

        ppAttributeList - Attribute list structure to populate

Return Values:

        NO_ERROR - The object was created successfully in AD

        Other status codes

--*/
{

    DWORD WinStatus = 0;

    //
    // validation
    //

    ASSERT( pObjectClass != NULL );


    WinStatus = AzpADAllocateAttrHeapModVals(
                    &ppAttributeList[0], 2
                    );

    if ( WinStatus != NO_ERROR ) {

        goto Cleanup;
    }

    ppAttributeList[0]->mod_type = AZ_AD_OBJECT_CLASS;

    ppAttributeList[0]->mod_values[0] = (PWCHAR)
        AzpAllocateHeap( ( wcslen( pObjectClass ) + 1 ) *
                         sizeof( WCHAR ), "MODVALi" );

    if ( ppAttributeList[0]->mod_values[0] == NULL ) {

        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    wcscpy( ppAttributeList[0]->mod_values[0], pObjectClass );

    ppAttributeList[0]->mod_op = LDAP_MOD_ADD;

    WinStatus = NO_ERROR;

Cleanup:

    return WinStatus;
}

DWORD
AzpGetADCommonAttrs(
    IN LDAP* pLdapHandle,
    IN AZPE_OBJECT_HANDLE pObject,
    IN AZ_AD_ATTRS ObjectAttrs[],
    IN ULONG lPersistFlags,
    OUT LDAPMod** ppAttributeList,
    IN OUT PULONG plIndex,
    IN BOOL bCreateFlag
    )
/*++

Routine Description:

        This routine updates the common attributes of all objects

Arguments:

        pLdapHandle - Handle to the DS policy store

        pObject - Object that needs to be updated in the DS

        ObjectAttrs - A NULL terminated list of attributes to be updated.  Pass
                NULL if there are no specific attributes that need to be read

        lPersistFlags - lPersistFlags from the persist engine describing the
                operation

 ppAttributeList - Attribute list to be updated with common attributes

 plIndex - number of attributes added to the attribute list structure

 bCreateFlag - Object is being created

Return Values:

        NO_ERROR - The object was successfully added/modified in the DS
        Other status codes (LDAP)

--*/
{
    DWORD WinStatus = 0;
    ULONG LdapStatus = 0;

    ULONG i = 0;

    PVOID pVoidStringValue = NULL;

    PWCHAR pNewRdn = NULL;

    PWCHAR pGuidDN = NULL;

    PWCHAR pGuidString = NULL;

    BOOL bNameChanged = FALSE;

    //
    // Validation
    //

    ASSERT( pObject != NULL );
    ULONG lObjectType = AdAzrolesInfo->AzpeObjectType(pObject);
    ULONG lDirtyBits = AdAzrolesInfo->AzpeDirtyBits(pObject);

    //
    // First check if the name has been changed.  This will
    // result in a call to ldap_rename_ext_s for all objects
    // except AzApplication and AzScope whose names are
    // stored in a different attribute.  This is of course
    // when the object is not being created.  We need to get
    // the GUID of the object and use that as the DN, since the name
    // has already changed in cache, but not in the AD store.
    //

    if ( (lDirtyBits & AZ_DIRTY_NAME) &&
         !(bCreateFlag) &&
         ( (lObjectType != OBJECT_TYPE_APPLICATION) &&
           (lObjectType != OBJECT_TYPE_SCOPE) ) ) {

        //
        // Create the GUIDized DN
        //

        WinStatus = UuidToString( AdAzrolesInfo->AzpePersistenceGuid(pObject), &pGuidString );

        if ( WinStatus != NO_ERROR ) {

            goto Cleanup;
        }

        pGuidDN = (PWCHAR) AzpAllocateHeap( (GUID_LINK_PREFIX_LENGTH +
                                             wcslen( pGuidString ) +
                                             GUIDSID_LINK_SUFFIX_LENGTH + 1) *
                                            sizeof( WCHAR ), "GUIDCN" );

        if ( pGuidDN == NULL ) {

            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        wcscpy( pGuidDN, GUID_LINK_PREFIX );
        wcscat( pGuidDN, pGuidString );
        wcscat( pGuidDN, GUIDSID_LINK_SUFFIX );

        //
        // Now get the new name for the object
        //

        WinStatus = AdAzrolesInfo->AzpeGetProperty(
                                       pObject,
                                       lPersistFlags,
                                       AZ_PROP_NAME,
                                       &pVoidStringValue
                                       );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpUpdateADCommonAttrs: AzpeGetProperty failed"
                      " for object name: %ld\n",
                      WinStatus
                      ));
            goto Cleanup;
        }

        //
        // Create the new RDN
        //

        pNewRdn = (PWCHAR) AzpAllocateHeap(
                               ( wcslen((PWCHAR)pVoidStringValue) +
                                 BUILD_CN_PREFIX_LENGTH + 1) *
                               sizeof( WCHAR ), "NEWRDN" );

        if ( pNewRdn == NULL ) {

            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        wcscpy( pNewRdn, BUILD_CN_PREFIX );
        wcscat( pNewRdn, (PWCHAR)pVoidStringValue );

        //
        // now call the routine to change the name of the object
        //

        LdapStatus = ldap_rename_ext_s(
                         pLdapHandle,
                         pGuidDN,
                         pNewRdn,
                         NULL, // same parent
                         TRUE,
                         NULL, // no server side control
                         NULL  // no client side control
                         );

        if ( LdapStatus != LDAP_SUCCESS ) {

            WinStatus = LdapMapErrorToWin32( LdapStatus );

            AzPrint(( AZD_AD,
                      "AzpADUpdateCommonAttrs: Failed to rename %ws"
                      ": %ld\n",
                      pGuidDN,
                      WinStatus
                      ));
            goto Cleanup;
        }

        bNameChanged = TRUE;

    } // if ( lDirtyBits & AZ_DIRTY_NAME )

    //
    // Now get the other common attributes if they are dirty and add
    // them to the DS object
    //

    for ( i = 0; i < AZ_AD_COMMON_ATTRS; i++ ) {

        if ( ObjectAttrs[i].AttrType == AZ_AD_END_LIST ) {

            //
            // No more attributes need to be read
            //

            break;
        }

        //
        // update the attribute
        // However, if the attribute is the application data attribute and object
        // is AzApplicationGroup, then don't update.  AzApplicationGroup objects are
        // the only objects that do not have the application data field
        // Also, if the name of the object has already changed, then do not update 
        // it again
        //

        if (!((lObjectType == OBJECT_TYPE_GROUP) && 
              (ObjectAttrs[i].AttrType == AZ_PROP_APPLICATION_DATA)) &&
              (lDirtyBits & ObjectAttrs[i].lDirtyBit) ) {

            if ( ObjectAttrs[i].AttrType == AZ_PROP_NAME &&
                bNameChanged ) {

                    continue;
                }

            WinStatus = AzpGetSpecificProperty(
                            pObject,
                            ppAttributeList,
                            plIndex,
                            ObjectAttrs[i],
                            lPersistFlags,
                            bCreateFlag
                            );

            if ( WinStatus != NO_ERROR ) {

                AzPrint(( AZD_AD,
                          "AzpADUpdateCommonAttrs: Get property failed "
                          ": %ld\n",
                          WinStatus ));
                goto Cleanup;
            }

            if ( !bCreateFlag || ppAttributeList[*plIndex] != NULL ) {

                ppAttributeList[*plIndex]->mod_op = bCreateFlag ? LDAP_MOD_ADD : LDAP_MOD_REPLACE;

                //
                // If the object is AzApplication or AzScope
                // and the property being set is AZ_PROP_NAME,
                // then set the msDS-AzapplicationName or
                // msDS-AzScopeName
                //

                if ( ObjectAttrs[i].AttrType == AZ_PROP_NAME ) {

                    ppAttributeList[*plIndex]->mod_type = AZ_AD_OBJECT_NAMES[lObjectType];

                } else {

                    ppAttributeList[*plIndex]->mod_type = ObjectAttrs[i].Attr;

                }

                (*plIndex)++;

            }

        } // if ( lDirtyBits & ObjectAttrs[i].lDirtyBit )

    } //for ( i < AZ_AD_COMMON_ATTRS )


    WinStatus = NO_ERROR;

 Cleanup:

    //
    // Free up used resources
    //

    if ( pGuidDN != NULL ) {

        AzpFreeHeap( pGuidDN );
    }

    if ( pGuidString != NULL ) {

        RpcStringFree( &pGuidString );
    }

    if ( pNewRdn != NULL ) {

        AzpFreeHeap( pNewRdn );
    }

    if ( pVoidStringValue != NULL ) {

        AzpFreeHeap( pVoidStringValue );
    }

    return WinStatus;
}

DWORD
AzpGetSpecificProperty(
    IN AZPE_OBJECT_HANDLE pObject,
    OUT PLDAPMod *ppAttribute,
    IN OUT ULONG *plIndex,
    IN AZ_AD_ATTRS ObjectAttr,
    IN ULONG lPersistFlags,
    IN BOOL bCreateFlag
    )
/*++

Routine Description:

        This routine reads in specific attributes of objects to
        an attribute list array element.  This array will be used
        by the calling function to update the AD policy store for this
        object.

Arguments:

        pObject - Handle to the object whose attributes will be read

        ppAttribute - Attribute list

        plIndex - Index into the attribute list

        ObjectAttr - Attribute that needs to be read from cache

        lPersistFlags - lPersistFlags from the persist engine describing the
                operation

        bCreateFlag - TRUE if the object is being created in DS

Return Values:

        NO_ERROR - The values was read in to the array element successfully
        Other status codes
--*/
{
    DWORD WinStatus = 0;

    PWCHAR pStringValue = NULL;
    WCHAR pStringNumber[32];
    PVOID pVoidTypeData = NULL;

    LONG lData = 0;

    //
    // Validation
    //

    ASSERT( pObject != NULL );

    //
    // Check if the attribute is a linked attribute.  These need
    // to be handled in a different way.  The problem arises
    // when we try to read attributes like msDS-NonMembers for
    // Group object.  The core differentiates between non-members
    // that are AzApplicationGrooups (stored in the Guid list)
    // and other non-members like NTGroups/NTUsers. (stored in the
    // Sid list).  The AD store does not differentiate
    // between the two and stores links to each of them in the
    // same attribute.  So, when we want to get property for
    // non-members from the core cache, we need to get both
    // the Sid non-members and Guid non-members and store them in
    // the same attribute in AD
    //

    if ( ObjectAttr.DataType == ENUM_AZ_SID_ARRAY ||
         ObjectAttr.DataType == ENUM_AZ_GUID_ARRAY ) {

        //
        // If the attribute is a linked attribute, then it is possible
        // that there are more than one values for the attribute.  Each
        // value is a name of an object that this object links to.
        // The linked object is assumed to already exist in DS.
        // If it does not, DS will respond with a "constraint violation"
        // error.  Report this error back to the persistence manager layer.
        //

        WinStatus = AzpHandleSubmitLinkedAttribute(
                        pObject,
                        ppAttribute,
                        ObjectAttr,
                        plIndex
                        );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpGetSpecificProperty: AzpADHandleSubmitLinkedAttribute"
                      " failed for %s: %ld\n",
                      L"<Unknown>", // AzpeObjectName(pObject),
                      WinStatus
                      ));

            goto Cleanup;
        }

    } else {

        //
        // Extract the property from the object
        //

        WinStatus = AdAzrolesInfo->AzpeGetProperty(
                                       pObject,
                                       lPersistFlags,
                                       ObjectAttr.AttrType,
                                       &pVoidTypeData );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpADGetSpecificProperty: Get Property failed"
                      ": %ld\n",
                      WinStatus ));
            goto Cleanup;
        }

        switch ( ObjectAttr.DataType ) {

            case ENUM_AZ_LONG:

                lData = *((PLONG)pVoidTypeData);

                wsprintf( pStringNumber, L"%d", lData );

                pStringValue = pStringNumber;
                break;

            case ENUM_AZ_GROUP_TYPE:

                lData = *((PLONG)pVoidTypeData);

                if ( lData == AZ_GROUPTYPE_BASIC ) {

                    lData = AZ_AD_BASIC_GROUP;

                } else {

                    lData = AZ_AD_QUERY_GROUP;

                }

                wsprintf( pStringNumber, L"%d", lData );

                pStringValue = pStringNumber;
                break;

            case ENUM_AZ_BOOL:

                //
                // There will always be a value for all BOOLs
                //

                if ( *((BOOL *)pVoidTypeData) ) {

                    pStringValue = AZ_AD_TRUE;

                } else {

                    pStringValue = AZ_AD_FALSE;
                }
                break;

            case ENUM_AZ_BSTR:

                //
                // If no value exists, that means the  attribute
                // has been deleted.  Pass the string to
                // AD to delete the attribute
                //

                pStringValue = (PWCHAR) pVoidTypeData;
                break;

            default:

                WinStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;

        } // switch ... case

        if ( *pStringValue != L'\0' || !bCreateFlag ) {

            if ( ppAttribute[*plIndex] == NULL ) {

                WinStatus = AzpADAllocateAttrHeapModVals(
                    &(ppAttribute[*plIndex]), 2
                    );

                if ( WinStatus != NO_ERROR ) {

                    goto Cleanup;
                }
            }

            if ( *pStringValue != L'\0' ) {

                ppAttribute[*plIndex]->mod_values[0] =
                    (PWCHAR) AzpAllocateHeap(
                        (wcslen( pStringValue )
                         + 1 ) * sizeof( WCHAR ), "MODVALi" );

                if ( ppAttribute[*plIndex]->mod_values[0] == NULL ) {

                    WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }

                wcscpy( ppAttribute[*plIndex]->mod_values[0], pStringValue );
            }
        }

    } // if ( AttrType == SID_ARRAY || AttrType == GUID_ARRAY ) ... else

    WinStatus = NO_ERROR;

 Cleanup:

    if ( pVoidTypeData != NULL ) {

        AzpFreeHeap( pVoidTypeData );

    }

    return WinStatus;
}

DWORD
AzpHandleSubmitLinkedAttribute(
    IN AZPE_OBJECT_HANDLE pObject,
    IN OUT PLDAPMod *ppAttribute,
    IN AZ_AD_ATTRS ObjectAttr,
    IN OUT PULONG plIndex
    )
/*++

Routine Description:

        This routine handles the linked attribute of an object being
        submitted to the AD policy store.  It is assumed that the linked
        object already exists in the DS.

Arguments:

        pObject - Pointer to the linking object whose link attribute needs
                to be handled

        ppAttribute - Pointer to the link attribute structure for submission of
                the linking object

        ObjectAttr - Object attribute to be read

 plIndex - index into the attribute list

Return Values:

        NO_ERROR - The link attribute structure was successfully populated
        Other status codes (including LDAP)
--*/
{
    DWORD WinStatus = 0;

    ULONG i = 0;

    PAZP_DELTA_ENTRY *pSidList = NULL;
    PAZP_DELTA_ENTRY *pGuidList = NULL;

    PAZP_DELTA_ENTRY pDeltaEntry = NULL;

    ULONG lSidArrayCount = 0;
    ULONG lGuidArrayCount = 0;
    ULONG lTotalCount = 0;

    PWCHAR pSidString = NULL;

    PWCHAR pGuidString = NULL;

    ULONG AttrType;

    BOOLEAN bSidValues = FALSE;

    //
    // We need to keep the list for linked attributes being added
    // separate from linked attributes being deleted.  This holds good
    // for both Sid lists and GUID lists.
    //

    ULONG lAddIndex;
    ULONG lDeleteIndex;

    //
    // Validation
    //

    ASSERT( pObject != NULL );

    //
    // Set the AttrType to type of attibute being read.  This
    // is used so that when we are reading Sid objects, we will
    // also make sure to read if there are changed Guid objects
    // (see previous comment on AD store having same attribute for
    //  Sid and Guid objects, and core cache being able to differentiate
    //  between them)
    //

    AttrType = ObjectAttr.AttrType;

    //
    // Check ObjectAttr if valuesd being read are Sid objects
    //

    if ( ObjectAttr.DataType == ENUM_AZ_SID_ARRAY ) {

        //
        // Also read Guid objects
        //

        switch ( AttrType ) {

            case AZ_PROP_ROLE_MEMBERS:

                AttrType = AZ_PROP_ROLE_APP_MEMBERS;
                break;

            case AZ_PROP_GROUP_MEMBERS:

                AttrType = AZ_PROP_GROUP_APP_MEMBERS;
                break;

            case AZ_PROP_GROUP_NON_MEMBERS:

                AttrType = AZ_PROP_GROUP_APP_NON_MEMBERS;
                break;

            default:

                WinStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
        }

        //
        // Get the Sid Object list
        //

        WinStatus = AdAzrolesInfo->AzpeGetDeltaArray(
                                       pObject,
                                       ObjectAttr.AttrType,
                                       &lSidArrayCount,
                                       &pSidList );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpHandleSubmitLinkedAttribute: AzpeGetDeltaArray"
                      " failed for %ws: %ld\n",
                      L"<Unknown>", // AzpeObjectName(pObject),
                      WinStatus
                      ));
            goto Cleanup;
        }

        if ( lSidArrayCount > 0 ) {

            bSidValues = TRUE;

        }
    }

    //
    // Read the Guid object list
    //

    WinStatus = AdAzrolesInfo->AzpeGetDeltaArray(
                                   pObject,
                                   AttrType,
                                   &lGuidArrayCount,
                                   &pGuidList );

    if ( WinStatus != NO_ERROR ) {

        AzPrint(( AZD_AD,
                  "AzpADHandleSubmitLinkedAttribute: AzpeGetDeltaArray"
                  " failed for %ws: %ld\n",
                  L"<Unknown>", // AzpeObjectName(pObject),
                  WinStatus
                  ));
        goto Cleanup;
    }

    //
    // Total count
    //

    lTotalCount = lSidArrayCount + lGuidArrayCount;

    //
    // reset i
    //

    i = 0;

    ULONG index;
    ULONG lAddCount = 0;
    ULONG lDeleteCount = 0;

    //
    // Count the number of Sids/Guids being added or deleted
    //

    for ( i = 0; i < lSidArrayCount; i++ ) {

        pDeltaEntry = pSidList[i];

        if ( pDeltaEntry->DeltaFlags & AZP_DELTA_ADD ) {

            lAddCount++;

        } else {

            lDeleteCount++;
        }
    }

    for ( i = 0; i < lGuidArrayCount; i++ ) {

        pDeltaEntry = pGuidList[i];

        if ( pDeltaEntry->DeltaFlags & AZP_DELTA_ADD ) {

            lAddCount++;

        } else {

            lDeleteCount++;
        }

    }

    //
    // If there are any Sid objects, loop through them
    // first
    //
    // Set lAddIndex to *plIndex, and lDeleteIndex
    // to the next index value if lAddCount is not zero
    // If lAddCount is zero, then there are no SIDs/GUIDs to be
    // added, and lDeleteIndex will be *plIndex
    //

    lAddIndex = *plIndex;
    lDeleteIndex = (lAddCount==0)?lAddIndex:(lAddIndex+1);

    i = 0;

    if ( bSidValues ) {

        for ( ; i < lSidArrayCount; i++ ) {

            pDeltaEntry = pSidList[i];

            AZASSERT( (pDeltaEntry->DeltaFlags & AZP_DELTA_SID) );

            index = (pDeltaEntry->DeltaFlags & AZP_DELTA_ADD) ? lAddIndex:lDeleteIndex;

            //
            // Convert Sid to String Sid
            //

            if ( !ConvertSidToStringSid(
                      pDeltaEntry->Sid,
                      &pSidString
                      ) ) {

                WinStatus = GetLastError();

                AzPrint(( AZD_AD,
                          "AzpHandleSubmitLinkedAttribute:"
                          " ConvertSidToStringSid failed: %ld\n",
                          WinStatus
                          ));
                goto Cleanup;
            }

            if ( ppAttribute[index] == NULL ) {

                WinStatus = AzpADAllocateAttrHeapModVals(
                                &(ppAttribute[index]),
                                ((pDeltaEntry->DeltaFlags & AZP_DELTA_ADD)?(lAddCount+1):(lDeleteCount+1))
                                );

                if ( WinStatus != NO_ERROR ) {

                    goto Cleanup;
                }

                ppAttribute[index]->mod_type = ObjectAttr.Attr;

                //
                // Check is we need to add the GUID link or we need to delete
                // the GUID link
                //

                ppAttribute[index]->mod_op = (pDeltaEntry->DeltaFlags & AZP_DELTA_ADD) ? LDAP_MOD_ADD:LDAP_MOD_DELETE;

            }

            WinStatus = AzpADAllocateHeapLinkAttribute( pSidString,
                                                        &(ppAttribute[index]->mod_values),
                                                        TRUE // Is Sid
                                                        );

            if ( WinStatus != NO_ERROR ) {

                goto Cleanup;
            }

            LocalFree( pSidString );

            pSidString = NULL;

        } // for ( i < lSidArrayCount )

    } // if ( bSidValues )

    //
    // We have all the Sid values that we need
    // Now get the guid values
    //

    for ( ; i < lTotalCount; i++ ) {

        pDeltaEntry = pGuidList[i-lSidArrayCount];

        index = (pDeltaEntry->DeltaFlags & AZP_DELTA_ADD) ? lAddIndex:lDeleteIndex;

        WinStatus = UuidToString(
                        &pDeltaEntry->Guid,
                        &pGuidString
                        );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpHandleSubmitLinkedAttribute:"
                      " UuidToString failed: %ld\n",
                      WinStatus
                      ));
            goto Cleanup;
        }

        if ( ppAttribute[index] == NULL ) {

            WinStatus = AzpADAllocateAttrHeapModVals(
                            &(ppAttribute[index]),
                            ((pDeltaEntry->DeltaFlags & AZP_DELTA_ADD)?(lAddCount+1):(lDeleteCount+1))
                            );

            if ( WinStatus != NO_ERROR ) {

                goto Cleanup;
            }



            ppAttribute[index]->mod_type = ObjectAttr.Attr;

            //
            // Check is we need to add the GUID link or we need to delete
            // the GUID link
            //

            ppAttribute[index]->mod_op = (pDeltaEntry->DeltaFlags & AZP_DELTA_ADD) ? LDAP_MOD_ADD:LDAP_MOD_DELETE;

        }

        //
        // We have the Guid value.  Now allocate memory
        // to attribute value structure
        //

        WinStatus = AzpADAllocateHeapLinkAttribute( pGuidString,
                                                    &(ppAttribute[index]->mod_values),
                                                    FALSE // Is Sid
                                                    );

        if ( WinStatus != NO_ERROR ) {

            goto Cleanup;
        }

        RpcStringFree( &pGuidString );

        pGuidString = NULL;
    }

    *plIndex = (ppAttribute[lDeleteIndex] == NULL) ? lDeleteIndex : (lDeleteIndex+1);

    WinStatus = NO_ERROR;

 Cleanup:

    //
    // release memory
    //

    if ( pGuidString != NULL ) {

        RpcStringFree( &pGuidString );
    }

    if ( pSidString != NULL ) {

        LocalFree( pSidString );
    }

    return WinStatus;
}

DWORD
AzpADAllocateHeapLinkAttribute(
    IN PWCHAR pString,
    IN OUT PWCHAR **ppModVals,
    IN BOOLEAN bIsSid
    )
/*++

Routine Description:

    This routine adds an input string to a multi-valued linked attribute value

Arguments:

    pString - String to be added to the multi-values linked attribute

    ppModVals - Multi-values linked attribute values

    bIsSid - TRUE if the link is a SID link (else GUID link)

Return Values:

    NO_ERROR - The input string was added successfully

    ERROR_NOT_ENOUGH_MEMORY - There was a memory resource problem

--*/
{

    DWORD WinStatus = 0;

    ULONG size = 0;

    ULONG index = 0;

    //
    // Validation
    //

    ASSERT( pString != NULL );

    while ( (*ppModVals)[index] != NULL ) {

        index++;
    }

    size = (bIsSid?SID_LINK_PREFIX_LENGTH:GUID_LINK_PREFIX_LENGTH) +
        (ULONG) wcslen( pString ) +
        GUIDSID_LINK_SUFFIX_LENGTH + 1;

    (*ppModVals)[index] = (PWCHAR) AzpAllocateHeap( size * sizeof( WCHAR ), "lMODVAL" );

    if ( (*ppModVals)[index] == NULL ) {

        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    wcscpy( (*ppModVals)[index], (bIsSid?SID_LINK_PREFIX:GUID_LINK_PREFIX) );
    wcscat( (*ppModVals)[index], pString );
    wcscat( (*ppModVals)[index], GUIDSID_LINK_SUFFIX );

    WinStatus = NO_ERROR;

 Cleanup:

    return WinStatus;

}

DWORD
AzpUpdateObjectAcls(
    IN PAZP_AD_CONTEXT pContext,
    IN OUT AZPE_OBJECT_HANDLE pObject,
    IN PWCHAR pDN,
    IN ULONG lPersistFlags,
    IN BOOL  bIsOnObjectSelf,
    IN PAZP_POLICY_USER_RIGHTS *ppPolicyAdminRights OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS *ppPolicyReaderRights OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS *ppDelegatedPolicyUsersRights OPTIONAL
    )
/*++

Routine Description:

        This routine submits any ACL changes to the persist
        object passed

Arguments:

        pContext - context for the store

        pObject - Pointer to object whose ACL needs to be updated

        pDN - DN of the passed in object

        lPersistFlags - Flags from ther persist engine layer

        bIsOnObjectSelf - When we recursively calls (from store object), we shouldn't go update
                          the DACL on store object for delegated users. Pass true if this update
                          is on the object itself, not container objects.

        ppPolicyAdminRights - Rights for policy admins

        ppPolicyReaderRights - Rights for policy readers

        ppDelegatedPolicyUsersRights - Rights for delegated users


Return Values:

        NO_ERROR - The ACLs were updated successfully

        Other status codes

--*/
{
    DWORD WinStatus;

    ULONG DirtyBits = AdAzrolesInfo->AzpeDirtyBits( pObject );
    ULONG lObjectType = AdAzrolesInfo->AzpeObjectType( pObject );

    PAZP_POLICY_USER_RIGHTS pStoreDelegatedUsersAttributeRights = NULL;
    GUID * pStoreObjectVersionGuid = NULL;

    PSECURITY_DESCRIPTOR pOldSd = NULL;

    PSECURITY_DESCRIPTOR pNewSd = NULL;

    BOOL UpdateDacl = FALSE;
    BOOL UpdateSacl = FALSE;
    BOOL DoingSubcontainer;

    BOOL EmptyPolicyAdmins = FALSE;

    SECURITY_INFORMATION si = 0;

    ULONG i = 0;

    PWCHAR pContainerDN = NULL;

    //
    // validation
    //

    ASSERT( pObject != NULL );


    //
    // Determine whether the DACL and/or SACL need to be updated
    //

    if ( DirtyBits & AZ_DIRTY_CREATE ) {
        UpdateDacl = TRUE;
        UpdateSacl = pContext->HasSecurityPrivilege;
    } else {
        if ( DirtyBits & (AZ_DIRTY_POLICY_READERS|AZ_DIRTY_POLICY_ADMINS|AZ_DIRTY_DELEGATED_POLICY_USERS) ) {
            UpdateDacl = TRUE;
        }

        if ( DirtyBits & AZ_DIRTY_APPLY_STORE_SACL ) {
            UpdateSacl = TRUE;
        }

        if ( !UpdateDacl && !UpdateSacl ) {
            WinStatus = NO_ERROR;
            goto Cleanup;
        }
    }

    if ( bIsOnObjectSelf && UpdateDacl && lObjectType == OBJECT_TYPE_AZAUTHSTORE)
    {
        pStoreDelegatedUsersAttributeRights = &StoreDelegatedUsersAttributeRights;
        pStoreObjectVersionGuid = &AZ_AD_OBJECT_VERSION_GUID;
    }

    //
    // Delegator objects have ACLed container objects for each child object type.
    // Determine if this call is for one of those containers
    //

    DoingSubcontainer = (ppPolicyAdminRights == NULL) && (ppPolicyReaderRights == NULL);

    //
    // Subcontainers always inherit their SACL from their parent
    //

    if ( DoingSubcontainer ) {
        UpdateSacl = FALSE;
    }

    //
    // If the object is a container AzRole object, then the child container objects
    // in its bucket need to be stamped first
    //

    if ( IsContainerObject( lObjectType ) && !DoingSubcontainer ) {

        for ( i = 0; i < OBJECT_TYPE_COUNT; i++ ) {

            if ( (!IsContainerObject(i)) &&
                 ( ( i == OBJECT_TYPE_GROUP && lObjectType == OBJECT_TYPE_AZAUTHSTORE ) ||
                   ( i != OBJECT_TYPE_OPERATION && lObjectType == OBJECT_TYPE_SCOPE ) ||
                   ( lObjectType == OBJECT_TYPE_APPLICATION ) ) ) {

                WinStatus = AzpADBuildDN(
                                pContext,
                                pObject,
                                &pContainerDN,
                                pDN,
                                FALSE,
                                &AdChildObjectContainers[i]
                                );

                if ( WinStatus != NO_ERROR ) {

                    goto Cleanup;
                }

                //
                // Now call this function recursively again to stamp
                // the container object
                //

                WinStatus = AzpUpdateObjectAcls(
                                pContext,
                                pObject,
                                pContainerDN,
                                lPersistFlags,
                                FALSE,           // recursively now, not on the object self
                                NULL,
                                NULL,
                                (PAZP_POLICY_USER_RIGHTS *)&ADDelegatedContainerReadersRights
                                );

                if ( WinStatus != NO_ERROR ) {

                    goto Cleanup;
                }

                AzpFreeHeap( pContainerDN );

                pContainerDN = NULL;

            }

        } // for loop
    }

    //
    // If we didn't just create the object,
    //  Get the existing file security descriptor so we can merge in the changes
    //

    if ( (DirtyBits & AZ_DIRTY_CREATE) == 0 ) {

        WinStatus = AzpADReadNTSecurityDescriptor(
                        pContext,
                        pObject,
                        pDN,
                        FALSE, // no need to read authorization store's DS parent
                        &pOldSd,
                        UpdateSacl, // read SACL
                        UpdateDacl  // read DACL
                        );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpADUpdateObjectAcls: AzpADReadNTSecurityDescriptor failed"
                      " :%ld\n",
                      WinStatus
                      ));
            goto Cleanup;
        }
    }

    //
    // Compute the new Security Descriptor
    //

    WinStatus = AdAzrolesInfo->AzpeGetSecurityDescriptorFromCache(
                                   pObject,
                                   lPersistFlags,
                                   (UpdateDacl ? ppPolicyAdminRights : NULL),
                                   (UpdateDacl ? ppPolicyReaderRights : NULL),
                                   (UpdateDacl ? ppDelegatedPolicyUsersRights : NULL),
                                   (UpdateDacl && ppDelegatedPolicyUsersRights != NULL)?(GUID *)&AZ_AD_CONTAINER_GUID:NULL,
                                   pStoreDelegatedUsersAttributeRights,
                                   pStoreObjectVersionGuid,
                                   (UpdateSacl ? &AdSaclRights : NULL),
                                   pOldSd,
                                   &pNewSd);

    if ( WinStatus == ERROR_EMPTY ) {
        EmptyPolicyAdmins = TRUE;
        WinStatus = NO_ERROR;
    }

    if ( WinStatus != NO_ERROR ) {

        AzPrint(( AZD_AD,
                  "AzpADUpdateObjectAcls: AzpeGetSecurityDescriptorFromCache failed:"
                  " %ld\n",
                  WinStatus
                  ));

        goto Cleanup;
    }

    //
    // Update the SACL on the object
    //

    if ( UpdateSacl ) {
        si |= SACL_SECURITY_INFORMATION;

    }

    //
    // Update the DACL on the object
    //

    if ( UpdateDacl ) {
        si |= DACL_SECURITY_INFORMATION;
    }

    //
    // Set the DACL/SACL onto the object
    //

    WinStatus = AzpADStampSD(
                    pContext,
                    pDN,
                    si,
                    pNewSd );

    if ( WinStatus != NO_ERROR ) {

        //
        // Unable to set the new security descriptor
        //

        AzPrint(( AZD_AD,
                  "AzpADUpdateObjectAcls: AzpADStampSD failed with SACL/DACL: %ld\n",
                  WinStatus
                  ));
        goto Cleanup;
    }

    //
    // If AzpADStampSD changed PolicyAdmins,
    //  load the PolicyAdmins back into the the azroles core.
    //
    if ( EmptyPolicyAdmins && !DoingSubcontainer ) {

        WinStatus = AzpApplyPolicyAcls(
                        pContext,
                        pObject,
                        pDN,
                        lPersistFlags,
                        TRUE ); // Only update PolicyAdmins

        if ( WinStatus != NO_ERROR ) {

            //
            // Unable to get the new security descriptor
            //

            AzPrint(( AZD_AD,
                      "AzpADUpdateObjectAcls: AzpApplyPolicyAcls failed with DACL: %ld\n",
                      WinStatus
                      ));
            goto Cleanup;
        }

    }

    WinStatus = NO_ERROR;

 Cleanup:

    //
    // free locally used memory
    //

    if ( pContainerDN != NULL ) {

        AzpFreeHeap( pContainerDN );
    }

    AdAzrolesInfo->AzpeFreeMemory( pNewSd );

    if ( pOldSd != NULL ) {
        AzpFreeHeap( pOldSd );
    }

    return WinStatus;
}


//
// Utility routines used by AD policy store APIs
//

DWORD
AzpADBuildDN(
    IN PAZP_AD_CONTEXT pContext,
    IN OUT AZPE_OBJECT_HANDLE pObject,
    IN OUT PWCHAR *ppDN,
    IN PWCHAR pParentDN,
    IN BOOL bAzAuthorizationStoreParent,
    IN PAZ_AD_CHILD_OBJECT_CONTAINERS pChildObjectContainer
    )
/*++

Routine Description:

        This routine builds the DN for an object.

Arguments:

        pContext - context for the store

        pObject - Pointer to the object whose DN is being built. For
                AzApplication and AzScope objects, a temporary GUID
                is assigned which will help identify them later on

        ppDN - The resulting DN

        pParentDN - DN of the parent object.  NULL passed if parent object DN not known.

        bAzAuthorizationStoreParent - TRUE if DN needs to be built for AzAuthStore parent in DS

        pChildObjectContainer - Child Object container for which the DN needs to be built
                               Pass NULL if the object is not a child object container

Return Values:

        NO_ERROR - The DN was build successfully
        ERROR_NOT_ENOUGH_MEMORY - insufficient resources

--*/
{

    DWORD WinStatus = 0;

    PWCHAR pAzAuthorizationStoreDN = NULL;
    ULONG lObjectType = AdAzrolesInfo->AzpeObjectType(pObject);

    //
    // Validation
    //

    ASSERT( pObject != NULL );

    //
    // If the DN needs to be build for AdCheckSecurityPrivilege ever-
    // present object
    //

    if ( bAzAuthorizationStoreParent ) {

        WinStatus = AzpADBuildDNForAzStoreParent(
                        pContext,
                        ppDN
                        );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpADBuildDN: AzpADBuildDNForBuiltinObject failed:"
                      "%ld\n",
                      WinStatus
                      ));
        }

        goto Cleanup;

    }

    //
    // For AzApplication, AzScope object, we need a temporary GUID
    // assigned to those objects which can be used during the DN creation.
    // This is different from the GUID assigned to the object itself - that
    // will be assigned when the object has been added to the DS and read
    // for the GUID
    //

    if ( (lObjectType == OBJECT_TYPE_APPLICATION && (pChildObjectContainer == NULL)) ||
         lObjectType == OBJECT_TYPE_SCOPE ) {

        LPWSTR TempString = (LPWSTR) AdAzrolesInfo->AzpeGetProviderData( pObject );

        if ( TempString == NULL ) {


            WinStatus = AzpCreateGuidCN( &TempString, NULL );

            AdAzrolesInfo->AzpeSetProviderData( pObject, (PVOID)TempString );
        }

    }

    if ( WinStatus != NO_ERROR ) {

        goto Cleanup;
    }

    //
    // We need to create the DN of the object.  The DN will
    // consist of the object's objectName, its parent's objectName,
    // upto and including the AzAuthorizationStore objectName.  For
    // AzApplication and AzScope objects, the RDN will have to be
    // changed depending on the object's name size.  For all child
    // objects of AzApplication (except Scopes), the DN will include an
    // extra parent which does not exist in the cache.  This is to support
    // delegation in AzRoles, and allow for same name role and task objects
    // This parent will always be a child of the AzApplication object, and its
    // DN is simply the GUID of the AzApplication object prefixed with
    // *_OBJECT_CONTAINER_NAME_PREFIX.
    // A similar logic is to be used for objects that are children of the AzScope
    // object.
    // For all child objects of AzAuthorizationStore that are not AzApplications,
    // we need to create the DN with parent as the AZ_AD_OBJECT_CONTAINER
    // under AzAuthorizationStore, and its DN is the RDN of the authorization store
    // object prefixed with GROUP_OBJECT_CONTAINER_NAME_PREFIX.
    //
    // Get the DN for the AzAuthorizationStore object.  The URL is in the format
    // msldap://servername/CN=AzAuthorizationStoreObjectName,OU=SomeOrganizationalUnit,DC=X
    // or msldap://CN=AzAuthorizationStoreObjectName,OU=SomeOrganizationalUnit,DC=X
    //

    pAzAuthorizationStoreDN = wcsrchr( pContext->PolicyUrl,
                               L'/' );

    ASSERT( pAzAuthorizationStoreDN != NULL );

    pAzAuthorizationStoreDN++;

    //
    // If we need to create the DN for the AZ_AD_OBJECT_CONTAINER
    //

    if ( pChildObjectContainer ) {

        WinStatus = AzpADObjectContainerRDN(
                        pObject,
                        ppDN,
                        pParentDN,
                        pAzAuthorizationStoreDN,
                        TRUE,
                        pChildObjectContainer
                        );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpADBuildDN: AzpADObjectContainerRDN failed:"
                      "%ld\n",
                      WinStatus
                      ));
        }

        goto Cleanup;
    }

    if ( lObjectType != OBJECT_TYPE_AZAUTHSTORE ) {

        WinStatus = AzpADBuildChildObjectDN(
                        pObject,
                        ppDN,
                        pParentDN,
                        pAzAuthorizationStoreDN
                        );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpADBuildDN: AzpADBuildChildObjectDN failed for %s"
                      ": %ld\n",
                      L"<Unknown>", // AzpeObjectName(pObject),
                      WinStatus
                      ));
            goto Cleanup;
        }

    } else {

        //
        // Object type is authorization store.  Hence the DN of the object
        // is the policy URL of the store
        //

        *ppDN = (PWCHAR) AzpAllocateHeap(
                             (wcslen( pAzAuthorizationStoreDN ) + 1) *
                             + sizeof( WCHAR ), "URLDN" );

        if ( *ppDN == NULL ) {

            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        wcscpy( *ppDN, pAzAuthorizationStoreDN );
    }

    WinStatus = NO_ERROR;

 Cleanup:

    pAzAuthorizationStoreDN = NULL;

    return WinStatus;
}

DWORD
AzpADBuildChildObjectDN(
    IN AZPE_OBJECT_HANDLE pObject,
    OUT PWCHAR *ppDN,
    IN PWCHAR pParentDN,
    IN PWCHAR pPolicyDN
    )
/*++

Routine Description:

        This routine is a worker routine for AzpADBuildDN.  Once we have the DN,
        concatenate it with the DN extracted from AzpLdapCrackUrl in
        AzpADPersistOpen.
        The DN needs to be in the format
        CN=objName,CN=CN=parentObj1Name,...,CN=AzAuthorizationStoreName,DC=X

Arguments:

        pObject - Pointer to object for whom the DN needs to be built
        ppDN - The built DN string
        pParentDN - DN of the parent object
        pPolicyDN - DN of policy itself

Return Values:

        NO_ERROR - The DN was build successfully
        Other status codes
--*/
{
    DWORD WinStatus = 0;
    DWORD lObjectType = AdAzrolesInfo->AzpeObjectType( pObject );

    PWCHAR pTempCN = NULL;

    PWCHAR pTempParentCN = NULL;

    PWCHAR pObjectContainerCN = NULL;

    ULONG lObjectContainerCNLength = 0;

    size_t lStringSize = 0;

    AZPE_OBJECT_HANDLE pTempObject = NULL;

    //
    // Validation
    //

    ASSERT( pObject != NULL );

    //
    // Set pTempCN to point to CN
    //

    WinStatus = AzpGetCNForDN(
                    pObject,
                    &pTempCN);

    if ( WinStatus != NO_ERROR ) {

        AzPrint(( AZD_AD,
                  "AzpADBuildDN: AzpADGetCNForDN failed: %ld\n",
                  WinStatus
                  ));

        goto Cleanup;
    }

    //
    // If the object whose DN is being built is a child of AzApplication/AzScope and
    // not a scope object, then it needs to go into a child container object
    // under the AzApplication/AzScope object.  The same holds true for AzApplicationGroup
    // objects that are children of AzAuthorizationStore
    //

    if ( !IsContainerObject( lObjectType ) ) {

        WinStatus = AzpADObjectContainerRDN(
                        AdAzrolesInfo->AzpeParentOfChild(pObject),
                        &pObjectContainerCN,
                        pParentDN,
                        pPolicyDN,
                        FALSE,  // Object container is not being created
                        &AdChildObjectContainers[lObjectType]
                        );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpADBuildDN: AzpADObjectContainerRDN failed"
                      " for %ws: %ld\n",
                      ((PGENERIC_OBJECT)pObject)->ObjectName->ObjectName.String,
                      WinStatus
                      ));
            goto Cleanup;
        }

        lObjectContainerCNLength = (ULONG)wcslen( pObjectContainerCN );
    }

    //
    // Allocate memory to the returned DN value
    //

    lStringSize = wcslen( pTempCN ) + wcslen( pPolicyDN ) + lObjectContainerCNLength;

    *ppDN = (PWCHAR) AzpAllocateHeap(
                         ( lStringSize + 1 ) * sizeof( WCHAR ), "BLDDN"
                         );

    if ( *ppDN == NULL ) {

        WinStatus = ERROR_NOT_ENOUGH_MEMORY;

        goto Cleanup;
    }

    //
    // Copy the CN of the object into the returning DN value.
    // After that, get the parent CN and keep adding the equivalent
    // size of the length of the parent's CN to the returning DN
    // value.
    //

    wcscpy( *ppDN, pTempCN );

    if ( lObjectContainerCNLength != 0 ) {

        wcscat( *ppDN, pObjectContainerCN );
    }

    AzpFreeHeap( pTempCN );

    pTempCN = NULL;

    pTempCN = (PWCHAR) AzpAllocateHeap(
                           ( lStringSize + 1 ) *
                           sizeof( WCHAR ), "TMPCN"
                           );

    if ( pTempCN == NULL ) {

        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    wcscpy( pTempCN, *ppDN );

    pTempObject = AdAzrolesInfo->AzpeParentOfChild(pObject);

    while ( pTempObject != NULL &&
            AdAzrolesInfo->AzpeObjectType(pTempObject) != OBJECT_TYPE_AZAUTHSTORE ) {

        //
        // Get the parent's CN
        //

        WinStatus = AzpGetCNForDN( pTempObject,
                                   &pTempParentCN
                                   );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpADBuildDN: AzpGetCNForDN failed: %ld\n",
                      WinStatus
                      ));

            goto Cleanup;
        }

        if ( pTempCN == NULL ) {

            //
            // Save the current returning DN value as the temporary CN
            // value
            //

            pTempCN = (PWCHAR) AzpAllocateHeap(
                                   ( lStringSize + 1 ) *
                                   sizeof( WCHAR ), "TMPCN"
                                   );

            if ( pTempCN == NULL ) {

                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            wcscpy( pTempCN, *ppDN );
        }

        //
        // Free the returning DN value and reallocate memory
        // to accomodate the parent's CN
        //

        lStringSize += wcslen( pTempParentCN );

        AzpFreeHeap( *ppDN );

        *ppDN = NULL;

        *ppDN = (PWCHAR) AzpAllocateHeap( ( lStringSize + 1 )
                                          * sizeof( WCHAR ), "BLDDN"
                                          );

        if ( *ppDN == NULL ) {

            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        wcscpy( *ppDN, pTempCN );
        wcscat( *ppDN, pTempParentCN );

        AzpFreeHeap( pTempParentCN );

        pTempParentCN = NULL;

        AzpFreeHeap( pTempCN );

        pTempCN = NULL;

        pTempObject = AdAzrolesInfo->AzpeParentOfChild(pTempObject);
    }

    //
    // Concatenate the policy DN to the above created DN value
    //

    wcscat( *ppDN, pPolicyDN );

    WinStatus = NO_ERROR;

 Cleanup:

    if ( pTempCN != NULL ) {

        AzpFreeHeap( pTempCN );
    }

    if ( pTempParentCN != NULL ) {

        AzpFreeHeap( pTempParentCN );
    }

    if ( pObjectContainerCN != NULL ) {

        AzpFreeHeap( pObjectContainerCN );
    }

    pTempObject = NULL;

    return WinStatus;
}

DWORD
AzpGetCNForDN(
    IN AZPE_OBJECT_HANDLE pObject,
    OUT PWCHAR *ppCN
    )
/*++

Routine Description:

        This routine generates a CN for the passed in object.  The CN is the quoted or escaped object Name.
        For example, CN=ObjectName
                     CN=Object\,Name

Arguments:

        pObject - Pointer to object whose CN needs to be built

        ppCN - Pointer to returned CN

Return Values:

        NO_ERROR - CN was built successfully
        ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD WinStatus = 0;
    ULONG lObjectType = AdAzrolesInfo->AzpeObjectType(pObject);
    LPWSTR ObjectName = NULL;
    LPWSTR QuotedObjectName = NULL;

    DWORD cObjectNameLen = 0;
    DWORD cQuotedObjectNameLen = 0;

    //
    // Validation
    //

    ASSERT( pObject != NULL );

    //
    // Handle case for application and scope objects differently
    // They already have their CN stored in an attribute pGuidCN
    //

    if ( lObjectType == OBJECT_TYPE_APPLICATION ||
         lObjectType == OBJECT_TYPE_SCOPE ) {

        LPWSTR TempString;

        TempString = (LPWSTR) AdAzrolesInfo->AzpeGetProviderData( pObject );
        ASSERT( TempString != NULL );

        *ppCN = (PWCHAR) AzpAllocateHeap(
                             ( wcslen( TempString ) + 1 ) * sizeof( WCHAR ),
                             "BLDCN2" );

        if ( *ppCN == NULL ) {

            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        wcscpy( *ppCN, TempString );


    } else {

        //
        // Get the object name
        //

        WinStatus = AdAzrolesInfo->AzpeGetProperty( pObject,
                                                    0, // No Flags
                                                    AZ_PROP_NAME,
                                                    (PVOID *)&ObjectName );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        //
        // Escape the returned object name so that special characters may be used
        //

        cObjectNameLen = (DWORD) wcslen( ObjectName );
        cQuotedObjectNameLen = 2*cObjectNameLen+1; // Twice the number of chars to include escape char. '\'

        QuotedObjectName = (PWCHAR) AzpAllocateHeap( cQuotedObjectNameLen*sizeof(WCHAR), "QTRDN" );

        if ( QuotedObjectName == NULL ) {

            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        WinStatus = DsQuoteRdnValue( cObjectNameLen, ObjectName, &cQuotedObjectNameLen, QuotedObjectName );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpGetCNForDN: Failed to quote RDN for object %ws: %ld\n",
                      ObjectName,
                      WinStatus
                      ));
            goto Cleanup;
        }

        //
        // Build a CN containing the object name
        //

        *ppCN = (PWCHAR) AzpAllocateHeap(
                             (BUILD_CN_PREFIX_LENGTH +
                              cQuotedObjectNameLen +
                              BUILD_CN_SUFFIX_LENGTH + 1) *
                             sizeof( WCHAR ),
                             "BLDCN3" );

        if ( *ppCN == NULL ) {

            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        wcscpy( *ppCN, BUILD_CN_PREFIX );

        wcscat( *ppCN, QuotedObjectName );

        wcscat( *ppCN, BUILD_CN_SUFFIX );

    }

    WinStatus = NO_ERROR;

 Cleanup:
    AdAzrolesInfo->AzpeFreeMemory( ObjectName );
    AdAzrolesInfo->AzpeFreeMemory( QuotedObjectName );

    return WinStatus;
}

DWORD
AzpCreateGuidCN(
    OUT PWCHAR *ppCN,
    IN PWCHAR pGuidString OPTIONAL
    )
/*++

Routine Description:

        This routine creates a GUIDized CN.  This routine is called specifically
        for AzApplication, and AzScope objects since their names can be longer than
        64 chars and RDN cannot.

Arguments:

        ppCN - The created CN

        pGuidString - An optional GUID string to be used for the CN

Return Values:

        NO_ERROR - The CN was created successfully
        ERROR_NOT_ENOUGH_MEMORY
--*/
{
    DWORD WinStatus = 0;

    PWCHAR pGuidValue = NULL;

    GUID guid;

    if ( pGuidString == NULL ) {

        //
        // Get a GUID for the object.
        //

        WinStatus = UuidCreate( &guid );

        if ( WinStatus != NO_ERROR ) {

            goto Cleanup;
        }

        WinStatus = UuidToString( &guid,
                                  &pGuidValue );

        if ( WinStatus != NO_ERROR ) {

            goto Cleanup;

        }

    } else {

        //
        // use the passed GUID string
        //

        pGuidValue = pGuidString;

    }


    *ppCN = (PWCHAR) AzpAllocateHeap ( (wcslen( pGuidValue ) +
                                        BUILD_CN_PREFIX_LENGTH +
                                        BUILD_CN_SUFFIX_LENGTH + 1 ) *
                                       sizeof( WCHAR ), "BLDCN" );

    if ( *ppCN == NULL ) {

        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    wcscpy( *ppCN, BUILD_CN_PREFIX );
    wcscat( *ppCN, pGuidValue );
    wcscat( *ppCN, BUILD_CN_SUFFIX );

    WinStatus = NO_ERROR;

 Cleanup:

    if ( pGuidString == NULL && pGuidValue != NULL ) {

        RpcStringFree( &pGuidValue );
    }

    return WinStatus;
}

DWORD
AzpADObjectContainerRDN(
    IN AZPE_OBJECT_HANDLE pParentObject,
    OUT PWCHAR *ppCN,
    IN LPCWSTR pParentDN OPTIONAL,
    IN LPCWSTR pPolicyDN,
    IN BOOL bObjectContainerCreate,
    IN PAZ_AD_CHILD_OBJECT_CONTAINERS pChildObjectContainer
    )
/*++

Routine Description:

        This routine creates a CN for an AZ_AD_OBJECT_CONTAINER object.  It simply
        takes the stringized GUID name for the passed in parent object if the parent
        object is AzApplication/AzScope, and prefixes it with *_OBJECT_CONTAINER_NAME_PREFIX.

        If the parent is AzAuthorizationStore, it takes the name of the authorization store
        object and prefixes it with *_OBJECT_CONTAINER_NAME_PREFIX

Arguments:

        pParentObject - Handle to the parent object

        ppCN - The created CN

        pParentDN - An optional parameter containing the DN of the parent object.
                    This is used when someone wants to create the the whole DN for
                    AZ_AD_OBJECT_CONTAINER during its creation

        pPolicyDN - DN of the policy store

        bObjectContainerCreate - TRUE if the DN is needed for the object container
                        creation

        pChildObjectContainer - Prefix for child object container.  NULL if child object
                        container RDN is not being constructed

Return Values:

        NO_ERROR - The CN was created successfully
        ERROR_NOT_ENOUGH_MEMORY
--*/
{
    DWORD WinStatus = 0;

    PWCHAR pPrefixGuidString = NULL;

    PWCHAR pGuidString = NULL;

    LPCWSTR pAzStoreNameStart = NULL;
    LPCWSTR pAzStoreNameEnd = NULL;

    ULONG lParentDNLength = 0;

    ULONG lObjectType = AdAzrolesInfo->AzpeObjectType( pParentObject );

    size_t lStringSize = 0;

    //
    // Validation
    // The container object can only be a child of an AzApplication object
    // or AzScope or AzAuthorizationStore object
    //

    ASSERT( pParentObject != NULL );
    ASSERT( lObjectType == OBJECT_TYPE_APPLICATION ||
            lObjectType == OBJECT_TYPE_AZAUTHSTORE ||
            lObjectType == OBJECT_TYPE_SCOPE );

    if ( pParentDN == NULL ) {

        pParentDN = pPolicyDN;
    }

    lParentDNLength = (ULONG)wcslen( pParentDN );

    if ( lObjectType == OBJECT_TYPE_APPLICATION ||
         lObjectType == OBJECT_TYPE_SCOPE ) {

        //
        // Get the stringized GUID name from the parent
        //

        pGuidString = (PWCHAR) AdAzrolesInfo->AzpeGetProviderData( pParentObject );
        ASSERT( pGuidString != NULL );

        pPrefixGuidString = pGuidString + BUILD_CN_PREFIX_LENGTH;

        lStringSize =  BUILD_CN_PREFIX_LENGTH + pChildObjectContainer->lPrefixLength +
            wcslen( pPrefixGuidString );

        if ( bObjectContainerCreate ) {

            lStringSize += lParentDNLength;
        }

    } else {

        pAzStoreNameStart = pParentDN + BUILD_CN_PREFIX_LENGTH;

        pAzStoreNameEnd = AzpGetAuthorizationStoreParent( pAzStoreNameStart );

        if (NULL == pAzStoreNameEnd)
        {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        lStringSize = BUILD_CN_PREFIX_LENGTH + pChildObjectContainer->lPrefixLength +
            (pAzStoreNameEnd-pAzStoreNameStart);

        if ( bObjectContainerCreate ) {

            lStringSize += lParentDNLength;
        }
    }


    *ppCN = (PWCHAR) AzpAllocateHeap (
                         ( lStringSize + 1 ) * sizeof( WCHAR ),
                         "CONTRDN" );

    if ( *ppCN == NULL ) {

        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    wcscpy( *ppCN, BUILD_CN_PREFIX );
    wcscat( *ppCN, pChildObjectContainer->pObjectContainerPrefix );

    if ( lObjectType == OBJECT_TYPE_APPLICATION ||
         lObjectType == OBJECT_TYPE_SCOPE ) {

        wcscat( *ppCN, pPrefixGuidString );

    } else {

        wcsncat( *ppCN, pAzStoreNameStart,
                 (pAzStoreNameEnd-pAzStoreNameStart) );
    }

    if ( bObjectContainerCreate ) {

        wcscat( *ppCN, pParentDN );
    }

    WinStatus = NO_ERROR;

 Cleanup:

    pGuidString = NULL;
    pPrefixGuidString = NULL;

    return WinStatus;
}

DWORD
AzpADBuildDNForAzStoreParent(
    IN PAZP_AD_CONTEXT pContext,
    OUT PWCHAR *ppDN
    )
/*++

Routine Description:

        This routine builds a DN for the container object in DS
        that contains (will contain) the authorization store object

Arguments:

        pContext - context for the store

        pObject - Pointer to object to get policy URl from

        ppDN - The created DN

Return Values:

        NO_ERROR - DN was created successfully

        ERROR_NOT_ENOUGH_MEMORY

--*/
{

    DWORD WinStatus = 0;

    LPCWSTR pParentDN = NULL;

    //
    // The policy URl is in the format
    // msldap://servername:port/CN=AzAuthStoreObject,DC=X
    // We need to extract the DC=X part.  This is
    // the object that will always exist in DS
    // We need to take care of escaped characters
    //

    pParentDN = AzpGetAuthorizationStoreParent( pContext->PolicyUrl );
    if (NULL == pParentDN)
    {
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    *ppDN = (PWCHAR) AzpAllocateHeap(
                         (wcslen( pParentDN ) + 1) *
                         + sizeof( WCHAR ), "ADPARDN" );

    if ( *ppDN == NULL ) {

        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    wcscpy( *ppDN, pParentDN );

    WinStatus = NO_ERROR;

 Cleanup:

    pParentDN = NULL;

    return WinStatus;
}

LPCWSTR
AzpGetAuthorizationStoreParent(
    IN LPCWSTR PolicyDN
    )
/*++

Routine description:

    This routine returns the parent DN for the Authorization Store

Arguments:

    PolicyDN - DN for the AzAuthorizationStore

Return Value:

    The DN of the parent of the AuthorizationStore.
    NULL will be returned if the passed in parameter doesn't contain the
    comma delimiter.

--*/
{

    LPCWSTR pReturnStr = NULL;
    LPCWSTR pEscChar = NULL;

    //
    // validation
    //

    ASSERT( PolicyDN != NULL );

    pReturnStr = pEscChar = wcschr( PolicyDN, L',' );

    if (NULL != pEscChar)
    {
        DWORD EscCharCnt = 0;

        while ( *(--pEscChar) == L'\\' ) {

            EscCharCnt++;
        }

        pReturnStr++;

        if ( (EscCharCnt%2) ) {

            pReturnStr = AzpGetAuthorizationStoreParent( pReturnStr );
        }
    }

    return pReturnStr;
}

BOOL
AzpLdapCrackUrl(
    IN OUT PWCHAR *ppszUrl,
    OUT PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
/*++

Routine Description:

        Crack an LDAP URL into its relevant parts.  The result must
        be freed using AzpLdapFreeUrlComponents

Parameters:
        ppszUrl - LDAP URL to be cracked
        pLdapUrlComponents - Structure storing the URL components

Return Value:
        TRUE  - URL was cracked successfully
        FALSE - URL could not be cracked
--*/
{
    BOOL  bResult = TRUE;
    ULONG cbUrl = INTERNET_MAX_PATH_LENGTH;
    PWCHAR pszHostInfo = NULL;
    PWCHAR pszDN = NULL;
    PWCHAR pszToken = NULL;
    WCHAR psz[INTERNET_MAX_PATH_LENGTH+1];

    //
    // Validation
    //

    ASSERT( *ppszUrl != NULL );
    if ( *ppszUrl == NULL ) {
        return FALSE;
    }

    //
    // Get rid of trailing '/'s from the URL
    //

    DWORD Len = (DWORD)wcslen(*ppszUrl);
    while ( Len > 0 && (*ppszUrl)[Len - 1] == L'/' ) {

        (*ppszUrl)[Len - 1] = L'\0';
        Len--;
    }

    //
    // Capture the URL and initialize the out parameter
    //

    __try
        {
            if ( !InternetCanonicalizeUrl(
                      *ppszUrl,
                      psz,
                      &cbUrl,
                      ICU_NO_ENCODE | ICU_DECODE
                      ) ) {

                bResult = FALSE;
                goto Cleanup;
            }
        }
    __except(EXCEPTION_EXECUTE_HANDLER)
        {
            SetLastError( GetExceptionCode() );
            bResult = FALSE;
            goto Cleanup;
        }

    //
    // Find the host
    //

    pszHostInfo = wcschr( psz, L'/' );

    //
    // if pszHostInfo is NULL, do not do the following
    //
    if ( pszHostInfo ) {

        pszHostInfo += 2;

        pszToken = pszHostInfo;

        //
        // If there is no host specified, we need to default to the local host
        // assuming it is the DC
        // The URL will then be in the form ldap://CN=
        //

        if ( !_wcsnicmp( pszToken, BUILD_CN_PREFIX,
                         BUILD_CN_PREFIX_LENGTH ) ) {

            //
            // no host name specified
            //
            pszHostInfo = NULL;

        } else {

            //
            // find the next / to separate host name and DN
            //
            while ( ( *pszToken != L'\0' ) && ( *pszToken != L'/' ) )
                pszToken++;

            if ( *pszToken == L'/' ) {

                *pszToken = L'\0';
                pszToken += 1;

            }

            while ( *pszToken == L'/' ) {

                pszToken++;

            }

        }
    }

    //
    // Find the DN
    //

    if ( pszToken != NULL ) {

        pszDN = L"";

        if ( *pszToken != L'\0' && *pszToken != L'?') {

            //
            // remember the DN
            //
            pszDN = pszToken;

            //
            // look for ? and terminiate it if found
            //
            pszToken = wcschr(pszToken, L'?');

            if ( pszToken ) {
                *pszToken = L'\0';
            }

        }

    } else {

        SetLastError( ERROR_INVALID_PARAMETER );

        bResult = FALSE;
        goto Cleanup;

    }


    //
    // Build up URL components
    //

    bResult = AzpLdapParseCrackedHost( pszHostInfo, pLdapUrlComponents );

    if ( bResult ) {

        bResult = AzpLdapParseCrackedDN( pszDN, pLdapUrlComponents );

    }

    if ( !bResult ) {

        AzpLdapFreeUrlComponents( pLdapUrlComponents );

    }

 Cleanup:

    return( bResult );
}

BOOL
AzpLdapParseCrackedHost(
    IN PWCHAR pszHost OPTIONAL,
    OUT PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
/*++

Routine Description:

      This procedure parses the cracked host string from LdapCrackUrl

Arguments:

      pszHost - Parsed host name
      pLdapUrlComponents - Structure storing the URL components

Return Value:

      TRUE - Cracked host name was parsed successfully
      FALSE - There was an error in parsing the cracked host name

--*/
{
    PWCHAR pszPort;

    if ( pszHost == NULL ) {

        pLdapUrlComponents->pszHost = NULL;
        pLdapUrlComponents->Port = LDAP_PORT;

        return( TRUE );
    }

    pszPort = wcschr( pszHost, L':' );

    if ( pszPort != NULL ) {

        *pszPort = L'\0';
        pszPort++;

    }

    pLdapUrlComponents->pszHost = (PWCHAR) AzpAllocateHeap(
                                               (wcslen( pszHost ) + 1)*
                                               sizeof( WCHAR ), "ADCRKHST"
                                               );

    if ( pLdapUrlComponents->pszHost == NULL ) {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( FALSE );

    }

    wcscpy( pLdapUrlComponents->pszHost, pszHost );

    pLdapUrlComponents->Port = 0;

    //
    // Get port number
    //

    if ( pszPort != NULL ) {

        pLdapUrlComponents->Port = _wtol( pszPort );

    }

    if ( pLdapUrlComponents->Port == 0 ) {

        pLdapUrlComponents->Port = LDAP_PORT;

    }

    return( TRUE );
}

BOOL
AzpLdapParseCrackedDN(
    IN PWCHAR pszDN,
    OUT PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
/*++

Routine Desciption:

        Parse the cracked DN

Arguments:

        pszDN - The parsed DN
        pLdapUrlComponents - Structure storing the URL components

Return Value:

      TRUE - Cracked DN was parsed successfully
      FALSE - There was an error in parsing the cracked DN

--*/
{
    BOOL bResult = FALSE;

    DWORD Len = (DWORD)wcslen( pszDN );

    pLdapUrlComponents->pszDN = (PWCHAR) AzpAllocateHeap(
                                             (Len + 1) *
                                             sizeof( WCHAR), "ADCRKDN"
                                             );

    if ( pLdapUrlComponents->pszDN == NULL ) {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );

        return bResult;

    }

    wcscpy( pLdapUrlComponents->pszDN, pszDN );

    //
    // make sure the DN does not end with a /
    //
    while ( Len > 0 &&
            pLdapUrlComponents->pszDN[Len-1] == L'/' ) {

        pLdapUrlComponents->pszDN[Len-1] = L'\0';
        Len--;
    }

    bResult = TRUE;

    return bResult;
}

VOID
AzpLdapFreeUrlComponents(
    IN OUT PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
/*++

Routine Description:

        Frees allocated URL components returned from LdapCrackUrl

Arguments:

        pLdapUrlComponents - Allocated structure to be freed

Return Value:

        (VOID)
--*/
{

    AzpFreeHeap( pLdapUrlComponents->pszHost );

    pLdapUrlComponents->pszHost = NULL;

    AzpFreeHeap( pLdapUrlComponents->pszDN );

    pLdapUrlComponents->pszDN = NULL;
}

INT __cdecl
AzpCompareSortStrings(
    IN const void *pArg1,
    IN const void *pArg2
    )
/*++

Routine Description:

        This routine compares two strings for the qsort/bsearch API

Arguments:

        pArg1 - First string for comparison
        pArg2 - Second String for comparison

Return Values:

        <0 - First string is smaller
        0 - strings are same
        >0 - First string is larger

--*/
{

    return _wcsicmp( * (PWCHAR *) pArg1, * (PWCHAR *) pArg2);
}

DWORD
AzpCheckPolicyExistence(
    LDAP* pLdapH,
    PWCHAR pDN,
    BOOL bCreatePolicy
    )
/*++

Routine Description:

        This routine runs a preliminary base scope search on the passed
        DN to check if the policy exists for the given URL.
        If bCreatePolicy is TRUE and the policy does exist, return
        ERROR_ALREADY_EXISTS.  If bCreatePolicy is FALSE, and the policy
        does not exist, return ERROR_FILE_NOT_FOUND.

Arguments:

        pLdapH - LDAP handle to DS
        pDN - DN of the store policy to be checked for existence
        bCreatePolicy - Bool indicating if policy needs to be created or not

Return Value:

        NO_ERROR if the policy does not exist
        ERROR_ALREADY_EXISTS if policy does exist and bCreatePolicy is TRUE
        ERROR_FILE_NOT_FOUND if policy does not exist and bCreatePolicy is FALSE

--*/
{

    DWORD WinStatus = 0;
    ULONG LdapStatus = 0;

    LDAPMessage* pResult = NULL;

    //
    // Validation
    //

    ASSERT( pDN != NULL);

    //
    // Perform a base level search on the passed DN
    //

    LdapStatus = ldap_search_s(
                     pLdapH,
                     pDN,
                     LDAP_SCOPE_BASE,
                     AZ_AD_ALL_CLASSES,
                     NULL,
                     0,
                     &pResult
                     );

    if ( LdapStatus == LDAP_NO_SUCH_OBJECT && !bCreatePolicy ) {

        WinStatus = ERROR_FILE_NOT_FOUND;
        goto Cleanup;

    } else if ( LdapStatus == LDAP_SUCCESS && bCreatePolicy ) {

        WinStatus = ERROR_ALREADY_EXISTS;
        goto Cleanup;
    }

    WinStatus = NO_ERROR;

 Cleanup:


    if ( pResult != NULL ) {

        ldap_msgfree( pResult );
    }

    return WinStatus;
}

DWORD
AzpADCheckCompatibility(
    LDAP* pLdapH
    )
/*++

Routine Description:

    This routine checks the domain's behavior version on the domainDns object
    of the DC to be at least AZ_AD_MIN_DOMAIN_BEHAVIOR_VERSION.  It further calls
    a sub-routine to check if the schema is upto-date with version number
    AZ_AD_MIN_SCHEMA_OBJECT_VERSION.

Arguments:

    pLdapH - LDAP handle to the DS

Return Value:

    NO_ERROR - The domain's behavior version is upto par
    ERROR_CURRENT_DOMAIN_NOT_ALLOWED - The current domain will not work for
               this version of azroles.  This may be because of two
               reasons:
                    1) The domain is not .Net native
                    2) The schema is incompatible
    Other Ldap Status codes

--*/
{

    DWORD WinStatus = NO_ERROR;
    ULONG LdapStatus = LDAP_SUCCESS;

    LDAPMessage* pResult = NULL;
    LDAPMessage* pEntry = NULL;

    PWCHAR *ppValueList = NULL;

    PWCHAR attrs[] = {
        LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W, 
        LDAP_OPATT_SCHEMA_NAMING_CONTEXT_W
    };

    ULONG i = 0;
    
    LdapStatus = ldap_search_s(
                     pLdapH,
                     NULL,
                     LDAP_SCOPE_BASE,
                     AZ_AD_ALL_CLASSES,
                     NULL,
                     0,
                     &pResult
                     );

    if ( LdapStatus != LDAP_SUCCESS ) {

        WinStatus = LdapMapErrorToWin32( LdapStatus );
        goto Cleanup;
    }

    pEntry = ldap_first_entry( pLdapH, pResult );

    if ( pEntry != NULL ) {

        //
        // Check if we are talking to an ADAM
        //

        ppValueList = ldap_get_values ( pLdapH,
                                        pEntry,
                                        LDAP_OPATT_SUPPORTED_CAPABILITIES_W
                                        );

        if ( ppValueList == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        else
        {
            i = 0;
            while (ppValueList[i] != NULL)
            {
                if (_wcsicmp(ppValueList[i++], AZ_AD_ADAM_OID) == 0)
                {
                    //
                    // we are talking to ADAM, so don't need further checking
                    //

                    goto Cleanup;
                }
            }
            ldap_value_free( ppValueList );
            ppValueList = NULL;
        }

        for ( i = 0; i < sizeof(attrs)/sizeof(PWSTR); i++ ) {

            ppValueList = ldap_get_values( pLdapH,
                                           pEntry,
                                           attrs[i]
                                           );

            if ( ppValueList == NULL ) {

                //
                // There should be the attribute we are looking for.
                // If we failed to retrieve it, that means there was a lack of
                // memory is storing/retrieving the value
                //

                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            WinStatus = AzpADCheckCompatibilityEx(
                            pLdapH,
                            *ppValueList,
                            i
                            );

            if ( WinStatus != NO_ERROR ) {

                goto Cleanup;
            }

            //
            // free this memory for the next iteration
            //
 
            ldap_value_free( ppValueList );
            ppValueList = NULL;
        }
    }

    WinStatus = NO_ERROR;

 Cleanup:


    //
    // release local memory
    //

    if ( ppValueList != NULL ) {

        ldap_value_free( ppValueList );
    }

    if ( pResult != NULL ) {

        ldap_msgfree( pResult );
    }

    return WinStatus;
}

DWORD
AzpADCheckCompatibilityEx(
    LDAP* pLdapH,
    PWCHAR pDN,
    ULONG index
    )
/*++

Routine Description:

        Worker routine for AzpADCheckCompatibility

Arguments:

        pLdapH - LDAP handle to the DC
        pDN    - DN of the object being queried
        index - index into the array identifying behavior to be checked

Return Values:

        NO_ERROR - The version is OK
        ERROR_CURRENT_DOMAIN_NOT_ALLOWED - The current domain will not work for
               this version of azroles.  This may be because of two
               reasons:
                    1) The domain is not .Net native
                    2) The schema is incompatible
        Other LDAP status codes

--*/
{

    DWORD WinStatus = 0;
    ULONG LdapStatus = 0;

    PWCHAR *ppValueList = 0;

    LDAPMessage* pResult = NULL;
    LDAPMessage* pEntry = NULL;

    PWCHAR attrs[] = {
        AZ_AD_DOMAIN_BEHAVIOR,
        AZ_AD_SCHEMA_OBJECT_VERSION
    };

    LONG attrsVal[] = {
        AZ_AD_MIN_DOMAIN_BEHAVIOR_VERSION,
        AZ_AD_MIN_SCHEMA_OBJECT_VERSION
    };


    LdapStatus = ldap_search_s(
                     pLdapH,
                     pDN,
                     LDAP_SCOPE_BASE,
                     AZ_AD_ALL_CLASSES,
                     NULL,
                     0,
                     &pResult
                     );

    if ( LdapStatus != NO_ERROR ) {

        WinStatus = LdapMapErrorToWin32( LdapStatus );
        goto Cleanup;
    }

    pEntry = ldap_first_entry( pLdapH, pResult );

    if ( pEntry != NULL ) {

        ppValueList = ldap_get_values(
                          pLdapH,
                          pEntry,
                          attrs[index]
                          );

        if ( ppValueList != NULL ) {

            if ( _wtol( *ppValueList ) >= attrsVal[index] ) {

                WinStatus = NO_ERROR;
                goto Cleanup;

            } else {

                WinStatus = ERROR_CURRENT_DOMAIN_NOT_ALLOWED;
                goto Cleanup;

            }
        }
    }

    //
    // If the values were not retrieved, then there has been
    // a memory resource problem
    //

    WinStatus = ERROR_NOT_ENOUGH_MEMORY;

 Cleanup:

    //
    // local cleanup
    //

    if ( ppValueList != NULL ) {

        ldap_value_free( ppValueList );

    }

    if ( pResult != NULL ) {

        ldap_msgfree( pResult );

    }

    return WinStatus;
}

DWORD
AzpCheckVersions(
    LDAP        * pLdapH,
    LDAPMessage * pResult
    )
/*++

Routine Description:

    This routine checks if the versions of the authorization store persisted
    in the store will allow us to continue reading or not.

Arguments:

    pLdapH  - LDAP handle to DS
    pResult - the search results that contains the major and minor versions

Return Value:

    NO_ERROR - we can continue reading.

    ERROR_REVISION_MISMATCH if we can't continue reading due to version mismatch
    Other status codes

Note:

    Our current implementation is that we will support reading for minor version
    mismatch but not reading for major version mismatch.

--*/
{
    //
    // Validation
    //

    ASSERT( pLdapH != NULL && pResult != NULL);

    DWORD WinStatus = ERROR_REVISION_MISMATCH;

    PWCHAR * ppValueList = ldap_get_values (
                               pLdapH,
                               pResult,
                               L"msDS-AzMajorVersion"
                               );

    if ( ppValueList != NULL )
    {
        LPWSTR pszStop;

        //
        // this casting will catch those negative integers
        //

        ULONG ulMajorVersion = (ULONG)(wcstol( ppValueList[0], &pszStop, 10));

        //
        // we want this to be perfect string for a number. Nothing should
        // be left after the wcstol.
        //

        if (ulMajorVersion <= AzGlCurrAzRolesMajorVersion && pszStop[0] == L'\0')
        {
            WinStatus = NO_ERROR;
        }

        ldap_value_free(ppValueList);
    }

    return WinStatus;
}

DWORD
AzpADReadNTSecurityDescriptor(
    IN PAZP_AD_CONTEXT pContext,
    IN AZPE_OBJECT_HANDLE pObject,
    IN PWCHAR pOptDN OPTIONAL,
    IN BOOL bAzAuthorizationStoreParent,
    OUT PSECURITY_DESCRIPTOR *ppSD,
    IN BOOL bReadSacl,
    IN BOOL bReadDacl
    )
/*++

Routine Description:

        This routine is a worker routine that reads the NT security
        descriptor for a given object

Arguments:

        pContext - context for the store

        pObject - Handle to object whose security descriptor or its container
                  child's security descriptor needs to be read

        pDN - Optional DN for the object

        pEntry - An optional LDAPMessage structure to read the DN off from

        bAzAuthorizationStoreParent - TRUE if the AzAuthorizationStore objects DS parent's NT security
                       descriptor needs to be read

        ppSD - Pointer to returned security descriptor
            The returned security descriptor should be freed using AzpFreeHeap.

        bReadSacl - TRUE if SACL needs to be read

        bReadDacl - TRUE if DACL needs to be read

Return Values:

        NO_ERROR - The security descriptor was read successfully
        ERROR_DS_INSUFF_ACCESS_RIGHTS - The security descriptor could not be read

        Other status codes

--*/
{

    DWORD WinStatus = 0;
    ULONG LdapStatus = 0;

    PWCHAR pDN = NULL;

    LDAPMessage *pResult = NULL;
    LDAPMessage *pEntry = NULL;

    LDAP_BERVAL **ppBerVal = NULL;

    BYTE berValue[2*sizeof(ULONG)];

    PWCHAR ppAttr[] = { AZ_AD_NT_SECURITY_DESCRIPTOR, NULL };


    SECURITY_INFORMATION info = 0;

    LDAPControl se_info_control = {

        TEXT(LDAP_SERVER_SD_FLAGS_OID),
        {
            5, (PCHAR)berValue
        },
        TRUE
    };

    PLDAPControl server_controls[] = {

        &se_info_control,
        NULL
    };

    //
    // Validation
    //

    ASSERT( pObject != NULL );
    ASSERT( pContext != NULL );
    ASSERT( pContext->PolicyUrl != NULL );

    //
    // Set the SECURITY_INFORMATION according to flags passed in
    //

    if ( bReadDacl ) {

        info = DACL_SECURITY_INFORMATION;

    }

    if ( bReadSacl ) {

        info |= SACL_SECURITY_INFORMATION;

    }

    //
    // Get the LDAP store context for LDAP handle
    //

    //
    // Build DN for object whose NT security descriptor needs to be got.
    // Pass bAzAuthorizationStoreParent - need this to read the security descriptor
    // of an already existing DS object
    //

    if ( pOptDN == NULL ) {

        WinStatus = AzpADBuildDN(
                        pContext,
                        pObject,
                        &pDN,
                        NULL,
                        bAzAuthorizationStoreParent,
                        NULL
                        );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_AD,
                      "AzpADReadNTSecurityDescriptor: AzpADBuildDN failed: %ld\n",
                      WinStatus
                      ));
            goto Cleanup;

        }

        pOptDN = pDN;
    }

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)info & 0xF);

    //
    // Search the object with the above DN to get the
    // NTSecurityDescriptor
    //

    LdapStatus = ldap_search_ext_s(
                     pContext->ld,
                     pOptDN,
                     LDAP_SCOPE_BASE,
                     AZ_AD_ALL_CLASSES,
                     ppAttr,
                     0,
                     (PLDAPControl *)server_controls,
                     NULL,
                     NULL,
                     0,
                     &pResult
                     );

    if ( LdapStatus != LDAP_SUCCESS ) {

        WinStatus = LdapMapErrorToWin32( LdapStatus );
        AzPrint(( AZD_AD,
                  "AzpADReadNTSecurityDescriptor: Failed to perform"
                  " search on %ws: %ld\n",
                  pDN,
                  WinStatus
                  ));
        goto Cleanup;
    }

    pEntry = ldap_first_entry( pContext->ld, pResult );

    if ( pEntry != NULL ) {

        ppBerVal = ldap_get_values_len( pContext->ld,
                                        pEntry,
                                        AZ_AD_NT_SECURITY_DESCRIPTOR );
        if ( ppBerVal != NULL ) {

            (*ppSD) = (PSECURITY_DESCRIPTOR) AzpAllocateHeap(
                                                 ppBerVal[0]->bv_len, "ADSD" );

            if ( (*ppSD) == NULL ) {

                WinStatus = ERROR_NOT_ENOUGH_MEMORY;

                goto Cleanup;
            }

            memcpy( *ppSD,
                    (SECURITY_DESCRIPTOR *) ppBerVal[0]->bv_val,
                    ppBerVal[0]->bv_len
                    );

        } else {

            WinStatus = ERROR_DS_INSUFF_ACCESS_RIGHTS;
            goto Cleanup;

        }
    } else {

        //
        // AZ_AD_NT_SECURITY_DESCRIPTOR value should exist if user
        // has sufficient rights to read it
        //

        WinStatus = ERROR_DS_INSUFF_ACCESS_RIGHTS;
        goto Cleanup;
    }

    WinStatus = NO_ERROR;

 Cleanup:

    //
    // free used resources
    //

    if ( pDN != NULL ) {

        AzpFreeHeap( pDN );
    }

    if ( ppBerVal != NULL ) {

        ldap_value_free_len( ppBerVal );
    }

    if ( pResult != NULL ) {

        ldap_msgfree( pResult );
    }

    return WinStatus;
}

DWORD
AzpADStampSD(
    IN PAZP_AD_CONTEXT pContext,
    IN PWCHAR pDN,
    IN SECURITY_INFORMATION SeInfo,
    IN PSECURITY_DESCRIPTOR pSD
    )
/*++

Routine Description:

        This routine stamps an updated security descriptor onto the object represented
        by the passed in DN.

Arguments:

        pContext - context for the store

        pDN     - DN of the object being updated

        dSize   - Size of the security descriptor

        SeInfo  - Security information about the security descriptor

        pSD     - The updated security descriptor that needs to be stamped on

Return Values:

        NO_ERROR - The new security descriptor was stamped onto the object in DS
                   successfully

        Other status codes

--*/
{

    DWORD        WinStatus  = 0;
    ULONG        LdapStatus = 0;

    PLDAPMod     ppAttrList[2];
    PLDAP_BERVAL ppBerVals[2];
    LDAPMod      Attribute;
    LDAP_BERVAL  BerVal;
    BYTE ControlBuffer[5];

    LDAPControl SeInfoControl = {

        LDAP_SERVER_SD_FLAGS_OID_W,
        {
            5, (PCHAR) ControlBuffer
        },
        TRUE
    };

    PLDAPControl ServerControls[2] = {
        &SeInfoControl,
        NULL
    };

    //
    // Validation
    //

    ASSERT( pContext != NULL );
    ASSERT( IsValidSecurityDescriptor( pSD ) );

    //
    // Get the LDAP store context for LDAP handle
    //


    ControlBuffer[0] = 0x30;
    ControlBuffer[1] = 0x3;
    ControlBuffer[2] = 0x02;
    ControlBuffer[3] = 0x01;
    ControlBuffer[4] = (BYTE)((ULONG)SeInfo & 0xF);

    ppAttrList[0] = &Attribute;
    ppAttrList[1] = NULL;

    ppBerVals[0] = &BerVal;
    ppBerVals[1] = NULL;

    BerVal.bv_val = (PCHAR) pSD;
    BerVal.bv_len = GetSecurityDescriptorLength( pSD );

    Attribute.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    Attribute.mod_type = AZ_AD_NT_SECURITY_DESCRIPTOR;
    Attribute.mod_values = (PWSTR *) ppBerVals;

    //
    // Perform the modification on the object
    //

    LdapStatus = ldap_modify_ext_s(
                     pContext->ld,
                     pDN,
                     ppAttrList,
                     (PLDAPControl *)ServerControls,
                     NULL
                     );

    if ( LdapStatus != LDAP_SUCCESS ) {

        WinStatus = LdapMapErrorToWin32( LdapStatus );

        AzPrint(( AZD_AD,
                  "AzpADStampSD: Failed to update security descriptor"
                  " on %ws: %ld\n",
                  pDN,
                  WinStatus
                  ));

        goto Cleanup;
    }

    WinStatus = NO_ERROR;

 Cleanup:

    return WinStatus;
}


BOOL
AzpIsAttrDirty(
    IN AZPE_OBJECT_HANDLE pObject,
    IN AZ_AD_ATTRS ObjectAttr
    )
/*++

Routine Description:

        Determines if a particular attribute is dirty.  Separate
        function needed because of dual membership attributes
        for AzApplicationGroup and AzRole objects.  DS stores the
        members/non-members in one attribute, but the core stores
        them separated on whether the (non)members are SID (non)members
        or AzApplicationGroup (non)members.

Arguments:

        pObject - Pointer to object whose attribute needs to be checked

        ObjectAttr - Object attribute needed to be checked

Return Values:

        TRUE - If the particular attribute is dirty

        FALSE - If the particular attribute is not dirty

--*/
{
    ULONG lObjectType = AdAzrolesInfo->AzpeObjectType(pObject);
    ULONG lDirtyBits = AdAzrolesInfo->AzpeDirtyBits(pObject);

    //
    // Validation
    //

    ASSERT( pObject != NULL );

    //
    // Is this object of type AzApplicationGroup?
    //

    if ( lObjectType == OBJECT_TYPE_GROUP ) {

        if ( ObjectAttr.AttrType == AZ_PROP_GROUP_MEMBERS ) {

            return ( (lDirtyBits & AZ_DIRTY_GROUP_MEMBERS) ||
                     (lDirtyBits & AZ_DIRTY_GROUP_APP_MEMBERS) );

        } else  if ( ObjectAttr.AttrType == AZ_PROP_GROUP_NON_MEMBERS ) {

            return ( (lDirtyBits & AZ_DIRTY_GROUP_NON_MEMBERS) ||
                     (lDirtyBits & AZ_DIRTY_GROUP_APP_NON_MEMBERS) );
        }
    } else if ( lObjectType == OBJECT_TYPE_ROLE ) {

        if ( ObjectAttr.AttrType == AZ_PROP_ROLE_MEMBERS ) {

            return ( (lDirtyBits & AZ_DIRTY_ROLE_MEMBERS) ||
                     (lDirtyBits & AZ_DIRTY_ROLE_APP_MEMBERS) );
        }
    }

    return ( lDirtyBits & ObjectAttr.lDirtyBit );
}

DWORD
AzpADAllocateAttrHeap(
    IN  DWORD      dwCount,
    OUT PLDAPMod **ppAttribute
    )
/*++

Routine Description:

        This routine allocates memory to a attribute list structure list

Arguments:

        ppAttrList - Pointer to attribute list that needs memory

Return Status:

        NO_ERROR - Memory was allocated successfully
        ERROR_NOT_ENOUGH_MEMORY
--*/
{
    DWORD WinStatus = 0;

    ULONG i = 0;

    *ppAttribute = ( LDAPMod **) AzpAllocateHeap( dwCount * sizeof(LDAPMod *), "ATRSTR" );

    if ( *ppAttribute == NULL ) {

        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    for ( i = 0; i < dwCount; i++ ) {

        (*ppAttribute)[i] = NULL;

    }

 Cleanup:

    return WinStatus;
}

DWORD
AzpADAllocateAttrHeapModVals(
    IN OUT LDAPMod **ppAttribute,
    IN ULONG lCount
    )
/*++

Routine Description:

        This routine allocates memory to a attribute list structure element

Arguments:

        ppAttribute - Pointer to attribute list that needs memory

 lCount - Number of attribute values needed

Return Status:

        NO_ERROR - Memory was allocated successfully
        ERROR_NOT_ENOUGH_MEMORY
--*/
{
    DWORD WinStatus = 0;

    ULONG i = 0;

    *ppAttribute = (LDAPMod *) AzpAllocateHeap( sizeof( LDAPMod ), "ATRLST" );

    if ( *ppAttribute == NULL ) {

        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    (*ppAttribute)->mod_values =
        (PWCHAR *) AzpAllocateHeap( lCount * sizeof( PWCHAR ), "ATRMOD" );

    if ( (*ppAttribute)->mod_values == NULL ) {

        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    for ( i = 0; i < lCount; i++) {

        (*ppAttribute)->mod_values[i] = NULL;

    }

 Cleanup:

    return WinStatus;
}

VOID
AzpADFreeAttrHeap(
    OUT PLDAPMod **ppAttributeList,
    IN BOOL bDeleteAttrList
    )
/*++

Routine Description:

        This routine frees the heap allocated to the LDAPMod structures

Arguments:

        ppAttributeList - Attribute list to be deleted

        bDeleteAttrList - TRUE if the entire list needs to be deleted
                          FALSE is only sub-components need to be deleted

Return Values:

        None

--*/
{

    ULONG lAttrValueCount = 0;
    ULONG lAttrListCount = 0;

    if ( (*ppAttributeList) != NULL ) {

        //
        // Iterate through the list freeing the heaps.
        //

        while ( (*ppAttributeList)[lAttrListCount] != NULL ) {

            if ( (*ppAttributeList)[lAttrListCount]->mod_values != NULL ) {

                while ( (*ppAttributeList)[lAttrListCount]->mod_values[lAttrValueCount]
                        != NULL ) {


                    AzpFreeHeap( (*ppAttributeList)[lAttrListCount]->
                                 mod_values[lAttrValueCount] );

                    lAttrValueCount++;
                }

                AzpFreeHeap( (*ppAttributeList)[lAttrListCount]->mod_values );
            }

            AzpFreeHeap( (*ppAttributeList)[lAttrListCount] );

            (*ppAttributeList)[lAttrListCount] = NULL;

            lAttrValueCount = 0;

            lAttrListCount++;
        }

        if ( bDeleteAttrList ) {

            AzpFreeHeap( (*ppAttributeList) );

            (*ppAttributeList) = NULL;
        }
    }
}

DWORD
AzpADStoreHasUpdate (
    IN  BOOL                 bUpdateContext,
    IN OUT PAZP_AD_CONTEXT   pContext,
    OUT BOOL               * pbHasUpdate
    )
/*++
Description:

    Determine whether AD store has been modified since our store loaded.
    For AD store, we rely on the uSNChanged attribute of the Authorization
    store object to tell us if any change to the store has happened.

Arguments:

    bUpdateContext - Whether or not this function call should update the Context's
                        uSNChanged attribute.

    pContext     - The persist context. If bUpdateContext is true, then
                    this function call will update the context's uSNChanged attribute

    pbHasUpdate  - Receives the test result.

Return Value:

    NO_ERROR - If test is successful

    Various error codes if error is encountered.
--*/
{
    AZASSERT(pContext != NULL);
    AZASSERT(pbHasUpdate != NULL);

    DWORD dwStatus = NO_ERROR;
    *pbHasUpdate = FALSE;

    //
    // search for the uSNChanged attribute of the authorization store object
    //

    ULONG LdapStatus = 0;

    LDAP *pLdapHandle = NULL;
    LDAPMessage *pResult = NULL;
    LDAPMessage *pObjectEntry = NULL;

    pLdapHandle = pContext->ld;

    LPWSTR usnObjVer[] = {AD_USNCHANGED, AD_OBJECTVERSION, NULL};

    LdapStatus = ldap_search_ext_s(
                     pLdapHandle,
                     pContext->pContextInfo,
                     LDAP_SCOPE_BASE,
                     AZ_AD_AZSTORE_FILTER,
                     usnObjVer,
                     0,
                     pContext->pLdapControls,
                     NULL,
                     NULL,
                     0,
                     &pResult // buffer to store read attributes
                     );

    if ( LdapStatus == LDAP_NO_SUCH_OBJECT )
    {
        //
        // most likely the objectVersion attribute is missing.
        // Try one more time.
        //

        if ( pResult != NULL )
        {
            ldap_msgfree(pResult);
            pResult = NULL;
        }

        LPWSTR usn[] = {AD_USNCHANGED, NULL};

        LdapStatus = ldap_search_ext_s(
                     pLdapHandle,
                     pContext->pContextInfo,
                     LDAP_SCOPE_BASE,
                     AZ_AD_AZSTORE_FILTER,
                     usn,
                     0,
                     pContext->pLdapControls,
                     NULL,
                     NULL,
                     0,
                     &pResult // buffer to store read attributes
                     );
    }

    if ( LdapStatus == LDAP_NO_SUCH_OBJECT )
    {
        dwStatus = ERROR_FILE_NOT_FOUND;
        goto Cleanup;

    } else if ( LdapStatus != LDAP_SUCCESS ) {

        dwStatus = LdapMapErrorToWin32( LdapStatus );
        goto Cleanup;

    }

    pObjectEntry = ldap_first_entry( pLdapHandle, pResult );

    ULONGLONG ullStoreUSN = 0;
    if ( pObjectEntry != NULL )
    {
        ullStoreUSN = AzpADReadUSNChanged(pLdapHandle, pObjectEntry, &(pContext->HasObjectVersion) );
    }
    else
    {
        dwStatus = ERROR_DS_INSUFF_ACCESS_RIGHTS;
        goto Cleanup;
    }

    *pbHasUpdate = (pContext->ullUSNChanged < ullStoreUSN);

    if (bUpdateContext)
    {
        pContext->ullUSNChanged = ullStoreUSN;
    }

Cleanup:

    if ( pResult != NULL )
    {
        ldap_msgfree(pResult);
    }

    return dwStatus;
}

ULONGLONG
AzpADReadUSNChanged (
    IN LDAP        * pLdapHandle,
    IN LDAPMessage * pEntry,
    OUT BOOLEAN      * pbHasObjectVersion
    )
/*++
Description:

    Read and return the uSNChanged attribute value.

Arguments:

    pLdapHandle  - The ldap handle.

    pEntry       - The search entry

    pbHasObjectVersion - Whether the object has ObjectVersion attribute or not

Return Value:

    The uSNChanged value. 0 if the reseach result doesn't have the attribute.

--*/
{
    AZASSERT(pLdapHandle != NULL);
    AZASSERT(pEntry != NULL);
    AZASSERT(pbHasObjectVersion != NULL);

    ULONGLONG ullUSN = 0;
    PWCHAR *ppValueList = ldap_get_values(pLdapHandle, pEntry, AD_USNCHANGED );

    if ( ppValueList != NULL )
    {
        ullUSN =_wtoi64( *ppValueList );
        ldap_value_free( ppValueList );
    }

    ppValueList = ldap_get_values(pLdapHandle, pEntry, AD_OBJECTVERSION );

    if ( ppValueList != NULL )
    {
        *pbHasObjectVersion = TRUE;
        ldap_value_free( ppValueList );
    }
    else
    {
        *pbHasObjectVersion = FALSE;
    }

    return ullUSN;
}

BOOL
AzpADNeedUpdateStoreUSN (
    IN PAZP_AD_CONTEXT    pContext,
    IN AZPE_OBJECT_HANDLE hObject,
    OUT BOOL             *pbReadBackUSN
    )
/*++
Description:

    Determine if the Authorization Store object needs to be updated
    when the given object is to be updated. We will update the authorization
    store object's ObjectVersion attribute when any changes to the store's
    objects happen (except for batch updates) so that we can very quickly
    determine if the store has been modified by testing its uSNChanged attribute.

Arguments:

    pContext    - The persist context

    hObject     - The handle to the object

    pbReadBackUSN  - If the uSNChanged attribute needs to be read back or not. In batch
                     update mode, we don't even want to read back. If other process has
                     updated the store, we also won't read back the uSNChanged so that
                     we still know that our cache is not in sync with the store.

Return Value:

    True if and only if the store's uSNChanged attribute needs to be updated.

--*/
{
    AZASSERT(pContext != NULL);
    AZASSERT(hObject != NULL);
    AZASSERT(pbReadBackUSN != NULL);
    *pbReadBackUSN = FALSE;

    //
    // if we are doing batch mode, we don't update uSNChanged attributes no matter what
    //

    if (AdAzrolesInfo->AzpeAzStoreIsBatchUpdateMode(hObject))
    {
        return FALSE;
    }

    ULONG ulObjectType = AdAzrolesInfo->AzpeObjectType(hObject);

    //
    // When the object is the AuthorizationStore itself, then any
    // change to it will cause the uSNChanged attribute to get updated
    // So, no need to update by us.
    //

    BOOL bNeedUpdateUSN = (ulObjectType != OBJECT_TYPE_AZAUTHSTORE);

    //
    // Now, let's see if someone else has updated our store or not. If yes,
    // then we don't need to update and we don't need to read back either.
    //

    BOOL bHasUpdate;
    DWORD dwStatus = AzpADStoreHasUpdate(FALSE, pContext, &bHasUpdate);

    if (ERROR_FILE_NOT_FOUND == dwStatus)
    {
        //
        // The store object doesn't exist. The USN needs to be read back
        //

        *pbReadBackUSN = TRUE;
        return FALSE;
    }
    else if (NO_ERROR != dwStatus || bHasUpdate)
    {
        //
        // If we encounter problems, then we won't try to do more reading.
        // If someone else has modified it, then we won't read back either
        //

        return FALSE;
    }
    else
    {
        //
        // As long as we are the one to update the store,
        // including we are updating the az store itself,
        // we need to read back the USN.
        //

        *pbReadBackUSN = TRUE;
        return bNeedUpdateUSN;
    }
}

DWORD
AzpADUpdateStoreObjectForUSN (
    IN     BOOL             bReadBackUSN,
    IN AZPE_OBJECT_HANDLE   hObject,
    IN OUT PAZP_AD_CONTEXT  pContext
    )
{
    AZASSERT(pContext != NULL);
    LPWSTR pwszDN = NULL;

    LDAPMod **ppAttributeList = NULL;

    //
    // We need the store object's DN
    //

    AZPE_OBJECT_HANDLE hAzStore = AdAzrolesInfo->AzpeGetAuthorizationStore(hObject);
    DWORD WinStatus = AzpADBuildDN(pContext,
                                   hAzStore,
                                   &pwszDN,
                                   NULL,
                                   FALSE,
                                   NULL
                                   );

    if ( NO_ERROR == WinStatus )
    {

        //
        // we only have at most two attribute to modify
        //

        if (pContext->HasObjectVersion)
        {
            //
            // if we already have the objectVersion attribute, then we need
            // to delete it and write it back to bump up uSNChanged attribute
            //

            WinStatus = AzpADAllocateAttrHeap(3, &ppAttributeList);
        }
        else
        {
            WinStatus = AzpADAllocateAttrHeap(2, &ppAttributeList);
        }

        if (NO_ERROR != WinStatus)
        {
            goto Cleanup;
        }

        if (pContext->HasObjectVersion)
        {
            //
            // delete the old one
            //

            WinStatus = AzpADAllocateAttrHeapModVals(&ppAttributeList[0], 2);
            if ( ppAttributeList[0] == NULL )
            {
                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            ppAttributeList[0]->mod_type = L"objectVersion";
            ppAttributeList[0]->mod_op = LDAP_MOD_DELETE;

            //
            // Add the value back
            //

            WinStatus = AzpADAllocateAttrHeapModVals(&ppAttributeList[1], 2);
            if ( ppAttributeList[1] == NULL )
            {
                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            ppAttributeList[1]->mod_type = L"objectVersion";
            ppAttributeList[1]->mod_op = LDAP_MOD_ADD;
            ppAttributeList[1]->mod_values[0] =
                        (PWCHAR) AzpAllocateHeap(2 * sizeof( WCHAR ), "MODVALi" );

            if ( ppAttributeList[1]->mod_values[0] == NULL )
            {
                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            wcscpy( ppAttributeList[1]->mod_values[0], L"1" );
        }
        else
        {
            WinStatus = AzpADAllocateAttrHeapModVals(&ppAttributeList[0], 2);

            if ( ppAttributeList[0] == NULL )
            {
                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            ppAttributeList[0]->mod_type = L"objectVersion";
            ppAttributeList[0]->mod_op = LDAP_MOD_ADD;
            ppAttributeList[0]->mod_values[0] =
                        (PWCHAR) AzpAllocateHeap(2 * sizeof( WCHAR ), "MODVALi" );

            if ( ppAttributeList[0]->mod_values[0] == NULL )
            {
                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            wcscpy( ppAttributeList[0]->mod_values[0], L"1" );
        }

        ULONG ldapStatus = ldap_modify_ext_s(
                                            pContext->ld,
                                            pwszDN,
                                            ppAttributeList,
                                            pContext->pLdapControls,
                                            NULL
                                            );
        if ( LDAP_SUCCESS != ldapStatus )
        {

            WinStatus = LdapMapErrorToWin32( ldapStatus );
            goto Cleanup;
        }

        //
        // we know for sure that our store has objectVersion attribute now
        //

        pContext->HasObjectVersion = 1;

    }

    if (NO_ERROR == WinStatus && bReadBackUSN)
    {
        //
        // Now, we need to read the USN back if so instructed.
        //

        BOOL bIgnored;

        WinStatus = AzpADStoreHasUpdate(TRUE, pContext, &bIgnored);
    }

Cleanup:

    if (ppAttributeList != NULL)
    {
        AzpADFreeAttrHeap(&ppAttributeList, TRUE);
    }

    if (pwszDN != NULL)
    {
        AzpFreeHeap(pwszDN);
    }

    return WinStatus;
}

DWORD
AzpADBuildNameSearchFilter(
    IN AZPE_OBJECT_HANDLE pObject,
    IN ULONG lPersistFlags,
    OUT PWSTR * ppSearchFilter
    )
/*++

Routine Description:

    This routine build a name based search filter

Arguments:

    pObject         - Object whose type and name will be used to build the search filter.

    lPersistFlags   - lPersistFlags from the persist engine describing the operation
    
    ppSerachFilter  - receives the search filter.

Return Values:

    NO_ERROR - If the filter is successfully build
    Other status codes
    
Note:
    Currently, this routine only support application and scope objects.
    When we have need to support other objects, we can easily expand this routine.
    
    Caller is responsible for freeing the by calling AdAzrolesInfo->AzpeFreeMemory
    
--*/
{
    if (pObject == NULL || ppSearchFilter == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    *ppSearchFilter = NULL;
    DWORD dwStatus = NO_ERROR;

    //
    // We only support building name search filter to application and
    // scope objects at this point, which can be easily extended when needed.
    //
    
    ULONG lObjectType = AdAzrolesInfo->AzpeObjectType(pObject);
    if (OBJECT_TYPE_APPLICATION != lObjectType && OBJECT_TYPE_SCOPE != lObjectType )
    {
        return ERROR_NOT_SUPPORTED;
    }
    else 
    {
        LPCWSTR pwszFmt;
        if ( OBJECT_TYPE_APPLICATION == lObjectType )
        {
            pwszFmt = L"(&(objectClass=msds-azapplication)(msds-azapplicationname=%s))";
        }
        else
        {
            pwszFmt = L"(&(objectClass=msds-azscope)(msds-azscopename=%s))";
        }

        LPWSTR pwszName = NULL;
        dwStatus = AdAzrolesInfo->AzpeGetProperty(pObject, lPersistFlags, AZ_PROP_NAME, (PVOID*)&pwszName);
        
        if (NO_ERROR == dwStatus)
        {
            AZASSERT(pwszName != NULL);
            
            //
            // Adding 1 is really not necessary because of the '%' in the pwszFmt. But
            // to make it less suspicious to readers, let us do it anyway.
            //
            
            size_t Len = wcslen(pwszFmt) + wcslen( pwszName ) + 1;
            
            *ppSearchFilter = (PWSTR)AdAzrolesInfo->AzpeAllocateMemory(Len * sizeof(WCHAR));
            if (*ppSearchFilter == NULL)
            {
                dwStatus = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                wnsprintfW(*ppSearchFilter, (int)Len, pwszFmt, pwszName);
            }
        }
        
        if ( NULL != pwszName )
        {
            AdAzrolesInfo->AzpeFreeMemory(pwszName);
        }
    }
    
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\authz\test\wmiaudit\wmi-aztest.cpp ===
DWORD TestAzAudit(
    )

{
    DWORD dwError = NO_ERROR;
    PCWSTR szMsg = L"<unknown>";
    AUTHZ_RM_AUDIT_INFO RmAuditInfo;
    AUTHZ_CLIENT_AUDIT_INFO ClAuditInfo;
    AUTHZ_AUDIT_INFO AuditInfo;
    AUTHZI_CLIENT_CONTEXT ClContext;

    // -----------------------------------------------------------------
    // test AzpInitRmAuditInfo
    // -----------------------------------------------------------------

    ZeroMemory((PVOID) &RmAuditInfo, sizeof(RmAuditInfo));
    RmAuditInfo.szResourceManagerName = L"TestRm";

    HANDLE hToken;
    BYTE TokenUserInfoBuf[256];
    TOKEN_USER* pTokenUserInfo = (TOKEN_USER*) TokenUserInfoBuf;
    DWORD dwSize;

    if ( OpenProcessToken( GetCurrentProcess(),
                           TOKEN_READ,
                           &hToken ))
    {
        if ( GetTokenInformation( hToken, TokenUser,
                                  pTokenUserInfo, 250,
                                  &dwSize ))
        {
            dwSize = RtlLengthSid( pTokenUserInfo->User.Sid );
            RmAuditInfo.psidRmProcess = AuthzpAlloc( dwSize );
            if ( RmAuditInfo.psidRmProcess )
            {
                CopyMemory( RmAuditInfo.psidRmProcess,
                            pTokenUserInfo->User.Sid,
                            dwSize );
                RmAuditInfo.dwRmProcessSidSize = dwSize;
            }
            else
            {
                szMsg = L"AuthzpAlloc";
                goto Error;
            }
        }
        else
        {
            szMsg = L"GetTokenInformation";
            goto GetError;
        }
    }
    else
    {
        szMsg = L"OpenProcessToken";
        goto GetError;
    }

    RmAuditInfo.hEventSource          = INVALID_HANDLE_VALUE;
    RmAuditInfo.hAuditEvent           = INVALID_HANDLE_VALUE;
    RmAuditInfo.hAuditEventPropSubset = INVALID_HANDLE_VALUE;
    
    dwError = AzpInitRmAuditInfo( &RmAuditInfo );

    if ( dwError != NO_ERROR )
    {
        szMsg = L"AzpInitRmAuditInfo";
        goto Error;
    }

    // -----------------------------------------------------------------
    // test AzpInitClientAuditInfo
    // -----------------------------------------------------------------

    ZeroMemory((PVOID) &ClAuditInfo, sizeof(ClAuditInfo));

    ClAuditInfo.psidClient = RmAuditInfo.psidRmProcess;
    ClAuditInfo.dwClientSidSize = RmAuditInfo.dwRmProcessSidSize;
    
    ClAuditInfo.hAuditEvent           = INVALID_HANDLE_VALUE;
    ClAuditInfo.hAuditEventPropSubset = INVALID_HANDLE_VALUE;
    
    
    dwError = AzpInitClientAuditInfo( &RmAuditInfo, &ClAuditInfo );

    if ( dwError != NO_ERROR )
    {
        szMsg = L"AzpInitClientAuditInfo";
        goto Error;
    }

    // -----------------------------------------------------------------
    // test AzpGenerateAuditEvent
    // -----------------------------------------------------------------

    ZeroMemory((PVOID) &AuditInfo, sizeof(AuditInfo));

    AuditInfo.hAuditEvent           = INVALID_HANDLE_VALUE;
    AuditInfo.hAuditEventPropSubset = INVALID_HANDLE_VALUE;

    AuditInfo.szOperationType = L"kkOperation";
    AuditInfo.szObjectType    = L"kkObjectType";
    AuditInfo.szObjectName    = L"kkObjectName";

    ZeroMemory((PVOID) &ClContext, sizeof(ClContext));
    
    dwError = AzpGenerateAuditEvent( &RmAuditInfo, &ClAuditInfo, &ClContext,
                                     &AuditInfo, 0x1122 );

    if ( dwError != NO_ERROR )
    {
        szMsg = L"AzpGenerateAuditEvent";
        goto Error;
    }

Finish:
    return dwError;

GetError:
    dwError = GetLastError();

Error:
    (void) wprintf( L"%s: 0x%x\n", szMsg, dwError );
    goto Finish;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\azdisp.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    azdisp.h

Abstract:

    Declaration of CAz* dispatch interfaces

Author:

    Xiaoxi Tan (xtan) 11-May-2001

--*/

#ifndef __AZDISP_H_
#define __AZDISP_H_

#include "resource.h"
#include "azrolesp.h"

#pragma warning ( push )
#pragma warning ( disable : 4100 ) // unreferenced formal parameter
#include "copyitem.h"
#pragma warning ( pop )

// macro defines

// defines

#define AZ_HR_FROM_WIN32(e)  ( ( (e) == ERROR_OUTOFMEMORY || (e) == ERROR_NOT_ENOUGH_MEMORY || (e) == NTE_NO_MEMORY ) ? E_OUTOFMEMORY : HRESULT_FROM_WIN32(e) )

#define AZ_HRESULT(e)  (((e) >= 0x80000000) ? (e) : AZ_HR_FROM_WIN32((e)))
#define AZ_HRESULT_LASTERROR(phr) \
{ \
    DWORD  _dwLastError; \
    _dwLastError = GetLastError(); \
    *(phr) = AZ_HRESULT(_dwLastError); \
}

#if DBG
#define AZASSERT(exp)  ASSERT((exp))
#else
#define AZASSERT(exp)
#endif //DBG

//
//chk has debug print for error jumps
//Note: the component should define AZD_COMPONENT to be one of
//      AZD_* before calling any of the following dbg macros
//
#if DBG
#define _JumpError(hr, label, pszMessage) \
{ \
    AzPrint((AZD_COMPONENT, "%s error occured: 0x%lx\n", (pszMessage), (hr))); \
    goto label; \
}

#define _PrintError(hr, pszMessage) \
{\
    AzPrint((AZD_COMPONENT, "%s error ignored: 0x%lx\n", (pszMessage), (hr))); \
}

#define _PrintIfError(hr, pszMessage) \
{\
    if (S_OK != hr) \
    { \
        _PrintError(hr, pszMessage); \
    } \
}

#else

#define _JumpError(hr, label, pszMessage) goto label;
#define _PrintError(hr, pszMessage)
#define _PrintIfError(hr, pszMessage)

#endif //DBG

#define _JumpErrorQuiet(hr, label, pszMessage) goto label;

//check hr err, goto error
#define _JumpIfError(hr, label, pszMessage) \
{ \
    if (S_OK != hr) \
    { \
        _JumpError((hr), label, (pszMessage)) \
    } \
}

//check win err, goto error and return hr
#define _JumpIfWinError(dwErr, phr, label, pszMessage) \
{ \
    if (ERROR_SUCCESS != dwErr) \
    { \
        *(phr) = AZ_HRESULT(dwErr); \
        _JumpError((*(phr)), label, (pszMessage)) \
    } \
}

//note hr is hidden from macro
#define _JumpIfOutOfMemory(phr, label, pMem, msg) \
{ \
    if (NULL == (pMem)) \
    { \
        *(phr) = E_OUTOFMEMORY; \
        _JumpError((*(phr)), label, "Out of Memory: " msg); \
    } \
}

// defines

typedef DWORD (*PFUNCAzGetProperty)(
    IN AZ_HANDLE hHandle,
    IN ULONG  PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue);

typedef DWORD (*PFUNCAzAddPropertyItem)(
    IN AZ_HANDLE hHandle,
    IN ULONG  PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue);

//return type IDs
enum ENUM_AZ_DATATYPE
{
    ENUM_AZ_BSTR = 0,
    ENUM_AZ_LONG,
    ENUM_AZ_BSTR_ARRAY,
    ENUM_AZ_SID_ARRAY,
    ENUM_AZ_BOOL,
    ENUM_AZ_GUID_ARRAY,
    ENUM_AZ_GROUP_TYPE,
};

//
// some complicated atl collection class defines
//
// each collection class needs T(Obj)Collection define by using
// T_AZ_MAP, T_AZ_ENUM, and T_AZ_COLL macros. Here is an example for
// IAzApplication collection class
//typedef std::map<CComBSTR, CComPtr<IAzApplication> > TApplicationMap;
//typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyMapItem<IAzApplication>, TApplicationMap> TApplicationEnum;
//typedef ICollectionOnSTLImpl<IAzApplications, TApplicationMap, VARIANT, _CopyMapItem<IAzApplication>, TApplicationEnum> TApplicationsCollection;


#define T_AZ_MAP(_obj) std::map<CComBSTR, CComPtr<_obj> >
#define T_AZ_ENUM(_obj, _map) CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _CopyMapItem<_obj>, _map>
#define T_AZ_COLL(_obj, _objs, _map, _enum) ICollectionOnSTLImpl<_objs, _map, VARIANT, _CopyMapItem<_obj>, _enum>

typedef T_AZ_MAP(IAzApplication)                      TApplicationMap;
typedef T_AZ_ENUM(IAzApplication, TApplicationMap)    TApplicationEnum;
typedef T_AZ_COLL(IAzApplication, IAzApplications,
                  TApplicationMap, TApplicationEnum)  TApplicationsCollection;


typedef T_AZ_MAP(IAzApplicationGroup)             TApplicationGroupMap;
typedef T_AZ_ENUM(IAzApplicationGroup,
                  TApplicationGroupMap)           TApplicationGroupEnum;
typedef T_AZ_COLL(IAzApplicationGroup,
                  IAzApplicationGroups,
                  TApplicationGroupMap,
                  TApplicationGroupEnum)          TApplicationGroupsCollection;


typedef T_AZ_MAP(IAzOperation)                        TOperationMap;
typedef T_AZ_ENUM(IAzOperation, TOperationMap)        TOperationEnum;
typedef T_AZ_COLL(IAzOperation, IAzOperations,
                  TOperationMap, TOperationEnum)      TOperationsCollection;


typedef T_AZ_MAP(IAzTask)                             TTaskMap;
typedef T_AZ_ENUM(IAzTask, TTaskMap)                  TTaskEnum;
typedef T_AZ_COLL(IAzTask, IAzTasks,
                  TTaskMap, TTaskEnum)                TTasksCollection;


typedef T_AZ_MAP(IAzScope)                            TScopeMap;
typedef T_AZ_ENUM(IAzScope, TScopeMap)                TScopeEnum;
typedef T_AZ_COLL(IAzScope, IAzScopes,
                  TScopeMap, TScopeEnum)              TScopesCollection;


typedef T_AZ_MAP(IAzRole)                             TRoleMap;
typedef T_AZ_ENUM(IAzRole, TRoleMap)                  TRoleEnum;
typedef T_AZ_COLL(IAzRole, IAzRoles,
                  TRoleMap, TRoleEnum)                TRolesCollection;

///////////////////////
//CAzAuthorizationStore
class ATL_NO_VTABLE CAzAuthorizationStore :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CAzAuthorizationStore, &CLSID_AzAuthorizationStore>,
    public IDispatchImpl<IAzAuthorizationStore, &IID_IAzAuthorizationStore, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZSTORE)

BEGIN_COM_MAP(CAzAuthorizationStore)
    COM_INTERFACE_ENTRY(IAzAuthorizationStore)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzAuthorizationStore
public:

        CAzAuthorizationStore();
        ~CAzAuthorizationStore();

        virtual HRESULT STDMETHODCALLTYPE put_Description(
            IN  BSTR  bstrDescription);

        virtual HRESULT STDMETHODCALLTYPE get_Description(
            OUT  BSTR __RPC_FAR *pbstrDescription);

        virtual HRESULT STDMETHODCALLTYPE put_ApplicationData(
            IN  BSTR  bstrApplicationData);

        virtual HRESULT STDMETHODCALLTYPE get_ApplicationData(
            OUT  BSTR __RPC_FAR *pbstrApplicationData);

        virtual HRESULT STDMETHODCALLTYPE
         get_DomainTimeout(
            OUT LONG         *plProp
            );

        virtual HRESULT STDMETHODCALLTYPE
         put_DomainTimeout(
            IN LONG         lProp
            );

        virtual HRESULT STDMETHODCALLTYPE
         get_ScriptEngineTimeout(
            OUT LONG         *plProp
            );

        virtual HRESULT STDMETHODCALLTYPE
         put_ScriptEngineTimeout(
            IN LONG         lProp
            );

        virtual HRESULT STDMETHODCALLTYPE
         get_MaxScriptEngines(
            OUT LONG         *plProp
            );

        virtual HRESULT STDMETHODCALLTYPE
         put_MaxScriptEngines(
            IN LONG         lProp
            );

        virtual HRESULT STDMETHODCALLTYPE
         get_GenerateAudits(
            OUT BOOL         *pbProp
            );

        virtual HRESULT STDMETHODCALLTYPE
         put_GenerateAudits(
            IN BOOL         bProp
            );

        virtual HRESULT STDMETHODCALLTYPE get_Writable(
            OUT BOOL *pfProp);

        virtual HRESULT STDMETHODCALLTYPE GetProperty(
            IN  LONG  lPropId,
            IN  VARIANT varReserved,
            OUT VARIANT *pvarProp);

        virtual HRESULT STDMETHODCALLTYPE SetProperty(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE AddPropertyItem(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE DeletePropertyItem(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE get_PolicyAdministrators(
            OUT VARIANT *pvarAdmins);

        virtual HRESULT STDMETHODCALLTYPE get_PolicyReaders(
            OUT VARIANT *pvarReaders);

        virtual HRESULT STDMETHODCALLTYPE AddPolicyAdministrator(
            IN  BSTR    bstrReader,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE DeletePolicyAdministrator(
            IN  BSTR    bstrReader,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE AddPolicyReader(
            IN  BSTR    bstrReader,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE DeletePolicyReader(
            IN  BSTR    bstrReader,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE Initialize(
            IN   LONG  lFlags,
            IN   BSTR bstrPolicyURL,
            IN   VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE UpdateCache(
            IN   VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE Delete(
            IN   VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE get_Applications(
            OUT  IAzApplications __RPC_FAR **ppApplications);

        virtual HRESULT STDMETHODCALLTYPE OpenApplication(
            IN   BSTR bstrApplicationName,
            IN   VARIANT varReserved,
            OUT  IAzApplication __RPC_FAR **ppApplication);

        virtual HRESULT STDMETHODCALLTYPE CreateApplication(
            IN  BSTR bstrApplicationName,
            IN  VARIANT varReserved,
            OUT IAzApplication __RPC_FAR **ppApplication);

        virtual HRESULT STDMETHODCALLTYPE DeleteApplication(
            IN  BSTR bstrApplicationName,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE get_ApplicationGroups(
            OUT IAzApplicationGroups __RPC_FAR **ppApplicationGroups);

        virtual HRESULT STDMETHODCALLTYPE CreateApplicationGroup(
            IN  BSTR bstrGroupName,
            IN  VARIANT varReserved,
            OUT IAzApplicationGroup __RPC_FAR **ppApplicationGroup);

        virtual HRESULT STDMETHODCALLTYPE OpenApplicationGroup(
            IN  BSTR bstrGroupName,
            IN  VARIANT varReserved,
            OUT IAzApplicationGroup __RPC_FAR **ppApplicationGroup);

        virtual HRESULT STDMETHODCALLTYPE DeleteApplicationGroup(
            IN  BSTR bstrGroupName,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE Submit(
            IN  LONG lFlags,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE get_DelegatedPolicyUsers(
            OUT VARIANT *pvarProp);

        virtual HRESULT STDMETHODCALLTYPE AddDelegatedPolicyUser(
            IN  BSTR    bstrDelegatedPolicyUser,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE DeleteDelegatedPolicyUser(
            IN  BSTR    bstrDelegatedPolicyUser,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE get_TargetMachine(
            OUT  BSTR __RPC_FAR *pbstrTargetMachine);

        virtual HRESULT STDMETHODCALLTYPE put_ApplyStoreSacl(
            IN  BOOL    bApplyStoreSacl);

        virtual HRESULT STDMETHODCALLTYPE get_ApplyStoreSacl(
            OUT BOOL * pbApplyStoreSacl);

        virtual HRESULT STDMETHODCALLTYPE get_PolicyAdministratorsName(
            OUT VARIANT * pvarAdminsName
            );

        virtual HRESULT STDMETHODCALLTYPE get_PolicyReadersName(
            OUT VARIANT * pvarReadersName
            );

        virtual HRESULT STDMETHODCALLTYPE  AddPolicyAdministratorName(
            IN BSTR        bstrAdminName,
            IN VARIANT     varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE DeletePolicyAdministratorName(
            IN BSTR        bstrAdminName,
            IN VARIANT     varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE AddPolicyReaderName(
            IN BSTR        bstrReaderName,
            IN VARIANT     varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE DeletePolicyReaderName(
            IN BSTR        bstrReaderName,
            IN VARIANT     varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE get_DelegatedPolicyUsersName(
            IN VARIANT *  pvarDelegatedPolicyUsersName
            );

        virtual HRESULT STDMETHODCALLTYPE AddDelegatedPolicyUserName(
            IN BSTR       bstrDelegatedPolicyUserName,
            IN VARIANT    varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE DeleteDelegatedPolicyUserName(
            IN BSTR       bstrDelegatedPolicyUserName,
            IN VARIANT    varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE CloseApplication(
           IN BSTR       bstrApplicationName,
           IN LONG       lFlags
           );

private:

        CRITICAL_SECTION            m_cs;
        AZ_HANDLE                   m_hAuthorizationStore;
};


///////////////////////
//CAzApplication
class ATL_NO_VTABLE CAzApplication :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IAzApplication, &IID_IAzApplication, &LIBID_AZROLESLib>
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CAzApplication)
    COM_INTERFACE_ENTRY(IAzApplication)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzApplication
public:

        CAzApplication();
        ~CAzApplication();

        virtual HRESULT STDMETHODCALLTYPE put_Name(
            IN  BSTR  bstrName);

        virtual HRESULT STDMETHODCALLTYPE get_Name(
            OUT  BSTR __RPC_FAR *pbstrName);

        virtual HRESULT STDMETHODCALLTYPE put_Description(
            IN  BSTR  bstrDescription);

        virtual HRESULT STDMETHODCALLTYPE get_Description(
            OUT  BSTR __RPC_FAR *pbstrDescription);

        virtual HRESULT STDMETHODCALLTYPE put_ApplicationData(
            IN  BSTR  bstrApplicationData);

        virtual HRESULT STDMETHODCALLTYPE get_ApplicationData(
            OUT  BSTR __RPC_FAR *pbstrApplicationData);

        virtual HRESULT STDMETHODCALLTYPE
         get_AuthzInterfaceClsid(
            OUT BSTR *pbstrProp);

        virtual HRESULT STDMETHODCALLTYPE
         put_AuthzInterfaceClsid(
            IN BSTR bstrProp);

        virtual HRESULT STDMETHODCALLTYPE
         get_Version(
            OUT BSTR *pbstrProp);

        virtual HRESULT STDMETHODCALLTYPE
         put_Version(
            IN BSTR bstrProp);

        virtual HRESULT STDMETHODCALLTYPE
         get_GenerateAudits(
            OUT BOOL *pbProp);

        virtual HRESULT STDMETHODCALLTYPE
         put_GenerateAudits(
            IN BOOL bProp);

        virtual HRESULT STDMETHODCALLTYPE
         get_ApplyStoreSacl(
            OUT BOOL *pbProp);

        virtual HRESULT STDMETHODCALLTYPE
         put_ApplyStoreSacl(
            IN BOOL bProp);

        virtual HRESULT STDMETHODCALLTYPE get_Writable(
            OUT BOOL *pfProp);

        virtual HRESULT STDMETHODCALLTYPE GetProperty(
            IN  LONG  lPropId,
            IN  VARIANT varReserved,
            OUT VARIANT *pvarProp);

        virtual HRESULT STDMETHODCALLTYPE SetProperty(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE get_PolicyAdministrators(
            OUT VARIANT *pvarAdmins);

        virtual HRESULT STDMETHODCALLTYPE get_PolicyReaders(
            OUT VARIANT *pvarReaders);

        virtual HRESULT STDMETHODCALLTYPE AddPolicyAdministrator(
            IN  BSTR    bstrReader,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE DeletePolicyAdministrator(
            IN  BSTR    bstrReader,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE AddPolicyReader(
            IN  BSTR    bstrReader,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE DeletePolicyReader(
            IN  BSTR    bstrReader,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE get_Scopes(
            OUT IAzScopes **ppScopes);

        virtual HRESULT STDMETHODCALLTYPE OpenScope(
            IN  BSTR bstrScopeName,
            IN  VARIANT varReserved,
            OUT IAzScope **ppScope);

        virtual HRESULT STDMETHODCALLTYPE CreateScope(
            IN  BSTR bstrScopeName,
            IN  VARIANT varReserved,
            OUT IAzScope **ppScope);

        virtual HRESULT STDMETHODCALLTYPE DeleteScope(
            IN  BSTR bstrScopeName,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE get_Operations(
            OUT IAzOperations **ppOperations);

        virtual HRESULT STDMETHODCALLTYPE OpenOperation(
            IN  BSTR bstrOperationName,
            IN  VARIANT varReserved,
            OUT IAzOperation **ppOperation);

        virtual HRESULT STDMETHODCALLTYPE CreateOperation(
            IN  BSTR bstrOperationName,
            IN  VARIANT varReserved,
            OUT IAzOperation **ppOperation);

        virtual HRESULT STDMETHODCALLTYPE DeleteOperation(
            IN  BSTR bstrOperationName,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE get_Tasks(
            OUT IAzTasks **ppTasks);

        virtual HRESULT STDMETHODCALLTYPE OpenTask(
            IN  BSTR bstrTaskName,
            IN  VARIANT varReserved,
            OUT IAzTask **ppTask);

        virtual HRESULT STDMETHODCALLTYPE CreateTask(
            IN  BSTR bstrTaskName,
            IN  VARIANT varReserved,
            OUT IAzTask **ppTask);

        virtual HRESULT STDMETHODCALLTYPE DeleteTask(
            IN  BSTR bstrTaskName,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE get_ApplicationGroups(
            OUT IAzApplicationGroups **ppGroups);

        virtual HRESULT STDMETHODCALLTYPE OpenApplicationGroup(
            IN  BSTR bstrGroupName,
            IN  VARIANT varReserved,
            OUT IAzApplicationGroup **ppGroup);

        virtual HRESULT STDMETHODCALLTYPE CreateApplicationGroup(
            IN  BSTR bstrGroupName,
            IN  VARIANT varReserved,
            OUT IAzApplicationGroup **ppGroup);

        virtual HRESULT STDMETHODCALLTYPE DeleteApplicationGroup(
            IN  BSTR bstrGroupName,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE get_Roles(
            OUT IAzRoles **ppRoles);

        virtual HRESULT STDMETHODCALLTYPE OpenRole(
            IN  BSTR bstrRoleName,
            IN  VARIANT varReserved,
            OUT IAzRole **ppRole);

        virtual HRESULT STDMETHODCALLTYPE CreateRole(
            IN  BSTR bstrRoleName,
            IN  VARIANT varReserved,
            OUT IAzRole **ppRole);

        virtual HRESULT STDMETHODCALLTYPE DeleteRole(
            IN  BSTR bstrRoleName,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE InitializeClientContextFromToken(
            IN  ULONGLONG ullTokenHandle,
            IN  VARIANT varReserved,
            OUT IAzClientContext **ppClientContext);

        virtual HRESULT STDMETHODCALLTYPE AddPropertyItem(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE DeletePropertyItem(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE Submit(
            IN  LONG lFlags,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE InitializeClientContextFromName(
            IN  BSTR  ClientName,
            IN  BSTR  DomainName,
            IN  VARIANT varReserved,
            OUT IAzClientContext **ppClientContext);

        virtual HRESULT STDMETHODCALLTYPE get_DelegatedPolicyUsers(
            OUT VARIANT *pvarProp);

        virtual HRESULT STDMETHODCALLTYPE AddDelegatedPolicyUser(
            IN  BSTR    bstrDelegatedPolicyUser,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE DeleteDelegatedPolicyUser(
            IN  BSTR    bstrDelegatedPolicyUser,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE InitializeClientContextFromStringSid(
            IN  BSTR  SidString,
            IN  LONG  lOptions,
            IN  VARIANT varReserved,
            OUT IAzClientContext **ppClientContext);

        virtual HRESULT STDMETHODCALLTYPE get_PolicyAdministratorsName(
            OUT VARIANT * pvarAdminsName
            );

        virtual HRESULT STDMETHODCALLTYPE get_PolicyReadersName(
            OUT VARIANT * pvarReadersName
            );

        virtual HRESULT STDMETHODCALLTYPE AddPolicyAdministratorName(
            IN BSTR       bstrAdmin,
            IN VARIANT    varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE DeletePolicyAdministratorName(
            IN BSTR       bstrAdmin,
            IN VARIANT    varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE AddPolicyReaderName(
            IN BSTR       bstrReader,
            IN VARIANT    varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE DeletePolicyReaderName(
            IN BSTR       bstrReader,
            IN VARIANT    varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE get_DelegatedPolicyUsersName(
            OUT VARIANT * pvarDelegatedPolicyUsers
            );

        virtual HRESULT STDMETHODCALLTYPE AddDelegatedPolicyUserName(
            IN BSTR        bstrDelegatedPolicyUser,
            IN VARIANT     varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE DeleteDelegatedPolicyUserName(
            IN BSTR        bstrDelegatedPolicyUser,
            IN VARIANT     varReserved
            );

        //internal methods
        HRESULT _Init(
            IN  AZ_HANDLE    hHandle);

private:

        CRITICAL_SECTION        m_cs;

        AZ_HANDLE               m_hApplication;
        DWORD                   m_dwSN;

};



///////////////////////
//CAzApplications
class ATL_NO_VTABLE CAzApplications :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<TApplicationsCollection, &IID_IAzApplications, &LIBID_AZROLESLib>
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CAzApplications)
    COM_INTERFACE_ENTRY(IAzApplications)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()


//IAzApplications
public:

        //internal methods
        HRESULT _Init(
            IN  VARIANT *pvarReserved,
            IN  AZ_HANDLE   hHandle);
};


///////////////////////
//CAzOperation
class ATL_NO_VTABLE CAzOperation :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IAzOperation, &IID_IAzOperation, &LIBID_AZROLESLib>
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CAzOperation)
    COM_INTERFACE_ENTRY(IAzOperation)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzOperation
public:

        CAzOperation();
        ~CAzOperation();

        virtual HRESULT STDMETHODCALLTYPE put_Name(
            IN  BSTR  bstrName);

        virtual HRESULT STDMETHODCALLTYPE get_Name(
            OUT  BSTR __RPC_FAR *pbstrName);

        virtual HRESULT STDMETHODCALLTYPE put_Description(
            OUT  BSTR  bstrDescription);

        virtual HRESULT STDMETHODCALLTYPE get_Description(
            IN  BSTR __RPC_FAR *pbstrDescription);

        virtual HRESULT STDMETHODCALLTYPE put_ApplicationData(
            OUT  BSTR  bstrApplicationData);

        virtual HRESULT STDMETHODCALLTYPE get_ApplicationData(
            IN  BSTR __RPC_FAR *pbstrApplicationData);

        virtual HRESULT STDMETHODCALLTYPE get_OperationID(
            OUT LONG  *plProp);

        virtual HRESULT STDMETHODCALLTYPE put_OperationID(
            IN LONG lProp);

        virtual HRESULT STDMETHODCALLTYPE get_Writable(
            OUT BOOL *pfProp);

        virtual HRESULT STDMETHODCALLTYPE GetProperty(
            IN  LONG  lPropId,
            IN  VARIANT varReserved,
            OUT VARIANT *pvarProp);

        virtual HRESULT STDMETHODCALLTYPE SetProperty(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE Submit(
            IN  LONG lFlags,
            IN  VARIANT varReserved);

        //internal methods
        HRESULT _Init(
            IN  AZ_HANDLE   hOwnerApp,
            IN  AZ_HANDLE    hHandle);
private:

        CRITICAL_SECTION        m_cs;

        AZ_HANDLE               m_hOperation;

        AZ_HANDLE               m_hOwnerApp;
        DWORD                   m_dwOwnerAppSN;

};


///////////////////////
//CAzOperations
class ATL_NO_VTABLE CAzOperations :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<TOperationsCollection, &IID_IAzOperations, &LIBID_AZROLESLib>
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CAzOperations)
    COM_INTERFACE_ENTRY(IAzOperations)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzOperations
public:

        //internal methods
        HRESULT _Init(
            IN  AZ_HANDLE   hOwnerApp,
            IN  VARIANT *pvarReserved,
            IN  AZ_HANDLE   hHandle);
private:

    AZ_HANDLE   m_hOwnerApp;
    DWORD       m_dwOwnerAppSN;
};



///////////////////////
//CAzTask
class ATL_NO_VTABLE CAzTask :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IAzTask, &IID_IAzTask, &LIBID_AZROLESLib>
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CAzTask)
    COM_INTERFACE_ENTRY(IAzTask)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzTask
public:

        CAzTask();
        ~CAzTask();

        virtual HRESULT STDMETHODCALLTYPE put_Name(
            IN  BSTR  bstrName);

        virtual HRESULT STDMETHODCALLTYPE get_Name(
            IN  BSTR __RPC_FAR *pbstrName);

        virtual HRESULT STDMETHODCALLTYPE put_Description(
            IN  BSTR  bstrDescription);

        virtual HRESULT STDMETHODCALLTYPE get_Description(
            IN  BSTR __RPC_FAR *pbstrDescription);

        virtual HRESULT STDMETHODCALLTYPE put_ApplicationData(
            IN  BSTR  bstrApplicationData);

        virtual HRESULT STDMETHODCALLTYPE get_ApplicationData(
            IN  BSTR __RPC_FAR *pbstrApplicationData);

        virtual HRESULT STDMETHODCALLTYPE
        get_BizRule(
            OUT BSTR *pbstrProp);

        virtual HRESULT STDMETHODCALLTYPE
        put_BizRule(
            IN BSTR bstrProp);

        virtual HRESULT STDMETHODCALLTYPE
        get_BizRuleLanguage(
            OUT BSTR *pbstrProp);

        virtual HRESULT STDMETHODCALLTYPE
        put_BizRuleLanguage(
            IN BSTR bstrProp);

        virtual HRESULT STDMETHODCALLTYPE
        get_BizRuleImportedPath(
            OUT BSTR *pbstrProp);

        virtual HRESULT STDMETHODCALLTYPE
        put_BizRuleImportedPath(
            IN BSTR bstrProp);

        virtual HRESULT STDMETHODCALLTYPE
        get_IsRoleDefinition(
            OUT BOOL *pfProp);

        virtual HRESULT STDMETHODCALLTYPE
        put_IsRoleDefinition(
            IN BOOL fProp);

        virtual HRESULT STDMETHODCALLTYPE
        get_Operations(
            OUT VARIANT *pvarProp);

        virtual HRESULT STDMETHODCALLTYPE
        get_Tasks(
            OUT VARIANT *pvarProp);

    HRESULT STDMETHODCALLTYPE AddOperation(
        IN             BSTR        bstrOp,
        IN  VARIANT     varReserved
        );

    HRESULT STDMETHODCALLTYPE DeleteOperation(
        IN             BSTR        bstrOp,
        IN    VARIANT     varReserved
        );

    HRESULT STDMETHODCALLTYPE AddTask(
        IN              BSTR        bstrTask,
        IN    VARIANT     varReserved
        );

    HRESULT STDMETHODCALLTYPE DeleteTask(
        IN            BSTR        bstrTask,
        IN    VARIANT     varReserved
        );

        virtual HRESULT STDMETHODCALLTYPE get_Writable(
            OUT BOOL *pfProp);

        virtual HRESULT STDMETHODCALLTYPE GetProperty(
            IN  LONG  lPropId,
            IN  VARIANT varReserved,
            OUT VARIANT *pvarProp);

        virtual HRESULT STDMETHODCALLTYPE SetProperty(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE AddPropertyItem(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE DeletePropertyItem(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE Submit(
            IN  LONG lFlags,
            IN  VARIANT varReserved);

        //internal methods
        HRESULT _Init(
            IN  AZ_HANDLE   hOwnerApp,
            IN  AZ_HANDLE    hHandle);
private:

        CRITICAL_SECTION        m_cs;

        AZ_HANDLE               m_hTask;
        AZ_HANDLE               m_hOwnerApp;
        DWORD                   m_dwOwnerAppSN;

};


///////////////////////
//CAzTasks
class ATL_NO_VTABLE CAzTasks :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<TTasksCollection, &IID_IAzTasks, &LIBID_AZROLESLib>
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CAzTasks)
    COM_INTERFACE_ENTRY(IAzTasks)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzTasks
public:

        //internal methods
        HRESULT _Init(
            IN  AZ_HANDLE   hOwnerApp,
            IN  VARIANT *pvarReserved,
            IN  AZ_HANDLE   hHandle);
private:

    AZ_HANDLE   m_hOwnerApp;
    DWORD       m_dwOwnerAppSN;
};



///////////////////////
//CAzScope
class ATL_NO_VTABLE CAzScope :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IAzScope, &IID_IAzScope, &LIBID_AZROLESLib>
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CAzScope)
    COM_INTERFACE_ENTRY(IAzScope)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzScope
public:

        CAzScope();
        ~CAzScope();

        virtual HRESULT STDMETHODCALLTYPE put_Name(
            IN  BSTR  bstrName);

        virtual HRESULT STDMETHODCALLTYPE get_Name(
            IN  BSTR __RPC_FAR *pbstrName);

        virtual HRESULT STDMETHODCALLTYPE put_Description(
            IN  BSTR  bstrDescription);

        virtual HRESULT STDMETHODCALLTYPE get_Description(
            IN  BSTR __RPC_FAR *pbstrDescription);

        virtual HRESULT STDMETHODCALLTYPE put_ApplicationData(
            IN  BSTR  bstrApplicationData);

        virtual HRESULT STDMETHODCALLTYPE get_ApplicationData(
            IN  BSTR __RPC_FAR *pbstrApplicationData);

        virtual HRESULT STDMETHODCALLTYPE get_Writable(
            OUT BOOL *pfProp);

        virtual HRESULT STDMETHODCALLTYPE GetProperty(
            IN  LONG  lPropId,
            IN  VARIANT varReserved,
            OUT VARIANT *pvarProp);

        virtual HRESULT STDMETHODCALLTYPE SetProperty(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE AddPropertyItem(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE DeletePropertyItem(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE get_PolicyAdministrators(
            OUT VARIANT *pvarAdmins);

        virtual HRESULT STDMETHODCALLTYPE get_PolicyReaders(
            OUT VARIANT *pvarReaders);

        virtual HRESULT STDMETHODCALLTYPE AddPolicyAdministrator(
            IN  BSTR    bstrReader,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE DeletePolicyAdministrator(
            IN  BSTR    bstrReader,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE AddPolicyReader(
            IN  BSTR    bstrReader,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE DeletePolicyReader(
            IN  BSTR    bstrReader,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE get_ApplicationGroups(
            OUT IAzApplicationGroups **ppGroups);

        virtual HRESULT STDMETHODCALLTYPE OpenApplicationGroup(
            IN  BSTR bstrGroupName,
            IN  VARIANT varReserved,
            OUT IAzApplicationGroup **ppGroup);

        virtual HRESULT STDMETHODCALLTYPE CreateApplicationGroup(
            IN  BSTR bstrGroupName,
            IN  VARIANT varReserved,
            OUT IAzApplicationGroup **ppGroup);

        virtual HRESULT STDMETHODCALLTYPE DeleteApplicationGroup(
            IN  BSTR bstrGroupName,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE get_Roles(
            OUT IAzRoles **ppRoles);

        virtual HRESULT STDMETHODCALLTYPE OpenRole(
            IN  BSTR bstrRoleName,
            IN  VARIANT varReserved,
            OUT IAzRole **ppRole);

        virtual HRESULT STDMETHODCALLTYPE CreateRole(
            IN  BSTR bstrRoleName,
            IN  VARIANT varReserved,
            OUT IAzRole **ppRole);

        virtual HRESULT STDMETHODCALLTYPE DeleteRole(
            IN  BSTR bstrRoleName,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE get_Tasks(
            OUT IAzTasks **ppTasks);

        virtual HRESULT STDMETHODCALLTYPE OpenTask(
            IN  BSTR bstrTaskName,
            IN  VARIANT varReserved,
            OUT IAzTask **ppTask);

        virtual HRESULT STDMETHODCALLTYPE CreateTask(
            IN  BSTR bstrTaskName,
            IN  VARIANT varReserved,
            OUT IAzTask **ppTask);

        virtual HRESULT STDMETHODCALLTYPE DeleteTask(
            IN  BSTR bstrTaskName,
            IN  VARIANT varReserved );


        virtual HRESULT STDMETHODCALLTYPE Submit(
            IN  LONG lFlags,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE  get_CanBeDelegated(
            OUT BOOL *pfProp);

        virtual HRESULT STDMETHODCALLTYPE  get_BizrulesWritable(
            OUT BOOL *pfProp);

        virtual HRESULT STDMETHODCALLTYPE  get_PolicyAdministratorsName(
            OUT VARIANT*        pvarAdmins
            );

        virtual HRESULT STDMETHODCALLTYPE  get_PolicyReadersName(
            OUT VARIANT*        pvarReaders
            );

        virtual HRESULT STDMETHODCALLTYPE  AddPolicyAdministratorName(
            IN  BSTR        bstrAdmin,
            IN  VARIANT     varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE  DeletePolicyAdministratorName(
            IN  BSTR        bstrAdmin,
            IN  VARIANT     varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE  AddPolicyReaderName(
            IN  BSTR        bstrReader,
            IN  VARIANT     varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE  DeletePolicyReaderName(
            IN  BSTR        bstrReader,
            IN  VARIANT     varReserved
            );

        //internal methods
        HRESULT _Init(
            IN  AZ_HANDLE   hOwnerApp,
            IN  AZ_HANDLE    hHandle);
private:

        CRITICAL_SECTION        m_cs;

        AZ_HANDLE               m_hScope;
        AZ_HANDLE               m_hOwnerApp;
        DWORD                   m_dwOwnerAppSN;

};


///////////////////////
//CAzScopes
class ATL_NO_VTABLE CAzScopes :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<TScopesCollection, &IID_IAzScopes, &LIBID_AZROLESLib>
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CAzScopes)
    COM_INTERFACE_ENTRY(IAzScopes)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzScopes
public:

        //internal methods
        HRESULT _Init(
            IN  AZ_HANDLE   hOwnerApp,
            IN  VARIANT *pvarReserved,
            IN  AZ_HANDLE   hHandle);
private:

    AZ_HANDLE   m_hOwnerApp;
    DWORD       m_dwOwnerAppSN;
};



///////////////////////
//CAzApplicationGroup
class ATL_NO_VTABLE CAzApplicationGroup :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IAzApplicationGroup, &IID_IAzApplicationGroup, &LIBID_AZROLESLib>
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CAzApplicationGroup)
    COM_INTERFACE_ENTRY(IAzApplicationGroup)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzApplicationGroup
public:

        CAzApplicationGroup();
        ~CAzApplicationGroup();

        virtual HRESULT STDMETHODCALLTYPE put_Name(
            IN  BSTR  bstrName);

        virtual HRESULT STDMETHODCALLTYPE get_Name(
            IN  BSTR __RPC_FAR *pbstrName);

        virtual HRESULT STDMETHODCALLTYPE put_Description(
            IN  BSTR  bstrDescription);

        virtual HRESULT STDMETHODCALLTYPE get_Description(
            IN  BSTR __RPC_FAR *pbstrDescription);

        virtual HRESULT STDMETHODCALLTYPE
        get_Type(
            OUT LONG         *plProp
            );

        virtual HRESULT STDMETHODCALLTYPE
        put_Type(
            IN LONG         lProp
            );

        virtual HRESULT STDMETHODCALLTYPE
        get_LdapQuery(
            OUT BSTR         *pbstrProp
            );

        virtual HRESULT STDMETHODCALLTYPE
        put_LdapQuery(
            IN BSTR         bstrProp
            );

        virtual HRESULT STDMETHODCALLTYPE
        get_AppMembers(
            OUT VARIANT         *pvarProp
            );

        virtual HRESULT STDMETHODCALLTYPE
        get_AppNonMembers(
            OUT VARIANT         *pvarProp
            );

        virtual HRESULT STDMETHODCALLTYPE
        get_Members(
            OUT VARIANT         *pvarProp
            );

        virtual HRESULT STDMETHODCALLTYPE
        get_NonMembers(
            OUT VARIANT         *pvarProp
            );

    virtual HRESULT STDMETHODCALLTYPE AddAppMember(
        IN             BSTR        bstrOp,
        IN             VARIANT varReserved
        );

    virtual HRESULT STDMETHODCALLTYPE DeleteAppMember(
        IN             BSTR        bstrOp,
        IN             VARIANT varReserved
        );

    virtual HRESULT STDMETHODCALLTYPE AddAppNonMember(
        IN             BSTR        bstrOp,
        IN             VARIANT varReserved
        );

    virtual HRESULT STDMETHODCALLTYPE DeleteAppNonMember(
        IN             BSTR        bstrOp,
        IN             VARIANT varReserved
        );

        virtual HRESULT STDMETHODCALLTYPE AddMember(
            IN  BSTR    bstrProp,
            IN             VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE DeleteMember(
            IN  BSTR    bstrProp,
            IN             VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE AddNonMember(
            IN  BSTR    bstrProp,
            IN             VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE DeleteNonMember(
            IN  BSTR    bstrProp,
            IN             VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE get_Writable(
            OUT BOOL *pfProp);

        virtual HRESULT STDMETHODCALLTYPE GetProperty(
            IN  LONG  lPropId,
            IN  VARIANT varReserved,
            OUT VARIANT *pvarProp);

        virtual HRESULT STDMETHODCALLTYPE SetProperty(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE AddPropertyItem(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE DeletePropertyItem(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE Submit(
            IN  LONG lFlags,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE  AddMemberName(
            IN BSTR    bstrProp,
            IN VARIANT varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE  DeleteMemberName(
            IN BSTR    bstrProp,
            IN VARIANT varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE  AddNonMemberName(
            IN BSTR    bstrProp,
            IN VARIANT varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE  DeleteNonMemberName(
            IN BSTR    bstrProp,
            IN VARIANT varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE  get_MembersName(
            OUT VARIANT * pvarProp
            );

        virtual HRESULT STDMETHODCALLTYPE  get_NonMembersName(
            OUT VARIANT * pvarProp
            );

        //internal methods
        HRESULT _Init(
            IN  AZ_HANDLE   hOwnerApp,
            IN  AZ_HANDLE    hHandle);
private:

        CRITICAL_SECTION        m_cs;

        AZ_HANDLE               m_hGroup;
        AZ_HANDLE               m_hOwnerApp;
        DWORD                   m_dwOwnerAppSN;

};


///////////////////////
//CAzApplicationGroups
class ATL_NO_VTABLE CAzApplicationGroups :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<TApplicationGroupsCollection, &IID_IAzApplicationGroups, &LIBID_AZROLESLib>
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CAzApplicationGroups)
    COM_INTERFACE_ENTRY(IAzApplicationGroups)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzApplicationGroups
public:

        //internal methods
        HRESULT _Init(
            IN  AZ_HANDLE   hOwnerApp,
            IN  VARIANT *pvarReserved,
            IN  AZ_HANDLE   hHandle);
private:

    AZ_HANDLE   m_hOwnerApp;
    DWORD       m_dwOwnerAppSN;
};



///////////////////////
//CAzRole
class ATL_NO_VTABLE CAzRole :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IAzRole, &IID_IAzRole, &LIBID_AZROLESLib>
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CAzRole)
    COM_INTERFACE_ENTRY(IAzRole)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzRole
public:

        CAzRole();
        ~CAzRole();

        virtual HRESULT STDMETHODCALLTYPE put_Name(
            IN  BSTR  bstrName);

        virtual HRESULT STDMETHODCALLTYPE get_Name(
            IN  BSTR __RPC_FAR *pbstrName);

        virtual HRESULT STDMETHODCALLTYPE put_Description(
            IN  BSTR  bstrDescription);

        virtual HRESULT STDMETHODCALLTYPE get_Description(
            IN  BSTR __RPC_FAR *pbstrDescription);

        virtual HRESULT STDMETHODCALLTYPE put_ApplicationData(
            IN  BSTR  bstrApplicationData);

        virtual HRESULT STDMETHODCALLTYPE get_ApplicationData(
            IN  BSTR __RPC_FAR *pbstrApplicationData);

        virtual
        HRESULT STDMETHODCALLTYPE get_AppMembers(
        OUT VARIANT *pvarProp
        );

        virtual
        HRESULT STDMETHODCALLTYPE get_Members(
        OUT VARIANT *pvarProp
        );

       virtual
        HRESULT STDMETHODCALLTYPE get_Operations(
        OUT VARIANT *pvarProp
        );

        virtual
        HRESULT STDMETHODCALLTYPE get_Tasks(
        OUT VARIANT *pvarProp
        );

    virtual HRESULT STDMETHODCALLTYPE AddAppMember(
        IN             BSTR        bstrProp,
        IN             VARIANT varReserved
        );

    virtual HRESULT STDMETHODCALLTYPE DeleteAppMember(
        IN             BSTR        bstrProp,
        IN             VARIANT varReserved
        );

    virtual HRESULT STDMETHODCALLTYPE AddTask(
        IN             BSTR        bstrProp,
        IN             VARIANT varReserved
        );

    virtual HRESULT STDMETHODCALLTYPE DeleteTask(
        IN             BSTR        bstrProp,
        IN             VARIANT varReserved
        );

    virtual HRESULT STDMETHODCALLTYPE AddOperation(
        IN             BSTR        bstrProp,
        IN             VARIANT varReserved
        );

    virtual HRESULT STDMETHODCALLTYPE DeleteOperation(
        IN             BSTR        bstrProp,
        IN             VARIANT varReserved
        );

        virtual HRESULT STDMETHODCALLTYPE AddMember(
            IN  BSTR    bstrProp,
            IN             VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE DeleteMember(
            IN  BSTR    bstrProp,
            IN             VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE get_Writable(
            OUT BOOL *pfProp);

        virtual HRESULT STDMETHODCALLTYPE GetProperty(
            IN  LONG  lPropId,
            IN  VARIANT varReserved,
            OUT VARIANT *pvarProp);

        virtual HRESULT STDMETHODCALLTYPE SetProperty(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE AddPropertyItem(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE DeletePropertyItem(
            IN  LONG  lPropId,
            IN  VARIANT varProp,
            IN  VARIANT varReserved );

        virtual HRESULT STDMETHODCALLTYPE Submit(
            IN  LONG lFlags,
            IN  VARIANT varReserved);

        virtual HRESULT STDMETHODCALLTYPE  AddMemberName(
            IN BSTR    bstrProp,
            IN VARIANT varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE  DeleteMemberName(
            IN BSTR    bstrProp,
            IN VARIANT varReserved
            );

        virtual HRESULT STDMETHODCALLTYPE  get_MembersName(
            OUT VARIANT * pvarProp
            );

        //internal methods
        HRESULT _Init(
            IN  AZ_HANDLE    hOwnerApp,
            IN  AZ_HANDLE    hHandle);
private:

        CRITICAL_SECTION        m_cs;

        AZ_HANDLE               m_hRole;
        AZ_HANDLE               m_hOwnerApp;
        DWORD                   m_dwOwnerAppSN;

};


///////////////////////
//CAzRoles
class ATL_NO_VTABLE CAzRoles :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<TRolesCollection, &IID_IAzRoles, &LIBID_AZROLESLib>
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CAzRoles)
    COM_INTERFACE_ENTRY(IAzRoles)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzRoles
public:

        //internal methods
        HRESULT _Init(
            IN  AZ_HANDLE   hOwnerApp,
            IN  VARIANT *pvarReserved,
            IN  AZ_HANDLE   hHandle);
private:

    AZ_HANDLE   m_hOwnerApp;
    DWORD       m_dwOwnerAppSN;
};




///////////////////////
//CAzClientContext
class ATL_NO_VTABLE CAzClientContext :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IAzClientContext, &IID_IAzClientContext, &LIBID_AZROLESLib>
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CAzClientContext)
    COM_INTERFACE_ENTRY(IAzClientContext)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzClientContext
public:

        CAzClientContext();
        ~CAzClientContext();

        virtual HRESULT STDMETHODCALLTYPE AccessCheck(
            IN  BSTR bstrObjectName,
            IN  VARIANT varScopeNames,
            IN  VARIANT varOperations,
            IN  VARIANT varParameterNames,
            IN  VARIANT varParameterValues,
            IN  VARIANT varInterfaceNames,
            IN  VARIANT varInterfaceFlags,
            IN  VARIANT varInterfaces,
            OUT VARIANT *pvarResults);

        virtual HRESULT STDMETHODCALLTYPE GetBusinessRuleString(
            OUT BSTR *pbstrBusinessRuleString);

        virtual HRESULT STDMETHODCALLTYPE get_UserDn(
            OUT BSTR *pbstrProp
            );

        virtual HRESULT STDMETHODCALLTYPE get_UserSamCompat(
            OUT  BSTR *pbstrProp
            );

        virtual HRESULT STDMETHODCALLTYPE get_UserDisplay(
            OUT  BSTR *pbstrProp
            );

        virtual HRESULT STDMETHODCALLTYPE get_UserGuid(
            OUT  BSTR *pbstrProp
            );

        virtual HRESULT STDMETHODCALLTYPE get_UserCanonical(
            OUT  BSTR *pbstrProp
            );

        virtual HRESULT STDMETHODCALLTYPE get_UserUpn(
            OUT  BSTR *pbstrProp
            );

        virtual HRESULT STDMETHODCALLTYPE get_UserDnsSamCompat(
            OUT  BSTR *pbstrProp
            );

        virtual HRESULT STDMETHODCALLTYPE GetProperty(
            IN  LONG  lPropId,
            IN  VARIANT varReserved,
            OUT VARIANT *pvarProp);

        virtual HRESULT STDMETHODCALLTYPE GetRoles(
            IN  BSTR bstrScopeName,
            OUT VARIANT *pvarRoleNames);

        virtual HRESULT STDMETHODCALLTYPE get_RoleForAccessCheck(
            OUT BSTR *pbstrProp
            );

        virtual HRESULT STDMETHODCALLTYPE put_RoleForAccessCheck(
            IN BSTR bstrProp
            );

        //internal methods
        HRESULT _Init(
            IN  AZ_HANDLE   hOwnerApp,
            IN  AZ_HANDLE   hHandle,
            IN  LONG        varReserved);

private:
        CRITICAL_SECTION        m_cs;

        AZ_HANDLE               m_hClientContext;
        LONG                    m_lReserved;
        WCHAR                  *m_pwszBusinessRuleString;
        AZ_HANDLE               m_hOwnerApp;
        DWORD                   m_dwOwnerAppSN;

};

///////////////////////
//CAzBizRuleContext
class ATL_NO_VTABLE CAzBizRuleContext :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CAzBizRuleContext, &CLSID_AzBizRuleContext>,
    public IDispatchImpl<IAzBizRuleContext, &IID_IAzBizRuleContext, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZBIZRULECONTEXT)

BEGIN_COM_MAP(CAzBizRuleContext)
    COM_INTERFACE_ENTRY(IAzBizRuleContext)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzBizRuleContext
public:

        CAzBizRuleContext();
        ~CAzBizRuleContext();

        virtual HRESULT STDMETHODCALLTYPE put_BusinessRuleResult(
            IN  BOOL bResult);

        virtual HRESULT STDMETHODCALLTYPE put_BusinessRuleString(
            IN  BSTR bstrBusinessRuleString);

        virtual HRESULT STDMETHODCALLTYPE get_BusinessRuleString(
            OUT BSTR *pbstrBusinessRuleString);

        virtual HRESULT STDMETHODCALLTYPE GetParameter(
            IN  BSTR bstrParameterName,
            OUT VARIANT *pvarParameterValue);

        friend VOID SetAccessCheckContext(
            IN OUT CAzBizRuleContext* BizRuleContext,
            IN BOOL bCaseSensitive,
            IN PACCESS_CHECK_CONTEXT AcContext,
            IN PBOOL BizRuleResult,
            IN HRESULT *ScriptError
            );


private:
        PACCESS_CHECK_CONTEXT m_AcContext;
        PBOOL m_BizRuleResult;
        HRESULT *m_ScriptError;
        ITypeInfo *m_typeInfo;
        BOOL m_bCaseSensitive;

};

#endif //__AZDISP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\accessck.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    accessck.cxx

Abstract:

    CAzBizRuleContext class implementation

Author:

    ObjectFame sample code taken from http://support.microsoft.com/support/kb/articles/Q183/6/98.ASP
    Cliff Van Dyke (cliffv) 19-July-2001

-- */

#include "pch.hxx"

/////////////////////////
//CAzBizRuleContext
/////////////////////////
//Constructor
CAzBizRuleContext::CAzBizRuleContext()
{
    AzPrint((AZD_SCRIPT_MORE, "CAzBizRuleContext\n"));
    m_typeInfo = NULL;
    m_AcContext = NULL;
    // m_theConnection = NULL;

    //
    // Set the default return values for this access check
    //
    m_BizRuleResult = NULL;
    m_ScriptError = NULL;
    m_bCaseSensitive = TRUE;

}

//Destructor
CAzBizRuleContext::~CAzBizRuleContext()
{
    if (m_typeInfo != NULL) {
        m_typeInfo->Release();
        m_typeInfo = NULL;
    }

    ASSERT( m_AcContext == NULL );
    ASSERT( m_BizRuleResult == NULL );
    ASSERT( m_ScriptError == NULL );

    AzPrint((AZD_SCRIPT_MORE, "~CAzBizRuleContext\n"));
}

//
// Methods to set/get the boolean result of the business rule
//

HRESULT
CAzBizRuleContext::put_BusinessRuleResult(
    IN BOOL bResult
    )
/*++

Routine Description:

    The script calls the SetBusinessRuleResult method to indicate whether the business rule
    has decided to grant permission to the user to perform the requested task.

    If the script never calls this method, permission is not granted.

    On entry, AcContext->ClientContext.CritSect must be locked.

Arguments:

    BizRuleResult -- Specifies whether permission is granted.  If TRUE, permission is granted.
        If FALSE, permission is not granted.

Return Value:

    None

--*/
{
    AzPrint((AZD_SCRIPT, "CAzBizRuleContext::put_BusinessRuleResult: %ld\n", bResult));

    //
    // This really can't happen, but ...
    //
    if ( m_BizRuleResult == NULL || m_AcContext == NULL || m_ScriptError == NULL ) {
        ASSERT( FALSE );
        return E_FAIL;
    }
    ASSERT( AzpIsCritsectLocked( &m_AcContext->ClientContext->CritSect ) );

    //
    // Set the result
    //

    *m_BizRuleResult = bResult;
    return S_OK;
}

HRESULT
CAzBizRuleContext::put_BusinessRuleString(
    IN BSTR bstrBusinessRuleString
    )
/*++

Routine Description:

    The script calls the put_BusinessRuleString method to store a string to be returned
    from access check.

    If the no script ever calls this method, a zero length string is returned from access check.

    On entry, AcContext->ClientContext.CritSect must be locked.

Arguments:

    bstrBusinessRuleString -- The string to store

Return Value:

    None

--*/
{
    HRESULT hr;
    DWORD WinStatus;

    AZP_STRING CapturedString;

    //
    // Initialization
    //
    AzPrint((AZD_SCRIPT, "CAzBizRuleContext::put_BusinessRuleString: %ws\n", bstrBusinessRuleString ));
    AzpInitString( &CapturedString, NULL );

    //
    // This really can't happen, but ...
    //
    if ( m_BizRuleResult == NULL || m_AcContext == NULL || m_ScriptError == NULL ) {
        ASSERT( FALSE );
        hr = E_FAIL;
        goto Cleanup;
    }
    ASSERT( AzpIsCritsectLocked( &m_AcContext->ClientContext->CritSect ) );

    //
    // Capture the input string
    //

    WinStatus = AzpCaptureString( &CapturedString,
                                  bstrBusinessRuleString,
                                  AZ_MAX_BIZRULE_STRING,
                                  TRUE ); // NULL is OK

    if ( WinStatus != NO_ERROR ) {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // Swap the old/new names
    //

    AzpSwapStrings( &CapturedString, &m_AcContext->BusinessRuleString );
    hr = S_OK;

Cleanup:
    AzpFreeString( &CapturedString );
    return hr;
}

HRESULT
CAzBizRuleContext::get_BusinessRuleString(
    OUT  BSTR *pbstrBusinessRuleString)
/*++

Routine Description:

    The script calls the get_BusinessRuleString method to get a copy of the string to be returned
    from access check.

    If the no script ever calls this method, a zero length string is returned from access check.

    On entry, AcContext->ClientContext.CritSect must be locked.

Arguments:

    bstrBusinessRuleString -- A pointer to the string to return

Return Value:

    None

--*/
{
    LPWSTR TempString;
    AzPrint((AZD_SCRIPT, "CAzBizRuleContext::get_BusinessRuleString: %ws\n", m_AcContext->BusinessRuleString.String ));

    //
    // This really can't happen, but ...
    //
    if ( m_BizRuleResult == NULL || m_AcContext == NULL || m_ScriptError == NULL ) {
        ASSERT( FALSE );
        return E_FAIL;
    }
    ASSERT( AzpIsCritsectLocked( &m_AcContext->ClientContext->CritSect ) );

    //
    // Set the result
    //

    if ( m_AcContext->BusinessRuleString.String == NULL ) {
        TempString = NULL;
    } else {
        TempString = SysAllocString( m_AcContext->BusinessRuleString.String );

        if ( TempString == NULL ) {
            return E_OUTOFMEMORY;
        }
    }

    //
    // Return it to the caller
    //

    *pbstrBusinessRuleString = TempString;
    return S_OK;
}

HRESULT
CAzBizRuleContext::GetParameter(
    IN   BSTR bstrParameterName,
    OUT  VARIANT *pvarParameterValue )
{
/*++

Routine Description:

    The script calls the GetParameter method to get the parameters
    passed into IAzClientContext::AccessCheck in Parameters

    On entry, AcContext->ClientContext.CritSect must be locked.


Arguments:

    bstrParameterName - Specifies the parameter to get.  This name must match the name
        in one of the elements specified in the ParameterNames array passed to AccessCheck.

    pvarParameterValue - Returns a variant containing the corresponding element in the
        ParameterValues array passed to AccessCheck.

Return Value:

    S_OK: pvarParameterValue was returned successfully
    E_INVALIDARG: bstrParameterName did not correspond to a passed in parameter

--*/
    HRESULT hr;
    VARIANT Name;
    VARIANT *ParameterNameInArray;
    ULONG ArrayIndex;

    AzPrint((AZD_SCRIPT, "CAzBizRuleContext::GetParameter: %ls\n", bstrParameterName ));

    //
    // This really can't happen, but ...
    //
    if ( m_BizRuleResult == NULL || m_AcContext == NULL || m_ScriptError == NULL ) {
        ASSERT( FALSE );
        return E_FAIL;
    }
    ASSERT( AzpIsCritsectLocked( &m_AcContext->ClientContext->CritSect ) );

    //
    // Convert name to an easier form to compare
    //

    VariantInit( &Name );
    V_VT(&Name) = VT_BSTR;
    V_BSTR(&Name) = bstrParameterName;


    //
    // We didn't capture the array
    //  So access it under a try/except
    __try {


        //
        // Do a binary search to find the parameter
        //

        if (m_bCaseSensitive)
        {
            ParameterNameInArray = (VARIANT *) bsearch(
                            &Name,
                            m_AcContext->ParameterNames,
                            m_AcContext->ParameterCount,
                            sizeof(VARIANT),
                            AzpCompareParameterNames );
        }
        else
        {
            ParameterNameInArray = (VARIANT *) bsearch(
                            &Name,
                            m_AcContext->ParameterNames,
                            m_AcContext->ParameterCount,
                            sizeof(VARIANT),
                            AzpCaseInsensitiveCompareParameterNames );
        }

        if ( ParameterNameInArray == NULL ) {
            AzPrint((AZD_INVPARM, "CAzBizRuleContext::GetParameter: %ls: Parameter not passed in.\n", bstrParameterName ));
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        //
        // Return the parameter to the caller
        //

        ArrayIndex = (ULONG)(ParameterNameInArray - m_AcContext->ParameterNames);
        hr = VariantCopy( pvarParameterValue, &m_AcContext->ParameterValues[ArrayIndex] );

        if ( FAILED(hr)) {
            goto Cleanup;
        }

        //
        // Mark that we've used this parameter
        //

        if ( !m_AcContext->UsedParameters[ArrayIndex] ) {
            m_AcContext->UsedParameters[ArrayIndex] = TRUE;
            m_AcContext->UsedParameterCount ++;
        }

        hr = S_OK;

Cleanup:;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        hr = GetExceptionCode();
        AzPrint((AZD_CRITICAL, "GetParameter took an exception: 0x%lx\n", hr));
    }

    if ( FAILED(hr)) {
        *m_ScriptError = hr;
    }

    return hr;
}


VOID
SetAccessCheckContext(
    IN OUT CAzBizRuleContext* BizRuleContext,
    IN BOOL bCaseSensitive,
    IN PACCESS_CHECK_CONTEXT AcContext,
    IN PBOOL BizRuleResult,
    IN HRESULT *ScriptError
    )
/*++

Routine Description:

    The routine tells this object about the current access check context that is running.
    The context is used to satisfy queries from the script about the access check being performed.

    On entry, AcContext->ClientContext.CritSect must be locked.

Arguments:

    BizRuleContext - Pointer to the instance of IAzBizRuleContext to update.
    
    bCaseSensitive - Specify whether the the script is case-sensitive or not.

    AcContext - Specifies the context of the accesscheck operation the bizrule is being evaluated for
        NULL - sets the AccessCheck object back to an initialized state.

    BizRuleResult - Result of the bizrule
        NULL - sets the AccessCheck object back to an initialized state.

    ScriptError - Status of the script.
        Any error generated by the script should be returned here.
        NULL - sets the AccessCheck object back to an initialized state.

Return Value:

    None
    
Note:
    1. This function modifies the state of the BizRuleContext object. And the modification
    is not protected. The reason this works, and future implementation must keep this
    in mind, is that we execute biz rules one after another sequentially. When that
    needs to be changed, then the whole biz rule context object needs to be re-written.
    
    2. This function should really be a member function of CAzBizRuleContext instead of
    a friend function. Need to change that in V2.

--*/
{

    //
    // Initialization
    //

    AzPrint(( AZD_SCRIPT_MORE, "CAzBizRuleContext::SetAccessCheckContext\n"));

    if ( AcContext != NULL ) {
        ASSERT( AzpIsCritsectLocked( &AcContext->ClientContext->CritSect ) );
    }

    //
    // Save the pointer to the context
    //

    ASSERT( BizRuleContext != NULL );
    ASSERT( BizRuleContext->m_AcContext == NULL || AcContext == NULL );
    ASSERT( BizRuleContext->m_BizRuleResult == NULL || BizRuleResult == NULL );
    ASSERT( BizRuleContext->m_ScriptError == NULL || ScriptError == NULL );

    BizRuleContext->m_AcContext = AcContext;
    BizRuleContext->m_BizRuleResult = BizRuleResult;
    BizRuleContext->m_ScriptError = ScriptError;
    BizRuleContext->m_bCaseSensitive = bCaseSensitive;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\azdisp.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    azdisp.cxx

Abstract:

    Implementation of CAz* dispatch interfaces

Author:

    Xiaoxi Tan (xtan) 11-May-2001

--*/

#include "pch.hxx"
#include <Ntdsapi.h>
#include <dispex.h>

#define AZD_COMPONENT     AZD_DISPATCH


//object type IDs
enum ENUM_AZ_OBJECT
{
    ENUM_AZ_APPLICATION   = 0,
    ENUM_AZ_GROUP         = 1,
    ENUM_AZ_OPERATION     = 2,
    ENUM_AZ_TASK          = 3,
    ENUM_AZ_SCOPE         = 4,
    ENUM_AZ_ROLE          = 5,
    ENUM_AZ_CLIENTCONTEXT = 6,
    ENUM_AZ_APPLICATIONS  = 7,
    ENUM_AZ_GROUPS        = 8,
    ENUM_AZ_OPERATIONS    = 9,
    ENUM_AZ_TASKS         = 10,
    ENUM_AZ_SCOPES        = 11,
    ENUM_AZ_ROLES         = 12,
};

//data struct defines
typedef DWORD (*PFUNCAzCreate)(
    IN AZ_HANDLE hObjHandle,
    IN LPCWSTR Name,
    IN DWORD Reserved,
    OUT PAZ_HANDLE phHandle);

typedef DWORD (*PFUNCAzOpen)(
    IN AZ_HANDLE hObjHandle,
    IN LPCWSTR Name,
    IN DWORD Reserved,
    OUT PAZ_HANDLE phHandle);

typedef DWORD (*PFUNCAzClose)(
    IN AZ_HANDLE hObjHandle,
    IN LPCWSTR Name,
    IN LONG lFlags);

typedef DWORD (*PFUNCAzDelete)(
    IN AZ_HANDLE hParent,
    IN LPCWSTR Name,
    IN DWORD lReserved);

typedef DWORD (*PFUNCAzEnum)(
    IN  AZ_HANDLE   hParent,
    IN  DWORD       Reserved,
    IN OUT ULONG     *lContext,
    OUT AZ_HANDLE   *phObject);

typedef DWORD (*PFUNCAzSetProperty)(
    IN AZ_HANDLE hHandle,
    IN ULONG  PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue);

typedef DWORD (*PFUNCAzRemovePropertyItem)(
    IN AZ_HANDLE hHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue);


//
// Routine that checks if an object is still good to use
//  This is needed because when an application is forcefually
//  closed, all its descendent objects becomes un-usable, even
//  the CloseHandle call in the COM objects' destructors can't proceed.
//


BOOL IsObjectUsable (
    IN AZ_HANDLE hOwnerApp, 
    DWORD dwOwnerAppSN
    )
/*++
Description:
    This helper function determines if the object is still usable.

Arguments:

    hOwnerApp       - The owner application handle of the object.

    dwOwnerAppSN    - The sequential number of the owner application.

Return:

    True if and only if the owner application is still valid.

Note:
    Since applications can be forcefully closed, and when that happens,
    all descendent objects originated from the applications becomes invalid because
    their memory is freed. This violates the normal COM programming model where
    objects must be allowed to live by its own ref-counting rules.

    To solve this problem, we deviced the following solution:
    (1) We add a sequential number to the application object struct. This sequential
        number is created at the store load time and modified when an application
        is closed. The sequential number is not persisted. Different application
        cache structs can have the same sequential number.
    (2) when a COM object is created, if it has an application object as its
        ancestor, it caches that application's handle and the sequential number of
        the application. This application handle is called owner app handle,
        whereas the sequential number is called owner app sequential number.
    (3) An application has its sequential number incremented when it is closed.
    (4) When an object needs to do any function relating to the cache, we check
        if the object is still usable based on the cached owner app's sequential number
        and the current application's sequential number. If they don't match, we
        know that the object is a dangling object after its owning application was
        closed (which might have been brought back to live by OpenApplication)
    (5) Some objects (AzStore object, and those ApplicationGroup object owned by
        the store object) may not have an owner app. In those cases, the hOwnerApp
        should be NULL and we don't check the other condition.

--*/
{
    return (hOwnerApp == NULL) || 
           (dwOwnerAppSN == AzpRetrieveApplicationSequenceNumber(hOwnerApp));
}

HRESULT
myAccountNameToSid (
    IN LPCWSTR pwszName,
    OUT PSID * ppSid
    )
/*++
Description:
    This helper function convert an account name to a SID.

Arguments:

    pwszName - Name of the account to lookup

    ppSid    - Receives the SID if found. Caller must call LocalFree
               if it receives a valid SID.

Return:

    Success: S_OK
    Failure: E_INVALIDARG, E_OUTOFMEMORY, or other error codes from LookupAccountName

--*/
{
    if (ppSid == NULL)
    {
        return E_INVALIDARG;
    }

    *ppSid = NULL;

    if (pwszName == NULL || *pwszName == L'\0')
    {
        return E_INVALIDARG;
    }

    //
    // do account lookup
    //

    HRESULT hr = S_OK;

    DWORD dwSidSize = 0;
    DWORD dwDomainSize = 0;
    SID_NAME_USE snu;

    //
    // we don't care about the return result because it will fail anyway
    // since we are querying the buffer sizes
    //

    LookupAccountName(NULL,
                    pwszName,
                    NULL,
                    &dwSidSize,
                    NULL,
                    &dwDomainSize,
                    &snu
                    );

    DWORD dwErr = GetLastError();

    //
    // it must fail for buffer not sufficient
    //

    if (dwErr != ERROR_INSUFFICIENT_BUFFER)
    {
        return AZ_HR_FROM_WIN32(dwErr);
    }

    //
    // all sids are LocalAlloc'ed. So, we just follow
    // the same so that callers can have a consistent usage
    //

    *ppSid = (PSID) LocalAlloc(LPTR, dwSidSize);

    //
    // although we don't care about domain, but without
    // retrieving domain, lookup will fail.
    //

    LPWSTR pwszDomain = NULL;

    SafeAllocaAllocate(pwszDomain, dwDomainSize * sizeof(WCHAR));

    if (*ppSid != NULL && pwszDomain != NULL)
    {
        if ( !LookupAccountName(NULL,
                                pwszName,
                                *ppSid,
                                &dwSidSize,
                                pwszDomain,
                                &dwDomainSize,
                                &snu
                                ) )
        {
            dwErr = GetLastError();
            hr = AZ_HR_FROM_WIN32(dwErr);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    //
    // we don't need domain name
    //

    if (pwszDomain != NULL)
    {
        SafeAllocaFree(pwszDomain);
    }

    if (hr != S_OK && *ppSid != NULL)
    {
        LocalFree(*ppSid);
        *ppSid = NULL;
    }

    return hr;
}


HRESULT
mySidToAccountName (
    IN PSID      pSid,
    OUT LPWSTR * ppwszName
    )
/*++
Description:

    This helper function convert an a SID to a string account name. Note: this function
     doesn't convert the name to UPN.

Arguments:

    pSid        - The SID whose name will be looked up.

    ppwszName   - Receives the name of the SID. Caller must free it by LocalFree.

Return:

    Success: S_OK
    Failure: E_INVALIDARG, E_OUTOFMEMORY, or other error codes from LookupAccountSid

--*/
{
    if (ppwszName == NULL)
    {
        return E_INVALIDARG;
    }

    *ppwszName = NULL;

    if (pSid == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // do account lookup
    //

    HRESULT hr = S_OK;

    DWORD dwNameSize = 0;
    DWORD dwDomainSize = 0;
    SID_NAME_USE snu;

    //
    // we don't care about the return result because it will fail anyway
    // since we are querying the buffer sizes
    //

    LookupAccountSid(NULL,
                    pSid,
                    NULL,
                    &dwNameSize,
                    NULL,
                    &dwDomainSize,
                    &snu
                    );

    DWORD dwErr = GetLastError();

    //
    // it must fail for buffer not sufficient to be correct.
    //

    if (dwErr != ERROR_INSUFFICIENT_BUFFER)
    {
        return AZ_HR_FROM_WIN32(dwErr);
    }

    //
    // we should have used AzpAllocateHeap, but that will make
    // our calling routine confused. So, use a more consistent
    // memory routine so that the caller can use the same to free it
    //

    LPWSTR pszNTName = (LPWSTR) LocalAlloc(LPTR, dwNameSize * sizeof(WCHAR));

    //
    // although we don't care about domain, but without
    // retrieving domain, lookup will fail. We don't pass out this memory
    // so, we will just use
    //

    LPWSTR pwszDomain = NULL;
    SafeAllocaAllocate(pwszDomain, dwDomainSize * sizeof(WCHAR));

    if (pszNTName != NULL && pwszDomain != NULL)
    {
        if ( !LookupAccountSid(NULL,
                                pSid,
                                pszNTName,
                                &dwNameSize,
                                pwszDomain,
                                &dwDomainSize,
                                &snu
                                ) )
        {
            dwErr = GetLastError();
            hr = AZ_HR_FROM_WIN32(dwErr);
        }
        else
        {
            *ppwszName = pszNTName;
            pszNTName = NULL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    //
    // we don't need domain name
    //

    if (pwszDomain != NULL)
    {
        SafeAllocaFree(pwszDomain);
    }

    if (pszNTName != NULL)
    {
        LocalFree((HLOCAL)pszNTName);
        pszNTName = NULL;
    }

    return hr;
}


HRESULT
mySidToName (
    IN HANDLE    hDS,
    IN PSID      pSid,
    OUT LPWSTR * ppwszName
    )
/*++
Description:

    This helper function convert an a SID to a string account name.
     If possible, we will return UPN name. But any failure to convert
     to UPN name will result in a regular NT4 style name.

Arguments:

    hDS         - DS handle if we need UPN name

    pSid        - The SID whose name will be looked up.

    ppwszName   - Receives the name of the SID. Caller must free it by LocalFree.
                  If we can crack the name, we will return UPN. Otherwise, the NT
                  account name will be returned.

Return:

    Success: S_OK
    Failure: E_INVALIDARG, E_OUTOFMEMORY, or other error codes from LookupAccountName

--*/
{
    if (ppwszName == NULL)
    {
        return E_INVALIDARG;
    }

    *ppwszName = NULL;

    if (pSid == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // Get the string SID to crack the name
    //

    HRESULT hr = S_OK;
    DWORD dwErr;

    LPWSTR pwszStringSid = NULL;

    if (!ConvertSidToStringSid(pSid, &pwszStringSid))
    {
        return AZ_HR_FROM_WIN32(GetLastError());
    }

    PDS_NAME_RESULTW pnamesResult = NULL;
    dwErr = DsCrackNamesW ( hDS,
                            DS_NAME_NO_FLAGS,
                            DS_SID_OR_SID_HISTORY_NAME,
                            DS_USER_PRINCIPAL_NAME,
                            1,
                            &pwszStringSid,
                            &pnamesResult
                            );

    if ( pnamesResult != NULL &&
        (DS_NAME_NO_ERROR == dwErr) &&
        (pnamesResult->rItems[0].pName != NULL) &&
        (pnamesResult->rItems[0].status == DS_NAME_NO_ERROR)
        )
    {
        dwErr = NO_ERROR;

        //
        // we can use the cracked UPN. Adding 1 to include the null terminator.
        //

        DWORD dwLen = (DWORD) wcslen(pnamesResult->rItems[0].pName) + 1;
        *ppwszName = (LPWSTR) LocalAlloc(LPTR, dwLen * sizeof(WCHAR));
        if (*ppwszName != NULL)
        {
            memcpy(*ppwszName, pnamesResult->rItems[0].pName, dwLen * sizeof(WCHAR));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        //
        // we will just have to use the NT style name
        //

        hr = mySidToAccountName(pSid, ppwszName);
    }

    if (pnamesResult != NULL)
    {
        DsFreeNameResult(pnamesResult);
    }

    return hr;
}

BOOL
myNeedSidToNameConversion (
    IN LONG lPropID,
    OUT LONG * plPersistPropID
    )
/*++
Description:

    Since we internally persist only sid but we allow the
    user to use account names, we need to convert when such properties
    are requested. This helper function determines which property
    ID needs sid to name conversion.

Arguments:

    lPropID         - The ID of the property

    plPersistPropID - The ID on which is property is persisted

Return:
    TRUE if the property needs sid to name conversion
    FALSE otherwise

--*/
{
    BOOL bResult = TRUE;
    switch (lPropID)
    {
        case AZ_PROP_GROUP_MEMBERS_NAME:
            *plPersistPropID = AZ_PROP_GROUP_MEMBERS;
            break;
        case AZ_PROP_GROUP_NON_MEMBERS_NAME:
            *plPersistPropID = AZ_PROP_GROUP_NON_MEMBERS;
            break;
        case AZ_PROP_ROLE_MEMBERS_NAME:
            *plPersistPropID = AZ_PROP_ROLE_MEMBERS;
            break;
        case AZ_PROP_POLICY_ADMINS_NAME:
            *plPersistPropID = AZ_PROP_POLICY_ADMINS;
            break;
        case AZ_PROP_POLICY_READERS_NAME:
            *plPersistPropID = AZ_PROP_POLICY_READERS;
            break;
        case AZ_PROP_DELEGATED_POLICY_USERS_NAME:
            *plPersistPropID = AZ_PROP_DELEGATED_POLICY_USERS;
            break;
        default:
            *plPersistPropID = lPropID;
            bResult = FALSE;
            break;
     }
     return bResult;
}

template<class T>
HRESULT
myAddItemToMap (
    IN OUT T_AZ_MAP(T) * pMap,
    IN OUT T** ppObj
    )

/*++
Description:
    This helper function is designed to solve the problem in STL's implementation
    which does not protect caller from "out of memory" conditions. STL will simply
    crash. By catching the exception ourselves, we will be able to continue with
    appropriate error code.

Arguments:

    pMap - The map where this object (*ppObj) will be added.

    ppObj   - the object that will be added to the map.

Return:

    Success: S_OK
    Failure: E_INVALIDARG or E_OUTOFMEMORY

********** Warning **************
    We consider the object pointed to by *ppObj is consumed after calling
    this function regardless of success or failure. So, the outgoing *ppObj
    will always be NULL.

    This is not a good design in general use. But for our maps, this is the
    cleanest way of reducing duplicate code.
********** Warning **************

--*/
{
    if (pMap == NULL || ppObj == NULL || *ppObj == NULL)
    {
        if (ppObj != NULL && *ppObj != NULL)
        {
            (*ppObj)->Release();
            *ppObj = NULL;
        }
        return E_INVALIDARG;
    }

    //
    // $consider:
    // all our maps uses BSTR representation of index numbers
    // as keys. We should eventually clean that up. We should
    // just use indexes.
    //

    WCHAR    wszIndex[12];
    wnsprintf(wszIndex, 12, L"%09u", pMap->size() + 1);

    BSTR  bstrIndex = ::SysAllocString(wszIndex);

    if (bstrIndex == NULL)
    {
        (*ppObj)->Release();
        *ppObj = NULL;
        return E_OUTOFMEMORY;
    }

    //
    // STL doesn't check for memory allocation failure.
    // We have to catch it ourselves. Secondly, our map
    // uses CComPtr<T>, so the addition to the map causes
    // the ref count of the object to go up by 1. So, regardless
    // whether we successfully added the object to the map or not,
    // we will release it.
    //

    HRESULT HR = S_OK;
    __try
    {
        (*pMap)[bstrIndex] = (*ppObj);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        HR = E_OUTOFMEMORY;
    }
    (*ppObj)->Release();
    *ppObj = NULL;

    ::SysFreeString(bstrIndex);

    return HR;
}

//some internal common procedures

HRESULT
HandleReserved(
    IN VARIANT *pvarReserved
    )
/*+++
Description:
    helper routine to validate VARIANT reserved passed from
    COM interface callers. The reserved is enforced to be
    VT_NULL, VT_EMPTY, 0, or DISP_E_PARAMNOTFOUND
Arguments:
    pvarReserved - point to reserved variable for validation
Return:

 All reserved parameters should either not be specified or should be zero
---*/
{
    if ( pvarReserved == NULL) {
        return S_OK;

    } else if ( V_VT(pvarReserved) == VT_ERROR ) {

        //
        // From MSDN in a section talking about passing in parameters
        //
        //    If the parameters are positional (unnamed), you would set cArgs
        //    to the total number of possible parameters, cNamedArgs to 0, and
        //    pass VT_ERROR as the type of the omitted parameters, with the
        //    status code DISP_E_PARAMNOTFOUND as the value.

        if ( V_ERROR(pvarReserved) == DISP_E_PARAMNOTFOUND ) {
            return S_OK;
        }

    } else if ( V_VT(pvarReserved) == VT_EMPTY ) {
        return S_OK;

    } else if ( V_VT(pvarReserved) == VT_NULL ) {
        return S_OK;

    } else if ( V_VT(pvarReserved) == VT_I4 ) {

        if ( V_I4(pvarReserved) == 0 ) {
            return S_OK;
        }

    } else if ( V_VT(pvarReserved) == VT_I2 ) {

        if ( V_I2(pvarReserved) == 0 ) {
            return S_OK;
        }
    }

    return AZ_HRESULT( ERROR_INVALID_PARAMETER );
}

inline BOOL
myIsGoodUnicode (
    IN WCHAR wch
    )
/*++
Description:

    Test if the given WCHAR is a valid unicode character. For v1,
    all unicode characters must be that they are valid for according to
    XML spec.
    
Arguments:

    wch - given WCHAR to check.
    
Return:
    
    TRUE and and only is the wchar is a good unicode character.
    
--*/
{
    static const WCHAR wchUnicodeR1First   = 0x0020;
    static const WCHAR wchUnicodeR1Last    = 0xD7FF;
    static const WCHAR wchUnicodeR2First   = 0xE000;
    static const WCHAR wchUnicodeR2Last    = 0xFFFD;
    
    return ( wch >= wchUnicodeR1First && wch <= wchUnicodeR1Last ||
             wch >= wchUnicodeR2First && wch <= wchUnicodeR2Last ||
             wch == 0x9 ||
             wch == 0xA ||
             wch == 0xD);
}

inline BOOL
myIsGoodSurrogatePair (
    IN WCHAR wchHi,
    IN WCHAR wchLo
    )
/*++
Description:

    This function determines if a pair of WCHARs is a good surrogate pair.

    For valid utf-8 characters in the range, [#x10000 - #x10FFFF], MSXML uses
    surrogate pairs to pass them around using BSTR. For v1 before we implement
    provider specific validation, we require that all providers pass such 
    characters using surrogate pairs. This is the best assumption because
    multiple MS products (MSXML, SQL Server 2000) already use surrogate pairs.
    There is probably no reason to believe that other products (such as DS) won't.
    
Arguments:

    wchHi   - The high part of the surrogate.
    
    wchLo   - The low part of the surrogate.
    
Return:
    
    TRUE and and only is the pair is a good surrogate pair.
    
--*/
{
    static const WCHAR wchSurrogateHiFirst = 0xD800;
    static const WCHAR wchSurrogateHiLast  = 0xDBFF;
    static const WCHAR wchSurrogateLoFirst = 0xDC00;
    static const WCHAR wchSurrogateLoLast  = 0xDFFF;
    
    return ( wchHi >= wchSurrogateHiFirst && wchHi <= wchSurrogateHiLast &&
             wchLo >= wchSurrogateLoFirst && wchLo <= wchSurrogateLoLast);
}

HRESULT
myVerifyBSTRData (
    IN const BSTR bstrData
    )
/*++
Description:

    XML spec disallows certain characters being used. Here is the Char
    definition expansion:
        Char ::= #x9 | #xA | #xD | [#x20 - #xD7FF] | [#xE000 = #xFFFD] | [#x10000 - #x10FFFF]
    For v1, we will just disallow invalid characters for providers, thus
    bending for the convenience of XML provider.
    
Arguments:

    bstrData    - The BSTR data to be verified. This must be a NULL terminated BSTR.
    
Return:
    
    Success: S_OK.
    Failure: various error code.
    
Note:
    CLR has an API called IsSurrogate to test if a unicode
    character is a surrogate character. But we are not using CLR yet.
    So, we opt to do the test ourselves for v1.
--*/
{
    HRESULT hr = S_OK;
    
    //
    // We have nothing to check if given a NULL BSTR.
    //
    
    if (bstrData != NULL)
    {
        int i = 0;
        while (bstrData[i] != L'\0')
        {
            if ( !myIsGoodUnicode(bstrData[i]) && 
                 !myIsGoodSurrogatePair(bstrData[i], bstrData[i+1]) 
               )
            {
                hr = AZ_HR_FROM_WIN32(ERROR_INVALID_DATA);
                break;
            }
            ++i;
        }
    }
    return hr;
}

/////////////////////////
//myAzNewObject
// This routine creates any type of AZ objects define in ENUM_AZ_OBJECT
//
// This routine is called from COM interface wrappers.
//
/////////////////////////
HRESULT
myAzNewObject(
    IN   AZ_HANDLE hOwnerApp,
    IN   DWORD     dwOwnerAppSN,
    IN   ENUM_AZ_OBJECT enumObject,
    IN   AZ_HANDLE hObject,
    IN   VARIANT *pvarReserved,
    OUT  IUnknown  **ppObject)
/*+++
Description:
    a central place to instantiate any az com interface object
    it is used for any object creating child interface object pointer
Arguments:
    hOwnerApp  - the handle of the owner application
    dwOwnerAppSN - The sequential number of the owner app.
    enumObject - indicate what interface object is created
    hObject - a az core handle used for interface object _Init call
    pvarReserved - reserved passed from the caller
    ppObject - pointer for returned interface pointer
Return:
    *ppObject must be Release by the call if success
---*/
{
    HRESULT hr;
    CComPtr<IUnknown>               srpObject;
    CComObject<CAzApplication>      *pApp;
    CComObject<CAzApplicationGroup> *pGroup;
    CComObject<CAzOperation>        *pOperation;
    CComObject<CAzTask>             *pTask;
    CComObject<CAzScope>            *pScope;
    CComObject<CAzRole>             *pRole;
    CComObject<CAzClientContext>    *pClient;
    CComObject<CAzApplications>          *pApps;
    CComObject<CAzApplicationGroups>     *pGroups;
    CComObject<CAzOperations>            *pOperations;
    CComObject<CAzTasks>                 *pTasks;
    CComObject<CAzScopes>                *pScopes;
    CComObject<CAzRoles>                 *pRoles;

    BOOL bLockSet = FALSE;

    if (NULL == ppObject)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "Null ppObject");
    }
    AZASSERT(NULL != hObject);

    //
    //initialize
    //

    *ppObject = NULL;

    //
    // Grab the close application lock so that close
    // application does not interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );
    bLockSet = TRUE;

    if (!IsObjectUsable(hOwnerApp, dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    //
    // validate reserved parameters
    //
    hr = HandleReserved(pvarReserved );
    _JumpIfError(hr, error, "HandleReserved");

    switch (enumObject)
    {
        case ENUM_AZ_APPLICATION:
            hr = CComObject<CAzApplication>::CreateInstance(&pApp);
            _JumpIfError(hr, error, "CreateInstance");
            AZASSERT(NULL != pApp);

            //
            // this QI will also secure the object
            //

            hr = pApp->QueryInterface(&srpObject);
            _JumpIfError(hr, error, "CAzApplication::QueryInterface(IUknown**)");

            hr = pApp->_Init(hObject);
            _JumpIfError(hr, error, "Application->_Init");
        break;

        case ENUM_AZ_GROUP:
            hr = CComObject<CAzApplicationGroup>::CreateInstance(&pGroup);
            _JumpIfError(hr, error, "CreateInstance");
            AZASSERT(NULL != pGroup);

            //
            // this QI will also secure the object
            //

            hr = pGroup->QueryInterface(&srpObject);
            _JumpIfError(hr, error, "CAzApplicationGroup::QueryInterface(IUknown**)");

            hr = pGroup->_Init(hOwnerApp, hObject);
            
            _JumpIfError(hr, error, "Group->_Init");
        break;

        case ENUM_AZ_OPERATION:
            hr = CComObject<CAzOperation>::CreateInstance(&pOperation);
            _JumpIfError(hr, error, "CreateInstance");
            AZASSERT(NULL != pOperation);

            //
            // this QI will also secure the object
            //

            hr = pOperation->QueryInterface(&srpObject);
            _JumpIfError(hr, error, "CAzOperation::QueryInterface(IUknown**)");

            hr = pOperation->_Init(hOwnerApp, hObject);

            _JumpIfError(hr, error, "Operation->_Init");
        break;

        case ENUM_AZ_TASK:
            hr = CComObject<CAzTask>::CreateInstance(&pTask);
            _JumpIfError(hr, error, "CreateInstance");
            AZASSERT(NULL != pTask);

            //
            // this QI will also secure the object
            //

            hr = pTask->QueryInterface(&srpObject);
            _JumpIfError(hr, error, "CAzTask::QueryInterface(IUknown**)");

            hr = pTask->_Init(hOwnerApp, hObject);
            _JumpIfError(hr, error, "Task->_Init");
        break;

        case ENUM_AZ_SCOPE:
            hr = CComObject<CAzScope>::CreateInstance(&pScope);
            _JumpIfError(hr, error, "CreateInstance");
            AZASSERT(NULL != pScope);

            //
            // this QI will also secure the object
            //

            hr = pScope->QueryInterface(&srpObject);
            _JumpIfError(hr, error, "CAzScope::QueryInterface(IUknown**)");

            hr = pScope->_Init(hOwnerApp, hObject);

            _JumpIfError(hr, error, "Scope->_Init");
        break;

        case ENUM_AZ_ROLE:
            hr = CComObject<CAzRole>::CreateInstance(&pRole);
            _JumpIfError(hr, error, "CreateInstance");
            AZASSERT(NULL != pRole);

            //
            // this QI will also secure the object
            //

            hr = pRole->QueryInterface(&srpObject);
            _JumpIfError(hr, error, "CAzRole::QueryInterface(IUknown**)");

            hr = pRole->_Init(hOwnerApp, hObject);
            _JumpIfError(hr, error, "Role->_Init");
        break;

        case ENUM_AZ_APPLICATIONS:
            hr = CComObject<CAzApplications>::CreateInstance(&pApps);
            _JumpIfError(hr, error, "CreateInstance");
            AZASSERT(NULL != pApps);

            //
            // this QI will also secure the object
            //

            hr = pApps->QueryInterface(&srpObject);
            _JumpIfError(hr, error, "CAzApplications::QueryInterface(IUknown**)");

            hr = pApps->_Init(pvarReserved, hObject);
            _JumpIfError(hr, error, "Apps->_Init");
        break;

        case ENUM_AZ_GROUPS:
            hr = CComObject<CAzApplicationGroups>::CreateInstance(&pGroups);
            _JumpIfError(hr, error, "CreateInstance");
            AZASSERT(NULL != pGroups);

            //
            // this QI will also secure the object
            //

            hr = pGroups->QueryInterface(&srpObject);
            _JumpIfError(hr, error, "CAzApplicationGroups::QueryInterface(IUknown**)");

            hr = pGroups->_Init(hOwnerApp, pvarReserved, hObject);
            _JumpIfError(hr, error, "Groups->_Init");
        break;

        case ENUM_AZ_OPERATIONS:
            hr = CComObject<CAzOperations>::CreateInstance(&pOperations);
            _JumpIfError(hr, error, "CreateInstance");
            AZASSERT(NULL != pOperations);

            //
            // this QI will also secure the object
            //

            hr = pOperations->QueryInterface(&srpObject);
            _JumpIfError(hr, error, "CAzOperations::QueryInterface(IUknown**)");

            hr = pOperations->_Init(hOwnerApp, pvarReserved, hObject);
            _JumpIfError(hr, error, "Operations->_Init");
        break;

        case ENUM_AZ_TASKS:
            hr = CComObject<CAzTasks>::CreateInstance(&pTasks);
            _JumpIfError(hr, error, "CreateInstance");
            AZASSERT(NULL != pTasks);

            //
            // this QI will also secure the object
            //

            hr = pTasks->QueryInterface(&srpObject);
            _JumpIfError(hr, error, "CAzTasks::QueryInterface(IUknown**)");

            hr = pTasks->_Init(hOwnerApp, pvarReserved, hObject);
            _JumpIfError(hr, error, "Tasks->_Init");
        break;

        case ENUM_AZ_SCOPES:
            hr = CComObject<CAzScopes>::CreateInstance(&pScopes);
            _JumpIfError(hr, error, "CreateInstance");
            AZASSERT(NULL != pScopes);

            //
            // this QI will also secure the object
            //

            hr = pScopes->QueryInterface(&srpObject);
            _JumpIfError(hr, error, "CAzScopes::QueryInterface(IUknown**)");

            hr = pScopes->_Init(hOwnerApp, pvarReserved, hObject);
            _JumpIfError(hr, error, "Scopes->_Init");
        break;

        case ENUM_AZ_ROLES:
            hr = CComObject<CAzRoles>::CreateInstance(&pRoles);
            _JumpIfError(hr, error, "CreateInstance");
            AZASSERT(NULL != pRoles);

            //
            // this QI will also secure the object
            //

            hr = pRoles->QueryInterface(&srpObject);
            _JumpIfError(hr, error, "CAzRoles::QueryInterface(IUknown**)");

            hr = pRoles->_Init(hOwnerApp, pvarReserved, hObject);
            _JumpIfError(hr, error, "Roles->_Init");
        break;

        case ENUM_AZ_CLIENTCONTEXT:
            hr = CComObject<CAzClientContext>::CreateInstance(&pClient);
            _JumpIfError(hr, error, "CreateInstance");
            AZASSERT(NULL != pClient);

            //
            // this QI will also secure the object
            //

            hr = pClient->QueryInterface(&srpObject);
            _JumpIfError(hr, error, "CAzClientContext::QueryInterface(IUknown**)");

            hr = pClient->_Init(hOwnerApp, hObject, 0/*pvarReserved*/);
            _JumpIfError(hr, error, "ClientContext->_Init");
        break;

        default:
            AZASSERT(FALSE);
            hr = E_INVALIDARG;
            _JumpError(hr, error, "invalid object index");
        break;
    }

    //
    // Everything is fine. Let's hand it to the out parameter
    // Otherwise, the smart pointer will release its ref count automatically
    //

    *ppObject = srpObject.Detach();

    hr = S_OK;
error:

    if ( bLockSet ) {

        AzpUnlockResource( &AzGlCloseApplication );
    }

    return hr;
}


/////////////////////////
//myAzCreateObject
/////////////////////////
HRESULT
myAzCreateObject(
    IN   AZ_HANDLE hOwnerApp,
    IN   DWORD     dwOwnerAppSN,
    IN   PFUNCAzCreate pfuncAzCreate,
    IN   ENUM_AZ_OBJECT enumObject,
    IN   AZ_HANDLE hParentObject,
    IN   BSTR bstrObjectName,
    IN   VARIANT varReserved,
    OUT  IUnknown  **ppObject)
/*+++
Description:
    a subroutine for any object creating a new child object by passing
    a name. For example IAzApplication::CreateOperation and
    IAzScope::CreateTask call this routine to create a new child object
Arguments:
    hOwnerApp     - the application that owns (directly or indirectly) this new object
    dwOwnerAppSN - The sequential number of the owner app.
    pfuncAzCreate - az core object creation function pointer
    enumObject - object type
    hParentObject - from where the new child object is created
    bstrObjectName - new child object name
    varReserved - reserved variable from callers
    ppObject - interface pointer of the new object for return
Return:
    *ppObject must be Release by the caller
---*/
{
    HRESULT hr;
    DWORD   dwErr;
    AZ_HANDLE  hObject = NULL;
    BOOL bLockSet = FALSE;

    AZASSERT(NULL != pfuncAzCreate);

    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    //
    // Grab the close application lock so that close
    // application does not interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );
    bLockSet = TRUE;

    if (NULL == hParentObject)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Null parent handle");
    }
    else if (!IsObjectUsable(hOwnerApp, dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    //
    // create a new object in core cache
    // ref count is incremented for hObject by core
    //

    dwErr = pfuncAzCreate(hParentObject, bstrObjectName, 0, &hObject);

    _JumpIfWinError(dwErr, &hr, error, "Az(object)Create");
    AZASSERT(NULL != hObject);

    //
    // create a COM object to return
    //

    hr = myAzNewObject(
                hOwnerApp,
                dwOwnerAppSN,
                enumObject,
                hObject,
                &varReserved,
                ppObject);
    _JumpIfError(hr, error, "myAzNewObject");

    //
    // az object destructor will free the handle
    //
    hObject = NULL;

    hr = S_OK;

error:
    if (NULL != hObject)
    {
        AzCloseHandle(hObject, 0);
    }

    if ( bLockSet ) {

        AzpUnlockResource( &AzGlCloseApplication );

    }

    return hr;
}


/////////////////////////
//myAzDeleteObject
/////////////////////////
HRESULT
myAzDeleteObject(
    IN AZ_HANDLE    hOwnerApp,
    IN DWORD        dwOwnerAppSN,
    IN PFUNCAzDelete pfuncAzDelete,
    IN AZ_HANDLE    hParent,
    IN BSTR         bstrObjectName,
    IN VARIANT      varReserved)
/*+++
Description:
    delete a child object from az core by name
Arguments:
    hOwnerApp  - the handle of the owner app
    dwOwnerAppSN - The sequential number of the owner app.
    pfuncAzDelete - az core object delete function pointer
    hParent - parent object handle from where the child lives
    bstrObjectName - child object name
    varReserved - reserved variant passed from the caller
Return:
---*/
{
    HRESULT hr;
    DWORD   dwErr;
    BOOL bLockSet = FALSE;

    AZASSERT(NULL != pfuncAzDelete);

    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    //
    // grab the close application lock so that close application
    // does not interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );
    bLockSet = TRUE;

    if (NULL == hParent)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Null parent handle");
    }
    else if (!IsObjectUsable(hOwnerApp, dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    dwErr = pfuncAzDelete(
                hParent,
                bstrObjectName,
                0 );

    _JumpIfWinError(dwErr, &hr, error, "Az(object)Delete");

    hr = S_OK;
error:

    if ( bLockSet ) {

        AzpUnlockResource( &AzGlCloseApplication );
    }

    return hr;
}

/////////////////////////
//myAzOpenObject
/////////////////////////
HRESULT
myAzOpenObject(
    IN   AZ_HANDLE hOwnerApp,
    IN   DWORD dwOwnerAppSN,
    IN   PFUNCAzOpen pfuncAzOpen,
    IN   ENUM_AZ_OBJECT enumObject,
    IN   AZ_HANDLE hParentObject,
    IN   BSTR bstrObjectName,
    IN   VARIANT varReserved,
    OUT  IUnknown  **ppObject)
/*+++
Description:
    a subroutine for any object opening a new child object by passing
    a name. For example IAzApplication::OpenOperation and
    IAzScope::OpenTask call this routine to create a new child object
Arguments:
    hOwnerApp   - the application that owns (directly or indirectly) this new object
    dwOwnerAppSN - The sequential number of the owner app.
    pfuncAzOpen - az core object open function pointer
    enumObject - object type
    hParentObject - from where the child object lives
    bstrObjectName - child object name
    varReserved - reserved variable from callers
    ppObject - interface pointer of the opened object for return
Return:
    *ppObject must be Release by the caller
---*/
{
    HRESULT hr;
    DWORD   dwErr;
    AZ_HANDLE  hObject = NULL;
    BOOL bLockSet = FALSE;

    AZASSERT(NULL != pfuncAzOpen);

    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    //
    // Grab the close application lock so that close
    // application does not interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );
    bLockSet = TRUE;

    if (NULL == hParentObject)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Null parent handle");
    }
    else if (!IsObjectUsable(hOwnerApp, dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    //open existing object
    dwErr = pfuncAzOpen(hParentObject, bstrObjectName, 0, &hObject);
    _JumpIfWinError(dwErr, &hr, error, "Az(object)Open");
    AZASSERT(NULL != hObject);

    hr = myAzNewObject(hOwnerApp, dwOwnerAppSN, enumObject, hObject, NULL, ppObject);
    _JumpIfError(hr, error, "myAzNewObject");

    // az object destructor will free the handle
    hObject = NULL;

    hr = S_OK;
error:
    if (NULL != hObject)
    {
        AzCloseHandle(hObject, 0);
    }

    if ( bLockSet ) {

        AzpUnlockResource( &AzGlCloseApplication );
    }

    return hr;
}


/////////////////////////
//myAzCloseObject
/////////////////////////
HRESULT
myAzCloseObject(
    IN PFUNCAzClose pfuncAzClose,
    IN AZ_HANDLE hParentObject,
    IN BSTR bstrObjectName,
    IN LONG lFlags
    )
/*++

Description:
       
    This routine is used to close any object from cache.  For example,
    to unload an AzApplication object from cache.  
    IAzAuthorizationStore::CloseApplication will call this routine for example.

Arguments:

    pfuncAzClose - Az core object close function pointer
    hParentObject - parent of the Clild object being closed
    bstrObjectName - Name of the object being closed
    varReserved - Reserved variable for callers

Return:

    S_OK if the object was unloaded from the cache

--*/
{

    HRESULT hr;
    DWORD dwErr;

    AZASSERT( pfuncAzClose != NULL );

    //
    // close the object
    //

    //
    // Grab the close application lock so that no other routine
    // interferes
    //

    AzpLockResourceExclusive( &AzGlCloseApplication );

    dwErr = pfuncAzClose(hParentObject, bstrObjectName, lFlags);

    AzpUnlockResource( &AzGlCloseApplication );

    _JumpIfWinError( dwErr, &hr, error, "Az(object)Close");

    hr = S_OK;

error:

    return hr;
}

/////////////////////////
//myAzNextObject
/////////////////////////
HRESULT
myAzNextObject(
    IN     AZ_HANDLE hOwnerApp,
    IN     DWORD dwOwnerAppSN, 
    IN     PFUNCAzEnum pfuncAzEnum,
    IN OPTIONAL VARIANT *pvarReserved,
    IN     ENUM_AZ_OBJECT enumObject,
    IN     AZ_HANDLE hParent,
    IN OUT PULONG  plContext,
    OUT    IUnknown **ppObject)
/*+++
Description:
    a sub-routine to enumerate object handles for collection interface
    object initialization. all collection class _Init routines call this
    subroutine
Arguments:
    hOwnerApp   - the application that owns (directly or indirectly) this new object
    dwOwnerAppSN - The sequential number of the owner app.
    pfuncAzEnum - az core object enumeration function pointer
    pvarReserved - reserved variant passed from the caller
    enumObject - object type
    hParent - parent object handle
    plContext - the context for core enumeration
    ppObject - interface pointer of the opened object for return
Return:
    *ppObject must be Release by the caller
---*/
{
    HRESULT  hr;
    AZ_HANDLE hObject = NULL;
    DWORD    dwErr;

    AZASSERT(NULL != pfuncAzEnum);

    hr = HandleReserved(pvarReserved );
    _JumpIfError(hr, error, "HandleReserved");

    //enum to next object

    //
    // Grab the CloseApplication lock to maintain order
    //

    AzpLockResourceShared( &AzGlCloseApplication );
    dwErr = pfuncAzEnum(hParent, 0, plContext, &hObject);
    AzpUnlockResource( &AzGlCloseApplication );

    _JumpIfWinError(dwErr, &hr, error, "Az(object)Enum");

    hr = myAzNewObject(hOwnerApp, dwOwnerAppSN, enumObject, hObject, NULL, ppObject);
    _JumpIfError(hr, error, "myAzNewObject");

    // az object destructor will free the handle
    hObject = NULL;

    hr = S_OK;
error:
    if (NULL != hObject)
    {
        AzpLockResourceShared( &AzGlCloseApplication );
        AzCloseHandle(hObject, 0);
        AzpUnlockResource( &AzGlCloseApplication );
    }
    return hr;
}


HRESULT
myAzGetPropertyDataType(
    IN   LONG  lPropId,
    OUT  ENUM_AZ_DATATYPE *pDataType)
/*+++
Description:
    a routine to map property ID to a data type
Arguments:
    lPropId - property ID
    pDataType - pointer to hold data type
Return:
---*/
{
    HRESULT  hr;
    ENUM_AZ_DATATYPE  dataType;

    // check property ID and assign data type
    switch (lPropId)
    {
        case AZ_PROP_NAME:
        case AZ_PROP_DESCRIPTION:
        case AZ_PROP_APPLICATION_DATA:
        case AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID:
        case AZ_PROP_APPLICATION_VERSION:
        case AZ_PROP_TASK_BIZRULE:
        case AZ_PROP_TASK_BIZRULE_LANGUAGE:
        case AZ_PROP_TASK_BIZRULE_IMPORTED_PATH:
        case AZ_PROP_GROUP_LDAP_QUERY:
        case AZ_PROP_CLIENT_CONTEXT_USER_DN:
        case AZ_PROP_CLIENT_CONTEXT_USER_SAM_COMPAT:
        case AZ_PROP_CLIENT_CONTEXT_USER_DISPLAY:
        case AZ_PROP_CLIENT_CONTEXT_USER_GUID:
        case AZ_PROP_CLIENT_CONTEXT_USER_CANONICAL:
        case AZ_PROP_CLIENT_CONTEXT_USER_UPN:
        case AZ_PROP_CLIENT_CONTEXT_USER_DNS_SAM_COMPAT:
        case AZ_PROP_AZSTORE_TARGET_MACHINE:
        case AZ_PROP_CLIENT_CONTEXT_ROLE_FOR_ACCESS_CHECK:
            dataType = ENUM_AZ_BSTR;
        break;

        case AZ_PROP_AZSTORE_DOMAIN_TIMEOUT:
        case AZ_PROP_AZSTORE_SCRIPT_ENGINE_TIMEOUT:
        case AZ_PROP_AZSTORE_MAX_SCRIPT_ENGINES:
        case AZ_PROP_OPERATION_ID:
        case AZ_PROP_GROUP_TYPE:
        //case AZ_PROP_AZSTORE_MAJOR_VERSION: make it invisible to clients
        //case AZ_PROP_AZSTORE_MINOR_VERSION: make it invisible to clients
            dataType = ENUM_AZ_LONG;
        break;

        case AZ_PROP_TASK_OPERATIONS:
        case AZ_PROP_TASK_TASKS:
        case AZ_PROP_GROUP_APP_MEMBERS:
        case AZ_PROP_GROUP_APP_NON_MEMBERS:
        case AZ_PROP_ROLE_APP_MEMBERS:
        case AZ_PROP_ROLE_OPERATIONS:
        case AZ_PROP_ROLE_TASKS:
            dataType = ENUM_AZ_BSTR_ARRAY;
        break;

        case AZ_PROP_GROUP_MEMBERS:
        case AZ_PROP_GROUP_NON_MEMBERS:
        case AZ_PROP_ROLE_MEMBERS:
        case AZ_PROP_POLICY_ADMINS:
        case AZ_PROP_POLICY_READERS:
        case AZ_PROP_DELEGATED_POLICY_USERS:
        case AZ_PROP_GROUP_MEMBERS_NAME:
        case AZ_PROP_GROUP_NON_MEMBERS_NAME:
        case AZ_PROP_ROLE_MEMBERS_NAME:
        case AZ_PROP_POLICY_ADMINS_NAME:
        case AZ_PROP_POLICY_READERS_NAME:
        case AZ_PROP_DELEGATED_POLICY_USERS_NAME:
            dataType = ENUM_AZ_SID_ARRAY;
        break;

        case AZ_PROP_TASK_IS_ROLE_DEFINITION:
        case AZ_PROP_WRITABLE:
        case AZ_PROP_APPLY_STORE_SACL:
        case AZ_PROP_GENERATE_AUDITS:
        case AZ_PROP_SCOPE_BIZRULES_WRITABLE:
        case AZ_PROP_SCOPE_CAN_BE_DELEGATED:
        case AZ_PROP_CHILD_CREATE:

            dataType = ENUM_AZ_BOOL;
        break;

        default:
            hr = E_INVALIDARG;
            _JumpError(hr, error, "invalid property ID");
        break;
    }

    *pDataType = dataType;

    hr = S_OK;
error:
    return hr;
}

/////////////////////////
//myAzGetProperty
/////////////////////////
HRESULT
myAzGetProperty(
    IN   AZ_HANDLE hOwnerApp,
    IN   DWORD dwOwnerAppSN,
    IN   AZ_HANDLE hObject,
    IN   LONG  lPropId,
    IN   VARIANT varReserved,
    OUT  VARIANT *pvarProp)
/*+++
Description:
    retrieve az core object property and convert property data into
    variant for interface object
    all object GetProperty eventually call this routine as well as individual
    property
Arguments:
    hOwnerApp    - the application that owns (directly or indirectly) this new object
    dwOwnerAppSN - The sequential number of the owner app.
    hObject - az core object handle
    lPropId - property ID
    varReserved - reserved varaint passed in by caller
    pvarProp - point to variant to hold returned property data
Return:
    pvarProp should freed by VariantClear
---*/
{
    HRESULT hr;
    DWORD   dwErr;
    PVOID   pProp = NULL;
    BSTR    bstrProp;
    VARIANT varProp;
    VARIANT TempVariant;
    AZ_STRING_ARRAY *pStringArray;
    AZ_SID_ARRAY    *pSidArray;
    WCHAR           *pwszSidOrName = NULL;
    SAFEARRAYBOUND   rgsaBound[1]; //one dimension array
    SAFEARRAY       *psaString = NULL;
    long             lArrayIndex[1]; //one dimension
    DWORD            i;
    ENUM_AZ_DATATYPE dataType;
    BOOL bConvertSidToName;
    HANDLE hDS = NULL;
    LONG lPersistPropID = lPropId;
    BOOL bLockSet = FALSE;

    VariantInit( &TempVariant );
    VariantInit(&varProp);

    if (NULL == pvarProp)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "Null pvarProp");
    }

    //init
    VariantInit(pvarProp);

    //
    // grab the lock so that close application cannot interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );
    bLockSet = TRUE;

    if (NULL == hObject)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Null object handle");
    }
    else if (!IsObjectUsable(hOwnerApp, dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    // determine the type of data
    hr = myAzGetPropertyDataType(lPropId, &dataType);
    _JumpIfError(hr, error, "myAzGetPropertyDataType");

    //
    // When we receive request for the names for those properties
    // that are persisted using SIDs, we simply map these name properties
    // to their SID counterparties. This routines does the check and
    // conversion if neede. In any case, the out parameter is always the
    // SID property ID so that we don't have to modify any core functions.
    //

    bConvertSidToName = myNeedSidToNameConversion(lPropId, &lPersistPropID);

    dwErr = AzGetProperty(
            hObject,
            lPersistPropID,
            0,
            &pProp);
    _JumpIfWinError(dwErr, &hr, error, "Az(object)GetProperty");
    AZASSERT(NULL != pProp);

    switch (dataType)
    {
        case ENUM_AZ_BSTR:
            bstrProp = SysAllocString((WCHAR*)pProp);
            _JumpIfOutOfMemory(&hr, error, bstrProp, "SysAllocString");
            //for return
            varProp.vt = VT_BSTR;
            varProp.bstrVal = bstrProp;
        break;

        case ENUM_AZ_LONG:
            //for return
            varProp.vt = VT_I4;
            varProp.lVal = *((LONG*)pProp);
        break;

        case ENUM_AZ_BOOL:
            //for return
            varProp.vt = VT_BOOL;
            if (*((LONG*)pProp))
            {
                varProp.boolVal = VARIANT_TRUE;
            }
            else
            {
                varProp.boolVal = VARIANT_FALSE;
            }
        break;

        case ENUM_AZ_SID_ARRAY:
            pSidArray = (AZ_SID_ARRAY*)pProp;
            rgsaBound[0].lLbound = 0; //array index from 0
            rgsaBound[0].cElements = pSidArray->SidCount;

            //create array descriptor
            psaString = SafeArrayCreate(
                    VT_VARIANT,  //base type of array element
                    1,        //count of bound, ie. one dimension
                    rgsaBound);
            _JumpIfOutOfMemory(&hr, error, psaString, "SafeArrayCreate");

            //init to 1st element
            lArrayIndex[0] = 0;

            if (bConvertSidToName)
            {
                dwErr = DsBind(NULL, NULL, &hDS);
                if (NO_ERROR != dwErr && ERROR_NOT_ENOUGH_MEMORY != dwErr)
                {
                    //
                    // we will quietly fail and give the user the NT4 style name
                    //

                    AzPrint((AZD_ALL, "Can't DS bind. Will just return non-UPN names\n"));
                    dwErr = NO_ERROR;
                }
                else if (ERROR_NOT_ENOUGH_MEMORY == dwErr)
                {
                    hr = E_OUTOFMEMORY;
                    _JumpIfError(hr, error, "DsBind");
                }
            }

            //loop to load and put strings
            for (i = 0; i < pSidArray->SidCount; ++i)
            {
                BOOL bUseSid = !bConvertSidToName;
                if (bConvertSidToName)
                {
                    hr = mySidToName(hDS, pSidArray->Sids[i], &pwszSidOrName);

                    //
                    // for whatever reason we failed to get the name, then we will give SID
                    //

                    if ( FAILED(hr) )
                    {
                        bUseSid = TRUE;
                        hr = S_OK;
                    }
                }

                if (bUseSid && !ConvertSidToStringSid(pSidArray->Sids[i], &pwszSidOrName))
                {
                    AZ_HRESULT_LASTERROR(&hr);
                    _JumpError(hr, error, "ConvertSidToStringSid");
                }

                //then, create an element in BSTR
                bstrProp = SysAllocString(pwszSidOrName);
                _JumpIfOutOfMemory(&hr, error, bstrProp, "SysAllocString");

                //
                // Fill in a temporary variant
                //
                VariantClear( &TempVariant );
                V_VT(&TempVariant) = VT_BSTR;
                V_BSTR(&TempVariant) = bstrProp;

                //put into array
                hr = SafeArrayPutElement(psaString, lArrayIndex, &TempVariant );
                _JumpIfError(hr, error, "SafeArrayPutElement");

                //adjust index for the next element in array
                ++(lArrayIndex[0]);

                //make sure memory is freed
                AZASSERT(NULL != pwszSidOrName);
                LocalFree(pwszSidOrName);
                pwszSidOrName = NULL;
            }

            //for return
            varProp.vt = VT_ARRAY | VT_VARIANT;
            varProp.parray = psaString;
            psaString = NULL;
            break;

        case ENUM_AZ_BSTR_ARRAY:
            pStringArray = (AZ_STRING_ARRAY*)pProp;
            rgsaBound[0].lLbound = 0; //array index from 0
            rgsaBound[0].cElements = pStringArray->StringCount;

            //create array descriptor
            psaString = SafeArrayCreate(
                    VT_VARIANT,  //base type of array element
                    1,        //count of bound, ie. one dimension
                    rgsaBound);
            _JumpIfOutOfMemory(&hr, error, psaString, "SafeArrayCreate");

            //init to 1st element
            lArrayIndex[0] = 0;


            //loop to load and put strings
            for (i = 0; i < pStringArray->StringCount; ++i)
            {
                //1st, create an element in BSTR
                bstrProp = SysAllocString(pStringArray->Strings[i]);
                _JumpIfOutOfMemory(&hr, error, bstrProp, "SysAllocString");

                //
                // Fill in a temporary variant
                //
                VariantClear( &TempVariant );
                V_VT(&TempVariant) = VT_BSTR;
                V_BSTR(&TempVariant) = bstrProp;


                //put into array
                hr = SafeArrayPutElement(psaString, lArrayIndex, &TempVariant);
                _JumpIfError(hr, error, "SafeArrayPutElement");

                //adjust index for the next element in array
                ++(lArrayIndex[0]);
            }

            //for return
            varProp.vt = VT_ARRAY | VT_VARIANT;
            varProp.parray = psaString;
            psaString = NULL;
        break;

        default:
            hr = E_INVALIDARG;
            _JumpError(hr, error, "invalid data type index");
        break;
    }

    //return
    *pvarProp = varProp;

    hr = S_OK;
error:
    if (NULL != pProp)
    {
        AzFreeMemory(pProp);
    }
    if (NULL != pwszSidOrName)
    {
        LocalFree(pwszSidOrName);
    }
    if (NULL != psaString)
    {
        SafeArrayDestroy(psaString);
    }
    VariantClear( &TempVariant );

    if (hDS != NULL)
    {
        DsUnBind(&hDS);
    }

    if ( bLockSet ) {

        AzpUnlockResource( &AzGlCloseApplication );
    }

    return hr;
}


/////////////////////////
//myAzSetProperty
/////////////////////////
HRESULT
myAzSetProperty(
    IN   AZ_HANDLE hOwnerApp,
    IN   DWORD dwOwnerAppSN,
    IN   AZ_HANDLE hObject,
    IN   LONG  lPropId,
    IN   VARIANT varReserved,
    IN   VARIANT *pvarProp)
/*+++
Description:
    convert interface caller property data and set it to az core object
    all object SetProperty methods call this routine as well as individual
    property
Arguments:
    hOwnerApp - The handle to the applicatio this hObject is owned.
    dwOwnerAppSN - The sequential number of the owner app.
    hObject - az core object handle
    lPropId - property ID
    varReserved - reserved variant passed from caller
    pvarProp - variant property value
Return:

---*/
{
    HRESULT hr;
    DWORD   dwErr;
    PVOID   pProp;
    VARIANT varProp;
    ENUM_AZ_DATATYPE dataType;
    LONG    lBoolVal = 0;

    ::VariantInit(&varProp);

    //
    // grab the lock so that close application cannot interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );

    if (NULL == hObject)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Null object handle");
    }
    else if (!IsObjectUsable(hOwnerApp, dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    if (NULL == pvarProp)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "Null pvarProp");
    }
    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    // determine the type of data
    hr = myAzGetPropertyDataType(lPropId, &dataType);
    _JumpIfError(hr, error, "myAzGetPropertyDataType");

    //pvarProp is from applications, use try/except for any violation params
    __try
    {
        switch (dataType)
        {
            case ENUM_AZ_BSTR:
                hr = VariantChangeType(&varProp, pvarProp, 0, VT_BSTR);
                _JumpIfError(hr, error, "VariantChangeType");
                
                //
                // Prevent invalid characters being used.
                //
                
                hr = myVerifyBSTRData(varProp.bstrVal);
                _JumpIfError(hr, error, "myVerifyBSTRData");
                
                pProp = (PVOID)varProp.bstrVal;
            break;

            case ENUM_AZ_LONG:
                hr = VariantChangeType(&varProp, pvarProp, 0, VT_UI4);
                _JumpIfError(hr, error, "VariantChangeType");
                pProp = (PVOID)&(varProp.ulVal);
            break;

            case ENUM_AZ_BOOL:
                hr = VariantChangeType(&varProp, pvarProp, 0, VT_BOOL);
                _JumpIfError(hr, error, "VariantChangeType");
                lBoolVal = (varProp.boolVal == VARIANT_TRUE) ? 1 : 0;
                pProp = (PVOID)&(lBoolVal);
            break;

            default:
                hr = E_INVALIDARG;
                _JumpError(hr, error, "invalid data type index");
            break;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = AZ_HRESULT(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "VariantChangeType-exception");
    }

    // now real app properties
    dwErr = AzSetProperty(
                hObject,
                lPropId,
                0,
                pProp);
    _JumpIfWinError(dwErr, &hr, error, "Az(object)SetProperty");

    hr = S_OK;
error:
    VariantClear(&varProp);

    AzpUnlockResource( &AzGlCloseApplication );

    return hr;
}


/////////////////////////
//myAzAddOrDeletePropertyItem
/////////////////////////
HRESULT
myAzAddOrDeletePropertyItem(
    IN   AZ_HANDLE hOwnerApp, 
    IN   DWORD dwOwnerAppSN,
    IN   PFUNCAzAddPropertyItem pfuncAddPropertyItem,
    IN   PFUNCAzRemovePropertyItem pfuncRemovePropertyItem,
    IN   AZ_HANDLE hObject,
    IN   LONG  lPropId,
    IN   VARIANT varReserved,
    IN   VARIANT *pvarProp)
/*+++
Description:
    routine to convert variant property item from interface caller and
    add or delete the item from az core object
Arguments:
    hOwnerApp - the handle of the application that owns this object.
    dwOwnerAppSN - The sequential number of the owner app.
    pfuncAddPropertyItem - object core property item add function pointer
                if NULL, pfuncRemovePropertyItem will be checked for deletion
    pfuncRemovePropertyItem - object core property item deletion function
                pointer, pfuncAddPropertyItem must be NULL if it is deletion
    hObject - object handle from which property items live
    lPropId - property ID
    varReserved - reserved variant passed from caller
    pvarProp - pointer to variant property value to be added/deleted
Return:

---*/
{
    HRESULT hr;
    DWORD   dwErr;
    PVOID   pProp;
    PSID    pSid = NULL;
    VARIANT varProp;
    ENUM_AZ_DATATYPE dataType;
    BOOL    fAdd = (NULL != pfuncAddPropertyItem);
    LONG lPersistPropID = lPropId;

    VariantInit(&varProp);

    //
    // grab the lock so that close application cannot interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );

    if (NULL == hObject)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Null object handle");
    }
    else if (!IsObjectUsable(hOwnerApp, dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    if (NULL == pvarProp)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "Null pvarProp");
    }

    if (!fAdd && NULL == pfuncRemovePropertyItem)
    {
        // must be delete
        hr = E_INVALIDARG;
        _JumpError(hr, error, "null function pinter");
    }

    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    // determine the type of data
    hr = myAzGetPropertyDataType(lPropId, &dataType);
    _JumpIfError(hr, error, "myAzGetPropertyDataType");


    //pvarProp is from applications, use try/except for any violation params
    __try
    {
        //convert to bstr variant any way
        hr = VariantChangeType(
                    &varProp,
                    pvarProp,
                    0,
                    VT_BSTR);
        _JumpIfError(hr, error, "VariantChangeType");
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = AZ_HRESULT(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "VariantChangeType-exception");
    }

    switch (dataType)
    {
        case ENUM_AZ_BSTR_ARRAY:
        
            //
            // If we are adding, we need to check the validity of the BSTR
            //  to disallow out of range characters
            //
            
            if (fAdd)
            {
                hr = myVerifyBSTRData(varProp.bstrVal);
                _JumpIfError(hr, error, "myVerifyBSTRData");
            }
            
            pProp = (PVOID)varProp.bstrVal;
        break;

        case ENUM_AZ_SID_ARRAY:

            //
            // Some properties are persisted as SID arrays, but
            // we need to convert them to names
            //

            if (!myNeedSidToNameConversion(lPropId, &lPersistPropID))
            {
                //convert string sid to sid
                if (!ConvertStringSidToSid(varProp.bstrVal, &pSid))
                {
                    hr = AZ_HR_FROM_WIN32(GetLastError());
                    _JumpError(hr, error, "myUserNameToSid");
                }
            }
            else
            {
                //
                // we will assume it to be a account name
                //

                hr = myAccountNameToSid(varProp.bstrVal, &pSid);
                _JumpIfError(hr, error, "myAccountNameToSid");
            }
            pProp = (PVOID)pSid;
        break;

        default:
            hr = E_INVALIDARG;
            _JumpError(hr, error, "invalid data type index");
        break;
    }

    if (fAdd)
    {
        // now real app properties
        dwErr = pfuncAddPropertyItem(
                    hObject,
                    lPersistPropID,
                    0,
                    pProp);
        _JumpIfWinError(dwErr, &hr, error, "Az(object)AddPropertyItem");
    }
    else
    {
        dwErr = pfuncRemovePropertyItem(
                    hObject,
                    lPersistPropID,
                    0,
                    pProp);
        _JumpIfWinError(dwErr, &hr, error, "Az(object)RemovePropertyItem");
    }

    hr = S_OK;
error:
    VariantClear(&varProp);
    if (NULL != pSid)
    {
        LocalFree(pSid);
    }

    AzpUnlockResource( &AzGlCloseApplication );

    return hr;
}


/////////////////////////
//myAzAddPropertyItem
/////////////////////////
inline HRESULT
myAzAddPropertyItem(
    IN   AZ_HANDLE hOwnerApp, 
    IN   DWORD dwOwnerAppSN,
    IN   AZ_HANDLE hObject,
    IN   LONG  lPropId,
    IN   VARIANT varReserved,
    IN   VARIANT *pvarProp)
/*+++
Description:
    wraper api for property item add
Arguments:
    hOwnerApp - the handle of the application that owns this object.
    dwOwnerAppSN - The sequential number of the owner app.
    hObject - object handle from which property items live
    lPropId - property ID
    varReserved - reserved variant passed from caller
    pvarProp - pointer to variant property value to be added
Return:
---*/
{
    return myAzAddOrDeletePropertyItem(
                hOwnerApp, 
                dwOwnerAppSN,
                AzAddPropertyItem,
                NULL, // not delete
                hObject,
                lPropId,
                varReserved,
                pvarProp);
}


/////////////////////////
//myAzDeletePropertyItem
/////////////////////////
inline HRESULT
myAzDeletePropertyItem(
    IN   AZ_HANDLE hOwnerApp, 
    IN   DWORD dwOwnerAppSN,
    IN   AZ_HANDLE hObject,
    IN   LONG  lPropId,
    IN   VARIANT varReserved,
    IN   VARIANT *pvarProp)
/*+++
Description:
    wraper api for property item deletion
Arguments:
    hOwnerApp - the handle of the application that owns this object.
    dwOwnerAppSN - The sequential number of the owner app.
    hObject - object handle from which property items live
    lPropId - property ID
    varReserved - reserved variant passed from caller
    pvarProp - pointer to variant property value to be deleted
Return:
---*/
{
    return myAzAddOrDeletePropertyItem(
                hOwnerApp, 
                dwOwnerAppSN,
                NULL,  // not add
                AzRemovePropertyItem,
                hObject,
                lPropId,
                varReserved,
                pvarProp);
}

/////////////////////////
//myAzAddPropertyItemBstr
/////////////////////////
HRESULT
myAzAddPropertyItemBstr(
    IN   AZ_HANDLE hOwnerApp, 
    IN   DWORD dwOwnerAppSN,
    IN   AZ_HANDLE hObject,
    IN   LONG  lPropId,
    IN   VARIANT varReserved,
    IN   BSTR    bstrItem)
/*+++
Description:
    wraper api for BSTR property item add
Arguments:
    hOwnerApp - the handle of the application that owns this object.
    dwOwnerAppSN - The sequential number of the owner app.
    hObject - object handle from which property items live
    lPropId - property ID
    varReserved - reserved variant passed from caller
    bstrItem - BSTR property value to be added
Return:
---*/
{
    VARIANT  varItem;

    VariantInit(&varItem);
    V_VT(&varItem) = VT_BSTR;
    V_BSTR(&varItem) = bstrItem;

    return myAzAddPropertyItem(
                hOwnerApp, 
                dwOwnerAppSN,
                hObject,
                lPropId,
                varReserved,
                &varItem);
}


/////////////////////////
//myAzDeletePropertyItemBstr
/////////////////////////
HRESULT
myAzDeletePropertyItemBstr(
    IN   AZ_HANDLE hOwnerApp, 
    IN   DWORD dwOwnerAppSN,
    IN   AZ_HANDLE hObject,
    IN   LONG  lPropId,
    IN   VARIANT varReserved,
    IN   BSTR    bstrItem)
/*+++
Description:
    wraper api for BSTR property item deletion
Arguments:
    hOwnerApp - the handle of the application that owns this object.
    dwOwnerAppSN - The sequential number of the owner app.
    hObject - object handle from which property items live
    lPropId - property ID
    varReserved - reserved variant passed from caller
    bstrItem - BSTR property value to be deleted
Return:
---*/
{
    VARIANT  varItem;

    VariantInit(&varItem);
    V_VT(&varItem) = VT_BSTR;
    V_BSTR(&varItem) = bstrItem;

    return myAzDeletePropertyItem(
                hOwnerApp, 
                dwOwnerAppSN,
                hObject,
                lPropId,
                varReserved,
                &varItem);
}

HRESULT
myAzAddOrDeleteUser(
    IN   AZ_HANDLE hOwnerApp, 
    IN   DWORD dwOwnerAppSN,
    IN AZ_HANDLE  hObject,
    IN ULONG      lPropId,
    IN VARIANT    varReserved,
    IN BSTR       bstrUser,
    IN BOOL       fAdd)
/*+++
Description:
    This routine is a wrapper api to modify (add/remove) properties of policy
    readers and policy admins SID list.

    This routine has a special quick check on ACL support from the store. If
    underlying store does not support ACL (e.g., FAT system), this API will
    block the attempt to add or delete policy admins/readers.

Arguments:
    hOwnerApp    - the handle of the application that owns this object.

    dwOwnerAppSN - The sequential number of the owner app.

    hObject     - object handle from which property items live

    lPropId     - property ID

    varReserved - reserved variant passed from caller

    bstrUser    - user SID in BSTR

    fAdd        - TRUE if add & FALSE if delete

Return:

---*/
{
    HRESULT  hr;

    if (fAdd)
    {
        hr = myAzAddPropertyItemBstr(
                    hOwnerApp, 
                    dwOwnerAppSN,
                    hObject,
                    lPropId,
                    varReserved,
                    bstrUser);
        _JumpIfError(hr, error, "myAzAddPropertyItemBstr");
    }
    else
    {
        hr = myAzDeletePropertyItemBstr(
                    hOwnerApp, 
                    dwOwnerAppSN,
                    hObject,
                    lPropId,
                    varReserved,
                    bstrUser);
        _JumpIfError(hr, error, "myAzDeletePropertyItemBstr");
    }

    hr = S_OK;
error:
    return hr;
}

HRESULT
myGetBstrProperty(
    IN   AZ_HANDLE hOwnerApp, 
    IN   DWORD dwOwnerAppSN,
    IN   AZ_HANDLE hObject,
    IN   LONG  lPropId,
    OUT  BSTR  *pbstrProp)
/*+++
Description:
    wraper routine to get any BSTR property
Arguments:
    hOwnerApp - the handle of the application that owns this object.
    dwOwnerAppSN - The sequential number of the owner app.
    hObject - az core object handle
    lPropId - property ID
    pbstrProp - point to BSTR to hold returned property data
Return:
    pbstrProp should freed by SysFreeString
---*/
{
    HRESULT  hr;
    DWORD    dwErr;
    PVOID    pProp = NULL;
    BOOL     bLockSet = FALSE;

    if (NULL == pbstrProp)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "invalid null parameter");
    }

    //init
    *pbstrProp = NULL;

    //
    // Grab the close application lock so that close application
    // does not interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );
    bLockSet = TRUE;

    if (!IsObjectUsable(hOwnerApp, dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    dwErr = AzGetProperty(
                hObject,
                lPropId,
                0,
                (PVOID*)&pProp);
    _JumpIfWinError(dwErr, &hr, error, "(object)GetProperty");

    AZASSERT(NULL != pProp);

    *pbstrProp = SysAllocString((WCHAR*)pProp);
    _JumpIfOutOfMemory(&hr, error, *pbstrProp, "SysAllocString");

    hr = S_OK;
error:
    if (NULL != pProp)
    {
        AzFreeMemory(pProp );
    }

    if ( bLockSet ) {

        AzpUnlockResource( &AzGlCloseApplication );
    }

    return hr;
}

HRESULT
mySetBstrProperty(
    IN   AZ_HANDLE hOwnerApp, 
    IN   DWORD dwOwnerAppSN,
    IN  AZ_HANDLE hObject,
    IN  LONG  lPropId,
    IN  BSTR  bstrProp)
/*+++
Description:
    warper routine to set BSTR property
Arguments:
    hOwnerApp - the handle of the application that owns this object.
    dwOwnerAppSN - The sequential number of the owner app.
    hObject - az core object handle
    lPropId - property ID
    bstrProp - BSTR property data
Return:
---*/
{
    HRESULT  hr;
    DWORD    dwErr;

    //
    // Lock the close application lock so that close
    // application does not interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );

    if (!IsObjectUsable(hOwnerApp, dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }
    
    hr = myVerifyBSTRData(bstrProp);
    _JumpIfError(hr, error, "myVerifyBSTRData");

    dwErr = AzSetProperty(
                hObject,
                lPropId,
                0,
                (PVOID)bstrProp);       // bstr is wchar * at nominal address
    _JumpIfWinError(dwErr, &hr, error, "(object)SetProperty");

    hr = S_OK;
error:

    AzpUnlockResource( &AzGlCloseApplication );

    return hr;
}

HRESULT
myGetLongProperty(
    IN   AZ_HANDLE hOwnerApp, 
    IN   DWORD dwOwnerAppSN,
    IN   AZ_HANDLE hObject,
    IN   LONG  lPropId,
    OUT  LONG  *plProp)
/*+++
Description:
    wraper routine to get any LONG property
Arguments:
    hOwnerApp - the handle of the application that owns this object.
    dwOwnerAppSN - The sequential number of the owner app.
    hObject - az core object handle
    lPropId - property ID
    plProp - point to LONG to hold returned property data
Return:
---*/
{
    HRESULT  hr;
    DWORD    dwErr;
    PVOID    pProp = NULL;
    BOOL     bLockSet = FALSE;

    if (NULL == plProp)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "invalid null parameter");
    }

    // init
    *plProp = 0;

    //
    // grab the lock so that close application does not interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );
    bLockSet = TRUE;

    if (!IsObjectUsable(hOwnerApp, dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    // get data into buffer at temporary pointer
    dwErr = AzGetProperty(
                hObject,
                lPropId,
                0,
                (PVOID*)&pProp);
    _JumpIfWinError(dwErr, &hr, error, "(object)GetProperty");

    AZASSERT(NULL != pProp);

    *plProp = *((LONG *)pProp);
    hr = S_OK;
error:
    if (NULL != pProp)
    {
        AzFreeMemory(pProp);
    }

    if ( bLockSet ) {

        AzpUnlockResource( &AzGlCloseApplication );
    }

    return hr;
}

HRESULT
mySetLongProperty(
    IN   AZ_HANDLE hOwnerApp, 
    IN   DWORD dwOwnerAppSN,
    IN  AZ_HANDLE hObject,
    IN  LONG  lPropId,
    IN  LONG  lProp)
/*+++
Description:
    warper routine to set LONG property
Arguments:
    hOwnerApp - the handle of the application that owns this object.
    dwOwnerAppSN - The sequential number of the owner app.
    hObject - az core object handle
    lPropId - property ID
    lProp - LONG property data
Return:
---*/
{
    HRESULT  hr;
    DWORD    dwErr;
    BOOL     bLockSet = FALSE;

    //
    // Grab the lock so that close application cannot interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );
    bLockSet = TRUE;

    if (!IsObjectUsable(hOwnerApp, dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    dwErr = AzSetProperty(
                hObject,
                lPropId,
                0,
                (PVOID)&lProp);
    _JumpIfWinError(dwErr, &hr, error, "(object)SetProperty");

    hr = S_OK;
error:

    if ( bLockSet ) {

        AzpUnlockResource( &AzGlCloseApplication );
    }

    return hr;
}

HRESULT
myGetBoolProperty(
    IN   AZ_HANDLE hOwnerApp, 
    IN   DWORD dwOwnerAppSN,
    IN   AZ_HANDLE hObject,
    IN   LONG  lPropId,
    OUT  BOOL  *plProp)
/*+++
Description:
    wraper routine to get any BOOL property
Arguments:
    hOwnerApp - the handle of the application that owns this object.
    dwOwnerAppSN - The sequential number of the owner app.
    hObject - az core object handle
    lPropId - property ID
    plProp - point to BOOL to hold returned property data
Return:
---*/
{
    HRESULT  hr;
    DWORD    dwErr;
    PVOID    pProp = NULL;
    BOOL     bLockSet = FALSE;

    if (NULL == plProp)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "invalid null parameter");
    }

    // init
    *plProp = FALSE;

    //
    // Grab the close application lock so that close
    // application does not interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );
    bLockSet = TRUE;

    if (!IsObjectUsable(hOwnerApp, dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    // get data into buffer at temporary pointer
    dwErr = AzGetProperty(
                hObject,
                lPropId,
                0,
                (PVOID*)&pProp);
    _JumpIfWinError(dwErr, &hr, error, "(object)GetProperty");

    AZASSERT(NULL != pProp);

    *plProp = *((BOOL *)pProp);
    hr = S_OK;
error:
    if (NULL != pProp)
    {
        AzFreeMemory(pProp);
    }

    if ( bLockSet ) { 

        AzpUnlockResource( &AzGlCloseApplication );
    
    }

    return hr;
}

HRESULT
mySetBoolProperty(
    IN   AZ_HANDLE hOwnerApp, 
    IN   DWORD dwOwnerAppSN,
    IN  AZ_HANDLE hObject,
    IN  LONG  lPropId,
    IN  BOOL  fProp)
/*+++
Description:
    warper routine to set BOOL property
Arguments:
    hOwnerApp - the handle of the application that owns this object.
    dwOwnerAppSN - The sequential number of the owner app.
    hObject - az core object handle
    lPropId - property ID
    fProp - BOOL property data
Return:
---*/
{
    HRESULT  hr;
    DWORD    dwErr;
    BOOL bLockSet = FALSE;

    //
    // Grab the close application lock so that close
    // application cannot interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );
    bLockSet = TRUE;

    if (!IsObjectUsable(hOwnerApp, dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    dwErr = AzSetProperty(
                hObject,
                lPropId,
                0,
                (PVOID)&fProp);
    _JumpIfWinError(dwErr, &hr, error, "(object)SetProperty");

    hr = S_OK;
error:

    if ( bLockSet ) {

        AzpUnlockResource( &AzGlCloseApplication );
    }

    return hr;
}


// object implementation starts

/////////////////////////
//CAzAuthorizationStore
/////////////////////////
CAzAuthorizationStore::CAzAuthorizationStore()
{
    //init
    __try {
        InitializeCriticalSection(&m_cs);
    } __except(EXCEPTION_EXECUTE_HANDLER) {}

    m_hAuthorizationStore = NULL;
}

CAzAuthorizationStore::~CAzAuthorizationStore()
{
    if (NULL != m_hAuthorizationStore)
    {
        //
        // grab the CloseApplication lock to maintain order
        //

        AzpLockResourceShared( &AzGlCloseApplication );

        AzCloseHandle(m_hAuthorizationStore, 0);

        AzpUnlockResource( &AzGlCloseApplication );
    }
    DeleteCriticalSection(&m_cs);
}


HRESULT
CAzAuthorizationStore::get_Description(
    OUT  BSTR __RPC_FAR *pbstrDescription)
{
    return myGetBstrProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_DESCRIPTION,
                pbstrDescription);
}

HRESULT
CAzAuthorizationStore::put_Description(
    IN  BSTR  bstrDescription)
{
    return mySetBstrProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_DESCRIPTION,
                bstrDescription);
}

HRESULT
CAzAuthorizationStore::get_ApplicationData(
    OUT  BSTR __RPC_FAR *pbstrApplicationData)
{
    return myGetBstrProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_APPLICATION_DATA,
                pbstrApplicationData);
}

HRESULT
CAzAuthorizationStore::put_ApplicationData(
    IN  BSTR  bstrApplicationData)
{
    return mySetBstrProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_APPLICATION_DATA,
                bstrApplicationData);
}

HRESULT
CAzAuthorizationStore::get_DomainTimeout(
    OUT LONG         *plProp
    )
{
        return myGetLongProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_AZSTORE_DOMAIN_TIMEOUT,
                plProp);
}

HRESULT
CAzAuthorizationStore::put_DomainTimeout(
    IN LONG         lProp
    )
{
        return mySetLongProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_AZSTORE_DOMAIN_TIMEOUT,
                lProp);
}

HRESULT
CAzAuthorizationStore::get_ScriptEngineTimeout(
    OUT LONG         *plProp
    )
{
        return myGetLongProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_AZSTORE_SCRIPT_ENGINE_TIMEOUT,
                plProp);
}

HRESULT
CAzAuthorizationStore::put_ScriptEngineTimeout(
    IN LONG         lProp
    )
{
        return mySetLongProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_AZSTORE_SCRIPT_ENGINE_TIMEOUT,
                lProp);
}

HRESULT
CAzAuthorizationStore::get_MaxScriptEngines(
    OUT LONG         *plProp
    )
{
        return myGetLongProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_AZSTORE_MAX_SCRIPT_ENGINES,
                plProp);
}

HRESULT
CAzAuthorizationStore::put_MaxScriptEngines(
    IN LONG         lProp
    )
{
        return mySetLongProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_AZSTORE_MAX_SCRIPT_ENGINES,
                lProp);
}

HRESULT
CAzAuthorizationStore::get_GenerateAudits(
    OUT BOOL         * pbProp
    )
{
        return myGetBoolProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_GENERATE_AUDITS,
                pbProp);
}

HRESULT
CAzAuthorizationStore::put_GenerateAudits(
    IN BOOL         bProp
    )
{
        return mySetBoolProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_GENERATE_AUDITS,
                bProp);
}

HRESULT
CAzAuthorizationStore::get_Writable(
    OUT BOOL *pfProp)
{
        return myGetBoolProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_WRITABLE,
                pfProp);
}

HRESULT
CAzAuthorizationStore::GetProperty(
    IN   LONG  lPropId,
    IN   VARIANT varReserved,
    OUT  VARIANT *pvarProp)
{
    return myAzGetProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                lPropId,
                varReserved,
                pvarProp);
}

HRESULT
CAzAuthorizationStore::SetProperty(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzSetProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzAuthorizationStore::AddPropertyItem(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzAddPropertyItem(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzAuthorizationStore::DeletePropertyItem(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzDeletePropertyItem(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzAuthorizationStore::get_PolicyAdministrators(
    OUT  VARIANT *pvarProp)
{
        CComVariant vtemp;
        return myAzGetProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_POLICY_ADMINS,
                vtemp,
                pvarProp);
}

HRESULT
CAzAuthorizationStore::get_PolicyAdministratorsName(
    OUT  VARIANT *pvarProp)
{
    CComVariant vtemp;
    return myAzGetProperty(
            NULL,   // no app owns this object
            0,      // doesn't matter if no app owns it
            m_hAuthorizationStore,
            AZ_PROP_POLICY_ADMINS_NAME,
            vtemp,
            pvarProp);
}

HRESULT
CAzAuthorizationStore::get_PolicyReaders(
    OUT  VARIANT *pvarProp)
{
        CComVariant vtemp;
        return myAzGetProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_POLICY_READERS,
                vtemp,
                pvarProp);
}

HRESULT
CAzAuthorizationStore::get_PolicyReadersName(
    OUT  VARIANT *pvarProp)
{
    CComVariant vtemp;
    return myAzGetProperty(
            NULL,   // no app owns this object
            0,      // doesn't matter if no app owns it
            m_hAuthorizationStore,
            AZ_PROP_POLICY_READERS_NAME,
            vtemp,
            pvarProp);
}

HRESULT
CAzAuthorizationStore::AddPolicyAdministrator(
    IN   BSTR     bstrAdmin,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_POLICY_ADMINS,
                varReserved,
                bstrAdmin,
                TRUE);
}

HRESULT
CAzAuthorizationStore::AddPolicyAdministratorName(
    IN   BSTR     bstrAdmin,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_POLICY_ADMINS_NAME,
                varReserved,
                bstrAdmin,
                TRUE);
}

HRESULT
CAzAuthorizationStore::DeletePolicyAdministrator(
    IN   BSTR     bstrAdmin,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_POLICY_ADMINS,
                varReserved,
                bstrAdmin,
                FALSE);
}

HRESULT
CAzAuthorizationStore::DeletePolicyAdministratorName(
    IN   BSTR     bstrAdmin,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_POLICY_ADMINS_NAME,
                varReserved,
                bstrAdmin,
                FALSE);
}

HRESULT
CAzAuthorizationStore::AddPolicyReader(
    IN   BSTR     bstrReader,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_POLICY_READERS,
                varReserved,
                bstrReader,
                TRUE);
}


HRESULT
CAzAuthorizationStore::AddPolicyReaderName(
    IN   BSTR     bstrReader,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_POLICY_READERS_NAME,
                varReserved,
                bstrReader,
                TRUE);
}

HRESULT
CAzAuthorizationStore::DeletePolicyReader(
    IN   BSTR     bstrReader,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_POLICY_READERS,
                varReserved,
                bstrReader,
                FALSE);
}

HRESULT
CAzAuthorizationStore::DeletePolicyReaderName(
    IN   BSTR     bstrReader,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_POLICY_READERS_NAME,
                varReserved,
                bstrReader,
                FALSE);
}

HRESULT
CAzAuthorizationStore::get_TargetMachine(
    OUT  BSTR __RPC_FAR *pbstrTargetMachine)
{
    return myGetBstrProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_AZSTORE_TARGET_MACHINE,
                pbstrTargetMachine);
}

HRESULT
CAzAuthorizationStore::Initialize(
    IN   LONG  lFlags,
    IN   BSTR bstrPolicyURL,
    IN   VARIANT varReserved )
{
    HRESULT hr;
    DWORD   dwErr;

    LPCWSTR pwszPolicyUrl = bstrPolicyURL;

    if (NULL != m_hAuthorizationStore)
    {
        //init before, disallow
        hr = E_ACCESSDENIED;
        _JumpError(hr, error, "multiple Initiallize");
    }

    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    //
    // Grab CloseApplication lock to maintain order
    //

    AzpLockResourceShared( &AzGlCloseApplication );

    dwErr = AzInitialize(
                pwszPolicyUrl,
                lFlags,
                0,
                &m_hAuthorizationStore);

    AzpUnlockResource( &AzGlCloseApplication );

    _JumpIfWinError(dwErr, &hr, error, "AzInitialize");
    AZASSERT(NULL != m_hAuthorizationStore);

    hr = S_OK;
error:
    return hr;
}

HRESULT
CAzAuthorizationStore::UpdateCache(
    IN   VARIANT varReserved )
{
    HRESULT hr;
    DWORD   dwErr;

    if (NULL == m_hAuthorizationStore)
    {
        //init before, disallow
        hr = E_ACCESSDENIED;
        _JumpError(hr, error, "multiple Initiallize");
    }

    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    //
    // Lock the close application so that it doesn't interfere
    // 

    AzpLockResourceShared( &AzGlCloseApplication );

    dwErr = AzUpdateCache( m_hAuthorizationStore );

    //
    // drop the global lock
    //

    AzpUnlockResource( &AzGlCloseApplication );

    _JumpIfWinError(dwErr, &hr, error, "AzUpdateCache");

    AZASSERT(NULL != m_hAuthorizationStore);

    hr = S_OK;
error:
    return hr;
}


HRESULT
CAzAuthorizationStore::Delete(
    IN   VARIANT varReserved)
{
    HRESULT  hr;
    DWORD    dwErr;

    //
    // Grab the CloseApplication lock to maintain order
    //

    AzpLockResourceShared( &AzGlCloseApplication );

    if (NULL == m_hAuthorizationStore)
    {
        // not initialized, can't delete anything
        hr = E_ACCESSDENIED;
        _JumpError(hr, error, "not Initiallized");
    }

    hr = HandleReserved(&varReserved);
    _JumpIfError(hr, error, "HandleReserved");


    dwErr = AzAuthorizationStoreDelete(
                m_hAuthorizationStore,
                0);
    _JumpIfWinError(dwErr, &hr, error, "AzAuthorizaitonStoreDelete");

    // release authorization store object itself
    dwErr = AzCloseHandle(m_hAuthorizationStore, 0);
    _JumpIfWinError(dwErr, &hr, error, "AzCloseHandle(authorization store)");

    // set it to null
    m_hAuthorizationStore = NULL;

    hr = S_OK;
error:

    AzpUnlockResource( &AzGlCloseApplication );
    return hr;
}


HRESULT
CAzAuthorizationStore::get_Applications(
    OUT  IAzApplications __RPC_FAR **ppApplications)
{
    CComVariant vtemp;

    return myAzNewObject(
                        NULL,   // not owned by application object
                        0,      // doesn't matter if no owner app
                        ENUM_AZ_APPLICATIONS,
                        m_hAuthorizationStore,
                        &vtemp,
                        (IUnknown**)ppApplications);

}


HRESULT
CAzAuthorizationStore::OpenApplication(
    IN   BSTR bstrApplicationName,
    IN   VARIANT varReserved,
    OUT  IAzApplication __RPC_FAR **ppApplication)
{
    HRESULT  hr;

    hr = myAzOpenObject(
                NULL,   // not owned by application object
                0,      // doesn't matter if no owner app
                AzApplicationOpen,
                ENUM_AZ_APPLICATION,
                m_hAuthorizationStore,
                bstrApplicationName,
                varReserved,
                (IUnknown**)ppApplication);

    return hr;
}

HRESULT
CAzAuthorizationStore::CloseApplication(
    IN BSTR bstrApplicationName,
    IN LONG lFlags
    )
{
    HRESULT hr;

    hr = myAzCloseObject(
             AzApplicationClose,
             m_hAuthorizationStore,
             bstrApplicationName,
             lFlags
             );

    return hr;
}

HRESULT
CAzAuthorizationStore::CreateApplication(
    IN   BSTR bstrApplicationName,
    IN   VARIANT varReserved,
    OUT  IAzApplication __RPC_FAR **ppApplication)
{
    HRESULT hr;

    hr = myAzCreateObject(
                NULL,   // not owned by application object
                0,      // doesn't matter if no owner app
                AzApplicationCreate,
                ENUM_AZ_APPLICATION,
                m_hAuthorizationStore,
                bstrApplicationName,
                varReserved,
                (IUnknown**)ppApplication);

    return hr;
}

HRESULT
CAzAuthorizationStore::DeleteApplication(
    IN   BSTR bstrApplicationName,
    IN   VARIANT varReserved )
{
    HRESULT hr;

    hr = myAzDeleteObject(
                NULL,   // not owned by application object
                0,      // doesn't matter if no owner app
                AzApplicationDelete,
                m_hAuthorizationStore,
                bstrApplicationName,
                varReserved);

    return hr;
}

HRESULT
CAzAuthorizationStore::get_ApplicationGroups(
    OUT  IAzApplicationGroups __RPC_FAR **ppApplicationGroups)
{
    CComVariant vtemp;
    return myAzNewObject(
                        NULL,   // not owned by application object
                        0,      // doesn't matter if no owner app
                        ENUM_AZ_GROUPS,
                        m_hAuthorizationStore,
                        &vtemp,
                        (IUnknown**)ppApplicationGroups);
}

HRESULT
CAzAuthorizationStore::CreateApplicationGroup(
    IN   BSTR bstrGroupName,
    IN   VARIANT varReserved,
    OUT  IAzApplicationGroup __RPC_FAR **ppApplicationGroup)
{
    HRESULT  hr;
    hr = myAzCreateObject(
                NULL,   // not owned by application object
                0,      // doesn't matter if no owner app
                AzGroupCreate,
                ENUM_AZ_GROUP,
                m_hAuthorizationStore,
                bstrGroupName,
                varReserved,
                (IUnknown**)ppApplicationGroup);
    return hr;
}

HRESULT
CAzAuthorizationStore::OpenApplicationGroup(
    IN   BSTR bstrGroupName,
    IN   VARIANT varReserved,
    OUT  IAzApplicationGroup __RPC_FAR **ppApplicationGroup)
{
    HRESULT  hr;
    hr = myAzOpenObject(
                NULL,   // not owned by application object
                0,      // doesn't matter if no owner app
                AzGroupOpen,
                ENUM_AZ_GROUP,
                m_hAuthorizationStore,
                bstrGroupName,
                varReserved,
                (IUnknown**)ppApplicationGroup);
    return hr;
}

HRESULT
CAzAuthorizationStore::DeleteApplicationGroup(
    IN   BSTR bstrGroupName,
    IN   VARIANT varReserved )
{
    HRESULT hr;
    hr = myAzDeleteObject(
                NULL,   // not owned by application object
                0,      // doesn't matter if no owner app
                AzGroupDelete,
                m_hAuthorizationStore,
                bstrGroupName,
                varReserved);

    return hr;
}

HRESULT
CAzAuthorizationStore::Submit(
    IN   LONG lFlags,
    IN   VARIANT varReserved)
{
    HRESULT  hr;
    DWORD    dwErr;

    //
    // Grab CloseApplication lock to maintain order
    //

    AzpLockResourceShared( &AzGlCloseApplication );

    if (NULL == m_hAuthorizationStore)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Null AzAuthorizationStore");
    }
    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    dwErr = AzSubmit(m_hAuthorizationStore, lFlags, 0);
    _JumpIfWinError(dwErr, &hr, error, "AzSubmit");

    hr = S_OK;
error:

    AzpUnlockResource( &AzGlCloseApplication );
    return hr;
}

HRESULT
CAzAuthorizationStore::get_DelegatedPolicyUsers(
    OUT  VARIANT *pvarProp)
{
        CComVariant vtemp;
        return myAzGetProperty(
                NULL,   // not owned by application object
                0,      // doesn't matter if no owner app
                m_hAuthorizationStore,
                AZ_PROP_DELEGATED_POLICY_USERS,
                vtemp,
                pvarProp);
}

HRESULT
CAzAuthorizationStore::get_DelegatedPolicyUsersName(
    OUT  VARIANT *pvarProp)
{
        CComVariant vtemp;
        return myAzGetProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_DELEGATED_POLICY_USERS_NAME,
                vtemp,
                pvarProp);
}

HRESULT
CAzAuthorizationStore::AddDelegatedPolicyUser(
    IN   BSTR     bstrDelegatedPolicyUser,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_DELEGATED_POLICY_USERS,
                varReserved,
                bstrDelegatedPolicyUser,
                TRUE);
}

HRESULT
CAzAuthorizationStore::AddDelegatedPolicyUserName(
    IN   BSTR     bstrDelegatedPolicyUser,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_DELEGATED_POLICY_USERS_NAME,
                varReserved,
                bstrDelegatedPolicyUser,
                TRUE);
}

HRESULT
CAzAuthorizationStore::DeleteDelegatedPolicyUser(
    IN   BSTR     bstrDelegatedPolicyUser,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_DELEGATED_POLICY_USERS,
                varReserved,
                bstrDelegatedPolicyUser,
                FALSE);
}

HRESULT
CAzAuthorizationStore::DeleteDelegatedPolicyUserName(
    IN   BSTR     bstrDelegatedPolicyUser,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_DELEGATED_POLICY_USERS_NAME,
                varReserved,
                bstrDelegatedPolicyUser,
                FALSE);
}

HRESULT
CAzAuthorizationStore::put_ApplyStoreSacl(
    IN  BOOL    bApplyStoreSacl)
{
    return mySetBoolProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_APPLY_STORE_SACL,
                bApplyStoreSacl);
}

HRESULT
CAzAuthorizationStore::get_ApplyStoreSacl(
    OUT BOOL  * pbApplyStoreSacl)
{
    return myGetBoolProperty(
                NULL,   // no app owns this object
                0,      // doesn't matter if no app owns it
                m_hAuthorizationStore,
                AZ_PROP_APPLY_STORE_SACL,
                pbApplyStoreSacl);
}


/////////////////////////
//CAzApplication
/////////////////////////
CAzApplication::CAzApplication()
{
    //init
    __try {
        InitializeCriticalSection(&m_cs);
    } __except(EXCEPTION_EXECUTE_HANDLER) {}

    m_hApplication = NULL;
}

CAzApplication::~CAzApplication()
{
    if (NULL != m_hApplication)
    {
        //
        // Grab the lock to maintain order
        //
        AzpLockResourceShared( &AzGlCloseApplication );
        AzCloseHandle(m_hApplication, 0);
        AzpUnlockResource( &AzGlCloseApplication );
    }
    DeleteCriticalSection(&m_cs);
}

HRESULT
CAzApplication::_Init(
    IN   AZ_HANDLE  hHandle)
{
    HRESULT hr;
    EnterCriticalSection(&m_cs);

    //init once
    AZASSERT(NULL != hHandle);
    AZASSERT(NULL == m_hApplication);

    m_hApplication = hHandle;
    
    //
    // Grab the CloseApplication lock to maintain order
    //

    AzpLockResourceShared( &AzGlCloseApplication );
    m_dwSN = AzpRetrieveApplicationSequenceNumber(m_hApplication);
    AzpUnlockResource( &AzGlCloseApplication );

    hr = S_OK;
//error:
    LeaveCriticalSection(&m_cs);
    return hr;
}

HRESULT
CAzApplication::get_Description(
    OUT  BSTR __RPC_FAR *pbstrDescription)
{
    return myGetBstrProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_DESCRIPTION,
                pbstrDescription);
}

HRESULT
CAzApplication::put_Description(
    IN  BSTR  bstrDescription)
{
    return mySetBstrProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_DESCRIPTION,
                bstrDescription);
}

HRESULT
CAzApplication::get_Name(
    OUT  BSTR __RPC_FAR *pbstrName)
{
    return myGetBstrProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_NAME,
                pbstrName);
}

HRESULT
CAzApplication::put_Name(
    IN  BSTR  bstrName)
{
    return mySetBstrProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_NAME,
                bstrName);
}

HRESULT
CAzApplication::get_ApplicationData(
    OUT  BSTR __RPC_FAR *pbstrApplicationData)
{
    return myGetBstrProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_APPLICATION_DATA,
                pbstrApplicationData);
}

HRESULT
CAzApplication::put_ApplicationData(
    IN  BSTR  bstrApplicationData)
{
    return mySetBstrProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_APPLICATION_DATA,
                bstrApplicationData);
}


HRESULT STDMETHODCALLTYPE
CAzApplication::get_AuthzInterfaceClsid(
    OUT BSTR *pbstrProp)
{
        return myGetBstrProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID,
                pbstrProp);
}

HRESULT STDMETHODCALLTYPE
CAzApplication::put_AuthzInterfaceClsid(
    IN BSTR bstrProp)
{
        return mySetBstrProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID,
                bstrProp);
}

HRESULT STDMETHODCALLTYPE
CAzApplication::get_Version(
    OUT BSTR *pbstrProp)
{
        return myGetBstrProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_APPLICATION_VERSION,
                pbstrProp);
}

HRESULT STDMETHODCALLTYPE
CAzApplication::put_Version(
    IN BSTR bstrProp)
{
        return mySetBstrProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_APPLICATION_VERSION,
                bstrProp);
}

HRESULT STDMETHODCALLTYPE
CAzApplication::get_GenerateAudits(
    OUT BOOL *pbProp)
{
        return myGetBoolProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_GENERATE_AUDITS,
                pbProp);
}

HRESULT STDMETHODCALLTYPE
CAzApplication::put_GenerateAudits(
    IN BOOL bProp)
{
        return mySetBoolProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_GENERATE_AUDITS,
                bProp);
}

HRESULT STDMETHODCALLTYPE
CAzApplication::get_ApplyStoreSacl(
    OUT BOOL *pbProp)
{
        return myGetBoolProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_APPLY_STORE_SACL,
                pbProp);
}

HRESULT STDMETHODCALLTYPE
CAzApplication::put_ApplyStoreSacl(
    IN BOOL bProp)
{
        return mySetLongProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_APPLY_STORE_SACL,
                bProp);
}


HRESULT
CAzApplication::get_Writable(
    OUT BOOL *pfProp)
{
        return myGetBoolProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_WRITABLE,
                pfProp);
}

HRESULT
CAzApplication::GetProperty(
    IN   LONG  lPropId,
    IN   VARIANT varReserved,
    OUT  VARIANT *pvarProp)
{
    return myAzGetProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                lPropId,
                varReserved,
                pvarProp);
}

HRESULT
CAzApplication::SetProperty(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzSetProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzApplication::get_PolicyAdministrators(
    OUT  VARIANT *pvarProp)
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_POLICY_ADMINS,
                vtemp,
                pvarProp);
}

HRESULT
CAzApplication::get_PolicyAdministratorsName(
    OUT  VARIANT *pvarProp)
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_POLICY_ADMINS_NAME,
                vtemp,
                pvarProp);
}

HRESULT
CAzApplication::get_PolicyReaders(
    OUT  VARIANT *pvarProp)
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_POLICY_READERS,
                vtemp,
                pvarProp);
}

HRESULT
CAzApplication::get_PolicyReadersName(
    OUT  VARIANT *pvarProp)
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_POLICY_READERS_NAME,
                vtemp,
                pvarProp);
}

HRESULT
CAzApplication::AddPolicyAdministrator(
    IN   BSTR     bstrAdmin,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_POLICY_ADMINS,
                varReserved,
                bstrAdmin,
                TRUE);
}

HRESULT
CAzApplication::AddPolicyAdministratorName(
    IN   BSTR     bstrAdmin,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_POLICY_ADMINS_NAME,
                varReserved,
                bstrAdmin,
                TRUE);
}

HRESULT
CAzApplication::DeletePolicyAdministrator(
    IN   BSTR     bstrAdmin,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_POLICY_ADMINS,
                varReserved,
                bstrAdmin,
                FALSE);
}

HRESULT
CAzApplication::DeletePolicyAdministratorName(
    IN   BSTR     bstrAdmin,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_POLICY_ADMINS_NAME,
                varReserved,
                bstrAdmin,
                FALSE);
}

HRESULT
CAzApplication::AddPolicyReader(
    IN   BSTR     bstrReader,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_POLICY_READERS,
                varReserved,
                bstrReader,
                TRUE);
}

HRESULT
CAzApplication::AddPolicyReaderName(
    IN   BSTR     bstrReader,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_POLICY_READERS_NAME,
                varReserved,
                bstrReader,
                TRUE);
}

HRESULT
CAzApplication::DeletePolicyReader(
    IN   BSTR     bstrReader,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_POLICY_READERS,
                varReserved,
                bstrReader,
                FALSE);
}

HRESULT
CAzApplication::DeletePolicyReaderName(
    IN   BSTR     bstrReader,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_POLICY_READERS_NAME,
                varReserved,
                bstrReader,
                FALSE);
}

HRESULT
CAzApplication::get_Scopes(
    OUT  IAzScopes **ppScopes)
{
    CComVariant vtemp;
    return myAzNewObject(
                        m_hApplication,
                        m_dwSN,
                        ENUM_AZ_SCOPES,
                        m_hApplication,
                        &vtemp,
                        (IUnknown**)ppScopes);
}

HRESULT
CAzApplication::OpenScope(
    IN   BSTR bstrScopeName,
    IN   VARIANT varReserved,
    OUT  IAzScope **ppScope)
{
    HRESULT  hr;
    hr = myAzOpenObject(
                m_hApplication,
                m_dwSN,
                AzScopeOpen,
                ENUM_AZ_SCOPE,
                m_hApplication,
                bstrScopeName,
                varReserved,
                (IUnknown**)ppScope);
    return hr;
}

HRESULT
CAzApplication::CreateScope(
    IN   BSTR bstrScopeName,
    IN   VARIANT varReserved,
    OUT  IAzScope **ppScope)
{
    HRESULT  hr;
    hr = myAzCreateObject(
                m_hApplication,
                m_dwSN,
                AzScopeCreate,
                ENUM_AZ_SCOPE,
                m_hApplication,
                bstrScopeName,
                varReserved,
                (IUnknown**)ppScope);
    return hr;
}

HRESULT
CAzApplication::DeleteScope(
    IN   BSTR bstrScopeName,
    IN   VARIANT varReserved )
{
    HRESULT hr;

    hr = myAzDeleteObject(
                m_hApplication,
                m_dwSN,
                AzScopeDelete,
                m_hApplication,
                bstrScopeName,
                varReserved);

    return hr;
}

HRESULT
CAzApplication::get_Operations(
    OUT  IAzOperations **ppOperations)
{
    CComVariant vtemp;
    return myAzNewObject(
                    m_hApplication,
                    m_dwSN,
                    ENUM_AZ_OPERATIONS,
                    m_hApplication,
                    &vtemp,
                    (IUnknown**)ppOperations);
}

HRESULT
CAzApplication::OpenOperation(
    IN   BSTR bstrOperationName,
    IN   VARIANT varReserved,
    OUT  IAzOperation **ppOperation)
{
    HRESULT  hr;
    hr = myAzOpenObject(
                m_hApplication,
                m_dwSN,
                AzOperationOpen,
                ENUM_AZ_OPERATION,
                m_hApplication,
                bstrOperationName,
                varReserved,
                (IUnknown**)ppOperation);
    return hr;
}

HRESULT
CAzApplication::CreateOperation(
    IN   BSTR bstrOperationName,
    IN   VARIANT varReserved,
    OUT  IAzOperation **ppOperation)
{
    HRESULT  hr;
    hr = myAzCreateObject(
                m_hApplication,
                m_dwSN,
                AzOperationCreate,
                ENUM_AZ_OPERATION,
                m_hApplication,
                bstrOperationName,
                varReserved,
                (IUnknown**)ppOperation);
    return hr;
}

HRESULT
CAzApplication::DeleteOperation(
    IN   BSTR bstrOperationName,
    IN   VARIANT varReserved )
{
    HRESULT hr;

    hr = myAzDeleteObject(
                m_hApplication,
                m_dwSN,
                AzOperationDelete,
                m_hApplication,
                bstrOperationName,
                varReserved);

    return hr;
}

HRESULT
CAzApplication::get_Tasks(
    OUT  IAzTasks **ppTasks)
{
    CComVariant vtemp;
    return myAzNewObject(
                        m_hApplication,
                        m_dwSN,
                        ENUM_AZ_TASKS,
                        m_hApplication,
                        &vtemp,
                        (IUnknown**)ppTasks);
}

HRESULT
CAzApplication::OpenTask(
    IN   BSTR bstrTaskName,
    IN   VARIANT varReserved,
    OUT  IAzTask **ppTask)
{
    HRESULT  hr;
    hr = myAzOpenObject(
                m_hApplication,
                m_dwSN,
                AzTaskOpen,
                ENUM_AZ_TASK,
                m_hApplication,
                bstrTaskName,
                varReserved,
                (IUnknown**)ppTask);
    return hr;
}

HRESULT
CAzApplication::CreateTask(
    IN   BSTR bstrTaskName,
    IN   VARIANT varReserved,
    OUT  IAzTask **ppTask)
{
    HRESULT  hr;
    hr = myAzCreateObject(
                m_hApplication,
                m_dwSN,
                AzTaskCreate,
                ENUM_AZ_TASK,
                m_hApplication,
                bstrTaskName,
                varReserved,
                (IUnknown**)ppTask);
    return hr;
}

HRESULT
CAzApplication::DeleteTask(
    IN   BSTR bstrTaskName,
    IN   VARIANT varReserved )
{
    HRESULT hr;

    hr = myAzDeleteObject(
                m_hApplication,
                m_dwSN,
                AzTaskDelete,
                m_hApplication,
                bstrTaskName,
                varReserved);

    return hr;
}

HRESULT
CAzApplication::get_ApplicationGroups(
    OUT  IAzApplicationGroups **ppGroups)
{
    CComVariant vtemp;
    return myAzNewObject(
                    m_hApplication,
                    m_dwSN,
                    ENUM_AZ_GROUPS,
                    m_hApplication,
                    &vtemp,
                    (IUnknown**)ppGroups);
}

HRESULT
CAzApplication::OpenApplicationGroup(
    IN   BSTR bstrGroupName,
    IN   VARIANT varReserved,
    OUT  IAzApplicationGroup **ppGroup)
{
    HRESULT  hr;
    hr = myAzOpenObject(
                m_hApplication,
                m_dwSN,
                AzGroupOpen,
                ENUM_AZ_GROUP,
                m_hApplication,
                bstrGroupName,
                varReserved,
                (IUnknown**)ppGroup);
    return hr;
}

HRESULT
CAzApplication::CreateApplicationGroup(
    IN   BSTR bstrGroupName,
    IN   VARIANT varReserved,
    OUT  IAzApplicationGroup **ppGroup)
{
    HRESULT  hr;
    hr = myAzCreateObject(
                m_hApplication,
                m_dwSN,
                AzGroupCreate,
                ENUM_AZ_GROUP,
                m_hApplication,
                bstrGroupName,
                varReserved,
                (IUnknown**)ppGroup);
    return hr;
}

HRESULT
CAzApplication::DeleteApplicationGroup(
    IN   BSTR bstrGroupName,
    IN   VARIANT varReserved )
{
    HRESULT hr;

    hr = myAzDeleteObject(
                m_hApplication,
                m_dwSN,
                AzGroupDelete,
                m_hApplication,
                bstrGroupName,
                varReserved);

    return hr;
}

HRESULT
CAzApplication::get_Roles(
    OUT  IAzRoles **ppRoles)
{
    CComVariant vtemp;
    return myAzNewObject(
                    m_hApplication,
                    m_dwSN,
                    ENUM_AZ_ROLES,
                    m_hApplication,
                    &vtemp,
                    (IUnknown**)ppRoles);
}

HRESULT
CAzApplication::OpenRole(
    IN   BSTR bstrRoleName,
    IN   VARIANT varReserved,
    OUT  IAzRole **ppRole)
{
    HRESULT  hr;
    hr = myAzOpenObject(
                m_hApplication,
                m_dwSN,
                AzRoleOpen,
                ENUM_AZ_ROLE,
                m_hApplication,
                bstrRoleName,
                varReserved,
                (IUnknown**)ppRole);
    return hr;
}

HRESULT
CAzApplication::CreateRole(
    IN   BSTR bstrRoleName,
    IN   VARIANT varReserved,
    OUT  IAzRole **ppRole)
{
    HRESULT  hr;
    hr = myAzCreateObject(
                m_hApplication,   // this application owns the new object
                m_dwSN,           
                AzRoleCreate,
                ENUM_AZ_ROLE,
                m_hApplication,
                bstrRoleName,
                varReserved,
                (IUnknown**)ppRole);
    return hr;
}

HRESULT
CAzApplication::DeleteRole(
    IN   BSTR bstrRoleName,
    IN   VARIANT varReserved )
{
    HRESULT hr;

    hr = myAzDeleteObject(
                m_hApplication,
                m_dwSN,
                AzRoleDelete,
                m_hApplication,
                bstrRoleName,
                varReserved);

    return hr;
}


HRESULT
CAzApplication::InitializeClientContextFromToken(
    IN   ULONGLONG ullTokenHandle,
    IN   VARIANT varReserved,
    OUT  IAzClientContext **ppClientContext)
{
    HRESULT hr;
    DWORD   dwErr;
    AZ_HANDLE  hClientContext = NULL;
    BOOL bLockSet = FALSE;

#pragma warning ( push )
#pragma warning ( disable : 4312 ) // cast of long to handle

    HANDLE hTokenHandle = (HANDLE)(ullTokenHandle);

    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    //
    // init output
    //
    if ( ppClientContext == NULL ) {
        hr = E_INVALIDARG;
        _JumpIfError(hr, error, "ppClientContext");
    }

    *ppClientContext = NULL;

    //
    // grab the lock so that close application cannot interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );
    bLockSet = TRUE;

    if (!IsObjectUsable(m_hApplication, m_dwSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    dwErr = AzInitializeContextFromToken(
                m_hApplication,
                hTokenHandle,
                0,
                &hClientContext);
    _JumpIfWinError(dwErr, &hr, error, "AzInitializeContextFromToken");

#pragma warning ( pop )

    AZASSERT(NULL != hClientContext);

    hr = myAzNewObject(
                m_hApplication,
                m_dwSN,
                ENUM_AZ_CLIENTCONTEXT,
                hClientContext,
                NULL,  //varReserved is not used here
                (IUnknown**)ppClientContext);
    _JumpIfError(hr, error, "myAzNewObject");

    // let client context object to release the handle
    hClientContext = NULL;

    hr = S_OK;
error:
    if (NULL != hClientContext)
    {
        AzCloseHandle(hClientContext, 0);
    }

    if ( bLockSet ) {

        AzpUnlockResource( &AzGlCloseApplication );
    }

    return hr;
}

HRESULT
CAzApplication::InitializeClientContextFromName(
    IN   BSTR  ClientName,
    IN   OPTIONAL BSTR  DomainName,
    IN   VARIANT varReserved,
    OUT  IAzClientContext **ppClientContext)
{
    HRESULT hr;
    DWORD   dwErr;
    AZ_HANDLE  hClientContext = NULL;
    BOOL bLockSet = FALSE;

    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    //
    // init output
    //
    if ( ppClientContext == NULL ) {
        hr = E_INVALIDARG;
        _JumpIfError(hr, error, "ppClientContext");
    }

    *ppClientContext = NULL;

    //
    // Grab the lock so that close application cannot interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );
    bLockSet = TRUE;

    if (!IsObjectUsable(m_hApplication, m_dwSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    dwErr = AzInitializeContextFromName(
                m_hApplication,
                DomainName,
                ClientName,
                0,
                &hClientContext);
    _JumpIfWinError(dwErr, &hr, error, "AzInitializeContextFromName");

    AZASSERT(NULL != hClientContext);

    hr = myAzNewObject(
                m_hApplication,
                m_dwSN,
                ENUM_AZ_CLIENTCONTEXT,
                hClientContext,
                NULL,  //varReserved is not used here
                (IUnknown**)ppClientContext);
    _JumpIfError(hr, error, "myAzNewObject");

    // let client context object to release the handle
    hClientContext = NULL;

    hr = S_OK;
error:
    if (NULL != hClientContext)
    {
        AzCloseHandle(hClientContext, 0);
    }

    if ( bLockSet ) {

        AzpUnlockResource( &AzGlCloseApplication );
    }

    return hr;
}

HRESULT
CAzApplication::InitializeClientContextFromStringSid(
    IN   BSTR  SidString,
    IN   LONG  lOptions,
    IN   OPTIONAL VARIANT varReserved,
    OUT  IAzClientContext **ppClientContext
    )
/*
This routine initializes a client context from a string SID.
The string SID may or may not be a valid Windows account (specified
in lOptions).

*/
{
    HRESULT hr;
    DWORD   dwErr;
    AZ_HANDLE  hClientContext = NULL;
    BOOL bLockSet = FALSE;

    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    //
    // init output
    //
    if ( ppClientContext == NULL ) {
        hr = E_INVALIDARG;
        _JumpIfError(hr, error, "ppClientContext");
    }

    *ppClientContext = NULL;

    //
    // grab the lock so that close application cannot interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );
    bLockSet = TRUE;

    if (!IsObjectUsable(m_hApplication, m_dwSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    //
    // call to core engine for initialization
    //
    dwErr = AzInitializeContextFromStringSid(
                m_hApplication,
                SidString,
                lOptions,
                &hClientContext);
    _JumpIfWinError(dwErr, &hr, error, "AzInitializeContextFromStringSid");

    AZASSERT(NULL != hClientContext);

    //
    // create the COM object
    //
    hr = myAzNewObject(
                m_hApplication,
                m_dwSN,
                ENUM_AZ_CLIENTCONTEXT,
                hClientContext,
                NULL,  //varReserved is not used here
                (IUnknown**)ppClientContext);
    _JumpIfError(hr, error, "myAzNewObject");

    //
    // let client context object to release the handle
    //
    hClientContext = NULL;

    hr = S_OK;

error:

    if (NULL != hClientContext)
    {
        AzCloseHandle(hClientContext, 0);
    }

    if ( bLockSet ) {

        AzpUnlockResource( &AzGlCloseApplication );
    }

    return hr;
}

HRESULT
CAzApplication::AddPropertyItem(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzAddPropertyItem(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzApplication::DeletePropertyItem(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzDeletePropertyItem(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzApplication::Submit(
    IN   LONG lFlags,
    IN   VARIANT varReserved)
{
    HRESULT hr;
    DWORD   dwErr;


    //
    // Grab the lock so that close application cannot interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );

    if (NULL == m_hApplication)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Null AzApplication");
    }
    else if (!IsObjectUsable(m_hApplication, m_dwSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Application was closed.");
    }

    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    dwErr = AzSubmit(m_hApplication, lFlags, 0);
    _JumpIfWinError(dwErr, &hr, error, "AzSubmit");

    hr = S_OK;
error:

    AzpUnlockResource( &AzGlCloseApplication );
    return hr;
}


HRESULT
CAzApplication::get_DelegatedPolicyUsers(
    OUT  VARIANT *pvarProp)
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_DELEGATED_POLICY_USERS,
                vtemp,
                pvarProp);
}

HRESULT
CAzApplication::get_DelegatedPolicyUsersName(
    OUT  VARIANT *pvarProp)
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_DELEGATED_POLICY_USERS_NAME,
                vtemp,
                pvarProp);
}

HRESULT
CAzApplication::AddDelegatedPolicyUser(
    IN   BSTR     bstrDelegatedPolicyUser,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_DELEGATED_POLICY_USERS,
                varReserved,
                bstrDelegatedPolicyUser,
                TRUE);
}

HRESULT
CAzApplication::AddDelegatedPolicyUserName(
    IN   BSTR     bstrDelegatedPolicyUser,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_DELEGATED_POLICY_USERS_NAME,
                varReserved,
                bstrDelegatedPolicyUser,
                TRUE);
}

HRESULT
CAzApplication::DeleteDelegatedPolicyUser(
    IN   BSTR     bstrDelegatedPolicyUser,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_DELEGATED_POLICY_USERS,
                varReserved,
                bstrDelegatedPolicyUser,
                FALSE);
}

HRESULT
CAzApplication::DeleteDelegatedPolicyUserName(
    IN   BSTR     bstrDelegatedPolicyUser,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                m_hApplication,
                m_dwSN,
                m_hApplication,
                AZ_PROP_DELEGATED_POLICY_USERS_NAME,
                varReserved,
                bstrDelegatedPolicyUser,
                FALSE);
}


/////////////////////////
//CAzApplications
/////////////////////////
HRESULT
CAzApplications::_Init(
    IN OPTIONAL VARIANT  *pvarReserved,
    IN  AZ_HANDLE   hParent)
{
    HRESULT  hr;
    ULONG    lContext = 0;
    IAzApplication * pIApp = NULL;

    while (S_OK == (hr = myAzNextObject(
                NULL,   // this must be owned by the store, not an application
                0,      // doesn't matter if not owned by an app
                AzApplicationEnum,
                pvarReserved,
                ENUM_AZ_APPLICATION,
                hParent,
                &lContext,
                (IUnknown**)&pIApp)))
    {
        AZASSERT(NULL != (PVOID)pIApp);

        //
        // myAddItemToMap will release the pIApp
        //

        hr = myAddItemToMap<IAzApplication>(&m_coll, &pIApp);
        _JumpIfError(hr, error, "myAddItemToMap");
    }

    if (AZ_HRESULT(ERROR_NO_MORE_ITEMS) != hr)
    {
        _JumpError(hr, error, "myAzNextObject");
    }

    hr = S_OK;
error:
    return hr;
}



/////////////////////////
//CAzOperation
/////////////////////////
CAzOperation::CAzOperation()
{
    //init
    __try {
        InitializeCriticalSection(&m_cs);
    } __except(EXCEPTION_EXECUTE_HANDLER) {}

    m_hOperation = NULL;
}

CAzOperation::~CAzOperation()
{
    if (NULL != m_hOperation)
    {
        AzpLockResourceShared( &AzGlCloseApplication );
        if (IsObjectUsable(m_hOwnerApp, m_dwOwnerAppSN))
        {
            AzCloseHandle(m_hOperation, 0);
        }
        AzpUnlockResource( &AzGlCloseApplication );
    }
    DeleteCriticalSection(&m_cs);
}

HRESULT
CAzOperation::_Init(
    IN   AZ_HANDLE  hOwnerApp,
    IN   AZ_HANDLE  hHandle)
{
    HRESULT hr;
    EnterCriticalSection(&m_cs);

    //init once
    AZASSERT(NULL != hHandle);
    AZASSERT(NULL == m_hOperation);

    m_hOperation = hHandle;

    m_hOwnerApp = hOwnerApp;
    if (hOwnerApp != NULL)
    {
        //
        // Grab the CloseApplication lock to maintain order
        //

        AzpLockResourceShared( &AzGlCloseApplication );
        m_dwOwnerAppSN = AzpRetrieveApplicationSequenceNumber(hOwnerApp);
        AzpUnlockResource( &AzGlCloseApplication );
    }
    else
    {
        m_dwOwnerAppSN = 0;
    }

    hr = S_OK;
//error:
    LeaveCriticalSection(&m_cs);
    return hr;
}

HRESULT
CAzOperation::get_Description(
    OUT  BSTR __RPC_FAR *pbstrDescription)
{
    return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hOperation,
                AZ_PROP_DESCRIPTION,
                pbstrDescription);
}

HRESULT
CAzOperation::put_Description(
    IN  BSTR  bstrDescription)
{
    return mySetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hOperation,
                AZ_PROP_DESCRIPTION,
                bstrDescription);
}

HRESULT
CAzOperation::get_Name(
    OUT  BSTR __RPC_FAR *pbstrName)
{
    return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hOperation,
                AZ_PROP_NAME,
                pbstrName);
}

HRESULT
CAzOperation::put_Name(
    IN  BSTR  bstrName)
{
    return mySetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hOperation,
                AZ_PROP_NAME,
                bstrName);
}

HRESULT
CAzOperation::get_ApplicationData(
    OUT  BSTR __RPC_FAR *pbstrApplicationData)
{
    return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hOperation,
                AZ_PROP_APPLICATION_DATA,
                pbstrApplicationData);
}

HRESULT
CAzOperation::put_ApplicationData(
    IN  BSTR  bstrApplicationData)
{
    return mySetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hOperation,
                AZ_PROP_APPLICATION_DATA,
                bstrApplicationData);
}

HRESULT
CAzOperation::get_Writable(
    OUT BOOL *pfProp)
{
        return myGetBoolProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hOperation,
                AZ_PROP_WRITABLE,
                pfProp);
}

HRESULT
CAzOperation::get_OperationID(
    OUT  LONG *plProp)
{
        return myGetLongProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hOperation,
                AZ_PROP_OPERATION_ID,
                plProp);
}

HRESULT
CAzOperation::put_OperationID(
    IN  LONG lProp)
{
        return mySetLongProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hOperation,
                AZ_PROP_OPERATION_ID,
                lProp);
}

HRESULT
CAzOperation::GetProperty(
    IN   LONG  lPropId,
    IN   VARIANT varReserved,
    OUT  VARIANT *pvarProp)
{
    return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hOperation,
                lPropId,
                varReserved,
                pvarProp);
}

HRESULT
CAzOperation::SetProperty(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzSetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hOperation,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzOperation::Submit(
    IN   LONG lFlags,
    IN   VARIANT varReserved)
{
    HRESULT  hr;
    DWORD    dwErr;


    //
    // grab the lock so that close application does not
    // interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );

    if (NULL == m_hOperation)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Null AzOperation");
    }
    else if (!IsObjectUsable(m_hOwnerApp, m_dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    dwErr = AzSubmit(m_hOperation, lFlags, 0);
    _JumpIfWinError(dwErr, &hr, error, "AzSubmit");

    hr = S_OK;
error:

    AzpUnlockResource( &AzGlCloseApplication );
    return hr;
}


/////////////////////////
//CAzOperations
/////////////////////////
HRESULT
CAzOperations::_Init(
    IN  AZ_HANDLE   hOwnerApp,
    IN OPTIONAL VARIANT  *pvarReserved,
    IN  AZ_HANDLE   hParent)
{
    HRESULT  hr;
    ULONG    lContext = 0;
    IAzOperation * pIOp = NULL;

    m_hOwnerApp = hOwnerApp;
    if (hOwnerApp != NULL)
    {
        AzpLockResourceShared( &AzGlCloseApplication );
        m_dwOwnerAppSN = AzpRetrieveApplicationSequenceNumber(hOwnerApp);
        AzpUnlockResource( &AzGlCloseApplication );
    }
    else
    {
        m_dwOwnerAppSN = 0;
    }

    while (S_OK == (hr = myAzNextObject(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                AzOperationEnum,
                pvarReserved,
                ENUM_AZ_OPERATION,
                hParent,
                &lContext,
                (IUnknown**)&pIOp)))
    {
        AZASSERT(NULL != (PVOID)pIOp);

        //
        // myAddItemToMap will release the pIOp
        //

        hr = myAddItemToMap<IAzOperation>(&m_coll, &pIOp);
        _JumpIfError(hr, error, "myAddItemToMap");
    }

    if (AZ_HRESULT(ERROR_NO_MORE_ITEMS) != hr)
    {
        _JumpError(hr, error, "myAzNextObject");
    }

    hr = S_OK;
error:
    return hr;
}


/////////////////////////
//CAzTask
/////////////////////////
CAzTask::CAzTask()
{
    //init
    __try {
        InitializeCriticalSection(&m_cs);
    } __except(EXCEPTION_EXECUTE_HANDLER) {}

    m_hTask = NULL;
}

CAzTask::~CAzTask()
{
    if (NULL != m_hTask)
    {
        //
        // Grab the lock so that Close application does not interfere
        //

        AzpLockResourceShared( &AzGlCloseApplication );

        if (IsObjectUsable(m_hOwnerApp, m_dwOwnerAppSN))
        {
            AzCloseHandle(m_hTask, 0);
        }

        AzpUnlockResource( &AzGlCloseApplication );
    }
    DeleteCriticalSection(&m_cs);
}

HRESULT
CAzTask::_Init(
    IN   AZ_HANDLE  hOwnerApp,
    IN   AZ_HANDLE  hHandle)
{
    HRESULT hr;
    EnterCriticalSection(&m_cs);

    //init once
    AZASSERT(NULL != hHandle);
    AZASSERT(NULL == m_hTask);

    m_hTask = hHandle;

    m_hOwnerApp = hOwnerApp;
    if (hOwnerApp != NULL)
    {
        //
        // Grab lock top maintain order
        //
        AzpLockResourceShared( &AzGlCloseApplication );
        m_dwOwnerAppSN = AzpRetrieveApplicationSequenceNumber(hOwnerApp);
        AzpUnlockResource( &AzGlCloseApplication );
    }
    else
    {
        m_dwOwnerAppSN = 0;
    }

    hr = S_OK;
//error:
    LeaveCriticalSection(&m_cs);
    return hr;
}

HRESULT
CAzTask::get_Description(
    OUT  BSTR __RPC_FAR *pbstrDescription)
{
    return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                AZ_PROP_DESCRIPTION,
                pbstrDescription);
}

HRESULT
CAzTask::put_Description(
    IN  BSTR  bstrDescription)
{
    return mySetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                AZ_PROP_DESCRIPTION,
                bstrDescription);
}

HRESULT
CAzTask::get_Name(
    OUT  BSTR __RPC_FAR *pbstrName)
{
    return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                AZ_PROP_NAME,
                pbstrName);
}

HRESULT
CAzTask::put_Name(
    IN  BSTR  bstrName)
{
    return mySetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                AZ_PROP_NAME,
                bstrName);
}

HRESULT
CAzTask::get_ApplicationData(
    OUT  BSTR __RPC_FAR *pbstrApplicationData)
{
    return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                AZ_PROP_APPLICATION_DATA,
                pbstrApplicationData);
}

HRESULT
CAzTask::put_ApplicationData(
    IN  BSTR  bstrApplicationData)
{
    return mySetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                AZ_PROP_APPLICATION_DATA,
                bstrApplicationData);
}

HRESULT STDMETHODCALLTYPE
CAzTask::get_BizRule(
    OUT BSTR *pbstrProp)
{
        return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                AZ_PROP_TASK_BIZRULE,
                pbstrProp);
}

HRESULT STDMETHODCALLTYPE
CAzTask::put_BizRule(
    IN BSTR bstrProp)
{
        return mySetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                AZ_PROP_TASK_BIZRULE,
                bstrProp);
}

HRESULT STDMETHODCALLTYPE
CAzTask::get_BizRuleLanguage(
    OUT BSTR *pbstrProp)
{
        return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                AZ_PROP_TASK_BIZRULE_LANGUAGE,
                pbstrProp);
}

HRESULT STDMETHODCALLTYPE
CAzTask::put_BizRuleLanguage(
    IN BSTR bstrProp)
{
        return mySetBstrProperty(
                 m_hOwnerApp,
                m_dwOwnerAppSN,
               m_hTask,
                AZ_PROP_TASK_BIZRULE_LANGUAGE,
                bstrProp);
}

HRESULT STDMETHODCALLTYPE
CAzTask::get_BizRuleImportedPath(
    OUT BSTR *pbstrProp)
{
        return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                AZ_PROP_TASK_BIZRULE_IMPORTED_PATH,
                pbstrProp);
}

HRESULT STDMETHODCALLTYPE
CAzTask::put_BizRuleImportedPath(
    IN BSTR bstrProp)
{
        return mySetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                AZ_PROP_TASK_BIZRULE_IMPORTED_PATH,
                bstrProp);
}

HRESULT STDMETHODCALLTYPE
CAzTask::get_IsRoleDefinition(
    OUT BOOL *pfProp)
{
        return myGetBoolProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                AZ_PROP_TASK_IS_ROLE_DEFINITION,
                pfProp);
}

HRESULT STDMETHODCALLTYPE
CAzTask::put_IsRoleDefinition(
    IN BOOL fProp)
{
        return mySetBoolProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                AZ_PROP_TASK_IS_ROLE_DEFINITION,
                fProp);
}

HRESULT STDMETHODCALLTYPE
CAzTask::get_Operations(
    OUT VARIANT *pvarProp)
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                AZ_PROP_TASK_OPERATIONS,
                vtemp,
                pvarProp);
}

HRESULT STDMETHODCALLTYPE
CAzTask::get_Tasks(
    OUT VARIANT *pvarProp)
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                AZ_PROP_TASK_TASKS,
                vtemp,
                pvarProp);
}

HRESULT  CAzTask::AddOperation(
    IN             BSTR        bstrOp,
    IN  VARIANT     varReserved
    )
{
    HRESULT hr;
    hr = myAzAddPropertyItemBstr(
                    m_hOwnerApp,
                    m_dwOwnerAppSN,
                    m_hTask,
                    AZ_PROP_TASK_OPERATIONS,
                    varReserved,
                    bstrOp);
    return hr;
}

HRESULT  CAzTask::DeleteOperation(
    IN             BSTR        bstrOp,
    IN    VARIANT     varReserved
    )
{
    HRESULT hr;
    hr = myAzDeletePropertyItemBstr(
        m_hOwnerApp,
        m_dwOwnerAppSN,
        m_hTask,
        AZ_PROP_TASK_OPERATIONS,
        varReserved,
        bstrOp);
    return hr;
}

HRESULT  CAzTask::AddTask(
    IN              BSTR        bstrTask,
    IN    VARIANT     varReserved
    )
{
    HRESULT hr;
    hr = myAzAddPropertyItemBstr(
                    m_hOwnerApp,
                    m_dwOwnerAppSN,
                    m_hTask,
                    AZ_PROP_TASK_TASKS,
                    varReserved,
                    bstrTask);
    return hr;
}

HRESULT  CAzTask::DeleteTask(
    IN            BSTR        bstrTask,
    IN    VARIANT     varReserved
    )
{
    HRESULT hr;
    hr = myAzDeletePropertyItemBstr(
        m_hOwnerApp,
        m_dwOwnerAppSN,
        m_hTask,
        AZ_PROP_TASK_TASKS,
        varReserved,
        bstrTask);
    return hr;
}

HRESULT
CAzTask::get_Writable(
    OUT BOOL *pfProp)
{
        return myGetBoolProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                AZ_PROP_WRITABLE,
                pfProp);
}

HRESULT
CAzTask::GetProperty(
    IN   LONG  lPropId,
    IN   VARIANT varReserved,
    OUT  VARIANT *pvarProp)
{
    return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                lPropId,
                varReserved,
                pvarProp);
}

HRESULT
CAzTask::SetProperty(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzSetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzTask::AddPropertyItem(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzAddPropertyItem(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzTask::DeletePropertyItem(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzDeletePropertyItem(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hTask,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzTask::Submit(
    IN   LONG lFlags,
    IN   VARIANT varReserved)
{
    HRESULT  hr;
    DWORD    dwErr;

    //
    // Grab the lock so that close application does not 
    // interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );

    if (NULL == m_hTask)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Null AzTask");
    }
    else if (!IsObjectUsable(m_hOwnerApp, m_dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    dwErr = AzSubmit(m_hTask, lFlags, 0);
    _JumpIfWinError(dwErr, &hr, error, "AzSubmit");

    hr = S_OK;
error:

    AzpUnlockResource( &AzGlCloseApplication );

    return hr;
}


/////////////////////////
//CAzTasks
/////////////////////////
HRESULT
CAzTasks::_Init(
    IN AZ_HANDLE hOwnerApp,
    IN OPTIONAL VARIANT  *pvarReserved,
    IN  AZ_HANDLE   hParent)
{
    HRESULT  hr;
    ULONG    lContext = 0;
    IAzTask * pITask = NULL;

    m_hOwnerApp = hOwnerApp;
    if (hOwnerApp != NULL)
    {
        AzpLockResourceShared( &AzGlCloseApplication );
        m_dwOwnerAppSN = AzpRetrieveApplicationSequenceNumber(hOwnerApp);
        AzpUnlockResource( &AzGlCloseApplication );
    }
    else
    {
        m_dwOwnerAppSN = 0;
    }

    while (S_OK == (hr = myAzNextObject(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                AzTaskEnum,
                pvarReserved,
                ENUM_AZ_TASK,
                hParent,
                &lContext,
                (IUnknown**)&pITask)))
    {
        AZASSERT(NULL != (PVOID)pITask);

        //
        // myAddItemToMap will release the pITask
        //

        hr = myAddItemToMap<IAzTask>(&m_coll, &pITask);
        _JumpIfError(hr, error, "myAddItemToMap");
    }

    if (AZ_HRESULT(ERROR_NO_MORE_ITEMS) != hr)
    {
        _JumpError(hr, error, "myAzNextObject");
    }

    hr = S_OK;
error:
    return hr;
}


/////////////////////////
//CAzScope
/////////////////////////
CAzScope::CAzScope()
{
    //init
    __try {
        InitializeCriticalSection(&m_cs);
    } __except(EXCEPTION_EXECUTE_HANDLER) {}

    m_hScope = NULL;
}

CAzScope::~CAzScope()
{
    if (NULL != m_hScope)
    {
        // 
        // Grab the lock so that close application does not
        // interfere
        //

        AzpLockResourceShared( &AzGlCloseApplication );

        if (IsObjectUsable(m_hOwnerApp, m_dwOwnerAppSN))
        {
            AzCloseHandle(m_hScope, 0);
        }

        AzpUnlockResource( &AzGlCloseApplication );
    }
    DeleteCriticalSection(&m_cs);
}

HRESULT
CAzScope::_Init(
    IN   AZ_HANDLE  hOwnerApp,
    IN   AZ_HANDLE  hHandle)
{
    HRESULT hr;
    EnterCriticalSection(&m_cs);

    //init once
    AZASSERT(NULL != hHandle);
    AZASSERT(NULL == m_hScope);

    m_hScope = hHandle;

    m_hOwnerApp = hOwnerApp;
    if (hOwnerApp != NULL)
    {
        //
        // Grab lock to maintain order
        //

        AzpLockResourceShared( &AzGlCloseApplication );
        m_dwOwnerAppSN = AzpRetrieveApplicationSequenceNumber(hOwnerApp);
        AzpUnlockResource( &AzGlCloseApplication );
    }
    else
    {
        m_dwOwnerAppSN = 0;
    }

    hr = S_OK;
//error:
    LeaveCriticalSection(&m_cs);
    return hr;
}

HRESULT
CAzScope::get_Description(
    OUT  BSTR __RPC_FAR *pbstrDescription)
{
    return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_DESCRIPTION,
                pbstrDescription);
}

HRESULT
CAzScope::put_Description(
    IN  BSTR  bstrDescription)
{
    return mySetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_DESCRIPTION,
                bstrDescription);
}

HRESULT
CAzScope::get_Name(
    OUT  BSTR __RPC_FAR *pbstrName)
{
    return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_NAME,
                pbstrName);
}

HRESULT
CAzScope::put_Name(
    IN  BSTR  bstrName)
{
    return mySetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_NAME,
                bstrName);
}

HRESULT
CAzScope::get_ApplicationData(
    OUT  BSTR __RPC_FAR *pbstrApplicationData)
{
    return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_APPLICATION_DATA,
                pbstrApplicationData);
}

HRESULT
CAzScope::put_ApplicationData(
    IN  BSTR  bstrApplicationData)
{
    return mySetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_APPLICATION_DATA,
                bstrApplicationData);
}

HRESULT
CAzScope::get_Writable(
    OUT BOOL *pfProp)
{
        return myGetBoolProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_WRITABLE,
                pfProp);
}

HRESULT
CAzScope::GetProperty(
    IN   LONG  lPropId,
    IN   VARIANT varReserved,
    OUT  VARIANT *pvarProp)
{
    return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                lPropId,
                varReserved,
                pvarProp);
}

HRESULT
CAzScope::AddPropertyItem(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzAddPropertyItem(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzScope::DeletePropertyItem(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzDeletePropertyItem(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzScope::get_PolicyAdministrators(
    OUT  VARIANT *pvarProp)
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_POLICY_ADMINS,
                vtemp,
                pvarProp);
}

HRESULT
CAzScope::get_PolicyAdministratorsName(
    OUT VARIANT*        pvarAdminsName
    )
{
    CComVariant vtemp;
    return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_POLICY_ADMINS_NAME,
                vtemp,
                pvarAdminsName);
}

HRESULT
CAzScope::get_PolicyReaders(
    OUT  VARIANT *pvarProp)
{
         CComVariant vtemp;
         return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_POLICY_READERS,
                vtemp,
                pvarProp);
}


HRESULT
CAzScope::get_PolicyReadersName(
    OUT VARIANT*        pvarReadersName
    )
{
    CComVariant vtemp;
    return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_POLICY_READERS_NAME,
                vtemp,
                pvarReadersName);
}

HRESULT
CAzScope::AddPolicyAdministrator(
    IN   BSTR     bstrAdmin,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_POLICY_ADMINS,
                varReserved,
                bstrAdmin,
                TRUE);
}



HRESULT
CAzScope::AddPolicyAdministratorName(
    IN  BSTR        bstrAdminName,
    IN  VARIANT     varReserved
    )
{
    return myAzAddOrDeleteUser(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_POLICY_ADMINS_NAME,
                varReserved,
                bstrAdminName,
                TRUE);
}

HRESULT
CAzScope::DeletePolicyAdministrator(
    IN   BSTR     bstrAdmin,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_POLICY_ADMINS,
                varReserved,
                bstrAdmin,
                FALSE);
}



HRESULT
CAzScope::DeletePolicyAdministratorName(
    IN  BSTR        bstrAdminName,
    IN  VARIANT     varReserved
    )
{
    return myAzAddOrDeleteUser(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_POLICY_ADMINS_NAME,
                varReserved,
                bstrAdminName,
                FALSE);
}

HRESULT
CAzScope::AddPolicyReader(
    IN   BSTR     bstrReader,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_POLICY_READERS,
                varReserved,
                bstrReader,
                TRUE);
}

HRESULT
CAzScope::AddPolicyReaderName(
    IN  BSTR        bstrReaderName,
    IN  VARIANT     varReserved
    )
{
    return myAzAddOrDeleteUser(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_POLICY_READERS_NAME,
                varReserved,
                bstrReaderName,
                TRUE);
}

HRESULT
CAzScope::DeletePolicyReader(
    IN   BSTR     bstrReader,
    IN   VARIANT varReserved)
{
    return myAzAddOrDeleteUser(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_POLICY_READERS,
                varReserved,
                bstrReader,
                FALSE);
}

HRESULT
CAzScope::DeletePolicyReaderName(
    IN  BSTR        bstrReaderName,
    IN  VARIANT     varReserved
    )
{
    return myAzAddOrDeleteUser(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_POLICY_READERS_NAME,
                varReserved,
                bstrReaderName,
                FALSE);
}

HRESULT
CAzScope::SetProperty(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzSetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                lPropId,
                varReserved,
                &varProp);
}


HRESULT
CAzScope::get_ApplicationGroups(
    OUT  IAzApplicationGroups **ppGroups)
{
    CComVariant vtemp;
    return myAzNewObject(
                            m_hOwnerApp,   // owned by the same application
                            m_dwOwnerAppSN,
                            ENUM_AZ_GROUPS,
                            m_hScope,
                            &vtemp,
                            (IUnknown**)ppGroups);
}

HRESULT
CAzScope::OpenApplicationGroup(
    IN   BSTR bstrGroupName,
    IN   VARIANT varReserved,
    OUT  IAzApplicationGroup **ppGroup)
{
    HRESULT  hr;
    hr = myAzOpenObject(
                m_hOwnerApp,   // owned by the same application
                m_dwOwnerAppSN,
                AzGroupOpen,
                ENUM_AZ_GROUP,
                m_hScope,
                bstrGroupName,
                varReserved,
                (IUnknown**)ppGroup);
    return hr;
}

HRESULT
CAzScope::CreateApplicationGroup(
    IN   BSTR bstrGroupName,
    IN   VARIANT varReserved,
    OUT  IAzApplicationGroup **ppGroup)
{
    HRESULT  hr;
    hr = myAzCreateObject(
                m_hOwnerApp,   // owned by the same application
                m_dwOwnerAppSN,
                AzGroupCreate,
                ENUM_AZ_GROUP,
                m_hScope,
                bstrGroupName,
                varReserved,
                (IUnknown**)ppGroup);
    return hr;
}


HRESULT
CAzScope::DeleteApplicationGroup(
    IN   BSTR bstrGroupName,
    IN   VARIANT varReserved )
{
    HRESULT hr;

    hr = myAzDeleteObject(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                AzGroupDelete,
                m_hScope,
                bstrGroupName,
                varReserved);

    return hr;
}

HRESULT
CAzScope::get_Roles(
    OUT  IAzRoles **ppRoles)
{
    HRESULT hr;
    CComVariant vtemp;

    //
    // Grab lock to maintain order
    //

    AzpLockResourceShared( &AzGlCloseApplication );

    if (ppRoles == NULL)
    {
        hr = E_POINTER;
        _JumpIfError( hr, error, "Null AzRole");
    }

    *ppRoles = NULL;

    if (!IsObjectUsable(m_hOwnerApp, m_dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpIfError( hr, error, "Owning application was closed" );
    }

    hr = myAzNewObject(
                    m_hOwnerApp,
                    m_dwOwnerAppSN,
                    ENUM_AZ_ROLES,
                    m_hScope,
                    &vtemp,
                    (IUnknown**)ppRoles);

error:

    AzpUnlockResource( &AzGlCloseApplication );
    return hr;
}

HRESULT
CAzScope::OpenRole(
    IN   BSTR bstrRoleName,
    IN   VARIANT varReserved,
    OUT  IAzRole **ppRole)
{
    HRESULT hr;

    //
    // Grab lock to maintain order
    //

    AzpLockResourceShared( &AzGlCloseApplication );

    if (ppRole == NULL)
    {
        hr = E_POINTER;
        _JumpIfError( hr, error, "Null AzRole" );
    }

    *ppRole = NULL;

    if (!IsObjectUsable(m_hOwnerApp, m_dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpIfError( hr, error, "Owning application was closed" );
    }

    hr = myAzOpenObject(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                AzRoleOpen,
                ENUM_AZ_ROLE,
                m_hScope,
                bstrRoleName,
                varReserved,
                (IUnknown**)ppRole);

error:

    AzpUnlockResource( &AzGlCloseApplication );
    
    return hr;
}

HRESULT
CAzScope::CreateRole(
    IN   BSTR bstrRoleName,
    IN   VARIANT varReserved,
    OUT  IAzRole **ppRole)
{
    HRESULT hr;

    //
    // Grab lock to maintain locking order
    //

    AzpLockResourceShared( &AzGlCloseApplication );

    if (ppRole == NULL)
    {
        hr = E_POINTER;
        _JumpIfError( hr, error, "Null AzRole" );
    }

    *ppRole = NULL;

    if (!IsObjectUsable(m_hOwnerApp, m_dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpIfError( hr, error, "Owning application was closed" );
    }

    hr = myAzCreateObject(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                AzRoleCreate,
                ENUM_AZ_ROLE,
                m_hScope,
                bstrRoleName,
                varReserved,
                (IUnknown**)ppRole);

error:

    AzpUnlockResource( &AzGlCloseApplication );
    return hr;
}

HRESULT
CAzScope::DeleteRole(
    IN   BSTR bstrRoleName,
    IN   VARIANT varReserved )
{
    HRESULT hr;

    hr = myAzDeleteObject(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                AzRoleDelete,
                m_hScope,
                bstrRoleName,
                varReserved);

    return hr;
}

HRESULT
CAzScope::get_Tasks(
    OUT  IAzTasks **ppTasks)
{
    CComVariant vtemp;
    return myAzNewObject(
                        m_hOwnerApp,
                        m_dwOwnerAppSN,
                        ENUM_AZ_TASKS,
                        m_hScope,
                        &vtemp,
                        (IUnknown**)ppTasks);
}

HRESULT
CAzScope::OpenTask(
    IN   BSTR bstrTaskName,
    IN   VARIANT varReserved,
    OUT  IAzTask **ppTask)
{
    HRESULT  hr;
    hr = myAzOpenObject(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                AzTaskOpen,
                ENUM_AZ_TASK,
                m_hScope,
                bstrTaskName,
                varReserved,
                (IUnknown**)ppTask);
    return hr;
}

HRESULT
CAzScope::CreateTask(
    IN   BSTR bstrTaskName,
    IN   VARIANT varReserved,
    OUT  IAzTask **ppTask)
{
    HRESULT  hr;
    hr = myAzCreateObject(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                AzTaskCreate,
                ENUM_AZ_TASK,
                m_hScope,
                bstrTaskName,
                varReserved,
                (IUnknown**)ppTask);
    return hr;
}

HRESULT
CAzScope::DeleteTask(
    IN   BSTR bstrTaskName,
    IN   VARIANT varReserved )
{
    HRESULT hr;

    hr = myAzDeleteObject(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                AzTaskDelete,
                m_hScope,
                bstrTaskName,
                varReserved);

    return hr;
}

HRESULT
CAzScope::Submit(
    IN   LONG lFlags,
    IN   VARIANT varReserved)
{
    HRESULT  hr;
    DWORD    dwErr;


    //
    // grab the lock so that close application does not interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );
    
    if (NULL == m_hScope)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Null AzScope");
    }
    else if (!IsObjectUsable(m_hOwnerApp, m_dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }


    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    dwErr = AzSubmit(m_hScope, lFlags, 0);
    _JumpIfWinError(dwErr, &hr, error, "AzSubmit");

    hr = S_OK;
error:
    
    AzpUnlockResource( &AzGlCloseApplication );
    return hr;
}

HRESULT
CAzScope::get_CanBeDelegated(
    OUT BOOL *pfProp)
{
        return myGetBoolProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_SCOPE_CAN_BE_DELEGATED,
                pfProp);
}

HRESULT
CAzScope::get_BizrulesWritable(
    OUT BOOL *pfProp)
{
        return myGetBoolProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hScope,
                AZ_PROP_SCOPE_BIZRULES_WRITABLE,
                pfProp);
}


/////////////////////////
//CAzScopes
/////////////////////////
HRESULT
CAzScopes::_Init(
    IN AZ_HANDLE hOwnerApp,
    IN OPTIONAL VARIANT  *pvarReserved,
    IN  AZ_HANDLE   hParent)
{
    HRESULT  hr;
    ULONG    lContext = 0;
    IAzScope * pIScope = NULL;

    m_hOwnerApp = hOwnerApp;
    if (hOwnerApp != NULL)
    {
        //
        // Grab the lock to maintain order
        //
        AzpLockResourceShared( &AzGlCloseApplication );
        m_dwOwnerAppSN = AzpRetrieveApplicationSequenceNumber(hOwnerApp);
        AzpUnlockResource( &AzGlCloseApplication );
    }
    else
    {
        m_dwOwnerAppSN = 0;
    }

    while (S_OK == (hr = myAzNextObject(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                AzScopeEnum,
                pvarReserved,
                ENUM_AZ_SCOPE,
                hParent,
                &lContext,
                (IUnknown**)&pIScope)))
    {
        AZASSERT(NULL != (PVOID)pIScope);

        //
        // myAddItemToMap will release the pIScope
        //

        hr = myAddItemToMap<IAzScope>(&m_coll, &pIScope);
        _JumpIfError(hr, error, "myAddItemToMap");
    }

    if (AZ_HRESULT(ERROR_NO_MORE_ITEMS) != hr)
    {
        _JumpError(hr, error, "myAzNextObject");
    }

    hr = S_OK;
error:
    return hr;
}


/////////////////////////
//CAzApplicationGroup
/////////////////////////
CAzApplicationGroup::CAzApplicationGroup()
{
    //init
    __try {
        InitializeCriticalSection(&m_cs);
    } __except(EXCEPTION_EXECUTE_HANDLER) {}

    m_hGroup = NULL;
}

CAzApplicationGroup::~CAzApplicationGroup()
{
    if (NULL != m_hGroup)
    {
        //
        // Grab the lock so that close application does not interfere
        //

        AzpLockResourceShared( &AzGlCloseApplication );

        if (IsObjectUsable(m_hOwnerApp, m_dwOwnerAppSN))
        {
            AzCloseHandle(m_hGroup, 0);
        }

        AzpUnlockResource( &AzGlCloseApplication );
    }
    DeleteCriticalSection(&m_cs);
}

HRESULT
CAzApplicationGroup::_Init(
    IN   AZ_HANDLE  hOwnerApp,
    IN   AZ_HANDLE  hHandle)
{
    HRESULT hr;
    EnterCriticalSection(&m_cs);

    //init once
    AZASSERT(NULL != hHandle);
    AZASSERT(NULL == m_hGroup);

    m_hGroup = hHandle;

    m_hOwnerApp = hOwnerApp;
    if (hOwnerApp != NULL)
    {
        //
        // Grab the lock to maintain order
        //
        AzpLockResourceShared( &AzGlCloseApplication );
        m_dwOwnerAppSN = AzpRetrieveApplicationSequenceNumber(hOwnerApp);
        AzpUnlockResource( &AzGlCloseApplication );
    }
    else
    {
        m_dwOwnerAppSN = 0;
    }

    hr = S_OK;
//error:
    LeaveCriticalSection(&m_cs);
    return hr;
}

HRESULT CAzApplicationGroup::get_Type(
    OUT LONG         *plProp
    )
{
        return myGetLongProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_TYPE,
                plProp);
}

HRESULT CAzApplicationGroup::put_Type(
    IN LONG         lProp
    )
{
        return mySetLongProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_TYPE,
                lProp);
}

HRESULT CAzApplicationGroup::get_LdapQuery(
    OUT BSTR         *pbstrProp
    )
{
        return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_LDAP_QUERY,
                pbstrProp);
}

HRESULT CAzApplicationGroup::put_LdapQuery(
    IN BSTR         bstrProp
    )
{
        return mySetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_LDAP_QUERY,
                bstrProp);
}

HRESULT CAzApplicationGroup::get_AppMembers(
    OUT VARIANT         *pvarProp
    )
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_APP_MEMBERS,
                vtemp,
                pvarProp);
}

HRESULT CAzApplicationGroup::get_AppNonMembers(
    OUT VARIANT         *pvarProp
    )
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_APP_NON_MEMBERS,
                vtemp,
                pvarProp);
}

HRESULT CAzApplicationGroup::get_Members(
    OUT VARIANT         *pvarProp
    )
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_MEMBERS,
                vtemp,
                pvarProp);
}

HRESULT CAzApplicationGroup::get_MembersName(
    OUT VARIANT         *pvarProp
    )
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_MEMBERS_NAME,
                vtemp,
                pvarProp);
}

HRESULT CAzApplicationGroup::get_NonMembers(
    OUT VARIANT         *pvarProp
    )
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_NON_MEMBERS,
                vtemp,
                pvarProp);
}

HRESULT CAzApplicationGroup::get_NonMembersName(
    OUT VARIANT         *pvarProp
    )
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_NON_MEMBERS_NAME,
                vtemp,
                pvarProp);
}

HRESULT
CAzApplicationGroup::get_Description(
    OUT  BSTR __RPC_FAR *pbstrDescription)
{
    return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_DESCRIPTION,
                pbstrDescription);
}

HRESULT
CAzApplicationGroup::put_Description(
    IN  BSTR  bstrDescription)
{
    return mySetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_DESCRIPTION,
                bstrDescription);
}

HRESULT
CAzApplicationGroup::get_Name(
    OUT  BSTR __RPC_FAR *pbstrName)
{
    return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_NAME,
                pbstrName);
}

HRESULT
CAzApplicationGroup::put_Name(
    IN  BSTR  bstrName)
{
    return mySetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_NAME,
                bstrName);
}

HRESULT  CAzApplicationGroup::AddAppMember(
    IN              BSTR        bstrMember,
    IN  VARIANT varReserved
    )
{
        HRESULT hr;
        hr = myAzAddPropertyItemBstr(
                        m_hOwnerApp,
                        m_dwOwnerAppSN,
                        m_hGroup,
                        AZ_PROP_GROUP_APP_MEMBERS,
                        varReserved,
                        bstrMember);
        return hr;
}

HRESULT  CAzApplicationGroup::DeleteAppMember(
    IN            BSTR        bstrMember,
    IN VARIANT varReserved
    )
{
        HRESULT hr;
        hr = myAzDeletePropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_APP_MEMBERS,
                varReserved,
                bstrMember);
        return hr;
}

HRESULT  CAzApplicationGroup::AddAppNonMember(
    IN              BSTR        bstrNonMember,
    IN VARIANT varReserved
    )
{
        HRESULT hr;
        hr = myAzAddPropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_APP_NON_MEMBERS,
                varReserved,
                bstrNonMember);
        return hr;
}

HRESULT  CAzApplicationGroup::DeleteAppNonMember(
    IN            BSTR        bstrNonMember,
    IN VARIANT varReserved
    )
{
        HRESULT hr;
        CComVariant vtemp;
        hr = myAzDeletePropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_APP_NON_MEMBERS,
                varReserved,
                bstrNonMember);
        return hr;
}

HRESULT
CAzApplicationGroup::AddMember(
    IN   BSTR     bstrProp,
    IN   VARIANT varReserved)
{
        return myAzAddPropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_MEMBERS,
                varReserved,
                bstrProp);
}

HRESULT
CAzApplicationGroup::DeleteMember(
    IN   BSTR     bstrProp,
    IN   VARIANT varReserved)
{
        return myAzDeletePropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_MEMBERS,
                varReserved,
                bstrProp);
}

HRESULT
CAzApplicationGroup::AddMemberName(
    IN   BSTR     bstrProp,
    IN   VARIANT varReserved)
{
        return myAzAddPropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_MEMBERS_NAME,
                varReserved,
                bstrProp);
}

HRESULT
CAzApplicationGroup::DeleteMemberName(
    IN   BSTR     bstrProp,
    IN   VARIANT varReserved)
{
        return myAzDeletePropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_MEMBERS_NAME,
                varReserved,
                bstrProp);
}

HRESULT
CAzApplicationGroup::AddNonMember(
    IN   BSTR     bstrProp,
    IN   VARIANT varReserved)
{
        return myAzAddPropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_NON_MEMBERS,
                varReserved,
                bstrProp);
}

HRESULT
CAzApplicationGroup::DeleteNonMember(
    IN   BSTR     bstrProp,
    IN   VARIANT varReserved)
{
        return myAzDeletePropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_NON_MEMBERS,
                varReserved,
                bstrProp);
}

HRESULT
CAzApplicationGroup::AddNonMemberName(
    IN   BSTR     bstrProp,
    IN   VARIANT varReserved)
{
        return myAzAddPropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_NON_MEMBERS_NAME,
                varReserved,
                bstrProp);
}

HRESULT
CAzApplicationGroup::DeleteNonMemberName(
    IN   BSTR     bstrProp,
    IN   VARIANT varReserved)
{
        return myAzDeletePropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_GROUP_NON_MEMBERS_NAME,
                varReserved,
                bstrProp);
}

HRESULT
CAzApplicationGroup::get_Writable(
    OUT BOOL *pfProp)
{
        return myGetBoolProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                AZ_PROP_WRITABLE,
                pfProp);
}

HRESULT
CAzApplicationGroup::GetProperty(
    IN   LONG  lPropId,
    IN   VARIANT varReserved,
    OUT  VARIANT *pvarProp)
{
    return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                lPropId,
                varReserved,
                pvarProp);
}

HRESULT
CAzApplicationGroup::SetProperty(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzSetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzApplicationGroup::AddPropertyItem(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzAddPropertyItem(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzApplicationGroup::DeletePropertyItem(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzDeletePropertyItem(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hGroup,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzApplicationGroup::Submit(
    IN   LONG lFlags,
    IN   VARIANT varReserved)
{
    HRESULT  hr;
    DWORD    dwErr;

    //
    // Grab the lock so that close application does not interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );

    if (NULL == m_hGroup)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Null AzApplicationGroup");
    }
    else if (!IsObjectUsable(m_hOwnerApp, m_dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    dwErr = AzSubmit(m_hGroup, lFlags, 0);
    _JumpIfWinError(dwErr, &hr, error, "AzSubmit");

    hr = S_OK;
error:

    AzpUnlockResource( &AzGlCloseApplication );

    return hr;
}


/////////////////////////
//CAzApplicationGroups
/////////////////////////
HRESULT
CAzApplicationGroups::_Init(
    IN AZ_HANDLE hOwnerApp,
    IN OPTIONAL VARIANT  *pvarReserved,
    IN  AZ_HANDLE   hParent)
{
    HRESULT  hr;
    ULONG    lContext = 0;
    IAzApplicationGroup * pIGroup = NULL;

    m_hOwnerApp = hOwnerApp;
    if (hOwnerApp != NULL)
    {
        //
        // grab the lock to maintain order
        //
        AzpLockResourceShared( &AzGlCloseApplication );
        m_dwOwnerAppSN = AzpRetrieveApplicationSequenceNumber(hOwnerApp);
        AzpUnlockResource( &AzGlCloseApplication );
    }
    else
    {
        m_dwOwnerAppSN = 0;
    }

    while (S_OK == (hr = myAzNextObject(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                AzGroupEnum,
                pvarReserved,
                ENUM_AZ_GROUP,
                hParent,
                &lContext,
                (IUnknown**)&pIGroup)))
    {
        AZASSERT(NULL != (PVOID)pIGroup);

        //
        // myAddItemToMap will release the pIGroup
        //

        hr = myAddItemToMap<IAzApplicationGroup>(&m_coll, &pIGroup);
        _JumpIfError(hr, error, "myAddItemToMap");
    }

    if (AZ_HRESULT(ERROR_NO_MORE_ITEMS) != hr)
    {
        _JumpError(hr, error, "myAzNextObject");
    }

    hr = S_OK;
error:
    return hr;
}


/////////////////////////
//CAzRole
/////////////////////////
CAzRole::CAzRole()
{
    //init
    __try {
        InitializeCriticalSection(&m_cs);
    } __except(EXCEPTION_EXECUTE_HANDLER) {}

    m_hRole = NULL;
}

CAzRole::~CAzRole()
{
    if (NULL != m_hRole)
    {
        //
        // grab the lock so that close application does not interfere
        //

        AzpLockResourceShared( &AzGlCloseApplication );

        if (IsObjectUsable(m_hOwnerApp, m_dwOwnerAppSN))
        {
            AzCloseHandle(m_hRole, 0);
        }

        AzpUnlockResource( &AzGlCloseApplication );
    }
    DeleteCriticalSection(&m_cs);
}

HRESULT
CAzRole::_Init(
    IN   AZ_HANDLE  hOwnerApp,
    IN   AZ_HANDLE  hHandle)
{
    HRESULT hr;
    EnterCriticalSection(&m_cs);

    //init once
    AZASSERT(NULL != hHandle);
    AZASSERT(NULL == m_hRole);

    m_hRole = hHandle;

    m_hOwnerApp = hOwnerApp;
    if (hOwnerApp != NULL)
    {
        //
        // Grab the lock to maintain order
        //
        AzpLockResourceShared( &AzGlCloseApplication );
        m_dwOwnerAppSN = AzpRetrieveApplicationSequenceNumber(hOwnerApp);
        AzpUnlockResource( &AzGlCloseApplication );
    }
    else
    {
        m_dwOwnerAppSN = 0;
    }
    hr = S_OK;
//error:
    LeaveCriticalSection(&m_cs);
    return hr;
}

HRESULT
CAzRole::get_Description(
    OUT  BSTR __RPC_FAR *pbstrDescription)
{
    return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_DESCRIPTION,
                pbstrDescription);
}

HRESULT
CAzRole::put_Description(
    IN  BSTR  bstrDescription)
{
    return mySetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_DESCRIPTION,
                bstrDescription);
}

HRESULT
CAzRole::get_Name(
    OUT  BSTR __RPC_FAR *pbstrName)
{
    return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_NAME,
                pbstrName);
}

HRESULT
CAzRole::put_Name(
    IN  BSTR  bstrName)
{
    return mySetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_NAME,
                bstrName);
}

HRESULT
CAzRole::get_ApplicationData(
    OUT  BSTR __RPC_FAR *pbstrApplicationData)
{
    return myGetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_APPLICATION_DATA,
                pbstrApplicationData);
}

HRESULT
CAzRole::put_ApplicationData(
    IN  BSTR  bstrApplicationData)
{
    return mySetBstrProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_APPLICATION_DATA,
                bstrApplicationData);
}

HRESULT CAzRole::get_AppMembers(
    OUT VARIANT *pvarProp
)
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_ROLE_APP_MEMBERS,
                vtemp,
                pvarProp);
}

HRESULT CAzRole::get_Members(
    OUT VARIANT *pvarProp
)
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_ROLE_MEMBERS,
                vtemp,
                pvarProp);
}

HRESULT CAzRole::get_MembersName(
    OUT VARIANT *pvarProp
)
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_ROLE_MEMBERS_NAME,
                vtemp,
                pvarProp);
}

HRESULT CAzRole::get_Operations(
    OUT VARIANT *pvarProp
)
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_ROLE_OPERATIONS,
                vtemp,
                pvarProp);
}

HRESULT CAzRole::get_Tasks(
    OUT VARIANT *pvarProp
)
{
        CComVariant vtemp;
        return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_ROLE_TASKS,
                vtemp,
                pvarProp);
}

HRESULT  CAzRole::AddAppMember(
    IN              BSTR        bstrProp,
    IN VARIANT varReserved
    )
{
        HRESULT hr;
        hr = myAzAddPropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_ROLE_APP_MEMBERS,
                varReserved,
                bstrProp);
        return hr;
}

HRESULT  CAzRole::DeleteAppMember(
    IN            BSTR        bstrProp,
    IN VARIANT varReserved
    )
{
        HRESULT hr;
        hr = myAzDeletePropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_ROLE_APP_MEMBERS,
                varReserved,
                bstrProp);
        return hr;
}

HRESULT  CAzRole::AddTask(
    IN              BSTR        bstrProp,
    IN VARIANT varReserved
    )
{
        HRESULT hr;
        hr = myAzAddPropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_ROLE_TASKS,
                varReserved,
                bstrProp);
        return hr;
}

HRESULT  CAzRole::DeleteTask(
    IN            BSTR        bstrProp,
    IN VARIANT varReserved
    )
{
        HRESULT hr;
        CComVariant vtemp;
        hr = myAzDeletePropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_ROLE_TASKS,
                varReserved,
                bstrProp);
        return hr;
}

HRESULT  CAzRole::AddOperation(
    IN              BSTR        bstrProp,
    IN VARIANT varReserved
    )
{
        HRESULT hr;
        CComVariant vtemp;
        hr = myAzAddPropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_ROLE_OPERATIONS,
                varReserved,
                bstrProp);
        return hr;
}

HRESULT  CAzRole::DeleteOperation(
    IN            BSTR        bstrProp,
    IN VARIANT varReserved
    )
{
        HRESULT hr;
        CComVariant vtemp;
        hr = myAzDeletePropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_ROLE_OPERATIONS,
                varReserved,
                bstrProp);
        return hr;
}

HRESULT
CAzRole::AddMember(
    IN   BSTR     bstrProp,
    IN   VARIANT varReserved)
{
        return myAzAddPropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_ROLE_MEMBERS,
                varReserved,
                bstrProp);
}

HRESULT
CAzRole::DeleteMember(
    IN   BSTR     bstrProp,
    IN   VARIANT varReserved)
{
        return myAzDeletePropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_ROLE_MEMBERS,
                varReserved,
                bstrProp);
}

HRESULT
CAzRole::AddMemberName(
    IN   BSTR     bstrProp,
    IN   VARIANT varReserved)
{
        return myAzAddPropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_ROLE_MEMBERS_NAME,
                varReserved,
                bstrProp);
}

HRESULT
CAzRole::DeleteMemberName(
    IN   BSTR     bstrProp,
    IN   VARIANT varReserved)
{
        return myAzDeletePropertyItemBstr(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_ROLE_MEMBERS_NAME,
                varReserved,
                bstrProp);
}

HRESULT
CAzRole::get_Writable(
    OUT BOOL *pfProp)
{
        return myGetBoolProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                AZ_PROP_WRITABLE,
                pfProp);
}

HRESULT
CAzRole::GetProperty(
    IN   LONG  lPropId,
    IN   VARIANT varReserved,
    OUT  VARIANT *pvarProp)
{
    return myAzGetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                lPropId,
                varReserved,
                pvarProp);
}

HRESULT
CAzRole::SetProperty(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzSetProperty(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzRole::AddPropertyItem(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzAddPropertyItem(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzRole::DeletePropertyItem(
    IN   LONG  lPropId,
    IN   VARIANT varProp,
    IN   VARIANT varReserved )
{
    return myAzDeletePropertyItem(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                m_hRole,
                lPropId,
                varReserved,
                &varProp);
}

HRESULT
CAzRole::Submit(
    IN   LONG lFlags,
    IN   VARIANT varReserved)
{
    HRESULT  hr;
    DWORD    dwErr;

    //
    // grab the lock so that close application does not interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );

    if (NULL == m_hRole)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Null AzRole");
    }
    else if (!IsObjectUsable(m_hOwnerApp, m_dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    hr = HandleReserved( &varReserved );
    _JumpIfError(hr, error, "HandleReserved");

    dwErr = AzSubmit(m_hRole, lFlags, 0);
    _JumpIfWinError(dwErr, &hr, error, "AzSubmit");

    hr = S_OK;
error:

    AzpUnlockResource( &AzGlCloseApplication );

    return hr;
}


/////////////////////////
//CAzRoles
/////////////////////////
HRESULT
CAzRoles::_Init(
    IN AZ_HANDLE hOwnerApp,
    IN OPTIONAL VARIANT  *pvarReserved,
    IN  AZ_HANDLE   hParent)
{
    HRESULT  hr;
    ULONG    lContext = 0;
    IAzRole * pIRole = NULL;

    m_hOwnerApp = hOwnerApp;
    if (hOwnerApp != NULL)
    {
        //
        // Grab the lock to maintain order
        //
        AzpLockResourceShared( &AzGlCloseApplication );
        m_dwOwnerAppSN = AzpRetrieveApplicationSequenceNumber(hOwnerApp);
        AzpLockResourceShared( &AzGlCloseApplication );
    }
    else
    {
        m_dwOwnerAppSN = 0;
    }

    while (S_OK == (hr = myAzNextObject(
                m_hOwnerApp,
                m_dwOwnerAppSN,
                AzRoleEnum,
                pvarReserved,
                ENUM_AZ_ROLE,
                hParent,
                &lContext,
                (IUnknown**)&pIRole)))
    {
        AZASSERT(NULL != (PVOID)pIRole);

        //
        // myAddItemToMap will release the pIRole
        //

        hr = myAddItemToMap<IAzRole>(&m_coll, &pIRole);
        _JumpIfError(hr, error, "myAddItemToMap");
    }

    if (AZ_HRESULT(ERROR_NO_MORE_ITEMS) != hr)
    {
        _JumpError(hr, error, "myAzNextObject");
    }

    hr = S_OK;
error:
    return hr;
}


/////////////////////////
//CAzClientContext
/////////////////////////
CAzClientContext::CAzClientContext()
{
    //init
    __try {
        InitializeCriticalSection(&m_cs);
    } __except(EXCEPTION_EXECUTE_HANDLER) {}

    m_hClientContext = NULL;
    m_pwszBusinessRuleString = NULL;
}

CAzClientContext::~CAzClientContext()
{
    if (NULL != m_hClientContext)
    {
        //
        // grab the lock so that close application does not interfere
        //

        AzpLockResourceShared( &AzGlCloseApplication );

        if (IsObjectUsable(m_hOwnerApp, m_dwOwnerAppSN))
        {
            AzCloseHandle(m_hClientContext, 0);
        }
        m_hClientContext = NULL;

        AzpUnlockResource( &AzGlCloseApplication );
    }
    if (NULL != m_pwszBusinessRuleString)
    {
        AzpFreeHeap(m_pwszBusinessRuleString );
        m_pwszBusinessRuleString = NULL;
    }

    DeleteCriticalSection(&m_cs);
}

HRESULT
CAzClientContext::AccessCheck(
    IN   BSTR bstrObjectName,
    IN   VARIANT varScopeNames,
    IN   VARIANT varOperations,
    IN   VARIANT varParameterNames,
    IN   VARIANT varParameterValues,
    IN   VARIANT varInterfaceNames,
    IN   VARIANT varInterfaceFlags,
    IN   VARIANT varInterfaces,
    OUT  VARIANT *pvarResults)
{
    HRESULT hr;
    DWORD   dwErr;
    ULONG    lScopeCount;
    LPCWSTR *ppwszScopeNames = NULL;

    //
    // This is the alias of the scope names that we will pass to the core
    // It may be NULL if all passed in scope elements are empty, thus allow
    // the use of default scope.
    //

    LPCWSTR *ppNonEmptyScopeNames = ppwszScopeNames;

    ULONG   lOperationCount;
    LONG   *plOperations = NULL;
    ULONG   *plResults = NULL;
    WCHAR  *pwszBusinessRuleString = NULL;

    SAFEARRAY      *psaScopes = NULL;
    VARIANT HUGEP  *pvarScopes;
    SAFEARRAY      *psaOperations = NULL;
    VARIANT HUGEP  *pvarOperations;
    VARIANT         varResults;
    ULONG            i;
    SAFEARRAYBOUND   rgsaBound[1]; //one dimension array
    SAFEARRAY       *psaResults = NULL;
    long             lArrayIndex[1]; //one dimension

    //
    // The following variants are guaranteed to be safearrays
    //

    VARIANT varSAParameterNames;
    VARIANT varSAParameterValues;
    VARIANT varSAInterfaceNames;
    VARIANT varSAInterfaceFlags;
    VARIANT varSAInterfaces;
    VariantInit(&varSAParameterNames);
    VariantInit(&varSAParameterValues);
    VariantInit(&varSAInterfaceNames);
    VariantInit(&varSAInterfaceFlags);
    VariantInit(&varSAInterfaces);

    AZASSERT(NULL != pvarResults);

    AZASSERT(NULL != m_hClientContext);

    // init
    VariantInit(pvarResults);

    //
    // Grab the lock so that Close application does not interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );

    //
    // we need to protect our instance data
    //

    EnterCriticalSection(&m_cs);

    if (NULL != m_pwszBusinessRuleString)
    {
        AzpFreeHeap(m_pwszBusinessRuleString );
        m_pwszBusinessRuleString = NULL;
    }

    if (!IsObjectUsable(m_hOwnerApp, m_dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    // prepare input data

    //
    // Validate the scope names array
    //

    if (varScopeNames.vt == VT_DISPATCH)
    {
        hr = AzpGetSafearrayFromArrayObject(varScopeNames, &psaScopes );
        _JumpIfError(hr, error, "AzpGetPtrFromArrayObject");
    }
    else
    {
        dwErr = AzpSafeArrayPointerFromVariant(
                        &varScopeNames,
                        TRUE, // VT_EMPTY is to be allowed
                        &psaScopes );
        _JumpIfWinError(dwErr, &hr, error, "AzpSafeArrayPointerFromVariant");
    }

    //
    // If VT_EMPTY was passed, then we use the default scope
    // Otherwise, get the list of scopes passed in
    //

    if ( psaScopes != NULL ) {

        hr = SafeArrayAccessData(
                 psaScopes,
                 (void HUGEP **)&pvarScopes);
        _JumpIfError(hr, error, "SafeArrayAccessData");

        // get the count of scopes
        lScopeCount = psaScopes->rgsabound[0].cElements;
        if ( lScopeCount == 0 ) {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "invalid Scope count");
        }

        // Allocate a array of LPWSTRs
        SafeAllocaAllocate( ppwszScopeNames, lScopeCount*sizeof(LPWSTR) );
        _JumpIfOutOfMemory(&hr, error, ppwszScopeNames, "AzpAllocateHeap");

        //
        // We may see empty scopes being passed in. We will reply
        // on this pass to find out how many non-empty scopes we have
        //

        lScopeCount = 0;

        // Fill in the array of LPSWTRs
        for ( i=0; i<psaScopes->rgsabound[0].cElements; i++) {

            ppwszScopeNames[i] = NULL;
            if ( V_VT(&pvarScopes[i]) == VT_BSTR ) {

                //
                // we will regard NULL bstr (which is possible from C++ code or empty
                // string ("") as an empty scope. This provides the best programming
                // experience for scripting clients.
                //

                if (pvarScopes[i].bstrVal != NULL && wcslen(pvarScopes[i].bstrVal) != 0)
                {
                    ++lScopeCount;
                    ppwszScopeNames[i] = V_BSTR(&pvarScopes[i]);
                }
            }
            else if (V_VT(&pvarScopes[i]) != VT_EMPTY ) {
                hr = E_INVALIDARG;
                _JumpError(hr, error, "invalid scope data type");
            }
        }

        //
        // If we end up having no non-empty scopes, then we should
        // pass a NULL to the core. The core enforces that if the scope
        // count is 0, the scope name parameter must be NULL.
        //

        if (lScopeCount == 0)
        {
            ppNonEmptyScopeNames = NULL;
        }
        else
        {
            ppNonEmptyScopeNames = ppwszScopeNames;
        }

    } else { // if ( psaScopes != NULL )

        lScopeCount = 0;
    }

    //
    // Validate the operations array
    //

    if (varOperations.vt == VT_DISPATCH)
    {
        hr = AzpGetSafearrayFromArrayObject(varOperations, &psaOperations );
        _JumpIfError(hr, error, "AzpGetPtrFromArrayObject");
    }
    else
    {
        dwErr = AzpSafeArrayPointerFromVariant(
                        &varOperations,
                        FALSE,
                        &psaOperations );
        _JumpIfWinError(dwErr, &hr, error, "AzpSafeArrayPointerFromVariant");
    }

    AZASSERT(NULL != psaOperations);

    hr = SafeArrayAccessData(
                psaOperations,
                (void HUGEP **)&pvarOperations);
    _JumpIfError(hr, error, "SafeArrayAccessData");

    // get the count of operations
    lOperationCount = psaOperations->rgsabound[0].cElements;
    if ( lOperationCount == 0 ) {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "invalid operation count");
    }

    // Allocate a array of ULONGs
    SafeAllocaAllocate( plOperations, lOperationCount*sizeof(ULONG) );
    _JumpIfOutOfMemory(&hr, error, plOperations, "AzpAllocateHeap");

    // Fill in the array of ULONGs
    for ( i=0; i<lOperationCount; i++) {
        if ( V_VT(&pvarOperations[i]) == VT_EMPTY ) {
            lOperationCount = i;
            if ( lOperationCount == 0 ) {
                hr = E_INVALIDARG;
                _JumpError(hr, error, "invalid operation count");
            }
            break;
        }
        if ( V_VT(&pvarOperations[i]) == VT_I4 ) {
            plOperations[i] = V_I4(&pvarOperations[i]);
        } else if ( V_VT(&pvarOperations[i]) == VT_I2 ) {
            plOperations[i] = V_I2(&pvarOperations[i]);
        } else {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "invalid Operation data type");
        }

    }

    //
    // prepare the other parameters if they are JScript style
    // array objects.
    // If these local VARIANT variables are set to VT_EMPTY,
    // it indicates that AzContextAccessCheck should not
    // use this parameter. It should use the passed in parameter
    // directly
    //

    //
    // The parameter names
    //

    if (varParameterNames.vt == VT_DISPATCH)
    {
        SAFEARRAY * psaParam = NULL;
        hr = AzpGetSafearrayFromArrayObject(varParameterNames, &psaParam);
        if (SUCCEEDED(hr))
        {
            varSAParameterNames.vt = VT_ARRAY | VT_VARIANT;
            varSAParameterNames.parray = psaParam;
        }
        _JumpIfError(hr, error, "AzpGetPtrFromArrayObject");
    }

    //
    // The parameter values
    //

    if (varParameterValues.vt == VT_DISPATCH)
    {
        SAFEARRAY * psaParam = NULL;
        hr = AzpGetSafearrayFromArrayObject(varParameterValues, &psaParam);
        if (SUCCEEDED(hr))
        {
            varSAParameterValues.vt = VT_ARRAY | VT_VARIANT;
            varSAParameterValues.parray = psaParam;
        }
        _JumpIfError(hr, error, "AzpGetPtrFromArrayObject");
    }

    //
    // The interface names
    //

    if (varInterfaceNames.vt == VT_DISPATCH)
    {
        SAFEARRAY * psaParam = NULL;
        hr = AzpGetSafearrayFromArrayObject(varInterfaceNames, &psaParam);
        if (SUCCEEDED(hr))
        {
            varSAInterfaceNames.vt = VT_ARRAY | VT_VARIANT;
            varSAInterfaceNames.parray = psaParam;
        }
        _JumpIfError(hr, error, "AzpGetPtrFromArrayObject");
    }

    //
    // The interface flags
    //

    if (varInterfaceFlags.vt == VT_DISPATCH)
    {
        SAFEARRAY * psaParam = NULL;
        hr = AzpGetSafearrayFromArrayObject(varInterfaceFlags, &psaParam);
        if (SUCCEEDED(hr))
        {
            varSAInterfaceFlags.vt = VT_ARRAY | VT_VARIANT;
            varSAInterfaceFlags.parray = psaParam;
        }
        _JumpIfError(hr, error, "AzpGetPtrFromArrayObject");
    }

    //
    // The interfaces
    //

    if (varInterfaces.vt == VT_DISPATCH)
    {
        SAFEARRAY * psaParam = NULL;
        hr = AzpGetSafearrayFromArrayObject(varInterfaces, &psaParam);
        if (SUCCEEDED(hr))
        {
            varSAInterfaces.vt = VT_ARRAY | VT_VARIANT;
            varSAInterfaces.parray = psaParam;
        }
        _JumpIfError(hr, error, "AzpGetPtrFromArrayObject");
    }

    //
    // allocate operation results for output
    //
    SafeAllocaAllocate( plResults, lOperationCount*sizeof(ULONG) );
    _JumpIfOutOfMemory(&hr, error, plResults, "AzpAllocateHeap");

    //now we are ready to access check
    dwErr = AzContextAccessCheck(
                    m_hOwnerApp,
                    m_dwOwnerAppSN,
                    m_hClientContext,
                    bstrObjectName,
                    lScopeCount,
                    ppNonEmptyScopeNames,
                    lOperationCount,
                    plOperations,
                    plResults,
                    &pwszBusinessRuleString,
                    (varSAParameterNames.vt == VT_EMPTY)    ? &varParameterNames  : &varSAParameterNames,
                    (varSAParameterValues.vt == VT_EMPTY)   ? &varParameterValues : &varSAParameterValues,
                    (varSAInterfaceNames.vt == VT_EMPTY)    ? &varInterfaceNames  : &varSAInterfaceNames,
                    (varSAInterfaceFlags.vt == VT_EMPTY)    ? &varInterfaceFlags  : &varSAInterfaceFlags,
                    (varSAInterfaces.vt == VT_EMPTY)        ? &varInterfaces      : &varSAInterfaces
                    );

    _JumpIfWinError(dwErr, &hr, error, "AzContextAccessCheck");

    // save business rule string
    m_pwszBusinessRuleString = pwszBusinessRuleString;
    pwszBusinessRuleString = NULL;

    // convert results to variant for output

    rgsaBound[0].lLbound = 0; //array index from 0
    rgsaBound[0].cElements = lOperationCount;

    //create array descriptor
    psaResults = SafeArrayCreate(
                     VT_VARIANT,  //base type of array element
                     1,        //count of bound, ie. one dimension
                     rgsaBound);
    _JumpIfOutOfMemory(&hr, error, psaResults, "SafeArrayCreate");

    //init to 1st element
    lArrayIndex[0] = 0;

    //loop to load and put strings
    for (i = 0; i < lOperationCount; ++i)
    {

        VARIANT var;

        VariantInit( &var );
        V_VT(&var) = VT_I4;
        V_I4(&var) = plResults[i];


        //put into array
        hr = SafeArrayPutElement(
                    psaResults,
                    lArrayIndex,
                    &var );
        _JumpIfError(hr, error, "SafeArrayPutElement");

        //adjust index for the next element in array
        ++(lArrayIndex[0]);
    }

    //for return
    VariantInit(&varResults);
    V_VT(&varResults) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(&varResults) = psaResults;
    psaResults = NULL;
    *pvarResults = varResults;

    hr = S_OK;
error:

    LeaveCriticalSection(&m_cs);

    if (NULL != psaScopes)
    {
        SafeArrayUnaccessData(psaScopes);
    }
    if (NULL != psaOperations)
    {
        SafeArrayUnaccessData(psaOperations);
    }
    if (NULL != pwszBusinessRuleString)
    {
        AzpFreeHeap(pwszBusinessRuleString );
    }
    if (NULL != psaResults)
    {
        SafeArrayDestroy(psaResults);
    }

    SafeAllocaFree( ppwszScopeNames );
    SafeAllocaFree( plOperations );
    SafeAllocaFree( plResults );

    VariantClear(&varSAParameterNames);
    VariantClear(&varSAParameterValues);
    VariantClear(&varSAInterfaceNames);
    VariantClear(&varSAInterfaceFlags);
    VariantClear(&varSAInterfaces);

    AzpUnlockResource( &AzGlCloseApplication );

    return hr;
}

HRESULT
CAzClientContext::GetRoles(
    IN   OPTIONAL BSTR bstrScopeName,
    OUT  VARIANT *pvarRoleNames)
{
    HRESULT hr = S_OK;
    DWORD Count = 0;
    LPWSTR *Strings = NULL;
    DWORD dwErr = NO_ERROR;
    BSTR    bstrProp;
    VARIANT varRoleNames;
    VARIANT TempVariant;
    SAFEARRAYBOUND   rgsaBound[1]; //one dimension array
    SAFEARRAY       *psaString = NULL;
    long             lArrayIndex[1]; //one dimension
    DWORD            i;
    BSTR bstrLocal = NULL;

    AZASSERT(NULL != pvarRoleNames);
    AZASSERT(NULL != m_hClientContext);

    //init
    VariantInit(pvarRoleNames);
    VariantInit( &TempVariant );

    //
    // Grab the lock so that close application does not interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );

    if (!IsObjectUsable(m_hOwnerApp, m_dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    //
    // We get an empty string from the caller if no argument is supplied. Supply
    // ScopeName to NULL if we get an empty string.
    //

    if (ARGUMENT_PRESENT(bstrScopeName)) {
        if (bstrScopeName[0]) {
            bstrLocal = bstrScopeName;
        }
    }

    dwErr = AzContextGetRoles(
                m_hClientContext,
                bstrLocal,
                &Strings,
                &Count );

    _JumpIfWinError(dwErr, &hr, error, "AzContextAccessCheck");

    VariantInit(&varRoleNames);
    rgsaBound[0].lLbound = 0; //array index from 0
    rgsaBound[0].cElements = Count;

    //create array descriptor
    psaString = SafeArrayCreate(
            VT_VARIANT,  //base type of array element
            1,        //count of bound, ie. one dimension
            rgsaBound);
    _JumpIfOutOfMemory(&hr, error, psaString, "SafeArrayCreate");

    //init to 1st element
    lArrayIndex[0] = 0;

    //loop to load and put strings
    for (i = 0; i < Count; ++i)
    {
        //1st, create an element in BSTR
        bstrProp = SysAllocString(Strings[i]);
        _JumpIfOutOfMemory(&hr, error, bstrProp, "SysAllocString");

        //
        // Fill in a temporary variant
        //
        VariantClear( &TempVariant );
        V_VT(&TempVariant) = VT_BSTR;
        V_BSTR(&TempVariant) = bstrProp;


        //put into array
        hr = SafeArrayPutElement(psaString, lArrayIndex, &TempVariant);
        _JumpIfError(hr, error, "SafeArrayPutElement");

        //adjust index for the next element in array
        ++(lArrayIndex[0]);
    }

    //for return
    varRoleNames.vt = VT_ARRAY | VT_VARIANT;
    varRoleNames.parray = psaString;
    psaString = NULL;

    //return
    *pvarRoleNames = varRoleNames;

    hr = S_OK;
error:
    if (NULL != Strings)
    {
        AzFreeMemory(Strings);
    }
    if (NULL != psaString)
    {
        SafeArrayDestroy(psaString);
    }
    VariantClear( &TempVariant );

    AzpUnlockResource( &AzGlCloseApplication );

    return hr;
}

HRESULT
CAzClientContext::GetBusinessRuleString(
    OUT  BSTR *pbstrBusinessRuleString)
{
    HRESULT hr;

    AZASSERT(NULL != pbstrBusinessRuleString);

    //
    // Grab the lock so that close application does not interfere
    //

    AzpLockResourceShared( &AzGlCloseApplication );

    if (!IsObjectUsable(m_hOwnerApp, m_dwOwnerAppSN))
    {
        hr = AZ_HR_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "Owning application was closed.");
    }

    if ( m_pwszBusinessRuleString == NULL ) {
        *pbstrBusinessRuleString = NULL;
    } else {
        *pbstrBusinessRuleString = SysAllocString(m_pwszBusinessRuleString);
        _JumpIfOutOfMemory(&hr, error, *pbstrBusinessRuleString, "SysAllocString");
    }

    hr = S_OK;
error:

    AzpUnlockResource( &AzGlCloseApplication );

    return hr;
}

HRESULT CAzClientContext::get_UserDn(
    OUT BSTR *pbstrProp
    )
{
    return myGetBstrProperty(
                m_hOwnerApp, 
                m_dwOwnerAppSN,
                m_hClientContext,
                AZ_PROP_CLIENT_CONTEXT_USER_DN,
                pbstrProp);
}

HRESULT CAzClientContext::get_UserSamCompat(
    OUT BSTR *pbstrProp
    )
{
    return myGetBstrProperty(
                m_hOwnerApp, 
                m_dwOwnerAppSN,
                m_hClientContext,
                AZ_PROP_CLIENT_CONTEXT_USER_SAM_COMPAT,
                pbstrProp);
}

HRESULT CAzClientContext::get_UserDisplay(
    OUT BSTR *pbstrProp
    )
{
    return myGetBstrProperty(
                m_hOwnerApp, 
                m_dwOwnerAppSN,
                m_hClientContext,
                AZ_PROP_CLIENT_CONTEXT_USER_DISPLAY,
                pbstrProp);
}

HRESULT CAzClientContext::get_UserGuid(
    OUT BSTR *pbstrProp
    )
{
        CComVariant vtemp;
    return myGetBstrProperty(
                m_hOwnerApp, 
                m_dwOwnerAppSN,
                m_hClientContext,
                AZ_PROP_CLIENT_CONTEXT_USER_GUID,
                pbstrProp);
}

HRESULT CAzClientContext::get_UserCanonical(
    OUT BSTR *pbstrProp
    )
{
    return myGetBstrProperty(
                m_hOwnerApp, 
                m_dwOwnerAppSN,
                m_hClientContext,
                AZ_PROP_CLIENT_CONTEXT_USER_CANONICAL,
                pbstrProp);
}

HRESULT CAzClientContext::get_UserUpn(
    OUT BSTR *pbstrProp
    )
{
    return myGetBstrProperty(
                m_hOwnerApp, 
                m_dwOwnerAppSN,
                m_hClientContext,
                AZ_PROP_CLIENT_CONTEXT_USER_UPN,
                pbstrProp);
}

HRESULT CAzClientContext::get_UserDnsSamCompat(
    OUT BSTR *pbstrProp
    )
{
    return myGetBstrProperty(
                m_hOwnerApp, 
                m_dwOwnerAppSN,
                m_hClientContext,
                AZ_PROP_CLIENT_CONTEXT_USER_DNS_SAM_COMPAT,
                pbstrProp);
}

HRESULT
CAzClientContext::GetProperty(
    IN   LONG  lPropId,
    IN   VARIANT varReserved,
    OUT  VARIANT *pvarProp)
{
    return myAzGetProperty(
                m_hOwnerApp, 
                m_dwOwnerAppSN,
                m_hClientContext,
                lPropId,
                varReserved,
                pvarProp);
}

HRESULT CAzClientContext::get_RoleForAccessCheck(
    OUT BSTR *pbstrProp
    )
{
    return myGetBstrProperty(
                m_hOwnerApp, 
                m_dwOwnerAppSN,
                m_hClientContext,
                AZ_PROP_CLIENT_CONTEXT_ROLE_FOR_ACCESS_CHECK,
                pbstrProp);
}

HRESULT CAzClientContext::put_RoleForAccessCheck(
    IN BSTR bstrProp
    )
{
    return mySetBstrProperty(
                m_hOwnerApp, 
                m_dwOwnerAppSN,
                m_hClientContext,
                AZ_PROP_CLIENT_CONTEXT_ROLE_FOR_ACCESS_CHECK,
                bstrProp);
}

HRESULT
CAzClientContext::_Init(
    IN  AZ_HANDLE   hOwnerApp,
    IN  AZ_HANDLE   hHandle,
    IN  LONG        lReserved)
{
    HRESULT hr;
    EnterCriticalSection(&m_cs);

    //init once
    AZASSERT(NULL == m_hClientContext);
    AZASSERT(NULL != hHandle);

    m_hClientContext = hHandle;
    m_lReserved = lReserved;

    m_hOwnerApp = hOwnerApp;
    if (hOwnerApp != NULL)
    {
        //
        //Grab the lock to maintain order
        //
        AzpLockResourceShared( &AzGlCloseApplication );
        m_dwOwnerAppSN = AzpRetrieveApplicationSequenceNumber(hOwnerApp);
        AzpUnlockResource( &AzGlCloseApplication );
    }
    else
    {
        m_dwOwnerAppSN = 0;
    }

    hr = S_OK;
//error:
    LeaveCriticalSection(&m_cs);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\app.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    app.cxx

Abstract:

    Routines implementing the Application object

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/

#include "pch.hxx"

//
// Define the default values for all scalar attributes
//


AZP_DEFAULT_VALUE AzGlApplicationDefaultValues[] = {
    { AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID, AZ_DIRTY_APPLICATION_AUTHZ_INTERFACE_CLSID, NULL },
    { AZ_PROP_APPLICATION_VERSION,               AZ_DIRTY_APPLICATION_VERSION,               NULL },
    { 0, 0, NULL }
};


DWORD
AzpApplicationGenerateInitializationAudit(
    PAZP_APPLICATION Application,
    PAZP_AZSTORE AzAuthorizationStore
    )
/*++

Routine Description:

   This routine generates an application initialization audit.

Arguments:
    Application - Application which just initialized.

    AzAuthorizationStore - Authorization Store maitaining the application.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    DWORD WinStatus = NO_ERROR;
    AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent = NULL;
    PAUDIT_PARAMS pAuditParams = NULL;
    BOOL b;

    //
    // If audit handle is NULL, then do no generate any audits
    //

    if ( (AzAuthorizationStore->hApplicationInitializationAuditEventType == NULL) ) {
        
        return NO_ERROR;
    }

    //
    // The audit format will be as follows:
    //   %tApplication Name:%t%1%n
    //   %tApplication Instance ID:%t%2%n
    //   %tClient Name:%t%3%n
    //   %tClient Domain:%t%4%n
    //   %tClient ID:%t%5%n
    //   %tPolicy Store URL:%t%6%n
    //

    if (!AuthziAllocateAuditParams(
            &pAuditParams,
            AZP_APPINIT_AUDITPARAMS_NO
            )) {
    
                goto Cleanup;
    }

    //
    // Put the audit parameters in the array.
    //

    b = AuthziInitializeAuditParamsWithRM( APF_AuditSuccess,
                                           Application->AuthzResourceManager,
                                           AZP_APPINIT_AUDITPARAMS_NO,
                                           pAuditParams,
                                           APT_String,Application->GenericObject.ObjectName->ObjectName.String,
                                           APT_Luid, Application->InstanceId,
                                           APT_LogonId | AP_PrimaryLogonId,
                                           APT_String, AzAuthorizationStore->PolicyUrl.String );

    if ( !b ) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Initialize the audit event handle with the audit parameters.
    //

    b = AuthziInitializeAuditEvent( 0,
                                    NULL,
                                    AzAuthorizationStore->hApplicationInitializationAuditEventType,
                                    pAuditParams,
                                    NULL,
                                    INFINITE,
                                    L"", L"", L"", L"",
                                    &hAuditEvent );
    if ( !b ) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Send the audit to Lsa.
    //

    b = AuthziLogAuditEvent( 0,
                             hAuditEvent,
                             NULL );

    if ( !b ) {

        WinStatus = GetLastError();
        goto Cleanup;
    }

Cleanup:

    //
    // Free the audit event handle.
    //

    if ( hAuditEvent != NULL ) {
        (VOID) AuthzFreeAuditEvent( hAuditEvent );
    }

    //
    // Free the PAUDIT_PARAMS structure
    //

    if ( pAuditParams ) {

        AuthziFreeAuditParams( pAuditParams );
    }

    return WinStatus;
}


DWORD
AzpApplicationInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzApplicationCreate.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{

    PAZP_APPLICATION Application = (PAZP_APPLICATION) ChildGenericObject;
    PAZP_AZSTORE AzAuthorizationStore = (PAZP_AZSTORE) ParentGenericObject;
    NTSTATUS Status;
    DWORD WinStatus = NO_ERROR;
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES NewState = {0};
    TOKEN_PRIVILEGES OldState = {0};
    BOOL PrivilegeAdjusted = FALSE;

    DWORD AuthzFlags = 0;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Sanity check the parent
    //

    ASSERT( ParentGenericObject->ObjectType == OBJECT_TYPE_AZAUTHSTORE );
    UNREFERENCED_PARAMETER( ParentGenericObject );


    //
    // If policy store has been initialized in store manage mode only,
    // then we do not need to initialize the authz resource manager for auditing
    //

    if ( AzpOpenToManageStore(AzAuthorizationStore) ) {

        AuthzFlags = AUTHZ_RM_FLAG_NO_AUDIT;

    } else {

        //
        // Get the current token to adjust the Audit privilege.
        //

        WinStatus = AzpGetCurrentToken( &hToken );

        if ( WinStatus != NO_ERROR ) {
            return WinStatus;
        }

        //
        // Enable the audit privilege.
        //

        WinStatus = AzpChangeSinglePrivilege(
            SE_AUDIT_PRIVILEGE,
            hToken,
            &NewState,
            &OldState );

        if ( WinStatus == NO_ERROR ) {

            PrivilegeAdjusted = TRUE;

        } else {

            //
            // If auditing is not mandatory, then initialize the resource manager
            // with no audit flag
            //

            if ( (AzAuthorizationStore->InitializeFlag & AZ_AZSTORE_FLAG_AUDIT_IS_CRITICAL) == 0) {

                WinStatus = NO_ERROR;
                AuthzFlags = AUTHZ_RM_FLAG_NO_AUDIT;

            } else  {
                
                goto Cleanup;
            }
        }

    }

    if ( !AuthzInitializeResourceManager(
        AuthzFlags,
        NULL,                       // No Callback ace function
        NULL,                       // We compute our own dynamic groups
        NULL,                       // "                               "
        Application->GenericObject.ObjectName->ObjectName.String,
        &Application->AuthzResourceManager ) ) {

        WinStatus = GetLastError();

        if ( WinStatus != NO_ERROR ) {

            if ( WinStatus == ERROR_ACCESS_DENIED ) {

                WinStatus = NO_ERROR;

                //
                // the caller may be on an impersonated thread which doesn't have
                // access to the process token, let's call again to initialize
                // resource manager on the impersonated thread
                //

                if ( !AuthzInitializeResourceManager(
                    AuthzFlags |
                    AUTHZ_RM_FLAG_INITIALIZE_UNDER_IMPERSONATION,  // allow impersonation thread
                    NULL,                       // No Callback ace function
                    NULL,                       // We compute our own dynamic groups
                    NULL,                       // "                               "
                    Application->GenericObject.ObjectName->ObjectName.String,
                    &Application->AuthzResourceManager ) ) {

                    WinStatus = GetLastError();

                    goto Cleanup;
                }

            } else {

                goto Cleanup;
            }
        }
    }

    //
    // Initialize the lists of child objects
    //  Let the generic object manager know all of the types of children we support
    //

    ChildGenericObject->ChildGenericObjectHead = &Application->Operations;

    // List of child operations
    ObInitGenericHead( &Application->Operations,
                       OBJECT_TYPE_OPERATION,
                       ChildGenericObject,
                       &Application->Tasks );

    // List of child tasks
    ObInitGenericHead( &Application->Tasks,
                       OBJECT_TYPE_TASK,
                       ChildGenericObject,
                       &Application->Scopes );

    // List of child scopes
    ObInitGenericHead( &Application->Scopes,
                       OBJECT_TYPE_SCOPE,
                       ChildGenericObject,
                       &Application->Groups );

    // List of child groups
    ObInitGenericHead( &Application->Groups,
                       OBJECT_TYPE_GROUP,
                       ChildGenericObject,
                       &Application->Roles );

    // List of child roles
    ObInitGenericHead( &Application->Roles,
                       OBJECT_TYPE_ROLE,
                       ChildGenericObject,
                       &Application->ClientContexts );

    // List of child ClientContexts
    ObInitGenericHead( &Application->ClientContexts,
                       OBJECT_TYPE_CLIENT_CONTEXT,
                       ChildGenericObject,
                       &ChildGenericObject->AzpSids );

    // List of child AzpSids
    ObInitGenericHead( &ChildGenericObject->AzpSids,
                       OBJECT_TYPE_SID,
                       ChildGenericObject,
                       NULL );




    //
    // Allocate a luid for this instance of the application
    //

    Status = NtAllocateLocallyUniqueId(&Application->InstanceId);

    if ( !NT_SUCCESS(Status) ) {
        WinStatus = RtlNtStatusToDosError( Status );
        goto Cleanup;
    }

    //
    // By default generate audits
    //

    Application->GenericObject.IsGeneratingAudits = TRUE;

    //
    // Generate app initialization audit if the authorization store level boolean
    // is true and we are not in manage store mode
    //

    if ( AzAuthorizationStore->GenericObject.IsGeneratingAudits &&
         !AzpOpenToManageStore(AzAuthorizationStore) ) {
        WinStatus = AzpApplicationGenerateInitializationAudit( Application,
                                                               AzAuthorizationStore );

        if ( WinStatus != NO_ERROR ) {

            goto Cleanup;
        }
    }

    //
    // If the parent AzAuthorizationStore object support delegation, then the application object
    // supports the following options:
    // . AZPE_OPTIONS_SUPPORTS_DACL
    // . AZPE_OPTIONS_SUPPORTS_DELEGATION
    // . AZPE_OPTIONS_SUPPORTS_SACL
    //

    if ( CHECK_DELEGATION_SUPPORT( ParentGenericObject ) == NO_ERROR ) {

        ChildGenericObject->IsAclSupported = TRUE;
        ChildGenericObject->IsDelegationSupported = TRUE;
        ChildGenericObject->IsSACLSupported = TRUE;
    }

    //
    // If the provider does not support Lazy load, set the AreChildrenLoaded to
    // TRUE.  Else leave it as FALSE.  This will be set to true during the call
    // to AzPersistUpdateChildrenCache.
    //

    if ( !(AzAuthorizationStore->ChildLazyLoadSupported) ) {

        ChildGenericObject->AreChildrenLoaded = TRUE;

    } else  {

        ChildGenericObject->AreChildrenLoaded = FALSE;
    }

    //
    // Set the boolean to indicate that the application needs to be unloaded to FALSE
    // For providers where lazy load is not supported, this will always remain FALSE.
    //

    ((PAZP_APPLICATION)ChildGenericObject)->UnloadApplicationObject = FALSE;

    //
    // Set the boolean to indicate that the application is closed.  This will
    // be set to false whenever the application is opened by the user (lazy
    // loading the application is similar to open)
    //

    ChildGenericObject->ObjectClosed = TRUE;

    //
    // Set the AppSequenceNumber to 1.  Whenever the application is closed, 
    // increment the AppSequenceNumber.  This is used to track invalid COM
    // handles to the application object after the application object has
    // been closed
    //

    ((PAZP_APPLICATION)ChildGenericObject)->AppSequenceNumber = 1;

Cleanup:

    //
    // If we had adjusted the audit privilege, revert to the original state.
    //

    if ( PrivilegeAdjusted ) {
        DWORD TempWinStatus;
        TempWinStatus = AzpChangeSinglePrivilege(
                        0,      // This is ignored since OldState is NULL.
                        hToken,
                        &OldState,
                        NULL ); // This should be set to NULL to specify REVERT.

        ASSERT( TempWinStatus == NO_ERROR );
    }

    if ( hToken != NULL ) {
        CloseHandle( hToken );
        hToken = NULL;
    }

    if ( WinStatus != NO_ERROR ) {

        //
        // Free the authz resource manager handle.
        //

        if ( Application->AuthzResourceManager != NULL ) {
            AuthzFreeResourceManager( Application->AuthzResourceManager );
            Application->AuthzResourceManager = NULL;
        }
    }

    return WinStatus;
}



VOID
AzpApplicationFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for Application object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    PAZP_APPLICATION Application = (PAZP_APPLICATION) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Free any local strings
    //
    AzpFreeString( &Application->AppVersion );
    AzpFreeString( &Application->AuthzInterfaceClsid );

    if ( Application->AuthzResourceManager != NULL ) {
        if ( !AuthzFreeResourceManager( Application->AuthzResourceManager ) ) {
            ASSERT( FALSE );
        }
    }

}


DWORD
AzpApplicationGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    This routine is the Application specific worker routine for AzGetProperty.
    It does any object specific property gets.

    On entry, AzGlResource must be locked shared.

Arguments:

    GenericObject - Specifies a pointer to the object to be queried

    Flags - Specifies internal flags
        AZP_FLAGS_BY_GUID - name lists should be returned as GUID lists
        AZP_FLAGS_PERSIST_* - Call is from the persistence provider

    PropertyId - Specifies which property to return.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID  LPWSTR - CLSID of the IAppAuthzInterface interface supplied by the application
        AZ_PROP_APPLICATION_VERSION         LPWSTR - Version string for the application

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_APPLICATION Application = (PAZP_APPLICATION) GenericObject;
    UNREFERENCED_PARAMETER( Flags );

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    *PropertyValue = NULL;

    //
    // Return any object specific attribute
    //

    switch ( PropertyId ) {

    //
    // Return IAppAuthzInterface CLSID
    //
    case AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID:

        *PropertyValue = AzpGetStringProperty( &Application->AuthzInterfaceClsid );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    //
    // Return application version to the caller
    //
    case AZ_PROP_APPLICATION_VERSION:

        *PropertyValue = AzpGetStringProperty( &Application->AppVersion );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    default:
        AzPrint(( AZD_INVPARM, "AzApplicationGetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        break;
    }

    return WinStatus;
}


DWORD
AzpApplicationSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    This routine is the Application object specific worker routine for AzSetProperty.
    It does any object specific property sets.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies a pointer to the object to be modified

    Flags - Specifies flags controlling to operation of the routine
        AZP_FLAGS_SETTING_TO_DEFAULT - Property is being set to default value
        AZP_FLAGS_PERSIST_* - Call is from the persistence provider

    PropertyId - Specifies which property to set.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID  LPWSTR - CLSID of the IAppAuthzInterface interface supplied by the application
        AZ_PROP_APPLICATION_VERSION         LPWSTR - Version string for the application

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_APPLICATION Application = (PAZP_APPLICATION) GenericObject;
    AZP_STRING CapturedString;
    BOOL bHasChanged = TRUE;

    //
    // Initialization
    //

    UNREFERENCED_PARAMETER( Flags );
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    AzpInitString( &CapturedString, NULL );


    //
    // Set any object specific attribute
    //

    switch ( PropertyId ) {

    //
    // Set IAppAuthzInterface CLSID attribute
    //
    case AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID:

        BEGIN_SETPROP( &WinStatus, Application, Flags, AZ_DIRTY_APPLICATION_AUTHZ_INTERFACE_CLSID ) {

            //
            // Capture the input string
            //

            WinStatus = AzpCaptureString( &CapturedString,
                                          (LPWSTR) PropertyValue,
                                          CHECK_STRING_LENGTH( Flags, 512),  // Guess larger than needed
                                          TRUE ); // NULL is OK

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            //
            // Do parameter validity checking
            //
            BEGIN_VALIDITY_CHECKING( Flags ) {
                GUID TempGuid;

                //
                // It must syntactically be a UUID
                //

                WinStatus = UuidFromString( CapturedString.String,
                                            &TempGuid );

                if ( WinStatus != NO_ERROR ) {
                    AzPrint(( AZD_INVPARM, "AzpApplicationSetProperty: cannot convert CLSID %ws %ld\n", CapturedString.String, WinStatus ));
                    goto Cleanup;
                }

            } END_VALIDITY_CHECKING;

            //
            // Swap the old/new names
            //

            AzpSwapStrings( &CapturedString, &Application->AuthzInterfaceClsid );

        } END_SETPROP(bHasChanged);

        break;

    //
    // Set application version on the object
    //
    case AZ_PROP_APPLICATION_VERSION:

        BEGIN_SETPROP( &WinStatus, Application, Flags, AZ_DIRTY_APPLICATION_VERSION ) {
            //
            // Capture the input string
            //

            WinStatus = AzpCaptureString( &CapturedString,
                                          (LPWSTR) PropertyValue,
                                          CHECK_STRING_LENGTH( Flags, AZ_MAX_APPLICATION_VERSION_LENGTH),
                                          TRUE ); // NULL is OK

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            //
            // Swap the old/new names
            //

            AzpSwapStrings( &CapturedString, &Application->AppVersion );
        } END_SETPROP(bHasChanged);
        break;

    default:
        AzPrint(( AZD_INVPARM, "AzpApplicationSetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Free any local resources
    //
Cleanup:
    AzpFreeString( &CapturedString );

    return WinStatus;
}


DWORD
WINAPI
AzApplicationCreate(
    IN AZ_HANDLE AzAuthorizationStoreHandle,
    IN LPCWSTR ApplicationName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ApplicationHandle
    )
/*++

Routine Description:

    This routine adds an application into the scope of the specified AzAuthorizationStore.  It also sets
    Application object specific optional characteristics using the parent AzAuthorizationStore object.

Arguments:

    AzAuthorizationStoreHandle - Specifies a handle to the AzAuthorizationStore.

    ApplicationName - Specifies the name of the application to add.

    Reserved - Reserved.  Must by zero.

    ApplicationHandle - Return a handle to the application.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonCreateObject(
               (PGENERIC_OBJECT) AzAuthorizationStoreHandle,
               OBJECT_TYPE_AZAUTHSTORE,
               &(((PAZP_AZSTORE)AzAuthorizationStoreHandle)->Applications),
               OBJECT_TYPE_APPLICATION,
               ApplicationName,
               Reserved,
               (PGENERIC_OBJECT *) ApplicationHandle );

}


DWORD
WINAPI
AzApplicationOpen(
    IN AZ_HANDLE AzAuthorizationStoreHandle,
    IN LPCWSTR ApplicationName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ApplicationHandle
    )
/*++

Routine Description:

    This routine opens an application into the scope of the specified AzAuthorizationStore.

Arguments:

    AzAuthorizationStoreHandle - Specifies a handle to the AzAuthorizationStore.

    ApplicationName - Specifies the name of the application to open

    Reserved - Reserved.  Must by zero.

    ApplicationHandle - Return a handle to the application.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - There is no application by that name

--*/
{
    DWORD WinStatus = 0;

    //
    // Call the common routine to do most of the work
    //

    WinStatus =  ObCommonOpenObject(
                    (PGENERIC_OBJECT) AzAuthorizationStoreHandle,
                    OBJECT_TYPE_AZAUTHSTORE,
                    &(((PAZP_AZSTORE)AzAuthorizationStoreHandle)->Applications),
                    OBJECT_TYPE_APPLICATION,
                    ApplicationName,
                    Reserved,
                    (PGENERIC_OBJECT *) ApplicationHandle );

    if ( WinStatus == NO_ERROR ) {

        //
        // Load the children if the Application object has already been submitted to
        // the store
        //

        if ( !((PGENERIC_OBJECT) *ApplicationHandle)->AreChildrenLoaded ) {

            //
            // Grab the resource lock exclusive
            //
            AzpLockResourceExclusive( &AzGlResource );

            WinStatus = AzPersistUpdateChildrenCache(
                (PGENERIC_OBJECT) *ApplicationHandle
                );

            AzpUnlockResource( &AzGlResource );

            if ( WinStatus != NO_ERROR ) {

                //
                // Dereference the application handle and return nothing to the caller
                //

                AzCloseHandle( (PGENERIC_OBJECT)*ApplicationHandle, 0 );
                *ApplicationHandle = NULL;
            }
        }
    }

    //
    // The application object is no longer closed.  Mark that in the object.
    //
    
    if ( WinStatus == NO_ERROR ) {

        ((PGENERIC_OBJECT)*ApplicationHandle)->ObjectClosed = FALSE;

    }

    return WinStatus;
}

DWORD
WINAPI
AzApplicationClose(
    IN AZ_HANDLE AzAuthorizationStoreHandle,
    IN LPCWSTR pApplicationName,
    IN LONG lFlags
    )
/*++

Routine Description:

    This routine unloads the children of the application object specified
    by pApplicationName from the cache.  It will leave the application object
    in cache however.
    
    If the provider does not support lazy loading of objects, then it is not
    possible to call the close API.  Return ERROR_NOT_SUPPORTED.

Arguments:

    AzAuthorizationStoreHandle - Handle to the authorization store object
    pApplicationName - Name of the application to be unloaded from the cache
    lFlags - Flag specifying the behavior of the close

             AZ_AZSTORE_FORCE_APPLICATION_CLOSE - Forcefully remove all children
                 of the specified of application from cache
             
             If no flags are specified, then the application will be unloaded only
             when the reference handle count reaches zero.

Return Value:

    NO_ERROR - The application was successfully unloaded from the cache
    ERROR_NOT_SUPPORTED - Provider does not support this API
    ERROR_NOT_ENOUGH_MEMORY - Lack of resources
    Other status codes

--*/
{

    DWORD WinStatus = NO_ERROR;
    PGENERIC_OBJECT pApplication = NULL;
    AZP_STRING AppName;
    BOOLEAN bResourceLocked = FALSE;

    //
    // Validation
    //

    ASSERT( AzAuthorizationStoreHandle != INVALID_HANDLE_VALUE );

    AzpInitString( &AppName, NULL );

    //
    // If the store is a provider that does not support lazy load,
    // then we do not support unloading an application for that 
    // provider
    //

    if ( !((PAZP_AZSTORE)AzAuthorizationStoreHandle)->ChildLazyLoadSupported ) {

        WinStatus = ERROR_NOT_SUPPORTED;
        goto Cleanup;
    }
    
    //
    // Reference the application object by name
    //

    WinStatus = AzpCaptureString(
                    &AppName,
                    pApplicationName,
                    AZ_MAX_APPLICATION_NAME_LENGTH,
                    FALSE // NULL not OK
                    );

    if ( WinStatus != NO_ERROR ) {
        
        AzPrint(( AZD_INVPARM,
                  "AzApplicationClose: Failed to capture application name: %ld\n",
                  WinStatus
                  ));
        goto Cleanup;
    }

    //
    // Grab the cache lock exclusively to unload the application
    //

    AzpLockResourceExclusive( &AzGlResource );
    bResourceLocked = TRUE;
    
    WinStatus = ObReferenceObjectByName(
                    &((PAZP_AZSTORE)AzAuthorizationStoreHandle)->Applications,
                    &AppName,
                    0, // No flags
                    &pApplication
                    );

    if ( WinStatus != NULL ) {
    
        AzPrint(( AZD_REF,
                  "AzApplicationClose: Cannot reference application %ws: %ld\n",
                  pApplicationName,
                  WinStatus
                  ));

        goto Cleanup;
    }
    
    //
    // Check the flags that were sent by the user.  If the user
    // does not wish to perform a forcefull unloading of the application,
    // then simply set the boolean on the application object indicating
    // that the application object needs to be unloaded when the handle
    // reference count reaches 0.
    //
    
    if ( (lFlags & AZ_AZSTORE_FORCE_APPLICATION_CLOSE) != 0 ) {

        //
        // Forcefull close required
        //

        //
        // Call the routine to clean up all the child generic heads
        //
        
        WinStatus = ObUnloadChildGenericHeads( pApplication );

        if ( WinStatus != ERROR_NOT_SUPPORTED && WinStatus != NO_ERROR ) {
                        
            //
            // Update the children cache of this application object
            //
            
            DWORD TempWinStatus = NO_ERROR;

            TempWinStatus = AzPersistUpdateChildrenCache( pApplication );

            if ( TempWinStatus != NO_ERROR ) {

                AzPrint(( AZD_REF,
                          "AzApplicationClose: Cannot reload children on unload failure: %ld\n",
                          TempWinStatus
                          ));
            }

            goto Cleanup;
        }

        //
        // Set the boolean on the object specifying that its children are no
        // longer loaded
        //
        
        ((PGENERIC_OBJECT)pApplication)->AreChildrenLoaded = FALSE;

    } else {

        
        ((PAZP_APPLICATION)pApplication)->UnloadApplicationObject = TRUE;        

    }

        
    WinStatus = NO_ERROR;

Cleanup:

    if ( pApplication != NULL ) {
        
        ObDereferenceObject( pApplication );
    }

    AzpFreeString( &AppName );

    //
    // drop the global lock
    //
    
    if ( bResourceLocked ) {

        AzpUnlockResource( &AzGlResource );

    }

    return WinStatus;
}


DWORD
WINAPI
AzApplicationEnum(
    IN AZ_HANDLE AzAuthorizationStoreHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE ApplicationHandle
    )
/*++

Routine Description:

    Enumerates all of the applications for the specified AzAuthorizationStore.

Arguments:

    AzAuthorizationStoreHandle - Specifies a handle to the AzAuthorizationStore.

    Reserved - Reserved.  Must by zero.

    EnumerationContext - Specifies a context indicating the next application to return
        On input for the first call, should point to zero.
        On input for subsequent calls, should point to the value returned on the previous call.
        On output, returns a value to be passed on the next call.

    ApplicationHandle - Returns a handle to the next application object.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful (a handle was returned)

    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonEnumObjects(
                    (PGENERIC_OBJECT) AzAuthorizationStoreHandle,
                    OBJECT_TYPE_AZAUTHSTORE,
                    &(((PAZP_AZSTORE)AzAuthorizationStoreHandle)->Applications),
                    EnumerationContext,
                    Reserved,
                    (PGENERIC_OBJECT *) ApplicationHandle );

}


DWORD
WINAPI
AzApplicationDelete(
    IN AZ_HANDLE AzAuthorizationStoreHandle,
    IN LPCWSTR ApplicationName,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This routine deletes an application from the scope of the specified AzAuthorizationStore.
    Also deletes any child objects of ApplicationName.

Arguments:

    AzAuthorizationStoreHandle - Specifies a handle to the AzAuthorizationStore.

    ApplicationName - Specifies the name of the application to delete.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - An object by that name cannot be found

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonDeleteObject(
                    (PGENERIC_OBJECT) AzAuthorizationStoreHandle,
                    OBJECT_TYPE_AZAUTHSTORE,
                    &(((PAZP_AZSTORE)AzAuthorizationStoreHandle)->Applications),
                    OBJECT_TYPE_APPLICATION,
                    ApplicationName,
                    Reserved );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\azper.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    azper.h

Abstract:

    Describe the interface between a persistence provider and the persistence engine.

Author:

    Cliff Van Dyke (cliffv) 3-Dec-2001

--*/

#ifndef _AZPER_H_
#define _AZ_H_

#ifdef __cplusplus
extern "C" {
#endif


/////////////////////////////////////////////////////////////////////////////
//
// Structure definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// Handle to various objects passed to/from the persistence provider
//

#if DBG // Do stronger type checking on debug builds
typedef struct {
} *AZPE_OBJECT_HANDLE;
#else //DBG
typedef PVOID AZPE_OBJECT_HANDLE;
#endif //DBG

//
// Opaque context returned by *PersistOpen
//

#if DBG // Do stronger type checking on debug builds
typedef struct {
} *AZPE_PERSIST_CONTEXT;
#else //DBG
typedef PVOID AZPE_PERSIST_CONTEXT;
#endif //DBG
typedef AZPE_PERSIST_CONTEXT *PAZPE_PERSIST_CONTEXT;

//
// Structure defining a GUID and the operation that was performed on a GUID
//

typedef struct _AZP_DELTA_ENTRY {

    // Operation that was performed
    ULONG DeltaFlags;
#define AZP_DELTA_ADD              0x0001   // Delta was an add and not a remove
#define AZP_DELTA_SID              0x0002   // Delta is for a SID and not a GUID
#define AZP_DELTA_PERSIST_PROVIDER 0x0004   // Delta was created by the persist provider and not the app

    // Guid the operation was performed on
    union {
        GUID Guid;
        PSID Sid; // AZP_DELTA_SID is set
    };

} AZP_DELTA_ENTRY, *PAZP_DELTA_ENTRY;

//
// Generic structures to hold rights for policy admins/readers or
// delegated policy users
//

typedef struct _AZP_POLICY_USER_RIGHTS {

    //
    // Mask
    //

    ULONG lUserRightsMask;

    //
    // Flags
    //

    ULONG lUserRightsFlags;

} AZP_POLICY_USER_RIGHTS, *PAZP_POLICY_USER_RIGHTS;

/////////////////////////////////////////////////////////////////////////////
//
// #define definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// Registry location where the provider registers itself
//
// The Dll implementing the provider should be in a value named
//      AZ_REGISTRY_PROVIDER_KEY_NAME\\<PolicyUrlPrefix>\\AZ_REGISTRY_PROVIDER_DLL_VALUE_NAME
// where <PolicyUrlPrefix> is the characters before the : in the policy url passed to Initialize
//

#define AZ_REGISTRY_KEY_NAME L"SYSTEM\\CurrentControlSet\\Control\\LSA\\AzRoles"
#define AZ_REGISTRY_PROVIDER_KEY_NAME (AZ_REGISTRY_KEY_NAME L"\\Providers")
#define AZ_REGISTRY_PROVIDER_KEY_NAME_LEN ((sizeof(AZ_REGISTRY_PROVIDER_KEY_NAME)/sizeof(WCHAR))-1)
#define AZ_REGISTRY_PROVIDER_DLL_VALUE_NAME L"ProviderDll"

//
// Definition of dirty bits returned from AzpeDirtyBits
//
// Generic bits that apply to all objects (or to several objects)
//
// policy readers and admins for AzAuthorizationStore, AzApplication and AzScope
// objects.  Also delegated policy users applied to AzAuthorizationStore and
// AzApplication objects
#define AZ_DIRTY_NAME                               0x80000000
#define AZ_DIRTY_DESCRIPTION                        0x40000000
#define AZ_DIRTY_APPLY_STORE_SACL                   0x20000000
// Object is dirty because it has been created
#define AZ_DIRTY_CREATE                             0x10000000
#define AZ_DIRTY_DELEGATED_POLICY_USERS             0x08000000
#define AZ_DIRTY_POLICY_ADMINS                      0x04000000
#define AZ_DIRTY_POLICY_READERS                     0x02000000
#define AZ_DIRTY_APPLICATION_DATA                   0x01000000
#define AZ_DIRTY_GENERATE_AUDITS                    0x00100000

// Common attributes that apply to all objects
#define AZ_DIRTY_COMMON_ATTRS                       0xC1000000

// Object specific bits that apply to individual objects
#define AZ_DIRTY_OBJECT_SPECIFIC                    0x000FFFFF


#define AZ_DIRTY_AZSTORE_DOMAIN_TIMEOUT               0x00000100
#define AZ_DIRTY_AZSTORE_SCRIPT_ENGINE_TIMEOUT        0x00000200
#define AZ_DIRTY_AZSTORE_MAX_SCRIPT_ENGINES           0x00000400
#define AZ_DIRTY_AZSTORE_MAJOR_VERSION                0x00000800
#define AZ_DIRTY_AZSTORE_MINOR_VERSION                0x00001000
#define AZ_DIRTY_AZSTORE_ALL_SCALAR                  (0x00000700 | AZ_DIRTY_APPLICATION_DATA | AZ_DIRTY_DESCRIPTION | AZ_DIRTY_GENERATE_AUDITS | AZ_DIRTY_APPLY_STORE_SACL | AZ_DIRTY_AZSTORE_MAJOR_VERSION | AZ_DIRTY_AZSTORE_MINOR_VERSION )
#define AZ_DIRTY_AZSTORE_ALL                         (0x00000000 | AZ_DIRTY_AZSTORE_ALL_SCALAR | AZ_DIRTY_DELEGATED_POLICY_USERS | AZ_DIRTY_POLICY_ADMINS | AZ_DIRTY_POLICY_READERS | AZ_DIRTY_CREATE)

#define AZ_DIRTY_OPERATION_ID                       0x00000001
#define AZ_DIRTY_OPERATION_ALL_SCALAR              (0x00000001 | AZ_DIRTY_APPLICATION_DATA | AZ_DIRTY_NAME | AZ_DIRTY_DESCRIPTION  )
#define AZ_DIRTY_OPERATION_ALL                     (AZ_DIRTY_OPERATION_ALL_SCALAR | AZ_DIRTY_CREATE)

#define AZ_DIRTY_TASK_OPERATIONS                    0x00000001
#define AZ_DIRTY_TASK_TASKS                         0x00000002
#define AZ_DIRTY_TASK_BIZRULE                       0x00000100
#define AZ_DIRTY_TASK_BIZRULE_LANGUAGE              0x00000200
#define AZ_DIRTY_TASK_BIZRULE_IMPORTED_PATH         0x00000400
#define AZ_DIRTY_TASK_IS_ROLE_DEFINITION            0x00000800
#define AZ_DIRTY_TASK_ALL_SCALAR                   (0x00000F00 | AZ_DIRTY_APPLICATION_DATA | AZ_DIRTY_NAME | AZ_DIRTY_DESCRIPTION  )
#define AZ_DIRTY_TASK_ALL                          (0x00000003 | AZ_DIRTY_TASK_ALL_SCALAR | AZ_DIRTY_CREATE)

#define AZ_DIRTY_SCOPE_ALL_SCALAR                  (0x00000000 | AZ_DIRTY_APPLICATION_DATA | AZ_DIRTY_NAME | AZ_DIRTY_DESCRIPTION | AZ_DIRTY_APPLY_STORE_SACL )
#define AZ_DIRTY_SCOPE_ALL                         (0x00000000 | AZ_DIRTY_SCOPE_ALL_SCALAR | AZ_DIRTY_POLICY_ADMINS | AZ_DIRTY_POLICY_READERS | AZ_DIRTY_CREATE)

#define AZ_DIRTY_GROUP_APP_MEMBERS                  0x00000001
#define AZ_DIRTY_GROUP_APP_NON_MEMBERS              0x00000002
#define AZ_DIRTY_GROUP_MEMBERS                      0x00000004
#define AZ_DIRTY_GROUP_NON_MEMBERS                  0x00000008
#define AZ_DIRTY_GROUP_TYPE                         0x00000100
#define AZ_DIRTY_GROUP_LDAP_QUERY                   0x00000200
#define AZ_DIRTY_GROUP_ALL_SCALAR                  (0x00000300 | AZ_DIRTY_NAME | AZ_DIRTY_DESCRIPTION  )
#define AZ_DIRTY_GROUP_ALL                         (0x0000000F | AZ_DIRTY_GROUP_ALL_SCALAR | AZ_DIRTY_CREATE)

#define AZ_DIRTY_ROLE_APP_MEMBERS                   0x00000001
#define AZ_DIRTY_ROLE_MEMBERS                       0x00000002
#define AZ_DIRTY_ROLE_OPERATIONS                    0x00000004
#define AZ_DIRTY_ROLE_TASKS                         0x00000008
#define AZ_DIRTY_ROLE_ALL_SCALAR                   (0x00000000 | AZ_DIRTY_APPLICATION_DATA | AZ_DIRTY_NAME | AZ_DIRTY_DESCRIPTION  )
#define AZ_DIRTY_ROLE_ALL                          (0x0000000F | AZ_DIRTY_ROLE_ALL_SCALAR | AZ_DIRTY_CREATE)

#define AZ_DIRTY_APPLICATION_AUTHZ_INTERFACE_CLSID  0x00000100
#define AZ_DIRTY_APPLICATION_VERSION                0x00000200
#define AZ_DIRTY_APPLICATION_ALL_SCALAR            (0x00000300 | AZ_DIRTY_APPLICATION_DATA | AZ_DIRTY_NAME | AZ_DIRTY_DESCRIPTION | AZ_DIRTY_GENERATE_AUDITS | AZ_DIRTY_APPLY_STORE_SACL )
#define AZ_DIRTY_APPLICATION_ALL                   (0x00000000 | AZ_DIRTY_APPLICATION_ALL_SCALAR | AZ_DIRTY_DELEGATED_POLICY_USERS | AZ_DIRTY_POLICY_ADMINS | AZ_DIRTY_POLICY_READERS | AZ_DIRTY_CREATE)

//
// ObjectType as returned from AzpeObjectType
//
//
// The order of the defines below must not change since providers and azroles
//  build tables that are indexed by this number
//
#define OBJECT_TYPE_AZAUTHSTORE   0
#define OBJECT_TYPE_APPLICATION     1
#define OBJECT_TYPE_OPERATION       2
#define OBJECT_TYPE_TASK            3
#define OBJECT_TYPE_SCOPE           4
#define OBJECT_TYPE_GROUP           5
#define OBJECT_TYPE_ROLE            6
#define OBJECT_TYPE_COUNT           7   // Number of object types visible to providers

//
// Definitions of the lPersistFlags
//
// Note to developer.  Confine these flags bits to the lower order 2 bytes or change
// the AZP_FLAGS defines in genobj.h

#define AZPE_FLAGS_PERSIST_OPEN                  0x0001  // Call is from the persistence provider doing AzPersistOpen
#define AZPE_FLAGS_PERSIST_UPDATE_CACHE          0x0002  // Call is from the persistence provider doing AzPersistUpdateCache
#define AZPE_FLAGS_PERSIST_REFRESH               0x0004  // Call is from the persistence provider doing AzPersistRefresh
#define AZPE_FLAGS_PERSIST_SUBMIT                0x0008  // Call is from the persistence provider doing AzPersistSubmit
#define AZPE_FLAGS_PERSIST_UPDATE_CHILDREN_CACHE 0x0010  // Call is from the persistence provider doing AzPersistUpdateChildrenCache
#define AZPE_FLAGS_PERSIST_MASK                  0xFFFF  // Call is from the persistence provider (OR of bits above)
#define AZPE_FLAGS_PERSIST_OPEN_MASK             0x0017  // Call is from the persistence provider doing one of the update-like operations

//
// Options passed to AzpeSetObjectOptions
//

#define AZPE_OPTIONS_WRITABLE               0x01 // Current user can write this object
#define AZPE_OPTIONS_SUPPORTS_DACL          0x02 // DACL can be specified for this object
#define AZPE_OPTIONS_SUPPORTS_DELEGATION    0x04 // Delegation can be specified for this object
#define AZPE_OPTIONS_SUPPORTS_SACL          0x08 // Apply SACL can be specified for this object
#define AZPE_OPTIONS_HAS_SECURITY_PRIVILEGE 0x10 // Current user SE_SECURITY_PRIVILEGE on machine containing store
#define AZPE_OPTIONS_SUPPORTS_LAZY_LOAD     0x20 // Provider supports lazy load for children
#define AZPE_OPTIONS_CREATE_CHILDREN        0x40 // Current user can create children for the object
#define AZPE_OPTIONS_VALID_MASK             0x7F // Mask of the valid options

//
// This flag means that some updates from the store has been made.
//

#define AZPE_FLAG_CACHE_UPDATE_STORE_LEVEL 0x00000001


/////////////////////////////////////////////////////////////////////////////
//
// Procedures implemented by the providers
//
/////////////////////////////////////////////////////////////////////////////

typedef DWORD
(WINAPI * AZ_PERSIST_OPEN)(
    IN LPCWSTR PolicyUrl,
    IN AZPE_OBJECT_HANDLE hAzStore,
    IN ULONG lPersistFlags,
    IN BOOL CreatePolicy,
    OUT PAZPE_PERSIST_CONTEXT PersistContext,
    OUT LPWSTR *pwszTargetMachine
    );

typedef DWORD
(WINAPI *AZ_PERSIST_UPDATE_CACHE)(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN ULONG lPersistFlags,
    OUT ULONG * pulUpdatedFlag
    );


typedef DWORD
(WINAPI *AZ_PERSIST_UPDATE_CHILDREN_CACHE)(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags
    );

typedef VOID
(WINAPI *AZ_PERSIST_CLOSE)(
    IN AZPE_PERSIST_CONTEXT PersistContext
    );

typedef DWORD
(WINAPI *AZ_PERSIST_SUBMIT)(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN BOOLEAN DeleteMe
    );

typedef DWORD
(WINAPI *AZ_PERSIST_REFRESH)(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags
    );

typedef DWORD
(WINAPI *AZ_PERSIST_CHECK_PRIVILEGE)(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

//
// Structure describing a provider
//

typedef struct _AZPE_PROVIDER_INFO {

    //
    // Version of this structure
    //

    ULONG ProviderInfoVersion;
#define AZPE_PROVIDER_INFO_VERSION_1 1
#define AZPE_PROVIDER_INFO_VERSION_2 2

    //
    // Prefix of the PolicyUrl that define the provider
    //  The policy URL should be of the form <Prefix>:<ProviderSpecificUrl>
    //

    LPCWSTR PolicyUrlPrefix;

    //
    // Routines exported by the provider
    //

    AZ_PERSIST_OPEN AzPersistOpen;
    AZ_PERSIST_UPDATE_CACHE AzPersistUpdateCache;
    AZ_PERSIST_CLOSE AzPersistClose;
    AZ_PERSIST_SUBMIT AzPersistSubmit;
    AZ_PERSIST_REFRESH AzPersistRefresh;

    //
    // Following are valid for version 2 and more only
    //

    AZ_PERSIST_UPDATE_CHILDREN_CACHE AzPersistUpdateChildrenCache;

    //
    // When new fields are added to this structure,
    //  make sure you increment the version number and add a new define for
    //  the new version number.
    //

} AZPE_PROVIDER_INFO, *PAZPE_PROVIDER_INFO;


/////////////////////////////////////////////////////////////////////////////
//
// Procedures implemented by the persistence engine and called by the providers
//
/////////////////////////////////////////////////////////////////////////////

typedef DWORD
(WINAPI *AZPE_CREATE_OBJECT)(
    IN AZPE_OBJECT_HANDLE AzpeParentHandle,
    IN ULONG ChildObjectType,
    IN LPCWSTR ChildObjectNameString,
    IN GUID *ChildObjectGuid,
    IN ULONG lPersistFlags,
    OUT AZPE_OBJECT_HANDLE *AzpeChildHandle
    );

typedef VOID
(WINAPI *AZPE_OBJECT_FINISHED)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN DWORD WinStatus
    );

typedef DWORD
(WINAPI *AZPE_GET_PROPERTY)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

typedef DWORD
(WINAPI *AZPE_GET_DELTA_ARRAY)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG PropertyId,
    OUT PULONG DeltaArrayCount,
    OUT PAZP_DELTA_ENTRY **DeltaArray
    );

typedef DWORD
(WINAPI *AZPE_GET_SECURITY_DESCRIPTOR_FROM_CACHE)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN PAZP_POLICY_USER_RIGHTS *ppPolicyAdminRights OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS *ppPolicyReaderRights OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS *ppDelegatedPolicyUsersRights OPTIONAL,
    IN GUID *pDelegatedObjectGuid OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS pDelegatedUsersAttributeRights OPTIONAL,
    IN GUID *pAttributeGuid OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS pSaclRights OPTIONAL,
    IN PSECURITY_DESCRIPTOR OldSd OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewSd
    );

//
// Routines to return a single field of an object
//

typedef DWORD
(WINAPI *AZPE_OBJECT_TYPE)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

typedef DWORD
(WINAPI *AZPE_DIRTY_BITS)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

typedef GUID *
(WINAPI *AZPE_PERSISTENCE_GUID)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

typedef BOOLEAN
(WINAPI *AZPE_IS_PARENT_WRITABLE)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

typedef AZPE_OBJECT_HANDLE
(WINAPI *AZPE_PARENT_OF_CHILD)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

typedef BOOLEAN
(WINAPI *AZPE_UPDATE_CHILDREN)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

typedef BOOLEAN
(WINAPI *AZPE_CAN_CREATE_CHILDREN)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

//
// Routines to change an object
//

typedef DWORD
(WINAPI *AZPE_SET_PROPERTY)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    );
typedef DWORD
(WINAPI *AZPE_SET_OBJECT_OPTIONS)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG ObjectOptions
    );

typedef DWORD
(WINAPI *AZPE_ADD_PROPERTY_ITEM_SID)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG PropertyId,
    IN PSID Sid
    );

typedef DWORD
(WINAPI *AZPE_ADD_PROPERTY_ITEM_GUID)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG PropertyId,
    IN GUID *ObjectGuid
    );

typedef DWORD
(WINAPI *AZPE_ADD_PROPERTY_ITEM_GUID_STRING)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG PropertyId,
    IN WCHAR *ObjectGuidString
    );

typedef VOID
(WINAPI *AZPE_SET_PROVIDER_DATA)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN PVOID ProviderData
    );

typedef PVOID
(WINAPI *AZPE_GET_PROVIDER_DATA)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

typedef DWORD
(WINAPI *AZPE_SET_SECURITY_DESCRIPTOR_INTO_CACHE)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN PSECURITY_DESCRIPTOR pSD,
    IN ULONG lPersistFlags,
    IN PAZP_POLICY_USER_RIGHTS pAdminRights,
    IN PAZP_POLICY_USER_RIGHTS pReadersRights,
    IN PAZP_POLICY_USER_RIGHTS pDelegatedUserRights OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS pSaclRights OPTIONAL
    );

typedef PVOID
(WINAPI *AZPE_ALLOCATE_MEMORY)(
     IN SIZE_T Size
     );

typedef VOID
(WINAPI *AZPE_FREE_MEMORY)(
    IN PVOID Buffer
    );

typedef BOOL
(WINAPI *AZPE_AZSTORE_IS_BATCH_MODE)(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

typedef AZPE_OBJECT_HANDLE
(WINAPI *AZPE_GET_AUTHORIZATION_STORE)(
    IN AZPE_OBJECT_HANDLE hObject
    );

//
// Structure describing routines exported by azroles to the provider
//

typedef struct _AZPE_AZROLES_INFO {

    //
    // Version of this structure
    //

    ULONG AzrolesInfoVersion;
#define AZPE_AZROLES_INFO_VERSION_1 1
#define AZPE_AZROLES_INFO_VERSION_2 2

    //
    // Routines exported by azroles to the provider
    //

    AZPE_CREATE_OBJECT AzpeCreateObject;
    AZPE_OBJECT_FINISHED AzpeObjectFinished;
    AZPE_GET_PROPERTY AzpeGetProperty;
    AZPE_GET_DELTA_ARRAY AzpeGetDeltaArray;
    AZPE_GET_SECURITY_DESCRIPTOR_FROM_CACHE AzpeGetSecurityDescriptorFromCache;
    AZPE_OBJECT_TYPE AzpeObjectType;
    AZPE_DIRTY_BITS AzpeDirtyBits;
    AZPE_PERSISTENCE_GUID AzpePersistenceGuid;
    AZPE_PARENT_OF_CHILD AzpeParentOfChild;
    AZPE_SET_PROPERTY AzpeSetProperty;
    AZPE_SET_OBJECT_OPTIONS AzpeSetObjectOptions;
    AZPE_ADD_PROPERTY_ITEM_SID AzpeAddPropertyItemSid;
    AZPE_ADD_PROPERTY_ITEM_GUID AzpeAddPropertyItemGuid;
    AZPE_ADD_PROPERTY_ITEM_GUID_STRING AzpeAddPropertyItemGuidString;
    AZPE_SET_PROVIDER_DATA AzpeSetProviderData;
    AZPE_GET_PROVIDER_DATA AzpeGetProviderData;
    AZPE_SET_SECURITY_DESCRIPTOR_INTO_CACHE AzpeSetSecurityDescriptorIntoCache;
    AZPE_ALLOCATE_MEMORY AzpeAllocateMemory;
    AZPE_FREE_MEMORY AzpeFreeMemory;

    //
    // Following are valid for version 2 and more only
    //

    AZPE_IS_PARENT_WRITABLE AzpeIsParentWritable;
    AZPE_UPDATE_CHILDREN AzpeUpdateChildren;
    AZPE_CAN_CREATE_CHILDREN AzpeCanCreateChildren;
    AZPE_AZSTORE_IS_BATCH_MODE AzpeAzStoreIsBatchUpdateMode;
    AZPE_GET_AUTHORIZATION_STORE AzpeGetAuthorizationStore;

    //
    // When new fields are added to this structure,
    //  make sure you increment the version number and add a new define for
    //  the new version number.
    //

} AZPE_AZROLES_INFO, *PAZPE_AZROLES_INFO;

//
// The only actual routine exported by the provider
//

typedef DWORD
(WINAPI * AZ_PERSIST_PROVIDER_INITIALIZE)(
    IN PAZPE_AZROLES_INFO AzrolesInfo,
    OUT PAZPE_PROVIDER_INFO *ProviderInfo
    );

#define AZ_PERSIST_PROVIDER_INITIALIZE_NAME "AzPersistProviderInitialize"

#ifdef __cplusplus
}
#endif
#endif // _AZPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\azroles.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    azroles.cxx

Abstract:

    Implementation of DLL Exports.

Author:

    Xiaoxi Tan (xtan) 11-May-2001

--*/


#include "pch.hxx"
#include "resource.h"
#include "initguid.h"

#include "azroles_i.c"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_AzAuthorizationStore, CAzAuthorizationStore)
    OBJECT_ENTRY(CLSID_AzBizRuleContext, CAzBizRuleContext)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    BOOL ret = TRUE;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        ret = AzDllInitialize();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        ret = AzDllUnInitialize();
    }
    return ret;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\azstore.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    azstore.cxx

Abstract:

    Routines implementing the Authorization Store object

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

History:

    Chaitanya D. Upadhyay (chaitu) 28-May-2002
        Changed all references to AdminManager to AzAuthorizationStore

--*/

#include "pch.hxx"

//
// Global Data
//



//
// Global list of all AzAuthorizationStores for this process
//  Access serialized by AzGlResource
//

GENERIC_OBJECT_HEAD AzGlAzStores;

SAFE_RESOURCE AzGlResource;
SAFE_RESOURCE AzGlCloseApplication;

BOOL ResourceInitialized = FALSE;

BOOL AzIsDC = FALSE;
UCHAR SidBuffer[SECURITY_MAX_SID_SIZE] = {0};
PSID AzAccountDomainSid = (PSID) SidBuffer;
BOOL AzAccountDomainSidInitialized = FALSE;

GUID AzGlZeroGuid;

//
// Well known sids
//
PSID AzGlCreatorOwnerSid;
PSID AzGlWorldSid;
PSID AzGlCreatorGroupSid;
ULONG AzGlWorldSidSize;

//
// Define the default values for all scalar attributes
//

ULONG AzGlDefDomainTimeout = AZ_AZSTORE_DEFAULT_DOMAIN_TIMEOUT;
ULONG AzGlDefScriptEngineTimeout = AZ_AZSTORE_DEFAULT_SCRIPT_ENGINE_TIMEOUT;
ULONG AzGlDefMaxScriptEngines = AZ_AZSTORE_DEFAULT_MAX_SCRIPT_ENGINES;
ULONG AzGlCurrAzRolesMajorVersion   = 1;
ULONG AzGlCurrAzRolesMinorVersion   = 0;

AZP_DEFAULT_VALUE AzGlAzStoreDefaultValues[] = {
    { AZ_PROP_AZSTORE_DOMAIN_TIMEOUT,        AZ_DIRTY_AZSTORE_DOMAIN_TIMEOUT,        &AzGlDefDomainTimeout },
    { AZ_PROP_AZSTORE_SCRIPT_ENGINE_TIMEOUT, AZ_DIRTY_AZSTORE_SCRIPT_ENGINE_TIMEOUT, &AzGlDefScriptEngineTimeout },
    { AZ_PROP_AZSTORE_MAX_SCRIPT_ENGINES,    AZ_DIRTY_AZSTORE_MAX_SCRIPT_ENGINES,    &AzGlDefMaxScriptEngines },
    { AZ_PROP_AZSTORE_MAJOR_VERSION,         AZ_DIRTY_AZSTORE_MAJOR_VERSION,         &AzGlCurrAzRolesMajorVersion},
    { AZ_PROP_AZSTORE_MINOR_VERSION,         AZ_DIRTY_AZSTORE_MINOR_VERSION,         &AzGlCurrAzRolesMinorVersion},
    { 0, 0, NULL }
};

AZP_STRING AzGEmptyString = {0};

#if DBG
BOOL CritSectInitialized = FALSE;
#endif // DBG
#ifdef AZROLESDBG

BOOL LogFileCritSectInitialized = FALSE;


DWORD
myatolx(
    char const *psz)
{
    DWORD dw = 0;

    while (isxdigit(*psz))
    {
        char ch = *psz++;
        if (isdigit(ch))
        {
            ch -= '0';
        }
        else if (isupper(ch))
        {
            ch += 10 - 'A';
        }
        else
        {
            ch += 10 - 'a';
        }
        dw = (dw << 4) | ch;
    }
    return(dw);
}

#endif //AZROLESDBG

DWORD
AzpInitializeAccountDomainSid( VOID )

/*++

Routine description:

    This routine reads whether this machine is a DC and reads the AccountDomain
    sid if it is not.

Arguments: None

Return Value:

    Returns ERROR_SUCCESS on success, appropriate failure value otherwise.

--*/

{
    DWORD WinStatus;
    NTSTATUS Status;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC BasicInfo  = NULL;
    LSA_HANDLE hPolicy = NULL;
    OBJECT_ATTRIBUTES obja = {0};
    PPOLICY_ACCOUNT_DOMAIN_INFO pAccountInfo = NULL;

    //
    // Get the information about the local machine.
    //

    WinStatus = DsRoleGetPrimaryDomainInformation(
        NULL,
        DsRolePrimaryDomainInfoBasic,
        (PBYTE *) &BasicInfo );

    if ( WinStatus != NO_ERROR )
    {
        return WinStatus;
    }

    switch(BasicInfo->MachineRole)
    {
    case DsRole_RolePrimaryDomainController:
    case DsRole_RoleBackupDomainController:

        //
        // If the local machine is a DC then the client account must be a domain
        // account. The only workgroup accounts that can be authenticated are
        // local machine accounts.
        // Note that in this case we do not read the AccountDomainSid.
        //

        AzIsDC = TRUE;
        DsRoleFreeMemory( BasicInfo );
        return NO_ERROR;

    default:
        DsRoleFreeMemory( BasicInfo );
        break;
    }

    //
    // This may be a member server or a standalone machine. We need to get the
    // AccountDomainSid.
    //
    //   open LSA policy
    //

    Status = LsaOpenPolicy(
                 0,
                 &obja,
                 POLICY_VIEW_LOCAL_INFORMATION,
                 &hPolicy );

    if (!NT_SUCCESS(Status))
    {
        WinStatus = LsaNtStatusToWinError(Status);
        goto Cleanup;
    }

    //
    // Read the AccountDomainOformation.
    //
    Status = LsaQueryInformationPolicy(
                 hPolicy,
                 PolicyAccountDomainInformation,
                 (PVOID*)&pAccountInfo
                 );

    if ( !NT_SUCCESS( Status ) )
    {
        WinStatus = LsaNtStatusToWinError( Status );
        goto Cleanup;
    }

    ASSERT( RtlLengthSid( pAccountInfo->DomainSid ) < SECURITY_MAX_SID_SIZE );

    //
    // Copy the AccountDomainSid into global buffer.
    //
    Status = RtlCopySid(
                 RtlLengthSid( pAccountInfo->DomainSid ),
                 AzAccountDomainSid,
                 pAccountInfo->DomainSid );


    if ( !NT_SUCCESS( Status ) )
    {
        WinStatus = LsaNtStatusToWinError( Status );
        goto Cleanup;
    }

    AzAccountDomainSidInitialized = TRUE;

Cleanup:


    if ( hPolicy != NULL )
    {
        LsaClose( hPolicy );
    }

    if ( pAccountInfo != NULL )
    {
        LsaFreeMemory(pAccountInfo);
    }

    return WinStatus;
}

PSID
AzpAllocateWellKnownSid(
    IN WELL_KNOWN_SID_TYPE WellKnownSidType
    )
/*++

Routine Description:

    This routine allocate the SID of a well known security principal

Arguments:

    WellKnownSidType - the well known account sid that the caller desires

Return Values:

    A pointer to the allocated SID.  The caller must call AzpFreeHeap to free the sid.
    NULL - buffer couldn't be allocated

--*/
{
    DWORD WinStatus;
    DWORD SidSize;
    PSID Sid = NULL;

    //
    // Determine the size of the buffer
    //

    SidSize = 0;

    if (!CreateWellKnownSid( WellKnownSidType, NULL, NULL, &SidSize)) {

        WinStatus = GetLastError();

        if ( WinStatus != ERROR_INSUFFICIENT_BUFFER ) {
            return NULL;
        }

    } else {
        return NULL;
    }

    //
    // Allocate the buffer
    //

    Sid = AzpAllocateHeap( SidSize, "UTILWSID" );

    if ( Sid == NULL ) {
        return NULL;
    }

    //
    // Fill in the SID
    //

    if (!CreateWellKnownSid( WellKnownSidType, NULL, Sid, &SidSize)) {

        AzpFreeHeap( Sid );
        Sid = NULL;
    }

    return Sid;

}


BOOL
AzDllInitialize(VOID)
/*++

Routine Description

    This initializes global events and variables for the DLL.

Arguments

    none

Return Value

    Boolean: TRUE on success, FALSE on fail.

--*/
{
#ifdef DBG
    NTSTATUS Status;
#endif // DBG
    BOOL RetVal = TRUE;
    DWORD WinStatus;

    //
    // Initialize global constants
    //

    RtlZeroMemory( &AzGlZeroGuid, sizeof(AzGlZeroGuid) );

    //
    // Initialize the safe lock subsystem
    //

#ifdef DBG
    Status = SafeLockInit( SAFE_MAX_LOCK, TRUE );

    if ( !NT_SUCCESS( Status )) {
        RetVal = FALSE;
        KdPrint(("AzRoles.dll: SafeLockInit failed: 0x%lx\n",
                     Status ));
        goto Cleanup;
    }
#endif


    //
    // Initialize the resource
    //
    __try {

        SafeInitializeResource( &AzGlCloseApplication, SAFE_CLOSE_APPLICATION );
        SafeInitializeResource( &AzGlResource, SAFE_GLOBAL_LOCK );

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        RetVal = FALSE;
        KdPrint(("AzRoles.dll: RtlInitializeResource failed: 0x%lx\n",
                     GetExceptionCode() ));
        goto Cleanup;
    }

    ResourceInitialized = TRUE;

    //
    // Initialize the root of the tree of objects
    //

    AzpLockResourceExclusive( &AzGlResource );
    ObInitGenericHead( &AzGlAzStores, OBJECT_TYPE_AZAUTHSTORE, NULL, NULL );
    AzpUnlockResource( &AzGlResource );

    //
    // Initialize the stack allocator
    //

    SafeAllocaInitialize(
        SAFEALLOCA_USE_DEFAULT,
        SAFEALLOCA_USE_DEFAULT,
        AzpAllocateHeapSafe,
        AzpFreeHeap
        );

    WinStatus = AzpInitializeAccountDomainSid();

    if ( WinStatus != NO_ERROR ) {
        RetVal = FALSE;
        KdPrint(("AzRoles.dll: AzpInitializeAccountDomainSid failed: 0x%lx\n",
                     WinStatus ));
        goto Cleanup;
    }

#if DBG
    //
    // Initialize the allocator
    //

    InitializeListHead ( &AzGlAllocatedBlocks );
    Status = SafeInitializeCriticalSection( &AzGlAllocatorCritSect, SAFE_ALLOCATOR );

    if ( !NT_SUCCESS( Status )) {
        RetVal = FALSE;
        KdPrint(("AzRoles.dll: InitializCriticalSection (AzGlAllocatorCritSect) failed: 0x%lx\n",
                     Status ));
        goto Cleanup;
    }

    CritSectInitialized = TRUE;
#endif // DBG

#ifdef AZROLESDBG
    //
    // Initialize debugging
    //

    Status = SafeInitializeCriticalSection( &AzGlLogFileCritSect, SAFE_LOGFILE );

    if ( !NT_SUCCESS( Status )) {
        RetVal = FALSE;
        KdPrint(("AzRoles.dll: InitializCriticalSection (AzGlLogFileCritSect) failed: 0x%lx\n",
                     Status ));
        goto Cleanup;
    }
    LogFileCritSectInitialized = TRUE;



    //
    // Get debug flag from environment variable AZDBG
    //
    char const *pszAzDbg;
    pszAzDbg = getenv("AZDBG");
    if (NULL != pszAzDbg)
    {
        AzGlDbFlag |= myatolx(pszAzDbg);
    }

#endif // AZROLESDBG

    //
    // Initialize Global variables
    //

    AzGlCreatorOwnerSid = AzpAllocateWellKnownSid( WinCreatorOwnerSid );

    if ( AzGlCreatorOwnerSid == NULL ) {
        RetVal = FALSE;
        KdPrint(("AzRoles.dll: Cannot allocate creator owner sid\n" ));
        goto Cleanup;
    }

    AzGlCreatorGroupSid = AzpAllocateWellKnownSid( WinCreatorGroupSid );

    if ( AzGlCreatorGroupSid == NULL ) {
        RetVal = FALSE;
        KdPrint(("AzRoles.dll: Cannot allocate creator group sid\n" ));
        goto Cleanup;
    }

    AzGlWorldSid = AzpAllocateWellKnownSid( WinWorldSid );

    if ( AzGlWorldSid == NULL ) {
        RetVal = FALSE;
        KdPrint(("AzRoles.dll: Cannot allocate world sid\n" ));
        goto Cleanup;
    }
    AzGlWorldSidSize = GetLengthSid( AzGlWorldSid );

Cleanup:
    if ( !RetVal ) {
        AzDllUnInitialize();
    }
    return RetVal;

}


BOOL
AzDllUnInitialize(VOID)
/*++

Routine Description

    This uninitializes global events and variables for the DLL.

Arguments

    none

Return Value

    Boolean: TRUE on success, FALSE on fail.

--*/
{
    BOOL RetVal = TRUE;

    //
    // Free any global resources
    //

    if ( AzGlCreatorOwnerSid != NULL ) {
        AzpFreeHeap( AzGlCreatorOwnerSid );
        AzGlCreatorOwnerSid = NULL;
    }

    if ( AzGlCreatorGroupSid != NULL ) {
        AzpFreeHeap( AzGlCreatorGroupSid );
        AzGlCreatorGroupSid = NULL;
    }

    if ( AzGlWorldSid != NULL ) {
        AzpFreeHeap( AzGlWorldSid );
        AzGlWorldSid = NULL;
    }

    //
    // Delete the resource
    //

    if ( ResourceInitialized ) {
        SafeDeleteResource( &AzGlResource );
        SafeDeleteResource( &AzGlCloseApplication );
        ResourceInitialized = FALSE;
    }

#if DBG
    //
    // Done with the allocator
    //

    if ( CritSectInitialized ) {
        ASSERT( IsListEmpty( &AzGlAllocatedBlocks ));
        SafeDeleteCriticalSection ( &AzGlAllocatorCritSect );
        CritSectInitialized = FALSE;
    }
#endif // DBG

#ifdef AZROLESDBG
    //
    // Done with debugging
    //

    if ( LogFileCritSectInitialized ) {
        SafeDeleteCriticalSection ( &AzGlLogFileCritSect );
        LogFileCritSectInitialized = FALSE;
    }
#endif // AZROLESDBG

    return RetVal;

}

VOID
AzpAzStoreCleanupAuditSystem(
    IN OUT PAZP_AZSTORE AzAuthorizationStore
    )
/*++

Routine Description:

    This routines deregisters the event types with Authz audit system.

Arguments:

    AzAuthorizationStore - Authorization Store for which the audit handles will be deregistered.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    //
    // Free the audit handles
    //

    if ( AzAuthorizationStore->hClientContextCreateAuditEventType != NULL )
    {
        AuthziFreeAuditEventType( AzAuthorizationStore->hClientContextCreateAuditEventType );
        AzAuthorizationStore->hClientContextCreateAuditEventType = NULL;
    }

    if ( AzAuthorizationStore->hClientContextDeleteAuditEventType != NULL )
    {
        AuthziFreeAuditEventType( AzAuthorizationStore->hClientContextDeleteAuditEventType );
        AzAuthorizationStore->hClientContextDeleteAuditEventType = NULL;
    }

    if ( AzAuthorizationStore->hAccessCheckAuditEventType != NULL )
    {
        AuthziFreeAuditEventType( AzAuthorizationStore->hAccessCheckAuditEventType );
        AzAuthorizationStore->hAccessCheckAuditEventType = NULL;
    }

    if ( AzAuthorizationStore->hApplicationInitializationAuditEventType != NULL)
    {
        AuthziFreeAuditEventType( AzAuthorizationStore->hApplicationInitializationAuditEventType );
        AzAuthorizationStore->hApplicationInitializationAuditEventType = NULL;
    }

    if ( AzAuthorizationStore->hClientContextCreateNameAuditEventType != NULL )
    {
        AuthziFreeAuditEventType( AzAuthorizationStore->hClientContextCreateNameAuditEventType );
        AzAuthorizationStore->hClientContextCreateNameAuditEventType = NULL;
    }

    if ( AzAuthorizationStore->hClientContextDeleteNameAuditEventType != NULL )
    {
        AuthziFreeAuditEventType( AzAuthorizationStore->hClientContextDeleteNameAuditEventType );
        AzAuthorizationStore->hClientContextDeleteNameAuditEventType = NULL;
    }

    if ( AzAuthorizationStore->hAccessCheckNameAuditEventType != NULL )
    {
        AuthziFreeAuditEventType( AzAuthorizationStore->hAccessCheckNameAuditEventType );
        AzAuthorizationStore->hAccessCheckNameAuditEventType = NULL;
    }

    return;
}

DWORD
AzpAzStoreInitializeAuditSystem(
    IN OUT PAZP_AZSTORE AzAuthorizationStore
    )
/*++

Routine Description:

    This routines registers the event types with Authz audit system. We need
    one event handle per type of event generated.

Arguments:

    AzAuthorizationStore - Authorization Store for which the audit handles will be registered.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    BOOL b;
    HANDLE hToken = NULL;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hClientContextCreateNameAuditEventType = NULL;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hClientContextDeleteNameAuditEventType = NULL;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAccessCheckNameAuditEventType = NULL;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hClientContextCreateAuditEventType = NULL;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hClientContextDeleteAuditEventType = NULL;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAccessCheckAuditEventType = NULL;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hApplicationInitializationAuditEventType = NULL;
    TOKEN_PRIVILEGES NewPrivilegeState = {0};
    DWORD WinStatus;
    TOKEN_PRIVILEGES OldPrivilegeState = {0};
    BOOL PrivilegeAdjusted = FALSE;

    //
    // Set the values to Zero.
    //

    AzAuthorizationStore->hAccessCheckAuditEventType = NULL;
    AzAuthorizationStore->hApplicationInitializationAuditEventType = NULL;
    AzAuthorizationStore->hClientContextCreateAuditEventType = NULL;
    AzAuthorizationStore->hClientContextDeleteAuditEventType = NULL;
    AzAuthorizationStore->hAccessCheckNameAuditEventType = NULL;
    AzAuthorizationStore->hClientContextCreateNameAuditEventType = NULL;
    AzAuthorizationStore->hClientContextDeleteNameAuditEventType = NULL;

    //
    // Get the current token to adjust the Audit privilege.
    //

    WinStatus = AzpGetCurrentToken( &hToken );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Enable the audit privilege
    // If the initialize flag has the audit_is_critical bit set, then fail
    // if privilege is not held.  If the bit is not set, then simply return
    // w/o initializing any audit handles.
    //

    WinStatus = AzpChangeSinglePrivilege(
                    SE_AUDIT_PRIVILEGE,
                    hToken,
                    &NewPrivilegeState,
                    &OldPrivilegeState );

    if ( WinStatus != NO_ERROR ) {

        CloseHandle( hToken );
        
        if ( (AzAuthorizationStore->InitializeFlag & AZ_AZSTORE_FLAG_AUDIT_IS_CRITICAL) == 0 ) {

            //
            // Audit is not critical
            //

            WinStatus = NO_ERROR;
        }

        return WinStatus;
    }

    PrivilegeAdjusted = TRUE;

    //
    // Get audit handles for the event types we are interested in.
    //

    // Audit handle for Client context creation audit.
    b = AuthziInitializeAuditEventType( 0,
                                        SE_CATEGID_OBJECT_ACCESS,
                                        SE_AUDITID_AZ_CLIENTCONTEXT_CREATION,
                                        AZP_CLIENTCREATE_AUDITPARAMS_NO,
                                        &hClientContextCreateAuditEventType );

    if ( !b ) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    // Audit handle for Client context deletion audit.
    b = AuthziInitializeAuditEventType( 0,
                                        SE_CATEGID_OBJECT_ACCESS,
                                        SE_AUDITID_AZ_CLIENTCONTEXT_DELETION,
                                        AZP_CLIENTDELETE_AUDITPARAMS_NO,
                                        &hClientContextDeleteAuditEventType );

    if ( !b ) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    // Audit handle for access check audit.
    b = AuthziInitializeAuditEventType( 0,
                                        SE_CATEGID_OBJECT_ACCESS,
                                        SE_AUDITID_AZ_ACCESSCHECK,
                                        AZP_ACCESSCHECK_AUDITPARAMS_NO,
                                        &hAccessCheckAuditEventType );

    if ( !b ) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    // Audit handle for app initialization audit.
    b = AuthziInitializeAuditEventType( 0,
                                        SE_CATEGID_OBJECT_ACCESS,
                                        SE_AUDITID_AZ_APPLICATION_INITIALIZATION,
                                        AZP_APPINIT_AUDITPARAMS_NO,
                                        &hApplicationInitializationAuditEventType );

    if ( !b ) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    // Audit handle for Client context name creation audit.
    b = AuthziInitializeAuditEventType( 0,
                                        SE_CATEGID_OBJECT_ACCESS,
                                        SE_AUDITID_AZ_CLIENTCONTEXT_CREATION,
                                        AZP_CLIENTCREATE_AUDITPARAMS_NO+2,
                                        &hClientContextCreateNameAuditEventType );

    if ( !b ) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    // Audit handle for Client context name deletion audit.
    b = AuthziInitializeAuditEventType( 0,
                                        SE_CATEGID_OBJECT_ACCESS,
                                        SE_AUDITID_AZ_CLIENTCONTEXT_DELETION,
                                        AZP_CLIENTDELETE_AUDITPARAMS_NO+2,
                                        &hClientContextDeleteNameAuditEventType );

    if ( !b ) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    // Audit handle for access check name audit.
    b = AuthziInitializeAuditEventType( 0,
                                        SE_CATEGID_OBJECT_ACCESS,
                                        SE_AUDITID_AZ_ACCESSCHECK,
                                        AZP_ACCESSCHECK_AUDITPARAMS_NO+2,
                                        &hAccessCheckNameAuditEventType );

    if ( !b ) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Set the handles in the authorization store structure.
    //

    AzAuthorizationStore->hAccessCheckAuditEventType = hAccessCheckAuditEventType;
    AzAuthorizationStore->hApplicationInitializationAuditEventType = hApplicationInitializationAuditEventType;
    AzAuthorizationStore->hClientContextCreateAuditEventType =hClientContextCreateAuditEventType;
    AzAuthorizationStore->hClientContextDeleteAuditEventType = hClientContextDeleteAuditEventType;

    AzAuthorizationStore->hAccessCheckNameAuditEventType = hAccessCheckNameAuditEventType;
    AzAuthorizationStore->hClientContextCreateNameAuditEventType = hClientContextCreateNameAuditEventType;
    AzAuthorizationStore->hClientContextDeleteNameAuditEventType = hClientContextDeleteNameAuditEventType;

    WinStatus = NO_ERROR;

Cleanup:

    //
    // In case of errors, free all the audit handles that were created.
    //

    if ( WinStatus != NO_ERROR ) {

        if ( hClientContextCreateAuditEventType != NULL ) {
            AuthziFreeAuditEventType( hClientContextCreateAuditEventType );
        }

        if ( hClientContextDeleteAuditEventType != NULL ) {
            AuthziFreeAuditEventType( hClientContextDeleteAuditEventType );
        }

        if ( hAccessCheckAuditEventType != NULL ) {
            AuthziFreeAuditEventType( hAccessCheckAuditEventType );
        }

        if ( hClientContextCreateNameAuditEventType != NULL ) {
            AuthziFreeAuditEventType( hClientContextCreateNameAuditEventType );
        }

        if ( hClientContextDeleteNameAuditEventType != NULL ) {
            AuthziFreeAuditEventType( hClientContextDeleteNameAuditEventType );
        }

        if ( hAccessCheckNameAuditEventType != NULL ) {
            AuthziFreeAuditEventType( hAccessCheckNameAuditEventType );
        }

        if ( hApplicationInitializationAuditEventType != NULL) {
            AuthziFreeAuditEventType( hApplicationInitializationAuditEventType );
        }
    }

    //
    // If we had adjusted the audit privilege, revert to the original state.
    //

    if ( PrivilegeAdjusted ) {
        WinStatus = AzpChangeSinglePrivilege(
                        0,      // This is ignored since OldState is NULL.
                        hToken,
                        &OldPrivilegeState,
                        NULL ); // This should be set to NULL to specify REVERT.

        ASSERT( WinStatus == NO_ERROR );
    }

    if ( hToken != NULL ) {
        CloseHandle( hToken );
    }

    return WinStatus;
}


DWORD
AzpAzStoreInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzInitialize.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    DWORD WinStatus;
    PAZP_AZSTORE AzAuthorizationStore = (PAZP_AZSTORE) ChildGenericObject;
    NTSTATUS Status;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Initialize the lists of child objects
    //  Let the generic object manager know all of the types of children we support
    //

    ASSERT( ParentGenericObject == NULL );
    UNREFERENCED_PARAMETER( ParentGenericObject );

    ChildGenericObject->ChildGenericObjectHead = &AzAuthorizationStore->Applications;

    // List of child applications
    ObInitGenericHead( &AzAuthorizationStore->Applications,
                       OBJECT_TYPE_APPLICATION,
                       ChildGenericObject,
                       &AzAuthorizationStore->Groups );

    // List of child groups
    ObInitGenericHead( &AzAuthorizationStore->Groups,
                       OBJECT_TYPE_GROUP,
                       ChildGenericObject,
                       &ChildGenericObject->AzpSids );

    // List of child AzpSids
    ObInitGenericHead( &ChildGenericObject->AzpSids,
                       OBJECT_TYPE_SID,
                       ChildGenericObject,
                       NULL );

    //
    // Initialize the Domain list.
    //

    Status = SafeInitializeCriticalSection( &AzAuthorizationStore->DomainCritSect,
                                            SAFE_DOMAIN_LIST );

    if ( !NT_SUCCESS( Status )) {
        WinStatus = RtlNtStatusToDosError( Status );
        goto Cleanup;
    }

    AzAuthorizationStore->DomainCritSectInitialized = TRUE;
    InitializeListHead( &AzAuthorizationStore->Domains );


    //
    // Initialize Crit sect that serializes Persist engine operations
    //

    Status = SafeInitializeCriticalSection( &AzAuthorizationStore->FreeScriptCritSect,
                                            SAFE_FREE_SCRIPT_LIST );

    if ( !NT_SUCCESS( Status )) {
        WinStatus = RtlNtStatusToDosError( Status );
        goto Cleanup;
    }

    AzAuthorizationStore->FreeScriptCritSectInitialized = TRUE;
    InitializeListHead( &AzAuthorizationStore->LruFreeScriptHead );

    //
    // Initialize AzAuthStore mode
    //

    Status = SafeInitializeCriticalSection(
                &AzAuthorizationStore->PersistCritSect,
                SAFE_PERSIST_LOCK );
    if ( !NT_SUCCESS( Status ))
    {
        WinStatus = RtlNtStatusToDosError( Status );
        goto Cleanup;
    }
    AzAuthorizationStore->PersistCritSectInitialized = TRUE;
    InitializeListHead( &AzAuthorizationStore->NewNames );

    //
    // Initialize the script engine timer queue
    //

    AzAuthorizationStore->ScriptEngineTimerQueue = CreateTimerQueue();

    if ( AzAuthorizationStore->ScriptEngineTimerQueue == NULL ) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    //
    // By default generate audits
    //

    AzAuthorizationStore->GenericObject.IsGeneratingAudits = TRUE;

    WinStatus = NO_ERROR;
Cleanup:
    if ( WinStatus != NO_ERROR ) {
        AzpAzStoreCleanupAuditSystem( AzAuthorizationStore );
        AzpAzStoreFree( ChildGenericObject );
    }

    return WinStatus;
}


VOID
AzpAzStoreFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzAuthorizationStore object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    PAZP_AZSTORE AzAuthorizationStore = (PAZP_AZSTORE) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Close the database store
    //

    AzPersistClose( AzAuthorizationStore );

    //
    // Free any local strings
    //

    AzpFreeString( &AzAuthorizationStore->PolicyUrl );

    //
    // Free any local strings
    //

    AzpFreeString( &AzAuthorizationStore->TargetMachine );

    //
    // Free the domain list
    //

    if ( AzAuthorizationStore->DomainCritSectInitialized ) {

        // Free the list itself
        AzpUnlinkDomains( AzAuthorizationStore );

        // Free the crit sect protecting the list
        SafeDeleteCriticalSection( &AzAuthorizationStore->DomainCritSect );
        AzAuthorizationStore->DomainCritSectInitialized = FALSE;
    }

    //
    // Free the free script list
    //

    if ( AzAuthorizationStore->FreeScriptCritSectInitialized ) {

        //
        // The LRU FreeScriptList should have been flushed as each task object
        //  was freed.
        //  So we shouldn't be here unless the free script list is empty.

        ASSERT( IsListEmpty( &AzAuthorizationStore->LruFreeScriptHead ));
        ASSERT( AzAuthorizationStore->LruFreeScriptCount == 0 );

        // Free the crit sect protecting the list
        SafeDeleteCriticalSection( &AzAuthorizationStore->FreeScriptCritSect );
        AzAuthorizationStore->FreeScriptCritSectInitialized = FALSE;
    }

    //
    // Free the timer queue
    //

    if ( AzAuthorizationStore->ScriptEngineTimerQueue != NULL ) {
        DeleteTimerQueueEx( AzAuthorizationStore->ScriptEngineTimerQueue,
                            INVALID_HANDLE_VALUE );     // Wait for operation to finish
        AzAuthorizationStore->ScriptEngineTimerQueue = NULL;
    }

    // Free persistence engine critical section
    if (AzAuthorizationStore->PersistCritSectInitialized)
    {
        SafeDeleteCriticalSection( &AzAuthorizationStore->PersistCritSect );
        AzAuthorizationStore->PersistCritSectInitialized = FALSE;
        ASSERT( IsListEmpty( &AzAuthorizationStore->NewNames ));
    }

    //
    // Cleanup the audit system handles.
    //

    AzpAzStoreCleanupAuditSystem( AzAuthorizationStore );

    //
    // Free the provider dll
    //

    if ( AzAuthorizationStore->ProviderDll != NULL ) {
        FreeLibrary( AzAuthorizationStore->ProviderDll );
        AzAuthorizationStore->ProviderDll = NULL;
    }
}


DWORD
AzpAzStoreGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    This routine is the AzAuthorizationStore specific worker routine for AzGetProperty.
    It does any object specific property gets.

    On entry, AzGlResource must be locked shared.

Arguments:

    GenericObject - Specifies a pointer to the object to be queried

    Flags - Specifies internal flags
        AZP_FLAGS_BY_GUID - name lists should be returned as GUID lists
        AZP_FLAGS_PERSIST_* - Call is from the persistence provider

    PropertyId - Specifies which property to return.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_AZSTORE_DOMAIN_TIMEOUT        PULONG - Domain timeout (in milliseconds)
        AZ_PROP_AZSTORE_SCRIPT_ENGINE_TIMEOUT PULONG - Script timeout (in milliseconds)
        AZ_PROP_AZSTORE_MAX_SCRIPT_ENGINES    PULONG - Max number of cached scripts
        AZ_PROP_AZSTORE_MAJOR_VERSION         PLONG  - Major version
        AZ_PROP_AZSTORE_MINOR_VERSION         PLONG  - Minor version

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_AZSTORE AzAuthorizationStore = (PAZP_AZSTORE) GenericObject;
    UNREFERENCED_PARAMETER( Flags );

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );


    //
    // Return any object specific attribute
    //
    //  Return the domain timeout to the caller
    //

    switch ( PropertyId ) {
    case AZ_PROP_AZSTORE_DOMAIN_TIMEOUT:

        *PropertyValue = AzpGetUlongProperty( AzAuthorizationStore->DomainTimeout );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    //
    //  Return the script engine timeout to the caller
    //
    case AZ_PROP_AZSTORE_SCRIPT_ENGINE_TIMEOUT:

        *PropertyValue = AzpGetUlongProperty( AzAuthorizationStore->ScriptEngineTimeout );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    //
    //  Return max number of cached scripted engines
    //

    case AZ_PROP_AZSTORE_MAX_SCRIPT_ENGINES:

        *PropertyValue = AzpGetUlongProperty( AzAuthorizationStore->MaxScriptEngines );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    //
    //  Return store's major version
    //

    case AZ_PROP_AZSTORE_MAJOR_VERSION:

        *PropertyValue = AzpGetUlongProperty( AzAuthorizationStore->MajorVersion );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    //
    //  Return store's minor version
    //

    case AZ_PROP_AZSTORE_MINOR_VERSION:

        *PropertyValue = AzpGetUlongProperty( AzAuthorizationStore->MinorVersion );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    //
    //  Return store's target machine for resolving accounts
    //

    case AZ_PROP_AZSTORE_TARGET_MACHINE:

        *PropertyValue = AzpGetStringProperty( &AzAuthorizationStore->TargetMachine );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;


    default:
        AzPrint(( AZD_INVPARM, "AzpAzStoreGetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        break;
    }

    return WinStatus;
}


DWORD
AzpAzStoreSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    This routine is the AzAuthorizationStore object specific worker routine for AzSetProperty.
    It does any object specific property sets.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies a pointer to the object to be modified

    Flags - Specifies flags controlling to operation of the routine
        AZP_FLAGS_SETTING_TO_DEFAULT - Property is being set to default value
        AZP_FLAGS_PERSIST_* - Call is from the persistence provider

    PropertyId - Specifies which property to set.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_AZSTORE_DOMAIN_TIMEOUT        PULONG - Domain timeout (in milliseconds)
        AZ_PROP_AZSTORE_SCRIPT_ENGINE_TIMEOUT PULONG - Script timeout (in milliseconds)
        AZ_PROP_AZSTORE_MAX_SCRIPT_ENGINES    PULONG - Max number of cached scripts
        AZ_PROP_AZSTORE_MAJOR_VERSION         PLONG  - Major version
        AZ_PROP_AZSTORE_MINOR_VERSION         PLONG  - Minor version

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus;
    PAZP_AZSTORE AzAuthorizationStore = (PAZP_AZSTORE) GenericObject;
    LONG TempLong;
    
    BOOL bHasChanged = TRUE;

    //
    // Initialization
    //

    UNREFERENCED_PARAMETER( Flags );
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Set any object specific attribute
    //
    //  Set domain timeout
    //

    switch ( PropertyId ) {
    case AZ_PROP_AZSTORE_DOMAIN_TIMEOUT:

        BEGIN_SETPROP( &WinStatus, AzAuthorizationStore, Flags, AZ_DIRTY_AZSTORE_DOMAIN_TIMEOUT ) {
            WinStatus = AzpCaptureLong( PropertyValue, &TempLong );
            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            //
            // Do parameter validity checking
            //
            BEGIN_VALIDITY_CHECKING( Flags ) {
                if ( TempLong < AZ_AZSTORE_MIN_DOMAIN_TIMEOUT && TempLong != -1 ) {
                    AzPrint(( AZD_INVPARM, "AzpAzStoreManagerSetProperty: domain timeout too small %ld\n", TempLong ));
                    WinStatus = ERROR_INVALID_PARAMETER;
                    goto Cleanup;
                }
            } END_VALIDITY_CHECKING;

            AzAuthorizationStore->DomainTimeout = TempLong;
        } END_SETPROP(bHasChanged);
        break;

    //
    //  Set script engine timeout
    //

    case AZ_PROP_AZSTORE_SCRIPT_ENGINE_TIMEOUT:

        BEGIN_SETPROP( &WinStatus, AzAuthorizationStore, Flags, AZ_DIRTY_AZSTORE_SCRIPT_ENGINE_TIMEOUT ) {
            WinStatus = AzpCaptureLong( PropertyValue, &TempLong );
            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            //
            // Do parameter validity checking
            //
            BEGIN_VALIDITY_CHECKING( Flags ) {
                if ( TempLong < AZ_AZSTORE_MIN_SCRIPT_ENGINE_TIMEOUT && TempLong != -1 && TempLong != 0 ) {
                    AzPrint(( AZD_INVPARM, "AzpAzStoreManagerSetProperty: script engine timeout too small %ld\n", TempLong ));
                    WinStatus = ERROR_INVALID_PARAMETER;
                    goto Cleanup;
                }
            } END_VALIDITY_CHECKING;

            AzAuthorizationStore->ScriptEngineTimeout = TempLong;
        } END_SETPROP(bHasChanged);
        break;

    //
    //  Set max number of cached scripted engines
    //

    case AZ_PROP_AZSTORE_MAX_SCRIPT_ENGINES:

        BEGIN_SETPROP( &WinStatus, AzAuthorizationStore, Flags, AZ_DIRTY_AZSTORE_MAX_SCRIPT_ENGINES ) {

            WinStatus = AzpCaptureLong( PropertyValue, &TempLong );
            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            //
            // Do parameter validity checking
            //
            BEGIN_VALIDITY_CHECKING( Flags ) {
                if ( TempLong < 0) {
                    AzPrint(( AZD_INVPARM, "AzpAzStoreManagerSetProperty: max script engines too small %ld\n", TempLong ));
                    WinStatus = ERROR_INVALID_PARAMETER;
                    goto Cleanup;
                }
            } END_VALIDITY_CHECKING;

            AzAuthorizationStore->MaxScriptEngines = TempLong;
        } END_SETPROP(bHasChanged);
        break;

    //
    // Major version. These are hidden from out side clients. Howeveer, in order
    // for it to work with our cache model, we still have to implement this code.
    //

    case AZ_PROP_AZSTORE_MAJOR_VERSION:

        BEGIN_SETPROP( &WinStatus, AzAuthorizationStore, Flags, AZ_DIRTY_AZSTORE_MAJOR_VERSION ) {

            WinStatus = AzpCaptureLong( PropertyValue, &TempLong );

            if (WinStatus != NO_ERROR)
            {
                goto Cleanup;
            }

            AzAuthorizationStore->MajorVersion = TempLong;

        } END_SETPROP(bHasChanged);

        break;

    //
    // Minor version These are hidden from out side clients. Howeveer, in order
    // for it to work with our cache model, we still have to implement this code.
    //

    case AZ_PROP_AZSTORE_MINOR_VERSION:

        BEGIN_SETPROP( &WinStatus, AzAuthorizationStore, Flags, AZ_DIRTY_AZSTORE_MINOR_VERSION ) {

            WinStatus = AzpCaptureLong( PropertyValue, &TempLong );

            if (WinStatus != NO_ERROR)
            {
                goto Cleanup;
            }

            AzAuthorizationStore->MinorVersion = TempLong;

        } END_SETPROP(bHasChanged);

        break;

    default:
        AzPrint(( AZD_INVPARM, "AzpAzStoreManagerSetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        break;
    }

Cleanup:
    return WinStatus;
}



DWORD
WINAPI
AzInitialize(
    IN LPCWSTR PolicyUrl,
    IN DWORD Flags,
    IN DWORD Reserved,
    OUT PAZ_HANDLE AzStoreHandle
    )
/*++

Routine Description:

    This routine initializes the authorization store.  This routine must be called before any other
    routine.

Arguments:

    PolicyUrl - Specifies the location of the policy store

    Flags - Specifies flags that control the behavior of AzInitialize
        AZ_AZSTORE_FLAG_CREATE: Create the policy database
        AZ_AZSTORE_FLAG_MANAGE_STORE_ONLY: Open the store for administrative purposes only.  There
                                         will be no runtime functions performed.
        AZ_AZSTORE_FLAG_BATCH_UPDATE: When this flag is set, we will not update
                                      the authorization store object for the purpuse of quick
                                      discovery of store modification. For those clients who know
                                      that they will do massive number of updates within a short
                                      period of time on an AD store, then they should use this
                                      flag to reduce network traffic.
        AZ_AZSTORE_FLAG_AUDIT_IS_CRITICAL: If this flag is specified, the calling process needs to have
                                      SE_AUDIT_PRIVILEGE, else error will be returned.

    Reserved - Reserved.  Must by zero.

    AzStoreHandle - Return a handle to the AzAuthorizationStore.
        The caller must close this handle by calling AzCloseHandle.


Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - AZ_AZSTORE_FLAG_CREATE flag was specified and the policy already exists
    ERROR_FILE_NOT_FOUND - AZ_AZSTORE_FLAG_CREATE flag was not specified and the policy does not already exist

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT AzAuthorizationStore = NULL;
    AZP_STRING AzStoreName;
    AZP_STRING PolicyUrlString;

    //
    // Grab the global lock
    //

    AzpLockResourceExclusive( &AzGlResource );
    AzpInitString( &AzStoreName, NULL );
    AzpInitString( &PolicyUrlString, NULL );

    //
    // Initialization
    //

    __try {
        *AzStoreHandle = NULL;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        WinStatus = RtlNtStatusToDosError( GetExceptionCode());
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "AzInitialize: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    if ( Flags & ~AZ_AZSTORE_FLAG_VALID ) {
        AzPrint(( AZD_INVPARM, "AzInitialize: Invalid flags 0x%lx\n", Flags ));
        WinStatus = ERROR_INVALID_FLAGS;
        goto Cleanup;
    }

    //
    // Capture the Policy URL
    //

    WinStatus = AzpCaptureString( &PolicyUrlString,
                                  (LPWSTR) PolicyUrl,
                                  AZ_MAX_POLICY_URL_LENGTH,
                                  FALSE ); // NULL is not OK

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Create the object. If this succeeds, then AzAuthorizationStore is holding
    // two ref count: one for global list and one for AzAuthorizationStore itself.
    // Therefore, if for any reason we fail to return the requested handle,
    // we must decrement one extra ref count because the global list ref
    // count relies on the handle's close to go down to 0.
    //

    WinStatus = ObCreateObject(
                    NULL, // There is no parent object
                    &AzGlAzStores,
                    OBJECT_TYPE_AZAUTHSTORE,
                    &AzStoreName,
                    NULL,   // Guid not known
                    0,      // No special flags
                    &AzAuthorizationStore );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Set authorization store specific fields
    //

    AzpSwapStrings( &PolicyUrlString, &((PAZP_AZSTORE)AzAuthorizationStore)->PolicyUrl );

    AzpInitString(&((PAZP_AZSTORE)AzAuthorizationStore)->TargetMachine, NULL);

    ((PAZP_AZSTORE)AzAuthorizationStore)->InitializeFlag = Flags;

    //
    // Initialize the audit system if not in manage store mode
    //

    if ( !AzpOpenToManageStore((PAZP_AZSTORE)AzAuthorizationStore) ) {

        WinStatus = AzpAzStoreInitializeAuditSystem( (PAZP_AZSTORE)AzAuthorizationStore );

        if ( WinStatus != NO_ERROR ) {

            //
            // Bug 591762: We will fail Initialization if SeAuditPrivilege is not held,
            // or if the Audit System failed to initialize for some other reason.  This is
            // because the user specifically asked for Initialization with runtime audits
            // being generated.
            //

            ObDereferenceObject( AzAuthorizationStore );

            AzPrint(( AZD_CRITICAL,
                     "AzInitialize: Failed to Initialize Audit system: %ld\n",
                     WinStatus
                     ));

            goto Cleanup;
        }
    }

    //
    // Load the objects for the database store
    //

    WinStatus = AzPersistOpen(
        (PAZP_AZSTORE)AzAuthorizationStore,
        (Flags & AZ_AZSTORE_FLAG_CREATE) != 0 );

    if ( WinStatus != NO_ERROR ) {
        ObDereferenceObject( AzAuthorizationStore );
        goto Cleanup;
    }


    //
    // Return the handle to the caller
    //

    ObIncrHandleRefCount( AzAuthorizationStore );
    *AzStoreHandle = AzAuthorizationStore;

    WinStatus = NO_ERROR;

    //
    // Free locally used resources
    //
Cleanup:

    if ( AzAuthorizationStore != NULL ) {
        ObDereferenceObject( AzAuthorizationStore );
    }

    AzpFreeString( &PolicyUrlString );

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;

}

DWORD
WINAPI
AzUpdateCache(
    IN AZ_HANDLE AzStoreHandle
    )
/*++

Routine Description:

    This routine updates the cache to match the underlying store.

Arguments:

    AzStoreHandle - Specifies a handle to the AzAuthorizationStore.


Return Value:

    NO_ERROR - The operation was successful


--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedGenericObject = NULL;


    //
    // Grab the global lock
    //

    AzpLockResourceExclusive( &AzGlResource );

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( (PGENERIC_OBJECT)AzStoreHandle,
                                           FALSE,   // Don't allow deleted objects
                                           FALSE,   // No need to refresh the cache here
                                           OBJECT_TYPE_AZAUTHSTORE );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedGenericObject = (PGENERIC_OBJECT) AzStoreHandle;


    WinStatus = AzPersistUpdateCache( (PAZP_AZSTORE)ReferencedGenericObject );

    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedGenericObject != NULL ) {
        ObDereferenceObject( ReferencedGenericObject );
    }

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}


DWORD
WINAPI
AzGetProperty(
    IN AZ_HANDLE AzHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    Returns the specified property for an Authz object

Arguments:

    AzHandle - Specifies a handle to the object to get the property for

    PropertyId - Specifies which property to return.

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.
        The PropertyId is one of the AZ_PROP_* values.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    //
    // Call the common routine to do most of the work
    //
    return ObCommonGetProperty(
                    (PGENERIC_OBJECT) AzHandle,
                    0,  // No flags
                    PropertyId,
                    Reserved,
                    PropertyValue );
}


DWORD
WINAPI
AzSetProperty(
    IN AZ_HANDLE AzHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Sets the specified property for an AzAuthorizationStore.

Arguments:

    AzHandle - Specifies a handle to the object to set the property for

    PropertyId - Specifies which property to set

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.
        The PropertyId is one of the AZ_PROP_* values.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{

    //
    // Call the common routine to do most of the work
    //

    return ObCommonSetProperty(
                    (PGENERIC_OBJECT) AzHandle,
                    PropertyId,
                    Reserved,
                    PropertyValue );
}


DWORD
WINAPI
AzAuthorizationStoreDelete(
    IN AZ_HANDLE AzStoreHandle,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This routine deletes the authorization store object specified by the passed in handle
    Also deletes any child objects of ApplicationName and the underlying store.

Arguments:

    AzStoreHandle - Specifies a handle to the AzAuthorizationStore.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedGenericObject = NULL;


    //
    // Grab the global lock
    //

    AzpLockResourceExclusive( &AzGlResource );

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "AzAuthorizationStoreDelete: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( (PGENERIC_OBJECT)AzStoreHandle,
                                           FALSE,   // Don't allow deleted objects
                                           FALSE,   // No need to refresh the cache on a delete
                                           OBJECT_TYPE_AZAUTHSTORE );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedGenericObject = (PGENERIC_OBJECT) AzStoreHandle;



    //
    // Actually, delete the object
    //

    WinStatus = AzPersistSubmit( ReferencedGenericObject, TRUE );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Mark the entry (and its child objects) as deleted
    //  We do this since other threads may have references to the objects.
    //  We want to ensure those threads know the objects are deleted.
    //

    ObMarkObjectDeleted( ReferencedGenericObject );



    //
    // Return to the caller
    //

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedGenericObject != NULL ) {
        ObDereferenceObject( ReferencedGenericObject );
    }

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;

}



DWORD
WINAPI
AzCloseHandle(
    IN AZ_HANDLE AzHandle,
    IN DWORD Reserved
    )
/*++

Routine Description:

    Close a handle returned from any of the Az* routines

Arguments:

    AzHandle - Passes in the handle to be closed.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The passed in handle was invalid

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedGenericObject = NULL;
    PGENERIC_OBJECT GenericObject = (PGENERIC_OBJECT) AzHandle;
    PGENERIC_OBJECT AzStoreGenericObject = NULL;
    DWORD ObjectType;


    //
    // Grab the global lock
    //

    AzpLockResourceShared( &AzGlResource );

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "AzCloseHandle: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Determine the type of the object
    //

    WinStatus = ObGetHandleType( GenericObject,
                                 TRUE,          // Ok to close handle for deleted object
                                 &ObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Grab the lock exclusively if we're going to change the database
    //

    if ( ObjectType == OBJECT_TYPE_AZAUTHSTORE ) {
        AzpLockResourceSharedToExclusive( &AzGlResource );
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( GenericObject,
                                           TRUE,    // Allow deleted objects
                                           FALSE,   // No need to refresh cache on a close
                                           ObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedGenericObject = GenericObject;

    //
    // Grab a reference to the root of the core cache
    //
    //  This might be the last handle open.  Closing the last handle removes
    //  the last reference to the object at the root of the core cache.
    //  We need to ensure that there are no other references to children objects.
    //  We do that by grabing our own reference here so that our dereference will
    //  be the final dereference
    //

    AzStoreGenericObject = &GenericObject->AzStoreObject->GenericObject;

    InterlockedIncrement( &AzStoreGenericObject->ReferenceCount );
    AzpDumpGoRef( "AzAuthorizationStore in AzCloseHandle ref", AzStoreGenericObject );



    //
    // If the object is dirty,
    //  and we're closing the last handle,
    //  abort the changes.
    //

    if ( GenericObject->DirtyBits != 0 &&
         GenericObject->HandleReferenceCount == 1 ) {

        //
        // We need an exclusive lock to delete the object.
        //
        // If this is the AzAuthorizationStore object, the we already 
        // have the glock held exclusively
        //

        if ( ObjectType != OBJECT_TYPE_AZAUTHSTORE ) {

            AzpLockResourceSharedToExclusive( &AzGlResource );
        }

        //
        // Ensure things haven't changed
        //

        if ( GenericObject->DirtyBits != 0 &&
             GenericObject->HandleReferenceCount == 1 ) {

            AzPersistAbort( GenericObject );

        }
    }

    //
    // Handle close of AzAuthorizationStore handles
    //

    if ( ObjectType == OBJECT_TYPE_AZAUTHSTORE ) {

        //
        // If the object hasn't been deleted,
        //  remove the reference representing being in the global list.
        //

        if ( (GenericObject->Flags & GENOBJ_FLAGS_DELETED) == 0 ) {

            //
            // Make sure the caller doesn't re-use the handle
            //
            GenericObject->Flags |= GENOBJ_FLAGS_DELETED;

            // No longer in the global list
            ObDereferenceObject( GenericObject );
        }

    //
    // For a client context,
    //  remove the link from the parent when the handle closes
    //

    } else if ( ObjectType == OBJECT_TYPE_CLIENT_CONTEXT ) {

        ASSERT( GenericObject->HandleReferenceCount == 1 );

        // One from ObReferenceObjectByHandle,
        //  one for being in the global list,
        //  one because the handle itself isn't closed yet.
        //ASSERT( GenericObject->ReferenceCount == 3 );

        // No longer in the global list
        ObDereferenceObject( GenericObject );

    }


    //
    // Actually close the handle
    //

    WinStatus = ObDecrHandleRefCount( GenericObject );

    if ( WinStatus != NO_ERROR ) {

        goto Cleanup;
    }

    //
    // Done
    //

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedGenericObject != NULL ) {
        ObDereferenceObject( ReferencedGenericObject );
    }

    if ( AzStoreGenericObject != NULL ) {
        // This dereference might delete the entire cache
        ObDereferenceObject( AzStoreGenericObject );
    }

    //
    // Drop the global lock
    //
    
    AzpUnlockResource( &AzGlResource );

    return WinStatus;

}


VOID
WINAPI
AzFreeMemory(
    IN OUT PVOID Buffer
    )
/*++

Routine Description

    Free memory returned from AzGetProperty

Arguments

    Buffer - address of buffer to free

Return Value

    None

--*/
{
    if ( Buffer != NULL ) {
        AzpFreeHeap( Buffer);
    }
}


inline BOOL
AzpAzStoreVersionAllowWrite(
    IN PAZP_AZSTORE AzAuthorizationStore
    )

/*++

Routine Description:

        This routine tests if the current azroles.dll verion can support
        writing of the store created by a potentially different version
        of adroles.dll. The version of the dll that wrote the dll is captured
        by the major and minor verions of the AzAuthStore object.

Arguments:

        AzAuthorizationStore - the auth store object

Return Values:

        TRUE if it supports the action
        FALSE if not.

Note:

    MajorVersion (DWORD) - Specifies the major version of the azroles.dll
    that wrote this policy.  An azroles.dll with an older major version
    number cannot read nor write a database with a newer major version number.
    The version 1 value of this DWORD is 1.  We hope to never have to
    change this value in future releases.

    MinorVersion (DWORD) - Specifies the minor version of the azroles.dll
    that wrote this policy.  An azroles.dll with an older minor version
    number can read but cannot write a database with a newer minor version number.
    The version 1 value of this DWORD is 0.

--*/

{
    return ( AzAuthorizationStore->MajorVersion == AzGlCurrAzRolesMajorVersion &&
             AzAuthorizationStore->MinorVersion <= AzGlCurrAzRolesMinorVersion );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\bizrule.h ===
/*++

    Copyright (c) 2001  Microsoft Corporation

Module Name:

    bizrule.h

Abstract:

    Header for data associated with Client Contexts.

    Include routines implementing Business Rules and the Operation Cache.

Author:

    IActiveScript sample code taken from http://support.microsoft.com/support/kb/articles/Q183/6/98.ASP
    Cliff Van Dyke (cliffv) 18-July-2001

--*/



/////////////////////////////////////////////////////////////////////////////
//
// Structure definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// For a particular role or task, define the operations or tasks that apply.
//

typedef struct _AZ_OPS_AND_TASKS {

    //
    // Applicable operations
    //  An array of operations that are applicable for this access check.
    //  Each element is an index into the OpInfo array.
    //

    ULONG OpCount;
    PULONG OpIndexes;

    //
    // Applicable task
    //  An array of operations that are applicable for this access check.
    //  Each element is an index into the TaskInfo array.
    //

    ULONG TaskCount;
    PULONG TaskIndexes;
#define AZ_INVALID_INDEX 0xFFFFFFFF

} AZ_OPS_AND_TASKS, *PAZ_OPS_AND_TASKS;

//
// Define all the information associated with a role and
// that has a lifetime of an AccessCheck operation
//

typedef struct _AZ_ROLE_INFO {

    //
    // A pointer to the role object.
    //  The reference count is held on this role object.
    //
    PAZP_ROLE Role;

    //
    // Operations and tasks that apply to this role
    //
    AZ_OPS_AND_TASKS OpsAndTasks;

    //
    // Computed group membership of this role
    // NOT_YET_DONE: Status has not yet been computed.
    //
    ULONG ResultStatus;

    //
    // Boolean indicating that this role has been processed and no further processing
    //  is required for the lifetime of the AccessCheck.
    //
    BOOLEAN RoleProcessed;

    //
    // Boolean indicating that the Sid membership of the role has been computed
    //
    BOOLEAN SidsProcessed;


} AZ_ROLE_INFO, *PAZ_ROLE_INFO;

//
// Define all the information associated with a task and
// that has a lifetime of an AccessCheck operation
//

typedef struct _AZ_TASK_INFO {

    //
    // A pointer to the task object.
    //  The reference count is held on this task object.
    //
    PAZP_TASK Task;

    //
    // Operations and tasks that apply to this task
    //
    AZ_OPS_AND_TASKS OpsAndTasks;

    //
    // Boolean indicating that this task has been processed and no further processing
    //  is required for the lifetime of the AccessCheck.
    //
    BOOLEAN TaskProcessed;

    //
    // Boolean indicating that the BizRule for this task has been processed and that the
    //  result of the BizRule is in BizRuleResult.
    //
    BOOLEAN BizRuleProcessed;
    BOOLEAN BizRuleResult;

} AZ_TASK_INFO, *PAZ_TASK_INFO;


//
// Define a context that describe an access check operation in progress
//

typedef struct _ACCESS_CHECK_CONTEXT {

    //
    // Client context of the caller
    //
    PAZP_CLIENT_CONTEXT ClientContext;

    //
    // Application doing the access check
    //
    PAZP_APPLICATION Application;

    //
    // Object being accessed
    //
    AZP_STRING ObjectNameString;

    //
    // The BusinessRuleString returned from the various bizrules
    //
    AZP_STRING BusinessRuleString;

    //
    // Operations that the caller wants to check and the Result access granted for that operation.
    //
    ULONG OperationCount;
    PAZP_OPERATION *OperationObjects;
    PULONG Results;

    // Array with one element per operation
    PBOOLEAN OperationWasProcessed;

    // Number of operations that have already been processed
    ULONG ProcessedOperationCount;

    // Number of operations that were resolved from the operation cache
    ULONG CachedOperationCount;

    //
    // Scope the access check is being performed on
    //
    AZP_STRING ScopeNameString;
    PAZP_SCOPE Scope;

    //
    // Roles that match the Scope

    ULONG RoleCount;
    PAZ_ROLE_INFO RoleInfo;

    //
    // Tasks that apply to the access check
    //

    ULONG TaskCount;
    PAZ_TASK_INFO TaskInfo;

    //
    // Parameters to pass to Bizrules
    //  See AzContextAccessCheck parameters for descriptions
    //
    // Arrays actually passed to AzContextAccessCheck

    SAFEARRAY* SaParameterNames;
    VARIANT *ParameterNames;
    SAFEARRAY* SaParameterValues;
    VARIANT *ParameterValues;

    // Array indicating whether each parameter is actually used
    BOOLEAN *UsedParameters;
    ULONG UsedParameterCount;

    // Number of elements in the above arrays
    ULONG ParameterCount;

    //
    // Interfaces to pass to Bizrules
    //  See AzContextAccessCheck parameters for descriptions
    //

    SAFEARRAY *InterfaceNames;
    SAFEARRAY *InterfaceFlags;
    SAFEARRAY *Interfaces;
    LONG InterfaceLower;   // Lower bound of above arrays
    LONG InterfaceUpper;   // Upper bound of above arrays

} ACCESS_CHECK_CONTEXT, *PACCESS_CHECK_CONTEXT;


/////////////////////////////////////////////////////////////////////////////
//
// Procedure definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// Procedures from context.cxx
//

INT __cdecl
AzpCompareParameterNames(
    IN const void *pArg1,
    IN const void *pArg2
    );
    
    
INT __cdecl
AzpCaseInsensitiveCompareParameterNames(
    IN const void *pArg1,
    IN const void *pArg2
    );


//
// Procedures from bizrule.cxx
//

DWORD
AzpProcessBizRule(
    IN PACCESS_CHECK_CONTEXT AcContext,
    IN PAZP_TASK Task,
    OUT PBOOL BizRuleResult
    );

DWORD
AzpParseBizRule(
    IN PAZP_TASK Task
    );

VOID
AzpFlushBizRule(
    IN PAZP_TASK Task
    );

//
// Procedures from opcache.cxx
//

VOID
AzpInitOperationCache(
    IN PAZP_CLIENT_CONTEXT ClientContext
    );

BOOLEAN
AzpCheckOperationCache(
    IN PACCESS_CHECK_CONTEXT AcContext
    );

VOID
AzpUpdateOperationCache(
    IN PACCESS_CHECK_CONTEXT AcContext
    );

VOID
AzpFlushOperationCache(
    IN PAZP_CLIENT_CONTEXT ClientContext
    );

/////////////////////////////////////////////////////////////////////////////
//
// Class definitions
//
/////////////////////////////////////////////////////////////////////////////


class CScriptEngine;

//
// Structure used for linking CScriptEngine instances into a list
//

typedef struct _LIST_ELEMENT {

    //
    // Link to the next entry in the list
    //
    LIST_ENTRY Next;

    //
    // Pointer to the ScriptEngine head
    //
    CScriptEngine *This;

} LIST_ELEMENT, *PLIST_ELEMENT;

//
// IActiveScriptSite implementation.
//
// This interface allows the script engine to call back to the script host.
//

class CScriptEngine:public IActiveScriptSite
{

protected :
    LONG m_cRef;             //variable to maintain the reference count

    //
    // Pointer to the task that defines this bizrule
    //

    PAZP_TASK m_Task;

    //
    // Pointer to the context for the active AccessCheck using this bizrule
    //
    PACCESS_CHECK_CONTEXT m_AcContext;

    //
    // Link to the next script engine in either the FreeScript list or RunningScript list
    //
    LIST_ELEMENT m_Next;

    //
    // Link to the next script engine in LRU FreeScript list
    //
    LIST_ELEMENT m_LruNext;

    //
    // Script engine references
    //
    IActiveScript *m_Engine;
    IActiveScriptParse *m_Parser;

    //
    // Pointer to the IAzBizRuleContext interface that the script will interact with
    //
    IAzBizRuleContext *m_BizRuleContext;

    //
    // Thread ID of the thread that initialized the script
    //

    SCRIPTTHREADID m_BaseThread;


    //
    // Copy of the BizRuleSerialNumber that was active when we parsed the BizRule script
    //

    DWORD m_BizRuleSerialNumber;

    //
    // Script failure status code
    //

    HRESULT m_ScriptError;

    //
    // Various state booleans
    //
    DWORD m_fInited:1;          // Have we been inited?
    DWORD m_fCorrupted:1;       // Might the engine be "unsafe" for reuse?
    DWORD m_fTimedOut:1;        // Script timed out

    BOOL  m_bCaseSensitive;

public:
    //Constructor
    CScriptEngine();

    //Destructor
    ~CScriptEngine();

    HRESULT
    Init(
        IN PAZP_TASK Task,
        IN IActiveScript *ClonedActiveScript OPTIONAL,
        IN DWORD ClonedBizRuleSerialNumber OPTIONAL
        );

    HRESULT
    RunScript(
        IN PACCESS_CHECK_CONTEXT AcContext,
        OUT PBOOL BizRuleResult
        );

    HRESULT InterruptScript();

    HRESULT ResetToUninitialized();

    HRESULT ReuseEngine();

    BOOL IsBaseThread();

    VOID FinalRelease();


    //
    // Insert this engine into an externally managed list
    //

    VOID
    InsertHeadList(
        IN PLIST_ENTRY ListHead
        );

    VOID
    RemoveListEntry(
        VOID
        );

    VOID
    InsertHeadLruList(
        VOID
        );

    VOID
    RemoveLruListEntry(
        VOID
        );

    //
    // Inline interfaces
    //
    inline IActiveScript *GetActiveScript()
    {
        return (m_Engine);
    }

    inline DWORD GetBizRuleSerialNumber( VOID )
    {
        return (m_BizRuleSerialNumber);
    }

    inline BOOL FIsCorrupted()
    {
        return (m_fCorrupted);
    }


#ifdef DBG
    inline VOID AssertValid()
    const {
        ASSERT(m_fInited);
        ASSERT(m_Engine != NULL);
        ASSERT(m_Parser != NULL);
        ASSERT(m_BizRuleContext != NULL);
        ASSERT(m_cRef != 0);
     }
#else
     virtual VOID AssertValid() const {}
#endif // DBG



    /******* IUnknown *******/
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    /******* IActiveScriptSite *******/
    STDMETHODIMP GetLCID(LCID * plcid);         // address of variable for language identifier

    STDMETHODIMP GetItemInfo(
        LPCOLESTR pstrName,     // address of item name
        DWORD dwReturnMask,    // bit mask for information retrieval
        IUnknown ** ppunkItem,         // address of pointer to item's IUnknown
        ITypeInfo ** ppTypeInfo );      // address of pointer to item's ITypeInfo

    STDMETHODIMP GetDocVersionString(
        BSTR * pbstrVersionString);     // address of document version string

    STDMETHODIMP OnScriptTerminate(
        const VARIANT * pvarResult,       // address of script results
        const EXCEPINFO * pexcepinfo);   // address of structure with exception information

    STDMETHODIMP OnStateChange(
        SCRIPTSTATE ssScriptState);   // new state of engine

    STDMETHODIMP OnScriptError(
        IActiveScriptError * pase);   // address of error interface

    STDMETHODIMP OnEnterScript(void);
    STDMETHODIMP OnLeaveScript(void);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\azrolesp.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    azrolesp.h

Abstract:

    Definitions of C interfaces.

    One day all of these interfaces will be in the public SDK.  Only such
    interfaces exist in this file.

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/



#ifndef _AZROLESP_H_
#define _AZROLESP_H_

#include "azroles.h"

#if !defined(_AZROLESAPI_)
#define WINAZROLES DECLSPEC_IMPORT
#else
#define WINAZROLES
#endif

#ifdef __cplusplus
extern "C" {
#endif


/////////////////////////////////////////////////////////////////////////////
//
// Value definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// Common Property IDs
//
// This list of property IDs are common to all objects.
// Each object should pick specific property ids after AZ_PROP_FIRST_SPECIFIC
//

#define AZ_PROP_FIRST_SPECIFIC              100


//
// Audit specific constants
//

#define AZP_APPINIT_AUDITPARAMS_NO       4
#define AZP_CLIENTCREATE_AUDITPARAMS_NO  4
#define AZP_ACCESSCHECK_AUDITPARAMS_NO   9
#define AZP_CLIENTDELETE_AUDITPARAMS_NO  3


//
// Maximum length (in characters) of the object name
//

// #define AZ_MAX_APPLICATION_NAME_LENGTH      512
// #define AZ_MAX_OPERATION_NAME_LENGTH         64
// #define AZ_MAX_TASK_NAME_LENGTH              64
// #define AZ_MAX_SCOPE_NAME_LENGTH          65536
// #define AZ_MAX_GROUP_NAME_LENGTH             64
// #define AZ_MAX_ROLE_NAME_LENGTH              64
// #define AZ_MAX_NAME_LENGTH                65536  // Max of the above

//
// Maximum length (in characters) of the description of an object
//

// #define AZ_MAX_DESCRIPTION_LENGTH          1024

//
// Maximum length (in characters) of various object strings
//

// #define AZ_MAX_POLICY_URL_LENGTH          65536

// #define AZ_MAX_GROUP_LDAP_QUERY_LENGTH     4096

/////////////////////////////////////////////////////////////////////////////
//
// Structure definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// Handle to various objects returned to caller
//

typedef PVOID AZ_HANDLE;
typedef AZ_HANDLE *PAZ_HANDLE;

//
// Array of strings returned from various "GetProperty" procedures
//

typedef struct _AZ_STRING_ARRAY {

    //
    // Number of strings
    //
    ULONG StringCount;

    //
    // An array of StringCount pointers to strings.
    //
    LPWSTR *Strings;

} AZ_STRING_ARRAY, *PAZ_STRING_ARRAY;

//
// Array of SIDs returned from various "GetProperty" procedures
//

typedef struct _AZ_SID_ARRAY {

    //
    // Number of SIDs
    //
    ULONG SidCount;

    //
    // An array of SidCount pointers to SIDs.
    //
    PSID *Sids;

} AZ_SID_ARRAY, *PAZ_SID_ARRAY;


//
// Array of GUIDs returned from various "GetProperty" procedures
//

typedef struct _AZ_GUID_ARRAY {

    //
    // Number of GUIDs
    //
    ULONG GuidCount;

    //
    // An array of GuidCount pointers to GUIDs.
    //
    GUID **Guids;

} AZ_GUID_ARRAY, *PAZ_GUID_ARRAY;


/////////////////////////////////////////////////////////////////////////////
//
// Procedure definitions
//
/////////////////////////////////////////////////////////////////////////////

WINAZROLES
DWORD
WINAPI
AzInitialize(
    IN LPCWSTR PolicyUrl,
    IN DWORD Flags,
    IN DWORD Reserved,
    OUT PAZ_HANDLE AzStoreHandle
    );

WINAZROLES
DWORD
WINAPI
AzUpdateCache(
    IN AZ_HANDLE AzStoreHandle
    );

WINAZROLES
DWORD
WINAPI
AzGetProperty(
    IN AZ_HANDLE AzHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzSetProperty(
    IN AZ_HANDLE AzHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzAddPropertyItem(
    IN AZ_HANDLE AzHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzRemovePropertyItem(
    IN AZ_HANDLE AzHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

//
// Flags to AuthorizationStore routines
//
#define AZ_AZSTORE_FLAG_VALID  0x000F  // Mask of all valid flags

//
// AzAuthorizationStore routines
//

WINAZROLES
DWORD
WINAPI
AzAuthorizationStoreDelete(
    IN AZ_HANDLE AzStoreHandle,
    IN DWORD Reserved
    );


//
// Application routines
//
WINAZROLES
DWORD
WINAPI
AzApplicationCreate(
    IN AZ_HANDLE AzStoreHandle,
    IN LPCWSTR ApplicationName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ApplicationHandle
    );

WINAZROLES
DWORD
WINAPI
AzApplicationOpen(
    IN AZ_HANDLE AzStoreHandle,
    IN LPCWSTR ApplicationName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ApplicationHandle
    );

WINAZROLES
DWORD
WINAPI
AzApplicationClose(
    IN AZ_HANDLE AzAuthorizationStoreHandle,
    IN LPCWSTR pApplicationName,
    IN LONG lFlags
    );

WINAZROLES
DWORD
WINAPI
AzApplicationEnum(
    IN AZ_HANDLE AzStoreHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE ApplicationHandle
    );

WINAZROLES
DWORD
WINAPI
AzApplicationDelete(
    IN AZ_HANDLE AzStoreHandle,
    IN LPCWSTR ApplicationName,
    IN DWORD Reserved
    );


//
// Operation routines
//
WINAZROLES
DWORD
WINAPI
AzOperationCreate(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR OperationName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE OperationHandle
    );

WINAZROLES
DWORD
WINAPI
AzOperationOpen(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR OperationName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE OperationHandle
    );

WINAZROLES
DWORD
WINAPI
AzOperationEnum(
    IN AZ_HANDLE ApplicationHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE OperationHandle
    );

WINAZROLES
DWORD
WINAPI
AzOperationDelete(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR OperationName,
    IN DWORD Reserved
    );


//
// Task routines
//
WINAZROLES
DWORD
WINAPI
AzTaskCreate(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR TaskName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE TaskHandle
    );

WINAZROLES
DWORD
WINAPI
AzTaskOpen(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR TaskName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE TaskHandle
    );

WINAZROLES
DWORD
WINAPI
AzTaskEnum(
    IN AZ_HANDLE ApplicationHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE TaskHandle
    );

WINAZROLES
DWORD
WINAPI
AzTaskDelete(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR TaskName,
    IN DWORD Reserved
    );


//
// Scope routines
//
WINAZROLES
DWORD
WINAPI
AzScopeCreate(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR ScopeName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ScopeHandle
    );

WINAZROLES
DWORD
WINAPI
AzScopeOpen(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR ScopeName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ScopeHandle
    );

WINAZROLES
DWORD
WINAPI
AzScopeEnum(
    IN AZ_HANDLE ApplicationHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE ScopeHandle
    );

WINAZROLES
DWORD
WINAPI
AzScopeDelete(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR ScopeName,
    IN DWORD Reserved
    );


//
// Group routines
//
WINAZROLES
DWORD
WINAPI
AzGroupCreate(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR GroupName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE GroupHandle
    );

WINAZROLES
DWORD
WINAPI
AzGroupOpen(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR GroupName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE GroupHandle
    );

WINAZROLES
DWORD
WINAPI
AzGroupEnum(
    IN AZ_HANDLE ParentHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE GroupHandle
    );

WINAZROLES
DWORD
WINAPI
AzGroupDelete(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR GroupName,
    IN DWORD Reserved
    );


//
// Role routines
//
WINAZROLES
DWORD
WINAPI
AzRoleCreate(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR RoleName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE RoleHandle
    );

WINAZROLES
DWORD
WINAPI
AzRoleOpen(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR RoleName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE RoleHandle
    );

WINAZROLES
DWORD
WINAPI
AzRoleEnum(
    IN AZ_HANDLE ParentHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE RoleHandle
    );

WINAZROLES
DWORD
WINAPI
AzRoleDelete(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR RoleName,
    IN DWORD Reserved
    );

//
// Routines common to all objects
//

WINAZROLES
DWORD
WINAPI
AzCloseHandle(
    IN AZ_HANDLE AzHandle,
    IN DWORD Reserved
    );

WINAZROLES
DWORD
WINAPI
AzSubmit(
    IN AZ_HANDLE AzHandle,
    IN DWORD Flags,
    IN DWORD Reserved
    );

WINAZROLES
VOID
WINAPI
AzFreeMemory(
    IN OUT PVOID Buffer
    );

//
// Client context routines
//

WINAZROLES
DWORD
WINAPI
AzInitializeContextFromToken(
    IN AZ_HANDLE ApplicationHandle,
    IN HANDLE TokenHandle OPTIONAL,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ClientContextHandle
    );

WINAZROLES
DWORD
WINAPI
AzInitializeContextFromName(
    IN AZ_HANDLE ApplicationHandle,
    IN LPWSTR DomainName OPTIONAL,
    IN LPWSTR ClientName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ClientContextHandle
    );

WINAZROLES
DWORD
WINAPI
AzInitializeContextFromStringSid(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR SidString,
    IN DWORD lOptions,
    OUT PAZ_HANDLE ClientContextHandle
    );

WINAZROLES
DWORD
WINAPI
AzContextAccessCheck(
    IN AZ_HANDLE ApplicationObjectHandle,
    IN DWORD ApplicationSequenceNumber,
    IN AZ_HANDLE ClientContextHandle,
    IN LPCWSTR ObjectName,
    IN ULONG ScopeCount,
    IN LPCWSTR * ScopeNames,
    IN ULONG OperationCount,
    IN PLONG Operations,
    OUT ULONG *Results,
    OUT LPWSTR *BusinessRuleString OPTIONAL,
    IN VARIANT *ParameterNames OPTIONAL,
    IN VARIANT *ParameterValues OPTIONAL,
    IN VARIANT *InterfaceNames OPTIONAL,
    IN VARIANT *InterfaceFlags OPTIONAL,
    IN VARIANT *Interfaces OPTIONAL
    );

WINAZROLES
DWORD
WINAPI
AzContextGetRoles(
    IN AZ_HANDLE ClientContextHandle,
    IN LPCWSTR ScopeName OPTIONAL,
    OUT LPWSTR **RoleNames,
    OUT DWORD *Count
    );


#ifdef __cplusplus
}
#endif
#endif // _AZROLESP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\context.cxx ===
/*++
Copyright (c) 2001  Microsoft Corporation

Module Name:

    context.cxx

Abstract:

    Routines implementing the client context API

Author:

    Cliff Van Dyke (cliffv) 22-May-2001

--*/

#include "pch.hxx"
#include <winber.h>
#include <ntseapi.h>
#include <kerberos.h>
#include <azroles.h>

//
// Structure definitions
//


//
// Structure representing an APP group that a client context may be a member of
//

typedef struct _AZP_MEMBER_EVALUATION {

    //
    // Link to next entry in the list of member evaluation structs for this
    //  client context.
    //

    LIST_ENTRY Next;

    //
    // Group being evaluated
    //

    PAZP_GROUP Group;

    //
    // Status of the evaluation
    //  NO_ERROR: Membership has been determined
    //  NOT_YET_DONE: Membership has not yet been determined
    //  ERROR_NO_SUCH_DOMAIN: We couldn't contact the domain controller
    //

    DWORD WinStatus;
#define NOT_YET_DONE 0xFFFFFFFF

    //
    // Indicates whether the client is a member of the specified group.
    //  This field is valid only if WinStatus is NO_ERROR.
    //

    BOOLEAN IsMember;

} AZP_MEMBER_EVALUATION, *PAZP_MEMBER_EVALUATION;



//
// Macros
//
// PopUlong: remove a ULONG from an array of ULONGs
//  Simply replace the element by the last element in the array and
//  make the array shorter
//

#define PopUlong( _Array, _Index, _Count ) { \
    (_Count)--; \
    (_Array)[_Index] = (_Array)[_Count]; \
}

extern BOOL AzIsDC;
extern PSID AzAccountDomainSid;
extern BOOL AzAccountDomainSidInitialized;



//
// Procedure forwards
//

DWORD
AzpCheckGroupMembershipOne(
    IN PAZP_CLIENT_CONTEXT ClientContext,
    IN PAZP_GROUP Group,
    IN BOOLEAN LocalOnly,
    IN DWORD RecursionLevel,
    OUT PBOOLEAN RetIsMember,
    OUT LPDWORD ExtendedStatus
    );

DWORD
AzpAccessCheckGenerateAudit(
    IN PACCESS_CHECK_CONTEXT AcContext
    )
/*++

Routine Description:

    This routine generates run-time access check audits. One success or failure
    audit is generated per operation.

Arguments:

    AcContext - Specifies the context of the user who will be audited.

Return Value:

    NO_ERROR - The operation was successful
    Other exception status codes

--*/
{

    BOOL b;
    ULONG i;
    DWORD WinStatus = NO_ERROR;
    PAUDIT_PARAMS pAuditParams = NULL;
    PAZP_AZSTORE AzAuthorizationStore;
    AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent = NULL;
    PAZP_APPLICATION Application = AcContext->Application;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditHandle = NULL;

    //
    // Get the authorization store pointer for the application
    //

    AzAuthorizationStore = (PAZP_AZSTORE) ParentOfChild(&AcContext->Application->GenericObject);

    //
    // If audit handle is null, then do not generate any audits
    //

    if ( (AzAuthorizationStore->hAccessCheckAuditEventType == NULL) &&
         (AzAuthorizationStore->hAccessCheckNameAuditEventType == NULL) ) {

        return NO_ERROR;
    }

    if (!AuthziAllocateAuditParams(
            &pAuditParams,
            AZP_ACCESSCHECK_AUDITPARAMS_NO+2
            )) {
    
                goto Cleanup;
    }

    //
    // Loop thru all the operations and generate one audit per operation
    //

    for ( i=0; i < AcContext->OperationCount; i++ ) {

        //
        // Decide on whether this is a success or a failure audit
        //

        DWORD Flags = (AcContext->Results[i] == NO_ERROR) ?
                          APF_AuditSuccess :
                          APF_AuditFailure;

        //
        // The structure of the audit is as follows
        //   %tApplication Name:%t%1%n
        //   %tApplication Instance ID
        //   %tObject Name:%t%3%n
        //   %tScope Names:%t%4%n
        //   %tClient Name:%t%5%n
        //   %tClient Domain:%t%6%n
        //   %tClient Context ID:%t%7%
        //   %tRole:%t%8%n
        //   %tGroups:%t%9%n
        //   %tOperation:%t%10%n
        //   %tOperation ID:%t%11%n
        //

        //
        // Fill in the audit parameters array
        //

        if ( AcContext->ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_TOKEN ) {

            hAuditHandle = AzAuthorizationStore->hAccessCheckAuditEventType;

            b = AuthziInitializeAuditParamsWithRM( Flags,
                                                   Application->AuthzResourceManager,
                                                   AZP_ACCESSCHECK_AUDITPARAMS_NO,
                                                   pAuditParams,
                                                   APT_String, Application->GenericObject.ObjectName->ObjectName.String,
                                                   APT_Luid, Application->InstanceId,
                                                   APT_String, AcContext->ObjectNameString.String,
                                                   APT_String, AcContext->ScopeNameString.String ? AcContext->ScopeNameString.String : L"-",
                                                   APT_LogonId, AcContext->ClientContext->LogonId,
                                                   APT_String, L"Role",
                                                   APT_String, L"Group",
                                                   APT_String, AcContext->OperationObjects[i]->GenericObject.ObjectName->ObjectName.String,
                                                   APT_Ulong, AcContext->OperationObjects[i]->OperationId );

        } else if ( AcContext->ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_NAME ||
                    AcContext->ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_SID ) {

            hAuditHandle = AzAuthorizationStore->hAccessCheckNameAuditEventType;

            //
            // both from name and from SID audit share the same audit layout
            //
            // We do not have the client Logon Id here since the context was created
            // from name or SID. So, we pass the Logon id that we allocated as a LUID and
            // the Domain Name, Client Name as separate strings. LSA can not lookup
            // the names from the LUID since no logon session exists.
            //

            b = AuthziInitializeAuditParamsWithRM( Flags,
                                                   Application->AuthzResourceManager,
                                                   AZP_ACCESSCHECK_AUDITPARAMS_NO+2,
                                                   pAuditParams,
                                                   APT_String, Application->GenericObject.ObjectName->ObjectName.String,
                                                   APT_Luid, Application->InstanceId,
                                                   APT_String, AcContext->ObjectNameString.String,
                                                   APT_String, AcContext->ScopeNameString.String ? AcContext->ScopeNameString.String : L"-",
                                                   APT_String, AcContext->ClientContext->ClientName,
                                                   APT_String, AcContext->ClientContext->DomainName ? AcContext->ClientContext->DomainName : L"",
                                                   APT_Luid, AcContext->ClientContext->LogonId,
                                                   APT_String, L"Role",
                                                   APT_String, L"Group",
                                                   APT_String, AcContext->OperationObjects[i]->GenericObject.ObjectName->ObjectName.String,
                                                   APT_Ulong, AcContext->OperationObjects[i]->OperationId );


        } else {
            ASSERT( FALSE );
            b = FALSE;
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        if (!b) {
            WinStatus = GetLastError();
            goto Cleanup;
        }

        //
        // Fill in the Audit event handle
        //

        b = AuthziInitializeAuditEvent( 0,
                                        NULL,
                                        hAuditHandle,
                                        pAuditParams,
                                        NULL,
                                        INFINITE,
                                        L"", L"", L"", L"",
                                        &hAuditEvent );

        if (!b) {
            WinStatus = GetLastError();
            goto Cleanup;
        }

        //
        // Send off the audit to LSA
        //

        b = AuthziLogAuditEvent( 0,
                                 hAuditEvent,
                                 NULL );

        if (!b) {
            WinStatus = GetLastError();
            goto Cleanup;
        }

        //
        // Free the audit event sructure and set it to NULL
        //

        AuthzFreeAuditEvent( hAuditEvent );
        hAuditEvent = NULL;
    }

Cleanup:

    //
    // Free the audit event handle
    //

    if ( hAuditEvent != NULL ) {
        AuthzFreeAuditEvent( hAuditEvent );
    }

    //
    // Free the PAUDIT_PARAMS structure
    //

    if ( pAuditParams ) {

        AuthziFreeAuditParams( pAuditParams );
    }        

    return WinStatus;
}

DWORD
AzpClientContextGenerateCreateSuccessAudit(
    IN PAZP_CLIENT_CONTEXT ClientContext,
    IN PAZP_APPLICATION Application
    )
/*++

Routine Description:

    This routine generates success audit for client context creation.

Arguments:

    ClientContext - Specifies the context of the user who will be audited.

    Application - Specifies the application in whose scope the client context
    has been created.

Return Value:

    NO_ERROR - The operation was successful
    Other exception status codes

--*/
{
    BOOL b;
    DWORD WinStatus = NO_ERROR;
    PAUDIT_PARAMS pAuditParams = NULL;
    PAZP_AZSTORE AzAuthorizationStore;
    AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent = NULL;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditHandle = NULL;

    //
    // Get the authorization store pointer
    //

    AzAuthorizationStore = (PAZP_AZSTORE) ParentOfChild(&Application->GenericObject);

    //
    // If audit handle is null, then do not generate any audits
    //

    if ( (AzAuthorizationStore->hClientContextCreateAuditEventType == NULL) &&
         (AzAuthorizationStore->hClientContextCreateNameAuditEventType == NULL) ) {

        return NO_ERROR;
    }

    if (!AuthziAllocateAuditParams(
            &pAuditParams,
            AZP_ACCESSCHECK_AUDITPARAMS_NO+2 
            )) {
    
                goto Cleanup;
    }

    //
    // The structure of the audit is as follows
    //   %tApplication Name:%t%1%n
    //   %tApplication Instance ID:%t%2%n
    //   %tClient Name:%t%3%n
    //   %tClient Domain:%t%4%n
    //   %tClient Context ID:%t%5%n
    //   %tStatus:%t%6%n
    //

    //
    // Fill in the audit parameters array
    //

    if ( ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_TOKEN ) {

        hAuditHandle = AzAuthorizationStore->hClientContextCreateAuditEventType;

        b = AuthziInitializeAuditParamsWithRM( APF_AuditSuccess,
                                               Application->AuthzResourceManager,
                                               AZP_CLIENTCREATE_AUDITPARAMS_NO,
                                               pAuditParams,
                                               APT_String, Application->GenericObject.ObjectName->ObjectName.String,
                                               APT_Luid, Application->InstanceId,
                                               APT_LogonId, ClientContext->LogonId,
                                               APT_Ulong, NO_ERROR );

    } else if ( ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_NAME ||
                ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_SID ) {

        hAuditHandle = AzAuthorizationStore->hClientContextCreateNameAuditEventType;

        //
        // both from name or from SID contexts share the same audit layout
        //
        // We do not have the client Logon Id here since the context was created
        // from name or SID. So, we pass the Logon id that we allocated as a LUID and
        // the Domain Name, Client Name as separate strings. LSA can not lookup
        // the names from the LUID since no logon session exists.
        //

        b = AuthziInitializeAuditParamsWithRM( APF_AuditSuccess,
                                               Application->AuthzResourceManager,
                                               AZP_CLIENTCREATE_AUDITPARAMS_NO+2,
                                               pAuditParams,
                                               APT_String, Application->GenericObject.ObjectName->ObjectName.String,
                                               APT_Luid, Application->InstanceId,
                                               APT_String, ClientContext->ClientName,
                                               APT_String, ClientContext->DomainName ? ClientContext->DomainName : L"",
                                               APT_Luid, ClientContext->LogonId,
                                               APT_Ulong, NO_ERROR );

    } else {
        ASSERT( FALSE );
        b = FALSE;
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (!b) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Fill in the Audit event handle
    //

    b = AuthziInitializeAuditEvent( 0,
                                    NULL,
                                    hAuditHandle,
                                    pAuditParams,
                                    NULL,
                                    INFINITE,
                                    L"", L"", L"", L"",
                                    &hAuditEvent );

    if (!b) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Send off the audit to LSA
    //

    b = AuthziLogAuditEvent( 0,
                             hAuditEvent,
                             NULL );

    if (!b) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

Cleanup:

    //
    // Free the audit event handle
    //

    if ( hAuditEvent != NULL ) {
        AuthzFreeAuditEvent( hAuditEvent );
    }

    //
    // Free the PAUDIT_PARAMS structure
    //

    if ( pAuditParams ) {

        AuthziFreeAuditParams( pAuditParams );
    }   

    return WinStatus;
}

DWORD
AzpClientContextGenerateDeleteAudit(
    IN PAZP_CLIENT_CONTEXT ClientContext,
    IN PAZP_APPLICATION Application
    )
/*++

Routine Description:

    This routine generates audit for client context deletion.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ClientContext - Specifies the context of the user who will be audited.

    Application - Specifies the application in whose scope the client context
    has been created.

Return Value:

    NO_ERROR - The operation was successful
    Other exception status codes

--*/
{
    DWORD WinStatus = NO_ERROR;
    BOOL b;
    AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent = NULL;
    PAUDIT_PARAMS pAuditParams = NULL;
    PAZP_AZSTORE AzAuthorizationStore;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditHandle = NULL;

    //
    // Get the authorization store pointer
    //

    AzAuthorizationStore = (PAZP_AZSTORE) ParentOfChild(&Application->GenericObject);

    //
    // If audit handles are null, then do not generate any audtis
    //

    if ( (AzAuthorizationStore->hClientContextDeleteAuditEventType == NULL) &&
         (AzAuthorizationStore->hClientContextDeleteNameAuditEventType == NULL) ) {

        return NO_ERROR;
    }

    if (!AuthziAllocateAuditParams(
            &pAuditParams,
            AZP_ACCESSCHECK_AUDITPARAMS_NO+2
            )) {
    
                goto Cleanup;
    }
            
    //
    // The structure of the audit is as follows
    //   %tApplication Name:%t%1%n
    //   %tApplication Instance ID:%t%2%n
    //   %tClient Name:%t%3%n
    //   %tClient Domain:%t%4%n
    //   %tClient Context ID:%t%5%n
    //

    //
    // Fill in the audit parameters array
    //

    if ( ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_TOKEN ) {

        hAuditHandle = AzAuthorizationStore->hClientContextDeleteAuditEventType;

        b = AuthziInitializeAuditParamsWithRM( APF_AuditSuccess,
                                               Application->AuthzResourceManager,
                                               AZP_CLIENTDELETE_AUDITPARAMS_NO,
                                               pAuditParams,
                                               APT_String, Application->GenericObject.ObjectName->ObjectName.String,
                                               APT_Luid, Application->InstanceId,
                                               APT_LogonId, ClientContext->LogonId );

    } else if ( ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_NAME ||
                ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_SID ) {

        hAuditHandle = AzAuthorizationStore->hClientContextDeleteNameAuditEventType;

        //
        // both from name or from SID contexts share the same audit layout
        //
        // We do not have the client Logon Id here since the context was created
        // from name or SID. So, we pass the Logon id that we allocated as a LUID and
        // the Domain Name, Client Name as separate strings. LSA can not lookup
        // the names from the LUID since no logon session exists.
        //

        b = AuthziInitializeAuditParamsWithRM( APF_AuditSuccess,
                                               Application->AuthzResourceManager,
                                               AZP_CLIENTDELETE_AUDITPARAMS_NO+2,
                                               pAuditParams,
                                               APT_String, Application->GenericObject.ObjectName->ObjectName.String,
                                               APT_Luid, Application->InstanceId,
                                               APT_String, ClientContext->ClientName,
                                               APT_String, ClientContext->DomainName ? ClientContext->DomainName : L"",
                                               APT_Luid, ClientContext->LogonId);

    } else {
        ASSERT( FALSE );
        b = FALSE;
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (!b) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Fill in the Audit event handle
    //

    b = AuthziInitializeAuditEvent( 0,
                                    NULL,
                                    hAuditHandle,
                                    pAuditParams,
                                    NULL,
                                    INFINITE,
                                    L"", L"", L"", L"",
                                    &hAuditEvent );

    if (!b) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Send off the audit to LSA
    //

    b = AuthziLogAuditEvent( 0,
                             hAuditEvent,
                             NULL );

    if (!b) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

Cleanup:

    //
    // Free the audit event handle
    //

    if ( hAuditEvent != NULL ) {
        AuthzFreeAuditEvent( hAuditEvent );
    }

    //
    // Free the PAUDIT_PARAMS structure
    //

    if ( pAuditParams ) {

        AuthziFreeAuditParams( pAuditParams );
    } 

    return WinStatus;
}

VOID
AzpFlushGroupEval(
    IN PAZP_CLIENT_CONTEXT ClientContext
    )
/*++

Routine Description:

    This routine flushes the group evaluation for the specified client context

    On entry, AzGlResource must be locked shared

Arguments:

    ClientContext - Specifies the client context for which all group evaluation is
        to be flushed.

Return Value:

    None.

--*/
{

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    //
    // Free the cache of group membership evaluations
    //

    while ( !IsListEmpty( &ClientContext->MemEval ) ) {
        PAZP_MEMBER_EVALUATION MemEval;
        PLIST_ENTRY ListEntry;

        //
        // Remove the entry from the list
        //

        ListEntry = RemoveHeadList( &ClientContext->MemEval );

        MemEval = CONTAINING_RECORD( ListEntry,
                                     AZP_MEMBER_EVALUATION,
                                     Next );

        AzpFreeHeap( MemEval );

    }
}


DWORD
AzpClientContextInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzInitializeClientContextFrom*.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    NTSTATUS Status;
    PAZP_CLIENT_CONTEXT ClientContext = (PAZP_CLIENT_CONTEXT) ChildGenericObject;
    UNREFERENCED_PARAMETER( ParentGenericObject );

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Initialize the client context critical section
    //

    Status = SafeInitializeCriticalSection( &ClientContext->CritSect, SAFE_CLIENT_CONTEXT );

    if ( !NT_SUCCESS( Status )) {
        return RtlNtStatusToDosError( Status );
    }

    ClientContext->CritSectInitialized = TRUE;


    //
    // ClientContexts are referenced by "Applications"
    //  Let the generic object manager know all of the lists we support
    //  This is a "back" link so we don't need to define which applications can reference this client context.
    //

    ChildGenericObject->GenericObjectLists = &ClientContext->backApplications;

    // Back link to applications
    ObInitObjectList( &ClientContext->backApplications,
                      NULL,
                      TRUE, // Backward link
                      0,    // No link pair id
                      0,    // No dirty bit on back link
                      NULL,
                      NULL,
                      NULL );

    //
    // Maintain a handle to the user's token / identity.
    //

    ClientContext->TokenHandle = INVALID_HANDLE_VALUE;
    ClientContext->ClientName = NULL;
    ClientContext->DomainName = NULL;

    AzpInitString(&ClientContext->RoleName, NULL);

    //
    // Initialize the cache of group membership evaluations
    //

    InitializeListHead( &ClientContext->MemEval );

    //
    // Store the serial number of that cache
    //

    ClientContext->GroupEvalSerialNumber =
        ClientContext->GenericObject.AzStoreObject->GroupEvalSerialNumber;

    //
    // Initialize the operation cache
    //

    AzpInitOperationCache( ClientContext );


    return NO_ERROR;
}


VOID
AzpClientContextFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for ClientContext object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    PAZP_CLIENT_CONTEXT ClientContext = (PAZP_CLIENT_CONTEXT) GenericObject;
    PAZP_APPLICATION Application = (PAZP_APPLICATION) ParentOfChild( &ClientContext->GenericObject );
    PAZP_AZSTORE AzAuthorizationStore = (PAZP_AZSTORE) ParentOfChild( &Application->GenericObject );

    DWORD WinStatus;


    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Generate a Client context deletion audit if needed.
    //

    if ( Application->GenericObject.IsGeneratingAudits &&
         !AzpOpenToManageStore(AzAuthorizationStore) ) {
        WinStatus = AzpClientContextGenerateDeleteAudit( ClientContext,
                                                         Application );
        if ( WinStatus != NO_ERROR ) {
            AzPrint(( AZD_ACCESS_MORE, "AzpClientContextFree:  AzpClientContextGenerateDeleteAudit failed with %ld\n", WinStatus ));
        }
    }

    //
    // Free any local strings
    //

    if ( ClientContext->AccountDn != NULL ) {
        AzpFreeHeap( ClientContext->AccountDn );
    }

    //
    // Free the reference to the account domain
    //
    if ( ClientContext->Domain != NULL ) {
        AzpDereferenceDomain( ClientContext->Domain );
    }


    //
    // Free any authz context
    //

    if ( ClientContext->AuthzClientContext != NULL ) {
        if ( !AuthzFreeContext( ClientContext->AuthzClientContext ) ) {
            ASSERT( FALSE );
        }
    }


    //
    // Close the user's token
    //

    if ( ClientContext->TokenHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( ClientContext->TokenHandle );
        ClientContext->TokenHandle = INVALID_HANDLE_VALUE;
        ASSERT( ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_TOKEN );
    }

    //
    // Free the client name and the domain name.
    //

    if ( ClientContext->DomainName != NULL ) {
        AzpFreeHeap(  ClientContext->DomainName );
        ClientContext->DomainName = NULL;
        ASSERT( ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_NAME );
    }

    if ( ClientContext->ClientName != NULL ) {
        AzpFreeHeap(  ClientContext->ClientName );
        ClientContext->ClientName = NULL;
        ASSERT( ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_NAME ||
                ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_SID );
    }

    //
    // free the role name if it's specified in the context
    //
    AzpFreeString( &ClientContext->RoleName );

    //
    // Free the cache of group membership evaluations
    //

    AzpFlushGroupEval( ClientContext );

    //
    // Free the cache of previously evaluated operations
    //

    AzpFlushOperationCache( ClientContext );

    //
    // Delete the client context critical section
    //

    if ( ClientContext->CritSectInitialized ) {
        SafeDeleteCriticalSection( &ClientContext->CritSect );
        ClientContext->CritSectInitialized = FALSE;
    }

}

DWORD
AzpGetUserNameEx(
    IN PAZP_CLIENT_CONTEXT ClientContext,
    IN EXTENDED_NAME_FORMAT NameFormat,
    IN LPWSTR *NameBuffer,
    OUT BOOLEAN *pbIsDomainDnsName
    )
/*++

Routine Description:

    This routine is a wrapper around GetUserNameEx.

    It impersonates the token implied by ClientContext,
    It handles allocating the buffer so the caller doesn't have to guess.

    On entry, ClientContext->ReferenceCount must be incremented.

Arguments:

    ClientContext - Specifies the context of the user to check group membership of.

    NameFormat - Any name format that is valid for GetUserNameEx

    NameBuffer - On success, returns a buffer in the same format as GetUserNameEx
        The returned buffer should be freed using AzpFreeHeap,

    pbIsDomainDnsName - set to TRUE if the returned Domain names is in DNS format

Return Value:

    Same as GetUserNameEx.

--*/
{
    DWORD WinStatus;

    LPWSTR Buffer = NULL;
    ULONG BufferSize;
    HANDLE CurrentToken = NULL;
    BOOL Impersonating = FALSE;

    TOKEN_STATISTICS TokenStats = {0};

    PTOKEN_USER pUserToken = NULL;
    DWORD RetSize = 0;
    LPWSTR ClientName = NULL;

    //
    // Initialization
    //

    ASSERT( ClientContext->GenericObject.ReferenceCount != 0 );

    //
    // Make sure that we have a valid token.
    //

    if ( ClientContext->TokenHandle == INVALID_HANDLE_VALUE ) {
        AzPrint(( AZD_INVPARM, "AzpGetUserNameEx: no cached token handle\n" ));
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Get the token stats to retreive the impersonation level
    //

    if ( !GetTokenInformation( ClientContext->TokenHandle,
                               TokenStatistics,
                               &TokenStats,
                               sizeof(TOKEN_STATISTICS),
                               &RetSize ) ) {

        WinStatus = GetLastError();
        AzPrint(( AZD_CRITICAL,
                  "AzpGetUserNameEx: Cannot get token statistics: %ld\n",
                  WinStatus
                  ));

        goto Cleanup;
    }

    //
    // Check to see if we're already impersonating
    //

    if ( !OpenThreadToken( 
              GetCurrentThread(),
              TOKEN_IMPERSONATE,
              TRUE,       // as self to ensure we never fail
              &CurrentToken
              ) ) {
        
        WinStatus = GetLastError();
        
        if ( WinStatus != ERROR_NO_TOKEN ) {
            AzPrint(( AZD_CRITICAL, "AzpGetUserNameEx: Cannot GetThreadToken %ld\n", WinStatus ));
            goto Cleanup;
        }
        
        CurrentToken = NULL;
        
    }

    //
    // Impersonate the user's token
    //

    if ( !SetThreadToken( NULL, ClientContext->TokenHandle ) ) {

        WinStatus = GetLastError();

        AzPrint(( AZD_CRITICAL, "AzpGetUserNameEx: Cannot SetThreadToken %ld\n", WinStatus ));
        goto Cleanup;
    }

    Impersonating = TRUE;

    //
    // Determine the size of the buffer
    //

    BufferSize = 0;

    if ( GetUserNameExW( NameFormat, NULL, &BufferSize ) ) {

        WinStatus = ERROR_INTERNAL_ERROR;
        goto Cleanup;

    }

    WinStatus = GetLastError();

    if ( WinStatus != ERROR_MORE_DATA ) {
        AzPrint(( AZD_CRITICAL, "AzpGetUserNameEx: Cannot GetUserNameExW %ld\n", WinStatus ));
        goto Cleanup;
    }

    //
    // Allocate a buffer
    //

    Buffer = (LPWSTR) AzpAllocateHeap( BufferSize * sizeof(WCHAR), "CNGUSER" );

    if ( Buffer == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Determine the DNS domain name
    //

    if ( !GetUserNameExW( NameFormat, Buffer, &BufferSize ) ) {
        WinStatus = GetLastError();
        AzPrint(( AZD_CRITICAL, "AzpGetUserNameEx: Cannot GetUserNameExW %ld\n", WinStatus ));
        goto Cleanup;
    }

    *pbIsDomainDnsName = TRUE;

    WinStatus = NO_ERROR;

    //
    // Free any local resources
    //
Cleanup:

    if ( Impersonating ) {
        //
        // Revert to self
        //

        if ( !SetThreadToken( NULL, CurrentToken ) ) {

            DWORD TempStatus = GetLastError();
            AzPrint(( AZD_CRITICAL, "AzpGetUserNameEx: Cannot SetThreadToken (revert) %ld\n", TempStatus ));

            if ( WinStatus == NO_ERROR ) {

                WinStatus = TempStatus;
            }
        }
    }

    if ( WinStatus == NO_ERROR ) {

        //
        // Return the buffer to the caller
        //

        *NameBuffer = Buffer;
        Buffer = NULL;

    }

    if ( Buffer != NULL ) {
        AzpFreeHeap( Buffer );
    }

    if ( pUserToken != NULL ) {

        AzpFreeHeap( pUserToken );
    }

    if ( ClientName != NULL ) {

        AzpFreeHeap( ClientName );
    }

    //
    // Close the handle to the current token to prevent any leaks
    //

    if ( CurrentToken != NULL ) {

        CloseHandle( CurrentToken );
    }

    return WinStatus;
}


DWORD
AzpClientContextGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    This routine is the ClientContext specific worker routine for AzGetProperty.
    It does any object specific property gets.  If the client context has
    AZP_CONTEXT_CREATED_FROM_SID flag set, then only
    RoleForAccessCheck property will be returned.  All the rest will be returned
    for AZP_CONTEXT_CREATED_FROM_TOKEN and AZP_CONTEXT_CREATED_FROM_NAME.

    On entry, AzGlResource must be locked shared.

Arguments:

    GenericObject - Specifies a pointer to the object to be queried

    Flags - Specifies internal flags
        AZP_FLAGS_BY_GUID - name lists should be returned as GUID lists
        AZP_FLAGS_PERSIST_* - Call is from the persistence provider

    PropertyId - Specifies which property to return.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_CLIENT_CONTEXT_USER_DN              LPWSTR - DN of the user
        AZ_PROP_CLIENT_CONTEXT_USER_SAM_COMPAT      LPWSTR - Sam compatible name of the user
        AZ_PROP_CLIENT_CONTEXT_USER_DISPLAY         LPWSTR - Display name of the user
        AZ_PROP_CLIENT_CONTEXT_USER_GUID            LPWSTR - GUID of the user
        AZ_PROP_CLIENT_CONTEXT_USER_CANONICAL       LPWSTR - Canonical name of the user
        AZ_PROP_CLIENT_CONTEXT_USER_UPN             LPWSTR - UPN of the user
        AZ_PROP_CLIENT_CONTEXT_USER_DNS_SAM_COMPAT  LPWSTR - DNS same compat name of the user
        AZ_PROP_CLIENT_CONTEXT_ROLE_FOR_ACCESS_CHECK LPWSTR - role name (may be NULL) for the access check

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_CLIENT_CONTEXT ClientContext = (PAZP_CLIENT_CONTEXT) GenericObject;
    EXTENDED_NAME_FORMAT NameFormat;

    LPWSTR PropertyString = NULL;
    AZP_STRING PropertyAzpString;

    BOOLEAN Ignore = FALSE;
    DWORD RetSize = 0;
    DWORD UserNameSize = 0;

    TOKEN_STATISTICS TokenStats = {0};

    PWSTR UserName = NULL;

    UNREFERENCED_PARAMETER(Flags); //ignore


    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    //
    // Return any object specific attribute
    //
    switch ( PropertyId ) {
    case AZ_PROP_CLIENT_CONTEXT_USER_DN:
        NameFormat = NameFullyQualifiedDN; break;

    case AZ_PROP_CLIENT_CONTEXT_USER_SAM_COMPAT:
        NameFormat = NameSamCompatible; break;

    case AZ_PROP_CLIENT_CONTEXT_USER_DISPLAY:
        NameFormat = NameDisplay; break;

    case AZ_PROP_CLIENT_CONTEXT_USER_GUID:
        NameFormat = NameUniqueId; break;

    case AZ_PROP_CLIENT_CONTEXT_USER_CANONICAL:
        NameFormat = NameCanonical; break;

    case AZ_PROP_CLIENT_CONTEXT_USER_UPN:
        NameFormat = NameUserPrincipal; break;

    case AZ_PROP_CLIENT_CONTEXT_USER_DNS_SAM_COMPAT:
        NameFormat = NameDnsDomain; break;

    case AZ_PROP_CLIENT_CONTEXT_ROLE_FOR_ACCESS_CHECK:

        //
        // this is a property that stored in the client context structure
        // do not need to go through getusernameex
        //

        *PropertyValue = AzpGetStringProperty( &ClientContext->RoleName );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        return WinStatus;

    default:
        AzPrint(( AZD_CRITICAL, "AzpClientContextGetProperty: invalid opcode %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // If the client context has been created from token, then use GetUserNameEx
    // to retrieve the different name properties.
    // If the client was created from Name, then we need to use TranslateName API
    // to retrieve the various name information properties (since no token is available).
    // However, TranslateName does not support NameDnsDomain format, and will return a
    // ERROR_NO_SUCH_USER - this needs to be returned to the caller as ERROR_NOT_SUPPORTED.
    // If the client was created from a StringSID with AZ_CLIENT_CONTEXT_SKIP_GROUP flag set,
    // then we return ERROR_NOT_SUPPORTED
    //

    if ( ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_SID ) {

        WinStatus = ERROR_NOT_SUPPORTED;
        goto Cleanup;

    } else if ( ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_TOKEN ) {

        //
        // Get the token stats to retreive the impersonation level
        //

        if ( !GetTokenInformation( ClientContext->TokenHandle,
                                   TokenStatistics,
                                   &TokenStats,
                                   sizeof(TOKEN_STATISTICS),
                                   &RetSize ) ) {

            WinStatus = GetLastError();
            AzPrint(( AZD_CRITICAL,
                  "AzpClientContextGetProperty: Cannot get token statistics: %ld\n",
                      WinStatus
                      ));

            goto Cleanup;
        }

        //
        // Get the attribute from the LSA
        //

        WinStatus = AzpGetUserNameEx( ClientContext,
                                      NameFormat,
                                      &PropertyString,
                                      &Ignore );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

    } else if ( ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_NAME ) {

        //
        // Get the size required for the return string value
        //

        UserNameSize = (DWORD) (wcslen(ClientContext->ClientName)+wcslen(ClientContext->DomainName)+2)*
                                            sizeof(WCHAR);

        UserName = (PWSTR) AzpAllocateHeap( UserNameSize, "USRNAME" );

        if ( UserName == NULL ) {

            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        wnsprintf( UserName, UserNameSize, L"%ws\\%ws", ClientContext->DomainName, ClientContext->ClientName );

        TranslateName( UserName,
                       NameSamCompatible,
                       NameFormat,
                       NULL, // get size for return buffer
                       &RetSize
                       );

        if ( (GetLastError() == ERROR_NO_SUCH_USER) &&
             (PropertyId == AZ_PROP_CLIENT_CONTEXT_USER_DNS_SAM_COMPAT) ) {

            WinStatus = ERROR_NOT_SUPPORTED;
            goto Cleanup;
        }

        //
        // Now that we have the size of the buffer we want, allocate
        // and call TranslateName.  The buffer will have the name in
        // required format
        //

        PropertyString = (LPWSTR) AzpAllocateHeap( RetSize*sizeof(WCHAR), "CLNTNAM" );

        if ( PropertyString == NULL ) {

            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        if ( !TranslateName( UserName,
                             NameSamCompatible,
                             NameFormat,
                             PropertyString,
                             &RetSize
                             ) ) {

            WinStatus = GetLastError();
            AzPrint(( AZD_CRITICAL,
                     "AzpClientContextGetProperty: Cannot translate name: %ld\n",
                     WinStatus
                     ));
            goto Cleanup;
        }
    }

    //
    // Copy the string back to the caller
    //


    AzpInitString( &PropertyAzpString, PropertyString );


    *PropertyValue = AzpGetStringProperty( &PropertyAzpString );

    if ( *PropertyValue == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    WinStatus = NO_ERROR;

    //
    // Free any local resources
    //
Cleanup:

    if ( PropertyString != NULL ) {
        AzpFreeHeap( PropertyString );
    }

    if ( UserName != NULL ) {

        AzpFreeHeap( UserName );
    }

    return WinStatus;
}

DWORD
AzpClientContextSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    This routine is the ClientContext object specific worker routine for AzSetProperty.
    It does any object specific property sets.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies a pointer to the object to be modified

    Flags - Specifies flags controlling to operation of the routine
        AZP_FLAGS_SETTING_TO_DEFAULT - Property is being set to default value
        AZP_FLAGS_PERSIST_* - Call is from the persistence provider

    PropertyId - Specifies which property to set.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_CLIENT_CONTEXT_ROLE_FOR_ACCESS_CHECK         LPWSTR  - role specified for this access check

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_CLIENT_CONTEXT ClientContext = (PAZP_CLIENT_CONTEXT) GenericObject;

    //
    // Initialization
    //

    UNREFERENCED_PARAMETER( Flags );
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Set any object specific attribute
    //
    //  Set role name
    //

    switch ( PropertyId ) {
    case AZ_PROP_CLIENT_CONTEXT_ROLE_FOR_ACCESS_CHECK:

        //
        // role name set to the client context is not persisted (via submit)
        // so there is no need to define a dirty bit for this property.
        //
        // It's only temporarialy set in the client context structure,
        // which will be used by AccessCheck only
        //

        AZP_STRING TempString;
        WinStatus = AzpCaptureString(&TempString,
                                     (LPCWSTR)PropertyValue,
                                     AZ_MAX_ROLE_NAME_LENGTH,
                                     TRUE
                                    );
        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        //
        // swap the new role name with existing role name and free the existing one
        //

        AzpSwapStrings(&ClientContext->RoleName,&TempString);

        //
        // free the existing role name specifed in the context, if any
        //
        AzpFreeString(&TempString);


        break;

    default:
        AzPrint(( AZD_INVPARM, "AzpClientContextSetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        break;
    }

Cleanup:
    return WinStatus;
}



DWORD
AzpCheckSidMembership(
    IN PAZP_CLIENT_CONTEXT ClientContext,
    IN PGENERIC_OBJECT_LIST SidList,
    OUT PBOOLEAN IsMember
    )
/*++

Routine Description:

    This routine checks to see if client context contains any of the Sids in SidList.

    Do this be creating a security descriptor with all of the sids in a DACL and doing
    and access check.

    ??? Consider caching the SecurityDescriptors

    On entry, AzGlResource must be locked Shared.

Arguments:

    ClientContext - Specifies the context of the user to check group membership of.

    SidList - Specifies the list of sids to check membership for

    IsMember - Returns TRUE if the user has one or more of the listed sids in his token.
        Returns FALSE if the user has none of the listed sids in his token.

Return Value:

    NO_ERROR - The function was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory

    Any failure returned here should be returned to the caller.

--*/
{
    DWORD WinStatus;
#define CHECK_SID_ACCESS_MASK 1
    ULONG FirstSid;
    ULONG LastSid;
    BOOLEAN UseBiggest = FALSE;

    ULONG i;
    PSID Sid = NULL;
    DWORD AclSize;
    PACL Acl = NULL;

    AUTHZ_ACCESS_REQUEST AccessRequest = { CHECK_SID_ACCESS_MASK };
    AUTHZ_ACCESS_REPLY AccessReply;
    DWORD GrantedAccess;
    DWORD AuthStatus;

    SECURITY_DESCRIPTOR SecurityDescriptor;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );
    ASSERT( ClientContext->GenericObject.ReferenceCount != 0 );
    *IsMember = FALSE;

    //
    // If there isn't at least one sid,
    //  then we're not a member.
    //

    if ( SidList->GenericObjects.UsedCount == 0 ) {
        WinStatus = NO_ERROR;
        goto Cleanup;
    }

    //
    // Loop doing at most 64KB at a time since that's the ACL limit
    //

#define BIGGEST_ACL 0xFFFF
    for ( FirstSid=0; FirstSid<SidList->GenericObjects.UsedCount; FirstSid=LastSid ) {

        //
        // Loop through the list of sids computing the ACL size
        //

        AclSize = sizeof(ACL);
        LastSid = SidList->GenericObjects.UsedCount;
        for ( i=FirstSid; i<LastSid; i++ ) {
            DWORD AceSize;

            ASSERT(((PGENERIC_OBJECT)(SidList->GenericObjects.Array[i]))->ObjectType == OBJECT_TYPE_SID );
            Sid =  (PSID)((PAZP_SID)(SidList->GenericObjects.Array[i]))->GenericObject.ObjectName->ObjectName.String;

            AceSize = ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
                       RtlLengthSid( Sid );

            if ( AclSize + AceSize >= BIGGEST_ACL) {
                LastSid = i;
                UseBiggest = TRUE;
                break;
            }

            AclSize += AceSize;

        }

        AzPrint(( AZD_ACCESS_MORE,
                  "AzpCheckSidMembership: Process sids %ld to %ld with %ld byte ACL\n",
                  FirstSid,
                  LastSid,
                  AclSize ));

        //
        // Allocate memory for Acl
        //

        if ( Acl == NULL ) {
            SafeAllocaAllocate( Acl, UseBiggest ? BIGGEST_ACL : AclSize );

            if ( Acl == NULL ) {
                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
        }

        //
        // Initialize the buffer
        //
        if (!InitializeAcl( Acl, AclSize, ACL_REVISION)) {
            WinStatus = GetLastError();
            goto Cleanup;
        }

        //
        // Loop through the list of sids adding them to the ACL
        //

        for ( i=FirstSid; i<LastSid; i++ ) {

            Sid =  (PSID)((PAZP_SID)(SidList->GenericObjects.Array[i]))->GenericObject.ObjectName->ObjectName.String;

            if ( !AddAccessAllowedAce(
                        Acl,
                        ACL_REVISION,
                        CHECK_SID_ACCESS_MASK,
                        Sid ) ) {
                WinStatus = GetLastError();
                goto Cleanup;
            }

        }

        //
        // Initialize the security descriptor
        //

        if ( !InitializeSecurityDescriptor(
                        &SecurityDescriptor,
                        SECURITY_DESCRIPTOR_REVISION ) ) {

            WinStatus = GetLastError();
            goto Cleanup;
        }

        if ( !SetSecurityDescriptorDacl(
                        &SecurityDescriptor,
                        TRUE,
                        Acl,
                        FALSE ) ) {

            WinStatus = GetLastError();
            goto Cleanup;
        }

        //
        // Use an arbitrary SID as the "owner".
        //
        //  AuthzAccessCheck uses it to replace "CreatorOwner" and to determine
        //  ReadControl/WriteDac.  None of those apply to us.  But we need to placate
        //  AuthzAccessCheck.
        //

        if ( !SetSecurityDescriptorOwner(
                        &SecurityDescriptor,
                        Sid,
                        FALSE ) ) {

            WinStatus = GetLastError();
            goto Cleanup;
        }


        //
        // Check if the client has any of the sids in his context
        //

        AccessReply.ResultListLength = 1;
        AccessReply.GrantedAccessMask = &GrantedAccess;
        AccessReply.Error = &AuthStatus;

        if ( !AuthzAccessCheck(
                        0,      // No Flags
                        ClientContext->AuthzClientContext,
                        &AccessRequest,
                        NULL,   // No auditing
                        &SecurityDescriptor,
                        NULL,   // No extra security descriptors
                        0,      // No extra security descriptors
                        &AccessReply,
                        NULL ) ) {  // No Cached results

            WinStatus = GetLastError();
            goto Cleanup;

        }

        if ( GrantedAccess & CHECK_SID_ACCESS_MASK ) {
            *IsMember = TRUE;
            break;
        }
    }

    WinStatus = NO_ERROR;

    //
    // Free any local resources
    //
Cleanup:
    if ( Acl != NULL ) {
        SafeAllocaFree( Acl );
    }

    return WinStatus;
}

DWORD
AzpCheckGroupMembership(
    IN PAZP_CLIENT_CONTEXT ClientContext,
    IN PGENERIC_OBJECT_LIST GroupList,
    IN BOOLEAN LocalOnly,
    IN DWORD RecursionLevel,
    OUT PBOOLEAN RetIsMember,
    OUT LPDWORD RetExtendedStatus
    )
/*++

Routine Description:

    This routine checks to see if the user specified by ClientContext is a member of
    any of the groups specified by GroupList.

    On entry, AzGlResource must be locked Shared.

    *** Note: this routine will temporarily drop AzGlResource in cases where it hits the wire

Arguments:

    ClientContext - Specifies the context of the user to check group membership of.

    GroupList - Specifies the list of groups to check group membership of

    LocalOnly - Specifies that the caller doesn't want to go off machine to determine
        the membership.

    RecursionLevel - Indicates the level of recursion.
        Used to prevent infinite recursion.

    RetIsMember - Returns whether the caller is a member of the specified group.

    RetExtendedStatus - Returns extended status information about the operation.
        NO_ERROR is returned if the group membership was determined.
            The Caller may use the value returned in IsMember.

        If LocalOnly is TRUE, NOT_YET_DONE means that the caller must call again with
            with LocalOnly set to false to get the group membership.

        If LocalOnly is FALSE, an error value indicates that the LDAP server returned
            an error while evaluating the request.  The caller may return this error
            to the original API caller if this group membership is required to determine
            whether the access check worked or not.

Return Value:

    NO_ERROR - The function was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory

    Any failure returned here should be returned to the caller.

--*/
{
    DWORD WinStatus;

    ULONG i;
    DWORD SavedExtendedStatus = NO_ERROR;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    if ( RecursionLevel > 100 ) {
        return ERROR_DS_LOOP_DETECT;
    }

    //
    // Loop through the list of groups evaluating each
    //

    for ( i=0; i<GroupList->GenericObjects.UsedCount; i++ ) {

        PAZP_GROUP Group;
        BOOLEAN IsMember;
        DWORD ExtendedStatus;


        //
        // Check the membership of one group
        //

        ASSERT(((PGENERIC_OBJECT)(GroupList->GenericObjects.Array[i]))->ObjectType == OBJECT_TYPE_GROUP );
        Group = (PAZP_GROUP) GroupList->GenericObjects.Array[i];

        WinStatus = AzpCheckGroupMembershipOne(
                            ClientContext,
                            Group,
                            LocalOnly,
                            RecursionLevel,
                            &IsMember,
                            &ExtendedStatus );

        if ( WinStatus != NO_ERROR ) {
            return WinStatus;
        }

        //
        // If we're definitively a member,
        //  tell our caller.
        //

        if ( ExtendedStatus == NO_ERROR ) {

            if ( IsMember ) {
                *RetIsMember = TRUE;
                *RetExtendedStatus = NO_ERROR;
                return NO_ERROR;

            }

        //
        // If we don't have a definitive answer,
        //  remember the answer hoping that we can get a definitive answer.
        //

        } else {

            SavedExtendedStatus = ExtendedStatus;
        }


    }

    //
    // ASSERT: we couldn't prove we're a member
    //  Return any defered status we may have
    //

    *RetExtendedStatus = SavedExtendedStatus;
    *RetIsMember = FALSE;
    return NO_ERROR;

}

DWORD
AzpComputeAccountDn(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE AuthzClientContext,
    OUT LPWSTR *RetAccountDn
    )
/*++

Routine Description:

    This routine computes the DN of the account to query.

Arguments:

    AuthzClientContext - Client context for the account

    RetAccountDn - Returns a pointer to the string containing the DN for the account
        The caller must free this string using AzpFreeHeap.

Return Value:

    NO_ERROR - The function was successful.

    ERROR_NOT_ENOUGH_MEMORY - not enough memory

    Any failure returned here should be returned to the caller.

--*/
{
    DWORD WinStatus;

    ULONG BufferSize;
    PTOKEN_USER UserSid = NULL;
    ULONG UserSidSize;
    LPWSTR AccountDn = NULL;

    ULONG i;
    LPBYTE InBuffer;
    WCHAR *OutBuffer;


    //
    // Determine the length of the sid
    //

    if ( AuthzGetInformationFromContext( AuthzClientContext,
                                         AuthzContextInfoUserSid,
                                         0,
                                         &BufferSize,
                                         NULL ) ) {

        WinStatus = ERROR_INTERNAL_ERROR;
        AzPrint(( AZD_CRITICAL,
                  "AzpComputeAccountDn: AuthzGetInformationFromContext failed %ld\n",
                  WinStatus ));
        goto Cleanup;
    }

    WinStatus = GetLastError();

    if ( WinStatus != ERROR_INSUFFICIENT_BUFFER ) {
        AzPrint(( AZD_CRITICAL,
                  "AzpComputeAccountDn: AuthzGetInformationFromContext failed %ld\n",
                  WinStatus ));
        goto Cleanup;
    }

    //
    // Allocate a buffer for the SID
    //

    SafeAllocaAllocate( UserSid, BufferSize );

    if ( UserSid == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        AzPrint(( AZD_CRITICAL,
                  "AzpComputeAccountDn: SafeAllocaAllocate failed %ld\n",
                  WinStatus ));
        goto Cleanup;
    }

    //
    // Read the user sid into the buffer.
    //

    if ( !AuthzGetInformationFromContext( AuthzClientContext,
                                          AuthzContextInfoUserSid,
                                          BufferSize,
                                          &BufferSize,
                                          UserSid ) ) {

        WinStatus = GetLastError();
        AzPrint(( AZD_CRITICAL,
                  "AzpComputeAccountDn: AuthzGetInformationFromContext failed %ld\n",
                  WinStatus ));
        goto Cleanup;
    }

    //
    // Convert the Sid to a DN
    //
    // Allocate a buffer for the DN
    //
#define DN_PREFIX L"<Sid="
#define DN_PREFIX_LENGTH ((sizeof(DN_PREFIX)/sizeof(WCHAR))-1)
#define DN_SUFFIX L">"
#define DN_SUFFIX_LENGTH ((sizeof(DN_SUFFIX)/sizeof(WCHAR))-1)

    UserSidSize = RtlLengthSid( UserSid->User.Sid );

    AccountDn = (LPWSTR) AzpAllocateHeap(
                                 (DN_PREFIX_LENGTH +
                                  UserSidSize * 2 +
                                  DN_SUFFIX_LENGTH +
                                  1) * sizeof(WCHAR), "CNACCDN" );

    if ( AccountDn == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        AzPrint(( AZD_CRITICAL,
                  "AzpComputeAccountDn: AzpAllocateHeap failed %ld\n",
                  WinStatus ));
        goto Cleanup;
    }

    //
    // Build the DN.
    //  The form is <SID=0104000000000005150000005951B81766725D2564633B0B>
    //  Where each byte of the SID has been turned into two ASCII hex digits.
    //  This format will work on both win2k and whistler.
    //

    RtlCopyMemory( AccountDn, DN_PREFIX, DN_PREFIX_LENGTH*sizeof(WCHAR) );

    InBuffer = (LPBYTE) UserSid->User.Sid;
    OutBuffer = &AccountDn[DN_PREFIX_LENGTH];

    CHAR XlateArray[] = { '0', '1', '2', '3', '4' ,'5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

    for ( i=0; i<UserSidSize; i++ ) {

        *OutBuffer++ = XlateArray[  (InBuffer[i] >> 4) & 0xF ];
        *OutBuffer++ = XlateArray[  InBuffer[i] & 0xF ];

    }

    RtlCopyMemory( OutBuffer,
                   DN_SUFFIX,
                   (DN_SUFFIX_LENGTH+1)*sizeof(WCHAR) );

    //
    // Save it away
    //

    *RetAccountDn = AccountDn;
    AccountDn = NULL;
    WinStatus = NO_ERROR;

    //
    // Free locally used resources
    //
Cleanup:
    if ( UserSid != NULL ) {
        SafeAllocaFree( UserSid );
    }

    if ( AccountDn != NULL ) {
        AzpFreeHeap( AccountDn );
    }

    return WinStatus;
}

DWORD
AzpLdapSupported(
    IN PSID UserSid,
    OUT PBOOLEAN LdapSupported
    )

/*++

Routine description:

    This routine decides whether a given user is a domain user or a local
    machine user.
    On a DC, we support LdapQueries since the user account is surely a domain
    account.
    On a non-dc, we compare the User sid with the AccountDomainSid. If the two
    are equal then this is a local user on a non-DC and we do not support Ldap
    queries.

Arguments:

    UserSid - Sid of the client.

    LdapSupported - Returns whether or not we support LdapQueries.

Return Value:

    Returns ERROR_SUCCESS on success, appropriate failure value otherwise.

--*/

{
    BOOL Equal = FALSE;

    *LdapSupported = TRUE;

    //
    // If this is a DC, we support LdapQueries.
    //

    if ( AzIsDC ) {
        return NO_ERROR;
    }

    ASSERT( AzAccountDomainSidInitialized );


    //
    // Check whether the user belongs to the current machine account domain.
    //

    if ( !EqualDomainSid( AzAccountDomainSid, UserSid, &Equal ) ) {
        return GetLastError();
    }

    //
    // If they are equal this is a local account.
    //

    if ( Equal ) {
        *LdapSupported = FALSE;
    }

    return NO_ERROR;
}

DWORD
AzpCheckGroupMembershipLdap(
    IN PAZP_CLIENT_CONTEXT ClientContext,
    IN OUT PAZP_MEMBER_EVALUATION MemEval
    )
/*++

Routine Description:

    This routine checks to see if the user specified by ClientContext is a member of
    the specified LDAP_QUERY AppGroup.

    Client context created from SID (to skip ldap group check) will not be allowed
    in this routine (ERROR_INVALID_PARAMETER will be returned)

    This routine goes over the wire so AzGlResource must not be locked.

    On entry, ClientContext.CritSect must be locked.

Arguments:

    ClientContext - Specifies the context of the user to check group membership of.

    MemEval - Membership evaluation cache entry for this group
        The cache entry is updated to reflect group membership or
        the reason for failure to find group membership.

Return Value:

    NO_ERROR - The function was successful. (MemEval was updated.)
        MemEval->WinStatus is either set to NO_ERROR or ERROR_NO_SUCH_DOMAIN.

    ERROR_NOT_ENOUGH_MEMORY - not enough memory

    Any failure returned here should be returned to the caller.

--*/
{
    DWORD WinStatus;
    PAZP_AZSTORE AzAuthorizationStore = ClientContext->GenericObject.AzStoreObject;
    LPWSTR DnsDomainName = NULL;

    ULONG GetDcContext;
    PAZP_DC Dc = NULL;

    WCHAR *p;

    ULONG LdapStatus;
    LDAP_TIMEVAL LdapTimeout;
    LPWSTR Attributes[2];
    PLDAPMessage LdapMessage = NULL;

    ULONG EntryCount;

    BOOLEAN IsDomainDnsName = FALSE;


    //
    // Initialization
    //

    ASSERT( AzpIsCritsectLocked( &ClientContext->CritSect ) );
    AzPrint(( AZD_ACCESS_MORE, "AzpCheckGroupMembershipLdap: %ws\n", MemEval->Group->GenericObject.ObjectName->ObjectName.String ));


    //
    // If we don't yet know what domain this user is in,
    //  find out.
    //

    if ( ClientContext->Domain == NULL ) {

        //
        // If we know the domain doesn't support LDAP,
        //  we're sure that the user isn't a member of the group.
        //

        if ( ClientContext->LdapNotSupported ) {
            MemEval->IsMember = FALSE;
            MemEval->WinStatus = NO_ERROR;

            AzPrint(( AZD_ACCESS_MORE,
                      "AzpCheckGroupMembershipLdap: %ws: User is in NT 4 domain or local account: Membership is %ld\n",
                      MemEval->Group->GenericObject.ObjectName->ObjectName.String,
                      MemEval->IsMember ));

            WinStatus = NO_ERROR;
            goto Cleanup;
        }

        if ( ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_TOKEN ) {

            //
            // Get the dns domain name from the LSA
            //

            WinStatus = AzpGetUserNameEx( ClientContext,
                                          NameDnsDomain,
                                          &DnsDomainName,
                                          &IsDomainDnsName );

            if ( WinStatus != NO_ERROR ) {

                //
                // If the account is a local account,
                //  or the domain is an NT 4.0 (or older domain),
                //  then the user isn't a member of this ldap group.
                //

                if ( WinStatus == ERROR_NONE_MAPPED ) {
                    ClientContext->LdapNotSupported = TRUE;
                    MemEval->IsMember = FALSE;
                    MemEval->WinStatus = NO_ERROR;

                    AzPrint(( AZD_ACCESS_MORE,
                              "AzpCheckGroupMembershipLdap: %ws: User is in NT 4 domain or local account: Membership is %ld\n",
                              MemEval->Group->GenericObject.ObjectName->ObjectName.String,
                              MemEval->IsMember ));

                    WinStatus = NO_ERROR;
                    goto Cleanup;
                }

                AzPrint(( AZD_CRITICAL,
                          "AzpCheckGroupMembershipLdap: %ws: AzpGetUserNameEx failed %ld\n",
                          MemEval->Group->GenericObject.ObjectName->ObjectName.String,
                          WinStatus ));

                //
                // The DC can be down.
                //  In that case, ERROR_NO_SUCH_DOMAIN is returned above and
                //  Cleanup puts it in MemEval->WinStatus
                //
                goto Cleanup;
            }

            //
            // AzpGetUserNameEx may return the DnsDomainName with the user name
            // Trim it off if it exists
            //

            p = wcschr( DnsDomainName, L'\\' );

            if ( p != NULL ) {

                *p = '\0';
            }

            //
            // Get the domain handle for this domain
            //

            ClientContext->Domain = AzpReferenceDomain( AzAuthorizationStore,
                                                        DnsDomainName,
                                                        IsDomainDnsName );

        } else if ( ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_NAME ) {

            //
            // Check whether we support Ldap Queries.
            // We do not support Ldap queries if the account is local.
            //
            // Note, AZP_CONTEXT_CREATED_FROM_SID will not get into this code path
            // because SKIP_GROUP is set so ldap group evaluation is skipped.

            WinStatus = AzpLdapSupported( (PSID) ClientContext->SidBuffer, &ClientContext->LdapNotSupported );

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            if ( !ClientContext->LdapNotSupported ) {
                MemEval->IsMember = FALSE;
                MemEval->WinStatus = NO_ERROR;
                goto Cleanup;
            }

            //
            // We have the domain name available already. It's in NetBios name
            // format.
            //

            ClientContext->Domain = AzpReferenceDomain( AzAuthorizationStore,
                                                        ClientContext->DomainName,
                                                        FALSE );
        } else {
            ASSERT( FALSE );
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        if ( ClientContext->Domain == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

    }

    //
    // Loop handling failed DCs
    //

    GetDcContext = 0;
    for ( ;; ) {

        //
        // Free the name from the previous iteration
        //

        if ( Dc != NULL ) {
            AzpDereferenceDc( Dc );
            Dc = NULL;
        }

        //
        // Get the name of a DC to try
        //

        WinStatus = AzpGetDc( AzAuthorizationStore,
                              ClientContext->Domain,
                              &GetDcContext,
                              &Dc );

        if ( WinStatus != NO_ERROR ) {


            AzPrint(( AZD_ACCESS,
                      "AzpCheckGroupMembershipLdap: %ws: DsGetDcName failed %ld\n",
                      MemEval->Group->GenericObject.ObjectName->ObjectName.String,
                      WinStatus ));

            goto Cleanup;
        }




        //
        // Free up resources from the previous iteration
        //
        if ( LdapMessage != NULL ) {
            ldap_msgfree( LdapMessage );
            LdapMessage = NULL;
        }

        //
        // Ensure we have an DN of the user object
        //

        if ( ClientContext->AccountDn == NULL ) {

            WinStatus = AzpComputeAccountDn(
                                ClientContext->AuthzClientContext,
                                &ClientContext->AccountDn );

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

        }


        //
        // Read the user object
        //

        LdapTimeout.tv_sec = 30;    // Wait at most 30 seconds
        LdapTimeout.tv_usec = 0;

        Attributes[0] = L"ObjectClass"; // Pick a random attribute to ask for
        Attributes[1] = NULL;

        LdapStatus = ldap_search_ext_sW(
                                Dc->LdapHandle,
                                ClientContext->AccountDn,
                                LDAP_SCOPE_BASE,
                                MemEval->Group->LdapQuery.String,
                                Attributes, // Ask for only one attribute
                                TRUE,   // Only attribute types (not values)
                                NULL,   // No server controls
                                NULL,   // No client controls
                                &LdapTimeout,
                                0,      // No limit on size of response
                                &LdapMessage );

        if ( LdapStatus != LDAP_SUCCESS ) {

            AzPrint(( AZD_ACCESS,
                      "AzpCheckGroupMembershipLdap: %ws: ldap_search failed on %ws: %ld: %s\n",
                      MemEval->Group->GenericObject.ObjectName->ObjectName.String,
                      Dc->DcName.String,
                      LdapStatus,
                      ldap_err2stringA( LdapStatus )));

            WinStatus = AzpLdapErrorToWin32Error(LdapStatus);

            //
            // If the DC is down,
            //  find another one.
            //

            if ( WinStatus == ERROR_NO_SUCH_DOMAIN ) {
                continue;
            }
            goto Cleanup;
        }

        //
        // Loop through the list of objects returned
        //

        EntryCount = ldap_count_entries( Dc->LdapHandle, LdapMessage );

        if ( EntryCount == 0xFFFFFFFF ) {

            LdapStatus = LdapGetLastError();

            AzPrint(( AZD_CRITICAL,
                      "AzpCheckGroupMembershipLdap: %ws: ldap_count_entries failed on %ws: %ld: %s\n",
                      MemEval->Group->GenericObject.ObjectName->ObjectName.String,
                      Dc->DcName.String,
                      LdapStatus,
                      ldap_err2stringA( LdapStatus )));

            WinStatus = AzpLdapErrorToWin32Error(LdapStatus);
            goto Cleanup;
        }

#if 0 // Run dlcheck.exe if this is ever turned on
        //
        // Perhaps just debug code, but display all of the attributes returned
        //
        ULONG EntryIndex;
        LPWSTR AttributeName;
        BerElement *BerState;
        PLDAPMessage CurrentEntry;

        CurrentEntry = NULL;
        for ( EntryIndex = 0; EntryIndex < EntryCount; EntryIndex ++ ) {

            //
            // Get the next entry
            //
            if ( EntryIndex == 0) {
                CurrentEntry = ldap_first_entry( Dc->LdapHandle, LdapMessage );
            } else {
                CurrentEntry = ldap_next_entry( Dc->LdapHandle, CurrentEntry );
            }

            if ( CurrentEntry == NULL ) {

                LdapStatus = LdapGetLastError();

                if ( LdapStatus != LDAP_SUCCESS ) {
                    AzPrint(( AZD_CRITICAL,
                              "AzpCheckGroupMembershipLdap: %ws: ldap_xxx_entry failed on %ws: %ld: %s\n",
                              MemEval->Group->GenericObject.ObjectName->ObjectName.String,
                              Dc->DcName.String,
                              LdapStatus,
                              ldap_err2stringA( LdapStatus )));
                }

                WinStatus = AzpLdapErrorToWin32Error(LdapStatus);
                goto Cleanup;
            }

            //
            // Loop through the attributes
            //

            AttributeName = ldap_first_attributeW( Dc->LdapHandle, CurrentEntry, &BerState );

            AzPrint(( AZD_ACCESS_MORE, "Object %ld\n", EntryIndex ));

            while ( AttributeName != NULL ) {

                AzPrint(( AZD_ACCESS_MORE, "    %ws\n", AttributeName ));

                ldap_memfree( AttributeName );

                AttributeName = ldap_next_attributeW( Dc->LdapHandle, CurrentEntry, BerState );

            }

            if ( BerState != NULL ) {
                ber_free( BerState, 0 );
            }


            LdapStatus = LdapGetLastError();

            if ( LdapStatus != LDAP_SUCCESS ) {


                AzPrint(( AZD_CRITICAL,
                          "AzpCheckGroupMembershipLdap: %ws: ldap_xxx_attribute failed on %ws: %ld: %s\n",
                          MemEval->Group->GenericObject.ObjectName->ObjectName.String,
                          Dc->DcName.String,
                          LdapStatus,
                          ldap_err2stringA( LdapStatus )));

                WinStatus = AzpLdapErrorToWin32Error(LdapStatus);
                goto Cleanup;
            }


        }
#endif // 0

        //
        // The query worked.
        //  We're a member of the group depending on whether the entry was actually returned.
        //

        MemEval->IsMember = (EntryCount != 0);
        MemEval->WinStatus = NO_ERROR;

        AzPrint(( AZD_ACCESS_MORE,
                  "AzpCheckGroupMembershipLdap: %ws: ldap_search worked on %ws: Membership is %ld\n",
                  MemEval->Group->GenericObject.ObjectName->ObjectName.String,
                  Dc->DcName.String,
                  MemEval->IsMember ));

        WinStatus = NO_ERROR;
        goto Cleanup;

    }

    // ASSERT: Not reached

    //
    // Free locally used resources
    //
Cleanup:
    if ( LdapMessage != NULL ) {
        ldap_msgfree( LdapMessage );
        LdapMessage = NULL;
    }


    if ( Dc != NULL ) {
        AzpDereferenceDc( Dc );
    }
    if ( DnsDomainName != NULL ) {
        AzpFreeHeap( DnsDomainName );
    }

    //
    // If the failure came from the DC,
    //  indicate that we need to try again sometime.
    //

    if ( WinStatus == ERROR_NO_SUCH_DOMAIN ) {
        MemEval->WinStatus = WinStatus;
        WinStatus = NO_ERROR;
    }
    return WinStatus;
}

DWORD
AzpCheckGroupMembershipOne(
    IN PAZP_CLIENT_CONTEXT ClientContext,
    IN PAZP_GROUP Group,
    IN BOOLEAN LocalOnly,
    IN DWORD RecursionLevel,
    OUT PBOOLEAN RetIsMember,
    OUT LPDWORD ExtendedStatus
    )
/*++

Routine Description:

    This routine checks to see if the user specified by ClientContext is a member of
    the specified AppGroup.

    On entry, ClientContext.CritSect must be locked.
    On entry, AzGlResource must be locked Shared.

    *** Note: this routine will temporarily drop AzGlResource in cases where it hits the wire

Arguments:

    ClientContext - Specifies the context of the user to check group membership of.

    Group - Specifies the group to check group membership of

    LocalOnly - Specifies that the caller doesn't want to go off machine to determine
        the membership.

    RecursionLevel - Indicates the level of recursion.
        Used to prevent infinite recursion.

    RetIsMember - Returns whether the caller is a member of the specified group.

    ExtendedStatus - Returns extended status information about the operation.
        NO_ERROR is returned if the group membership was determined.
            The Caller may use the value returned in IsMember.

        If LocalOnly is TRUE, NOT_YET_DONE means that the caller must call again with
            with LocalOnly set to false to get the group membership.

        If LocalOnly is FALSE, an error value indicates that the LDAP server returned
            an error while evaluating the request.  The caller may return this error
            to the original API caller if this group membership is required to determine
            whether the access check worked or not.

Return Value:

    NO_ERROR - The function was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory

    Any failure returned here should be returned to the caller.

--*/
{
    DWORD WinStatus;
    PLIST_ENTRY ListEntry;

    PAZP_MEMBER_EVALUATION MemEval;

    BOOLEAN IsMember;
    BOOLEAN IsNonMember;


    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );
    ASSERT( AzpIsCritsectLocked( &ClientContext->CritSect ) );
    *RetIsMember = FALSE;
    *ExtendedStatus = NO_ERROR;
    AzPrint(( AZD_ACCESS_MORE, "AzpCheckGroupMembershipOne: %ws\n", Group->GenericObject.ObjectName->ObjectName.String ));

    //
    // Loop through the list of groups that have previously been evaluated
    //

    MemEval = NULL;
    for ( ListEntry = ClientContext->MemEval.Flink;
          ListEntry != &ClientContext->MemEval;
          ListEntry = ListEntry->Flink) {

        MemEval = CONTAINING_RECORD( ListEntry,
                                     AZP_MEMBER_EVALUATION,
                                     Next );

        if ( MemEval->Group == Group ) {
            break;
        }

        MemEval = NULL;

    }

    //
    // If we didn't find one,
    //  create one.
    //

    if ( MemEval == NULL ) {

        //
        // Allocate it
        //

        MemEval = (PAZP_MEMBER_EVALUATION) AzpAllocateHeap( sizeof( AZP_MEMBER_EVALUATION ), "CNMEMEVL");

        if ( MemEval == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Initialize it
        //

        MemEval->Group = Group;
        MemEval->WinStatus = NOT_YET_DONE;
        MemEval->IsMember = FALSE;

        //
        // Link it in
        //

        InsertHeadList( &ClientContext->MemEval,
                        &MemEval->Next );

        AzPrint(( AZD_ACCESS_MORE, "AzpCheckGroupMembershipOne: %ws: Create cache entry\n", Group->GenericObject.ObjectName->ObjectName.String ));


    }

    //
    // If we already know the membership,
    //  return the cached answer.
    //

    if ( MemEval->WinStatus == NO_ERROR ) {

        WinStatus = NO_ERROR;
        *ExtendedStatus = NO_ERROR;

        AzPrint(( AZD_ACCESS_MORE, "AzpCheckGroupMembershipOne: %ws: %ld: %ld: Answer found in cache\n", Group->GenericObject.ObjectName->ObjectName.String, *ExtendedStatus, MemEval->IsMember ));
        goto Cleanup;
    }



    //
    // Handle a membership group,
    //

    if ( Group->GroupType == AZ_GROUPTYPE_BASIC ) {
        DWORD AppNonMemberStatus;
        DWORD AppMemberStatus;

        AzPrint(( AZD_ACCESS_MORE, "AzpCheckGroupMembershipOne: %ws: Is a basic group\n", Group->GenericObject.ObjectName->ObjectName.String ));

        //
        // Check the NT Group non-membership
        //

        WinStatus = AzpCheckSidMembership(
                            ClientContext,
                            &Group->SidNonMembers,
                            &IsNonMember );

        if ( WinStatus != NO_ERROR ) {
            AzPrint(( AZD_ACCESS_MORE, "AzpCheckGroupMembershipOne: %ws: Cannot AzpCheckSidMembership (non member) %ld\n", Group->GenericObject.ObjectName->ObjectName.String, WinStatus ));
            goto Cleanup;
        }

        //
        // If we're not a member,
        //  that's definitive
        //

        if ( IsNonMember ) {

            // Cache the answer
            MemEval->IsMember = FALSE;
            MemEval->WinStatus = NO_ERROR;

            // Return the cached answer
            WinStatus = NO_ERROR;
            *ExtendedStatus = MemEval->WinStatus;
            AzPrint(( AZD_ACCESS_MORE, "AzpCheckGroupMembershipOne: %ws: Is non member via NT Sid\n", Group->GenericObject.ObjectName->ObjectName.String ));
            goto Cleanup;
        }

        //
        // Check the app group non-membership
        //

        WinStatus = AzpCheckGroupMembership(
                        ClientContext,
                        &Group->AppNonMembers,
                        LocalOnly,
                        RecursionLevel+1,   // Increment recursion level
                        &IsNonMember,
                        &AppNonMemberStatus );

        if ( WinStatus != NO_ERROR ) {
            AzPrint(( AZD_ACCESS_MORE, "AzpCheckGroupMembershipOne: %ws: Cannot AzpCheckGroupMembership (non member) %ld\n", Group->GenericObject.ObjectName->ObjectName.String, WinStatus ));
            goto Cleanup;
        }

        //
        // If we're not a member,
        //  that's definitive.
        //
        // Note that if we couldn't determine non-membership,
        //  we wait to report back to the caller until we find out if we're a member.
        //  No use worrying the caller if we definitely aren't a member.
        //

        if ( AppNonMemberStatus == NO_ERROR ) {
            if ( IsNonMember ) {

                // Cache the answer
                MemEval->IsMember = FALSE;
                MemEval->WinStatus = NO_ERROR;

                // Return the cached answer
                WinStatus = NO_ERROR;
                *ExtendedStatus = MemEval->WinStatus;
                AzPrint(( AZD_ACCESS_MORE, "AzpCheckGroupMembershipOne: %ws: Is non member via app group\n", Group->GenericObject.ObjectName->ObjectName.String ));
                goto Cleanup;
            }
        }


        //
        // Check the NT Group membership
        //

        WinStatus = AzpCheckSidMembership(
                            ClientContext,
                            &Group->SidMembers,
                            &IsMember );

        if ( WinStatus != NO_ERROR ) {
            AzPrint(( AZD_ACCESS_MORE, "AzpCheckGroupMembershipOne: %ws: Cannot AzpCheckSidMembership (member) %ld\n", Group->GenericObject.ObjectName->ObjectName.String, WinStatus ));
            goto Cleanup;
        }

        //
        // If we couldn't determine membership based on SIDs,
        //  try via app groups
        //

        if ( !IsMember ) {

            //
            // Check the app group membership
            //

            WinStatus = AzpCheckGroupMembership(
                            ClientContext,
                            &Group->AppMembers,
                            LocalOnly,
                            RecursionLevel+1,   // Increment recursion level
                            &IsMember,
                            &AppMemberStatus );

            if ( WinStatus != NO_ERROR ) {
                AzPrint(( AZD_ACCESS_MORE, "AzpCheckGroupMembershipOne: %ws: Cannot AzpCheckGroupMembership (member) %ld\n", Group->GenericObject.ObjectName->ObjectName.String, WinStatus ));
                goto Cleanup;
            }

            //
            // If we couldn't determine membership,
            //  return that status to our caller.
            //

            if ( AppMemberStatus != NO_ERROR ) {

                // We cache this failure only on the LDAP_QUERY group that
                //  caused it.

                MemEval->IsMember = FALSE;
                MemEval->WinStatus = NOT_YET_DONE;

                // Return the cached answer
                WinStatus = NO_ERROR;
                *ExtendedStatus = AppMemberStatus;
                AzPrint(( AZD_ACCESS_MORE, "AzpCheckGroupMembershipOne: %ws: Cannot AzpCheckGroupMembership (member) extended status: %ld\n", Group->GenericObject.ObjectName->ObjectName.String, AppMemberStatus ));
                goto Cleanup;
            }
        }

        //
        // ASSERT: We've determined membership via the SID or APP group mechanisms
        //
        // If we're a member and we couldn't find non-membership,
        //  tell the caller now.
        //

        if ( IsMember ) {
            if ( AppNonMemberStatus != NO_ERROR ) {

                // We cache this failure only on the LDAP_QUERY group that
                //  caused it.

                MemEval->IsMember = FALSE;
                MemEval->WinStatus = NOT_YET_DONE;

                // Return the cached answer
                WinStatus = NO_ERROR;
                *ExtendedStatus = AppNonMemberStatus;
                AzPrint(( AZD_ACCESS_MORE, "AzpCheckGroupMembershipOne: %ws: Cannot AzpCheckGroupMembership (non member) extended status: %ld\n", Group->GenericObject.ObjectName->ObjectName.String, AppNonMemberStatus ));
                goto Cleanup;
            }
        }

        //
        // Finally, we've found out whether we're a member
        //  Tell the caller
        //

        MemEval->IsMember = IsMember;
        MemEval->WinStatus = NO_ERROR;
        *ExtendedStatus = NO_ERROR;
        WinStatus = NO_ERROR;
        AzPrint(( AZD_ACCESS_MORE, "AzpCheckGroupMembershipOne: %ws: %ld: %ld: Answer computed\n", Group->GenericObject.ObjectName->ObjectName.String, *ExtendedStatus, MemEval->IsMember ));



    //
    // Handle an LDAP_QUERY group.
    //

    } else if ( Group->GroupType == AZ_GROUPTYPE_LDAP_QUERY ) {

        //
        // If the caller only wants local processing,
        // or skip ldap group in which case the context is created from SID,
        // We're done for now.
        //

        if ( LocalOnly ||
             (ClientContext->CreationType == AZP_CONTEXT_CREATED_FROM_SID) ) {

            WinStatus = NO_ERROR;

            //
            // ERROR_NO_SUCH_DOMAIN isn't definitive.
            //  Convert it to NOT_YET_DONE to ensure we try again.
            //
            ASSERT( MemEval->WinStatus == ERROR_NO_SUCH_DOMAIN || MemEval->WinStatus == NOT_YET_DONE );
            *ExtendedStatus = NOT_YET_DONE;
            AzPrint(( AZD_ACCESS_MORE, "AzpCheckGroupMembershipOne: %ws: Avoid ldapquery group\n", Group->GenericObject.ObjectName->ObjectName.String ));
            goto Cleanup;
        }

        //
        // Query the DC to determine group membership
        //
        // Drop AzGlResource while going over the wire
        //

        AzPrint(( AZD_ACCESS_MORE, "AzpCheckGroupMembershipOne: %ws: Is an ldapquery group\n", Group->GenericObject.ObjectName->ObjectName.String ));

        AzpUnlockResource( &AzGlResource );

        WinStatus = AzpCheckGroupMembershipLdap(
                            ClientContext,
                            MemEval );

        AzpLockResourceShared( &AzGlResource );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        *ExtendedStatus = MemEval->WinStatus;

    //
    // Handle invalid group types
    //

    } else {

        AzPrint(( AZD_ACCESS_MORE, "AzpCheckGroupMembershipOne: %ws: Is an invalid group type\n", Group->GenericObject.ObjectName->ObjectName.String, Group->GroupType ));

        //
        // Don't fail the AccessCheck because of malformed policy data
        //
        MemEval->IsMember = FALSE;
        MemEval->WinStatus = NO_ERROR;

        // Return the cached answer
        WinStatus = NO_ERROR;
        *ExtendedStatus = MemEval->WinStatus;

    }



    //
    // Free any local resources
    //
Cleanup:
    if ( WinStatus == NO_ERROR &&
         *ExtendedStatus == NO_ERROR ) {

        *RetIsMember = MemEval->IsMember;

    }

    return WinStatus;
}

DWORD
AzpWalkTaskTree(
    IN PACCESS_CHECK_CONTEXT AcContext,
    IN PGENERIC_OBJECT_LIST OperationObjectList,
    IN PGENERIC_OBJECT_LIST TaskObjectList,
    IN DWORD RecursionLevel,
    IN OUT LPDWORD *AllocatedMemory OPTIONAL,
    IN OUT LPDWORD MemoryRequired,
    IN OUT LPDWORD TaskInfoArraySize,
    OUT PAZ_OPS_AND_TASKS OpsAndTasks OPTIONAL,
    OUT PBOOLEAN CallAgain
    )
/*++

Routine Description:

    This routine walks a tree of tasks collecting information about the tasks.  The caller should
    call this routine twice.  Once to determine how much memory to allocate.  The second to initialize
    that memory.

    On the first pass, AllocatedMemory and AcContext->TaskInfo should be passed in as null.
    On the first pass, this routine simply counts the number of tasks and operations in the tree.

    Between the first and second passes, the caller should allocate two buffers.
    The first should be MemoryRequired bytes long and should be passed in AllocatedMemory on the
    second pass. The second should be TaskInfoArraySize bytes long and should
    be passed in AcContext->TaskInfo on the second pass. (The caller is responsible for freeing
    this memory.)

    On the second pass, this routine fills in the allocated arrays.  AcContext->TaskInfo is
    filled in with each task found.  However, this routine weeds out duplicates.  By weeding
    out duplicates, the TaskInfo array has a single entry for each applicable task and we can
    ensure that each task is processed at most one time.

    Since duplicates are weeded out, the TaskInfo array may be larger than the number of entries used.

    On entry, AcContext->ClientContext.CritSect must be locked.
    On entry, AzGlResource must be locked Shared.  (The AzGlResource should not be dropped between
    the two calls to AzpWalkTaskTree mentioned above.)

Arguments:

    AcContext - Specifies the context of the user to check group membership of.

    OperationObjectList - Specifies a list of operations referenced by the parent object.

    TaskObjectList - Specifies the list of tasks referenced by the parent object.

    RecursionLevel - Indicates the level of recursion.
        Used to prevent infinite recursion.

    AllocatedMemory - On the first pass, this pointer should be NULL.
        On the second pass, this is a pointer to the memory allocated by the caller.

    MemoryRequired - This variable is incremented by the amount of memory required on the second pass.

    TaskInfoArraySize - This variable is incremented by the amount of memory required on the second pass.

    OpsAndTasks - On the second pass, this structure is filled in with the indices to all
        of the applicable operations from OperationObjectList and tasks from TaskObjectList.

    CallAgain - Set to TRUE if an operation was found in OperationObjectList or
        recursively in TaskObjectList.
        FALSE if the OperationObjectList and TaskObjectList should never be processed again.

Return Value:

    NO_ERROR - The function was successful

--*/
{
    DWORD WinStatus;
    BOOLEAN FirstPass = (AllocatedMemory==NULL);
    ULONG Size;

    ULONG i;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );
    ASSERT( AzpIsCritsectLocked( &AcContext->ClientContext->CritSect ) );

    if ( RecursionLevel > 100 ) {
        return ERROR_DS_LOOP_DETECT;
    }

    if ( FirstPass ) {
        ASSERT( OpsAndTasks == NULL );
        ASSERT( AcContext->TaskInfo == NULL );
    } else {
        ASSERT( OpsAndTasks != NULL );
        ASSERT( AcContext->TaskInfo != NULL );
    }

    *CallAgain = FALSE;
    if ( OpsAndTasks != NULL ) {
        RtlZeroMemory( OpsAndTasks, sizeof(*OpsAndTasks) );
    }

    //
    // If the caller passed in any operations,
    //  see which are applicable
    //

    if ( OperationObjectList->GenericObjects.UsedCount ) {

        ULONG OpIndex;

        //
        // Allocate a buffer for the array of indices to the operations
        //

        Size = OperationObjectList->GenericObjects.UsedCount*sizeof(ULONG);
        *MemoryRequired += Size;

        if ( !FirstPass ) {
            // AzPrint(( AZD_ACCESS_MORE, "Used: 0x%lx (0x%lx)\n", *AllocatedMemory, Size ));
            OpsAndTasks->OpIndexes = *AllocatedMemory;
            *AllocatedMemory = (LPDWORD)(((LPBYTE)(*AllocatedMemory)) + Size);
        }


        //
        // Determine which operations are applicable
        //
        for ( OpIndex = 0;
              OpIndex < OperationObjectList->GenericObjects.UsedCount;
              OpIndex++ ) {

            PAZP_OPERATION Operation;

            Operation = (PAZP_OPERATION)(OperationObjectList->GenericObjects.Array[OpIndex]);
            ASSERT( Operation->GenericObject.ObjectType == OBJECT_TYPE_OPERATION );


            //
            // Find this operation in the list of operations requested by the caller.
            //
            for ( i=0; i<AcContext->OperationCount; i++ ) {

                //
                // If the Task operation matches a requested operation,
                //  then we have a match.
                //

                if ( Operation->OperationId == AcContext->OperationObjects[i]->OperationId ) {

                    //
                    // Indicate that we've found an operation
                    //

                    *CallAgain = TRUE;


                    //
                    // On the second pass,
                    //  Remember an index for this operation.
                    //

                    if ( !FirstPass ) {
                        OpsAndTasks->OpIndexes[OpsAndTasks->OpCount] = i;
                        OpsAndTasks->OpCount++;
                    }

                    break;
                }

            }

        }
    }

    //
    // If the caller passed in any tasks,
    //  see which are applicable
    //

    if ( TaskObjectList->GenericObjects.UsedCount ) {

        ULONG TaskIndex;
        PAZ_TASK_INFO TaskInfo;

        //
        // Allocate a buffer for the array of indices to the tasks
        //

        Size = TaskObjectList->GenericObjects.UsedCount*sizeof(ULONG);
        *MemoryRequired += Size;

        if ( !FirstPass ) {
            // AzPrint(( AZD_ACCESS_MORE, "Used: 0x%lx (0x%lx)\n", *AllocatedMemory, Size ));
            OpsAndTasks->TaskIndexes = *AllocatedMemory;
            *AllocatedMemory = (LPDWORD)(((LPBYTE)(*AllocatedMemory)) + Size);
        }

        //
        // Walk the task object list
        //

        for ( TaskIndex = 0;
              TaskIndex < TaskObjectList->GenericObjects.UsedCount;
              TaskIndex ++ ) {

            PAZP_TASK Task;

            BOOLEAN LocalCallAgain;

            Task = (PAZP_TASK)(TaskObjectList->GenericObjects.Array[TaskIndex]);
            ASSERT( Task->GenericObject.ObjectType == OBJECT_TYPE_TASK );

            //
            // If this is the not the first pass,
            //  find a TaskInfo.
            //

            *TaskInfoArraySize += sizeof(AZ_TASK_INFO);
            TaskInfo = NULL;

            if (  !FirstPass ) {

                //
                // Determine if this task already has a taskinfo
                //

                for ( i=0; i<AcContext->TaskCount; i++ ) {

                    if ( Task == AcContext->TaskInfo[i].Task ) {
                        TaskInfo = &AcContext->TaskInfo[i];
                        break;
                    }
                }

                //
                // If there isn't already a task info,
                //  allocate one
                //

                if ( TaskInfo == NULL ) {

                    //
                    // Grab the next TaskInfo and initialize to zero.
                    //

                    TaskInfo = &AcContext->TaskInfo[AcContext->TaskCount];
                    AcContext->TaskCount++;

                    RtlZeroMemory( TaskInfo, sizeof(*TaskInfo) );

                    //
                    // Reference the task
                    //  Need to grab a reference since the global lock will be dropped during the
                    //  lifetime of this task info.
                    //

                    InterlockedIncrement( &Task->GenericObject.ReferenceCount );
                    AzpDumpGoRef( "Task reference", &Task->GenericObject );

                    TaskInfo->Task = Task;

                }
            }

            //
            // Recurse.
            //

            WinStatus = AzpWalkTaskTree( AcContext,
                                         &Task->Operations,
                                         &Task->Tasks,
                                         RecursionLevel+1,
                                         AllocatedMemory,
                                         MemoryRequired,
                                         TaskInfoArraySize,
                                         FirstPass ? NULL : &TaskInfo->OpsAndTasks,
                                         &LocalCallAgain );

            if ( WinStatus != NO_ERROR ) {
                return WinStatus;
            }


            //
            // If operations were found in the subtree,
            //  then process the subtree.
            //

            if ( LocalCallAgain ) {

                *CallAgain = TRUE;

                //
                // On the second pass,
                //  Remember an index for this task
                //

                if ( !FirstPass ) {
                    OpsAndTasks->TaskIndexes[OpsAndTasks->TaskCount] =
                        (ULONG)(TaskInfo - AcContext->TaskInfo);
                    OpsAndTasks->TaskCount++;
                }

            //
            // If no applicable operations were found anywhere,
            //  ditch this task.
            //
            } else {

                if ( !FirstPass ) {
                    TaskInfo->TaskProcessed = TRUE;
                }
            }

        }
    }


    return NO_ERROR;
}

DWORD
AzpCaptureBizRuleParameters(
    IN PACCESS_CHECK_CONTEXT AcContext,
    IN VARIANT *ParameterNames OPTIONAL,
    IN VARIANT *ParameterValues OPTIONAL
    )
/*++

Routine Description:

    This routine captures the access check parameters related to BizRule evaluation.
    The captured parameters are remembered in the AcContext.

Arguments:

    AcContext - Specifies the access check context

    ParameterNames - See AzContextAccessCheck
    ParameterValues - See AzContextAccessCheck


Return Value:

    NO_ERROR - The function was successful
    ERROR_INVALID_PARAMETER - One of the parameters are invalid

    Any failure returned here should be returned to the caller.

--*/
{
    DWORD WinStatus;

    HRESULT hr;
    SAFEARRAY* SaNames;
    SAFEARRAY* SaValues;
    VARIANT HUGEP *Names = NULL;
    VARIANT HUGEP *Values = NULL;
    LONG NamesLower;
    LONG NamesUpper;
    LONG ValuesLower;
    LONG ValuesUpper;

    ULONG ParameterCount;
    ULONG Index;

    //
    // We don't actually capture.  But we do reference several fields.  Do those
    // references under a try/except.
    //
    // All uses of these parameters are done under try/except.
    //

    __try {

        //
        // Canonicalize the array references
        //

        WinStatus = AzpSafeArrayPointerFromVariant( ParameterNames,
                                                    TRUE,
                                                    &SaNames );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = AzpSafeArrayPointerFromVariant( ParameterValues,
                                                    TRUE,
                                                    &SaValues );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }


        //
        // If one is null, both must be.
        //
        if ( SaNames == NULL ) {

            if ( SaValues == NULL ) {
                WinStatus = NO_ERROR;
                AcContext->ParameterNames = NULL;
                AcContext->ParameterValues = NULL;
                AcContext->ParameterCount = 0;
            } else {
                AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleParameters: Names is NULL but Values isn't\n" ));
                WinStatus = ERROR_INVALID_PARAMETER;
            }
            goto Cleanup;

        } else if ( SaValues == NULL ) {
            AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleParameters: Values is NULL but Names isn't\n" ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;

        }


        //
        // Both must have the same upper and lower bounds
        //
        hr = SafeArrayGetLBound( SaNames, 1, &NamesLower );
        if ( FAILED(hr)) {
            AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleParameters: Can't get name lbound 0x%lx\n", hr ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        hr = SafeArrayGetLBound( SaValues, 1, &ValuesLower );
        if ( FAILED(hr)) {
            AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleParameters: Can't get value lbound 0x%lx\n", hr ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        hr = SafeArrayGetUBound( SaNames, 1, &NamesUpper );
        if ( FAILED(hr)) {
            AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleParameters: Can't get name ubound 0x%lx\n", hr ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        hr = SafeArrayGetUBound( SaValues, 1, &ValuesUpper );
        if ( FAILED(hr)) {
            AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleParameters: Can't get value ubound 0x%lx\n", hr ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        if ( NamesLower != ValuesLower ||
             NamesUpper != ValuesUpper ) {
            AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleParameters: Array bounds don't match %ld %ld %ld %ld\n", NamesLower, ValuesLower, NamesUpper, ValuesUpper ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }


        //
        // Lock the arrays
        //

        hr = SafeArrayAccessData( SaNames, (void HUGEP**)&Names);

        if (FAILED(hr)) {
            AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleParameters: Can't access ParameterNames 0x%lx\n", hr ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        hr = SafeArrayAccessData( SaValues, (void HUGEP**)&Values);

        if (FAILED(hr)) {
            SafeArrayUnaccessData( SaNames );
            AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleParameters: Can't access ParameterValues 0x%lx\n", hr ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }


        //
        // Loop validating the parameter arrays
        //

        ParameterCount = NamesUpper - NamesLower + 1;
        for ( Index=0; Index<ParameterCount; Index++ ) {

            //
            // Stop at the end of the array
            //
            if ( V_VT( &Names[Index] ) == VT_EMPTY ) {
                ParameterCount = Index;
                break;
            }

            //
            // Only allow BSTRs
            //
            if ( V_VT( &Names[Index] ) != VT_BSTR ) {
                AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleParameters: Parameter %ld isn't a VT_BSTR\n", Index ));
                WinStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }

            //
            // Value cannot be an interface
            //
            if ( V_VT( &Values[Index] ) == VT_DISPATCH ||
                 V_VT( &Values[Index] ) == VT_UNKNOWN ) {

                AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleParameters: Parameter %ws should have an interface value\n",
                          V_BSTR(&Names[Index] ) ));

                WinStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }


#if DBG
            //
            // On a checked build, ensure the parameters are already sorted
            //
            // Only compare after the first iteration
            //

            if ( Index != 0 ) {

                if ( AzpCompareParameterNames(&Names[Index-1], &Names[Index] ) >= 0 ) {

                    AzPrint(( AZD_INVPARM,
                              "AzpBuildParameterDescriptor: Parameters not sorted: %ws: %ws\n",
                              V_BSTR(&Names[Index-1] ),
                              V_BSTR(&Names[Index] ) ));

                    WinStatus = ERROR_INVALID_PARAMETER;
                    goto Cleanup;
                }
            }

#endif // DBG
        }



        //
        // Remember the data
        //
        AcContext->SaParameterNames = SaNames;
        AcContext->ParameterNames = Names;
        AcContext->SaParameterValues = SaValues;
        AcContext->ParameterValues = Values;

        AcContext->ParameterCount = ParameterCount;

        WinStatus = NO_ERROR;

Cleanup:;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        WinStatus = RtlNtStatusToDosError( GetExceptionCode());

    }

    return WinStatus;
}

INT __cdecl
AzpCompareParameterNames(
    IN const void *pArg1,
    IN const void *pArg2
    )
/*++

Routine Description:

        This routine compares two parameter names for the qsort/bsearch API

Arguments:

        pArg1 - First string for comparison
        pArg2 - Second String for comparison

Return Values:

        <0 - First string is smaller
        0 - strings are same
        >0 - First string is larger

--*/
{
    HRESULT hr;

    VARIANT *var1 = (VARIANT *) pArg1;
    VARIANT *var2 = (VARIANT *) pArg2;

    //
    // Compare the parameter names
    //  This comparison has proven to be a bottleneck for AccessCheck performance.
    //  Consider replacing this with some combination of SysStringByteLen and memcmp.
    //  I'm not sure that all callers pass in strings when SysStringByteLen isn't longer
    //  than the useful part of the string.
    //  I'm not sure that memcmp returns the same sort order as a case sensitive VarCmp.
    //

    ASSERT( V_VT(var1) == VT_BSTR );
    ASSERT( V_VT(var2) == VT_BSTR );

    hr = VarCmp( var1, var2, LOCALE_USER_DEFAULT, 0);

    if ( hr == VARCMP_LT ) {
        return -1;
    } else if ( hr == (HRESULT)VARCMP_GT ) {
        return 1;
    } else {
        return 0;
    }
}


INT __cdecl
AzpCaseInsensitiveCompareParameterNames(
    IN const void *pArg1,
    IN const void *pArg2
    )
/*++

Routine Description:

        This routine compares case-insensitively two parameter
        names for the qsort/bsearch API

Arguments:

        pArg1 - First string for comparison
        pArg2 - Second String for comparison

Return Values:

        <0 - First string is smaller
        0 - strings are same
        >0 - First string is larger

--*/
{
    HRESULT hr;

    VARIANT *var1 = (VARIANT *) pArg1;
    VARIANT *var2 = (VARIANT *) pArg2;

    //
    // See comments in AzpCompareParameterNames
    //

    ASSERT( V_VT(var1) == VT_BSTR );
    ASSERT( V_VT(var2) == VT_BSTR );

    hr = VarCmp( var1, var2, LOCALE_USER_DEFAULT, NORM_IGNORECASE);

    if ( hr == VARCMP_LT ) {
        return -1;
    } else if ( hr == (HRESULT)VARCMP_GT ) {
        return 1;
    } else {
        return 0;
    }
}

DWORD
AzpCaptureBizRuleInterfaces(
    IN PACCESS_CHECK_CONTEXT AcContext,
    IN VARIANT *InterfaceNames OPTIONAL,
    IN VARIANT *InterfaceFlags OPTIONAL,
    IN VARIANT *Interfaces OPTIONAL
    )
/*++

Routine Description:

    This routine captures the access check interfaces related to BizRule evaluation.
    The captured parameters are remembered in the AcContext.

    On entry, AzGlResource must be locked Shared.

Arguments:

    AcContext - Specifies the access check context

    InterfaceNames - See AzContextAccessCheck
    InterfaceFlags - See AzContextAccessCheck
    Interfaces - See AzContextAccessCheck


Return Value:

    NO_ERROR - The function was successful
    ERROR_INVALID_PARAMETER - One of the parameters are invalid

    Any failure returned here should be returned to the caller.

--*/
{
    DWORD WinStatus;

    HRESULT hr;
    SAFEARRAY* Names;
    SAFEARRAY* Flags;
    SAFEARRAY* SaInterfaces;
    LONG NamesLower;
    LONG NamesUpper;
    LONG FlagsLower;
    LONG FlagsUpper;
    LONG InterfacesLower;
    LONG InterfacesUpper;

    //
    // We don't actually capture.  But we do reference several fields.  Do those
    // references under a try/except.
    //
    // All uses of these parameters are done under try/except.
    //

    __try {

        //
        // Canonicalize the array references
        //

        WinStatus = AzpSafeArrayPointerFromVariant( InterfaceNames,
                                                    TRUE,
                                                    &Names );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = AzpSafeArrayPointerFromVariant( InterfaceFlags,
                                                    TRUE,
                                                    &Flags );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = AzpSafeArrayPointerFromVariant( Interfaces,
                                                    TRUE,
                                                    &SaInterfaces );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }


        //
        // If one is null, all must be.
        //
        if ( Names == NULL ) {

            if ( Flags == NULL && SaInterfaces == NULL ) {
                WinStatus = NO_ERROR;
                AcContext->InterfaceNames = NULL;
                AcContext->InterfaceFlags = NULL;
                AcContext->Interfaces = NULL;
            } else {
                AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleInterfaces: Names is NULL but Flags or Interfaces isn't\n" ));
                WinStatus = ERROR_INVALID_PARAMETER;
            }
            goto Cleanup;

        } else if ( Flags == NULL || SaInterfaces == NULL ) {
            AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleInterfaces: Flags or Interfaces is NULL but Names isn't\n" ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;

        }


        //
        // All must have the same upper and lower bounds
        //
        hr = SafeArrayGetLBound( Names, 1, &NamesLower );
        if ( FAILED(hr)) {
            AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleInterfaces: Can't get name lbound 0x%lx\n", hr ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        hr = SafeArrayGetLBound( Flags, 1, &FlagsLower );
        if ( FAILED(hr)) {
            AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleInterfaces: Can't get value lbound 0x%lx\n", hr ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        hr = SafeArrayGetLBound( SaInterfaces, 1, &InterfacesLower );
        if ( FAILED(hr)) {
            AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleInterfaces: Can't get interfaces lbound 0x%lx\n", hr ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        hr = SafeArrayGetUBound( Names, 1, &NamesUpper );
        if ( FAILED(hr)) {
            AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleInterfaces: Can't get name ubound 0x%lx\n", hr ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        hr = SafeArrayGetUBound( Flags, 1, &FlagsUpper );
        if ( FAILED(hr)) {
            AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleInterfaces: Can't get value ubound 0x%lx\n", hr ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        hr = SafeArrayGetUBound( SaInterfaces, 1, &InterfacesUpper );
        if ( FAILED(hr)) {
            AzPrint(( AZD_INVPARM, "AzpCaptureBizRuleInterfaces: Can't get interfaces ubound 0x%lx\n", hr ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        if ( NamesLower != FlagsLower ||
             NamesLower != InterfacesLower ||
             NamesUpper != FlagsUpper  ||
             NamesUpper != InterfacesUpper  ) {

            AzPrint(( AZD_INVPARM,
                      "AzpCaptureBizRuleInterfaces: Array bounds don't match %ld %ld %ld %ld %ld %ld\n",
                      NamesLower, FlagsLower, InterfacesLower,
                      NamesUpper, FlagsUpper, InterfacesUpper ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }



        //
        // Remember the data
        //
        AcContext->InterfaceNames = Names;
        AcContext->InterfaceFlags = Flags;
        AcContext->Interfaces = SaInterfaces;

        AcContext->InterfaceLower = NamesLower;
        AcContext->InterfaceUpper = NamesUpper;

        WinStatus = NO_ERROR;

Cleanup:;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        WinStatus = RtlNtStatusToDosError( GetExceptionCode());

    }

    //
    // Validate the parameters
    //


    return WinStatus;
}


typedef enum {
    WeedOutFinishedOps,
    SetResultStatus
} OPS_AND_TASKS_OPCODE;

DWORD
AzpWalkOpsAndTasks(
    IN PACCESS_CHECK_CONTEXT AcContext,
    IN PAZP_STRING Name,
    IN PAZ_OPS_AND_TASKS OpsAndTasks,
    IN OPS_AND_TASKS_OPCODE Opcode,
    IN DWORD ResultStatus,
    IN BOOLEAN BizrulesOk,
    OUT PBOOLEAN CallAgain
    )
/*++

Routine Description:

    This routine walks the OpsAndTasks tree built by AzpWalkTaskTree performing the function
    specified by Opcode.

    On entry, AcContext->ClientContext.CritSect must be locked.
    On entry, AzGlResource must be locked Shared.

    *** Note: this routine will temporarily drop AzGlResource in cases where it hits the wire

Arguments:

    AcContext - Specifies the context of the user to check group membership of.

    Name - Name of the object containing OpsAndTasks.

    OpsAndTasks - Specifies the set of operations and tasks for a particular role or task.

    Opcode - Specifies the operation to perform.
        WeedOutFinishedOps: update OpsAndTasks to remove operations that are already finished
            and return CallAgain if there are any operations left.
        SetResultStatus: Set ResultStatus on all operations that haven't yet been processed

    ResultStatus - Specifies the ResultStatus to be set for the SetResultStatus opcode.

    BizrulesOk - Specifies TRUE if it is OK to process Bizrules.
        If FALSE, only Ops and Tasks without bizrules are processed.
        This boolean is ignored for the WeedOutFinishedOps opcode.

    CallAgain - Set to TRUE if the caller should call again for this OpsAndTasks.
        FALSE if the OpsAndTasks should never be processed again.

Return Value:

    NO_ERROR - The function was successful

--*/
{
    DWORD WinStatus;

    ULONG i;
    ULONG OpIndex;


    //
    // Initialization
    //

    UNREFERENCED_PARAMETER( Name ); // Not referenced on a free build

    ASSERT( AzpIsLockedShared( &AzGlResource ) );
    ASSERT( AzpIsCritsectLocked( &AcContext->ClientContext->CritSect ) );

    *CallAgain = FALSE;

    //
    // Loop through the list of operations seeing if they're still applicable.
    //

    for ( i = 0; i < OpsAndTasks->OpCount; ) {

        ASSERT( i < AcContext->OperationCount );

        //
        // If all operations have now been processed,
        //  we're done.
        //

        if ( AcContext->ProcessedOperationCount == AcContext->OperationCount ) {
            AzPrint(( AZD_ACCESS_MORE,
                      "AzpWalkOpsAndTasks: %ws: %ws: All operations have been processed %ld.\n",
                      AcContext->ObjectNameString.String,
                      AcContext->ScopeNameString.String ? AcContext->ScopeNameString.String : L"",
                      AcContext->OperationCount ));
            break;
        }

        //
        // If the operation result is already known,
        //  ditch it from this list.
        //

        OpIndex = OpsAndTasks->OpIndexes[i];

        if ( AcContext->OperationWasProcessed[OpIndex] ) {

            PopUlong( OpsAndTasks->OpIndexes, i, OpsAndTasks->OpCount );

        //
        // If the operation still needs to be processed,
        //  note the fact and move on
        //
        } else {

            //
            // Update the Results array
            //
            if ( Opcode == SetResultStatus ) {


                //
                // If permission is now granted to the operation,
                //  mark it so.
                //

                if ( ResultStatus == NO_ERROR ) {

                    AzPrint(( AZD_ACCESS_MORE,
                              "AzpWalkOpsAndTasks: %ws: %ws: %ws: Operation granted\n",
                              AcContext->ObjectNameString.String,
                              Name->String,
                              AcContext->OperationObjects[OpIndex]->GenericObject.ObjectName->ObjectName.String ));

                    AcContext->Results[OpIndex] = NO_ERROR;
                    AcContext->OperationWasProcessed[OpIndex] = TRUE;
                    AcContext->ProcessedOperationCount++;

                //
                // If we don't already know that result,
                //  update it.
                //
                // If the result is already ERROR_ACCESS_DENIED, any status other than NO_ERROR is
                //  less informative than the one we already have.
                //

                } else if ( AcContext->Results[OpIndex] != ERROR_ACCESS_DENIED ) {
                    AcContext->Results[OpIndex] = ResultStatus;
                    AzPrint(( AZD_ACCESS_MORE,
                              "AzpWalkOpsAndTasks: %ws: %ws: %ws: Operation extended failure %ld\n",
                              AcContext->ObjectNameString.String,
                              Name->String,
                              AcContext->OperationObjects[OpIndex]->GenericObject.ObjectName->ObjectName.String,
                              ResultStatus ));
                }

            }

            //
            // If the operation has now been granted access,
            //  ditch it from this list.
            //

            if ( AcContext->Results[OpIndex] == NO_ERROR ) {
                PopUlong( OpsAndTasks->OpIndexes, i, OpsAndTasks->OpCount );
            } else {
                *CallAgain = TRUE;
                i++;
            }
        }

    }


    //
    // Loop through the list of tasks recursing
    //

    for ( i=0; i<OpsAndTasks->TaskCount; ) {

        PAZ_TASK_INFO TaskInfo;
        BOOLEAN LocalCallAgain;

        //
        // If the task has already been processed,
        //  ditch it from the list.
        //

        ASSERT( i < AcContext->TaskCount );
        TaskInfo = &AcContext->TaskInfo[OpsAndTasks->TaskIndexes[i]];

        if ( TaskInfo->TaskProcessed ) {
            PopUlong( OpsAndTasks->TaskIndexes, i, OpsAndTasks->TaskCount );

        //
        // If the task still needs to be processed,
        //  do so now.
        //

        } else {

            BOOLEAN WalkTree;

            //
            // If the task has a BizRule,
            //  process the BizRule
            //
            //

            WalkTree = TRUE;

            if ( TaskInfo->Task->BizRule.StringSize != 0 ) {

                //
                // If we're just weeding out operations
                //  don't process the BizRule and continue walking the tree
                //

                if ( Opcode == WeedOutFinishedOps ) {

                    WalkTree = TRUE;

                //
                // If we're setting ResultStatus,
                //  and we're not yet processing BizRules,
                //  we're done for now
                //

                } else if ( !BizrulesOk ) {

                    WalkTree = FALSE;


                //
                // If we're setting ResultStatus,
                //  and we're allowed to process the bizrule,
                //  do so now.
                //

                } else {

                    //
                    // If we haven't yet cached the result of the BizRule,
                    //  process the BizRule now.
                    //
                    if ( !TaskInfo->BizRuleProcessed ) {

                        BOOL BizRuleResult = FALSE;

                        //
                        // If there exists a bizrule in a task under a delegated scope, we need to return
                        // an error back to the user telling them that the store is in an inconsistent state.
                        // Tasks under delegated scopes are not allowed to have any bizrules.  If they do, then
                        // the store has either been compromised, or changed not using azroles.dll.  The business
                        // rule then should be evaluated to a FALSE, and a reason returned to the user.
                        //

                        if ( (((PGENERIC_OBJECT)
                               (TaskInfo->Task))->ParentGenericObjectHead->ParentGenericObject)->ObjectType
                             == OBJECT_TYPE_SCOPE &&
                             (((PGENERIC_OBJECT)
                               (TaskInfo->Task))->ParentGenericObjectHead->ParentGenericObject)->PolicyAdmins.GenericObjects.UsedCount
                             != 0 ) {

                            WinStatus = ERROR_FILE_CORRUPT;
                            return WinStatus;

                        }

                        // Drop AzGlResource while going over the wire
                        AzpUnlockResource( &AzGlResource );
                        WinStatus = AzpProcessBizRule( AcContext, TaskInfo->Task, &BizRuleResult );
                        AzpLockResourceShared( &AzGlResource );

                        if ( WinStatus != NO_ERROR ) {
                            return WinStatus;
                        }

                        TaskInfo->BizRuleProcessed = TRUE;
                        TaskInfo->BizRuleResult = (BOOLEAN)BizRuleResult;
                    }

                    //
                    // If the BizRule granted access,
                    //   walk the tree.
                    //
                    if ( TaskInfo->BizRuleResult ) {
                        WalkTree = TRUE;

                    //
                    // If the BizRule didn't grant access,
                    //  don't walk the tree and never process this task again
                    //

                    } else {

                        WalkTree = FALSE;
                        TaskInfo->TaskProcessed = TRUE;
                    }
                }

            }

            //
            // If we need to recurse,
            //  do so now
            //

            if ( WalkTree ) {

                //
                // Process all of the operations and tasks for this task
                //
                WinStatus = AzpWalkOpsAndTasks( AcContext,
                                                &TaskInfo->Task->GenericObject.ObjectName->ObjectName,
                                                &TaskInfo->OpsAndTasks,
                                                Opcode,
                                                ResultStatus,
                                                BizrulesOk,
                                                &LocalCallAgain );

                if ( WinStatus != NO_ERROR ) {
                    return WinStatus;
                }

                //
                // If we're not to walk the tree again,
                //  mark it so.
                //

                if ( !LocalCallAgain ) {
                    TaskInfo->TaskProcessed = TRUE;
                }

            }

            //
            // If the task is now marked as processed,
            //  ditch it from the list.
            //

            if ( TaskInfo->TaskProcessed ) {

                PopUlong( OpsAndTasks->TaskIndexes, i, OpsAndTasks->TaskCount );

            //
            // Otherwise process it again
            //

            } else {
                *CallAgain = TRUE;
                i++;
            }

        }
    }


    return NO_ERROR;
}


DWORD
WINAPI
AzInitializeContextFromToken(
    IN AZ_HANDLE ApplicationHandle,
    IN HANDLE TokenHandle OPTIONAL,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ClientContextHandle
    )
/*++

Routine Description:

    This routine creates a client context based on a passed in token handle or on
    the impersonation token of the caller's thread.

Arguments:

    ApplicationHandle - Specifies a handle to the application object that
        is this client context applies to.

    TokenHandle - Handle to the NT token describing the cleint.
        NULL implies the impersonation token of the caller's thread.
        The token mast have been opened for TOKEN_QUERY, TOKEN_IMPERSONATION, and
        TOKEN_DUPLICATE access.

    Reserved - Reserved.  Must by zero.

    ClientContextHandle - Return a handle to the client context
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_SUPPORTED - Function not supported in current store mode (ie, manage store)
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    DWORD WinStatus;
    LUID Identifier = {0};
    PAZP_CLIENT_CONTEXT ClientContext = NULL;
    HANDLE TempTokenHandle = INVALID_HANDLE_VALUE;
    TOKEN_STATISTICS TokenStats = {0};
    PAZP_AZSTORE AzAuthorizationStore = (PAZP_AZSTORE) ParentOfChild(
        &((PAZP_APPLICATION)ApplicationHandle)->GenericObject );

    DWORD Ignore;

    DWORD dwDesiredAccess; // Desired access for DuplicateTokenEx
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel; // Impersonation level for DuplicateTokenEx

    //
    // If the store is in manage mode only, then no runtime is allowed
    // Return ERROR_NOT_SUPPORTED
    //

    if ( AzpOpenToManageStore(AzAuthorizationStore) ) {

        WinStatus = ERROR_NOT_SUPPORTED;
        AzPrint(( AZD_CRITICAL, "AzInitializeContextFromToken: Cannot initialize context since store is in manage mode %ld\n",
                  WinStatus
                  ));
        goto Cleanup;
    }


    //
    // Call the common routine to create our client context object
    //

    WinStatus = ObCommonCreateObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->ClientContexts),
                    OBJECT_TYPE_CLIENT_CONTEXT,
                    NULL,
                    Reserved,
                    (PGENERIC_OBJECT *) &ClientContext );

    if ( WinStatus != NO_ERROR ) {
        AzPrint(( AZD_CRITICAL, "AzInitializeContextFromToken: Cannot ObCommonCreateObject %ld\n", WinStatus ));
        goto Cleanup;
    }

    //
    // Client context isn't persisted.
    //
    ASSERT( ClientContext->GenericObject.DirtyBits == 0);

    //
    // If the user didn't pass a handle in,
    //  open a thread or process token handle.
    //

    ClientContext->CreationType = AZP_CONTEXT_CREATED_FROM_TOKEN;

    if ( TokenHandle == NULL ) {

        if ( !OpenThreadToken( GetCurrentThread(),
                               TOKEN_QUERY | TOKEN_IMPERSONATE,
                               TRUE,
                               &ClientContext->TokenHandle ) ) {

            WinStatus = GetLastError();

            //
            // If there is not thread token,
            //  use the process token.
            //
            if ( WinStatus == ERROR_NO_TOKEN ) {
                if ( !OpenProcessToken( GetCurrentProcess(),
                                        TOKEN_DUPLICATE,
                                        &TempTokenHandle ) ) {

                    WinStatus = GetLastError();
                    AzPrint(( AZD_CRITICAL, "AzInitializeContextFromToken: Cannot OpenProcessToken %ld\n", WinStatus ));
                    goto Cleanup;
                }

                //
                // Need an impersonation token
                //
                if ( !DuplicateTokenEx( TempTokenHandle,
                                        TOKEN_QUERY | TOKEN_IMPERSONATE,
                                        NULL,
                                        SecurityImpersonation,
                                        TokenImpersonation,
                                        &ClientContext->TokenHandle ) ) {

                    WinStatus = GetLastError();
                    AzPrint(( AZD_CRITICAL, "AzInitializeContextFromToken: Cannot DuplicateTokenEx %ld\n", WinStatus ));
                    goto Cleanup;
                }

            } else {
                AzPrint(( AZD_CRITICAL, "AzInitializeContextFromToken: Cannot OpenThreadToken %ld\n", WinStatus ));
                goto Cleanup;
            }
        }

    //
    // If the user did pass a handle in,
    //  dup it
    //

    } else {

        if ( !GetTokenInformation( TokenHandle,
                                   TokenStatistics,
                                   &TokenStats,
                                   sizeof(TOKEN_STATISTICS),
                                   &Ignore ) ) {
            WinStatus = GetLastError();
            AzPrint(( AZD_ACCESS, "AzInitializeContextFromToken:  GetTokenInformation failed with %ld\n", WinStatus ));
            goto Cleanup;
        }

        dwDesiredAccess = TOKEN_QUERY | TOKEN_IMPERSONATE;

        if ( TokenStats.ImpersonationLevel > SecurityIdentification ) {

            ImpersonationLevel = SecurityImpersonation;

        } else {

            ImpersonationLevel = SecurityIdentification;
        }

        if ( !DuplicateTokenEx( TokenHandle,
                                dwDesiredAccess,
                                NULL,
                                ImpersonationLevel,
                                TokenImpersonation,
                                &ClientContext->TokenHandle ) ) {

            WinStatus = GetLastError();
            AzPrint(( AZD_CRITICAL, "AzInitializeContextFromToken: Cannot DuplicateTokenEx %ld\n", WinStatus ));
            goto Cleanup;
        }
    }

    //
    // Read the token authentication Id
    //

    if ( !GetTokenInformation( ClientContext->TokenHandle,
                               TokenStatistics,
                               &TokenStats,
                               sizeof(TOKEN_STATISTICS),
                               &Ignore ) ) {
        WinStatus = GetLastError();
        AzPrint(( AZD_ACCESS, "AzInitializeContextFromToken:  GetTokenInformation failed with %ld\n", WinStatus ));
        goto Cleanup;
    }

    ClientContext->LogonId = TokenStats.AuthenticationId;

    //
    // Initialize Authz
    //

    if ( !AuthzInitializeContextFromToken(
                0,      // No Flags
                ClientContext->TokenHandle,
                (((PAZP_APPLICATION)ApplicationHandle)->AuthzResourceManager),
                NULL,   // No expiration time
                Identifier,
                NULL,   // No dynamic group args
                &ClientContext->AuthzClientContext ) ) {

        WinStatus = GetLastError();
        AzPrint(( AZD_CRITICAL, "AzInitializeContextFromToken: Cannot AuthzInitializeContextFromToken %ld\n", WinStatus ));
        goto Cleanup;
    }


    //
    // Generate a client context creation audit based on the audit boolean.
    //

    if ( ((PAZP_APPLICATION) ApplicationHandle)->GenericObject.IsGeneratingAudits &&
         !AzpOpenToManageStore(AzAuthorizationStore) ) {

        WinStatus = AzpClientContextGenerateCreateSuccessAudit( ClientContext,
                                                                (PAZP_APPLICATION) ApplicationHandle );

        if ( WinStatus != NO_ERROR ) {
            AzPrint(( AZD_ACCESS, "AzpGenerateContextCreateAudit: Cannot ObCommonCreateObject %ld\n", WinStatus ));
            goto Cleanup;
        }

    }



    WinStatus = NO_ERROR;
    *ClientContextHandle = ClientContext;
    ClientContext = NULL;

    //
    // Free any local resources
    //
Cleanup:
    if ( ClientContext != NULL ) {
        AzCloseHandle( ClientContext, 0 );
    }
    if ( TempTokenHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( TempTokenHandle );
    }

    return WinStatus;
}

DWORD
AzpGetClientContextTokenS4U(
    IN LPCWSTR ClientName,
    IN LPCWSTR DomainName OPTIONAL,
    OUT PHANDLE pTokenHandle
    )
/*++

Routine Description:

        This routine tries to get an identify-level token for the user
        using KERB_S4U_LOGON authentication package.

Arguments:

        ClientName - Name of the user
        DomainName - An optional domain name for the user
        pTokenHandle - Handle to the acquired identify-level token

Return Value:

        NO_ERROR - The operation was successful
        ERROR_NOT_ENOUGH_MEMORY - lack of memory resources
        Other Status code returned from LsaLogonUser specific calls.

--*/
{ 
    
    DWORD WinStatus = NO_ERROR;
    NTSTATUS Status;
    NTSTATUS subStatus;

    HANDLE hLsa = INVALID_HANDLE_VALUE;
    LSA_STRING asProcessName;
    LSA_STRING asPackageName;
    ULONG ulAuthPackage;
    LUID luid;

    DWORD ClientNameLength = 0;
    DWORD DomainNameLength = 0;
    
    PKERB_S4U_LOGON pPackage = NULL;
    ULONG ulPackageSize = 0;

    TOKEN_SOURCE sourceContext;
    PVOID pProfileBuffer = NULL;
    ULONG ulProfileLength = 0;

    QUOTA_LIMITS quota;

    //
    // Validation
    //

    ASSERT( ClientName != NULL );

    ClientNameLength = (DWORD)(wcslen( ClientName )*sizeof(WCHAR));
    
    //
    // Setup the Authentication package
    //

    ulPackageSize = sizeof( KERB_S4U_LOGON );
    ulPackageSize += ClientNameLength;

    if ( DomainName ) {

        DomainNameLength = (DWORD)(wcslen( DomainName )*sizeof(WCHAR));
        ulPackageSize += DomainNameLength;
    }
    
    pPackage = (PKERB_S4U_LOGON) LocalAlloc(LMEM_FIXED, ulPackageSize);

    if ( pPackage == NULL ) {

        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    pPackage->MessageType = KerbS4ULogon;
    pPackage->Flags = 0;

    pPackage->ClientUpn.Length = (USHORT)ClientNameLength;
    pPackage->ClientUpn.MaximumLength = (USHORT)ClientNameLength;
    pPackage->ClientUpn.Buffer = (LPWSTR)(pPackage + 1);

    RtlCopyMemory(
        pPackage->ClientUpn.Buffer,
        ClientName,
        ClientNameLength
        );
    
    if ( DomainName ) {

        pPackage->ClientRealm.Length = (USHORT)DomainNameLength;
        pPackage->ClientRealm.MaximumLength = (USHORT)DomainNameLength;
        pPackage->ClientRealm.Buffer = (LPWSTR)
            (((PBYTE)(pPackage->ClientUpn.Buffer)) + pPackage->ClientUpn.Length);
        
        RtlCopyMemory(
            pPackage->ClientRealm.Buffer,
            DomainName,
            DomainNameLength
            );

    } else {

        pPackage->ClientRealm.Length = 0;
        pPackage->ClientRealm.MaximumLength = 0;
        pPackage->ClientRealm.Buffer = NULL;
    }

    //
    // Initialize process name
    //
    
    RtlInitString(
        &asProcessName,
        "AzManAPI"
        );

    //
    // Register with Lsa
    //

    Status = LsaConnectUntrusted(
                 &hLsa
                 );

    if ( !NT_SUCCESS( Status ) ) {

        WinStatus = LsaNtStatusToWinError( Status );
        goto Cleanup;
    }

    //
    // Get the Autherntication package
    //

    
    RtlInitString( &asPackageName, MICROSOFT_KERBEROS_NAME_A );


    Status = LsaLookupAuthenticationPackage(
                 hLsa,
                 &asPackageName,
                 &ulAuthPackage
                 );

    if ( !NT_SUCCESS( Status ) ) {
        
        WinStatus = LsaNtStatusToWinError( Status );
        goto Cleanup;
    }

    //
    // Prepare the source context
    //

    RtlCopyMemory(
        sourceContext.SourceName,
        "AzRoles ",
        sizeof(sourceContext.SourceName)
        );
    
    Status = NtAllocateLocallyUniqueId(
                 &sourceContext.SourceIdentifier
                 );

    if ( !NT_SUCCESS( Status ) ) {

        WinStatus = RtlNtStatusToDosError( Status );
        goto Cleanup;

    }

    //
    // Now that everything is set up, do the actual logon
    //

    Status = LsaLogonUser(
                 hLsa,
                 &asPackageName,
                 Network,
                 ulAuthPackage,
                 pPackage,
                 ulPackageSize,
                 0,
                 &sourceContext,
                 &pProfileBuffer,
                 &ulProfileLength,
                 &luid,
                 pTokenHandle,
                 &quota,
                 &subStatus
                 );

    if ( !NT_SUCCESS( Status ) ) {

        WinStatus = LsaNtStatusToWinError( Status );
        goto Cleanup;

    }
    
    WinStatus = NO_ERROR;

Cleanup:

    if ( pPackage ) {

        LocalFree( pPackage );
    }

    if ( pProfileBuffer ) {
        
        LsaFreeReturnBuffer( pProfileBuffer );

    }

    if ( hLsa != INVALID_HANDLE_VALUE ) {

        LsaDeregisterLogonProcess( hLsa );

    }

    return WinStatus;
}

DWORD
WINAPI
AzInitializeContextFromName(
    IN AZ_HANDLE ApplicationHandle,
    IN LPWSTR DomainName OPTIONAL,
    IN LPWSTR ClientName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ClientContextHandle
    )
/*++


Routine Description:

    This routine creates a client context based on a passed in token handle or on
    the impersonation token of the caller's thread.

Arguments:

    ApplicationHandle - Specifies a handle to the application object that
        is this client context applies to.

    DomainName - Domain in which the user account lives. This may be NULL.

    ClientName - Name of the user account. Together these two represent a user
    account which may be looked up using LookupAccountName.

    Reserved - Reserved.  Must by zero.

    ClientContextHandle - Return a handle to the client context
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_SUPPORTED - Function not supported in current store mode (ie, manage store)
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    DWORD WinStatus;
    LUID Identifier = {0};
    PAZP_CLIENT_CONTEXT ClientContext = NULL;
    DWORD SidSize = SECURITY_MAX_SID_SIZE;
    PWCHAR LocalDomainBuffer[MAX_COMPUTERNAME_LENGTH+1];
    DWORD DomainSize = MAX_COMPUTERNAME_LENGTH;
    SID_NAME_USE SidType = SidTypeUnknown;
    DWORD ClientNameSize = 0;
    DWORD DomainNameSize = 0;
    PAZP_AZSTORE AzAuthorizationStore = (PAZP_AZSTORE) ParentOfChild(
        &((PAZP_APPLICATION)ApplicationHandle)->GenericObject );
    NTSTATUS Status;
    DWORD Ignore = 0;
    PWCHAR pSamCompatName = NULL;
    DWORD SamCompatNameSize = 0;
    HANDLE hToken = INVALID_HANDLE_VALUE;

    //
    // If the store is in manage mode only, then no runtime is allowed
    // Return ERROR_NOT_SUPPORTED
    //

    if ( AzpOpenToManageStore(AzAuthorizationStore) ) {

        WinStatus = ERROR_NOT_SUPPORTED;
        AzPrint(( AZD_CRITICAL, "AzInitializeContextFromName: Cannot initialize context since store is in manage mode %ld\n",
                  WinStatus
                  ));
        goto Cleanup;
    }

    //
    // Try to logon user using KERB_S4U_LOGON.  This will give
    // us an identify-level token for the user.  Use this to 
    // create the client context from token.  If S4U is not supported
    // then use LookupAccountName/SID to intialize Authz using the SID
    //

    WinStatus = AzpGetClientContextTokenS4U(
                    ClientName,
                    ((DomainName == NULL)? NULL:((wcslen(DomainName) == 0)?NULL:DomainName)),
                    &hToken
                    );
    
    if ( WinStatus == NO_ERROR ) {
        
        WinStatus = AzInitializeContextFromToken(
                        ApplicationHandle,
                        hToken,
                        Ignore,
                        ClientContextHandle
                        );
        
        if ( WinStatus != NO_ERROR ) {
            
            AzPrint(( AZD_CRITICAL,
                      "AzInitializeContextFromName: Cannot AzInitializeFromToken %ld\n",
                      WinStatus
                      ));
            goto Cleanup;
        }       
        
        return WinStatus;
    }
                        
    //
    // Call the common routine to create our client context object
    //


    WinStatus = ObCommonCreateObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->ClientContexts),
                    OBJECT_TYPE_CLIENT_CONTEXT,
                    NULL,
                    Reserved,
                    (PGENERIC_OBJECT *) &ClientContext );

    if ( WinStatus != NO_ERROR ) {
        AzPrint(( AZD_CRITICAL, "AzInitializeContextFromName: Cannot ObCommonCreateObject %ld\n", WinStatus ));
        goto Cleanup;
    }

    //
    // Client context isn't persisted.
    //
    ASSERT( ClientContext->GenericObject.DirtyBits == 0);


    ClientContext->CreationType = AZP_CONTEXT_CREATED_FROM_NAME;

    //
    // Allocate a LUID to represent out client. We need this for linking
    // audits.
    //

    Status = NtAllocateLocallyUniqueId(&ClientContext->LogonId);

    if ( !NT_SUCCESS( Status )) {
        WinStatus =  RtlNtStatusToDosError( Status );
        AzPrint(( AZD_CRITICAL, "AzInitializeContextFromName: Cannot allocate LUID %ld\n", WinStatus ));
        goto Cleanup;
    }

    //
    // If passed in name is not in UPN (detected by presence of "@") or SamCompat (detected by
    // presence of "\") format, then we need to  append it to the passed in domain name.
    //

    if ( ((DomainName != NULL) && (*DomainName != NULL)) &&
         ((wcschr( ClientName, L'@' ) == NULL) && (wcschr( ClientName, L'\\' ) == NULL))
       ) {

        SamCompatNameSize = (DWORD)((wcslen(DomainName) + wcslen(ClientName) + 2) * sizeof(WCHAR));
        
        pSamCompatName = (PWCHAR) AzpAllocateHeap( SamCompatNameSize, "TCLNTNAM" );

        if ( pSamCompatName == NULL ) {

           WinStatus = ERROR_NOT_ENOUGH_MEMORY;
           goto Cleanup;
        }
        
        wnsprintf( pSamCompatName, SamCompatNameSize, L"%ws\\%ws", DomainName, ClientName );
    } 

    //
    // Lookup the name of client name.
    //

    if ( !LookupAccountNameW(
              NULL,
              pSamCompatName?pSamCompatName:ClientName,
              ClientContext->SidBuffer,
              &SidSize,
              (LPWSTR) LocalDomainBuffer,
              &DomainSize,
              &SidType ) ) {

        WinStatus = GetLastError();
        ASSERT( WinStatus != ERROR_INSUFFICIENT_BUFFER );
        AzPrint(( AZD_CRITICAL, "AzInitializeContextFromName: LookupAccoutName failed with %ld\n", WinStatus ));

    }

    //
    // We only support SidTypeUser account type.
    //

    if ( SidType != SidTypeUser ) {
        WinStatus = ERROR_INVALID_PARAMETER;
        AzPrint(( AZD_CRITICAL, "AzInitializeContextFromName: Invalid user type - expected SIdTypeUser, got %ld\n", SidType ));
        goto Cleanup;
    }

    //
    // Do the reverse lookup and store the domain name and the client name.
    // We have to do this since the domain name is optional.
    //  Get the size of the buffer in the first call.
    //

    if ( !LookupAccountSidW(
              NULL,
              ClientContext->SidBuffer,
              NULL,
              &ClientNameSize,
              NULL,
              &DomainNameSize,
              &SidType ) ) {

        WinStatus = GetLastError();

        if ( WinStatus != ERROR_INSUFFICIENT_BUFFER ) {
            goto Cleanup;
        }

        //
        // Note that these get freed when then client context is released - even in
        // error cases in this routine itself.
        //

        //
        // Since LookupAccountSid returns size in characters and not bytes...
        //

        DomainNameSize *= sizeof( WCHAR );
        ClientNameSize *= sizeof( WCHAR );

        ClientContext->DomainName = (LPWSTR) AzpAllocateHeap( DomainNameSize, "CNDOMNM" );

        if  ( ClientContext->DomainName == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        ClientContext->ClientName = (LPWSTR) AzpAllocateHeap( ClientNameSize, "CNCLNTNM" );

        if ( ClientContext->ClientName == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        if ( !LookupAccountSidW(
                  NULL,
                  ClientContext->SidBuffer,
                  ClientContext->ClientName,
                  &ClientNameSize,
                  ClientContext->DomainName,
                  &DomainNameSize,
                  &SidType ) ) {

            WinStatus = GetLastError();
            goto Cleanup;
        }
    } else {

        //
        // This can not happen since we supplied a NULL buffer.
        //

        ASSERT( FALSE );
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize Authz
    //

    if ( !AuthzInitializeContextFromSid(
                0,      // No Flags
                ClientContext->SidBuffer,
                (((PAZP_APPLICATION)ApplicationHandle)->AuthzResourceManager),
                NULL,   // No expiration time
                Identifier,
                NULL,   // No dynamic group args
                &ClientContext->AuthzClientContext ) ) {

        WinStatus = GetLastError();
        AzPrint(( AZD_CRITICAL, "AzInitializeContextFromToken: Cannot AuthzInitializeContextFromToken %ld\n", WinStatus ));
        goto Cleanup;
    }


    //
    // Generate a client context creation audit based on the audit boolean.
    //

    if ( ((PAZP_APPLICATION) ApplicationHandle)->GenericObject.IsGeneratingAudits &&
         !AzpOpenToManageStore(AzAuthorizationStore) ) {

        WinStatus = AzpClientContextGenerateCreateSuccessAudit( ClientContext,
                                                                (PAZP_APPLICATION) ApplicationHandle );

        if ( WinStatus != NO_ERROR ) {
            AzPrint(( AZD_ACCESS, "AzpGenerateContextCreateAudit: Cannot ObCommonCreateObject %ld\n", WinStatus ));
            goto Cleanup;
        }

    }


    WinStatus = NO_ERROR;
    *ClientContextHandle = ClientContext;
    ClientContext = NULL;

    //
    // Free any local resources
    //
Cleanup:

    if ( pSamCompatName != NULL ) {

        AzpFreeHeap( pSamCompatName ) ;
    }

    if ( hToken != INVALID_HANDLE_VALUE ) {

        CloseHandle( hToken );
    }

    if ( ClientContext != NULL ) {
        AzCloseHandle( ClientContext, 0 );
    }


    return WinStatus;
}

DWORD
WINAPI
AzInitializeContextFromStringSid(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR SidString,
    IN DWORD lOptions,
    OUT PAZ_HANDLE ClientContextHandle
    )
/*++


Routine Description:

    This routine creates a client context based on a passed in SID string.
    Note, the sid string can be any arbitary SID and the lOptions will indicate
    if Lldap group should be skipped (for the arbitary SID)

    if AZ_CLIENT_CONTEXT_SKIP_GROUP is true, we will skip the ldap group check
    even if this is a valid NT user sid.

    if AZ_CLIENT_CONTEXT_SKIP_GROUP is false, we will require the SID string is
    a valid NT user sid (LookupSid must be able to find the domain name and
    client name).

Arguments:

    ApplicationHandle - Specifies a handle to the application object that
        is this client context applies to.

    SidString - Sid string of the account.

    lOptions - options for the method
                    AZ_CLIENT_CONTEXT_SKIP_GROUP

    ClientContextHandle - Return a handle to the client context
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    DWORD WinStatus;
    LUID Identifier = {0};
    PAZP_CLIENT_CONTEXT ClientContext = NULL;
    PSID pAccountSid = NULL;
    NTSTATUS Status;

    LPWSTR DomainName = NULL;
    LPWSTR ClientName = NULL;
    DWORD DomainNameSize = 0;
    DWORD ClientNameSize = 0;
    SID_NAME_USE SidType = SidTypeUnknown;

    PAZP_AZSTORE AzAuthorizationStore = (PAZP_AZSTORE) ParentOfChild(
        &((PAZP_APPLICATION)ApplicationHandle)->GenericObject );
    //
    // check parameter
    //
    if ( SidString == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // If the store is in manage mode only, then no runtime is allowed
    // Return ERROR_NOT_SUPPORTED
    //

    if ( AzpOpenToManageStore(AzAuthorizationStore) ) {

        WinStatus = ERROR_NOT_SUPPORTED;
        AzPrint(( AZD_CRITICAL, "AzInitializeContextFromStringSid: Cannot initialize context since store is in manage mode %ld\n",
                  WinStatus
                  ));
        goto Cleanup;
    }

    //
    // Lookup the SID (binary) of the SID string.
    //
    if ( !ConvertStringSidToSidW(
              SidString,
              &pAccountSid) ) {

        WinStatus = GetLastError();
        AzPrint(( AZD_CRITICAL, "AzInitializeContextFromStringSid: ConvertSidStringToSid failed with %ld\n", WinStatus ));
        goto Cleanup;

    }

    //
    // if flag AZ_CLIENT_CONTEXT_SKIP_GROUP is not set
    // we assume this ia a valid NT user account
    // check if the SID is a valid NT account
    //

    if ( !(lOptions & AZ_CLIENT_CONTEXT_SKIP_GROUP) ) {

        if ( !LookupAccountSidW(
                  NULL,
                  pAccountSid,
                  NULL,
                  &ClientNameSize,
                  NULL,
                  &DomainNameSize,
                  &SidType ) ) {

            //
            // should get ERROR_INSUFFICIENT_BUFFER if the account is resolved
            //
            WinStatus = GetLastError();

            if ( WinStatus != ERROR_INSUFFICIENT_BUFFER ) {
                //
                // the SID string cannot be resolved
                //
                goto Cleanup;
            }

            //
            // Since LookupAccountSid returns size in characters and not bytes...
            //

            DomainNameSize *= sizeof( WCHAR );
            ClientNameSize *= sizeof( WCHAR );

            DomainName = (LPWSTR) AzpAllocateHeap( DomainNameSize, "CNDOMNM" );

            if  ( DomainName == NULL ) {
                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            ClientName = (LPWSTR) AzpAllocateHeap( ClientNameSize, "CNCLNTNM" );

            if ( ClientName == NULL ) {
                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            if ( !LookupAccountSidW(
                      NULL,
                      pAccountSid,
                      ClientName,
                      &ClientNameSize,
                      DomainName,
                      &DomainNameSize,
                      &SidType ) ) {

                WinStatus = GetLastError();
                AzPrint(( AZD_CRITICAL, "AzInitializeContextFromStringSid: LookupAccountSid failed with %ld\n", WinStatus ));
                goto Cleanup;
            }

            //
            // We only support SidTypeUser account type.
            //

            if ( SidType != SidTypeUser ) {
                WinStatus = ERROR_INVALID_PARAMETER;
                AzPrint(( AZD_CRITICAL, "AzInitializeContextFromStringSid: Invalid user type - expected SIdTypeUser, got %ld\n", SidType ));
                goto Cleanup;
            }

        } else {

            //
            // This can not happen since we supplied a NULL buffer.
            //

            ASSERT( FALSE );
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // hand the call to InitializeContextFromName
        //
        WinStatus = AzInitializeContextFromName(
                             ApplicationHandle,
                             DomainName,
                             ClientName,
                             0,
                             ClientContextHandle
                             );

        //
        // the client context is handled by FromName
        // we are done now so go to clean up
        //
        goto Cleanup;
    }

    //
    // when it's get here, the client context will be initialzied from SID
    // and ldap group check will be skipped later on during access check
    //
    // Call the common routine to create our client context object
    //

    WinStatus = ObCommonCreateObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->ClientContexts),
                    OBJECT_TYPE_CLIENT_CONTEXT,
                    NULL,
                    0,
                    (PGENERIC_OBJECT *) &ClientContext );

    if ( WinStatus != NO_ERROR ) {
        AzPrint(( AZD_CRITICAL, "AzInitializeContextFromStringSid: Cannot ObCommonCreateObject %ld\n", WinStatus ));
        goto Cleanup;
    }

    //
    // Client context isn't persisted.
    //
    ASSERT( ClientContext->GenericObject.DirtyBits == 0);

    //
    // Allocate a LUID to represent out client. We need this for linking
    // audits.
    //

    Status = NtAllocateLocallyUniqueId(&ClientContext->LogonId);

    if ( !NT_SUCCESS( Status )) {
        WinStatus =  RtlNtStatusToDosError( Status );
        AzPrint(( AZD_CRITICAL, "AzInitializeContextFromStringSid: Cannot allocate LUID %ld\n", WinStatus ));
        goto Cleanup;
    }

    ClientContext->CreationType = AZP_CONTEXT_CREATED_FROM_SID;

    //
    // copy the SID to sid buffer
    //
    if ( !CopySid (
            SECURITY_MAX_SID_SIZE,
            (PSID)(ClientContext->SidBuffer),
            pAccountSid
            ) ) {

        WinStatus = GetLastError();
        AzPrint(( AZD_CRITICAL, "AzInitializeContextFromStringSid: CopySid failed with %ld\n", WinStatus ));
        goto Cleanup;

    }

    //
    // save the SID string in the client name buffer (for auditing purpose)
    //

    ClientNameSize = (DWORD)wcslen(SidString);

    ClientContext->ClientName = (LPWSTR) AzpAllocateHeap( (ClientNameSize+1)*sizeof(WCHAR), "CNCLNTNM" );

    if ( ClientContext->ClientName == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    wcsncpy(ClientContext->ClientName, SidString, ClientNameSize);
    ClientContext->ClientName[ClientNameSize] = L'\0';

    //
    // Initialize Authz
    //

    if ( !AuthzInitializeContextFromSid(
                AUTHZ_SKIP_TOKEN_GROUPS,
                ClientContext->SidBuffer,
                (((PAZP_APPLICATION)ApplicationHandle)->AuthzResourceManager),
                NULL,   // No expiration time
                Identifier,
                NULL,   // No dynamic group args
                &ClientContext->AuthzClientContext ) ) {

        WinStatus = GetLastError();
        AzPrint(( AZD_CRITICAL, "AzInitializeContextFromToken: Cannot AuthzInitializeContextFromToken %ld\n", WinStatus ));
        goto Cleanup;
    }


    //
    // Generate a client context creation audit based on the audit boolean.
    //

    if ( ((PAZP_APPLICATION) ApplicationHandle)->GenericObject.IsGeneratingAudits ) {

        WinStatus = AzpClientContextGenerateCreateSuccessAudit( ClientContext,
                                                                (PAZP_APPLICATION) ApplicationHandle );

        if ( WinStatus != NO_ERROR ) {
            AzPrint(( AZD_ACCESS, "AzpGenerateContextCreateAudit: Cannot ObCommonCreateObject %ld\n", WinStatus ));
            goto Cleanup;
        }

    }


    WinStatus = NO_ERROR;
    *ClientContextHandle = ClientContext;
    ClientContext = NULL;

    //
    // Free any local resources
    //
Cleanup:

    if ( ClientContext != NULL ) {
        AzCloseHandle( ClientContext, 0 );
    }

    if ( pAccountSid ) {
        LocalFree(pAccountSid);
    }

    if ( DomainName ) {
        AzpFreeHeap(  DomainName );
    }

    if ( ClientName ) {
        AzpFreeHeap(  ClientName );
    }

    return WinStatus;
}

DWORD
WINAPI
AzContextAccessCheck(
    IN AZ_HANDLE ApplicationObjectHandle,
    IN DWORD ApplicationSequenceNumber,
    IN AZ_HANDLE ClientContextHandle,
    IN LPCWSTR ObjectName,
    IN ULONG ScopeCount,
    IN LPCWSTR * ScopeNames OPTIONAL,
    IN ULONG OperationCount,
    IN PLONG Operations,
    OUT ULONG *Results,
    OUT LPWSTR *BusinessRuleString OPTIONAL,
    IN VARIANT *ParameterNames OPTIONAL,
    IN VARIANT *ParameterValues OPTIONAL,
    IN VARIANT *InterfaceNames OPTIONAL,
    IN VARIANT *InterfaceFlags OPTIONAL,
    IN VARIANT *Interfaces OPTIONAL
    )
/*++

Routine Description:

    The application calls the AccessCheck function whenever it wants to check if a
    particular operation is allowed to the client.

    The specified Operation may require application group membership to be evaluated.
    The application group membership is added to the client context so that it need not
    be evaluated again on subsequent AccessCheck calls on this same client context.

    The AccessCheck method may not be called by a BizRule.

    The AccessCheck function does not directly support the concept of "maximum allowed".

    If the script engine timeout is set to 0, then biz rules evaluated as returning FALSE.


Arguments:

    ApplicationObjectHandle - Handle to the parent application object of the client context object

    ApplicationSequenceNumber - Sequence number on the parent application object

    ClientContextHandle - Specifies a handle to the client context object indentifying
        the client.

    ObjectName - Specifies the object being accessed. (Meant for auditing purposes)

    ScopeCount - Specifies the number of elements in the ScopeNames array.
                 Some application do not create scopes, and treat al objects as if in the
                 first scope. 0 is passed in if there are no scopes defined

    ScopeNames - Specifies an optional list of scope names.  Must be
                 NULL if ScopeCount is 0.  ERROR_INVALID_PARAMETER is returned otherwise.

    OperationCount - Specifies the number of elements in the Operations array.

    Operations - Specifies which operations to check access for.  Each element
        is the Operation Id of an operation in the AzApplication policy.

        An operation should apear only once in this array.  If not, the first occurrence
        in the matching Results array will have the result set correctly.  The
        value in the Results array is undefined for the other occurrences.

    Results - Returns an array of results of the access check.  Each element in
        this array corresponds to the corresponding element in the Operations array.
        A value of NO_ERROR indicates that the access is granted.
        A value of ERROR_ACCESS_DENIED indicates that the access is not granted.
        Other values indicate that access should not be granted and describes the
        reason.  For instance, permission to perform this operation may have required
        the evaluation of an LDAP_QUERY group and the domain controller may have been
        unavailable.

    BusinessRuleString - Returns the string set by any BizRules via the
        SetBusinessRuleReturnString method.
        Any returned sting must be freed by calling AzFreeMemory.

    ParameterNames - Specifies an array of names of the parameters.
        There are ParameterCount elements in the array. The name defines a way for the
        BizRule script to reference the corresponding element in the ParameterValues array.
        See IAzBizRuleContext::GetParameter for more information.
        This parameter may be NULL.  This parameter may be a pointer to an empty variant.  This
        parameter may be a pointer to a single dimension safe array variant where each element is a
        BSTR.

    ParameterValues - Specifies an array of values of the parameters.  Each element in this array
        contains the value of the parameter named by the corresponding element in ParameterNames.
        Each element in this array may be of any type.

    InterfaceNames - Specifies an array of names. Each element specifies the name that
        the interface will be known by in the script.  AccessCheck will call the
        IActiveScript::AddNamedItem method for each name.

    InterfaceFlags - Specifies an array of flags that will be passed to
        IActiveScript::AddNamedItem.  Each element matches the corresponding element
        in the InterfaceNames array.


    Interfaces - Specifies an array of IUnknown interfaces.  These interfaces will be
        made available to the BizRule script.  In addition, these interfaces should
        support the IActiveScriptSite interface.  During BizRule script evaluation,
        anytime the script host engine calls the IActiveScriptSite interface supplied
        by AccessCheck, AccessCheck will forward those calls to the IActiveScriptSite
        interface specified here.  For instance, AccessCheck calls the application's
        IActiveScriptSite::GetItemInfo in AccessChecks GetItemInfo routine if the
        ItemName string passed to me was an InterfaceNames from above.

        Each element matches the corresponding element in the InterfaceNames array.


Return Value:

    Returns the status of the function.  Does not indicate where the operation is permitted.  NO_ERROR is returned whether permission is granted or not.

    NO_ERROR - The operation was successful
    ERROR_INVALID_PARAMETER - If ScopeCount is 0, but there are ScopeName present
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    ERROR_NOT_FOUND - One of the ScopeNames or Operations is not defined in the
        AZ policy database.
    OLESCRIPT_E_SYNTAX - The syntax of the bizrule is invalid

    Other status codes

--*/
{
    DWORD WinStatus;

    ULONG i;

    BOOLEAN CritSectLocked = FALSE;
    ACCESS_CHECK_CONTEXT AcContext;
    ULONG LocalIndex;
    BOOLEAN LocalOnly;
    BOOLEAN BizrulesOk;

    LPBYTE AllocatedBuffer = NULL;
    PULONG TempAllocatedMemory;
    ULONG MemoryRequired;
    ULONG TaskInfoArraySize;

    ULONG RoleIndex;
    PAZP_ROLE Role;
    PAZ_ROLE_INFO RoleInfo;

    ULONG RoleListIndex;
#define ROLE_LIST_COUNT 2
    PGENERIC_OBJECT_HEAD RoleLists[ROLE_LIST_COUNT];
    ULONG RoleListCount;

    ULONG ProcessedRoleCount = 0;

    BOOLEAN CallAgain;

    //
    // Initialization
    //

    RtlZeroMemory( &AcContext, sizeof( AcContext ) );

    //
    // Grab the locks needed.
    //
    // Note, that even though the global lock is grabbed here, it is dropped during
    //  BizRule and LDAP Queries.  By ensuring that the global lock isn't held while
    //  going off-machine, the policy cache can be updated via the change notification
    //  or the AzUpdateCache mechanisms.
    //
    //

    if ( ApplicationSequenceNumber != AzpRetrieveApplicationSequenceNumber( ApplicationObjectHandle ) ) {

        WinStatus = ERROR_INVALID_HANDLE;
        goto Cleanup;
    }

    AzpLockResourceShared( &AzGlResource );

    //
    // validate that the ScopeCount and ScopeNames match
    //

    if ( ScopeCount == 0 &&
         ScopeNames != NULL ) {

        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( (PGENERIC_OBJECT)ClientContextHandle,
                                           FALSE,   // Don't allow deleted objects
                                           FALSE,   // No cache to refresh
                                           OBJECT_TYPE_CLIENT_CONTEXT );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    AcContext.ClientContext = (PAZP_CLIENT_CONTEXT) ClientContextHandle;
    AcContext.Application = (PAZP_APPLICATION) ParentOfChild( &AcContext.ClientContext->GenericObject );

    //
    // Grab the lock on the client context (observing locking order)
    //
    // This locking order allows the context crit sect to be locked for the life of the
    //  access check call and for the global lock to be periodically dropped when we
    //  go off-machine.
    //

    AzpUnlockResource( &AzGlResource );
    SafeEnterCriticalSection( &AcContext.ClientContext->CritSect );
    CritSectLocked = TRUE;
    AzpLockResourceShared( &AzGlResource );

    //
    // If group memberships have changed,
    //  flush the cache.
    //
    // This code doesn't prevent the group membership from changing *during* the access check
    // call.  That's fine.  It does protect against changes made prior to the access check call.
    //

    if ( AcContext.ClientContext->GroupEvalSerialNumber !=
         AcContext.ClientContext->GenericObject.AzStoreObject->GroupEvalSerialNumber ) {

        AzpFlushGroupEval( AcContext.ClientContext );

        //
        // Update the serial number to the new serial number
        //

        AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: GroupEvalSerialNumber changed from %ld to %ld\n",
                  AcContext.ObjectNameString.String,
                  AcContext.ClientContext->GroupEvalSerialNumber,
                  AcContext.ClientContext->GenericObject.AzStoreObject->GroupEvalSerialNumber ));

        AcContext.ClientContext->GroupEvalSerialNumber =
            AcContext.ClientContext->GenericObject.AzStoreObject->GroupEvalSerialNumber;
    }


    //
    // Capture the object name
    //

    WinStatus = AzpCaptureString( &AcContext.ObjectNameString,
                                  ObjectName,
                                  AZ_MAX_SCOPE_NAME_LENGTH,
                                  FALSE ); // NULL not ok

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }



    //
    // Capture the scopes
    //

    if ( ScopeCount > 0 ) {

        WinStatus = AzpCaptureString( &AcContext.ScopeNameString,
                                      *ScopeNames,
                                      AZ_MAX_SCOPE_NAME_LENGTH,
                                      FALSE ); // NULL not ok

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = ObReferenceObjectByName( &AcContext.Application->Scopes,
                                             &AcContext.ScopeNameString,
                                             AZP_FLAGS_REFRESH_CACHE,
                                             (PGENERIC_OBJECT *)&AcContext.Scope );

        if ( WinStatus != NO_ERROR ) {

            //
            // if a scope cannot be found, ObReferenceObjectByName will
            // return ERROR_NOT_FOUND. We need to mask it to more specific error
            // code before returning to the caller
            //

            if ( WinStatus == ERROR_NOT_FOUND ) {

                WinStatus = ERROR_SCOPE_NOT_FOUND;
            }

            goto Cleanup;
        }

        //
        // If the scope referenced does not have its children loaded into cache,
        // then do so now.  However, if the scope has not been submitted, then neither
        // have its children, and they are already in cache
        //

        if ( !((PGENERIC_OBJECT)(AcContext.Scope))->AreChildrenLoaded ) {

            //
            // grab the resource lock exclusively
            //

            AzpLockResourceSharedToExclusive( &AzGlResource );

            WinStatus = AzPersistUpdateChildrenCache(
                (PGENERIC_OBJECT)AcContext.Scope
                );

            AzpLockResourceExclusiveToShared( &AzGlResource );

            if ( WinStatus != NO_ERROR ) {

                AzPrint(( AZD_ACCESS_MORE,
                          "AzAccessCheck: Failed to load children for %ws: %ld",
                          ((PGENERIC_OBJECT)AcContext.Scope)->ObjectName,
                          WinStatus
                          ));
                goto Cleanup;
            }

        }

    } else {

        AzpInitString( &AcContext.ScopeNameString, NULL );

    }

    //
    // Capture the Operations
    //

    if ( OperationCount == 0 ) {
        AzPrint(( AZD_INVPARM, "AzAccessCheck: %ws: invalid OperationCount %ld\n", AcContext.ObjectNameString.String, OperationCount ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    SafeAllocaAllocate( AcContext.OperationObjects,
                        OperationCount*(sizeof(PAZP_OPERATION) + sizeof(BOOLEAN)) );

    if ( AcContext.OperationObjects == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory( AcContext.OperationObjects,
                   OperationCount*(sizeof(PAZP_OPERATION) + sizeof(BOOLEAN)) );

    AcContext.OperationWasProcessed = (PBOOLEAN)(&AcContext.OperationObjects[OperationCount]);
    AcContext.OperationCount = OperationCount;
    AcContext.Results = Results;

    for ( i=0; i<AcContext.OperationCount; i++ ) {

        //
        // The operation isn't allowed until proven otherwise
        //

        Results[i] = NOT_YET_DONE;

        //
        // Find the specific operation
        //

        WinStatus = AzpReferenceOperationByOpId( AcContext.Application,
                                                 Operations[i],
                                                 TRUE,  // Refresh the cache if it needs it
                                                 &AcContext.OperationObjects[i] );

        if ( WinStatus != NO_ERROR ) {

            //
            // if an operation cannot be found, AzpReferenceOperationByOpId will
            // return ERROR_NOT_FOUND. We need to mask it to more specific error
            // code before returning to the caller
            //

            if ( WinStatus == ERROR_NOT_FOUND ) {

                WinStatus = ERROR_INVALID_OPERATION;
            }

            goto Cleanup;
        }

    }

    //
    // Capture the Bizrule parameters
    //

    if ( BusinessRuleString != NULL ) {
        *BusinessRuleString = NULL;
    }

    WinStatus = AzpCaptureBizRuleParameters( &AcContext, ParameterNames, ParameterValues );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Allocate an array to hold the list of used paramaters
    //

    if ( AcContext.ParameterCount != 0 ) {

        // Allocate the array on the stack
        SafeAllocaAllocate( AcContext.UsedParameters, AcContext.ParameterCount * sizeof(*AcContext.UsedParameters) );

        if ( AcContext.UsedParameters == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        RtlZeroMemory( AcContext.UsedParameters, AcContext.ParameterCount * sizeof(*AcContext.UsedParameters) );

    }

    //
    // Capture the Interfaces parameters
    //

    WinStatus = AzpCaptureBizRuleInterfaces( &AcContext, InterfaceNames, InterfaceFlags, Interfaces );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Determine if we've already cached the result of this access check
    //

    if ( AzpCheckOperationCache( &AcContext ) ) {

        // Entire access check was satisfied from cache
        WinStatus = NO_ERROR;
        goto Cleanup;
    }



    //
    // Compute the roles that apply to the scope
    //
    //  There are two such lists: the roles that are children of the scope, and
    //      the roles that are children of the application the scope is in.
    //
    //  If there was no scope specified, the just the roles for the application
    //  are set
    //

    RoleLists[0] = &AcContext.Application->Roles;
    AcContext.RoleCount = RoleLists[0]->ObjectCount;
    RoleListCount = 1;

    if ( ScopeCount > 0 ) {
        RoleLists[RoleListCount] = &AcContext.Scope->Roles;
        AcContext.RoleCount += RoleLists[RoleListCount]->ObjectCount;
        RoleListCount++;
    }

    //
    // If there are no applicable roles,
    //  access is denied to all operations
    //

    if ( AcContext.RoleCount == 0 ) {
        WinStatus = NO_ERROR;
        AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: There are no roles for this scope\n", AcContext.ObjectNameString.String,
                                   AcContext.ScopeNameString.String ? AcContext.ScopeNameString.String : L""));
        goto Cleanup;
    }

    //
    // Capture the roles.
    //  Create references so we can drop AzGlResource when we hit the wire
    //

    SafeAllocaAllocate( AcContext.RoleInfo, AcContext.RoleCount*sizeof(*AcContext.RoleInfo) );

    if ( AcContext.RoleInfo == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RoleIndex = 0;

    MemoryRequired = 0;
    TaskInfoArraySize = 0;

    //
    // boolean to indicate if the requested role is already found
    //
    BOOL bFoundRole=FALSE;

    for ( RoleListIndex=0; RoleListIndex<RoleListCount; RoleListIndex++ ) {
        PLIST_ENTRY ListEntry;

        for ( ListEntry = RoleLists[RoleListIndex]->Head.Flink ;
              ListEntry != &RoleLists[RoleListIndex]->Head ;
              ListEntry = ListEntry->Flink ,
                    RoleIndex++ ) {

            PGENERIC_OBJECT GenericObject;

            //
            // Grab a pointer to the next role to process
            //

            RoleInfo = &AcContext.RoleInfo[RoleIndex];
            GenericObject = CONTAINING_RECORD( ListEntry,
                                               GENERIC_OBJECT,
                                               Next );

            ASSERT( GenericObject->ObjectType == OBJECT_TYPE_ROLE );

            //
            // Grab a reference
            //
            InterlockedIncrement( &GenericObject->ReferenceCount );
            AzpDumpGoRef( "Role reference", GenericObject );
            Role = (PAZP_ROLE) GenericObject;

            //
            // Initialize the RoleInfo entry
            //
            RoleInfo = &AcContext.RoleInfo[RoleIndex];
            RoleInfo->Role = Role;
            RoleInfo->RoleProcessed = FALSE;
            RoleInfo->SidsProcessed = FALSE;
            RoleInfo->ResultStatus = NOT_YET_DONE;

            //
            // if a role is specified in the client context
            // only perform access check on this role
            //
            if ( AcContext.ClientContext->RoleName.StringSize != 0 &&
                ( bFoundRole ||
                  !AzpEqualStrings( &(Role->GenericObject.ObjectName->ObjectName),
                                     &AcContext.ClientContext->RoleName ) ) ) {
                //
                // this role is not the one, skip it
                //

                AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: This role %ws is not the requested role %ws \n", Role->GenericObject.ObjectName->ObjectName.String, AcContext.ClientContext->RoleName.String ));
                RoleInfo->RoleProcessed = TRUE;
                ProcessedRoleCount++;

            } else {
                //
                // either this is the requested role, or
                // we need to check for all roles
                //

                //
                // Walk the list of operations and tasks so see which are applicable
                //  This is pass 1 which only determines the amount of memory needed
                //
                // Determine if this role has any operations that apply to this access check
                //

                WinStatus = AzpWalkTaskTree( &AcContext,
                                             &Role->Operations,
                                             &Role->Tasks,
                                             0,         // RecursionLevel
                                             NULL,      // No allocated memory, yet
                                             &MemoryRequired,
                                             &TaskInfoArraySize,
                                             NULL,      // No OpsAndTasks to fill in
                                             &CallAgain );

                if ( WinStatus != NO_ERROR ) {
                    goto Cleanup;
                }

                //
                // If no applicable operations were found anywhere,
                //  ditch this task.
                //

                if ( !CallAgain ) {

                    AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: No operations for this role apply\n", AcContext.ObjectNameString.String, Role->GenericObject.ObjectName->ObjectName.String ));
                    RoleInfo->RoleProcessed = TRUE;
                    ProcessedRoleCount++;
                }

                //
                // remember that the requested role is already found
                //
                bFoundRole = TRUE;
            }
        }
    }

    ASSERT( AcContext.RoleCount == RoleIndex );

    //
    // If we've processed all of the roles,
    //  we're done.
    //

    if ( ProcessedRoleCount == AcContext.RoleCount ) {
        AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: No roles have applicable operations %ld.\n", AcContext.ObjectNameString.String,
                                   AcContext.ScopeNameString.String ? AcContext.ScopeNameString.String : L"", AcContext.RoleCount ));
        WinStatus = NO_ERROR;
        goto Cleanup;
    }


    //
    // Allocate a buffer for the task info and index arrays
    //

    ASSERT( (MemoryRequired+TaskInfoArraySize) != 0 );

    SafeAllocaAllocate( AllocatedBuffer, MemoryRequired+TaskInfoArraySize );
    if ( AllocatedBuffer == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    // AzPrint(( AZD_ACCESS_MORE, "Allocated: 0x%lx (0x%lx)\n", AllocatedBuffer, MemoryRequired+TaskInfoArraySize ));

    AcContext.TaskInfo = (PAZ_TASK_INFO) AllocatedBuffer;
    TempAllocatedMemory = (PULONG)(AllocatedBuffer + TaskInfoArraySize);

    //
    // Walk the list of operations and tasks so see which are applicable
    //  This is pass 2 which actually initializes the data structures
    //

    MemoryRequired = 0;
    TaskInfoArraySize = 0;

    for ( RoleIndex=0; RoleIndex<AcContext.RoleCount; RoleIndex++ ) {

        //
        // Grab a pointer to the next role to process
        //

        RoleInfo = &AcContext.RoleInfo[RoleIndex];
        Role = RoleInfo->Role;

        if ( RoleInfo->RoleProcessed ) {
            continue;
        }

        //
        // Determine if this role has any operations that apply to this access check
        //

        WinStatus = AzpWalkTaskTree( &AcContext,
                                     &Role->Operations,
                                     &Role->Tasks,
                                     0,         // RecursionLevel
                                     &TempAllocatedMemory,
                                     &MemoryRequired,
                                     &TaskInfoArraySize,
                                     &RoleInfo->OpsAndTasks,
                                     &CallAgain );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        ASSERT( CallAgain );

        if ( !CallAgain ) {
            RoleInfo->RoleProcessed = TRUE;
            ProcessedRoleCount++;
        }

    }


    AzPrint(( AZD_ACCESS_MORE,
              "AzContextAccessCheck: Starting Access Check loops\n"
              ));


    //
    // Loop through the roles several times.  Each time be more willing to go off-machine.
    //
    // There are 3 iterations of this loop
    //  0: Local only, no bizrules.
    //  1: Local only, bizrules.  If script engine timeout is set to 0, then skip this iteration.
    //  2: remote ok, bizrules.  If script engine timeout is set to 0, bizrules are not evaluated.
    //

    for ( LocalIndex=0 ; LocalIndex<3; LocalIndex++ ) {

        LocalOnly =  (LocalIndex < 2);

        //
        // If script engine timeout is set to 0, skip the 2nd iteration
        //

        if ( (LocalIndex == 1) &&
             ((AcContext.ClientContext)->GenericObject).AzStoreObject->ScriptEngineTimeout == 0 ) {

            continue;
        }

        BizrulesOk = (LocalIndex > 0) &&
            (((AcContext.ClientContext)->GenericObject).AzStoreObject->ScriptEngineTimeout != 0);

        //
        // If we've processed all of the roles,
        //  we're done.
        //

        if ( ProcessedRoleCount == AcContext.RoleCount ) {
            AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: All roles have been processed %ld.\n", AcContext.ObjectNameString.String,
                                        AcContext.ScopeNameString.String ? AcContext.ScopeNameString.String : L"", AcContext.RoleCount ));
            break;
        }

        //
        // Loop through the list of roles
        //

        for ( RoleIndex=0; RoleIndex<AcContext.RoleCount; RoleIndex++ ) {

            // BOOLEAN FoundOperation;

            ULONG AppMemberStatus;
            BOOLEAN IsMember;

            //
            // Grab a pointer to the next role to process
            //

            RoleInfo = &AcContext.RoleInfo[RoleIndex];
            Role = RoleInfo->Role;

            //
            // If we've processed all of the operations,
            //  we're done.
            //

            if ( AcContext.ProcessedOperationCount == AcContext.OperationCount ) {
                AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: All operations have been processed %ld.\n", AcContext.ObjectNameString.String,
                        AcContext.ScopeNameString.String ? AcContext.ScopeNameString.String : L"", AcContext.OperationCount ));
                break;
            }

            //
            // If we've already processed this role,
            //  don't do it again.
            //

            if ( RoleInfo->RoleProcessed ) {
                continue;
            }

            //
            // Be verbose
            //

            AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: Process role\n", AcContext.ObjectNameString.String, Role->GenericObject.ObjectName->ObjectName.String ));


            //
            // Ensure the role still references at least one operation that hasn't previously
            //  been granted access.
            //
            // This check is cheaper than processing group membership or bizrules.
            //

            if ( AcContext.ProcessedOperationCount != 0 ) {

                WinStatus = AzpWalkOpsAndTasks( &AcContext,
                                                &Role->GenericObject.ObjectName->ObjectName,
                                                &RoleInfo->OpsAndTasks,
                                                WeedOutFinishedOps,
                                                ERROR_INTERNAL_ERROR,   // Not used for this opcode
                                                BizrulesOk,
                                                &CallAgain );

                if ( WinStatus != NO_ERROR ) {
                    AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: AzpWalkOpsAndTasks failed %ld\n", AcContext.ObjectNameString.String, Role->GenericObject.ObjectName->ObjectName.String, WinStatus ));
                    goto Cleanup;
                }

                //
                // If no operations from this role apply,
                //  ignore the entire role.
                //

                if ( !CallAgain ) {

                    // Mark this role as having been processed
                    RoleInfo->RoleProcessed = TRUE;
                    ProcessedRoleCount ++;
                    AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: No operations for this role apply\n", AcContext.ObjectNameString.String, Role->GenericObject.ObjectName->ObjectName.String ));
                    continue;
                }

            }



            //
            // Check the group memberhsip of the role if we haven't done so already
            //

            if ( RoleInfo->ResultStatus == NOT_YET_DONE ) {

                //
                // Check the NT Group membership in the role
                //  NT Group membership is always evaluated locally
                //

                if ( !RoleInfo->SidsProcessed ) {

                    AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: CheckSidMembership of role\n", AcContext.ObjectNameString.String, Role->GenericObject.ObjectName->ObjectName.String ));

                    WinStatus = AzpCheckSidMembership(
                                        AcContext.ClientContext,
                                        &Role->SidMembers,
                                        &IsMember );

                    if ( WinStatus != NO_ERROR ) {
                        AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: CheckSidMembership failed %ld\n", AcContext.ObjectNameString.String, Role->GenericObject.ObjectName->ObjectName.String, WinStatus ));
                        goto Cleanup;
                    }

                    AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: CheckSidMembership is %ld\n", AcContext.ObjectNameString.String, Role->GenericObject.ObjectName->ObjectName.String, IsMember ));
                    // Convert the membership to a status code
                    RoleInfo->ResultStatus = IsMember ? NO_ERROR : NOT_YET_DONE;
                    RoleInfo->SidsProcessed = TRUE;

                }

                //
                // If we couldn't determine membership based on SIDs,
                //  try via app groups
                //

                if ( RoleInfo->ResultStatus == NOT_YET_DONE ) {

                    //
                    // Check the app group membership
                    //
                    // *** Note: this routine will temporarily drop AzGlResource in cases where it hits the wire
                    //

                    AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: CheckGroupMembership of role\n", AcContext.ObjectNameString.String, Role->GenericObject.ObjectName->ObjectName.String ));

                    WinStatus = AzpCheckGroupMembership(
                                    AcContext.ClientContext,
                                    &Role->AppMembers,
                                    LocalOnly,
                                    0,  // No recursion yet
                                    &IsMember,
                                    &AppMemberStatus );

                    if ( WinStatus != NO_ERROR ) {
                        AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: CheckGroupMembership failed %ld\n", AcContext.ObjectNameString.String, Role->GenericObject.ObjectName->ObjectName.String, WinStatus ));
                        goto Cleanup;
                    }

                    //
                    // If we couldn't determine membership,
                    //  remember the status to return to our caller.
                    //

                    if ( AppMemberStatus != NO_ERROR ) {

                        RoleInfo->ResultStatus = AppMemberStatus;
                        AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: CheckGroupMembership extended status %ld\n", AcContext.ObjectNameString.String, Role->GenericObject.ObjectName->ObjectName.String, AppMemberStatus ));

                    } else {

                        // Convert the membership to a status code
                        RoleInfo->ResultStatus = IsMember ? NO_ERROR : ERROR_ACCESS_DENIED;
                        AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: CheckGroupMembership is %ld\n", AcContext.ObjectNameString.String, Role->GenericObject.ObjectName->ObjectName.String, IsMember ));
                    }
                }
            }

            //
            // If we've found an answer,
            //  update the results array.
            //

            if ( RoleInfo->ResultStatus != NOT_YET_DONE ) {

                //
                // ASSERT: We have a ResultStatus for this Role
                //
                // Set the ResultStatus in the Results array for every operation granted
                //  by this role.
                //
                // *** Note: this routine will temporarily drop AzGlResource in cases where it hits the wire
                //

                WinStatus = AzpWalkOpsAndTasks( &AcContext,
                                                &Role->GenericObject.ObjectName->ObjectName,
                                                &RoleInfo->OpsAndTasks,
                                                SetResultStatus,
                                                RoleInfo->ResultStatus,
                                                BizrulesOk,
                                                &CallAgain );

                if ( WinStatus != NO_ERROR ) {
                    AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: AzpWalkOpsAndTasks failed %ld\n", AcContext.ObjectNameString.String, Role->GenericObject.ObjectName->ObjectName.String, WinStatus ));
                    goto Cleanup;
                }

                //
                // If no operations from this role apply,
                //  ignore the entire role.
                //

                if ( !CallAgain ) {

                    // Mark this role as having been processed
                    RoleInfo->RoleProcessed = TRUE;
                    ProcessedRoleCount ++;
                    AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: Role finished being processed\n", AcContext.ObjectNameString.String, Role->GenericObject.ObjectName->ObjectName.String ));
                    continue;
                }

                //
                // AzpWalkOpsAndTasks says CallAgain for ERROR_ACCESS_DENIED hoping for a NO_ERROR.
                //  That won't happen for a Role since the ResultStatus won't change.
                //

                if ( RoleInfo->ResultStatus == ERROR_ACCESS_DENIED &&
                     BizrulesOk ) {

                    // Mark this role as having been processed
                    RoleInfo->RoleProcessed = TRUE;
                    ProcessedRoleCount ++;
                    AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: %ws: Role finished being processed due to ACCESS_DENIED\n", AcContext.ObjectNameString.String, Role->GenericObject.ObjectName->ObjectName.String ));
                    continue;
                }


            }

        }

    }


    WinStatus = NO_ERROR;


    //
    // Free any local resources
    //
Cleanup:


    //
    // If access wasn't granted,
    //  process the results array to ensure the best status possible is returned
    //

    if ( WinStatus == NO_ERROR &&
         AcContext.OperationCount != AcContext.ProcessedOperationCount ) {

        for ( i=0; i<AcContext.OperationCount; i++ ) {

            //
            // Convert unknown status to a definitive access denied status
            //
            switch ( Results[i] ) {
            case NOT_YET_DONE:
                Results[i] = ERROR_ACCESS_DENIED;
                break;

            //
            // A definitive status should be left alone
            //
            case NO_ERROR:
            case ERROR_ACCESS_DENIED:
                break;

            //
            // All other status codes should fail the access check API and not just
            //  deny access.
            //
            // Other status codes are temporarily put in the results array in hopes
            // that a better status will be found via later processing.
            //
            // The only known status code is ERROR_NO_SUCH_DOMAIN.
            //
            default:
                ASSERT( FALSE );
            case ERROR_NO_SUCH_DOMAIN:
                WinStatus = Results[i];
                break;
            }
        }
    }

    //
    // Generate the access check audits if the audit boolean is set to TRUE.
    //

    if ( WinStatus ==  NO_ERROR ) {
        if ( AcContext.Application->GenericObject.IsGeneratingAudits &&
             !AzpOpenToManageStore(AcContext.ClientContext->GenericObject.AzStoreObject) ) {

            WinStatus = AzpAccessCheckGenerateAudit( &AcContext );

            if ( WinStatus != NO_ERROR ) {
                AzPrint(( AZD_ACCESS_MORE, "AzAccessCheck: %ws: AzpAccessCheckGenerateAudit failed with %ld\n", AcContext.ObjectNameString.String, WinStatus ));
            }

        }
    }

    //
    // Update the cache of results
    //

    if ( WinStatus ==  NO_ERROR ) {
        AzpUpdateOperationCache( &AcContext );
    }

    //
    // Free the operation objects
    //

    if ( AcContext.OperationObjects != NULL ) {

        for ( i=0; i<AcContext.OperationCount; i++ ) {

            if ( AcContext.OperationObjects[i] != NULL ) {
                ObDereferenceObject( (PGENERIC_OBJECT)AcContext.OperationObjects[i] );
            }

        }

        SafeAllocaFree( AcContext.OperationObjects );
    }


    //
    // Free the role info
    //
    if ( AcContext.RoleInfo != NULL ) {

        for ( RoleIndex=0; RoleIndex<AcContext.RoleCount; RoleIndex++ ) {
            ObDereferenceObject( (PGENERIC_OBJECT)AcContext.RoleInfo[RoleIndex].Role );
            // SafeAllocaFree( AcContext.RoleInfo[RoleIndex].OpsAndTasks.OpIndexes ); // Part of AllocatedBuffer
        }

        SafeAllocaFree ( AcContext.RoleInfo );
    }

    //
    // Free the task info
    //

    if ( AcContext.TaskInfo != NULL ) {

        for ( i=0; i<AcContext.TaskCount; i++ ) {
            ObDereferenceObject( (PGENERIC_OBJECT)AcContext.TaskInfo[i].Task );
            // SafeAllocaFree( AcContext.TaskInfo[i].OpsAndTasks.OpIndexes ); // Part of AllocatedBuffer
        }

        // SafeAllocaFree ( AcContext.TaskInfo ); // Part of AllocatedBuffer
    }

    SafeAllocaFree( AllocatedBuffer );

    //
    // Free sundry other data
    //
    if ( AcContext.Scope != NULL ) {
        ObDereferenceObject( (PGENERIC_OBJECT) AcContext.Scope );
    }

    AzpFreeString( &AcContext.ObjectNameString );
    AzpFreeString( &AcContext.ScopeNameString );

    if ( AcContext.ClientContext != NULL ) {
        ObDereferenceObject( (PGENERIC_OBJECT)AcContext.ClientContext );
    }

    if ( AcContext.SaParameterNames != NULL ) {
        SafeArrayUnaccessData( AcContext.SaParameterNames );
    }

    if ( AcContext.SaParameterValues != NULL ) {
        SafeArrayUnaccessData( AcContext.SaParameterValues );
    }

    SafeAllocaFree( AcContext.UsedParameters );

    //
    // Drop the locks
    //

    AzpUnlockResource( &AzGlResource );
    if ( CritSectLocked ) {
        SafeLeaveCriticalSection( &AcContext.ClientContext->CritSect );
    }

    //
    // Return the BusinessRuleString to the caller
    //

    if ( WinStatus == NO_ERROR && BusinessRuleString != NULL ) {
        *BusinessRuleString = AcContext.BusinessRuleString.String;
    } else {
        AzpFreeString( &AcContext.BusinessRuleString );
    }


    return WinStatus;
}

DWORD
WINAPI
AzContextGetRoles(
    IN AZ_HANDLE ClientContextHandle,
    IN LPCWSTR ScopeName OPTIONAL,
    OUT LPWSTR **RoleNames,
    OUT DWORD *Count
    )
/*++

Routine Description:

    The application calls the GetRoles function whenever it wants to find the
    roles the client belongs to in a specified scope.

    If the ScopeName parameter is NULL, Roles applicable at the default Scope
    are returned.

    Otherwise, only those Roles applicable at the speficied scope (and not
    including the roles at the default scope) are returned.

    Biz rules re not evaluated since they do not come in the picture.

Arguments:

    ClientContextHandle - Specifies a handle to the client context object indentifying
        the client.

    ScopeName - Specifies the scope name from which the roles are applicable.
        NULL scope represents the Application scope.

    RoleNames - Returns an array of role names applicable at the given scope.

    RoleCount - Returns the number of eleements in the array.

Return Value:

    Returns the status of the function.

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    ERROR_NOT_FOUND - ScopeName is not defined in the AZ policy database.

    Other status codes

--*/
{

    DWORD WinStatus = NO_ERROR;

    AZP_STRING ScopeNameString = {0};
    PAZP_SCOPE Scope = NULL;

    BOOLEAN CritSectLocked = FALSE;
    PAZP_CLIENT_CONTEXT ClientContext = NULL;

    PAZP_APPLICATION Application = NULL;

    PGENERIC_OBJECT_HEAD RoleList = NULL;
    PAZP_ROLE Role = NULL;
    PAZ_ROLE_INFO RoleInfo = NULL;
    ULONG RoleCount = 0;

    ULONG RoleIndex = 0;
    ULONG ProcessedRoleCount = 0;
    ULONG ApplicableRoleCount = 0;
    ULONG LocalIndex = 0;

    BOOLEAN LocalOnly = FALSE;
    ULONG Size;
    ULONG i;

    PLIST_ENTRY ListEntry = NULL;

    //
    // Initialization
    //

    *Count = 0;
    *RoleNames = NULL;

    //
    // Grab the locks needed.
    //
    // Note, that even though the global lock is grabbed here, it is dropped during
    //  LDAP Queries.  By ensuring that the global lock isn't held while
    //  going off-machine, the policy cache can be updated via the change notification
    //  or the AzUpdateCache mechanisms.
    //
    //

    AzpLockResourceShared( &AzGlResource );

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( (PGENERIC_OBJECT)ClientContextHandle,
                                           FALSE,   // Don't allow deleted objects
                                           FALSE,   // No cache to refresh
                                           OBJECT_TYPE_CLIENT_CONTEXT );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ClientContext = (PAZP_CLIENT_CONTEXT) ClientContextHandle;
    Application = (PAZP_APPLICATION) ParentOfChild( &ClientContext->GenericObject );

    if (!ARGUMENT_PRESENT(ScopeName)) {

        //
        // If ScopeName is not provided, we pick the Application Scope as the
        // default scope.
        //

        RoleList = &Application->Roles;
    } else {

        //
        // Capture the ScopeName provided and reference the Scope object.
        //

        WinStatus = AzpCaptureString( &ScopeNameString,
                                      ScopeName,
                                      AZ_MAX_SCOPE_NAME_LENGTH,
                                      FALSE ); // NULL not ok

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = ObReferenceObjectByName( &Application->Scopes,
                                             &ScopeNameString,
                                             AZP_FLAGS_REFRESH_CACHE,
                                             (PGENERIC_OBJECT *)&Scope );

        if ( WinStatus != NO_ERROR ) {

            //
            // if a scope cannot be found, ObReferenceObjectByName will
            // return ERROR_NOT_FOUND. We need to mask it to more specific error
            // code before returning to the caller
            //

            if ( WinStatus == ERROR_NOT_FOUND ) {

                WinStatus = ERROR_SCOPE_NOT_FOUND;
            }

            goto Cleanup;
        }

        RoleList = &Scope->Roles;
    }

    //
    // If there are no applicable roles, return now.
    //

    RoleCount = RoleList->ObjectCount;
    if ( RoleCount == 0 ) {
        WinStatus = NO_ERROR;
        goto Cleanup;
    }

    //
    // Grab the lock on the client context (observing locking order)
    //
    // This locking order allows the context crit sect to be locked for the life of the
    //  access check call and for the global lock to be periodically dropped when we
    //  go off-machine.
    //

    AzpUnlockResource( &AzGlResource );
    SafeEnterCriticalSection( &ClientContext->CritSect );
    CritSectLocked = TRUE;
    AzpLockResourceShared( &AzGlResource );

    //
    // Recheck just in case someone deleted all the roles in our scope when
    // we dropped the global lock.
    //

    RoleCount = RoleList->ObjectCount;
    if ( RoleCount == 0 ) {
        WinStatus = NO_ERROR;
        goto Cleanup;
    }

    //
    // Allocate memory for Role structures.
    //

    SafeAllocaAllocate( RoleInfo, RoleCount*sizeof(AZ_ROLE_INFO) );
    if ( RoleInfo == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    //
    // Grab all the roles, put them into a list and reference them. Now we will
    // not lose them if we have to drop the global lock while going off the machine.
    //
    //

    for ( ListEntry = RoleList->Head.Flink ;
          ListEntry != &RoleList->Head ;
          ListEntry = ListEntry->Flink, RoleIndex++ ) {

        PGENERIC_OBJECT GenericObject;

        //
        // Grab a pointer to the next role to process
        //

        GenericObject = CONTAINING_RECORD( ListEntry,
                                           GENERIC_OBJECT,
                                           Next );

        ASSERT( GenericObject->ObjectType == OBJECT_TYPE_ROLE );

        //
        // Grab a reference
        //
        InterlockedIncrement( &GenericObject->ReferenceCount );
        AzpDumpGoRef( "Role reference", GenericObject );
        Role = (PAZP_ROLE) GenericObject;

        //
        // Initialize the RoleInfo entry
        //
        RoleInfo[RoleIndex].Role = Role;
        RoleInfo[RoleIndex].RoleProcessed = FALSE;
        RoleInfo[RoleIndex].SidsProcessed = FALSE;
        RoleInfo[RoleIndex].ResultStatus = NOT_YET_DONE;

    }


    //
    // There are 2 iterations of this loop
    //  0: Local only
    //  1: remote ok
    // Note that we do not evaluate BizRules like AccessCheck does.
    //

    for ( LocalIndex=0 ; LocalIndex<2; LocalIndex++ ) {

        LocalOnly =  (LocalIndex < 1);

        //
        // If we've processed all of the roles,
        //  we're done.
        //

        if ( ProcessedRoleCount == RoleCount ) {
            break;
        }

        //
        // Loop through the list of roles
        //

        for ( RoleIndex=0; RoleIndex<RoleCount; RoleIndex++ ) {

            ULONG AppMemberStatus = NO_ERROR;
            BOOLEAN IsMember = FALSE;

            //
            // If we've already processed this role,
            //  don't do it again.
            //

            if ( RoleInfo[RoleIndex].RoleProcessed ) {
                continue;
            }

            //
            // Grab a pointer to the next role to process
            //

            Role = RoleInfo[RoleIndex].Role;

            //
            // Check the group memberhsip of the role if we haven't done so already
            //

            if ( RoleInfo[RoleIndex].ResultStatus == NOT_YET_DONE ) {

                //
                // Check the NT Group membership in the role
                //  NT Group membership is always evaluated locally
                //

                if ( !RoleInfo[RoleIndex].SidsProcessed ) {

                    AzPrint(( AZD_ACCESS_MORE, "GetRoles: %ws: CheckSidMembership of role\n", Role->GenericObject.ObjectName->ObjectName.String ));

                    WinStatus = AzpCheckSidMembership(
                                        ClientContext,
                                        &Role->SidMembers,
                                        &IsMember );

                    if ( WinStatus != NO_ERROR ) {
                        AzPrint(( AZD_ACCESS_MORE, "GetRoles: %ws: CheckSidMembership failed %ld\n", Role->GenericObject.ObjectName->ObjectName.String, WinStatus ));
                        goto Cleanup;
                    }

                    AzPrint(( AZD_ACCESS_MORE, "GetRoles: %ws: CheckSidMembership is %ld\n", Role->GenericObject.ObjectName->ObjectName.String, IsMember ));

                    // Convert the membership to a status code
                    if ( IsMember ) {
                        RoleInfo[RoleIndex].ResultStatus = NO_ERROR;
                        ApplicableRoleCount++;
                    } else {
                        RoleInfo[RoleIndex].ResultStatus = NOT_YET_DONE;
                    }
                    RoleInfo[RoleIndex].SidsProcessed = TRUE;

                }

                //
                // If we couldn't determine membership based on SIDs,
                //  try via app groups
                //

                if ( RoleInfo[RoleIndex].ResultStatus == NOT_YET_DONE ) {

                    //
                    // Check the app group membership
                    //
                    // *** Note: this routine will temporarily drop AzGlResource in cases where it hits the wire
                    //

                    AzPrint(( AZD_ACCESS_MORE, "GetRoles: %ws: CheckGroupMembership of role\n", Role->GenericObject.ObjectName->ObjectName.String ));

                    WinStatus = AzpCheckGroupMembership(
                                    ClientContext,
                                    &Role->AppMembers,
                                    LocalOnly,
                                    0,  // No recursion yet
                                    &IsMember,
                                    &AppMemberStatus );

                    if ( WinStatus != NO_ERROR ) {
                        AzPrint(( AZD_ACCESS_MORE, "GetRoles: %ws: CheckGroupMembership failed %ld\n", Role->GenericObject.ObjectName->ObjectName.String, WinStatus ));
                        goto Cleanup;
                    }

                    //
                    // Let check if we could determine membership,
                    //

                    if ( AppMemberStatus == NO_ERROR ) {
                        // Convert the membership to a status code
                        if ( IsMember ) {
                            RoleInfo[RoleIndex].ResultStatus = NO_ERROR;
                            ApplicableRoleCount++;
                        } else {
                            RoleInfo[RoleIndex].ResultStatus = ERROR_ACCESS_DENIED;
                        }
                        AzPrint(( AZD_ACCESS_MORE, "GetRoles: %ws: CheckGroupMembership is %ld\n", Role->GenericObject.ObjectName->ObjectName.String, IsMember ));
                    } else if (AppMemberStatus == ERROR_ACCESS_DENIED ||
                               AppMemberStatus == NOT_YET_DONE) {

                        //
                        // These error codes are ok. We did not encounter an
                        // error.
                        //

                        RoleInfo[RoleIndex].ResultStatus = AppMemberStatus;

                    } else {

                        //
                        // We failed to determine membership. The likely error
                        // code here would be ERROR_NO_SUCH_DOMAIN. We do not
                        // want to continue.
                        //

                        WinStatus = AppMemberStatus;
                        goto Cleanup;
                    }
                    AzPrint(( AZD_ACCESS_MORE, "GetRoles: %ws: CheckGroupMembership extended status %ld\n", Role->GenericObject.ObjectName->ObjectName.String, AppMemberStatus ));
                }
            }

            //
            // Mark the role as processed if
            //     we have determined that the client belongs/does not belong to the role
            //   OR
            //     if this is the last iteration
            //
            //

            if ( RoleInfo[RoleIndex].ResultStatus != NOT_YET_DONE || !LocalOnly ) {

                    // Mark this role as having been processed
                    RoleInfo[RoleIndex].RoleProcessed = TRUE;
                    ProcessedRoleCount ++;
                    AzPrint(( AZD_ACCESS_MORE, "GetRoles: %ws: Role finished being processed \n", Role->GenericObject.ObjectName->ObjectName.String ));

            }

        }
    }

    ASSERT( ProcessedRoleCount == RoleCount );

    //
    // Check that we are returning non zero number of roles.
    //

    if ( ApplicableRoleCount > 0) {

        PUCHAR Current = NULL;

        //
        // Get the size of the buffer required to return the strings for role names.
        //

        Size = (sizeof(LPWSTR)) * ApplicableRoleCount;
        for ( RoleIndex=0; RoleIndex<RoleCount; RoleIndex++ ) {

            // Pick only applicable roles.
            if ( RoleInfo[RoleIndex].ResultStatus == NO_ERROR ) {

                // Note that the StringSize also includes the NULL character.
                Size += RoleInfo[RoleIndex].Role->GenericObject.ObjectName->ObjectName.StringSize;
            } else if ( RoleInfo[RoleIndex].ResultStatus != ERROR_ACCESS_DENIED  &&
                        RoleInfo[RoleIndex].ResultStatus != NOT_YET_DONE ) {

                WinStatus = RoleInfo[RoleIndex].ResultStatus;

                //
                // This should not happen. We have taken care to break out early.
                //

                ASSERT(FALSE);

                goto Cleanup;

            }
        }


        //
        // Allocate memory required to hold the strings.
        //

        *RoleNames = (LPWSTR *) AzpAllocateHeap( Size, "GETROLES" );

        if ( *RoleNames == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Set the number of RoleNames we will return.
        //

        *Count = ApplicableRoleCount;

        //
        // Set the current buffer pointer.
        //

        Current = (PUCHAR) ( (*RoleNames)+ApplicableRoleCount );


        //
        // Copy all the applicable roles into our buffer.
        //

        for ( i=0, RoleIndex=0; RoleIndex<RoleCount; RoleIndex++ ) {
            if ( RoleInfo[RoleIndex].ResultStatus == NO_ERROR ) {

                (*RoleNames)[i] = (LPWSTR) Current;

                RtlCopyMemory( Current,
                               RoleInfo[RoleIndex].Role->GenericObject.ObjectName->ObjectName.String,
                               RoleInfo[RoleIndex].Role->GenericObject.ObjectName->ObjectName.StringSize );

                Current += RoleInfo[RoleIndex].Role->GenericObject.ObjectName->ObjectName.StringSize;

                i++;
            }
        }
    }

    WinStatus = NO_ERROR;

Cleanup:

    //
    // Release references to all the object we touched.
    //
    //

    if ( ClientContext != NULL ) {
        ObDereferenceObject( (PGENERIC_OBJECT)ClientContext );
    }

    if ( Scope != NULL ) {
        ObDereferenceObject( (PGENERIC_OBJECT)Scope );
    }

    if ( RoleInfo != NULL ) {

        for ( RoleIndex=0; RoleIndex<RoleCount; RoleIndex++ ) {
            ObDereferenceObject( (PGENERIC_OBJECT)RoleInfo[RoleIndex].Role );
        }

        SafeAllocaFree ( RoleInfo );
    }

    if ( ScopeName != NULL ) {
        AzpFreeString( &ScopeNameString );
    }

    //
    // Drop the locks
    //

    AzpUnlockResource( &AzGlResource );
    if ( CritSectLocked ) {
        SafeLeaveCriticalSection( &ClientContext->CritSect );
    }

    return WinStatus;
}

inline BOOL
AzpOpenToManageStore (
    IN PAZP_AZSTORE pAzStore
    )
/*++

Routine Description:

    Detect if the store is opened for manage only

Arguments:

    pAzStore    - The authorization store object

Return Value:

    TRUE if and only if the store's initialization flag has
    set the manage only flag.

--*/
{
    return (pAzStore->InitializeFlag & AZ_AZSTORE_FLAG_MANAGE_STORE_ONLY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\copyitem.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows

  Copyright (C) Microsoft Corporation, 1995 - 1999

  File:    CopyItem.h

  Content: Declaration of _CopyXXXItem template class.

  History: 11-15-99    dsie     created
           08-20-01    xtan     copy/paste

------------------------------------------------------------------------------*/


#ifndef __CopyItem_H_
#define __CopyItem_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <map>
#pragma warning(disable:4786) // Disable symbol names > 256 character warning.


//
// _CopyMapItem class. 
//
template <class T>
class _CopyMapItem
{
public:
    //
    // copy method.
    //
    static HRESULT copy(VARIANT * p1, std::pair<const CComBSTR, CComPtr<T> > * p2)
    {
        CComPtr<T> p = p2->second;
        CComVariant var = p;
        return VariantCopy(p1, &var);
    }

    //
    // init method.
    //
	static void init(VARIANT * p)
    {
        p->vt = VT_EMPTY;
    }

    //
    // destroy method.
    //
	static void destroy(VARIANT * p)
    {
        VariantClear(p);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\domain.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    domain.cxx

Abstract:

    Routines implementing a cache of domains and the DC for that domain.

Author:

    Cliff Van Dyke (cliffv) 29-June-2001

--*/

#include "pch.hxx"
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <windns.h>

//
// Structure definitions
//
// A cached domain
//

typedef struct _AZP_DOMAIN {

    //
    // Link to the next domain for this AzAuthorizationStore
    //  Access is serialized by the AzAuthorizationStore->DomainCritSect
    //

    LIST_ENTRY Next;

    //
    // Reference count in this structure
    //  Access is serialized by Interlocked increment/decrement
    //

    LONG ReferenceCount;

    //
    // Name of the domain represented by this structure
    //  Access is serialized by the AZP_DOMAIN->DomainCritSect
    //  In the case of InitializeFromName we do not have the DNS domain name.
    //  The boolean is used to distinguish the two cases.
    //

    AZP_STRING DomainName;
    BOOLEAN IsDnsDomainName;

    //
    // A DCs in that domain
    //  Access is serialized by the AZP_DOMAIN->DomainCritSect
    //

    PAZP_DC Dc;

    //
    // A boolean indicating that the domain is down and the time when it went down.
    //  Access is serialized by the AZP_DOMAIN->DomainCritSect
    //

    BOOLEAN DomainIsDown;
    LARGE_INTEGER DomainDownStartTime;

    SAFE_CRITICAL_SECTION DomainCritSect;

} AZP_DOMAIN, *PAZP_DOMAIN;

PVOID
AzpReferenceDomain(
    IN PAZP_AZSTORE AzAuthorizationStore,
    IN LPWSTR DomainName,
    IN BOOLEAN IsDnsDomainName
    )
/*++

Routine Description:

    This routine finds the domain structure for a domain.  If none exists, it is allocated.

Arguments:

    AzAuthorizationStore - The AzAuthorizationStore object for the authz policy database.

    DomainName - Name of the domain being referenced.

    IsDnsDomainName - Whether this is really a DNS Domain name or NetBios Name.
        When we have a token avalaible we have the DNS Domain name. If not, in
        the case in which we have initialized the context from Name we only
        have a NetBios name.

Return Value:

    Returns a pointer to the referenced domain object.  The pointer must be dereference by
    calling AzpDereferenceDomain.

    NULL: memory could not be allocated for the domain.

--*/
{
    NTSTATUS Status;
    PAZP_DOMAIN Domain = NULL;
    PLIST_ENTRY ListEntry;
    AZP_STRING DomainNameString;

    //
    // Initialization
    //

    ASSERT( AzAuthorizationStore->GenericObject.ObjectType == OBJECT_TYPE_AZAUTHSTORE );
    ASSERT( AzAuthorizationStore->DomainCritSectInitialized );

    AzpInitString( &DomainNameString, DomainName );
    SafeEnterCriticalSection( &AzAuthorizationStore->DomainCritSect );

    //
    // Walk the list finding an existing domain.
    //

    for ( ListEntry = AzAuthorizationStore->Domains.Flink ;
          ListEntry != &AzAuthorizationStore->Domains ;
          ListEntry = ListEntry->Flink) {

        Domain = CONTAINING_RECORD( ListEntry,
                                    AZP_DOMAIN,
                                    Next );

        if ( AzpEqualStrings( &DomainNameString, &Domain->DomainName )) {

            //
            // Reference the domain
            //
            InterlockedIncrement( &Domain->ReferenceCount );
            AzPrint(( AZD_DOMREF, "0x%lx %ws (%ld): Domain ref\n", Domain, Domain->DomainName.String, Domain->ReferenceCount ));

            //
            // Move it to the front of the list
            //

            RemoveEntryList( &Domain->Next );
            InsertHeadList( &AzAuthorizationStore->Domains, &Domain->Next );

            break;
        }

        Domain = NULL;
    }

    //
    // If we didn't find one,
    //  allocate one.
    //

    if ( Domain == NULL ) {

        Domain = (PAZP_DOMAIN) AzpAllocateHeap( sizeof(AZP_DOMAIN) + DomainNameString.StringSize, "DMDOM" );

        if ( Domain != NULL ) {

            //
            // Initialize the domain
            //

            RtlZeroMemory( Domain, sizeof(*Domain) );

            //
            // Initialize the client context critical section
            //

            Status = SafeInitializeCriticalSection( &Domain->DomainCritSect, SAFE_DOMAIN );

            if ( !NT_SUCCESS( Status )) {
                AzpFreeHeap( Domain );
                Domain = NULL;

            } else {

                RtlCopyMemory( (Domain+1),
                               DomainNameString.String,
                               DomainNameString.StringSize );

                Domain->DomainName = DomainNameString;
                Domain->DomainName.String = (LPWSTR)(Domain+1);
                Domain->IsDnsDomainName = IsDnsDomainName;


                // One to return to the caller.
                // One for being in the linked list
                Domain->ReferenceCount = 2;

                InsertHeadList( &AzAuthorizationStore->Domains, &Domain->Next );
            }

        }
    }


    SafeLeaveCriticalSection( &AzAuthorizationStore->DomainCritSect );
    return (PVOID) Domain;
}


VOID
AzpDereferenceDomain(
    IN PVOID DomainHandle
    )
/*++

Routine Description:

    This routine decrements the reference count on the domain object.
    If the reference count reaches zero, the object is deleted.

Arguments:

    DomainHandle - Handle to the domain to dereference

Return Value:

    None.

--*/
{
    PAZP_DOMAIN Domain = (PAZP_DOMAIN) DomainHandle;
    ULONG RefCount;

    //
    // Decrement the reference count
    //

    RefCount = InterlockedDecrement( &Domain->ReferenceCount );
    AzPrint(( AZD_DOMREF, "0x%lx %ws (%ld): Domain deref\n", Domain, Domain->DomainName.String, Domain->ReferenceCount ));

    //
    // If the object is no longer referenced,
    //  delete it.
    //

    if ( RefCount == 0 ) {

        if ( Domain->Dc != NULL ) {
            AzpDereferenceDc( Domain->Dc );
        }

        SafeDeleteCriticalSection( &Domain->DomainCritSect );
        AzpFreeHeap( Domain );

    }
}

VOID
AzpUnlinkDomains(
    IN PAZP_AZSTORE AzAuthorizationStore
    )
/*++

Routine Description:

    This routine unlinks all of the domains from the AzAuthorizationStore.

Arguments:

    AzAuthorizationStore - The AzAuthorizationStore object for the authz policy database.

Return Value:

    None.

--*/
{

    //
    // Initialization
    //

    ASSERT( AzAuthorizationStore->GenericObject.ObjectType == OBJECT_TYPE_AZAUTHSTORE );
    ASSERT( AzAuthorizationStore->DomainCritSectInitialized );
    SafeEnterCriticalSection( &AzAuthorizationStore->DomainCritSect );

    //
    // Free the list of domains
    //

    while ( !IsListEmpty( &AzAuthorizationStore->Domains ) ) {
        PLIST_ENTRY ListEntry;
        PAZP_DOMAIN Domain;

        //
        // Remove the entry from the list
        //

        ListEntry = RemoveHeadList( &AzAuthorizationStore->Domains );

        Domain = CONTAINING_RECORD( ListEntry,
                                    AZP_DOMAIN,
                                    Next );

        ASSERT( Domain->ReferenceCount == 1 );
        AzpDereferenceDomain( Domain );

    }

    SafeLeaveCriticalSection( &AzAuthorizationStore->DomainCritSect );
}

DWORD
AzpLdapErrorToWin32Error(
    IN ULONG LdapStatus
    )
/*++

Routine Description:

    Map Ldap Error to Win 32 error.

    Be a little bit more specific than LdapMapErrorToWin32

Arguments:

    LdapStatus - LdapStatus code to map.

Return Value:

    Corresponding win 32 status code

--*/
{

    //
    // Return a consistent status code for DC down
    //

    switch ( LdapStatus ) {
    case LDAP_SERVER_DOWN :
    case LDAP_UNAVAILABLE :
    case LDAP_BUSY:
        return ERROR_NO_SUCH_DOMAIN;

    default:
        return LdapMapErrorToWin32( LdapStatus );
    }
}

DWORD
AzpAllocateDc(
    IN PAZP_STRING DcName,
    OUT PAZP_DC *RetDc
    )
/*++

Routine Description:

    This routine allocates a PAZP_DC structure and binds to the DC

Arguments:

    DcName - Name of the Dc to allocate the structure for

    RetDc - Returns a pointer to a structure representing a DC.
        The caller should dereference this structure by calling AzpDereferenceDc

Return Value:


    Status of the operation:

    NO_ERROR: a DcName has been returned.  The caller should try the named DC.  If the DC is
        expected to be down, the caller should call this routine again.

    ERROR_NO_SUCH_DOMAIN: No DC could be found.

    Others: resource errors. etc.

--*/
{
    DWORD WinStatus;
    PAZP_DC Dc = NULL;

    ULONG LdapStatus;
    LDAP *LdapHandle = NULL;

    //
    // Initialize the LDAP connection
    //

    LdapHandle = ldap_init( DcName->String, LDAP_PORT );

    if ( LdapHandle == NULL ) {
        LdapStatus = LdapGetLastError();
        AzPrint(( AZD_ACCESS,
                  "AzpAllocateDc: ldap_init failed on %ws: %ld: %s\n",
                  DcName->String,
                  LdapStatus,
                  ldap_err2stringA( LdapStatus )));

        WinStatus = AzpLdapErrorToWin32Error( LdapStatus );
        goto Cleanup;
    }

    //
    // Set our default options
    //

    WinStatus = AzpADSetDefaultLdapOptions( LdapHandle, DcName->String );

    if (WinStatus != NO_ERROR)
    {
        AzPrint(( AZD_AD,
                  "AzpAllocateDc: AzpADSetDefaultLdapOptions failed on %ws: %ld\n",
                  DcName->String,
                  WinStatus
                ));

        goto Cleanup;
    }

    //
    // Bind to the DC
    //

    LdapStatus = ldap_bind_s( LdapHandle,
                              NULL, // No DN of account to authenticate as
                              NULL, // Default credentials
                              LDAP_AUTH_NEGOTIATE );

    if ( LdapStatus != LDAP_SUCCESS ) {

        AzPrint(( AZD_ACCESS,
                  "AzpAllocateDc: ldap_bind failed on %ws: %ld: %s\n",
                  DcName->String,
                  LdapStatus,
                  ldap_err2stringA( LdapStatus )));

        WinStatus = AzpLdapErrorToWin32Error(LdapStatus);
        goto Cleanup;
    }


    //
    // Allocate the structure
    //

    Dc = (PAZP_DC) AzpAllocateHeap( sizeof(AZP_DC) + DcName->StringSize, "DMDC" );

    if ( Dc == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Fill it in
    //

    RtlCopyMemory( (Dc+1),
                   DcName->String,
                   DcName->StringSize );

    Dc->DcName = *DcName;
    Dc->DcName.String = (LPWSTR)(Dc+1);

    Dc->LdapHandle = LdapHandle;
    LdapHandle = NULL;


    // One to return to the caller.
    Dc->ReferenceCount = 1;
    AzPrint(( AZD_DOMREF, "0x%lx %ws (%ld): DC Allocaote\n", Dc, Dc->DcName.String, Dc->ReferenceCount ));

    //
    // Return it to the caller
    //

    *RetDc = Dc;
    Dc = NULL;
    WinStatus = NO_ERROR;

Cleanup:
    if ( LdapHandle != NULL ) {
        LdapStatus = ldap_unbind( LdapHandle );

        ASSERT( LdapStatus == LDAP_SUCCESS );
    }
    return WinStatus;
}



DWORD
AzpGetDc(
    IN PAZP_AZSTORE AzAuthorizationStore,
    IN PVOID DomainHandle,
    IN OUT PULONG Context,
    OUT PAZP_DC *RetDc
    )
/*++

Routine Description:

    This routine returns the DC for the domain represented by DomainHandle.

Arguments:

    AzAuthorizationStore - The AzAuthorizationStore object for the authz policy database.

    DomainHandle - A handle to the domain to find a DC for

    Context - Specifies the context indicating how hard this routine has tried to find
        a DC.  The caller should call the routine in a loop.  On the first call, the caller
        should pass in a pointer DWORD set to zero.  On subsequent calls, the caller should
        pass in the value returned on the previous pass.

    RetDc - Returns a pointer to a structure representing a DC.
        The caller should dereference this structure by calling AzpDereferenceDc

Return Value:

    Status of the operation:

    NO_ERROR: a DcName has been returned.  The caller should try the named DC.  If the DC is
        expected to be down, the caller should call this routine again.

    ERROR_NO_SUCH_DOMAIN: No DC could be found.

    Others: resource errors. etc.

--*/
{
    DWORD WinStatus;

    PAZP_DOMAIN Domain = (PAZP_DOMAIN) DomainHandle;
    ULONG DsGetDcFlags;

    PDOMAIN_CONTROLLER_INFO DomainControllerInfo = NULL;
    AZP_STRING CapturedString;

    PAZP_DC Dc = NULL;
    PAZP_DC TempDc;

    //
    // Initialization
    //

    ASSERT( AzAuthorizationStore->GenericObject.ObjectType == OBJECT_TYPE_AZAUTHSTORE );
    ASSERT( AzAuthorizationStore->DomainCritSectInitialized );

    AzpInitString( &CapturedString, NULL );
    SafeEnterCriticalSection( &Domain->DomainCritSect );
    *RetDc = NULL;


    //
    // If the domain is down,
    //  check to see if it is time to try again.
    //

    if ( Domain->DomainIsDown ) {

        //
        // If we haven't waited long enough,
        //  fail immediately.
        //

        if ( !AzpTimeHasElapsed( &Domain->DomainDownStartTime,
                                 AzAuthorizationStore->DomainTimeout ) ) {

            WinStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;

        }

        //
        // If we have waited long enough,
        //  try again to find a DC.
        //

        if ( Domain->Dc != NULL ) {
            AzpDereferenceDc( Domain->Dc );   // No use trying this stale DC
            Domain->Dc = NULL;
        }
        Domain->DomainIsDown = FALSE;
    }

    //
    // Loop through the various states internally so our caller doesn't need to
    //

    for ( ; *Context <= 2 ; (*Context)++ ) {


        //
        // If this is the first call,
        //  return the cached DC name.
        //

        if ( *Context == 0 ) {

            //
            // If there is no cached value,
            //  continue the loop to look harder.
            //

            if ( Domain->Dc == NULL ) {
                continue;
            }


        //
        // On the second call, use DsGetDcName.
        //  On the third call, use DsGetDcName withforce.
        //
        } else {

            if (Domain->IsDnsDomainName) {
                DsGetDcFlags = DS_IS_DNS_NAME | DS_IP_REQUIRED;
            } else {;
                //
                // Make sure that this is NT5 domain or higher.
                //
                DsGetDcFlags = DS_IS_FLAT_NAME | DS_IP_REQUIRED |
                               DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME;
            }
            if ( *Context == 2 ) {
                DsGetDcFlags |= DS_FORCE_REDISCOVERY;
            }

            //
            // Free the values from the previous iteration
            //
            if ( DomainControllerInfo != NULL ) {
                NetApiBufferFree( DomainControllerInfo );
                DomainControllerInfo = NULL;
            }

            if ( Dc != NULL ) {
                AzpDereferenceDc( Dc );
                Dc = NULL;
            }

            AzpFreeString( &CapturedString );

            //
            // Find a DC in the user's account domain
            //

            WinStatus = DsGetDcName(
                            NULL,
                            Domain->DomainName.String,
                            NULL,   // No guid
                            NULL,   // No site,
                            DsGetDcFlags,
                            &DomainControllerInfo );

            if ( WinStatus != NO_ERROR ) {

                //
                // If the DC is down,
                //  DsGetDcName never lies,
                //  but map obnoxious status codes to a more likeable one
                //

                if ( WinStatus == WSAEHOSTUNREACH ||
                     WinStatus == ERROR_NO_SUCH_DOMAIN ) {

                    break;
                }
                goto Cleanup;
            }

            //
            // Capture the DC name into a string structure.
            //

            AzpFreeString( &CapturedString );

            WinStatus = AzpCaptureString( &CapturedString,
                                          DomainControllerInfo->DomainControllerName + 2,
                                          DNS_MAX_NAME_LENGTH,
                                          FALSE );  // Null not OK

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            //
            // If the DC name is the same as the previous name,
            //  continue looping to try harder to find a DC.
            //

            if ( Domain->Dc != NULL &&
                 AzpEqualStrings( &CapturedString, &Domain->Dc->DcName) ) {

                WinStatus = ERROR_NO_SUCH_DOMAIN;
                continue;
            }

            //
            // Allocate a structure representing the DC
            //

            WinStatus = AzpAllocateDc( &CapturedString,
                                       &Dc );

            if ( WinStatus != NO_ERROR ) {
                if ( WinStatus == ERROR_NO_SUCH_DOMAIN ) {
                    continue;
                }
                goto Cleanup;
            }

            //
            // Swap the old/new Dcs
            //

            TempDc = Domain->Dc;
            Domain->Dc = Dc;
            Dc = TempDc;

        }


        //
        // Return the found DC to the caller.
        //

        ASSERT( Domain->Dc != NULL );
        ASSERT( Domain->Dc->DcName.StringSize != 0 );

        InterlockedIncrement( &Domain->Dc->ReferenceCount );
        AzPrint(( AZD_DOMREF, "0x%lx %ws (%ld): DC ref\n", Domain->Dc, Domain->Dc->DcName.String, Domain->Dc->ReferenceCount ));

        *RetDc = Domain->Dc;
        WinStatus = NO_ERROR;
        goto Cleanup;

    }

    //
    // No DC can be found via any mechanism
    //  Set the negative cache to indicate so.
    //

    Domain->DomainIsDown = TRUE;
    GetSystemTimeAsFileTime( (PFILETIME)&Domain->DomainDownStartTime );
    WinStatus = ERROR_NO_SUCH_DOMAIN;


Cleanup:
    if ( DomainControllerInfo != NULL ) {
        NetApiBufferFree( DomainControllerInfo );
    }

    AzpFreeString( &CapturedString );

    if ( Dc != NULL ) {
        AzpDereferenceDc( Dc );
        Dc = NULL;
    }

    SafeLeaveCriticalSection( &Domain->DomainCritSect );
    return WinStatus;
}

VOID
AzpDereferenceDc(
    IN PAZP_DC Dc
    )
/*++

Routine Description:

    This routine decrements the reference count on the DC object.
    If the reference count reaches zero, the object is deleted.

Arguments:

    Dc - Pointer to the DC to dereference

Return Value:

    None.

--*/
{
    ULONG RefCount;

    //
    // Decrement the reference count
    //

    RefCount = InterlockedDecrement( &Dc->ReferenceCount );
    AzPrint(( AZD_DOMREF, "0x%lx %ws (%ld): DC deref\n", Dc, Dc->DcName.String, Dc->ReferenceCount ));

    //
    // If the object is no longer referenced,
    //  delete it.
    //

    if ( RefCount == 0 ) {
        if ( Dc->LdapHandle != NULL ) {
            ULONG LdapStatus;
            LdapStatus = ldap_unbind( Dc->LdapHandle );

            ASSERT( LdapStatus == LDAP_SUCCESS );
        }
        AzpFreeHeap( Dc );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\bizrule.cxx ===
/*++

    Copyright (c) 2001  Microsoft Corporation

Module Name:

    bizrule.cxx

Abstract:

    Routines implementing Business Rules

Author:

    IAcativeScript sample code taken from http://support.microsoft.com/support/kb/articles/Q183/6/98.ASP
        and from from \nt\inetsrv\iis\svcs\cmp\asp as originally written by AndrewS

    Cliff Van Dyke (cliffv) 18-July-2001

--*/

#include "pch.hxx"
#define AZD_COMPONENT     AZD_SCRIPT

//
// Performance measurement globals
//
#define ENABLE_PERF 1
#ifdef ENABLE_PERF
    LONG AzGlPerfEngineCacheTries;
    LONG AzGlPerfEnginesInFreeScriptList;
    LONG AzGlPerfEngineCacheHits;
    LONG AzGlPerfEngineFlushes;
    LONG AzGlPerfRunningEngineCacheHits;
#endif

//*****************************************************************************
// The following macros are used to catch exceptions thrown from the external
// scripting engines.
//
// Use of TRY/CATCH blocks around calls to the script engine is controlled by
// the DBG compile #define.  If DBG is 1, then the TRY/CATCH blocks are NOT
// used so that checked builds break into the debugger and we can examine why
// the error occurred.  If DBG is 0, then the TRY/CATCH blocks are used and
// exceptions are captured and logged to the browser (if possible) and the NT
// Event log.
//
// The TRYCATCH macros are:
//
//  TRYCATCH(_s, _IFStr)
//      _s      - statement to execute inside of TRY/CATCH block.
//      _IFStr  - string containing the name of interface invoked
//  TRYCATCH_HR(_s, _hr, _IFStr)
//      _s      - statement to execute inside of TRY/CATCH block.
//      _hr     - HRESULT to store return from _s
//      _IFStr  - string containing the name of interface invoked
//
//  NOTES:
//  The macros also expect that there is a local variable defined in the function
//  the macros is used of type char * named _pFuncName.
//
//  A minimal test capability is included to allow for random errors to be throw.
//  The test code is compiled in based on the TEST_TRYCATCH #define.
//
//*****************************************************************************

//*****************************************************************************
// TEST_TRYCATCH definitions
//*****************************************************************************
#define TEST_TRYCATCH 0

#if TEST_TRYCATCH
#define  THROW_INTERVAL 57

int g_TryCatchCount = 0;

#define TEST_THROW_ERROR  g_TryCatchCount++; if ((g_TryCatchCount % THROW_INTERVAL) == 0) {THROW(0x80070000+g_TryCatchCount);}
#else
#define TEST_THROW_ERROR
#endif

//*****************************************************************************
// The following is the heart of the TRYCATCH macros.  The definitions here are
// based on the definition of DBG.  Again, note that when DBG is off that the
// TRYCATCH defines are removed.
//*****************************************************************************
// ??? We could log it here

#if DBG
#define START_TRYCATCH( _IFStr ) { \
        AzPrint((AZD_SCRIPT_MORE, "Calling: %s\n", _IFStr ));
#define END_TRYCATCH(_hr, _IFStr) }
#else // DBG

#define START_TRYCATCH( _IFStr ) __try {
#define END_TRYCATCH(_hr, _IFStr) \
    } __except( EXCEPTION_EXECUTE_HANDLER ) { \
        _hr = GetExceptionCode(); \
        AzPrint((AZD_CRITICAL, "Exception: %s: 0x%lx\n", _IFStr, _hr )); \
    }
#endif // DBG

//*****************************************************************************
// Definition of TRYCATCH_INT which is used by all of the TRYCATCH macros
// described above.
//*****************************************************************************

#define TRYCATCH_INT(_s, _hr, _IFStr) \
    START_TRYCATCH( _IFStr ) \
    TEST_THROW_ERROR \
    _hr = _s; \
    END_TRYCATCH(_hr, _IFStr)

//*****************************************************************************
// Here are the actual definitions of the TRYCATCH macros described above.
//*****************************************************************************

#define TRYCATCH(_s, _IFStr) \
    { \
        HRESULT     _tempHR; \
        TRYCATCH_INT(_s, _tempHR, _IFStr); \
    }
#define TRYCATCH_HR(_s, _hr, _IFStr) TRYCATCH_INT(_s, _hr, _IFStr)

//
// Name of the IAzBizRuleContext interface
//

#define BIZRULE_CONTEXT_INTERFACE_NAME L"AzBizRuleContext"


HRESULT
AzpGetScriptEngine(
    IN PAZP_TASK Task,
    OUT CScriptEngine ** RetScriptEngine
    )
/*++

Routine Description:

    This routine allocates a script engine to run the bizrule task.

    Ideally, we will find an engine in our FreeScript list
    and will just hand it out.  If there isnt one, then we will look
    in the Running Script List and attempt to clone a running script.
    Failing that, we will create a new script engine.

Arguments:

    Task - Task containing the BizRule to process

    RetScriptEngine - Returns a pointer to the script engine to use
        The caller should free the engine by calling AzpReturnEngineToCache.

Return Value:

    S_OK: a script engine was successfully returned
    OLESCRIPT_E_SYNTAX - The syntax of the bizrule is invalid

--*/
{
    HRESULT hr;
    PAZP_AZSTORE AzAuthorizationStore = Task->GenericObject.AzStoreObject;

    CScriptEngine *ScriptEngine = NULL;
    IActiveScript *ClonedActiveScript = NULL;
    DWORD ClonedBizRuleSerialNumber = 0;
    PLIST_ENTRY ListEntry;
    PLIST_ELEMENT ListElement;


    //
    // First try to find an engine in the FreeScript list
    //

#ifdef ENABLE_PERF
    InterlockedIncrement( &AzGlPerfEngineCacheTries );
#endif

    SafeEnterCriticalSection( &AzAuthorizationStore->FreeScriptCritSect );

    if ( !IsListEmpty( &Task->FreeScriptHead ) ) {

        //
        // Try to find an engine that was initialized by this thread
        //

        for ( ListEntry = Task->FreeScriptHead.Flink;
              ListEntry != &Task->FreeScriptHead;
              ListEntry = ListEntry->Flink) {

            ListElement = CONTAINING_RECORD( ListEntry,
                                             LIST_ELEMENT,
                                             Next );

            ASSERT( ListElement->This != NULL );
            ScriptEngine = (CScriptEngine *) ListElement->This;

            if ( ScriptEngine->IsBaseThread() ) {
                break;
            }

            ScriptEngine = NULL;
            AzPrint((AZD_SCRIPT_MORE, "Avoided script engine in non-base thread.\n" ));

        }


        //
        // If not,
        //  grab the one at the front of the list.
        //  ResuseEngine will fix it up
        //

        if ( ScriptEngine == NULL ) {
            //
            // Remove the entry from the list
            //

            ListEntry = Task->FreeScriptHead.Flink;

            ListElement = CONTAINING_RECORD( ListEntry,
                                             LIST_ELEMENT,
                                             Next );

            ASSERT( ListElement->This != NULL );
            ScriptEngine = ListElement->This;
            AzPrint((AZD_SCRIPT, "Using free script engine from non-base thread.\n" ));
        }

        ScriptEngine->RemoveListEntry();
        ScriptEngine->RemoveLruListEntry();  // Remove from the LRU list too
#ifdef ENABLE_PERF
        InterlockedDecrement( &AzGlPerfEnginesInFreeScriptList );
#endif

        // There was a reference for being in the FreeScript list.
        // That reference is now ours.

        // Drop the crit sect before actually doing anything with the script engine
        SafeLeaveCriticalSection( &AzAuthorizationStore->FreeScriptCritSect );

        //
        // Never re-use an engine that has a script that is not up to date
        //  The Assert below is overactive.  The script was up to date when it was placed
        //  on the free script list.  However, the script may be changing out from under
        //  us.  That's fine.  This script will be used one last time then will be ditched
        //  as we try to put it onto the free script list again.
        //

        // ASSERT( ScriptEngine->GetBizRuleSerialNumber() == Task->BizRuleSerialNumber );


        //
        // Update the script engine so it can be reused.
        //
        hr = ScriptEngine->ReuseEngine();

        if (FAILED(hr)) {
            AzPrint((AZD_CRITICAL, "ReuseEngine failed: 0x%lx\n", hr ));
            goto Cleanup;
        }

        // Got an engine for sure...so just incr the cache hit count
#ifdef ENABLE_PERF
        InterlockedIncrement( &AzGlPerfEngineCacheHits );
#endif
        AzPrint((AZD_SCRIPT, "Using free script engine.\n" ));

    } else {
        SafeLeaveCriticalSection( &AzAuthorizationStore->FreeScriptCritSect );
    }

    //
    // If not found, try to find the engine in the Running script list and clone it
    //

    if ( ScriptEngine == NULL ) {
        CScriptEngine *RunningScriptEngine = NULL;

        //
        // Search the running script list
        //
        // This is a different crit sect than FreeScriptCritSect since we actually keep
        //  this crit sect locked while cloning the engine.  That can take a long time
        //  and we don't want to increase the contention on FreeScriptCritSect.
        //

        SafeEnterCriticalSection( &Task->RunningScriptCritSect );

        for ( ListEntry = Task->RunningScriptHead.Flink;
              ListEntry != &Task->RunningScriptHead;
              ListEntry = ListEntry->Flink) {

            ListElement = CONTAINING_RECORD( ListEntry,
                                             LIST_ELEMENT,
                                             Next );

            ASSERT( ListElement->This != NULL );
            RunningScriptEngine = (CScriptEngine *) ListElement->This;

            //
            // If the script engine hasn't GPF'd and
            //  is running the current version of the bizrule,
            //  use it.
            //

            if ( !RunningScriptEngine->FIsCorrupted() &&
                RunningScriptEngine->GetBizRuleSerialNumber() == Task->BizRuleSerialNumber ) {

                ClonedBizRuleSerialNumber = Task->BizRuleSerialNumber;
                break;
            }

            RunningScriptEngine = NULL;
        }

        //
        // If we didn't find a script engine,
        //  we're done.
        //

        if ( RunningScriptEngine == NULL ) {
            SafeLeaveCriticalSection( &Task->RunningScriptCritSect );

        //
        // If we found a running script engine,
        //  clone it.

        } else {
            IActiveScript *pAS;

            RunningScriptEngine->AssertValid();

            //
            // Clone the engine
            //
            pAS = RunningScriptEngine->GetActiveScript();

            ASSERT(pAS != NULL);

            hr = pAS->Clone( &ClonedActiveScript );

            // We've cloned the engine, we can let go of the CS
            SafeLeaveCriticalSection( &Task->RunningScriptCritSect );

            //
            // Scripting engines are not required to implement clone.  If we get an error,
            // just continue on and create a new engine
            //
            if (FAILED(hr)) {
                ASSERT(hr == E_NOTIMPL);        // I only expect E_NOTIMPL
                ClonedActiveScript = NULL;
            } else {

#ifdef ENABLE_PERF
                InterlockedIncrement( &AzGlPerfRunningEngineCacheHits );
#endif

                AzPrint((AZD_SCRIPT, "Using clone of running script engine.\n" ));
            }
        }
    }


    //
    // If we couldn't find any script engine to reuse,
    //  allocate a new one.
    //

    if ( ScriptEngine == NULL) {

        //
        // Allocate the object
        //

        ScriptEngine = new CScriptEngine;

        if ( ScriptEngine == NULL ) {
            hr = E_OUTOFMEMORY;
            AzPrint((AZD_CRITICAL, "new CScriptEngine failed: 0x%lx\n", hr ));
            goto Cleanup;
        }

        //
        // Initialize it
        //

        hr = ScriptEngine->Init( Task, ClonedActiveScript, ClonedBizRuleSerialNumber );

        if (FAILED(hr)) {
            ClonedActiveScript = NULL;  // ::Init always steals this reference
            AzPrint((AZD_CRITICAL, "ScriptEngine->Init failed: 0x%lx\n", hr ));
            goto Cleanup;
        }

        if ( ClonedActiveScript == NULL ) {
            AzPrint((AZD_SCRIPT, "Using new script engine.\n" ));
        }
        ClonedActiveScript = NULL;  // ::Init always steals this reference

    }

    //
    // Put the script engine onto the RunningScripts list.
    //

    ScriptEngine->AssertValid();

    SafeEnterCriticalSection( &Task->RunningScriptCritSect );
    ScriptEngine->InsertHeadList( &Task->RunningScriptHead );
    SafeLeaveCriticalSection( &Task->RunningScriptCritSect );

    //
    // Return the script engine to the caller
    //
    // The reference for being in the running script list is shared with our caller.
    //
    hr = S_OK;
    *RetScriptEngine = ScriptEngine;
    ScriptEngine = NULL;

Cleanup:

    ASSERT(SUCCEEDED(hr) || hr == TYPE_E_ELEMENTNOTFOUND || hr == OLESCRIPT_E_SYNTAX || hr == E_OUTOFMEMORY );

    if ( ScriptEngine != NULL ) {
        ScriptEngine->FinalRelease();
    }

    if ( ClonedActiveScript != NULL ) {
        ClonedActiveScript->Release();
    }
    return (hr);
}


VOID
AzpReturnEngineToCache(
    IN PAZP_TASK Task,
    IN CScriptEngine *ScriptEngine
    )
/*++

Routine Description:

    Caller is done with the engine.  Return it to the cache.

Arguments:

    Task - Task containing the BizRule to process

    ScriptEngine - Specifies the script engine to free

Return Value:

    S_OK: a script engine was successfully returned

--*/
{
    HRESULT hr;
    PAZP_AZSTORE AzAuthorizationStore = Task->GenericObject.AzStoreObject;

    ASSERT( ScriptEngine != NULL);

    //
    // Remove the engine from the Running Script List
    //

    SafeEnterCriticalSection( &Task->RunningScriptCritSect );
    ScriptEngine->RemoveListEntry();
    SafeLeaveCriticalSection( &Task->RunningScriptCritSect );

    //
    // We want to reuse this engine.  Try to return it to the "Uninitialized"
    // state.  Some engine languages arent able to do this.  If it fails, deallocate
    // the engine; it cant be reused.
    //

    hr = ScriptEngine->ResetToUninitialized();

    if (FAILED(hr)) {
        // Engine doesnt support this, sigh.  Deallocate and continue.
        AzPrint((AZD_CRITICAL, "Engine doesn't support reset: 0x%lx\n", hr ));
        goto Cleanup;
    }



    //
    // If the script changed while this engine was running,
    //  Or if there was a GPF while then engine was running,
    //  then it might be in a corrupted state.
    //
    // In either case, delete the engine.
    //

    SafeEnterCriticalSection( &AzAuthorizationStore->FreeScriptCritSect );
    SafeEnterCriticalSection( &Task->RunningScriptCritSect );

    if ( ScriptEngine->GetBizRuleSerialNumber() != Task->BizRuleSerialNumber ||
         ScriptEngine->FIsCorrupted() ) {

        SafeLeaveCriticalSection( &AzAuthorizationStore->FreeScriptCritSect );
        SafeLeaveCriticalSection( &Task->RunningScriptCritSect );
        AzPrint((AZD_SCRIPT, "Script changed while engine was running\n" ));
        goto Cleanup;
    }

    //
    // Add the script to the free script list for potential re-use.
    //

    ScriptEngine->InsertHeadList( &Task->FreeScriptHead );
    ScriptEngine->InsertHeadLruList();
    ScriptEngine = NULL;

#ifdef ENABLE_PERF
    InterlockedIncrement( &AzGlPerfEnginesInFreeScriptList );
#endif

    //
    // If there are too many scripts cached,
    //  delete the least recently used engine.
    //

    if ( AzAuthorizationStore->LruFreeScriptCount > AzAuthorizationStore->MaxScriptEngines ) {
        PLIST_ENTRY ListEntry;
        PLIST_ELEMENT ListElement;

        AzPrint((AZD_SCRIPT, "Script LRU'ed out: %ld\n", AzAuthorizationStore->MaxScriptEngines ));

        //
        // Grab the entry from the tail of the list
        //

        ListEntry = AzAuthorizationStore->LruFreeScriptHead.Blink;

        ListElement = CONTAINING_RECORD( ListEntry,
                                         LIST_ELEMENT,
                                         Next );

        ASSERT( ListElement->This != NULL );
        ScriptEngine = ListElement->This;

        //
        // Delink it
        //
        ScriptEngine->RemoveListEntry();
        ScriptEngine->RemoveLruListEntry();  // Remove from the LRU list too
#ifdef ENABLE_PERF
        InterlockedDecrement( &AzGlPerfEnginesInFreeScriptList );
#endif

    }


    SafeLeaveCriticalSection( &Task->RunningScriptCritSect );
    SafeLeaveCriticalSection( &AzAuthorizationStore->FreeScriptCritSect );

Cleanup:
    if ( ScriptEngine != NULL ) {
        ScriptEngine->FinalRelease();
    }
    return;
}

VOID
AzpFlushBizRule(
    IN PAZP_TASK Task
    )
/*++

Routine Description:

    This routine flushes the bizrule cache.

    This routine is called whenever the bizrule script is changed

Arguments:

    Task - Task containing the BizRule to flush

    BizRuleResult - Result of the bizrule

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    OLESCRIPT_E_SYNTAX - The syntax of the bizrule is invalid
    Other exception status codes

--*/
{
    PAZP_AZSTORE AzAuthorizationStore = Task->GenericObject.AzStoreObject;
    PLIST_ENTRY ListEntry;
    PLIST_ELEMENT ListElement;
    CScriptEngine *ScriptEngine = NULL;

    //
    // Delete engines on the Free Script List
    //  Engines on the running script list are deleted as they finish running
    //

    SafeEnterCriticalSection( &AzAuthorizationStore->FreeScriptCritSect );
    while ( !IsListEmpty( &Task->FreeScriptHead ) ) {


        //
        // Remove the entry from the list
        //

        ListEntry = Task->FreeScriptHead.Flink;

        ListElement = CONTAINING_RECORD( ListEntry,
                                         LIST_ELEMENT,
                                         Next );

        ASSERT( ListElement->This != NULL );
        ScriptEngine = ListElement->This;

        ScriptEngine->RemoveListEntry();
        ScriptEngine->RemoveLruListEntry(); // Remove it from the LRU list too
        ScriptEngine->FinalRelease();

#ifdef ENABLE_PERF
        InterlockedDecrement( &AzGlPerfEnginesInFreeScriptList );
        InterlockedIncrement( &AzGlPerfEngineFlushes );
#endif

        AzPrint((AZD_SCRIPT, "Script Freed from free script list\n" ));

    }

    SafeLeaveCriticalSection( &AzAuthorizationStore->FreeScriptCritSect );

    return;
}

DWORD
AzpProcessBizRule(
    IN PACCESS_CHECK_CONTEXT AcContext,
    IN PAZP_TASK Task,
    OUT PBOOL BizRuleResult
    )
/*++

Routine Description:

    This routine is the main bizrule routine that determine whether a bizrule is satisfied.
    If the AzAuthorizationStore object's script engine timeout has been set to 0, then return
    the biz rule result as false without processing the biz rule.

    On entry, AcContext->ClientContext.CritSect must be locked.

Arguments:

    AcContext - Specifies the context of the accesscheck operation the bizrule is being evaluated for

    Task - Task containing the BizRule to process

    BizRuleResult - Result of the bizrule

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    OLESCRIPT_E_SYNTAX - The syntax of the bizrule is invalid
    Other exception status codes

--*/
{
    DWORD WinStatus;
    HRESULT hr;
    CScriptEngine *ScriptEngine = NULL;
    
    // BOOL fCoInit = FALSE;

    //
    // Check Root AzAuthorizationStore object's script engine timeout parameter
    //

    if ( (Task->GenericObject).AzStoreObject->ScriptEngineTimeout == 0 ) {
        WinStatus = NO_ERROR;
        *BizRuleResult = FALSE;
        goto Cleanup;
    }

    //
    // Initialization
    //

    ASSERT( AzpIsCritsectLocked( &AcContext->ClientContext->CritSect ) );
    *BizRuleResult = FALSE;

#if 0
    // init COM
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    ASSERT( hr != S_OK );   // engine caching breaks if com isn't already initialized
    if (hr == S_OK || hr == S_FALSE) {
        fCoInit = TRUE;
    } else if (hr != RPC_E_CHANGED_MODE) {
        WinStatus = AzpHresultToWinStatus(hr);
        AzPrint((AZD_CRITICAL, "CoInitializeEx failed: 0x%lx, %ld\n", hr, WinStatus));
        goto Cleanup;
    }
#endif // 0

    //
    // Get a script engine to run the script in
    //

    hr = AzpGetScriptEngine( Task, &ScriptEngine );

    if (FAILED(hr)) {
        WinStatus = AzpHresultToWinStatus(hr);
        AzPrint((AZD_CRITICAL, "AzpGetScriptEngine failed: 0x%lx, %ld\n", hr, WinStatus));
        goto Cleanup;
    }

    //
    // Run the script
    //
    
    hr = ScriptEngine->RunScript( AcContext, BizRuleResult );

    if (FAILED(hr)) {
        WinStatus = AzpHresultToWinStatus(hr);
        AzPrint((AZD_CRITICAL, "RunScript failed: 0x%lx, %ld\n", hr, WinStatus));
        *BizRuleResult = FALSE;
        goto Cleanup;
    }

    WinStatus = NO_ERROR;


    //
    // Free any local resources
    //
Cleanup:

    if (ScriptEngine != NULL) {
        AzpReturnEngineToCache( Task, ScriptEngine );
    }
#if 0
    if (fCoInit) {
        CoUninitialize();
    }
#endif // 0
    return WinStatus;

}

DWORD
AzpParseBizRule(
    IN PAZP_TASK Task
    )
/*++

Routine Description:


    This routine parses a bizrule to see if it is syntactically valid.

Arguments:

    Task - Task containing the BizRule to parse

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    OLESCRIPT_E_SYNTAX - The syntax of the bizrule is invalid

--*/
{
    DWORD WinStatus;
    HRESULT hr;
    CScriptEngine *ScriptEngine = NULL;
    BOOL fCoInit = FALSE;

    //
    // Initialization
    //

    // init COM
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    ASSERT( hr != S_OK );   // engine caching breaks if com isn't already initialized
    if (hr == S_OK || hr == S_FALSE) {
        fCoInit = TRUE;
    } else if (hr != RPC_E_CHANGED_MODE) {
        WinStatus = AzpHresultToWinStatus(hr);
        AzPrint((AZD_CRITICAL, "CoInitializeEx failed: 0x%lx, %ld\n", hr, WinStatus));
        goto Cleanup;
    }

    //
    // Get a script engine to run the script in
    //

    hr = AzpGetScriptEngine( Task, &ScriptEngine );

    if (FAILED(hr)) {
        WinStatus = AzpHresultToWinStatus(hr);
        AzPrint((AZD_CRITICAL, "AzpGetScriptEngine failed: 0x%lx, %ld\n", hr, WinStatus));
        goto Cleanup;
    }

    WinStatus = NO_ERROR;


    //
    // Free any local resources
    //
Cleanup:

    if (ScriptEngine != NULL) {
        AzpReturnEngineToCache( Task, ScriptEngine );
    }
    if (fCoInit) {
        CoUninitialize();
    }
    return WinStatus;

}

VOID
AzpInterruptScript(
    PVOID Parameter,
    BOOLEAN TimerFired
    )
/*++

Routine Description:

    This is the callback routine that fires when a script takes too long to execute

Arguments:

    Parameter - "This" pointer for the script that took too long

    TimerFired - Not used

Return Value:

    None

--*/
{
    CScriptEngine *ScriptEngine = (CScriptEngine *)Parameter;
    UNREFERENCED_PARAMETER( TimerFired );

    AzPrint((AZD_SCRIPT, "Script Timed out.\n"));
    ScriptEngine->InterruptScript();
}



//Constructor
CScriptEngine::CScriptEngine()
{
    //
    // Fields are initialized below in the order they are defined
    //

    m_cRef = 1;
    m_Task = NULL;

    ::InitializeListHead( &m_Next.Next );
    m_Next.This = this;

    ::InitializeListHead( &m_LruNext.Next );
    m_LruNext.This = this;

    m_Engine = NULL;
    m_Parser = NULL;
    m_BizRuleContext = NULL;
    m_AcContext = NULL;

    m_BaseThread = 0;

    m_BizRuleSerialNumber = 0;

    m_ScriptError = S_OK;

    m_fInited = FALSE;
    m_fCorrupted = FALSE;
    m_fTimedOut = FALSE;
    
    m_bCaseSensitive = TRUE;


    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine\n"));
}

//Destructor
CScriptEngine::~CScriptEngine()
{
    AzPrint((AZD_SCRIPT_MORE, "~CScriptEngine\n"));

    //
    // Assert that FinalRelease was called
    //
    ASSERT( m_Engine == NULL );
    ASSERT( m_Parser == NULL );
    ASSERT( m_BizRuleContext == NULL );
    ASSERT( m_AcContext == NULL );
    ASSERT( IsListEmpty( &m_Next.Next ) );

}


HRESULT
CScriptEngine::Init(
    IN PAZP_TASK Task,
    IN IActiveScript *ClonedActiveScript OPTIONAL,
    IN DWORD ClonedBizRuleSerialNumber OPTIONAL
    )
/*++

Routine Description:

    This routine creates the ActiveX Scripting Engine and initializes it.

Arguments:

    Task - Task containing the BizRule to process

    ClonedActiveScript - Pointer to an instance of a cloned script engine.
        NULL: This is a new script engine and not a clone.

        This routine always steals ClonedActiveScript and will always release it sooner
        or later.  The caller should not use this argument after making this call.

    ClonedBizRuleSerialNumber - Serial number of the bizrule parsed by ClonedActiveScript.

Return Value:

    HRESULT status of the operation

--*/
{
    HRESULT hr;
    LPWSTR BizRule = NULL;

    EXCEPINFO ParseExceptionInfo;

    //
    // Initialization
    //

    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::InitializeScriptEngine\n"));

    if ( m_fInited ) {
        ASSERT(!m_fInited);
        hr = AZ_HRESULT(ERROR_ALREADY_INITIALIZED);


        if ( ClonedActiveScript != NULL ) {
            ClonedActiveScript->Release();
        }
        goto Cleanup;
    }

    m_Task = Task;


    //
    // If this is a clone,
    //  simply steal the passed in pointer to the script engine.
    //

    if ( ClonedActiveScript != NULL ) {
        m_Engine = ClonedActiveScript;

    //
    // If this isn't a clone,
    //  instantiate a script engine
    //

    } else {

        //
        // Convert the language name to a Clsid
        //

        if ( IsEqualGUID( Task->BizRuleLanguageClsid, AzGlZeroGuid ) ) {

            hr = CLSIDFromProgID( Task->BizRuleLanguage.String, &Task->BizRuleLanguageClsid);

            if (FAILED(hr)) {
                AzPrint((AZD_CRITICAL, "Failed to get scripting engine CLSID: 0x%lx\n", hr));
                goto Cleanup;
            }
            
            //
            // determine if our language is case-sensitive or not
            //
            
            m_bCaseSensitive = _wcsicmp(Task->BizRuleLanguage.String, L"VBScript") != 0;
        }


        //
        // Create the scripting engine with a call to CoCreateInstance,
        // placing the created engine in m_Engine.
        //
        hr = CoCreateInstance( Task->BizRuleLanguageClsid,
                               NULL, // Not part of an aggregate
                               CLSCTX_INPROC_SERVER,        // In process
                               IID_IActiveScript,
                               (void **)&m_Engine);

        if (FAILED(hr)) {
            AzPrint((AZD_CRITICAL, "Failed to create scripting engine: 0x%lx\n", hr));
            goto Cleanup;
        }
    }

    //
    // Query for the IActiveScriptParse interface of the engine
    //

    TRYCATCH_HR(m_Engine->QueryInterface(IID_IActiveScriptParse, (void **)&m_Parser), hr, "IActiveScript::QueryInterface()");
    if (FAILED(hr)) {
        AzPrint((AZD_CRITICAL, "Engine doesn't support IActiveScriptParse: 0x%lx\n", hr));
        goto Cleanup;
    } else if ( m_Parser == NULL ) {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Create an object for the script to interact with.
    //
    hr = CoCreateInstance( CLSID_AzBizRuleContext,
                           NULL, // Not part of an aggregate
                           CLSCTX_INPROC_SERVER,        // In process
                           IID_IAzBizRuleContext,
                           (void **)&m_BizRuleContext);

    if (FAILED(hr)) {
        AzPrint((AZD_CRITICAL, "Failed to create AzBizRuleContext instance: 0x%lx\n", hr));
        goto Cleanup;
    }

    //
    // Remember the thread ID of this thread.
    //  Only this thread can re-use the engine without going to unitialized state first
    //

    TRYCATCH_HR(m_Engine->GetCurrentScriptThreadID( &m_BaseThread), hr, "IActiveScript::GetCurrentScriptThreadID()");
    if (FAILED(hr)) {
        AzPrint((AZD_CRITICAL, "Error calling GetCurrentScriptThreadID: 0x%lx\n", hr));
        goto Cleanup;
    }
    AzPrint((AZD_SCRIPT, "Set ThreadId to: 0x%lx 0x%lx\n", this, m_BaseThread));

    //
    // The engine needs to know the host it runs on.
    //
    // Once we've set the script site, IActiveScript can call back
    m_fInited = TRUE;
    TRYCATCH_HR(m_Engine->SetScriptSite((IActiveScriptSite *) this), hr, "IActiveScript::SetScriptSite()");
    if (FAILED(hr)) {
        AzPrint((AZD_CRITICAL, "Error calling SetScriptSite: 0x%lx\n", hr));
        m_fInited = FALSE;
        goto Cleanup;
    }



    //
    // If this isn't a clone,
    //  the parse the script.
    //

    if ( ClonedActiveScript == NULL ) {

        //
        // Initialize the script engine so it's ready to run.
        //

        TRYCATCH_HR(m_Parser->InitNew(), hr, "IActiveScriptParse::InitNew()");
        if (FAILED(hr)) {
            AzPrint((AZD_CRITICAL, "Error calling InitNew: 0x%lx\n", hr));
            goto Cleanup;
        }

        //
        // Add the name of the object that will respond to the script
        //

        TRYCATCH_HR( m_Engine->AddNamedItem( BIZRULE_CONTEXT_INTERFACE_NAME,
                                             SCRIPTITEM_ISPERSISTENT | SCRIPTITEM_ISVISIBLE ),
                     hr,
                     "IActiveScript::AddNamedItem()" );

        if (FAILED(hr)) {
            AzPrint((AZD_CRITICAL, "Failed to AddNamedItem: 0x%lx\n", hr));
            goto Cleanup;
        }

        //
        // Grab a copy of the bizrule
        //

        SafeEnterCriticalSection( &Task->RunningScriptCritSect );

        SafeAllocaAllocate( BizRule, Task->BizRule.StringSize );
        if ( BizRule == NULL ) {
            SafeLeaveCriticalSection( &Task->RunningScriptCritSect );
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        RtlCopyMemory( BizRule, Task->BizRule.String, Task->BizRule.StringSize );
        m_BizRuleSerialNumber = Task->BizRuleSerialNumber;
        SafeLeaveCriticalSection( &Task->RunningScriptCritSect );

        //
        //
        // Pass the script to be run to the script engine.
        //  I don't know what SCRIPTTEXT_HOSTMANAGESSOURCE is but IIS sets it so I will.
        //

        TRYCATCH_HR( m_Parser->ParseScriptText( BizRule,
                                                NULL,       // pstrItemName
                                                NULL,       // punkContext
                                                NULL,       // pstrDelimiter
                                                0,          // dwSourceContextCookie
                                                1,          // ulStartingLineNumber
                                                SCRIPTTEXT_ISPERSISTENT | SCRIPTTEXT_HOSTMANAGESSOURCE,
                                                NULL,        // pvarResult
                                                &ParseExceptionInfo),        // exception info filled in on error
                     hr,
                    "IActiveScriptParse::ParseScriptText()");

        if (FAILED(hr)) {
            AzPrint((AZD_CRITICAL, "Failed to ParseScriptText: 0x%lx\n", hr));
            goto Cleanup;
        }

    //
    // If it is a clone,
    //  clone the bizrule serial number.
    //
    } else {
        m_BizRuleSerialNumber = ClonedBizRuleSerialNumber;
    }


    //
    // Done initialization
    //
    AssertValid();

    hr = S_OK;

Cleanup:
    SafeAllocaFree( BizRule );
    if ( FAILED(hr)) {

        // Note: Our caller has to call FinalRelease which will do most of the cleanup
    }
    return hr;

}

HRESULT
CScriptEngine::RunScript(
    IN PACCESS_CHECK_CONTEXT AcContext,
    OUT PBOOL BizRuleResult
    )
/*++

Routine Description:

    This routine runs an initialized script

Arguments:

    AcContext - Specifies the context of the accesscheck operation the bizrule is being evaluated for
    
    BizRuleResult - Result of the bizrule

Return Value:

    HRESULT describing whether the operation worked

--*/
{
    HRESULT hr;
    PAZP_AZSTORE AzAuthorizationStore = m_Task->GenericObject.AzStoreObject;
    BOOLEAN InterfaceNamesLocked = FALSE;
    BOOLEAN InterfaceFlagsLocked = FALSE;
    VARIANT varName;
    VARIANT varFlag;

    HANDLE TimerHandle = INVALID_HANDLE_VALUE;
    HRESULT ScriptErrorFromAccessCheck = S_OK;

    //
    // Initialization
    //
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::RunScript\n"));
    AssertValid();
    m_ScriptError = S_OK;
    m_AcContext = AcContext;

    VariantInit(&varName);
    VariantInit(&varFlag);

    //
    // Tell the access check object the context of the current access check
    //

    SetAccessCheckContext( static_cast<CAzBizRuleContext *> (m_BizRuleContext), m_bCaseSensitive, AcContext, BizRuleResult, &ScriptErrorFromAccessCheck );

    //
    // Add each interface that the caller passed to access check
    //

    if ( AcContext->Interfaces != NULL ) {
        VARIANT HUGEP *varNames;
        VARIANT HUGEP *varFlags;
        ULONG Index;

        //
        // We didn't capture the array
        //  So access it under a try/except
        __try {

            //
            // Access the variant arrays directly
            //
            ASSERT( AcContext->InterfaceNames != NULL && AcContext->InterfaceFlags != NULL );

            hr = SafeArrayAccessData( AcContext->InterfaceNames, (void HUGEP **)&varNames);
            _JumpIfError(hr, Cleanup, "SafeArrayAccessData");
            InterfaceNamesLocked = TRUE;

            hr = SafeArrayAccessData( AcContext->InterfaceFlags, (void HUGEP **)&varFlags);
            _JumpIfError(hr, Cleanup, "SafeArrayAccessData");
            InterfaceFlagsLocked = TRUE;

            //
            // Loop adding each name
            //

            for ( Index=0; Index<AcContext->InterfaceNames->rgsabound[0].cElements; Index++ ) {

                //
                // Stop at the end of the array
                //
                if ( V_VT(&varNames[Index]) == VT_EMPTY ) {
                    break;
                }

                //
                // Convert the interface name to a BSTR
                //
                hr = VariantChangeType(&varName, &varNames[Index], 0, VT_BSTR);
                _JumpIfError(hr, Cleanup, "VariantChangeType");


                //
                // Convert the flags to a LONG
                //

                hr = VariantChangeType(&varFlag, &varFlags[Index], 0, VT_I4 );
                _JumpIfError(hr, Cleanup, "VariantChangeType");


                //
                // Add the name of the object that will respond to the script
                //  Ignore SCRIPTITEM_ISPERSISTENT since that would invalidate our caching.
                //

                TRYCATCH_HR( m_Engine->AddNamedItem(
                                    V_BSTR(&varName),
                                    (V_I4(&varFlag) | SCRIPTITEM_ISVISIBLE) & ~SCRIPTITEM_ISPERSISTENT ),
                             hr,
                             "IActiveScript::AddNamedItem()" );

                if (FAILED(hr)) {
                    AzPrint((AZD_CRITICAL, "Failed to AddNamedItem: 0x%lx\n", hr));
                    goto Cleanup;
                }

                //
                // Clean up
                //
                VariantClear(&varName);
                VariantClear(&varFlag);
            }
        } __except( EXCEPTION_EXECUTE_HANDLER ) {

            hr = GetExceptionCode();
            AzPrint((AZD_CRITICAL, "RunScript took an exception: 0x%lx\n", hr));
            goto Cleanup;
        }
    }

    //
    // Queue a timer to kill the engine if it takes too long
    //

    m_fTimedOut = FALSE;
    if ( !CreateTimerQueueTimer(
            &TimerHandle,
            AzAuthorizationStore->ScriptEngineTimerQueue,
            AzpInterruptScript,
            this,
            AzAuthorizationStore->ScriptEngineTimeout,
            0,  // Not a period timer
            0 ) ) { // No special flags

        hr = AZ_HRESULT(GetLastError());
        goto Cleanup;
    }


    //
    // Tell the engine to start processing the script with a call to
    // SetScriptState().
    //
    __try {
        hr = m_Engine->SetScriptState( SCRIPTSTATE_STARTED );
    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        hr = GetExceptionCode();
        AzPrint((AZD_CRITICAL, "Script took an exception: 0x%lx\n", hr));

        // Dont reuse the engine
        m_fCorrupted = TRUE;
    }

    if (FAILED(hr)) {
        AzPrint((AZD_CRITICAL, "Failed to SetScriptState(STARTED): 0x%lx\n", hr));
        goto Cleanup;
    }


    //
    // See if IAzBizRuleContext detected an error
    //

    if ( ScriptErrorFromAccessCheck != S_OK ) {
        hr = ScriptErrorFromAccessCheck;
        AzPrint((AZD_CRITICAL, "Script from access check to caller: 0x%lx\n", hr));
        goto Cleanup;
    }

    //
    // See if the script had an error
    //

    if ( m_ScriptError != S_OK ) {
        hr = m_ScriptError;
        AzPrint((AZD_SCRIPT, "Return script error to caller: 0x%lx\n", hr));
        goto Cleanup;
    }



    hr = S_OK;

Cleanup:

    //
    // Delete any timer
    if ( TimerHandle != INVALID_HANDLE_VALUE ) {
        if ( !DeleteTimerQueueTimer(
                    AzAuthorizationStore->ScriptEngineTimerQueue,
                    TimerHandle,
                    INVALID_HANDLE_VALUE ) ) {

            AzPrint((AZD_CRITICAL, "Cannot DeleteTimerQueurTimer: %ld\n", GetLastError() ));
        }
    }

    //
    // Cleanup from adding interfaces
    //
    if ( AcContext->Interfaces != NULL ) {

        //
        // We didn't capture the array
        //  So access it under a try/except
        __try {
            if ( InterfaceNamesLocked ) {
                SafeArrayUnaccessData( AcContext->InterfaceNames );
            }
            if ( InterfaceFlagsLocked ) {
                SafeArrayUnaccessData( AcContext->InterfaceFlags );
            }
        } __except( EXCEPTION_EXECUTE_HANDLER ) {

            AzPrint((AZD_CRITICAL, "RunScript took an exception: 0x%lx\n", hr));
        }

        VariantClear(&varName);
        VariantClear(&varFlag);
    }

    //
    // Tell the access check object to forget about the current access check
    //

    SetAccessCheckContext( static_cast<CAzBizRuleContext *> (m_BizRuleContext), TRUE, NULL, NULL, NULL );

    return hr;

}

HRESULT
CScriptEngine::InterruptScript(
    VOID
    )
/*++

Routine Description:

    This routine runs stops a currently running script

Arguments:

    None

Return Value:

    HRESULT describing whether the operation worked

--*/
{
    HRESULT hr;
    EXCEPINFO excepinfo;

    //tracing purposes only
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::InterruptScript\n"));
    AssertValid();


    //
    // Fill in the excepinfo.  This will be passed to OnScriptError
    //

    RtlZeroMemory( &excepinfo, sizeof(EXCEPINFO));
    excepinfo.wCode = ERROR_TIMEOUT;
    m_fTimedOut = TRUE;

    //
    // Blow the script away
    //

    TRYCATCH_HR(m_Engine->InterruptScriptThread(
                            SCRIPTTHREADID_BASE,       // The thread in which the engine was instantiated
                            &excepinfo,
                            0 ),
                hr,
                "IActiveScript::InterruptScriptThread()");
    return hr;
}

HRESULT
CScriptEngine::ResetToUninitialized()
/*++

Routine Description:

    When we want to reuse an engine, we reset it to an uninited state
    before putting it on the FreeScript list

Arguments:

    None

Return Value:

    HRESULT describing whether the operation worked

--*/
{
    HRESULT hr = S_OK;
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::ResetToUninitialized\n"));

    //
    // Release interfaces, they will need to be re-gotten when
    // the engine is reused
    //
    if (m_Parser) {
        TRYCATCH(m_Parser->Release(), "IActiveScriptParse::Release()");
        m_Parser = NULL;
    }

    //
    // Set the script state to Uninitialized
    //  IIS sets the state to uninitialized here.  That does not give good performance.
    //  Setting it to initialized give better performance as long as the next thread to
    //  reuse the engine comes in on the same thread.
    //
    if (m_Engine) {

        TRYCATCH_HR(m_Engine->SetScriptState( SCRIPTSTATE_INITIALIZED ), hr, "IActiveScript::SetScriptState()");
        if (FAILED(hr)) {
            AzPrint((AZD_CRITICAL, "Failed to SetScriptState(INITIALIZED): 0x%lx\n", hr));
        }
    }

    //
    // Indicate the the bizrule is no longer associated with a particular access check
    //  ... Can't do this until the script state is set
    //

    m_AcContext = NULL;

    return (hr);
}

HRESULT
CScriptEngine::ReuseEngine(
    VOID
    )
/*++

Routine Description:

    When reusing an engine from the FreeScript list, this routine is called
    to set the script engine to the initialized state.

    Basically, this routine undoes the effects of ResetToUninitialized.

Arguments:

    None

Return Value:

    HRESULT describing whether the operation worked

--*/
{
    HRESULT hr;

    SCRIPTSTATE nScriptState = SCRIPTSTATE_UNINITIALIZED;
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::ReuseEngine\n"));

    //
    // IIS enters this routine with an INITIALIZED engine when debugging the script.
    // In that case, it only sets the script site if the state is uninitilized.
    // We'll always be initialized.
    //

    TRYCATCH_HR(m_Engine->GetScriptState(&nScriptState), hr, "IActiveScript::GetScriptState()");
    if (FAILED(hr)) {
        AzPrint((AZD_CRITICAL, "Failed to GetScriptState: 0x%lx\n", hr));
        goto Cleanup;
    }

    //
    // If the script engine has thread state,
    //  ditch it.
    //

    if ( nScriptState == SCRIPTSTATE_INITIALIZED ) {
        SCRIPTTHREADID ThreadId = 0;

        //
        // Get the thread id of the current thread
        //

        TRYCATCH_HR(m_Engine->GetCurrentScriptThreadID( &ThreadId), hr, "IActiveScript::GetCurrentScriptThreadID()");
        if (FAILED(hr)) {
            AzPrint((AZD_CRITICAL, "Error calling GetCurrentScriptThreadID: 0x%lx\n", hr));
            goto Cleanup;
        }

        //
        // If this thread isn't the thread that put the engine into initialized state,
        //  then go to uninitialized state do clear the engines thread local storage.
        //

        if ( m_BaseThread != ThreadId ) {
            TRYCATCH_HR(m_Engine->SetScriptState( SCRIPTSTATE_UNINITIALIZED), hr, "IActiveScript::SetScriptState()");

            if (FAILED(hr)) {
                AzPrint((AZD_CRITICAL, "Failed to SetScriptState(UNINITIALIZED): 0x%lx\n", hr));
                goto Cleanup;
            }

            nScriptState = SCRIPTSTATE_UNINITIALIZED;
            m_BaseThread = ThreadId;
            AzPrint((AZD_SCRIPT, "Changed ThreadId to: 0x%lx 0x%lx\n", this, m_BaseThread));
        }

    }


    //
    // The engine needs to know the host it runs on.
    //
    if ( nScriptState == SCRIPTSTATE_UNINITIALIZED ) {
        TRYCATCH_HR(m_Engine->SetScriptSite((IActiveScriptSite *) this), hr, "IActiveScript::SetScriptSite()");
        if (FAILED(hr)) {
            AzPrint((AZD_CRITICAL, "Error calling SetScriptSite: 0x%lx\n", hr));
            goto Cleanup;
        }
    }

    //
    // Query for the IActiveScriptParse interface of the engine
    //

    TRYCATCH_HR(m_Engine->QueryInterface(IID_IActiveScriptParse, (void **)&m_Parser), hr, "IActiveScript::QueryInterface()");
    if (FAILED(hr)) {
        AzPrint((AZD_CRITICAL, "Engine doesn't support IActiveScriptParse: 0x%lx\n", hr));
        goto Cleanup;
    } else if ( m_Parser == NULL ) {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = S_OK;

    AssertValid();

Cleanup:
    return (hr);
}

BOOL
CScriptEngine::IsBaseThread(
    VOID
    )
/*++

Routine Description:

    Returns TRUE if the calling thread is the base thread that initialized the engine

Arguments:

    None

Return Value:

    TRUE - The calling thread is the base thread

--*/
{
    HRESULT hr;
    SCRIPTTHREADID ThreadId = 0;

    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::IsBaseThread\n"));

    ASSERT( m_Engine != NULL );

    //
    // Get the thread id of the current thread
    //

    TRYCATCH_HR(m_Engine->GetCurrentScriptThreadID( &ThreadId), hr, "IActiveScript::GetCurrentScriptThreadID()");
    if (FAILED(hr)) {
        AzPrint((AZD_CRITICAL, "Error calling GetCurrentScriptThreadID: 0x%lx\n", hr));
        return FALSE;
    }

    //
    // Check to see if it is the base thread
    //

    return m_BaseThread == ThreadId;
}


VOID
CScriptEngine::FinalRelease(
    VOID
    )
/*++

Routine Description:

    Call this when we are done with the object - Like release but
    it removes all of the interfaces we got, so that the ref.
    count will be zero when last external user is done with the engine.

Arguments:

    None

Return Value:

    None

--*/
{
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::FinalRelease\n"));

    //
    // Free all of the interfaces used by the script engine
    //

    if (m_BizRuleContext != NULL) {
        m_BizRuleContext->Release();
        m_BizRuleContext = NULL;
    }

    if (m_Parser) {
        TRYCATCH(m_Parser->Release(), "IActiveScriptParse::Release()");
        m_Parser = NULL;
    }

    if (m_Engine) {
        HRESULT hr;

        // Engine needs to be in uninitialized state before closing.
        //  This is only needed if a different thread than this one put it in the
        //  initialized state.
        //
        //  This is a hack.  If I can set it from initialized to uninitialized in a different
        //  thread, then why can't close do it in a different thread.
        //
        TRYCATCH_HR(m_Engine->SetScriptState( SCRIPTSTATE_UNINITIALIZED), hr, "IActiveScript::SetScriptState()");

        if (FAILED(hr)) {
            AzPrint((AZD_CRITICAL, "Failed to SetScriptState(UNINITIALIZED): 0x%lx\n", hr));
            ASSERT(SUCCEEDED(hr));
        }

        //
        // Close the engine before releasing it.
        //
        TRYCATCH_HR(m_Engine->Close(), hr, "IActiveScript::Close()");

        if (FAILED(hr)) {
            AzPrint((AZD_CRITICAL, "Cannot CloseEngine: 0x%lx\n", hr ));
            ASSERT(SUCCEEDED(hr));
        }

        // Then we can release it
        TRYCATCH(m_Engine->Release(), "IActiveScript::Release()");

        m_Engine = NULL;
    }

    //
    // We must be the last reference
    //

#if DBG
    ULONG cRefs = Release();
    ASSERT(cRefs == 0);
#else
    Release();
#endif //DBG

    return;
}


VOID
CScriptEngine::InsertHeadList(
    IN PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    This routine inserts this ScriptEngine object at the head of the list specified.
    The caller must ensure this object is in at most only one list.
    The caller must provide any serialization.

Arguments:

    ListHead - List to insert the object into.

Return Value:

    None.

--*/
{
    //tracing purposes only
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::InsertHeadList\n"));

    ::InsertHeadList( ListHead, &m_Next.Next );
    // m_Next.This = this;

}

VOID
CScriptEngine::RemoveListEntry(
    VOID
    )
/*++

Routine Description:

    This routine removes this ScriptEngine object from whatever list it is in.
    The caller must ensure this object is in a list.
    The caller must provide any serialization.

Arguments:

    None

Return Value:

    None.

--*/
{
    //tracing purposes only
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::RemoveListEntry\n"));

    ::RemoveEntryList( &m_Next.Next );
    ::InitializeListHead( &m_Next.Next );
    // m_Next.This = this;

}

VOID
CScriptEngine::InsertHeadLruList(
    VOID
    )
/*++

Routine Description:

    This routine inserts this ScriptEngine object at the head of the LRU list.

    The caller must provide any serialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PAZP_AZSTORE AzAuthorizationStore = m_Task->GenericObject.AzStoreObject;
    //tracing purposes only
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::InsertHeadLruList\n"));

    ::InsertHeadList( &AzAuthorizationStore->LruFreeScriptHead, &m_LruNext.Next );
    AzAuthorizationStore->LruFreeScriptCount ++;
    // m_Next.This = this;

}

VOID
CScriptEngine::RemoveLruListEntry(
    VOID
    )
/*++

Routine Description:

    This routine removes this ScriptEngine object from whatever LRU list it is in.
    The caller must ensure this object is in a list.
    The caller must provide any serialization.

Arguments:

    None

Return Value:

    None.

--*/
{
    PAZP_AZSTORE AzAuthorizationStore = m_Task->GenericObject.AzStoreObject;
    //tracing purposes only
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::RemoveLruListEntry\n"));

    ::RemoveEntryList( &m_LruNext.Next );
    ::InitializeListHead( &m_LruNext.Next );
    AzAuthorizationStore->LruFreeScriptCount --;
    // m_Next.This = this;

}


/******************************************************************************
*   IUnknown Interfaces -- All COM objects must implement, either directly or
*   indirectly, the IUnknown interface.
******************************************************************************/

STDMETHODIMP CScriptEngine::QueryInterface(REFIID riid, void **ppvObj)
/*++

Routine Description:

    Standard COM QueryInterface routine.

    Determines if this component supports the requested interface.

Arguments:

    riid - Id of the interface being queried

    ppvObj - On success, returns a pointer to that interface.

Return Value:

    S_OK: ppvObj is returned
    E_NOINTERFACE: riid is not supported

--*/
{
    //tracing purposes only
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::QueryInterface->"));

    //
    // Only two interfaces are supported
    //
    if (riid == IID_IUnknown) {
        AzPrint((AZD_SCRIPT_MORE, "IUnknown\n"));
        *ppvObj = static_cast < IActiveScriptSite * >(this);

    } else if (riid == IID_IActiveScriptSite) {
        AzPrint((AZD_SCRIPT_MORE, "IActiveScriptSite\n"));
        *ppvObj = static_cast < IActiveScriptSite * >(this);

    } else {
        AzPrint((AZD_SCRIPT_MORE, "Unsupported Interface: "));
        AzpDumpGuid(AZD_SCRIPT_MORE, (GUID *) & riid);
        AzPrint((AZD_SCRIPT_MORE, "\n"));

        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    static_cast < IUnknown * >(*ppvObj)->AddRef();
    return S_OK;
}

/******************************************************************************
*   AddRef() -- In order to allow an object to delete itself when it is no
*   longer needed, it is necessary to maintain a count of all references to
*   this object.  When a new reference is created, this function increments
*   the count.
******************************************************************************/
STDMETHODIMP_(ULONG) CScriptEngine::AddRef()
{
    ULONG cRef;

    cRef = InterlockedIncrement(&m_cRef);

    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::AddRef %ld\n", cRef ));
    return(cRef);
}

/******************************************************************************
*   Release() -- When a reference to this object is removed, this function
*   decrements the reference count.  If the reference count is 0, then this
*   function deletes this object and returns 0;
******************************************************************************/
STDMETHODIMP_(ULONG) CScriptEngine::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::Release %ld\n", cRef));

    if (0 == cRef) {
        delete this;
    }
    return(cRef);
}

/******************************************************************************
*   IActiveScriptSite Interfaces -- These interfaces define the exposed methods
*   of ActiveX Script Hosts.
******************************************************************************/

/******************************************************************************
*   GetLCID() -- Gets the identifier of the host's user interface.  This method
*   returns S_OK if the identifier was placed in plcid, E_NOTIMPL if this
*   function is not implemented, in which case the system-defined identifier
*   should be used, and E_POINTER if the specified pointer was invalid.
******************************************************************************/
STDMETHODIMP CScriptEngine::GetLCID(LCID * plcid)
{
    //tracing purposes only
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::GetLCID\n"));
    UNREFERENCED_PARAMETER(plcid);

    return E_NOTIMPL;
}

/******************************************************************************
*   GetItemInfo() -- Retrieves information about an item that was added to the
*   script engine through a call to AddNamedItem.
*   Parameters:   pstrName -- the name of the item, specified in AddNamedItem.
*            dwReturnMask -- Mask indicating what kind of pointer to return
*               SCRIPTINFO_IUNKNOWN or SCRIPTINFO_ITYPEINFO
*            ppunkItem -- return spot for an IUnknown pointer
*            ppTypeInfo -- return spot for an ITypeInfo pointer
*   Returns:   S_OK if the call was successful
*            E_INVALIDARG if one of the arguments was invalid
*            E_POINTER if one of the pointers was invalid
*            TYPE_E_ELEMENTNOTFOUND if there wasn't an item of the
*               specified type.
******************************************************************************/
STDMETHODIMP CScriptEngine::GetItemInfo(
               LPCOLESTR pstrName,
               DWORD dwReturnMask,
               IUnknown ** ppunkItem,
               ITypeInfo ** ppTypeInfo
)
{
    HRESULT hr;

    VARIANT varName;
    VARIANT varInterface;
    IDispatch *Interface = NULL;
    BOOLEAN InterfaceNamesLocked = FALSE;

    //
    // Initialization
    //
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::GetItemInfo: %ws\n", pstrName));
    VariantInit( &varName );
    VariantInit( &varInterface );


    //Use logical ANDs to determine which type(s) of pointer the caller wants,
    //and make sure that that placeholder is currently valid.
    if (dwReturnMask & SCRIPTINFO_IUNKNOWN) {
        if (!ppunkItem) {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        *ppunkItem = NULL;
    }
    if (dwReturnMask & SCRIPTINFO_ITYPEINFO) {
        if (!ppTypeInfo) {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        *ppTypeInfo = NULL;
    }

    //
    // We didn't capture the array
    //  So access it under a try/except
    __try {

        //
        // Check for the BizRuleContext interface itself
        //
        if (!_wcsicmp( BIZRULE_CONTEXT_INTERFACE_NAME, pstrName)) {

            //
            // Use the access check interface
            //
            Interface = m_BizRuleContext;

        //
        // If the caller passed interfaces to access check,
        //  look there.
        //

        } else if ( m_AcContext != NULL && m_AcContext->Interfaces != NULL ) {
            VARIANT HUGEP *varNames;
            ULONG Index;
            LONG InterfacesIndex;

            //
            // Convert name to an easier form to compare
            //

            V_VT(&varName) = VT_BSTR;
            V_BSTR(&varName) = (BSTR) pstrName;

            //
            // Access the variant array directly
            //
            ASSERT( m_AcContext->InterfaceNames != NULL && m_AcContext->InterfaceFlags != NULL );

            hr = SafeArrayAccessData( m_AcContext->InterfaceNames, (void HUGEP **)&varNames);
            _JumpIfError(hr, Cleanup, "SafeArrayAccessData");
            InterfaceNamesLocked = TRUE;


            //
            // Find an interface name that matches the passed in name
            //

            for ( Index=0; Index<m_AcContext->InterfaceNames->rgsabound[0].cElements; Index++ ) {

                //
                // Stop at the end of the array
                //
                if ( V_VT(&varNames[Index]) == VT_EMPTY ) {
                    break;
                }

                if ( VarCmp( &varName, &varNames[Index], LOCALE_USER_DEFAULT, NORM_IGNORECASE ) == (HRESULT)VARCMP_EQ ) {

                    //
                    // Copy out the array element.
                    //

                    InterfacesIndex = m_AcContext->InterfaceLower + Index;

                    hr = SafeArrayGetElement( m_AcContext->Interfaces, &InterfacesIndex, &varInterface );
                    _JumpIfError(hr, Cleanup, "SafeArrayGetElement");

                    //
                    // Ensure it is an IDispatch interface
                    //

                    if ( V_VT( &varInterface ) != VT_DISPATCH ) {
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }

                    //
                    // Use the passed in interface
                    //

                    Interface = V_DISPATCH( &varInterface );
                    break;
                }

            }
        }

        //
        // If no interface was found,
        //  fail
        //

        if ( Interface == NULL ) {
            hr = TYPE_E_ELEMENTNOTFOUND;
            goto Cleanup;
        }

        //
        // If an interface was found,
        //  return the requested information about the interface.
        //

        hr = S_OK;
        if (dwReturnMask & SCRIPTINFO_IUNKNOWN) {
            Interface->QueryInterface(IID_IUnknown, (void **)ppunkItem);
        }

        if (dwReturnMask & SCRIPTINFO_ITYPEINFO) {
            hr = Interface->GetTypeInfo( 0, 0, ppTypeInfo );
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        hr = GetExceptionCode();
        AzPrint((AZD_CRITICAL, "GetItemInfo took an exception: 0x%lx\n", hr));
        goto Cleanup;
    }

Cleanup:
    //
    // Cleanup from finding interfaces
    //
    if ( m_AcContext != NULL && m_AcContext->Interfaces != NULL ) {

        //
        // We didn't capture the array
        //  So access it under a try/except
        __try {
            if ( InterfaceNamesLocked ) {
                SafeArrayUnaccessData( m_AcContext->InterfaceNames );
            }

        } __except( EXCEPTION_EXECUTE_HANDLER ) {

            AzPrint((AZD_CRITICAL, "GetItemInfo took an exception: 0x%lx\n", hr));
        }

        VariantClear(&varName);
        VariantClear(&varInterface);
    }
    return hr;
}

/******************************************************************************
*   GetDocVersionString() -- It is possible, even likely that a script document
*   can be changed between runs.  The host can define a unique version number
*   for the script, which can be saved along with the script.  If the version
*   changes, the engine will know to recompile the script on the next run.
******************************************************************************/
STDMETHODIMP CScriptEngine::GetDocVersionString(BSTR * pbstrVersionString)
{
    //tracing purposes only
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::GetDocVersionString\n"));
    UNREFERENCED_PARAMETER(pbstrVersionString);

    //For the generic case, this function isn't implemented.
    return E_NOTIMPL;
}

/******************************************************************************
*   OnScriptTerminate() -- This method may give the host a chance to react when
*   the script terminates.  pvarResult give the result of the script or NULL
*   if the script doesn't give a result, and pexcepinfo gives the location of
*   any exceptions raised by the script.  Returns S_OK if the calls succeeds.
******************************************************************************/
STDMETHODIMP CScriptEngine::OnScriptTerminate(const VARIANT * pvarResult,
                  const EXCEPINFO * pexcepinfo)
{
    //tracing purposes only
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::OnScriptTerminate\n"));
    UNREFERENCED_PARAMETER(pvarResult);
    UNREFERENCED_PARAMETER(pexcepinfo);

    //If something needs to happen when the script terminates, put it here.
    return S_OK;
}

/******************************************************************************
*   OnStateChange() -- This function gives the host a chance to react when the
*   state of the script engine changes.  ssScriptState lets the host know the
*   new state of the machine.  Returns S_OK if successful.
******************************************************************************/
STDMETHODIMP CScriptEngine::OnStateChange(SCRIPTSTATE ssScriptState)
{
    //tracing purposes only
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::OnStateChange:"));

    //If something needs to happen when the script enters a certain state,
    //put it here.
    switch (ssScriptState) {
    case SCRIPTSTATE_UNINITIALIZED:
        AzPrint((AZD_SCRIPT_MORE, "State: Uninitialized.\n"));
        break;
    case SCRIPTSTATE_INITIALIZED:
        AzPrint((AZD_SCRIPT_MORE, "State: Initialized.\n"));
        break;
    case SCRIPTSTATE_STARTED:
        AzPrint((AZD_SCRIPT_MORE, "State: Started.\n"));
        break;
    case SCRIPTSTATE_CONNECTED:
        AzPrint((AZD_SCRIPT_MORE, "State: Connected.\n"));
        break;
    case SCRIPTSTATE_DISCONNECTED:
        AzPrint((AZD_SCRIPT_MORE, "State: Disconnected.\n"));
        break;
    case SCRIPTSTATE_CLOSED:
        AzPrint((AZD_SCRIPT_MORE, "State: Closed.\n"));
        break;
    default:
        break;
    }

    return S_OK;
}

/******************************************************************************
*   OnScriptError() -- This function gives the host a chance to respond when
*   an error occurs while running a script.  pase holds a reference to the
*   IActiveScriptError object, which the host can use to get information about
*   the error.  Returns S_OK if the error was handled successfully, and an OLE
*   error code if not.
******************************************************************************/
STDMETHODIMP CScriptEngine::OnScriptError(
    IActiveScriptError * pscripterror)
{
    //tracing purposes only
    AzPrint((AZD_SCRIPT, "CScriptEngine::OnScriptError\n"));

    ASSERT(pscripterror);
    AssertValid();

    if ( m_fTimedOut ) {
        m_ScriptError = AZ_HRESULT(ERROR_TIMEOUT);
    }

    //
    // Only report the first error in this script
    //

    if ( m_ScriptError == S_OK ) {

        m_ScriptError = E_UNEXPECTED;

        if (pscripterror) {
            EXCEPINFO theException;
            HRESULT hr;

            //
            // Get a description of the exception
            //

            hr = pscripterror->GetExceptionInfo(&theException);

            if ( FAILED(hr)) {

                m_ScriptError = hr;

            //
            // Log the exception
            //
            } else {

                m_ScriptError = theException.wCode == 0 ?
                            theException.scode :
                            theException.wCode;

                AzPrint(( AZD_CRITICAL,
                          "Script Error: Code: 0x%lx %ld\n"
                          "              Src:  %ws\n"
                          "              File: %ws\n"
                          "              Desc: %ws\n",
                          m_ScriptError,
                          m_ScriptError,
                          theException.bstrSource,
                          theException.bstrHelpFile,
                          theException.bstrDescription));

            }
        }
    }


    // return S_OK to tell the script engine that we handled the error ok.
    // Returning E_FAIL would not stop the scripting engine, this was a doc error.
    return S_OK;
}

/******************************************************************************
*   OnEnterScript() -- This function gives the host a chance to respond when
*   the script begins running.  Returns S_OK if the call was successful.
******************************************************************************/
STDMETHODIMP CScriptEngine::OnEnterScript(void)
{
    //tracing purposes only
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::OnEnterScript\n"));

    return S_OK;
}

/******************************************************************************
*   OnExitScript() -- This function gives the host a chance to respond when
*   the script finishes running.  Returns S_OK if the call was successful.
******************************************************************************/
STDMETHODIMP CScriptEngine::OnLeaveScript(void)
{
    //tracing purposes only
    AzPrint((AZD_SCRIPT_MORE, "CScriptEngine::OnLeaveScript\n"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\genobj.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    genobj.cxx

Abstract:

    Generic object implementation.

    AZ roles has so many objects that need creation, enumeration, etc
    that it seems prudent to have a single body of code for doing those operations


Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/


#include "pch.hxx"

// Procedure forwards
PGENERIC_OBJECT_LIST
ObGetObjectListPtr(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG LinkToObjectType,
    IN PGENERIC_OBJECT_LIST LinkToGenericObjectList
    );

//
// Table of sizes of the specific objects
//

DWORD SpecificObjectSize[OBJECT_TYPE_MAXIMUM] = {
    sizeof(AZP_AZSTORE),  // OBJECT_TYPE_AZAUTHSTORE
    sizeof(AZP_APPLICATION),    // OBJECT_TYPE_APPLICATION
    sizeof(AZP_OPERATION),      // OBJECT_TYPE_OPERATION
    sizeof(AZP_TASK),           // OBJECT_TYPE_TASK
    sizeof(AZP_SCOPE),          // OBJECT_TYPE_SCOPE
    sizeof(AZP_GROUP),          // OBJECT_TYPE_GROUP
    sizeof(AZP_ROLE),           // OBJECT_TYPE_ROLE
    sizeof(AZP_SID),            // OBJECT_TYPE_SID
    sizeof(AZP_CLIENT_CONTEXT), // OBJECT_TYPE_CLIENT_CONTEXT
    0,                          // OBJECT_TYPE_ROOT
};

//
// Maximum length of the object name
//

DWORD MaxObjectNameLength[OBJECT_TYPE_MAXIMUM] = {
    0,           // OBJECT_TYPE_AZAUTHSTORE
    AZ_MAX_APPLICATION_NAME_LENGTH,
    AZ_MAX_OPERATION_NAME_LENGTH,
    AZ_MAX_TASK_NAME_LENGTH,
    AZ_MAX_SCOPE_NAME_LENGTH,
    AZ_MAX_GROUP_NAME_LENGTH,
    AZ_MAX_ROLE_NAME_LENGTH,
    0,           // OBJECT_TYPE_SID
    0,           // OBJECT_TYPE_CLIENT_CONTEXT
    0,           // OBJECT_TYPE_ROOT
};

//
// Table of object init routines
//
// Specifies a routine to call to initialize the object type specific fields
//  when adding a generic object.
//

OBJECT_INIT_ROUTINE *ObjectInitRoutine[OBJECT_TYPE_MAXIMUM] = {
    &AzpAzStoreInit,    // OBJECT_TYPE_AZAUTHSTORE
    &AzpApplicationInit,     // OBJECT_TYPE_APPLICATION
    &AzpOperationInit,       // OBJECT_TYPE_OPERATION
    &AzpTaskInit,            // OBJECT_TYPE_TASK
    &AzpScopeInit,           // OBJECT_TYPE_SCOPE
    &AzpGroupInit,           // OBJECT_TYPE_GROUP
    &AzpRoleInit,            // OBJECT_TYPE_ROLE
    &AzpSidInit,             // OBJECT_TYPE_SID
    &AzpClientContextInit,   // OBJECT_TYPE_CLIENT_CONTEXT
    NULL,                    // OBJECT_TYPE_ROOT
};

//
// Table of object free routines
//
// Specifies a routine to call to free the object type specific fields
//  when freeing a generic object.
//

OBJECT_FREE_ROUTINE *ObjectFreeRoutine[OBJECT_TYPE_MAXIMUM] = {
    &AzpAzStoreFree,    // OBJECT_TYPE_AZAUTHSTORE
    &AzpApplicationFree,     // OBJECT_TYPE_APPLICATION
    &AzpOperationFree,       // OBJECT_TYPE_OPERATION
    &AzpTaskFree,            // OBJECT_TYPE_TASK
    &AzpScopeFree,           // OBJECT_TYPE_SCOPE
    &AzpGroupFree,           // OBJECT_TYPE_GROUP
    &AzpRoleFree,            // OBJECT_TYPE_ROLE
    &AzpSidFree,             // OBJECT_TYPE_SID
    &AzpClientContextFree,   // OBJECT_TYPE_CLIENT_CONTEXT
    NULL,                    // OBJECT_TYPE_ROOT
};

//
// Table of name conflict check routines.
//
// Specifies a routine to call to determine whether a specified name conflicts
//  with other objects.
//
// NULL means that the name has not special conflict rules
//

OBJECT_NAME_CONFLICT_ROUTINE *ObjectNameConflictRoutine[OBJECT_TYPE_MAXIMUM] = {
    NULL,                            // OBJECT_TYPE_AZAUTHSTORE
    NULL,                            // OBJECT_TYPE_APPLICATION
    &AzpOperationNameConflict,       // OBJECT_TYPE_OPERATION
    &AzpTaskNameConflict,            // OBJECT_TYPE_TASK
    NULL,                            // OBJECT_TYPE_SCOPE
    &AzpGroupNameConflict,           // OBJECT_TYPE_GROUP
    &AzpRoleNameConflict,            // OBJECT_TYPE_ROLE
    NULL,                            // OBJECT_TYPE_SID
    NULL,                            // OBJECT_TYPE_CLIENT_CONTEXT
    NULL,                            // OBJECT_TYPE_ROOT
};

//
// Table of object specific GetProperty routines
//
// Specifies a routine to call to get object type specific fields
//  when querying a generic object.
//
// NULL means there are no object specific fields.
//

OBJECT_GET_PROPERTY_ROUTINE *ObjectGetPropertyRoutine[OBJECT_TYPE_MAXIMUM] = {
    &AzpAzStoreGetProperty,    // OBJECT_TYPE_AZAUTHSTORE
    &AzpApplicationGetProperty,     // OBJECT_TYPE_APPLICATION
    &AzpOperationGetProperty,       // OBJECT_TYPE_OPERATION
    &AzpTaskGetProperty,            // OBJECT_TYPE_TASK
    &AzpScopeGetProperty,           // OBJECT_TYPE_SCOPE
    &AzpGroupGetProperty,           // OBJECT_TYPE_GROUP
    &AzpRoleGetProperty,            // OBJECT_TYPE_ROLE
    NULL,                           // OBJECT_TYPE_SID
    &AzpClientContextGetProperty,   // OBJECT_TYPE_CLIENT_CONTEXT
    NULL,                           // OBJECT_TYPE_ROOT
};

//
// Table of object specific SetProperty routines
//
// Specifies a routine to call to set object type specific fields
//  when modifying a generic object.
//
// NULL means there are no object specific fields.
//

OBJECT_SET_PROPERTY_ROUTINE *ObjectSetPropertyRoutine[OBJECT_TYPE_MAXIMUM] = {
    &AzpAzStoreSetProperty,    // OBJECT_TYPE_AZAUTHSTORE
    &AzpApplicationSetProperty,     // OBJECT_TYPE_APPLICATION
    &AzpOperationSetProperty,       // OBJECT_TYPE_OPERATION
    &AzpTaskSetProperty,            // OBJECT_TYPE_TASK
    NULL,                           // OBJECT_TYPE_SCOPE
    &AzpGroupSetProperty,           // OBJECT_TYPE_GROUP
    NULL,                           // OBJECT_TYPE_ROLE
    NULL,                           // OBJECT_TYPE_SID
    &AzpClientContextSetProperty,   // OBJECT_TYPE_CLIENT_CONTEXT
    NULL,                           // OBJECT_TYPE_ROOT
};


//
// Table of object specific dirty bits
//
// Specifies the maximum set of dirty bits applicable for each object type
//
// 0 means there are no object specific fields.
//

DWORD AzGlObjectAllDirtyBits[OBJECT_TYPE_MAXIMUM] = {
    AZ_DIRTY_AZSTORE_ALL,             // OBJECT_TYPE_AZAUTHSTORE
    AZ_DIRTY_APPLICATION_ALL,       // OBJECT_TYPE_APPLICATION
    AZ_DIRTY_OPERATION_ALL,         // OBJECT_TYPE_OPERATION
    AZ_DIRTY_TASK_ALL,              // OBJECT_TYPE_TASK
    AZ_DIRTY_SCOPE_ALL,             // OBJECT_TYPE_SCOPE
    AZ_DIRTY_GROUP_ALL,             // OBJECT_TYPE_GROUP
    AZ_DIRTY_ROLE_ALL,              // OBJECT_TYPE_ROLE
    0,                              // OBJECT_TYPE_SID
    0,                              // OBJECT_TYPE_CLIENT_CONTEXT
    0,                              // OBJECT_TYPE_ROOT
};

//
// Table of object specific dirty bits.
//
// Specifies the maximum set of dirty bits applicable for each object type
// This list includes only attributes that are scalars.
//
// 0 means there are no object specific fields.
//

DWORD ObjectAllScalarDirtyBits[OBJECT_TYPE_MAXIMUM] = {
    AZ_DIRTY_AZSTORE_ALL_SCALAR,          // OBJECT_TYPE_AZAUTHSTORE
    AZ_DIRTY_APPLICATION_ALL_SCALAR,    // OBJECT_TYPE_APPLICATION
    AZ_DIRTY_OPERATION_ALL_SCALAR,      // OBJECT_TYPE_OPERATION
    AZ_DIRTY_TASK_ALL_SCALAR,           // OBJECT_TYPE_TASK
    AZ_DIRTY_SCOPE_ALL_SCALAR,          // OBJECT_TYPE_SCOPE
    AZ_DIRTY_GROUP_ALL_SCALAR,          // OBJECT_TYPE_GROUP
    AZ_DIRTY_ROLE_ALL_SCALAR,           // OBJECT_TYPE_ROLE
    0,                                  // OBJECT_TYPE_SID
    0,                                  // OBJECT_TYPE_CLIENT_CONTEXT
    0,                                  // OBJECT_TYPE_ROOT
};

//
// Table of object specific default values for scalars
//
// This table does double duty as an object specific mapping between dirty bits and property ids
//
// NULL means there are no object specific scalars for the object type
//

AZP_DEFAULT_VALUE *ObjectDefaultValuesArray[OBJECT_TYPE_MAXIMUM] = {
    AzGlAzStoreDefaultValues,  // OBJECT_TYPE_AZAUTHSTORE
    AzGlApplicationDefaultValues,   // OBJECT_TYPE_APPLICATION
    AzGlOperationDefaultValues,     // OBJECT_TYPE_OPERATION
    AzGlTaskDefaultValues,          // OBJECT_TYPE_TASK
    NULL,                           // OBJECT_TYPE_SCOPE
    AzGlGroupDefaultValues,         // OBJECT_TYPE_GROUP
    NULL,                           // OBJECT_TYPE_ROLE
    NULL,                           // OBJECT_TYPE_SID
    NULL,                           // OBJECT_TYPE_CLIENT_CONTEXT
    NULL,                           // OBJECT_TYPE_ROOT
};

//
// Table of object specific AddPropertyItem routines
//
// Specifies a routine to call to add property type specific fields.
//
// NULL means there is no object specific action to take
//

OBJECT_ADD_PROPERTY_ITEM_ROUTINE *ObjectAddPropertyItemRoutine[OBJECT_TYPE_MAXIMUM] = {
    NULL,                       // OBJECT_TYPE_AZAUTHSTORE
    NULL,                       // OBJECT_TYPE_APPLICATION
    NULL,                       // OBJECT_TYPE_OPERATION
    &AzpTaskAddPropertyItem,    // OBJECT_TYPE_TASK
    NULL,                       // OBJECT_TYPE_SCOPE
    &AzpGroupAddPropertyItem,   // OBJECT_TYPE_GROUP
    NULL,                       // OBJECT_TYPE_ROLE
    NULL,                       // OBJECT_TYPE_SID
    NULL,                       // OBJECT_TYPE_CLIENT_CONTEXT
    NULL,                       // OBJECT_TYPE_ROOT
};

DWORD
ObCloseHandle(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    Close a handle forcefully for a generic object.

    On entry, the global lock must be held exclusively

Arguments:

    GenericObject - Object whose handle needs to be closed.

Return Value:

    NO_ERROR - The operation was successful.

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedGenericObject = NULL;
    PGENERIC_OBJECT AzStoreGenericObject = NULL;
    DWORD ObjectType;


    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    ObjectType = GenericObject->ObjectType;

    //
    // Grab a reference to the object
    //

    WinStatus = ObReferenceObjectByHandle( GenericObject,
                                           TRUE,    // Allow deleted objects
                                           FALSE,   // No need to refresh cache on a close
                                           ObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedGenericObject = GenericObject;
    
    //
    // Grab a reference to the root of the core cache
    //

    AzStoreGenericObject = &GenericObject->AzStoreObject->GenericObject;

    InterlockedIncrement( &AzStoreGenericObject->ReferenceCount );
    AzpDumpGoRef( "AzAuthorizationStore in ObCloseHandle ref", AzStoreGenericObject );

    //
    // For a client context,
    //  remove the link from the parent when the handle closes
    //

    if ( ObjectType == OBJECT_TYPE_CLIENT_CONTEXT ) {

        ASSERT( GenericObject->HandleReferenceCount == 1 );

        // No longer in the global list
        ObDereferenceObject( GenericObject );

    }

    //
    // Actually close the handle
    //

    WinStatus = ObDecrHandleRefCount( GenericObject );

    if ( WinStatus != NO_ERROR ) {

        goto Cleanup;
    }

    //
    // Done
    //

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedGenericObject != NULL ) {
        ObDereferenceObject( ReferencedGenericObject );
    }
    
    if ( AzStoreGenericObject != NULL ) {
        // This dereference might delete the entire cache
        ObDereferenceObject( AzStoreGenericObject );
    }

    return WinStatus;

}

RTL_GENERIC_COMPARE_RESULTS
AzpAvlCompare(
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID FirstStruct,
    IN PVOID SecondStruct
    )
/*++

Routine Description:

    This routine will compare two generic object names

Arguments:

    IN PRTL_GENERIC_TABLE - Supplies the table containing the announcements
    IN PVOID FirstStuct - The first structure to compare.
    IN PVOID SecondStruct - The second structure to compare.

Return Value:

    Result of the comparison.

--*/
{
    PGENERIC_OBJECT_NAME Name1 = (PGENERIC_OBJECT_NAME) FirstStruct;
    PGENERIC_OBJECT_NAME Name2 = (PGENERIC_OBJECT_NAME) SecondStruct;
    LONG CompareResult;

    CompareResult = AzpCompareStrings( &Name1->ObjectName, &Name2->ObjectName );

    if ( CompareResult == CSTR_LESS_THAN ) {
        return GenericLessThan;
    } else if ( CompareResult == CSTR_GREATER_THAN ) {
        return GenericGreaterThan;
    } else {
        return GenericEqual;
    }

    UNREFERENCED_PARAMETER(Table);

}

VOID
ObInitGenericHead(
    IN PGENERIC_OBJECT_HEAD GenericObjectHead,
    IN ULONG ObjectType,
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT_HEAD SiblingGenericObjectHead OPTIONAL
    )
/*++

Routine Description

    Initialize the head of a list of generic objects

    On entry, AzGlResource must be locked exclusive.

Arguments

    GenericObjectHead - Specifies the list head to initialize

    ObjectType - Specifies the type of objects in the list

    ParentGenericObject - Specifies a back link to parent generic object
        that host the object head being initialized.

    SiblingGenericObjectHead - Specifies a pointer to an object head that
        is a sibling of the one being initialized.

Return Value

    None

--*/

{

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Initialize the linked list
    //

    InitializeListHead( &GenericObjectHead->Head );
    GenericObjectHead->ObjectCount = 0;

    //
    // Initialize the AVL tree of child objects
    //

    RtlInitializeGenericTable( &GenericObjectHead->AvlTree,
                               AzpAvlCompare,
                               AzpAvlAllocate,
                               AzpAvlFree,
                               NULL);

    //
    // Initialize the sequence number
    //  Start at 1 since a zero EnumerationContext means beginning of list.
    //

    GenericObjectHead->NextSequenceNumber = 1;


    //
    // Store the ObjectType
    //

    GenericObjectHead->ObjectType = ObjectType;

    //
    // Store the back pointer to the parent generic object
    //

    GenericObjectHead->ParentGenericObject = ParentGenericObject;

    //
    // Store the link to the next Generic head
    //

    GenericObjectHead->SiblingGenericObjectHead = SiblingGenericObjectHead;

    //
    // If the parent (parent AzApplication/AzScope only) needs to be loaded before objects
    // in the list of this head can be enumerated, then set the flag to do so
    //

    if ( ParentGenericObject != NULL &&
         (ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION ||
         ParentGenericObject->ObjectType == OBJECT_TYPE_SCOPE) ) {

        GenericObjectHead->LoadParentBeforeReferencing = TRUE;

    } else {

        GenericObjectHead->LoadParentBeforeReferencing = FALSE;
    }
}


VOID
ObFreeGenericHead(
    IN PGENERIC_OBJECT_HEAD GenericObjectHead
    )
/*++

Routine Description

    Free any ojects on a generic head structure

    On entry, AzGlResource must be locked exclusive.

Arguments

    GenericObjectHead - Specifies the list head to free

Return Value

    None

--*/

{
    PLIST_ENTRY ListEntry;
    PGENERIC_OBJECT GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Walk the list of child objects dereferencing each.
    //

    while ( !IsListEmpty( &GenericObjectHead->Head ) ) {

        //
        // Grab the first entry and dereference it.
        //

        ListEntry = GenericObjectHead->Head.Flink;

        GenericObject = CONTAINING_RECORD( ListEntry,
                                           GENERIC_OBJECT,
                                           Next );

        ASSERT( GenericObject->ReferenceCount == 1 );
        ObDereferenceObject( GenericObject );
    }

}


DWORD
ObUnloadChildGenericHeads(
    IN PGENERIC_OBJECT pParentObject
    )
/*++

Routine Description:

   This routine is called to unload all the children of a parent object
   from the cache.  The parent object is marked closed, and no operations
   pertaining to its children will be allowed.

   On entry, AzGlResource must be locked exclusive

Arguments:

   pParentObject - Pointer to parent whose children need to be unloaded from cache

Return Value:

   NO_ERROR - Operation completed successfully
   Other status codes

--*/
{
    DWORD WinStatus = NO_ERROR;
    PLIST_ENTRY pListEntry;
    PLIST_ENTRY pPrevEntry;
    PGENERIC_OBJECT pGenericObject;
    PGENERIC_OBJECT_HEAD pGenericObjectHead;
    DWORD ObjectCount = 0;

    //
    // Validation
    //

    ASSERT( pParentObject != NULL );
    ASSERT( AzpIsLockedExclusive(&AzGlResource) );

    //
    // If the parent object has been closed by another thread, then return
    //

    if ( !(pParentObject->AreChildrenLoaded) ) {

        return NO_ERROR;
    }

    //
    // Free children of this object
    // Loop for each type of child
    //

    for ( pGenericObjectHead = pParentObject->ChildGenericObjectHead;
          pGenericObjectHead != NULL;
          pGenericObjectHead = pGenericObjectHead->SiblingGenericObjectHead ) {

        //
        // Walk the list of child objects freeing them in the process
        //

        pPrevEntry = &pGenericObjectHead->Head;

        for ( pListEntry = pPrevEntry->Flink;
              pListEntry != &pGenericObjectHead->Head ;
              pListEntry = pPrevEntry->Flink ) {

            ObjectCount = pGenericObjectHead->ObjectCount;
            
            pGenericObject = CONTAINING_RECORD( pListEntry,
                                                GENERIC_OBJECT,
                                                Next
                                                );
            
            //
            // if the object is a parent object, then release all
            // its children first
            //

            DWORD ObjectType = pGenericObject->ObjectType;

            if ( IsContainerObject( ObjectType ) ) {

                WinStatus = ObUnloadChildGenericHeads( pGenericObject );

                if ( WinStatus != NO_ERROR ) {

                    goto Cleanup;
                }
            }

            //
            // If there are any open handles, close the handle
            // repeatedly.  After that, there are no references to
            // this object.  We can then release the object.
            //
            // If closing the handle, releases the object, then
            // close handle API will return INVALID_HANDLE_VALUE.
            // We do not need to release the object after that since
            // its already released.
            //

            DWORD HandleRefCount = pGenericObject->HandleReferenceCount;

            while( HandleRefCount != 0 ) {

                WinStatus = ObCloseHandle( pGenericObject );

                if ( WinStatus == ERROR_INVALID_HANDLE || ObjectType == OBJECT_TYPE_CLIENT_CONTEXT ) {

                    break;

                } else if ( WinStatus != NO_ERROR ) {

                    goto Cleanup;
                }

                HandleRefCount = pGenericObject->HandleReferenceCount;
            }

            //
            // By the time we get to this, we should only have one more reference count
            // because only the global resource list holds onto it. All other reference
            // count should have already been released by the previous loop of closing
            // handles. 
            //

            if ( WinStatus == NO_ERROR && ObjectType != OBJECT_TYPE_CLIENT_CONTEXT ) {

                //
                // Now, decrement the reference count on the object
                //
                
                ObDereferenceObject( pGenericObject );

            } 

            //
            // Initialize the sequence number for the generic head,
            // if there are no other children of the same type
            //

            if ( pGenericObjectHead->ObjectCount == 0 ) {

                pGenericObjectHead->NextSequenceNumber = 1;
            }

            if ( pGenericObjectHead->ObjectCount == ObjectCount ) {

                pPrevEntry = pListEntry;
            } 

            WinStatus = NO_ERROR;
        }
    }

    //
    // reset unloading the parent object to FALSE since we have just unloaded it.
    // Mark the object as closed.
    //
    // We want to decrement the handle count to the application object to 0 as well
    //  
    
    if ( pParentObject->ObjectType == OBJECT_TYPE_APPLICATION ) {
        
        while ( pParentObject->HandleReferenceCount != 0 ) {

            WinStatus = ObCloseHandle( pParentObject );

            if ( WinStatus != NO_ERROR ) {

                goto Cleanup;
            }
        }          
        
        ((PAZP_APPLICATION)pParentObject)->UnloadApplicationObject = FALSE;

        pParentObject->ObjectClosed = TRUE;

        //
        // Increment the AppSequenceNumber to catch any invalid COM handles
        // to this closed object
        //

        ((PAZP_APPLICATION)pParentObject)->AppSequenceNumber++;          

    }


    WinStatus = NO_ERROR;

Cleanup:

    return WinStatus;
}    


PGENERIC_OBJECT_NAME
ObInsertNameIntoAvlTree(
    IN PGENERIC_OBJECT_HEAD ParentGenericObjectHead,
    IN PAZP_STRING ObjectName
    )
/*++

Routine Description

    Allocates a GENERIC_OBJECT_NAME structure and inserts it into the AvlTree.

    On entry, AzGlResource must be locked exclusive.

Arguments

    ParentGenericObjectHead - Specifies the list head of the list to insert into

    ObjectName - Name of the object

Return Value

    Returns a pointer to the inserted object.

    NULL: not enough memory

--*/
{
    PGENERIC_OBJECT_NAME TemplateObjectName = NULL;
    PGENERIC_OBJECT_NAME InsertedObjectName = NULL;
    BOOLEAN NewElement;

    ULONG NameSize;


    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Allocate memory on a stack for a template of the object name.
    //

    NameSize = sizeof(GENERIC_OBJECT_NAME) + ObjectName->StringSize;

    SafeAllocaAllocate( TemplateObjectName, NameSize );

    if ( TemplateObjectName == NULL ) {
        goto Cleanup;
    }

    //
    // Initialize the template of the object name
    //

    TemplateObjectName->GenericObject = NULL;
    TemplateObjectName->ObjectName = *ObjectName;
    TemplateObjectName->ObjectName.String = (LPWSTR)(TemplateObjectName+1);

    RtlCopyMemory( TemplateObjectName->ObjectName.String,
                   ObjectName->String,
                   ObjectName->StringSize );

    //
    // Put it in the AVL tree
    //

    InsertedObjectName = (PGENERIC_OBJECT_NAME) RtlInsertElementGenericTable (
                            &ParentGenericObjectHead->AvlTree,
                            TemplateObjectName,
                            NameSize,
                            &NewElement );

    if ( InsertedObjectName == NULL ) {
        goto Cleanup;
    }

    ASSERT( NewElement );

    //
    // Relocate the pointer to the object name string
    //

    InsertedObjectName->ObjectName.String = (LPWSTR)(InsertedObjectName+1);


    //
    // Free any locally used resources
    //
Cleanup:

    if ( TemplateObjectName != NULL ) {
        SafeAllocaFree( TemplateObjectName );
    }

    return InsertedObjectName;
}


PGENERIC_OBJECT
ObAllocateGenericObject(
    IN PGENERIC_OBJECT_HEAD ParentGenericObjectHead,
    IN PAZP_STRING ObjectName
    )
/*++

Routine Description

    Allocate memory for the private object structure of the specified type and inserts
    it into the list of such objects maintained by the parent object.

    On entry, AzGlResource must be locked exclusive.

Arguments

    ParentGenericObjectHead - Specifies the list head of the list to insert into

    ObjectName - Name of the object

Return Value

    Returns a pointer to the allocated object.  The caller should dereference the
    returned object by calling ObDereferenceObject.  (There is a second reference representing
    the fact that the entry has been inserted in the ParentGenericObjectHead.  The
    caller should wait to decrement this second reference count until the caller wants the object
    to be removed from the parent list.)

    NULL: not enough memory

--*/
{
    ULONG ObjectType = ParentGenericObjectHead->ObjectType;
    PGENERIC_OBJECT_NAME InsertedObjectName = NULL;

    PGENERIC_OBJECT GenericObject = NULL;
    ULONG BaseSize;


    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Ensure the object is supported
    //

    if ( ObjectType > OBJECT_TYPE_MAXIMUM  ||
         SpecificObjectSize[ObjectType] == 0 ) {

        ASSERT( ObjectType <= OBJECT_TYPE_MAXIMUM );
        ASSERT( SpecificObjectSize[ObjectType] != 0 );

        goto Cleanup;
    }

    BaseSize = SpecificObjectSize[ObjectType];
    ASSERT( BaseSize >= sizeof(GENERIC_OBJECT) );

    //
    // Add the object name to the AVL tree (If it is a named object)
    //

    if ( ObjectName->String != NULL ) {
        InsertedObjectName = ObInsertNameIntoAvlTree(
                                ParentGenericObjectHead,
                                ObjectName );

        if ( InsertedObjectName == NULL ) {
            goto Cleanup;
        }
    }


    //
    // Allocate the memory for the generic object itself
    //

    GenericObject = (PGENERIC_OBJECT) AzpAllocateHeap( BaseSize, "GENOBJ" );

    if ( GenericObject == NULL ) {
        goto Cleanup;
    }


    //
    // Initialize it
    //

    RtlZeroMemory( GenericObject, BaseSize );
    GenericObject->ObjectType = ObjectType;
    if ( InsertedObjectName != NULL ) {
        GenericObject->ObjectName = InsertedObjectName;
        InsertedObjectName->GenericObject = GenericObject;
        InsertedObjectName = NULL;  // For this point it'll be freed as a part of the generic object
    }
    InitializeListHead( &GenericObject->Next );

    // One for being in the global list (being in the AVL tree doesn't count as a reference)
    // One for returning a reference to our caller
    GenericObject->ReferenceCount = 2;
    AzpDumpGoRef( "Allocate object", GenericObject );


    //
    // Set the sequence number
    //

    GenericObject->SequenceNumber = ParentGenericObjectHead->NextSequenceNumber;
    ParentGenericObjectHead->NextSequenceNumber ++;

    //
    // Insert the object
    //  Insert at the tail to keep the list in sequence number order.
    //

    ASSERT( ParentGenericObjectHead->ObjectType == GenericObject->ObjectType );
    InsertTailList( &ParentGenericObjectHead->Head, &GenericObject->Next );
    ParentGenericObjectHead->ObjectCount ++;

    //
    // Provide a back link
    //

    ASSERT( GenericObject->ParentGenericObjectHead == NULL );
    GenericObject->ParentGenericObjectHead = ParentGenericObjectHead;


    //
    // Free any locally used resources
    //
Cleanup:

    if ( InsertedObjectName != NULL ) {
        if (!RtlDeleteElementGenericTable (
                    &ParentGenericObjectHead->AvlTree,
                    InsertedObjectName ) ) {
            ASSERT( FALSE );
        }
    }

    return GenericObject;
}

VOID
ObFreeGenericObject(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description

    Free memory for the private object structure of the specified type

    On entry, AzGlResource must be locked exclusive.

Arguments

    GenericObject - Specifies the pointer to the generic object to free

Return Value

    None.

--*/
{
    PGENERIC_OBJECT_HEAD ChildGenericObjectHead;

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    ASSERT( GenericObject->HandleReferenceCount == 0 );
    ASSERT( GenericObject->ReferenceCount == 0 );

    //
    // Call the routine to do provider specific freeing
    //

    if ( GenericObject->ProviderData != NULL ) {
        AzpeFreeMemory( GenericObject->ProviderData );
        GenericObject->ProviderData = NULL;
    }

    //
    // Delink the entry from the parent
    //

    ASSERT( !IsListEmpty( &GenericObject->Next ));
    RemoveEntryList( &GenericObject->Next );
    GenericObject->ParentGenericObjectHead->ObjectCount --;

    //
    // Free children of this object
    //  Loop for each type of child
    //

    for ( ChildGenericObjectHead = GenericObject->ChildGenericObjectHead;
          ChildGenericObjectHead != NULL;
          ChildGenericObjectHead = ChildGenericObjectHead->SiblingGenericObjectHead ) {

        ObFreeGenericHead( ChildGenericObjectHead );
    }


    //
    // Remove all references to/from this object
    //

    ObRemoveObjectListLinks( GenericObject );


    //
    // Call the routine to do object type specific freeing
    //

    if ( ObjectFreeRoutine[GenericObject->ObjectType] == NULL ) {
        ASSERT( ObjectFreeRoutine[GenericObject->ObjectType] != NULL );
    } else {

        ObjectFreeRoutine[GenericObject->ObjectType](GenericObject );

    }


    //
    // Free the common fields
    //

    AzpFreeString( &GenericObject->Description );

    AzpFreeString( &GenericObject->ApplicationData );

    //
    // Free the object itself
    //

    PGENERIC_OBJECT_HEAD ParentGenericObjectHead = GenericObject->ParentGenericObjectHead;
    PGENERIC_OBJECT_NAME InsertedObjectName = GenericObject->ObjectName;

    AzpFreeHeap( GenericObject );

    //
    // Free the object name
    //

    if ( InsertedObjectName != NULL ) {
        if (!RtlDeleteElementGenericTable (
                    &ParentGenericObjectHead->AvlTree,
                    InsertedObjectName ) ) {

            InsertedObjectName->GenericObject = NULL;
            ASSERT( FALSE );
        }
    }


}

VOID
ObIncrHandleRefCount(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description

    Increment the "handle" reference count on an object.

    On entry, AzGlResource must be locked shared.

Arguments

    GenericObject - Specifies the object to insert into the list

Return Value

    None

--*/
{

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    //
    // Keep a reference to our parent object.
    //  We validate the handle by walking the list of children in our parent.
    //  So, prevent our parent from being deleted as long as the user has a handle to the child.
    //

    if ( ParentOfChild( GenericObject ) != NULL ) {
        InterlockedIncrement ( &(ParentOfChild( GenericObject )->ReferenceCount) );
        AzpDumpGoRef( "Child handle ref", ParentOfChild( GenericObject ));
    }

    //
    // The handle ref count is a real ref count.  Increment it too.
    //

    InterlockedIncrement( &GenericObject->ReferenceCount );
    AzpDumpGoRef( "Handle ref", GenericObject );

    //
    // Increment the handle ref count
    //

    InterlockedIncrement( &GenericObject->HandleReferenceCount );
    AzPrint(( AZD_HANDLE, "0x%lx %ld (%ld): Open Handle\n", GenericObject, GenericObject->ObjectType, GenericObject->HandleReferenceCount ));

    //
    // Increment the reference count on the object at the root of the cache
    //  This object has pointer to several objects in the cache.  We don't
    //  maintain references to those objects because that would lead to circular references.
    //

    InterlockedIncrement( &GenericObject->AzStoreObject->GenericObject.ReferenceCount );
    AzpDumpGoRef( "Authorization Store Handle ref", &GenericObject->AzStoreObject->GenericObject );
}

DWORD
ObDecrHandleRefCount(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description

    Decrement the "handle" reference count on an object.

    On entry, AzGlResource must be locked shared.

Arguments

    GenericObject - Specifies the object to insert into the list

Return Value

    NO_ERROR - Handle was decremented successfully
    Other status codes

--*/
{

    DWORD WinStatus = NO_ERROR;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    //
    // Decrement the handle ref count
    //

    InterlockedDecrement( &GenericObject->HandleReferenceCount );
    AzPrint(( AZD_HANDLE, "0x%lx %ld (%ld): Close Handle\n", GenericObject, GenericObject->ObjectType, GenericObject->HandleReferenceCount ));

    //
    // Decrement the reference count on the entire tree of objects
    //
    AzpDumpGoRef( "Authorization Store Handle deref", &GenericObject->AzStoreObject->GenericObject );
    ObDereferenceObject( &GenericObject->AzStoreObject->GenericObject );

    //
    // The handle ref count is a real ref count.  Decrement it too.
    //

    AzpDumpGoRef( "Handle deref", GenericObject );
    ObDereferenceObject( GenericObject );

    //
    // Decrement the ref count we have on our parent.
    //

    if ( ParentOfChild( GenericObject ) != NULL ) {
        AzpDumpGoRef( "Child handle deref", ParentOfChild( GenericObject ) );
        ObDereferenceObject( ParentOfChild( GenericObject ) );
    }

    //
    // Finally, if object whose handle ref count is being decreased is an application object,
    // then unload the children if the handle reference count is 0
    //

    if ( (GenericObject->HandleReferenceCount == 0) && 
         (GenericObject->ObjectType == OBJECT_TYPE_APPLICATION) ) {

        if ( ((PAZP_APPLICATION)GenericObject)->UnloadApplicationObject ) {

            AzpLockResourceSharedToExclusive( &AzGlResource );

            WinStatus = ObUnloadChildGenericHeads(GenericObject);

            if ( WinStatus != ERROR_NOT_SUPPORTED && WinStatus != NO_ERROR ) {
                
                //
                // Update the children cache of this application object
                //

                DWORD TempWinStatus = NO_ERROR;

                TempWinStatus = AzPersistUpdateChildrenCache( GenericObject );

                if ( TempWinStatus != NO_ERROR ) {

                    AzPrint(( AZD_REF,
                              "ObDecrHandleRefCount: Cannot reload children on failure of unload: %ld\n",
                              TempWinStatus
                              ));
                }

                goto Cleanup;
            }

            GenericObject->AreChildrenLoaded = FALSE;
        }
    }

    WinStatus = NO_ERROR;

Cleanup:

    return WinStatus;
            
}


DWORD
ObGetHandleType(
    IN PGENERIC_OBJECT Handle,
    IN BOOL AllowDeletedObjects,
    OUT PULONG ObjectType
    )
/*++

Routine Description

    This routine takes a handle passed by an application and safely determines what the
    handle type is.

    This routine allows a caller to support various handle types rather than being
    limited to one.

Arguments

    Handle - Handle to check

    AllowDeletedObjects - TRUE if it is OK to use a handle to a deleted object

    ObjectType - Returns the type of object the handle represents


Return Value

    NO_ERROR - the handle is OK
    ERROR_INVALID_HANDLE - the handle isn't OK

--*/
{
    DWORD WinStatus;
    PGENERIC_OBJECT GenericObject = Handle;


    //
    // Initialization
    //

    if ( Handle == NULL ) {
        AzPrint(( AZD_CRITICAL, "0x%lx: NULL handle is invalid\n", Handle ));
        return ERROR_INVALID_HANDLE;
    }

    //
    // Use a try/except since we're touching memory assuming the handle is valid
    //

    WinStatus = NO_ERROR;
    __try {

        //
        // Sanity check the scalar values on the object
        //

        if ( GenericObject->ObjectType >= OBJECT_TYPE_MAXIMUM ) {
            AzPrint(( AZD_CRITICAL, "0x%lx %ld: Handle Object type is too large.\n", GenericObject, GenericObject->ObjectType ));
            WinStatus = ERROR_INVALID_HANDLE;

        } else if ( GenericObject->HandleReferenceCount <= 0 ) {
            AzPrint(( AZD_HANDLE, "0x%lx %ld: Handle has no handle reference count.\n", GenericObject, GenericObject->ObjectType ));
            WinStatus = ERROR_INVALID_HANDLE;

        } else if ( GenericObject->ParentGenericObjectHead == NULL ) {
            AzPrint(( AZD_CRITICAL, "0x%lx %ld: Handle has no ParentGenericObjectHead.\n", GenericObject, GenericObject->ObjectType ));
            WinStatus = ERROR_INVALID_HANDLE;

        } else if ( !AllowDeletedObjects &&
                    (GenericObject->Flags & GENOBJ_FLAGS_DELETED) != 0 ) {
            AzPrint(( AZD_CRITICAL, "0x%lx %ld: Object is deleted.\n", GenericObject, GenericObject->ObjectType ));
            WinStatus = ERROR_INVALID_HANDLE;

        } else {
            PGENERIC_OBJECT_HEAD ParentGenericObjectHead = GenericObject->ParentGenericObjectHead;

            //
            // Sanity check the object with its head
            //

            if ( ParentGenericObjectHead->ObjectType != GenericObject->ObjectType ) {

                AzPrint(( AZD_CRITICAL, "0x%lx %ld: Object type doesn't match parent.\n", GenericObject, GenericObject->ObjectType ));
                WinStatus = ERROR_INVALID_HANDLE;

            } else if ( GenericObject->SequenceNumber >= ParentGenericObjectHead->NextSequenceNumber ) {

                AzPrint(( AZD_CRITICAL, "0x%lx %ld: Sequence number doesn't match parent.\n", GenericObject, GenericObject->ObjectType ));
                WinStatus = ERROR_INVALID_HANDLE;

            } else {

                *ObjectType = GenericObject->ObjectType;
            }
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        AzPrint(( AZD_CRITICAL, "0x%lx: AV accessing handle\n", GenericObject ));
        WinStatus = ERROR_INVALID_HANDLE;
    }

    return WinStatus;
}


DWORD
ObReferenceObjectByName(
    IN PGENERIC_OBJECT_HEAD GenericObjectHead,
    IN PAZP_STRING ObjectName,
    IN ULONG Flags,
    OUT PGENERIC_OBJECT *RetGenericObject
    )
/*++

Routine Description

    This routine finds an object by the specified name.

    On entry, AzGlResource must be locked shared.

Arguments

    GenericObjectHead - Head of the list of objects to check

    ObjectName - Object Name of the object to look for

    Flags - Specifies internal flags
        AZP_FLAGS_BY_GUID - name lists should be returned as GUID lists
        AZP_FLAGS_ALLOW_DELETED_OBJECTS - Allow deleted objects to be found
        AZP_FLAGS_REFRESH_CACHE - Ensure cache entry is up to date
        AZP_FLAGS_RECONCILE - Call is from AzpPersistReconcile

    RetGenericObject - On success, returns a pointer to the object
        The returned pointer must be dereferenced using ObDereferenceObject.

Return Value

    NO_ERROR: The object was returned
    ERROR_NOT_FOUND: The object could not be found
    Others: The object could not be refreshed

--*/
{
    DWORD WinStatus;
    PGENERIC_OBJECT GenericObject = NULL;

    PGENERIC_OBJECT_NAME InsertedObjectName;
    GENERIC_OBJECT_NAME TemplateObjectName;
    PLIST_ENTRY ListEntry;
    BOOL        fGuidFound = FALSE;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );
    *RetGenericObject = NULL;

    if ( Flags & AZP_FLAGS_BY_GUID )
    {
        GUID *ObjectGuid = (GUID *)ObjectName;

        AzPrint(( AZD_REF, "ObReferenceObjectByName (by guid): " ));
        AzpDumpGuid( AZD_REF, ObjectGuid );
        AzPrint(( AZD_REF, "\n" ));

        for ( ListEntry = GenericObjectHead->Head.Flink ;
              ListEntry != &GenericObjectHead->Head ;
              ListEntry = ListEntry->Flink)
        {

            GenericObject = CONTAINING_RECORD( ListEntry,
                                               GENERIC_OBJECT,
                                               Next );
            // compare guid
            if (IsEqualGUID(*ObjectGuid, GenericObject->PersistenceGuid))
            {
                // find the object
                fGuidFound = TRUE;
                break;
            }
        }

        if (!fGuidFound || NULL == GenericObject)
        {
            // not found
            return ERROR_NOT_FOUND;
        }
    }
    else
    {

        //
        // Lookup the name in the AVL tree
        //

        TemplateObjectName.ObjectName = *ObjectName;
        TemplateObjectName.GenericObject = NULL;

        InsertedObjectName = (PGENERIC_OBJECT_NAME) RtlLookupElementGenericTable (
                                &GenericObjectHead->AvlTree,
                                &TemplateObjectName );

        if ( InsertedObjectName == NULL ) {
            return ERROR_NOT_FOUND;
        }

        GenericObject = InsertedObjectName->GenericObject;
    }

    ASSERT(NULL != GenericObject);

    //
    // Ignore deleted objects
    //

    if ( (Flags & AZP_FLAGS_ALLOW_DELETED_OBJECTS) == 0 &&
                (GenericObject->Flags & GENOBJ_FLAGS_DELETED) != 0 ) {
        return ERROR_NOT_FOUND;
    }

    //
    // If the caller wants the object to be refreshed,
    //  do so now.
    //

    if ( (Flags & AZP_FLAGS_REFRESH_CACHE) != 0 &&
         (GenericObject->Flags & GENOBJ_FLAGS_REFRESH_ME) != 0  ) {

        AzpLockResourceSharedToExclusive( &AzGlResource );

        WinStatus = AzPersistRefresh( GenericObject );

        if ( WinStatus != NO_ERROR ) {
            return WinStatus;
        }
    }

    //
    // Return the object to the caller
    //

    InterlockedIncrement( &GenericObject->ReferenceCount );
    AzpDumpGoRef( "Ref by name", GenericObject );

    *RetGenericObject = GenericObject;
    return NO_ERROR;
}

DWORD
ObReferenceObjectByHandle(
    IN PGENERIC_OBJECT Handle,
    IN BOOL AllowDeletedObjects,
    IN BOOLEAN RefreshCache,
    IN ULONG ObjectType
    )
/*++

Routine Description

    This routine takes a handle passed by an application and safely determines whether
    it is a valid handle.  If so, this routine increments the reference count on the
    handle to prevent the handle from being closed.

    On entry, AzGlResource must be locked shared.

Arguments

    Handle - Handle to check

    AllowDeletedObjects - TRUE if it is OK to use a handle to a deleted object

    RefreshCache - If TRUE, the returned object has its cache entry refreshed from
        the policy database if needed.
        If FALSE, the entry is returned unrefreshed.

    ObjectType - Specifies the type of object the caller expects the handle to be


Return Value

    NO_ERROR - the handle is OK
        The handle must be dereferenced using ObDereferenceObject.
    ERROR_INVALID_HANDLE - the handle isn't OK

--*/
{
    DWORD WinStatus;
    PGENERIC_OBJECT GenericObject = Handle;
    ULONG LocalObjectType;

    PGENERIC_OBJECT Current;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    if ( Handle == NULL ) {
        AzPrint(( AZD_CRITICAL, "0x%lx: NULL handle not allowed.\n", NULL ));
        return ERROR_INVALID_HANDLE;
    }

    //
    // Use a try/except since we're touching memory assuming the handle is valid
    //

    __try {


        WinStatus = ObGetHandleType( Handle, AllowDeletedObjects, &LocalObjectType );

        if ( WinStatus == NO_ERROR ) {

            if ( ObjectType != LocalObjectType ) {
                AzPrint(( AZD_HANDLE, "0x%lx %ld: Object Type not local object type\n", GenericObject, GenericObject->ObjectType ));
                WinStatus = ERROR_INVALID_HANDLE;
            } else {
                PGENERIC_OBJECT_HEAD ParentGenericObjectHead = GenericObject->ParentGenericObjectHead;

                //
                // Ensure the object is actually in the list
                //
                // If the object has no name,
                //  search the linear list
                //

                if ( GenericObject->ObjectName == NULL ) {
                    PLIST_ENTRY ListEntry;

                    WinStatus = ERROR_INVALID_HANDLE;
                    for ( ListEntry = ParentGenericObjectHead->Head.Flink ;
                          ListEntry != &ParentGenericObjectHead->Head ;
                          ListEntry = ListEntry->Flink) {

                        Current = CONTAINING_RECORD( ListEntry,
                                                     GENERIC_OBJECT,
                                                     Next );

                        //
                        // If we found the object,
                        //  grab a reference.
                        //
                        if ( Current == GenericObject ) {

                            //
                            // If the caller wants the object to be refreshed,
                            //  do so now.
                            //

                            if ( RefreshCache &&
                                 (GenericObject->Flags & GENOBJ_FLAGS_REFRESH_ME) != 0  ) {

                                //
                                // Need exclusive access
                                //

                                AzpLockResourceSharedToExclusive( &AzGlResource );

                                WinStatus = AzPersistRefresh( GenericObject );

                                if ( WinStatus != NO_ERROR ) {
                                    break;
                                }
                            }

                            //
                            // Grab a reference to the object
                            //

                            InterlockedIncrement( &GenericObject->ReferenceCount );
                            AzpDumpGoRef( "Ref by Handle", GenericObject );
                            WinStatus = NO_ERROR;
                            break;
                        }
                    }

                    //
                    // If not,
                    //  the handle is invalid.
                    //

                    if ( WinStatus == ERROR_INVALID_HANDLE ) {
                        AzPrint(( AZD_HANDLE, "0x%lx %ld: Handle not in list.\n", GenericObject, GenericObject->ObjectType ));
                    }

                //
                // If the object has a name,
                //  search the AVL name tree since there may be large numbers of such
                //  handles.  We want to avoid a linear search.
                //

                } else {

                    WinStatus = ObReferenceObjectByName(
                                    ParentGenericObjectHead,
                                    &GenericObject->ObjectName->ObjectName,
                                    (RefreshCache ? AZP_FLAGS_REFRESH_CACHE : 0) |
                                        (AllowDeletedObjects ? AZP_FLAGS_ALLOW_DELETED_OBJECTS : 0 ),
                                    &Current );

                    if ( WinStatus != NO_ERROR ) {
                        if ( WinStatus == ERROR_NOT_FOUND ) {
                            AzPrint(( AZD_CRITICAL, "0x%lx %ld: Object not in list.\n", GenericObject, GenericObject->ObjectType ));
                            WinStatus = ERROR_INVALID_HANDLE;
                        }

                    } else if ( Current != GenericObject ) {
                        WinStatus = ERROR_INVALID_HANDLE;
                        AzPrint(( AZD_CRITICAL, "0x%lx %ld: Found wrong object with name.\n", GenericObject, GenericObject->ObjectType ));
                        ObDereferenceObject( Current );
                    }
                }
            }

        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        AzPrint(( AZD_CRITICAL, "0x%lx: AV accessing handle\n", GenericObject ));
        WinStatus = ERROR_INVALID_HANDLE;
    }

    return WinStatus;
}

VOID
ObDereferenceObject(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description

    Decrement the reference count on an object.

    When the last reference count is removed, delete the object.

    On entry, AzGlResource must be locked shared.  If the ref count reaches zero,
        AzGlResource must be locked exclusively.  We can get away with that because
        we force the ref count to zero only when closing the AzAuthorizationStore object.

Arguments

    GenericObject - Specifies the object to insert into the list

Return Value

    None

--*/
{
    ULONG RefCount;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    //
    // Decrement the reference count
    //

    RefCount = InterlockedDecrement( &GenericObject->ReferenceCount );
    AzpDumpGoRef( "Deref", GenericObject );

    //
    // Check if the object is no longer referenced
    //

    if ( RefCount == 0 ) {

        //
        // Grab the lock exclusively
        // If we are unloading the children of a parent object,
        // we might already have the lock exclusively
        //

        ASSERT( GenericObject->HandleReferenceCount == 0 );

        AzpLockResourceSharedToExclusive( &AzGlResource );

        //
        // Free the object itself
        //

        ObFreeGenericObject( GenericObject );

    }

}


DWORD
AzpValidateName(
    IN PAZP_STRING ObjectName,
    IN ULONG ObjectType
    )
/*++

Routine Description:

    This routine does a syntax check to ensure that the object name string contains
        only valid characters.

Arguments:

    ObjectName - Specifies the name of the object to validate.

    ObjectType - Specifies the type of the named object

Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_NAME - the syntax of the name is invalid

--*/
{
    LPWSTR Result;

#define CTRL_CHARS_0   L"\001\002\003\004\005\006\007"
#define CTRL_CHARS_1   L"\010\011\012\013\014\015\016\017"
#define CTRL_CHARS_2   L"\020\021\022\023\024\025\026\027"
#define CTRL_CHARS_3   L"\030\031\032\033\034\035\036\037"
#define CTRL_CHARS_STR CTRL_CHARS_0 CTRL_CHARS_1 CTRL_CHARS_2 CTRL_CHARS_3

#define SCOPE_INVALID_CHARS  (CTRL_CHARS_STR)
#define ALL_INVALID_CHARS  (L"\"*/:<>?\\|" CTRL_CHARS_STR)

    //
    // No need to validate SID names.
    //  All sid names are generated internally.
    //

    if ( ObjectType == OBJECT_TYPE_SID ) {
        ASSERT( ObjectName->IsSid );
        return NO_ERROR;
    }
    ASSERT( !ObjectName->IsSid );

    //
    // Allow NULL names for objects without names
    //

    if ( MaxObjectNameLength[ObjectType] == 0 ) {
        if ( ObjectName->String == NULL ) {
            return NO_ERROR;
        } else {
            return ERROR_INVALID_NAME;
        }
    }


    //
    // Non-null names must have valid characters
    //

    //
    // we disallow any leading and trailing spaces
    //

    if (ObjectName->StringSize <= 1   ||
        ObjectName->String[0] == L' ' ||
        ObjectName->String[(ObjectName->StringSize)/sizeof(ObjectName->String[0]) - 1] == L' ')
    {
        return ERROR_INVALID_NAME;
    }

    Result = wcspbrk( ObjectName->String,
                      ObjectType == OBJECT_TYPE_SCOPE ?
                        SCOPE_INVALID_CHARS :
                        ALL_INVALID_CHARS );

    return Result == NULL ? NO_ERROR : ERROR_INVALID_NAME;


}

DWORD
ObBuildGuidizedName(
    IN ULONG ObjectType,
    IN PAZP_STRING ObjectName,
    IN GUID *ObjectGuid,
    OUT PAZP_STRING BuiltObjectName
    )
/*++

Routine Description:

    This routine builds a unique name for an object given its real name and a GUID.
    This built name is used to resolve conflicts caused by renames, differences in the
    underlying store and the cache, and naming problems in the underlying store.

    The built name will be

        <ObjectName>-<ObjectGuid>

    Where <ObjectName> will be truncated on the right to meet maximum length restrictions
    for the object type.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    ObjectType - Specifies the object type of the object

    ObjectName - Specifies the conflicting name of the object

    ObjectGuid - Specifies the GUID of the object.
        This GUID uniquely identifies the child object.

    BuiltObjectName - Returns a pointer to the built name.
        This string must be freed using AzpFreeString.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_ENOUGH_MEMORY - There isn't enough memory to allocate the string

--*/
{
    DWORD WinStatus;

    LPWSTR GuidString;
    ULONG GuidLength;

    ULONG NameLength;

    LPWSTR BuiltString;

    //
    // Convert UUID to a string
    //

    WinStatus = UuidToString( ObjectGuid, &GuidString );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    GuidLength = (ULONG) wcslen( GuidString );

    //
    // Compute the number of characters to use from ObjectName
    //

    ASSERT( MaxObjectNameLength[ObjectType] != 0 );
    ASSERT( MaxObjectNameLength[ObjectType] > GuidLength+1 );

    NameLength = (ObjectName->StringSize/sizeof(WCHAR))-1;

    if ( NameLength + 1 + GuidLength > MaxObjectNameLength[ObjectType] ) {
        NameLength = MaxObjectNameLength[ObjectType] - 1 - GuidLength;
    }

    //
    // Allocate a buffer for the return string
    //

    BuiltString = (LPWSTR) AzpAllocateHeap( (NameLength + 1 + GuidLength + 1) * sizeof(WCHAR), "GNGUIDNM" );

    if ( BuiltString == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Copy the strings to the allocated buffer
    //

    RtlCopyMemory( BuiltString, ObjectName->String, NameLength*sizeof(WCHAR) );
    BuiltString[NameLength] = L'-';
    RtlCopyMemory( &BuiltString[NameLength+1], GuidString, (GuidLength+1) * sizeof(WCHAR) );

    //
    // Return the built string to the caller
    //

    AzpInitString( BuiltObjectName, BuiltString );

    WinStatus = NO_ERROR;

Cleanup:
    RpcStringFree( &GuidString );

    return WinStatus;
}


DWORD
ObCreateObject(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN ULONG ChildObjectType,
    IN PAZP_STRING ChildObjectNameString,
    IN GUID *ChildObjectGuid OPTIONAL,
    IN ULONG Flags,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    )
/*++

Routine Description:

    This routine creates a child object in the scope of the specified parent object.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        be verified.

    GenericChildHead - Specifies a pointer to the head of the list of children of
        ParentGenericObject.

    ChildObjectType - Specifies the object type RetChildGenericObject.

    ChildObjectNameString - Specifies the name of the child object.
        This name must be unique at the current scope.

    ChildObjectGuid - Specifies the GUID of the child object.
        This GUID uniquely identifies the child object.
        This parameter is only specified in AzpModeInit.
        If not specified, only the name of the object will be used to identify the child
        and the GUID will be set to zero.

    Flags - Specifies internal flags
        AZP_FLAGS_BY_GUID - ChildObjectGuid is passed in (This flag is superfluous but is sanity checked.)
        AZP_FLAGS_PERSIST_* - Call is from the persistence provider
        AZP_FLAGS_RECONCILE - Call is from AzpPersistReconcile

    RetChildGenericObject - Returns a pointer to the allocated generic child object
        This pointer must be dereferenced using ObDereferenceObject.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    DWORD WinStatus;

    ULONG DirtyBits;

    PGENERIC_OBJECT ChildGenericObject = NULL;
    PGENERIC_OBJECT FoundGenericObject = NULL;
    BOOLEAN WeLinkedInObject = FALSE;
    BOOLEAN NameConflicts = FALSE;
    AZP_STRING BuiltChildObjectNameString;

    //
    // Initialization
    //

    ASSERT( ChildObjectType != OBJECT_TYPE_ROOT );
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    AzpInitString( &BuiltChildObjectNameString, NULL );

    //
    // first things first, let's check if the AuthorizatioStore's versions support write
    //

    if (ParentGenericObject != NULL && IsNormalFlags(Flags) &&
        !AzpAzStoreVersionAllowWrite(ParentGenericObject->AzStoreObject) )
    {
        WinStatus = ERROR_REVISION_MISMATCH;
        goto Cleanup;
    }

    //
    // Validate the name
    //  Don't complain to the persist provider
    // Skip this test for SID object creation since they are
    // never persisted
    //

    if ( (ChildObjectType != OBJECT_TYPE_SID ) &&
         IsNormalFlags(Flags) ) {
        //
        // If the parent object has never been submitted,
        //  complain.
        //

        if ( ParentGenericObject != NULL &&
            (ParentGenericObject->DirtyBits & AZ_DIRTY_CREATE) != 0 ) {

            WinStatus = ERROR_DS_NO_PARENT_OBJECT;
            goto Cleanup;
        }

        //
        // Validate the syntax of the name
        //

        WinStatus = AzpValidateName( ChildObjectNameString, ChildObjectType );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

    }

    //
    // If the GUID was passed in,
    //  determine if an object by this guid already exists
    //

    if ( ChildObjectGuid != NULL ) {

        AzPrint(( AZD_REF, "ObCreateObject: %ws ", ChildObjectNameString->String ));
        AzpDumpGuid( AZD_REF, ChildObjectGuid );
        AzPrint(( AZD_REF, "\n" ));

        ASSERT( Flags & AZP_FLAGS_BY_GUID );
        ASSERT( Flags & (AZPE_FLAGS_PERSIST_MASK) );

        WinStatus = ObReferenceObjectByName(
                        GenericChildHead,
                        (PAZP_STRING)ChildObjectGuid,
                        AZP_FLAGS_BY_GUID,
                        &ChildGenericObject );

        if ( WinStatus == NO_ERROR ) {

            ASSERT( ChildGenericObject->ObjectType == ChildObjectType );

        } else if ( WinStatus == ERROR_NOT_FOUND ) {

            ChildGenericObject = NULL;

        } else {
            goto Cleanup;
        }


    } else {
        ASSERT( (Flags & AZP_FLAGS_BY_GUID) == 0 );
    }


    //
    // Don't do name collision detection for client contexts.
    //  Client contexts don't have names
    //

    if ( ChildObjectType != OBJECT_TYPE_CLIENT_CONTEXT ) {


        //
        // Ensure the new name doesn't exist in the current list
        //  Deleted objects conflict since they consume our entry in the AVL tree.
        //  The caller should close the deleted object.
        //

        WinStatus = ObReferenceObjectByName( GenericChildHead,
                                             ChildObjectNameString,
                                             AZP_FLAGS_ALLOW_DELETED_OBJECTS,
                                             &FoundGenericObject );

        if ( WinStatus == NO_ERROR ) {
            NameConflicts = TRUE;
        } else if ( WinStatus == ERROR_NOT_FOUND ) {

            //
            // Ensure the name doesn't conflict with the names of other objects that share the namespace.
            //

            if ( ObjectNameConflictRoutine[ChildObjectType] != NULL ) {

                WinStatus = ObjectNameConflictRoutine[ChildObjectType](
                                               ParentGenericObject,
                                               ChildObjectNameString );

                if ( WinStatus != NO_ERROR ) {
                    NameConflicts = TRUE;
                }

            }
        } else {
            goto Cleanup;
        }

        //
        // Handle name conflicts
        //

        if ( NameConflicts ) {

            //
            // If we're creating by GUID,
            //  then we don't care about the conflict
            //

            if ( ChildObjectGuid != NULL ) {

                //
                // If we found the object by GUID,
                //  and we found the same object by name,
                //  ignore the collision.
                //

                if ( FoundGenericObject == ChildGenericObject ) {

                    /* Drop through */

                //
                // If we collided with a different object,
                //  rename this one
                //

                } else {

                    WinStatus = ObBuildGuidizedName(
                                    ChildObjectType,
                                    ChildObjectNameString,
                                    ChildObjectGuid,
                                    &BuiltChildObjectNameString );

                    if ( WinStatus != NO_ERROR ) {
                        goto Cleanup;
                    }
                }

            } else {
                WinStatus = ERROR_ALREADY_EXISTS;
                goto Cleanup;
            }
        }



    }

    //
    // If we found the object by GUID,
    //  set the name on the object
    //

    if ( ChildGenericObject != NULL ) {

        //
        // If the object doesn't yet have the correct name,
        //  set the name on the object.
        //

        if ( FoundGenericObject != ChildGenericObject ) {

            WinStatus = ObSetProperty(
                            ChildGenericObject,
                            Flags,
                            AZ_PROP_NAME,
                            BuiltChildObjectNameString.StringSize ?
                                BuiltChildObjectNameString.String :
                                ChildObjectNameString->String );

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }
        }



    //
    // If we didn't find the existing object by GUID,
    //  allocate a new one.
    //

    } else {

        //
        // Allocate the structure to return to the caller
        //  (And insert it into the list of children of this parent.)
        //
        ChildGenericObject = ObAllocateGenericObject(
                                GenericChildHead,
                                BuiltChildObjectNameString.StringSize ?
                                    &BuiltChildObjectNameString :
                                    ChildObjectNameString );

        if ( ChildGenericObject == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        ChildGenericObject->DirtyBits = 0;

        //
        // Set the optional characteristics to a default value.  These will be changed
        // subsequently, if required.
        //

        //
        // Since we are creating the object, assume that it is writable.  If not, the value will
        // be changed from the provider
        //

        ChildGenericObject->IsWritable = TRUE;
        ChildGenericObject->CanCreateChildren = TRUE;

        ChildGenericObject->IsAclSupported = FALSE;
        ChildGenericObject->IsDelegationSupported = FALSE;
        ChildGenericObject->IsSACLSupported = FALSE;


        WeLinkedInObject = TRUE;


        //
        // Keep a pointer to the object at the root of the tree
        //  Back pointers don't increment reference count.
        //

        if ( ChildObjectType == OBJECT_TYPE_AZAUTHSTORE  ) {
            ChildGenericObject->AzStoreObject = (PAZP_AZSTORE) ChildGenericObject;
        } else {
            ChildGenericObject->AzStoreObject = (PAZP_AZSTORE)
                        ParentGenericObject->AzStoreObject;
        }


        //
        // Set AreChildrenLoaded to TRUE.  This will be set to the appropriate value
        // for AzApplication and AzScope objects in their respective init routines
        //

        ChildGenericObject->AreChildrenLoaded = TRUE;

        //
        // Call the routine to do object type specific initialization
        //

        if ( ObjectInitRoutine[ChildObjectType] == NULL ) {
            ASSERT( ObjectInitRoutine[ChildObjectType] != NULL );
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        WinStatus = ObjectInitRoutine[ChildObjectType](
                                       ParentGenericObject,
                                       ChildGenericObject );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        //
        // If the object is of type OBJECT_TYPE_AUTHORIZATION_STORE or
        // OBJECT_TYPE_APPLICATION or OBJECT_TYPE_SCOPE,
        // then set the PolicyAdmins and PolicyReaders list
        //

        if ( IsContainerObject( ChildObjectType ) ) {

            // ??? when one of these objects do object specific intialization
            // we'll have to be careful to not destroy the existing pointer.
            ChildGenericObject->GenericObjectLists =
                &(ChildGenericObject->PolicyAdmins);

            // policy admins

            ObInitObjectList( &ChildGenericObject->PolicyAdmins,
                              &ChildGenericObject->PolicyReaders,
                              FALSE, // forward link
                              AZP_LINKPAIR_POLICY_ADMINS,
                              AZ_DIRTY_POLICY_ADMINS,
                              &ChildGenericObject->AzpSids,
                              NULL,
                              NULL
                              );

            if ( !IsDelegatorObject( ChildObjectType ) ) {

                // policy readers

                ObInitObjectList( &ChildGenericObject->PolicyReaders,
                                  NULL,
                                  FALSE,    // Forward link
                                  AZP_LINKPAIR_POLICY_READERS,  //diff admins and readers
                                  AZ_DIRTY_POLICY_READERS,
                                  &ChildGenericObject->AzpSids,
                                  NULL,
                                  NULL);

            } else {

                // policy readers

                ObInitObjectList( &ChildGenericObject->PolicyReaders,
                                  &ChildGenericObject->DelegatedPolicyUsers,
                                  FALSE,    // Forward link
                                  AZP_LINKPAIR_POLICY_READERS,  //diff admins and readers
                                  AZ_DIRTY_POLICY_READERS,
                                  &ChildGenericObject->AzpSids,
                                  NULL,
                                  NULL);

                // policy readers

                ObInitObjectList( &ChildGenericObject->DelegatedPolicyUsers,
                                  NULL,
                                  FALSE,    // Forward link
                                  AZP_LINKPAIR_DELEGATED_POLICY_USERS,
                                  AZ_DIRTY_DELEGATED_POLICY_USERS,
                                  &ChildGenericObject->AzpSids,
                                  NULL,
                                  NULL);
            }

        } // if object type is AzAuthStore or application or scope

    }

    //
    // Remember the GUID
    //

    if ( ChildObjectGuid != NULL ) {
        ChildGenericObject->PersistenceGuid = *ChildObjectGuid;


        //
        // If we had to make up a name for the object,
        // and this call is from AzPersistUpdateCache,
        //  leave the new name lying around for AzpPersistReconcile to find so it can try to fix the issue.
        //

        if ( BuiltChildObjectNameString.StringSize != 0 &&
             (Flags & AZPE_FLAGS_PERSIST_UPDATE_CACHE) != 0 ) {

            if ( !ObAllocateNewName(
                    ChildGenericObject,
                    ChildObjectNameString ) ) {

                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
        }

    }

    //
    // Set all of the object specific default scalar values
    //  Skip when call from persist provider since we'll catch this in AzpPersistReconcile

    if ( IsNormalFlags(Flags) ) {
        WinStatus = ObSetPropertyToDefault(
                            ChildGenericObject,
                            ObjectAllScalarDirtyBits[ChildObjectType] &
                                    AZ_DIRTY_OBJECT_SPECIFIC );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }
    }


    //
    // Mark the object as needing to be written.
    //  Only the name has been set.  All other attributes have been defaulted.
    //  Only named objects are dirty after creation.
    //

    DirtyBits = AzGlObjectAllDirtyBits[ChildObjectType] & (AZ_DIRTY_NAME|AZ_DIRTY_CREATE);

    if ( IsNormalFlags(Flags) ) {
        ChildGenericObject->DirtyBits |= DirtyBits;
    } else {
        ASSERT( AzpIsCritsectLocked( &ChildGenericObject->AzStoreObject->PersistCritSect ) );
        ASSERT( (ChildGenericObject->Flags & GENOBJ_FLAGS_PERSIST_OK) == 0 );
        ChildGenericObject->PersistDirtyBits = DirtyBits;
    }

    //
    // Return the pointer to the new structure
    //

    *RetChildGenericObject = ChildGenericObject;
    ChildGenericObject = NULL;

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:
    if ( ChildGenericObject != NULL ) {

        // Remove the local reference
        ObDereferenceObject( ChildGenericObject );

        if ( WeLinkedInObject ) {
            // Remove the reference for being in the global list
            ObDereferenceObject( ChildGenericObject );
        }
    }

    if ( FoundGenericObject != NULL ) {
        ObDereferenceObject( FoundGenericObject );
    }

    AzpFreeString( &BuiltChildObjectNameString );

    return WinStatus;
}


DWORD
ObCommonCreateObject(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN ULONG ParentObjectType,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN ULONG ChildObjectType,
    IN LPCWSTR ChildObjectName,
    IN DWORD Reserved,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    )
/*++

Routine Description:

    This routine creates a child object in the scope of the specified parent object.

Arguments:

    ParentGenericObject - Specifies a handle to the parent object to add the child
        object onto.  This "handle" has been passed from the application and needs to
        be verified.

    ParentObjectType - Specifies the object type ParentGenericObject.

    GenericChildHead - Specifies a pointer to the head of the list of children of
        ParentGenericObject.  This is a computed pointer and is considered untrustworthy
        until ParentGenericObject has been verified.

    ChildObjectType - Specifies the object type RetChildGenericObject.

    ChildObjectName - Specifies the name of the child object.
        This name must be unique at the current scope.
        This name is passed from the application and needs to be verified.

    Reserved - Reserved.  Must by zero.

    RetChildGenericObject - Return a handle to the generic child object
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedParentObject = NULL;
    PGENERIC_OBJECT ChildGenericObject = NULL;
    AZP_STRING ChildObjectNameString;

    //
    // Grab the global lock
    //

    ASSERT( ParentObjectType != OBJECT_TYPE_ROOT );
    ASSERT( ChildObjectType != OBJECT_TYPE_AZAUTHSTORE );

    AzpLockResourceExclusive( &AzGlResource );
    AzpInitString( &ChildObjectNameString, NULL );

    //
    // Initialization
    //

    __try {
        *RetChildGenericObject = NULL;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        WinStatus = RtlNtStatusToDosError( GetExceptionCode());
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "ObCommonCreateObject: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( ParentGenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           TRUE,    // Refresh the cache
                                           ParentObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedParentObject = ParentGenericObject;

    //
    // first, let's make sure that caller can create new object
    //

    if ( ReferencedParentObject->CanCreateChildren == 0 && ChildObjectType != OBJECT_TYPE_CLIENT_CONTEXT ) {

        WinStatus = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // If the parent has not been loaded, then load the parent first
    //

    if ( !(ReferencedParentObject->AreChildrenLoaded) ) {

        WinStatus = AzPersistUpdateChildrenCache(
            ReferencedParentObject
            );

        if ( WinStatus != NO_ERROR ) {

            goto Cleanup;
        }
    }

    //
    // Capture the object name string from the caller
    //

    WinStatus = AzpCaptureString( &ChildObjectNameString,
                                  ChildObjectName,
                                  MaxObjectNameLength[ChildObjectType],
                                  ChildObjectType == OBJECT_TYPE_CLIENT_CONTEXT );  // NULL names only OK for client context

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Create the object
    //

    WinStatus = ObCreateObject(
                        ParentGenericObject,
                        GenericChildHead,
                        ChildObjectType,
                        &ChildObjectNameString,
                        NULL,   // Guid not known
                        0,      // No special flags
                        &ChildGenericObject );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Return the handle to the caller
    //

    ObIncrHandleRefCount( ChildGenericObject );
    *RetChildGenericObject = ChildGenericObject;

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedParentObject != NULL ) {
        ObDereferenceObject( ReferencedParentObject );
    }

    if ( ChildGenericObject != NULL ) {
        ObDereferenceObject( ChildGenericObject );
    }
    AzpFreeString( &ChildObjectNameString );

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}


DWORD
ObCommonOpenObject(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN ULONG ParentObjectType,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN ULONG ChildObjectType,
    IN LPCWSTR ChildObjectName,
    IN DWORD Reserved,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    )
/*++

Routine Description:

    This routine opens a child object in the scope of the specified parent object.

Arguments:

    ParentGenericObject - Specifies a handle to the parent object to open the child
        object from.  This "handle" has been passed from the application and needs to
        be verified.

    ParentObjectType - Specifies the object type ParentGenericObject.

    GenericChildHead - Specifies a pointer to the head of the list of children of
        ParentGenericObject.  This is a computed pointer and is considered untrustworthy
        until ParentGenericObject has been verified.

    ChildObjectType - Specifies the object type RetChildGenericObject.

    ChildObjectName - Specifies the name of the child object.
        This name is passed from the application and needs to be verified.

    Reserved - Reserved.  Must by zero.

    RetChildGenericObject - Return a handle to the generic child object
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - There is no object by that name

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedParentObject = NULL;
    PGENERIC_OBJECT ChildGenericObject = NULL;

    AZP_STRING ChildObjectNameString;

    //
    // Grab the global lock
    //

    AzpLockResourceShared( &AzGlResource );
    ASSERT( ParentObjectType != OBJECT_TYPE_ROOT );
    ASSERT( ChildObjectType != OBJECT_TYPE_AZAUTHSTORE );

    //
    // Initialization
    //

    AzpInitString( &ChildObjectNameString, NULL );
    __try {
        *RetChildGenericObject = NULL;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        WinStatus = RtlNtStatusToDosError( GetExceptionCode());
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "ObCommonOpenObject: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( ParentGenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           TRUE,    // Refresh the cache
                                           ParentObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedParentObject = ParentGenericObject;

    //
    // If the parent has not been loaded, then load the parent first
    //

    if ( !(ParentGenericObject->AreChildrenLoaded) ) {

        //
        // grab the resource lock exclusively
        //

        AzpLockResourceSharedToExclusive( &AzGlResource );

        WinStatus = AzPersistUpdateChildrenCache(
            ParentGenericObject
            );

        AzpLockResourceExclusiveToShared( &AzGlResource );

        if ( WinStatus != NO_ERROR ) {

            goto Cleanup;
        }
    }


    //
    // Capture the object name string from the caller
    //

    WinStatus = AzpCaptureString( &ChildObjectNameString,
                                  ChildObjectName,
                                  MaxObjectNameLength[ChildObjectType],
                                  FALSE );  // NULL names not OK

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Find the named object
    //

    WinStatus = ObReferenceObjectByName( GenericChildHead,
                                         &ChildObjectNameString,
                                         AZP_FLAGS_REFRESH_CACHE,
                                         &ChildGenericObject );


    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Return the handle to the caller
    //

    ObIncrHandleRefCount( ChildGenericObject );
    *RetChildGenericObject = ChildGenericObject;

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedParentObject != NULL ) {
        ObDereferenceObject( ReferencedParentObject );
    }

    if ( ChildGenericObject != NULL ) {
        ObDereferenceObject( ChildGenericObject );
    }

    AzpFreeString( &ChildObjectNameString );

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}

DWORD
ObEnumObjects(
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN BOOL EnumerateDeletedObjects,
    IN BOOL RefreshCache,
    IN OUT PULONG EnumerationContext,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    )
/*++

Routine Description:

    This routine enumerates the next child object from the scope of the specified parent object.

    On entry, AzGlResource must be locked shared.

Arguments:

    GenericChildHead - Specifies a pointer to the head of the list of children of
        ParentGenericObject.

    EnumerateDeletedObjects - Specifies whether deleted objects are to be returned
        in the enumeration.

    RefreshCache - If TRUE, the returned object has its cache entry refreshed from
        the policy database if needed.
        If FALSE, the entry is returned unrefreshed.

    EnumerationContext - Specifies a context indicating the next object to return
        On input for the first call, should point to zero.
        On input for subsequent calls, should point to the value returned on the previous call.
        On output, returns a value to be passed on the next call.

    RetChildGenericObject - Returns a pointer to the generic child object

Return Value:

    NO_ERROR - The operation was successful (a handle was returned)

    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

--*/
{
    DWORD WinStatus;

    PLIST_ENTRY ListEntry;
    PGENERIC_OBJECT ChildGenericObject = NULL;



    //
    // If we've already returned the whole list,
    //  don't bother walking the list.
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    if ( *EnumerationContext >= GenericChildHead->NextSequenceNumber ) {
        WinStatus = ERROR_NO_MORE_ITEMS;
        goto Cleanup;
    }

    //
    // Walk the list of children finding where we left off
    //

    for ( ListEntry = GenericChildHead->Head.Flink ;
          ListEntry != &GenericChildHead->Head ;
          ListEntry = ListEntry->Flink) {

        ChildGenericObject = CONTAINING_RECORD( ListEntry,
                                                GENERIC_OBJECT,
                                                Next );

        //
        // See if this is it
        //

        if ( ChildGenericObject->SequenceNumber > *EnumerationContext ) {

            //
            // Ignore deleted object if the caller doesn't want to see them
            //
            // If this is not a deleted object,
            //  or the caller wants deleted objects to be returned,
            //  return it.
            //

            if ((ChildGenericObject->Flags & GENOBJ_FLAGS_DELETED) == 0 ||
                EnumerateDeletedObjects ) {

                break;
            }

        }

        ChildGenericObject = NULL;

    }

    //
    // If we've already returned the whole list,
    //  indicate so.
    //

    if ( ChildGenericObject == NULL ) {
        WinStatus = ERROR_NO_MORE_ITEMS;
        goto Cleanup;
    }

    //
    // If the caller wants the object to be refreshed,
    //  do so now.
    //

    if ( RefreshCache &&
         (ChildGenericObject->Flags & GENOBJ_FLAGS_REFRESH_ME) != 0  ) {

        //
        // Need exclusive access
        //

        AzpLockResourceSharedToExclusive( &AzGlResource );

        WinStatus = AzPersistRefresh( ChildGenericObject );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }
    }

    //
    // Return the handle to the caller
    //

    *EnumerationContext = ChildGenericObject->SequenceNumber;
    *RetChildGenericObject = ChildGenericObject;

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:
    return WinStatus;
}

DWORD
ObCommonEnumObjects(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN ULONG ParentObjectType,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN OUT PULONG EnumerationContext,
    IN DWORD Reserved,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    )
/*++

Routine Description:

    This routine enumerates the next child object from the scope of the specified parent object.
    If the children of the parent have not yet been loaded, call the persistence provider routine
    to load all the children of the parent object.

Arguments:

    ParentGenericObject - Specifies a handle to the parent object to enumerate the child
        objects of.
        This "handle" has been passed from the application and needs to be verified.

    ParentObjectType - Specifies the object type ParentGenericObject.

    GenericChildHead - Specifies a pointer to the head of the list of children of
        ParentGenericObject.  This is a computed pointer and is considered untrustworthy
        until ParentGenericObject has been verified.

    EnumerationContext - Specifies a context indicating the next object to return
        On input for the first call, should point to zero.
        On input for subsequent calls, should point to the value returned on the previous call.
        On output, returns a value to be passed on the next call.

    Reserved - Reserved.  Must by zero.

    RetChildGenericObject - Returns a handle to the generic child object
        The caller must close this handle by calling AzpDzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful (a handle was returned)

    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedParentObject = NULL;
    PGENERIC_OBJECT ChildGenericObject = NULL;

    //
    // Grab the global lock
    //
    ASSERT( ParentObjectType != OBJECT_TYPE_ROOT );

    AzpLockResourceShared( &AzGlResource );


    //
    // Initialize the return handle
    //

    __try {
        *RetChildGenericObject = NULL;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        WinStatus = RtlNtStatusToDosError( GetExceptionCode());
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "ObCommonEnumObjects: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( ParentGenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           TRUE,    // Refresh the cache
                                           ParentObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // If the parent needs to be loaded for its children, then do it now
    // If the parent has not been submitted, then no need to do so
    //

    if ( GenericChildHead->LoadParentBeforeReferencing &&
         !(ParentGenericObject->AreChildrenLoaded) ) {
  
        //
        // Grab the resource lock exclusively
        //

        AzpLockResourceSharedToExclusive( &AzGlResource );

        WinStatus = AzPersistUpdateChildrenCache( ParentGenericObject );

        AzpLockResourceExclusiveToShared( &AzGlResource );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        ParentGenericObject->AreChildrenLoaded = TRUE;

    }

    ReferencedParentObject = ParentGenericObject;

    //
    // Call the common routine to do the actual enumeration
    //

    WinStatus = ObEnumObjects( GenericChildHead,
                               FALSE,   // Don't enumerate deleted objects
                               TRUE,    // Refresh the cache
                               EnumerationContext,
                               &ChildGenericObject );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Return the handle to the caller
    //

    ObIncrHandleRefCount( ChildGenericObject );
    *RetChildGenericObject = ChildGenericObject;

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedParentObject != NULL ) {
        ObDereferenceObject( ReferencedParentObject );
    }

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}


DWORD
ObCommonGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    Returns the specified property for a generic object.

Arguments:

    GenericObject - Specifies a handle to the object to get the property from.
        This "handle" has been passed from the application and needs to be verified.

    Flags - Specifies internal flags
        AZP_FLAGS_BY_GUID - name lists should be returned as GUID lists
        AZP_FLAGS_PERSIST_* - Call is from the persistence provider

    PropertyId - Specifies which property to return.

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME                   LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION            LPWSTR - Description of the object
        AZ_PROP_APPLICATION_DATA       LPWSTR - Opaque data stored by an application
        AZ_PROP_POLICY_ADMINS          PAZ_SID_ARRAY - List of policy admins
        AZ_PROP_POLICY_READERS         PAZ_SID_ARRAY - List of policy reader
        AZ_PROP_DELEGATED_POLICY_USERS PAZ_SID_ARRAY - List of delegated policy users

        Any object specific properties.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    DWORD WinStatus;

    ULONG ObjectType;
    PGENERIC_OBJECT ReferencedGenericObject = NULL;

    //
    // Grab the global lock
    //

    AzpLockResourceShared( &AzGlResource );


    //
    // Initialize the return value
    //

    __try {
        *PropertyValue = NULL;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        WinStatus = RtlNtStatusToDosError( GetExceptionCode());
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "ObCommonGetProperty: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Determine the type of the object
    //

    WinStatus = ObGetHandleType( GenericObject,
                                 FALSE,   // Don't allow deleted objects
                                 &ObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( GenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           TRUE,    // Refresh the cache
                                           ObjectType );
    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedGenericObject = GenericObject;

    //
    // Call the common routine
    //

    WinStatus = ObGetProperty( GenericObject,
                               Flags,
                               PropertyId,
                               PropertyValue );


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedGenericObject != NULL ) {
        ObDereferenceObject( ReferencedGenericObject );
    }

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;

}


DWORD
ObGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    Returns the specified property for a generic object.

Arguments:

    GenericObject - Specifies a handle to the object to get the property from.
        This "handle" has been passed from the application and needs to be verified.

    Flags - Specifies internal flags
        AZP_FLAGS_BY_GUID - name lists should be returned as GUID lists
        AZP_FLAGS_PERSIST_* - Call is from the persistence provider

    PropertyId - Specifies which property to return.

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME             LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION      LPWSTR - Description of the object
        AZ_PROP_APPLICATION_DATA LPWSTR - Opaque data stored by an application
        AZ_PROP_POLICY_ADMINS    PAZ_SID_ARRAY - List of policy admins
        AZ_PROP_POLICY_READERS   PAZ_SID_ARRAY - List of policy reader
        AZ_PROP_GENERATE_AUDITS  ULONG - whether the object's auditing flag is set
        AZ_PROP_APPLY_STORE_SACL LONG  - whether the object's apply sacl flag is set

        Any object specific properties.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    DWORD WinStatus;

    //
    // Initialize the return value
    //

    *PropertyValue = NULL;

    //
    // Return any common attribute
    //
    //  Return object name to the caller
    //

    switch ( PropertyId ) {
    case AZ_PROP_NAME:

        //
        // Fail if the object is unnamed
        //

        if ( (AzGlObjectAllDirtyBits[GenericObject->ObjectType] & AZ_DIRTY_NAME) == 0 ) {
            AzPrint(( AZD_INVPARM, "ObCommonGetProperty: Object has no name\n" ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        *PropertyValue = AzpGetStringProperty( &GenericObject->ObjectName->ObjectName );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        break;

    //
    // Return object decription to the caller
    //
    case AZ_PROP_DESCRIPTION:

        //
        // Fail if the object has no description
        //

        if ( (AzGlObjectAllDirtyBits[GenericObject->ObjectType] & AZ_DIRTY_DESCRIPTION) == 0 ) {
            AzPrint(( AZD_INVPARM, "ObCommonGetProperty: Object has no description\n" ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        *PropertyValue = AzpGetStringProperty( &GenericObject->Description );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        break;

    //
    // Return object application data to the caller
    //
    case AZ_PROP_APPLICATION_DATA:

        //
        // Fail if the object has no application data
        //

        if ( (AzGlObjectAllDirtyBits[GenericObject->ObjectType] & AZ_DIRTY_APPLICATION_DATA) == 0 ) {
            AzPrint(( AZD_INVPARM, "ObCommonGetProperty:"
                      "Object has no application data\n" ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        *PropertyValue = AzpGetStringProperty( &GenericObject->ApplicationData );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        break;

    //
    //  Return audit boolean flag
    //

    case AZ_PROP_GENERATE_AUDITS:
        //
        // Ensure the call has privilege
        //

        if ( IsNormalFlags(Flags) ) {

            if ( !GenericObject->AzStoreObject->HasSecurityPrivilege ) {
                WinStatus = ERROR_ACCESS_DENIED;
                goto Cleanup;
            }

        }

        if ( (AzGlObjectAllDirtyBits[GenericObject->ObjectType] & AZ_DIRTY_GENERATE_AUDITS) == 0 ) {
            AzPrint(( AZD_INVPARM, "ObCommonGetProperty: Object has no generate-audits data\n" ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        *PropertyValue = AzpGetUlongProperty((GenericObject->IsGeneratingAudits) ? 1 : 0);

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        break;

    //
    // return apply SACL LONG
    //

    case AZ_PROP_APPLY_STORE_SACL:
        //
        // Ensure the caller has privilege
        //

        if ( IsNormalFlags(Flags) ) {

            if ( !GenericObject->AzStoreObject->HasSecurityPrivilege ) {
                WinStatus = ERROR_ACCESS_DENIED;
                goto Cleanup;
            }

        }

        if ( (AzGlObjectAllDirtyBits[GenericObject->ObjectType] & AZ_DIRTY_APPLY_STORE_SACL) == 0 ) {
            AzPrint(( AZD_INVPARM, "ObCommonGetProperty: Object has no apply-store-sacl data\n" ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        if ( !(GenericObject->IsSACLSupported) ) {

            AzPrint(( AZD_INVPARM, "ObCommonGetProperty:"
                      "Object has no apply-store-sacl data\n" ));
            WinStatus = ERROR_NOT_SUPPORTED;
            goto Cleanup;
        }

        *PropertyValue = AzpGetUlongProperty( (GenericObject->ApplySacl) ? 1 : 0 );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        break;

    //
    // Return object write permission to the caller
    //
    case AZ_PROP_WRITABLE:

        *PropertyValue = AzpGetUlongProperty( (GenericObject->IsWritable) ? 1 : 0 );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        break;

    //
    // Return object child create permissions to the caller
    //

    case AZ_PROP_CHILD_CREATE:

        *PropertyValue = AzpGetUlongProperty( (GenericObject->CanCreateChildren) ? 1 : 0 );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        break;

    //
    // Return the list of policy admins/readers
    //

    case AZ_PROP_POLICY_ADMINS:
    case AZ_PROP_POLICY_READERS:

        WinStatus = CHECK_ACL_SUPPORT(GenericObject);

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        if ( PropertyId == AZ_PROP_POLICY_ADMINS ) {

            *PropertyValue = ObGetPropertyItems( &GenericObject->PolicyAdmins );

        } else {

            *PropertyValue = ObGetPropertyItems( &GenericObject->PolicyReaders );
        }

        if ( *PropertyValue == NULL ) {

            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        break;

    //
    // Return the list of delegated policy users
    //

    case AZ_PROP_DELEGATED_POLICY_USERS:

        WinStatus = CHECK_DELEGATION_SUPPORT(GenericObject);

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        *PropertyValue = ObGetPropertyItems( &GenericObject->DelegatedPolicyUsers );

        if ( *PropertyValue == NULL ) {

            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        break;

    default:
        ASSERT ( PropertyId >= AZ_PROP_FIRST_SPECIFIC );

        //
        // Call the routine to do object type specific querying
        //

        if ( ObjectGetPropertyRoutine[GenericObject->ObjectType] != NULL ) {

            WinStatus = ObjectGetPropertyRoutine[GenericObject->ObjectType](
                            GenericObject,
                            Flags,
                            PropertyId,
                            PropertyValue );
            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }
        } else {
            AzPrint(( AZD_INVPARM, "ObCommonGetProperty: No get property routine.\n", GenericObject->ObjectType, PropertyId ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        break;
    }


    //
    // Return the value to the caller
    //
    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:

    return WinStatus;

}


DWORD
ObSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Sets the specified property for a generic object.

Arguments:

    GenericObject - Specifies a handle to the object to modify.

    Flags - Specifies flags controlling to operation of the routine
        AZP_FLAGS_SETTING_TO_DEFAULT - Property is being set to default value
        AZP_FLAGS_PERSIST_* - Call is from the persistence provider

    PropertyId - Specifies which property to return.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME             LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION      LPWSTR - Description of the object
        AZ_PROP_APPLICATION_DATA LPWSTR - Opaque data stored by an application
        AZ_PROP_GENERATE_AUDITS  PULONG - whether the audit flag is set
        AZ_PROP_APPLY_STORE_SACL PLONG  - whether the sacl flag is set

        Any object specific properties.


Return Value:

    NO_ERROR - The operation was successful
    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    DWORD WinStatus;

    AZP_STRING CapturedString;
    PGENERIC_OBJECT_NAME NewObjectName = NULL;
    BOOL bHasChanged = TRUE;
    
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    AzpInitString( &CapturedString, NULL );

    if ( IsNormalFlags(Flags) &&
        ((Flags & AZP_FLAGS_SETTING_TO_DEFAULT) == 0) &&
        GenericObject->IsWritable == 0 &&
        GenericObject->ObjectType != OBJECT_TYPE_CLIENT_CONTEXT)
    {
        WinStatus = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Set any common attribute
    //
    //  Set the object name
    //

    switch ( PropertyId ) {
    case AZ_PROP_NAME:

        BEGIN_SETPROP( &WinStatus, GenericObject, Flags, AZ_DIRTY_NAME ) {
            PGENERIC_OBJECT ChildGenericObject;
            PGENERIC_OBJECT_LIST GenericObjectList;

            //
            // Capture the input string
            //

            WinStatus = AzpCaptureString( &CapturedString,
                                          (LPWSTR) PropertyValue,
                                          CHECK_STRING_LENGTH( Flags, MaxObjectNameLength[GenericObject->ObjectType]),
                                          FALSE ); // NULL not ok

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            //
            // Validate the syntax of the name
            //

            WinStatus = AzpValidateName( &CapturedString, GenericObject->ObjectType );

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            //
            // Check to see if the name conflicts with an existing name
            //
            // Ensure the new name doesn't exist in the current list
            //  Deleted objects conflict since they consume our entry in the AVL tree.
            //  The caller should close the deleted object.
            //

            WinStatus = ObReferenceObjectByName( GenericObject->ParentGenericObjectHead,
                                                 &CapturedString,
                                                 AZP_FLAGS_ALLOW_DELETED_OBJECTS,
                                                 &ChildGenericObject );

            if ( WinStatus == NO_ERROR ) {
                ObDereferenceObject( ChildGenericObject );
                WinStatus = ERROR_ALREADY_EXISTS;
                goto Cleanup;
            }

            //
            // Ensure the name doesn't conflict with the names of other objects that share the namespace.
            //

            if ( ObjectNameConflictRoutine[GenericObject->ObjectType] != NULL ) {

                WinStatus = ObjectNameConflictRoutine[GenericObject->ObjectType](
                                               ParentOfChild(GenericObject),
                                               &CapturedString );

                if ( WinStatus != NO_ERROR ) {
                    goto Cleanup;
                }

            }

            //
            // Insert the new name into the AVL tree
            //

            NewObjectName = ObInsertNameIntoAvlTree(
                                GenericObject->ParentGenericObjectHead,
                                &CapturedString );

            if ( NewObjectName == NULL ) {
                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            NewObjectName->GenericObject = GenericObject;

            //
            // Update all links to this object to be links to the new name
            //  Forward links are maintained in order sorted by name
            //
            // Walk all of the GenericObjectLists rooted on by this object
            //

            for ( GenericObjectList = GenericObject->GenericObjectLists;
                  GenericObjectList != NULL;
                  GenericObjectList = GenericObjectList->NextGenericObjectList ) {

                ULONG Index;


                //
                // Skip forward links since they represent linke 'from' this object
                //

                if ( !GenericObjectList->IsBackLink ) {
                    continue;
                }

                //
                // Follow each backlink to the forward link back to us
                //

                for ( Index=0; Index<GenericObjectList->GenericObjects.UsedCount; Index++ ) {

                    PGENERIC_OBJECT OtherGenericObject;
                    PGENERIC_OBJECT_LIST OtherGenericObjectList;
                    ULONG OtherIndex;

                    //
                    // Grab a pointer to the object the points to us
                    //

                    OtherGenericObject = (PGENERIC_OBJECT)
                            (GenericObjectList->GenericObjects.Array[Index]);

                    //
                    // Get a pointer to the object list that our entry is in
                    //

                    OtherGenericObjectList = ObGetObjectListPtr( OtherGenericObject,
                                                                 GenericObject->ObjectType,
                                                                 GenericObjectList );

                    ASSERT( OtherGenericObjectList != NULL );
                    ASSERT( !OtherGenericObjectList->IsBackLink );

                    //
                    // Lookup our old name in the object list that our entry is in.
                    //  It has to be there since we have a back link.
                    //

                    WinStatus = ObLookupPropertyItem( OtherGenericObjectList,
                                                      &GenericObject->ObjectName->ObjectName,
                                                      &OtherIndex );

                    ASSERT( WinStatus == ERROR_ALREADY_EXISTS );

                    //
                    // Remove the old entry
                    //

                    AzpRemovePtrByIndex( &OtherGenericObjectList->GenericObjects, OtherIndex );

                    //
                    // Lookup our new name in the object list that our entry is in.
                    //  It can't be there since we already did conflict detection.
                    //

                    WinStatus = ObLookupPropertyItem( OtherGenericObjectList,
                                                      &CapturedString,
                                                      &OtherIndex );

                    ASSERT( WinStatus == ERROR_NOT_FOUND );

                    //
                    // Add the new entry
                    //  This can't fail because of no memory since we just freed up a slot
                    //

                    WinStatus = AzpAddPtr(
                        &OtherGenericObjectList->GenericObjects,
                        GenericObject,
                        OtherIndex );

                    ASSERT( WinStatus == NO_ERROR );

                }

            }

            //
            // Remove the old name from the AVL tree
            //

            if (!RtlDeleteElementGenericTable (
                        &GenericObject->ParentGenericObjectHead->AvlTree,
                        GenericObject->ObjectName ) ) {

                GenericObject->ObjectName->GenericObject = NULL;
                ASSERT( FALSE );
            }

            GenericObject->ObjectName = NewObjectName;

            WinStatus = NO_ERROR;

        } END_SETPROP(bHasChanged);

        break;

    //
    // Set object description
    //
    case AZ_PROP_DESCRIPTION:

        BEGIN_SETPROP( &WinStatus, GenericObject, Flags, AZ_DIRTY_DESCRIPTION ) {

            //
            // Capture the input string
            //

            WinStatus = AzpCaptureString( &CapturedString,
                                          (LPWSTR) PropertyValue,
                                          CHECK_STRING_LENGTH( Flags, AZ_MAX_DESCRIPTION_LENGTH),
                                          TRUE ); // NULL is OK

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            //
            // Swap the old/new names
            //

            AzpSwapStrings( &CapturedString, &GenericObject->Description );

            WinStatus = NO_ERROR;

        } END_SETPROP(bHasChanged);

        break;

    //
    // Set application data
    //
    case AZ_PROP_APPLICATION_DATA:

        BEGIN_SETPROP( &WinStatus, GenericObject, Flags, AZ_DIRTY_APPLICATION_DATA ) {

            //
            // Capture the input string
            //

            WinStatus = AzpCaptureString( &CapturedString,
                                          (LPWSTR) PropertyValue,
                                          CHECK_STRING_LENGTH(
                                              Flags,
                                              AZ_MAX_APPLICATION_DATA_LENGTH),
                                          TRUE ); // NULL is OK

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            //
            // Swap the old/new names
            //

            AzpSwapStrings( &CapturedString, &GenericObject->ApplicationData );

            WinStatus = NO_ERROR;

        } END_SETPROP(bHasChanged);

        break;

    //
    //  to set audit, check pirvilege 1st.  If previously known that the user
    //  does not have the privilege, no need to make the call into the provider
    //

    case AZ_PROP_GENERATE_AUDITS:

        BEGIN_SETPROP( &WinStatus, GenericObject, Flags, AZ_DIRTY_GENERATE_AUDITS ) {

            //
            // Do parameter validity checking
            //

            WinStatus = AzpCaptureLong( PropertyValue, &GenericObject->IsGeneratingAudits);

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

        } END_SETPROP(bHasChanged);

        break;

    //
    // Set whether or not a SACL should be stored
    //

    case AZ_PROP_APPLY_STORE_SACL:

        BEGIN_SETPROP( &WinStatus, GenericObject, Flags, AZ_DIRTY_APPLY_STORE_SACL ) {

            //
            // Do parameter validity checking
            //

            BEGIN_VALIDITY_CHECKING( Flags ) {

                if ( !(GenericObject->IsSACLSupported) ) {

                    AzPrint(( AZD_INVPARM, "ObCommonGetProperty:"
                              "Object has no apply-store-sacl data\n" ));
                    WinStatus = ERROR_NOT_SUPPORTED;
                    goto Cleanup;
                }


                //
                // Ensure the caller has privilege
                //

                if ( !GenericObject->AzStoreObject->HasSecurityPrivilege ) {
                    WinStatus = ERROR_ACCESS_DENIED;
                    goto Cleanup;
                }

            } END_VALIDITY_CHECKING;

            WinStatus = AzpCaptureLong( PropertyValue, &GenericObject->ApplySacl);

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

        } END_SETPROP(bHasChanged);

        break;

    default:
        ASSERT ( PropertyId >= AZ_PROP_FIRST_SPECIFIC );

        //
        // Call the routine to do object type specific set property
        //

        if ( ObjectSetPropertyRoutine[GenericObject->ObjectType] != NULL ) {

            WinStatus = ObjectSetPropertyRoutine[GenericObject->ObjectType](
                        GenericObject,
                        Flags,
                        PropertyId,
                        PropertyValue );

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

        } else {
            AzPrint(( AZD_INVPARM, "ObSetProperty: no set property routine: %ld %ld\n", GenericObject->ObjectType, PropertyId ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        break;
    }


    //
    // Free locally used resources
    //
Cleanup:

    AzpFreeString( &CapturedString );

    //
    // Mark that the operation caches need flushing
    //  ... any change to the object cache invalidates the cache
    //
    //  ??? This is really sub-optimal.  We really want to know if the attribute has
    //  *changed*.  Otherwise, calling AzUpdateCache will increment the serial number.
    //  It should. But only if the attribute becomes different.
    //

    if ( WinStatus == NO_ERROR ) {
        GenericObject->AzStoreObject->OpCacheSerialNumber ++;

        AzPrint(( AZD_ACCESS_MORE, "ObSetProperty: OpCacheSerialNumber set to %ld\n",
                  GenericObject->AzStoreObject->OpCacheSerialNumber ));
    }

    return WinStatus;

}

PAZP_DEFAULT_VALUE
ObDirtyBitToDefaultValue(
    IN ULONG ObjectType,
    IN ULONG DirtyBit
    )
/*++

Routine Description:

    This routine finds the default value structure for a particular dirty bit.

Arguments:

    ObjectType - Specifies the object type of the object the DirtyBits apply to

    DirtyBits - Specifies the dirty bit to lookup


Return Value:

    NULL if there is no translation

--*/
{
    PAZP_DEFAULT_VALUE DefaultValues;

    //
    // Grab the array for this particular object type
    //

    DefaultValues = ObjectDefaultValuesArray[ObjectType];

    if ( DefaultValues == NULL ) {
        return NULL;
    }

    //
    // Loop through the list finding the correct entry
    //

    while ( DefaultValues->DirtyBit != 0 ) {

        if ( DefaultValues->DirtyBit == DirtyBit ) {
            return DefaultValues;
        }

        DefaultValues++;
    }

    return NULL;
}

DWORD
ObSetPropertyToDefault(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG DirtyBits
    )
/*++

Routine Description:

    Sets the properties corresponding to "DirtyBits" to their default value.

    This routine only sets attributes that are scalars to their default value.
    The caller is responsible for setting attributes that are "lists".

Arguments:

    GenericObject - Specifies a handle to the object to modify.
        This "handle" has been passed from the application and needs to be verified.

    DirtyBits - Specifies a bit mask of attributes which are to be set to their default value.
        The caller is allowed to pass in bits that don't apply to this object.
        Such bits are silently ignored.


Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;

    //
    // Silently ignore bits that don't apply to this object
    //
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    DirtyBits &= ObjectAllScalarDirtyBits[GenericObject->ObjectType];

    //
    // Handle any common attributes
    //  Handle the object name
    //

    if ( DirtyBits & AZ_DIRTY_NAME ) {

        DirtyBits &= ~AZ_DIRTY_NAME;
    }

    //
    // Handle object description
    //

    if ( DirtyBits & AZ_DIRTY_DESCRIPTION ) {

        //
        // Free the old string
        //
        AzpFreeString( &GenericObject->Description );
        DirtyBits &= ~AZ_DIRTY_DESCRIPTION;
    }

    //
    // Handle object application data
    //

    if ( DirtyBits & AZ_DIRTY_APPLICATION_DATA ) {

        //
        // Free the old string
        //
        AzpFreeString( &GenericObject->ApplicationData );
        DirtyBits &= ~AZ_DIRTY_APPLICATION_DATA;
    }

    //
    // Handle ApplyStoreSacl
    //

    if ( DirtyBits & AZ_DIRTY_APPLY_STORE_SACL ) {

        //
        // Only define the bit for container objects
        //

        if ( IsContainerObject( GenericObject->ObjectType ) ) {
            if ( GenericObject->ObjectType == OBJECT_TYPE_AZAUTHSTORE ) {
                GenericObject->ApplySacl = GenericObject->AzStoreObject->HasSecurityPrivilege;
            } else {
                GenericObject->ApplySacl = FALSE;
            }
        }
        DirtyBits &= ~AZ_DIRTY_APPLY_STORE_SACL;
    }

    //
    // Handle IsGeneratingAudits
    //

    if ( DirtyBits & AZ_DIRTY_GENERATE_AUDITS ) {

        //
        // Only define the bit at the authorization store and application level
        //

        if ( GenericObject->ObjectType == OBJECT_TYPE_AZAUTHSTORE ||
             GenericObject->ObjectType == OBJECT_TYPE_APPLICATION ) {

            GenericObject->IsGeneratingAudits = TRUE;
        }
        DirtyBits &= ~AZ_DIRTY_GENERATE_AUDITS;
    }

    //
    // Loop handling one bit at a time
    //

    while ( DirtyBits != 0 ) {

        ULONG DirtyBit;
        PAZP_DEFAULT_VALUE DefaultValue;
        DWORD TempStatus;

        ASSERT( (DirtyBits & ~AZ_DIRTY_OBJECT_SPECIFIC) == 0 );

        //
        // Grab the next bit
        //

        DirtyBit = DirtyBits & ~(DirtyBits & (DirtyBits-1));

        //
        // Lookup the default value
        //

        DefaultValue = ObDirtyBitToDefaultValue(
                            GenericObject->ObjectType,
                            DirtyBit );

        ASSERT( DefaultValue != NULL );

        //
        // Set the property to its default value
        // We should ignore bits where the default value isn't in
        // the default table
        //

        if ( DefaultValue != NULL ) {

            TempStatus = ObSetProperty( GenericObject,
                                        AZP_FLAGS_SETTING_TO_DEFAULT,
                                        DefaultValue->PropertyId,
                                        DefaultValue->DefaultValue );

            if ( TempStatus != NO_ERROR ) {
                WinStatus = TempStatus;
            }
        }

        // Turn off the processed bit
        DirtyBits &= ~DirtyBit;

    }

    return WinStatus;

}

DWORD
ObCommonSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Sets the specified property for a generic object.

Arguments:

    GenericObject - Specifies a handle to the object to modify.
        This "handle" has been passed from the application and needs to be verified.

    PropertyId - Specifies which property to return.

    Reserved - Reserved.  Must by zero.


    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME             LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION      LPWSTR - Description of the object
        AZ_PROP_APPLICATION_DATA LPWSTR - Opaque data stored by an application
        Any object specific properties.


Return Value:

    NO_ERROR - The operation was successful
    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    DWORD WinStatus;

    ULONG ObjectType;
    PGENERIC_OBJECT ReferencedGenericObject = NULL;

    //
    // Grab the global lock
    //
    AzpLockResourceExclusive( &AzGlResource );


    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "ObCommonSetProperty: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Determine the type of the object
    //

    WinStatus = ObGetHandleType( GenericObject,
                                 FALSE,   // Don't allow deleted objects
                                 &ObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( GenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           TRUE,    // Refresh the cache
                                           ObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedGenericObject = GenericObject;

    WinStatus = ObSetProperty(
                    GenericObject,
                    0,      // No flags
                    PropertyId,
                    PropertyValue);
    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Ensure the object was marked as needing to be written
    //

    ASSERT( (GenericObject->DirtyBits & ~AzGlObjectAllDirtyBits[ObjectType]) == 0);



    //
    // Return the value to the caller
    //
    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedGenericObject != NULL ) {
        ObDereferenceObject( ReferencedGenericObject );
    }

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;

}

VOID
ObMarkObjectDeletedEx(
    IN PGENERIC_OBJECT GenericObject,
    IN BOOLEAN DoingChild
    )
/*++

Routine Description

    Mark this object and all child objects as deleted.

    On entry, AzGlResource must be locked exclusive.

Arguments

    GenericObject - Specifies the object to mark

    DoingChild - True if this is a recursive call

Return Value

    None

--*/
{
    PGENERIC_OBJECT_HEAD ChildGenericObjectHead;

    PGENERIC_OBJECT ChildGenericObject;
    PLIST_ENTRY ListEntry;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Only mark the object if it is not already marked
    //

    if ( (GenericObject->Flags & GENOBJ_FLAGS_DELETED) == 0 ) {
        //
        // Mark the entry as deleted
        //

        GenericObject->Flags |= GENOBJ_FLAGS_DELETED;

        //
        // Delete all children of this object
        //
        //  Loop for each type of child object
        //

        for ( ChildGenericObjectHead = GenericObject->ChildGenericObjectHead;
              ChildGenericObjectHead != NULL;
              ChildGenericObjectHead = ChildGenericObjectHead->SiblingGenericObjectHead ) {

            //
            // Loop for each child object
            //

            for ( ListEntry = ChildGenericObjectHead->Head.Flink ;
                  ListEntry != &ChildGenericObjectHead->Head ;
                  ListEntry = ListEntry->Flink) {

                ChildGenericObject = CONTAINING_RECORD( ListEntry,
                                                        GENERIC_OBJECT,
                                                        Next );

                //
                // Mark that object
                //

                ObMarkObjectDeletedEx( ChildGenericObject, TRUE );

            }
        }

        //
        // Delete all references to/from this object
        //

        ObRemoveObjectListLinks( GenericObject );

        //
        // The object actually being deleted is delinked from its parent.
        //  That ensures it goes away when the last reference goes away
        //
        if ( !DoingChild ) {
            ObDereferenceObject( GenericObject );
        }
    }

}

VOID
ObMarkObjectDeleted(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description

    Mark this object and all child objects as deleted.

    On entry, AzGlResource must be locked exclusive.

Arguments

    GenericObject - Specifies the object to mark

Return Value

    None

--*/
{

    ObMarkObjectDeletedEx( GenericObject, FALSE );

}


DWORD
ObCommonDeleteObject(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN ULONG ParentObjectType,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN ULONG ChildObjectType,
    IN LPCWSTR ChildObjectName,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This routine deletes a child object from the scope of the specified parent object.

Arguments:

    ParentGenericObject - Specifies a handle to the parent object to delete the child
        object from.  This "handle" has been passed from the application and needs to
        be verified.

    ParentObjectType - Specifies the object type ParentGenericObject.

    GenericChildHead - Specifies a pointer to the head of the list of children of
        ParentGenericObject.  This is a computed pointer and is considered untrustworthy
        until ParentGenericObject has been verified.

    ChildObjectType - Specifies the object type RetChildGenericObject.

    ChildObjectName - Specifies the name of the child object.
        This name is passed from the application and needs to be verified.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - An object by that name cannot be found

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedParentObject = NULL;
    PGENERIC_OBJECT ChildGenericObject = NULL;

    AZP_STRING ChildObjectNameString;


    //
    // Initialization
    //

    AzpInitString( &ChildObjectNameString, NULL );
    ASSERT( ParentObjectType != OBJECT_TYPE_ROOT );
    ASSERT( ChildObjectType != OBJECT_TYPE_AZAUTHSTORE );

    //
    // Grab the global lock
    //

    AzpLockResourceExclusive( &AzGlResource );

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "ObCommonDeleteObject: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( ParentGenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           FALSE,   // No need to refresh the cache on a delete
                                           ParentObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedParentObject = ParentGenericObject;

   //
    // If the parent has not been loaded, then load the parent first
    //

    if ( !(ReferencedParentObject->AreChildrenLoaded) ) {

        WinStatus = AzPersistUpdateChildrenCache(
            ReferencedParentObject
            );

        if ( WinStatus != NO_ERROR ) {

            goto Cleanup;
        }
    }

    //
    // Capture the object name string from the caller
    //

    WinStatus = AzpCaptureString( &ChildObjectNameString,
                                  ChildObjectName,
                                  MaxObjectNameLength[ChildObjectType],
                                  FALSE );  // NULL names not OK

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Find the object to delete.
    //

    WinStatus = ObReferenceObjectByName( GenericChildHead,
                                         &ChildObjectNameString,
                                         0,     // No special flags
                                         &ChildGenericObject );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Actually, delete the object
    //

    WinStatus = AzPersistSubmit( ChildGenericObject, TRUE );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Mark the entry (and its child objects) as deleted
    //  We do this since other threads may have references to the objects.
    //  We want to ensure those threads know the objects are deleted.
    //

    ObMarkObjectDeleted( ChildGenericObject );



    //
    // Return to the caller
    //

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedParentObject != NULL ) {
        ObDereferenceObject( ReferencedParentObject );
    }

    if ( ChildGenericObject != NULL ) {
        ObDereferenceObject( ChildGenericObject );
    }

    AzpFreeString( &ChildObjectNameString );

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}

LONG
AzpCompareDeltaEntries(
    const void *DeltaEntry1,
    const void *DeltaEntry2
    )
/*++

Routine description:

    Compare two AZP_DELTA_ENTRYs

Arguments:

    DeltaEntry1 - First entry to compare

    DeltaEntry2 - Second entry to compare

Returns:

    CSTR_LESS_THAN: Entry 1 is less than entry 2
    CSTR_EQUAL: Entry 1 is equal to entry 2
    CSTR_GREATER_THAN: Entry 1 is greater than entry 2

--*/
{
    LONG Result;
    PAZP_DELTA_ENTRY Delta1 = (PAZP_DELTA_ENTRY)DeltaEntry1;
    PAZP_DELTA_ENTRY Delta2 = (PAZP_DELTA_ENTRY)DeltaEntry2;

    //
    // If these entries are SIDs,
    //  compare them
    //
    if ( Delta1->DeltaFlags & AZP_DELTA_SID ) {
        ASSERT( Delta2->DeltaFlags & AZP_DELTA_SID );

        Result = AzpCompareSid( Delta1->Sid, Delta2->Sid );

    //
    // If these entries are GUIDs,
    //  compare them
    //
    } else {
        GUID *Guid1 = &Delta1->Guid;
        GUID *Guid2 = &Delta2->Guid;

        ULONG i;

        ASSERT( (Delta2->DeltaFlags & AZP_DELTA_SID) == 0 );

        //
        // Compare the individual bytes
        //

        Result = CSTR_EQUAL;

        for ( i = 0; i < (sizeof(GUID)/4); i++ ) {

            const ULONG& b1 = ((PULONG)(Guid1))[i];
            const ULONG& b2 = ((PULONG)(Guid2))[i];

            if ( b1 == b2 ) {

                continue;

            } else if ( b1 < b2 ) {

                Result = CSTR_LESS_THAN;

            } else {

                Result = CSTR_GREATER_THAN;
            }

            break;
        }
    }

    return Result;
}

BOOLEAN
ObLookupDelta(
    IN ULONG DeltaFlags,
    IN GUID *Guid,
    IN PAZP_PTR_ARRAY AzpPtrArray,
    OUT PULONG InsertionPoint OPTIONAL
    )
/*++

Routine Description:

    This routine determines if a delta is already in the delta array

    On entry, AzGlResource must be locked share

Arguments:

    DeltaFlags - Specifies flags describing the delta.  This is a set of the
        AZP_DELTA_* flags.

    Guid - Specifies the GUID to lookup ino the array
        If AZP_DELTA_SID is specified, this field is a pointer to a AZP_STRING
            structure describing a SID.

    AzpPtrArray - Specifies the array to lookup the delta in.

    InsertionPoint - On FALSE, returns the point where one would insert the named object.
        On TRUE, returns an index to the object.

Return Value:

    TRUE - Object was found
    FALSE - Object was not found

--*/
{
    AZP_DELTA_ENTRY DeltaEntryTemplate;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    //
    // Determine if the GUID is already in the array.
    //

    DeltaEntryTemplate.DeltaFlags = DeltaFlags;
    if ( DeltaFlags & AZP_DELTA_SID ) {

        DeltaEntryTemplate.Sid = (PSID)(((PAZP_STRING)Guid)->String);
        ASSERT( RtlValidSid( DeltaEntryTemplate.Sid ));
    } else {
        DeltaEntryTemplate.Guid = *Guid;
        ASSERT( !IsEqualGUID( DeltaEntryTemplate.Guid, AzGlZeroGuid));
    }

    return AzpBsearchPtr( AzpPtrArray,
                          &DeltaEntryTemplate,
                          AzpCompareDeltaEntries,
                          InsertionPoint );

}

DWORD
ObAddDeltaToArray(
    IN ULONG DeltaFlags,
    IN GUID *Guid,
    IN PAZP_PTR_ARRAY AzpPtrArray,
    IN BOOLEAN DiscardDeletes
    )
/*++

Routine Description:

    Adds a delta to an array of deltas.

    If the delta is already in the list, the DeltaFlags of the current entry are
    updated.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    DeltaFlags - Specifies flags describing the delta.  This is a set of the
        AZP_DELTA_* flags.

    Guid - Specifies the GUID to add to the array
        If AZP_DELTA_SID is specified, this field is a pointer to a AZP_STRING
            structure describing a SID.

    AzpPtrArray - Specifies the array to add the GUID to.

    DiscardDeletes - TRUE if a Deletion entry should delete the corresponding entry
        and not add the deletion entry to the AzpPtrArray

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to extend the array.

--*/
{
    DWORD WinStatus;
    ULONG InsertionPoint;

    PAZP_DELTA_ENTRY DeltaEntry = NULL;
    ULONG SidSize;
    BOOLEAN DiscardMe;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    DiscardMe = DiscardDeletes && (DeltaFlags & AZP_DELTA_ADD) == 0 ;

    //
    // Determine if the GUID is already in the array.
    //

    if ( ObLookupDelta( DeltaFlags,
                        Guid,
                        AzpPtrArray,
                        &InsertionPoint ) ) {

        PULONG OldDeltaFlags = &((PAZP_DELTA_ENTRY)(AzpPtrArray->Array[InsertionPoint]))->DeltaFlags;
        //
        // Found it
        //
        // If the entry being added is from the persistence provider,
        //  don't overwrite the existing entry.
        //  The one added by the application is more applicable.
        //

        if ( DeltaFlags & AZP_DELTA_PERSIST_PROVIDER ) {

            // This assert is over active.  The provider certainly shouldn't add the same link
            //  twice.  But we can simply ignore the second entry.
            //ASSERT( (*OldDeltaFlags & AZP_DELTA_PERSIST_PROVIDER) == 0 );


        //
        // If we are to discard the entry,
        //  free the allocated memory and its slot in the array.
        //

        } else if ( DiscardMe ) {

            // Free the memory
            AzpFreeHeap( (PAZP_DELTA_ENTRY)(AzpPtrArray->Array[InsertionPoint]) );

            // Free the slot in the array
            AzpRemovePtrByIndex( AzpPtrArray, InsertionPoint );

        //
        // If the entry being added is from the app,
        //  simply overwrite the previous entry.
        //

        } else {
            ASSERT( (*OldDeltaFlags & AZP_DELTA_PERSIST_PROVIDER) == 0 );
            *OldDeltaFlags = DeltaFlags;
        }

        return NO_ERROR;
    }

    //
    // If we are to discard this entry,
    //  we're done.
    //

    if ( DiscardMe ) {
        WinStatus = NO_ERROR;
        goto Cleanup;
    }

    //
    // Allocate an entry to link into the array
    //

    if ( DeltaFlags & AZP_DELTA_SID ) {

        SidSize = ((PAZP_STRING)Guid)->StringSize;
    } else {
        ASSERT( !IsEqualGUID( *Guid, AzGlZeroGuid));
        SidSize = 0;
    }

    DeltaEntry = (PAZP_DELTA_ENTRY) AzpAllocateHeap( sizeof(*DeltaEntry) + SidSize, "GEDELTA" );

    if ( DeltaEntry == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    DeltaEntry->DeltaFlags = DeltaFlags;

    if ( DeltaFlags & AZP_DELTA_SID ) {
        DeltaEntry->Sid = (PSID)(&(DeltaEntry->Sid)+1);

        RtlCopyMemory( DeltaEntry->Sid,
                       ((PAZP_STRING)Guid)->String,
                       SidSize );

    } else {
        DeltaEntry->Guid = *Guid;
    }

    //
    // Insert the entry into the list
    //

    WinStatus = AzpAddPtr(
        AzpPtrArray,
        DeltaEntry,
        InsertionPoint );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    DeltaEntry = NULL;


    //
    // Free locally used resources
    //
Cleanup:

    if ( DeltaEntry != NULL ) {
        AzpFreeHeap( DeltaEntry );
    }

    return WinStatus;
}

VOID
ObFreeDeltaArray(
    IN PAZP_PTR_ARRAY DeltaArray,
    IN BOOLEAN FreeAllEntries
    )
/*++

Routine Description:

    Frees an array of deltas.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    DeltaArray - Pointer to the delta array to free

    FreeAllEntries - If TRUE all entries are freed.
        If FALSE, only persistence provider entries are freed.

Return Value:

    None

--*/
{
    LONG Index;
    PAZP_DELTA_ENTRY DeltaEntry;

    //
    // Initialization
    //

    AzPrint(( AZD_OBJLIST, "0x%lx: 0x%lx: %ld: ObFreeDeltaArray\n", DeltaArray, DeltaArray->Array, FreeAllEntries ));
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Free each entry in the delta array
    //  Walk the array from the top to avoid continually compacting the array
    //

    for ( Index=DeltaArray->UsedCount-1;
          Index>=0;
          Index-- ) {

        //
        // If all entries are to be removed,
        //  or the entry was added by the persist provider
        //  remove it
        //

        DeltaEntry = (PAZP_DELTA_ENTRY)DeltaArray->Array[Index];

        if ( FreeAllEntries ||
             (DeltaEntry->DeltaFlags & AZP_DELTA_PERSIST_PROVIDER) != 0 ) {

            // Free the memory
            AzpFreeHeap( DeltaEntry );

            // Free the slot in the array
            AzpRemovePtrByIndex( DeltaArray, Index );

        }


    }

    //
    // If the DeltaArray is now empty,
    //  delete the array itself
    //

    if ( DeltaArray->UsedCount == 0 && DeltaArray->Array != NULL ) {
        AzpFreeHeap( DeltaArray->Array );
        DeltaArray->Array = NULL;
        DeltaArray->AllocatedCount = 0;
    }

}


VOID
ObInitObjectList(
    IN OUT PGENERIC_OBJECT_LIST GenericObjectList,
    IN PGENERIC_OBJECT_LIST NextGenericObjectList OPTIONAL,
    IN BOOL IsBackLink,
    IN ULONG LinkPairId,
    IN ULONG DirtyBit,
    IN PGENERIC_OBJECT_HEAD GenericObjectHead0 OPTIONAL,
    IN PGENERIC_OBJECT_HEAD GenericObjectHead1 OPTIONAL,
    IN PGENERIC_OBJECT_HEAD GenericObjectHead2 OPTIONAL
    )
/*++

Routine Description

    Initialize a list of generic objects.

    The caller must call ObFreeObjectList after calling this routine.

Arguments

    GenericObjectList - Specifies the object list to initialize

    NextGenericObjectList - Specifies a pointer to the next GenericObjectList
        that is hosted in the same generic object as this one.

    IsBackLink - TRUE if the link is a backlink
        See GENERIC_OBJECT_LIST definition.

    LinkPairId - LinkPairId for this object list.
        See GENERIC_OBJECT_LIST definition.

    DirtyBit - Specifies the dirty bit that should be set when this object list is modified.
        Should be zero for back links.

    GenericObjectHeadN - Specifies a pointer to the head of the list of objects
        that are candidates for being pointed to by the object list.

        If this object list is maintained by an external API (and not a "back" list),
        then at least one GenericObjectHead must be specified.

        If this is a back link, all GenericObjectHeads must be NULL.

Return Value

    None

--*/
{

    //
    // Initialize most fields to zero
    //

    RtlZeroMemory( GenericObjectList, sizeof(*GenericObjectList) );

    //
    // Initialize the pointer to the next generic object list for this object
    //

    GenericObjectList->NextGenericObjectList = NextGenericObjectList;

    //
    // Initialize the link pair information
    //

    GenericObjectList->IsBackLink = IsBackLink;
    GenericObjectList->LinkPairId = LinkPairId;
    GenericObjectList->DirtyBit = DirtyBit;

    if ( IsBackLink ) {
        ASSERT( DirtyBit == 0 );
        ASSERT( GenericObjectHead0 == NULL );
        ASSERT( GenericObjectHead1 == NULL );
        ASSERT( GenericObjectHead2 == NULL );
    }

    //
    // Initialize the pointers to the object heads
    //

    GenericObjectList->GenericObjectHeads[0] = GenericObjectHead0;
    GenericObjectList->GenericObjectHeads[1] = GenericObjectHead1;
    GenericObjectList->GenericObjectHeads[2] = GenericObjectHead2;

    AzPrint(( AZD_OBJLIST, "0x%lx: 0x%lx: ObInitObjectList\n", &GenericObjectList->GenericObjects, GenericObjectList->GenericObjects.Array ));

}


//
// TABLE of mappings to backlink object list tables
//

struct {
    ULONG LinkFromObjectType;
    ULONG LinkToObjectType;
    BOOL IsBackLink;
    ULONG LinkPairId;
    ULONG ObjectListOffset;
} ObjectListOffsetTable[] = {
    { OBJECT_TYPE_TASK,           OBJECT_TYPE_OPERATION,      FALSE, 0,                        offsetof(_AZP_TASK, Operations) },
    { OBJECT_TYPE_OPERATION,      OBJECT_TYPE_TASK,           TRUE,  0,                        offsetof(_AZP_OPERATION, backTasks) },
    { OBJECT_TYPE_TASK,           OBJECT_TYPE_TASK,           FALSE, 0,                        offsetof(_AZP_TASK, Tasks) },
    { OBJECT_TYPE_TASK,           OBJECT_TYPE_TASK,           TRUE,  0,                        offsetof(_AZP_TASK, backTasks) },
    { OBJECT_TYPE_GROUP,          OBJECT_TYPE_GROUP,          FALSE, AZP_LINKPAIR_MEMBERS,     offsetof(_AZP_GROUP, AppMembers) },
    { OBJECT_TYPE_GROUP,          OBJECT_TYPE_GROUP,          TRUE,  AZP_LINKPAIR_MEMBERS,     offsetof(_AZP_GROUP, backAppMembers) },
    { OBJECT_TYPE_GROUP,          OBJECT_TYPE_GROUP,          FALSE, AZP_LINKPAIR_NON_MEMBERS, offsetof(_AZP_GROUP, AppNonMembers) },
    { OBJECT_TYPE_GROUP,          OBJECT_TYPE_GROUP,          TRUE,  AZP_LINKPAIR_NON_MEMBERS, offsetof(_AZP_GROUP, backAppNonMembers) },
    { OBJECT_TYPE_ROLE,           OBJECT_TYPE_GROUP,          FALSE, 0,                        offsetof(_AZP_ROLE, AppMembers) },
    { OBJECT_TYPE_GROUP,          OBJECT_TYPE_ROLE,           TRUE,  0,                        offsetof(_AZP_GROUP, backRoles) },
    { OBJECT_TYPE_ROLE,           OBJECT_TYPE_OPERATION,      FALSE, 0,                        offsetof(_AZP_ROLE, Operations) },
    { OBJECT_TYPE_OPERATION,      OBJECT_TYPE_ROLE,           TRUE,  0,                        offsetof(_AZP_OPERATION, backRoles) },
    { OBJECT_TYPE_ROLE,           OBJECT_TYPE_TASK,           FALSE, 0,                        offsetof(_AZP_ROLE, Tasks) },
    { OBJECT_TYPE_TASK,           OBJECT_TYPE_ROLE,           TRUE,  0,                        offsetof(_AZP_TASK, backRoles) },
    { OBJECT_TYPE_GROUP,          OBJECT_TYPE_SID,            FALSE, AZP_LINKPAIR_SID_MEMBERS, offsetof(_AZP_GROUP, SidMembers) },
    { OBJECT_TYPE_SID,            OBJECT_TYPE_GROUP,          TRUE,  AZP_LINKPAIR_SID_MEMBERS, offsetof(_AZP_SID, backGroupMembers) },
    { OBJECT_TYPE_GROUP,          OBJECT_TYPE_SID,            FALSE, AZP_LINKPAIR_SID_NON_MEMBERS, offsetof(_AZP_GROUP, SidNonMembers) },
    { OBJECT_TYPE_SID,            OBJECT_TYPE_GROUP,          TRUE,  AZP_LINKPAIR_SID_NON_MEMBERS, offsetof(_AZP_SID, backGroupNonMembers) },
    { OBJECT_TYPE_ROLE,           OBJECT_TYPE_SID,            FALSE, 0,                        offsetof(_AZP_ROLE, SidMembers) },
    { OBJECT_TYPE_SID,            OBJECT_TYPE_ROLE,           TRUE,  0,                        offsetof(_AZP_SID, backRoles) },
   { OBJECT_TYPE_AZAUTHSTORE,   OBJECT_TYPE_SID,            FALSE, AZP_LINKPAIR_POLICY_ADMINS,    offsetof(_GENERIC_OBJECT, PolicyAdmins) },
    { OBJECT_TYPE_SID,            OBJECT_TYPE_AZAUTHSTORE,  TRUE,  AZP_LINKPAIR_POLICY_ADMINS,    offsetof(_AZP_SID, backAdmins) },
    { OBJECT_TYPE_AZAUTHSTORE,  OBJECT_TYPE_SID,            FALSE, AZP_LINKPAIR_POLICY_READERS,   offsetof(_GENERIC_OBJECT, PolicyReaders) },
    { OBJECT_TYPE_SID,            OBJECT_TYPE_AZAUTHSTORE,  TRUE,  AZP_LINKPAIR_POLICY_READERS,   offsetof(_AZP_SID, backReaders) },
    { OBJECT_TYPE_APPLICATION,    OBJECT_TYPE_SID,            FALSE, AZP_LINKPAIR_POLICY_ADMINS,    offsetof(_GENERIC_OBJECT, PolicyAdmins) },
    { OBJECT_TYPE_SID,            OBJECT_TYPE_APPLICATION,    TRUE,  AZP_LINKPAIR_POLICY_ADMINS,    offsetof(_AZP_SID, backAdmins) },
    { OBJECT_TYPE_APPLICATION,    OBJECT_TYPE_SID,            FALSE, AZP_LINKPAIR_POLICY_READERS,   offsetof(_GENERIC_OBJECT, PolicyReaders) },
    { OBJECT_TYPE_SID,            OBJECT_TYPE_APPLICATION,    TRUE,  AZP_LINKPAIR_POLICY_READERS,   offsetof(_AZP_SID, backReaders) },
    { OBJECT_TYPE_SCOPE,          OBJECT_TYPE_SID,            FALSE, AZP_LINKPAIR_POLICY_ADMINS,    offsetof(_GENERIC_OBJECT, PolicyAdmins) },
    { OBJECT_TYPE_SID,            OBJECT_TYPE_SCOPE,          TRUE,  AZP_LINKPAIR_POLICY_ADMINS,    offsetof(_AZP_SID, backAdmins) },
    { OBJECT_TYPE_SCOPE,          OBJECT_TYPE_SID,            FALSE, AZP_LINKPAIR_POLICY_READERS,   offsetof(_GENERIC_OBJECT, PolicyReaders) },
    { OBJECT_TYPE_SID,            OBJECT_TYPE_SCOPE,          TRUE,  AZP_LINKPAIR_POLICY_READERS,   offsetof(_AZP_SID, backReaders) },
    { OBJECT_TYPE_AZAUTHSTORE,  OBJECT_TYPE_SID,            FALSE, AZP_LINKPAIR_DELEGATED_POLICY_USERS, offsetof(_GENERIC_OBJECT, DelegatedPolicyUsers) },
    {OBJECT_TYPE_SID,             OBJECT_TYPE_AZAUTHSTORE,  TRUE,  AZP_LINKPAIR_DELEGATED_POLICY_USERS, offsetof(_AZP_SID, backDelegatedPolicyUsers) },
    { OBJECT_TYPE_APPLICATION,  OBJECT_TYPE_SID,              FALSE, AZP_LINKPAIR_DELEGATED_POLICY_USERS, offsetof(_GENERIC_OBJECT, DelegatedPolicyUsers) },
    {OBJECT_TYPE_SID,             OBJECT_TYPE_APPLICATION,    TRUE,  AZP_LINKPAIR_DELEGATED_POLICY_USERS, offsetof(_AZP_SID, backDelegatedPolicyUsers) },
};


PGENERIC_OBJECT_LIST
ObGetObjectListPtr(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG LinkToObjectType,
    IN PGENERIC_OBJECT_LIST LinkToGenericObjectList
    )
/*++

Routine Description

    Returns a pointer to a GENERIC_OBJECT_LIST structure within the passed in
    GenericObject that is suitable for linking an object of type LinkToObjectType
    into.

Arguments

    GenericObject - Specifies the object the link is from.

    LinkToObjectType - Specifies the object type the link is to.

    LinkToGenericObjectList - Specifies a pointer to the generic object list
        structure that is within the LinkToGenericObject.

Return Value

    Returns a pointer to the generic object list.

--*/
{
    PGENERIC_OBJECT_LIST GenericObjectList = NULL;
    ULONG i;


    //
    // Compute the address of the generic address list the object is in.
    //      We could do this more generically, but that would scatter this data
    //      over too wide an array.
    //

    for ( i=0; i<sizeof(ObjectListOffsetTable)/sizeof(ObjectListOffsetTable[0]); i++ ) {

        //
        // Find the entry in the table that matches our situation
        //

        if ( GenericObject->ObjectType == ObjectListOffsetTable[i].LinkFromObjectType &&
             LinkToObjectType == ObjectListOffsetTable[i].LinkToObjectType &&
             LinkToGenericObjectList->IsBackLink != ObjectListOffsetTable[i].IsBackLink &&
             LinkToGenericObjectList->LinkPairId == ObjectListOffsetTable[i].LinkPairId ) {

            GenericObjectList = (PGENERIC_OBJECT_LIST)
                (((LPBYTE)GenericObject)+(ObjectListOffsetTable[i].ObjectListOffset));
        }
    }

    ASSERT( GenericObjectList != NULL );

    return GenericObjectList;

}


VOID
ObRemoveObjectListLink(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN ULONG Index
    )
/*++

Routine Description

    Remove the links between generic objects in both directions

    On entry, AzGlResource must be locked exclusive.

Arguments

    GenericObject - Specifies an object the link is from

    GenericObjectList - Specifies a pointer to the generic object list
        structure that is within the GenericObject.

    Index - Specifies the index within GenericObjectList that is to be removed.

Return Value

    None

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT OtherGenericObject;
    PGENERIC_OBJECT_LIST OtherGenericObjectList;
    ULONG OtherIndex;
    BOOL  fRemoveByPtr = FALSE;


    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Grab a pointer to the linked-to object
    //

    OtherGenericObject = (PGENERIC_OBJECT)
            (GenericObjectList->GenericObjects.Array[Index]);

    //
    // Remove that pointer from our array
    //

    AzpRemovePtrByIndex( &GenericObjectList->GenericObjects,
                         Index );


    //
    // Get a pointer to the object list that our entry is in
    //

    OtherGenericObjectList = ObGetObjectListPtr( OtherGenericObject,
                                                 GenericObject->ObjectType,
                                                 GenericObjectList );

    ASSERT( OtherGenericObjectList != NULL );

    if (NULL != GenericObject->ObjectName &&
        !OtherGenericObjectList->IsBackLink)
    {
        //
        // Lookup our name in the object list that our entry is in
        // Back links are not maintained in order since names are not unique
        //

        WinStatus = ObLookupPropertyItem( OtherGenericObjectList,
                                      &GenericObject->ObjectName->ObjectName,
                                      &OtherIndex );

        //
        // If found,
        //  remove it quickly
        //

        if ( WinStatus == ERROR_ALREADY_EXISTS ) {

            AzpRemovePtrByIndex( &OtherGenericObjectList->GenericObjects, OtherIndex );

        } else {
            //
            // In all other cases
            //
            fRemoveByPtr = TRUE;
        }
    } else {
        // either back link or AzAuthStore object
        // all objects have name except AzAuthStore
        fRemoveByPtr = TRUE;
    }

    if (fRemoveByPtr) {
        AzpRemovePtrByPtr( &OtherGenericObjectList->GenericObjects, GenericObject );
    }

    //
    // Mark that the operation caches need flushing
    //  ... any change to the object cache invalidates the cache
    //

    GenericObject->AzStoreObject->OpCacheSerialNumber ++;

    AzPrint(( AZD_ACCESS_MORE, "ObRemoveObjectListLink: OpCacheSerialNumber set to %ld\n",
              GenericObject->AzStoreObject->OpCacheSerialNumber ));
}

LONG
AzpCompareGenericObjectEntries(
    const void *Object1,
    const void *Object2
    )
/*++

Routine description:

    Compare names of two GENERIC_OBJECTS

Arguments:

    Object1 - First entry to compare

    Object2 - Second entry to compare

Returns:

    CSTR_LESS_THAN: Entry 1 is less than entry 2
    CSTR_EQUAL: Entry 1 is equal to entry 2
    CSTR_GREATER_THAN: Entry 1 is greater than entry 2

--*/
{
    LONG Result;
    PGENERIC_OBJECT GenericObject1 = (PGENERIC_OBJECT) Object1;
    PGENERIC_OBJECT GenericObject2 = (PGENERIC_OBJECT) Object2;

    //
    // Compare the names
    //

    ASSERT( GenericObject1->ObjectName != NULL );
    ASSERT( GenericObject2->ObjectName != NULL );


    Result = AzpCompareStrings(
                &GenericObject1->ObjectName->ObjectName,
                &GenericObject2->ObjectName->ObjectName );

#if 0
    AzPrint(( AZD_CRITICAL, "Compare: '%ws' '%ws' %ld\n",
              GenericObject1->ObjectName->ObjectName.String,
              GenericObject2->ObjectName->ObjectName.String,
              Result ));
#endif // 0

    return Result;
}

DWORD
ObLookupPropertyItem(
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PAZP_STRING ObjectName,
    OUT PULONG InsertionPoint OPTIONAL
    )
/*++

Routine Description:

    This routine determins if the specified object name is already in the
    object list.

    On entry, AzGlResource must be locked share

Arguments:

    GenericObjectList - Specifies the object list to be searched

    ObjectName - Specifies the ObjectName to lookup

    InsertionPoint - On ERROR_NOT_FOUND, returns the point where one would insert the named
        object.  On ERROR_ALREADY_EXISTS, returns an index to the object.

Return Value:

    ERROR_ALREADY_EXISTS - An object by that name already exists in the list

    ERROR_NOT_FOUND - There is no object by that name

    Misc other failure statuses.

--*/
{
    GENERIC_OBJECT GenericObjectTemplate;
    GENERIC_OBJECT_NAME GenericObjectName;

    //  Back links are not maintained in order since names are not unique
    ASSERT( !GenericObjectList->IsBackLink );

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );
    // AzPrint(( AZD_CRITICAL, "Lookup: 0x%lx %ws\n", GenericObjectList, ObjectName->String ));

    //
    // Build a template of the object to search for
    //

    GenericObjectTemplate.ObjectName = &GenericObjectName;
    GenericObjectName.ObjectName = *ObjectName;

    //
    // Find the object in the array
    //

    if ( AzpBsearchPtr(
            &GenericObjectList->GenericObjects,
            &GenericObjectTemplate,
            AzpCompareGenericObjectEntries,
            InsertionPoint ) ) {

        // AzPrint(( AZD_CRITICAL, "Lookup: 0x%lx %ws found %ld\n", GenericObjectList, ObjectName->String, *InsertionPoint ));
        return ERROR_ALREADY_EXISTS;

    }

    // AzPrint(( AZD_CRITICAL, "Lookup: 0x%lx %ws not found %ld\n", GenericObjectList, ObjectName->String, *InsertionPoint ));
    return ERROR_NOT_FOUND;
}



DWORD
ObAddPropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN ULONG Flags,
    IN PAZP_STRING ObjectName
    )
/*++

Routine Description:

    Adds an object to the list of objects specified by GenericObjectList.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies a pointer to the object the link is from

    Flags - Specifies internal flags
        AZP_FLAGS_BY_GUID - ObjectName is a pointer to a GUID
        AZP_FLAGS_PERSIST_* - Call is from the persistence provider
        AZP_FLAGS_RECONCILE - Call is from AzpPersistReconcile

    GenericObjectList - Specifies the object list to add the object into.

    ObjectName - Specifies a pointer to name of the object to add.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_FOUND - There is no object by that name

    ERROR_ALREADY_EXISTS - An object by that name already exists in the list

--*/
{
    DWORD WinStatus;
    ULONG InsertionPoint;
    ULONG BackInsertionPoint;
    ULONG ObjectTypeIndex;

    PGENERIC_OBJECT FoundGenericObject = NULL;
    PGENERIC_OBJECT_LIST BackGenericObjectList;
    ULONG DeltaFlags = AZP_DELTA_ADD;
    GUID *DeltaGuid;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    if (IsNormalFlags(Flags) &&
        GenericObject->IsWritable == 0 &&
        GenericObject->ObjectType != OBJECT_TYPE_CLIENT_CONTEXT)
    {
        WinStatus = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // first things first, let's check if the AzAuthStore's versions support writing
    //

    if ( IsNormalFlags(Flags) &&
         !AzpAzStoreVersionAllowWrite(GenericObject->AzStoreObject) )
    {
        WinStatus = ERROR_REVISION_MISMATCH;
        goto Cleanup;
    }

    //
    // If this is the provider calling,
    //  we can't be guaranteed that the linked-to object exists.
    //  So just remember the GUID (or Sid) for now
    //

    if ( Flags & AZPE_FLAGS_PERSIST_MASK ) {

        // Delta is from the persist provider
        DeltaFlags |= AZP_DELTA_PERSIST_PROVIDER;

        // Link is to a SID
        if ( (Flags & AZP_FLAGS_BY_GUID) == 0 ) {
            DeltaFlags |= AZP_DELTA_SID;
            ASSERT( AzpIsSidList( GenericObjectList ) );
            if ( !AzpIsSidList( GenericObjectList ) ) {
                WinStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        } else {
            ASSERT( !AzpIsSidList( GenericObjectList ) );
            if ( AzpIsSidList( GenericObjectList ) ) {
                WinStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            AzPrint(( AZD_REF, "ObAddPropertyItem (by guid): " ));
            AzpDumpGuid( AZD_REF, (GUID *)ObjectName );
            AzPrint(( AZD_REF, "\n" ));
        }

        //
        // Just remember the delta
        //

        WinStatus = ObAddDeltaToArray(
                        DeltaFlags,
                        (GUID *)ObjectName,
                        &GenericObjectList->DeltaArray,
                        FALSE ); // Allow deletion entries in the array

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        //
        // Remember that the provider changed the attribute
        //

        ASSERT( AzpIsCritsectLocked( &GenericObject->AzStoreObject->PersistCritSect ) );
        ASSERT( (GenericObject->Flags & GENOBJ_FLAGS_PERSIST_OK) == 0 );
        GenericObject->PersistDirtyBits |= GenericObjectList->DirtyBit;


    //
    // If this is the app calling or AzpPersistReconcile calling,
    //  we know the linked-to object should exist.
    //

    } else {

        //
        // Don't allow creator/owner on any sid list.
        //  The sids only apply to inheritable ACEs.
        //  On the readers/admins/delegators lists, it ends up getting morphed.
        //  So simply disallow to prevent confusion.
        //

        if ( IsNormalFlags(Flags) && AzpIsSidList( GenericObjectList ) ) {
            PSID Sid = (PSID) ObjectName->String;
            ASSERT( ObjectName->IsSid );

            if ( RtlEqualSid( Sid, AzGlCreatorOwnerSid )) {
                WinStatus = ERROR_INVALID_PARAMETER;
                AzPrint(( AZD_INVPARM, "ObAddPropertyItem: Cannot set creator owner sid\n" ));
                goto Cleanup;
            }

            if ( RtlEqualSid( Sid, AzGlCreatorGroupSid )) {
                WinStatus = ERROR_INVALID_PARAMETER;
                AzPrint(( AZD_INVPARM, "ObAddPropertyItem: Cannot set creator group sid\n" ));
                goto Cleanup;
            }
        }

        //
        // Loop through the various lists of objects that can be referenced
        //

        for ( ObjectTypeIndex=0; ObjectTypeIndex<GEN_OBJECT_HEAD_COUNT; ObjectTypeIndex++ ) {

            //
            // Stop when there are no more lists to search
            //

            if ( GenericObjectList->GenericObjectHeads[ObjectTypeIndex] == NULL ) {
                break;
            }

            //
            // Find the specified object in this list
            //

            WinStatus = ObReferenceObjectByName(
                                GenericObjectList->GenericObjectHeads[ObjectTypeIndex],
                                ObjectName,
                                Flags,
                                &FoundGenericObject );

            if ( WinStatus == NO_ERROR ) {
                break;
            }

            //
            // If this is a link to a SID object,
            //  create the SID object.
            //
            // AzpSids are pseudo objects that come into existence as they are needed.
            //

            if ( AzpIsSidList( GenericObjectList ) ) {

                ASSERT( ObjectTypeIndex == 0 ); // There is only one list of sids
                WinStatus = ObCreateObject(
                            GenericObjectList->GenericObjectHeads[0]->ParentGenericObject,
                            GenericObjectList->GenericObjectHeads[0],
                            OBJECT_TYPE_SID,
                            ObjectName,
                            NULL,   // Guid not known
                            Flags,  // Flags from our caller
                            &FoundGenericObject );


                if ( WinStatus != NO_ERROR ) {
                    goto Cleanup;
                }

            }

        }

        //
        // If none of the lists had an object by the requested name,
        //  or the found object has *never* been submited,
        //  complain.
        //

        if ( FoundGenericObject == NULL ||
             (FoundGenericObject->DirtyBits & AZ_DIRTY_CREATE) != 0 ) {
            WinStatus = ERROR_NOT_FOUND;
            goto Cleanup;
        }


        //
        // Prevent a reference to ourself
        //

        if ( GenericObject == FoundGenericObject ) {
            AzPrint(( AZD_INVPARM, "Reference to self\n" ));
            WinStatus = ERROR_DS_LOOP_DETECT;
            goto Cleanup;
        }

        //
        // Call the object specific routine to validate the request
        //

        if ( ObjectAddPropertyItemRoutine[GenericObject->ObjectType] != NULL ) {

            WinStatus = ObjectAddPropertyItemRoutine[GenericObject->ObjectType](
                        GenericObject,
                        GenericObjectList,
                        FoundGenericObject );

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

        }



        //
        // Find the insertion point for this name.
        //

        WinStatus = ObLookupPropertyItem( GenericObjectList,
                                          &FoundGenericObject->ObjectName->ObjectName,
                                          &InsertionPoint );

        if ( WinStatus != ERROR_NOT_FOUND ) {
            goto Cleanup;
        }

        //
        // Insert the generic object into the list
        //

        WinStatus = AzpAddPtr(
            &GenericObjectList->GenericObjects,
            FoundGenericObject,
            InsertionPoint );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        //
        // Get a pointer to the backlink object list
        //

        BackGenericObjectList = ObGetObjectListPtr( FoundGenericObject,
                                                    GenericObject->ObjectType,
                                                    GenericObjectList );

        ASSERT( BackGenericObjectList != NULL );

        //
        // Maintain a back link from the generic object we just linked to back
        //  to this object.
        //
        // Back links are not maintained in order since names are not unique
        //

        BackInsertionPoint = BackGenericObjectList->GenericObjects.UsedCount;

        WinStatus = AzpAddPtr(
            &BackGenericObjectList->GenericObjects,
            GenericObject,
            BackInsertionPoint );

        if ( WinStatus != NO_ERROR ) {
            // Undo the forward link
            AzpRemovePtrByIndex( &GenericObjectList->GenericObjects, InsertionPoint );
            goto Cleanup;
        }

        //
        // Let the persist provider know of the change
        //

        if ( IsNormalFlags(Flags) ) {
            if ( AzpIsSidList( GenericObjectList ) ) {
                DeltaGuid = (GUID *)ObjectName;
                DeltaFlags |= AZP_DELTA_SID;
            } else {
                DeltaGuid = &FoundGenericObject->PersistenceGuid;
            }

            WinStatus = ObAddDeltaToArray(
                            DeltaFlags,
                            DeltaGuid,
                            &GenericObjectList->DeltaArray,
                            FALSE ); // Allow deletion entries in the array

            if ( WinStatus != NO_ERROR ) {
                // Undo the forward link
                AzpRemovePtrByIndex( &GenericObjectList->GenericObjects, InsertionPoint );
                // Undo the back link
                AzpRemovePtrByIndex( &BackGenericObjectList->GenericObjects, BackInsertionPoint );
                goto Cleanup;
            }
        }


        //
        // Mark that the group membership caches need flushing
        //

        if ( GenericObject->ObjectType == OBJECT_TYPE_GROUP ) {
            GenericObject->AzStoreObject->GroupEvalSerialNumber ++;

            AzPrint(( AZD_ACCESS_MORE, "ObAddPropertyItem: GroupEvalSerialNumber set to %ld\n",
                      GenericObject->AzStoreObject->GroupEvalSerialNumber ));
        }

        //
        // Finally set the dirty bit
        //

        if ( IsNormalFlags(Flags) ) {
            GenericObject->DirtyBits |= GenericObjectList->DirtyBit;
        }

        //
        // Mark that the operation caches need flushing
        //  ... any change to the object cache invalidates the cache
        //

        GenericObject->AzStoreObject->OpCacheSerialNumber ++;

        AzPrint(( AZD_ACCESS_MORE, "ObAddPropertyItem: OpCacheSerialNumber set to %ld\n",
                  GenericObject->AzStoreObject->OpCacheSerialNumber ));


        //
        // Return to the caller
        //

        WinStatus = NO_ERROR;

    }


    //
    // Free locally used resources
    //
Cleanup:

    if ( FoundGenericObject != NULL ) {
        ObDereferenceObject( FoundGenericObject );
    }

    return WinStatus;
}

DWORD
WINAPI
AzAddPropertyItem(
    IN AZ_HANDLE AzHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Adds an item to the list of items specified by PropertyId.

Arguments:

    AzHandle - Specifies a handle to the object to add a property item for

    PropertyId - Specifies which property to modify

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to item to add.
        The specified value and type depends on PropertyId.


Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

    ERROR_NOT_FOUND - There is no object by that name

    ERROR_ALREADY_EXISTS - An item by that name already exists in the list

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT GenericObject = (PGENERIC_OBJECT) AzHandle;
    PGENERIC_OBJECT ReferencedObject = NULL;

    PGENERIC_OBJECT_LIST GenericObjectList;
    ULONG ObjectType;

    AZP_STRING ObjectNameString;



    //
    // Initialization
    //

    AzpInitString( &ObjectNameString, NULL );

    //
    // Grab the global lock
    //

    AzpLockResourceExclusive( &AzGlResource );

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "AzAddPropertyItem: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // if this is ACL related property items
    // quick check to see if it is valid
    // we really want this to happen early
    //

    if (AZ_PROP_POLICY_ADMINS == PropertyId ||
        AZ_PROP_POLICY_READERS == PropertyId)
    {

        WinStatus = CHECK_ACL_SUPPORT(GenericObject);

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

    } else if ( PropertyId == AZ_PROP_DELEGATED_POLICY_USERS ) {

        WinStatus = CHECK_DELEGATION_SUPPORT(GenericObject);

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }
    }

    //
    // Validate the Property ID
    //

    WinStatus = ObMapPropIdToObjectList(
                                (PGENERIC_OBJECT)AzHandle,
                                PropertyId,
                                &GenericObjectList,
                                &ObjectType );

    if ( WinStatus != NO_ERROR ) {
        AzPrint(( AZD_INVPARM, "AzAddPropertyItem: invalid prop id %ld\n", PropertyId ));
        return WinStatus;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( GenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           TRUE,    // Refresh the cache
                                           ObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedObject = GenericObject;


    //
    // if policy admins is to be modified for an scope object,
    // we need to check if it's allowed (w/ bizrules)
    //
    if ( PropertyId == AZ_PROP_POLICY_ADMINS &&
         ObjectType == OBJECT_TYPE_SCOPE ) {

        //
        // currently it's not delegated
        //
        WinStatus = AzpScopeCanBeDelegated(GenericObject, FALSE);

        if ( WinStatus != ERROR_SUCCESS ) {

            //
            // if scope cannot be delegated or some error occurs detecting the delegation,
            // do not allow changes to policy admins
            //
            goto Cleanup;
        }

    }

    //
    // Capture the object name string from the caller
    //

    if ( AzpIsSidList( GenericObjectList ) ) {
        WinStatus = AzpCaptureSid( &ObjectNameString,
                                   PropertyValue );
    } else {
        WinStatus = AzpCaptureString( &ObjectNameString,
                                      (LPWSTR)PropertyValue,
                                      AZ_MAX_NAME_LENGTH,   // Don't need to validate size exactly
                                      FALSE );  // NULL names not OK
    }

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Actually add the property item
    //

    WinStatus = ObAddPropertyItem( GenericObject,
                                   GenericObjectList,
                                   0,   // No flags
                                   &ObjectNameString );
    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Ensure the object was marked as needing to be written
    //

    ASSERT( GenericObject->DirtyBits != 0 );
    ASSERT( (GenericObject->DirtyBits & ~AzGlObjectAllDirtyBits[ObjectType]) == 0);

    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedObject != NULL ) {
        ObDereferenceObject( ReferencedObject );
    }

    AzpFreeString( &ObjectNameString );

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}


DWORD
ObRemovePropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PAZP_STRING ObjectName
    )
/*++

Routine Description:

    Removes a generic object from the list of items specified by GenericObjectList

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies the object the link is from.

    GenericObjectList - Specifies the obejct list to remote the object from.

    ObjectName - Specifies a pointer to the name of the object to remove.


Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_FOUND - There is no object by that name in the list

--*/
{
    DWORD WinStatus;

    ULONG InsertionPoint;
    ULONG DeltaFlags = 0;
    GUID *DeltaGuid;


    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // first things first, let's check version support write
    //

    if ( !AzpAzStoreVersionAllowWrite(GenericObject->AzStoreObject) )
    {
        WinStatus = ERROR_REVISION_MISMATCH;
        goto Cleanup;
    }

    //
    // Lookup that name in the object list
    //

    WinStatus = ObLookupPropertyItem( GenericObjectList,
                                      ObjectName,
                                      &InsertionPoint );

    if ( WinStatus != ERROR_ALREADY_EXISTS ) {
        goto Cleanup;
    }

    //
    // Let the persist provider know of the change
    //

    if ( AzpIsSidList( GenericObjectList ) ) {
        DeltaGuid = (GUID *)ObjectName;
        DeltaFlags |= AZP_DELTA_SID;
    } else {
        DeltaGuid = &((PGENERIC_OBJECT)GenericObjectList->GenericObjects.Array[InsertionPoint])->PersistenceGuid;
    }

    WinStatus = ObAddDeltaToArray(
                    DeltaFlags,
                    DeltaGuid,
                    &GenericObjectList->DeltaArray,
                    FALSE ); // Allow deletion entries in the array

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Remove the links in both directions
    //

    ObRemoveObjectListLink( GenericObject, GenericObjectList, InsertionPoint );

    //
    // Mark that the group membership caches need flushing
    //

    if ( GenericObject->ObjectType == OBJECT_TYPE_GROUP ) {
        GenericObject->AzStoreObject->GroupEvalSerialNumber ++;

        AzPrint(( AZD_ACCESS_MORE, "ObRemovePropertyItem: GroupEvalSerialNumber set to %ld\n",
                  GenericObject->AzStoreObject->GroupEvalSerialNumber ));
    }

    //
    // Finally set the dirty bit
    //

    GenericObject->DirtyBits |= GenericObjectList->DirtyBit;

    WinStatus = NO_ERROR;



    //
    // Return to the caller
    //
Cleanup:
    return WinStatus;
}


DWORD
WINAPI
AzRemovePropertyItem(
    IN AZ_HANDLE AzHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Remove an item from the list of items specified by PropertyId.

Arguments:

    AzHandle - Specifies a handle to the object to add a property item for

    PropertyId - Specifies which property to modify

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to item to remove.
        The specified value and type depends on PropertyId.


Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

    ERROR_NOT_FOUND - There is no item by that name in the list

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT GenericObject = (PGENERIC_OBJECT) AzHandle;
    PGENERIC_OBJECT ReferencedObject = NULL;

    AZP_STRING ObjectNameString;

    PGENERIC_OBJECT_LIST GenericObjectList;
    ULONG ObjectType;


    //
    // Initialization
    //

    AzpInitString( &ObjectNameString, NULL );

    //
    // Grab the global lock
    //

    AzpLockResourceExclusive( &AzGlResource );

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "AzRemovePropertyItem: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Validate the Property ID
    //

    WinStatus = ObMapPropIdToObjectList(
                                GenericObject,
                                PropertyId,
                                &GenericObjectList,
                                &ObjectType );

    if ( WinStatus != NO_ERROR ) {
        AzPrint(( AZD_INVPARM, "AzRemovePropertyItem: invalid prop id %ld\n", PropertyId ));
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( GenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           TRUE,    // Refresh the cache
                                           ObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedObject = GenericObject;


    //
    // Capture the object name string from the caller
    //

    if ( AzpIsSidList( GenericObjectList ) ) {
        WinStatus = AzpCaptureSid( &ObjectNameString,
                                   PropertyValue );
    } else {
        WinStatus = AzpCaptureString( &ObjectNameString,
                                      (LPWSTR)PropertyValue,
                                      AZ_MAX_NAME_LENGTH,   // Don't need to validate size exactly
                                      FALSE );  // NULL names not OK
    }

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Remove the item from the list and backlist
    //

    WinStatus = ObRemovePropertyItem( GenericObject,
                                      GenericObjectList,
                                      &ObjectNameString );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Ensure the object was marked as needing to be written
    //

    ASSERT( GenericObject->DirtyBits != 0 );
    ASSERT( (GenericObject->DirtyBits & ~AzGlObjectAllDirtyBits[ObjectType]) == 0);


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedObject != NULL ) {
        ObDereferenceObject( ReferencedObject );
    }

    AzpFreeString( &ObjectNameString );

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}


PAZ_STRING_ARRAY
ObGetPropertyItems(
    IN PGENERIC_OBJECT_LIST GenericObjectList
    )
/*++

Routine Description:

    Return a list of generic object names as an array of object name strings.

    On entry, AzGlResource must be locked shared

Arguments:

    GenericObjectList - Specifies the object list to get the entries for.

Return Value:

    Returns the array of object name strings in a single allocated buffer.
        Free the buffer using AzFreeMemory.
    NULL - Not enough memory was available to allocate the string

--*/
{
    PAZP_PTR_ARRAY GenericObjects;
    ULONG i;

    ULONG Size;
    LPBYTE Where;

    PGENERIC_OBJECT GenericObject;

    PAZ_STRING_ARRAY StringArray;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );
    GenericObjects = &GenericObjectList->GenericObjects;


    //
    // Loop through the list of objects computing the size of the buffer to allocate
    //

    Size = 0;

    for ( i=0; i<GenericObjects->UsedCount; i++ ) {

        GenericObject = (PGENERIC_OBJECT) (GenericObjects->Array[i]);

        Size += GenericObject->ObjectName->ObjectName.StringSize;

    }

    //
    // Allocate a buffer to return to the caller
    //

    Size += sizeof(AZ_STRING_ARRAY) + (GenericObjects->UsedCount * sizeof(LPWSTR));

    StringArray = (PAZ_STRING_ARRAY) AzpAllocateHeap( Size, "GEGETITM" );

    if ( StringArray == NULL ) {
        return NULL;
    }

    StringArray->StringCount = GenericObjects->UsedCount;
    StringArray->Strings = (LPWSTR *)(StringArray+1);
    Where = (LPBYTE)(&StringArray->Strings[GenericObjects->UsedCount]);


    //
    // Loop through the list of objects copying the names into the return buffer
    //

    for ( i=0; i<GenericObjects->UsedCount; i++ ) {

        GenericObject = (PGENERIC_OBJECT) (GenericObjects->Array[i]);

        StringArray->Strings[i] = (LPWSTR) Where;

        RtlCopyMemory( Where,
                       GenericObject->ObjectName->ObjectName.String,
                       GenericObject->ObjectName->ObjectName.StringSize );

        Where += GenericObject->ObjectName->ObjectName.StringSize;

    }

    ASSERT( (ULONG)(Where - (LPBYTE)StringArray) == Size );

    return StringArray;

}

PAZ_GUID_ARRAY
ObGetPropertyItemGuids(
    IN PGENERIC_OBJECT_LIST GenericObjectList
    )
/*++

Routine Description:

    Return a list of generic object guids as an array of object guids

    On entry, AzGlResource must be locked shared

Arguments:

    GenericObjectList - Specifies the object list to get the entries for.

Return Value:

    Returns the array of object guids in a single allocated buffer.
        Free the buffer using AzFreeMemory.
    NULL - Not enough memory was available to allocate the string

--*/
{
    PAZP_PTR_ARRAY GenericObjects;
    ULONG i;

    ULONG Size;
    LPBYTE Where;

    PGENERIC_OBJECT GenericObject;

    PAZ_GUID_ARRAY GuidArray;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );
    GenericObjects = &GenericObjectList->GenericObjects;


    //
    // calculate the size of single buffer
    //

    Size = sizeof(AZ_GUID_ARRAY) +
           (GenericObjects->UsedCount * sizeof(GUID*)) +
           GenericObjects->UsedCount * sizeof(GUID);

    GuidArray = (PAZ_GUID_ARRAY) AzpAllocateHeap( Size, "GEGUIDAR" );

    if ( GuidArray == NULL ) {
        return NULL;
    }

    GuidArray->GuidCount = GenericObjects->UsedCount;
    GuidArray->Guids = (GUID **)(GuidArray+1);
    // point to memory location for guid data
    Where = (LPBYTE)(&GuidArray->Guids[GenericObjects->UsedCount]);

    //
    // Loop through the list of objects copying the guids into the return buffer
    //

    for ( i=0; i<GenericObjects->UsedCount; i++ ) {

        GenericObject = (PGENERIC_OBJECT) (GenericObjects->Array[i]);

        GuidArray->Guids[i] = (GUID*) Where;

        RtlCopyMemory( Where,
                       &GenericObject->PersistenceGuid,
                       sizeof(GUID) );

        Where += sizeof(GUID);

    }

    ASSERT( (ULONG)(Where - (LPBYTE)GuidArray) == Size );

    return GuidArray;

}


VOID
ObRemoveObjectListLinks(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description

    Remove any links to/from the specified object.

    On entry, AzGlResource must be locked exclusive.

Arguments

    GenericObject - Specifies the object to remove links to/from

Return Value

    None

--*/
{
    PGENERIC_OBJECT_LIST GenericObjectList;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Walk all of the GenericObjectLists rooted on by this object
    //
    // The GenericObjectList may be forward links or backward links.  We don't care.
    // All links must be removed.
    //

    for ( GenericObjectList = GenericObject->GenericObjectLists;
          GenericObjectList != NULL;
          GenericObjectList = GenericObjectList->NextGenericObjectList ) {


        AzPrint(( AZD_OBJLIST, "0x%lx: 0x%lx: %ld: ObRemoveObjectListLinks\n", &GenericObjectList->GenericObjects, GenericObjectList->GenericObjects.Array, GenericObjectList->GenericObjects.UsedCount ));

        //
        // Free the array itself
        //

        ObFreeObjectList( GenericObject, GenericObjectList );
    }

}

VOID
ObFreeObjectList(
    IN PGENERIC_OBJECT GenericObject,
    IN OUT PGENERIC_OBJECT_LIST GenericObjectList
    )
/*++

Routine Description:

    Free any memory pointed to by an array of object name strings.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies the obect containing GenericObjectList

    GenericObjectList - Specifies the object list to free.

Return Value:

    Returns the array of object name strings in a single allocated buffer.
        Free the buffer using AzFreeMemory.
    NULL - Not enough memory was available to allocate the string

--*/
{
    PAZP_PTR_ARRAY GenericObjects;
    ULONG Index;

    //
    // Initialization
    //

    AzPrint(( AZD_OBJLIST, "0x%lx: 0x%lx: ObFreeObjectList\n", &GenericObjectList->GenericObjects, GenericObjectList->GenericObjects.Array ));
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Walk the list of links to other objects removing the link and removing the corresponding
    //  pointer back.
    //

    GenericObjects = &GenericObjectList->GenericObjects;
    while ( GenericObjects->UsedCount != 0 ) {

        //
        // Remove the last entry in the list
        //

        Index = GenericObjects->UsedCount - 1;

        //
        // Remove the links in both directions
        //

        ObRemoveObjectListLink( GenericObject,
                                GenericObjectList,
                                Index );

    }

    //
    // Free the actual array
    //

    if ( GenericObjects->Array != NULL ) {
        AzPrint(( AZD_OBJLIST, "0x%lx: 0x%lx: Free array\n", GenericObjects, GenericObjects->Array ));
        AzpFreeHeap( GenericObjects->Array );
        GenericObjects->Array = NULL;
        GenericObjects->AllocatedCount = 0;

    }

    //
    // Free the delta array, too
    //

    ObFreeDeltaArray( &GenericObjectList->DeltaArray, TRUE );

}

DWORD
ObCheckNameConflict(
    IN PGENERIC_OBJECT_HEAD GenericObjectHead,
    IN PAZP_STRING ObjectNameString,
    IN ULONG ConflictListOffset,
    IN ULONG GrandchildListOffset,
    IN ULONG GrandChildConflictListOffset
    )
/*++

Routine Description:

    This routine checks to see if there is a name conflict between the name specified and
    the name of objects that are children of any of the objects in a list of objects.

    Optionally, this routine will recurse to check grandchildren.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObjectHead - Specifies the head of the list of objects that have children to be checked.

    ObjectNameString - Specifies the name of the object to check.

    ConflictListOffset - For each of the objects in GenericObjectHead, this is the offset to
        the GENERIC_OBJECT_HEAD structure containing the list of objects to check for name conflict.

    GrandchildListOffset - For each of the objects in GenericObjectHead, this is the offst to
        the GENERIC_OBJECT_HEAD structure containing the list of objects that contain grandchild
        objects to check.

    GrandChildConflictListOffset - For each of the objects in the list specified by GrandchildListOffset,
        this is the offset to the GENERIC_OBJECT_HEAD structure containing the list of objects to
        check for name conflict.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    DWORD WinStatus;
    PGENERIC_OBJECT GenericObject;
    PLIST_ENTRY ListEntry;

    PGENERIC_OBJECT ConflictGenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Loop through each object in the list
    //

    for ( ListEntry = GenericObjectHead->Head.Flink ;
          ListEntry != &GenericObjectHead->Head ;
          ListEntry = ListEntry->Flink) {

        GenericObject = CONTAINING_RECORD( ListEntry,
                                           GENERIC_OBJECT,
                                           Next );

        //
        // Ignore deleted objects
        //

        if ( GenericObject->Flags & GENOBJ_FLAGS_DELETED ) {
            continue;
        }

        //
        // Check all children to make sure there is no name conflict
        //

        WinStatus = ObReferenceObjectByName(
                        (PGENERIC_OBJECT_HEAD)( ((LPBYTE)GenericObject) + ConflictListOffset ),
                        ObjectNameString,
                        0,     // No special flags
                        &ConflictGenericObject );

        if ( WinStatus == NO_ERROR ) {
            ObDereferenceObject( ConflictGenericObject );
            return ERROR_ALREADY_EXISTS;
        }

        //
        // If we're to check grandchildren,
        //  do so now.
        //

        if ( GrandchildListOffset != 0 ) {

            WinStatus = ObCheckNameConflict(
                            (PGENERIC_OBJECT_HEAD)( ((LPBYTE)GenericObject) + GrandchildListOffset ),
                            ObjectNameString,
                            GrandChildConflictListOffset,
                            0,
                            0 );

            if ( WinStatus != NO_ERROR ) {
                return WinStatus;
            }
        }


    }

    return NO_ERROR;
}

DWORD
ObMapPropIdToObjectList(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    OUT PGENERIC_OBJECT_LIST *GenericObjectList,
    OUT PULONG ObjectType
    )
/*++

Routine Description:

    Map a property ID to the object type that it pertains to and the
    generic object list containing the linked to objects

Arguments:

    GenericObject - Specifies the object being linked from.
        This parameter is used only to compute GenericObjectList. It may simply be
        an unverified handle passed by the app.

    PropertyId - Specifies which property to map

    GenericObjectList - On success, returns the address of the generic object list
        within GenericObject to link the objects to.

    ObjectType - On success, returns the object type that PropertyId pertains to.


Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId doesn't correspond to a linked property

--*/
{
    // get object type
    __try {
        *ObjectType = GenericObject->ObjectType;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        return RtlNtStatusToDosError( GetExceptionCode());
    }

    //
    // Validate the Property ID
    //

    switch ( PropertyId ) {
    case AZ_PROP_GROUP_APP_MEMBERS:
        *GenericObjectList = &((PAZP_GROUP)GenericObject)->AppMembers;
        ASSERT(*ObjectType == OBJECT_TYPE_GROUP);
        break;
    case AZ_PROP_GROUP_APP_NON_MEMBERS:
        *GenericObjectList = &((PAZP_GROUP)GenericObject)->AppNonMembers;
        ASSERT(*ObjectType == OBJECT_TYPE_GROUP);
        break;
    case AZ_PROP_GROUP_MEMBERS:
        *GenericObjectList = &((PAZP_GROUP)GenericObject)->SidMembers;
        ASSERT(*ObjectType == OBJECT_TYPE_GROUP);
        break;
    case AZ_PROP_GROUP_NON_MEMBERS:
        *GenericObjectList = &((PAZP_GROUP)GenericObject)->SidNonMembers;
        ASSERT(*ObjectType == OBJECT_TYPE_GROUP);
        break;
    case AZ_PROP_TASK_OPERATIONS:
        *GenericObjectList = &((PAZP_TASK)GenericObject)->Operations;
        ASSERT(*ObjectType == OBJECT_TYPE_TASK);
        break;
    case AZ_PROP_TASK_TASKS:
        *GenericObjectList = &((PAZP_TASK)GenericObject)->Tasks;
        ASSERT(*ObjectType == OBJECT_TYPE_TASK);
        break;
    case AZ_PROP_ROLE_APP_MEMBERS:
        *GenericObjectList = &((PAZP_ROLE)GenericObject)->AppMembers;
        ASSERT(*ObjectType == OBJECT_TYPE_ROLE);
        break;
    case AZ_PROP_ROLE_MEMBERS:
        *GenericObjectList = &((PAZP_ROLE)GenericObject)->SidMembers;
        ASSERT(*ObjectType == OBJECT_TYPE_ROLE);
        break;
    case AZ_PROP_ROLE_OPERATIONS:
        *GenericObjectList = &((PAZP_ROLE)GenericObject)->Operations;
        ASSERT(*ObjectType == OBJECT_TYPE_ROLE);
        break;
    case AZ_PROP_ROLE_TASKS:
        *GenericObjectList = &((PAZP_ROLE)GenericObject)->Tasks;
        ASSERT(*ObjectType == OBJECT_TYPE_ROLE);
        break;

    case AZ_PROP_POLICY_ADMINS:
        *GenericObjectList = &(GenericObject)->PolicyAdmins;
        break;

    case AZ_PROP_POLICY_READERS:
        *GenericObjectList = &(GenericObject)->PolicyReaders;
        break;

    case AZ_PROP_DELEGATED_POLICY_USERS:
        *GenericObjectList = &(GenericObject)->DelegatedPolicyUsers;
        break;

    default:
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}


BOOLEAN
ObAllocateNewName(
    IN PGENERIC_OBJECT GenericObject,
    IN PAZP_STRING ObjectName
    )
/*++

Routine Description

    Allocates the structure describing the new name of a generic object.

    On entry, PersistCritSect must be locked.

Arguments

    GenericObject - Pointer to the GenericObject being renamed

    ObjectName - New name of the object

Return Value

    TRUE - New name has been properly allocated and linked
    FALSE - not enough memory

--*/
{
    PNEW_OBJECT_NAME NewObjectName = NULL;
    PAZP_AZSTORE AzAuthorizationStore = GenericObject->AzStoreObject;

    //
    // Initialization
    //

    ASSERT( AzpIsCritsectLocked( &AzAuthorizationStore->PersistCritSect ) );

    //
    // Allocate memory for the new of the object name.
    //

    NewObjectName = (PNEW_OBJECT_NAME) AzpAllocateHeap( sizeof(NEW_OBJECT_NAME) + ObjectName->StringSize, "GENAME" );

    if ( NewObjectName == NULL ) {
        return FALSE;
    }

    //
    // Reference the renamed object
    //  The reference count really doesn't need to be incremented since we *know*
    //  that AzpPersistReconcile won't delete the object, but ...
    //

    NewObjectName->GenericObject = GenericObject;

    InterlockedIncrement( &GenericObject->ReferenceCount );
    AzpDumpGoRef( "Reference from NewName", GenericObject );

    //
    // Initialize the name
    //

    NewObjectName->ObjectName = *ObjectName;
    NewObjectName->ObjectName.String = (LPWSTR)(NewObjectName+1);

    RtlCopyMemory( &NewObjectName->ObjectName.String,
                   ObjectName->String,
                   ObjectName->StringSize );

    //
    // Link the structure onto the authorization store where AzpReconcile can find it
    //

    InsertHeadList( &AzAuthorizationStore->NewNames, &NewObjectName->Next );

    return TRUE;
}

VOID
ObFreeNewName(
    IN PNEW_OBJECT_NAME NewObjectName
    )
/*++

Routine Description

    Free the structure describing the new name of a generic object.

    On entry, PersistCritSect must be locked.

Arguments

    NewObjectName - Pointer to the structure to free

Return Value

    None

--*/
{

    //
    // Initialization
    //

    ASSERT( AzpIsCritsectLocked( &NewObjectName->GenericObject->AzStoreObject->PersistCritSect ) );

    //
    // Dereference the renamed object
    //

    ObDereferenceObject( NewObjectName->GenericObject );

    //
    // Remove the entry from the list on the authorization store object
    //

    RemoveEntryList( &NewObjectName->Next );

    //
    // Finally, free the structure
    //
    AzpFreeHeap( NewObjectName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\makefile.inc ===
PRIVLIB= $(O)\$(TARGETNAME)p.lib
$(O)\$(TARGETNAME).lib : $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\$(TARGETNAME)p.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\$(TARGETNAME)p.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\$(TARGETNAME)p.def: $(TARGETNAME).def
    $(C_PREPROCESSOR) $** -DPRIVATEEXPORT= > $@

stdafx_stub.cxx: stdafx.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\genobj.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    genobj.h

Abstract:

    Definitions for the generic object implementation.

    AZ roles has so many objects that need creation, enumeration, etc
    that it seems prudent to have a single body of code for doing those operations.


Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/


#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////////////
//
// Structure definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// A generic object list head.
//
// This structure represent the head of a linked list of objects.  The linked
// list of objects are considered to be "children" of this structure.
//

typedef struct _GENERIC_OBJECT_HEAD {

    //
    // Head of the linked list of objects
    //

    LIST_ENTRY Head;

    //
    // Count of entries on the list headed by Head
    //

    ULONG ObjectCount;

    //
    // Tree of the names of the objects
    //

    RTL_GENERIC_TABLE AvlTree;

    //
    // Back pointer to the GenericObject containing this structure
    //

    struct _GENERIC_OBJECT *ParentGenericObject;


    //
    // Each of the list heads that are rooted on a single object are linked
    //  together.  That list is headed by GENERIC_OBJECT->ChildGenericObjectHead.
    //  This field is a pointer to the next entry in the list.
    //

    struct _GENERIC_OBJECT_HEAD *SiblingGenericObjectHead;

    //
    // The next sequence number to give out.
    //

    ULONG NextSequenceNumber;

    //
    // Object type of objects in this list
    //

    ULONG ObjectType;

    //
    // Flag to indicate that the parent needs to be loaded before this object can be
    // referenced
    //

    BOOLEAN LoadParentBeforeReferencing;

    //
    // The order of the defines below must match the tables at the top of genobj.cxx
    //
    // Define object types that are not visible to the providers
    //
#define OBJECT_TYPE_SID             (OBJECT_TYPE_COUNT)
#define OBJECT_TYPE_CLIENT_CONTEXT  (OBJECT_TYPE_COUNT+1)
#define OBJECT_TYPE_ROOT            (OBJECT_TYPE_COUNT+2)
#define OBJECT_TYPE_MAXIMUM         (OBJECT_TYPE_COUNT+3)


} GENERIC_OBJECT_HEAD, *PGENERIC_OBJECT_HEAD;

//
// The name of a generic object
//
// This is a separate structure since the AVL tree manager insists on allocating its own
// structure.  Combine that with the facts that objects can be renamed and that a pointer
// to the object is returned directly to the user as the handle to the object.  These
// facts imply that the structure containing the object name and the structure implementing
// the "handle" cannot be the same structure.  I chose to not implement a separate "handle"
// structure.  Such an implementation would have to "re-create and copy" the generic object
// structure upon rename.
//

typedef struct _GENERIC_OBJECT_NAME {

    //
    // Name of the object
    //
    AZP_STRING ObjectName;

    //
    // Pointer to the GenericObject structure named by this name
    //
    struct _GENERIC_OBJECT *GenericObject;

} GENERIC_OBJECT_NAME, *PGENERIC_OBJECT_NAME;

//
// The new name of a generic object
//
// This structure is only used during an AzPersistUpdateCache.  Every attempt is made
// to update the name of the object in the AVL tree.  However, if there are name conflicts,
// a GUID-ized name is used.  That's certainly OK in a pinch.  And we'll leave the name
// that way if we can't fix it or in certain bounday low memory conditions.  However, we
// should fix it up if we can.  This structure remembers the real name of the object and
// allows AzpPersistReconcile to try to fix the name up.
//

typedef struct _NEW_OBJECT_NAME {

    //
    // Link to the next new name for the same authorization store object
    //

    LIST_ENTRY Next;

    //
    // Pointer to the GenericObject structure named by this name
    //  The specified generic object has its reference count incremented.
    //
    struct _GENERIC_OBJECT *GenericObject;

    //
    // New name of the object
    //
    AZP_STRING ObjectName;

} NEW_OBJECT_NAME, *PNEW_OBJECT_NAME;

//
// Object List
//
// Some objects have lists of references to other objects.  These lists are
//  not parent/child relationships.  Rather they represent memberships, etc.
//
// This structure represents the head of such a list.
//
// Both the pointed-from and pointed-to object have a generic object list.  The
// "forward" link represents the list that is managed via external API.  The
// "backward" link is provided to allow fixup of references when an object is deleted.
// The "backward" link is also provided for cases where internal routines need to
// traverse the link relationship in the opposite direction of the external API.
// By convention, GENERIC_OBJECT_LIST instances in the forward direction are named
// simply by the name of the object to point to.  For instance, an object list that points
// to AZ_OPERATION objects might be called "Operations".  By convention, GENERIC_OBJECT_LIST
// instances in the backward direction are prefixed by the name "back".  For instance,
// "backTasks".
//
// Note, there really isn't any reason why we couldn't expose "AddPropertyItem" and
// "RemovePropertyItem" APIs for the "back" lists.  See the IsBackLink and LinkPairId
// definition.
//

typedef struct _GENERIC_OBJECT_LIST {

    //
    // Each of the object lists that are rooted on a single object are linked
    //  together.  That list is headed by GENERIC_OBJECT->GenericObjectLists.
    //  This field is a pointer to the next entry in the list.
    //

    struct _GENERIC_OBJECT_LIST *NextGenericObjectList;

    //
    // Since an object list is a list of other objects, we want to be able to
    //  generically find the other objects.  The array below is an array of pointers
    //  to the head of the lists that contain the other objects.
    //
    //
    // Unused elements in this array are set to NULL.
    //
    // These pointers are always pointers to a field in a "parent" structure.
    // Therefore, reference counts aren't needed.  Instead, the "child" structure
    // containing the pointer to the parent will be deleted before the parent structure.
    //

#define GEN_OBJECT_HEAD_COUNT 3
    PGENERIC_OBJECT_HEAD GenericObjectHeads[GEN_OBJECT_HEAD_COUNT];

    //
    // List identifier.
    //
    // The code maintains the link and the backlink.  To do that, the code needs to
    //  find one the "other" generic object list from this one.  That algorithm uses
    //  the IsBackLink and LinkPairId field.
    //
    // One object list has IsBackLink set TRUE and the other set FALSE.  This handles
    // the case where an object contain both a forward an backward object list.  For
    // instance, the AZ_GROUP object contains the AppMembers and backAppMembers fields.
    // This field differentiates between the two.
    //
    // There are cases where an object has multiple links between the same object types.
    // For instance, the AZ_GROUP object has both AppMembers and AppNonMembers links.
    // In those cases, the LinkPairId is set to a unique value to identify the pair.
    // In most cases, the value is simply zero.
    //
    BOOL IsBackLink;
    ULONG LinkPairId;

#define AZP_LINKPAIR_MEMBERS                1
#define AZP_LINKPAIR_NON_MEMBERS            2
#define AZP_LINKPAIR_SID_MEMBERS            3
#define AZP_LINKPAIR_SID_NON_MEMBERS        4
#define AZP_LINKPAIR_POLICY_ADMINS          5
#define AZP_LINKPAIR_POLICY_READERS         6
#define AZP_LINKPAIR_DELEGATED_POLICY_USERS 7

    //
    // Dirty Bit to be set when this list is changed
    //

    ULONG DirtyBit;


    //
    // The array of pointers to the generic objects.
    //
    // Being in this list does not increment the ReferenceCount on the pointed-to
    // generic object.
    //

    AZP_PTR_ARRAY GenericObjects;

    //
    // An array of pointers to AZP_DELTA_ENTRY containing the GUIDs of the pointed to objects.
    //
    // This array contains GUIDs of links that have not yet been persisted.
    // It also contains GUIDs of links that have been updated from the persistence
    // provider but not yet merged into GenericObjects.

    AZP_PTR_ARRAY DeltaArray;

} GENERIC_OBJECT_LIST, *PGENERIC_OBJECT_LIST;

//
// A generic object
//

typedef struct _GENERIC_OBJECT {

    //
    // Link to the next instance of an object of this type for the same parent object
    //

    LIST_ENTRY Next;

    //
    // Back pointer to the head of the list this object is in
    //

    PGENERIC_OBJECT_HEAD ParentGenericObjectHead;

    GENERIC_OBJECT_HEAD AzpSids;

    //
    // Pointer to the list heads for children of this object
    //  This is a static list of the various GENERIC_OBJECT_HEAD structures
    //  that exist in the object type specific portion of this object.
    //  The list allows the generic object code to have insight into the
    //  children of this object.
    //

    PGENERIC_OBJECT_HEAD ChildGenericObjectHead;

    //
    // Pointer to the list heads of pointers to other objects
    //  This is a static list of the various GENERIC_OBJECT_LIST structures
    //  that exist in the object type specific portion of this object.
    //  The list allows the generic object code to have insight into the
    //  other types of objects pointed to by this object.
    //

    struct _GENERIC_OBJECT_LIST *GenericObjectLists;

    //
    // Pointer to the generic object at the root of all generic objects
    //  (Pointer to an AzAuthorizationStore object)
    //

    struct _AZP_AZSTORE *AzStoreObject;

    //
    // Pointer to provider specific data for this object
    //

    PVOID ProviderData;

    //
    // A list of SIDs as policy users
    // Used by AzAuthorizationStore, AzApplication and AzScope objects
    //

    GENERIC_OBJECT_LIST PolicyAdmins;
    GENERIC_OBJECT_LIST PolicyReaders;

    //
    // Boolean specifying whether or not the object ACL-able
    //
    // Used by AzAuthorizationStore, AzApplication and AzScope objects

    LONG IsAclSupported;

    //
    // Boolean specifying if delegation is supported.  It is set during the
    // persist open calls at the provider levels.  For example, an XML provider
    // would set this to FALSE, while an LDAP provider would set it to TRUE
    //
    // Used by AzAuthorizationStore and AzApplication objects
    //

    LONG IsDelegationSupported;

    //
    // A list of SIDs as delegated users
    // Used by AzAuthorizationStore and AzApplication
    //

    GENERIC_OBJECT_LIST DelegatedPolicyUsers;

    //
    // Name of the object
    //

    PGENERIC_OBJECT_NAME ObjectName;


    //
    // Opaque private information added by an application
    //

    AZP_STRING ApplicationData;


    //
    // Description of the object
    //

    AZP_STRING Description;

    //
    // Boolean indicating if the caller can write the object
    //

    LONG IsWritable;

    //
    // Boolen indicating if the caller can create children for this object
    //

    LONG CanCreateChildren;

    //
    // GUID of the object
    //  The Guid of the object is assigned by the persistence provider.
    //  The GUID is needed to make the object rename safe.
    //

    GUID PersistenceGuid;


    //
    // Number of references to this instance of the object
    //  These are references from within our code.
    //

    LONG ReferenceCount;

    //
    // Number of references to this instance of the object
    //  These are references represented by handles passed back to our caller.
    //

    LONG HandleReferenceCount;

    //
    // Sequence number of this object.
    //  The list specified in Next is maintained in SequenceNumber order.
    //  New entries are added to the tail end.
    //  Enumerations are returned in SequenceNumber order.
    //  SequenceNumber is returned to the caller as the EnumerationContext.
    //
    // This mechanism allows insertions and deletions to be handled seemlessly.
    //

    ULONG SequenceNumber;

    //
    // Specific object type represented by this generic object
    //

    ULONG ObjectType;

    //
    // Flags describing attributes of the generic object
    //

    ULONG Flags;

#define GENOBJ_FLAGS_DELETED    0x01    // Object has been deleted
#define GENOBJ_FLAGS_PERSIST_OK 0x02    // Persist provider has finished with this object
#define GENOBJ_FLAGS_REFRESH_ME 0x04    // Object needs to be refreshed from cache

    //
    // Flags to indicate which attributes are dirty
    //  High order bits are generic to all objects
    //  Low order bits are specific to individual objects
    //
    // Bits in "DirtyBits" indicates that the object needs to be submitted
    //  See the AZ_DIRTY_* defines.
    //

    ULONG DirtyBits;

    //
    // Flags to indicate that Persistence provider has changed the attribute
    //  Access to this field is serialized by the PersistCritSect
    //
    //  See the AZ_DIRTY_* defines.
    //

    ULONG PersistDirtyBits;

    //
    // Boolean specifying whether or not audits should be generated. Only
    //  Authorizartion Store and application objects have this property. When this
    // is set to TRUE all possible audits for this AzAuthStore/application are generated.
    //

    LONG IsGeneratingAudits;

    //
    // Apply SACL property. Only AzAuthorizationStore, application and Scope objects
    // have this property.
    //

    LONG ApplySacl;

    //
    // whether apply SACL property is supported or not.
    // For AD stores, AzAuthorizationStore, application and Scope objects support it.
    // For XML stores, only AzAuthorizationStore supports it.
    //

    LONG IsSACLSupported;

    //
    // Boolean to indicate if the children are loaded into cache
    //

    BOOLEAN AreChildrenLoaded;

    //
    // Boolean to indicate that the object has been closed
    //

    BOOLEAN ObjectClosed;

} GENERIC_OBJECT, *PGENERIC_OBJECT;

//
// Property ID to dirty bit mapping table
//
// This structure gives a mapping between property ID and the corresponding dirty bit.
// It also provides a default value for the property.
//

typedef struct _AZP_DEFAULT_VALUE {

    ULONG PropertyId;

    ULONG DirtyBit;

    PVOID DefaultValue;

} AZP_DEFAULT_VALUE, *PAZP_DEFAULT_VALUE;


/////////////////////////////////////////////////////////////////////////////
//
// Macro definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// Macro to determine if a GENERIC_OBJECT_LIST is a list of sids
//

#define AzpIsSidList( _gol ) \
    ((_gol)->GenericObjectHeads[0] != NULL && \
     (_gol)->GenericObjectHeads[0]->ObjectType == OBJECT_TYPE_SID )

//
// Macro to determine the address of a parent object from a child object
//

#define ParentOfChild( _go ) \
    ((_go)->ParentGenericObjectHead->ParentGenericObject)

//
// Macro to determine if an object type is a container type object or not
//

#define IsContainerObject( _objT ) \
    ( (_objT) == OBJECT_TYPE_AZAUTHSTORE || \
      (_objT) == OBJECT_TYPE_APPLICATION || \
      (_objT) == OBJECT_TYPE_SCOPE )

//
// Macro to determine is an object type is a delegator type object or not
//

#define IsDelegatorObject( _objT ) \
    ( (_objT) == OBJECT_TYPE_AZAUTHSTORE || \
      (_objT) == OBJECT_TYPE_APPLICATION )

//
// Macros to determine if the provider actually supports ACLs or delegation
//

#define CHECK_ACL_SUPPORT(_o) \
    (IsContainerObject( (_o)->ObjectType ) ? \
        ((_o)->IsAclSupported ? NO_ERROR : ERROR_NOT_SUPPORTED) : \
        ERROR_INVALID_PARAMETER )

#define CHECK_DELEGATION_SUPPORT(_o) \
    (IsDelegatorObject( (_o)->ObjectType ) ? \
        ((_o)->IsDelegationSupported ? NO_ERROR : ERROR_NOT_SUPPORTED) : \
        ERROR_INVALID_PARAMETER )

//
// Macro to set a property in the cache.
//
// This macro acts as a wrapper around the code to set the property.
// The macro detects the mode of the caller and properly handles the following:
//
// * Ensures object supports this "dirty" bit
// * Sets the appropriate "dirty" bit depending on mode
// * Avoids setting the property on AzUpdateCache if the property is dirty
//
// The correct calling sequence of the macros is:
//
//  case AZ_PROP_XXX:
//      BEGIN_SETPROP( &WinStatus, Object, AZ_DIRTY_XXX ) {
//          WinStatus = f( Object->Property );
//          /* Optionally */ if ( WinStatus != NO_ERROR ) goto Cleanup
//      } END_SETPROP;
//      break;
//

extern DWORD AzGlObjectAllDirtyBits[];

#define BEGIN_SETPROP( __WinStatusPtr, __ObjectPtr, __Flags, __DirtyBit ) \
{ \
    DWORD *_WinStatusPtr = (__WinStatusPtr); \
    PGENERIC_OBJECT _GenericObject = ((PGENERIC_OBJECT)(__ObjectPtr)); \
    ULONG _DirtyBit = (__DirtyBit); \
    ULONG _Flags = (__Flags); \
    BOOLEAN _DoSetProperty = FALSE; \
    \
    if ( (AzGlObjectAllDirtyBits[_GenericObject->ObjectType] & _DirtyBit) == 0 ) { \
        AzPrint(( AZD_INVPARM, "SetProperty: Object doesn't support dirty bit 0x%lx\n", _DirtyBit )); \
        *_WinStatusPtr = ERROR_INVALID_PARAMETER; \
    \
    } else if ( IsNormalFlags(_Flags) ) { \
    \
        _DoSetProperty = TRUE; \
        AzPrint(( AZD_PERSIST_MORE, "IsNormalFlags(_Flags) = TRUE\n" )); \
        if ( (_Flags & AZP_FLAGS_SETTING_TO_DEFAULT) == 0 && !AzpAzStoreVersionAllowWrite(_GenericObject->AzStoreObject) ) \
        { \
            *_WinStatusPtr = ERROR_REVISION_MISMATCH; \
        } \
        else { \
            _DoSetProperty = TRUE; \
        } \
    \
    } else { \
    \
        if ( (_GenericObject->DirtyBits & _DirtyBit) == 0 ) { \
            AzPrint(( AZD_PERSIST_MORE, "(_GenericObject->DirtyBits & _DirtyBit) = 0\n" )); \
            _DoSetProperty = TRUE; \
        } else if (IsRefreshFlags(_Flags)) { \
            AzPrint(( AZD_PERSIST_MORE, "IsRefreshFlags(_Flags) = TRUE\n" )); \
            _DoSetProperty = TRUE; \
        } else { \
            *_WinStatusPtr = NO_ERROR; \
        } \
    \
    } \
    \
    if ( _DoSetProperty ) { \

#define END_SETPROP( __PropHasChanged ) \
        if ( *_WinStatusPtr == NO_ERROR && \
             (_Flags & AZP_FLAGS_SETTING_TO_DEFAULT) == 0 ) { \
            if ( IsNormalFlags( _Flags ) ) { \
                if ( (__PropHasChanged) ) { \
                    _GenericObject->DirtyBits |= _DirtyBit; \
                } \
            } else { \
                ASSERT( AzpIsCritsectLocked( &_GenericObject->AzStoreObject->PersistCritSect ) ); \
                ASSERT( (_GenericObject->Flags & GENOBJ_FLAGS_PERSIST_OK) == 0 ); \
                _GenericObject->PersistDirtyBits |= _DirtyBit; \
            } \
        \
        } \
    } \
}




//
// Macro to do validity checking after setting a property in the cache.
//
// This macro acts as a wrapper around the code to do the validity checking.
// Some validity checking is only appropriate only when the caller is the UI
// or application.  This validity checking may not be valid when setting default
// values or when populating the cache from the store.
//
// The correct calling sequence of the macros is:
//
//  case AZ_PROP_XXX:
//      BEGIN_SETPROP( &WinStatus, Object, AZ_DIRTY_XXX ) {
//
//          BEGIN_VALIDITY_CHECKING( Flags ) {
//              checks to see if property is valid
//          } END_VALIDITY_CHECKING;
//
//          WinStatus = f( Object->Property );
//
//          /* Optionally */ if ( WinStatus != NO_ERROR ) goto Cleanup
//      } END_SETPROP;
//      break;
//

#define DO_VALIDITY_CHECKING( _Flags ) \
    ( IsNormalFlags(_Flags) && (_Flags & (AZP_FLAGS_SETTING_TO_DEFAULT)) == 0 )

#define BEGIN_VALIDITY_CHECKING( _Flags ) \
{ \
    \
    if ( DO_VALIDITY_CHECKING( _Flags ) ) {

#define END_VALIDITY_CHECKING \
    } \
}

//
// Macro to handle validity check on string length.
//
// The correct calling sequence of the macros is:
//
//  case AZ_PROP_XXX:
//      BEGIN_SETPROP( &WinStatus, Object, AZ_DIRTY_XXX ) {
//
//          //
//          // Capture the input string
//          //
//
//          WinStatus = AzpCaptureString( &CapturedString,
//                                        (LPWSTR) PropertyValue,
//                                        CHECK_STRING_LENGTH( Flags, AZ_MAX_XXX),
//                                        TRUE ); // NULL is OK
//
//          if ( WinStatus != NO_ERROR ) {
//              goto Cleanup;
//          }
//
//          WinStatus = f( Object->Property );
//
//          /* Optionally */ if ( WinStatus != NO_ERROR ) goto Cleanup
//      } END_SETPROP;
//      break;
//

#define CHECK_STRING_LENGTH( _Flags, _MaxLen ) \
    (DO_VALIDITY_CHECKING( _Flags ) ? (_MaxLen) : 0xFFFFFFFF)

/////////////////////////////////////////////////////////////////////////////
//
// Procedure definitions
//
/////////////////////////////////////////////////////////////////////////////

VOID
ObInitGenericHead(
    IN PGENERIC_OBJECT_HEAD GenericObjectHead,
    IN ULONG ObjectType,
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT_HEAD SiblingGenericObjectHead OPTIONAL
    );

VOID
ObFreeGenericObject(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
ObIncrHandleRefCount(
    IN PGENERIC_OBJECT GenericObject
    );

DWORD
ObDecrHandleRefCount(
    IN PGENERIC_OBJECT GenericObject
    );

DWORD
ObGetHandleType(
    IN PGENERIC_OBJECT Handle,
    IN BOOL AllowDeletedObjects,
    OUT PULONG ObjectType
    );

DWORD
ObReferenceObjectByName(
    IN PGENERIC_OBJECT_HEAD GenericObjectHead,
    IN PAZP_STRING ObjectName,
    IN ULONG Flags,
    OUT PGENERIC_OBJECT *RetGenericObject
    );

DWORD
ObReferenceObjectByHandle(
    IN PGENERIC_OBJECT Handle,
    IN BOOL AllowDeletedObjects,
    IN BOOLEAN RefreshCache,
    IN ULONG ObjectType
    );

VOID
ObDereferenceObject(
    IN PGENERIC_OBJECT GenericObject
    );

typedef DWORD
(OBJECT_INIT_ROUTINE)(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

typedef DWORD
(OBJECT_NAME_CONFLICT_ROUTINE)(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PAZP_STRING ChildObjectNameString
    );

typedef VOID
(OBJECT_FREE_ROUTINE)(
    IN PGENERIC_OBJECT GenericObject
    );

typedef DWORD
(OBJECT_GET_PROPERTY_ROUTINE)(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

typedef DWORD
(OBJECT_SET_PROPERTY_ROUTINE)(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    );

typedef DWORD
(OBJECT_ADD_PROPERTY_ITEM_ROUTINE)(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PGENERIC_OBJECT LinkedToObject
    );

DWORD
ObCreateObject(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN ULONG ChildObjectType,
    IN PAZP_STRING ChildObjectNameString,
    IN GUID *ChildObjectGuid OPTIONAL,
    IN ULONG Flags,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    );

//
// Flags to various internal functions
//  The low order 2 bytes of this DWORD are shared with the AZPE_FLAGS defines in azper.h
//

#define AZP_FLAGS_SETTING_TO_DEFAULT    0x00010000  // Property is being set to default value
#define AZP_FLAGS_BY_GUID               0x00020000  // Name based routine should use GUID instead
#define AZP_FLAGS_ALLOW_DELETED_OBJECTS 0x00040000  // Allow deleted objects to be found
#define AZP_FLAGS_REFRESH_CACHE         0x00080000  // Ensure cache is up to date
#define AZP_FLAGS_RECONCILE             0x00100000  // The caller is AzpPersistReconcile

//
// Macro to return TRUE if this is a normal caller
//  (e.g., the app and not an internal caller)
//
#define IsNormalFlags( _Flags ) (((_Flags) & (AZPE_FLAGS_PERSIST_MASK|AZP_FLAGS_RECONCILE)) == 0 )
#define IsRefreshFlags( _Flags ) (((_Flags) & (AZPE_FLAGS_PERSIST_REFRESH)) != 0 )

DWORD
ObGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

DWORD
ObSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    );

DWORD
ObSetPropertyToDefault(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG DirtyBits
    );


DWORD
ObCommonCreateObject(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN ULONG ParentObjectType,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN ULONG ChildObjectType,
    IN LPCWSTR ChildObjectName,
    IN DWORD Reserved,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    );

DWORD
ObCommonOpenObject(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN ULONG ParentObjectType,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN ULONG ChildObjectType,
    IN LPCWSTR ChildObjectName,
    IN DWORD Reserved,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    );

DWORD
ObEnumObjects(
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN BOOL EnumerateDeletedObjects,
    IN BOOL RefreshCache,
    IN OUT PULONG EnumerationContext,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    );

DWORD
ObCommonEnumObjects(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN ULONG ParentObjectType,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN OUT PULONG EnumerationContext,
    IN DWORD Reserved,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    );

DWORD
ObCommonGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    );

DWORD
ObCommonSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

VOID
ObMarkObjectDeleted(
    IN PGENERIC_OBJECT GenericObject
    );

DWORD
ObCommonDeleteObject(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN ULONG ParentObjectType,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN ULONG ChildObjectType,
    IN LPCWSTR ChildObjectName,
    IN DWORD Reserved
    );

VOID
ObInitObjectList(
    IN OUT PGENERIC_OBJECT_LIST GenericObjectList,
    IN PGENERIC_OBJECT_LIST NextGenericObjectList OPTIONAL,
    IN BOOL IsBackLink,
    IN ULONG LinkPairId,
    IN ULONG DirtyBit,
    IN PGENERIC_OBJECT_HEAD GenericObjectHead0 OPTIONAL,
    IN PGENERIC_OBJECT_HEAD GenericObjectHead1 OPTIONAL,
    IN PGENERIC_OBJECT_HEAD GenericObjectHead2 OPTIONAL
    );

DWORD
ObAddPropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN ULONG       Flags,
    IN PAZP_STRING ObjectName
    );

DWORD
ObLookupPropertyItem(
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PAZP_STRING ObjectName,
    OUT PULONG InsertionPoint OPTIONAL
    );

DWORD
ObRemovePropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PAZP_STRING ObjectName
    );

PAZ_STRING_ARRAY
ObGetPropertyItems(
    IN PGENERIC_OBJECT_LIST GenericObjectList
    );

PAZ_GUID_ARRAY
ObGetPropertyItemGuids(
    IN PGENERIC_OBJECT_LIST GenericObjectList
    );

VOID
ObRemoveObjectListLink(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN ULONG Index
    );

VOID
ObRemoveObjectListLinks(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
ObFreeObjectList(
    IN PGENERIC_OBJECT GenericObject,
    IN OUT PGENERIC_OBJECT_LIST GenericObjectList
    );

DWORD
ObCheckNameConflict(
    IN PGENERIC_OBJECT_HEAD GenericObjectHead,
    IN PAZP_STRING ObjectNameString,
    IN ULONG ConflictListOffset,
    IN ULONG GrandchildListOffset,
    IN ULONG GrandChildConflictListOffset
    );

DWORD
ObMapPropIdToObjectList(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    OUT PGENERIC_OBJECT_LIST *GenericObjectList,
    OUT PULONG ObjectType
    );

BOOLEAN
ObLookupDelta(
    IN ULONG DeltaFlags,
    IN GUID *Guid,
    IN PAZP_PTR_ARRAY AzpPtrArray,
    OUT PULONG InsertionPoint OPTIONAL
    );

DWORD
ObAddDeltaToArray(
    IN ULONG DeltaFlags,
    IN GUID *Guid,
    IN PAZP_PTR_ARRAY AzpPtrArray,
    IN BOOLEAN DiscardDeletes
    );

VOID
ObFreeDeltaArray(
    IN PAZP_PTR_ARRAY DeltaArray,
    IN BOOLEAN FreeAllEntries
    );

BOOLEAN
ObAllocateNewName(
    IN PGENERIC_OBJECT GenericObject,
    IN PAZP_STRING ObjectName
    );

VOID
ObFreeNewName(
    IN PNEW_OBJECT_NAME NewObjectName
    );

DWORD
ObUnloadChildGenericHeads(
    IN PGENERIC_OBJECT pParentObject
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\opcache.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    opcache.cxx

Abstract:

    Routines implementing a cache of which operations have already been checked
    for a particular client context

Author:

    Cliff Van Dyke (cliffv) 14-Nov-2001

--*/

#include "pch.hxx"
#define AZD_COMPONENT     AZD_ACCESS

//
// Windows XP RTM doesn't support RtlLookupElementGenericTableFull
//  Windoes XP SP1 does support it
//  So avoid the API if building a binary that runs on XP RTM.
#ifndef RUN_ON_XP_RTM
#define USE_AVL_FULL 1
#endif // RUN_ON_XP_RTM

//
// Structure describing the operations that have previously had access checks done on them
//  for a particular scope.
//

typedef struct _AZP_OPERATION_CACHE {

    //
    // Pointer to the scope object this cache entry applies to
    //  The ReferenceCount is held on Scope.
    //  This value is NULL if the scope is the application.
    //
    PAZP_SCOPE Scope;

    //
    // Pointer to the operation object this cache entry applies to
    //  The ReferenceCount is held on Operation
    //  This field must be the first field in the structure.
    //
    PAZP_OPERATION Operation;

    //
    // Pointer to the business rule string applicable to this operation
    //  The actual string is a part of this same allocated buffer.
    AZP_STRING BizRuleString;

    //
    // Result of the access check
    //
    DWORD Result;

} AZP_OPERATION_CACHE, *PAZP_OPERATION_CACHE;

RTL_GENERIC_COMPARE_RESULTS
AzpAvlCacheCompare(
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID FirstStruct,
    IN PVOID SecondStruct
    )
/*++

Routine Description:

    This routine will compare twp operation cache entries

Arguments:

    IN PRTL_GENERIC_TABLE - Supplies the table containing the announcements
    IN PVOID FirstStuct - The first structure to compare.
    IN PVOID SecondStruct - The second structure to compare.

Return Value:

    Result of the comparison.

--*/
{
    PAZP_OPERATION_CACHE Op1 = (PAZP_OPERATION_CACHE) FirstStruct;
    PAZP_OPERATION_CACHE Op2 = (PAZP_OPERATION_CACHE) SecondStruct;

    if ( Op1->Scope < Op2->Scope ) {
        return GenericLessThan;
    } else if ( Op1->Scope > Op2->Scope ) {
        return GenericGreaterThan;
    } else if ( Op1->Operation < Op2->Operation ) {
        return GenericLessThan;
    } else if ( Op1->Operation > Op2->Operation ) {
        return GenericGreaterThan;
    } else {
        return GenericEqual;
    }

    UNREFERENCED_PARAMETER(Table);

}

VOID
AzpInitOperationCache(
    IN PAZP_CLIENT_CONTEXT ClientContext
    )
/*++

Routine Description:

    Initializes the operation cache for a client context

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ClientContext - Specifies the client context to initialize the cache for

Return Value:

    None

--*/
{

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Initialize the AVL tree of scopes that have been access checked already
    //

    RtlInitializeGenericTable( &ClientContext->OperationCacheAvlTree,
                               AzpAvlCacheCompare,
                               AzpAvlAllocate,
                               AzpAvlFree,
                               NULL);

}

VOID
AzpFlushOperationCache(
    IN PAZP_CLIENT_CONTEXT ClientContext
    )
/*++

Routine Description:

    Flushes the operation cache for a client context

    On entry, AcContext->ClientContext.CritSect must be locked OR
        AzGlResource must be locked exclusively.

Arguments:

    ClientContext - Specifies the client context to flush the cache for

Return Value:

    None

--*/
{
    ULONG i;
    PAZP_OPERATION_CACHE OperationCache;

    //
    // Initialization
    //

    ASSERT( AzpIsCritsectLocked( &ClientContext->CritSect ) ||
            AzpIsLockedExclusive( &AzGlResource ) );

    //
    //  Loop until the OperationCache is empty
    //

    for (;;) {

        //
        // Get the first element in the table
        //

        OperationCache = (PAZP_OPERATION_CACHE) RtlEnumerateGenericTable( &ClientContext->OperationCacheAvlTree, TRUE );

        if ( OperationCache == NULL ) {
            break;
        }

        //
        // Dereference the Scope object
        //

        if ( OperationCache->Scope != NULL ) {
            ObDereferenceObject( &OperationCache->Scope->GenericObject );
            OperationCache->Scope = NULL;
        }

        //
        // Dereference the Operation object
        //

        ObDereferenceObject( &OperationCache->Operation->GenericObject );



        //
        // Delete the entry
        //

        RtlDeleteElementGenericTable( &ClientContext->OperationCacheAvlTree, OperationCache );
    }

    ASSERT (RtlNumberGenericTableElementsAvl(&ClientContext->OperationCacheAvlTree) == 0);

    //
    // Ditch the arrays of cached parameters
    //

    if ( ClientContext->UsedParameterNames != NULL ) {

        for ( i=0; i<ClientContext->UsedParameterCount; i++) {
            VariantClear( &ClientContext->UsedParameterNames[i] );
            VariantClear( &ClientContext->UsedParameterValues[i] );
        }

        AzpFreeHeap( ClientContext->UsedParameterNames );
        ClientContext->UsedParameterNames = NULL;

        // UsedParameterValues is a part of the UsedParameterNames allocated block
        ClientContext->UsedParameterValues = NULL;
        ClientContext->UsedParameterCount = 0;

    }


}

BOOLEAN
AzpCheckOperationCache(
    IN PACCESS_CHECK_CONTEXT AcContext
    )
/*++

Routine Description:

    This routine checks checks to see if this access check can be satisified by the
    cache of operations.

    On entry, AcContext->ClientContext.CritSect must be locked.
    On entry, AzGlResource must be locked Shared.

Arguments:

    AcContext - Specifies the context of the user to check group membership of.
        AcContext is updated to indicate any operations that are know to be allowed or denied.

Return Value:

    TRUE - All operations were satisfied from cache

--*/
{
    ULONG WinStatus;
    ULONG OpIndex;
    ULONG i;

    PAZP_CLIENT_CONTEXT ClientContext = AcContext->ClientContext;
    AZP_OPERATION_CACHE TemplateOperationCache = {0};
    PAZP_OPERATION_CACHE OperationCache;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );
    ASSERT( AzpIsCritsectLocked( &ClientContext->CritSect ) );

    //
    // Check to ensure we should be using the operation cache
    //
    // Avoid the cache if any interfaces were passed by the caller
    // (This could relaxed.  It doesn't make any difference that the interface was
    // passed by the caller.  It only matters if the interface was actually used.
    // So we could set a boolean in CScriptEngine::GetItemInfo and simply not cache
    // operations that used the interfaces.)
    //

    if ( AcContext->Interfaces != NULL ) {

        AzPrint(( AZD_ACCESS_MORE,
                  "AzpCheckOperationCache: Operation cache avoided since interfaces passed in\n" ));
        return FALSE;
    }


    //
    // If object cache has changed,
    //  flush the operation cache.
    //
    // This code doesn't prevent the object cache from changing *during* the access check
    // call.  That's fine.  It does protect against changes made prior to the access check call.
    //

    if ( ClientContext->OpCacheSerialNumber !=
         ClientContext->GenericObject.AzStoreObject->OpCacheSerialNumber ) {

        AzpFlushOperationCache( ClientContext );

        //
        // Update the serial number to the new serial number
        //

        AzPrint(( AZD_ACCESS_MORE, "AzpCheckOperationCache: OpCacheSerialNumber changed from %ld to %ld\n",
                  ClientContext->OpCacheSerialNumber,
                  ClientContext->GenericObject.AzStoreObject->OpCacheSerialNumber ));

        ClientContext->OpCacheSerialNumber =
            ClientContext->GenericObject.AzStoreObject->OpCacheSerialNumber;
    }

    //
    // If the cache is empty,
    //  we're done now
    //

    if ( RtlNumberGenericTableElementsAvl(&ClientContext->OperationCacheAvlTree) == 0 ) {
        return FALSE;
    }

    //
    // If any of the parmeters used to build the operation cache have changed,
    //  Don't use the operation cache.
    //
    //
    // We didn't capture the array
    //  So access it under a try/except
    __try {

        //
        // If the number of passed parameters changed in size,
        //  flush the cache
        //

        if ( ClientContext->UsedParameterCount != 0 &&
             ClientContext->UsedParameterCount != AcContext->ParameterCount ) {

            AzPrint(( AZD_CRITICAL,
                      "AzpCheckOperationCache: Parameter count changed from previous call %ld %ld\n",
                       ClientContext->UsedParameterCount,
                       AcContext->ParameterCount ));

            AzpFlushOperationCache( ClientContext );
        }

        //
        //
        // For each name on the existing list of used paramaters,
        //  check to ensure the value hasn't change
        //

        for ( i=0; i<ClientContext->UsedParameterCount; i++ ) {

            //
            // Skip parameters that weren't used on the previous call
            //

            if ( V_VT(&ClientContext->UsedParameterNames[i] ) == VT_EMPTY ) {
                continue;
            }


            //
            // If the used parameter wasn't passed in on this new call,
            //  or if the used parameter has a different value on this new call,
            //  flush the cache
            //
            // We rely on the fact that the app always passes the same parameter names
            // on every AccessCheck call.  That is reasonable since the app has a fixed
            // contract with the bizrule writers to supply a fixed set of parameters.
            //

            if ( i >= AcContext->ParameterCount ||
                 AzpCompareParameterNames(
                    &ClientContext->UsedParameterNames[i],
                    &AcContext->ParameterNames[i] ) != 0 ||
                 VarCmp(
                    &ClientContext->UsedParameterValues[i],
                    &AcContext->ParameterValues[i],
                    LOCALE_USER_DEFAULT, 0 ) != (HRESULT)VARCMP_EQ ) {

                AzPrint(( AZD_ACCESS_MORE,
                          "AzpCheckOperationCache: Parameter '%ws' changed from previous call\n",
                          V_BSTR( &ClientContext->UsedParameterNames[i] ) ));

                AzpFlushOperationCache( ClientContext );
                break;
            }
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        AzPrint((AZD_CRITICAL, "AzpUpdateOperationCache took an exception: 0x%lx\n", GetExceptionCode()));
        return FALSE;
    }



    //
    // Loop handling each operation
    //

    for ( OpIndex=0; OpIndex<AcContext->OperationCount; OpIndex++ ) {

        //
        // Lookup the scope/operation pair in the operation cache
        //

        TemplateOperationCache.Scope = AcContext->Scope;
        TemplateOperationCache.Operation = AcContext->OperationObjects[OpIndex];

        OperationCache = (PAZP_OPERATION_CACHE) RtlLookupElementGenericTable (
                                &ClientContext->OperationCacheAvlTree,
                                &TemplateOperationCache );

        if ( OperationCache == NULL ) {
            continue;
        }

        //
        // Return the bizrule string for this operation
        //  The caller cannot depend upon order of evaluation.
        //  Therefore, only the first cached string need be returned.
        //

        if ( AcContext->BusinessRuleString.StringSize == 0 ) {

            WinStatus = AzpDuplicateString( &AcContext->BusinessRuleString,
                                            &OperationCache->BizRuleString );

            if ( WinStatus != NO_ERROR ) {
                return FALSE;
            }

        }

        //
        // The operation result was found,
        //  return it.
        //

        AcContext->Results[OpIndex] = OperationCache->Result;
        AcContext->OperationWasProcessed[OpIndex] = TRUE;
        AcContext->ProcessedOperationCount++;
        AcContext->CachedOperationCount++;

        AzPrint(( AZD_ACCESS_MORE,
                  "AzpCheckOperationCache: '%ws/%ws' found in operation cache\n",
                  OperationCache->Scope != NULL ? OperationCache->Scope->GenericObject.ObjectName->ObjectName.String : NULL,
                  OperationCache->Operation->GenericObject.ObjectName->ObjectName.String,
                  OperationCache->Result ));

        if (AcContext->OperationCount == AcContext->CachedOperationCount) {
            return TRUE;
        }

    }

    return FALSE;

}

VOID
AzpUpdateOperationCache(
    IN PACCESS_CHECK_CONTEXT AcContext
    )
/*++

Routine Description:

    This routine updated the operation cache with new results.

    On entry, AcContext->ClientContext.CritSect must be locked.
    On entry, AzGlResource must be locked Shared.

Arguments:

    AcContext - Specifies the context of the user to check group membership of.
        AcContext is updated to indicate any operations that are know to be allowed or denied.

Return Value:

    None

--*/
{
    ULONG OpIndex;
    PAZP_CLIENT_CONTEXT ClientContext = AcContext->ClientContext;

    HRESULT hr;
    ULONG i;

#ifdef USE_AVL_FULL
    PVOID NodeOrParent;
    TABLE_SEARCH_RESULT SearchResult;
#endif USE_AVL_FULL
    BOOLEAN NewElement;

    PAZP_OPERATION_CACHE TemplateOperationCache = NULL;
    ULONG TemplateOperationCacheSize;
    PAZP_OPERATION_CACHE OperationCache;


    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );
    ASSERT( AzpIsCritsectLocked( &ClientContext->CritSect ) );

    //
    // If we aren't supposed to use the cache for this AccessCheck,
    //  we're done
    //

    if ( AcContext->Interfaces != NULL ) {
        goto Cleanup;
    }

    //
    // If all operations were satisfied via the cache,
    //  simply return
    //

    if ( AcContext->CachedOperationCount == AcContext->OperationCount ) {

        AzPrint(( AZD_ACCESS_MORE,
                  "AzpUpdateOperationCache: No operations to cache\n" ));
        goto Cleanup;
    }

    //
    // Save the list of "used" parameters
    //
    // This is a combined list of all parameters used on this call and
    //  all the parameters used on previous calls.
    //
    // Skip this if there are no newly used parameters
    //

    if ( AcContext->UsedParameterCount != 0 ) {

        //
        // We didn't capture the array
        //  So access it under a try/except
        __try {

            ASSERT( AcContext->ParameterCount != 0 );
            ASSERT( ClientContext->UsedParameterCount == 0 ||
                    ClientContext->UsedParameterCount == AcContext->ParameterCount );


            //
            // If no buffer has been allocated yet,
            //  allocate and initialize it.
            //

            if ( ClientContext->UsedParameterCount == 0 ) {

                VARIANT *ParameterNames = NULL;

                //
                // Allocate the array
                //


                ParameterNames = (VARIANT *) AzpAllocateHeap(
                                                 2 * sizeof(VARIANT) * AcContext->ParameterCount,
                                                 "OPCACHE"
                                                 );

                if ( ParameterNames == NULL ) {
                    goto Cleanup;
                }

                //
                // Initialize all of the variants to VT_EMPTY
                //

                for ( i=0; i<AcContext->ParameterCount*2; i++ ) {

                    VariantInit( &ParameterNames[i] );
                }

                //
                // Store the pointers to the initialized arrays
                //
                ClientContext->UsedParameterNames = ParameterNames;
                ClientContext->UsedParameterValues = &ParameterNames[AcContext->ParameterCount];
                ClientContext->UsedParameterCount = AcContext->ParameterCount;
            }

            //
            // Copy the new names into the new buffer
            //

            for ( i=0; i<AcContext->ParameterCount; i++ ) {

                //
                // Only copy parameters that have been used
                //  and weren't copy on a previous call
                //

                if ( AcContext->UsedParameters[i] &&
                     V_VT(&ClientContext->UsedParameterNames[i]) == VT_EMPTY ) {

                    hr = VariantCopy( &ClientContext->UsedParameterNames[i],
                                      &AcContext->ParameterNames[i] );

                    if ( FAILED(hr) ) {
                        goto Cleanup;
                    }

                    hr = VariantCopy( &ClientContext->UsedParameterValues[i],
                                      &AcContext->ParameterValues[i] );

                    if ( FAILED(hr) ) {
                        VariantClear( &ClientContext->UsedParameterNames[i] );
                        goto Cleanup;
                    }


                    AzPrint(( AZD_ACCESS_MORE,
                              "AzpUpdateOperationCache: Added parameter '%ws' to the used parameter list\n",
                              V_BSTR( &ClientContext->UsedParameterNames[i] ) ));

                }
            }

        } __except( EXCEPTION_EXECUTE_HANDLER ) {

            hr = GetExceptionCode();
            AzPrint((AZD_CRITICAL, "AzpUpdateOperationCache took an exception: 0x%lx\n", hr));
            goto Cleanup;
        }

    }

    //
    // Allocate a template for the operation cache entry
    //

    TemplateOperationCacheSize = sizeof(AZP_OPERATION_CACHE) + AcContext->BusinessRuleString.StringSize;
    SafeAllocaAllocate( TemplateOperationCache, TemplateOperationCacheSize );

    if ( TemplateOperationCache == NULL ) {
        goto Cleanup;
    }

    //
    // Loop handling each operation
    //

    for ( OpIndex=0; OpIndex<AcContext->OperationCount; OpIndex++ ) {

        //
        // Lookup the scope/operation pair in the operation cache
        //

        TemplateOperationCache->Scope = AcContext->Scope;
        TemplateOperationCache->Operation = AcContext->OperationObjects[OpIndex];

        AzPrint(( AZD_ACCESS_MORE,
                  "AzpUpdateOperationCache: Added '%ws/%ws' %ld to operation cache\n",
                  AcContext->Scope != NULL ? AcContext->Scope->GenericObject.ObjectName->ObjectName.String : NULL,
                  AcContext->OperationObjects[OpIndex]->GenericObject.ObjectName->ObjectName.String,
                  AcContext->Results[OpIndex] ));

        OperationCache = (PAZP_OPERATION_CACHE)
#ifdef USE_AVL_FULL
                            RtlLookupElementGenericTableFull(
#else // USE_AVL_FULL
                            RtlLookupElementGenericTable(
#endif // USE_AVL_FULL
                                &ClientContext->OperationCacheAvlTree,
                                TemplateOperationCache
#ifdef USE_AVL_FULL
                                ,
                                &NodeOrParent,
                                &SearchResult
#endif // USE_AVL_FULL
                                );

        if ( OperationCache == NULL ) {

            OperationCache = (PAZP_OPERATION_CACHE)
#ifdef USE_AVL_FULL
                            RtlInsertElementGenericTableFull(
#else // USE_AVL_FULL
                            RtlInsertElementGenericTable(
#endif // USE_AVL_FULL
                                    &ClientContext->OperationCacheAvlTree,
                                    TemplateOperationCache,
                                    TemplateOperationCacheSize,
                                    &NewElement
#ifdef USE_AVL_FULL
                                    ,
                                    NodeOrParent,
                                    SearchResult
#endif // USE_AVL_FULL
                                    );

            if ( OperationCache == NULL ) {
                continue;
            }

            ASSERT( NewElement );

            //
            // Initialize the new element
            //

            if ( OperationCache->Scope != NULL) {
                InterlockedIncrement( &OperationCache->Scope->GenericObject.ReferenceCount );
                AzpDumpGoRef( "Scope Cache", &OperationCache->Scope->GenericObject );
            }

            InterlockedIncrement( &OperationCache->Operation->GenericObject.ReferenceCount );
            AzpDumpGoRef( "Operation Cache", &OperationCache->Operation->GenericObject );

            OperationCache->Result = AcContext->Results[OpIndex];

            //
            // Fill in the biz rule string
            //  Don't bother if the result is NO_ERROR.
            //

            if ( OperationCache->Result != NO_ERROR ) {
                OperationCache->BizRuleString.String = (LPWSTR)&OperationCache[1];
                OperationCache->BizRuleString.StringSize = AcContext->BusinessRuleString.StringSize;

                if ( AcContext->BusinessRuleString.StringSize != 0 ) {
                    RtlCopyMemory( OperationCache->BizRuleString.String,
                                   AcContext->BusinessRuleString.String,
                                   AcContext->BusinessRuleString.StringSize );
                }
            } else {
                OperationCache->BizRuleString.StringSize = 0;
            }

        //
        // The operation is already cached.
        //  This is one of two cases:
        //      * The result was already filled in by AzpCheckOperationCache
        //      * The caller passed the same operation in twice
        //
        // In the latter case, the cache is assumed to be correct.  Return the
        //  cached value for the all results.
        //

        } else {
            AcContext->Results[OpIndex] = OperationCache->Result;
        }


    }

    //
    // Free locally used resources
    //
Cleanup:

    SafeAllocaFree( TemplateOperationCache );
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\group.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    group.cxx

Abstract:

    Routines implementing the Group object

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/

#include "pch.hxx"


//
// Define the default values for all scalar attributes
//

ULONG AzGlDefGroupType = AZ_GROUPTYPE_BASIC;

AZP_DEFAULT_VALUE AzGlGroupDefaultValues[] = {
    { AZ_PROP_GROUP_TYPE,       AZ_DIRTY_GROUP_TYPE,       &AzGlDefGroupType },
    { AZ_PROP_GROUP_LDAP_QUERY, AZ_DIRTY_GROUP_LDAP_QUERY, NULL },
    { 0, 0, NULL }
};


DWORD
AzpGroupInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzGroupCreate.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    PAZP_GROUP Group = (PAZP_GROUP) ChildGenericObject;
    PAZP_AZSTORE AzAuthorizationStore = NULL;
    PAZP_APPLICATION Application = NULL;
    PAZP_SCOPE Scope = NULL;
    PGENERIC_OBJECT_HEAD ParentSids = NULL;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Behave differently depending on the object type of the parent object
    //
    // A group references SID objects that are siblings of itself.
    // That way, the back links on the SID object references just the groups
    // that are siblings of the SID object.
    //

    if ( ParentGenericObject->ObjectType == OBJECT_TYPE_AZAUTHSTORE ) {

        AzAuthorizationStore = (PAZP_AZSTORE) ParentGenericObject;

    } else if ( ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION ) {

        AzAuthorizationStore = ParentGenericObject->AzStoreObject;
        Application = (PAZP_APPLICATION) ParentGenericObject;

    } else if ( ParentGenericObject->ObjectType == OBJECT_TYPE_SCOPE ) {

        AzAuthorizationStore = ParentGenericObject->AzStoreObject;
        Application = (PAZP_APPLICATION) ParentOfChild( ParentGenericObject );
        Scope = (PAZP_SCOPE) ParentGenericObject;

    } else {

        ASSERT( FALSE );
    }

    ParentSids = &ParentGenericObject->AzpSids;

    //
    // Groups reference other groups.
    //  These other groups can be siblings of this group or siblings of our parents.
    //
    //  Let the generic object manager know all of the lists we support
    //

    ChildGenericObject->GenericObjectLists = &Group->AppMembers;

    ObInitObjectList( &Group->AppMembers,
                      &Group->AppNonMembers,
                      FALSE,    // Forward link
                      AZP_LINKPAIR_MEMBERS,
                      AZ_DIRTY_GROUP_APP_MEMBERS,
                      &AzAuthorizationStore->Groups,
                      Application == NULL ? NULL : &Application->Groups,
                      Scope == NULL ? NULL : &Scope->Groups );

    // Same for non members
    ObInitObjectList( &Group->AppNonMembers,
                      &Group->backAppMembers,
                      FALSE,    // Forward link
                      AZP_LINKPAIR_NON_MEMBERS,
                      AZ_DIRTY_GROUP_APP_NON_MEMBERS,
                      &AzAuthorizationStore->Groups,
                      Application == NULL ? NULL : &Application->Groups,
                      Scope == NULL ? NULL : &Scope->Groups );

    // back links for the above
    ObInitObjectList( &Group->backAppMembers,
                      &Group->backAppNonMembers,
                      TRUE,     // backward link
                      AZP_LINKPAIR_MEMBERS,
                      0,    // No dirty bit on back link
                      NULL,
                      NULL,
                      NULL );

    ObInitObjectList( &Group->backAppNonMembers,
                      &Group->backRoles,
                      TRUE,     // backward link
                      AZP_LINKPAIR_NON_MEMBERS,
                      0,    // No dirty bit on back link
                      NULL,
                      NULL,
                      NULL );

    // Groups are referenced by "Roles"
    ObInitObjectList( &Group->backRoles,
                      &Group->SidMembers,
                      TRUE,     // Backward link
                      0,        // No link pair id
                      0,    // No dirty bit on back link
                      NULL,
                      NULL,
                      NULL );

    // Groups reference SID objects
    ObInitObjectList( &Group->SidMembers,
                      &Group->SidNonMembers,
                      FALSE,    // Forward link
                      AZP_LINKPAIR_SID_MEMBERS,
                      AZ_DIRTY_GROUP_MEMBERS,
                      ParentSids,
                      NULL,
                      NULL );

    // Same for non members
    ObInitObjectList( &Group->SidNonMembers,
                      NULL,
                      FALSE,    // Forward link
                      AZP_LINKPAIR_SID_NON_MEMBERS,
                      AZ_DIRTY_GROUP_NON_MEMBERS,
                      ParentSids,
                      NULL,
                      NULL );


    return NO_ERROR;
}


VOID
AzpGroupFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for Group object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    PAZP_GROUP Group = (PAZP_GROUP) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Free any local strings
    //

    AzpFreeString( &Group->LdapQuery );


}

DWORD
AzpGroupNameConflict(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PAZP_STRING ChildObjectNameString
    )
/*++

Routine Description:

    This routine is a worker routine to determine if the specified ChildObjectNameString
    conflicts with the names of other objects that share a namespace with Groups.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildObjectNameString - Specifies the name of the child object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    PAZP_AZSTORE AzAuthorizationStore = NULL;
    PAZP_APPLICATION Application = NULL;

    ULONG WinStatus;
    PGENERIC_OBJECT ConflictGenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Behave differently depending on the object type of the parent object
    //
    // A group that is a child of the authorization store,
    //  cannot have the same name as any groups that are children of any of the child applications, and
    //  cannot have the same name as any groups that are children of any of the grandchild child scopes.
    //

    if ( ParentGenericObject->ObjectType == OBJECT_TYPE_AZAUTHSTORE ) {
        AzAuthorizationStore = (PAZP_AZSTORE) ParentGenericObject;

        //
        // Check groups that are children and grandchildren
        //

        WinStatus = ObCheckNameConflict( &AzAuthorizationStore->Applications,
                                         ChildObjectNameString,
                                         offsetof(_AZP_APPLICATION, Groups),
                                         offsetof(_AZP_APPLICATION, Scopes),
                                         offsetof(_AZP_SCOPE, Groups) );


    //
    // A group that is a child of an application
    //  cannot have the same name as groups that are children of the authorization store,
    //  and cannot have the same name as any groups that are children of any of the child scopes.
    //

    } else if ( ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION ) {
        AzAuthorizationStore = ParentGenericObject->AzStoreObject;
        Application = (PAZP_APPLICATION) ParentGenericObject;

        //
        // Check groups that are children of the authorization store
        //
        //

        WinStatus = ObReferenceObjectByName( &AzAuthorizationStore->Groups,
                                             ChildObjectNameString,
                                             0,     // No special flags
                                             &ConflictGenericObject );

        if ( WinStatus == NO_ERROR ) {
            ObDereferenceObject( ConflictGenericObject );
            return ERROR_ALREADY_EXISTS;
        }

        //
        // Check groups that are children of child scopes.
        //

        WinStatus = ObCheckNameConflict( &Application->Scopes,
                                         ChildObjectNameString,
                                         offsetof(_AZP_SCOPE, Groups),
                                         0,
                                         0 );

    //
    // A group that is a child of a scope,
    //  cannot have the same name as groups that are children of the application or authorization store
    //
    } else if ( ParentGenericObject->ObjectType == OBJECT_TYPE_SCOPE ) {
        AzAuthorizationStore = ParentGenericObject->AzStoreObject;
        Application = (PAZP_APPLICATION) ParentOfChild( ParentGenericObject );

        //
        // Check groups that are children of the application.
        //

        WinStatus = ObReferenceObjectByName( &Application->Groups,
                                             ChildObjectNameString,
                                             0,     // No special flags
                                             &ConflictGenericObject );

        if ( WinStatus == NO_ERROR ) {
            ObDereferenceObject( ConflictGenericObject );
            return ERROR_ALREADY_EXISTS;
        }

        //
        // Check groups that are children of the authorization store
        //
        //

        WinStatus = ObReferenceObjectByName( &AzAuthorizationStore->Groups,
                                             ChildObjectNameString,
                                             0,     // No special flags
                                             &ConflictGenericObject );

        if ( WinStatus == NO_ERROR ) {
            ObDereferenceObject( ConflictGenericObject );
            return ERROR_ALREADY_EXISTS;
        }

        WinStatus = NO_ERROR;


    } else {
        WinStatus = ERROR_INTERNAL_ERROR;
        ASSERT( FALSE );
    }


    return WinStatus;
}


DWORD
AzpGroupGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    This routine is the Group specific worker routine for AzGetProperty.
    It does any object specific property gets.

    On entry, AzGlResource must be locked shared.

Arguments:

    GenericObject - Specifies a pointer to the object to be queried

    Flags - Specifies internal flags
        AZP_FLAGS_BY_GUID - name lists should be returned as GUID lists
        AZP_FLAGS_PERSIST_* - Call is from the persistence provider

    PropertyId - Specifies which property to return.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_GROUP_TYPE                 PULONG - Group type of the group
        AZ_PROP_GROUP_APP_MEMBERS          AZ_STRING_ARRAY - Application groups that are members of this group
        AZ_PROP_GROUP_APP_NON_MEMBERS      AZ_STRING_ARRAY - Application groups that are non-members of this group
        AZ_PROP_GROUP_LDAP_QUERY           LPWSTR - Ldap query string of the group
        AZ_PROP_GROUP_MEMBERS              AZ_SID_ARRAY - NT sids that are members of this group
        AZ_PROP_GROUP_NON_MEMBERS          AZ_SID_ARRAY - NT sids that are non-members of this group

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_GROUP Group = (PAZP_GROUP) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );


    //
    // Return any object specific attribute
    //
    //
    switch ( PropertyId ) {
    case AZ_PROP_GROUP_TYPE:

        *PropertyValue = AzpGetUlongProperty( Group->GroupType );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    // Return the set of app members to the caller
    case AZ_PROP_GROUP_APP_MEMBERS:

        if ( Flags & AZP_FLAGS_BY_GUID )
        {
            *PropertyValue = ObGetPropertyItemGuids( &Group->AppMembers );
        }
        else
        {
            *PropertyValue = ObGetPropertyItems( &Group->AppMembers );
        }

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    case AZ_PROP_GROUP_APP_NON_MEMBERS:

        if ( Flags & AZP_FLAGS_BY_GUID )
        {
            *PropertyValue = ObGetPropertyItemGuids( &Group->AppNonMembers );
        }
        else
        {
            *PropertyValue = ObGetPropertyItems( &Group->AppNonMembers );
        }

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    // Return the set of sid members to the caller
    case AZ_PROP_GROUP_MEMBERS:

        *PropertyValue = ObGetPropertyItems( &Group->SidMembers );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    case AZ_PROP_GROUP_NON_MEMBERS:

        *PropertyValue = ObGetPropertyItems( &Group->SidNonMembers );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    //
    // Return ldap query string to the caller
    //
    case AZ_PROP_GROUP_LDAP_QUERY:

        *PropertyValue = AzpGetStringProperty( &Group->LdapQuery );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    default:
        AzPrint(( AZD_INVPARM, "AzpGroupGetProperty: invalid opcode %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        break;
    }

    return WinStatus;
}



DWORD
AzpGroupSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    This routine is the Group object specific worker routine for AzSetProperty.
    It does any object specific property sets.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies a pointer to the object to be modified

    Flags - Specifies flags controlling to operation of the routine
        AZP_FLAGS_SETTING_TO_DEFAULT - Property is being set to default value
        AZP_FLAGS_PERSIST_* - Call is from the persistence provider

    PropertyId - Specifies which property to set.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_GROUP_TYPE                 PULONG - Group type of the group
        AZ_PROP_GROUP_LDAP_QUERY           LPWSTR - Ldap query string of the group

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_GROUP Group = (PAZP_GROUP) GenericObject;
    AZP_STRING CapturedString;
    LONG LocalGroupType;

    BOOL bHasChanged = TRUE;

    //
    // Initialization
    //

    UNREFERENCED_PARAMETER( Flags );
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    AzpInitString( &CapturedString, NULL );


    //
    // Set the group type
    //

    switch ( PropertyId ) {
    case AZ_PROP_GROUP_TYPE:

        BEGIN_SETPROP( &WinStatus, Group, Flags, AZ_DIRTY_GROUP_TYPE ) {

            WinStatus = AzpCaptureLong( PropertyValue, &LocalGroupType );

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            //
            // Do parameter validity checking
            //
            BEGIN_VALIDITY_CHECKING( Flags ) {

                //
                // Ensure that changing the group type doesn't orphan any data
                //
                if ( LocalGroupType == AZ_GROUPTYPE_LDAP_QUERY ) {

                    //
                    // An LDAP query group can have no membership links
                    //

                    if ( Group->AppMembers.GenericObjects.UsedCount != 0 ||
                         Group->AppNonMembers.GenericObjects.UsedCount != 0 ||
                         Group->SidMembers.GenericObjects.UsedCount != 0 ||
                         Group->SidNonMembers.GenericObjects.UsedCount != 0 ) {

                        AzPrint(( AZD_INVPARM, "AzpGroupGetProperty: cannot set group type to ldap query if group has membership.\n" ));
                        WinStatus = ERROR_INVALID_PARAMETER;
                        goto Cleanup;

                    }

                } else if ( LocalGroupType == AZ_GROUPTYPE_BASIC ) {

                    //
                    // A basic group can have no LDAP query string
                    //

                    if ( Group->LdapQuery.StringSize != 0 ) {

                        AzPrint(( AZD_INVPARM, "AzpGroupGetProperty: cannot set group type to basic if group has ldap query string.\n" ));
                        WinStatus = ERROR_INVALID_PARAMETER;
                        goto Cleanup;

                    }

                } else {
                    AzPrint(( AZD_INVPARM, "AzpGroupGetProperty: invalid grouptype %ld\n", LocalGroupType ));
                    WinStatus = ERROR_INVALID_PARAMETER;
                    goto Cleanup;

                }

            } END_VALIDITY_CHECKING;

            Group->GroupType = LocalGroupType;

        } END_SETPROP(bHasChanged);
        break;

    //
    // Set LDAP Query string on the object
    //
    case AZ_PROP_GROUP_LDAP_QUERY:

        BEGIN_SETPROP( &WinStatus, Group, Flags, AZ_DIRTY_GROUP_LDAP_QUERY ) {

            //
            // Capture the input string
            //

            WinStatus = AzpCaptureString( &CapturedString,
                                          (LPWSTR) PropertyValue,
                                          CHECK_STRING_LENGTH( Flags, AZ_MAX_GROUP_LDAP_QUERY_LENGTH),
                                          TRUE ); // NULL is OK

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            //
            // Only process the change if the strings have changed
            //

            bHasChanged = !AzpEqualStrings( &CapturedString, &Group->LdapQuery );

            if ( bHasChanged ) {

                //
                // Do parameter validity checking
                //
                BEGIN_VALIDITY_CHECKING( Flags ) {

                    //
                    // Only allow this propery if the group type is right
                    //  (But let them clear it out)
                    //

                    if ( Group->GroupType != AZ_GROUPTYPE_LDAP_QUERY  &&
                         CapturedString.StringSize != 0 ) {

                        AzPrint(( AZD_INVPARM, "AzpGroupSetProperty: can't set ldap query before group type\n" ));
                        WinStatus = ERROR_INVALID_PARAMETER;
                        goto Cleanup;
                    }

                } END_VALIDITY_CHECKING;

                //
                // Swap the old/new names
                //

                AzpSwapStrings( &CapturedString, &Group->LdapQuery );

                //
                // Mark that the group membership caches need flushing
                //

                Group->GenericObject.AzStoreObject->GroupEvalSerialNumber ++;

                AzPrint(( AZD_ACCESS_MORE, "AzpGroupSetProperty: GroupEvalSerialNumber set to %ld\n",
                          Group->GenericObject.AzStoreObject->GroupEvalSerialNumber ));
            }

        } END_SETPROP(bHasChanged);
        break;

    default:
        AzPrint(( AZD_INVPARM, "AzpGroupSetProperty: invalid propid %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Free any local resources
    //
Cleanup:
    AzpFreeString( &CapturedString );

    return WinStatus;
}

DWORD
AzpGroupCheckRefLoop(
    IN PAZP_GROUP ParentGroup,
    IN PAZP_GROUP CurrentGroup,
    IN ULONG GenericObjectListOffset
    )
/*++

Routine Description:

    This routine determines whether the group members of "CurrentGroup"
    reference "ParentGroup".  This is done to detect loops where the
    group references itself directly or indirectly.

    On entry, AzGlResource must be locked shared.

Arguments:

    ParentGroup - Group that contains the original membership.

    CurrentGroup - Group that is currently being inspected to see if it
        loops back to ParentGroup

    GenericObjectListOffset -  Offset to the particular GenericObjectList being
        checked.

Return Value:

    Status of the operation
    ERROR_DS_LOOP_DETECT - A loop has been detected.

--*/
{
    ULONG WinStatus;

    PGENERIC_OBJECT_LIST GenericObjectList;
    ULONG i;
    PAZP_GROUP NextGroup;

    //
    // Check for a reference to ourself
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );
    if ( ParentGroup == CurrentGroup ) {
        return ERROR_DS_LOOP_DETECT;
    }

    //
    // Compute a pointer to the membership list to check
    //

    GenericObjectList = (PGENERIC_OBJECT_LIST)
        (((LPBYTE)CurrentGroup)+GenericObjectListOffset);

    //
    // Check all groups that are members of the current group
    //

    for ( i=0; i<GenericObjectList->GenericObjects.UsedCount; i++ ) {

        NextGroup = (PAZP_GROUP) (GenericObjectList->GenericObjects.Array[i]);


        //
        // Recursively check this group
        //

        WinStatus = AzpGroupCheckRefLoop( ParentGroup, NextGroup, GenericObjectListOffset );

        if ( WinStatus != NO_ERROR ) {
            return WinStatus;
        }

    }

    return NO_ERROR;

}


DWORD
AzpGroupAddPropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PGENERIC_OBJECT LinkedToObject
    )
/*++

Routine Description:

    This routine is the group object specific worker routine for AzAddPropertyItem.
    It does any object specific property adds

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies a pointer to the object to be modified

    GenericObjectList - Specifies the object list the object is to be added to

    LinkedToObject - Specifies the object that is being linked to

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_GROUP Group = (PAZP_GROUP) GenericObject;


    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // All item adds are membership additions.
    //  Ensure the group has the right group type.
    //

    if ( Group->GroupType != AZ_GROUPTYPE_BASIC ) {
        AzPrint(( AZD_INVPARM, "AzpGroupAddPropertyItem: invalid group type %ld\n", Group->GroupType ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // If we're linking to a group,
    //  Ensure this newly added membership doesn't cause a group membership loop
    //

    if ( LinkedToObject->ObjectType == OBJECT_TYPE_GROUP ) {
        WinStatus = AzpGroupCheckRefLoop( Group,
                                          (PAZP_GROUP)LinkedToObject,
                                          (ULONG)(((LPBYTE)GenericObjectList)-((LPBYTE)Group)) );
    }


    //
    // Free any local resources
    //
Cleanup:

    return WinStatus;
}


DWORD
AzpGroupGetGenericChildHead(
    IN AZ_HANDLE ParentHandle,
    OUT PULONG ObjectType,
    OUT PGENERIC_OBJECT_HEAD *GenericChildHead
    )
/*++

Routine Description:

    This routine determines whether ParentHandle supports Group objects as
    children.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the group.
        This may be an authorization store handle, an Application Handle, or a
        Scope handle.

    ObjectType - Returns the object type of the ParentHandle.

    GenericChildHead - Returns a pointer to the head of the list of groups objects
        that are children of the object specified by ParentHandle.  This in an unverified
        pointer.  The pointer is only valid after ParentHandle has been validated.

Return Value:

    Status of the operation.

--*/
{
    DWORD WinStatus;

    //
    // Determine the type of the parent handle
    //

    WinStatus = ObGetHandleType( (PGENERIC_OBJECT)ParentHandle,
                                 FALSE, // ignore deleted objects
                                 ObjectType );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }


    //
    // Verify that the specified handle support children groups.
    //

    switch ( *ObjectType ) {
    case OBJECT_TYPE_AZAUTHSTORE:

        *GenericChildHead = &(((PAZP_AZSTORE)ParentHandle)->Groups);
        break;

    case OBJECT_TYPE_APPLICATION:

        *GenericChildHead = &(((PAZP_APPLICATION)ParentHandle)->Groups);
        break;

    case OBJECT_TYPE_SCOPE:

        *GenericChildHead = &(((PAZP_SCOPE)ParentHandle)->Groups);
        break;

    default:
        return ERROR_INVALID_HANDLE;
    }

    return NO_ERROR;
}



DWORD
WINAPI
AzGroupCreate(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR GroupName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE GroupHandle
    )
/*++

Routine Description:

    This routine adds a group into the scope of the specified parent object.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the group.
        This may be an authorization store handle, an Application Handle, or a
        Scope handle.

    GroupName - Specifies the name of the group to add.

    Reserved - Reserved.  Must by zero.

    GroupHandle - Return a handle to the group.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports groups as children
    //

    WinStatus = AzpGroupGetGenericChildHead( ParentHandle,
                                             &ObjectType,
                                             &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonCreateObject(
                    (PGENERIC_OBJECT) ParentHandle,
                    ObjectType,
                    GenericChildHead,
                    OBJECT_TYPE_GROUP,
                    GroupName,
                    Reserved,
                    (PGENERIC_OBJECT *) GroupHandle );

}



DWORD
WINAPI
AzGroupOpen(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR GroupName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE GroupHandle
    )
/*++

Routine Description:

    This routine opens a group into the scope of the specified parent object.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the group.
        This may be an authorization store handle, an Application Handle, or a
        Scope handle.

    GroupName - Specifies the name of the group to open

    Reserved - Reserved.  Must by zero.

    GroupHandle - Return a handle to the group.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - There is no group by that name

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports groups as children
    //

    WinStatus = AzpGroupGetGenericChildHead( ParentHandle,
                                             &ObjectType,
                                             &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonOpenObject(
            (PGENERIC_OBJECT) ParentHandle,
            ObjectType,
            GenericChildHead,
            OBJECT_TYPE_GROUP,
            GroupName,
            Reserved,
            (PGENERIC_OBJECT *) GroupHandle );
}


DWORD
WINAPI
AzGroupEnum(
    IN AZ_HANDLE ParentHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE GroupHandle
    )
/*++

Routine Description:

    Enumerates all of the groups for the specified parent object.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the group.
        This may be an authorization store handle, an Application Handle, or a
        Scope handle.

    Reserved - Reserved.  Must by zero.

    EnumerationContext - Specifies a context indicating the next group to return
        On input for the first call, should point to zero.
        On input for subsequent calls, should point to the value returned on the previous call.
        On output, returns a value to be passed on the next call.

    GroupHandle - Returns a handle to the next group object.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful (a handle was returned)

    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports groups as children
    //

    WinStatus = AzpGroupGetGenericChildHead( ParentHandle,
                                             &ObjectType,
                                             &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonEnumObjects(
                    (PGENERIC_OBJECT) ParentHandle,
                    ObjectType,
                    GenericChildHead,
                    EnumerationContext,
                    Reserved,
                    (PGENERIC_OBJECT *) GroupHandle );

}


DWORD
WINAPI
AzGroupDelete(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR GroupName,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This routine deletes a group from the scope of the specified parent object.
    Also deletes any child objects of GroupName.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the group.
        This may be an authorization store handle, an Application Handle, or a
        Scope handle.

    GroupName - Specifies the name of the group to delete.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - An object by that name cannot be found

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports groups as children
    //

    WinStatus = AzpGroupGetGenericChildHead( ParentHandle,
                                             &ObjectType,
                                             &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonDeleteObject(
                    (PGENERIC_OBJECT) ParentHandle,
                    ObjectType,
                    GenericChildHead,
                    OBJECT_TYPE_GROUP,
                    GroupName,
                    Reserved );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\op.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    op.cxx

Abstract:

    Routines implementing the Operation object

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/

#include "pch.hxx"

//
// Define the default values for all scalar attributes
//

ULONG AzGlDefOperationId = 0;

AZP_DEFAULT_VALUE AzGlOperationDefaultValues[] = {
    { AZ_PROP_OPERATION_ID, AZ_DIRTY_OPERATION_ID, &AzGlDefOperationId },
    { 0, 0, NULL }
};



DWORD
AzpOperationInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzOperationCreate.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    PAZP_OPERATION Operation = (PAZP_OPERATION) ChildGenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Sanity check the parent
    //

    ASSERT( ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION );
    UNREFERENCED_PARAMETER( ParentGenericObject );

    //
    // Operations are referenced by "Tasks" and "Roles"
    //  Let the generic object manager know all of the lists we support
    //  This is a "back" link so we don't need to define which tasks can reference this operation.
    //

    ChildGenericObject->GenericObjectLists = &Operation->backTasks;

    // Back link to tasks
    ObInitObjectList( &Operation->backTasks,
                      &Operation->backRoles,
                      TRUE, // Backward link
                      0,    // No link pair id
                      0,    // No dirty bit on back link
                      NULL,
                      NULL,
                      NULL );

    // Back link to roles
    ObInitObjectList( &Operation->backRoles,
                      NULL,
                      TRUE, // Backward link
                      0,    // No link pair id
                      0,    // No dirty bit on back link
                      NULL,
                      NULL,
                      NULL );

    return NO_ERROR;
}


VOID
AzpOperationFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for Operation object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    // PAZP_OPERATION Operation = (PAZP_OPERATION) GenericObject;
    UNREFERENCED_PARAMETER( GenericObject );

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Free any local strings
    //


}

DWORD
AzpOperationNameConflict(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PAZP_STRING ChildObjectNameString
    )
/*++

Routine Description:

    This routine is a worker routine to determine if the specified ChildObjectNameString
    conflicts with the names of other objects that share a namespace with Operations.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildObjectNameString - Specifies the name of the child object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    ULONG WinStatus;
    PAZP_APPLICATION Application = (PAZP_APPLICATION) ParentGenericObject;
    PGENERIC_OBJECT ConflictGenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Sanity check the parent
    //

    ASSERT( ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION );

    //
    // Operations and tasks share a namespace so ensure there isn't a task by this name.
    //

    WinStatus = ObReferenceObjectByName( &Application->Tasks,
                                         ChildObjectNameString,
                                         0,     // No special flags
                                         &ConflictGenericObject );

    if ( WinStatus == NO_ERROR ) {
        ObDereferenceObject( ConflictGenericObject );
        return ERROR_ALREADY_EXISTS;
    }

    //
    // Check tasks that are children of child scopes.
    //

    WinStatus = ObCheckNameConflict( &Application->Scopes,
                                     ChildObjectNameString,
                                     offsetof(_AZP_SCOPE, Tasks),
                                     0,
                                     0 );

    return WinStatus;
}

DWORD
AzpOperationGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    This routine is the Group specific worker routine for AzGetProperty.
    It does any object specific property gets.

    On entry, AzGlResource must be locked shared.

Arguments:

    GenericObject - Specifies a pointer to the object to be queried

    Flags - Specifies internal flags
        AZP_FLAGS_BY_GUID - name lists should be returned as GUID lists
        AZP_FLAGS_PERSIST_* - Call is from the persistence provider

    PropertyId - Specifies which property to return.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_OPERATION_ID       PULONG - Operation ID of the operation

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_OPERATION Operation = (PAZP_OPERATION) GenericObject;

    UNREFERENCED_PARAMETER(Flags); //ignore

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );


    //
    // Return any object specific attribute
    //
    //  Return operation id to the caller
    //

    switch ( PropertyId ) {
    case AZ_PROP_OPERATION_ID:

        *PropertyValue = AzpGetUlongProperty( Operation->OperationId );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    default:
        AzPrint(( AZD_INVPARM, "AzpOperationGetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        break;
    }

    return WinStatus;
}


DWORD
AzpOperationSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    This routine is the Operation object specific worker routine for AzSetProperty.
    It does any object specific property sets.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies a pointer to the object to be modified

    Flags - Specifies flags controlling to operation of the routine
        AZP_FLAGS_SETTING_TO_DEFAULT - Property is being set to default value
        AZP_FLAGS_PERSIST_* - Call is from the persistence provider

    PropertyId - Specifies which property to set.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_OPERATION_ID       PULONG - Operation ID of the operation

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus;
    PAZP_OPERATION Operation = (PAZP_OPERATION) GenericObject;
    PAZP_OPERATION ReferencedOperation = NULL;
    LONG TempLong;
    BOOL bHasChanged = TRUE;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Return any object specific attribute
    //
    //  Return ooperation id to the caller
    //

    switch ( PropertyId ) {
    case AZ_PROP_OPERATION_ID:

        BEGIN_SETPROP( &WinStatus, Operation, Flags, AZ_DIRTY_OPERATION_ID ) {
            WinStatus = AzpCaptureLong( PropertyValue, &TempLong );
            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            //
            // Do parameter validity checking
            //
            BEGIN_VALIDITY_CHECKING( Flags ) {

                if ( TempLong < 0) {
                    AzPrint(( AZD_INVPARM, "AzpOperationSetProperty: Operation Id too small %ld\n", TempLong ));
                    WinStatus = ERROR_INVALID_PARAMETER;
                    goto Cleanup;
                }

                //
                // Ensure the operation id doesn't collide with another operation
                //

                WinStatus = AzpReferenceOperationByOpId(
                                (PAZP_APPLICATION)ParentOfChild( GenericObject ),
                                TempLong,
                                FALSE,
                                &ReferencedOperation );

                if ( WinStatus == NO_ERROR ) {

                    if ( ReferencedOperation != Operation ) {
                        AzPrint(( AZD_INVPARM, "AzpOperationSetProperty: Operation ID %ld is already used.\n", TempLong ));
                        WinStatus = ERROR_ALREADY_EXISTS;
                        goto Cleanup;
                    }

                    //
                    // Allow setting our own operation ID back to its original value
                    //

                    WinStatus = ERROR_NOT_FOUND;
                }

                if ( WinStatus != ERROR_NOT_FOUND ) {
                    goto Cleanup;
                }

            } END_VALIDITY_CHECKING;

            //
            // Set the operation ID on the object
            //
            Operation->OperationId = TempLong;
            WinStatus = NO_ERROR;

        } END_SETPROP(bHasChanged);

        break;

    default:
        AzPrint(( AZD_INVPARM, "AzpOperationSetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        break;
    }

Cleanup:
    if ( ReferencedOperation != NULL ) {
        ObDereferenceObject( (PGENERIC_OBJECT)ReferencedOperation );
    }
    return WinStatus;
}


DWORD
AzpReferenceOperationByOpId(
    IN PAZP_APPLICATION Application,
    IN LONG OperationId,
    IN BOOLEAN RefreshCache,
    OUT PAZP_OPERATION *RetOperation
    )
/*++

Routine Description

    This routine finds an operation object by the operationid

    On entry, AzGlResource must be locked shared.

Arguments

    Application - Application that the operation is defined for

    OperationId - Operation id to look for

    RefreshCache - If TRUE, the returned object has its cache entry refreshed from
        the policy database if needed.
        If FALSE, the entry is returned unrefreshed.

    RetOperation - On success, returns a pointer to the operation object
        The returned pointer must be dereferenced using ObDereferenceObject.

Return Value

    NO_ERROR: The object was returned
    ERROR_NOT_FOUND: The object could not be found
    Others: The object could not be refreshed

--*/
{
    DWORD WinStatus;
    PGENERIC_OBJECT GenericObject;
    PAZP_OPERATION Operation;
    PLIST_ENTRY ListEntry;
    PGENERIC_OBJECT_HEAD GenericObjectHead = &Application->Operations;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );
    *RetOperation = NULL;

    //
    // Loop trying to find the object
    //
    // ??? Consider doing a binary search.  That would be possible if we maintained
    //  a separate list sorted by operation id
    //

    for ( ListEntry = GenericObjectHead->Head.Flink ;
          ListEntry != &GenericObjectHead->Head ;
          ListEntry = ListEntry->Flink) {

        GenericObject = CONTAINING_RECORD( ListEntry,
                                           GENERIC_OBJECT,
                                           Next );

        Operation = (PAZP_OPERATION) GenericObject;

        //
        // Ignore deleted objects
        //

        if ( GenericObject->Flags & GENOBJ_FLAGS_DELETED ) {
            continue;
        }

        //
        // If we found the object,
        //  grab a reference.
        //
        if ( Operation->OperationId == OperationId ) {

            //
            // If the caller wants the object to be refreshed,
            //  do so now.
            //

            if ( RefreshCache &&
                 (GenericObject->Flags & GENOBJ_FLAGS_REFRESH_ME) != 0  ) {

                //
                // Need exclusive access
                //

                AzpLockResourceSharedToExclusive( &AzGlResource );

                WinStatus = AzPersistRefresh( GenericObject );

                if ( WinStatus != NO_ERROR ) {
                    return WinStatus;
                }
            }

            //
            // Return the object to the caller
            //

            InterlockedIncrement( &GenericObject->ReferenceCount );
            AzpDumpGoRef( "Ref by operation id", GenericObject );

            *RetOperation = Operation;
            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}



DWORD
WINAPI
AzOperationCreate(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR OperationName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE OperationHandle
    )
/*++

Routine Description:

    This routine adds an operation into the scope of the specified application.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    OperationName - Specifies the name of the operation to add.

    Reserved - Reserved.  Must by zero.

    OperationHandle - Return a handle to the operation.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonCreateObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->Operations),
                    OBJECT_TYPE_OPERATION,
                    OperationName,
                    Reserved,
                    (PGENERIC_OBJECT *) OperationHandle );
}



DWORD
WINAPI
AzOperationOpen(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR OperationName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE OperationHandle
    )
/*++

Routine Description:

    This routine opens an operation into the scope of the specified application.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    OperationName - Specifies the name of the operation to open

    Reserved - Reserved.  Must by zero.

    OperationHandle - Return a handle to the operation.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - There is no operation by that name

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonOpenObject(
        (PGENERIC_OBJECT) ApplicationHandle,
        OBJECT_TYPE_APPLICATION,
        &(((PAZP_APPLICATION)ApplicationHandle)->Operations),
        OBJECT_TYPE_OPERATION,
        OperationName,
        Reserved,
        (PGENERIC_OBJECT *) OperationHandle );
}


DWORD
WINAPI
AzOperationEnum(
    IN AZ_HANDLE ApplicationHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE OperationHandle
    )
/*++

Routine Description:

    Enumerates all of the operations for the specified application.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    Reserved - Reserved.  Must by zero.

    EnumerationContext - Specifies a context indicating the next operation to return
        On input for the first call, should point to zero.
        On input for subsequent calls, should point to the value returned on the previous call.
        On output, returns a value to be passed on the next call.

    OperationHandle - Returns a handle to the next operation object.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful (a handle was returned)

    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonEnumObjects(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->Operations),
                    EnumerationContext,
                    Reserved,
                    (PGENERIC_OBJECT *) OperationHandle );

}


DWORD
WINAPI
AzOperationDelete(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR OperationName,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This routine deletes an operation from the scope of the specified application.
    Also deletes any child objects of OperationName.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    OperationName - Specifies the name of the operation to delete.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - An object by that name cannot be found

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonDeleteObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->Operations),
                    OBJECT_TYPE_OPERATION,
                    OperationName,
                    Reserved );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\objects.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    objects.h

Abstract:

    Definitions for the sundry objects implemented by azroles


Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

Revision History:

    20-Aug-2001 chaitu

        Added critical section serialization for LDAP

    6-Oct-2001

        Added private variables to AzApplication and AzScope
        to temporarily store GUIDized CN for AD store

--*/


#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////////////
//
// Structure definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// An Authorization Store
//

typedef struct _AZP_AZSTORE {

    //
    // All objects are a generic objects
    //

    GENERIC_OBJECT GenericObject;

    //
    // Define objects that can be children of this AuthorizationStore
    //

    GENERIC_OBJECT_HEAD Applications;
    GENERIC_OBJECT_HEAD Groups;

    //
    // Identifies the persistence provider
    //

    PAZPE_PROVIDER_INFO ProviderInfo;

    //
    // This context identifies the instance of the persistence provider.
    //

    AZPE_PERSIST_CONTEXT PersistContext;
    HMODULE ProviderDll;

    //
    // Policy type/URL
    //

    AZP_STRING PolicyUrl;

    //
    // target machine name for the policy URL
    //

    AZP_STRING TargetMachine;

    //
    // Persistence engine operations are serialized by PersistCritSect
    //

    SAFE_CRITICAL_SECTION  PersistCritSect;
    BOOLEAN                PersistCritSectInitialized;

    //
    // List of NEW_OBJECT_NAME structs.
    //  (See the comment on NEW_OBJECT_NAME)
    //

    LIST_ENTRY NewNames;

    //
    // Domain Timeout.
    //  These variables represent our ability to cache the fact that a DC is down in a domain.
    //  Access to all variables are serialized by DomainCritSect.
    //

    SAFE_CRITICAL_SECTION DomainCritSect;
    BOOLEAN DomainCritSectInitialized;

    //
    // Time (in milliseconds) after a domain is detected to be unreachable before we'll attempt
    // to contact a DC again.
    //

    LONG DomainTimeout;

    //
    // List of domains we've used.
    //

    LIST_ENTRY Domains;

    //
    // List of Free scripts in LRU order
    //  Access serialized by FreeScriptCritSect

    LIST_ENTRY LruFreeScriptHead;
    LONG LruFreeScriptCount;

    SAFE_CRITICAL_SECTION FreeScriptCritSect;
    BOOLEAN FreeScriptCritSectInitialized;

    //
    // Maximum number of script engines that can be cached at one time
    //

    LONG MaxScriptEngines;

    //
    // Time (in milliseconds) that a script is allowed to run before being automatically
    // terminated.
    //

    LONG ScriptEngineTimeout;
    HANDLE ScriptEngineTimerQueue;


    //
    // Count of the number of times group evaluation has been flushed
    //

    ULONG GroupEvalSerialNumber;

    //
    // Count of the number of times the operation cache has been flushed
    //

    ULONG OpCacheSerialNumber;

    //
    // Audit related structures.
    //

    //
    //  TRUE if a user has SE_SECURITY_PRIVILEGE
    //

    BOOLEAN HasSecurityPrivilege;

    // Audit handles for different audit types.
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hClientContextCreateAuditEventType;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hClientContextDeleteAuditEventType;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAccessCheckAuditEventType;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hApplicationInitializationAuditEventType;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hClientContextCreateNameAuditEventType;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hClientContextDeleteNameAuditEventType;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAccessCheckNameAuditEventType;

    //
    // Version numbers
    //

    ULONG MajorVersion;
    ULONG MinorVersion;

    //
    // Initialize flag
    //

    ULONG InitializeFlag;

    //
    // TRUE if the provider supports lazy load for children
    //

    BOOLEAN ChildLazyLoadSupported;

} AZP_AZSTORE, *PAZP_AZSTORE;

//
// An Application
//

typedef struct _AZP_APPLICATION {

    //
    // All objects are a generic objects
    //

    GENERIC_OBJECT GenericObject;

    //
    // Attributes from the external definition of the object
    //

    AZP_STRING AuthzInterfaceClsid;
    AZP_STRING AppVersion;

    //
    // Define objects that can be children of this application
    //

    GENERIC_OBJECT_HEAD Operations;
    GENERIC_OBJECT_HEAD Tasks;
    GENERIC_OBJECT_HEAD Scopes;
    GENERIC_OBJECT_HEAD Groups;
    GENERIC_OBJECT_HEAD Roles;
    GENERIC_OBJECT_HEAD ClientContexts;

    //
    // An application is known as a resource manager to the authz code
    //

    AUTHZ_RESOURCE_MANAGER_HANDLE AuthzResourceManager;


    //
    // Application instace Luid.
    //

    LUID InstanceId;

    //
    // Boolean to indicate if the application object needs to be unloaded
    // from the cache, i.e., its children removed from cache.  The application
    // object will continue to reside in the cache for enumeration purposes
    //

    BOOLEAN UnloadApplicationObject;

    //
    // A sequence number needed to check if a COM handle to this object is
    // valid after the application object has been closed
    //

    DWORD AppSequenceNumber;


} AZP_APPLICATION, *PAZP_APPLICATION;

//
// An Operation
//

typedef struct _AZP_OPERATION {

    //
    // All objects are generic objects
    //

    GENERIC_OBJECT GenericObject;

    //
    // Attributes from the external definition of the object
    //

    LONG OperationId;

    //
    // An Operation object is referenced by Tasks objects and Role objects
    //

    GENERIC_OBJECT_LIST backTasks;
    GENERIC_OBJECT_LIST backRoles;


} AZP_OPERATION, *PAZP_OPERATION;

//
// A Task
//

typedef struct _AZP_TASK {

    //
    // All objects are generic objects
    //

    GENERIC_OBJECT GenericObject;

    //
    // Attributes from the external definition of the object
    //

    AZP_STRING BizRule; // Modification serialized by RunningScriptCritSect
    AZP_STRING BizRuleLanguage;
    CLSID BizRuleLanguageClsid;  //The CLSID corresponding to BizRuleLanguage
    AZP_STRING BizRuleImportedPath;
    LONG IsRoleDefinition;

    //
    // A Task object references a list of Operation objects
    //

    GENERIC_OBJECT_LIST Operations;

    //
    // An Task object is referenced by Role objects
    //

    GENERIC_OBJECT_LIST backRoles;

    //
    // An Task object references other task objects
    //

    GENERIC_OBJECT_LIST Tasks;
    GENERIC_OBJECT_LIST backTasks;

    //
    // Maintain a list of free script engines for running the bizrule
    //  Access serialized by AzAuthorizationStore->FreeScriptCritSect
    //

    LIST_ENTRY FreeScriptHead;

    //
    // Maintain a cache of running script engines
    //

    SAFE_CRITICAL_SECTION RunningScriptCritSect;
    BOOLEAN RunningScriptCritSectInitialized;

    LIST_ENTRY RunningScriptHead;
    ULONG BizRuleSerialNumber;  // Access serialized by RunningScriptCritSect


} AZP_TASK, *PAZP_TASK;

//
// A Scope
//

typedef struct _AZP_SCOPE {

    //
    // All objects are generic objects
    //

    GENERIC_OBJECT GenericObject;

    //
    // Attributes from the external definition of the object
    //


    //
    // Roles defined for this scope
    //

    GENERIC_OBJECT_HEAD Tasks;
    GENERIC_OBJECT_HEAD Groups;
    GENERIC_OBJECT_HEAD Roles;


} AZP_SCOPE, *PAZP_SCOPE;

//
// A Group
//

typedef struct _AZP_GROUP {

    //
    // All objects are generic objects
    //

    GENERIC_OBJECT GenericObject;

    //
    // Attributes from the external definition of the object
    //

    LONG GroupType;
    AZP_STRING LdapQuery;


    //
    // A Group object references a list of Group objects as members and non members
    //

    GENERIC_OBJECT_LIST AppMembers;
    GENERIC_OBJECT_LIST AppNonMembers;

    GENERIC_OBJECT_LIST backAppMembers;
    GENERIC_OBJECT_LIST backAppNonMembers;


    //
    // A Group object is referenced by Role objects
    //
    GENERIC_OBJECT_LIST backRoles;

    //
    // A Group object references a list of Sid objects as members and non members
    //

    GENERIC_OBJECT_LIST SidMembers;
    GENERIC_OBJECT_LIST SidNonMembers;

} AZP_GROUP, *PAZP_GROUP;

//
// A Role
//

typedef struct _AZP_ROLE {

    //
    // All objects are generic objects
    //

    GENERIC_OBJECT GenericObject;

    //
    // Attributes from the external definition of the object
    //


    //
    // A Role object references a list of Group objects, a list of operation objects,
    //  and a list of task objects.
    //
    //

    GENERIC_OBJECT_LIST AppMembers;
    GENERIC_OBJECT_LIST Operations;
    GENERIC_OBJECT_LIST Tasks;

    //
    // A Role object references a list of Sid objects as members
    //

    GENERIC_OBJECT_LIST SidMembers;


} AZP_ROLE, *PAZP_ROLE;

//
// A Sid.
//
//  A Sid object is a pseudo-object.  It really doesn't exist from any external
//  interface.  It exists simply as a holder of back-references to real objects
//  that contain lists of sids
//

typedef struct _AZP_SID {

    //
    // All objects are generic objects
    //
    // Note that the "ObjectName" of the generic object is really a binary SID.
    //

    GENERIC_OBJECT GenericObject;

    //
    // A Sid is referenced by Group objects and Role Objects
    //

    GENERIC_OBJECT_LIST backGroupMembers;
    GENERIC_OBJECT_LIST backGroupNonMembers;

    GENERIC_OBJECT_LIST backRoles;

    GENERIC_OBJECT_LIST backAdmins;
    GENERIC_OBJECT_LIST backReaders;

    GENERIC_OBJECT_LIST backDelegatedPolicyUsers;

} AZP_SID, *PAZP_SID;

//
// A Client Context
//
//  A client context object is a pseudo-object.  It is not persisted.
//

typedef struct _AZP_CLIENT_CONTEXT {

    //
    // All objects are generic objects
    //
    // Note that the "ObjectName" of the generic object is empty
    //

    GENERIC_OBJECT GenericObject;

    //
    // A ClientContext is referenced by Application objects
    //

    GENERIC_OBJECT_LIST backApplications;

    //
    // The client context is typically accessed with the AzGlResource locked shared.
    //  That allows multiple access check operations to be performed simultaneously.
    //  This crit sect protects the field of the client context.
    //

    SAFE_CRITICAL_SECTION CritSect;
    BOOLEAN CritSectInitialized;

    //
    // A client context has an underlying authz context
    //
    // This field is only modified during ClientContext creation and deletion.  Both
    // of which happen with AzGlResource locked exclusively.  So, references to this field
    // are allowed anytime the GenericObject.ReferenceCount is incremented.
    //

    AUTHZ_CLIENT_CONTEXT_HANDLE AuthzClientContext;


    //
    // Creation routine for the client context.
    // We only have two creation routines right now.
    //     FromToken
    //     FromName
    //

#define AZP_CONTEXT_CREATED_FROM_TOKEN 0x1
#define AZP_CONTEXT_CREATED_FROM_NAME  0x2
#define AZP_CONTEXT_CREATED_FROM_SID   0x4

    DWORD  CreationType;


    //
    // The token handle of the client.
    //  If the client has no token, this value is INVALID_TOKEN_HANDLE.
    //
    // This field is only modified during ClientContext creation and deletion.  Both
    // of which happen with AzGlResource locked exclusively.  So, references to this field
    // are allowed anytime the GenericObject.ReferenceCount is incremented.
    // This has a valid handle if the CreationType is AZP_CONTEXT_CREATED_FROM_TOKEN.
    //

    HANDLE TokenHandle;

    //
    // The (Domain, Client) pair to represent the client.
    // This has valid strings if CreationType is AZP_CONTEXT_CREATED_FROM_NAME.
    //

    LPWSTR DomainName;
    LPWSTR ClientName;
    UCHAR SidBuffer[SECURITY_MAX_SID_SIZE];


    //
    // The DN of the account representing the user sid
    //  Access to this field is serialized by ClientContext->CritSect.
    //

    LPWSTR AccountDn;


    //
    // The Domain handle of the account domain for the user account.
    //  If the Domain is NULL, either the domain isn't known or the domain doesn't
    //  support LDAP (because either the domain is an NT 4.0 (or older) domain or the account
    //  is a local account).  Check the LdapNotSupported boolean to differentiate.
    //
    //  Access to these fields are serialized by ClientContext->CritSect.
    //

    PVOID Domain;
    BOOLEAN LdapNotSupported;


    //
    // List of our status' for evaluating membership in app groups
    //  Access to this field is serialized by ClientContext->CritSect.
    //

    LIST_ENTRY MemEval;

    //
    // Count of the number of times group evaluation has been flushed
    //

    ULONG GroupEvalSerialNumber;

    //
    // Count of the number of times the operation cache has been flushed
    //

    ULONG OpCacheSerialNumber;

    //
    // Cache of operations that have already been Access Checked
    //

    RTL_GENERIC_TABLE OperationCacheAvlTree;

    //
    // Parameters to pass to Bizrules
    //  See AzContextAccessCheck parameters for descriptions
    //
    //  This copy of the parameters was captured from the most recent AccessCheck.
    //  It is used on the next AccessCheck to determine whether cached results
    //  can be used.  Currently it is only used for the OperationCacheAvlTree.
    //  In the future, it may be used for the MemEval cache when ldap query groups
    //  become parameterized.
    //
    // These arrays are sparse.  The UsedParameterNames type is VT_EMPTY for unused parameters
    //
    VARIANT *UsedParameterNames;
    VARIANT *UsedParameterValues;
    ULONG UsedParameterCount;

    //
    // Logon Id of the client token. This is needed for generating audits.
    //

    LUID LogonId;

    //
    // role name (if specified by client) for access check
    //
    AZP_STRING RoleName;

} AZP_CLIENT_CONTEXT, *PAZP_CLIENT_CONTEXT;


/////////////////////////////////////////////////////////////////////////////
//
// Global definitions
//
/////////////////////////////////////////////////////////////////////////////

extern SAFE_RESOURCE AzGlCloseApplication;
extern SAFE_RESOURCE AzGlResource;
extern GUID AzGlZeroGuid;


/////////////////////////////////////////////////////////////////////////////
//
// Procedure definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// Init functions for the various specific objects
//

DWORD
AzpAzStoreInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

DWORD
AzpApplicationInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

DWORD
AzpOperationInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

DWORD
AzpTaskInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

DWORD
AzpScopeInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

DWORD
AzpGroupInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

DWORD
AzpRoleInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

DWORD
AzpSidInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

DWORD
AzpClientContextInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

//
// NameConflict routines for the specific objects
//

DWORD
AzpOperationNameConflict(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PAZP_STRING ChildObjectNameString
    );

DWORD
AzpTaskNameConflict(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PAZP_STRING ChildObjectNameString
    );

DWORD
AzpGroupNameConflict(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PAZP_STRING ChildObjectNameString
    );

DWORD
AzpRoleNameConflict(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PAZP_STRING ChildObjectNameString
    );


//
// Get/Set property functions for the specific objects
//

DWORD
AzpAzStoreGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

DWORD
AzpAzStoreSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    );

DWORD
AzpApplicationGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

DWORD
AzpApplicationSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    );

DWORD
AzpOperationGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

DWORD
AzpOperationSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    );

DWORD
AzpTaskGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

DWORD
AzpTaskSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    );

DWORD
AzpGroupGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

DWORD
AzpScopeGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

DWORD
AzpGroupSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    );

DWORD
AzpClientContextSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    );

DWORD
AzpTaskAddPropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PGENERIC_OBJECT LinkedToObject
    );

DWORD
AzpGroupAddPropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PGENERIC_OBJECT LinkedToObject
    );

DWORD
AzpRoleGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

DWORD
AzpRoleAddPropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN AZP_STRING ObjectName
    );

DWORD
AzpClientContextGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

//
// Free routines for the various object types
//

VOID
AzpAzStoreFree(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
AzpApplicationFree(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
AzpOperationFree(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
AzpTaskFree(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
AzpScopeFree(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
AzpGroupFree(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
AzpRoleFree(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
AzpSidFree(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
AzpClientContextFree(
    IN PGENERIC_OBJECT GenericObject
    );

//
// Other object specific functions
//

DWORD
AzpReferenceOperationByOpId(
    IN PAZP_APPLICATION Application,
    IN LONG OperationId,
    IN BOOLEAN RefreshCache,
    OUT PAZP_OPERATION *RetOperation
    );

BOOL
AzpOpenToManageStore (
    IN PAZP_AZSTORE pAzStore
    );

//
// Object specific default value arrays
//

extern AZP_DEFAULT_VALUE AzGlAzStoreDefaultValues[];
extern AZP_DEFAULT_VALUE AzGlApplicationDefaultValues[];
extern AZP_DEFAULT_VALUE AzGlOperationDefaultValues[];
extern AZP_DEFAULT_VALUE AzGlTaskDefaultValues[];
extern AZP_DEFAULT_VALUE AzGlGroupDefaultValues[];

//
// Procedures from domain.cxx
//

typedef struct _AZP_DC {

    //
    // Reference count for this structure
    //

    LONG ReferenceCount;

    //
    // Name of the DC
    //

    AZP_STRING DcName;

    //
    // Ldap Handle to the DC
    //

    LDAP *LdapHandle;

} AZP_DC, *PAZP_DC;

PVOID
AzpReferenceDomain(
    IN PAZP_AZSTORE AzAuthorizationStore,
    IN LPWSTR DomainName,
    IN BOOLEAN IsDnsDomainName
    );

VOID
AzpDereferenceDomain(
    IN PVOID DomainHandle
    );

VOID
AzpUnlinkDomains(
    IN PAZP_AZSTORE AzAuthorizationStore
    );

DWORD
AzpLdapErrorToWin32Error(
    IN ULONG LdapStatus
    );

DWORD
AzpGetDc(
    IN PAZP_AZSTORE AzAuthorizationStore,
    IN PVOID DomainHandle,
    IN OUT PULONG Context,
    OUT PAZP_DC *RetDc
    );

VOID
AzpDereferenceDc(
    IN PAZP_DC Dc
    );


//
// These are the current major and minor versions for authorization store
//

extern ULONG AzGlCurrAzRolesMajorVersion;
extern ULONG AzGlCurrAzRolesMinorVersion;

//
// version control routine. Here are the rules:
//   MajorVersion (DWORD) - Specifies the major version of the azroles.dll
//   that wrote this policy.  An azroles.dll with an older major version
//   number cannot read nor write a database with a newer major version number.
//   The version 1 value of this DWORD is 1.  We hope to never have to
//   change this value in future releases.
//
//   MinorVersion (DWORD) - Specifies the minor version of the azroles.dll
//   that wrote this policy.  An azroles.dll with an older minor version
//   number can read but cannot write a database with a newer minor version number.
//   The version 1 value of this DWORD is 0.
//

BOOL AzpAzStoreVersionAllowWrite(
    IN PAZP_AZSTORE AzAuthorizationStore
    );

DWORD AzpScopeCanBeDelegated(
    IN PGENERIC_OBJECT  GenericObject,
    IN BOOL bLockedShared
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by azroles.rc
//
#define IDS_PROJNAME                    100
#define IDR_AZSTORE                     101
#define IDR_AZBIZRULECONTEXT            117


// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\persist.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    persist.h

Abstract:

    Routines implementing the common logic for persisting the authz policy.

    This file contains routine called by the core logic to submit changes.
    It also contains routines that are called by the particular providers to
    find out information about the changed objects.

Author:

    Cliff Van Dyke (cliffv) 9-May-2001

--*/


/////////////////////////////////////////////////////////////////////////////
//
// Procedure definitions
//
/////////////////////////////////////////////////////////////////////////////

#ifdef _AZROLESAPI_
//
// Procedures that simply route to the providers
//

DWORD
AzPersistOpen(
    IN PAZP_AZSTORE AzAuthorizationStore,
    IN BOOL CreatePolicy
    );

VOID
AzPersistClose(
    IN PAZP_AZSTORE AzAuthorizationStore
    );

DWORD
AzPersistSubmit(
    IN PGENERIC_OBJECT GenericObject,
    IN BOOLEAN DeleteMe
    );

VOID
AzPersistAbort(
    IN PGENERIC_OBJECT GenericObject
    );

DWORD
AzPersistUpdateCache(
    IN PAZP_AZSTORE AzAuthorizationStore
    );

DWORD
AzPersistUpdateChildrenCache(
    IN OUT PGENERIC_OBJECT GenericObject
    );

DWORD
AzPersistRefresh(
    IN PGENERIC_OBJECT GenericObject
    );

//
// Some of the Azpe* routines are used by the core.  Define those here.
//

DWORD
WINAPI
AzpeAddPropertyItemSid(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG PropertyId,
    IN PSID Sid
    );

VOID
WINAPI
AzpeFreeMemory(
    IN PVOID Buffer
    );
    
BOOL
WINAPI
AzpAzStoreIsBatchUpdateMode(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );
    
AZPE_OBJECT_HANDLE
WINAPI
AzpeGetAuthorizationStore(
    IN AZPE_OBJECT_HANDLE hObject
    );
    
#endif // _AZROLESAPI_

//
// Externs exported from the internal providers
//
// These are the only interfaces to the internal providers.  That makes them
//  equivalent to the loaded providers.
//

#define AZ_XML_PROVIDER_NAME L"MSXML"
#define AZ_XML_PROVIDER_NAME_LENGTH 5
DWORD
WINAPI
XmlProviderInitialize(
    IN PAZPE_AZROLES_INFO AzrolesInfo,
    OUT PAZPE_PROVIDER_INFO *ProviderInfo
    );

#define AZ_AD_PROVIDER_NAME L"MSLDAP"
DWORD
WINAPI
AdProviderInitialize(
    IN PAZPE_AZROLES_INFO AzrolesInfo,
    OUT PAZPE_PROVIDER_INFO *ProviderInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\persist.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    persist.cxx

Abstract:

    Routines implementing the common logic for persisting the authz policy.

    This file contains routine called by the core logic to submit changes.
    It also contains routines that are called by the particular providers to
    find out information about the changed objects.

Author:

    Cliff Van Dyke (cliffv) 9-May-2001

--*/

#include "pch.hxx"

DWORD
WINAPI
AzpeCreateObject(
    IN AZPE_OBJECT_HANDLE AzpeParentHandle,
    IN ULONG ChildObjectType,
    IN LPCWSTR ChildObjectNameString,
    IN GUID *ChildObjectGuid OPTIONAL,
    IN ULONG lPersistFlags,
    OUT AZPE_OBJECT_HANDLE *AzpeChildHandle
    );

VOID
WINAPI
AzpeObjectFinished(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN DWORD WinStatus
    );

DWORD
WINAPI
AzpeGetProperty(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

DWORD
WINAPI
AzpeGetDeltaArray(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG PropertyId,
    OUT PULONG DeltaArrayCount,
    OUT PAZP_DELTA_ENTRY **DeltaArray
    );

DWORD
WINAPI
AzpeGetSecurityDescriptorFromCache(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN PAZP_POLICY_USER_RIGHTS *ppPolicyAdminRights OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS *ppPolicyReaderRights OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS *ppDelegatedPolicyUsersRights OPTIONAL,
    IN GUID *pDelegatedObjectGuid OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS pDelegatedUsersAttributeRights OPTIONAL,
    IN GUID *pAttributeGuid OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS pSaclRights OPTIONAL,
    IN PSECURITY_DESCRIPTOR OldSd OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewSd
    );

//
// Routines to return a single field of an object
//

DWORD
WINAPI
AzpeObjectType(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

DWORD
WINAPI
AzpeDirtyBits(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

GUID *
WINAPI
AzpePersistenceGuid(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

AZPE_OBJECT_HANDLE
WINAPI
AzpeParentOfChild(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

BOOLEAN
WINAPI
AzpeIsParentWritable(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

BOOLEAN
WINAPI
AzpeUpdateChildren(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

BOOLEAN
WINAPI
AzpeCanCreateChildren(
    IN AZPE_OBJECT_HANDLE AzpeCanCreateChildren
    );

//
// Routines to change an object
//

DWORD
WINAPI
AzpeSetProperty(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    );

DWORD
WINAPI
AzpeSetObjectOptions(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG ObjectOptions
    );

DWORD
WINAPI
AzpeAddPropertyItemGuid(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG PropertyId,
    IN GUID *ObjectGuid
    );

DWORD
WINAPI
AzpeAddPropertyItemGuidString(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG PropertyId,
    IN WCHAR *ObjectGuidString
    );

VOID
WINAPI
AzpeSetProviderData(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN PVOID ProviderData
    );

PVOID
WINAPI
AzpeGetProviderData(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

DWORD
WINAPI
AzpeSetSecurityDescriptorIntoCache(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN PSECURITY_DESCRIPTOR pSD,
    IN ULONG lPersistFlags,
    IN PAZP_POLICY_USER_RIGHTS pAdminRights,
    IN PAZP_POLICY_USER_RIGHTS pReadersRights,
    IN PAZP_POLICY_USER_RIGHTS pDelegatedUserRights OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS pSaclRights OPTIONAL
    );

PVOID
WINAPI
AzpeAllocateMemory(
     IN SIZE_T Size
     );

VOID
WINAPI
AzpeFreeMemory (
    IN PVOID Buffer
    );

BOOLEAN
WINAPI
AzpeIsParentWritable(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );
    
BOOLEAN
WINAPI
AzpeUpdateChildren(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );

BOOLEAN
WINAPI
AzpeCanCreateChildren(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    );
    
BOOL
WINAPI
AzpeAzStoreIsBatchUpdateMode(
    IN AZPE_OBJECT_HANDLE hObject
    );
    
AZPE_OBJECT_HANDLE
WINAPI
AzpeGetAuthorizationStore(
    IN AZPE_OBJECT_HANDLE hObject
    );
    
//
// Define the Azrole info structure to pass to the providers
//

AZPE_AZROLES_INFO AzGlAzrolesInfo = {
    AZPE_AZROLES_INFO_VERSION_2,

    //
    // Routines exported by azroles to the provider
    //

    AzpeCreateObject,
    AzpeObjectFinished,
    AzpeGetProperty,
    AzpeGetDeltaArray,
    AzpeGetSecurityDescriptorFromCache,
    AzpeObjectType,
    AzpeDirtyBits,
    AzpePersistenceGuid,
    AzpeParentOfChild,
    AzpeSetProperty,
    AzpeSetObjectOptions,
    AzpeAddPropertyItemSid,
    AzpeAddPropertyItemGuid,
    AzpeAddPropertyItemGuidString,
    AzpeSetProviderData,
    AzpeGetProviderData,
    AzpeSetSecurityDescriptorIntoCache,
    AzpeAllocateMemory,
    AzpeFreeMemory,
    //
    // These routines available for Version 2 and higher only
    //

    AzpeIsParentWritable,
    AzpeUpdateChildren,
    AzpeCanCreateChildren,
    AzpeAzStoreIsBatchUpdateMode,
    AzpeGetAuthorizationStore

};


//
// The enumeration context describes the current state of an enumeration
// through the list of all the objects in the authz policy database
//

typedef struct _AZP_PERSIST_ENUM_CONTEXT {

    //
    // Stack Index
    //  The enumeration walks the tree of objects. While enumerating child objects,
    //  the context of the parent object enumeration is kept on the stack of contexts.
    //

    LONG StackIndex;
#define AZ_PERSIST_MAX_INDEX 4

    //
    // Object to return on the first call to AzpPersistEnumNext
    //
    PGENERIC_OBJECT GenericObject;


    //
    // Pointer to the current Generic Child Head being enumerated
    //
    PGENERIC_OBJECT_HEAD GenericChildHead[AZ_PERSIST_MAX_INDEX];
    ULONG EnumerationContext[AZ_PERSIST_MAX_INDEX];

    //
    // Variables for remembering the last object that was returned
    //  These are maintained to allow us to detect if that object was deleted.
    //

    PGENERIC_OBJECT PreviousObject;
    PGENERIC_OBJECT_HEAD PreviousGenericChildHead;
    ULONG PreviousEnumContext;

} AZP_PERSIST_ENUM_CONTEXT, *PAZP_PERSIST_ENUM_CONTEXT;

DWORD
AzpPersistEnumOpen(
    IN PGENERIC_OBJECT GenericObject,
    OUT PVOID *PersistEnumContext
    )
/*++

Routine Description:

    This routine begins an enumeration of the objects in the authz policy database from
    GenericObject

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies the object that is being queried

    PersistEnumContext - Returns a context that can be passed to AzpPersistEnumNext.
        This context must be closed by calling AzPersistClose.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    PAZP_PERSIST_ENUM_CONTEXT Context = NULL;

    //
    // Allocate memory for the context
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    Context = (PAZP_PERSIST_ENUM_CONTEXT) AzpAllocateHeap( sizeof(*Context), "PEENUMCX" );

    if ( Context == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory( Context, sizeof(*Context) );

    //
    // Initialize it
    //

    Context->GenericObject = GenericObject;
    Context->StackIndex = -1;

    //
    // Return the context to the caller
    //

    *PersistEnumContext = Context;
    return NO_ERROR;

}

DWORD
AzpPersistEnumNext(
    IN PVOID PersistEnumContext,
    OUT PGENERIC_OBJECT *GenericObject
    )
/*++

Routine Description:

    This routine returns the next object in the list of all objects in the authz policy database.

    The caller may feel free to delete the returned object and its children.  However,
    the caller should not delete any other objects.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    PersistEnumContext - A context describing the current state of the enumeration

    GenericObject - Returns a pointer to an next object.
        There is no reference on this object

Return Value:

    NO_ERROR - The operation was successful (a GenericObject was returned)
    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

    Other status codes

--*/
{
    DWORD WinStatus;
    PGENERIC_OBJECT PreviousObject = NULL;

    PAZP_PERSIST_ENUM_CONTEXT Context = (PAZP_PERSIST_ENUM_CONTEXT) PersistEnumContext;

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // If this is the first call,
    //  return the AzAuthorizationStore itself.
    //

    if ( Context->PreviousObject == NULL ) {
        *GenericObject = Context->GenericObject;
        Context->PreviousObject = *GenericObject;
        Context->PreviousGenericChildHead = NULL;
        Context->PreviousEnumContext = NULL;
        return NO_ERROR;
    }

    //
    // Detect if the previously returned object was deleted by the caller
    //

    if ( Context->PreviousGenericChildHead == NULL ) {
        PreviousObject = Context->GenericObject;
    } else {

        WinStatus = ObEnumObjects( Context->PreviousGenericChildHead,
                                   TRUE, // return deleted objects
                                   FALSE, // Don't refresh the cache
                                   &Context->PreviousEnumContext,
                                   &PreviousObject );

        if ( WinStatus != NO_ERROR ) {
            if ( WinStatus != ERROR_NO_MORE_ITEMS ) {
                return WinStatus;
            }
            PreviousObject = NULL;
        }
    }

    //
    // If the previously returned object wasn't deleted by the caller,
    //  process its children.
    //

    if ( Context->PreviousObject == PreviousObject ) {

        //
        // Only push onto the stack if the current object can have children
        //

        if ( Context->PreviousObject->ChildGenericObjectHead != NULL ) {

            if ( Context->StackIndex+1 >= AZ_PERSIST_MAX_INDEX ) {
                ASSERT(FALSE);
                return ERROR_INTERNAL_ERROR;
            }

            Context->StackIndex++;
            Context->GenericChildHead[Context->StackIndex] = Context->PreviousObject->ChildGenericObjectHead;
            Context->EnumerationContext[Context->StackIndex] = 0;
        }
    }

    //
    // Loop until we find another object to return
    //

    for (;;) {

        //
        // Don't return pseudo objects to the caller.
        //

        if ( Context->GenericChildHead[Context->StackIndex]->ObjectType != OBJECT_TYPE_SID ) {
            ULONG PreviousEnumContext;

            //
            // Get the next object from the current list
            //

            PreviousEnumContext = Context->EnumerationContext[Context->StackIndex];

            WinStatus = ObEnumObjects( Context->GenericChildHead[Context->StackIndex],
                                       TRUE, // return deleted objects
                                       FALSE, // Don't refresh the cache
                                       &Context->EnumerationContext[Context->StackIndex],
                                       GenericObject );

            //
            // If that worked,
            //  remember the object that was found and return it to the caller
            //
            if ( WinStatus == NO_ERROR ) {
                Context->PreviousObject = *GenericObject;
                Context->PreviousGenericChildHead = Context->GenericChildHead[Context->StackIndex];
                Context->PreviousEnumContext = PreviousEnumContext;
                return NO_ERROR;
            }
            if ( WinStatus != ERROR_NO_MORE_ITEMS ) {
                return WinStatus;
            }
        }

        //
        // Move on to the next set of sibling object types.
        //

        Context->EnumerationContext[Context->StackIndex] = 0;
        if ( Context->GenericChildHead[Context->StackIndex]->SiblingGenericObjectHead != NULL ) {
            Context->GenericChildHead[Context->StackIndex] = Context->GenericChildHead[Context->StackIndex]->SiblingGenericObjectHead;
            continue;
        }

        //
        // There are no more sibling object types for the same parent.
        // Continue the enumeration of the parent objects
        //

        if ( Context->StackIndex == 0 ) {
            return ERROR_NO_MORE_ITEMS;
        }

        Context->StackIndex--;

    }
}

VOID
AzpPersistEnumClose(
    IN PVOID PersistEnumContext
    )
/*++

Routine Description:

    This routine returns free any resources consumed by the PersistEnumContext.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    PersistEnumContext - A context describing the current state of the enumeration

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    AzpFreeHeap( PersistEnumContext );
}

//
// Operation being reconciled
//

typedef enum _RECONCILE_TYPE {
    IsOpen,             // AzPersistOpen
    PreUpdateCache,     // AzPersistUpdateCache (prior to calling provider), AzPersistUpdateChildrenCache
    IsUpdateCache,      // AzPersistUpdateCache
    IsUpdateChildCache, // AzPersisUpdateChildrenCache
    IsRefresh           // AzPersistRefresh
} RECONCILE_TYPE, *PRECONCILE_TYPE;

DWORD
AzpPersistReconcileDeltaArray(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN RECONCILE_TYPE ReconType
    )
/*++

Routine Description:


    Implements AzpPersistReconcile for a single generic object list

    On entry, AzGlResource must be locked exclusive.
        PersistCritSect must be locked. (unless this is a refresh)

Arguments:

    GenericObject - Specifies the object in the cache that is to be reconciled

    GenericObjectList - Specifies the delta array to reconcile.

    ReconType - Specifies the routine that called the persistence provider

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    DWORD SavedWinStatus = NO_ERROR;
    DWORD WinStatus;

    ULONG Index;
    ULONG DeltaIndex;
    PAZP_DELTA_ENTRY DeltaEntry;


    //
    // Skip back links
    //

    if ( GenericObjectList->IsBackLink ) {
        goto Cleanup;
    }

    //
    // Ensure each entry in the delta array has an entry in the object list
    //

    for ( DeltaIndex=0; DeltaIndex<GenericObjectList->DeltaArray.UsedCount; DeltaIndex++ ) {

        //
        // If the entry corresponds to an "add",
        //  do an "add" to the object list.
        //

        DeltaEntry = (PAZP_DELTA_ENTRY)GenericObjectList->DeltaArray.Array[DeltaIndex];

        if ( DeltaEntry->DeltaFlags & AZP_DELTA_ADD ) {
            PAZP_STRING StringToAdd;
            AZP_STRING SidString;
            ULONG Flags = AZP_FLAGS_RECONCILE;

            //
            // Compute the parameters to ObAddPropertyItem
            //
            if ( DeltaEntry->DeltaFlags & AZP_DELTA_SID ) {
                AzpInitSid( &SidString, DeltaEntry->Sid );
                StringToAdd = &SidString;
            } else {
                AzPrint(( AZD_REF, "AzpPersistReconcileOne (by guid): " ));
                AzpDumpGuid( AZD_REF, &DeltaEntry->Guid );
                AzPrint(( AZD_REF, "\n" ));
                Flags |= AZP_FLAGS_BY_GUID;
                StringToAdd = (PAZP_STRING) &DeltaEntry->Guid;
            }


            //
            // Add the property item
            //

            WinStatus = ObAddPropertyItem(
                            GenericObject,
                            GenericObjectList,
                            Flags,
                            StringToAdd );

            //
            // We ignore links that have already been updated.
            // During the update child cache routine, we want to ignore objects that exist in the store
            // but not yet in the cache since the user has not called an update on the entire policy cache
            //

            if ( (WinStatus != NO_ERROR && WinStatus != ERROR_ALREADY_EXISTS) &&
                 ((ReconType != IsUpdateChildCache) ||
                  (ReconType == IsUpdateChildCache && WinStatus != ERROR_NOT_FOUND)) ) {

                AzPrint(( AZD_REF,
                          "AzpPersistReconcileOne: ObAddPropertyItem failed %ld\n",
                          WinStatus
                          ));
                SavedWinStatus = WinStatus;
            }
        }
    }

    //
    // Remove entries from the object list that should no longer exist
    //

    for ( Index=0; Index<GenericObjectList->GenericObjects.UsedCount; ) {

        PGENERIC_OBJECT LinkedToGenericObject;
        DWORD DeltaFlags;
        GUID *Guid;

        //
        // Determine if the object is in the DeltaArray
        //

        LinkedToGenericObject = (PGENERIC_OBJECT)(GenericObjectList->GenericObjects.Array[Index]);

        if ( LinkedToGenericObject->ObjectType == OBJECT_TYPE_SID ) {
            DeltaFlags = AZP_DELTA_SID;
            Guid = (GUID *)&LinkedToGenericObject->ObjectName->ObjectName;
        } else {
            DeltaFlags = 0;
            Guid = &LinkedToGenericObject->PersistenceGuid;
        }

        if ( ObLookupDelta( DeltaFlags,
                            Guid,
                            &GenericObjectList->DeltaArray,
                            &DeltaIndex ) ) {

            //
            // Found it.
            //
            // If the entry is an "add" entry,
            //  this is one we added above,
            //  just move to the next entry.
            //

            DeltaEntry = (PAZP_DELTA_ENTRY)GenericObjectList->DeltaArray.Array[DeltaIndex];

            if ( DeltaEntry->DeltaFlags & AZP_DELTA_ADD ) {
                Index++;
                continue;
            }
        }

        //
        // Link should be removed
        //
        // Either there was no entry in the DeltaArray (or the entry is a "remove" entry
        //
        // Remove the links in both directions
        //

        ObRemoveObjectListLink( GenericObject,
                                GenericObjectList,
                                Index );


    }

Cleanup:

    //
    // Clear the bit that got us here
    //

    GenericObject->PersistDirtyBits &= ~GenericObjectList->DirtyBit;

    //
    // Free entries from the delta arrays that were added by the persist provider.
    //

    ObFreeDeltaArray( &GenericObjectList->DeltaArray, FALSE );

    return SavedWinStatus;

}

DWORD
AzpPersistReconcileOne(
    IN PGENERIC_OBJECT GenericObject,
    IN RECONCILE_TYPE ReconType,
    IN BOOLEAN OpenFailed
    )
/*++

Routine Description:


    Implements AzpPersistReconcile for a single object.

    On entry, AzGlResource must be locked exclusive.
        PersistCritSect must be locked. (unless this is a refresh)

Arguments:

    GenericObject - Specifies the object in the cache that is to be reconciled

    ReconType - Specifies the routine that called the persistence provider

    OpenFailed - TRUE if the open call to the persistence provider failed.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    DWORD WinStatus;

    DWORD SavedWinStatus = NO_ERROR;

    ULONG DirtyBits;
    PGENERIC_OBJECT_LIST GenericObjectList;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    ASSERT( ReconType == IsRefresh || ReconType == PreUpdateCache || AzpIsCritsectLocked( &GenericObject->AzStoreObject->PersistCritSect ) );

    AzPrint(( AZD_PERSIST,
              "AzpPersistReconcileOne: %ws %ld 0x%lx 0x%lx\n",
              GenericObject->ObjectName == NULL ? NULL : GenericObject->ObjectName->ObjectName.String,
              GenericObject->ObjectType,
              GenericObject->PersistDirtyBits,
              GenericObject->DirtyBits ));

    if ( ReconType == IsOpen ) {
        ASSERT( GenericObject->DirtyBits == 0 || GenericObject->ObjectType == OBJECT_TYPE_AZAUTHSTORE);
    }

    //
    // If the provider didn't create this object, then the object doesn't exist in the store.
    //

    if ( (GenericObject->PersistDirtyBits & AZ_DIRTY_CREATE) == 0 ) {

        //
        // Never delete cached objects if the persistence provider failed.
        //  The provider may have bailed before processing the object.
        //  If an object is abosultely clean, then we should just let it stay there.
        //
        
        if ( OpenFailed ) {
            goto Cleanup;
        }

        if ( ReconType == IsOpen ) {
            ASSERT( GenericObject->PersistDirtyBits & AZ_DIRTY_CREATE );
        }

        //
        // If the app didn't create this object either,
        //  then the object should be deleted from the cache,
        //  Unless it already has been marked for deletion.
        // This is also not marked for deletion if the children of AzApplication/AzScope
        // are being loaded into cache
        //
        // NOTE: other attributes might be dirty.  This simply reflects the fact
        //  that during reconciliation a delete overides a modification.
        //

        if ( (GenericObject->DirtyBits & AZ_DIRTY_CREATE) == 0 ) {

           //
           // Mark the entry (and its child objects) as deleted
           //  We do this since other threads may have references to the objects.
           //  We want to ensure those threads know the objects are deleted.
           //

           ObMarkObjectDeleted( GenericObject );

           GenericObject = NULL;    // Don't reference this again
           goto Cleanup;

        }

    //
    // If the provider created this object,
    //  and successfully set all of the attributes it knows about,
    //  clean up the attributes.
    //

    } else if ((GenericObject->Flags & GENOBJ_FLAGS_PERSIST_OK) != 0 ) {

        //
        // Never bother updating objects if the persistence provider failed and this
        //  is AzInitialize.  We'll delete the attributes soon anyway.
        //

        if ( OpenFailed ) {
            goto Cleanup;
        }


        //
        // Compute the properties that were neither written by
        //  the provider nor by the application.

        DirtyBits = 0xFFFFFFFF & (~GenericObject->DirtyBits) & (~GenericObject->PersistDirtyBits);

        //
        // All such properties should be set to their default value
        //

        WinStatus = ObSetPropertyToDefault( GenericObject, DirtyBits );

        if ( WinStatus != NO_ERROR ) {

            SavedWinStatus = WinStatus;
            AzPrint(( AZD_CRITICAL, "AzpPersistReconcile: Cannot refresh object: %ws %ld\n", GenericObject->ObjectName->ObjectName.String, WinStatus ));
            // Continue processing
        }

        //
        // Fix up all of the links from this object
        //
        // Walk all of the GenericObjectLists rooted on by this object
        //

        for ( GenericObjectList = GenericObject->GenericObjectLists;
              GenericObjectList != NULL;
              GenericObjectList = GenericObjectList->NextGenericObjectList ) {


            //
            // Reconcile this individual object list entry.
            //

            WinStatus = AzpPersistReconcileDeltaArray( GenericObject, GenericObjectList, ReconType );

            if ( WinStatus != NO_ERROR ) {

                SavedWinStatus = WinStatus;
                // ASSERT(FALSE);
            }

        }

    }

Cleanup:
    //
    // If the object wasn't deleted,
    //  clean it up.
    //

    if ( GenericObject != NULL ) {

        //
        // Clear any bits the provider left lying around
        //

        GenericObject->PersistDirtyBits = 0;
        GenericObject->Flags &= !GENOBJ_FLAGS_PERSIST_OK;

        //
        // Indicate whether the cache entry needs to be refreshed.
        //
        // If the provider didn't successfully update the cache,
        //  leave the refresh bit alone.
        //
        // If the caller IsOpen,
        //  we don't care since we'll be deleting the cache shortly.
        // If the caller IsUpdateCache,
        //  we haven't changed the state one way or another.
        //      The cache is guaranteed to not be worse than it was before.  But that's
        //      all we can say.
        // If the caller IsRefresh,
        //  that bit was set when we were called so we leave it set.
        //

        if ( OpenFailed ) {
            /* Drop through */

        //
        // If we detected an error,
        //  mark the item as needing refreshed since the current state of the cache is bogus.
        //

        } else if ( SavedWinStatus != NO_ERROR ) {

            GenericObject->Flags |= GENOBJ_FLAGS_REFRESH_ME;

        //
        // Otherwise, the cache entry is known to match the underlying store
        //

        } else {

            GenericObject->Flags &= ~GENOBJ_FLAGS_REFRESH_ME;
        }



        //
        // Free entries from the delta arrays that were added by the persist provider.
        //

        for ( GenericObjectList = GenericObject->GenericObjectLists;
              GenericObjectList != NULL;
              GenericObjectList = GenericObjectList->NextGenericObjectList ) {

            ObFreeDeltaArray( &GenericObjectList->DeltaArray, FALSE );

        }
    }

    return SavedWinStatus;
}

DWORD
AzpPersistReconcile(
    IN PGENERIC_OBJECT GenericObject,
    IN RECONCILE_TYPE ReconType,
    IN BOOLEAN OpenFailed
    )
/*++

Routine Description:

    This routine reconciles any inconsistencies in the cache that were left around
    by the persistence provider during the initial population of the cache or
    during a periodic cache update.

    Examples, are given in the code below.  However, the philosophy is the persistence
    providers shouldn't have to worry about ordering issues and naming issues.  For instance,
    they should be able to link to objects that are not yet in the cache.  They should
    be able to create an object with the same name as a deleted object.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies the object that is being queried

    ReconType - Specifies the routine that called the persistence provider

    OpenFailed - TRUE if the open call to the persistence provider failed.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    DWORD WinStatus;
    DWORD SavedWinStatus = NO_ERROR;

    PVOID EnumContext = NULL;
    PGENERIC_OBJECT NextGenericObject;
    BOOL FixMoreNames = TRUE;
    PNEW_OBJECT_NAME NewObjectName;
    PLIST_ENTRY ListEntry;
    PAZP_AZSTORE AzAuthorizationStore = GenericObject->AzStoreObject;

    //
    // Prepare to enumerate all of the objects in the cache
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    WinStatus = AzpPersistEnumOpen( GenericObject, &EnumContext );

    if ( WinStatus != NO_ERROR ) {
        SavedWinStatus = WinStatus;
        goto Cleanup;
    }

    //
    // If this call is from UpdateChildrenCache, we donot want to call AzpPersistReconcileOne
    // on the parent object, but only on its children
    //

    if ( ReconType == IsUpdateChildCache ) {

        WinStatus = AzpPersistEnumNext( EnumContext, &NextGenericObject );

        if ( WinStatus != NO_ERROR) {
            if ( WinStatus != ERROR_NO_MORE_ITEMS ) {
                SavedWinStatus = WinStatus;
            }
            goto Cleanup;
        }

        ASSERT( NextGenericObject == GenericObject );

    }

    //
    // Loop through each object
    //

    for (;;) {

        //
        // Get the next object
        //

        WinStatus = AzpPersistEnumNext( EnumContext, &NextGenericObject );

        if ( WinStatus != NO_ERROR) {
            if ( WinStatus != ERROR_NO_MORE_ITEMS ) {
                SavedWinStatus = WinStatus;
            }
            break;
        }


        //
        // Reconcile that one object
        //

        WinStatus = AzpPersistReconcileOne( NextGenericObject, ReconType, OpenFailed );

        if ( WinStatus != NO_ERROR ) {
            SavedWinStatus = WinStatus;
            AzPrint(( AZD_CRITICAL,
                      "AzpPersistReconcile: Cannot reconcile object: %ws %ld %ld\n",
                      NextGenericObject->ObjectName == NULL ? NULL : NextGenericObject->ObjectName->ObjectName.String,
                      NextGenericObject->ObjectType,
                      WinStatus ));
            // Continue processing
        }

    }

    //
    // Loop attempting to fix up any name conflicts.
    //  Keep looping as long as a pass fixed at least one name
    //
    // Don't fix name comflicts if we're just cleaning up.
    //

    while ( ReconType != PreUpdateCache && FixMoreNames ) {

        FixMoreNames = FALSE;

        //
        // Loop handling each conflicting name
        //

        for ( ListEntry = AzAuthorizationStore->NewNames.Flink;
              ListEntry != &AzAuthorizationStore->NewNames;
              ) {

            NewObjectName = CONTAINING_RECORD( ListEntry,
                                               NEW_OBJECT_NAME,
                                               Next );
            // Entry might be deleted below
            ListEntry = ListEntry->Flink;

            //
            // Try to set the name
            //

            WinStatus = ObSetProperty(
                            NewObjectName->GenericObject,
                            AZP_FLAGS_RECONCILE,
                            AZ_PROP_NAME,
                            &NewObjectName->ObjectName );

            if ( WinStatus == NO_ERROR ) {
                ObFreeNewName( NewObjectName );
                FixMoreNames = TRUE;
            }


        }

    }

    //
    // If we couldn't fix all of the collided names,
    //  return the problem to the caller.
    //

    if ( SavedWinStatus == NO_ERROR  &&
         !IsListEmpty( &AzAuthorizationStore->NewNames ) ) {

        SavedWinStatus = ERROR_ALREADY_EXISTS;

    }

Cleanup:
    if ( EnumContext != NULL ) {
        AzpPersistEnumClose( EnumContext );
    }

    //
    // Free the list of conflicting names
    //

    while ( !IsListEmpty( &AzAuthorizationStore->NewNames ) ) {

        ListEntry = RemoveHeadList( &AzAuthorizationStore->NewNames );

        NewObjectName = CONTAINING_RECORD( ListEntry,
                                           NEW_OBJECT_NAME,
                                           Next );

        ObFreeNewName( NewObjectName );

    }
    return SavedWinStatus;
}


//
// List of providers that are built into azroles.dll
//

struct {
    LPWSTR PolicyUrlPrefix;
    AZ_PERSIST_PROVIDER_INITIALIZE ProviderInitRoutine;
} AzGlInternalProviders[] = {
#ifdef USE_INTERNAL_MSXML
    { AZ_XML_PROVIDER_NAME, XmlProviderInitialize },
#endif // USE_INTERNAL_MSXML
    { AZ_AD_PROVIDER_NAME, AdProviderInitialize },
};
#define INTERNAL_PROVIDER_COUNT (sizeof(AzGlInternalProviders)/sizeof(AzGlInternalProviders[0]))

DWORD
AzpPersistDetermineProvider(
    IN PAZP_AZSTORE AzAuthorizationStore
    )
/*++

Routine Description:

    This routine determines which provider to use for a particular Policy URL.

Arguments:

    AzAuthorizationStore - A pointer to the authorization store object the provider is needed for
        The PolicyUrl should already have been set.
        On successfull return, the ProviderInfo and ProviderDll will be properly set.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_INVALID_PARAMETER - The policy URL cannot identify the provider
    Other status codes

--*/
{
    DWORD WinStatus;

    ULONG Index;
    ULONG UrlPrefixLength;
    AZ_PERSIST_PROVIDER_INITIALIZE ProviderInitRoutine = NULL;
    PAZPE_PROVIDER_INFO ProviderInfo;
    LPWSTR PolicyUrl = AzAuthorizationStore->PolicyUrl.String;
    LPWSTR KeyName = NULL;
    HKEY KeyHandle = NULL;
    HMODULE DllHandle = NULL;

    //
    // Initialization
    //

    ASSERT( AzAuthorizationStore->PolicyUrl.String != NULL );
    ASSERT( AzAuthorizationStore->ProviderInfo == NULL );
    ASSERT( AzAuthorizationStore->ProviderDll == NULL );


    //
    // Loop through the internal providers finding the one specified
    //

    for ( Index=0; Index<INTERNAL_PROVIDER_COUNT; Index++ ) {

        UrlPrefixLength = (ULONG) wcslen(AzGlInternalProviders[Index].PolicyUrlPrefix);


        //
        // Check if the prefix of the provider matches the passed in URL
        //
        if (_wcsnicmp( AzGlInternalProviders[Index].PolicyUrlPrefix, PolicyUrl, UrlPrefixLength) == 0) {

            //
            // Ensure the next character is a :
            //

            if ( UrlPrefixLength == 0 || PolicyUrl[UrlPrefixLength] == L':' ) {
                ProviderInitRoutine = AzGlInternalProviders[Index].ProviderInitRoutine;
                break;
            }
        }

    }

    //
    // If we didn't find an internal provider,
    //  load one
    //

    if ( ProviderInitRoutine == NULL ) {
        LPWSTR ColonPtr;
        ULONG KeyNameLen;
        DWORD ValueType;
        WCHAR ProviderDll[MAX_PATH+1];
        DWORD ProviderDllSize;

        //
        // Determin the length of the name of the registry key
        //

        ColonPtr = wcschr( PolicyUrl, L':' );

        if ( ColonPtr == NULL ) {
            WinStatus = ERROR_BAD_PROVIDER;
            goto Cleanup;
        }

        UrlPrefixLength = (ULONG)(ColonPtr - PolicyUrl);
        KeyNameLen = AZ_REGISTRY_PROVIDER_KEY_NAME_LEN +
                     1 +
                     UrlPrefixLength +
                     1;

        //
        // Build the name of the registry key
        //

        SafeAllocaAllocate( KeyName, KeyNameLen * sizeof(WCHAR) );

        if ( KeyName == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        RtlCopyMemory( KeyName, AZ_REGISTRY_PROVIDER_KEY_NAME, AZ_REGISTRY_PROVIDER_KEY_NAME_LEN * sizeof(WCHAR) );
        KeyName[AZ_REGISTRY_PROVIDER_KEY_NAME_LEN] = '\\';
        RtlCopyMemory( &KeyName[AZ_REGISTRY_PROVIDER_KEY_NAME_LEN+1],
                       PolicyUrl,
                       UrlPrefixLength*sizeof(WCHAR) );
        KeyName[AZ_REGISTRY_PROVIDER_KEY_NAME_LEN+1+UrlPrefixLength] = '\0';

        AzPrint(( AZD_PERSIST, "AzpPersistDetermineProvider: Open Provider reg key at 'HKLM\\%ws'\n", KeyName ));

        //
        // Open the registry key
        //

        WinStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                  KeyName,
                                  0,
                                  KEY_READ,
                                  &KeyHandle );

        if ( WinStatus != NO_ERROR ) {
            AzPrint(( AZD_CRITICAL, "AzpPersistDetermineProvider: Cannot open Provider reg key at 'HKLM\\%ws' %ld\n", KeyName, WinStatus ));
            if ( WinStatus == ERROR_FILE_NOT_FOUND ) {
                WinStatus = ERROR_BAD_PROVIDER;
            }
            goto Cleanup;
        }

        //
        // Read the name of the provider dll
        //

        ProviderDllSize = sizeof(ProviderDll);

        WinStatus = RegQueryValueEx( KeyHandle,
                                     AZ_REGISTRY_PROVIDER_DLL_VALUE_NAME,
                                     NULL,
                                     &ValueType,
                                     (LPBYTE)ProviderDll,
                                     &ProviderDllSize );

        if ( WinStatus != NO_ERROR ) {

            AzPrint(( AZD_CRITICAL,
                      "AzpPersistDetermineProvider: Cannot open Provider reg value at 'HKLM\\%ws\\%ws' %ld\n",
                      KeyName,
                      AZ_REGISTRY_PROVIDER_DLL_VALUE_NAME,
                      WinStatus ));

            if ( WinStatus == ERROR_FILE_NOT_FOUND ) {
                WinStatus = ERROR_BAD_PROVIDER;
            }
            goto Cleanup;
        }

        //
        // Load the library
        //

        DllHandle = LoadLibrary( ProviderDll );

        if ( DllHandle == NULL ) {

            WinStatus = GetLastError();

            AzPrint(( AZD_CRITICAL,
                      "AzpPersistDetermineProvider: Cannot load libary '%ws' %ld\n",
                      ProviderDll,
                      WinStatus ));

            goto Cleanup;
        }

        //
        // Get the address of the provider init routine
        //

        ProviderInitRoutine = (AZ_PERSIST_PROVIDER_INITIALIZE)
                GetProcAddress( DllHandle, AZ_PERSIST_PROVIDER_INITIALIZE_NAME );

        if ( ProviderInitRoutine == NULL ) {

            WinStatus = GetLastError();

            AzPrint(( AZD_CRITICAL,
                      "AzpPersistDetermineProvider: libary '%ws' does not export '%s': %ld\n",
                      ProviderDll,
                      AZ_PERSIST_PROVIDER_INITIALIZE_NAME,
                      WinStatus ));

            goto Cleanup;
        }


    }

    //
    // A provider has been found
    //  Ask the provider for the provider info
    //

    WinStatus = ProviderInitRoutine( &AzGlAzrolesInfo, &ProviderInfo );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Ensure the provider info is a version we understand
    //

    if ( ProviderInfo->ProviderInfoVersion < AZPE_PROVIDER_INFO_VERSION_1 ) {
        WinStatus = ERROR_UNKNOWN_REVISION;
        goto Cleanup;
    }

    //
    // Return the information to the caller
    //

    AzAuthorizationStore->ProviderInfo = ProviderInfo;
    AzAuthorizationStore->ProviderDll = DllHandle;
    DllHandle = NULL;
    WinStatus = NO_ERROR;

    //
    // Free locally used resources
    //
Cleanup:
    SafeAllocaFree( KeyName );
    if ( KeyHandle != NULL ) {
        RegCloseKey( KeyHandle );
    }
    if ( DllHandle != NULL ) {
        FreeLibrary( DllHandle );
    }
    return WinStatus;

}

DWORD
AzPersistOpen(
    IN PAZP_AZSTORE AzAuthorizationStore,
    IN BOOL CreatePolicy
    )
/*++

Routine Description:

    This routine open the authz policy database.
    This routine also reads the policy database into cache.

    On Success, the caller should call AzPersistClose to free any resources
        consumed by the open.

    This routine routes the request to the correct provider.

    On entry, AzGlResource must be locked exclusive.
    This routine temporarily drops the AzGlResource while waiting for updates to complete.

Arguments:

    AzAuthorizationStore - Specifies the policy database that is to be read.

    CreatePolicy - TRUE if the policy database is to be created.
        FALSE if the policy database already exists

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    ERROR_ALREADY_EXISTS - CreatePolicy is TRUE and the policy already exists
    ERROR_FILE_NOT_FOUND - CreatePolicy is FALSE and the policy does not already exist
    Other status codes

--*/
{
    DWORD WinStatus;
    DWORD TempWinStatus;
    DWORD lPersistFlags;
    BOOLEAN CritSectLocked = FALSE;
    BOOLEAN ResourceLocked = TRUE;
    LPWSTR pwszTargetMachine=NULL;

    //
    // Compute the flags
    //

    lPersistFlags = AZPE_FLAGS_PERSIST_OPEN;

    //
    // Drop the global crit sect across the call to the provider to ensure on
    // UpdateCache that it doesn't lock out AccessCheck calls while it hits the wire
    //
    // Grab the Persistence crit sect maintaining locking order
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    AzpUnlockResource( &AzGlResource );
    ResourceLocked = FALSE;
    SafeEnterCriticalSection( &AzAuthorizationStore->PersistCritSect );
    CritSectLocked = TRUE;

    //
    // Determine which provider to use
    //

    WinStatus = AzpPersistDetermineProvider( AzAuthorizationStore );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Call the appropriate provider
    //

    WinStatus = AzAuthorizationStore->ProviderInfo->AzPersistOpen(
                        AzAuthorizationStore->PolicyUrl.String,
                        (AZPE_OBJECT_HANDLE)AzAuthorizationStore,
                        lPersistFlags,
                        CreatePolicy,
                        &AzAuthorizationStore->PersistContext,
                        &pwszTargetMachine );

    if ( WinStatus == NO_ERROR &&
        pwszTargetMachine ) {

        //
        // target machine name is returned
        // add it to the authorization store object, which will be freed when
        // authorization store object is freed
        //
        AzpInitString(&AzAuthorizationStore->TargetMachine, pwszTargetMachine);
    }

    //
    // Restore the lock now that we're out of the provider
    //

    AzpLockResourceExclusive( &AzGlResource );
    ResourceLocked = TRUE;

    //
    // Ensure the provider set the version
    //

    if ( WinStatus == NO_ERROR ) {
        ASSERT( (((PGENERIC_OBJECT)AzAuthorizationStore)->PersistDirtyBits & (AZ_DIRTY_AZSTORE_MAJOR_VERSION | AZ_DIRTY_AZSTORE_MINOR_VERSION)) == (AZ_DIRTY_AZSTORE_MAJOR_VERSION | AZ_DIRTY_AZSTORE_MINOR_VERSION) );
    }

    //
    // If we didn't create the underlying store,
    //  Turn off the dirty bits.
    //  (AZ_DIRTY_CREATE was set when the object was created.  But the object really isn't dirty.)
    //

    if ( !CreatePolicy ) {
        AzAuthorizationStore->GenericObject.DirtyBits = 0;
    }
    else
    {
        //
        // Major and minor versions are not to be set externally. But they always need
        // to be persisted in the authorization store object. We thus set these bits dirty.
        // This will make sure that these two properties are persisted upon submit.
        //

        ((PGENERIC_OBJECT)AzAuthorizationStore)->DirtyBits |=
            (AZ_DIRTY_AZSTORE_MAJOR_VERSION | AZ_DIRTY_AZSTORE_MINOR_VERSION);
    }

    //
    // Now that the entire cache has been updated from the store
    //  fix up any issues in the cache.
    //

    TempWinStatus = AzpPersistReconcile( (PGENERIC_OBJECT)AzAuthorizationStore, IsOpen, WinStatus != NO_ERROR );

    if ( WinStatus == NO_ERROR ) {
        WinStatus = TempWinStatus;
    }

    //
    // If we created the store,
    //  set the default AZ_PROP_APPLY_STORE_SACL based on whether the caller has the privilege
    //

    if ( CreatePolicy ) {
        AzAuthorizationStore->GenericObject.ApplySacl = AzAuthorizationStore->HasSecurityPrivilege;
    }


Cleanup:
    if ( !ResourceLocked ) {
        AzpLockResourceExclusive( &AzGlResource );
    }
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    if ( CritSectLocked ) {
        SafeLeaveCriticalSection( &AzAuthorizationStore->PersistCritSect );
    }
    return WinStatus;
}



DWORD
AzPersistUpdateCache(
    IN PAZP_AZSTORE AzAuthorizationStore
    )
/*++

Routine Description:

    This routine updates the cache to reflect the current authz policy database.

    This routine routes the request to the correct provider.

    On entry, AzGlResource must be locked exclusive.
    This routine temporarily drops the AzGlResource while waiting for other updates to complete.

Arguments:

    AzAuthorizationStore - Specifies the policy database that is to be read.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    ERROR_ALREADY_EXISTS - CreatePolicy is TRUE and the policy already exists
    ERROR_FILE_NOT_FOUND - CreatePolicy is FALSE and the policy does not already exist
    Other status codes

--*/
{
    DWORD WinStatus;
    DWORD TempWinStatus = NO_ERROR;
    BOOLEAN CritSectLocked = FALSE;

    //
    // Provider decides what to update. It passes back that information
    // via the flag.
    // 
    
    ULONG ulEffectiveUpdateFlag = 0;

    //
    // Walk the cache cleaning up from any previous failed attempt.
    //

    WinStatus = AzpPersistReconcile( (PGENERIC_OBJECT)AzAuthorizationStore, PreUpdateCache, TRUE );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Drop the global crit sect across the call to the provider to ensure on
    // UpdateCache that it doesn't lock out AccessCheck calls while it hits the wire
    //
    // Grab the Persistence crit sect maintaining locking order
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    AzpUnlockResource( &AzGlResource );
    SafeEnterCriticalSection( &AzAuthorizationStore->PersistCritSect );
    CritSectLocked = TRUE;


    //
    // Call the appropriate provider
    //  The peristence provider will drop
    //

    WinStatus = AzAuthorizationStore->ProviderInfo->AzPersistUpdateCache(
        AzAuthorizationStore->PersistContext,
        AZPE_FLAGS_PERSIST_UPDATE_CACHE,
        &ulEffectiveUpdateFlag);

    //
    // Restore the lock now that we're out of the provider
    //

    AzpLockResourceExclusive( &AzGlResource );


    //
    // Now that the entire cache has been updated from the store
    // If the store has been deleted, ERROR_FILE_NOT_FOUND is returned.  In this case,
    // the cache needs to cleaned up completely.
    // fix up any issues in the cache.
    //

    if ( (AZPE_FLAG_CACHE_UPDATE_STORE_LEVEL & ulEffectiveUpdateFlag) || (WinStatus != NO_ERROR) )
    {
        TempWinStatus = AzpPersistReconcile( (PGENERIC_OBJECT)AzAuthorizationStore, IsUpdateCache,
                                         (WinStatus != NO_ERROR &&
                                          WinStatus != ERROR_FILE_NOT_FOUND) );
    }

    if ( WinStatus == NO_ERROR ) {
        WinStatus = TempWinStatus;
    }


Cleanup:
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    if ( CritSectLocked ) {
        SafeLeaveCriticalSection( &AzAuthorizationStore->PersistCritSect );
    }
    return WinStatus;
}

DWORD
AzPersistUpdateChildrenCache(
    IN OUT PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine updates the child objects (upto one level) under the object specified.

    The request is routed to the relevant provider.

    On entry, the global resource must be locked exclusive

Arguments:

    GenericObject - Object whose children need to be updated (one-level only)

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    DWORD WinStatus = 0;
    DWORD TempWinStatus = 0;
    BOOLEAN bCritSectLocked = FALSE;

    PAZP_AZSTORE AzAuthorizationStore = (PAZP_AZSTORE) GenericObject->AzStoreObject;

    //
    // Validate that the provider supports lazy load
    //

    ASSERT( AzAuthorizationStore->ProviderInfo->ProviderInfoVersion >= AZPE_PROVIDER_INFO_VERSION_2 );

    //
    // If the parent object has not been submitted as yet, then no children exist for it.
    // Simply return NO_ERROR
    //

    if ( (GenericObject->DirtyBits & AZ_DIRTY_CREATE) != 0 ) {

        return NO_ERROR;
    }

    WinStatus = AzpPersistReconcile( GenericObject, PreUpdateCache, TRUE );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    AzpUnlockResource( &AzGlResource );

    //
    // Grab the Persistence crit sect maintaining locking order
    //

    SafeEnterCriticalSection( &AzAuthorizationStore->PersistCritSect );
    bCritSectLocked = TRUE;

    //
    // If the children have already been loaded by another thread, then
    // skip this
    //

    if ( GenericObject->AreChildrenLoaded ) {
        
        //
        // Grab the lock back
        //

        AzpLockResourceExclusive( &AzGlResource );

        goto Cleanup;
    }

    //
    // Call the appropriate provider
    //

    WinStatus = AzAuthorizationStore->ProviderInfo->AzPersistUpdateChildrenCache(
        AzAuthorizationStore->PersistContext,
        (AZPE_OBJECT_HANDLE) GenericObject,
        AZPE_FLAGS_PERSIST_UPDATE_CHILDREN_CACHE );

    //
    // Restore the lock, now that we are out of the provider
    //

    AzpLockResourceExclusive( &AzGlResource );

    if ( WinStatus == NO_ERROR ) {

        //
        // Set the flag on the generic object that its children have been loaded
        // and this object is no longer closed
        //

        GenericObject->AreChildrenLoaded = TRUE;
        GenericObject->ObjectClosed = FALSE;

    }

    //
    // Now that the cache has been updated from the store
    //  fix up any issues in the cache.
    //

    TempWinStatus = AzpPersistReconcile( GenericObject, IsUpdateChildCache, WinStatus != NO_ERROR );

    if ( WinStatus == NO_ERROR ) {
        WinStatus = TempWinStatus;
    }

Cleanup:

    if ( bCritSectLocked ) {
            SafeLeaveCriticalSection( &AzAuthorizationStore->PersistCritSect );
    }

    return WinStatus;
}

VOID
AzPersistClose(
    IN PAZP_AZSTORE AzAuthorizationStore
    )
/*++

Routine Description:

    This routine closes the authz policy database storage handles.
    This routine routes the request to the correct provider.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    AzAuthorizationStore - Specifies the policy database that is to be read.

Return Value:

    None

--*/
{

    //
    // If the store wasn't successfully opened,
    //  we're done.

    if ( AzAuthorizationStore->PersistContext == NULL ) {
        return;
    }

    //
    // Grab the persist engine crit sect maintaining locking order
    //
    // The provider uses PersistCritSect to serialize access to many of its structures.
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    AzpUnlockResource( &AzGlResource );
    SafeEnterCriticalSection( &AzAuthorizationStore->PersistCritSect );
    AzpLockResourceExclusive( &AzGlResource );

    //
    // Call the appropriate provider
    //
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    AzAuthorizationStore->ProviderInfo->AzPersistClose( AzAuthorizationStore->PersistContext );

    AzAuthorizationStore->PersistContext = NULL;
    SafeLeaveCriticalSection( &AzAuthorizationStore->PersistCritSect );
}

DWORD
AzPersistSubmit(
    IN PGENERIC_OBJECT GenericObject,
    IN BOOLEAN DeleteMe
    )
/*++

Routine Description:

    This routine submits changes made to the authz policy database.
    This routine routes the request to the correct provider.

    If the object is being created, the GenericObject->PersistenceGuid field will be
    zero on input.  Upon successful creation, this routine will set PersistenceGuid to
    non-zero.  Upon failed creation, this routine will leave PersistenceGuid as zero.

    On entry, AzGlResource must be locked exclusive.
    This routine temporarily drops the AzGlResource while waiting for updates to complete.

Arguments:

    GenericObject - Specifies the object in the database that is to be updated
        in the underlying store.

    DeleteMe - TRUE if the object and all of its children are to be deleted.
        FALSE if the object is to be updated.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    DWORD WinStatus = NO_ERROR;

    PGENERIC_OBJECT_LIST GenericObjectList;


    //
    // Grab the persist engine crit sect maintaining locking order
    //
    // The PersistCritSect must be locked since we want to ensure that AzpPersistReconcile
    // doesn't have to deal with a changing database.
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    AzpUnlockResource( &AzGlResource );
    SafeEnterCriticalSection( &GenericObject->AzStoreObject->PersistCritSect );
    AzpLockResourceExclusive( &AzGlResource );

    //
    // Only persist dirty objects
    //

    if ( GenericObject->DirtyBits != 0 ||
         DeleteMe ) {

        //
        // Call the appropriate provider
        //

        WinStatus = GenericObject->AzStoreObject->ProviderInfo->AzPersistSubmit(
                            GenericObject->AzStoreObject->PersistContext,
                            (AZPE_OBJECT_HANDLE)GenericObject,
                            AZPE_FLAGS_PERSIST_SUBMIT,
                            DeleteMe );

        if ( WinStatus != NO_ERROR ) {
        
            //
            // Submit somehow fails, we need to remember that we are not in good
            // shape with the store. So any access should refresh it.
            //
            
            GenericObject->Flags |= GENOBJ_FLAGS_REFRESH_ME;
            goto Cleanup;
        }

        //
        // Ensure the provider created a GUID
        //

        if ( (GenericObject->DirtyBits & AZ_DIRTY_CREATE) != 0 &&
             GenericObject->ObjectType != OBJECT_TYPE_AZAUTHSTORE &&
             !DeleteMe ) {
            ASSERT( !IsEqualGUID( GenericObject->PersistenceGuid, AzGlZeroGuid ) );
        }

        //
        // Ensure the provider didn't change the cache.
        //

        ASSERT( GenericObject->PersistDirtyBits == 0 );


        //
        // Clean up the list of deltas
        //
        // Walk all of the GenericObjectLists rooted on by this object
        //

        for ( GenericObjectList = GenericObject->GenericObjectLists;
              GenericObjectList != NULL;
              GenericObjectList = GenericObjectList->NextGenericObjectList ) {


            //
            // If there is a list of deltas,
            //  delete it
            //

            if ( GenericObjectList->DeltaArray.UsedCount != 0 ) {
                ASSERT( !GenericObjectList->IsBackLink );
                ASSERT( (GenericObject->DirtyBits & GenericObjectList->DirtyBit) != 0 );
                ObFreeDeltaArray( &GenericObjectList->DeltaArray, TRUE );
            }

        }

        //
        // Turn off the dirty bits
        //

        GenericObject->DirtyBits = 0;

    }

Cleanup:
    SafeLeaveCriticalSection( &GenericObject->AzStoreObject->PersistCritSect );
    return WinStatus;

}

VOID
AzPersistAbort(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine aborts changes made to the authz policy database.
    This routine routes the request to the correct provider.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies the object in the database that is to be updated
        in the underlying store.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    PGENERIC_OBJECT_LIST GenericObjectList;
    BOOLEAN WasCreated;

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Clean up the list of deltas
    //  ... The changes where aborted.
    //
    // Walk all of the GenericObjectLists rooted on by this object
    //

    for ( GenericObjectList = GenericObject->GenericObjectLists;
          GenericObjectList != NULL;
          GenericObjectList = GenericObjectList->NextGenericObjectList ) {


        //
        // If there is a list of deltas,
        //  delete it
        //

        if ( GenericObjectList->DeltaArray.UsedCount != 0 ) {
            ASSERT( !GenericObjectList->IsBackLink );
            ASSERT( (GenericObject->DirtyBits & GenericObjectList->DirtyBit) != 0 );
            ObFreeDeltaArray( &GenericObjectList->DeltaArray, TRUE );
        }

    }

    //
    // Turn off the dirty bits
    //  ... The changes where aborted.
    //

    WasCreated = (( GenericObject->DirtyBits & AZ_DIRTY_CREATE ) != 0);
    GenericObject->DirtyBits = 0;

    //
    // Update the cache to match the real object
    //
    // If we were trying to persist a creation of the object,
    //  delete the object from the cache.
    //

    if ( WasCreated ) {

        //
        // Mark the entry (and its child objects) as deleted
        //  We do this since other threads may have references to the objects.
        //  We want to ensure those threads know the objects are deleted.
        //

        ObMarkObjectDeleted( GenericObject );


    } else {

        //
        // Refresh the cache
        //  Ignore the status code
        //

        (VOID) AzPersistRefresh( GenericObject );

    }
}



DWORD
AzPersistRefresh(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine updates the attributes of the object from the policy database.

    This routine routes the request to the correct provider.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies the object in the database whose cache entry is to be
        updated
        The GenericObject->PersistenceGuid field should be non-zero on input.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    DWORD WinStatus;
    DWORD TempWinStatus;

    //
    // Grab the persist engine crit sect maintaining locking order
    //
    // The PersistCritSect must be locked since we want to ensure that AzpPersistReconcile
    // doesn't have to deal with a changing database.
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    AzpUnlockResource( &AzGlResource );
    SafeEnterCriticalSection( &GenericObject->AzStoreObject->PersistCritSect );

    //
    // Mark the object that it needs to be refreshed
    //  so that it'll be refreshed later if we're not successful this time
    //

    GenericObject->Flags |= GENOBJ_FLAGS_REFRESH_ME;

    //
    // Clear any bits the provider left lying around
    //

    GenericObject->PersistDirtyBits = 0;
    GenericObject->Flags &= !GENOBJ_FLAGS_PERSIST_OK;


    //
    // Call the appropriate provider
    //

    WinStatus = GenericObject->AzStoreObject->ProviderInfo->AzPersistRefresh(
                        GenericObject->AzStoreObject->PersistContext,
                        (AZPE_OBJECT_HANDLE)GenericObject,
                        AZPE_FLAGS_PERSIST_REFRESH );

    // Provider should return WinStatus
    // ASSERT( SUCCEEDED(WinStatus) );

    //
    // Restore the lock now that we're out of the provider
    //

    AzpLockResourceExclusive( &AzGlResource );

    //
    // If the provider couldn't find the object,
    //  that's OK.  Reconcile will delete the cache entry.
    //

    if ( WinStatus == ERROR_NOT_FOUND ) {
        WinStatus = NO_ERROR;
    }

    //
    // Reconcile this one object
    //

    TempWinStatus = AzpPersistReconcileOne(
                    GenericObject,
                    IsRefresh,
                    WinStatus != NO_ERROR );    // Operation status

    if ( TempWinStatus != NO_ERROR ) {

        if ( WinStatus == NO_ERROR ) {
            WinStatus = TempWinStatus;
        }

        AzPrint(( AZD_CRITICAL, "AzpPersistReconcile: Cannot reconcile object: %ws %ld\n", GenericObject->ObjectName->ObjectName.String, TempWinStatus ));
        // Continue processing
    }

    SafeLeaveCriticalSection( &GenericObject->AzStoreObject->PersistCritSect );
    return WinStatus;

}





DWORD
WINAPI
AzSubmit(
    IN AZ_HANDLE AzHandle,
    IN DWORD Flags,
    IN DWORD Reserved
    )
/*++

Routine Description:

    Submit the changes made to the object via the *Create, *SetProperty, or *SetPropertyItem
    APIs.

    On failure, any changes made to the object are undone.

Arguments:

    AzHandle - Passes in the handle to be updated.

    Flags - Specifies flags that control the behavior of AzInitialize
        AZ_SUBMIT_FLAG_ABORT: Abort the operation instead of commiting it

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The passed in handle was invalid

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedGenericObject = NULL;
    PGENERIC_OBJECT GenericObject = (PGENERIC_OBJECT) AzHandle;
    DWORD ObjectType;

    //
    // Grab the global lock
    //  Only for the authorization store case do we modify anything.
    //

    AzpLockResourceExclusive( &AzGlResource );

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "AzCloseHandle: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Determine the type of the object
    //

    WinStatus = ObGetHandleType( GenericObject,
                                 FALSE,   // Don't allow deleted objects
                                 &ObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( GenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           TRUE,    // Refresh the cache
                                           ObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedGenericObject = GenericObject;

    //
    // If we've been asked to abort the changes,
    //  do so
    //

    if ( Flags & AZ_SUBMIT_FLAG_ABORT ) {

        //
        // Call the worker routine to abort the operation
        //

        AzPersistAbort( GenericObject );


    //
    // Submit the changes
    //

    } else {

        //
        // Submit the change
        //    On failure, leave the object dirty
        //

        WinStatus = AzPersistSubmit( GenericObject, FALSE );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

    }


    WinStatus = NO_ERROR;

    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedGenericObject != NULL ) {
        ObDereferenceObject( ReferencedGenericObject );
    }

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;

}

//
// Various functions that are callable by the provider.
//  These Azpe* routines are the only routines callable by the provider.
//  They are typically thin wrappers around other routines in the core.
//

DWORD
AzpeCreateObject(
    IN AZPE_OBJECT_HANDLE AzpeParentHandle,
    IN ULONG ChildObjectType,
    IN LPCWSTR ChildObjectNameString,
    IN GUID *ChildObjectGuid,
    IN ULONG lPersistFlags,
    OUT AZPE_OBJECT_HANDLE *AzpeChildHandle
    )
/*++

Routine Description:

    The provider should call AzpeCreateObject to create an object in the AzRoles object cache.
    It should only be called from a thread processing a call to AzPersistOpen,
    AzPersistUpdateCache, AzPersistUpdateChildrenCache or AzPersistRefresh.

Arguments:

    AzpeParentHandle - Specifies a handle to the object that is the parent of the object
        to create.

    ChildObjectType - Specifies the type of the object to create.  This should be one
        of the OBJECT_TYPE_* defines.  See the section entitled AzpeObjectType for a
        list of valid object types.  OBJECT_TYPE_AZAUTHSTORE is not valid.

    ChildObjectNameString - Specifies the name of the object to create.

    ChildObjectGuid - Specifies the Persistence Guid of the object to create.

    lPersistFlags - Specifies a bit mask describing the operation. The provider should
        pass the same flags that were passed to it by AzRoles when AzRoles called the AzPersist*.

    AzpeChildHandle - On success, returns a handle to the newly created object.
        The provider must call AzpeObjectFinished to close this handle.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    ERROR_INVALID_FLAGS - lPersistFlags is invalid.

--*/
{
    DWORD WinStatus;
    PGENERIC_OBJECT ParentGenericObject = (PGENERIC_OBJECT)AzpeParentHandle;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    AZP_STRING ChildObjectName;

    //
    // Ensure the provider didn't pass bogus parameters
    //

    if ( (lPersistFlags & ~AZPE_FLAGS_PERSIST_OPEN_MASK) != 0) {
        ASSERT( FALSE );
        return ERROR_INVALID_FLAGS;
    }

    if ( ChildObjectType >= OBJECT_TYPE_COUNT ) {
        ASSERT( ChildObjectType < OBJECT_TYPE_COUNT );
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Initialization
    //

    AzpLockResourceExclusive( &AzGlResource );
    AzpInitString( &ChildObjectName, ChildObjectNameString );

    //
    // Find child object head data structure from parent object
    //

    for ( GenericChildHead = ParentGenericObject->ChildGenericObjectHead;
          GenericChildHead != NULL;
          GenericChildHead = GenericChildHead->SiblingGenericObjectHead ) {

        if ( GenericChildHead->ObjectType == ChildObjectType ) {

            //
            // Found object type head
            //

            break;
        }
    }

    if ( GenericChildHead == NULL ) {

        WinStatus = ERROR_INVALID_PARAMETER;

        AzPrint(( AZD_INVPARM,
                  "AzpeCreateObject: Cannot find Object Head: %ld: %ld\n",
                  ParentGenericObject->ObjectType,
                  ChildObjectType ));

        goto Cleanup;
    }


    //
    // Actually create the object
    //

    WinStatus = ObCreateObject(
                        ParentGenericObject,
                        GenericChildHead,
                        ChildObjectType,
                        &ChildObjectName,
                        ChildObjectGuid,
                        lPersistFlags | AZP_FLAGS_BY_GUID,
                        (PGENERIC_OBJECT *)AzpeChildHandle );

Cleanup:
    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}

DWORD
AzpeSetProperty(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    The provider should call AzpeSetProperty to set the value of a scalar property
    in the AzRoles object cache.  It should only be called from a thread processing
    a call to AzPersistOpen, AzPersistUpdateCache, AzPersistUpdateChildrenCache or
    AzPersistRefresh.

    This operation is silently ignored if the application has already modified this
    property and has not yet submitted the change.

    The provider should not call AzpeSetProperty for values that it hasn't actually stored.
    That is, the provider should make no assumption about the default values of the properties.

    AzpeSetProperty does not bounds check, length check, or value check the PropertyValue.
    The provider maintains the definitive copy of the authorization policy.  AzRoles
    simply maintains a cache of that authorization policy.

Arguments:

    AzpeObjectHandle - Specifies a handle to the object.

    lPersistFlags - Specifies a bit mask describing the operation. The provider should
        pass the same flags that were passed to it by AzRoles when AzRoles called the AzPersist*.

    PropertyId - Specifies the property ID of the property to set.  This should be one of
        the AZ_PROP_* defines.  See the section entitled PropertyId parameter for a list
        of valid values.

    PropertyValue - Specifies a pointer to the buffer containing the property.
        For properties that are strings, the pointer is of type LPWSTR.
        For properties that are LONGs, the pointer is of type PULONG.
        For properties that are Booleans, the pointer is of type PBOOL.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_INVALID_FLAGS - lPersistFlags is invalid.
    ERROR_INVALID_PARAMETER - Property ID is invalid
    ERROR_NOT_ENOUGH_MEMORY - not enough memory

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT_LIST GenericObjectList;
    ULONG ObjectType;

    //
    // Ensure the provider didn't pass bogus flags
    //

    if ( (lPersistFlags & ~AZPE_FLAGS_PERSIST_OPEN_MASK) != 0) {
        ASSERT( FALSE );
        return ERROR_INVALID_FLAGS;
    }

    //
    // Ensure the provider is only getting a scalar property
    //

    WinStatus = ObMapPropIdToObjectList(
                                (PGENERIC_OBJECT)AzpeObjectHandle,
                                PropertyId,
                                &GenericObjectList,
                                &ObjectType );

    if ( WinStatus == NO_ERROR ) {
        AzPrint(( AZD_INVPARM, "AzpeSetProperty: Property ID for non-scalar: %ld\n", PropertyId ));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Actually set the property
    //
    AzpLockResourceExclusive( &AzGlResource );
    WinStatus = ObSetProperty(
            (PGENERIC_OBJECT)AzpeObjectHandle,
            lPersistFlags,
            PropertyId,
            PropertyValue);

    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}

DWORD
AzpeSetObjectOptions(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG ObjectOptions
    )
/*++

Routine Description:

    The provider should call AzpeSetObjectOptions to tell AzRoles about optional
    characteristics of the object.  It should be called from a thread processing
    a call to AzPersistOpen, AzPersistUpdateCache, or AzPersistUpdateChildrenCache,
    AzPersistRefresh for each object read from the authorization database.  It should
    be called from a thread processing a call to AzPersistSubmit for each newly created object.

Arguments:

    AzpeObjectHandle - Specifies a handle to the object.

    lPersistFlags - Specifies a bit mask describing the operation. The provider should
        pass the same flags that were passed to it by AzRoles when AzRoles called the AzPersist*.

    ObjectOptions - Specifies a bit mask containing one or more of the following bits:

        AZPE_OPTIONS_WRITABLE  (0x1) - If this bit is set, then the current user can write
            this object.  This corresponds to the Writable method on the various objects.

        AZPE_OPTIONS_SUPPORTS_DACL  (0x2) - If this bit is set, then the provider supports
            setting AZ_PROP_POLICY_READERS and AZ_PROP_POLICY_ADMINS on this object.
            This bit should only be specified if the object type is OBJECT_TYPE_AZAUTHSTORE,
            OBJECT_TYPE_APPLICATION or OBJECT_TYPE_SCOPE.

        AZPE_OPTIONS_SUPPORTS_DELEGATION (0x4) If this bit is set, then the provider
            supports setting AZ_PROP_DELEGATED_POLICY_USERS on this object.  This bit
            should only be specified if the object type is OBJECT_TYPE_AZAUTHSTORE
            or OBJECT_TYPE_APPLICATION.

        AZPE_OPTIONS_SUPPORTS_SACL  (0x8) - If this bit is set, then the provider
            supports setting AZ_PROP_APPLY_STORE_SACL on this object.  This bit should
            only be specified if the object type is OBJECT_TYPE_AZAUTHSTORE,
            OBJECT_TYPE_APPLICATION or OBJECT_TYPE_SCOPE.

        AZPE_OPTIONS_HAS_SECURITY_PRIVILEGE (0x10) - If this bit is set, then the current
            user has SE_SECURITY_PRIVILEGE on the machine containing the store.

        AZPE_OPTIONS_SUUPORTS_LAZY_LOAD (0x20) - If this bit is set, then the provider supports
            lazy load for children

        AZPE_OPTIONS_CREATE_CHILDREN - If this bit is set, then the current user can create children
             for this object.  Currently, user only for AzScope objects.


Return Value:

    NO_ERROR - The operation was successful
    ERROR_INVALID_FLAGS - lPersistFlags is invalid.

--*/
{
    PGENERIC_OBJECT GenericObject = (PGENERIC_OBJECT)AzpeObjectHandle;

    //
    // Ensure the provider didn't pass bogus flags
    //

    if ( (lPersistFlags & ~AZPE_FLAGS_PERSIST_MASK) != 0) {
        ASSERT( FALSE );
        return ERROR_INVALID_FLAGS;
    }

    if ( (ObjectOptions & ~AZPE_OPTIONS_VALID_MASK) != 0) {
        AzPrint(( AZD_INVPARM, "AzpeSetObjectOptions: bad options mask 0x%lx\n", ObjectOptions ));
        ASSERT( FALSE );
        return ERROR_INVALID_PARAMETER;
    }

    AzpLockResourceExclusive( &AzGlResource );

    //
    // Mark the object as writable
    //

    GenericObject->IsWritable = (( ObjectOptions & AZPE_OPTIONS_WRITABLE ) != 0);

    //
    // Mark whether the object support a DACL
    //

    if ( IsContainerObject( GenericObject->ObjectType )) {
        GenericObject->IsAclSupported = (( ObjectOptions & AZPE_OPTIONS_SUPPORTS_DACL ) != 0);
    } else {
        GenericObject->IsAclSupported = FALSE;
    }

    //
    // Mark whether the object support a SACL
    //

    if ( IsContainerObject( GenericObject->ObjectType )) {
        GenericObject->IsSACLSupported = (( ObjectOptions & AZPE_OPTIONS_SUPPORTS_SACL ) != 0);
    } else {
        GenericObject->IsSACLSupported = FALSE;
    }

    //
    // Load delegation support flag
    //

    if ( IsDelegatorObject( GenericObject->ObjectType ) ) {
        GenericObject->IsDelegationSupported = (( ObjectOptions & AZPE_OPTIONS_SUPPORTS_DELEGATION ) != 0);
    } else {
        GenericObject->IsDelegationSupported = FALSE;
    }

    //
    // Mark whether the current user has SE_SECURITY_PRIVILEGE on the store server
    //

    if ( GenericObject->ObjectType == OBJECT_TYPE_AZAUTHSTORE ) {
        ((PAZP_AZSTORE)GenericObject)->HasSecurityPrivilege = (( ObjectOptions & AZPE_OPTIONS_HAS_SECURITY_PRIVILEGE ) != 0);

        //
        // If the provider supports lazy load for children
        //

        ((PAZP_AZSTORE)GenericObject)->ChildLazyLoadSupported = ((ObjectOptions & AZPE_OPTIONS_SUPPORTS_LAZY_LOAD) != 0);
    }

    //
    // Mark if the AzScope object children can be created
    //

    if ( IsContainerObject(GenericObject->ObjectType) ) {
        GenericObject->CanCreateChildren = ((ObjectOptions & AZPE_OPTIONS_CREATE_CHILDREN) != 0);
    }

    AzpUnlockResource( &AzGlResource );
    return NO_ERROR;
}

VOID
AzpeObjectFinished(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN DWORD WinStatus
    )
/*++

Routine Description:

    The provider should call AzpeObjectFinished to indicate that it is finished
    updating the cache for a particular object.  It should only be called from a
    thread processing a call to AzPersistOpen, AzPersistUpdateCache, AzPersistUpdateChildrenCache,
    or AzPersistRefresh.

Arguments:

    AzpeObjectHandle - Specifies a handle to the object.

    WinStatus - Specifies whether the provider successfully set all attributes
    of the object.  If all attributes were set, specify NO_ERROR.  If not all attributes
    were set, specify an appropriate status code.

Return Value:

    None.

--*/
{
    PGENERIC_OBJECT GenericObject = (PGENERIC_OBJECT)AzpeObjectHandle;

    //
    // Initialization
    //
    AzpLockResourceExclusive( &AzGlResource );

    // Should no longer ASSERT on this condition.
    //ASSERT( WinStatus == NO_ERROR );

    ASSERT( (GenericObject->Flags & GENOBJ_FLAGS_PERSIST_OK) == 0 );

    //
    // Indicate that the provider has blessed the object
    //
    if ( WinStatus == NO_ERROR ) {
        GenericObject->Flags |= GENOBJ_FLAGS_PERSIST_OK;

        // Providers don't call AzpeCreateObject for the authorization store object.
        // So ensure the dirty bit gets set.
        //ASSERT( (GenericObject->PersistDirtyBits & AZ_DIRTY_CREATE) != 0 || GenericObject->ObjectType == OBJECT_TYPE_AZAUTHSTORE );
        GenericObject->PersistDirtyBits |= AZ_DIRTY_CREATE;
    }

    //
    // If this isn't the authorization store object,
    //  the provider got this handle from AzpeCreateObject,
    //  so dereference it.
    //
    if ( GenericObject->ObjectType != OBJECT_TYPE_AZAUTHSTORE ) {
        ObDereferenceObject( GenericObject );
    }

    AzpUnlockResource( &AzGlResource );
}

DWORD
AzpeGetProperty(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    The provider should call AzpeGetProperty to determine the value of scalar properties
    for a particular object.  It should only be called from a thread processing a call to
    AzPersistSubmit.

Arguments:

    AzpeObjectHandle - Specifies a handle to the object.

    lPersistFlags - Specifies a bit mask describing the operation. The provider should
        pass the same flags that were passed to it by AzRoles when AzRoles called the AzPersist*.

    PropertyId - Specifies the property ID of the property to get.  This should be one
        of the AZ_PROP_* defines.  See the section entitled PropertyId parameter for a
        list of valid values.

    PropertyValue - On success, returns a pointer to the buffer containing the property.
        The provider should free this buffer using AzpeFreeMemory.
        For properties that are strings, the returned pointer is of type LPWSTR.
        For properties that are LONGs, the returned pointer is of type PULONG.
        For properties that are Booleans, the returned pointer is of type PBOOL.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    ERROR_INVALID_FLAGS - lPersistFlags is invalid.
    ERROR_INVALID_PARAMETER - PropertyId is invalid.

--*/
{
    DWORD WinStatus;
    PGENERIC_OBJECT_LIST GenericObjectList;
    ULONG ObjectType;

    //
    // Ensure the provider didn't pass bogus flags
    //

    if ( (lPersistFlags & ~AZPE_FLAGS_PERSIST_SUBMIT) != 0) {
        ASSERT( FALSE );
        return ERROR_INVALID_FLAGS;
    }

    //
    // Ensure the provider is only getting a scalar property
    //

    WinStatus = ObMapPropIdToObjectList(
                                (PGENERIC_OBJECT)AzpeObjectHandle,
                                PropertyId,
                                &GenericObjectList,
                                &ObjectType );

    if ( WinStatus == NO_ERROR ) {
        AzPrint(( AZD_INVPARM, "AzpeGetProperty: Property ID for non-scalar: %ld\n", PropertyId ));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Go get the property value
    //
    AzpLockResourceExclusive( &AzGlResource );

    WinStatus = ObGetProperty(
                (PGENERIC_OBJECT)AzpeObjectHandle,
                lPersistFlags |
                    AZP_FLAGS_BY_GUID, // use guid from persist store if apply
                PropertyId,
                PropertyValue);

    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}

DWORD
AzpeGetDeltaArray(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG PropertyId,
    OUT PULONG DeltaArrayCount,
    OUT PAZP_DELTA_ENTRY **DeltaArray
    )
/*++

Routine Description:

    The provider should call AzpeObjectFinished to determine the value of non-scalar
    properties for a particular object.  It should only be called from a thread
    processing a call to AzPersistSubmit.

Arguments:

    AzpeObjectHandle - Specifies a handle to the object.

    lPersistFlags - Specifies a bit mask describing the operation. The provider should
        pass the same flags that were passed to it by AzRoles when AzRoles called the
        AzPersist*.

    PropertyId - Specifies the property ID of the property to get.  This should be one
        of the AZ_PROP_* defines.  See the section entitled PropertyId parameter for
        a list of valid values.

    DeltaArrayCount - On success, returns the number of elements in DeltaArray.
        The returned value may be zero if no changes have been made to the property.

    DeltaArray - On success, returns a pointers to the delta array.  This pointer need
        not be freed.  The pointer is only valid until the persistence provider returns
        from the AzPersistSubmit call.  The returned value may be NULL if no changes
        have been made to the property.


Return Value:

    NO_ERROR - The operation was successful
    ERROR_INVALID_PARAMETER - PropertyId is invalid.


--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT_LIST GenericObjectList;
    ULONG ObjectType;

    //
    // Map to the generic object list
    //

    WinStatus = ObMapPropIdToObjectList(
                                (PGENERIC_OBJECT)AzpeObjectHandle,
                                PropertyId,
                                &GenericObjectList,
                                &ObjectType );

    if ( WinStatus != NO_ERROR ) {
        AzPrint(( AZD_INVPARM, "AzpeGetDeltaArray: invalid prop id %ld\n", PropertyId ));
        return WinStatus;
    }

    //
    // Return the delta array from the object list
    //

    *DeltaArrayCount = GenericObjectList->DeltaArray.UsedCount;
    *DeltaArray = (PAZP_DELTA_ENTRY *)GenericObjectList->DeltaArray.Array;

    return NO_ERROR;

}

DWORD
AzpeObjectType(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    )
/*++

Routine Description:

    The routine returns the object type for a particular object

Arguments:

    AzpeObjectHandle - Specifies a handle to the objec

Return Value:
    Returns the object type of the object.  This will be one of the OBJECT_TYPE_* defines.

--*/
{
    return ((PGENERIC_OBJECT)AzpeObjectHandle)->ObjectType;
}

DWORD
AzpeDirtyBits(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    )
/*++

Routine Description:

    This routine returns a bit mask of the dirty bits for a particular object.
    Each bit corresponds to a property that has been modified by the application.
    It should only be called from a thread processing a call to AzPersistSubmit.

    The dirty bits are object type specific.  The provider should determine
    the object type of the object then should map each dirty bit to the corresponding
    property ID.  If the property ID corresponds to a scalar, the provider should call
    AzpeGetProperty to get the value of the property.  If the property ID corresponds
    to a list, the provider should call AzpeGetDeltaArray to get a description of what
    values where added to and removed from the property.  See the section entitled
    PropertyId Parameter for details.

    Each PropertyId maps to a single AZ_DIRTY_* dirty bit as returned from AzpeDirtyBits.
    The #define names exist on a one-to-one basis.  That is AZ_PROP_NAME is the property
    ID for AZ_DIRTY_NAME.

    There is one special dirty bit, AZ_DIRTY_CREATE.  That bit is set if the object
    was created by the application.

    If AzpeDirtyBits returns a bit the provider doesn't understand, the provider
    should fail the AzPersistSubmit call.


Arguments:

    AzpeObjectHandle - Specifies a handle to the object.


Return Value:

    Returns a bit mask specifying which properties where changed on the object.
    These bits are the AZ_DIRTY_* defines.

--*/
{
    return ((PGENERIC_OBJECT)AzpeObjectHandle)->DirtyBits;
}

GUID *
AzpePersistenceGuid(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    )
/*++

Routine Description:

    This routine returns a pointer to the location of the persistence GUID in the
    AzRoles cache.  The provider may read the returned location as long as the
    AzpeObjectHandle is valid.  The provider may only modify the returned location
    while processing an AzPersistSubmit call and then only if the AZ_DIRTY_CREATE
    bit was set.

Arguments:

    AzpeObjectHandle - Specifies a handle to the object.

Return Value:

    Returns a pointer to the location of the persistence GUID in the AzRoles cache.

--*/
{
    return &((PGENERIC_OBJECT)AzpeObjectHandle)->PersistenceGuid;
}

BOOLEAN
AzpeIsParentWritable(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    )
/*++
Routine Description:

    This routine returns the IsWritable property of the object's parent

Arguments:

    AzpeObjectHandle - Specifies a handle to the object

Return Value:

    BOOLEAN value indicating the IsWritable property of the parent

--*/
{
    return (BOOLEAN)(ParentOfChild((PGENERIC_OBJECT)AzpeObjectHandle)->IsWritable);
}

BOOLEAN
AzpeCanCreateChildren(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    )
/*++
Routine Description:

    This routine returns the CanCreateChildren property of the object's parent

Arguments:

    AzpeObjectHandle - Specifies a handle to the object

Return Value:

    BOOLEAN value indicating the IsWritable property of the parent

--*/
{
    return (BOOLEAN)(ParentOfChild((PGENERIC_OBJECT)AzpeObjectHandle)->CanCreateChildren);
}

BOOLEAN
AzpeUpdateChildren(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    )
/*++

Routine Description:

    This routine returns TRUE if the children of the object need to be updated into cache

Arguments:

    AzpeObjectHandle - Specifies a handle to the object

Return Value:

    BOOLEAN value indicating if the children of the object need to be updated into the cache

--*/
{
    BOOLEAN retVal = FALSE;

    if ( ((PGENERIC_OBJECT)AzpeObjectHandle)->ObjectType == OBJECT_TYPE_SCOPE ||
         ((PGENERIC_OBJECT)AzpeObjectHandle)->ObjectType == OBJECT_TYPE_APPLICATION ) {

         retVal = ((PGENERIC_OBJECT)AzpeObjectHandle)->AreChildrenLoaded;
    }

    return retVal;
}

AZPE_OBJECT_HANDLE
AzpeParentOfChild(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    )
/*++

Routine Description:

    This routine returns a handle to the parent of a particular object.
    The provider may use this parent handle as long as AzpeObjectHandle is valid.

Arguments:

    AzpeObjectHandle - Specifies a handle to the object.

Return Value:

        Returns a handle to the parent of a particular object.
        If AzpeObjectHandle is for an authorization store object, NULL is returned.

--*/
{

    return (AZPE_OBJECT_HANDLE)ParentOfChild((PGENERIC_OBJECT)AzpeObjectHandle);
}

DWORD
AzpeAddPropertyItemSid(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG PropertyId,
    IN PSID Sid
    )
/*++

Routine Description:

    The provider should call AzpeAddPropertyItemSid to set the value of a SID list
    property in the AzRoles object cache.  It should be called once from each SID
    in the SID list. It should only be called from a thread processing a call
    to AzPersistOpen, AzPersistUpdateCache, AzPersistUpdateChildrenCache or AzPersistRefresh.

    This routine may also be called from a thread processing AzPersistSubmit if the
    submitted AZ_PROP_POLICY_ADMINS list is empty.  In that case, the provider should default
    the AZ_PROP_POLICY_ADMINS list to the owner of the submitted file and should tell AzRoles
    who that own is by either calling AzpeSetSecurityDescriptorIntoCache or AzpeAddPropertyItemSid.

Arguments:

    AzpeObjectHandle - Specifies a handle to the object.

    lPersistFlags - Specifies a bit mask describing the operation. The provider should
        pass the same flags that were passed to it by AzRoles when AzRoles called the AzPersist*.

    PropertyId - Specifies the property ID of the property to set.  This should be one
        of the AZ_PROP_* defines.  See the section entitled PropertyId parameter for a
        list of valid values.

    Sid - Specifies a pointer to the SID to add to the Sid list

Return Value:

    NO_ERROR - The operation was successful
    ERROR_INVALID_FLAGS - lPersistFlags is invalid.
    ERROR_INVALID_PARAMETER - Property ID is invalid or the Sid is syntactically invalid.
    ERROR_NOT_ENOUGH_MEMORY - not enough memory

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT GenericObject = (PGENERIC_OBJECT)AzpeObjectHandle;
    PGENERIC_OBJECT_LIST GenericObjectList;
    ULONG ObjectType;
    AZP_STRING SidString;

    //
    // Ensure the provider didn't pass bogus flags
    //

    if ( (lPersistFlags & ~AZPE_FLAGS_PERSIST_MASK) != 0) {
        ASSERT( FALSE );
        return ERROR_INVALID_FLAGS;
    }

    //
    // Handle calls from submit.
    //

    if ( lPersistFlags & AZPE_FLAGS_PERSIST_SUBMIT ) {

        //
        // Submit is only allowed for Policy admins
        //  .. on the authorization store object
        //  .. if there is no an empty policy admins list
        //
        if ( PropertyId != AZ_PROP_POLICY_ADMINS ||
             GenericObject->ObjectType != OBJECT_TYPE_AZAUTHSTORE &&
             GenericObject->PolicyAdmins.GenericObjects.UsedCount == 0 ) {

            AzPrint(( AZD_INVPARM, "AzpeAddPropertyItemSid: called from submit: %ld %ld %ld\n",
                      PropertyId,
                      GenericObject->ObjectType,
                      GenericObject->PolicyAdmins.GenericObjects.UsedCount ));

            ASSERT( FALSE );
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Treat this as though it came from reconcile.
        //  That ensure the cache really gets updated but the dirty bits don't
        //

        lPersistFlags |= AZP_FLAGS_RECONCILE;
        lPersistFlags &= ~AZPE_FLAGS_PERSIST_SUBMIT;

    }

    //
    // Initialization
    //
    AzpLockResourceExclusive( &AzGlResource );


    //
    // Validate the Property ID
    //

    WinStatus = ObMapPropIdToObjectList(
                                GenericObject,
                                PropertyId,
                                &GenericObjectList,
                                &ObjectType );

    if ( WinStatus != NO_ERROR ) {
        AzPrint(( AZD_INVPARM, "AzpeAddPropertyItemSid: invalid prop id %ld\n", PropertyId ));
        goto Cleanup;
    }



    //
    // Validate a passed in SID
    //

    if ( !RtlValidSid( Sid ) ) {
        AzPrint(( AZD_INVPARM, "AzpeAddPropertyItemSid: SID not valid\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }



    //
    // Add the property item
    //

    AzpInitSid( &SidString, Sid );
    WinStatus = ObAddPropertyItem(
                    GenericObject,
                    GenericObjectList,
                    lPersistFlags,
                    &SidString );

Cleanup:
    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}


DWORD
AzpeAddPropertyItemGuid(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG PropertyId,
    IN GUID *ObjectGuid
    )
/*++

Routine Description:

    The provider should call AzpeAddPropertyItemGuid to set the value of a property
    that is a list of other object in the AzRoles object cache.  It should be called
    once from each object in the list. It should only be called from a thread
    processing a call to AzPersistOpen, AzPersistUpdateCache, AzPersistUpdateChildrenCache
    or AzPersistRefresh.

Arguments:

    AzpeObjectHandle - Specifies a handle to the object.

    lPersistFlags - Specifies a bit mask describing the operation. The provider should
    pass the same flags that were passed to it by AzRoles when AzRoles called the AzPersist*.

    PropertyId - Specifies the property ID of the property to set.  This should be one of
    the AZ_PROP_* defines.  See the section entitled PropertyId parameter for a list of
    valid values.

    ObjectGuid - Specifies the persistence GUID of the object in the list.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_INVALID_FLAGS - lPersistFlags is invalid.
    ERROR_INVALID_PARAMETER - Property ID is invalid
    ERROR_NOT_ENOUGH_MEMORY - not enough memory


--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT_LIST GenericObjectList;
    ULONG ObjectType;

    //
    // Ensure the provider didn't pass bogus flags
    //

    if ( (lPersistFlags & ~AZPE_FLAGS_PERSIST_OPEN_MASK) != 0) {
        ASSERT( FALSE );
        return ERROR_INVALID_FLAGS;
    }


    //
    // Validate the Property ID
    //

    WinStatus = ObMapPropIdToObjectList(
                                (PGENERIC_OBJECT)AzpeObjectHandle,
                                PropertyId,
                                &GenericObjectList,
                                &ObjectType );

    if ( WinStatus != NO_ERROR ) {
        AzPrint(( AZD_INVPARM, "AzpeAddPropertyItemGuid: invalid prop id %ld\n", PropertyId ));
        return WinStatus;
    }

    AzpLockResourceExclusive( &AzGlResource );

    WinStatus = ObAddPropertyItem(
                (PGENERIC_OBJECT)AzpeObjectHandle,
                GenericObjectList,
                lPersistFlags |
                    AZP_FLAGS_BY_GUID,
                (PAZP_STRING)ObjectGuid);

    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}


DWORD
AzpeAddPropertyItemGuidString(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN ULONG PropertyId,
    IN WCHAR *ObjectGuidString
    )
/*++

Routine Description:

    AzpeAddPropertyItemGuidString is identical to AzpeAddPropertyItemGuid except it
    takes the GUID as an LPWSTR.  The provider may call whichever function is more convenient.

Arguments:

    AzpeObjectHandle - Specifies a handle to the object.

    lPersistFlags - Specifies a bit mask describing the operation. The provider should
    pass the same flags that were passed to it by AzRoles when AzRoles called the AzPersist*.

    PropertyId - Specifies the property ID of the property to set.  This should be one
    of the AZ_PROP_* defines.  See the section entitled PropertyId parameter for a list
    of valid values.

    ObjectGuidString - Specifies the persistence GUID of the object in the list.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_INVALID_FLAGS - lPersistFlags is invalid.
    ERROR_INVALID_PARAMETER - Property ID is invalid
    ERROR_NOT_ENOUGH_MEMORY - not enough memory

--*/
{
    DWORD dwErr;
    GUID  ObjectGuid;

    //
    // Convert the string to a GUID
    //
    ASSERT(NULL != ObjectGuidString);

    dwErr = UuidFromString(ObjectGuidString, &ObjectGuid);
    if (S_OK != dwErr)
    {
        goto Cleanup;
    }


    //
    // Use the routine that takes a binary GUID
    //

    dwErr = AzpeAddPropertyItemGuid( AzpeObjectHandle,
                                     lPersistFlags,
                                     PropertyId,
                                     &ObjectGuid );

Cleanup:
    return dwErr;
}

PVOID
AzpeGetProviderData(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle
    )
/*++

Routine Description:

    AzpeGetProviderData returns a pointer to buffer previously stored by AzpeSetProviderData.
    The provider is responsible for providing any synchronization for the data.
    The provider should only access the data from a thread processing a call to one of
    the AzPersist* routines.

Arguments:

    AzpeObjectHandle - Specifies a handle to the object.

Return Value:

    A pointer to the data the provider previously passed into AzpeSetProviderData

--*/
{
    return ((PGENERIC_OBJECT)AzpeObjectHandle)->ProviderData;
}

VOID
AzpeSetProviderData(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN PVOID ProviderData
    )
/*++

Routine Description:

    It may be convenient for the provider to store some provider specific data on
    each object.  AzpeSetProviderData stores a pointer to that data in the AzRoles cache.
    Azoles will automatically delete the pointed to data when it deletes the cache entry.

    The provider may clear a previously stored pointer by specifying NULL as
    ProviderData.

    The provider is responsible for providing any synchronization for the data.
    The provider should only access the data from a thread processing a call to one
    of the AzPersist* routines.

Arguments:

    AzpeObjectHandle - Specifies a handle to the object.

    ProviderData - Specifies a pointer to data to be stored by the provider.
        The buffer should have been allocated using AzpeAllocateMemory.  AzRoles
        will delete this data when the cache entry is deleted by using AzpeFreeMemory.

Return Value:

    None

--*/
{
    ((PGENERIC_OBJECT)AzpeObjectHandle)->ProviderData = ProviderData;
}

VOID
AzpeFreeMemory(
    IN PVOID Buffer
    )
/*++

Routine Description

    The provider must use AzpeFreeMemory to free memory allocated by AzpeAllocateMemory,
    AzpeGetProperty, and AzpeGetSecurityDescriptorFromCache.

Arguments

    Buffer - Specifies a pointer to the buffer to be free.
    If NULL, the call is silently ignored.


Return Value

    None

--*/
{
    if ( Buffer != NULL ) {
        AzpFreeHeap( Buffer );
    }
}


PVOID
AzpeAllocateMemory(
    IN SIZE_T Size
    )
/*++

Routine Description:

    The provider may call AzpeAllocateMemory to allocate memory. The provider
    must use AzpeAllocateMemory to allocate memory passed to AzpeSetProviderData
    and returned in the pwszTargetMachine parameter to AzPersistOpen.  The provider
    may use AzpeAllocateMemory for other memory allocation. The provider must
    not have any memory allocated after it returns from AzPersistClose.

Arguments:

    Size - Size in bytes of the memory to allocate.

Return Values:

    Returns a pointer to the allocated memory.
    NULL - Not enough memory

--*/
{

    return AzpAllocateHeap( Size, "AZPEALOC" );
}


DWORD
AzpSdToPolicy(
    IN PSECURITY_DESCRIPTOR pSD,
    IN PAZP_POLICY_USER_RIGHTS pAdminRights OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS pReaderRights OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS pDelegatedUserRights OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS pSaclRights OPTIONAL,
    IN DWORD (*CallbackRoutine) (
                  IN PVOID Context,
                  IN ULONG lPersistFlags,
                  IN ULONG PropertyId,
                  IN PSID Sid ),
    IN PVOID Context,
    IN ULONG lPersistFlags
    )
/*++

Routine Description:

    AzpSdToPolicy parses a security descriptor and determines which ACEs correspond
    to AZ_PROP_POLICY_ADMINS, AZ_PROP_POLICY_READERS, and AZ_PROP_DELEGATED_POLICY_USERS properties.
    For each such Sid, the routine calls a callback routine to tell the caller about the sid.

    It also determines whether AZ_PORP_APPLY_STORE_SACL is TRUE or FALSE by inspecting the SACL.
    After determining the value, the routine calls a callback routine to tell the caller the value.

Arguments:

    pSD - The current security descriptor for the object on the object in the store

    pAdminRights - Rights for admins (Mask and Flags)

    pReaderRights - Rights for readers (Mask and Flags).  Specify NULL if the readers list
        need not be added.  (For instance, for AzPersistSubmit as described above.)

    pDelegatedUserRights - An optional parameter specifying the delegated                               user's rights (Mask and Flags)

    pSaclRights - Specifies the rights to put on the SACL

    CallbackRoutine - Address of the routine to call for each policy sid.

    Context - Context to pass to the callback routine.

    lPersistFlags - Internal flags
        These flags are passed to the callback routine but are otherwise unused.

Return Values:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other values returned from CallbackRoutine

--*/
{

    DWORD WinStatus = 0;

    PACL pDacl;
    BOOL bDaclPresent;
    BOOL bDaclDefaulted;

    PACL pSacl;
    BOOL bSaclPresent;
    BOOL bSaclDefaulted;

    ACL_SIZE_INFORMATION AclInfo;

    PACE_HEADER pAceHeader;
    PACCESS_ALLOWED_ACE pAce;
    PSID pSid;

    ULONG lUserType;
    ULONG i;

    BOOL bPolicyAdmin;
    BOOL bPolicyReader;
    BOOL bDelegatedPolicyUser;

    BOOL ApplySacl;

    //
    // Validation
    //

    ASSERT( pSD != NULL );

    //
    // If the caller is interested, do the DACL
    //

    if ( pAdminRights || pReaderRights || pDelegatedUserRights) {

        //
        // Retrive the DACL information.  From this, the SIDs will
        // extracted for each ACE, and loaded into the policy readers/
        // admins and delegators list property accordingly.
        // All inherited ACEs will be discarded
        //

        if ( !GetSecurityDescriptorDacl(pSD,
                                        &bDaclPresent,
                                        &pDacl,
                                        &bDaclDefaulted
                                        ) ) {
            WinStatus = GetLastError();
            goto Cleanup;
        }


        if( !bDaclPresent ||
            (pDacl == NULL)
            ) {

            WinStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        //
        // We now need the ACL information from the DACL
        //

        if ( !GetAclInformation(
                  pDacl,
                  &AclInfo,
                  sizeof( ACL_SIZE_INFORMATION ),
                  AclSizeInformation
                  ) ) {

            WinStatus = GetLastError();
            goto Cleanup;
        }

        //
        // Loop through all the SIDs in the ACEs adding each one to the appropriate
        // user type.  Ignore all inherited ACEs
        //

        for ( i = 0; i < AclInfo.AceCount; i++ ) {

            if ( GetAce( pDacl, i, (PVOID *)&pAce ) ) {

                ASSERT( pAce != NULL );

                pAceHeader = (PACE_HEADER) pAce;

                //
                // Allowed ACEs should only be added
                //

                if ( pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE ||
                     pAceHeader->AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE ) {

                    //
                    // Pick up the AzRoles policy aces.  Ignore inherited ACEs
                    //

                    if ( !(pAceHeader->AceFlags & INHERITED_ACE) ) {

                        bDelegatedPolicyUser = pDelegatedUserRights != NULL &&
                            !(pAce->Mask ^ pDelegatedUserRights->lUserRightsMask) &&
                            (pAceHeader->AceFlags == pDelegatedUserRights->lUserRightsFlags);

                        bPolicyAdmin = pAdminRights != NULL &&
                            !(pAce->Mask ^ pAdminRights->lUserRightsMask) &&
                            (pAceHeader->AceFlags & INHERIT_ONLY_ACE) == 0;

                        bPolicyReader = pReaderRights != NULL &&
                            !(pAce->Mask ^ pReaderRights->lUserRightsMask) &&
                            (pAceHeader->AceFlags & pReaderRights->lUserRightsFlags) == pReaderRights->
                            lUserRightsFlags &&
                            (pAceHeader->AceFlags & INHERIT_ONLY_ACE) == 0;

                        if ( bPolicyAdmin ||
                             bPolicyReader ||
                             bDelegatedPolicyUser
                             ) {

                            pSid = (PSID)&pAce->SidStart;

                            if ( bDelegatedPolicyUser ) {

                                lUserType = AZ_PROP_DELEGATED_POLICY_USERS;

                                pSid = RtlObjectAceSid( pAce );

                            } else if ( bPolicyAdmin ) {

                                lUserType = AZ_PROP_POLICY_ADMINS;

                            } else {

                                lUserType = AZ_PROP_POLICY_READERS;

                            }

                            if ( IsValidSid( pSid ) ) {

                                WinStatus = (*CallbackRoutine)(
                                                Context,
                                                lPersistFlags,
                                                lUserType,
                                                pSid );

                                if ( WinStatus != NO_ERROR ) {

                                    goto Cleanup;
                                }


                            } // if ( IsValidSid( pSid )

                        } // if AzRoles policy ace

                    } // if not inherited

                } // if ACCESS_ALLOWED_ACE_TYPE

            } // if GetAce

        } // for ( i=0; i<AceCount; i++ )
    }

    //
    // If the caller is interested, do the SACL
    //

    if ( pSaclRights ) {

        //
        // Retrive the SACL information.
        //
        // Use it to determine AZ_PORP_APPLY_STORE_SACL
        //

        if ( !GetSecurityDescriptorSacl(pSD,
                                        &bSaclPresent,
                                        &pSacl,
                                        &bSaclDefaulted
                                        ) ) {
            WinStatus = GetLastError();
            goto Cleanup;
        }


        //
        // If there is a SACL,
        //  determine if we have put explicit ACEs in the SACL.
        //  If so, set ApplySacl TRUE
        //

        ApplySacl = FALSE;

        if( bSaclPresent && pSacl != NULL ) {

            //
            // We now need the ACL information from the SACL
            //

            if ( !GetAclInformation(
                      pSacl,
                      &AclInfo,
                      sizeof( ACL_SIZE_INFORMATION ),
                      AclSizeInformation
                      ) ) {

                WinStatus = GetLastError();
                goto Cleanup;
            }

            //
            // Loop through all ACEs
            //

            for ( i = 0; i < AclInfo.AceCount; i++ ) {

                pAce = NULL;

                if ( GetAce( pSacl, i, (PVOID *)&pAce ) ) {

                    ASSERT( pAce != NULL );

                    pAceHeader = (PACE_HEADER) pAce;

                    //
                    // Ignore non-audit ACEs and
                    // Ignore inherited ACEs
                    //

                    if ( pAceHeader->AceType != SYSTEM_AUDIT_ACE_TYPE ||
                         (pAceHeader->AceFlags & INHERITED_ACE) != 0 ) {
                        continue;
                    }

                    //
                    // If this is the explicit ACE we inserted,
                    //  the consider that the ApplySacl property is true for this object.
                    //

                    pSid = (PSID)&pAce->SidStart;

                    if ( RtlEqualSid( pSid, AzGlWorldSid ) &&
                         pAce->Mask == pSaclRights->lUserRightsMask ) {

                        ApplySacl = TRUE;
                        break;
                    }
                }
            }
        }


        //
        // Tell the caller the whether an explicit SACL was applied
        //

        WinStatus = (*CallbackRoutine)(
                        Context,
                        lPersistFlags,
                        AZ_PROP_APPLY_STORE_SACL,
                        (PSID)&ApplySacl );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }
    }

    WinStatus = NO_ERROR;

    //
    // Free local resources
    //
Cleanup:

    return WinStatus;
}

//
// Context for AzpeGetSecurityDescriptorFromCache
//
typedef struct _AZP_GET_ACL_CONTEXT_ENTRY {

    ULONG PropertyId;   // Property Id for this policy

    //
    // Policy Rights as specified by the caller.
    //  NULL implies the caller isn't interested

    PAZP_POLICY_USER_RIGHTS *ppPolicyRights;

    //
    // Delta array containing the merged data from the existing Security Descriptor
    //  plus the deltas added by the application
    //

    AZP_PTR_ARRAY ResultDeltaArray;

} AZP_GET_ACL_CONTEXT_ENTRY, *PAZP_GET_ACL_CONTEXT_ENTRY;

typedef struct _AZP_GET_ACL_CONTEXT {

    //
    // One entry for admins, readers, and delegators
    //
#define AZP_GET_ACL_CONTEXT_ADMINS      0
#define AZP_GET_ACL_CONTEXT_READERS     1
#define AZP_GET_ACL_CONTEXT_DELEGATORS  2
#define AZP_GET_ACL_CONTEXT_COUNT       3
    AZP_GET_ACL_CONTEXT_ENTRY ContextEntry[AZP_GET_ACL_CONTEXT_COUNT];

} AZP_GET_ACL_CONTEXT, *PAZP_GET_ACL_CONTEXT;




DWORD
AzpAddSidsToAcl(
    IN PAZP_PTR_ARRAY DeltaArray,
    IN DWORD AceFlags,
    IN ACCESS_MASK Mask,
    IN OUT PACL pDacl,
    IN GUID *pDelegatedObjectGuid
    )
/*++

Routine Description:

        This routine adds the SIDs in the passed SID array into the ACL
        with the given mask.

Arguments:

        pSids - The array of SIDs that need to be added to the ACL

        Mask - The mask used in each ace

        pDacl - Pointer to the ACL

        pDelegatedObjectGuid - GUID of the object this ACL will be placed on

Return Values:

        NO_ERROR - The SIDs were added successfully

        Other Status codes

--*/
{

    DWORD WinStatus = 0;
    ULONG i = 0;
    BOOL bResult = FALSE;

    //
    // Validation
    //

    AZASSERT( DeltaArray != NULL );
    AZASSERT( pDacl != NULL );

    for ( i = 0; i < DeltaArray->UsedCount; i++ ) {

        PAZP_DELTA_ENTRY DeltaEntry = (PAZP_DELTA_ENTRY)DeltaArray->Array[i];
        ASSERT( DeltaEntry->DeltaFlags & AZP_DELTA_SID );
        ASSERT( DeltaEntry->DeltaFlags & AZP_DELTA_ADD );

        if ( pDelegatedObjectGuid == NULL ) {

            bResult = AddAccessAllowedAceEx(
                          pDacl,
                          ACL_REVISION,
                          AceFlags,
                          Mask,
                          DeltaEntry->Sid
                          );
        } else {

            bResult = AddAccessAllowedObjectAce(
                          pDacl,
                          ACL_REVISION_DS,
                          AceFlags,
                          Mask,
                          pDelegatedObjectGuid,
                          NULL,
                          DeltaEntry->Sid
                          );
        }

        if ( !bResult ) {

            WinStatus = GetLastError();
            goto Cleanup;
        }
    }

    WinStatus = NO_ERROR;

Cleanup:

    return WinStatus;

}



DWORD
AzpGetSdWorker(
    IN PVOID Context,
    IN ULONG lPersistFlags,
    IN ULONG PropertyId,
    IN PSID Sid
    )
/*++

Routine Description:

    Worker routine for AzpeGetSecurityDescriptorFromCache.  This is a callback routine for AzpSdToPolicy.
    It is called for each policy SID and simply remembers the list of sids

Arguments:

    Context - Context from AzpeSetSecurityDescriptorIntoCache. In this case, the context
        is a pointer to a AZP_GET_ACL_CONTEXT structure.

    lPersistFlags - Internal flags

    PropertyId - AZ_PROP_* identifying the right granted to the Sid.

    Sid - Specifies the Sid the right is granted to.

Return Values:

    NO_ERROR - The operation was successful
    Other errors from AzpeAddPropertyItemSid.

--*/
{
    ULONG PolicyIndex;
    PAZP_GET_ACL_CONTEXT RealContext = (PAZP_GET_ACL_CONTEXT)Context;
    PAZP_GET_ACL_CONTEXT_ENTRY ContextEntry = NULL;
    AZP_STRING SidString;

    //
    // AZ_PROP_APPLY_STORE_SACL is a boolean.
    //  There is nothing to merge.
    //

    ASSERT( PropertyId != AZ_PROP_APPLY_STORE_SACL );

    //
    // Find the context entry for this policy
    //

    for ( PolicyIndex=0; PolicyIndex<AZP_GET_ACL_CONTEXT_COUNT; PolicyIndex++ ) {


        //
        // If the property ID matches,
        //  use it.
        //

        ContextEntry = &RealContext->ContextEntry[PolicyIndex];

        if ( ContextEntry->PropertyId == PropertyId ) {
            break;
        }

    }

    if ( PolicyIndex == AZP_GET_ACL_CONTEXT_COUNT ) {
        ASSERT( PolicyIndex != AZP_GET_ACL_CONTEXT_COUNT );
        return NO_ERROR;
    }



    //
    // If the caller isn't interested in this right,
    //  we're done.
    //

    if ( ContextEntry->ppPolicyRights == NULL ) {
        return NO_ERROR;
    }

    //
    // Add this sid to the list of Sids for this policy
    //

    AzpInitSid( &SidString, Sid );

    return ObAddDeltaToArray(
                    AZP_DELTA_SID | AZP_DELTA_ADD,
                    (GUID *)&SidString,
                    &ContextEntry->ResultDeltaArray,
                    TRUE ); // Discard entries that are deletions

    UNREFERENCED_PARAMETER( lPersistFlags );


}

DWORD
AzpeGetSecurityDescriptorFromCache(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags,
    IN PAZP_POLICY_USER_RIGHTS *ppPolicyAdminRights OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS *ppPolicyReaderRights OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS *ppDelegatedPolicyUsersRights OPTIONAL,
    IN GUID *pDelegatedObjectGuid OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS pDelegatedUsersAttributeRights OPTIONAL,
    IN GUID *pAttributeGuid OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS pSaclRights OPTIONAL,
    IN PSECURITY_DESCRIPTOR OldSd OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewSd
    )
/*++

Routine Description:

    AzpeGetSecurityDescriptorFromCache is a support routine for the AZ_PROP_POLICY_ADMINS,
    AZ_PROP_POLICY_READERS, AZ_PROP_DELEGATED_POLICY_USERS, and AZ_PROP_APPLY_STORE_SACL properties.
    The routine reads the deltas to those properties from the object cache and
    builds a DACL and SACL corresponding to that policy.

    The provider may choose to call AzpeGetDeltaArray for each of those properties
    if the provider's security model does not match that provided by this routine.

    This routine should only be called from a thread processing a call to AzPersistSubmit.


    The caller should only call this routine if the security descriptor should be written.
    Specifically, if the object was just created (the AZ_DIRTY_CREATE dirty bits is set
    for the object) or if the dirty bit for the properties mentioned above are set.
    AzpeGetSecurityDescriptorFromCache process the DACL and SACL separately.
    The caller should also. The caller should only specify the DACL specific parameters
    to this routine if the DACL is to be written. The caller should only specify the SACL
    specific parameter to this routine if the SACL is to be written.

    If the AZ_DIRTY_CREATE bit is not set, then the previous security descriptor from
    the object needs to be passed to AzpeGetSecurityDescriptorFromCache.  Again, the
    DACL should only be read if the DACL changed (as indicated by the dirty bits).
    The SACL should only be read if the SACL changed (as indicated by the dirty bits).
    Otherwise, the security descriptor read may fail because the caller has no access.

    The returned security descriptor has the SE_DACL_PROTECTED if an only if the DACL
    is to be marked as protected.

    The caller should not pass the generic access bit GENERIC_READ, GENERIC_WRITE,
    or GENERIC_EXECUTE to this routine.  This routine needs to do bit mask comparisons
    with the access mask on the ACLs on the security descriptor.  It cannot interpret
    the generic bits.  Instead, pass the object specific mask such as FILE_GENERIC_READ.



Arguments:

        AzpeObjectHandle - Handle to object whose ACLs will be read

        lPersistFlags - Internal flags

        ppPolicyAdminRights - Rights for policy admins.
            Specifies a NULL terminated array of pointers to AZP_POLICY_USER_RIGHTS structures.
            Each structure specifies an ACE to add to the DACL for each policy admin.
            The first element of the array must be the one passed to AzpeSetSecurityDescriptorIntoCache.

        ppPolicyReaderRights - Rights for policy readers
            Specifies a NULL terminated array of pointers to AZP_POLICY_USER_RIGHTS structures.
            Each structure specifies an ACE to add to the DACL for each policy reader.
            The first element of the array must be the one passed to AzpeSetSecurityDescriptorIntoCache.

        ppDelegatedPolicyUsersRights - Rights for delegated users
            Specifies a NULL terminated array of pointers to AZP_POLICY_USER_RIGHTS structures.
            Each structure specifies an ACE to add to the DACL for each delegated policy user.
            The first element of the array must be the one passed to AzpeSetSecurityDescriptorIntoCache.

        pDelegatedObjectGuid - GUID for an object on which the delegated users
                               will have read access on

        
        pDelegatedUsersAttributeRights - the rights that needs to be granted to the delegated users
            for the attribute whoese guid is given by the next parameter.
            
        pAttributeGuid - the attribute that will grant special access to the delegated attribute users,
    
        pSaclRights - Specifies the rights to put on the SACL

        OldSd - Specifies the existing security descriptor for the object
            Specify NULL for a newly created object.

        NewSd - Returns the new self relative security descriptor for the object.
            The returned buffer should be freed using AzpeFreeHeap.

Return Values:

        NO_ERROR - The ACLs were got successfully
        ERROR_EMPTY - The PolicyAdmins list was empty.  AzpeGetSecurityDescriptorFromCache added the
            CreatorOwner Sid to the DACL a admin.   The provider should apply that
            DACL then re-read the DACL to determine the actual PolicyAdmin.  The
            provider should tell AzRole about the actual AZ_PROP_POLICY_ADMINS by
            calling AzpeSetSecurityDescriptorIntoCache or by calling AzpeAddPropertyItemSid for the actual
            creator/owner returned in the read DACL

        Other status codes

--*/
{
    DWORD WinStatus;

    ULONG PolicyIndex;
    ULONG DeltaIndex;
    ULONG RightsCountIndex;

    AZP_GET_ACL_CONTEXT Context;
    PAZP_GET_ACL_CONTEXT_ENTRY ContextEntry;

    AZP_STRING SidString;
    ULONG SidSize;

    BOOLEAN UpdateDacl = (ppPolicyAdminRights != NULL || ppPolicyReaderRights != NULL || ppDelegatedPolicyUsersRights != NULL);
    DWORD DaclSize;
    PACL TempDacl = NULL;

    DWORD SaclSize;
    PACL TempSacl = NULL;

    SECURITY_DESCRIPTOR TempSd;
    ULONG ObjectType = AzpeObjectType(AzpeObjectHandle);

    BOOL SetCreatorOwner = FALSE;



    //
    // Initialization
    //
    // Build a table since each of the three policies are handled the same way
    //

    ASSERT( AzpeObjectHandle != NULL );
    RtlZeroMemory( &Context, sizeof(Context) );
    Context.ContextEntry[AZP_GET_ACL_CONTEXT_ADMINS].PropertyId = AZ_PROP_POLICY_ADMINS;
    Context.ContextEntry[AZP_GET_ACL_CONTEXT_ADMINS].ppPolicyRights = ppPolicyAdminRights;
    Context.ContextEntry[AZP_GET_ACL_CONTEXT_READERS].PropertyId = AZ_PROP_POLICY_READERS;
    Context.ContextEntry[AZP_GET_ACL_CONTEXT_READERS].ppPolicyRights = ppPolicyReaderRights;
    Context.ContextEntry[AZP_GET_ACL_CONTEXT_DELEGATORS].PropertyId = AZ_PROP_DELEGATED_POLICY_USERS;
    Context.ContextEntry[AZP_GET_ACL_CONTEXT_DELEGATORS].ppPolicyRights = ppDelegatedPolicyUsersRights;

    //
    // Ensure the provider didn't pass bogus parameters
    //

    if ( (lPersistFlags & ~AZPE_FLAGS_PERSIST_SUBMIT) != 0) {
        ASSERT( FALSE );
        WinStatus = ERROR_INVALID_FLAGS;
        goto Cleanup;
    }

    //
    // Initialize the local security descriptor
    //

    if ( !InitializeSecurityDescriptor( &TempSd, SECURITY_DESCRIPTOR_REVISION) ) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Get the Sids from the existing security descriptor on the object
    //
    // Call AzpGetSdWorker for each sid in the Security Descriptor
    //

    if ( OldSd != NULL ) {
        WinStatus = AzpSdToPolicy(
                        OldSd,
                        ppPolicyAdminRights ? ppPolicyAdminRights[0] : NULL,
                        ppPolicyReaderRights ? ppPolicyReaderRights[0] : NULL,
                        ppDelegatedPolicyUsersRights ? ppDelegatedPolicyUsersRights[0] : NULL,
                        NULL,   // No need to determine previous state of boolean
                        AzpGetSdWorker,
                        &Context,   // Context
                        lPersistFlags );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }
    }

    //
    // If the caller asked for one,
    //  Build the DACL
    //

    if ( UpdateDacl ) {

        //
        // Get the Sids that the application submitted
        //
        // Do it for each policy
        //

        for ( PolicyIndex=0; PolicyIndex<AZP_GET_ACL_CONTEXT_COUNT; PolicyIndex++ ) {
            ULONG SubmittedDeltaArrayCount;
            PAZP_DELTA_ENTRY *SubmittedDeltaArray;


            //
            // If the caller isn't asking for this policy,
            //  move to the next one

            ContextEntry = &Context.ContextEntry[PolicyIndex];
            if ( ContextEntry->ppPolicyRights == NULL ) {
                continue;
            }

            //
            // Get the submitted delta array from the object
            //

            WinStatus = AzpeGetDeltaArray(
                                AzpeObjectHandle,
                                ContextEntry->PropertyId,
                                &SubmittedDeltaArrayCount,
                                &SubmittedDeltaArray );

            if ( WinStatus != NO_ERROR ) {
                ASSERT( FALSE );
                goto Cleanup;
            }

            //
            // Add each Submitted delta entry to passed in delta array
            //

            for ( DeltaIndex=0; DeltaIndex<SubmittedDeltaArrayCount; DeltaIndex++ ) {

                ASSERT( SubmittedDeltaArray[DeltaIndex]->DeltaFlags & AZP_DELTA_SID );
                ASSERT( (SubmittedDeltaArray[DeltaIndex]->DeltaFlags & AZP_DELTA_PERSIST_PROVIDER) == 0 );

                AzpInitSid( &SidString, SubmittedDeltaArray[DeltaIndex]->Sid );

                WinStatus = ObAddDeltaToArray(
                                SubmittedDeltaArray[DeltaIndex]->DeltaFlags,
                                (GUID *)&SidString,
                                &ContextEntry->ResultDeltaArray,
                                TRUE ); // Discard entries that are deletions

                if ( WinStatus != NO_ERROR ) {
                    goto Cleanup;
                }

            }
        }



        //
        // If the caller wants the list of admins,
        //  and the AdminSids list is empty,
        //  and this is the authorization store object (and thus doesn't inherit PolicyAdmins),
        //  create one with just the creator/owner in it
        //

        if ( ppPolicyAdminRights != NULL &&
             Context.ContextEntry[AZP_GET_ACL_CONTEXT_ADMINS].ResultDeltaArray.UsedCount == 0 &&
             ObjectType == OBJECT_TYPE_AZAUTHSTORE ) {

            AzpInitSid( &SidString, AzGlCreatorOwnerSid );

            WinStatus = ObAddDeltaToArray(
                            AZP_DELTA_SID | AZP_DELTA_ADD,
                            (GUID *)&SidString,
                            &Context.ContextEntry[AZP_GET_ACL_CONTEXT_ADMINS].ResultDeltaArray,
                            TRUE ); // Discard entries that are deletions

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            SetCreatorOwner = TRUE;
        }

        //
        // Compute the size of the DACL
        //
        // Do it for each policy
        //

        DaclSize = sizeof( ACL );

        for ( PolicyIndex=0; PolicyIndex<AZP_GET_ACL_CONTEXT_COUNT; PolicyIndex++ ) {
            ULONG i;

            //
            // If the caller isn't asking for this policy,
            //  move to the next one

            ContextEntry = &Context.ContextEntry[PolicyIndex];
            if ( ContextEntry->ppPolicyRights == NULL ) {
                continue;
            }


            //
            // Determine the size of the ACLS after adding these ACEs
            //

            for ( i = 0; i < ContextEntry->ResultDeltaArray.UsedCount; i++ ) {
                PAZP_DELTA_ENTRY DeltaEntry = (PAZP_DELTA_ENTRY)ContextEntry->ResultDeltaArray.Array[i];

                ASSERT( DeltaEntry->DeltaFlags & AZP_DELTA_SID );
                ASSERT( DeltaEntry->DeltaFlags & AZP_DELTA_ADD );

                SidSize = GetLengthSid( DeltaEntry->Sid );

                //
                // We have one right count for delegate user's attribute specific ACE
                //
                
                if ( PolicyIndex == AZP_GET_ACL_CONTEXT_DELEGATORS &&
                    pDelegatedUsersAttributeRights != NULL && pAttributeGuid != NULL ) {
                    
                    DaclSize += sizeof( ACE_HEADER ) + sizeof ( ACCESS_MASK ) + SidSize +
                                + sizeof (ULONG)        // For object ACE flags
                                + sizeof( GUID );       // For attribute GUID
                }
                
                for ( RightsCountIndex = 0;
                      ContextEntry->ppPolicyRights[RightsCountIndex] != NULL;
                      RightsCountIndex++ ) {

                    DaclSize += sizeof( ACE_HEADER ) + sizeof ( ACCESS_MASK ) + SidSize;

                    if ( ContextEntry->ppPolicyRights[RightsCountIndex]->lUserRightsFlags &
                         INHERIT_ONLY_ACE ) {

                        DaclSize += sizeof (ULONG) // For object ACE flags
                                 + sizeof( GUID ); // For object GUID
                    }
                }
            }
            
        }



        //
        // Allocate a temporary buffer for the DACL
        //

        SafeAllocaAllocate( TempDacl, DaclSize )

        if ( TempDacl == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }


        //
        // Fill in the DACL
        //

        if ( !InitializeAcl( TempDacl, DaclSize, ACL_REVISION ) ) {
            WinStatus = GetLastError();
            goto Cleanup;
        }

        for ( PolicyIndex=0; PolicyIndex<AZP_GET_ACL_CONTEXT_COUNT; PolicyIndex++ ) {

            //
            // If the caller isn't asking for this policy,
            //  move to the next one

            ContextEntry = &Context.ContextEntry[PolicyIndex];
            if ( ContextEntry->ppPolicyRights == NULL ) {
                continue;
            }

            //
            // If there are no Sids to add,
            //  move on to the next one
            //

            if ( ContextEntry->ResultDeltaArray.UsedCount == 0 ) {
                continue;
            }

            //
            // Loop for each right to add
            //

            for ( RightsCountIndex = 0;
                  ContextEntry->ppPolicyRights[RightsCountIndex] != NULL;
                  RightsCountIndex++ ) {

                PAZP_POLICY_USER_RIGHTS pPolicyRights = ContextEntry->ppPolicyRights[RightsCountIndex];

                WinStatus = AzpAddSidsToAcl(
                                &ContextEntry->ResultDeltaArray,
                                pPolicyRights->lUserRightsFlags,
                                pPolicyRights->lUserRightsMask,
                                TempDacl,
                                (pPolicyRights->lUserRightsFlags & INHERIT_ONLY_ACE) ? pDelegatedObjectGuid:NULL );

                if ( WinStatus != NO_ERROR ) {
                    goto Cleanup;
                }

            }

            //
            // If we are processing delegators and the caller
            // asks us to put delegated users' attribute rights
            //
            
            if ( PolicyIndex == AZP_GET_ACL_CONTEXT_DELEGATORS &&
                 pDelegatedUsersAttributeRights != NULL && pAttributeGuid != NULL ) {
                    
                WinStatus = AzpAddSidsToAcl(
                                &ContextEntry->ResultDeltaArray,
                                pDelegatedUsersAttributeRights->lUserRightsFlags,
                                pDelegatedUsersAttributeRights->lUserRightsMask,
                                TempDacl,
                                pAttributeGuid
                                );

                if ( WinStatus != NO_ERROR ) {
                    goto Cleanup;
                }
            }
            
        }

        //
        // Add the DACL to the security descriptor
        //

        if ( !SetSecurityDescriptorDacl(
                  &TempSd,
                  TRUE,
                  TempDacl,
                  FALSE ) ) {

            WinStatus = GetLastError();
            goto Cleanup;
        }

        //
        // If this is the authorization store object, and
        //  the caller isn't asking for the SD of the "container" object for delegators,
        //  mark the SD as protected so azroles has absolute control of the DACL.
        //

        if ( ObjectType == OBJECT_TYPE_AZAUTHSTORE &&
             (ppPolicyAdminRights != NULL || ppPolicyReaderRights != NULL) ) {

            TempSd.Control |= SE_DACL_PROTECTED;

        }
    }


    //
    // If the caller asked for one, Build the SACL
    //
    // Only container objects can have a SACL
    //

    if ( pSaclRights && IsContainerObject( ObjectType ) ) {

        //
        // Only apply a SACL if one is configured
        //

        if ( ((PGENERIC_OBJECT)AzpeObjectHandle)->ApplySacl ) {

            //
            // Determine the size of the SACL
            //

            SaclSize = sizeof(ACL) +
                       sizeof(ACE_HEADER) +
                       sizeof(ACCESS_MASK) +
                       AzGlWorldSidSize;


            //
            // Allocate a buffer for the SACL
            //

            SafeAllocaAllocate( TempSacl, SaclSize );

            if ( TempSacl == NULL ) {
                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            //
            // Initialize the SACL
            //

            if ( !InitializeAcl( TempSacl, SaclSize, ACL_REVISION ) ) {
                WinStatus = GetLastError();
                goto Cleanup;
            }

            if ( !AddAuditAccessAceEx( TempSacl,
                                       ACL_REVISION,
                                       pSaclRights->lUserRightsFlags,
                                       pSaclRights->lUserRightsMask,
                                       AzGlWorldSid,
                                       TRUE,        // Audit Success
                                       TRUE )) {    // Audit Failure

                WinStatus = GetLastError();
                goto Cleanup;
            }

            //
            // Add the SACL to the security descriptor
            //
            // The SACL is never protected
            //

            if ( !SetSecurityDescriptorSacl(
                      &TempSd,
                      TRUE,
                      TempSacl,
                      FALSE ) ) {

                WinStatus = GetLastError();
                goto Cleanup;
            }
        }

    }


    //
    // Return a self relative SD back to the caller.
    //

    WinStatus = AzpConvertAbsoluteSDToSelfRelative(
                    &TempSd,
                    NewSd );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Tell the caller that he needs to re-read the security descriptor
    //
    if ( SetCreatorOwner ) {
        WinStatus = ERROR_EMPTY;
    }

Cleanup:

    //
    // Free the temporary resultant delta array
    //

    for ( PolicyIndex=0; PolicyIndex<AZP_GET_ACL_CONTEXT_COUNT; PolicyIndex++ ) {

        //
        // If the caller isn't asking for this policy,
        //  move to the next one

        ContextEntry = &Context.ContextEntry[PolicyIndex];

        ASSERT( ContextEntry->ResultDeltaArray.UsedCount == 0 ||
                ContextEntry->ppPolicyRights != NULL );

        ObFreeDeltaArray( &ContextEntry->ResultDeltaArray,
                          TRUE );   // FreeAllEntries

    }

    SafeAllocaFree( TempDacl )
    SafeAllocaFree( TempSacl )

    return WinStatus;
}


DWORD
AzpSetSdWorker(
    IN PVOID Context,
    IN ULONG lPersistFlags,
    IN ULONG PropertyId,
    IN PSID Sid
    )
/*++

Routine Description:

    Worker routine for AzpeSetSecurityDescriptorIntoCache. It is a callback routine for AzpSdToPolicy.
    It is called for each policy SID and simply call AzpeAddPropertyItemSid for the SID.

Arguments:

    Context - Context from AzpeSetSecurityDescriptorIntoCache In this case, the context is the
        AzpeObjectHandle.

    lPersistFlags - Internal flags

    PropertyId - AZ_PROP_* identifying the right granted to the Sid.

    Sid - Specifies the Sid the right is granted to.

Return Values:

    NO_ERROR - The operation was successful
    Other errors from AzpeAddPropertyItemSid.

--*/
{

    //
    // For AZ_PROP_APPLY_STORE_SACL, call AzpeSetProperty.
    //

    if ( PropertyId == AZ_PROP_APPLY_STORE_SACL ) {

        return AzpeSetProperty(
                        (AZPE_OBJECT_HANDLE)Context,
                        lPersistFlags,
                        PropertyId,
                        Sid );


    //
    // For all other property IDs, simply add the sid to the cache
    //

    } else {

        return AzpeAddPropertyItemSid(
                        (AZPE_OBJECT_HANDLE)Context,
                        lPersistFlags,
                        PropertyId,
                        Sid );
    }


}




DWORD
AzpeSetSecurityDescriptorIntoCache(
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN PSECURITY_DESCRIPTOR pSD,
    IN ULONG lPersistFlags,
    IN PAZP_POLICY_USER_RIGHTS pAdminRights,
    IN PAZP_POLICY_USER_RIGHTS pReaderRights OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS pDelegatedUserRights OPTIONAL,
    IN PAZP_POLICY_USER_RIGHTS pSaclRights OPTIONAL
    )
/*++

Routine Description:

    AzpeSetSecurityDescriptorIntoCache is a support routine for the AZ_PROP_POLICY_ADMINS,
    AZ_PROP_POLICY_READERS, AZ_PROP_DELEGATED_POLICY_USERS, and AZ_PROP_APPLY_STORE_SACL properties.
    It inspects the security descriptor for the object and set each of the above
    properties based on the ACEs found.

    The routine walks the DACL of the security descriptor for an object then
    calls AzpeAddPropertyItemSid for each non-inherited ACE.  The provider
    may choose to call AzpeAddPropertyItemSid itself if the provider's security model
    does not match that provided by this routine.

    The routine also walks the SACL of the security descriptor and calls AzpeSetProperty
    setting AZ_PROP_APPLY_STORE_SACL to TRUE or FALSE depending on whether there is a
    non-inherited ACE specifying the rights passed in pSaclRights.

    This routine should only be called from a thread processing a call to AzPersistOpen,
    AzPersistUpdateCache, AzPersistUpdateChildrenCache or AzPersistRefresh.

    This routine may also be called from a thread processing AzPersistSubmit if the
    submitted AZ_PROP_POLICY_ADMINS list is empty.  In that case, the provider should default
    the AZ_PROP_POLICY_ADMINS list to the owner of the submitted file and should tell AzRoles
    who that own is by either calling AzpeSetSecurityDescriptorIntoCache or AzpeAddPropertyItemSid.

Arguments:

    AzpeObjectHandle - Pointer to object whose policy admins and readers needs to be loaded.

    pSD - The current security descriptor for the object on the object in the store

    lPersistFlags - Internal flags

    pAdminRights - Rights for admins (Mask and Flags)

    pReaderRights - Rights for readers (Mask and Flags).  Specify NULL if the readers list
        need not be added.  (For instance, for AzPersistSubmit as described above.)

    pDelegatedUserRights - An optional parameter specifying the delegated                               user's rights (Mask and Flags)

    pSaclRights - Specifies the rights for the SACL.  By convention the provider
        should specify a mask consisting of all the access bits indicating modification
        to the policy store.  For instance, DELETE|WRITE_DAC|WRITE_OWNER|FILE_GENERIC_WRITE,
        would be appropriate for a file based store.

        The parameter should be NULL if AZ_PROP_APPLY_STORE_SACL isn't being set
        into the cache.  For instance, when caller doesn't have SE_SECURITY_PRIVILEGE
        or during AzPersistSubmit if the submitted AZ_PROP_POLICY_ADMINS list is empty.


Return Values:

    NO_ERROR - The operation was successful
    ERROR_INVALID_FLAGS - lPersistFlags is invalid.
    ERROR_INVALID_PARAMETER - Property ID is invalid
    ERROR_NOT_ENOUGH_MEMORY - not enough memory

--*/
{
    //
    // Validation
    //

    ASSERT( AzpeObjectHandle != NULL );

    //
    // Ensure the provider didn't pass bogus flags
    //

    if ( (lPersistFlags & ~AZPE_FLAGS_PERSIST_MASK) != 0) {
        ASSERT( FALSE );
        return ERROR_INVALID_FLAGS;
    }

    //
    // Call AzpSetSdWorker for each sid in the Security Descriptor
    //

    return AzpSdToPolicy(
                    pSD,
                    pAdminRights,
                    pReaderRights,
                    pDelegatedUserRights,
                    pSaclRights,
                    AzpSetSdWorker,
                    AzpeObjectHandle,   // Context
                    lPersistFlags );

}

BOOL
AzpeAzStoreIsBatchUpdateMode(
    IN AZPE_OBJECT_HANDLE hObject
    )
/*++

Description:

    Determines if the az store is initialized with a batch update flag.
    This flag is set if the store is created to update massive amount of objects.

Arguments:

    hObject - the object handle

Return Values:

    True if the initialization flag has that bit set.

--*/
{
    PAZP_AZSTORE pAzStore = (PAZP_AZSTORE)( ((PGENERIC_OBJECT)hObject)->AzStoreObject );
    return (pAzStore->InitializeFlag & AZ_AZSTORE_FLAG_BATCH_UPDATE);
}

AZPE_OBJECT_HANDLE
AzpeGetAuthorizationStore(
    IN AZPE_OBJECT_HANDLE hObject
    )
/*++

Description:

    Get the store handle from any object

Arguments:

    hObject - the object handle

Return Values:

    Returns the object's store handle

--*/
{
    return (AZPE_OBJECT_HANDLE)( ((PGENERIC_OBJECT)hObject)->AzStoreObject );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\stdafx.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    stdafx.cxx

Abstract:

    generated file, don't change

// stdafx.cxx : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

Author:

    Xiaoxi Tan (xtan) 11-May-2001

--*/

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\sid.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sid.cxx

Abstract:

    Routines implementing the SID pseudo-object.

Author:

    Cliff Van Dyke (cliffv) 8-May-2001

--*/

#include "pch.hxx"



DWORD
AzpSidInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzSidCreate.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    PAZP_SID AzpSid = (PAZP_SID) ChildGenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Behave differently depending on the object type of the parent object
    //

    ASSERT( ParentGenericObject->ObjectType == OBJECT_TYPE_AZAUTHSTORE ||
            ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION ||
            ParentGenericObject->ObjectType == OBJECT_TYPE_SCOPE );

    //
    // Sids are referenced by groups and roles.
    //
    //  Let the generic object manager know all of the lists we support
    //

    ChildGenericObject->GenericObjectLists = &AzpSid->backGroupMembers,

    // Sids are referenced by groups
    ObInitObjectList( &AzpSid->backGroupMembers,
                      &AzpSid->backGroupNonMembers,
                      TRUE,     // backward link
                      AZP_LINKPAIR_SID_MEMBERS,
                      0,    // No dirty bit on back link
                      NULL,
                      NULL,
                      NULL );

    ObInitObjectList( &AzpSid->backGroupNonMembers,
                      &AzpSid->backRoles,
                      TRUE,     // backward link
                      AZP_LINKPAIR_SID_NON_MEMBERS,
                      0,    // No dirty bit on back link
                      NULL,
                      NULL,
                      NULL );

    // Sids are referenced by "Roles"
    ObInitObjectList( &AzpSid->backRoles,
                      &AzpSid->backAdmins,
                      TRUE,     // Backward link
                      0,        // No link pair id
                      0,    // No dirty bit on back link
                      NULL,
                      NULL,
                      NULL );


    // Sids are referenced by object admins
    ObInitObjectList( &AzpSid->backAdmins,
                      &AzpSid->backReaders,
                      TRUE,     // Backward link
                      AZP_LINKPAIR_POLICY_ADMINS,      // diff admins and readers
                      0,    // No dirty bit on back link
                      NULL,
                      NULL,
                      NULL );


    if ( !IsDelegatorObject( ParentGenericObject->ObjectType ) ) {

        // Sids are referenced by object readers
        ObInitObjectList( &AzpSid->backReaders,
                          NULL,
                          TRUE,     // Backward link
                          AZP_LINKPAIR_POLICY_READERS,     // diff admins and readers
                          0,    // No dirty bit on back link
                          NULL,
                          NULL,
                          NULL );

    } else {

        // Sids are referenced by object readers
        ObInitObjectList( &AzpSid->backReaders,
                          &AzpSid->backDelegatedPolicyUsers,
                          TRUE,     // Backward link
                          AZP_LINKPAIR_POLICY_READERS,     // diff admins and readers
                          0,    // No dirty bit on back link
                          NULL,
                          NULL,
                          NULL );

        // Sids are referenced by delegated object users

        ObInitObjectList( &AzpSid->backDelegatedPolicyUsers,
                          NULL,
                          TRUE,     // Backward link
                          AZP_LINKPAIR_DELEGATED_POLICY_USERS,
                          0,    // No dirty bit on back link
                          NULL,
                          NULL,
                          NULL );
    }

    return NO_ERROR;
}


VOID
AzpSidFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for Sid object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    // PAZP_SID AzpSid = (PAZP_SID) GenericObject;
    UNREFERENCED_PARAMETER( GenericObject );

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Free any local strings
    //



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\role.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    role.cxx

Abstract:

    Routines implementing the Role object

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/

#include "pch.hxx"



DWORD
AzpRoleInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzRoleCreate.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    PAZP_ROLE Role = (PAZP_ROLE) ChildGenericObject;
    PAZP_AZSTORE AzAuthorizationStore = NULL;
    PAZP_APPLICATION Application = NULL;
    PAZP_SCOPE Scope = NULL;

    PGENERIC_OBJECT_HEAD ParentSids = NULL;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Behave differently depending on the object type of the parent object
    //
    // A role references SID objects that are siblings of itself.
    // That way, the back links on the SID object references just the roles
    // that are siblings of the SID object.
    //

    if ( ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION ) {

        AzAuthorizationStore = ParentGenericObject->AzStoreObject;
        Application = (PAZP_APPLICATION) ParentGenericObject;

    } else if ( ParentGenericObject->ObjectType == OBJECT_TYPE_SCOPE ) {

        AzAuthorizationStore = ParentGenericObject->AzStoreObject;
        Application = (PAZP_APPLICATION) ParentOfChild( ParentGenericObject );
        Scope = (PAZP_SCOPE) ParentGenericObject;

    } else {
        ASSERT( FALSE );
    }

    ParentSids = &ParentGenericObject->AzpSids;

    //
    // Roles reference groups, operations, and tasks.
    //  These other groups can be siblings of this group or siblings of our parents.
    //
    //  Let the generic object manager know all of the lists we support
    //

    ChildGenericObject->GenericObjectLists = &Role->AppMembers,

    // List of Groups
    ObInitObjectList( &Role->AppMembers,
                      &Role->Operations,
                      FALSE,    // Forward link
                      0,        // No link pair id
                      AZ_DIRTY_ROLE_APP_MEMBERS,
                      &AzAuthorizationStore->Groups,
                      &Application->Groups,
                      Scope == NULL ? NULL : &Scope->Groups );

    // List of Operations
    ObInitObjectList( &Role->Operations,
                      &Role->Tasks,
                      FALSE,    // Forward link
                      0,        // No link pair id
                      AZ_DIRTY_ROLE_OPERATIONS,
                      &Application->Operations,
                      NULL,
                      NULL );

    // List of Tasks
    ObInitObjectList( &Role->Tasks,
                      &Role->SidMembers,
                      FALSE,    // Forward link
                      0,        // No link pair id
                      AZ_DIRTY_ROLE_TASKS,
                      &Application->Tasks,
                      Scope == NULL ? NULL : &Scope->Tasks,
                      NULL );

    // Role reference SID objects
    ObInitObjectList( &Role->SidMembers,
                      NULL,
                      FALSE,    // Forward link
                      0,        // No link pair id
                      AZ_DIRTY_ROLE_MEMBERS,
                      ParentSids,
                      NULL,
                      NULL );


    return NO_ERROR;
}


VOID
AzpRoleFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for Role object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    // PAZP_ROLE Role = (PAZP_ROLE) GenericObject;
    UNREFERENCED_PARAMETER( GenericObject );

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Free any local strings
    //


}

DWORD
AzpRoleNameConflict(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PAZP_STRING ChildObjectNameString
    )
/*++

Routine Description:

    This routine is a worker routine to determine if the specified ChildObjectNameString
    conflicts with the names of other objects that share a namespace with Roles

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildObjectNameString - Specifies the name of the child object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    PAZP_APPLICATION Application = NULL;

    ULONG WinStatus;
    PGENERIC_OBJECT ConflictGenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Behave differently depending on the object type of the parent object
    //
    //
    // A role that is a child of an application
    //  cannot have the same name as any roles that are children of any of the child scopes.
    //

    if ( ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION ) {
        Application = (PAZP_APPLICATION) ParentGenericObject;

        //
        // Check roles that are children of child scopes.
        //

        WinStatus = ObCheckNameConflict( &Application->Scopes,
                                         ChildObjectNameString,
                                         offsetof(_AZP_SCOPE, Roles),
                                         0,
                                         0 );

    //
    // A role that is a child of a scope,
    //  cannot have the same name as roles that are children of the application.
    //
    } else if ( ParentGenericObject->ObjectType == OBJECT_TYPE_SCOPE ) {
        Application = (PAZP_APPLICATION) ParentOfChild( ParentGenericObject );

        //
        // Check roles that are children of the application.
        //

        WinStatus = ObReferenceObjectByName( &Application->Roles,
                                             ChildObjectNameString,
                                             0,     // No special flags
                                             &ConflictGenericObject );

        if ( WinStatus == NO_ERROR ) {
            ObDereferenceObject( ConflictGenericObject );
            return ERROR_ALREADY_EXISTS;
        }

        WinStatus = NO_ERROR;


    } else {
        WinStatus = ERROR_INTERNAL_ERROR;
        ASSERT( FALSE );
    }


    return WinStatus;
}


DWORD
AzpRoleGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    This routine is the Role specific worker routine for AzGetProperty.
    It does any object specific property gets.

    On entry, AzGlResource must be locked shared.

Arguments:

    GenericObject - Specifies a pointer to the object to be queried

    Flags - Specifies internal flags
        AZP_FLAGS_BY_GUID - name lists should be returned as GUID lists

    PropertyId - Specifies which property to return.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_ROLE_APP_MEMBERS  AZ_STRING_ARRAY - Application groups that are members of this role
        AZ_PROP_ROLE_MEMBERS      AZ_SID_ARRAY - NT Sids that are members of this role
        AZ_PROP_ROLE_OPERATIONS   AZ_STRING_ARRAY - Operations that can be performed by this role
        AZ_PROP_ROLE_TASKS        AZ_STRING_ARRAY - Tasks that can be performed by this role

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_ROLE Role = (PAZP_ROLE) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );


    //
    // Return any object specific attribute
    //
    //
    switch ( PropertyId ) {

    // Return the set of app members to the caller
    case AZ_PROP_ROLE_APP_MEMBERS:

        if ( Flags & AZP_FLAGS_BY_GUID )
        {
            *PropertyValue = ObGetPropertyItemGuids( &Role->AppMembers );
        }
        else
        {
            *PropertyValue = ObGetPropertyItems( &Role->AppMembers );
        }

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    // Return the set of SID members to the caller
    case AZ_PROP_ROLE_MEMBERS:

        *PropertyValue = ObGetPropertyItems( &Role->SidMembers );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    // Return the set of operations to the caller
    case AZ_PROP_ROLE_OPERATIONS:

        if ( Flags & AZP_FLAGS_BY_GUID )
        {
            *PropertyValue = ObGetPropertyItemGuids( &Role->Operations );
        }
        else
        {
            *PropertyValue = ObGetPropertyItems( &Role->Operations );
        }

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    // Return the set of tasks to the caller
    case AZ_PROP_ROLE_TASKS:

        if ( Flags & AZP_FLAGS_BY_GUID )
        {
            *PropertyValue = ObGetPropertyItemGuids( &Role->Tasks );
        }
        else
        {
            *PropertyValue = ObGetPropertyItems( &Role->Tasks );
        }

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    default:
        AzPrint(( AZD_INVPARM, "AzpRoleGetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        break;
    }

    return WinStatus;
}


DWORD
AzpRoleGetGenericChildHead(
    IN AZ_HANDLE ParentHandle,
    OUT PULONG ObjectType,
    OUT PGENERIC_OBJECT_HEAD *GenericChildHead
    )
/*++

Routine Description:

    This routine determines whether ParentHandle supports Role objects as
    children.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the role.
        This may be an Application Handle or a Scope handle.

    ObjectType - Returns the object type of the ParentHandle.

    GenericChildHead - Returns a pointer to the head of the list of roles objects
        that are children of the object specified by ParentHandle.  This in an unverified
        pointer.  The pointer is only valid after ParentHandle has been validated.

Return Value:

    Status of the operation.

--*/
{
    DWORD WinStatus;

    //
    // Determine the type of the parent handle
    //

    WinStatus = ObGetHandleType( (PGENERIC_OBJECT)ParentHandle,
                                 FALSE, // ignore deleted objects
                                 ObjectType );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }


    //
    // Verify that the specified handle support children roles.
    //

    switch ( *ObjectType ) {
    case OBJECT_TYPE_APPLICATION:

        *GenericChildHead = &(((PAZP_APPLICATION)ParentHandle)->Roles);
        break;

    case OBJECT_TYPE_SCOPE:

        *GenericChildHead = &(((PAZP_SCOPE)ParentHandle)->Roles);
        break;

    default:
        return ERROR_INVALID_HANDLE;
    }

    return NO_ERROR;
}



DWORD
WINAPI
AzRoleCreate(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR RoleName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE RoleHandle
    )
/*++

Routine Description:

    This routine adds a role into the scope of the specified parent object.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the role.
        This may be an Application Handle or a Scope handle.

    RoleName - Specifies the name of the role to add.

    Reserved - Reserved.  Must by zero.

    RoleHandle - Return a handle to the role.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports roles as children
    //

    WinStatus = AzpRoleGetGenericChildHead( ParentHandle,
                                             &ObjectType,
                                             &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonCreateObject(
                    (PGENERIC_OBJECT) ParentHandle,
                    ObjectType,
                    GenericChildHead,
                    OBJECT_TYPE_ROLE,
                    RoleName,
                    Reserved,
                    (PGENERIC_OBJECT *) RoleHandle );

}



DWORD
WINAPI
AzRoleOpen(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR RoleName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE RoleHandle
    )
/*++

Routine Description:

    This routine opens a role into the scope of the specified parent object.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the role.
        This may be an Application Handle or a Scope handle.

    RoleName - Specifies the name of the role to open

    Reserved - Reserved.  Must by zero.

    RoleHandle - Return a handle to the role.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - There is no role by that name

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports roles as children
    //

    WinStatus = AzpRoleGetGenericChildHead( ParentHandle,
                                             &ObjectType,
                                             &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonOpenObject(
        (PGENERIC_OBJECT) ParentHandle,
        ObjectType,
        GenericChildHead,
        OBJECT_TYPE_ROLE,
        RoleName,
        Reserved,
        (PGENERIC_OBJECT *) RoleHandle );

}


DWORD
WINAPI
AzRoleEnum(
    IN AZ_HANDLE ParentHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE RoleHandle
    )
/*++

Routine Description:

    Enumerates all of the roles for the specified parent object.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the role.
        This may be an Application Handle or a Scope handle.

    Reserved - Reserved.  Must by zero.

    EnumerationContext - Specifies a context indicating the next role to return
        On input for the first call, should point to zero.
        On input for subsequent calls, should point to the value returned on the previous call.
        On output, returns a value to be passed on the next call.

    RoleHandle - Returns a handle to the next role object.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful (a handle was returned)

    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports roles as children
    //

    WinStatus = AzpRoleGetGenericChildHead( ParentHandle,
                                             &ObjectType,
                                             &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonEnumObjects(
                    (PGENERIC_OBJECT) ParentHandle,
                    ObjectType,
                    GenericChildHead,
                    EnumerationContext,
                    Reserved,
                    (PGENERIC_OBJECT *) RoleHandle );

}

DWORD
WINAPI
AzRoleDelete(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR RoleName,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This routine deletes a role from the scope of the specified parent object.
    Also deletes any child objects of RoleName.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the role.
        This may be an Application Handle or a Scope handle.

    RoleName - Specifies the name of the role to delete.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - An object by that name cannot be found

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports roles as children
    //

    WinStatus = AzpRoleGetGenericChildHead( ParentHandle,
                                             &ObjectType,
                                             &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonDeleteObject(
                    (PGENERIC_OBJECT) ParentHandle,
                    ObjectType,
                    GenericChildHead,
                    OBJECT_TYPE_ROLE,
                    RoleName,
                    Reserved );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\scope.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    scope.cxx

Abstract:

    Routines implementing the Scope object

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/

#include "pch.hxx"



DWORD
AzpScopeInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzScopeCreate.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_SCOPE Scope = (PAZP_SCOPE) ChildGenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Sanity check the parent
    //

    ASSERT( ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION );
    UNREFERENCED_PARAMETER( ParentGenericObject );

    //
    // Initialize the lists of child objects
    //  Let the generic object manager know all of the types of children we support
    //

    ChildGenericObject->ChildGenericObjectHead = &Scope->Tasks;

    // List of child Tasks
    ObInitGenericHead( &Scope->Tasks,
                       OBJECT_TYPE_TASK,
                       ChildGenericObject,
                       &Scope->Groups );

    // List of child groups
    ObInitGenericHead( &Scope->Groups,
                       OBJECT_TYPE_GROUP,
                       ChildGenericObject,
                       &Scope->Roles );

    // List of child roles
    ObInitGenericHead( &Scope->Roles,
                       OBJECT_TYPE_ROLE,
                       ChildGenericObject,
                       &ChildGenericObject->AzpSids );

    // List of child AzpSids
    ObInitGenericHead( &ChildGenericObject->AzpSids,
                       OBJECT_TYPE_SID,
                       ChildGenericObject,
                       NULL );

    //
    // If the parent application object's parent AzAuthorizationStore object supports delegation,
    // then the scope object supports the following options:
    // . AZPE_OPTIONS_SUPPORTS_DACL
    // . AZPE_OPTIONS_SUPPORTS_SACL
    //

    if ( CHECK_DELEGATION_SUPPORT( (PGENERIC_OBJECT) ParentGenericObject->AzStoreObject ) ==
         NO_ERROR ) {

        ChildGenericObject->IsAclSupported = TRUE;
        ChildGenericObject->IsSACLSupported = TRUE;
    }

    //
    // If the provider does not support Lazy load, set the AreChildrenLoaded to
    // TRUE.  Else leave it as FALSE.  This will be set to true during the call
    // to AzPersistUpdateChildrenCache
    //

    if ( !(ParentGenericObject->AzStoreObject)->ChildLazyLoadSupported ) {

        ChildGenericObject->AreChildrenLoaded = TRUE;

    } else {

        ChildGenericObject->AreChildrenLoaded = FALSE;

    }


    return WinStatus;
}


VOID
AzpScopeFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for Scope object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    // PAZP_SCOPE Scope = (PAZP_SCOPE) GenericObject;
    UNREFERENCED_PARAMETER( GenericObject );

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Free any local strings
    //

}



DWORD
WINAPI
AzScopeCreate(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR ScopeName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ScopeHandle
    )
/*++

Routine Description:

    This routine adds a scope into the scope of the specified application.  It also sets
    Scope object specific optional characteristics using the parent Application object's
    parent AzAuthorizationStore object.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    ScopeName - Specifies the name of the scope to add.

    Reserved - Reserved.  Must by zero.

    ScopeHandle - Return a handle to the scope.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonCreateObject(
               (PGENERIC_OBJECT) ApplicationHandle,
               OBJECT_TYPE_APPLICATION,
               &(((PAZP_APPLICATION)ApplicationHandle)->Scopes),
               OBJECT_TYPE_SCOPE,
               ScopeName,
               Reserved,
               (PGENERIC_OBJECT *) ScopeHandle );

}



DWORD
WINAPI
AzScopeOpen(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR ScopeName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ScopeHandle
    )
/*++

Routine Description:

    This routine opens a scope into the scope of the specified application.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    ScopeName - Specifies the name of the scope to open

    Reserved - Reserved.  Must by zero.

    ScopeHandle - Return a handle to the scope.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - There is no scope by that name

--*/
{
    DWORD WinStatus = 0;

    //
    // Call the common routine to do most of the work
    //

    WinStatus = ObCommonOpenObject(
        (PGENERIC_OBJECT) ApplicationHandle,
        OBJECT_TYPE_APPLICATION,
        &(((PAZP_APPLICATION)ApplicationHandle)->Scopes),
        OBJECT_TYPE_SCOPE,
        ScopeName,
        Reserved,
        (PGENERIC_OBJECT *) ScopeHandle );

    if ( WinStatus == NO_ERROR ) {

        //
        // Load the children if the Scope object has already been submitted to
        // the store
        //

        if ( !((PGENERIC_OBJECT) *ScopeHandle)->AreChildrenLoaded ) {

            //
            // Grab the global resource lock
            //

            AzpLockResourceExclusive( &AzGlResource );

            WinStatus = AzPersistUpdateChildrenCache(
                (PGENERIC_OBJECT) *ScopeHandle
                );

            AzpUnlockResource( &AzGlResource );

            if ( WinStatus != NO_ERROR ) {

                //
                // Derefence the scope handle and return nothing to the caller
                //

                AzCloseHandle( (PGENERIC_OBJECT)*ScopeHandle, 0 );
                *ScopeHandle = NULL;
            }
        }
    }

    return WinStatus;
}


DWORD
WINAPI
AzScopeEnum(
    IN AZ_HANDLE ApplicationHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE ScopeHandle
    )
/*++

Routine Description:

    Enumerates all of the scopes for the specified application.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    Reserved - Reserved.  Must by zero.

    EnumerationContext - Specifies a context indicating the next scope to return
        On input for the first call, should point to zero.
        On input for subsequent calls, should point to the value returned on the previous call.
        On output, returns a value to be passed on the next call.

    ScopeHandle - Returns a handle to the next scope object.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful (a handle was returned)

    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonEnumObjects(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->Scopes),
                    EnumerationContext,
                    Reserved,
                    (PGENERIC_OBJECT *) ScopeHandle );

}


DWORD
WINAPI
AzScopeDelete(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR ScopeName,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This routine deletes a scope from the scope of the specified application.
    Also deletes any child objects of ScopeName.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    ScopeName - Specifies the name of the scope to delete.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - An object by that name cannot be found

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonDeleteObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->Scopes),
                    OBJECT_TYPE_SCOPE,
                    ScopeName,
                    Reserved );

}

DWORD
AzpScopeGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    This routine is the Scope specific worker routine for AzGetProperty.
    It does any object specific property gets.

    On entry, AzGlResource must be locked shared.

Arguments:

    GenericObject - Specifies a pointer to the object to be queried

    Flags - ignored

    PropertyId - Specifies which property to return.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;

    UNREFERENCED_PARAMETER(Flags); //ignore

    *PropertyValue = NULL;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    //
    // Return any object specific attribute
    //

    switch ( PropertyId ) {

    //
    // if the scope can be deleted (already has bizrule defined)
    //
    case AZ_PROP_SCOPE_CAN_BE_DELEGATED:

        if ( AzpScopeCanBeDelegated(GenericObject, TRUE) == ERROR_SUCCESS ) {

            *PropertyValue = AzpGetUlongProperty( 1 );
        } else {

            *PropertyValue = AzpGetUlongProperty( 0 );
        }

        break;

    //
    // if bizrule attributes under the scope can be created/modified
    //
    case AZ_PROP_SCOPE_BIZRULES_WRITABLE:

        if ( GenericObject->IsWritable &&
             GenericObject->PolicyAdmins.GenericObjects.UsedCount == 0 ) {

            //
            // scope has not been delegated and is writable.
            // for XML store that doesn't support delegation, PolicyAdmins should be empty
            //
            *PropertyValue = AzpGetUlongProperty( 1);

        } else {
            //
            // scope is not writable, or already been delegated
            //
            *PropertyValue = AzpGetUlongProperty(0);
        }

        break;

    default:
        AzPrint(( AZD_INVPARM, "AzScopeGetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
    }

    return WinStatus;
}

DWORD
AzpScopeCanBeDelegated(
    IN PGENERIC_OBJECT  GenericObject,
    IN BOOL bLockedShared
    )
/*
Routine Description:

    This routine determines if the scope passed in can be delegated. The logic here
    is to check if there is any task object under the scope that has bizrules defined.
    If there is task with bizrule, the scope cannot be delegated; otherwise, it can.

    Note that the scope may not be loaded in cache yet (with the lazy bit set), in which
    case, this routine will load the scope first then perform the check.

Arguments

    GenericObject - pointer to the scope object

    bLockedShared - TRUE if the global resource is shared

Return

    ERROR_SUCCESS if the scope can be delegated

    ERROR_NOT_SUPPORTED if the scope cannot be delegated

    other error if cannot determine
*/
{
    DWORD WinStatus = NO_ERROR;

    //
    // check input
    //
    if ( GenericObject == NULL ||
         GenericObject->ObjectType != OBJECT_TYPE_SCOPE ) {

        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if ( GenericObject->PolicyAdmins.GenericObjects.UsedCount != 0 ) {
        //
        // this scope is already delegated
        //
        WinStatus = ERROR_SUCCESS;
        goto Cleanup;
    }

    PAZP_SCOPE Scope = (PAZP_SCOPE)GenericObject;

    //
    // check if we need to load the scope first
    //

    if ( !(GenericObject->AreChildrenLoaded) ) {

        if ( bLockedShared ) {

            //
            // Grab the resource exclusively
            //

            AzpLockResourceSharedToExclusive( &AzGlResource );
        }

        WinStatus = AzPersistUpdateChildrenCache(
            GenericObject
            );

        if ( bLockedShared ) {

            AzpLockResourceExclusiveToShared( &AzGlResource );
        }

        if ( WinStatus != NO_ERROR ) {

            goto Cleanup;
        }

    }


    PLIST_ENTRY ListEntry;
    BOOL BizRuleTaskFound = FALSE;

    for ( ListEntry = Scope->Tasks.Head.Flink ;
          ListEntry != &(Scope->Tasks.Head) ;
          ListEntry = ListEntry->Flink ) {

        PGENERIC_OBJECT MyGO;

        //
        // Grab a pointer to the next task to process
        //

        MyGO = CONTAINING_RECORD( ListEntry,
                                   GENERIC_OBJECT,
                                   Next );

        ASSERT( MyGO->ObjectType == OBJECT_TYPE_TASK );

        //
        // check if there is bizrule defined in this task
        //
        PAZP_TASK Task = (PAZP_TASK)MyGO;

        if ( Task->BizRule.String != NULL ||
             Task->BizRuleLanguage.String != NULL ||
             Task->BizRuleImportedPath.String != NULL ) {

            BizRuleTaskFound = TRUE;
            break;
        }
    }

    if ( BizRuleTaskFound ) {
        //
        // there are bizrule defined.
        //
        WinStatus = ERROR_NOT_SUPPORTED;
    }

Cleanup:

    return WinStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\util.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    util.cxx

Abstract:

    Utility routines

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/


#include "pch.hxx"
#include <dispex.h>

#if DBG
//
// List of all allocated blocks
//  AccessSerialized by AzGlAllocatorCritSect
LIST_ENTRY AzGlAllocatedBlocks;
SAFE_CRITICAL_SECTION AzGlAllocatorCritSect;

//
// Force C++ to use our allocator
//

void * __cdecl operator new(size_t s) {
    return AzpAllocateHeap( s, "UTILNEW" );
}

void __cdecl operator delete(void *pv) {
    AzpFreeHeap( pv );
}

#endif // DBG



DWORD
AzpGetCurrentToken(
    OUT PHANDLE hToken
    )
/*++

Routine Description

    Returns the effective token on the thread.

Arguments

    hToken - To return the handle to the effective token.

Return Value

    DWORD error value.

--*/
{
    DWORD WinStatus;

    //
    // First open the thread token.
    //

    if ( OpenThreadToken(
             GetCurrentThread(),
             TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
             TRUE,
             hToken ) ) {

        return NO_ERROR;
    }

    WinStatus = GetLastError();

    //
    // If we failed because of any error other than thread not impersonating,
    // give up and return the error.
    //

    if ( WinStatus != ERROR_NO_TOKEN ) {
        return WinStatus;
    }

    //
    // We are not impersonating. Open the process token instead.
    //

    if ( OpenProcessToken(
             GetCurrentProcess(),
             TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
             hToken ) ) {

        return NO_ERROR;
    }

    return GetLastError();
}

DWORD
AzpChangeSinglePrivilege(
    IN DWORD PrivilegeValue,
    IN HANDLE hToken,
    IN PTOKEN_PRIVILEGES NewPrivilegeState,
    OUT PTOKEN_PRIVILEGES OldPrivilegeState OPTIONAL
    )
/*++

Routine Description

    This routine has two functions:
    1. Enable a given privilege and return the Old state of the privilege in
       the token.
    2. Revert back to the original state once the operation for which we had
       enabled the privilege has been performed.

Arguments

    PrivilegeValue - The privilege to enable. This is ignored when
      OldPrivilegesState is NULL.

    hToken - Token to adjust.

    NewPrivilegeState - The new value for the privilege.

    OldPrivilegeState - Buffer to hold the Old privilege state. The size of this
      is assumed to be sizeof(TOKEN_PRIVILEGES) and is sufficient to hold the
      Old state since we are only adjusting a single privilege.
      When this is NULL, we are reverting.

Return Value

    Returns a pointer to the allocated memory.
    NULL - Not enough memory

--*/
{

    DWORD BufferSize = 0;

    //
    // When there is no Old state, we enable the privilege supplied.
    // When there is Old state we set it back.
    //

    if ( ARGUMENT_PRESENT( OldPrivilegeState ) ) {
        NewPrivilegeState->PrivilegeCount = 1;
        NewPrivilegeState->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        NewPrivilegeState->Privileges[0].Luid = RtlConvertLongToLuid( PrivilegeValue );
    } else if ( NewPrivilegeState->PrivilegeCount == 0) {

        return NO_ERROR;
    }

    //
    // Adjust the token to change the privilege state.
    //

    AdjustTokenPrivileges (
        hToken,
        FALSE,
        NewPrivilegeState,
        sizeof(TOKEN_PRIVILEGES),
        OldPrivilegeState,
        &BufferSize );

    return GetLastError();
}


PVOID
AzpAllocateHeap(
    IN SIZE_T Size,
    IN LPSTR pDescr OPTIONAL
    )
/*++

Routine Description

    Memory allocator.  The pDescr field is ignored for Free builds

Arguments

    Size - Size (in bytes) to allocate

    pDescr - Optional string identifying the block of not more than 8 chars.

Return Value

    Returns a pointer to the allocated memory.
    NULL - Not enough memory

--*/
{

    DBG_UNREFERENCED_PARAMETER( pDescr ); //ignore

#if DBG
    ULONG HeaderSize;
    ULONG DescrSize = sizeof(DWORD) * 2;

    PLIST_ENTRY RealBlock;

    HeaderSize = ROUND_UP_COUNT( sizeof(LIST_ENTRY) + DescrSize,
                                 ALIGN_WORST );
    //
    // Allocate a block with a header
    //

    RealBlock = (PLIST_ENTRY) LocalAlloc( 0, HeaderSize + Size );

    if ( RealBlock == NULL ) {
        return NULL;
    }

    //
    // Link the block since we're nosey.
    //

    ASSERT( pDescr != NULL );
    RtlZeroMemory( ((LPBYTE)RealBlock)+sizeof(LIST_ENTRY), DescrSize );
    if ( pDescr != NULL ) {

        memcpy( ((LPBYTE)RealBlock)+sizeof(LIST_ENTRY),
                (LPBYTE)pDescr,
                DescrSize
                );
    }

    SafeEnterCriticalSection( &AzGlAllocatorCritSect );
    InsertHeadList( &AzGlAllocatedBlocks, RealBlock );
    SafeLeaveCriticalSection( &AzGlAllocatorCritSect );

    return (PVOID)(((LPBYTE)RealBlock)+HeaderSize);

#else // DBG
    return LocalAlloc( 0, Size );
#endif // DBG
}

PVOID
AzpAllocateHeapSafe(
    IN SIZE_T Size
    )
/*++

Routine Description:

        Memory allocator for SafeAlloca.  Calls
        AzpAllocateHeap in return

Arguments:

        Size - Size of block to be allocated

Return Values:

    Returns a pointer to the allocated memory.
    NULL - Not enough memory

--*/
{

    return AzpAllocateHeap( Size, "UTILSAFE" );
}

VOID
AzpFreeHeap(
    IN PVOID Buffer
    )
/*++

Routine Description

    Memory de-allocator.

Arguments

    Buffer - address of buffer to free

Return Value

    None

--*/
{

    if ( Buffer == NULL ) {
        return;
    }

#if DBG
    ULONG HeaderSize;

    ULONG DescrSize = sizeof(DWORD) * 2;

    PLIST_ENTRY RealBlock;

    HeaderSize = ROUND_UP_COUNT( sizeof(LIST_ENTRY) + DescrSize,
                                 ALIGN_WORST );

    RealBlock = (PLIST_ENTRY)(((LPBYTE)Buffer)-HeaderSize);

    SafeEnterCriticalSection( &AzGlAllocatorCritSect );
    RemoveEntryList( RealBlock );
    SafeLeaveCriticalSection( &AzGlAllocatorCritSect );

    LocalFree( RealBlock );
#else // DBG
    LocalFree( Buffer );
#endif // DBG

}

PVOID
AzpAvlAllocate(
    IN PRTL_GENERIC_TABLE Table,
    IN CLONG ByteSize
    )
/*++
Routine Description:

    This routine will allocate space to hold an entry in a generic AVL table.

Arguments:

    IN PRTL_GENERIC_TABLE Table - Supplies the table to allocate entries for.
    IN CLONG ByteSize - Supplies the number of bytes to allocate for the entry.


Return Value:

    None.

--*/
{
    return AzpAllocateHeap( ByteSize, "UTILAVL" );
    UNREFERENCED_PARAMETER(Table);
}

VOID
AzpAvlFree(
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    )
/*++

Routine Description:

    This routine will free an entry in a AVL generic table

Arguments:

    IN PRTL_GENERIC_TABLE Table - Supplies the table to allocate entries for.
    IN PVOID Buffer - Supplies the buffer to free.



Return Value:

    None.

--*/
{
    AzpFreeHeap( Buffer );
    UNREFERENCED_PARAMETER(Table);
}


VOID
AzpInitString(
    OUT PAZP_STRING AzpString,
    IN LPCWSTR String OPTIONAL
    )
/*++

Routine Description

    Initialize our private string structure to point to a passed in string.

Arguments

    AzpString - Initialized string

    String - zero terminated string to be reference
        If NULL, AzpString will be initialized to empty.

Return Value

    None

--*/
{
    //
    // Initialization
    //

    if ( String == NULL ) {
        AzpString->String = NULL;
        AzpString->StringSize = 0;
    } else {
        AzpString->String = (LPWSTR)String;
        AzpString->StringSize = (ULONG) ((wcslen(String)+1)*sizeof(WCHAR));
    }
    AzpString->IsSid = FALSE;

}

DWORD
AzpCaptureString(
    OUT PAZP_STRING AzpString,
    IN LPCWSTR String,
    IN ULONG MaximumLength,
    IN BOOLEAN NullOk
    )
/*++

Routine Description

    Capture the passed in string.

Arguments

    AzpString - Captured copy of the passed in string.
        On success, string must be freed using AzpFreeString

    String - zero terminated string to capture

    MaximumLength - Maximum length of the string (in characters).

    NullOk - if TRUE, a NULL string or zero length string is OK.

    pDescr - An optional description string

Return Value

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    ULONG WinStatus;
    ULONG StringSize;

    //
    // Initialization
    //

    AzpInitString( AzpString, NULL );

    if ( String == NULL ) {
        if ( !NullOk ) {
            AzPrint(( AZD_INVPARM, "AzpCaptureString: NULL not ok\n" ));
            return ERROR_INVALID_PARAMETER;
        }
        return NO_ERROR;
    }

    __try {

        //
        // Validate a passed in LPWSTR
        //

        ULONG StringLength;

        StringLength = (ULONG) wcslen( String );

        if ( StringLength == 0 ) {
            if ( !NullOk ) {
                AzPrint(( AZD_INVPARM, "AzpCaptureString: zero length not ok\n" ));
                return ERROR_INVALID_PARAMETER;
            }
            return NO_ERROR;
        }

        if ( StringLength > MaximumLength ) {
            AzPrint(( AZD_INVPARM, "AzpCaptureString: string too long %ld %ld %ws\n", StringLength, MaximumLength, String ));
            return ERROR_INVALID_PARAMETER;
        }

        StringSize = (StringLength+1)*sizeof(WCHAR);


        //
        // Allocate and copy the string
        //

        AzpString->String = (LPWSTR) AzpAllocateHeap( StringSize, "UTILSTR" );

        if ( AzpString->String == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        } else {

            RtlCopyMemory( AzpString->String,
                           String,
                           StringSize );

            AzpString->StringSize = StringSize;
            AzpString->IsSid = FALSE;

            WinStatus = NO_ERROR;
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        WinStatus = RtlNtStatusToDosError( GetExceptionCode());

        AzpFreeString( AzpString );
    }

    return WinStatus;
}

VOID
AzpInitSid(
    OUT PAZP_STRING AzpString,
    IN PSID Sid
    )
/*++

Routine Description

    Initialize an AZ_STRING structure to point to a sid

Arguments

    AzpString - String structure to initialize

    Sid - Sid to capture

Return Value

    None

--*/
{
    // Initialization
    //

    AzpString->String = (LPWSTR)Sid;
    AzpString->StringSize = RtlLengthSid( Sid );
    AzpString->IsSid = TRUE;

}

DWORD
AzpCaptureSid(
    OUT PAZP_STRING AzpString,
    IN PSID Sid
    )
/*++

Routine Description

    Capture the passed in SID

Arguments

    AzpString - Captured copy of the passed in sid.
        On success, string must be freed using AzpFreeString

    Sid - Sid to capture

Return Value

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    ULONG WinStatus;
    ULONG StringSize;

    //
    // Initialization
    //

    AzpInitString( AzpString, NULL );


    __try {

        //
        // Validate a passed in SID
        //

        if ( !RtlValidSid( Sid ) ) {
            AzPrint(( AZD_INVPARM, "AzpCaptureString: SID not valid\n" ));
            return ERROR_INVALID_PARAMETER;
        }

        StringSize = RtlLengthSid( Sid );

        //
        // Allocate and copy the SID
        //

        AzpString->String = (LPWSTR) AzpAllocateHeap( StringSize, "UTILSID" );

        if ( AzpString->String == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        } else {

            RtlCopyMemory( AzpString->String,
                           Sid,
                           StringSize );

            AzpString->StringSize = StringSize;
            AzpString->IsSid = TRUE;

            WinStatus = NO_ERROR;
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        WinStatus = RtlNtStatusToDosError( GetExceptionCode());

        AzpFreeString( AzpString );
    }

    return WinStatus;
}

DWORD
AzpCaptureLong(
    IN PVOID PropertyValue,
    OUT PLONG UlongValue
    )
/*++

Routine Description

    Support routine for the SetProperty API.
    Capture a parameter for the user application.

Arguments

    PropertyValue - Specifies a pointer to the property.

    UlongValue - Value to return to make a copy of.

Return Value
    NO_ERROR - The operation was successful
    Other exception status codes


--*/
{
    DWORD WinStatus;

    __try {
        *UlongValue = *(PULONG)PropertyValue;
        WinStatus = NO_ERROR;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        WinStatus = RtlNtStatusToDosError( GetExceptionCode());
    }

    return WinStatus;
}

DWORD
AzpDuplicateString(
    OUT PAZP_STRING AzpOutString,
    IN PAZP_STRING AzpInString
    )
/*++

Routine Description

    Make a duplicate of the passed in string

Arguments

    AzpOutString - Returns a copy of the passed in string.
        On success, string must be freed using AzpFreeString.

    AzpInString - Specifies a string to make a copy of.

Return Value

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory

--*/
{
    ULONG WinStatus;

    //
    // Initialization
    //

    AzpInitString( AzpOutString, NULL );

    //
    // Handle an empty string
    //

    if ( AzpInString->StringSize == 0 || AzpInString->String == NULL ) {

        WinStatus = NO_ERROR;

    //
    // Allocate and copy the string
    //

    } else {
        AzpOutString->String = (LPWSTR) AzpAllocateHeap( AzpInString->StringSize, "UTILDUP" );

        if ( AzpOutString->String == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        } else {

            RtlCopyMemory( AzpOutString->String,
                           AzpInString->String,
                           AzpInString->StringSize );

            AzpOutString->StringSize = AzpInString->StringSize;
            AzpOutString->IsSid = AzpInString->IsSid;

            WinStatus = NO_ERROR;
        }
    }

    return WinStatus;
}

BOOL
AzpEqualStrings(
    IN PAZP_STRING AzpString1,
    IN PAZP_STRING AzpString2
    )
/*++

Routine Description

    Does a case insensitive comparison of two strings

Arguments

    AzpString1 - First string to compare

    AzpString2 - Second string to compare

Return Value

    TRUE: the strings are equal
    FALSE: the strings are not equal

--*/
{

    //
    // Simply compare the strings
    //

    return (AzpCompareStrings( AzpString1, AzpString2 ) == CSTR_EQUAL);

}

LONG
AzpCompareSidWorker(
    IN PSID Sid1,
    IN ULONG Sid1Size,
    IN PSID Sid2,
    IN ULONG Sid2Size
    )
/*++

Routine description:

    SID comparison routine for non-equality

Arguments:

    Sid1 - First Sid to compare

    Sid1Size - Size (in bytes) of Sid1

    Sid2 - Second Sid to compare

    Sid2Size - Size (in bytes) of Sid2

Returns:

    CSTR_LESS_THAN: String 1 is less than string 2
    CSTR_EQUAL: String 1 is equal to string 2
    CSTR_GREATER_THAN: String 1 is greater than string 2

    this is the same code as RtlEqualSid, except it returns
       CSTR_*

--*/
{
    LONG Result;
    ULONG i;

    ASSERT( Sid1 && RtlValidSid( (PSID)(Sid1) ));
    ASSERT( Sid2 && RtlValidSid( (PSID)(Sid2) ));

    //
    // First compare lengths
    //

    if ( Sid1Size < Sid2Size ) {
        return CSTR_LESS_THAN;
    }

    if ( Sid1Size > Sid2Size ) {
        return CSTR_GREATER_THAN;
    }


    //
    // Compare the individual bytes
    //

    ASSERT( (Sid1Size % 4) == 0 );

    Result = CSTR_EQUAL;

    for ( i = 0; i < (Sid1Size/4); i++ ) {

        const ULONG& b1 = ((PULONG)Sid1)[i];
        const ULONG& b2 = ((PULONG)Sid2)[i];

        if ( b1 == b2 ) {

            continue;

        } else if ( b1 < b2 ) {

            Result = CSTR_LESS_THAN;

        } else {

            Result = CSTR_GREATER_THAN;
        }

        break;
    }

    return Result;
}

LONG
AzpCompareSid(
    IN PSID Sid1,
    IN PSID Sid2
    )
/*++

Routine description:

    SID comparison routine for non-equality

Arguments:

    Sid1 - First Sid to compare

    Sid2 - Second Sid to compare

Returns:

    CSTR_LESS_THAN: String 1 is less than string 2
    CSTR_EQUAL: String 1 is equal to string 2
    CSTR_GREATER_THAN: String 1 is greater than string 2

    this is the same code as RtlEqualSid, except it returns
       CSTR_*

--*/
{

    //
    // Call the worker routine
    //

    return AzpCompareSidWorker(
                Sid1,
                RtlLengthSid(Sid1),
                Sid2,
                RtlLengthSid(Sid2) );

}

LONG
AzpCompareSidString(
    IN PAZP_STRING AzpString1,
    IN PAZP_STRING AzpString2
    )
/*++

Routine description:

    SID comparison routine for non-equality

Arguments:

    AzpString1 - First string to compare

    AzpString2 - Second string to compare

Returns:

    CSTR_LESS_THAN: String 1 is less than string 2
    CSTR_EQUAL: String 1 is equal to string 2
    CSTR_GREATER_THAN: String 1 is greater than string 2

    this is the same code as RtlEqualSid, except it returns
       CSTR_*

--*/
{

    //
    // Call the worker routine
    //

    return AzpCompareSidWorker(
                AzpString1->String,
                AzpString1->StringSize,
                AzpString2->String,
                AzpString2->StringSize );
}


LONG
AzpCompareStrings(
    IN PAZP_STRING AzpString1,
    IN PAZP_STRING AzpString2
    )
/*++

Routine Description

    Does a case insensitive comparison of two strings

Arguments

    AzpString1 - First string to compare

    AzpString2 - Second string to compare

Return Value

    0: An error ocurred.  Call GetLastError();
    CSTR_LESS_THAN: String 1 is less than string 2
    CSTR_EQUAL: String 1 is equal to string 2
    CSTR_GREATER_THAN: String 1 is greater than string 2

--*/
{
    LONG Result;

    //
    // Handle NULL
    //
    ASSERT( (AzpString1->IsSid && AzpString2->IsSid) || (!AzpString1->IsSid && !AzpString2->IsSid) );
    if ( AzpString1->String == NULL ) {
        if ( AzpString2->String == NULL ) {
            return CSTR_EQUAL;
        }else {
            return CSTR_LESS_THAN;
        }
    } else {
        if ( AzpString2->String == NULL ) {
            return CSTR_GREATER_THAN;
        }
    }


    //
    // Compare the sids
    //

    if ( AzpString1->IsSid ) {

        Result = AzpCompareSidString( AzpString1, AzpString2 );

    //
    // Compare the Unicode strings
    //  Don't compare the trailing zero character.
    //  (Some callers pass in strings where the trailing character isn't a zero.)
    //

    } else {
        Result = CompareStringW( LOCALE_SYSTEM_DEFAULT,
                                 NORM_IGNORECASE,
                                 AzpString1->String,
                                 (AzpString1->StringSize/sizeof(WCHAR))-1,
                                 AzpString2->String,
                                 (AzpString2->StringSize/sizeof(WCHAR))-1 );
    }

    return Result;

}

VOID
AzpSwapStrings(
    IN OUT PAZP_STRING AzpString1,
    IN OUT PAZP_STRING AzpString2
    )
/*++

Routine Description

    Swap two strings

Arguments

    AzpString1 - First string to swap

    AzpString2 - Second string to swap

Return Value

    None

--*/
{
    AZP_STRING TempString;

    TempString = *AzpString1;
    *AzpString1 = *AzpString2;
    *AzpString2 = TempString;

}

VOID
AzpFreeString(
    IN PAZP_STRING AzpString
    )
/*++

Routine Description

    Free the specified string

Arguments

    AzpString - String to be freed.

    pDescr - An optional description string

Return Value

    None

--*/
{
    if ( AzpString->String != NULL ) {
        AzpFreeHeap( AzpString->String );
    }

    AzpInitString( AzpString, NULL );
}


BOOLEAN
AzpBsearchPtr (
    IN PAZP_PTR_ARRAY AzpPtrArray,
    IN PVOID Key,
    IN LONG (*Compare)(const void *, const void *),
    OUT PULONG InsertionPoint OPTIONAL
    )
/*++

Routine Description:

    This routine does a binary search on the array of pointers

    Code stolen from the libc bsearch() routine

Arguments:

    AzpPtrArray - Array that the pointer will be searched for

    Key - Pointer to be searched for

    Compare - Pointer to a routine to do the comparison.  Routine returns
        CSTR_LESS_THAN: String 1 is less than string 2
        CSTR_EQUAL: String 1 is equal to string 2
        CSTR_GREATER_THAN: String 1 is greater than string 2

    InsertionPoint - On FALSE, returns the point where one would insert the named object.
        On TRUE, returns an index to the object.

Return Value:

    TRUE - Object was found
    FALSE - Object was not found

--*/
{
    LONG lo = 0;
    LONG num = AzpPtrArray->UsedCount;
    LONG hi = num - 1;
    LONG mid;
    LONG half;
    LONG result;
    LONG TempInsertionPoint = 0;

    while (lo <= hi) {
        ASSERT( num == hi-lo+1 );

        // Handle more than one element left
        half = num / 2;

        if ( half ) {

            // Compare key to element in the middle of the array left
            mid = lo + (num & 1 ? half : (half - 1));

            result = (*Compare)( Key, AzpPtrArray->Array[mid] );

            // We lucked out and hit it right on the nose
            if ( result == CSTR_EQUAL ) {
                *InsertionPoint = mid;
                return TRUE;

            // Key is in the first half
            } else if ( result == CSTR_LESS_THAN ) {
                hi = mid - 1;
                num = num & 1 ? half : half-1;
                TempInsertionPoint = mid;

            // Key is in the second half
            } else {
                lo = mid+1;
                num = half;
                TempInsertionPoint = mid+1;
            }

        // Handle exactly one element left
        } else if (num) {
            ASSERT( hi == lo );
            ASSERT( num == 1 );

            result = (*Compare)( Key, AzpPtrArray->Array[lo] );

            if ( result == CSTR_EQUAL ) {
                *InsertionPoint = lo;
                return TRUE;

            } else if ( result == CSTR_LESS_THAN ) {
                TempInsertionPoint = lo;
                break;

            } else {
                TempInsertionPoint = lo+1;
                break;
            }

        // Handle exactly zero elements left
        } else {
            break;
        }
    }

    *InsertionPoint = TempInsertionPoint;
    return FALSE;
}


DWORD
AzpAddPtr(
    IN PAZP_PTR_ARRAY AzpPtrArray,
    IN PVOID Pointer,
    IN ULONG Index
    )
/*++

Routine Description

    Inserts a pointer into the array of pointers.

    The array will be automatically expanded to be large enough to contain the new pointer.
    All existing pointers from slot # 'Index' through the end of the existing array will
        be shifted to later slots.

Arguments

    AzpPtrArray - Array that the pointer will be inserted into.

    Pointer - Pointer to be inserted.

    Index - Index into the array where the 'Pointer' will be inserted
        If Index is larger than the current size of the array or AZP_ADD_ENDOFLIST,
        'Pointer' will be inserted after the existing elements of the array.

Return Value

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory

--*/
{

    //
    // Ensure Index isn't too large
    //

    if ( Index > AzpPtrArray->UsedCount ) {
        Index = AzpPtrArray->UsedCount;
    }

    //
    // If the array isn't large enough, make it bigger
    //

    if ( AzpPtrArray->UsedCount >= AzpPtrArray->AllocatedCount ) {
        PVOID *TempArray;

        //
        // Allocate a new array
        //

        TempArray = (PVOID *) AzpAllocateHeap(
                        (AzpPtrArray->AllocatedCount + AZP_PTR_ARRAY_INCREMENT) * sizeof(PVOID),
                        "UTILADD" );

        if ( TempArray == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Copy the data into the new array and free the old array
        //

        if ( AzpPtrArray->Array != NULL ) {

            RtlCopyMemory( TempArray,
                           AzpPtrArray->Array,
                           AzpPtrArray->AllocatedCount * sizeof(PVOID) );

            AzpFreeHeap( AzpPtrArray->Array );
            AzPrint(( AZD_OBJLIST, "0x%lx: 0x%lx: Free old array\n", AzpPtrArray, AzpPtrArray->Array ));
        }

        //
        // Grab the pointer to the new array and clear the new part of the array
        //

        AzpPtrArray->Array = TempArray;
        AzPrint(( AZD_OBJLIST, "0x%lx: 0x%lx: Allocate array\n", AzpPtrArray, AzpPtrArray->Array ));

        RtlZeroMemory( &TempArray[AzpPtrArray->UsedCount],
                       AZP_PTR_ARRAY_INCREMENT * sizeof(PVOID) );

        AzpPtrArray->AllocatedCount += AZP_PTR_ARRAY_INCREMENT;

    }

    //
    // Shift any old data
    //

    if ( Index != AzpPtrArray->UsedCount ) {

        RtlMoveMemory( &(AzpPtrArray->Array[Index+1]),
                       &(AzpPtrArray->Array[Index]),
                       (AzpPtrArray->UsedCount-Index) * sizeof(PVOID) );
    }

    //
    // Insert the new element
    //

    AzpPtrArray->Array[Index] = Pointer;
    AzpPtrArray->UsedCount ++;

    return NO_ERROR;
}


VOID
AzpRemovePtrByIndex(
    IN PAZP_PTR_ARRAY AzpPtrArray,
    IN ULONG Index
    )
/*++

Routine Description

    Remove a pointer from the array of pointers.

    All existing pointers from slot # 'Index' through the end of the existing array will
        be shifted to earlier slots.

Arguments

    AzpPtrArray - Array that the pointer will be removed into.

    Index - Index into the array where the 'Pointer' will be removed from.


Return Value

    None

--*/
{

    //
    // Ensure Index isn't too large
    //

    ASSERT( Index < AzpPtrArray->UsedCount );


    //
    // Shift any old data
    //

    if ( Index+1 != AzpPtrArray->UsedCount ) {

        RtlMoveMemory( &(AzpPtrArray->Array[Index]),
                       &(AzpPtrArray->Array[Index+1]),
                       (AzpPtrArray->UsedCount-Index-1) * sizeof(PVOID) );
    }

    //
    // Clear the last element
    //

    AzpPtrArray->UsedCount--;
    AzpPtrArray->Array[AzpPtrArray->UsedCount] = NULL;

}


VOID
AzpRemovePtrByPtr(
    IN PAZP_PTR_ARRAY AzpPtrArray,
    IN PVOID Pointer
    )
/*++

Routine Description

    Removes a pointer from the array of pointers.

    All existing pointers following the specified pointer will
        be shifted to earlier slots.

Arguments

    AzpPtrArray - Array that the pointer will be removed into.

    Pointer - Pointer to be removed


Return Value

    None

--*/
{
    ULONG i;
    BOOLEAN FoundIt = FALSE;

    for ( i=0; i<AzpPtrArray->UsedCount; i++ ) {

        if ( Pointer == AzpPtrArray->Array[i] ) {
            AzpRemovePtrByIndex( AzpPtrArray, i );
            FoundIt = TRUE;
            break;
        }
    }

    ASSERT( FoundIt );

}



PVOID
AzpGetStringProperty(
    IN PAZP_STRING AzpString
    )
/*++

Routine Description

    Support routine for the GetProperty API.  Convert an AzpString to the form
    supported by GetProperty.

    Empty string are returned as Zero length string instead of NULL

Arguments

    AzpString - Specifies a string to make a copy of.

Return Value

    Pointer to allocated string.
        String should be freed using AzFreeMemory.
    NULL - Not enough memory was available to allocate the string

--*/
{
    LPWSTR String;
    ULONG AllocatedSize;

    //
    // Allocate and copy the string
    //

    AllocatedSize = AzpString->StringSize ? AzpString->StringSize : (ULONG)sizeof(WCHAR);
    String = (LPWSTR) AzpAllocateHeap( AllocatedSize, "UTILGSTR" );

    if ( String != NULL ) {

        //
        // Convert NULL strings to zero length strings
        //

        if ( AzpString->StringSize == 0 ) {
            *String = L'\0';

        } else {

            RtlCopyMemory( String,
                           AzpString->String,
                           AzpString->StringSize );
        }

    }

    return String;
}

PVOID
AzpGetUlongProperty(
    IN ULONG UlongValue
    )
/*++

Routine Description

    Support routine for the GetProperty API.  Convert a ULONG to the form
    supported by GetProperty.

Arguments

    UlongValue - Value to return to make a copy of.

Return Value

    Pointer to allocated string.
        String should be freed using AzFreeMemory.
    NULL - Not enough memory was available to allocate the string

--*/
{
    PULONG RetValue;

    //
    // Allocate and copy the string
    //

    RetValue = (PULONG) AzpAllocateHeap( sizeof(ULONG), "UTILGLNG" );

    if ( RetValue != NULL ) {

        *RetValue = UlongValue;

    }

    return RetValue;
}


BOOLEAN
AzpTimeHasElapsed(
    IN PLARGE_INTEGER StartTime,
    IN DWORD Timeout
    )
/*++

Routine Description:

    Determine if "Timeout" milliseconds has has elapsed since StartTime.

Arguments:

    StartTime - Specifies an absolute time when the event started (100ns units).

    Timeout - Specifies a relative time in milliseconds.  0xFFFFFFFF indicates
        that the time will never expire.

Return Value:

    TRUE -- iff Timeout milliseconds have elapsed since StartTime.

--*/
{
    LARGE_INTEGER TimeNow;
    LARGE_INTEGER ElapsedTime;
    LARGE_INTEGER Period;

    //
    // If the period to too large to handle (i.e., 0xffffffff is forever),
    //  just indicate that the timer has not expired.
    //
    // (0xffffffff is a little over 48 days).
    //

    if ( Timeout == 0xffffffff ) {
        return FALSE;
    }

    //
    // Compute the elapsed time since we last authenticated
    //

    GetSystemTimeAsFileTime( (PFILETIME)&TimeNow );
    ElapsedTime.QuadPart = TimeNow.QuadPart - StartTime->QuadPart;

    //
    // Compute Period from milliseconds into 100ns units.
    //

    Period.QuadPart = UInt32x32To64( Timeout, 10000 );


    //
    // If the elapsed time is negative (totally bogus) or greater than the
    //  maximum allowed, indicate that enough time has passed.
    //

    if ( ElapsedTime.QuadPart < 0 || ElapsedTime.QuadPart > Period.QuadPart ) {
        return TRUE;
    }

    return FALSE;
}

DWORD
AzpHresultToWinStatus(
    HRESULT hr
    )
/*++

Routine Description

    Convert an Hresult to a WIN 32 status code

Arguments

    hr - Hresult to convert

Return Value

--*/
{
    DWORD WinStatus = ERROR_INTERNAL_ERROR;

    //
    // Success is still success
    //

    if ( hr == NO_ERROR ) {
        WinStatus = NO_ERROR;

    //
    // If the facility is WIN32,
    //  the translation is easy.
    //

    } else if ((HRESULT_FACILITY(hr) == FACILITY_WIN32) && (FAILED(hr))) {

        WinStatus = HRESULT_CODE(hr);

        if ( WinStatus == ERROR_SUCCESS ) {
            WinStatus = ERROR_INTERNAL_ERROR;
        }

    //
    // All others should be left intact
    //

    } else {

        WinStatus = hr;
    }

    return WinStatus;
}

DWORD
AzpSafeArrayPointerFromVariant(
    IN VARIANT* Variant,
    IN BOOLEAN NullOk,
    OUT SAFEARRAY **retSafeArray
    )
/*++

Routine Description:

    This routine takes a pointer to a variant and returns a pointer to a SafeArray.
    Any levels of VT_BYREF are skipped.

    This routine also requires that the array be unidimensional and be an array of variants.

    VBScript has two syntaxes for calling dispinterfaces:

    1.   obj.Method (arg)
    2.   obj.Method arg

    The first syntax will pass arg by value, which our dispinterfaces will
    be able to handle.  If Method takes a BSTR argument, the VARIANT that
    arrives at Method will be of type VT_BSTR.

    The second syntax will pass arg by reference.  In this case Method will
    receive a VARIANT of type (VT_VARIANT | VT_BYREF).  The VARIANT that is
    referenced will be of type VT_BSTR.

    This function will canoicalizes the two cases.

    Optionally, VT_EMPTY, VT_NULL and VT_ERROR variants are allowed.

Arguments:

    Variant - Variant to check

    NullOk - TRUE if VT_EMPTY, VT_NULL and VT_ERROR variants are to be allowed.  If TRUE,
        and Variant is such a null variant, the retSafeArray returns a NULL pointer.

    retSafeArray - Returns a pointer to the SafeArray.

Return Value:

    NO_ERROR - The function was successful
    ERROR_INVALID_PARAMETER - The parameter is invalid

--*/
{
    SAFEARRAY *SafeArray;
    VARTYPE Vartype;
    HRESULT hr;

    //
    // Skip over any pointers to variant.
    //

    *retSafeArray = NULL;
    while ((Variant != NULL) && (V_VT(Variant) == (VT_VARIANT | VT_BYREF))) {
        Variant = V_VARIANTREF(Variant);
    }

    //
    // If null parameters are OK,
    //  allow them
    //
    // EMPTY is uninitialized
    // NULL is explicitly null
    // ERROR is unspecified optional parameter
    //

    if ( Variant == NULL || V_VT(Variant) == VT_EMPTY || V_VT(Variant) == VT_NULL || V_VT(Variant) == VT_ERROR ) {
        return NullOk ? NO_ERROR : ERROR_INVALID_PARAMETER;
    }


    //
    // Ensure this is an array.
    //

    if ( !V_ISARRAY(Variant) ) {
        AzPrint(( AZD_INVPARM, "AzpSafeArrayPointerFromVariant: parameter is not an array 0x%lx.\n", V_VT(Variant) ));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the pointer to the safe array
    //

    if ( V_ISBYREF( Variant) ) {
        SafeArray = *(SAFEARRAY **)V_BYREF( Variant );
    } else {
        SafeArray = V_ARRAY( Variant );
    }

    //
    // Handle NULL safe array
    //
    if ( SafeArray == NULL ) {
        return NullOk ? NO_ERROR : ERROR_INVALID_PARAMETER;
    }


    //
    // Array must have one dimension
    //

    if ( SafeArrayGetDim( SafeArray ) != 1 ) {
        AzPrint(( AZD_INVPARM, "AzpSafeArrayPointerFromVariant: Array %lx isn't single dimension array\n", SafeArrayGetDim( SafeArray ) ));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // The type of the values array must be variant
    //

    hr = SafeArrayGetVartype( SafeArray, &Vartype );

    if ( FAILED(hr) || Vartype != VT_VARIANT ) {
        AzPrint(( AZD_INVPARM, "AzpSafeArrayPointerFromVariant: Array isn't array of VARIANT 0x%lx %lx\n", hr, Vartype ));
        return ERROR_INVALID_PARAMETER;
    }

    *retSafeArray = SafeArray;
    return NO_ERROR;


}

DWORD
AzpConvertAbsoluteSDToSelfRelative(
    IN PSECURITY_DESCRIPTOR pAbsoluteSD,
    OUT PSECURITY_DESCRIPTOR *ppSelfRelativeSD
    )
/*++

Routine Description:

        This routine returns a self-relative SD for a passed
        in absolute form SD.  The returned SD needs to be freed using
        LocalFree routine.

Arguments:

        pAbsoluteSD - Passed in absolute form SD

        ppSelfRelativeSD - Returned self-relative form SD

Return Values:

        NO_ERROR - The self-relative form SD was created successfully
        Other status codes
--*/
{

    DWORD WinStatus = 0;

    DWORD dSelfRelativeSDLen = 0;

    //
    // Figure out the size needed for the self relatiVe SD
    //


    if ( !MakeSelfRelativeSD(
        pAbsoluteSD,
        NULL,
        &dSelfRelativeSDLen
        ) ) {

        WinStatus = GetLastError();

        if ( WinStatus == ERROR_INSUFFICIENT_BUFFER ) {

            WinStatus = NO_ERROR;

            //
            // The required length is returned on insufficient buffer failure
            //

            *ppSelfRelativeSD = (PSECURITY_DESCRIPTOR) AzpAllocateHeap( dSelfRelativeSDLen, "UTILSD2" );

            if ( *ppSelfRelativeSD == NULL ) {

                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            if ( !MakeSelfRelativeSD(
                pAbsoluteSD,
                *ppSelfRelativeSD,
                &dSelfRelativeSDLen
                ) ) {

                WinStatus = GetLastError();
            }
        }
    }

Cleanup:

    if ( WinStatus != NO_ERROR ) {

        if ( *ppSelfRelativeSD != NULL ) {

            LocalFree( *ppSelfRelativeSD );
            *ppSelfRelativeSD = NULL;
        }
    }

    return WinStatus;
}

DWORD
AzpADSetDefaultLdapOptions (
    IN OUT PLDAP pHandleLdap,
    IN PCWSTR pDomainName OPTIONAL
    )
/*++

Routine Description:

        This routine sets our default common ldap binding options.

Arguments:

        pHandle - a valid (already initialized) LDAP handle
        
        pDomainName - an optional domain name

Return Values:

        NO_ERROR if all set correctly.
        Other error status codes in case of errors. These error codes
        have already been converted from ldap error codes to win status codes.

--*/
{
    LONG LdapOption = 0;
    ULONG LdapStatus = 0;
    DWORD dwStatus = NO_ERROR;

    //
    // Don't chase referals
    //

    LdapOption = PtrToLong( LDAP_OPT_OFF );

    LdapStatus = ldap_set_option( pHandleLdap,
                                  LDAP_OPT_REFERRALS,
                                  &LdapOption );

    if ( LdapStatus != LDAP_SUCCESS ) {

        dwStatus = LdapMapErrorToWin32( LdapStatus );
        AzPrint(( AZD_AD,
                    "AzpADSetDefaultLdapOptions: ldap_set_option LDAP_OPT_REFERRALS"
                    " failed: %ld\n",
                    dwStatus
                    ));

        goto Cleanup;
    }

    //
    // Set the option telling LDAP that I passed it an explicit DC name and
    // that it can avoid the DsGetDcName.
    //

    LdapOption = PtrToLong( LDAP_OPT_ON );

    LdapStatus = ldap_set_option( pHandleLdap,
                                    LDAP_OPT_AREC_EXCLUSIVE,
                                    &LdapOption );

    if ( LdapStatus != LDAP_SUCCESS ) {

        dwStatus = LdapMapErrorToWin32( LdapStatus );
        AzPrint(( AZD_AD,
                    "AzpADSetDefaultLdapOptions: ldap_set_option LDAP_OPT_AREC_EXCLUSIVE"
                    " failed: %ld\n",
                    dwStatus
                    ));

        goto Cleanup;
    }

    //
    // We will encrypt our ldap communication, so turn on the encrypt option
    //

    LdapOption = PtrToLong( LDAP_OPT_ON );
    LdapStatus = ldap_set_option( pHandleLdap,
                                  LDAP_OPT_ENCRYPT,
                                  &LdapOption
                                  );

    if ( LdapStatus != LDAP_SUCCESS ) {

        dwStatus = LdapMapErrorToWin32( LdapStatus );
        AzPrint(( AZD_AD,
                    "AzpADSetDefaultLdapOptions: ldap_set_option LDAP_OPT_ENCRYPT"
                    " failed: %ld\n",
                    dwStatus
                    ));

        goto Cleanup;
    }

    if ( pDomainName != NULL ) {

        //
        // We need to set the option to enforce mutual authentication with the DC
        //

        LdapStatus = ldap_set_option( pHandleLdap,
                                      LDAP_OPT_DNSDOMAIN_NAME,
                                      &pDomainName
                                      );

        if ( LdapStatus != LDAP_SUCCESS ) {

            dwStatus = LdapMapErrorToWin32( LdapStatus );
            AzPrint(( AZD_AD,
                      "AzpADSetDefaultLdapOptions: ldap_set_option LDAP_OPT_DNSDOMAIN_NAME"
                      " failed: %ld\n",
                      dwStatus
                      ));

            goto Cleanup;
        }
    }

Cleanup:

    return dwStatus;
}

HRESULT AzpGetSafearrayFromArrayObject (
    IN  VARIANT     varSAorObj,
    OUT SAFEARRAY** ppsaData)
/*++

Routine Description:

    This routine converts a JScript style Array object to safearray.

Arguments:

    varSAorObj  - The VARIANT that holds a IDispatchEx object.

    ppsaData    - Receives the safearray.

Return Values:

    Success:    S_OK
    Failures:   various error code

Note:
    JScript doesn't use safearrays. Instead, it uses its own intrinsic object
    Array for arrays. For clients that uses such object for arrays, we need
    special handling because our routines expect safearray.

--*/
{
    if (ppsaData == NULL)
    {
        return E_POINTER;
    }

    *ppsaData = NULL;

    if (varSAorObj.vt != VT_DISPATCH)
    {
        return E_INVALIDARG;
    }

    CComPtr<IDispatchEx> srpDispEx;
    HRESULT hr = varSAorObj.pdispVal->QueryInterface(IID_IDispatchEx, (void**)&srpDispEx);
    DISPID id = DISPID_STARTENUM;

    //
    // It's sad that we can't use vectors. EH causes compiler errors once we use <vector>
    //  So, we have to go two passes. The first is to find the count.
    //

    ULONG uCount = 0;
    while (S_OK == hr)
    {
        hr = srpDispEx->GetNextDispID(fdexEnumAll, id, &id);
        if (S_OK == hr)
        {
            ++uCount;
        }
    }

    //
    // now we know the count, we can create the safearray
    //

    UINT i;

    if (SUCCEEDED(hr))
    {
        SAFEARRAYBOUND   rgsaBound[1];
        rgsaBound[0].lLbound = 0;       //array index from 0
        rgsaBound[0].cElements = uCount;

        SAFEARRAY *psa = SafeArrayCreate( VT_VARIANT, 1, rgsaBound );
        if (psa == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            long lArrayIndex[1];
            lArrayIndex[0] = 0;

            //
            // put each element into the safearray
            //

            id = DISPID_STARTENUM;
            DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

            for (i = 0; i < uCount; ++i)
            {
                hr = srpDispEx->GetNextDispID(fdexEnumAll, id, &id);

                //
                // GetNextDispID will return S_FALSE when there is no more
                //

                if (S_OK == hr)
                {
                    //
                    // We have to get the property by invoking the IDispatchEx.
                    //

                    CComVariant var;
                    hr = srpDispEx->Invoke( id,
                                            IID_NULL,
                                            LOCALE_USER_DEFAULT,
                                            DISPATCH_PROPERTYGET,
                                            &dispparamsNoArgs,
                                            &var,
                                            NULL,
                                            NULL
                                            );
                    if (SUCCEEDED(hr))
                    {
                        hr = SafeArrayPutElement( psa, lArrayIndex, &var );
                        ++(lArrayIndex[0]);
                    }

                    if (FAILED(hr))
                    {
                        //
                        // This is an error that shouldn't happen.
                        //

                        AZASSERT(FALSE);
                        break;
                    }
                }
                else
                {
                    //
                    // hr may be S_FALSE if no more items are found
                    //

                    break;
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            *ppsaData = psa;
        }
        else
        {
            SafeArrayDestroy(psa);
        }
    }

    return SUCCEEDED(hr) ? S_OK : hr;
}

DWORD
AzpRetrieveApplicationSequenceNumber(
    IN AZ_HANDLE AzAppHandle
    )
/*++

Routine Description:

    This routine returns the sequence number of an AzApplication object
    that can be used to determine if a certain COM handle is valid or not
    after the AzApplication object has been closed

Arguments:

    AzAppHandle - Handle to the application object whose sequence number needs to 
                  be retrieved

Return Values:

    The value of the sequence number

--*/
{
    AzpLockResourceShared(&AzGlResource);
    DWORD dwSN = ((PAZP_APPLICATION)AzAppHandle)->AppSequenceNumber;
    AzpUnlockResource(&AzGlResource);
    return dwSN;
}

//
// Debugging support
//
#ifdef AZROLESDBG
#include <stdio.h>
SAFE_CRITICAL_SECTION AzGlLogFileCritSect;
ULONG AzGlDbFlag;
// HANDLE AzGlLogFile;

#define MAX_PRINTF_LEN 1024        // Arbitrary.

VOID
AzpDumpGuid(
    IN DWORD DebugFlag,
    IN GUID *Guid OPTIONAL
    )
/*++

Routine Description:

    Dumps a GUID to the debugger output.

Arguments:

    DebugFlag: Debug flag to pass on to AzPrintRoutine

    Guid: Guid to print

Return Value:

    none

--*/
{
    RPC_STATUS RpcStatus;
    unsigned char *StringGuid;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( DebugFlag != 0 && (AzGlDbFlag & DebugFlag) == 0 ) {
        return;
    }


    if ( Guid == NULL ) {
        AzPrint(( DebugFlag, "(null)" ));
    } else {
        RpcStatus = UuidToStringA( Guid, &StringGuid );

        if ( RpcStatus != RPC_S_OK ) {
            return;
        }

        AzPrint(( DebugFlag, "%s", StringGuid ));

        RpcStringFreeA( &StringGuid );
    }

}

VOID
AzpDumpGoRef(
    IN LPSTR Text,
    IN struct _GENERIC_OBJECT *GenericObject
    )
/*++

Routine Description:

    Dumps the ref count for a generic object

Arguments:

    Text - Description of why the ref count is changing

    GenericObject - a pointer to the object being ref counted

Return Value:

    none

--*/
{
    LPWSTR StringSid = NULL;
    LPWSTR StringToPrint;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( (AzGlDbFlag & AZD_REF) == 0 ) {
        return;
    }

    //
    // Convert the sid to a string
    //
    if ( GenericObject->ObjectName == NULL ) {
        StringToPrint = NULL;

    } else if ( GenericObject->ObjectName->ObjectName.IsSid ) {
        if ( ConvertSidToStringSid( (PSID)GenericObject->ObjectName->ObjectName.String, &StringSid)) {
            StringToPrint = StringSid;
        } else {
            StringToPrint = L"<Invalid Sid>";
        }
    } else {
        StringToPrint = GenericObject->ObjectName->ObjectName.String;
    }


    AzPrint(( AZD_REF, "0x%lx %ld (%ld) %ws: %s\n", GenericObject, GenericObject->ObjectType, GenericObject->ReferenceCount, StringToPrint, Text ));

    if ( StringSid != NULL ) {
        LocalFree( StringSid );
    }

}

VOID
AzpPrintRoutineV(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    va_list arglist
    )
/*++

Routine Description

    Debug routine for azroles

Arguments

    DebugFlag - Flag to indicating the functionality being debugged

    --- Other printf parameters

Return Value

--*/

{
    static LPSTR AzGlLogFileOutputBuffer = NULL;
    ULONG length;
    int   lengthTmp;
    // DWORD BytesWritten;
    static BeginningOfLine = TRUE;
    static LineCount = 0;
    static TruncateLogFileInProgress = FALSE;
    static LogProblemWarned = FALSE;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( DebugFlag != 0 && (AzGlDbFlag & DebugFlag) == 0 ) {
        return;
    }


    //
    // Allocate a buffer to build the line in.
    //  If there isn't already one.
    //

    length = 0;

    if ( AzGlLogFileOutputBuffer == NULL ) {
        AzGlLogFileOutputBuffer = (LPSTR) LocalAlloc( 0, MAX_PRINTF_LEN + 1 );

        if ( AzGlLogFileOutputBuffer == NULL ) {
            return;
        }
    }

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        //
        // Never print empty lines.
        //

        if ( Format[0] == '\n' && Format[1] == '\0' ) {
            return;
        }

#if 0
        //
        // If the log file is getting huge,
        //  truncate it.
        //

        if ( AzGlLogFile != INVALID_HANDLE_VALUE &&
             !TruncateLogFileInProgress ) {

            //
            // Only check every 50 lines,
            //

            LineCount++;
            if ( LineCount >= 50 ) {
                DWORD FileSize;
                LineCount = 0;

                //
                // Is the log file too big?
                //

                FileSize = GetFileSize( AzGlLogFile, NULL );
                if ( FileSize == 0xFFFFFFFF ) {
                    (void) DbgPrint( "[NETLOGON] Cannot GetFileSize %ld\n",
                                     GetLastError );
                } else if ( FileSize > AzGlParameters.LogFileMaxSize ) {
                    TruncateLogFileInProgress = TRUE;
                    SafeLeaveCriticalSection( &AzGlLogFileCritSect );
                    NlOpenDebugFile( TRUE );
                    NlPrint(( NL_MISC,
                              "Logfile truncated because it was larger than %ld bytes\n",
                              AzGlParameters.LogFileMaxSize ));
                    SafeEnterCriticalSection( &AzGlLogFileCritSect );
                    TruncateLogFileInProgress = FALSE;
                }

            }
        }

        //
        // If we're writing to the debug terminal,
        //  indicate this is a azroles message.
        //

        if ( AzGlLogFile == INVALID_HANDLE_VALUE ) {
            length += (ULONG) sprintf( &AzGlLogFileOutputBuffer[length], "[AZROLES] " );
        }

        //
        // Put the timestamp at the begining of the line.
        //
        {
            SYSTEMTIME SystemTime;
            GetLocalTime( &SystemTime );
            length += (ULONG) sprintf( &AzGlLogFileOutputBuffer[length],
                                  "%02u/%02u %02u:%02u:%02u ",
                                  SystemTime.wMonth,
                                  SystemTime.wDay,
                                  SystemTime.wHour,
                                  SystemTime.wMinute,
                                  SystemTime.wSecond );
        }
#endif // 0

        //
        // Indicate the type of message on the line
        //
        {
            char *Text;

            switch (DebugFlag) {
            case AZD_HANDLE:
                Text = "HANDLE"; break;
            case AZD_OBJLIST:
                Text = "OBJLIST"; break;
            case AZD_INVPARM:
                Text = "INVPARM"; break;
            case AZD_PERSIST:
            case AZD_PERSIST_MORE:
                Text = "PERSIST"; break;
            case AZD_REF:
                Text = "OBJREF"; break;
            case AZD_DISPATCH:
                Text = "DISPATCH"; break;
            case AZD_ACCESS:
            case AZD_ACCESS_MORE:
                Text = "ACCESS"; break;
            case AZD_DOMREF:
                Text = "DOMREF"; break;
            case AZD_XML:
                Text = "XML"; break;
            case AZD_AD:
                Text = "AD"; break;
            case AZD_SCRIPT:
            case AZD_SCRIPT_MORE:
                Text = "SCRIPT"; break;
            case AZD_CRITICAL:
                Text = "CRITICAL"; break;
            default:
                Text = "UNKNOWN"; break;

            case 0:
                Text = NULL;
            }
            if ( Text != NULL ) {
                length += (ULONG) sprintf( &AzGlLogFileOutputBuffer[length], "[%s] ", Text );
            }
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    lengthTmp = (ULONG) _vsnprintf( &AzGlLogFileOutputBuffer[length],
                                    MAX_PRINTF_LEN - length - 1,
                                    Format,
                                    arglist );

    if ( lengthTmp < 0 ) {
        length = MAX_PRINTF_LEN - 1;
        // always end the line which cannot fit into the buffer
        AzGlLogFileOutputBuffer[length-1] = '\n';
    } else {
        length += lengthTmp;
    }

    BeginningOfLine = (length > 0 && AzGlLogFileOutputBuffer[length-1] == '\n' );
    if ( BeginningOfLine ) {
        AzGlLogFileOutputBuffer[length-1] = '\r';
        AzGlLogFileOutputBuffer[length] = '\n';
        AzGlLogFileOutputBuffer[length+1] = '\0';
        length++;
    }


#if 0
    //
    // If the log file isn't open,
    //  just output to the debug terminal
    //

    if ( AzGlLogFile == INVALID_HANDLE_VALUE ) {
#if DBG
        if ( !LogProblemWarned ) {
            (void) DbgPrint( "[NETLOGON] Cannot write to log file [Invalid Handle]\n" );
            LogProblemWarned = TRUE;
        }
#endif // DBG

    //
    // Write the debug info to the log file.
    //

    } else {
        if ( !WriteFile( AzGlLogFile,
                         AzGlLogFileOutputBuffer,
                         length,
                         &BytesWritten,
                         NULL ) ) {
#if DBG
            if ( !LogProblemWarned ) {
                (void) DbgPrint( "[NETLOGON] Cannot write to log file %ld\n", GetLastError() );
                LogProblemWarned = TRUE;
            }
#endif // DBG
        }

    }
#else // 0
    printf( "%s", AzGlLogFileOutputBuffer );
#endif // 0

}

VOID
AzpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{
    va_list arglist;

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    SafeEnterCriticalSection( &AzGlLogFileCritSect );

    //
    // Simply change arguments to va_list form and call NlPrintRoutineV
    //

    va_start(arglist, Format);

    AzpPrintRoutineV( DebugFlag, Format, arglist );

    va_end(arglist);

    SafeLeaveCriticalSection( &AzGlLogFileCritSect );

} // AzPrintRoutine
#endif // AZROLESDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\task.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    task.cxx

Abstract:

    Routines implementing the Task object

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/

#include "pch.hxx"

//
// Define the default values for all scalar attributes
//

BOOL AzGlDefIsRoleDefinition = FALSE;

AZP_DEFAULT_VALUE AzGlTaskDefaultValues[] = {
    { AZ_PROP_TASK_BIZRULE,               AZ_DIRTY_TASK_BIZRULE,               NULL },
    { AZ_PROP_TASK_BIZRULE_LANGUAGE,      AZ_DIRTY_TASK_BIZRULE_LANGUAGE,      NULL },
    { AZ_PROP_TASK_BIZRULE_IMPORTED_PATH, AZ_DIRTY_TASK_BIZRULE_IMPORTED_PATH, NULL },
    { AZ_PROP_TASK_IS_ROLE_DEFINITION,    AZ_DIRTY_TASK_IS_ROLE_DEFINITION,    &AzGlDefIsRoleDefinition },
    { 0, 0, NULL }
};



DWORD
AzpTaskInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzTaskCreate.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    DWORD WinStatus;
    NTSTATUS Status;

    PAZP_TASK Task = (PAZP_TASK) ChildGenericObject;
    PAZP_APPLICATION Application = NULL;
    PAZP_SCOPE Scope = NULL;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Behave differently depending on the object type of the parent object
    //

    if ( ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION ) {
        Application = (PAZP_APPLICATION) ParentGenericObject;

    } else if ( ParentGenericObject->ObjectType == OBJECT_TYPE_SCOPE ) {
        Application = (PAZP_APPLICATION) ParentOfChild( ParentGenericObject );
        Scope = (PAZP_SCOPE) ParentGenericObject;

    } else {
        ASSERT( FALSE );
    }

    //
    // Tasks reference 'Operations' that are children of the same 'Application' as the Task object
    // Tasks reference 'Tasks' that are children of the same 'Application' as the Task object
    //  Let the generic object manager know all of the lists we support
    //

    ChildGenericObject->GenericObjectLists = &Task->Operations,
    // Link to Operations
    ObInitObjectList( &Task->Operations,
                      &Task->Tasks,
                      FALSE, // Forward link
                      0,     // No link pair id
                      AZ_DIRTY_TASK_OPERATIONS,
                      &Application->Operations,
                      NULL,
                      NULL );

    // Link to Tasks
    ObInitObjectList( &Task->Tasks,
                      &Task->backRoles,
                      FALSE, // Forward link
                      0,     // No link pair id
                      AZ_DIRTY_TASK_TASKS,
                      &Application->Tasks,
                      Scope == NULL ? NULL : &Scope->Tasks,
                      NULL );

    // Back link to roles
    ObInitObjectList( &Task->backRoles,
                      &Task->backTasks,
                      TRUE, // Backward link
                      0,    // No link pair id
                      0,    // No dirty bit on back link
                      NULL,
                      NULL,
                      NULL );

    // Back link to tasks
    ObInitObjectList( &Task->backTasks,
                      NULL,
                      TRUE, // Backward link
                      0,    // No link pair id
                      0,    // No dirty bit on back link
                      NULL,
                      NULL,
                      NULL );

    //
    // Initialize the list of free script engines
    //

    InitializeListHead( &Task->FreeScriptHead );

    //
    // Initialize the list of Running script engines
    //

    Status = SafeInitializeCriticalSection( &Task->RunningScriptCritSect, SAFE_RUNNING_SCRIPT_LIST );

    if ( !NT_SUCCESS( Status )) {
        WinStatus = RtlNtStatusToDosError( Status );
        goto Cleanup;
    }

    Task->RunningScriptCritSectInitialized = TRUE;

    InitializeListHead( &Task->RunningScriptHead );



    WinStatus =  NO_ERROR;

Cleanup:
    if ( WinStatus != NO_ERROR ) {
        AzpTaskFree( ChildGenericObject );
    }

    return WinStatus;
}


VOID
AzpTaskFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for Task object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    PAZP_TASK Task = (PAZP_TASK) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Free any local strings
    //

    AzpFreeString( &Task->BizRule );
    AzpFreeString( &Task->BizRuleLanguage );
    AzpFreeString( &Task->BizRuleImportedPath );

    //
    // Free the running script list
    //

    if ( Task->RunningScriptCritSectInitialized ) {

        //
        // Free the Free Script List itself
        //

        AzpFlushBizRule( Task );

        //
        // The task object is referenced as long as the script is running
        //  So we shouldn't be here unless the running script list is empty.

        ASSERT( IsListEmpty( &Task->RunningScriptHead ));

        // Free the crit sect protecting the list
        SafeDeleteCriticalSection( &Task->RunningScriptCritSect );
        Task->RunningScriptCritSectInitialized = FALSE;
    }

}

DWORD
AzpTaskNameConflict(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PAZP_STRING ChildObjectNameString
    )
/*++

Routine Description:

    This routine is a worker routine to determine if the specified ChildObjectNameString
    conflicts with the names of other objects that share a namespace with Tasks.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildObjectNameString - Specifies the name of the child object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    ULONG WinStatus;
    PAZP_APPLICATION Application = NULL;
    PGENERIC_OBJECT ConflictGenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );



    //
    // Behave differently depending on the object type of the parent object
    //
    //
    // A task that is a child of an application
    //  cannot have the same name as any tasks that are children of any of the child scopes.
    //

    if ( ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION ) {
        Application = (PAZP_APPLICATION) ParentGenericObject;

        //
        // Check tasks that are children of child scopes.
        //

        WinStatus = ObCheckNameConflict( &Application->Scopes,
                                         ChildObjectNameString,
                                         offsetof(_AZP_SCOPE, Tasks),
                                         0,
                                         0 );

    //
    // A task that is a child of a scope,
    //  cannot have the same name as tasks that are children of the application.
    //
    } else if ( ParentGenericObject->ObjectType == OBJECT_TYPE_SCOPE ) {
        Application = (PAZP_APPLICATION) ParentOfChild( ParentGenericObject );

        //
        // Check tasks that are children of the application.
        //

        WinStatus = ObReferenceObjectByName( &Application->Tasks,
                                             ChildObjectNameString,
                                             0,     // No special flags
                                             &ConflictGenericObject );
        if ( WinStatus == NO_ERROR ) {
            ObDereferenceObject( ConflictGenericObject );
            WinStatus = ERROR_ALREADY_EXISTS;
        } else {
            WinStatus = NO_ERROR;
        }

    } else {
        WinStatus = ERROR_INTERNAL_ERROR;
        ASSERT( FALSE );
    }

    //
    // Tasks and operations share a namespace so ensure there isn't an operation by this name.
    //

    if ( WinStatus == NO_ERROR ) {
        WinStatus = ObReferenceObjectByName( &Application->Operations,
                                             ChildObjectNameString,
                                             0,     // No special flags
                                             &ConflictGenericObject );

        if ( WinStatus == NO_ERROR ) {
            ObDereferenceObject( ConflictGenericObject );
            WinStatus = ERROR_ALREADY_EXISTS;
        } else {
            WinStatus = NO_ERROR;
        }

    }

    return WinStatus;
}


DWORD
AzpTaskGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    This routine is the Task specific worker routine for AzGetProperty.
    It does any object specific property gets.

    On entry, AzGlResource must be locked shared.

Arguments:

    GenericObject - Specifies a pointer to the object to be queried

    Flags - Specifies internal flags
        AZP_FLAGS_BY_GUID - name lists should be returned as GUID lists

    PropertyId - Specifies which property to return.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_TASK_BIZRULE                LPWSTR - Biz rule for the task
        AZ_PROP_TASK_BIZRULE_LANGUAGE       LPWSTR - Biz language rule for the task
        AZ_PROP_TASK_BIZRULE_IMPORTED_PATH  LPWSTR - Path Bizrule was imported from
        AZ_PROP_TASK_OPERATIONS             AZ_STRING_ARRAY - Operations granted by this task
        AZ_PROP_TASK_TASKS                  AZ_STRING_ARRAY - tasks granted by this task
        AZ_PROP_TASK_IS_ROLE_DEFINITION     PULONG - TRUE if this task is a role template

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_TASK Task = (PAZP_TASK) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    //
    // Return any object specific attribute
    //

    switch ( PropertyId ) {

    //
    // Return BizRule to the caller
    //
    case AZ_PROP_TASK_BIZRULE:

        //
        // check if bizrule should be returned
        //
        if ( Task->BizRule.String != NULL &&
             (ParentOfChild(GenericObject))->ObjectType == OBJECT_TYPE_SCOPE &&
             (ParentOfChild(GenericObject))->PolicyAdmins.GenericObjects.UsedCount != 0 ) {
            //
            // the parent scope object is delegated, do not allow bizrule
            //

            AzPrint(( AZD_INVPARM, "AzTaskGetProperty: scope is delegated - bizrule not allowed %ld\n", PropertyId ));
            WinStatus = ERROR_NOT_SUPPORTED;

        } else {

            *PropertyValue = AzpGetStringProperty( &Task->BizRule );

            if ( *PropertyValue == NULL ) {
                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        break;

    //
    // Return BizRule language to the caller
    //
    case AZ_PROP_TASK_BIZRULE_LANGUAGE:

        //
        // check if bizrule should be returned
        //
        if ( Task->BizRuleLanguage.String != NULL &&
             (ParentOfChild(GenericObject))->ObjectType == OBJECT_TYPE_SCOPE &&
             (ParentOfChild(GenericObject))->PolicyAdmins.GenericObjects.UsedCount != 0 ) {
            //
            // the parent scope object is delegated, do not allow bizrule
            //

            AzPrint(( AZD_INVPARM, "AzTaskGetProperty: scope is delegated - bizrule not allowed %ld\n", PropertyId ));
            WinStatus = ERROR_NOT_SUPPORTED;

        } else {

            *PropertyValue = AzpGetStringProperty( &Task->BizRuleLanguage );

            if ( *PropertyValue == NULL ) {
                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        break;

    //
    // Return BizRule imported path to the caller
    //
    case AZ_PROP_TASK_BIZRULE_IMPORTED_PATH:

        //
        // check if bizrule should be returned
        //
        if ( Task->BizRuleImportedPath.String != NULL &&
             (ParentOfChild(GenericObject))->ObjectType == OBJECT_TYPE_SCOPE &&
             (ParentOfChild(GenericObject))->PolicyAdmins.GenericObjects.UsedCount != 0 ) {
            //
            // the parent scope object is delegated, do not allow bizrule
            //

            AzPrint(( AZD_INVPARM, "AzTaskGetProperty: scope is delegated - bizrule not allowed %ld\n", PropertyId ));
            WinStatus = ERROR_NOT_SUPPORTED;

        } else {

            *PropertyValue = AzpGetStringProperty( &Task->BizRuleImportedPath );

            if ( *PropertyValue == NULL ) {
                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        break;

    //
    // Return the set of operations to the caller
    //
    case AZ_PROP_TASK_OPERATIONS:

        if ( Flags & AZP_FLAGS_BY_GUID )
        {
            *PropertyValue = ObGetPropertyItemGuids( &Task->Operations);
        }
        else
        {
            *PropertyValue = ObGetPropertyItems( &Task->Operations);
        }

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    //
    // Return the set of tasks to the caller
    //
    case AZ_PROP_TASK_TASKS:

        if ( Flags & AZP_FLAGS_BY_GUID )
        {
            *PropertyValue = ObGetPropertyItemGuids( &Task->Tasks);
        }
        else
        {
            *PropertyValue = ObGetPropertyItems( &Task->Tasks);
        }

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    case AZ_PROP_TASK_IS_ROLE_DEFINITION:

        *PropertyValue = AzpGetUlongProperty( (Task->IsRoleDefinition) ? 1 : 0 );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    default:
        AzPrint(( AZD_INVPARM, "AzTaskGetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        break;
    }

    return WinStatus;
}


DWORD
AzpTaskSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG Flags,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    This routine is the Task object specific worker routine for AzSetProperty.
    It does any object specific property sets.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies a pointer to the object to be modified

    Flags - Specifies flags controlling to operation of the routine
        AZP_FLAGS_SETTING_TO_DEFAULT - Property is being set to default value

    PropertyId - Specifies which property to set.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_TASK_BIZRULE                LPWSTR - Biz rule for the task
        AZ_PROP_TASK_BIZRULE_LANGUAGE       LPWSTR - Biz language rule for the task
        AZ_PROP_TASK_BIZRULE_IMPORTED_PATH  LPWSTR - Path Bizrule was imported from
        AZ_PROP_TASK_IS_ROLE_DEFINITION     PULONG - TRUE if this task is a role template

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;

    PAZP_TASK Task = (PAZP_TASK) GenericObject;
    AZP_STRING CapturedString;

    AZP_STRING ValidValue1;
    AZP_STRING ValidValue2;
    
    BOOL bHasChanged = TRUE;

    //
    // Initialization
    //

    UNREFERENCED_PARAMETER( Flags );
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    AzpInitString( &CapturedString, NULL );

    //
    // Set any object specific attribute
    //

    switch ( PropertyId ) {

    //
    // Set BizRule on the object
    //
    case AZ_PROP_TASK_BIZRULE:

        BEGIN_SETPROP( &WinStatus, Task, Flags, AZ_DIRTY_TASK_BIZRULE ) {

            //
            // Capture the input string
            //

            WinStatus = AzpCaptureString( &CapturedString,
                                          (LPWSTR) PropertyValue,
                                          CHECK_STRING_LENGTH( Flags, AZ_MAX_TASK_BIZRULE_LENGTH),
                                          TRUE ); // NULL is OK

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            if (IsNormalFlags(Flags) && CapturedString.String != NULL)
            {
                //
                // This SetProperty comes from the client. We will check against
                // space only biz rules
                //

                BOOL bSpaceOnly = TRUE;
                for (UINT i = 0; i < CapturedString.StringSize / sizeof(WCHAR) - 1; i++)
                {
                    if (!iswspace(CapturedString.String[i]))
                    {
                        bSpaceOnly = FALSE;
                        break;
                    }
                }

                if (bSpaceOnly)
                {
                    WinStatus = ERROR_INVALID_DATA;
                    goto Cleanup;
                }
            }

            //
            // Do parameter validity checking
            //
            BEGIN_VALIDITY_CHECKING( Flags ) {

                //
                // check if bizrule attribute is allowed
                //
                if ( CapturedString.String != NULL &&
                     (ParentOfChild(GenericObject))->ObjectType == OBJECT_TYPE_SCOPE &&
                     (ParentOfChild(GenericObject))->PolicyAdmins.GenericObjects.UsedCount != 0 ) {
                    //
                    // the parent scope object is delegated, do not allow bizrule
                    //

                    AzPrint(( AZD_INVPARM, "AzTaskGetProperty: scope is delegated - bizrule not allowed %ld\n", PropertyId ));
                    WinStatus = ERROR_NOT_SUPPORTED;
                    goto Cleanup;

                }

                //
                // Ensure the language is set
                //

                if ( CapturedString.String != NULL &&
                     Task->BizRuleLanguage.String == NULL ) {

                    AzPrint(( AZD_INVPARM, "AzpTaskSetProperty: Must set language before bizrule\n" ));
                    WinStatus = ERROR_INVALID_PARAMETER;
                    goto Cleanup;
                }

            } END_VALIDITY_CHECKING;

            //
            // Only process the change if the strings have changed
            //

            bHasChanged = !AzpEqualStrings( &CapturedString, &Task->BizRule );
            if ( bHasChanged ) {

                //
                // Swap the old/new names
                //

                SafeEnterCriticalSection( &Task->RunningScriptCritSect );
                AzpSwapStrings( &CapturedString, &Task->BizRule );
                Task->BizRuleSerialNumber ++;
                SafeLeaveCriticalSection( &Task->RunningScriptCritSect );

                //
                // Tell the script engine cache that the script has changed
                //

                AzpFlushBizRule( Task );

                //
                // Do parameter validity checking
                //
                BEGIN_VALIDITY_CHECKING( Flags ) {

                    //
                    // Ensure the script is syntactically valid
                    //

                    if ( Task->BizRule.String != NULL &&
                         Task->BizRuleLanguage.String != NULL ) {

                        WinStatus = AzpParseBizRule( Task );

                        if ( WinStatus != NO_ERROR ) {

                            // Put the script back
                            SafeEnterCriticalSection( &Task->RunningScriptCritSect );
                            AzpSwapStrings( &CapturedString, &Task->BizRule );
                            Task->BizRuleSerialNumber ++;
                            SafeLeaveCriticalSection( &Task->RunningScriptCritSect );
                        }
                    }

                } END_VALIDITY_CHECKING;
            }

        } END_SETPROP (bHasChanged);

        break;

    //
    // Set BizRule language on the object
    //
    case AZ_PROP_TASK_BIZRULE_LANGUAGE:

        BEGIN_SETPROP( &WinStatus, Task, Flags, AZ_DIRTY_TASK_BIZRULE_LANGUAGE ) {

            //
            // Capture the input string
            //

            WinStatus = AzpCaptureString( &CapturedString,
                                          (LPWSTR) PropertyValue,
                                          CHECK_STRING_LENGTH( Flags, AZ_MAX_TASK_BIZRULE_LANGUAGE_LENGTH),
                                          TRUE ); // NULL is OK

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            //
            // Ensure it is one of the valid values
            //

            //
            // Do parameter validity checking
            //
            BEGIN_VALIDITY_CHECKING( Flags ) {

                //
                // check if bizrule attribute is allowed
                //
                if ( CapturedString.String != NULL &&
                     (ParentOfChild(GenericObject))->ObjectType == OBJECT_TYPE_SCOPE &&
                     (ParentOfChild(GenericObject))->PolicyAdmins.GenericObjects.UsedCount != 0 ) {
                    //
                    // the parent scope object is delegated, do not allow bizrule
                    //

                    AzPrint(( AZD_INVPARM, "AzTaskGetProperty: scope is delegated - bizrule not allowed %ld\n", PropertyId ));
                    WinStatus = ERROR_NOT_SUPPORTED;
                    goto Cleanup;

                }

                if ( CapturedString.String != NULL ) {
                    AzpInitString( &ValidValue1, L"VBScript" );
                    AzpInitString( &ValidValue2, L"JScript" );

                    if ( !AzpEqualStrings( &CapturedString, &ValidValue1) &&
                         !AzpEqualStrings( &CapturedString, &ValidValue2) ) {
                        AzPrint(( AZD_INVPARM, "AzpTaskSetProperty: invalid language %ws\n", CapturedString.String ));
                        WinStatus = ERROR_INVALID_PARAMETER;
                        goto Cleanup;
                    }

                }

            } END_VALIDITY_CHECKING;


            //
            // Only process the change if the strings have changed
            //

            bHasChanged = !AzpEqualStrings( &CapturedString, &Task->BizRuleLanguage );

            if ( bHasChanged ) {

                //
                // Swap the old/new names
                //

                SafeEnterCriticalSection( &Task->RunningScriptCritSect );
                AzpSwapStrings( &CapturedString, &Task->BizRuleLanguage );
                RtlZeroMemory( &Task->BizRuleLanguageClsid, sizeof(Task->BizRuleLanguageClsid) );
                Task->BizRuleSerialNumber ++;
                SafeLeaveCriticalSection( &Task->RunningScriptCritSect );

                //
                // Tell the script engine cache that the script has changed
                //

                AzpFlushBizRule( Task );

                //
                // Do parameter validity checking
                //
                BEGIN_VALIDITY_CHECKING( Flags ) {

                    //
                    // Ensure the script is syntactically valid
                    //

                    if ( Task->BizRule.String != NULL &&
                         Task->BizRuleLanguage.String != NULL ) {

                        WinStatus = AzpParseBizRule( Task );

                        if ( WinStatus != NO_ERROR ) {

                            // Put the script back
                            SafeEnterCriticalSection( &Task->RunningScriptCritSect );
                            AzpSwapStrings( &CapturedString, &Task->BizRuleLanguage );
                            Task->BizRuleSerialNumber ++;
                            RtlZeroMemory( &Task->BizRuleLanguageClsid, sizeof(Task->BizRuleLanguageClsid) );
                            SafeLeaveCriticalSection( &Task->RunningScriptCritSect );
                        }
                    }

                } END_VALIDITY_CHECKING;
            }

        } END_SETPROP (bHasChanged);
        break;

    //
    // Set BizRule imported path on the object
    //
    case AZ_PROP_TASK_BIZRULE_IMPORTED_PATH:

        BEGIN_SETPROP( &WinStatus, Task, Flags, AZ_DIRTY_TASK_BIZRULE_IMPORTED_PATH ) {
            //
            // Capture the input string
            //

            WinStatus = AzpCaptureString( &CapturedString,
                                          (LPWSTR) PropertyValue,
                                          CHECK_STRING_LENGTH( Flags, AZ_MAX_TASK_BIZRULE_IMPORTED_PATH_LENGTH),
                                          TRUE ); // NULL is OK

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

            //
            // Ensure it is one of the valid values
            //

            //
            // Do parameter validity checking
            //
            BEGIN_VALIDITY_CHECKING( Flags ) {

                //
                // check if bizrule attribute is allowed
                //
                if ( CapturedString.String != NULL &&
                     (ParentOfChild(GenericObject))->ObjectType == OBJECT_TYPE_SCOPE &&
                     (ParentOfChild(GenericObject))->PolicyAdmins.GenericObjects.UsedCount != 0 ) {
                    //
                    // the parent scope object is delegated, do not allow bizrule
                    //

                    AzPrint(( AZD_INVPARM, "AzTaskGetProperty: scope is delegated - bizrule not allowed %ld\n", PropertyId ));
                    WinStatus = ERROR_NOT_SUPPORTED;
                    goto Cleanup;

                }
            } END_VALIDITY_CHECKING;


            //
            // Swap the old/new names
            //

            AzpSwapStrings( &CapturedString, &Task->BizRuleImportedPath );
        } END_SETPROP(bHasChanged);
        break;

    case AZ_PROP_TASK_IS_ROLE_DEFINITION:

        BEGIN_SETPROP( &WinStatus, Task, Flags, AZ_DIRTY_TASK_IS_ROLE_DEFINITION ) {
            WinStatus = AzpCaptureLong( PropertyValue, &Task->IsRoleDefinition );
        } END_SETPROP(bHasChanged);
        break;

    default:
        AzPrint(( AZD_INVPARM, "AzpTaskSetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Free any local resources
    //
Cleanup:
    AzpFreeString( &CapturedString );

    return WinStatus;
}

DWORD
AzpTaskCheckRefLoop(
    IN PAZP_TASK ParentTask,
    IN PAZP_TASK CurrentTask,
    IN ULONG GenericObjectListOffset
    )
/*++

Routine Description:

    This routine determines whether the task members of "CurrentTask"
    reference "ParentTask".  This is done to detect loops where the
    task references itself directly or indirectly.

    On entry, AzGlResource must be locked shared.

Arguments:

    ParentTask - Task that contains the original membership.

    CurrentTask - Task that is currently being inspected to see if it
        loops back to ParentTask

    GenericObjectListOffset -  Offset to the particular GenericObjectList being
        checked.

Return Value:

    Status of the operation
    ERROR_DS_LOOP_DETECT - A loop has been detected.

--*/
{
    ULONG WinStatus;

    PGENERIC_OBJECT_LIST GenericObjectList;
    ULONG i;
    PAZP_TASK NextTask;

    //
    // Check for a reference to ourself
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );
    if ( ParentTask == CurrentTask ) {
        return ERROR_DS_LOOP_DETECT;
    }

    //
    // Compute a pointer to the membership list to check
    //

    GenericObjectList = (PGENERIC_OBJECT_LIST)
        (((LPBYTE)CurrentTask)+GenericObjectListOffset);

    //
    // Check all tasks that are members of the current task
    //

    for ( i=0; i<GenericObjectList->GenericObjects.UsedCount; i++ ) {

        NextTask = (PAZP_TASK) (GenericObjectList->GenericObjects.Array[i]);


        //
        // Recursively check this task
        //

        WinStatus = AzpTaskCheckRefLoop( ParentTask, NextTask, GenericObjectListOffset );

        if ( WinStatus != NO_ERROR ) {
            return WinStatus;
        }

    }

    return NO_ERROR;

}


DWORD
AzpTaskAddPropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PGENERIC_OBJECT LinkedToObject
    )
/*++

Routine Description:

    This routine is the task object specific worker routine for AzAddPropertyItem.
    It does any object specific property adds

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies a pointer to the object to be modified

    GenericObjectList - Specifies the object list the object is to be added to

    LinkedToObject - Specifies the object that is being linked to

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus;
    PAZP_TASK Task = (PAZP_TASK) GenericObject;


    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // If we're linking to a task,
    //   Ensure this newly added membership doesn't cause a task membership loop
    //

    if ( LinkedToObject->ObjectType == OBJECT_TYPE_TASK ) {
        WinStatus = AzpTaskCheckRefLoop( Task,
                                         (PAZP_TASK)LinkedToObject,
                                         (ULONG)(((LPBYTE)GenericObjectList)-((LPBYTE)Task)) );
    } else {
        WinStatus = NO_ERROR;
    }


    //
    // Free any local resources
    //

    return WinStatus;
}

DWORD
AzpTaskGetGenericChildHead(
    IN AZ_HANDLE ParentHandle,
    OUT PULONG ObjectType,
    OUT PGENERIC_OBJECT_HEAD *GenericChildHead
    )
/*++

Routine Description:

    This routine determines whether ParentHandle supports Task objects as
    children.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the role.
        This may be an Application Handle or a Scope handle.

    ObjectType - Returns the object type of the ParentHandle.

    GenericChildHead - Returns a pointer to the head of the list of roles objects
        that are children of the object specified by ParentHandle.  This in an unverified
        pointer.  The pointer is only valid after ParentHandle has been validated.

Return Value:

    Status of the operation.

--*/
{
    DWORD WinStatus;

    //
    // Determine the type of the parent handle
    //

    WinStatus = ObGetHandleType( (PGENERIC_OBJECT)ParentHandle,
                                 FALSE, // ignore deleted objects
                                 ObjectType );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }


    //
    // Verify that the specified handle support children roles.
    //

    switch ( *ObjectType ) {
    case OBJECT_TYPE_APPLICATION:

        *GenericChildHead = &(((PAZP_APPLICATION)ParentHandle)->Tasks);
        break;

    case OBJECT_TYPE_SCOPE:

        *GenericChildHead = &(((PAZP_SCOPE)ParentHandle)->Tasks);
        break;

    default:
        return ERROR_INVALID_HANDLE;
    }

    return NO_ERROR;
}



DWORD
WINAPI
AzTaskCreate(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR TaskName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE TaskHandle
    )
/*++

Routine Description:

    This routine adds a task into the scope of the specified parent object

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the task.
        This may be an Application Handle or a Scope handle.

    TaskName - Specifies the name of the task to add.

    Reserved - Reserved.  Must by zero.

    TaskHandle - Return a handle to the task.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports tasks as children
    //

    WinStatus = AzpTaskGetGenericChildHead( ParentHandle,
                                            &ObjectType,
                                            &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }
    //
    // Call the common routine to do most of the work
    //

    return ObCommonCreateObject(
                    (PGENERIC_OBJECT) ParentHandle,
                    ObjectType,
                    GenericChildHead,
                    OBJECT_TYPE_TASK,
                    TaskName,
                    Reserved,
                    (PGENERIC_OBJECT *) TaskHandle );
}



DWORD
WINAPI
AzTaskOpen(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR TaskName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE TaskHandle
    )
/*++

Routine Description:

    This routine opens a task into the scope of the specified parent object.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the task.
        This may be an Application Handle or a Scope handle.

    TaskName - Specifies the name of the task to open

    Reserved - Reserved.  Must by zero.

    TaskHandle - Return a handle to the task.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - There is no task by that name

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports tasks as children
    //

    WinStatus = AzpTaskGetGenericChildHead( ParentHandle,
                                            &ObjectType,
                                            &GenericChildHead );


    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonOpenObject(
        (PGENERIC_OBJECT) ParentHandle,
        ObjectType,
        GenericChildHead,
        OBJECT_TYPE_TASK,
        TaskName,
        Reserved,
        (PGENERIC_OBJECT *) TaskHandle );

}


DWORD
WINAPI
AzTaskEnum(
    IN AZ_HANDLE ParentHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE TaskHandle
    )
/*++

Routine Description:

    Enumerates all of the tasks for the specified parent object.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the task.
        This may be an Application Handle or a Scope handle.

    Reserved - Reserved.  Must by zero.

    EnumerationContext - Specifies a context indicating the next task to return
        On input for the first call, should point to zero.
        On input for subsequent calls, should point to the value returned on the previous call.
        On output, returns a value to be passed on the next call.

    TaskHandle - Returns a handle to the next task object.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful (a handle was returned)

    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports tasks as children
    //

    WinStatus = AzpTaskGetGenericChildHead( ParentHandle,
                                            &ObjectType,
                                            &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonEnumObjects(
                    (PGENERIC_OBJECT) ParentHandle,
                    ObjectType,
                    GenericChildHead,
                    EnumerationContext,
                    Reserved,
                    (PGENERIC_OBJECT *) TaskHandle );

}


DWORD
WINAPI
AzTaskDelete(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR TaskName,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This routine deletes a task from the scope of the specified parent object.
    Also deletes any child objects of TaskName.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the task.
        This may be an Application Handle or a Scope handle.

    TaskName - Specifies the name of the task to delete.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - An object by that name cannot be found

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports tasks as children
    //

    WinStatus = AzpTaskGetGenericChildHead( ParentHandle,
                                            &ObjectType,
                                            &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonDeleteObject(
                    (PGENERIC_OBJECT) ParentHandle,
                    ObjectType,
                    GenericChildHead,
                    OBJECT_TYPE_TASK,
                    TaskName,
                    Reserved );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\stdafx_stub.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    stdafx_stub.cxx

Abstract:

    Stub file that does nothing but turn off some compiler warnings then
    includes the machine-generated stdafx.c

Author:

    Cliff Van Dyke (cliffv) 23-May-2001

--*/

#include "pch.hxx"

#pragma warning ( disable : 4100 ) // : unreferenced formal parameter
#pragma warning ( disable : 4189 ) // : local variable is initialized but not referenced
#pragma warning ( disable : 4505 ) // : unreferenced local function has been removed

#include "stdafx.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\stdafx.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    stdafx.h

Abstract:

    standard com include file

Author:

    Xiaoxi Tan (xtan) 11-May-2001

--*/

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__E58F938B_4BAB_4FC1_BC5C_60D1A67E6C7E__INCLUDED_)
#define AFX_STDAFX_H__E58F938B_4BAB_4FC1_BC5C_60D1A67E6C7E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT 1
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E58F938B_4BAB_4FC1_BC5C_60D1A67E6C7E__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\util.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    util.h

Abstract:

    Definitions of Utility routines

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/


#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////////////
//
// Macros
//
/////////////////////////////////////////////////////////////////////////////

//
// Macros for locking the global resource
//
#define AzpLockResourceExclusive( _Resource ) \
    SafeAcquireResourceExclusive( _Resource, TRUE )

#define AzpIsLockedExclusive( _Resource ) \
    (SafeNumberOfActive( _Resource ) < 0 )

#define AzpLockResourceShared( _Resource ) \
    SafeAcquireResourceShared( _Resource, TRUE )

#define AzpLockResourceSharedToExclusive( _Resource ) \
    SafeConvertSharedToExclusive( _Resource )

#define AzpLockResourceExclusiveToShared( _Resource ) \
    SafeConvertExclusiveToShared( _Resource )

#define AzpIsLockedShared( _Resource ) \
    (SafeNumberOfActive( _Resource ) != 0 )

#define AzpUnlockResource( _Resource ) \
    SafeReleaseResource( _Resource )

//
// Macros for safe critsect
//
#define AzpIsCritsectLocked( _CritSect ) \
    ( SafeCritsecLockCount( _CritSect ) != -1L)


/////////////////////////////////////////////////////////////////////////////
//
// Structure definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// Generic counted string.
//  Can't use UNICODE_STRING since that is limited to 32K characters.
//
typedef struct _AZP_STRING {

    //
    // Pointer to the string
    //
    LPWSTR String;

    //
    // Size of the string in bytes (including trailing zero)
    //

    ULONG StringSize;

    //
    // String is a binary SID
    //

    BOOL IsSid;

} AZP_STRING, *PAZP_STRING;

//
// Generic expandable array of pointers
//
typedef struct _AZP_PTR_ARRAY {

    //
    // Pointer to allocated array of pointers
    //

    PVOID *Array;

    //
    // Number of elements actually used in array
    //

    ULONG UsedCount;

    //
    // Number of elemets allocated in the array
    //

    ULONG AllocatedCount;
#define AZP_PTR_ARRAY_INCREMENT 4   // Amount to grow the array by

} AZP_PTR_ARRAY, *PAZP_PTR_ARRAY;


/////////////////////////////////////////////////////////////////////////////
//
// Global definitions
//
/////////////////////////////////////////////////////////////////////////////

extern LIST_ENTRY AzGlAllocatedBlocks;
extern SAFE_CRITICAL_SECTION AzGlAllocatorCritSect;
extern PSID AzGlCreatorOwnerSid;
extern PSID AzGlCreatorGroupSid;
extern PSID AzGlWorldSid;
extern ULONG AzGlWorldSidSize;


/////////////////////////////////////////////////////////////////////////////
//
// Procedure definitions
//
/////////////////////////////////////////////////////////////////////////////

PVOID
AzpAllocateHeap(
    IN SIZE_T Size,
    IN LPSTR pDescr OPTIONAL
    );

PVOID
AzpAllocateHeapSafe(
     IN SIZE_T Size
     );

VOID
AzpFreeHeap(
    IN PVOID Buffer
    );

PVOID
AzpAvlAllocate(
    IN PRTL_GENERIC_TABLE Table,
    IN CLONG ByteSize
    );

VOID
AzpAvlFree(
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    );

VOID
AzpInitString(
    OUT PAZP_STRING AzpString,
    IN LPCWSTR String OPTIONAL
    );

DWORD
AzpDuplicateString(
    OUT PAZP_STRING AzpOutString,
    IN PAZP_STRING AzpInString
    );

DWORD
AzpCaptureString(
    OUT PAZP_STRING AzpString,
    IN LPCWSTR String,
    IN ULONG MaximumLength,
    IN BOOLEAN NullOk
    );

VOID
AzpInitSid(
    OUT PAZP_STRING AzpString,
    IN PSID Sid
    );

DWORD
AzpCaptureSid(
    OUT PAZP_STRING AzpString,
    IN PSID Sid
    );

DWORD
AzpCaptureLong(
    IN PVOID PropertyValue,
    OUT PLONG UlongValue
    );

BOOL
AzpEqualStrings(
    IN PAZP_STRING AzpString1,
    IN PAZP_STRING AzpString2
    );

LONG
AzpCompareSidString(
    IN PAZP_STRING AzpString1,
    IN PAZP_STRING AzpString2
    );

LONG
AzpCompareSid(
    IN PSID Sid1,
    IN PSID Sid2
    );

LONG
AzpCompareStrings(
    IN PAZP_STRING AzpString1,
    IN PAZP_STRING AzpString2
    );

LONG
AzpCompareDeltaEntries(
    const void *DeltaEntry1,
    const void *DeltaEntry2
    );

VOID
AzpSwapStrings(
    IN OUT PAZP_STRING AzpString1,
    IN OUT PAZP_STRING AzpString2
    );

VOID
AzpFreeString(
    IN PAZP_STRING AzpString
    );

BOOLEAN
AzpBsearchPtr (
    IN PAZP_PTR_ARRAY AzpPtrArray,
    IN PVOID Key,
    IN LONG (*Compare)(const void *, const void *),
    OUT PULONG InsertionPoint OPTIONAL
    );

#define AZP_ADD_ENDOFLIST 0xFFFFFFFF
DWORD
AzpAddPtr(
    IN PAZP_PTR_ARRAY AzpPtrArray,
    IN PVOID Pointer,
    IN ULONG Index
    );

VOID
AzpRemovePtrByIndex(
    IN PAZP_PTR_ARRAY AzpPtrArray,
    IN ULONG Index
    );

VOID
AzpRemovePtrByPtr(
    IN PAZP_PTR_ARRAY AzpPtrArray,
    IN PVOID Pointer
    );

PVOID
AzpGetStringProperty(
    IN PAZP_STRING AzpString
    );

PVOID
AzpGetUlongProperty(
    IN ULONG UlongValue
    );

BOOLEAN
AzpTimeHasElapsed(
    IN PLARGE_INTEGER StartTime,
    IN DWORD Timeout
    );

BOOL
AzDllInitialize(VOID);

BOOL
AzDllUnInitialize(VOID);

DWORD
AzpHresultToWinStatus(
    HRESULT hr
    );

DWORD
AzpSafeArrayPointerFromVariant(
    IN VARIANT* Variant,
    IN BOOLEAN NullOk,
    OUT SAFEARRAY **retSafeArray
    );

DWORD
AzpGetCurrentToken(
    OUT PHANDLE hToken
    );

DWORD
AzpChangeSinglePrivilege(
    IN DWORD PrivilegeValue,
    IN HANDLE hToken,
    IN PTOKEN_PRIVILEGES NewPrivilegeState,
    OUT PTOKEN_PRIVILEGES OldPrivilegeState OPTIONAL
    );

DWORD
AzpConvertAbsoluteSDToSelfRelative(
    IN PSECURITY_DESCRIPTOR pAbsoluteSd,
    OUT PSECURITY_DESCRIPTOR *ppSelfRelativeSd
    );

//
// This routine sets our default common ldap binding options
//

DWORD
AzpADSetDefaultLdapOptions (
    IN OUT PLDAP pHandle,
    IN PCWSTR pDomainName OPTIONAL
    );

//
// This routine convert JScript style array object to
// safearrays that our functions use.
//

HRESULT
AzpGetSafearrayFromArrayObject (
    IN  VARIANT     varSAorObj,
    OUT SAFEARRAY** ppsaData
    );

//
// This routine returns the sequence number for an application object
// to check the validity of COM handles after the application has been
// closed

DWORD
AzpRetrieveApplicationSequenceNumber(
    IN AZ_HANDLE AzHandle
    );

/////////////////////////////////////////////////////////////////////////////
//
// Debugging Support
//
/////////////////////////////////////////////////////////////////////////////

#if DBG
#define AZROLESDBG 1
#endif // DBG

#ifdef AZROLESDBG
#define AzPrint(_x_) AzpPrintRoutine _x_

VOID
AzpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR FORMATSTRING,              // PRINTF()-STYLE FORMAT STRING.
    ...                                 // OTHER ARGUMENTS ARE POSSIBLE.
    );

VOID
AzpDumpGuid(
    IN DWORD DebugFlag,
    IN GUID *Guid
    );

VOID
AzpDumpGoRef(
    IN LPSTR Text,
    IN struct _GENERIC_OBJECT *GenericObject
    );

//
// Values of DebugFlag
//  The values of this flag are organized into bytes:
//  The least significant byte are flags that one always wants on
//  The next byte are flags that provider a reasonable level of verbosity
//  The next byte are flags that correspond to levels from the 2nd byte but are more verbose
//  The most significant byte are flags that are generally very verbose
//

#define AZD_CRITICAL     0x00000001  // Debug most critical errors
#define AZD_INVPARM      0x00000002  // Invalid Parameter
#define AZD_PERSIST      0x00000100  // Persistence code
#define AZD_ACCESS       0x00000200  // Debug access check
#define AZD_SCRIPT       0x00000400  // Debug bizrule scripts
#define AZD_DISPATCH     0x00000800  // Debug IDispatch interface code
#define AZD_XML          0x00001000  // xml store
#define AZD_AD           0x00002000  // Debug LDAP provider
#define AZD_PERSIST_MORE 0x00010000  // Persistence code (verbose mode)
#define AZD_ACCESS_MORE  0x00020000  // Debug access check (verbose mode)
#define AZD_SCRIPT_MORE  0x00040000  // Debug bizrule scripts (verbose mode)

#define AZD_HANDLE       0x01000000  // Debug handle open/close
#define AZD_OBJLIST      0x02000000  // Object list linking
#define AZD_REF          0x04000000  // Debug object ref count
#define AZD_DOMREF       0x08000000  // Debug domain ref count

#define AZD_ALL          0xFFFFFFFF

//
// The order below defines the order in which locks must be acquired.
// Violating this order will result in asserts firing in debug builds.
//
// Do not change the order without first verifying thoroughly that the change is safe.
//

enum {
    SAFE_CLOSE_APPLICATION = 1,
    SAFE_CLIENT_CONTEXT,
    SAFE_PERSIST_LOCK,
    SAFE_GLOBAL_LOCK,
    SAFE_DOMAIN_LIST,
    SAFE_DOMAIN,
    SAFE_FREE_SCRIPT_LIST,
    SAFE_RUNNING_SCRIPT_LIST,
    SAFE_LOGFILE,
    SAFE_ALLOCATOR,
    SAFE_MAX_LOCK
};

//
// Globals
//

extern SAFE_CRITICAL_SECTION AzGlLogFileCritSect;
extern ULONG AzGlDbFlag;

#else
// Non debug version
#define AzPrint(_x_)
#define AzpDumpGuid(_x_, _y_)
#define AzpDumpGoRef(_x_, _y_)
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\xml.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    xml.cxx

Abstract:

    This file implements a xml policy store provider

Author:

    Xiaoxi Tan (xtan) June-2001

--*/

#include "pch.hxx"
#define AZD_COMPONENT     AZD_XML
#include <msxml2.h>
#include <aclapi.h>
#include "resource.h"
#include <shlwapi.h>
#include <lm.h>
#include <lmdfs.h>

#pragma warning ( push )
#pragma warning ( disable : 4127 ) // avoid warning in while(TRUE)

// defines
#define ARRAYLEN(a)                 (sizeof(a)/sizeof((a)[0]))
// az object tag defines in xml store
// note, they are case sensitive

#define AZ_XML_TAG_AZSTORE          L"AzAdminManager"
#define AZ_XML_TAG_APPLICATION      L"AzApplication"
#define AZ_XML_TAG_OPERATION        L"AzOperation"
#define AZ_XML_TAG_TASK             L"AzTask"
#define AZ_XML_TAG_GROUP            L"AzApplicationGroup"
#define AZ_XML_TAG_ROLE             L"AzRole"
#define AZ_XML_TAG_SCOPE            L"AzScope"

// az object data tag defines in xml store
#define AZ_XML_TAG_MEMBER           L"Member"
#define AZ_XML_TAG_NONMEMBER        L"NonMember"
#define AZ_XML_TAG_OPERATIONID      L"OperationID"
#define AZ_XML_TAG_BIZRULE          L"BizRule"
#define AZ_XML_TAG_BIZRULELANGUAGE  L"BizRuleLanguage"
#define AZ_XML_TAG_LDAPQUERY        L"LdapQuery"

// az link element defines
#define AZ_XML_TAG_LINK_OPERATION      L"OperationLink"
#define AZ_XML_TAG_LINK_TASK           L"TaskLink"
#define AZ_XML_TAG_LINK_APPMEMBER      L"AppMemberLink"
#define AZ_XML_TAG_LINK_APPNONMEMBER   L"AppNonMemberLink"

// az object attribute name defines in xml store
#define AZ_XML_TAG_ATTR_NAME             L"Name"
#define AZ_XML_TAG_ATTR_DESCRIPTION      L"Description"
#define AZ_XML_TAG_ATTR_GUID             L"Guid"
#define AZ_XML_TAG_ATTR_GROUPTYPE        L"GroupType"
#define AZ_XML_TAG_ATTR_TIMEOUT          L"DomainTimeout"
#define AZ_XML_TAG_ATTR_APPCLSID         L"ApplicationCLSID"
#define AZ_XML_TAG_ATTR_APPVERSION       L"ApplicationVersion"
#define AZ_XML_TAG_ATTR_BIZRULEIP        L"BizRuleImportedPath"
#define AZ_XML_TAG_ATTR_ROLEDEFINITION   L"RoleDefinition"
#define AZ_XML_TAG_ATTR_MAXSCRIPTS       L"MaxScripts"
#define AZ_XML_TAG_ATTR_SCRIPTTIMEOUT    L"ScriptTimeout"
#define AZ_XML_TAG_ATTR_AUDITS           L"Audits"
#define AZ_XML_TAG_ATTR_APPLICATIONDATA  L"ApplicationData"
#define AZ_XML_TAG_ATTR_MAJOR_VERSION    L"MajorVersion"
#define AZ_XML_TAG_ATTR_MINOR_VERSION    L"MinorVersion"

// az group type values
#define AZ_XML_VAL_GROUPTYPE_LDAPQUERY   L"LdapQuery"
#define AZ_XML_VAL_GROUPTYPE_BASIC       L"Basic"
#define AZ_XML_VAL_TRUE                  L"True"
#define AZ_XML_VAL_FALSE                 L"False"

// xpath defines
#define AZ_XML_SELECTION_LANGUAGE    L"SelectionLanguage"
#define AZ_XML_XPATH                 L"XPath"

//globals
WCHAR const * const g_pwszAzTrue=AZ_XML_VAL_TRUE;
WCHAR const * const g_pwszAzFalse=AZ_XML_VAL_FALSE;
WCHAR const * const g_pwszBasicGroup=AZ_XML_VAL_GROUPTYPE_BASIC;
WCHAR const * const g_pwszLdapGroup=AZ_XML_VAL_GROUPTYPE_LDAPQUERY;
PAZPE_AZROLES_INFO XmlAzrolesInfo;

//
// common XML parsing errors. Currently, we map all XML parsing errors
// to ERROR_BAD_FORMAT. If we decide to map different types of errors to
// different system error code, then these errors are roughly grouped together
// in that way. Please see myXMLErrorToHresult to real implemenation detail.
//

//
// The following errors are more closely tied to syntax (format) errors:
//

#define XML_E_MISSINGEQUALS             0xC00CE501  // Missing equals sign between attribute and attribute value.
#define XML_E_MISSINGQUOTE              0xC00CE502  // A string literal was expected, but no opening quote character was found.
#define XML_E_COMMENTSYNTAX             0xC00CE503  // Incorrect syntax was used in a comment.
#define XML_E_XMLDECLSYNTAX             0xC00CE507  // Invalid syntax for an XML declaration.
#define XML_E_MISSINGWHITESPACE         0xC00CE509  // Required white space was missing.
#define XML_E_EXPECTINGTAGEND           0xC00CE50A  // The character '>' was expected.
#define XML_E_BADCHARINDTD              0xC00CE50B  // Invalid character found in document type definition (DTD).
#define XML_E_MISSINGSEMICOLON          0xC00CE50D  // A semicolon character was expected.
#define XML_E_UNBALANCEDPAREN           0xC00CE50F  // Unbalanced parentheses.
#define XML_E_EXPECTINGOPENBRACKET      0xC00CE510  // An opening '[' character was expected.
#define XML_E_BADENDCONDSECT            0xC00CE511  // Invalid syntax in a conditional section.
#define XML_E_UNEXPECTED_WHITESPACE     0xC00CE513  // White space is not allowed at this location.
#define XML_E_INCOMPLETE_ENCODING       0xC00CE514  // End of file reached in invalid state for current encoding.
#define XML_E_BADCHARINMIXEDMODEL       0xC00CE515  // Mixed content model cannot contain this character.
#define XML_E_MISSING_STAR              0xC00CE516  // Mixed content model must be defined as zero or more('*').
#define XML_E_MISSING_PAREN             0xC00CE518  // Missing parenthesis.
#define XML_E_PIDECLSYNTAX              0xC00CE51A  // Invalid syntax in processing instruction declaration.
#define XML_E_EXPECTINGCLOSEQUOTE       0xC00CE51B  // A single or double closing quote character (\' or \") is missing.
#define XML_E_MULTIPLE_COLONS           0xC00CE51C  // Multiple colons are not allowed in a name.
#define XML_E_WHITESPACEORQUESTIONMARK  0xC00CE520  // Expecting white space or '?'.
#define XML_E_UNEXPECTEDENDTAG          0xC00CE552  // End tag was not expected at this location.
#define XML_E_UNCLOSEDTAG               0xC00CE553  // The following tags were not closed: %1.
#define XML_E_DUPLICATEATTRIBUTE        0xC00CE554  // Duplicate attribute.
#define XML_E_MULTIPLEROOTS             0xC00CE555  // Only one top level element is allowed in an XML document.
#define XML_E_INVALIDATROOTLEVEL        0xC00CE556  // Invalid at the top level of the document.
#define XML_E_BADXMLDECL                0xC00CE557  // Invalid XML declaration.
#define XML_E_MISSINGROOT               0xC00CE558  // XML document must have a top level element.
#define XML_E_UNEXPECTEDEOF             0xC00CE559  // Unexpected end of file.
#define XML_E_BADPEREFINSUBSET          0xC00CE55A  // Parameter entities cannot be used inside markup declarations in an internal subset.
#define XML_E_PE_NESTING                0xC00CE55B  // The replacement text for a parameter entity must be properly nested with parenthesized groups.
#define XML_E_INVALID_CDATACLOSINGTAG   0xC00CE55C  // The literal string ']]>' is not allowed in element content.
#define XML_E_UNCLOSEDPI                0xC00CE55D  // Processing instruction was not closed.
#define XML_E_UNCLOSEDSTARTTAG          0xC00CE55E  // Element was not closed.
#define XML_E_UNCLOSEDENDTAG            0xC00CE55F  // End element was missing the character '>'.
#define XML_E_UNCLOSEDSTRING            0xC00CE560  // A string literal was not closed.
#define XML_E_UNCLOSEDCOMMENT           0xC00CE561  // A comment was not closed.
#define XML_E_UNCLOSEDDECL              0xC00CE562  // A declaration was not closed.
#define XML_E_UNCLOSEDMARKUPDECL        0xC00CE563  // A markup declaration was not closed.
#define XML_E_UNCLOSEDCDATA             0xC00CE564  // A CDATA section was not closed.
#define XML_E_BADDECLNAME               0xC00CE565  // Declaration has an invalid name.
#define XML_E_BADELEMENTINDTD           0xC00CE567  // An XML element is not allowed inside a DTD.
#define XML_E_RESERVEDNAMESPACE         0xC00CE568  // The namespace prefix is not allowed to start with the reserved string "xml".
#define XML_E_EXPECTING_VERSION         0xC00CE569  // The 'version' attribute is required at this location.
#define XML_E_EXPECTING_ENCODING        0xC00CE56A  // The 'encoding' attribute is required at this location.
#define XML_E_EXPECTING_NAME            0xC00CE56B  // At least one name is required at this location.
#define XML_E_UNEXPECTED_ATTRIBUTE      0xC00CE56C  // The specified attribute was not expected at this location. The attribute may be case sensitive.
#define XML_E_ENDTAGMISMATCH            0xC00CE56D  // End tag '%2' does not match the start tag '%1'.
#define XML_E_EXPECTING_NDATA           0xC00CE570  // NDATA keyword is missing.
#define XML_E_INVALID_TYPE              0xC00CE572  // Invalid type defined in ATTLIST.
#define XML_E_INVALIDXMLSPACE           0xC00CE573  // XML space attribute has invalid value. Must specify 'default' or 'preserve'.
#define XML_E_MULTI_ATTR_VALUE          0xC00CE574  // Multiple names found in attribute value when only one was expected.
#define XML_E_INVALID_PRESENCE          0xC00CE575  // Invalid ATTDEF declaration. Expected #REQUIRED, #IMPLIED or #FIXED.
#define XML_E_BADXMLCASE                0xC00CE576  // The name 'xml' is reserved and must be lowercase.
#define XML_E_CONDSECTINSUBSET          0xC00CE577  // Conditional sections are not allowed in an internal subset.
#define XML_E_INVALID_STANDALONE        0xC00CE579  // The standalone attribute must have the value 'yes' or 'no'.
#define XML_E_UNEXPECTED_STANDALONE     0xC00CE57A  // The standalone attribute cannot be used in external entities.
#define XML_E_DTDELEMENT_OUTSIDE_DTD    0xC00CE580  // Cannot have a DTD declaration outside of a DTD.
#define XML_E_DUPLICATEDOCTYPE          0xC00CE581  // Cannot have multiple DOCTYPE declarations.
#define XML_E_CDATAINVALID              0xC00CE578  // CDATA is not allowed in a DTD.
#define XML_E_DOCTYPE_IN_DTD            0xC00CE57B  // Cannot have a DOCTYPE declaration in a DTD.
#define XML_E_DOCTYPE_OUTSIDE_PROLOG    0xC00CE57E  // Cannot have a DOCTYPE declaration outside of a prolog.

//
// The following errors are more closely tied to invalid data errors
// (could consider using ERROR_INVALID_DATA)
//

#define XML_E_BADCHARDATA               0xC00CE508  // An invalid character was found in text content.
#define XML_E_BADCHARINENTREF           0xC00CE50E  // An invalid character was found inside an entity reference.
#define XML_E_BADCHARINDECL             0xC00CE50C  // An invalid character was found inside a DTD declaration.
#define XML_E_BADCHARINMODEL            0xC00CE517  // Invalid character in content model.
#define XML_E_BADCHARINENUMERATION      0xC00CE519  // Invalid character found in ATTLIST enumeration.
#define XML_E_INVALID_DECIMAL           0xC00CE51D  // Invalid character for decimal digit.
#define XML_E_INVALID_HEXIDECIMAL       0xC00CE51E  // Invalid character for hexadecimal digit.
#define XML_E_BADSTARTNAMECHAR          0xC00CE504  // A name was started with an invalid character.
#define XML_E_BADNAMECHAR               0xC00CE505  // A name contained an invalid character.
#define XML_E_BADCHARINSTRING           0xC00CE506  // A string literal contained an invalid character.
#define XML_E_INVALID_UNICODE           0xC00CE51F  // Invalid Unicode character value for this platform.
#define XML_E_BADEXTERNALID             0xC00CE566  // External ID is invalid.
#define XML_E_INVALID_MODEL             0xC00CE571  // Content model is invalid.
#define XML_E_MISSING_ENTITY            0xC00CE57C  // Reference to undefined entity.
#define XML_E_ENTITYREF_INNAME          0xC00CE57D  // Entity reference is resolved to an invalid name character.
#define XML_E_INVALID_VERSION           0xC00CE57F  // Invalid version number.

//
// The following errors are more or less tied to not-supported type of errors
// (could consider using ERROR_NOT_SUPPORTED)
//

#define XML_E_INVALIDSWITCH             0xC00CE56F  // Switch from current encoding to specified encoding not supported.
#define XML_E_INVALIDENCODING           0xC00CE56E  // System does not support the specified encoding.

//
// The following errors are not mapped to any system error codes at this time.
//

#define XML_E_FORMATINDEX_BADINDEX      0xC00CE306  // The value passed in to formatIndex must be greater than 0.
#define XML_E_FORMATINDEX_BADFORMAT     0xC00CE307  // Invalid format string.
#define XML_E_EXPECTED_TOKEN            0xC00CE380  // Expected token %1 found %2.
#define XML_E_UNEXPECTED_TOKEN          0xC00CE381  // Unexpected token %1.
#define XML_E_INTERNALERROR             0xC00CE512  // Internal error.
#define XML_E_SUSPENDED                 0xC00CE550  // The parser is suspended.
#define XML_E_STOPPED                   0xC00CE551  // The parser is stopped.
#define XML_E_RESOURCE                  0xC00CE582  // Error processing resource '%1'.


// macro defines

//
// if object is created or dirty bit
//
#define ObjectIsDirty(_go, _dirtyBit) \
    (0x0 != (XmlAzrolesInfo->AzpeDirtyBits(_go) & (_dirtyBit)))

//
// _JumpIfErrorOrPressOn should be used in any routines that are called from
// application (through COM API) or from az core for update cache
// if it is from application, it should return error immediately.
// if it is from az core, it should press on the do the next process.
// The routine uses _JumpIfErrorOrPressOn should use _HandlePressOnError too
// Arguments:
// _hr - the current error code we check
// _hr2 - current press on error code. It should be init to S_OK
// _label - error jump label
// _lFlag - persist flag to indicate where it comes from
// _fPressOn - flag to indicate should presson on or not
// pszMsg - back trace message
//
#define _JumpIfErrorOrPressOn(_hr, _hr2, _label, _lFlag, _fPressOn, pszMsg) \
{ \
    if (AZPE_FLAGS_PERSIST_UPDATE_CACHE & (_lFlag)) \
    { \
        if (S_OK != _hr) \
        { \
            if (_fPressOn) \
            { \
                if (S_OK == _hr2) \
                { \
                    _hr2 = _hr; \
                } \
            } \
            else \
            { \
                _JumpError(_hr, _label, pszMsg); \
            } \
            _PrintError(_hr, pszMsg); \
        } \
    } \
    else \
    { \
        _JumpIfError(_hr, _label, pszMsg); \
    } \
}

//
// _HandlePressOnError should be used in any routines call
// _JumpIfErrorOrPressOn. It is the replacement of regular
// hr = S_OK at the end of each sub-routine
//
#define _HandlePressOnError(_hr, _hr2) \
{ \
    if (S_OK != _hr2) \
    { \
        _hr = _hr2; \
    } \
    else \
    { \
        _hr = S_OK; \
    } \
}

// xml storage

// Each provider returns a single PVOID from *PersistOpen.
// That PVOID is a pointer to whatever context the provider needs to maintain a
// description of the local storage.
// The structure below is that context for the xml store provider.

typedef struct _AZP_XML_CONTEXT
{
    // interface pointer to xml document object
    IXMLDOMDocument2  *pDoc;

    // Policy URL
    LPCWSTR pwszPolicyUrl;

    // Handle to AzAuthorizationStore
    AZPE_OBJECT_HANDLE hAzAuthorizationStore;

    //
    // TRUE if the file is writable
    LONG IsWritable;

    // TRUE if the current user has SE_SECURITY_PRIVILEGE on the server containing the store.
    BOOLEAN HasSecurityPrivilege;
    
    FILETIME FTLastWrite;

} AZP_XML_CONTEXT, *PAZP_XML_CONTEXT;

//
// data structure for object property/attribute
//
typedef struct _AZ_PROP_ENTRY {
    ULONG             lPropId;     //attribute/property property ID
    ENUM_AZ_DATATYPE  lDataType;   //data type
    BOOL              fSingle;     //single occurence, flag to determine call on AddPropertyItem
    ULONG             lDirtyBit;   //property dirty bit
    WCHAR const      *pwszTag;     //tag in xml
} AZ_PROP_ENTRY;

typedef struct _AZ_CHILD_ENTRY {
    WCHAR const      *pwszChildTag;     //child object tag
    ULONG             ChildType;        //child object type
} AZ_CHILD_ENTRY;

typedef struct _AZ_SUBMIT_LOAD_ENTRY {
    WCHAR const           *pwszTag;       // object node tag
    WCHAR const * const   *rgpwszLkTag;   // for linked item deletion
    AZ_PROP_ENTRY         *rgpAttrs;      // array of attr entry data
    AZ_PROP_ENTRY         *rgpEles;       // array of element entries
    AZ_CHILD_ENTRY        *rgpChildren;   // array of children
} AZ_SUBMIT_LOAD_ENTRY;

//
// Procedures implemented by the xml provider
//

DWORD
WINAPI
XMLPersistOpen(
    IN LPCWSTR PolicyUrl,
    IN AZPE_OBJECT_HANDLE pAzAuthorizationStore,
    IN ULONG Flags,
    IN BOOL CreatePolicy,
    OUT PAZPE_PERSIST_CONTEXT PersistContext,
    OUT LPWSTR *pwszTargetMachine
    );

DWORD
WINAPI
XMLPersistUpdateCache(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN ULONG lPersistFlags,
    OUT ULONG* pulUpdateFlag
    );

VOID
WINAPI
XMLPersistClose(
    IN AZPE_PERSIST_CONTEXT PersistContext
    );

DWORD
WINAPI
XMLPersistSubmit(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG Flags,
    IN BOOLEAN DeleteMe
    );

DWORD
WINAPI
XMLPersistRefresh(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags
    );


//
// Define a provider info telling the core our interface
//
AZPE_PROVIDER_INFO XmlProviderInfo = {
    AZPE_PROVIDER_INFO_VERSION_1,
    AZ_XML_PROVIDER_NAME,

    XMLPersistOpen,
    XMLPersistUpdateCache,
    XMLPersistClose,
    XMLPersistSubmit,
    XMLPersistRefresh
};


//
// following data entries or tables handling all object submit
//

//
// authorization store entry
//
AZ_PROP_ENTRY g_AdAttrs[] = {
/*
{lPropId,                             lDataType,    fSingle, lDirtyBit,                            pwszTag},
*/
{AZ_PROP_AZSTORE_DOMAIN_TIMEOUT,        ENUM_AZ_LONG, TRUE,    AZ_DIRTY_AZSTORE_DOMAIN_TIMEOUT,        AZ_XML_TAG_ATTR_TIMEOUT},
{AZ_PROP_AZSTORE_SCRIPT_ENGINE_TIMEOUT, ENUM_AZ_LONG, TRUE,    AZ_DIRTY_AZSTORE_SCRIPT_ENGINE_TIMEOUT, AZ_XML_TAG_ATTR_SCRIPTTIMEOUT},
{AZ_PROP_AZSTORE_MAX_SCRIPT_ENGINES,    ENUM_AZ_LONG, TRUE,    AZ_DIRTY_AZSTORE_MAX_SCRIPT_ENGINES,    AZ_XML_TAG_ATTR_MAXSCRIPTS},
{AZ_PROP_GENERATE_AUDITS,             ENUM_AZ_BOOL, TRUE,    AZ_DIRTY_GENERATE_AUDITS,             AZ_XML_TAG_ATTR_AUDITS},
{AZ_PROP_APPLICATION_DATA,            ENUM_AZ_BSTR, TRUE,    AZ_DIRTY_APPLICATION_DATA,            AZ_XML_TAG_ATTR_APPLICATIONDATA},
{AZ_PROP_AZSTORE_MAJOR_VERSION,         ENUM_AZ_LONG, TRUE,    AZ_DIRTY_AZSTORE_MAJOR_VERSION,         AZ_XML_TAG_ATTR_MAJOR_VERSION},
{AZ_PROP_AZSTORE_MINOR_VERSION,         ENUM_AZ_LONG, TRUE,    AZ_DIRTY_AZSTORE_MINOR_VERSION,         AZ_XML_TAG_ATTR_MINOR_VERSION},
{0,                                   ENUM_AZ_LONG, FALSE,   0,                                    NULL}, //terminator entry
};
AZ_CHILD_ENTRY g_AdChild[] = {
/*
{pwszChildTag,                        ChildType},
*/
{AZ_XML_TAG_APPLICATION,              OBJECT_TYPE_APPLICATION},
{AZ_XML_TAG_GROUP,                    OBJECT_TYPE_GROUP},
{NULL,                                0}, //terminator entry
};

//
// application entry
//
AZ_PROP_ENTRY g_ApAttrs[] = {
/*
{lPropId,                                   lDataType,    fSingle, lDirtyBit,                                  pwszTag},
*/
{AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID, ENUM_AZ_BSTR, TRUE,    AZ_DIRTY_APPLICATION_AUTHZ_INTERFACE_CLSID, AZ_XML_TAG_ATTR_APPCLSID},
{AZ_PROP_APPLICATION_VERSION,               ENUM_AZ_BSTR, TRUE,    AZ_DIRTY_APPLICATION_VERSION,               AZ_XML_TAG_ATTR_APPVERSION},
{AZ_PROP_GENERATE_AUDITS,                   ENUM_AZ_BOOL, TRUE,    AZ_DIRTY_GENERATE_AUDITS,                   AZ_XML_TAG_ATTR_AUDITS},
{AZ_PROP_APPLICATION_DATA,                  ENUM_AZ_BSTR, TRUE,    AZ_DIRTY_APPLICATION_DATA,                  AZ_XML_TAG_ATTR_APPLICATIONDATA},
{0,                                         ENUM_AZ_BOOL, FALSE,   0,                                          NULL}, //terminator entry
};
AZ_CHILD_ENTRY g_ApChild[] = {
/*
{pwszChildTag,                        ChildType},
*/
{AZ_XML_TAG_OPERATION,                OBJECT_TYPE_OPERATION},
{AZ_XML_TAG_TASK,                     OBJECT_TYPE_TASK},
{AZ_XML_TAG_GROUP,                    OBJECT_TYPE_GROUP},
{AZ_XML_TAG_SCOPE,                    OBJECT_TYPE_SCOPE},
{AZ_XML_TAG_ROLE,                     OBJECT_TYPE_ROLE},
{NULL,                                0}, //terminator entry
};

//
// operation entry
//
WCHAR const * const g_OpLkTags[] = {
    AZ_XML_TAG_LINK_OPERATION,
    NULL,
};

AZ_PROP_ENTRY g_OpAttrs[] = {
/*
{lPropId,              lDataType,    fSingle, lDirtyBit,             pwszTag},
*/
{AZ_PROP_APPLICATION_DATA, ENUM_AZ_BSTR, TRUE,    AZ_DIRTY_APPLICATION_DATA, AZ_XML_TAG_ATTR_APPLICATIONDATA},
{0,                        ENUM_AZ_LONG, FALSE,   0,                         NULL}, //terminator entry
};
AZ_PROP_ENTRY g_OpEles[] = {
/*
{lPropId,              lDataType,    fSingle, lDirtyBit,             pwszTag},
*/
{AZ_PROP_OPERATION_ID,     ENUM_AZ_LONG, TRUE,    AZ_DIRTY_OPERATION_ID,     AZ_XML_TAG_OPERATIONID},
{0,                        ENUM_AZ_LONG, FALSE,   0,                         NULL}, //terminator entry
};

//
// task entry
//
WCHAR const * const g_TkLkTags[] = {
    AZ_XML_TAG_LINK_TASK,
    NULL,
};
AZ_PROP_ENTRY g_TkAttrs[] = {
/*
{lPropId,                            lDataType,    fSingle, lDirtyBit,                           pwszTag},
*/
{AZ_PROP_TASK_BIZRULE_IMPORTED_PATH, ENUM_AZ_BSTR, TRUE,    AZ_DIRTY_TASK_BIZRULE_IMPORTED_PATH, AZ_XML_TAG_ATTR_BIZRULEIP},
{AZ_PROP_TASK_IS_ROLE_DEFINITION,    ENUM_AZ_BOOL, TRUE,    AZ_DIRTY_TASK_IS_ROLE_DEFINITION,    AZ_XML_TAG_ATTR_ROLEDEFINITION},
{AZ_PROP_APPLICATION_DATA,           ENUM_AZ_BSTR, TRUE,    AZ_DIRTY_APPLICATION_DATA,           AZ_XML_TAG_ATTR_APPLICATIONDATA},
{0,                                  ENUM_AZ_LONG, FALSE,   0,                                   NULL}, //terminator entry
};
AZ_PROP_ENTRY g_TkEles[] = {
/*
{lPropId,                       lDataType,          fSingle, lDirtyBit,                      pwszTag},
*/
{AZ_PROP_TASK_BIZRULE_LANGUAGE, ENUM_AZ_BSTR,       TRUE,    AZ_DIRTY_TASK_BIZRULE_LANGUAGE, AZ_XML_TAG_BIZRULELANGUAGE},
{AZ_PROP_TASK_BIZRULE,          ENUM_AZ_BSTR,       TRUE,    AZ_DIRTY_TASK_BIZRULE,          AZ_XML_TAG_BIZRULE},
{AZ_PROP_TASK_OPERATIONS,       ENUM_AZ_GUID_ARRAY, FALSE,   AZ_DIRTY_TASK_OPERATIONS,       AZ_XML_TAG_LINK_OPERATION},
{AZ_PROP_TASK_TASKS,            ENUM_AZ_GUID_ARRAY, FALSE,   AZ_DIRTY_TASK_TASKS,            AZ_XML_TAG_LINK_TASK},
{0,                             ENUM_AZ_LONG,       FALSE,   0,                              NULL}, //terminator entry
};

//
// group entry
//
WCHAR const * const g_GpLkTags[] = {
    AZ_XML_TAG_LINK_APPMEMBER,
    AZ_XML_TAG_LINK_APPNONMEMBER,
    NULL,
};
AZ_PROP_ENTRY g_GpAttrs[] = {
/*
{lPropId,            lDataType,          fSingle, lDirtyBit,           pwszTag},
*/
{AZ_PROP_GROUP_TYPE, ENUM_AZ_GROUP_TYPE, TRUE,    AZ_DIRTY_GROUP_TYPE, AZ_XML_TAG_ATTR_GROUPTYPE},
{0,                  ENUM_AZ_LONG,       FALSE,   0,                   NULL}, //terminator entry
};
AZ_PROP_ENTRY g_GpEles[] = {
/*
{lPropId,                       lDataType,          fSingle, lDirtyBit,                      pwszTag},
*/
{AZ_PROP_GROUP_LDAP_QUERY,      ENUM_AZ_BSTR,       TRUE,    AZ_DIRTY_GROUP_LDAP_QUERY,      AZ_XML_TAG_LDAPQUERY},
{AZ_PROP_GROUP_MEMBERS,         ENUM_AZ_SID_ARRAY,  FALSE,   AZ_DIRTY_GROUP_MEMBERS,         AZ_XML_TAG_MEMBER},
{AZ_PROP_GROUP_NON_MEMBERS,     ENUM_AZ_SID_ARRAY,  FALSE,   AZ_DIRTY_GROUP_NON_MEMBERS,     AZ_XML_TAG_NONMEMBER},
{AZ_PROP_GROUP_APP_MEMBERS,     ENUM_AZ_GUID_ARRAY, FALSE,   AZ_DIRTY_GROUP_APP_MEMBERS,     AZ_XML_TAG_LINK_APPMEMBER},
{AZ_PROP_GROUP_APP_NON_MEMBERS, ENUM_AZ_GUID_ARRAY, FALSE,   AZ_DIRTY_GROUP_APP_NON_MEMBERS, AZ_XML_TAG_LINK_APPNONMEMBER},
{0,                             ENUM_AZ_LONG,       FALSE,   0,                              NULL}, //terminator entry
};

//
// scope entry
//
AZ_PROP_ENTRY  g_SpAttrs[] = {
/*
{lPropId,              lDataType,    fSingle, lDirtyBit,             pwszTag},
*/
{AZ_PROP_APPLICATION_DATA, ENUM_AZ_BSTR, TRUE,  AZ_DIRTY_APPLICATION_DATA, AZ_XML_TAG_ATTR_APPLICATIONDATA},
{0,                        ENUM_AZ_LONG, FALSE, 0,                         NULL}, //terminator entry
};

AZ_CHILD_ENTRY g_SpChild[] = {
/*
{pwszChildTag,                        ChildType},
*/
{AZ_XML_TAG_TASK,                     OBJECT_TYPE_TASK},
{AZ_XML_TAG_GROUP,                    OBJECT_TYPE_GROUP},
{AZ_XML_TAG_ROLE,                     OBJECT_TYPE_ROLE},
{NULL,                                0}, //terminator entry
};

//
// role entry
//
AZ_PROP_ENTRY g_RlAttrs[] = {
/*
{lPropId,                       lDataType,          fSingle, lDirtyBit,                 pwszTag},
*/
{AZ_PROP_APPLICATION_DATA,      ENUM_AZ_BSTR,       TRUE,    AZ_DIRTY_APPLICATION_DATA, AZ_XML_TAG_ATTR_APPLICATIONDATA},
{0,                             ENUM_AZ_LONG,       FALSE,   0,                         NULL}, //terminator entry
};
AZ_PROP_ENTRY g_RlEles[] = {
/*
{lPropId,                       lDataType,          fSingle, lDirtyBit,                 pwszTag},
*/
{AZ_PROP_ROLE_APP_MEMBERS,      ENUM_AZ_GUID_ARRAY, FALSE,   AZ_DIRTY_ROLE_APP_MEMBERS, AZ_XML_TAG_LINK_APPMEMBER},
{AZ_PROP_ROLE_MEMBERS,          ENUM_AZ_SID_ARRAY,  FALSE,   AZ_DIRTY_ROLE_MEMBERS,     AZ_XML_TAG_MEMBER},
{AZ_PROP_ROLE_OPERATIONS,       ENUM_AZ_GUID_ARRAY, FALSE,   AZ_DIRTY_ROLE_OPERATIONS,  AZ_XML_TAG_LINK_OPERATION},
{AZ_PROP_ROLE_TASKS,            ENUM_AZ_GUID_ARRAY, FALSE,   AZ_DIRTY_ROLE_TASKS,       AZ_XML_TAG_LINK_TASK},
{0,                             ENUM_AZ_LONG,       FALSE,   0,                         NULL}, //terminator entry
};

//
// ***IMPORTANT***, keep the order of element the same as defined
// in OBJECT_TYPE_* (see genobj.h)
//
AZ_SUBMIT_LOAD_ENTRY   g_SubmitLoadTable[OBJECT_TYPE_COUNT] = {
/*
{pwszTag,                 rgpwszLkTag,rgpAttrs,   rgpEles,   rgpChild},
*/

{AZ_XML_TAG_AZSTORE, NULL,       g_AdAttrs,  NULL,      g_AdChild}, //OBJECT_TYPE_AZAUTHSTORE
{AZ_XML_TAG_APPLICATION,  NULL,       g_ApAttrs,  NULL,      g_ApChild}, //OBJECT_TYPE_APPLICATION
{AZ_XML_TAG_OPERATION,    g_OpLkTags, g_OpAttrs,  g_OpEles,  NULL},      //OBJECT_TYPE_OPERATION
{AZ_XML_TAG_TASK,         g_TkLkTags, g_TkAttrs,  g_TkEles,  NULL},      //OBJECT_TYPE_TASK
{AZ_XML_TAG_SCOPE,        NULL,       g_SpAttrs,  NULL,      g_SpChild}, //OBJECT_TYPE_SCOPE
{AZ_XML_TAG_GROUP,        g_GpLkTags, g_GpAttrs,  g_GpEles,  NULL},      //OBJECT_TYPE_GROUP
{AZ_XML_TAG_ROLE,         NULL,       g_RlAttrs,  g_RlEles,  NULL},      //OBJECT_TYPE_ROLE
};

//
// rights for users
//

#define AZ_POLICY_AZSTORE_MASK_XML        FILE_ALL_ACCESS
#define AZ_POLICY_READER_MASK_XML       FILE_GENERIC_READ
#define AZ_POLICY_ACE_FLAGS_XML         0x0

//
// User rights for XML policy admins
//

AZP_POLICY_USER_RIGHTS PolicyAdminsRights = {

    AZ_POLICY_AZSTORE_MASK_XML,
    AZ_POLICY_ACE_FLAGS_XML
};

PAZP_POLICY_USER_RIGHTS XMLPolicyAdminsRights[] = {

    &PolicyAdminsRights,
    NULL
};

//
// User rights for XML policy readers
//

AZP_POLICY_USER_RIGHTS PolicyReadersRights = {

    AZ_POLICY_READER_MASK_XML,
    AZ_POLICY_ACE_FLAGS_XML
};

PAZP_POLICY_USER_RIGHTS XMLPolicyReadersRights[] = {

    &PolicyReadersRights,
    NULL
};

//
// Rights for the SACL.
//
AZP_POLICY_USER_RIGHTS XMLSaclRights = {

    DELETE|WRITE_DAC|WRITE_OWNER|FILE_GENERIC_WRITE,
    0   // No Flags
};

//
// the following functions are copied from UI (shell) team
// with minor changes
//
BOOL
IsDfsPath(
    IN  PWSTR pszPath,
    OUT PWSTR pszServer,
    IN  UINT   cchServer
    )
/*++
Routine Description:

    This function detects if a UNC file path is a DFS path and if so,
    the real server name for the DFS path is returned in the pszServer buffer.

Arguments:

    pszPath     - a UNC file path to detect

    pszServer   - buffer to receive the real server name

    cchServer   - length (tchars) of the pszServer buffer

--*/
{
    BOOL bIsDfs = FALSE;
    PWSTR pszTemp=NULL;
    PDFS_INFO_3 pDI3 = NULL;
    WCHAR szServer[MAX_PATH];

    if (pszPath == NULL || !PathIsUNC(pszPath))
        return FALSE;     // local machine

    //
    // allocate a temp buffer
    //
    pszTemp = (PWSTR)LocalAlloc(LPTR, (wcslen(pszPath)+1)*sizeof(TCHAR));

    if ( pszTemp == NULL ) {
        return FALSE;
    }

    wcscpy(pszTemp, pszPath);

    //
    // Check for DFS
    //
    for (;;)
    {
        DWORD dwErr;

        __try
        {
            // This is delay-loaded by the linker, so
            // must wrap with an exception handler.
            dwErr = NetDfsGetClientInfo(pszTemp,
                                        NULL,
                                        NULL,
                                        3,
                                        (LPBYTE*)&pDI3);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LocalFree(pszTemp);
            return FALSE;
        }

        if (NERR_Success == dwErr)
        {
            for (ULONG i = 0; i < pDI3->NumberOfStorages; i++)
            {
                if (DFS_STORAGE_STATE_ONLINE & pDI3->Storage[i].State)
                {
                    bIsDfs = TRUE;

                    szServer[0] = L'\\';
                    szServer[1] = L'\\';
                    wcsncpy(&szServer[2], pDI3->Storage[i].ServerName, ARRAYLEN(szServer)-2);

                    //
                    // If this server is active, quit looking
                    //
                    if (DFS_STORAGE_STATE_ACTIVE & pDI3->Storage[i].State)
                        break;
                }
            }
            break;
        }
        else if (NERR_DfsNoSuchVolume == dwErr)
        {
            //
            // If we're at the root, then we can't go any farther.
            //
            if (PathIsRoot(pszTemp))
                break;

            //
            // Remove the last path element and try again, if nothing is
            // removed, break, don't go in infinite loop
            //
            if (!PathRemoveFileSpec(pszTemp))
                break;
        }
        else
        {
            //
            // Some other error, bail
            //
            break;
        }
    }

    if (bIsDfs)
    {
        //
        // copy the server name to the output buffer
        //
        wcsncpy(pszServer, szServer, cchServer);

    }

    //
    // free the alloated buffer
    //
    if (NULL != pDI3)
        NetApiBufferFree(pDI3);

    LocalFree(pszTemp);

    return bIsDfs;
}


DWORD
_WNetGetConnection(
    IN PWSTR pszLocal,
    OUT PWSTR pszRemote,
    IN OUT LPDWORD pdwLen
    )
/*++
Routine Description:

    This function get an UNC path for a mapped netowrk path.
    It fails if the path is not a valid network path.

Arguments:

    pszLocal        - the local mapped drive letter

    pszRemote       - the mapped remote share name

    pdwLen          - the length of the buffer required

--*/
{
    DWORD dwErr = ERROR_PROC_NOT_FOUND;

    // This is the only function we call in mpr.dll, and it's delay-loaded
    // so wrap it with SEH.
    __try
    {
        dwErr = WNetGetConnection(pszLocal, pszRemote, pdwLen);
    }
    __finally
    {
    }

    return dwErr;
}

DWORD
myGetRemotePath(
    IN PCWSTR pszInName,
    OUT PWSTR *ppszOutName
    )
/*++
Routine Description:

    Return UNC version of a path that is mapped to a remote machine


Arguments:
    pszInName - initial path

    ppszOutName - UNC path returned, Must be freed by AzpFreeHeap

Return value:

--*/
{

    if(!pszInName || !ppszOutName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *ppszOutName = NULL;

    DWORD dwErr;
    WCHAR szLocalName[3];

    WCHAR szRemoteName[MAX_PATH];
    DWORD dwLen = ARRAYLEN(szRemoteName);
    szRemoteName[0] = L'\0';

    //
    // buffer to the drive letter only
    //
    szLocalName[0] = pszInName[0];
    szLocalName[1] = pszInName[1];
    szLocalName[2] = TEXT('\0');

    //
    // try to make the connection alive by accessing the remote share
    // but do not care error now (if it cannot connect, the next call will fail)
    //
    GetFileAttributes(pszInName);

    //
    // get connection for the drive letter
    //
    dwErr = _WNetGetConnection(szLocalName, szRemoteName, &dwLen);

    if (NO_ERROR == dwErr)
    {
        //
        // success, get the mapped path (local or remote)
        //
        dwLen = (DWORD)wcslen(szRemoteName);

    } else if ( ERROR_MORE_DATA != dwErr ) {
        //
        // other errors including ERROR_NOT_CONNECTED
        // return the error

        goto CleanUp;
    }

    //
    // if dwErr == ERROR_MORE_DATA, dwLen already has the correct value
    // Skip the drive letter and add the length of the rest of the path
    // (including NULL)
    //

    pszInName += 2;
    dwLen += (DWORD)wcslen(pszInName) + 1;

    //
    // We should never get incomplete paths, so we should always
    // see a backslash after the "X:".  If this isn't true, then
    // we should call GetFullPathName.
    //
    ASSERT(TEXT('\\') == *pszInName);

    //
    // Allocate the return buffer
    //
    *ppszOutName = (PWSTR)AzpAllocateHeap(dwLen * sizeof(WCHAR), "XMNAME" );
    if (!*ppszOutName)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanUp;
    }

    if (ERROR_MORE_DATA == dwErr)
    {
        //
        // Try again with the bigger buffer
        //
        dwErr = _WNetGetConnection(szLocalName, *ppszOutName, &dwLen);
    }
    else
    {
        //
        // WNetGetConnection succeeded from the first call. Copy the result
        //
        wcscpy(*ppszOutName, szRemoteName);
    }

    //
    // Copy the rest of the path
    //
    wcscat(*ppszOutName, pszInName);


CleanUp:

    if (NO_ERROR != dwErr && *ppszOutName)
    {
        AzpFreeHeap(*ppszOutName);
        *ppszOutName = NULL;
    }


    return (dwErr);
}


void
myGetVolumeInfo(
    IN PCWSTR pszPath,
    OUT PWSTR  pszVolume,
    IN ULONG   cchVolume
    )
/*++
Routine Description:

    This function queries the volume information for the given path

Arguments:

    pszPath     - a file path to detect

    pszVolume   - buffer to receive the volume name

    cchVolume   - length (tchars) of the output buffer

--*/
{
    if ( pszPath == NULL || pszVolume == NULL ) {
        return;
    }

    WCHAR szVolume[MAX_PATH+1];

    //
    // The path can be DFS or contain volume mount points, so start
    // with the full path and try GetVolumeInformation on successively
    // shorter paths until it succeeds or we run out of path.
    //
    // However, if it's a volume mount point, we're interested in the
    // the host folder's volume so back up one level to start.  The
    // child volume is handled separately (see AddMountedVolumePage).
    //

    wcsncpy(szVolume, pszPath, ARRAYLEN(szVolume));
    szVolume[MAX_PATH] = '\0';

    //
    // input volume name is always a XML file name
    //
    PathRemoveFileSpec(szVolume);

    for (;;)
    {
        PathAddBackslash(szVolume); // GetVolumeInformation likes a trailing '\'

        DWORD dwFlags = 0;
        if (GetVolumeInformation(szVolume,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &dwFlags,
                                 NULL,
                                 0))
        {
            break;
        }

        // Access denied implies that we've reached the deepest volume
        // in the path; we just can't get the flags.  It also implies
        // security, so assume persistent acls.
        if (ERROR_ACCESS_DENIED == GetLastError())
        {
            break;
        }

        // If we're at the root, then we can't go any farther.
        if (PathIsRoot(szVolume))
            break;

        // Remove the last path element and try again
        PathRemoveBackslash(szVolume);
        //if nothing is removed break instead of going in infinite loop
        if (!PathRemoveFileSpec(szVolume))
            break;
    }

    PathRemoveBackslash(szVolume);
    wcsncpy(pszVolume, szVolume, cchVolume);

}

DWORD
myXMLErrorToWin32 (
    IN LONG lErrCode
    )
/*++

Routine Description:

    This routine maps XML parsing error codes to system error codes.

Arguments:

    lErrCode - the XML parsing error to be translated.

Return Value:

    various win32 system error codes.

Note:

    (1) Currently, we map all errors related to parsing to ERROR_BAD_FORMAT.
    Other errors are not translated at all. However, this is a very coarse
    mapping and we might want to do a more fine-grained mapping at a
    later time.

    (2) All these XML_E_xxx are locally defined according to MSDN.
    Please see the definition of these constants for detail. Unfortunately I
    have to do that because these error codes are not available anyway I can find.

--*/
{
    switch (lErrCode)
    {

    //
    // the following errors match pretty well with ERROR_BAD_FORMAT
    //

    case XML_E_MISSINGEQUALS:
    case XML_E_MISSINGQUOTE:
    case XML_E_COMMENTSYNTAX:
    case XML_E_XMLDECLSYNTAX:
    case XML_E_MISSINGWHITESPACE:
    case XML_E_EXPECTINGTAGEND:
    case XML_E_BADCHARINDTD:
    case XML_E_MISSINGSEMICOLON:
    case XML_E_UNBALANCEDPAREN:
    case XML_E_EXPECTINGOPENBRACKET:
    case XML_E_BADENDCONDSECT:
    case XML_E_UNEXPECTED_WHITESPACE:
    case XML_E_INCOMPLETE_ENCODING:
    case XML_E_BADCHARINMIXEDMODEL:
    case XML_E_MISSING_STAR:
    case XML_E_MISSING_PAREN:
    case XML_E_PIDECLSYNTAX:
    case XML_E_EXPECTINGCLOSEQUOTE:
    case XML_E_MULTIPLE_COLONS:
    case XML_E_WHITESPACEORQUESTIONMARK:
    case XML_E_UNEXPECTEDENDTAG:
    case XML_E_UNCLOSEDTAG:
    case XML_E_DUPLICATEATTRIBUTE:
    case XML_E_MULTIPLEROOTS:
    case XML_E_INVALIDATROOTLEVEL:
    case XML_E_BADXMLDECL:
    case XML_E_MISSINGROOT:
    case XML_E_UNEXPECTEDEOF:
    case XML_E_BADPEREFINSUBSET:
    case XML_E_PE_NESTING:
    case XML_E_INVALID_CDATACLOSINGTAG:
    case XML_E_UNCLOSEDPI:
    case XML_E_UNCLOSEDSTARTTAG:
    case XML_E_UNCLOSEDENDTAG:
    case XML_E_UNCLOSEDSTRING:
    case XML_E_UNCLOSEDCOMMENT:
    case XML_E_UNCLOSEDDECL:
    case XML_E_UNCLOSEDMARKUPDECL:
    case XML_E_UNCLOSEDCDATA:
    case XML_E_BADDECLNAME:
    case XML_E_BADELEMENTINDTD:
    case XML_E_RESERVEDNAMESPACE:
    case XML_E_EXPECTING_VERSION:
    case XML_E_EXPECTING_ENCODING:
    case XML_E_EXPECTING_NAME:
    case XML_E_UNEXPECTED_ATTRIBUTE:
    case XML_E_ENDTAGMISMATCH:
    case XML_E_EXPECTING_NDATA:
    case XML_E_INVALID_TYPE:
    case XML_E_INVALIDXMLSPACE:
    case XML_E_MULTI_ATTR_VALUE:
    case XML_E_INVALID_PRESENCE:
    case XML_E_BADXMLCASE:
    case XML_E_CONDSECTINSUBSET:
    case XML_E_INVALID_STANDALONE:
    case XML_E_UNEXPECTED_STANDALONE:
    case XML_E_DTDELEMENT_OUTSIDE_DTD:
    case XML_E_DUPLICATEDOCTYPE:
    case XML_E_CDATAINVALID:
    case XML_E_DOCTYPE_IN_DTD:
    case XML_E_DOCTYPE_OUTSIDE_PROLOG:

    //
    // the following errors are more closely tied to ERROR_INVALID_DATA;
    //

    case XML_E_BADCHARDATA:
    case XML_E_BADCHARINENTREF:
    case XML_E_BADCHARINDECL:
    case XML_E_BADCHARINMODEL:
    case XML_E_BADCHARINENUMERATION:
    case XML_E_INVALID_DECIMAL:
    case XML_E_INVALID_HEXIDECIMAL:
    case XML_E_BADSTARTNAMECHAR:
    case XML_E_BADNAMECHAR:
    case XML_E_BADCHARINSTRING:
    case XML_E_INVALID_UNICODE:
    case XML_E_BADEXTERNALID:
    case XML_E_INVALID_MODEL:
    case XML_E_MISSING_ENTITY:
    case XML_E_ENTITYREF_INNAME:
    case XML_E_INVALID_VERSION:

    //
    // the following errors are more closely tied to ERROR_NOT_SUPPORTED;
    //

    case XML_E_INVALIDENCODING:
    case XML_E_INVALIDSWITCH:
        return ERROR_BAD_FORMAT;

    //
    // we don't translate the other errors:
    //

    case XML_E_FORMATINDEX_BADINDEX:
    case XML_E_FORMATINDEX_BADFORMAT:
    case XML_E_EXPECTED_TOKEN:
    case XML_E_UNEXPECTED_TOKEN:
    case XML_E_INTERNALERROR:
    case XML_E_SUSPENDED:
    case XML_E_STOPPED:
    case XML_E_RESOURCE:
    default:
        return lErrCode;
    }
}

HRESULT
myGetXmlError(
    IN  HRESULT          hrIn,
    IN  IXMLDOMDocument2 *pDoc,
    OUT OPTIONAL BSTR   *pbstrReason)
{
    HRESULT hr;
    HRESULT hrRet = hrIn;
    LONG  errorCode = 0;
    IXMLDOMParseError *pErr = NULL;

    hr = pDoc->get_parseError(&pErr);
    _JumpIfError(hr, error, "pDoc->get_parseError");
    AZASSERT(NULL != pErr);

    hr = pErr->get_errorCode(&errorCode);
    _JumpIfError(hr, error, "pErr->get_errorCode");

    if (NULL != pbstrReason && S_OK != errorCode)
    {
        hr = pErr->get_reason(pbstrReason);
        _JumpIfError(hr, error, "pErr->get_reason");
    }

    {
#ifdef DBG
    CComBSTR bstrText;
    pErr->get_reason(&bstrText);
    AzPrint((AZD_XML, "Loading XML file failed. Reason: %s", bstrText));
#endif
    }

    // take xml error code
    hrRet = AZ_HRESULT(myXMLErrorToWin32(errorCode));
error:
    if (NULL != pErr)
    {
        pErr->Release();
    }
    return hrRet;
}

#define _JumpIfXmlError(hr, phr, label, pDoc, pszMessage) \
{ \
    *(phr) = (hr); \
    if (S_OK != hr) \
    { \
        HRESULT  hrXml; \
        BSTR     bstrReason = NULL; \
        hrXml = myGetXmlError(hr, pDoc, &bstrReason); \
        if (NULL != bstrReason) \
        { \
            AzPrint((AZD_XML, "%s error occured: 0x%lx(%ws)\n", (pszMessage), (hrXml), (bstrReason))); \
        } \
        else \
        { \
            AzPrint((AZD_XML, "%s error occured: 0x%lx\n", (pszMessage), (hrXml))); \
        } \
        if (NULL != bstrReason) \
        { \
            SysFreeString(bstrReason); \
        } \
        *(phr) = hrXml; \
        goto label; \
    } \
}

HRESULT
myWszToBstr(
    IN WCHAR const *pwsz,
    OUT BSTR *pbstr)
/*
Description:
    convert wsz string to a BSTR
Arguments:
    IN: pwsz, a zero terminated wchar string
    OUT pbstr, a pointer to a BSTR, use SysFreeString to free the resource
*/
{
    HRESULT hr;

    if (NULL == pwsz)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "invalid pwsz");
    }
    if (NULL == pbstr)
    {
        hr = E_POINTER;
        _JumpIfError(hr, error, "null pbstr");
    }

    *pbstr = SysAllocString(pwsz);
    _JumpIfOutOfMemory(&hr, error, *pbstr, "SysAllocString");

    hr = S_OK;
error:
    return hr;
}

HRESULT
myWszToBstrVariant(
    IN WCHAR const *pwsz,
    OUT VARIANT *pvar)
/*
Description:
    convert wsz string to a variant with BSTR vt
Arguments:
    pwsz - a zero terminated wchar string
    pvar - a pointer to a variant in which a BSTR type is returned
              use VariantClear to free the resource
Return:
    use VariantClear to free resource in pvar
*/
{
    HRESULT hr;
    BSTR    bstr = NULL;

    if (NULL == pvar)
    {
        hr = E_POINTER;
        _JumpIfError(hr, error, "null pvar");
    }

    //init
    VariantInit(pvar);

    hr = myWszToBstr(pwsz, &bstr);
    _JumpIfError(hr, error, "myWszToBstr");

    pvar->vt = VT_BSTR;
    pvar->bstrVal = bstr;
    bstr = NULL; //release by caller

    hr = S_OK;
error:
    if (NULL != bstr)
    {
        SysFreeString(bstr);
    }
    return hr;
}


HRESULT
myFileExist(
    IN WCHAR const *pwszFile,
    OUT BOOL       *pfExist)
/*
Description:
    check file existence
Arguments:
    pwszFile - file path
    pfExist - return of file-existing flag, TRUE if file exists
Return:
*/
{
    HRESULT hr;
    WIN32_FILE_ATTRIBUTE_DATA wfad;

    //init
    *pfExist = FALSE;

    if (GetFileAttributesEx(
                pwszFile,  //xml file path
                GetFileExInfoStandard,
                &wfad))
    {
        *pfExist = TRUE;
        AzPrint((AZD_XML, "xml file %ws exists.\n", pwszFile));
    }
    else
    {
        AZ_HRESULT_LASTERROR(&hr);
        if (AZ_HRESULT(ERROR_FILE_NOT_FOUND) != hr)
        {
            _JumpError(hr, error, "GetFileAttributesEx");
        }
        AzPrint((AZD_XML, "xml file %ws doesn't exist.\n", pwszFile));
    }

    hr = S_OK;
error:
    return hr;
}

DWORD
myXmlStoreHasUpdate (
    IN AZP_XML_CONTEXT * pContext,
    OUT BOOL           * pbNeedUpdate
    )
/*++
Description:

    Determine whether XML file has been modified since our store loaded.
    For XML store, we just rely on timestamp to test.

Arguments:

    pContext     - The persist context.

    pbNeedUpdate - Receives the test result.

Return Value:
    NO_ERROR - If test is successful
    
    Various error code if error is encountered.

--*/
{
    //
    // For XML store, we just rely on timestamp to tell if
    // the store has been modified
    //
    
    AZASSERT(pbNeedUpdate != NULL);

    *pbNeedUpdate = FALSE;
    
    if (pContext->FTLastWrite.dwHighDateTime == 0 &&
        pContext->FTLastWrite.dwLowDateTime == 0)
    {
        //
        // this means that it is a new store, no need to update it
        //
        
        return NO_ERROR;
    }

    WIN32_FILE_ATTRIBUTE_DATA fad;
    
    DWORD dwStatus = NO_ERROR;
    
    if (GetFileAttributesEx(pContext->pwszPolicyUrl, GetFileExInfoStandard, &fad))
    {                      
        *pbNeedUpdate = CompareFileTime(&(fad.ftLastWriteTime), &(pContext->FTLastWrite)) != 0;
    }
    else
    {
        dwStatus = GetLastError();
    }

    return dwStatus;
}

HRESULT
myXmlLoad (
    IN VARIANT              varUrl, 
    OUT IXMLDOMDocument2 ** ppFreshDom
    )
/*++
Description:

    Load a fresh XML file into XML DOM object

Arguments:

    varUrl      - The XML store URL.
    
    ppFreshDom  - Freshly loaded DOM

Return Value:

    S_OK - If the operation completes successfully
    
    Various error code if errors are encountered.

--*/
{
    CComPtr<IXMLDOMDocument2> srpNewDom;
    HRESULT Hr = CoCreateInstance(
                                CLSID_DOMDocument,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IXMLDOMDocument2,
                                (void**)&srpNewDom);
                                
    if (SUCCEEDED(Hr))
    {
        //
        // This really should never fail
        //
        
        Hr = srpNewDom->put_async(FALSE);
        
        AZASSERT(SUCCEEDED(Hr));
        
        //
        // Load the XML
        //

        VARIANT_BOOL varbLoad;
        Hr = srpNewDom->load(varUrl, &varbLoad);
        
        if (FAILED(Hr))
        {
            if (0x800c0006 == Hr)
            {
                AzPrint((AZD_XML, "IXMLDOMDocument2::load failed. HRESULT = %d. Intepreted as 'file not found'.", Hr));
                Hr = AZ_HR_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }
            
            AzPrint((AZD_XML, "IXMLDOMDocument2::load failed. HRESULT = %d", Hr));
        }
    }
    else
    {
        AzPrint((AZD_XML, "CoCreating IXMLDOMDocument2 failed. HRESULT = %d", Hr));
    }
    
    //
    // If everything has worked, so we passback the fresh new DOM object.
    // Otherwise, the smart pointer will release itself.
    //
    
    if (SUCCEEDED(Hr))
    {
        *ppFreshDom = srpNewDom.Detach();
    }
    
    return Hr;
}

DWORD
XmlCheckSecurityPrivilege(
    IN LPCWSTR PolicyUrl,
    IN BOOL fCreatePolicy
    )
/*
Description:

    Determine whether the caller has SE_SECURITY_PRIVILEGE on the machine containing
    the xml store.

Arguments:

    PolicyUrl - Full path name of the file to check privilege on.
        If fCreatePolicy is TRUE, the file doesn't exist so the privilege is checked on
        the underlying folder

    fCreatePolicy - TRUE if the policy database is to be created.
        FALSE if the policy database already exists

Return Value:
    NO_ERROR - The caller has privilege
    ERROR_PRIVILEGE_NOT_HELD - The caller has no privilege
    Other errors


*/
{
    DWORD WinStatus;

    HANDLE hToken = NULL;
    LPCWSTR PathToCheck = PolicyUrl;
    WCHAR PathBuffer[MAX_PATH+1];

    TOKEN_PRIVILEGES NewPrivilegeState = {0};
    TOKEN_PRIVILEGES OldPrivilegeState = {0};
    BOOL bPrivilegeAdjusted = FALSE;

    NTSTATUS Status;
    UNICODE_STRING NtFileName;
    OBJECT_ATTRIBUTES Obja;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK IoStatusBlock;

    LPWSTR BufferToFree = NULL;

    //
    // Initialization
    //
    AZASSERT( PolicyUrl != NULL );
    RtlInitUnicodeString(&NtFileName, NULL);

    //
    // If we're creating the file,
    //  build the name of the underlying folder.
    //

    if ( fCreatePolicy ) {
        LPWSTR SlashPointer;
        DWORD PathLength;

        //
        // Determine the length of the path to the underlying folder
        //
        SlashPointer = wcsrchr( PolicyUrl, L'\\' );

        if ( SlashPointer == NULL ) {
            AzPrint(( AZD_INVPARM, "XmlCheckSecurityPrivilege: invalid full path '%ws'\n", PolicyUrl ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        PathLength = (ULONG)(SlashPointer - PolicyUrl) + 1;

        if ( PathLength > MAX_PATH ) {
            AzPrint(( AZD_INVPARM, "XmlCheckSecurityPrivilege: path is too long '%ws'\n", PolicyUrl ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;

        }

        //
        // Grab a copy of the path
        //

        wcsncpy( PathBuffer, PolicyUrl, PathLength );
        PathBuffer[PathLength] = '\0';

        PathToCheck = PathBuffer;

    }

    //
    // Enable the SE_SECURITY_PRIVILEGE privilege in order to read the SACL
    //
    //
    // Get the current token to adjust the security privilege.
    //

    WinStatus = AzpGetCurrentToken( &hToken );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Adjust the privilege.
    //  Ignore errors since the caller might be running "net only" and that
    //  user might have privilege on the machine containing the XML file.
    //

    WinStatus = AzpChangeSinglePrivilege(
                SE_SECURITY_PRIVILEGE,
                hToken,
                &NewPrivilegeState,
                &OldPrivilegeState );

    if ( WinStatus == NO_ERROR ) {
        bPrivilegeAdjusted = TRUE;
    }



    //
    // Convert the DOS pathname to an NT pathname
    //

    if ( !RtlDosPathNameToNtPathName_U(
                            PathToCheck,
                            &NtFileName,
                            NULL,
                            NULL
                            ) ) {
        WinStatus = ERROR_PATH_NOT_FOUND;
        goto Cleanup;
    }

    BufferToFree = NtFileName.Buffer;

    //
    // Call NtCreateFile to determine if we have the privilege
    //  Use NtCreateFile instead of CreateFile because:
    //      CreateFile always asks for SYNCHRONIZE and FILE_READ_ATTRIBUTES and we don't need them
    //      CreateFile cannot open directories
    //

    InitializeObjectAttributes(
        &Obja,
        &NtFileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateFile(
                &hFile,
                ACCESS_SYSTEM_SECURITY,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,          // Flags and attributes
                FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE, // Share mode
                FILE_OPEN,  // Create Disposition
                0,      // Create Flags
                NULL,   // EaBuffer
                0 );    // EaSize

    if ( !NT_SUCCESS(Status) ) {
        WinStatus = RtlNtStatusToDosError( Status );
        goto Cleanup;
    }


    WinStatus = NO_ERROR;

Cleanup:

    if ( hToken != NULL ) {
        if ( bPrivilegeAdjusted ) {

            DWORD TempStatus;

            TempStatus = AzpChangeSinglePrivilege(
                                            0,      // This is ignored since OldState is NULL.
                                            hToken,
                                            &OldPrivilegeState,
                                            NULL    // This should be set to NULL to specify REVERT.
                                            );

            ASSERT( TempStatus == NO_ERROR );
        }

        CloseHandle( hToken );
    }

    if ( BufferToFree != NULL ) {
        RtlFreeHeap(RtlProcessHeap(), 0, BufferToFree);
    }

    if ( hFile != INVALID_HANDLE_VALUE ) {
        NtClose(hFile);
    }

    return WinStatus;
}

DWORD
IsAclSupported(
    IN LPCWSTR pwszFileName)
/*
Description:
    check if a drive from a file path has ACL support
Arguments:
    pwszFileName - file full path
Return:
    error or ERROR_NOT_SUPPORTED if not ACL-able
*/
{
    DWORD  dwErr;
    WCHAR *pwszVolumePathName = NULL;
    DWORD dwFlags = 0;
    DWORD len;

    len = (DWORD)(wcslen(pwszFileName) + 2);  //by 2 in case of appending '\\'
    pwszVolumePathName = (WCHAR*)AzpAllocateHeap(len * sizeof(WCHAR), "XMPATH" );
    if (NULL == pwszVolumePathName)
    {
        dwErr = ERROR_OUTOFMEMORY;
        _JumpError(dwErr, error, "AzpAllocateHeap");
    }

    if (!GetVolumePathName(
            pwszFileName,
            pwszVolumePathName,
            len))
    {
        dwErr = GetLastError();
        _JumpError(dwErr, error, "GetVolumePathName");
    }

    len = (DWORD)wcslen(pwszVolumePathName);
    if(pwszVolumePathName[len -1] != L'\\')
    {
        pwszVolumePathName[len] = L'\\';
        pwszVolumePathName[len++] = L'\0';
    }
    if (!GetVolumeInformation(
                pwszVolumePathName,
                NULL,
                NULL,
                NULL,
                NULL,
                &dwFlags,
                NULL,
                0))
    {
        dwErr = GetLastError();
        _JumpError(dwErr, error, "GetVolumeInformation");
    }

    if(0x0 == (FS_PERSISTENT_ACLS & dwFlags))
    {
        dwErr = ERROR_NOT_SUPPORTED;
        _JumpError(dwErr, error, "ACL is not supported");
    }

    dwErr = NO_ERROR;
error:
    if (NULL != pwszVolumePathName)
    {
        AzpFreeHeap(pwszVolumePathName );
    }
    return dwErr;
}



HRESULT
myXmlLoadAclsToAzStore(
    IN PAZP_XML_CONTEXT PersistContext,
    IN ULONG lPersistFlags,
    IN BOOL OnlyAddPolicyAdmins
    )
/*
Description:
    loads xml store file DACL/SACL into the Azroles cache
Arguments:
    PersistContext - Context describing the policy store
    lPersistFlags - flags from the persist engine
    OnlyAddPolicyAdmins - TRUE if only PolicyAdmins is to be loads
Return:
*/
{
    HRESULT  hr;
    DWORD    dwErr;
    BOOLEAN DoSacl;

    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES NewPrivilegeState = {0};
    TOKEN_PRIVILEGES OldPrivilegeState = {0};
    BOOL bPrivilegeAdjusted = FALSE;

    SECURITY_INFORMATION si = 0;
    PSECURITY_DESCRIPTOR pSD = NULL;

    AZASSERT(NULL != PersistContext);

    //
    // Only do the SACL if requested and the caller has privilege
    //

    DoSacl = !OnlyAddPolicyAdmins && PersistContext->HasSecurityPrivilege;

    if ( DoSacl ) {

        //
        // Enable the SE_SECURITY_PRIVILEGE privilege in order to read the SACL
        //
        //
        // Get the current token to adjust the security privilege.
        //

        dwErr = AzpGetCurrentToken( &hToken );
        _JumpIfWinError(dwErr, &hr, error, "AzpGetCurrentToken");

        //
        // Adjust the privilege.
        //  Ignore errors since the caller might be running "net only" and that
        //  user might have privilege on the machine containing the XML file.
        //

        dwErr = AzpChangeSinglePrivilege(
                    SE_SECURITY_PRIVILEGE,
                    hToken,
                    &NewPrivilegeState,
                    &OldPrivilegeState );

        if ( dwErr == NO_ERROR ) {
            bPrivilegeAdjusted = TRUE;
        }

        //
        // Ask for the SACL
        //
        si |= SACL_SECURITY_INFORMATION;
    }


    //
    // Get file security descriptor
    //

    si |= DACL_SECURITY_INFORMATION;
    dwErr = GetNamedSecurityInfo(
                (LPWSTR)PersistContext->pwszPolicyUrl,
                SE_FILE_OBJECT,
                si,
                NULL,
                NULL,
                NULL,
                NULL,
                &pSD);
    _JumpIfWinError(dwErr, &hr, error, "GetNamedSecurityInfo");


    //
    // Set the security descriptor into the cache
    //

    dwErr = XmlAzrolesInfo->AzpeSetSecurityDescriptorIntoCache(
                PersistContext->hAzAuthorizationStore,
                pSD,
                lPersistFlags,
                &PolicyAdminsRights,
                OnlyAddPolicyAdmins ? NULL : &PolicyReadersRights,
                NULL,
                DoSacl ? &XMLSaclRights : NULL );
    _JumpIfWinError( dwErr, &hr, error, "AzpeSetSecurityDescriptorIntoCache" );

    hr = S_OK;
error:

    if ( hToken != NULL )
    {
        if ( bPrivilegeAdjusted )
        {
            dwErr = AzpChangeSinglePrivilege(
                                            0,      // This is ignored since OldState is NULL.
                                            hToken,
                                            &OldPrivilegeState,
                                            NULL    // This should be set to NULL to specify REVERT.
                                            );

            ASSERT( dwErr == NO_ERROR );
        }

        CloseHandle( hToken );
    }

    if (NULL != pSD)
    {
        LocalFree(pSD);
    }
    return hr;
}


HRESULT
myXmlSubmitAzStoreAcls(
    IN PAZP_XML_CONTEXT pPersistContext,
    IN AZPE_OBJECT_HANDLE pAzAuthorizationStore,
    IN ULONG lPersistFlags
    )
/*
Description:
    submit any acl changes to AzAuthorizationStore persist object (xml file)
Arguments:
    pPersistContext - Context describing the store
    pAzAuthorizationStore - AzAuthorizationStore object
    lPersistFlags - flags from the persist engine
Return:
*/
{
    HRESULT  hr;
    DWORD    dwErr;

    PSECURITY_DESCRIPTOR pOldSd = NULL;

    PSECURITY_DESCRIPTOR pNewSd = NULL;

    BOOL UpdateDacl = FALSE;
    PACL pDacl = NULL;
    BOOL bDaclPresent;
    BOOL bDaclDefaulted;

    BOOL UpdateSacl = FALSE;
    PACL pSacl = NULL;
    BOOL bSaclPresent;
    BOOL bSaclDefaulted;

    HANDLE hToken = NULL;

    TOKEN_PRIVILEGES NewPrivilegeState = {0};
    TOKEN_PRIVILEGES OldPrivilegeState = {0};
    BOOL bPrivilegeAdjusted = FALSE;


    BOOL EmptyPolicyAdmins = FALSE;

    SECURITY_INFORMATION si = 0;

    AZASSERT(NULL != pAzAuthorizationStore);

    //
    // Determine whether the DACL and/or SACL need to be updated
    //

    if ( ObjectIsDirty( pAzAuthorizationStore, AZ_DIRTY_CREATE) ) {
        UpdateDacl = TRUE;
        UpdateSacl = pPersistContext->HasSecurityPrivilege;
    } else {
        if ( ObjectIsDirty( pAzAuthorizationStore, AZ_DIRTY_POLICY_READERS|AZ_DIRTY_POLICY_ADMINS|AZ_DIRTY_DELEGATED_POLICY_USERS) ) {

            UpdateDacl = TRUE;
        }

        if ( ObjectIsDirty( pAzAuthorizationStore, AZ_DIRTY_APPLY_STORE_SACL) ) {
            UpdateSacl = TRUE;
        }

        if ( !UpdateDacl && !UpdateSacl ) {
            hr = S_OK;
            goto error;
        }
    }

    //
    // If we need to update the SACL,
    //  we need privilege.

    if ( UpdateSacl ) {

        //
        // Get the current token to adjust the security privilege.
        //

        dwErr = AzpGetCurrentToken( &hToken );
        _JumpIfWinError(dwErr, &hr, error, "AzpGetCurrentToken");

        //
        // Acquire security privilege so we can get/set the SACL
        //

        dwErr = AzpChangeSinglePrivilege(
                                        SE_SECURITY_PRIVILEGE,
                                        hToken,
                                        &NewPrivilegeState,
                                        &OldPrivilegeState
                                        );
        _JumpIfWinError(dwErr, &hr, error, "AzpChangeSinglePrivilege");

        bPrivilegeAdjusted = TRUE;
    }




    //
    // If we didn't just create the object,
    //  Get the existing file security descriptor so we can merge in the changes
    //

    if ( !ObjectIsDirty( pAzAuthorizationStore, AZ_DIRTY_CREATE) ) {

        si = (UpdateDacl ? DACL_SECURITY_INFORMATION : 0) |
             (UpdateSacl ? SACL_SECURITY_INFORMATION : 0);

        dwErr = GetNamedSecurityInfo(
                    (LPWSTR)pPersistContext->pwszPolicyUrl,
                    SE_FILE_OBJECT,
                    si,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &pOldSd);
        _JumpIfWinError(dwErr, &hr, error, "GetNamedSecurityInfo");
    }


    //
    // Get the new security descriptor for the file
    //

    dwErr = XmlAzrolesInfo->AzpeGetSecurityDescriptorFromCache(
                pAzAuthorizationStore,
                lPersistFlags,
                (UpdateDacl ? XMLPolicyAdminsRights : NULL),
                (UpdateDacl ? XMLPolicyReadersRights : NULL),
                NULL,
                NULL,
                NULL,
                NULL,
                (UpdateSacl ? &XMLSaclRights : NULL),
                pOldSd,
                &pNewSd );

    if ( dwErr == ERROR_EMPTY ) {
        EmptyPolicyAdmins = TRUE;
        dwErr = NO_ERROR;
    }
    _JumpIfWinError( dwErr, &hr, error, "AzpeGetSecurityDescriptorFromCache" );

    //
    // Update the SACL on the file
    //

    if ( UpdateSacl ) {

        //
        // Get the SACL from the returned security descriptor
        //

        if ( !GetSecurityDescriptorSacl(pNewSd,
                                        &bSaclPresent,
                                        &pSacl,
                                        &bSaclDefaulted
                                        ) ) {
            AZ_HRESULT_LASTERROR(&hr);
            _JumpError(hr, error, "GetSecurityDescriptorSacl");
        }


        // Indicate the SACL should be set
        //  The SACL is never protected.
        si |= SACL_SECURITY_INFORMATION | UNPROTECTED_SACL_SECURITY_INFORMATION;

    }

    //
    // Update the DACL on the file
    //

    if ( UpdateDacl ) {

        //
        // Get the DACL from the returned security descriptor
        //

        if ( !GetSecurityDescriptorDacl(pNewSd,
                                        &bDaclPresent,
                                        &pDacl,
                                        &bDaclDefaulted
                                        ) ) {
            AZ_HRESULT_LASTERROR(&hr);
            _JumpError(hr, error, "GetSecurityDescriptorDacl");
        }


        ASSERT( bDaclPresent && pDacl != NULL );

        //
        // Indicate the DACL should be set
        // The DACL needs to have its protected bit on.
        //
        si |= DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION;
    }

    //
    // Set the DACL/SACL onto the file
    //

    dwErr = SetNamedSecurityInfo(
                (LPWSTR)pPersistContext->pwszPolicyUrl,
                SE_FILE_OBJECT,
                si,
                NULL, //psidOwner
                NULL, //psidGroup
                pDacl,
                pSacl); //pSacl
    _JumpIfWinError(dwErr, &hr, error, "SetNamedSecurityinfo");


    //
    // If SetNamedSecurityinfo changed PolicyAdmins,
    //  load the PolicyAdmins back into the the azroles core.
    //
    if ( EmptyPolicyAdmins ) {
        hr = myXmlLoadAclsToAzStore(
                 pPersistContext,
                 lPersistFlags,
                 TRUE );
        _JumpIfError(hr, error, "myXmlLoadAclsToAzStore");
    }

    hr = S_OK;
error:
    if ( hToken != NULL ) {
        if ( bPrivilegeAdjusted ) {
            DWORD dwIgnoreErr;
            dwIgnoreErr = AzpChangeSinglePrivilege(
                              0,   // This is ignored since OldState is NULL.
                              hToken,
                              &OldPrivilegeState,
                              NULL );   // This should be set to NULL to specify REVERT.

            if (dwIgnoreErr != NO_ERROR) {
                AzPrint((AZD_XML, "AzpChangeSinglePrivilege failed to reset to original. Error code: %d", dwIgnoreErr));
            }
        }

        CloseHandle( hToken );
    }

    XmlAzrolesInfo->AzpeFreeMemory( pNewSd );

    if ( pOldSd != NULL ) {
        LocalFree(pOldSd);
    }

    return hr;
}



HRESULT
myXmlValidateNodeType(
    IXMLDOMNode  *pNode,
    DOMNodeType   designedNodeType)
/*
Description:
    make sure the node has a valid node type
Arguments:
    pNode - pointer to xml node
    designedNodeType - designed node type
*/
{
    HRESULT  hr;
    DOMNodeType nodeType;

    AZASSERT(NULL != pNode);

    hr = pNode->get_nodeType(&nodeType);
    _JumpIfError(hr, error, "pNode->get_nodeType");

    if (nodeType != designedNodeType)
    {
        // node type is not expected
        hr = E_INVALIDARG;
        _JumpError(hr, error, "bad node type");
    }

    hr = S_OK;
error:
    return hr;
}

HRESULT
myXmlGetNodeAttribute(
    IN  IXMLDOMNode  *pNode,
    IN  WCHAR const  *pwszName,
    OUT WCHAR       **ppwszValue)
/*
Description:
    query named attribute from xml element node
Arguments:
    pNode - pointer to xml node element
    pwszName - attribute name
    ppwszValue - returns the value of the attribute
Return:
*/
{
    HRESULT hr;
    IXMLDOMNamedNodeMap *pNodeMap = NULL;
    IXMLDOMNode         *pNodeAttr = NULL;
    BSTR                 bstrName = NULL;
    VARIANT              varValue;

    AZASSERT(NULL != pNode &&
             NULL != pwszName &&
             NULL != ppwszValue);

    // init
    *ppwszValue = NULL;
    VariantInit(&varValue);

    // validate node type
    hr = myXmlValidateNodeType(pNode, NODE_ELEMENT);
    _JumpIfError(hr, error, "myXmlValidateNodeType");

    // get attribute list
    hr = pNode->get_attributes(&pNodeMap);
    _JumpIfError(hr, error, "pNode->get_attributes");

    bstrName = SysAllocString(pwszName);
    _JumpIfOutOfMemory(&hr, error, bstrName, "SysAllocString");

    // return attribute node object
    hr = pNodeMap->getNamedItem(bstrName, &pNodeAttr);
    //_JumpIfError(hr, error, "pNodeMap->getNamedItem");
    if (S_OK != hr || NULL == pNodeAttr)
    {
        // seems doesn't have the attribute
        hr = AZ_HRESULT(ERROR_NOT_FOUND);
        _JumpErrorQuiet(hr, error, "attribute not found");
    }

    // now we get attribute value
    hr = pNodeAttr->get_nodeValue(&varValue);
    _JumpIfError(hr, error, "pNodeAttr->get_nodeValue");

    //??? may not true if we have other attribute type
    AZASSERT(VT_BSTR == varValue.vt);

    // we want to return the value in wchar
    *ppwszValue = (WCHAR*)AzpAllocateHeap(
            (wcslen(varValue.bstrVal) + 1) * sizeof(WCHAR), "XMVAL" );
    _JumpIfOutOfMemory(&hr, error, *ppwszValue, "AzpAllocateHeap");

    // return
    wcscpy(*ppwszValue, varValue.bstrVal);

    hr = S_OK;
error:
    if (NULL != pNodeMap)
    {
        pNodeMap->Release();
    }
    if (NULL != pNodeAttr)
    {
        pNodeAttr->Release();
    }
    if (NULL != bstrName)
    {
        SysFreeString(bstrName);
    }
    VariantClear(&varValue);

    return hr;
}

HRESULT
myXmlSetNodeAttribute(
    IN  IXMLDOMNode  *pNode,
    IN  WCHAR const  *pwszName,
    IN  WCHAR const  *pwszValue,
    IN OPTIONAL IXMLDOMDocument2  *pDoc)
/*
Description:
    set named attribute to xml element node
Arguments:
    pNode - pointer to xml node element
    pwszName - attribute name
    pwszValue - the value of the attribute
    pDoc - NULL means the attribute must exist, otherwise it creates one if not
Return:
*/
{
    HRESULT hr;
    IXMLDOMNamedNodeMap *pNodeMap = NULL;
    IXMLDOMNode         *pNodeAttr = NULL;
    IXMLDOMElement      *pEle = NULL;
    BSTR                 bstrName = NULL;
    VARIANT              varValue;

    AZASSERT(NULL != pNode &&
             NULL != pwszName &&
             NULL != pwszValue);

    AzPrint((AZD_XML, "(myXmlSetNodeAttribute)pNode = 0x%lx\n", pNode));

    // init
    VariantInit(&varValue);

    // validate node type
    hr = myXmlValidateNodeType(pNode, NODE_ELEMENT);
    _JumpIfError(hr, error, "myXmlValidateNodeType");

    // get attribute list
    hr = pNode->get_attributes(&pNodeMap);
    _JumpIfError(hr, error, "pNode->get_attributes");

    bstrName = SysAllocString(pwszName);
    _JumpIfOutOfMemory(&hr, error, bstrName, "SysAllocString");

    // convert value to variant
    hr = myWszToBstrVariant(
                pwszValue,
                &varValue);
    _JumpIfError(hr, error, "myWszToBstrVariant");

    // return attribute node object
    hr = pNodeMap->getNamedItem(bstrName, &pNodeAttr);
    if (S_OK == hr)
    {
        AZASSERT(NULL != pNodeAttr);

            // now we set attribute value
            hr = pNodeAttr->put_nodeValue(varValue);
            _JumpIfError(hr, error, "pNodeAttr->put_nodeValue");
    }
    else
    {
        // the attribute doesn't exist

#if DBG
{
    BSTR bstrXml = NULL;

    AzPrint((AZD_XML, "attribute %ws doesn't exist in the following element...\n", bstrName));
    hr = pNode->get_xml(&bstrXml);
    _JumpIfError(hr, error, "pNode->get_xml");
    AzPrint((AZD_XML, "The node xml = %ws\n", bstrXml));
    if (NULL != bstrXml) SysFreeString(bstrXml);
}
#endif //DBG

        if (NULL == pDoc)
        {
            // must not null if create one
            hr = AZ_HRESULT(ERROR_NOT_FOUND);
            _JumpErrorQuiet(hr, error, "attribute not found");
        }

        AZASSERT(NULL == pNodeAttr);

        hr = pNode->QueryInterface(IID_IXMLDOMElement, (void**)&pEle);
        _JumpIfError(hr, error, "pNode->QueryInterface");

        AZASSERT(NULL != pEle);

        //set attr
        hr = pEle->setAttribute(
                    bstrName,
                    varValue);
        _JumpIfError(hr, error, "pEle->setAttribute");
    }

#if DBG
{
    BSTR bstrXml = NULL;

    AzPrint((AZD_XML, "set %ws attribute is done...\n", bstrName));
    hr = pNode->get_xml(&bstrXml);
    _JumpIfError(hr, error, "pNode->get_xml");
    AzPrint((AZD_XML, "The node xml = %ws\n", bstrXml));
    if (NULL != bstrXml) SysFreeString(bstrXml);
}
#endif //DBG

    hr = S_OK;
error:
    if (NULL != pEle)
    {
        pEle->Release();
    }
    if (NULL != pNodeMap)
    {
        pNodeMap->Release();
    }
    if (NULL != pNodeAttr)
    {
        pNodeAttr->Release();
    }
    if (NULL != bstrName)
    {
        SysFreeString(bstrName);
    }
    VariantClear(&varValue);

    return hr;
}


HRESULT
myXmlValidateNodeTag(
    IXMLDOMNode  *pNode,
    WCHAR const  *pwszTag)
/*
Description:
    make sure the node has a valid az tag name
Arguments:
    pNode - pointer to xml node
    pwszTag - designed tag name for the node
Return:
*/
{
    HRESULT  hr;
    BSTR     bstrTag = NULL;

    AZASSERT(NULL != pNode &&
             NULL != pwszTag);

    hr = pNode->get_nodeName(&bstrTag);
    _JumpIfError(hr, error, "pNode->get_nodeName");

    if (0 != wcscmp(pwszTag, bstrTag))
    {
        // node tag name is bad
        hr = E_INVALIDARG;
        _JumpError(hr, error, "bad tag name");
    }

    hr = S_OK;
error:
    if (NULL != bstrTag)
    {
        SysFreeString(bstrTag);
    }
    return hr;
}


HRESULT
myXmlLoadObjectAttribute(
    IN IXMLDOMNode          *pNode,
    IN ULONG                 lPersistFlags,
    IN WCHAR const          *pwszAttrTag,
    IN AZPE_OBJECT_HANDLE       pObject,
    IN ULONG                 lPropId,
    IN ENUM_AZ_DATATYPE      DataType)
/*
Description: load a node attribute from persist store
    to az core object
Arguments:
    pNode - object node handle
    lPersistFlags - persist flags passed back to az core
    pwszAttrTag - attribute tag name
    pObject - az core object handle
    lPropId - property ID used to set on az core object
    DataType - data type
Return:
*/
{
    HRESULT  hr;
    DWORD    dwErr;
    PVOID    pV;
    WCHAR   *pwszAttrValue = NULL;
    ULONG    lNumber;

    AZASSERT(NULL != pNode &&
             NULL != pwszAttrTag &&
             NULL != pObject);

    // get attribute from xml node
    hr = myXmlGetNodeAttribute(
                pNode,
                pwszAttrTag,
                &pwszAttrValue);
    if (S_OK != hr && AZ_HRESULT(ERROR_NOT_FOUND) != hr)
    {
        _JumpError(hr, error, "myXmlGetNodeAttribute");
    }

    if (NULL != pwszAttrValue)
    {
        switch (DataType)
        {
            case ENUM_AZ_BSTR:
                // attribute is a string
                pV = (PVOID)pwszAttrValue;
            break;

            case ENUM_AZ_LONG:
                // atribute is a number
                // convert to number
                lNumber = _wtol(pwszAttrValue);
                pV = (PVOID)&lNumber;
            break;

            case ENUM_AZ_BOOL:
                // attribute is a boolean
                // map to boolean id
                // default to false
                lNumber = FALSE; // so any strings other than TRUE
                if (0 == _wcsicmp(pwszAttrValue, AZ_XML_VAL_TRUE))
                {
                    lNumber = TRUE;
                }
                pV = (PVOID)&lNumber;
            break;


            case ENUM_AZ_GROUP_TYPE:
                // set default to basic
                lNumber = AZ_GROUPTYPE_BASIC;
                if (0 == wcscmp(pwszAttrValue, AZ_XML_VAL_GROUPTYPE_LDAPQUERY))
                {
                    lNumber = AZ_GROUPTYPE_LDAP_QUERY;
                }
                pV = (PVOID)&lNumber;
            break;

            default:
                hr = E_INVALIDARG;
                _JumpError(hr, error, "invalid attribute data type");
        }

        // set object attribute
        dwErr = XmlAzrolesInfo->AzpeSetProperty(
                    pObject,
                    lPersistFlags,
                    lPropId,
                    pV);
        _JumpIfWinError(dwErr, &hr, error, "AzpeSetProperty");
    }

    hr = S_OK;
error:
    if (NULL != pwszAttrValue)
    {
        AzpFreeHeap(pwszAttrValue );
    }
    return hr;
}


HRESULT
myXmlSubmitObjectAttribute(
    IN   AZPE_OBJECT_HANDLE hObject,
    IN   ULONG            lPersistFlags,
    IN   ULONG            lPropId,
    IN   ENUM_AZ_DATATYPE DataType,
    IN   IXMLDOMNode      *pNode,
    IN   WCHAR const      *pwszAttrTag,
    IN   IXMLDOMDocument2  *pDoc)
/*
Description:
    gets an object property az core object and sets the
    property as an node attribute in xml doc.
    This is the routine used by all object attribute submissions

Arguments:
    jObject - handle of the object
    lPersistFlags - flags from the persist engine
    lPropId - property ID
    DataType - data type of the property, one of ENUM_AZ_*
    pNode - the node handle at  which the property is set as attribute
    pwszAttrTag - attribute tag string
    pDoc - root doc node handle
Return:
*/
{
    HRESULT  hr;
    DWORD    dwErr;
    PVOID    pvPropValue = NULL;
    WCHAR const * pwszValue;
    WCHAR    wszNumber[20];

    AZASSERT(NULL != hObject &&
             NULL != pwszAttrTag &&
             NULL != pNode &&
             NULL != pDoc);

    AzPrint((AZD_XML, "(myXmlSubmitObjectAttribute)pNode = 0x%lx\n", pNode));

    // get property from az core
    dwErr = XmlAzrolesInfo->AzpeGetProperty(
                    hObject,
                    lPersistFlags,
                    lPropId,
                    &pvPropValue);
    _JumpIfWinError(dwErr, &hr, error, "AzpeGetProperty");

    AZASSERT(NULL != pvPropValue);

    switch (DataType)
    {
        case ENUM_AZ_BSTR:
            pwszValue = (WCHAR*)pvPropValue;
        break;

        case ENUM_AZ_BOOL:
            // init
            pwszValue = g_pwszAzFalse;
            if (*((BOOL*)pvPropValue))
            {
                pwszValue = g_pwszAzTrue;
            }
        break;

        case ENUM_AZ_LONG:
            wsprintf(wszNumber, L"%d", (*(LONG*)pvPropValue));
            pwszValue = wszNumber;
        break;

        case ENUM_AZ_GROUP_TYPE:
            // init
            pwszValue = g_pwszBasicGroup;
            if (AZ_GROUPTYPE_LDAP_QUERY == *((LONG*)pvPropValue))
            {
                pwszValue = g_pwszLdapGroup;
            }
        break;

        default:
            hr = E_INVALIDARG;
            _JumpError(hr, error, "invalid attribute data type");
    }

    // persist the data
    hr = myXmlSetNodeAttribute(
                    pNode,
                    pwszAttrTag,
                    pwszValue,
                    pDoc);
    _JumpIfError(hr, error, "myXmlSetNodeAttribute");

    hr = S_OK;
error:
    if (NULL != pvPropValue)
    {
        XmlAzrolesInfo->AzpeFreeMemory(pvPropValue);
    }
    return hr;
}

DWORD
XMLPersistIsAcl(
    IN PAZP_XML_CONTEXT pPersistContext,
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    OUT BOOL           *pfAcl
    )
{
    UNREFERENCED_PARAMETER(pPersistContext);

    AZASSERT(NULL != AzpeObjectHandle);

    //init
    *pfAcl = FALSE;

    //
    // only authorization store object has acl for xml store
    //  Since we don't support XML stores on FAT system, we can safely
    //  return TRUE as for authorization store
    //

    if (OBJECT_TYPE_AZAUTHSTORE == XmlAzrolesInfo->AzpeObjectType( AzpeObjectHandle ))
    {
        *pfAcl = TRUE;
    }

    return NO_ERROR;
}

HRESULT
XmlSetObjectOptions(
    IN PAZP_XML_CONTEXT PersistContext,
    IN ULONG lPersistFlags,
    IN AZPE_OBJECT_HANDLE pObj
    )
/*
Description:

    Set the object options for the object

Arguments:
    PersistContext - Context describing the policy store
    lPersistFlags - flags from the persist engine
    pObj - object to be set

Return:
*/
{
    HRESULT  hr;
    DWORD    dwErr;
    ULONG ObjectOptions = 0;
    BOOL DaclSupported;
    ULONG lObjectType = XmlAzrolesInfo->AzpeObjectType(pObj);

    //
    // Tell azroles about the object options
    //

    if ( PersistContext->IsWritable ) {
        ObjectOptions |= AZPE_OPTIONS_WRITABLE;
        ObjectOptions |= AZPE_OPTIONS_CREATE_CHILDREN;
    }

    if ( lObjectType == OBJECT_TYPE_AZAUTHSTORE ) {

        dwErr = XMLPersistIsAcl( PersistContext, pObj, &DaclSupported );
        _JumpIfWinError(dwErr, &hr, error, "XMLPersistIsAcl");

        if ( DaclSupported ) {
            ObjectOptions |= AZPE_OPTIONS_SUPPORTS_DACL;
            ObjectOptions |= AZPE_OPTIONS_SUPPORTS_SACL;
        }

        if ( PersistContext->HasSecurityPrivilege ) {
            ObjectOptions |= AZPE_OPTIONS_HAS_SECURITY_PRIVILEGE;
        }
    }

    dwErr = XmlAzrolesInfo->AzpeSetObjectOptions(
                pObj,
                lPersistFlags,
                ObjectOptions );
    _JumpIfWinError(dwErr, &hr, error, "AzpeSetObjectOptions");

    hr = S_OK;

error:
    return hr;
}


HRESULT
myXmlLoadObjectCommonData(
    IN PAZP_XML_CONTEXT PersistContext,
    IN IXMLDOMNode         *pNode,
    IN ULONG                lPersistFlags,
    IN ULONG                lObjectType,
    IN AZPE_OBJECT_HANDLE      pParent,
    OUT OPTIONAL AZPE_OBJECT_HANDLE    *ppObj)
/*
Description:
    load common attributes such as decsription and guid
    from xml node and create az object and set common properties
Arguments:
    PersistContext - Context describing the policy store
    pNode - xml node object
    lPersistFlags - flags from the persist engine
    lObjectType - object type (OBJECT_TYPE_*)
    pObj - object to be set
Return:
*/
{
    HRESULT  hr2 = S_OK;
    HRESULT  hr;
    DWORD    dwErr;

    WCHAR   *pwszName = NULL;
    WCHAR   *pwszGuid = NULL;
    GUID     GuidData;

    AZPE_OBJECT_HANDLE      pObj = NULL;

    AZASSERT(NULL != pNode &&
             NULL != pParent);

    if (NULL != ppObj)
    {
        //init
        *ppObj = NULL;
    }

    if (OBJECT_TYPE_AZAUTHSTORE != lObjectType)
    {
        // get object name from xml node to create initial az object
        hr = myXmlGetNodeAttribute(
                    pNode,
                    AZ_XML_TAG_ATTR_NAME,
                    &pwszName);
        _JumpIfError(hr, error, "myXmlGetNodeAttribute(name)");

        // object guid must exist
        hr = myXmlGetNodeAttribute(
                    pNode,
                    AZ_XML_TAG_ATTR_GUID,
                    &pwszGuid);
        _JumpIfError(hr, error, "myXmlGetNodeAttribute");

        hr = UuidFromString(pwszGuid, &GuidData);
        _JumpIfError(hr, error, "UuidFromString");

        //let's create a real az object
        dwErr = XmlAzrolesInfo->AzpeCreateObject(
                    pParent,
                    lObjectType,
                    pwszName,
                    &GuidData,
                    lPersistFlags,
                    &pObj);
        _JumpIfWinError(dwErr, &hr, error, "AzpeCreateObject");

        AZASSERT(NULL != pObj);
    }
    else
    {
        // for AzAuthorizationStore object, it is on the top
        pObj = pParent;
    }

    // load other common attributes

    //
    // load description attribute
    //
    hr = myXmlLoadObjectAttribute(
                pNode,
                lPersistFlags,
                AZ_XML_TAG_ATTR_DESCRIPTION,
                pObj,
                AZ_PROP_DESCRIPTION,
                ENUM_AZ_BSTR);
    _JumpIfErrorOrPressOn(hr, hr2, error, lPersistFlags, TRUE, "myXmlLoadObjectAttribute(description)");


    //
    // Tell azroles about the object options
    //

    hr = XmlSetObjectOptions( PersistContext, lPersistFlags, pObj );
    _JumpIfError(hr, error, "XmlSetObjectOptions");


    //
    // Return the created object to the caller
    //
    if (OBJECT_TYPE_AZAUTHSTORE != lObjectType &&
        NULL != ppObj)
    {
        // return
        *ppObj = pObj;
        pObj = NULL;
    }

    _HandlePressOnError(hr, hr2);

error:
    if (NULL != pwszName)
    {
        AzpFreeHeap(pwszName );
    }
    if (NULL != pwszGuid)
    {
        AzpFreeHeap(pwszGuid );
    }

    return hr;
}



HRESULT
myObAddPropertyItem(
    IN AZPE_OBJECT_HANDLE  pObject,
    IN ULONG            lPersistFlags,
    IN ULONG            lPropertyId,
    IN ENUM_AZ_DATATYPE DataType,
    IN PVOID            pValue)
/*
Description:
    help routine to add property items
Arguments:
    pObject - az core object pointer
    lPersistFlags - persist flags
    lPropertyId - property ID
    DataType - data type of the property
    pValue - property item value
Return:
*/
{
    HRESULT  hr;
    DWORD    dwErr;

    if (ENUM_AZ_SID_ARRAY == DataType)
    {
        dwErr = XmlAzrolesInfo->AzpeAddPropertyItemSid(
                    pObject,
                    lPersistFlags,
                    lPropertyId,
                    pValue);
        _JumpIfWinError(dwErr, &hr, error, "AzpeAddPropertyItemSid");
    }
    else
    {
        // guid items
        dwErr = XmlAzrolesInfo->AzpeAddPropertyItemGuidString(
                    pObject,
                    lPersistFlags,
                    lPropertyId,
                    (WCHAR*)pValue);
        _JumpIfWinError(dwErr, &hr, error, "AzpeAddPropertyItemGuidString");
    }


    hr = S_OK;
error:
    return hr;
}


HRESULT
myXmlLoadProperties(
    IN     WCHAR const           *pwszPropTag,
    IN     ULONG                  lPersistFlags,
    IN     ULONG                  lPropertyId,
    IN     ENUM_AZ_DATATYPE       DataType,
    IN     BOOL                   fSingle,
    IN     IXMLDOMNode           *pObjectNode,
    IN     AZPE_OBJECT_HANDLE        pObject)
/*
Description:
    load object properties into az core object
    The property includes both single occurence element or multiple items
Argument:
    pwszPropTag - property tag name
    lPersistFlags - flags from the persist engine
    lPropertyId - property ID for az group member
    fSid - TRUE if element is in sid string format
    fSingle - the property should be single occurence
        this is used to determine call SetProperty or AddPropertyItem
    pObjectNode - interface pointer to xml object node
    pObject - az object handle to be set
Return:
*/
{
    HRESULT  hr;
    DWORD    dwErr;
    BSTR              bstrPropTag = NULL;
    BSTR              bstrPropValue = NULL;
    IXMLDOMNodeList  *pPropList = NULL;
    IXMLDOMNode      *pPropNode = NULL;
    LONG              lLength;
    LONG              i;
    LONG              lValue;
    VOID             *pValue;
    PSID              pSid = NULL;

    AZASSERT(NULL != pObject &&
             NULL != pwszPropTag &&
             NULL != pObjectNode);

    // convert to bstr for tag
    bstrPropTag = SysAllocString(pwszPropTag);
    _JumpIfOutOfMemory(&hr, error, bstrPropTag, "SysAllocString");

    // get element list
    hr = pObjectNode->selectNodes(
                bstrPropTag,
                &pPropList);
    _JumpIfError(hr, error, "pObjectNode->selectNodes");

    AZASSERT(NULL != pPropList);

    // get item length
    hr = pPropList->get_length(&lLength);
    _JumpIfError(hr, error, "pPropList->get_length");

    // add each elements into az object
    for (i = 0; i < lLength; ++i)
    {
        // get element node
        hr = pPropList->get_item(i, &pPropNode);
        _JumpIfError(hr, error, "pPropList->get_item");

        AZASSERT(NULL != pPropNode);

        // get element value
        hr = pPropNode->get_text(&bstrPropValue);
        _JumpIfError(hr, error, "pPropNode->get_text");

        AZASSERT(NULL != bstrPropValue);

        // init point to as string
        pValue = (VOID*)bstrPropValue;

        // if in sid format, do conversion
        if (ENUM_AZ_SID_ARRAY == DataType)
        {
            // convert string sid to sid
            if (!ConvertStringSidToSid(bstrPropValue, &pSid))
            {
                AZ_HRESULT_LASTERROR(&hr);
                _JumpError(hr, error, "ConvertStringSidToSid");
            }

            AZASSERT(NULL != pSid);

            pValue = (VOID*)pSid;
        }
        else if (ENUM_AZ_LONG == DataType)
        {
            lValue = _wtol(bstrPropValue);
            pValue = (VOID*)&lValue;
        }

        if (fSingle)
        {
            //
            // if string is empty, don't set it with the exception of BizRule
            // An empty BizRule is significantly different from no biz rule in
            // out current cache implementation.
            //
            
            if ( ENUM_AZ_LONG == DataType ||
                 (ENUM_AZ_BSTR == DataType && AZ_PROP_TASK_BIZRULE == lPropertyId) ||
                 (ENUM_AZ_BSTR == DataType && L'\0' != ((WCHAR*)pValue)[0])
               )
            {
                //
                // if we see a empty string for biz rule, use a one space value so that 
                // the cache will have a one space biz rule. Otherwise, the empty string will
                // be interprected as a NULL by our string capture utility AzpCaptureString.
                //
                
                PVOID pPropValue = (AZ_PROP_TASK_BIZRULE == lPropertyId && L'\0' == ((WCHAR*)pValue)[0]) ?
                                    L" " : pValue;
                
                dwErr = XmlAzrolesInfo->AzpeSetProperty(
                            pObject,
                            lPersistFlags,
                            lPropertyId,
                            pPropValue);
                            
                _JumpIfWinError(dwErr, &hr, error, "AzpeSetProperty");
            }

            // if single, we should be done
            // in case persist store has more than one, ignore the rest
            goto done;
        }

        // now ready to add element to az object
        dwErr = myObAddPropertyItem(
                        pObject,
                        lPersistFlags,
                        lPropertyId,
                        DataType,
                        pValue);
        _JumpIfWinError(dwErr, &hr, error, "myObAddPropertyItem");

        // free for the next in for loop
        if (NULL != pSid)
        {
            LocalFree(pSid);
            pSid = NULL;
        }
        pPropNode->Release();
        pPropNode = NULL;
        SysFreeString(bstrPropValue);
        bstrPropValue = NULL;
    }

done:
    hr = S_OK;
error:
    if (NULL != bstrPropTag)
    {
        SysFreeString(bstrPropTag);
    }
    if (NULL != bstrPropValue)
    {
        SysFreeString(bstrPropValue);
    }
    if (NULL != pSid)
    {
        LocalFree(pSid);
        pSid = NULL;
    }
    if (NULL != pPropList)
    {
        pPropList->Release();
    }
    if (NULL != pPropNode)
    {
        pPropNode->Release();
    }

    return hr;
}


HRESULT
myXmlLoadObject(
    IN PAZP_XML_CONTEXT PersistContext,
    IN AZPE_OBJECT_HANDLE       pParentObject,
    IN ULONG                 lObjectType,
    IN ULONG                 lPersistFlags,
    IN BOOL                  fChildren,
    IN BOOL                  fFinishAzStoreObject,
    IN IXMLDOMNode          *pObjectNode)
/*
Description:
    load a persist object and optional all children into az core
    if there is children, it will be recursive routine if load all children
Arguments:
    PersistContext - Context describing the policy store
    pParentObject - the parent object handle
    lObjectType - the object type that is loaded
    lPersistFlags - flags from the persist engine
                    if the flag is AZPE_FLAGS_PERSIST_OPEN, error handling returns immediately
                    if the flag is AZPE_FLAGS_PERSIST_UPDATE_CACHE, error handling press on.
    fChildren - TRUE if load child objects
    fFinishAzStoreObject - TRUE if want to call AzpeFinishObject on AzAuthorizationStore
    pObjectNode - the node handle of the object
Return:
*/
{
    HRESULT  hr2 = S_OK;
    HRESULT  hr;
    AZPE_OBJECT_HANDLE   pObject = NULL;
    BSTR              bstrChildTag = NULL;
    IXMLDOMNodeList  *pChildList = NULL;
    IXMLDOMNode      *pChildNode = NULL;
    LONG              lLength = 0;
    LONG              i;

    AZASSERT(NULL != pParentObject &&
             NULL != pObjectNode);

    // load/create object and set common attributes
    hr = myXmlLoadObjectCommonData(
                PersistContext,
                pObjectNode,
                lPersistFlags,
                lObjectType,
                pParentObject,
                &pObject);
    _JumpIfErrorOrPressOn(hr, hr2, error, lPersistFlags, NULL != pObject, "myXmlLoadObjectCommonData");

    if (OBJECT_TYPE_AZAUTHSTORE == lObjectType)
    {
        // if AzAuthorizationStore object, it is top, object points to parent
        AZASSERT(NULL == pObject);
        pObject = pParentObject;
    }
#if DBG
    else
    {
        AZASSERT(NULL != pObject);
    }
#endif //DBG

    //load object attributes
    if (NULL != g_SubmitLoadTable[lObjectType].rgpAttrs)
    {
        // load object attributes
        AZ_PROP_ENTRY *pAttrs;
        for (pAttrs = g_SubmitLoadTable[lObjectType].rgpAttrs;
             NULL != pAttrs[0].pwszTag; ++pAttrs)
        {
            hr = myXmlLoadObjectAttribute(
                    pObjectNode,
                    lPersistFlags,
                    pAttrs[0].pwszTag,
                    pObject,
                    pAttrs[0].lPropId,
                    pAttrs[0].lDataType);
            _JumpIfErrorOrPressOn(hr, hr2, error, lPersistFlags, TRUE, "myXmlLoadNodeAttribute");
        }
    }

    //load object property elements
    if (NULL != g_SubmitLoadTable[lObjectType].rgpEles)
    {
        // load object elements
        AZ_PROP_ENTRY *pEles;
        for (pEles = g_SubmitLoadTable[lObjectType].rgpEles;
             NULL != pEles[0].pwszTag; ++pEles)
        {
            hr = myXmlLoadProperties(
                    pEles[0].pwszTag,
                    lPersistFlags,
                    pEles[0].lPropId,
                    pEles[0].lDataType,
                    pEles[0].fSingle,  //single occurence
                    pObjectNode,
                    pObject);
            _JumpIfErrorOrPressOn(hr, hr2, error, lPersistFlags, TRUE, "myXmlLoadProperties");
        }
    }

    //
    // load the object children
    //
    if (fChildren && NULL != g_SubmitLoadTable[lObjectType].rgpChildren)
    {
        AZ_CHILD_ENTRY *pChild;
        for (pChild = g_SubmitLoadTable[lObjectType].rgpChildren;
             NULL != pChild[0].pwszChildTag; ++pChild)
        {
            bstrChildTag = SysAllocString(pChild->pwszChildTag);
            _JumpIfOutOfMemory(&hr, error, bstrChildTag, "SysAllocString");

            hr = pObjectNode->selectNodes(
                    bstrChildTag,
                    &pChildList);
            _JumpIfError(hr, error, "pObjectNode->selectNodes");

            hr = pChildList->get_length(&lLength);
            _JumpIfError(hr, error, "pTaskList->get_length");

            // add each child to the current object
            for (i = 0; i < lLength; ++i)
            {
                // get each child node
                hr = pChildList->get_item(i, &pChildNode);
                _JumpIfError(hr, error, "pChildList->get_item");

                AZASSERT(NULL != pChildNode);

                // make sure is a valid child, at least an element
                hr = myXmlValidateNodeType(
                            pChildNode,
                            NODE_ELEMENT);

                if (S_OK == hr)
                {
                    // ok, load child into the current object
                    hr = myXmlLoadObject(
                            PersistContext,
                            pObject,  // parent, which is the current object
                            pChild->ChildType,
                            lPersistFlags,
                            fChildren,
                            fFinishAzStoreObject,
                            pChildNode);
                    _JumpIfErrorOrPressOn(hr, hr2, error, lPersistFlags, TRUE, "myXmlLoadObject");
                }

                // free node for the next child
                pChildNode->Release();
                pChildNode = NULL;
            }

            // free for the next
            SysFreeString(bstrChildTag);
            bstrChildTag = NULL;
            pChildList->Release();
            pChildList = NULL;
        }
    }

    _HandlePressOnError(hr, hr2);
error:
    if (NULL != bstrChildTag)
    {
        SysFreeString(bstrChildTag);
    }
    if (NULL != pChildList)
    {
        pChildList->Release();
    }
    if (NULL != pChildNode)
    {
        pChildNode->Release();
    }

    if ((NULL != pObject) &&
        ((OBJECT_TYPE_AZAUTHSTORE != lObjectType) ||
         (OBJECT_TYPE_AZAUTHSTORE == lObjectType && fFinishAzStoreObject)
        )
       )
    {
        XmlAzrolesInfo->AzpeObjectFinished( pObject, AzpHresultToWinStatus(hr) );
    }

    return hr;
}

HRESULT
myXmlGetAzStoreNode(
    IN     IXMLDOMDocument2   *pDoc,
    OUT    IXMLDOMElement   **ppAzStoreNode)
/*
    get the az top node, authorization store
    IN: pDoc, the root node, document node
    IN: ppAzStoreNode, AzAuthStore node for return
*/
{
    HRESULT hr;

    AZASSERT(NULL != pDoc &&
             NULL != ppAzStoreNode);

    // get the root node, ie. the node of authorization store policy
    hr = pDoc->get_documentElement(ppAzStoreNode);
    _JumpIfError(hr, error, "pDoc->get_documentElement");

    AZASSERT(NULL != *ppAzStoreNode);

    // make sure it has the correct tag
    hr = myXmlValidateNodeTag(
                *ppAzStoreNode,
                AZ_XML_TAG_AZSTORE);
    _JumpIfError(hr, error, "myXmlValidateNodeTag");

    hr = S_OK;
error:
    return hr;
}

HRESULT
myXmlLoadPolicyToAzAuthorizationStore(
    IN PAZP_XML_CONTEXT PersistContext,
    IN     BOOL               fCreatePolicy,
    IN     ULONG              lPersistFlags,
    IN     IXMLDOMDocument2   *pDoc)
/*
    load xml policy data into az authorization store object
    PersistContext - Context describing the policy store
    IN: lPersistFlags, flags from the persist engine
    IN: pDoc, interface pointer to xml root node, document
*/
{
    HRESULT hr;
    IXMLDOMElement  *pAzStoreNode = NULL;

    AZASSERT(NULL != PersistContext &&
             NULL != pDoc);

    //init

    // get the root node, ie. the node of ploicy
    hr = myXmlGetAzStoreNode(pDoc, &pAzStoreNode);
    _JumpIfError(hr, error, "myXmlGetAzStoreNode");

    AZASSERT(NULL != pAzStoreNode);

    // start load AzAuthorizationStore object, this call invokes
    // recursively to load all AzAuthStore object children
    hr = myXmlLoadObject(
            PersistContext,
            PersistContext->hAzAuthorizationStore,
            OBJECT_TYPE_AZAUTHSTORE,
            lPersistFlags,
            TRUE,  //load all child objects
            FALSE, // we have to AzpeFinishObject later on AzAuthStore
            pAzStoreNode);
    _JumpIfError(hr, error, "myXmlLoadObject(AzAuthorizationStore)");

    //
    // On create, don't do this until AzPersistSubmit
    //
    if ( !fCreatePolicy ) {

        // now load AzAuthStore object policy acl
        hr = myXmlLoadAclsToAzStore(
                 PersistContext,
                 lPersistFlags,
                 FALSE );
        _JumpIfError(hr, error, "myXmlLoadAclsToAzStore");
    }

    hr = S_OK;
error:
    if (NULL != pAzStoreNode)
    {
        pAzStoreNode->Release();
    }
    XmlAzrolesInfo->AzpeObjectFinished( PersistContext->hAzAuthorizationStore, AzpHresultToWinStatus(hr) );
    return hr;
}

DWORD
XMLPersistWritable(
    IN PAZP_XML_CONTEXT XmlPersistContext
    )
{
    DWORD  dwErr = NO_ERROR;
    HANDLE    hFile = INVALID_HANDLE_VALUE;

    // init
    XmlPersistContext->IsWritable = FALSE;

    // xml is easy, all object writable depends on policy file permission

    hFile = CreateFile(
                XmlPersistContext->pwszPolicyUrl,
                GENERIC_WRITE,
                0, // not shared
                NULL,
                OPEN_EXISTING,
                0,
                NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        dwErr = GetLastError();
    }
    else
    {
        XmlPersistContext->IsWritable = TRUE;
    }

    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }
    return dwErr;
}

DWORD
XMLPersistTargetMachine(
    IN PCWSTR PolicyUrl,
    OUT PWSTR *ppwszTargetMachine OPTIONAL
    )
/*++
Routine Description
    Routine to determine the target machine name for account resolution
    based on the policy URL.

    For XML store, the target machine is the server (machine) name that
    the XML store is physically stored. If fail to get the machine name,
    the local machine (NULL) will be returned.

Arguments

    PolicyUrl   - the policy URL passed in

    ppwszTargetMachine - the output target machine name

Return Value

    NO_ERROR

--*/
{

    LPWSTR pszUNC = NULL;
    LPWSTR pszPath = (LPWSTR)PolicyUrl;
    BOOL bIsUNC = FALSE;
    DWORD WinStatus = NO_ERROR;
    PWSTR szServer=NULL;


    if ( PolicyUrl == NULL || ppwszTargetMachine == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppwszTargetMachine = NULL;

    if ( wcslen(PolicyUrl) <= 2 ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // determine if the URL is a UNC path first
    //
    if ( PolicyUrl[0] == L'\\' && PolicyUrl[1] == L'\\' ) {
        bIsUNC = TRUE;
    }

    if (!bIsUNC && PolicyUrl[1] != L':') {
        //
        // this is a relative path, which must be on the local machine
        // in which case *ppwszTargetMachine is set to NULL
        //
        return ERROR_SUCCESS;
    }

    if ( !bIsUNC ) {

        //
        // if it's a drive letter mapping
        // check to see if this is a remote path
        //
        WinStatus = myGetRemotePath(PolicyUrl, &pszUNC);

        if ( WinStatus == NO_ERROR ) {
            //
            // this is a valid network path
            //
            pszPath = pszUNC;

        } else {

            //
            // either this is not a network drive
            // or fail to resolve the connection
            // in either case, use the local machine as default
            // don't care the mount point much in this case since
            // the mount point and a local drive use the same server name
            //
            WinStatus = NO_ERROR;
            goto CleanUp;
        }
    }

    //
    // the path must be a UNC path when it gets here
    // get volume information related to the path (could be a mount point or DFS)
    //

    WCHAR szVolume[MAX_PATH];
    szVolume[0] = L'\0';

    myGetVolumeInfo(pszPath,
                  szVolume,
                  ARRAYLEN(szVolume));

    SafeAllocaAllocate( szServer, MAX_PATH*sizeof(WCHAR) );

    if ( szServer == NULL ) {

        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanUp;
    }

    //
    // get server name related to the volume
    //
    szServer[0] = L'\0';
    BOOL bIsDfs = IsDfsPath(szVolume, szServer, MAX_PATH);
    DWORD dwLen = 0;

    if ( bIsDfs ) {
        //
        // this is a DFS volume, server name is already stored in szServer
        //
        dwLen = (DWORD)wcslen(szServer);

    } else {
        //
        // not a DFS share, just use the server name in the UNC path
        //
        PWSTR pSlash = wcschr(&szVolume[2], L'\\');
        if (pSlash)
            dwLen = (ULONG)(pSlash - szVolume) - 2;
        else
            dwLen = (DWORD)wcslen(szVolume) - 2;

    }

    //
    // copy the target machine name
    //
    *ppwszTargetMachine = (PWSTR)XmlAzrolesInfo->AzpeAllocateMemory((dwLen+1)*sizeof(WCHAR));

    if ( *ppwszTargetMachine ) {

        wcsncpy(*ppwszTargetMachine,
                 bIsDfs? szServer : szVolume + 2,   // skip two backslashes
                 dwLen);

        (*ppwszTargetMachine)[dwLen] = L'\0';

    } else {

        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
    }

CleanUp:

    if ( szServer ) {

        SafeAllocaFree( szServer );

    }

    AzpFreeHeap(pszUNC);

    return WinStatus;

}


DWORD
WINAPI
XmlProviderInitialize(
    IN PAZPE_AZROLES_INFO AzrolesInfo,
    OUT PAZPE_PROVIDER_INFO *ProviderInfo
    )
/*++

Routine Description

    Routine to initialize the XML provider

Arguments

    AzrolesInfo - Specifies the interface to routines in azroles.dll

    ProviderInfo - Returns a pointer to the provider info for the provider

Return Value

    NO_ERROR - Provider was properly initialized
    ERROR_UNKNOWN_REVISION - AzrolesInfo is a version the provider doesn't support

--*/
{

    //
    // Ensure the azroles info is a version we understand
    //

    if ( AzrolesInfo->AzrolesInfoVersion < AZPE_AZROLES_INFO_VERSION_1 ) {
        return ERROR_UNKNOWN_REVISION;
    }

    XmlAzrolesInfo = AzrolesInfo;
    *ProviderInfo = &XmlProviderInfo;
    return NO_ERROR;
}


HRESULT
myXMLTestVersion (
    IXMLDOMDocument2 * pDoc
    )
/*++

Routine Description:

    This routine will determine if the major and minor version attributes
    persisted in the document is allows us to continue reading

Arguments:

    pDoc    - COM interface to the opened XML document

Return Value:

    S_OK - we can continue reading.

    AZ_HRESULT(ERROR_REVISION_MISMATCH) if we can't continue reading due to version mismatch

    Other HRESULT code

Note:

    Current implementation is that if the store is written by a azroles.dll of a
    newer major version than that of the current reading azroles.dll,
    then reading is not supported.

--*/
{
    CComPtr<IXMLDOMElement> srpDocElement;
    HRESULT hr = pDoc->get_documentElement(&srpDocElement);

    if (SUCCEEDED(hr))
    {
        CComVariant varMajVer;
        CComBSTR bstrMajVer(AZ_XML_TAG_ATTR_MAJOR_VERSION);

        if (bstrMajVer.m_str == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = srpDocElement->getAttribute(bstrMajVer, &varMajVer);
        }

        if (SUCCEEDED(hr) && varMajVer.vt == VT_BSTR)
        {
            VARIANT varMajVerInt;
            VariantInit(&varMajVerInt);

            hr = VariantChangeType(&varMajVerInt, &varMajVer, VARIANT_NOVALUEPROP, VT_UI4);

            //
            // If this variant is can't even convert to an integer, we will also consider
            // it a mismatch because other errors will be more misleading.
            //

            if ( FAILED(hr) || (varMajVerInt.ulVal > AzGlCurrAzRolesMajorVersion) )
            {
                hr = AZ_HRESULT(ERROR_REVISION_MISMATCH);
            }
            else
            {
                hr = S_OK;
            }
        }
        else if ( E_OUTOFMEMORY != hr )
        {
            //
            // Reading a BSTR out from the DOM node may fail. But we will
            // consider all failures except out-of-memory as a failure
            // of not having version numbers and thus a version mismatch error.
            //

            hr = AZ_HRESULT(ERROR_REVISION_MISMATCH);
        }
    }

    return hr;
}


DWORD
XMLPersistOpenEx(
    IN LPCWSTR PolicyUrl,
    IN PAZP_XML_CONTEXT OldXmlContext OPTIONAL,
    IN AZPE_OBJECT_HANDLE pAzAuthorizationStore,
    IN ULONG lPersistFlags,
    IN BOOL fCreatePolicy,
    OUT PAZPE_PERSIST_CONTEXT PersistContext OPTIONAL,
    OUT LPWSTR *pwszTargetMachine OPTIONAL
    )
/*++

Routine Description:

    This routine is shared betwen XMLPersistOpen and XMLPersistUpdateCache.

    This routine submits reads the authz policy database from storage.
    This routine also reads the policy database into cache.

    On Success, the caller should call XMLPersistClose to free any resources
        consumed by the open.

    On entry, AzAuthorizationStore->PersistCritSect must be locked.

Arguments:

    PolicyUrl - Specifies the location of the policy store

    OldXmlContext - On an AzUpdateCache, specifies the existing context

    pAzAuthorizationStore - Specifies the policy database that is to be read.

    lPersistFlags - lPersistFlags from the persist engine describing the operation
        AZPE_FLAGS_PERSIST_OPEN - Call is the original AzInitialize
        AZPE_FLAGS_PERSIST_UPDATE_CACHE - Call is an AzUpdateCache

    fCreatePolicy - TRUE if the policy database is to be created.
        FALSE if the policy database already exists

    PersistContext - On Success, returns a context that should be passed on all
        subsequent calls.
        The caller should call XMLPersistClose to free this context.
        This parameter is only returned for AzInitialize calls

    pwszTargetMachine - pointer to the target machine name where account resolution
                        should occur. This should be the machine where the ldap data
                        is stored.
Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    HRESULT  hr;
    AZP_XML_CONTEXT *pXMLPersistContext = NULL;
    ULONG PolicyUrlSize;
    WCHAR FullPathBuffer[MAX_PATH+1];
    ULONG FullPathLen;

    //
    // using CComVariant will allow us not to worry about
    // clearing the variant.
    //

    CComVariant    varParam;

    VARIANT_BOOL   varbLoad;
    BSTR             bstrEmptyPolicy = NULL;
    BOOL             fPolicyFileExists;

    DWORD dwErr;

    //
    // Get the full path name so that underlying components don't have to deal with
    //  relative path names
    //

    FullPathLen = GetFullPathName( PolicyUrl,
                             MAX_PATH+1,
                             FullPathBuffer,
                             NULL );

    if ( FullPathLen == 0 ) {
        AZ_HRESULT_LASTERROR(&hr);
        _JumpError(hr, error, "GetFullPathName");
    } else if ( FullPathLen > MAX_PATH ) {
        dwErr = ERROR_INVALID_NAME;
        _JumpIfWinError(dwErr, &hr, error, "GetFullPathName");
    }

    //
    // If this file is on a FAT file system, then we won't support it.
    //  And we won't to fail it early at the open stage.
    //

    dwErr = IsAclSupported( FullPathBuffer );

    if (dwErr != NO_ERROR)
    {
        _JumpIfWinError(dwErr, &hr, error, "XML stores on FAT file system are not supported");
    }

    PolicyUrl = FullPathBuffer;
    PolicyUrlSize = (FullPathLen+1) * sizeof(WCHAR);

    //
    // allocate a context describing this provider
    //

    pXMLPersistContext = (PAZP_XML_CONTEXT) AzpAllocateHeap(
                                       sizeof( *pXMLPersistContext ) + PolicyUrlSize,
                                       "XMCTXT" );

    _JumpIfOutOfMemory(&hr, error, pXMLPersistContext, "AzpAllocateHeap");

    ZeroMemory(pXMLPersistContext, sizeof(*pXMLPersistContext));

    pXMLPersistContext->hAzAuthorizationStore = pAzAuthorizationStore;

    //
    // Cache the PolicyUrl
    //

    pXMLPersistContext->pwszPolicyUrl = (LPWSTR)(pXMLPersistContext+1);

    RtlCopyMemory( (PVOID)pXMLPersistContext->pwszPolicyUrl,
                   PolicyUrl,
                   PolicyUrlSize );

    // create xml doc interface
    hr = CoCreateInstance(
            CLSID_DOMDocument,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IXMLDOMDocument2,
            (void**)&(pXMLPersistContext->pDoc));

    _JumpIfError(hr, error, "CoCreateInstance");

    // load xml store
    hr = pXMLPersistContext->pDoc->put_async(FALSE);
    _JumpIfError(hr, error, "pDoc->put_async");

    if (fCreatePolicy)
    {
        // only real open mode allows creating new store
        AZASSERT(AZPE_FLAGS_PERSIST_OPEN & lPersistFlags);

        // create a new policy

        // prevent creating new store if the file exists
        hr = myFileExist(pXMLPersistContext->pwszPolicyUrl, &fPolicyFileExists);
        _JumpIfError(hr, error, "myFileExist");

        if (fPolicyFileExists)
        {
            hr = AZ_HRESULT(ERROR_ALREADY_EXISTS);
            _JumpError(hr, error, "can't create new policy store if it exists");
        }

        bstrEmptyPolicy = SysAllocString(
            L"<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<AzAdminManager MajorVersion=\"1\" MinorVersion=\"0\">\n</AzAdminManager>");
        _JumpIfOutOfMemory(&hr, error, bstrEmptyPolicy, "SysAllocString");

        // load empty policy
        hr = pXMLPersistContext->pDoc->loadXML(
                    bstrEmptyPolicy,
                    &varbLoad);
        _JumpIfXmlError(hr, &hr, error, pXMLPersistContext->pDoc, "pDoc->loadXML")

        // Assume it is writable
        pXMLPersistContext->IsWritable = TRUE;
    }
    else
    {

        hr = myWszToBstrVariant(
                    pXMLPersistContext->pwszPolicyUrl,
                    &varParam);
        _JumpIfError(hr, error, "myWszToBstrVariant");

        // load doc object
        hr = pXMLPersistContext->pDoc->load(varParam, &varbLoad);
        // we want to get xml error code
        hr = myGetXmlError(hr, pXMLPersistContext->pDoc, NULL);
        if (0x800c0006 == hr)
        {
            // 0x800c0006, xml error,
            // The system cannot locate the object specified.
            // we want to map it file not found error
            hr = AZ_HRESULT(ERROR_FILE_NOT_FOUND);
        }
        _JumpIfError(hr, error, "pDoc->load")

        //
        // now we have loaded the XML document, we need to see
        // if the version of the document is what we can understand
        //

        hr = myXMLTestVersion(pXMLPersistContext->pDoc);

        _JumpIfError(hr, error, "myXMLReadTestVersion failed.");

        //
        // Determine if the file is writable.
        // We purposely ignore the return code in case the caller
        // doesn't have write access.
        //

        dwErr = XMLPersistWritable( pXMLPersistContext );
        if (NO_ERROR != dwErr)
        {
            AzPrint((AZD_XML, "XMLPersistWritable returns error code: %d", dwErr));
        }
        
        WIN32_FILE_ATTRIBUTE_DATA fad;

        //
        // We need the lastWrite filetime
        //
        
        if (GetFileAttributesEx(pXMLPersistContext->pwszPolicyUrl,
                                    GetFileExInfoStandard,
                                    &fad))
        {
            pXMLPersistContext->FTLastWrite = fad.ftLastWriteTime;
        }
        else
        {
            dwErr = GetLastError();
        }
    }
    
    //
    // Determine if the caller has security privilege
    //
    // For UpdateCache, the privilege is already known
    //
    if ( lPersistFlags & AZPE_FLAGS_PERSIST_UPDATE_CACHE ) {

        pXMLPersistContext->HasSecurityPrivilege = OldXmlContext->HasSecurityPrivilege;

    //
    // For Initialize, determine privilege by accessing the server
    //

    } else {

        dwErr = XmlCheckSecurityPrivilege( pXMLPersistContext->pwszPolicyUrl,
                                           fCreatePolicy );

        if ( dwErr == NO_ERROR ) {
            pXMLPersistContext->HasSecurityPrivilege = TRUE;
        } else if ( dwErr == ERROR_PRIVILEGE_NOT_HELD ) {
            pXMLPersistContext->HasSecurityPrivilege = FALSE;
        } else {
            _JumpIfWinError(dwErr, &hr, error, "XmlCheckSecurityPrivilege");
        }
    }


    //
    // Load the policy database
    //

    hr = myXmlLoadPolicyToAzAuthorizationStore(
             pXMLPersistContext,
             fCreatePolicy,
             lPersistFlags,
             pXMLPersistContext->pDoc);  //the current node in xml tree
    _JumpIfError(hr, error, "myXmlLoadPolicyToAzAuthorizationStore");

    //
    // On an UpdateCache,
    //  update the old context to contain the new doc instance
    //
    if (AZPE_FLAGS_PERSIST_UPDATE_CACHE & lPersistFlags)
    {
        IXMLDOMDocument2  *pTempDoc;

        pTempDoc = pXMLPersistContext->pDoc;
        pXMLPersistContext->pDoc = OldXmlContext->pDoc;
        OldXmlContext->pDoc = pTempDoc;

    //
    // On an Initialize,
    //  return the context to the caller.

    } else {

        // return the persist context to the caller
        *PersistContext = (AZPE_PERSIST_CONTEXT)pXMLPersistContext;
        pXMLPersistContext = NULL;

    }

    if ( pwszTargetMachine ) {
        //
        // detect the target machine name for this URL
        // if couldn't determine, default to local (NULL)
        // other errors such as out of memory will fail the function
        //

        dwErr = XMLPersistTargetMachine( PolicyUrl, pwszTargetMachine );

        _JumpIfWinError(dwErr, &hr, error, "XMLPersistTargetMachine");
    }

    hr = S_OK;
error:
    //free
    if (NULL != pXMLPersistContext)
    {
        if (NULL != pXMLPersistContext->pDoc)
        {
            pXMLPersistContext->pDoc->Release();
        }
        AzpFreeHeap(pXMLPersistContext);
    }
    if (NULL != bstrEmptyPolicy)
    {
        SysFreeString(bstrEmptyPolicy);
    }

    return AzpHresultToWinStatus( hr );
}

DWORD
XMLPersistOpen(
    IN LPCWSTR PolicyUrl,
    IN AZPE_OBJECT_HANDLE pAzAuthorizationStore,
    IN ULONG lPersistFlags,
    IN BOOL fCreatePolicy,
    OUT PAZPE_PERSIST_CONTEXT PersistContext,
    OUT LPWSTR *pwszTargetMachine
    )
/*++

Routine Description:

    This routine submits reads the authz policy database from storage.
    This routine also reads the policy database into cache.

    On Success, the caller should call XMLPersistClose to free any resources
        consumed by the open.

    On entry, AzAuthorizationStore->PersistCritSect must be locked.

Arguments:

    PolicyUrl - Specifies the location of the policy store

    pAzAuthorizationStore - Specifies the policy database that is to be read.

    lPersistFlags - lPersistFlags from the persist engine describing the operation
        AZPE_FLAGS_PERSIST_OPEN - Call is the original AzInitialize
        AZPE_FLAGS_PERSIST_UPDATE_CACHE - Call is an AzUpdateCache

    fCreatePolicy - TRUE if the policy database is to be created.
        FALSE if the policy database already exists

    PersistContext - On Success, returns a context that should be passed on all
        subsequent calls.
        The caller should call XMLPersistClose to free this context.

    pwszTargetMachine - pointer to the target machine name where account resolution
                        should occur. This should be the machine where the ldap data
                        is stored.
Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    AZASSERT(AZPE_FLAGS_PERSIST_OPEN & lPersistFlags);

    //
    // must be freed
    //

    LPWSTR pwszFilePolUrl = NULL;
    DWORD dwErr;

    // our persist layer has determined that this is an XML policy. That means the
    // URL must have the MSXML prefix and ':' following it.

    if (_wcsnicmp( AZ_XML_PROVIDER_NAME, PolicyUrl, AZ_XML_PROVIDER_NAME_LENGTH) == 0) {
        if (PolicyUrl[AZ_XML_PROVIDER_NAME_LENGTH] == L':')
        {
            PolicyUrl += AZ_XML_PROVIDER_NAME_LENGTH;
        }
        else
        {
            // this shouldn't have happened

            AZASSERT(FALSE);
            dwErr = ERROR_INVALID_NAME;
            _JumpError(dwErr, error, "Improper MSXML URL");
        }
    }
    else
    {
        // this shouldn't have happened
        AZASSERT(FALSE);
        dwErr = ERROR_INVALID_NAME;
        _JumpError(dwErr, error, "XML provider is invoked without proper MSXML prefix");
    }

    // we will prefix the policy url using file: so that we can rely on file: protocol
    // to handle the validity or the url.

    LPCWSTR wchFileUrl = L"file";

    SafeAllocaAllocate(pwszFilePolUrl, ( wcslen(wchFileUrl) + wcslen(PolicyUrl) + 1) * sizeof(WCHAR) );

    if (pwszFilePolUrl == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        _JumpError(dwErr, error, "SafeAllocaAllocate");
    }

    memcpy(pwszFilePolUrl, wchFileUrl, wcslen(wchFileUrl) * sizeof(WCHAR));
    memcpy(pwszFilePolUrl + wcslen(wchFileUrl), PolicyUrl, (wcslen(PolicyUrl) + 1) * sizeof(WCHAR));

    WCHAR wszDosPath[MAX_PATH + 1];
    DWORD dwPathLen = MAX_PATH + 1;

    //
    // PathCreateFromUrl will convert a file protocol URL (file:///<path>) to a dos path
    // There are several gotchas:
    //  (1) A wellformed file URL should use 3 slashes, not 2.
    //  (2) However, as far as the path portion has no encodings, two slashes will work.
    //  (3) If you want to use encoding, then you have to use "msxml:///<path>" with 3 slashes!
    //

    dwErr = AzpHresultToWinStatus(PathCreateFromUrl(pwszFilePolUrl, wszDosPath, &dwPathLen, 0));
    if (dwErr != NO_ERROR)
    {
        if (dwPathLen > MAX_PATH + 1)
        {
            dwErr = ERROR_INVALID_NAME;
        }
        _JumpError(dwErr, error, "PathCreateFromUrl");
    }
    else if (dwPathLen == 0)
    {
        dwErr = ERROR_INVALID_NAME;
        _JumpError(dwErr, error, "PathCreateFromUrl");
    }

    //
    // Call the worker routine
    //

    dwErr = XMLPersistOpenEx(wszDosPath,
                             NULL,  // No old context
                             pAzAuthorizationStore,
                             lPersistFlags,
                             fCreatePolicy,
                             PersistContext,
                             pwszTargetMachine );

error:

    if (pwszFilePolUrl != NULL)
    {
        SafeAllocaFree(pwszFilePolUrl);
    }

    return dwErr;
}

DWORD
XMLPersistUpdateCache(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN ULONG lPersistFlags,
    OUT ULONG * pulUpdatedFlag
    )
/*++

Routine Description:

    This routine updates the cache to reflect the current contents of the
    policy database.

    On entry, AzAuthorizationStore->PersistCritSect must be locked.

Arguments:

    PersistContext - Specifies the policy database that is to be closed

    lPersistFlags - lPersistFlags from the persist engine describing the operation
        AZPE_FLAGS_PERSIST_UPDATE_CACHE - Call is an AzUpdateCache
        
    pulUpdatedFlag - Passing back information whether the function call has truly
                    caused an update. Due to possible efficient updateCache
                    implementation by providers, it may decide to do nothing.
                    Currently, we only one bit (AZPE_FLAG_CACHE_UPDATE_STORE_LEVEL) to
                    indicate that the update is actually carried out.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    AZP_XML_CONTEXT *pXMLPersistContext = (AZP_XML_CONTEXT *)PersistContext;

    //
    // Call the worker routine
    //

    AZASSERT(AZPE_FLAGS_PERSIST_UPDATE_CACHE & lPersistFlags);
    AZASSERT( pXMLPersistContext != NULL );
    AZASSERT( pulUpdatedFlag != NULL );
    
    //
    // assume no update at all
    //
    
    *pulUpdatedFlag = 0;
    
    BOOL bNeedUpdate;
    
    DWORD dwStatus = myXmlStoreHasUpdate(pXMLPersistContext, &bNeedUpdate);
    
    if (dwStatus != NO_ERROR)
    {
        _JumpError(dwStatus, error, "myXmlStoreHasUpdate");
    }
    else if (bNeedUpdate)
    {
        dwStatus = XMLPersistOpenEx( pXMLPersistContext->pwszPolicyUrl,
                             pXMLPersistContext,
                             pXMLPersistContext->hAzAuthorizationStore,
                             lPersistFlags,
                             FALSE, // Don't create the store
                             NULL,
                             NULL ); // Don't return a new persist context
        
        if (NO_ERROR == dwStatus)
        {
            *pulUpdatedFlag = AZPE_FLAG_CACHE_UPDATE_STORE_LEVEL;
        }
    }

error:

    return dwStatus;
}


VOID
XMLPersistClose(
    IN AZPE_PERSIST_CONTEXT PersistContext
    )
/*++

Routine Description:

    This routine submits close the authz policy database storage handles.

    On entry, AzAuthorizationStore->PersistCritSect must be locked.

Arguments:

    PersistContext - Specifies the policy database that is to be closed

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    AZP_XML_CONTEXT *pPersistContext = (AZP_XML_CONTEXT *)PersistContext;
    AZASSERT(pPersistContext != NULL);

    // release xml doc

    pPersistContext->pDoc->Release();

    // free the context itself

    AzpFreeHeap(pPersistContext);
}


DWORD
XMLPersistDelete(
    IN LPCWSTR PolicyUrl)
{
    DWORD  dwErr = NO_ERROR;

    AZASSERT(NULL != PolicyUrl);

    // delete xml store is simple
    if (!DeleteFile( PolicyUrl))
    {
        dwErr = GetLastError();
    }

    return dwErr;
}


//
// implementation of updating xml store from az objects
//


HRESULT
myXmlGetNodeByAttribute(
    IN  LPCWSTR           pwszAtt,
    IN  LPCWSTR           pwszValue,
    IN  IXMLDOMNodeList  *pNodeList,
    OUT IXMLDOMNode     **ppNode)
/*
    find a node from a node list matching by given attribute's value.
    IN: pwszAtt, the name of the attribute on which the lookup will be based on.
    IN: pwszValue, the value of the attribute which we are looking for.
    IN: pNodeList, interface pointer to a list of nodes
    OUT: ppNode, the matched node
*/
{
    HRESULT  hr;
    LONG     lLength;
    LONG     i;
    IXMLDOMNode    *pNode = NULL;
    WCHAR          *pwszXmlAttrValue = NULL;

    AZASSERT(NULL != pwszAtt &&
             NULL != pwszValue && 
             NULL != pNodeList &&
             NULL != ppNode);

    // init
    *ppNode = NULL;

    // get length of the list
    hr = pNodeList->get_length(&lLength);
    _JumpIfError(hr, error, "pNodeList->get_length");

    if (0 == lLength)
    {
        // not found anything
        hr = AZ_HRESULT(ERROR_NOT_FOUND);
        _JumpError(hr, error, "not found any node children");
    }

    // go through the list and retrieve guid attribute
    for (i = 0; i < lLength; ++i)
    {
        hr = pNodeList->get_item(i, &pNode);
        _JumpIfError(hr, error, "pNodeList->get_item");

        AZASSERT(NULL != pNode);

        // get guid attribute value
        hr = myXmlGetNodeAttribute(
                pNode,
                pwszAtt,
                &pwszXmlAttrValue);
        _JumpIfError(hr, error, "myXmlGetNodeAttribute(guid)");

        // see if match, use case sensitive comp
        if (0 == _wcsicmp(pwszValue, pwszXmlAttrValue))
        {
            // ok, this is the node, return
            *ppNode = pNode;
            pNode = NULL;
            break;
        }
        
  // free for next in loop
        pNode->Release();
        pNode = NULL;
        AzpFreeHeap(pwszXmlAttrValue);
        pwszXmlAttrValue = NULL;
    }

    if (NULL == *ppNode)
    {
        hr = AZ_HRESULT(ERROR_NOT_FOUND);
        _JumpError(hr, error, "not found matched node");
    }

    hr = S_OK;
error:
    if (NULL != pNode)
    {
        pNode->Release();
    }
    if (NULL != pwszXmlAttrValue)
    {
        AzpFreeHeap(pwszXmlAttrValue);
    }

    return hr;
}

HRESULT
myXmlGetNodeListByXPath(
    IN   IXMLDOMDocument2     *pDoc,
    IN   WCHAR const          *pwszQuery,
    OUT  IXMLDOMNodeList     **ppList)
{
    HRESULT  hr;
    BSTR      bstrQuery = NULL;
    BSTR      bstrSelectionLanguage = NULL;
    BOOL      fChangedSL = FALSE;
    IXMLDOMNodeList     *pList = NULL;

    VARIANT   varDefSelectionLanguage;
    VARIANT   varSelectionLanguage;
    VARIANT   varXPath;

    AZASSERT(NULL != pDoc &&
             NULL != pwszQuery &&
             0x0 != pwszQuery[0] &&
             NULL != ppList);

    //init
    VariantInit(&varDefSelectionLanguage);
    VariantInit(&varSelectionLanguage);
    VariantInit(&varXPath);

    // convert query to bstr
    bstrQuery = SysAllocString(pwszQuery);
    _JumpIfOutOfMemory(&hr, error, bstrQuery, "SysAllocString");

    bstrSelectionLanguage = SysAllocString(AZ_XML_SELECTION_LANGUAGE);
    _JumpIfOutOfMemory(&hr, error, bstrSelectionLanguage, "SysAllocString");

    // get default selection language
    hr = pDoc->getProperty(
            bstrSelectionLanguage,
            &varDefSelectionLanguage);
    _JumpIfError(hr, error, "pDoc->getProperty(SelectionLanguage)");
    AzPrint((AZD_XML, "default SelectionLanguage=%ws\n", V_BSTR(&varDefSelectionLanguage)));

    hr = myWszToBstrVariant(
                    AZ_XML_XPATH,
                    &varXPath);
    _JumpIfError(hr, error, "myWszToBstrVariant");

    // change selection language to xpath
    hr = pDoc->setProperty(
                    bstrSelectionLanguage,
                    varXPath);
    _JumpIfError(hr, error, "pDoc->setProperty(SelectionLanguage)");
    fChangedSL = TRUE;

    // now looking for all nodes that match the xpath pattern
    hr = pDoc->selectNodes(
                bstrQuery,
                &pList);
    _JumpIfError(hr, error, "pDoc->selectNodes");

    AZASSERT(NULL != pList);

    //return
    *ppList = pList;
    pList = NULL;

    hr = S_OK;
error:
    // keep the following as the 1st
    if (fChangedSL)
    {
        HRESULT hr2;
        // restore the original Selection Language
        hr2 = pDoc->setProperty(
                bstrSelectionLanguage,
                varDefSelectionLanguage);
        _PrintIfError(hr2, "pDoc->getProperty(SelectionLanguage)");
    }

    if (NULL != bstrQuery)
    {
        SysFreeString(bstrQuery);
    }
    if (NULL != bstrSelectionLanguage)
    {
        SysFreeString(bstrSelectionLanguage);
    }
    if (NULL != pList)
    {
        pList->Release();
    }

    VariantClear(&varDefSelectionLanguage);
    VariantClear(&varSelectionLanguage);
    VariantClear(&varXPath);

    return hr;
}

HRESULT
myXmlRemoveAllLinks(
    IN   IXMLDOMDocument2     *pDoc,
    IN   WCHAR const          *pwszLinkTag,
    IN   GUID                 *pGuid)
{
    HRESULT  hr;
    WCHAR    *pwszGuid = NULL;
    WCHAR    *pwszQuery = NULL;
    IXMLDOMNodeList     *pList = NULL;
    IXMLDOMNode         *pNode = NULL;
    IXMLDOMNode         *pParentNode = NULL;
    LONG                 lLength;
    LONG                 i;

    AZASSERT(NULL != pGuid &&
             NULL != pDoc &&
             NULL != pwszLinkTag);

    //init

    // convert guid to string guid to form xpath query
    hr = UuidToString(pGuid, &pwszGuid);
    _JumpIfError(hr, error, "UuidToString");

    // query is in a pattern of //LinkTag[.="guid"]
    // for example, query OperationLink,
    // //OperationLink[.="25a63179-3663-4aa7-b0b8-48ca084d0747"]
    // in which "//[.=""]" has 8 chars
    pwszQuery = (WCHAR*)AzpAllocateHeap(
        (wcslen(pwszLinkTag) + wcslen(pwszGuid) + 9) * sizeof(WCHAR), "XMQRY" );

    _JumpIfOutOfMemory(&hr, error, pwszQuery, "AzpAllocateHeap");

    wsprintf(pwszQuery, L"//%s[.=\"%s\"]", pwszLinkTag, pwszGuid);
    AzPrint((AZD_XML, "XPath query(link delete)=%ws\n", pwszQuery));

    hr = myXmlGetNodeListByXPath(
                pDoc,
                pwszQuery,
                &pList);
    _JumpIfError(hr, error, "myXmlGetNodeListByXPath");

    // get length of the list
    hr = pList->get_length(&lLength);
    _JumpIfError(hr, error, "pList->get_length");

    if (0 < lLength)
    {
        // delete all of them because linked node is gone
        for (i = 0; i < lLength; ++i)
        {
            hr = pList->get_item(i, &pNode);
            _JumpIfError(hr, error, "pList->get_item");

            AZASSERT(NULL != pNode);

            // get parent
            hr = pNode->get_parentNode(&pParentNode);
            _JumpIfError(hr, error, "pNode->get_ParentNode");

            AZASSERT(NULL != pParentNode);

            // now delete the node
            hr = pParentNode->removeChild(
                    pNode,
                    NULL); //no return needed
            _JumpIfError(hr, error, "pParentNode->removeChild");

            // free for the next
            pNode->Release();
            pNode = NULL;
            pParentNode->Release();
            pParentNode = NULL;
        }
    }

    hr = S_OK;
error:
    if (NULL != pwszGuid)
    {
        RpcStringFree(&pwszGuid);
    }
    if (NULL != pwszQuery)
    {
        AzpFreeHeap(pwszQuery);
    }
    if (NULL != pNode)
    {
        pNode->Release();
    }
    if (NULL != pParentNode)
    {
        pParentNode->Release();
    }
    if (NULL != pList)
    {
        pList->Release();
    }

    return hr;
}


HRESULT
myXmlDeleteElement(
    IN IXMLDOMNode       *pParentNode,
    IN WCHAR const       *pwszElementTag,
    IN WCHAR const       *pwszElementData)
/*
Description:
    delete a element from the node
Argument:
    pDoc - doc root handle
    pParentNode - node handle of the parent of the element
    pwszElementTag - element tag
    pwszElementData - element data
Return:
*/
{
    HRESULT  hr;
    BSTR         bstrElementTag = NULL;
    BSTR         bstrElementData = NULL;
    IXMLDOMNodeList    *pNodeList = NULL;
    IXMLDOMNode        *pNode = NULL;
    LONG                lLength;
    LONG                i;


    // let's find the element first

    // convert to bstr
    bstrElementTag= SysAllocString(pwszElementTag);
    _JumpIfOutOfMemory(&hr, error, bstrElementTag, "SysAllocString");

    // get all matched nodes, should be just one though
    hr = pParentNode->selectNodes(
                bstrElementTag,
                &pNodeList);
    _JumpIfError(hr, error, "pParentNode->selectNodes");

    // get length
    hr = pNodeList->get_length(&lLength);
    _JumpIfError(hr, error, "pNodeList->get_length");

    for (i = 0; i < lLength; ++i)
    {
        // get the node handle
        hr = pNodeList->get_item(i, &pNode);
        _JumpIfError(hr, error, "pNodeList->get_item");

        // get element text
        hr = pNode->get_text(&bstrElementData);
        _JumpIfError(hr, error, "pNode->get_text");

        // use case insensitive compare because
        // all links are guid or sid, hex number is case insesitive
        if (0 == _wcsicmp(pwszElementData, bstrElementData))
        {
            // found it
            hr = pParentNode->removeChild(pNode, NULL);
            _JumpIfError(hr, error, "pParentNode->removeChild");
            //done, out for loop
            goto done;
        }
        // free for next
        pNode->Release();
        pNode = NULL;
        SysFreeString(bstrElementData);
        bstrElementData = NULL;
    }

    // if not found, error?
    AzPrint((AZD_XML, "Not found %s under tag %ws\n", pwszElementData));

done:
    hr = S_OK;
error:
    if (NULL != pNodeList)
    {
        pNodeList->Release();
    }
    if (NULL != pNode)
    {
        pNode->Release();
    }
    if (NULL != bstrElementTag)
    {
        SysFreeString(bstrElementTag);
    }
    if (NULL != bstrElementData)
    {
        SysFreeString(bstrElementData);
    }

    return hr;
}


HRESULT
myXmlAddElement(
    IN IXMLDOMDocument2  *pDoc,
    IN IXMLDOMNode       *pParentNode,
    IN WCHAR const       *pwszElementTag,
    IN WCHAR const       *pwszElementData)
/*
Description:
    add a new element and set data
Argument:
    pDoc - doc root handle
    pParentNode - node handle of the parent of the element
    pwszElementTag - element tag
    pwszElementData - element data
Return:
*/
{
    HRESULT  hr;
    IXMLDOMNode *pDocElementNode = NULL;
    BSTR         bstrElementTag = NULL;
    BSTR         bstrElementData = NULL;

    // convert tag to bstr
    bstrElementTag = SysAllocString(pwszElementTag);
    _JumpIfOutOfMemory(&hr, error, bstrElementTag, "SysAllocString");

    // create new empty element node
    hr = pDoc->createElement(
                bstrElementTag,
                (IXMLDOMElement**)&pDocElementNode);
    _JumpIfError(hr, error, "pDoc->createElement");

    AZASSERT(NULL != pDocElementNode);

    // convert element value to bstr
    bstrElementData = SysAllocString(pwszElementData);
    _JumpIfOutOfMemory(&hr, error, bstrElementData, "SysAllocString");

    // now let's set member value
    hr = pDocElementNode->put_text(bstrElementData);
    _JumpIfError(hr, error, "pDocElementNode->put_text");

    // attach to the right parent
    hr = pParentNode->appendChild(
                    pDocElementNode,
                    NULL); //don't need return
    _JumpIfError(hr, error, "pParentNode->appendChild");

    hr = S_OK;
error:
    if (NULL != pDocElementNode)
    {
        pDocElementNode->Release();
    }
    if (NULL != bstrElementTag)
    {
        SysFreeString(bstrElementTag);
    }
    if (NULL != bstrElementData)
    {
        SysFreeString(bstrElementData);
    }

    return hr;
}

HRESULT
myXmlUpdateSingleElement(
    IN IXMLDOMDocument2  *pDoc,
    IN IXMLDOMNode       *pParentNode,
    IN WCHAR const       *pwszElementTag,
    IN WCHAR const       *pwszElementData)
/*
Description:
    if named element tag exists, update with new data
    otherwise create a new element with the data
Arguments:
    pDoc - doc root handle
    pParentNode - node handle of the parent of the element
    pwszElementTag - element tag
    pwszElementData - element data
Return:
*/
{
    HRESULT  hr;
    BSTR                bstrElementTag = NULL;
    BSTR                bstrElementData = NULL;
    IXMLDOMNodeList    *pNodeList = NULL;
    IXMLDOMNode        *pNode = NULL;
    LONG                lLength;

    AZASSERT(NULL != pDoc &&
             NULL != pParentNode &&
             NULL != pwszElementTag &&
             NULL != pwszElementData);

    // let's find the element first

    // convert to bstr
    bstrElementTag= SysAllocString(pwszElementTag);
    _JumpIfOutOfMemory(&hr, error, bstrElementTag, "SysAllocString");

    // get all matched nodes, should be just one though
    hr = pParentNode->selectNodes(
                bstrElementTag,
                &pNodeList);
    _JumpIfError(hr, error, "pParentNode->selectNodes");

    AZASSERT(NULL != pNodeList);

    // get length
    hr = pNodeList->get_length(&lLength);
    _JumpIfError(hr, error, "pNodeList->get_length");

    if (1 < lLength)
    {
        // should be single occurence
        hr = E_INVALIDARG;
        _JumpError(hr, error, "invalid mutliple occurence");
    }

    if (1 == lLength)
    {
        // get node to do update
        hr = pNodeList->get_item(0, &pNode);
        _JumpIfError(hr, error, "pNodeList->get_item");

        if (_wcsicmp(pwszElementTag, AZ_XML_TAG_BIZRULE) == 0 &&
            (pwszElementData == NULL || wcslen(pwszElementData) == 0) )
        {
            //
            // For BizRule, an empty string means that we will remove
            // this element. Leaving this element will mean that this is a
            // blank BizRule, which is quite different as no BizRule
            //
            
            hr = pParentNode->removeChild(pNode, NULL);
        }
        else
        {
            // convert to bstr
            bstrElementData= SysAllocString(pwszElementData);
            _JumpIfOutOfMemory(&hr, error, bstrElementData, "SysAllocString");

            hr = pNode->put_text(bstrElementData);
            _JumpIfError(hr, error, "pNode->put_text");
        }
    }
    else
    {
        //must not existing
        AZASSERT(0 == lLength);

        hr = myXmlAddElement(
                    pDoc,
                    pParentNode,
                    pwszElementTag,
                    pwszElementData);
        _JumpIfError(hr, error, "myXmlAddElement");
    }

    hr = S_OK;
error:
    if (NULL != pNodeList)
    {
        pNodeList->Release();
    }
    if (NULL != pNode)
    {
        pNode->Release();
    }
    if (NULL != bstrElementTag)
    {
        SysFreeString(bstrElementTag);
    }
    if (NULL != bstrElementData)
    {
        SysFreeString(bstrElementData);
    }

    return hr;
}

#if DBG
void myDbgPrintDeltaEntry (PAZP_DELTA_ENTRY DeltaEntry)
{
    AzPrint((AZD_XML, "DeltaFlags=0x%x\n", DeltaEntry->DeltaFlags));
    if ((DeltaEntry->DeltaFlags & AZP_DELTA_SID) == 0)
    {
        AzpDumpGuid(AZD_XML, &DeltaEntry->Guid );
        AzPrint(( AZD_XML, "\n" ));
    }
    else
    {
        char *pszSid = NULL;
        if (ConvertSidToStringSidA(DeltaEntry->Sid, &pszSid))
        {
            AzPrint((AZD_XML, "Sid=%s\n", pszSid));
            LocalFree(pszSid);
        }
    }
}
#endif //DBG


HRESULT
myXmlSubmitObjectElements(
    IN IXMLDOMDocument2   *pDoc,
    IN ULONG              lPersistFlags,
    IN IXMLDOMNode       *pParentNode,
    IN WCHAR const       *pwszElementTag,
    IN ENUM_AZ_DATATYPE   DataType,
    IN AZPE_OBJECT_HANDLE hObject,
    IN ULONG              lPropertyId)
/*
Description:
    update all element data under a node
    all element data are retrieved from az object GetProperty method
Arguments:
    pDoc - root node for creation
    lPersistFlags - flags from the persist engine
    pParentNode - az object node under which the elements are updated
    DataType - ENUM_AZ_ data type, it handles long, str, str/sid array
    hObject - az object handle
    lPropertyId - property id for GetProperty
Return:
*/
{
    HRESULT hr;
    DWORD   dwErr;

    PVOID             pElements = NULL;
    WCHAR             wszId[20];
    BOOL              fSid = FALSE;
    BOOL              fGuid = FALSE;
    BOOL              fList = FALSE;
    ULONG             i;
    PAZP_DELTA_ENTRY  DeltaEntry;
    WCHAR       *pwszElementData;
    WCHAR       *pwszSid = NULL;
    WCHAR       *pwszGuid = NULL;

    ULONG DeltaArrayCount;
    PAZP_DELTA_ENTRY *DeltaArray;


    AZASSERT(NULL != pDoc &&
             NULL != pParentNode &&
             NULL != pwszElementTag &&
             NULL != hObject);

    //init


    // handle different type of elements

    switch (DataType)
    {
        case ENUM_AZ_BSTR:
            dwErr = XmlAzrolesInfo->AzpeGetProperty(
                        hObject,
                        lPersistFlags,
                        lPropertyId,
                        &pElements);
            _JumpIfWinError(dwErr, &hr, error, "AzpeGetProperty");

            AZASSERT(NULL != pElements);

            hr = myXmlUpdateSingleElement(
                        pDoc,
                        pParentNode,
                        pwszElementTag,
                        (WCHAR*)pElements);
            _JumpIfError(hr, error, "myXmlUpdateSingleElement(ENUM_AZ_BSTR)");
        break;

        case ENUM_AZ_LONG:
            dwErr = XmlAzrolesInfo->AzpeGetProperty(
                        hObject,
                        lPersistFlags,
                        lPropertyId,
                        &pElements);
            _JumpIfWinError(dwErr, &hr, error, "AzpeGetProperty");

            AZASSERT(NULL != pElements);

            wsprintf(wszId, L"%d", *((LONG*)pElements));
            hr = myXmlUpdateSingleElement(
                        pDoc,
                        pParentNode,
                        pwszElementTag,
                        wszId);
            _JumpIfError(hr, error, "myXmlUpdateSingleElement(ENUM_AZ_LONG)");
        break;

        case ENUM_AZ_SID_ARRAY:
            fSid = TRUE;
            fList = TRUE;
        break;

        case ENUM_AZ_GUID_ARRAY:
            fGuid = TRUE;
            fList = TRUE;
        break;

        default:
            hr = E_INVALIDARG;
            _JumpError(hr, error, "internal error: invalid data type");
    }

    if (fList)
    {

        dwErr = XmlAzrolesInfo->AzpeGetDeltaArray(
                    hObject,
                    lPropertyId,
                    &DeltaArrayCount,
                    &DeltaArray );
        _JumpIfWinError(dwErr, &hr, error, "AzpeGetDeltaArray");

        for (i = 0; i < DeltaArrayCount; ++i)
        {
            // get delta entry
            DeltaEntry = DeltaArray[i];

#if DBG
            myDbgPrintDeltaEntry(DeltaEntry);
#endif //DBG

            // convert linked object id to string
            if (fSid)
            {
                AZASSERT(0x0 != (AZP_DELTA_SID & DeltaEntry->DeltaFlags));

                // convert sid to string sid
                if (!ConvertSidToStringSid(
                            DeltaEntry->Sid,
                            &pwszSid))
                {
                    AZ_HRESULT_LASTERROR(&hr);
                    _JumpError(hr, error, "ConvertSidToStringSid");
                }

                AZASSERT(NULL != pwszSid);

                pwszElementData = pwszSid;
            }
            else
            {
                //must be guid
                AZASSERT(fGuid);

                hr = UuidToString(
                        &DeltaEntry->Guid,
                        &pwszGuid);
                _JumpIfError(hr, error, "UuidToString");

                AZASSERT(NULL != pwszGuid);

                pwszElementData = pwszGuid;
            }

            if (0x0 != (AZP_DELTA_ADD & DeltaEntry->DeltaFlags))
            {
                // this is add case

                hr = myXmlAddElement(
                            pDoc,
                            pParentNode,
                            pwszElementTag,
                            pwszElementData);
                _JumpIfError(hr, error, "myXmlAddElement");
            }
            else
            {
                // this is delete case

                hr = myXmlDeleteElement(
                            pParentNode,
                            pwszElementTag,
                            pwszElementData);
                _JumpIfError(hr, error, "myXmlDeleteElement");

            }
            // free for next in loop
            if (fSid)
            {
                AZASSERT(NULL != pwszSid);
                LocalFree(pwszSid);
                pwszSid = NULL;
            }
            else if (fGuid)
            {
                AZASSERT(NULL != pwszGuid);
                RpcStringFree(&pwszGuid);
                pwszGuid = NULL;
            }
        }
    }

    hr = S_OK;
error:
    if (NULL != pElements)
    {
        XmlAzrolesInfo->AzpeFreeMemory(pElements);
    }
    if (NULL != pwszSid)
    {
        LocalFree(pwszSid);
    }
    if (NULL != pwszGuid)
    {
        RpcStringFree(&pwszGuid);
    }
    return hr;

}


HRESULT
myXmlFindChildNodeByGuid(
    IN  IXMLDOMNode   *pParentNode,
    IN  WCHAR const   *pwszChildTag,
    IN  GUID          *pGuid,
    OUT IXMLDOMNode  **ppChildNode)
/*
    find a child node by matched guid attribute
    IN: pParentNode, parent node from which to do searching
    IN: pwszChildTag, node tag for searching
    IN: pGuid, guid for attribute matching
    OUT: ppChildNode, return node
*/
{
    HRESULT  hr;
    BSTR                 bstrChildTag = NULL;
    IXMLDOMNode         *pChildNode = NULL;
    IXMLDOMNodeList     *pChildList = NULL;
    
    PWSTR pwszGuid = NULL;

    AZASSERT(NULL != pParentNode &&
             NULL != pwszChildTag &&
             NULL != pGuid &&
             NULL != ppChildNode);

    // create child tag in bstr any way
    bstrChildTag = SysAllocString(pwszChildTag);
    _JumpIfOutOfMemory(&hr, error, bstrChildTag, "SysAllocString");

    // get list of all children
    hr = pParentNode->selectNodes(
                    bstrChildTag,
                    &pChildList);
    _JumpIfError(hr, error, "pParentNode->selectNodes");

    AZASSERT(NULL != pChildList);

    // ok, find the child node by guid
    
    hr = UuidToString(pGuid, &pwszGuid);
    _JumpIfError(hr, error, "UuidToString");
    
    hr = myXmlGetNodeByAttribute(
                    AZ_XML_TAG_ATTR_GUID,
                    pwszGuid,
                    pChildList,
                    &pChildNode);
    _JumpIfError(hr, error, "myXmlGetNamedGuidNode");

    *ppChildNode = pChildNode;
    pChildNode = NULL;

    hr = S_OK;
error:
    if (NULL != bstrChildTag)
    {
        SysFreeString(bstrChildTag);
    }
    if (NULL != pChildList)
    {
        pChildList->Release();
    }
    if (NULL != pChildNode)
    {
        pChildNode->Release();
    }

    if (NULL != pwszGuid)
    {
        RpcStringFree(&pwszGuid);
    }
    
    return hr;
}


HRESULT
myXmlDetermineParentNode(
    IN           IXMLDOMNode     *pAzStoreNode,
    IN           ULONG            lObjectType,
    IN OPTIONAL  GUID            *pApplicationGuid,
    IN OPTIONAL  GUID            *pScopeGuid,
    OUT          IXMLDOMNode    **ppParentNode)
/*
Description:
    determines the parent node of the current object.
    if both pApplicationGuid and pScopeGuid are NULL,
        the parent node is pAzStoreNode.
    if pApplicationGuid != NULL and pScopeGuid == NULL,
        the parent node is application queried by the guid.
    if pApplicationGuid != NULL and pScopeGuid != NULL,
        the parent node is scope queried by the both guids.
Arguments:
    pAzStoreNode - top parent node
    lObjectType - object type flag
    pApplicationGuid - the application guid under which the object lives
    pScopeGuid - the scope guid under which the object lives
Return:
    ppParentNode - returned parent node, freed by Release().
*/
{
    HRESULT  hr;
    IXMLDOMNode    *pApplicationNode = NULL;
    IXMLDOMNode    *pScopeNode = NULL;

    AZASSERT(NULL != pAzStoreNode &&
             NULL != ppParentNode);

    // init, it can be NULL if parent is AzAuthStore
    *ppParentNode = NULL;

    // determine parent

    if (NULL != pApplicationGuid &&
        OBJECT_TYPE_APPLICATION != lObjectType)
    {
        hr = myXmlFindChildNodeByGuid(
                    pAzStoreNode,
                    AZ_XML_TAG_APPLICATION,
                    pApplicationGuid,
                    &pApplicationNode);
        _JumpIfError(hr ,error, "myXmlFindChildNodeByGuid");

        AZASSERT(NULL != pApplicationNode);

        if (NULL == pScopeGuid || OBJECT_TYPE_SCOPE == lObjectType)
        {
            // parent must be application
            *ppParentNode = pApplicationNode;
            // for return
            pApplicationNode = NULL;
        }
        else
        {
            // should be scope
            hr = myXmlFindChildNodeByGuid(
                        pApplicationNode,
                        AZ_XML_TAG_SCOPE,
                        pScopeGuid,
                        &pScopeNode);
            _JumpIfError(hr ,error, "myXmlFindChildNodeByGuid");

            // oh, change parent to scope
            *ppParentNode = pScopeNode;
            // for return
            pScopeNode = NULL;
        }
    }

    hr = S_OK;
error:
    if (NULL != pApplicationNode)
    {
        pApplicationNode->Release();
    }
    if (NULL != pScopeNode)
    {
        pScopeNode->Release();
    }
    return hr;
}

HRESULT
myXmlSubmitObject(
    IN    IXMLDOMDocument2 *pDoc,
    IN    ULONG             lPersistFlags,
    IN    IXMLDOMNode      *pAzStoreNode,
    IN    GUID             *pApplicationGuid,
    IN    GUID             *pScopeGuid,
    IN    AZPE_OBJECT_HANDLE hObject,
    IN    ULONG             lObjectType,
    IN    BOOL              fDelete)
/*
Description:
    submit a group object into persist store
Arguments:
    pDoc - root of the doc for any creation
    lPersistFlags - flags from the persist engine
    pAzStoreNode - AzAuthStore node handle
    pApplicationGuid - application guid attribute,
        if NULL, the object is under AzAuthStore. if !NULL and pScopeGuid is NULL
        the object is under application
    pScopeGuid - scope guid attribute, if !NULL and pApplicationGuid !NULL,
        the object is under scope
    hObject - az object handle
    lObjectType - object index in the submit table
    fDelete - TRUE will delete the object
Return:
*/
{
    HRESULT  hr;

    IXMLDOMNode  *pParentTemp = NULL;
    IXMLDOMNode  *pParentNode;
    BSTR                 bstrObjectTag = NULL;
    IXMLDOMNode         *pObjectNode = NULL;
    IXMLDOMNodeList     *pObjectList = NULL;
    IXMLDOMNode         *pDocObjectNode = NULL;
    WCHAR               *pwszGuid = NULL;
    BOOL                 fNewObject = FALSE;
    
    PWSTR pwszName = NULL;

    AZASSERT(NULL != pDoc &&
             NULL != pAzStoreNode &&
             NULL != hObject);

    //init to AzAuthStore node, it may be changed from myXmlDetermineParentNode
    pParentNode = pAzStoreNode;

    if (OBJECT_TYPE_AZAUTHSTORE == lObjectType)
    {
        // AzAuthStore object
        pObjectNode = pAzStoreNode;
    }
    else
    {
        // non-AzAuthStore object
        // determine parent
        hr = myXmlDetermineParentNode(
                    pAzStoreNode,
                    lObjectType,
                    pApplicationGuid,
                    pScopeGuid,
                    &pParentTemp);
        _JumpIfError(hr, error, "myXmlDetermineParentNode");

        // if pParentTemp == NULL, the parent is AzAuthStore
        if (NULL != pParentTemp)
        {
            pParentNode = pParentTemp;
        }

        //
        // handle delate or create
        //

        // object tag name must be in bstr
        bstrObjectTag = SysAllocString(g_SubmitLoadTable[lObjectType].pwszTag);
        _JumpIfOutOfMemory(&hr, error, bstrObjectTag, "SysAllocString");

        // get the list of objects under parent

        hr = pParentNode->selectNodes(
                    bstrObjectTag,
                    &pObjectList);
        _JumpIfError(hr, error, "pParentNode->selectNodes");

        // at this point we should have a list of objects under parent
        AZASSERT(NULL != pObjectList);

        //
        // Get the GUID string
        //
        
        hr = UuidToString(XmlAzrolesInfo->AzpePersistenceGuid(hObject), &pwszGuid);
        _JumpIfError(hr, error, "UuidToString");
        
        // search the object by guid
        hr = myXmlGetNodeByAttribute(
                    AZ_XML_TAG_ATTR_GUID,
                    pwszGuid,
                    pObjectList,
                    &pObjectNode);
        if (S_OK != hr && AZ_HRESULT(ERROR_NOT_FOUND) != hr)
        {
            _JumpIfError(hr, error, "myXmlGetNamedGuidNode");
        }
        
        //
        // if we can't find the node by GUID, we need to test if we can
        // find the node by name. If we do, then that is a problem because
        // to our clients, name is the only identity they know even though
        // internally, we recognize objects by their guids.
        //
        
        if (AZ_HRESULT(ERROR_NOT_FOUND) == hr)
        {
            DWORD dwErr = XmlAzrolesInfo->AzpeGetProperty(hObject, lPersistFlags, AZ_PROP_NAME, (PVOID*)&pwszName);
            if (dwErr != NO_ERROR)
            {
                _JumpIfWinError(dwErr, &hr, error, "myXmlGetNamedGuidNode");
            }
            
            //
            // We must not be able to find this node by the name if
            //  there is no node matching by GUID
            //
            
            hr = myXmlGetNodeByAttribute(
                        AZ_XML_TAG_ATTR_NAME,
                        pwszName,
                        pObjectList,
                        &pObjectNode);
                        
            if (S_OK == hr)
            {
                hr = AZ_HRESULT(ERROR_ALREADY_EXISTS);
                _JumpIfError(hr, error, "myXmlGetNamedGuidNode");
            }
        }
        
        
        AzPrint((AZD_XML, "hr = 0x%lx, pObjectNode(from myXmlGetNamedGuidNode) = 0x%lx\n", hr, pObjectNode));
        AZASSERT((S_OK == hr && NULL != pObjectNode) ||
                 (AZ_HRESULT(ERROR_NOT_FOUND) == hr && NULL == pObjectNode));

        if (fDelete)
        {
            if (NULL != pObjectNode)
            {
                hr = pParentNode->removeChild(
                        pObjectNode,
                        NULL); //remove
                _JumpIfError(hr, error, "pParentNode->removeChild");
            }
            //else
            //{
                // try to delete an object not existing?

                // this can be from
                // this object was never submitted OR
                // the store has not been refreshed and
                // the object is deleted by another application
            //}

            if (NULL != g_SubmitLoadTable[lObjectType].rgpwszLkTag)
            {
                // this object can be referenced by other objects
                // by removing this object, we should remove all references or links

                WCHAR const * const *ppwszLinkTag;

                for (ppwszLinkTag = g_SubmitLoadTable[lObjectType].rgpwszLkTag;
                     NULL != *ppwszLinkTag; ++ppwszLinkTag)
                {
                    // remove link
                    hr = myXmlRemoveAllLinks(
                            pDoc,
                            *ppwszLinkTag,
                            XmlAzrolesInfo->AzpePersistenceGuid(hObject));
                    _JumpIfError(hr, error, "myXmlRemoveAllLinks");
                }

            }
            // deletion, it is done
            goto done;
        }
        else
        {
            if (NULL == pObjectNode)
            {
                //
                // looks the node doesn't exist, must be a new object
                //
                
                if ( !ObjectIsDirty( hObject, AZ_DIRTY_CREATE) )
                {
                    hr = AZ_HR_FROM_WIN32(ERROR_NOT_FOUND);
                    _JumpError(hr, error, "Submitting changes to a non-existent object");
                }
                
                fNewObject = TRUE;

                // let's create it
                hr = pDoc->createElement(
                            bstrObjectTag,
                            (IXMLDOMElement**)&pDocObjectNode);
                _JumpIfError(hr, error, "pDoc->createElement");

                AZASSERT(NULL != pDocObjectNode);

                // attach the new node to the right parent
                hr = pParentNode->appendChild(
                            pDocObjectNode,
                            &pObjectNode);
                _JumpIfError(hr, error, "pParentNode->appendChild");

                AzPrint((AZD_XML, "A new element node, 0x%lx, is added for %s\n", pObjectNode, bstrObjectTag));

            }

            // at this point, we should have object node
            AZASSERT(NULL != pObjectNode);

            // let's update object common data

            if (fNewObject)
            {
                // let's set object guid

                // convert guid to string guid
                hr = UuidToString(
                        XmlAzrolesInfo->AzpePersistenceGuid(hObject),
                        &pwszGuid);
                _JumpIfError(hr, error, "UuidToString");

                AZASSERT(NULL != pwszGuid);

                hr = myXmlSetNodeAttribute(
                            pObjectNode,
                            AZ_XML_TAG_ATTR_GUID,
                            pwszGuid,
                            pDoc);
                _JumpIfError(hr, error, "myXmlSetNodeAttribute");
            }

            if (ObjectIsDirty(hObject, AZ_DIRTY_NAME))
            {
                // submit name
                hr = myXmlSubmitObjectAttribute(
                        hObject,
                        lPersistFlags,
                        AZ_PROP_NAME,
                        ENUM_AZ_BSTR,
                        pObjectNode,
                        AZ_XML_TAG_ATTR_NAME,
                        pDoc);
                _JumpIfError(hr, error, "myXmlSubmitObjectAttribute(name)");
            }
        }
    }

    if (ObjectIsDirty( hObject, AZ_DIRTY_DESCRIPTION))
    {
        // every object has description
        hr = myXmlSubmitObjectAttribute(
                    hObject,
                    lPersistFlags,
                    AZ_PROP_DESCRIPTION,
                    ENUM_AZ_BSTR,
                    pObjectNode,
                    AZ_XML_TAG_ATTR_DESCRIPTION,
                    pDoc);
        _JumpIfError(hr, error, "myXmlSubmitObjectAttribute(description)");
    }

    //
    // submit object attributes if has
    //
    if (NULL != g_SubmitLoadTable[lObjectType].rgpAttrs)
    {
        // submit object attributes
        AZ_PROP_ENTRY *pAttrs;
        for (pAttrs = g_SubmitLoadTable[lObjectType].rgpAttrs;
             NULL != pAttrs[0].pwszTag; ++pAttrs)
        {
            if (ObjectIsDirty(hObject, pAttrs[0].lDirtyBit))
            {
                hr = myXmlSubmitObjectAttribute(
                            hObject,
                            lPersistFlags,
                            pAttrs[0].lPropId,
                            pAttrs[0].lDataType,
                            pObjectNode,
                            pAttrs[0].pwszTag,
                            pDoc);
                _JumpIfError(hr, error, "myXmlSubmitObjectAttribute");
            }
        }
    }

    //
    // submit object elements if has
    //
    if (NULL != g_SubmitLoadTable[lObjectType].rgpEles)
    {
        // submit object elements
        AZ_PROP_ENTRY *pEles;
        for (pEles = g_SubmitLoadTable[lObjectType].rgpEles;
             NULL != pEles[0].pwszTag; ++pEles)
        {
            if (ObjectIsDirty(hObject, pEles[0].lDirtyBit))
            {
                hr = myXmlSubmitObjectElements(
                            pDoc,
                            lPersistFlags,
                            pObjectNode,
                            pEles[0].pwszTag,
                            pEles[0].lDataType,
                            hObject,
                            pEles[0].lPropId);
                _JumpIfError(hr, error, "myXmlSubmitObjectElements");
            }
        }
    }

done:
    hr = S_OK;
error:
    if (NULL != pParentTemp)
    {
        pParentTemp->Release();
    }
    if (NULL != bstrObjectTag)
    {
        SysFreeString(bstrObjectTag);
    }
    if (OBJECT_TYPE_AZAUTHSTORE != lObjectType &&
        NULL != pObjectNode &&
        pObjectNode != pAzStoreNode)
    {
        pObjectNode->Release();

        AzPrint((AZD_XML, "pObjectNode, 0x%lx, is released\n", pObjectNode));

    }
    if (NULL != pObjectList)
    {
        pObjectList->Release();
    }
    if (NULL != pDocObjectNode)
    {
        pDocObjectNode->Release();
    }
    if (NULL != pwszGuid)
    {
        RpcStringFree(&pwszGuid);
    }
    if (NULL != pwszName)
    {
        AzFreeMemory(pwszName);
    }
    return hr;
}
    
DWORD
XMLPersistSubmit(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN AZPE_OBJECT_HANDLE pObj,
    IN ULONG lPersistFlags,
    IN BOOLEAN DeleteMe
    )
/*
Description:
    This routine submits changes made to the authz policy database.

    If the object is being created, the GenericObject->PersistenceGuid field will be
    zero on input.  Upon successful creation, this routine will set PersistenceGuid to
    non-zero.  Upon failed creation, this routine will leave PersistenceGuid as zero.

    On entry, AzAuthorizationStore->PersistCritSect must be locked.

Arguments:

    PersistContext - Specifies the policy database that is to be manipulated

    GenericObject - Specifies the object in the database that is to be updated
        in the underlying store.

    lPersistFlags - lPersistFlags from the persist engine describing the operation
        AZPE_FLAGS_PERSIST_OPEN - Call is the original AzInitialize
        AZPE_FLAGS_PERSIST_UPDATE_CACHE - Call is an AzUpdateCache

    DeleteMe - TRUE if the object and all of its children are to be deleted.
        FALSE if the object is to be updated.
Return Value:
    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes
*/
{
    HRESULT  hr;
    AZPE_OBJECT_HANDLE  pTempObj;
    GUID            *pAppGuid;
    GUID            *pScopeGuid;
    IXMLDOMDocument2 *pDoc;
    IXMLDOMElement  *pAzStoreNode = NULL;
    AZP_XML_CONTEXT *pPersistContext;
    VARIANT          varPolicyUrl;
    ULONG lObjectType = XmlAzrolesInfo->AzpeObjectType(pObj);

    ::VariantInit(&varPolicyUrl);

    AZASSERT(NULL != pObj );

    // init
    pPersistContext = (AZP_XML_CONTEXT*)PersistContext;
    AZASSERT(NULL != pPersistContext);
    pDoc = pPersistContext->pDoc;

    //
    // Handle deletion of the authorization store object
    //

    if ( lObjectType == OBJECT_TYPE_AZAUTHSTORE && DeleteMe ) {

        hr = XMLPersistDelete( pPersistContext->pwszPolicyUrl );
        _PrintIfError(hr, "XMLPersistDelete");
        goto error;
    }
    
    // determine at what level the object is located
    // by knowing pAppGuid and pScopeGuid, it can tell
    // for example,
    // if pAppGuid=NULL && pScopeGuid=NULL && ObjectType=Group
    // it is the object under AzAuthorizationStore
    // if pAppGuid!=NULL && pScopeGuid!=NULL && ObjectType=Group
    // it is the object under Scope

    // init
    pAppGuid = NULL;
    pScopeGuid = NULL;

    // go from the object up to AzAuthStore level
    pTempObj = pObj;
    while (NULL != pTempObj)
    {
        ULONG TempObjectType = XmlAzrolesInfo->AzpeObjectType(pTempObj);

        if (OBJECT_TYPE_AZAUTHSTORE == TempObjectType)
        {
            break;
        }
        else if (OBJECT_TYPE_APPLICATION == TempObjectType)
        {
            // point to application name
            pAppGuid = XmlAzrolesInfo->AzpePersistenceGuid( pTempObj );
        }
        else if (OBJECT_TYPE_SCOPE == TempObjectType)
        {
            // point to scope name
            pScopeGuid = XmlAzrolesInfo->AzpePersistenceGuid( pTempObj );
        }

        // point to the parent

        pTempObj = XmlAzrolesInfo->AzpeParentOfChild( pTempObj );
    }

    // we will get root node any way
    // get the root node, ie. the node of ploicy
    hr = myXmlGetAzStoreNode(
                pDoc,
                &pAzStoreNode);
    _JumpIfError(hr, error, "myXmlGetAzStoreNode");

    AZASSERT(NULL != pAzStoreNode);

    // let's check if the object has a guid
    if (OBJECT_TYPE_AZAUTHSTORE != lObjectType)
    {
        if (IsEqualGUID( *XmlAzrolesInfo->AzpePersistenceGuid(pObj), AzGlZeroGuid))
        {
            hr = UuidCreate( XmlAzrolesInfo->AzpePersistenceGuid(pObj) );
            _JumpIfError(hr, error, "UuidCreate");
        }
    }

    // submit object changes to persist store
    hr = myXmlSubmitObject(
                pDoc, // doc node
                lPersistFlags,
                pAzStoreNode, //AzAuthStore node
                pAppGuid,
                pScopeGuid,
                pObj,       //object handle
                lObjectType,
                DeleteMe);
    _JumpIfError(hr, error, "myXmlSubmitObject");


    // if submit called from persist engine, it must be dirty
    // persist whole xml doc

    AZASSERT(NULL != pPersistContext);

    hr = myWszToBstrVariant(
                    pPersistContext->pwszPolicyUrl,
                    &varPolicyUrl);
    _JumpIfError(hr, error, "myWszToBstrVariant");

    //
    // We should not blindly use the current DOM to save.
    // If there has been changes to the store, then we should bring in
    // those changes to this DOM and merge them and then do the save
    //
    
    BOOL bNeedUpdate;
    DWORD dwStatus = myXmlStoreHasUpdate(pPersistContext, &bNeedUpdate);
    if (NO_ERROR == dwStatus && bNeedUpdate)
    {
        //
        // load a fresh copy of dom, and then update this object's changes
        //
        
        CComPtr<IXMLDOMDocument2> srpDocNew;
        hr = myXmlLoad(varPolicyUrl, &srpDocNew);
        if (SUCCEEDED(hr))
        {
            //
            // put the same changes to the freshly loaded dom as well
            //
            
            CComPtr<IXMLDOMElement> srpStoreNode;
            hr = srpDocNew->get_documentElement(&srpStoreNode);
            if (SUCCEEDED(hr))
            {
                hr = myXmlSubmitObject(
                                        srpDocNew, // doc node
                                        lPersistFlags,
                                        srpStoreNode, //admin node
                                        pAppGuid,
                                        pScopeGuid,
                                        pObj,       //object handle
                                        lObjectType,
                                        DeleteMe
                                       );
           }
        }
        if (SUCCEEDED(hr))
        {
            hr = srpDocNew->save(varPolicyUrl);
        }
    }
    else if (NO_ERROR == dwStatus)
    {
        hr = pDoc->save(varPolicyUrl);
    }
    else
    {
        hr = AZ_HR_FROM_WIN32(dwStatus);
    }
    
    // release resource 1st
    VariantClear(&varPolicyUrl);
    _JumpIfError(hr, error, "pDoc->save");

    // if AzAuthStore, apply acl
    // we do it here because the file might not exist
    if ( lObjectType == OBJECT_TYPE_AZAUTHSTORE )
    {
        // submit any acl changes
        hr = myXmlSubmitAzStoreAcls(
                        pPersistContext,
                        pObj,
                        lPersistFlags );
        _JumpIfError(hr, error, "myXmlSubmitAzStoreAcls");
    }

    //
    // We will poll the filetime here only if no outside changes
    // have happened
    //
    
    if (!bNeedUpdate)
    {
        WIN32_FILE_ATTRIBUTE_DATA fad;
        
        if (GetFileAttributesEx(pPersistContext->pwszPolicyUrl,
                                            GetFileExInfoStandard,
                                            &fad))
        {
            pPersistContext->FTLastWrite = fad.ftLastWriteTime;
        }
        else
        {
            hr = AZ_HR_FROM_WIN32(GetLastError());
            _JumpIfError(hr, error, "GetFileAttributesEx");
        }
    }

    //
    // Tell azroles about the object options
    //

    hr = XmlSetObjectOptions( pPersistContext, lPersistFlags, pObj );
    _JumpIfError(hr, error, "XmlSetObjectOptions");

    hr = S_OK;
error:
    VariantClear(&varPolicyUrl);

    if (NULL != pAzStoreNode)
    {
        pAzStoreNode->Release();
    }
    return hr;
}



DWORD
XMLPersistRefresh(
    IN AZPE_PERSIST_CONTEXT PersistContext,
    IN AZPE_OBJECT_HANDLE AzpeObjectHandle,
    IN ULONG lPersistFlags
    )
/*++

Routine Description:

    This routine updates the attributes of the object from the policy database.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    PersistContext - Specifies the policy database that is to be manipulated

    AzpeObjectHandle - Specifies the object in the database whose cache entry is to be
        updated
        The GenericObject->PersistenceGuid field should be non-zero on input.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    DWORD dwErr = NO_ERROR;
    PAZP_XML_CONTEXT XmlPersistContext = (PAZP_XML_CONTEXT)PersistContext;
    AZPE_OBJECT_HANDLE     pParentObject;
    ULONG               lObjectType;
    IXMLDOMNodeList    *pList = NULL;
    IXMLDOMNode        *pObjectNode = NULL;
    IXMLDOMDocument2     *pDoc;
    WCHAR    *pwszGuid = NULL;
    WCHAR    *pwszQuery = NULL;

    ASSERT(NULL != AzpeObjectHandle);

    //init

    // get object type
    lObjectType = XmlAzrolesInfo->AzpeObjectType( AzpeObjectHandle );

    // get doc handle
    pDoc = XmlPersistContext->pDoc;

    // find the object node in the doc

    if (OBJECT_TYPE_AZAUTHSTORE == lObjectType)
    {
        // AzAuthStore is always special, itself, no parent
        // get object parent
        pParentObject = AzpeObjectHandle;

        // get the root node, ie. the node of ploicy
        dwErr = myXmlGetAzStoreNode(pDoc, (IXMLDOMElement**)&pObjectNode);
        _JumpIfError(dwErr, error, "myXmlGetAzStoreNode");

        // if AzAuthStore object, refresh policy acl
        dwErr = myXmlLoadAclsToAzStore(
                    XmlPersistContext,
                    lPersistFlags,
                    FALSE );
        _JumpIfError(dwErr, error, "myXmlLoadAclsToAzStore");

    }
    else
    {
        if (IsEqualGUID( *XmlAzrolesInfo->AzpePersistenceGuid( AzpeObjectHandle ), AzGlZeroGuid))
        {
            // this is a new object, no need to refresh
            goto done;
        }

        // get object parent
        pParentObject = XmlAzrolesInfo->AzpeParentOfChild( AzpeObjectHandle );
        ASSERT(NULL != pParentObject);

        // convert object guid to string guid to form xpath query
        dwErr = UuidToString( XmlAzrolesInfo->AzpePersistenceGuid( AzpeObjectHandle ), &pwszGuid);
        _JumpIfError(dwErr, error, "UuidToString");

        // get object node by using xpath query
        // query is in a pattern of //*/$ObjectTag$[@Guid="???"]
        // for example, query Operation,
        // //*/AzOperation[@Guid="25a63179-3663-4aa7-b0b8-48ca084d0747"]
        // in which "//*/[@=""] has 10 chars

        ASSERT(NULL != g_SubmitLoadTable[lObjectType].pwszTag);

        pwszQuery = (WCHAR*)AzpAllocateHeap(
                (wcslen(g_SubmitLoadTable[lObjectType].pwszTag) +
                 wcslen(AZ_XML_TAG_ATTR_GUID) +
                 wcslen(pwszGuid) + 11) * sizeof(WCHAR), "XMQRY2" );
        if (NULL == pwszQuery)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            _JumpError(dwErr, error, "AzpAllocateHeap");
        }

        wsprintf(pwszQuery, L"//*/%s[@%s=\"%s\"]",
                    g_SubmitLoadTable[lObjectType].pwszTag,
                    AZ_XML_TAG_ATTR_GUID,
                    pwszGuid);
        AzPrint((AZD_XML, "XPath query(refresh)=%ws\n", pwszQuery));

        dwErr = myXmlGetNodeListByXPath(
                    pDoc,
                    pwszQuery,
                    &pList);
        _JumpIfError(dwErr, error, "myXmlGetNodeListByXPath");

#if DBG
{
        LONG lLength;
        // get length of the list
        dwErr = pList->get_length(&lLength);
        _JumpIfError(dwErr, error, "pList->get_length");

        // object guid can't be shared
        AZASSERT(1 == lLength);
}
#endif //DBG

        dwErr = pList->get_item(0, &pObjectNode);
        _JumpIfError(dwErr, error, "pList->get_item");
    }

    ASSERT(NULL != pObjectNode);

    // now do the refresh
    dwErr = myXmlLoadObject(
                XmlPersistContext,
                pParentObject,
                lObjectType,
                lPersistFlags,
                FALSE, //don't load child objects
                TRUE, // AzpeFinishObject right after
                pObjectNode);
    _JumpIfError(dwErr, error, "myXmlLoadObject(refresh)");

done:
    dwErr = NO_ERROR;
error:
    if (NULL != pwszGuid)
    {
        RpcStringFree(&pwszGuid);
    }
    if (NULL != pwszQuery)
    {
        AzpFreeHeap(pwszQuery);
    }
    if (NULL != pList)
    {
        pList->Release();
    }
    if (NULL != pObjectNode)
    {
        pObjectNode->Release();
    }

    return dwErr;
}

#pragma warning ( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\msxml\init.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    init.cxx

Abstract:

    Provider initialization

Author:

    Cliff Van Dyke (cliffv) 12-Dec-2001

--*/


#include "pch.hxx"


DWORD
WINAPI
AzPersistProviderInitialize(
    IN PAZPE_AZROLES_INFO AzrolesInfo,
    OUT PAZPE_PROVIDER_INFO *ProviderInfo
    )
/*++

Routine Description

    Routine to initialize the provider
    Memory allocator

Arguments

    Size - Size (in bytes) to allocate

Return Value

    Returns a pointer to the allocated memory.
    NULL - Not enough memory

--*/
{
    return XmlProviderInitialize( AzrolesInfo, ProviderInfo );
}

#ifdef AZROLESDBG

BOOL LogFileCritSectInitialized = FALSE;


DWORD
myatolx(
    char const *psz)
{
    DWORD dw = 0;

    while (isxdigit(*psz))
    {
        char ch = *psz++;
        if (isdigit(ch))
        {
            ch -= '0';
        }
        else if (isupper(ch))
        {
            ch += 10 - 'A';
        }
        else
        {
            ch += 10 - 'a';
        }
        dw = (dw << 4) | ch;
    }
    return(dw);
}

#endif //AZROLESDBG

BOOL
AzDllUnInitialize(VOID)
/*++

Routine Description

    This uninitializes global events and variables for the DLL.

Arguments

    none

Return Value

    Boolean: TRUE on success, FALSE on fail.

--*/
{
    BOOL RetVal = TRUE;

    //
    // Don't call back on thread start/stop
    //
    // Handle detaching from a process.
    //

#ifdef AZROLESDBG
    //
    // Done with debugging
    //

    if ( LogFileCritSectInitialized ) {
        SafeDeleteCriticalSection ( &AzGlLogFileCritSect );
        LogFileCritSectInitialized = FALSE;
    }
#endif // AZROLESDBG

    return RetVal;

}


BOOL
AzDllInitialize(VOID)
/*++

Routine Description

    This initializes global events and variables for the DLL.

Arguments

    none

Return Value

    Boolean: TRUE on success, FALSE on fail.

--*/
{
#ifdef DBG
    NTSTATUS Status;
#endif // DBG
    BOOL RetVal = TRUE;

    //
    // Initialize global constants
    //

    RtlZeroMemory( &AzGlZeroGuid, sizeof(AzGlZeroGuid) );

    //
    // Initialize the safe lock subsystem

#ifdef DBG
    Status = SafeLockInit();

    if ( !NT_SUCCESS( Status )) {
        RetVal = FALSE;
        KdPrint(("AzRoles.dll: SafeLockInit failed: 0x%lx\n",
                     Status ));
        goto Cleanup;
    }
#endif


#ifdef AZROLESDBG
    //
    // Initialize debugging
    //

#define SAFE_LOGFILE 1
    Status = SafeInitializeCriticalSection( &AzGlLogFileCritSect, SAFE_LOGFILE );

    if ( !NT_SUCCESS( Status )) {
        RetVal = FALSE;
        KdPrint(("AzRoles.dll: InitializCriticalSection (AzGlLogFileCritSect) failed: 0x%lx\n",
                     Status ));
        goto Cleanup;
    }
    LogFileCritSectInitialized = TRUE;



    //
    // Get debug flag from environment variable AZDBG
    //
    char const *pszAzDbg;
    pszAzDbg = getenv("AZDBG");
    if (NULL != pszAzDbg)
    {
        AzGlDbFlag |= myatolx(pszAzDbg);
    }

#endif // AZROLESDBG

Cleanup:
    if ( !RetVal ) {
        AzDllUnInitialize();
    }
    return RetVal;

}


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    BOOL ret = TRUE;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);
        ret = AzDllInitialize();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        ret = AzDllUnInitialize();
    }
    return ret;    // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\msxml\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by azroles.rc
//
#define IDS_PROJNAME                    100
#define IDR_AZADMINMANAGER              101
#define IDR_AZACCESSCHECK               117


// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\msxml\makefile.inc ===
xml.cxx: ..\xml.cxx
        copy ..\xml.cxx .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\msxml\util.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    util.h

Abstract:

    Definitions of Utility routines

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/


#ifdef __cplusplus
extern "C" {
#endif


/////////////////////////////////////////////////////////////////////////////
//
// Global definitions
//
/////////////////////////////////////////////////////////////////////////////

extern LIST_ENTRY AzGlAllocatedBlocks;
extern SAFE_CRITICAL_SECTION AzGlAllocatorCritSect;
extern GUID AzGlZeroGuid;


/////////////////////////////////////////////////////////////////////////////
//
// Procedure definitions
//
/////////////////////////////////////////////////////////////////////////////

PVOID
AzpAllocateHeap(
    IN SIZE_T Size,
    IN LPSTR pDescr OPTIONAL
    );

VOID
AzpFreeHeap(
    IN PVOID Buffer
    );

DWORD
AzpHresultToWinStatus(
    HRESULT hr
    );

DWORD
AzpConvertSelfRelativeToAbsoluteSD(
    IN PSECURITY_DESCRIPTOR pSelfRelativeSd,
    OUT PSECURITY_DESCRIPTOR *ppAbsoluteSd,
    OUT PACL *ppDacl,
    OUT PACL *ppSacl
    );


/////////////////////////////////////////////////////////////////////////////
//
// Debugging Support
//
/////////////////////////////////////////////////////////////////////////////

#if DBG
#define AZROLESDBG 1
#endif // DBG

#ifdef AZROLESDBG
#define AzPrint(_x_) AzpPrintRoutine _x_

VOID
AzpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR FORMATSTRING,              // PRINTF()-STYLE FORMAT STRING.
    ...                                 // OTHER ARGUMENTS ARE POSSIBLE.
    );

VOID
AzpDumpGuid(
    IN DWORD DebugFlag,
    IN GUID *Guid
    );


//
// Values of DebugFlag
//  The values of this flag are organized into bytes:
//  The least significant byte are flags that one always wants on
//  The next byte are flags that provider a reasonable level of verbosity
//  The next byte are flags that correspond to levels from the 2nd byte but are more verbose
//  The most significant byte are flags that are generally very verbose
//
#define AZD_CRITICAL     0x00000001 // Debug most common errors
#define AZD_INVPARM      0x00000002  // Invalid Parameter

#define AZD_PERSIST      0x00000100  // Persistence code
#define AZD_ACCESS       0x00000200  // Debug access check
#define AZD_SCRIPT       0x00000400  // Debug bizrule scripts
#define AZD_DISPATCH     0x00000800  // Debug IDispatch interface code
#define AZD_XML          0x00001000  // xml store

#define AZD_PERSIST_MORE 0x00010000  // Persistence code (verbose mode)
#define AZD_ACCESS_MORE  0x00020000  // Debug access check (verbose mode)
#define AZD_SCRIPT_MORE  0x00040000 // Debug bizrule scripts (verbose mode)

#define AZD_HANDLE       0x01000000  // Debug handle open/close
#define AZD_OBJLIST      0x02000000  // Object list linking
#define AZD_REF          0x04000000  // Debug object ref count
#define AZD_DOMREF       0x08000000  // Debug domain ref count

#define AZD_ALL          0xFFFFFFFF

//
// Globals
//

extern SAFE_CRITICAL_SECTION AzGlLogFileCritSect;
extern ULONG AzGlDbFlag;

#else
// Non debug version
#define AzPrint(_x_)
#define AzpDumpGuid(_x_, _y_)
#define AzpDumpGoRef(_x_, _y_)
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\msxml\util.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    util.cxx

Abstract:

    Utility routines

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/


#include "pch.hxx"

#if DBG
//
// List of all allocated blocks
//  AccessSerialized by AzGlAllocatorCritSect
LIST_ENTRY AzGlAllocatedBlocks;
SAFE_CRITICAL_SECTION AzGlAllocatorCritSect;
GUID AzGlZeroGuid;


//
// Force C++ to use our allocator
//

void * __cdecl operator new(size_t s) {
    return AzpAllocateHeap( s, NULL );
}

void __cdecl operator delete(void *pv) {
    AzpFreeHeap( pv );
}

#endif // DBG

PVOID
AzpAllocateHeap(
    IN SIZE_T Size,
    IN LPSTR pDescr OPTIONAL
    )
/*++

Routine Description

    Memory allocator.  The pDescr field is ignored for Free builds

Arguments

    Size - Size (in bytes) to allocate

    pDescr - Optional string identifying the block of not more than 8 chars.

Return Value

    Returns a pointer to the allocated memory.
    NULL - Not enough memory

--*/
{

    DBG_UNREFERENCED_PARAMETER( pDescr ); //ignore

    return LocalAlloc( 0, Size );
}

VOID
AzpFreeHeap(
    IN PVOID Buffer
    )
/*++

Routine Description

    Memory de-allocator.

Arguments

    Buffer - address of buffer to free

Return Value

    None

--*/
{
    LocalFree( Buffer );

}






DWORD
AzpHresultToWinStatus(
    HRESULT hr
    )
/*++

Routine Description

    Convert an Hresult to a WIN 32 status code

Arguments

    hr - Hresult to convert

Return Value

--*/
{
    DWORD WinStatus = ERROR_INTERNAL_ERROR;

    //
    // Success is still success
    //

    if ( hr == NO_ERROR ) {
        WinStatus = NO_ERROR;

    //
    // If the facility is WIN32,
    //  the translation is easy.
    //

    } else if ((HRESULT_FACILITY(hr) == FACILITY_WIN32) && (FAILED(hr))) {

        WinStatus = HRESULT_CODE(hr);

        if ( WinStatus == ERROR_SUCCESS ) {
            WinStatus = ERROR_INTERNAL_ERROR;
        }

    //
    // All others should be left intact
    //

    } else {

        WinStatus = hr;
    }

    return WinStatus;
}


//
// Debugging support
//
#ifdef AZROLESDBG
#include <stdio.h>
SAFE_CRITICAL_SECTION AzGlLogFileCritSect;
ULONG AzGlDbFlag;
// HANDLE AzGlLogFile;

#define MAX_PRINTF_LEN 1024        // Arbitrary.

VOID
AzpDumpGuid(
    IN DWORD DebugFlag,
    IN GUID *Guid OPTIONAL
    )
/*++

Routine Description:

    Dumps a GUID to the debugger output.

Arguments:

    DebugFlag: Debug flag to pass on to AzPrintRoutine

    Guid: Guid to print

Return Value:

    none

--*/
{
    RPC_STATUS RpcStatus;
    unsigned char *StringGuid;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( DebugFlag != 0 && (AzGlDbFlag & DebugFlag) == 0 ) {
        return;
    }


    if ( Guid == NULL ) {
        AzPrint(( DebugFlag, "(null)" ));
    } else {
        RpcStatus = UuidToStringA( Guid, &StringGuid );

        if ( RpcStatus != RPC_S_OK ) {
            return;
        }

        AzPrint(( DebugFlag, "%s", StringGuid ));

        RpcStringFreeA( &StringGuid );
    }

}

DWORD
AzpConvertSelfRelativeToAbsoluteSD(
    IN PSECURITY_DESCRIPTOR pSelfRelativeSd,
    OUT PSECURITY_DESCRIPTOR *ppAbsoluteSD,
    OUT PACL *ppDacl,
    OUT PACL *ppSacl
    )
/*++

Routine Description:

        This routine returns an absolute form SD for a passed
        in self-relative form SD.  The returned SD and all of its required
        component(s) need to be freed using AzFreeMemory routine.

Arguments:

        pSelfRelativeSd - Passed in self-relative form SD

        ppAbsoluteSD - Returned absolute form SD

        ppDacl - Returned Dacl component if needed

        ppSacl - Returned Sacl component if needed

Return Values:

        NO_ERROR - The absolute form SD was created successfully
        Other status codes
--*/
{
    DWORD WinStatus = 0;

    DWORD dAbsoluteSDLen = 0;
    DWORD dDaclLen = 0;
    DWORD dSaclLen = 0;
    DWORD dOwnerLen = 0;
    DWORD dGroupLen = 0;

    PSID pOwner = NULL;
    PSID pGroup = NULL;

    //
    // We first need to get the size for each of its fields
    //

    if ( !MakeAbsoluteSD(
              pSelfRelativeSd, NULL,
              &dAbsoluteSDLen,
              NULL, &dDaclLen,
              NULL, &dSaclLen,
              NULL, &dOwnerLen,
              NULL, &dGroupLen
              ) ) {

        *ppAbsoluteSD = (PSECURITY_DESCRIPTOR) AzpAllocateHeap( dAbsoluteSDLen, NULL );

        if ( *ppAbsoluteSD == NULL ) {

            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        if ( ppDacl ) {

            *ppDacl = (PACL) AzpAllocateHeap( dDaclLen, NULL );

            if ( *ppDacl == NULL ) {

                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
        }

        if ( ppSacl ) {

            *ppSacl = (PACL) AzpAllocateHeap( dSaclLen, NULL );

            if ( *ppSacl == NULL ) {

                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

        }

        if ( dOwnerLen > 0 ) {

            pOwner = (PSID) AzpAllocateHeap( dOwnerLen, NULL );

            if ( pOwner == NULL ) {

                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
        }

        if ( dGroupLen > 0 ) {

            pGroup = (PSID) AzpAllocateHeap( dGroupLen, NULL );

            if ( pGroup == NULL ) {

                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
        }

        //
        // Now do the conversion
        //

        if ( !MakeAbsoluteSD(
                  pSelfRelativeSd, *ppAbsoluteSD,
                  &dAbsoluteSDLen,
                  *ppDacl, &dDaclLen,
                  NULL, &dSaclLen,
                  pOwner, &dOwnerLen,
                  pGroup, &dGroupLen ) ) {

            WinStatus = GetLastError();
            goto Cleanup;
        }

    } else {

        WinStatus = GetLastError();
        goto Cleanup;
    }

    WinStatus = NO_ERROR;

Cleanup:

    if ( pOwner != NULL ) {

        AzpFreeHeap( pOwner );
    }

    if ( pGroup != NULL ) {

        AzpFreeHeap( pGroup );
    }

    return WinStatus;
}

#if 0 //
VOID
AzpDumpGoRef(
    IN LPSTR Text,
    IN struct _GENERIC_OBJECT *GenericObject
    )
/*++

Routine Description:

    Dumps the ref count for a generic object

Arguments:

    Text - Description of why the ref count is changing

    GenericObject - a pointer to the object being ref counted

Return Value:

    none

--*/
{
    LPWSTR StringSid = NULL;
    LPWSTR StringToPrint;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( (AzGlDbFlag & AZD_REF) == 0 ) {
        return;
    }

    //
    // Convert the sid to a string
    //
    if ( GenericObject->ObjectName == NULL ) {
        StringToPrint = NULL;

    } else if ( GenericObject->ObjectName->ObjectName.IsSid ) {
        if ( ConvertSidToStringSid( (PSID)GenericObject->ObjectName->ObjectName.String, &StringSid)) {
            StringToPrint = StringSid;
        } else {
            StringToPrint = L"<Invalid Sid>";
        }
    } else {
        StringToPrint = GenericObject->ObjectName->ObjectName.String;
    }


    AzPrint(( AZD_REF, "0x%lx %ld (%ld) %ws: %s\n", GenericObject, GenericObject->ObjectType, GenericObject->ReferenceCount, StringToPrint, Text ));

    if ( StringSid != NULL ) {
        LocalFree( StringSid );
    }

}
#endif // 0

VOID
AzpPrintRoutineV(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    va_list arglist
    )
/*++

Routine Description

    Debug routine for azroles

Arguments

    DebugFlag - Flag to indicating the functionality being debugged

    --- Other printf parameters

Return Value

--*/

{
    static LPSTR AzGlLogFileOutputBuffer = NULL;
    ULONG length;
    int   lengthTmp;
    // DWORD BytesWritten;
    static BeginningOfLine = TRUE;
    static LineCount = 0;
    static TruncateLogFileInProgress = FALSE;
    static LogProblemWarned = FALSE;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( DebugFlag != 0 && (AzGlDbFlag & DebugFlag) == 0 ) {
        return;
    }


    //
    // Allocate a buffer to build the line in.
    //  If there isn't already one.
    //

    length = 0;

    if ( AzGlLogFileOutputBuffer == NULL ) {
        AzGlLogFileOutputBuffer = (LPSTR) LocalAlloc( 0, MAX_PRINTF_LEN + 1 );

        if ( AzGlLogFileOutputBuffer == NULL ) {
            return;
        }
    }

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        //
        // Never print empty lines.
        //

        if ( Format[0] == '\n' && Format[1] == '\0' ) {
            return;
        }

#if 0
        //
        // If the log file is getting huge,
        //  truncate it.
        //

        if ( AzGlLogFile != INVALID_HANDLE_VALUE &&
             !TruncateLogFileInProgress ) {

            //
            // Only check every 50 lines,
            //

            LineCount++;
            if ( LineCount >= 50 ) {
                DWORD FileSize;
                LineCount = 0;

                //
                // Is the log file too big?
                //

                FileSize = GetFileSize( AzGlLogFile, NULL );
                if ( FileSize == 0xFFFFFFFF ) {
                    (void) DbgPrint( "[NETLOGON] Cannot GetFileSize %ld\n",
                                     GetLastError );
                } else if ( FileSize > AzGlParameters.LogFileMaxSize ) {
                    TruncateLogFileInProgress = TRUE;
                    SafeLeaveCriticalSection( &AzGlLogFileCritSect );
                    NlOpenDebugFile( TRUE );
                    NlPrint(( NL_MISC,
                              "Logfile truncated because it was larger than %ld bytes\n",
                              AzGlParameters.LogFileMaxSize ));
                    SafeEnterCriticalSection( &AzGlLogFileCritSect );
                    TruncateLogFileInProgress = FALSE;
                }

            }
        }

        //
        // If we're writing to the debug terminal,
        //  indicate this is a azroles message.
        //

        if ( AzGlLogFile == INVALID_HANDLE_VALUE ) {
            length += (ULONG) sprintf( &AzGlLogFileOutputBuffer[length], "[AZROLES] " );
        }

        //
        // Put the timestamp at the begining of the line.
        //
        {
            SYSTEMTIME SystemTime;
            GetLocalTime( &SystemTime );
            length += (ULONG) sprintf( &AzGlLogFileOutputBuffer[length],
                                  "%02u/%02u %02u:%02u:%02u ",
                                  SystemTime.wMonth,
                                  SystemTime.wDay,
                                  SystemTime.wHour,
                                  SystemTime.wMinute,
                                  SystemTime.wSecond );
        }
#endif // 0

        //
        // Indicate the type of message on the line
        //
        {
            char *Text;

            switch (DebugFlag) {
            case AZD_HANDLE:
                Text = "HANDLE"; break;
            case AZD_OBJLIST:
                Text = "OBJLIST"; break;
            case AZD_INVPARM:
                Text = "INVPARM"; break;
            case AZD_PERSIST:
            case AZD_PERSIST_MORE:
                Text = "PERSIST"; break;
            case AZD_REF:
                Text = "OBJREF"; break;
            case AZD_DISPATCH:
                Text = "DISPATCH"; break;
            case AZD_ACCESS:
            case AZD_ACCESS_MORE:
                Text = "ACCESS"; break;
            case AZD_DOMREF:
                Text = "DOMREF"; break;
            case AZD_XML:
                Text = "XML"; break;
            case AZD_SCRIPT:
            case AZD_SCRIPT_MORE:
                Text = "SCRIPT"; break;
            case AZD_CRITICAL:
                Text = "CRITICAL"; break;
            default:
                Text = "UNKNOWN"; break;

            case 0:
                Text = NULL;
            }
            if ( Text != NULL ) {
                length += (ULONG) sprintf( &AzGlLogFileOutputBuffer[length], "[%s] ", Text );
            }
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    lengthTmp = (ULONG) _vsnprintf( &AzGlLogFileOutputBuffer[length],
                                    MAX_PRINTF_LEN - length - 1,
                                    Format,
                                    arglist );

    if ( lengthTmp < 0 ) {
        length = MAX_PRINTF_LEN - 1;
        // always end the line which cannot fit into the buffer
        AzGlLogFileOutputBuffer[length-1] = '\n';
    } else {
        length += lengthTmp;
    }

    BeginningOfLine = (length > 0 && AzGlLogFileOutputBuffer[length-1] == '\n' );
    if ( BeginningOfLine ) {
        AzGlLogFileOutputBuffer[length-1] = '\r';
        AzGlLogFileOutputBuffer[length] = '\n';
        AzGlLogFileOutputBuffer[length+1] = '\0';
        length++;
    }


#if 0
    //
    // If the log file isn't open,
    //  just output to the debug terminal
    //

    if ( AzGlLogFile == INVALID_HANDLE_VALUE ) {
#if DBG
        if ( !LogProblemWarned ) {
            (void) DbgPrint( "[NETLOGON] Cannot write to log file [Invalid Handle]\n" );
            LogProblemWarned = TRUE;
        }
#endif // DBG

    //
    // Write the debug info to the log file.
    //

    } else {
        if ( !WriteFile( AzGlLogFile,
                         AzGlLogFileOutputBuffer,
                         length,
                         &BytesWritten,
                         NULL ) ) {
#if DBG
            if ( !LogProblemWarned ) {
                (void) DbgPrint( "[NETLOGON] Cannot write to log file %ld\n", GetLastError() );
                LogProblemWarned = TRUE;
            }
#endif // DBG
        }

    }
#else // 0
    printf( "%s", AzGlLogFileOutputBuffer );
#endif // 0

}

VOID
AzpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{
    va_list arglist;

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    SafeEnterCriticalSection( &AzGlLogFileCritSect );

    //
    // Simply change arguments to va_list form and call NlPrintRoutineV
    //

    va_start(arglist, Format);

    AzpPrintRoutineV( DebugFlag, Format, arglist );

    va_end(arglist);

    SafeLeaveCriticalSection( &AzGlLogFileCritSect );

} // AzPrintRoutine
#endif // AZROLESDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\tests\aztest.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    aztest.c

Abstract:

    Test program for the azroles DLL.

Author:

    Cliff Van Dyke (cliffv) 16-Apr-2001

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

#define UNICODE 1
// #define SECURITY_WIN32 1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "azrolesp.h"
#include <lmcons.h>
#include <lmerr.h>
#include <stdio.h>      // printf
#include <sddl.h>
#include <ntstatus.dbg>
#include <winerror.dbg>

//
// Sundry defines to enable optional tests
//

// #define ENABLE_LEAK 1           // Run a test that leaks memory
// #define ENABLE_CAUGHT_AVS 1     // Run a test that AVs in azroles.dll (but the AV is caught)
// #define ENABLE_LOCAL_ACCOUNT 1  // Run tests with user logged onto a local account
// #define ENABLE_NT4_ACCOUNT 1    // Run tests with user logged onto an NT4 domain account
//#define ENABLE_CHAITU_ACCOUNT 1  // Run tests as CHAITU
// #define ENABLE_CLIFFV_ACCOUNT 1 // Run tests as CLIFFV
#define ENABLE_ADMIN_ACCOUNT_XML 1 // Run tests as CLIFFVDOM\Administrator (on XML store)
// #define ENABLE_ADMIN_ACCOUNT_AD 1  // Run tests as CLIFFVDOM\Administrator (on AD store)
// #define ENABLE_DC_DOWN 1        // Run tests where DC cannot be located


#if defined(ENABLE_LOCAL_ACCOUNT) || defined(ENABLE_NT4_ACCOUNT)
#define ENABLE_NON_DS_ACCOUNT 1
#endif

#if defined(ENABLE_ADMIN_ACCOUNT_XML) || defined(ENABLE_ADMIN_ACCOUNT_AD)
#define ENABLE_ADMIN_ACCOUNT 1
#endif

//
// Global parameters to AzInitialize
//


LPWSTR AzGlTestFile;
BOOLEAN NoInitAllTests = FALSE;
BOOLEAN NoUpdateCache = FALSE;
BOOLEAN Silent = FALSE;

//
// Structure to define an operation to preform
//

typedef struct _OPERATION {

    // The operation
    ULONG Opcode;

// These are generic opcodes that work for all object types
#define AzoGenCreate    0
#define AzoGenOpen      1
#define AzoGenEnum      2
#define AzoGenDelete    3

#define AzoGenMax       50

//
// These are object specific opcodes
//

#define AzoAdm          51
#define AzoAdmDelete    (AzoAdm+AzoGenDelete)

#define AzoApp          100
#define AzoAppCreate    (AzoApp+AzoGenCreate)
#define AzoAppOpen      (AzoApp+AzoGenOpen)
#define AzoAppEnum      (AzoApp+AzoGenEnum)
#define AzoAppDelete    (AzoApp+AzoGenDelete)

#define AzoOp           200
#define AzoOpCreate     (AzoOp+AzoGenCreate)
#define AzoOpOpen       (AzoOp+AzoGenOpen)
#define AzoOpEnum       (AzoOp+AzoGenEnum)
#define AzoOpDelete     (AzoOp+AzoGenDelete)

#define AzoTask         300
#define AzoTaskCreate   (AzoTask+AzoGenCreate)
#define AzoTaskOpen     (AzoTask+AzoGenOpen)
#define AzoTaskEnum     (AzoTask+AzoGenEnum)
#define AzoTaskDelete   (AzoTask+AzoGenDelete)

#define AzoScope        400
#define AzoScopeCreate  (AzoScope+AzoGenCreate)
#define AzoScopeOpen    (AzoScope+AzoGenOpen)
#define AzoScopeEnum    (AzoScope+AzoGenEnum)
#define AzoScopeDelete  (AzoScope+AzoGenDelete)

#define AzoGroup         500
#define AzoGroupCreate   (AzoGroup+AzoGenCreate)
#define AzoGroupOpen     (AzoGroup+AzoGenOpen)
#define AzoGroupEnum     (AzoGroup+AzoGenEnum)
#define AzoGroupDelete   (AzoGroup+AzoGenDelete)

#define AzoRole          600
#define AzoRoleCreate    (AzoRole+AzoGenCreate)
#define AzoRoleOpen      (AzoRole+AzoGenOpen)
#define AzoRoleEnum      (AzoRole+AzoGenEnum)
#define AzoRoleDelete    (AzoRole+AzoGenDelete)

#define AzoCC         800

//
// Real APIs that don't map to the generic APIs
#define AzoInit         1000
#define AzoClose        1001
#define AzoInitCFT      1002    // AzInitContextFromToken
#define AzoAccess       1003
#define AzoGetProp      1004
#define AzoSetProp      1005
#define AzoAddProp      1006
#define AzoRemProp      1007
#define AzoAdmDeleteNoInit 1008 // Same as AdmDelete but don't AzInitialize first
#define AzoUpdateCache  1009

//
// Pseudo opcode for TestLink subroutine
//

#define AzoTl          2000
#define AzoTlCreate    (AzoTl+AzoGenCreate)
#define AzoTlOpen      (AzoTl+AzoGenOpen)
#define AzoTlEnum      (AzoTl+AzoGenEnum)
#define AzoTlDelete    (AzoTl+AzoGenDelete)
#define AzoTlMax       2999

// Opcodes that aren't really API calls
#define AzoSleep        0x0FFFFFFA
#define AzoTestLink     0x0FFFFFFB
#define AzoGoSub        0x0FFFFFFC
#define AzoEcho         0x0FFFFFFD
#define AzoDupHandle    0x0FFFFFFE
#define AzoEndOfList    0x0FFFFFFF

//
// Bits that can be OR'ed into any opcode
//

#define AzoAbort         0x80000000  // Abort instead of commit
#define AzoNoSubmit      0x40000000  // Neither abort nor commit
#define AzoNoUpdateCache 0x20000000  // Don't call AzUpdateCache



    // Input Handle
    PAZ_HANDLE InputHandle;

    // Input Parameter
    LPWSTR Parameter1;

    // Output Handle
    // For AzoAccess, this is an array of operations
    PAZ_HANDLE OutputHandle;

    // Expected result status code
    ULONG ExpectedStatus;

    // List of operations to perform on each enumeration handle
    struct _OPERATION *EnumOperations;

    // Expected result String parameter
    // For AzoAccess, this is an array of results
    LPWSTR ExpectedParameter1;

    // Property ID of Get/SetPropertyId functions
    // For AzoAccess, this is the operation count.
    ULONG PropertyId;

} OPERATION, *POPERATION;

//
// Global handles
//

AZ_HANDLE AdminMgrHandle1;
AZ_HANDLE AdminMgrHandle2;

AZ_HANDLE AppHandle1;
AZ_HANDLE AppHandle2;

AZ_HANDLE OpHandle1;
AZ_HANDLE TaskHandleA;
AZ_HANDLE TaskHandle1;
AZ_HANDLE TaskHandle2;
AZ_HANDLE TaskHandleT;

AZ_HANDLE ScopeHandle1;
AZ_HANDLE ScopeHandle2;

AZ_HANDLE GroupHandleA;
AZ_HANDLE GroupHandleB;
AZ_HANDLE GroupHandle1;
AZ_HANDLE GroupHandle2;
AZ_HANDLE GroupHandleT;

AZ_HANDLE RoleHandleA;
AZ_HANDLE RoleHandle1;
AZ_HANDLE RoleHandle2;

AZ_HANDLE GenParentHandle1;

AZ_HANDLE GenHandle1;
AZ_HANDLE GenHandle2;
AZ_HANDLE GenHandleE;
AZ_HANDLE GenHandleE2;

HANDLE TokenHandle;
AZ_HANDLE CCHandle;
AZ_HANDLE CCHandle2;

//
// Constant property values
//
ULONG Zero = 0;
ULONG Eight = 8;
ULONG EightHundred = 800;
ULONG Nine  = 9;
ULONG FifteenThousand = 15000;
ULONG FiveThousand = 5000;
ULONG FortyFiveThousand = 45000;
ULONG GtBasic = AZ_GROUPTYPE_BASIC;
ULONG GtLdap = AZ_GROUPTYPE_LDAP_QUERY;
LONG AzGlTrue = TRUE;
#define ValidGuid L"47e348af-ff79-41af-8a67-2835d4c417f4"

//
// Various Sid constants
//
typedef struct _SID8 {
   UCHAR Revision;
   UCHAR SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
   ULONG SubAuthority[8];
} SID8, *PISID8;
#define SECURITY_MISC_AUTHORITY       {0,0,0,0,3,0xe8}
SID SidWorld = { 1, 1, SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID };
SID SidCreatorOwner = { 1, 1, SECURITY_CREATOR_SID_AUTHORITY, SECURITY_CREATOR_OWNER_RID };
SID SidLocal = { 1, 1, SECURITY_LOCAL_SID_AUTHORITY, SECURITY_LOCAL_RID };
SID Sid1 = { 1, 1, SECURITY_MISC_AUTHORITY, 1 };
SID Sid2 = { 1, 1, SECURITY_MISC_AUTHORITY, 2 };
SID Sid3 = { 1, 1, SECURITY_MISC_AUTHORITY, 3 };
SID Sid4 = { 1, 1, SECURITY_MISC_AUTHORITY, 4 };
SID Sid5 = { 1, 1, SECURITY_MISC_AUTHORITY, 5 };
SID Sid6 = { 1, 1, SECURITY_MISC_AUTHORITY, 6 };
#ifdef ENABLE_CLIFFV_ACCOUNT
SID8 SidOwner = { 1, 5, SECURITY_NT_AUTHORITY, SECURITY_NT_NON_UNIQUE, 397955417, 626881126, 188441444, 2908288 };
#endif // ENABLE_CLIFFV_ACCOUNT
#ifdef ENABLE_ADMIN_ACCOUNT_XML
SID8 SidOwner = { 1, 2, SECURITY_NT_AUTHORITY, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS };
#endif // ENABLE_ADMIN_ACCOUNT_XML
#ifdef ENABLE_ADMIN_ACCOUNT_AD
SID8 SidOwner = { 1, 5, SECURITY_NT_AUTHORITY, SECURITY_NT_NON_UNIQUE, 3421389450, 3242236637, 3934022420, 512 };
#endif // ENABLE_ADMIN_ACCOUNT_AD
#ifdef ENABLE_CHAITU_ACCOUNT
SID8 SidOwner = { 1, 5, SECURITY_NT_AUTHORITY, SECURITY_NT_NON_UNIQUE, 397955417, 626881126, 188441444, 3014042 };
#endif // ENABLE_CHAITU_ACCOUNT

PSID SidWorldOwnerx[] = { &SidWorld, (PSID)&SidOwner };
AZ_SID_ARRAY SidWorldOwnerArray = { 2, SidWorldOwnerx };
PSID SidOwnerx[] = { (PSID)&SidOwner };
AZ_SID_ARRAY SidOwnerArray = { 1, SidOwnerx };
PSID SidWorldx[] = { (PSID)&SidWorld };
AZ_SID_ARRAY SidWorldArray = { 1, SidWorldx };

DWORD SidX[100];
PSID Sid2x[] = { &Sid2 };
AZ_SID_ARRAY Sid2Array = { 1, Sid2x };

PSID Sid3x[] = { &Sid3 };
AZ_SID_ARRAY Sid3Array = { 1, Sid3x };

PSID Sid23x[] = { &Sid2, &Sid3 };
AZ_SID_ARRAY Sid23Array = { 2, Sid23x };

PSID Sid123x[] = { &Sid1, &Sid2, &Sid3 };
AZ_SID_ARRAY Sid123Array = { 3, Sid123x };

PSID Sid123456x[] = { &Sid1, &Sid2, &Sid3, &Sid4, &Sid5, &Sid6 };
AZ_SID_ARRAY Sid123456Array = { 6, Sid123456x };

//
// Generic operations valid for all enumerations
//
//  Requires GenHandleE to already be set
//

// Test double close of enum handle
OPERATION OpAppChildGenEnum1[] = {
    { AzoDupHandle, &GenHandleE,    NULL,        &GenHandleE2, NO_ERROR },
    { AzoClose,     &GenHandleE,    NULL,        NULL,         NO_ERROR },
    { AzoClose,     &GenHandleE,    NULL,        NULL,         ERROR_INVALID_HANDLE },
    { AzoClose,     &GenHandleE2,   NULL,        NULL,         ERROR_INVALID_HANDLE },
    { AzoEndOfList }
};

// General purpose object enum
OPERATION OpAppChildGenEnum2[] = {
    { AzoGetProp,    &GenHandleE,   NULL,        NULL,    NO_ERROR, NULL, NULL, AZ_PROP_NAME },
    { AzoGetProp,    &GenHandleE,   NULL,        NULL,    NO_ERROR, NULL, NULL, AZ_PROP_DESCRIPTION },
    { AzoClose,      &GenHandleE,   NULL,        NULL,    NO_ERROR },
    { AzoEndOfList }
};

//
// Generic operations that work on *ALL* objects
//
//  Requires GenParentHandle1 to already be set
//

OPERATION OpGen[] = {
    { AzoEcho, NULL, L"Gen object test" },
    { AzoGenCreate,  &GenParentHandle1,L"|",        &GenHandle1,      ERROR_INVALID_NAME },
    { AzoGenCreate,  &GenParentHandle1,L"Name1",    &GenHandle1,      NO_ERROR },
    { AzoDupHandle,  &GenHandle1,      NULL,        &GenHandle2,      NO_ERROR },
    { AzoClose,      &GenHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoClose,      &GenHandle2,      NULL,        NULL,             ERROR_INVALID_HANDLE },
    { AzoGenEnum,    &GenHandle1,      NULL,        &GenHandleE,      ERROR_INVALID_HANDLE },
    { AzoGenEnum,    &GenParentHandle1,NULL,        &GenHandleE,      NO_ERROR, OpAppChildGenEnum1 },
    { AzoGenEnum,    &GenParentHandle1,NULL,        &GenHandleE,      NO_ERROR, OpAppChildGenEnum2 },
    { AzoGenCreate,  &GenParentHandle1,L"Name2",    &GenHandle2,      NO_ERROR },
    { AzoGenEnum,    &GenParentHandle1,NULL,        &GenHandleE,      NO_ERROR, OpAppChildGenEnum2 },
    { AzoClose,      &GenHandle2,      NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Delete an object and make sure it doesn't get enumerated" },
    { AzoGenCreate,  &GenParentHandle1,L"Name3",    &GenHandle2,      NO_ERROR },
    { AzoGenDelete,  &GenParentHandle1,L"Name3",    NULL,             NO_ERROR },
    { AzoClose,      &GenHandle2,      NULL,        NULL,             NO_ERROR },
    { AzoGenEnum,    &GenParentHandle1,NULL,        &GenHandleE,      NO_ERROR, OpAppChildGenEnum2 },

    { AzoEcho, NULL, L"Create an object whose name equals that of a deleted object" },
    { AzoGenCreate,  &GenParentHandle1,L"Name3",    &GenHandle2,      NO_ERROR },
    { AzoClose,      &GenHandle2,      NULL,        NULL,             NO_ERROR },
    { AzoGenEnum,    &GenParentHandle1,NULL,        &GenHandleE,      NO_ERROR, OpAppChildGenEnum2 },

    { AzoEcho, NULL, L"Delete an object that isn't on the tail end of the enum list" },
    { AzoGenDelete,  &GenParentHandle1,L"Name2",    NULL,             NO_ERROR },
    { AzoGenEnum,    &GenParentHandle1,NULL,        &GenHandleE,      NO_ERROR, OpAppChildGenEnum2 },

    { AzoEcho, NULL, L"Basic get/set property tests" },
    { AzoGenCreate,  &GenParentHandle1,L"Name4",    &GenHandle1,      NO_ERROR },
    { AzoGetProp,    &GenHandle1,      NULL,        NULL,             NO_ERROR, NULL, L"Name4",     AZ_PROP_NAME },
    { AzoSetProp,    &GenHandle1,      L"|",        NULL,             ERROR_INVALID_NAME, NULL, NULL, AZ_PROP_NAME },
    { AzoGetProp,    &GenHandle1,      NULL,        NULL,             NO_ERROR, NULL, L"Name4",     AZ_PROP_NAME },
    { AzoSetProp,    &GenHandle1,      L"Name4",    NULL,             ERROR_ALREADY_EXISTS, NULL, NULL, AZ_PROP_NAME },
    { AzoGetProp,    &GenHandle1,      NULL,        NULL,             NO_ERROR, NULL, L"Name4",     AZ_PROP_NAME },
    { AzoSetProp,    &GenHandle1,      L"Name3",    NULL,             ERROR_ALREADY_EXISTS, NULL, NULL, AZ_PROP_NAME },
    { AzoGetProp,    &GenHandle1,      NULL,        NULL,             NO_ERROR, NULL, L"Name4",     AZ_PROP_NAME },
    { AzoGetProp,    &GenHandle1,      NULL,        NULL,             NO_ERROR, NULL, L"",          AZ_PROP_DESCRIPTION },
    { AzoSetProp,    &GenHandle1,      L"WasName4", NULL,             NO_ERROR, NULL, NULL,         AZ_PROP_NAME },
    { AzoSetProp,    &GenHandle1,      L"Nam4 Desc",NULL,             NO_ERROR, NULL, NULL,         AZ_PROP_DESCRIPTION },
    { AzoGetProp,    &GenHandle1,      NULL,        NULL,             NO_ERROR, NULL, L"WasName4",  AZ_PROP_NAME },
    { AzoGetProp,    &GenHandle1,      NULL,        NULL,             NO_ERROR, NULL, L"Nam4 Desc", AZ_PROP_DESCRIPTION },
    { AzoGenEnum,    &GenParentHandle1,NULL,        &GenHandleE,      NO_ERROR, OpAppChildGenEnum2 },
    { AzoClose,      &GenHandle1,      NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Ensure a newly created object is writable" },
    { AzoGenCreate,  &GenParentHandle1,L"Name5",    &GenHandle2,      NO_ERROR },
    { AzoGetProp,    &GenHandle2,      NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&AzGlTrue,  AZ_PROP_WRITABLE },
    { AzoClose,      &GenHandle2,      NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Open test" },
    { AzoGenOpen,    &GenParentHandle1,L"Name1",    &GenHandle1,      NO_ERROR },
    { AzoGetProp,    &GenHandle1,      NULL,        NULL,             NO_ERROR, NULL, L"Name1",     AZ_PROP_NAME },
    { AzoClose,      &GenHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoGenOpen,    &GenParentHandle1,L"NameBad",  &GenHandle1,      ERROR_NOT_FOUND },

    { AzoEndOfList }
};

//
// Operations specific to admin manager objects
//
OPERATION OpAdm[] = {
    { AzoEcho, NULL, L"Admin Manager specific operations" },
    { AzoInit,         NULL,             NULL,      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },

    { AzoEcho, NULL, L"Ensure the admin manager object is marked writable" },
    { AzoGetProp,    &AdminMgrHandle1,   NULL,      NULL,             NO_ERROR, NULL, (LPWSTR)&AzGlTrue,  AZ_PROP_WRITABLE },

    { AzoEcho, NULL, L"Set description on Admin Manager" },
    { AzoGetProp,    &AdminMgrHandle1,     NULL,        NULL,             NO_ERROR, NULL, L"",                     AZ_PROP_DESCRIPTION },
    { AzoSetProp,    &AdminMgrHandle1,     L"Adm Desc", NULL,             NO_ERROR, NULL, NULL,                    AZ_PROP_DESCRIPTION },
    { AzoGetProp,    &AdminMgrHandle1,     NULL,        NULL,             NO_ERROR, NULL, L"Adm Desc",             AZ_PROP_DESCRIPTION },

    { AzoEcho, NULL, L"Set Application Data on AdminManager" },
    { AzoGetProp,    &AdminMgrHandle1,     NULL,        NULL,             NO_ERROR, NULL, L"",                     AZ_PROP_APPLICATION_DATA },
    { AzoSetProp,    &AdminMgrHandle1,     L"Adm Application Data", NULL, NO_ERROR, NULL, NULL,                    AZ_PROP_APPLICATION_DATA },
    { AzoGetProp,    &AdminMgrHandle1,     NULL,        NULL,             NO_ERROR, NULL, L"Adm Application Data", AZ_PROP_APPLICATION_DATA },

    { AzoGetProp,    &AdminMgrHandle1,     NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&FifteenThousand, AZ_PROP_ADMIN_DOMAIN_TIMEOUT },
    { AzoSetProp,    &AdminMgrHandle1,     (LPWSTR)&EightHundred,NULL,     NO_ERROR, NULL, NULL,                    AZ_PROP_ADMIN_DOMAIN_TIMEOUT },
    { AzoGetProp,    &AdminMgrHandle1,     NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&EightHundred,    AZ_PROP_ADMIN_DOMAIN_TIMEOUT },

    { AzoAdmDelete,  &AdminMgrHandle1,     NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AdminMgrHandle1,     NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Test closing admin manager with other handle open" },
    { AzoInit,      NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate, &AdminMgrHandle1, L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoClose,     &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoClose,     &AppHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoInit,      NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, 0 },

    { AzoEcho, NULL, L"Test Setting the list of admins" },
    { AzoGetProp,   &AdminMgrHandle1, NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&SidOwnerArray,  AZ_PROP_POLICY_ADMINS },
    { AzoAddProp,   &AdminMgrHandle1, (LPWSTR)&SidCreatorOwner, NULL, ERROR_INVALID_PARAMETER, NULL, NULL,                    AZ_PROP_POLICY_ADMINS },
    { AzoAddProp,   &AdminMgrHandle1, (LPWSTR)&SidWorld, NULL,        NO_ERROR, NULL, NULL,                    AZ_PROP_POLICY_ADMINS },
    { AzoGetProp,   &AdminMgrHandle1, NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&SidWorldOwnerArray,  AZ_PROP_POLICY_ADMINS },
    { AzoRemProp,   &AdminMgrHandle1, (LPWSTR)&SidOwner, NULL,        NO_ERROR, NULL, NULL,                    AZ_PROP_POLICY_ADMINS },
    { AzoGetProp,   &AdminMgrHandle1, NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&SidWorldArray,  AZ_PROP_POLICY_ADMINS },
    { AzoRemProp,   &AdminMgrHandle1, (LPWSTR)&SidWorld, NULL,        NO_ERROR, NULL, NULL,                    AZ_PROP_POLICY_ADMINS },
    { AzoGetProp,   &AdminMgrHandle1, NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&SidOwnerArray,  AZ_PROP_POLICY_ADMINS },


    { AzoAdmDelete, &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoClose,     &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },

    { AzoEndOfList }
};


//
// Generic operations valid for all children of "admin manager"
//

OPERATION OpAdmChildGen[] = {
    { AzoEcho, NULL, L"Admin Manager generic Child object test" },
    { AzoInit,       NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },

    // Do a bunch of stuff not specific to application children
    { AzoDupHandle,  &AdminMgrHandle1, NULL,        &GenParentHandle1,NO_ERROR },
    { AzoGoSub,      NULL,             NULL,        NULL,             NO_ERROR, OpGen },

    { AzoAdmDelete,  &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

OPERATION OpAdmChildGenDupName[] = {
    { AzoEcho, NULL, L"Test creating two objects with the same name" },
    { AzoInit,       NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoGenCreate,  &AdminMgrHandle1, L"Name1",    &GenHandle1,      NO_ERROR },
    { AzoGenCreate,  &AdminMgrHandle1, L"Name1",    &GenHandle2,      ERROR_ALREADY_EXISTS },
    { AzoClose,      &GenHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,  &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};


//
// Generic operations valid for all children of "application"
//

OPERATION OpAppChildGen[] = {
    { AzoEcho, NULL, L"Application generic Child object test" },
    { AzoInit,       NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,  &AdminMgrHandle1, L"MyApp",    &AppHandle1,      NO_ERROR },

    // Do a bunch of stuff not specific to application children
    { AzoDupHandle,  &AppHandle1,      NULL,        &GenParentHandle1,NO_ERROR },
    { AzoGoSub,      NULL,             NULL,        NULL,             NO_ERROR, OpGen },

    { AzoClose,      &AppHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,  &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

OPERATION OpAppChildGenDupName[] = {
    { AzoEcho, NULL, L"Test creating two objects with the same name" },
    { AzoInit,       NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,  &AdminMgrHandle1, L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoAppCreate,  &AdminMgrHandle1, L"MyApp",    &AppHandle2,      ERROR_ALREADY_EXISTS },
    { AzoGenCreate,  &AppHandle1,      L"Name1",    &GenHandle1,      NO_ERROR },
    { AzoGenCreate,  &AppHandle1,      L"Name1",    &GenHandle2,      ERROR_ALREADY_EXISTS },
    { AzoClose,      &GenHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AppHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,  &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

OPERATION OpAppChildGenLeak[] = {
    { AzoEcho, NULL, L"Test leaking a handle" },
    { AzoInit,         NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1, L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoClose,        &AppHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,    &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};


//
// Generic operations valid for all children of "scope"
//

OPERATION OpScopeChildGen[] = {
    { AzoEcho, NULL, L"Scope generic Child object test" },
    { AzoInit,       NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,  &AdminMgrHandle1, L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoScopeCreate,&AppHandle1,      L"Scope 1",  &ScopeHandle1,    NO_ERROR },

    // Do a bunch of stuff not specific to scope children
    { AzoDupHandle,  &ScopeHandle1,    NULL,        &GenParentHandle1,NO_ERROR },
    { AzoGoSub,      NULL,             NULL,        NULL,             NO_ERROR, OpGen },

    { AzoClose,      &ScopeHandle1,    NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AppHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,  &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

OPERATION OpScopeChildGenDupName[] = {
    { AzoEcho, NULL, L"Test creating two objects with the same name" },
    { AzoInit,       NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,  &AdminMgrHandle1, L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoScopeCreate,&AppHandle1,      L"Scope 1",  &ScopeHandle1,    NO_ERROR },

    { AzoGenCreate,  &ScopeHandle1,    L"Name1",    &GenHandle1,      NO_ERROR },
    { AzoGenCreate,  &ScopeHandle1,    L"Name1",    &GenHandle2,      ERROR_ALREADY_EXISTS },
    { AzoClose,      &GenHandle1,      NULL,        NULL,             NO_ERROR },

    { AzoClose,      &ScopeHandle1,    NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AppHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,  &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

//
// Specific tests for application objects
//

OPERATION OpApplication[] = {
    { AzoEcho, NULL, L"Application object specific tests" },
    { AzoInit,      NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate, &AdminMgrHandle1, L"MyApp",    &AppHandle1,      NO_ERROR },

    { AzoEcho, NULL, L"Ensure CLSID can be set" },
    { AzoGetProp,    &AppHandle1,       NULL,        NULL,             NO_ERROR, NULL, NULL, AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID },
    { AzoSetProp,    &AppHandle1,       L"Rule1",    NULL,             RPC_S_INVALID_STRING_UUID, NULL, NULL,        AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID },
    { AzoSetProp,    &AppHandle1,       ValidGuid,   NULL,             NO_ERROR, NULL, NULL,        AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID },
    { AzoGetProp,    &AppHandle1,       NULL,        NULL,             NO_ERROR, NULL, ValidGuid,   AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID },
    { AzoSetProp,    &AppHandle1,       NULL,        NULL,             NO_ERROR, NULL, NULL,        AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID },
    { AzoGetProp,    &AppHandle1,       NULL,        NULL,             NO_ERROR, NULL, NULL, AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID },

    { AzoEcho, NULL, L"Ensure app version can be set" },
    { AzoGetProp,    &AppHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"",         AZ_PROP_APPLICATION_VERSION },
    { AzoSetProp,    &AppHandle1,       L"2160.5",   NULL,             NO_ERROR, NULL, NULL,        AZ_PROP_APPLICATION_VERSION },
    { AzoGetProp,    &AppHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"2160.5",   AZ_PROP_APPLICATION_VERSION },

    { AzoEcho, NULL, L"Ensure app data can be set" },
    { AzoGetProp,    &AppHandle1,       NULL,                      NULL,             NO_ERROR, NULL, L"",                       AZ_PROP_APPLICATION_DATA },
    { AzoSetProp,    &AppHandle1,       L"App Application Data",   NULL,             NO_ERROR, NULL, NULL,                      AZ_PROP_APPLICATION_DATA },
    { AzoGetProp,    &AppHandle1,       NULL,                      NULL,             NO_ERROR, NULL, L"App Application Data",   AZ_PROP_APPLICATION_DATA },

    { AzoClose,     &AppHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete, &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoClose,     &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};




//
// Specific tests for Operation objects
//

OPERATION OpOperation[] = {
    { AzoEcho, NULL, L"Operation object specific tests" },
    { AzoInit,      NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate, &AdminMgrHandle1, L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoOpCreate,  &AppHandle1,      L"Oper 1",   &OpHandle1,       NO_ERROR },
    { AzoGetProp,    &OpHandle1,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Zero,  AZ_PROP_OPERATION_ID },
    { AzoSetProp,    &OpHandle1,    (LPWSTR)&Eight, NULL,             NO_ERROR, NULL, NULL,           AZ_PROP_OPERATION_ID },
    { AzoGetProp,    &OpHandle1,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Eight, AZ_PROP_OPERATION_ID },

    { AzoEcho, NULL, L"Ensure operation Application data can be set" },
    { AzoGetProp,    &OpHandle1,       NULL,                   NULL,             NO_ERROR, NULL, L"",                    AZ_PROP_APPLICATION_DATA },
    { AzoSetProp,    &OpHandle1,       L"Op Application Data", NULL,             NO_ERROR, NULL, NULL,                   AZ_PROP_APPLICATION_DATA },
    { AzoGetProp,    &OpHandle1,       NULL,                   NULL,             NO_ERROR, NULL, L"Op Application Data", AZ_PROP_APPLICATION_DATA },
    { AzoClose,     &OpHandle1,       NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Ensure an operation ID cannot be reused" },
    { AzoOpCreate,  &AppHandle1,      L"Oper 2",   &OpHandle1,       NO_ERROR },
    { AzoSetProp,    &OpHandle1,    (LPWSTR)&Eight, NULL,            ERROR_ALREADY_EXISTS, NULL, NULL,           AZ_PROP_OPERATION_ID },
    { AzoClose,     &OpHandle1,       NULL,        NULL,             NO_ERROR },

    { AzoClose,     &AppHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete, &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoClose,     &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};



//
// Generic test of the ability of one object to link to another
//  AzoTestLink is the only opcode that can link to this subroutine of commands
//

AZ_STRING_ARRAY EmptyStringArray = { 0, NULL };

ULONG TestLinkOpcodeOffset;
ULONG TestLinkPropId;
AZ_HANDLE TestLinkHandleP;
AZ_HANDLE TestLinkHandleA;
WCHAR TestLinkObjectName[1000];

LPWSTR Op1x[] = { L"Op 1" };
AZ_STRING_ARRAY Op1 = { 1, Op1x };

LPWSTR Op12x[] = { L"Op 1", L"Op 2" };
AZ_STRING_ARRAY Op12 = { 2, Op12x };

LPWSTR Op24x[] = { L"Op 2", L"Op 4" };
AZ_STRING_ARRAY Op24 = { 2, Op24x };

LPWSTR Object2x[] = { L"Object 2" };
AZ_STRING_ARRAY Object2 = { 1, Object2x };

LPWSTR Object3x[] = { L"Object 3" };
AZ_STRING_ARRAY Object3 = { 1, Object3x };

LPWSTR Object23x[] = { L"Object 2", L"Object 3" };
AZ_STRING_ARRAY Object23 = { 2, Object23x };

LPWSTR Object123x[] = { L"Object 1", L"Object 2", L"Object 3" };
AZ_STRING_ARRAY Object123 = { 3, Object123x };

LPWSTR Object123456x[] = { L"Object 1", L"Object 2", L"Object 3", L"Object 4", L"Object 5", L"Object 6" };
AZ_STRING_ARRAY Object123456 = { 6, Object123456x };

OPERATION OpTestLink[] = {
    { AzoEcho, NULL,  L"Create some objects to link the object to" },
    { AzoTlCreate,    &TestLinkHandleP,        L"Object 1",   &OpHandle1,       NO_ERROR },
    { AzoClose,       &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoTlCreate,    &TestLinkHandleP,        L"Object 2",   &OpHandle1,       NO_ERROR },
    { AzoClose,       &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoTlCreate,    &TestLinkHandleP,        L"Object 3",   &OpHandle1,       NO_ERROR },
    { AzoClose,       &OpHandle1,         NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL,  L"Reference an object that doesn't exist" },
    { AzoGetProp,    &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&EmptyStringArray, 1 },
    { AzoSetProp,    &TestLinkHandleA,       L"random",   NULL,             ERROR_INVALID_PARAMETER, NULL, NULL,       1 },
    { AzoAddProp,    &TestLinkHandleA,       L"random",   NULL,             ERROR_NOT_FOUND, NULL, NULL,               1 },

    { AzoEcho, NULL,  L"Add and remove several objects" },
    { AzoAddProp,    &TestLinkHandleA,       L"Object 2",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGetProp,    &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Object2,            1 },
    { AzoAddProp,    &TestLinkHandleA,       L"Object 3",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGetProp,    &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Object23,           1 },
    { AzoAddProp,    &TestLinkHandleA,       L"Object 1",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGetProp,    &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Object123,          1 },
    { AzoRemProp,    &TestLinkHandleA,       L"Object 1",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGetProp,    &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Object23,           1 },
    { AzoRemProp,    &TestLinkHandleA,       L"Object 2",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGetProp,    &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Object3,            1 },

#if 0
    // This test has a couple problems.
    //  It assumes that the linked-to and linked-from objects have the same parents
    //  It assumes that an Open returns the same handle value as a previous close
    { AzoEcho, NULL,  L"Ensure the reference is still there after a close" },
    { AzoClose,       &TestLinkHandleA,       NULL,        NULL,             NO_ERROR },
    { AzoGenOpen,    &TestLinkHandleP,   TestLinkObjectName,  &TestLinkHandleA,     NO_ERROR },
    { AzoGetProp,    &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Object3,            1 },
#endif // 0

    { AzoEcho, NULL,  L"Add an item that already exists" },
    { AzoAddProp,    &TestLinkHandleA,       L"Object 3",   NULL,             ERROR_ALREADY_EXISTS, NULL, NULL,          1 },
    { AzoGetProp,    &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Object3,            1 },
    { AzoRemProp,    &TestLinkHandleA,       L"Object 3",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGetProp,    &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&EmptyStringArray, 1 },

    { AzoEcho, NULL,  L"Try more than 4 since reference buckets come in multiples of 4" },
    { AzoTlCreate,    &TestLinkHandleP,        L"Object 4",   &OpHandle1,       NO_ERROR },
    { AzoClose,       &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoTlCreate,    &TestLinkHandleP,        L"Object 5",   &OpHandle1,       NO_ERROR },
    { AzoClose,       &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoTlCreate,    &TestLinkHandleP,        L"Object 6",   &OpHandle1,       NO_ERROR },
    { AzoClose,       &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoAddProp,    &TestLinkHandleA,       L"Object 1",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoAddProp,    &TestLinkHandleA,       L"Object 4",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoAddProp,    &TestLinkHandleA,       L"Object 2",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoAddProp,    &TestLinkHandleA,       L"Object 5",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoAddProp,    &TestLinkHandleA,       L"Object 3",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoAddProp,    &TestLinkHandleA,       L"Object 6",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGetProp,    &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Object123456,       1 },

    { AzoTlDelete, &TestLinkHandleP,       L"Object 1",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoTlDelete|AzoNoUpdateCache, &TestLinkHandleP,       L"Object 4",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoTlDelete|AzoNoUpdateCache, &TestLinkHandleP,       L"Object 2",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoTlDelete, &TestLinkHandleP,       L"Object 5",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoTlDelete, &TestLinkHandleP,       L"Object 3",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoTlDelete, &TestLinkHandleP,       L"Object 6",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoEndOfList }
};

//
// Generic test of the ability of an object to link to a sid
//  AzoTestLink is the only opcode that can link to this subroutine of commands
//

OPERATION OpTestSid[] = {
    { AzoEcho, NULL,  L"Add and remove several links to sids" },
    { AzoAddProp,    &TestLinkHandleA,   (LPWSTR)&Sid2,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGetProp,    &TestLinkHandleA,   NULL,            NULL,             NO_ERROR, NULL, (LPWSTR)&Sid2Array,            1 },
    { AzoAddProp,    &TestLinkHandleA,   (LPWSTR)&Sid3,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGetProp,    &TestLinkHandleA,   NULL,            NULL,             NO_ERROR, NULL, (LPWSTR)&Sid23Array,           1 },
    { AzoAddProp,    &TestLinkHandleA,   (LPWSTR)&Sid1,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGetProp,    &TestLinkHandleA,   NULL,            NULL,             NO_ERROR, NULL, (LPWSTR)&Sid123Array,          1 },
    { AzoRemProp,    &TestLinkHandleA,   (LPWSTR)&Sid1,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGetProp,    &TestLinkHandleA,   NULL,            NULL,             NO_ERROR, NULL, (LPWSTR)&Sid23Array,           1 },
    { AzoRemProp,    &TestLinkHandleA,   (LPWSTR)&Sid2,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGetProp,    &TestLinkHandleA,   NULL,            NULL,             NO_ERROR, NULL, (LPWSTR)&Sid3Array,            1 },

    { AzoEc