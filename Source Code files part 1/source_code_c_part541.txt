uccess
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,               // ObjUuid
                                         L"ncacn_ip_tcp", // tcpip seq
                                         pwszServerName,  // NetworkAddr
                                         NULL,            // Endpoint
                                         L"",             // Options
                                         &pwszBinding);   // StringBinding

    DBGPRINTF( (DBG_CONTEXT, "\nRpcStringBindingComposeW(%S, %S) return %S."
                " Error = %ld\n",
                L"ncacn_ip_tcp",
                pwszServerName,
                pwszBinding,
                rpcStatus)
              );

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );

        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingFromStringBindingW(%S) return %d."
                    "Binding=%p\n",
                    pwszBinding,
                    rpcStatus,
                    *pBindingHandle)
                  );
    }

    if ( rpcStatus == RPC_S_OK) {

        //
        // set up the security information
        //

        rpcStatus =
          RpcBindingSetAuthInfoW(*pBindingHandle,
                                 pwszInterfaceName,   // pszPrincipalName
                                 RPC_C_AUTHN_LEVEL_CONNECT,
                                 RPC_C_AUTHN_WINNT,
                                 NULL,                // AuthnIdentity
                                 0                    // AuthzSvc
                                 );
        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingSetAuthInfo(%S(Interface=%S), %p)"
                    " return %d.\n",
                    pwszBinding,
                    pwszInterfaceName,
                    *pBindingHandle,
                    rpcStatus
                    )
                  );

    }

    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {

        DWORD rpcStatus1 = RpcStringFreeW(&pwszBinding);
        DBGPRINTF( (DBG_CONTEXT, "RpcStringFreeW() returns %d.",
                    rpcStatus1)
                  );

    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            DWORD rpcStatus1 = RpcBindingFree(*pBindingHandle);
            DBGPRINTF( (DBG_CONTEXT, "RpcBindingFree() returns %d.\n",
                        rpcStatus1)
                      );
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverTcpIp()

#else // CHICAGO



RPC_STATUS
RpcBindHandleOverTcpIp( OUT handle_t * pBindingHandle,
                       IN LPWSTR       pwszServerName,
                       IN LPWSTR       pwszInterfaceName
                       )
/*++

    Windows 95 version

  This function uses the parameters supplied and generates a dynamic end point
     binding handle for RPC over TCP/IP.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPSTR     pszBindingA = NULL;
    CHAR    szServerA[MAX_PATH];
    CHAR    szInterfaceA[MAX_PATH];
    int        cch;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    *szServerA = '0';

    if (pwszServerName)
    cch = WideCharToMultiByte(CP_ACP,
                              0,
                              pwszServerName,
                              -1,
                              szServerA,
                              sizeof(szServerA)/sizeof(CHAR),
                              NULL,NULL
                              );

    *szInterfaceA = '0';

    if(pwszInterfaceName)
    cch = WideCharToMultiByte(CP_ACP,
                              0,
                              pwszInterfaceName,
                              -1,
                              szInterfaceA,
                              sizeof(szInterfaceA)/sizeof(CHAR),
                              NULL,NULL
                              );


    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingCompose(0,            // ObjUuid
                                         "ncacn_ip_tcp", // tcpip seq
                                         szServerA, // NetworkAddr
                                         NULL, // Endpoint
                                         NULL, //L"",  // Options
                                         &pszBindingA);    // StringBinding

    DBGPRINTF( (DBG_CONTEXT, "\nRpcStringBindingCompose(%s, %s) return %s."
                " Error = %ld\n",
                "ncacn_ip_tcp",
                szServerA,
                pszBindingA,
                rpcStatus)
              );

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBinding(pszBindingA,
                                                 pBindingHandle );

        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingFromStringBinding(%s) return %d."
                    "Binding=%08x\n",
                    pszBindingA,
                    rpcStatus,
                    *pBindingHandle)
                  );
    }

    if ( rpcStatus == RPC_S_OK) {

        //
        // set up the security information
        //

        rpcStatus =
          RpcBindingSetAuthInfo(*pBindingHandle,
                                 szInterfaceA,   // pszPrincipalName
                                 RPC_C_AUTHN_LEVEL_CONNECT,
                                 RPC_C_AUTHN_WINNT,
                                 NULL,  // AuthnIdentity
                                 0      // AuthzSvc
                                 );
        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingSetAuthInfo(%s(Interface=%s), %08x)"
                    " return %d.\n",
                    pszBindingA,
                    szInterfaceA,
                    *pBindingHandle,
                    rpcStatus
                    )
                  );

    }

    //
    // Cleanup and return back.
    //

    if ( pszBindingA != NULL) {

        DWORD rpcStatus1 = RpcStringFree(&pszBindingA);
        DBGPRINTF( (DBG_CONTEXT, "RpcStringFreeW() returns %d.",
                    rpcStatus1)
                  );

    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            DWORD rpcStatus1 = RpcBindingFree(*pBindingHandle);
            DBGPRINTF( (DBG_CONTEXT, "RpcBindingFree() returns %d.\n",
                        rpcStatus1)
                      );
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverTcpIp()
#endif



#ifndef CHICAGO
DWORD
RpcuFindProtocolToUse( IN LPCWSTR pwszServerName)
/*++
  Given the server name this funciton determines the protocol
  to use for RPC binding.

  The transport used is determined dynamically based on following rules.

  If server name is NULL or 127.0.0.1 or same as local computer name
      then use the LPC.

  If server name starts with a leading "\\" (double slash),
      then attempt RPC binding over NamedPipe.

  If server name does not start with leading "\\",
      then attempt RPC binding over TCPIP.

  If TCPIP binding fails, then this function tries binding over NamedPipe.


  Argument:
    pwszServerName - pointer to string containing the name of the server


  Returns:
    DWORD containing the type of protocol to use.

--*/
{
    static WCHAR g_wchLocalMachineName[ MAX_COMPUTERNAME_LENGTH + 1];
    BOOL   fLeadingSlashes;
    DWORD  dwBindProtocol = ISRPC_CLIENT_OVER_NP;
    BOOL   fLocalMachine;

    if ( pwszServerName == NULL ||
         _wcsicmp( L"127.0.0.1", pwszServerName) == 0) {


        return (ISRPC_CLIENT_OVER_LPC);
    }

    if ( g_wchLocalMachineName[0] == L'\0') {

        DWORD cchComputerNameLen = MAX_COMPUTERNAME_LENGTH;

        //
        // Obtain the local computer name
        //

        if (!GetComputerNameW( g_wchLocalMachineName,
                              &cchComputerNameLen)
            ) {

            *g_wchLocalMachineName = L'\0';
        }
    }

    fLeadingSlashes = ((*pwszServerName == L'\\') &&
                       (*(pwszServerName+1) == L'\\')
                       );


    //
    // Check to see if machine name matches local computer name
    //  if so, use LPC
    //

    fLocalMachine = !_wcsicmp( g_wchLocalMachineName,
                              ((fLeadingSlashes) ?
                               (pwszServerName + 2) : pwszServerName)
                              );

    if ( fLocalMachine) {

        return (ISRPC_CLIENT_OVER_LPC);
    }

    if ( !fLeadingSlashes) {

        DWORD  nDots;
        LPCWSTR pszName;

        //
        // Check if the name has dotted decimal name.
        // If so then suggest TCP binding.
        //

        for( nDots = 0, pszName = pwszServerName;
            ((pszName = wcschr( pszName, L'.' )) != NULL);
            nDots++, pszName++)
          ;

        if ( nDots == 3) {

            //
            // if the string has 3 DOTs exactly then this string must represent
            // an IpAddress.
            //

            return(ISRPC_CLIENT_OVER_TCPIP);
        }
    }


    return ( ISRPC_CLIENT_OVER_NP);
} // RpcuFindProtocolToUse()
#endif



RPC_STATUS
RpcBindHandleForServer( OUT handle_t * pBindingHandle,
                       IN LPWSTR      pwszServerName,
                       IN LPWSTR      pwszInterfaceName,
                       IN LPWSTR      pwszOptions
                       )
/*++
  This function uses the parameters supplied and generates a binding
    handle for RPC.


  It is assumed that binding over named pipe uses static end point
      with the interface name and options as provided.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name
   pwszOptions      pointer to string containing any additional options for
                       binding.

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus = RPC_S_SERVER_UNAVAILABLE;
    LPWSTR     pwszBinding = NULL;
    DWORD      dwBindProtocol = 0;


    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

#ifndef CHICAGO
    dwBindProtocol = RpcuFindProtocolToUse( pwszServerName);
#else
    dwBindProtocol = ISRPC_CLIENT_OVER_TCPIP;
#endif

    switch ( dwBindProtocol) {

      case ISRPC_CLIENT_OVER_LPC:
        {

            WCHAR  rgchLpc[1024];

            //
            // generate a LPC end point name from the interface name.
            //  the End point =   <InterfaceName>_LPC
            //

            if ( lstrlenW( pwszInterfaceName) >=
                ( sizeof(rgchLpc)/sizeof(WCHAR) - 6)) {

                SetLastError( ERROR_INVALID_PARAMETER);
                return ( ERROR_INVALID_PARAMETER);
            }

            lstrcpyW( rgchLpc, pwszInterfaceName);
            lstrcatW( rgchLpc, L"_LPC");

            //
            // Attempt binding over static LPC.
            //

            rpcStatus = RpcBindHandleOverLpc( pBindingHandle,
                                             rgchLpc,
                                             pwszOptions
                                             );

            DBGPRINTF(( DBG_CONTEXT,
                       " RpcBindingOverLpc(%S) returns %d."
                       " Handle = %p\n",
                       pwszServerName, rpcStatus, *pBindingHandle));

            break;
        }

      case ISRPC_CLIENT_OVER_TCPIP:

// # ifdef RPC_BIND_OVER_TCP

        //
        // Attempt binding over TCPIP using Dynamic Endpoint.
        //

        rpcStatus = RpcBindHandleOverTcpIp( pBindingHandle,
                                           pwszServerName,
                                           pwszInterfaceName);

        DBGPRINTF(( DBG_CONTEXT,
                   " RpcBindingOverTcpIp(%S) returns %d. Handle = %p\n",
                   pwszServerName, rpcStatus, *pBindingHandle));

        if ( rpcStatus == RPC_S_OK) {

            break;  // done with RPC binding over TCP
        }

        // Fall Through

// # endif // RPC_BIND_OVER_TCP

      case ISRPC_CLIENT_OVER_NP:
        {
            WCHAR  rgchNp[1024];

            //
            // generate a NamedPipe end point name from the interface name.
            //  the End point =   \PIPE\<InterfaceName>
            //

            lstrcpyW( rgchNp, L"\\PIPE\\");
            if ( lstrlenW( pwszInterfaceName) >=
                ( sizeof(rgchNp)/sizeof(WCHAR) - 10)) {

                SetLastError( ERROR_INVALID_PARAMETER);
                return ( ERROR_INVALID_PARAMETER);
            }

            lstrcatW( rgchNp, pwszInterfaceName);

            //
            // Attempt binding over static NamedPipe.
            //

            rpcStatus = RpcBindHandleOverNamedPipe( pBindingHandle,
                                                   pwszServerName,
                                                   rgchNp,
                                                   pwszOptions
                                                   );

            DBGPRINTF(( DBG_CONTEXT,
                       " RpcBindingOverNamedPipe(%S) returns %d."
                       " Handle = %p\n",
                       pwszServerName, rpcStatus, *pBindingHandle));
            break;
        }

      default:
        break;

    } // switch()

    return ( rpcStatus);

} // RpcBindHandleForServer()





RPC_STATUS
RpcBindHandleFree(IN OUT handle_t * pBindingHandle)
/*++

  Description:

    This function frees up the binding handle allocated using
      RpcBindHandleForServer(). It uses RPC Binding Free routing to do this.
    This function acts just as a thunk so that the alloc/free of RPC contexts
      are consolidated within this module.

  Arguments:
    pBindingHandle  pointer to RPC binding handle that needs to be freed.


  Returns:
    RPC_STATUS - containig the RPC status. RPC_S_OK for success.

--*/
{

    return ( RpcBindingFree( pBindingHandle));

} // RpcBindHandleFree()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpapi\smtpbind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    srvbind.c

Abstract:

    Contains the RPC bind and un-bind routines for the Server
    Service.

Author:

    Dan Lafferty (danl)     01-Mar-1991

Environment:

    User Mode -Win32

Revision History


 Madan Appiah (madana) 10-Oct-1995 Created.
 Murali R. Krishnan (MuraliK)   15-Nov-1995   Remove Netp routines
 Murali R. Krishnan (MuraliK)   21-Nov-1995   Support TCP/IP binding
 Rohan Phillips   (rohanp)      26-Feb-1997   Moved from K2 tree for smtp

--*/

//
// INCLUDES
//

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <smtpinet.h>

#include <smtpsvc.h>
#include <inetinfo.h>
#include "apiutil.h"

handle_t
NNTP_IMPERSONATE_HANDLE_bind(
    SMTP_IMPERSONATE_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the inet info admin client stubs when
    it is necessary create an RPC binding to the server end with
    impersonation level of security

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcBindHandleForServer(&BindHandle,
                                       ServerName,
                                       SMTP_INTERFACE_NAME,
                                       PROT_SEQ_NP_OPTIONS_W
                                       );


    return BindHandle;
} // SMTP_IMPERSONATE_HANDLE_bind()


handle_t
SMTP_HANDLE_bind (
    SMTP_HANDLE   ServerName)

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the server service client stubs when
    it is necessary to bind to a server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    handle_t    BindingHandle;
    RPC_STATUS  status;

    status = RpcBindHandleForServer(&BindingHandle,
                                   ServerName,
                                   SMTP_INTERFACE_NAME,
                                   PROT_SEQ_NP_OPTIONS_W
                                   );

    return( BindingHandle);
}


void
NNTP_IMPERSONATE_HANDLE_unbind(
    SMTP_IMPERSONATE_HANDLE ServerName,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services
    This routine is called from the inet admin client stubs when it is
    necessary to unbind from the server end.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);

    (VOID ) RpcBindHandleFree(&BindHandle);

    return;
} // SMTP_IMPERSONATE_HANDLE_unbind()


void
SMTP_HANDLE_unbind (
    SMTP_HANDLE   ServerName,
    handle_t        BindingHandle)

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the server service client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
	UNREFERENCED_PARAMETER(ServerName);


	(VOID ) RpcBindHandleFree(&BindingHandle);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpapi\smtpsubs.c ===
/*++

Copyright (c) 1990-1992  Microsoft Corporation

Module Name:

    smtpsubs.c

Abstract:

    Subroutines for LAN Manager APIs.

Author:

    Dan Hinsley (DanHi) 23-Mar-93

Revision History:

--*/

// These must be included first:
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define NOMINMAX                // Avoid stdlib.h vs. windows.h warnings.
#include <windows.h>
#include <apiutil.h>


BOOLEAN
SmtpInitialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN LPVOID lpReserved OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DllHandle);          // avoid compiler warnings


    //
    // Handle attaching smtpsvc.dll to a new process.
    //

    if (Reason == DLL_PROCESS_ATTACH) {

#if 0
        //
        // Initialize RPC Bind Cache
        //

        NetpInitRpcBindCache();
#endif


    //
    // When DLL_PROCESS_DETACH and lpReserved is NULL, then a FreeLibrary
    // call is being made.  If lpReserved is Non-NULL, then ExitProcess is
    // in progress.  These cleanup routines will only be called when
    // a FreeLibrary is being called.  ExitProcess will automatically
    // clean up all process resources, handles, and pending io.
    //
    } else if ((Reason == DLL_PROCESS_DETACH) &&
               (lpReserved == NULL)) {

#if 0
        NetpCloseRpcBindCache();
#endif

    }

    return TRUE;

} // SmtpInitialize
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpapi\smtpstub.c ===
/*++

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    SmtpStub.C

Abstract:

    These are the smtp service API RPC client stubs.

Author:

    Johnson Apacible (johnsona)     17-Oct-1995
        template used srvstub.c (Dan Lafferty)

Environment:

    User Mode - Win32

Revision History:

--*/

//
// INCLUDES
//

#include <windows.h>
#include <apiutil.h>
#include <lmcons.h>     // NET_API_STATUS
#include <inetinfo.h>
#include <smtpapi.h>
#include <smtpsvc.h>


NET_API_STATUS
NET_API_FUNCTION
SmtpQueryStatistics(
    IN  LPWSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr
    )
/*++

Routine Description:

    This is the DLL entrypoint for SmtpGetStatistics

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    level --Level of information required. 100, 101 and 102 are valid
        for all platforms. 302, 402, 403, 502 are valid for the
        appropriate platform.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    *bufptr = NULL;     // Must be NULL so RPC knows to fill it in.

    RpcTryExcept

       apiStatus = SmtprQueryStatistics(
                servername,
                level,
                (LPSTAT_INFO) bufptr);

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // SmtpQueryStatistics

NET_API_STATUS
NET_API_FUNCTION
SmtpClearStatistics(
    IN LPWSTR Server OPTIONAL,  IN DWORD dwInstance)
{
    NET_API_STATUS status;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        status = SmtpClearStatistics(
                     Server, dwInstance
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

} // SmtpClearStatistics

NET_API_STATUS
NET_API_FUNCTION
SmtpGetAdminInformation(
    IN  LPWSTR                  pszServer OPTIONAL,
    OUT LPSMTP_CONFIG_INFO *    ppConfig,
    IN DWORD            dwInstance

    )
/*++

Routine Description:

    This is the DLL entrypoint for SmtpGetAdminInformation

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    ppConfig --Configuration information returned from the server.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    *ppConfig = NULL;     // Must be NULL so RPC knows to fill it in.

    RpcTryExcept

       apiStatus = SmtprGetAdminInformation(
                pszServer,
                (LPSMTP_CONFIG_INFO *) ppConfig,
                dwInstance);

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // SmtpGetAdminInformation


NET_API_STATUS
NET_API_FUNCTION
SmtpSetAdminInformation(
    IN  LPWSTR                  pszServer OPTIONAL,
    IN  LPSMTP_CONFIG_INFO      pConfig,
    IN DWORD            dwInstance

    )
/*++

Routine Description:

    This is the DLL entrypoint for SmtpSetAdminInformation

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    pConfig --Configuration information to be set on the server.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    RpcTryExcept

       apiStatus = SmtprSetAdminInformation(
                pszServer,
                (LPSMTP_CONFIG_INFO) pConfig,
                dwInstance);

    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // SmtpSetAdminInformation



/*++

Routine Description:

    SmtpGetConnectedUserList

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpGetConnectedUserList(
    IN  LPWSTR wszServerName,
    OUT LPSMTP_CONN_USER_LIST *ppConnUserList,
    IN DWORD            dwInstance

    )
{
    NET_API_STATUS apiStatus;

    *ppConnUserList = NULL;

    RpcTryExcept
    {

        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprGetConnectedUserList(
                     wszServerName,
                     ppConnUserList,
                     dwInstance
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}



/*++

Routine Description:

    SmtpDisconnectUser

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpDisconnectUser(
    IN LPWSTR wszServerName,
    IN DWORD dwUserId,
    IN DWORD dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprDisconnectUser(
                     wszServerName,
                     dwUserId,
                     dwInstance
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}



/*++

Routine Description:

    SmtpCreateUser

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpCreateUser(
    IN LPWSTR   wszServerName,
    IN LPWSTR   wszEmail,
    IN LPWSTR   wszForwardEmail,
    IN DWORD    dwLocal,
    IN DWORD    dwMailboxSize,
    IN DWORD    dwMailboxMessageSize,
    IN LPWSTR   wszVRoot,
    IN DWORD    dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept
    {

        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprCreateUser(
                     wszServerName,
                     wszEmail,
                     wszForwardEmail,
                     dwLocal,
                     dwMailboxSize,
                     dwMailboxMessageSize,
                     wszVRoot,
                     dwInstance
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}

/*++

Routine Description:

    SmtpDeleteUser

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpDeleteUser(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN  DWORD dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprDeleteUser(
                     wszServerName,
                     wszEmail,
                     dwInstance
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}

/*++

Routine Description:

    SmtpGetUserProps

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpGetUserProps(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    OUT LPSMTP_USER_PROPS *ppUserProps,
    IN  DWORD dwInstance

    )
{
    NET_API_STATUS apiStatus;

    *ppUserProps = NULL;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprGetUserProps(
                     wszServerName,
                     wszEmail,
                     ppUserProps,
                     dwInstance
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}

/*++

Routine Description:

    SmtpSetUserProps

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpSetUserProps(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN LPSMTP_USER_PROPS pUserProps,
    IN DWORD    dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprSetUserProps(
                     wszServerName,
                     wszEmail,
                     pUserProps,
                     dwInstance
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}


/*++

Routine Description:

    SmtpCreateDistList

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpCreateDistList(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN DWORD dwType,
    IN DWORD dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprCreateDistList(
                     wszServerName,
                     wszEmail,
                     dwType,
                     dwInstance
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}

/*++

Routine Description:

    SmtpDeleteDistList

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpDeleteDistList(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN DWORD dwInstance
    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprDeleteDistList(
                     wszServerName,
                     wszEmail,
                     dwInstance
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}


/*++

Routine Description:

    SmtpCreateDistListMember

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpCreateDistListMember(
    IN LPWSTR   wszServerName,
    IN LPWSTR   wszEmail,
    IN LPWSTR   wszEmailMember,
    IN DWORD    dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept
    {

        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprCreateDistListMember(
                     wszServerName,
                     wszEmail,
                     wszEmailMember,
                     dwInstance
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}

/*++

Routine Description:

    SmtpDeleteDistListMember

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpDeleteDistListMember(
    IN LPWSTR   wszServerName,
    IN LPWSTR   wszEmail,
    IN LPWSTR   wszEmailMember,
    IN  DWORD   dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprDeleteDistListMember(
                     wszServerName,
                     wszEmail,
                     wszEmailMember,
                     dwInstance
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}


/*++

Routine Description:

    SmtpGetNameList

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpGetNameList(
    IN LPWSTR wszServerName,
    IN LPWSTR wszEmail,
    IN DWORD dwType,
    IN DWORD dwRowsRequested,
    IN BOOL fForward,
    OUT LPSMTP_NAME_LIST *ppNameList,
    IN  DWORD   dwInstance

    )
{
    NET_API_STATUS apiStatus;

    // Make sure RPC knows we want them to fill it in
    *ppNameList = NULL;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprGetNameList(
                     wszServerName,
                     wszEmail,
                     dwType,
                     dwRowsRequested,
                     fForward,
                     ppNameList,
                     dwInstance
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}



/*++

Routine Description:

    SmtpGetNameListFromList

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpGetNameListFromList(
    IN  LPWSTR              wszServerName,
    IN  LPWSTR              wszEmailList,
    IN  LPWSTR              wszEmail,
    IN  DWORD               dwType,
    IN  DWORD               dwRowsRequested,
    IN  BOOL                fForward,
    OUT LPSMTP_NAME_LIST    *ppNameList,
    IN  DWORD               dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprGetNameListFromList(
                     wszServerName,
                     wszEmailList,
                     wszEmail,
                     dwType,
                     dwRowsRequested,
                     fForward,
                     ppNameList,
                     dwInstance
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}

/*++

Routine Description:

    SmtpGetVRootSize

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpGetVRootSize(
    IN  LPWSTR      wszServerName,
    IN  LPWSTR      wszVRoot,
    IN  LPDWORD     pdwBytes,
    IN  DWORD       dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprGetVRootSize(
                     wszServerName,
                     wszVRoot,
                     pdwBytes,
                     dwInstance
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}

/*++

Routine Description:

    SmtpBackupRoutingTable

Return Value:

    API Status - NO_ERROR on success, WIN32 error code on failure.

--*/

NET_API_STATUS
NET_API_FUNCTION
SmtpBackupRoutingTable(
    IN  LPWSTR      wszServerName,
    IN  LPWSTR      wszPath,
    IN  DWORD       dwInstance

    )
{
    NET_API_STATUS apiStatus;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = SmtprBackupRoutingTable(
                     wszServerName,
                     wszPath,
                     dwInstance
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return apiStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\server\svcstat.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    svcstat.cpp

Abstract:

    This module contains code for doing statistics rpcs

Author:

    Johnson Apacible (JohnsonA)     12-Nov-1995

Revision History:

--*/

#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "smtpsvc.h"
#include "findiis.hxx"

extern PSMTP_STATISTICS_BLOCK_ARRAY GetServerPerfCounters(PSMTP_IIS_SERVICE pService);

VOID
ClearStatistics(
        VOID
        );

NET_API_STATUS
NET_API_FUNCTION
SmtprQueryStatistics(
    IN SMTP_HANDLE	pszServer,
    IN DWORD		Level,
    OUT LPSTAT_INFO	pBuffer
    )
{
    APIERR							err = 0;	
	PSMTP_IIS_SERVICE				pService = NULL;
	PLIST_ENTRY						pInfoList = NULL;
	PLIST_ENTRY						pEntry = NULL;
	DWORD							dwEntries = 0;
	DWORD							dwAlloc = 0;
	PSMTP_INSTANCE_LIST_ENTRY		pSmtpInfo = NULL;
	PSMTP_STATISTICS_BLOCK_ARRAY	pSmtpStatsBlockArray = NULL;
	PSMTP_STATISTICS_BLOCK			pStatsBlock = NULL;

    _ASSERT( pBuffer != NULL );
    UNREFERENCED_PARAMETER(pszServer);

	pService = (PSMTP_IIS_SERVICE) g_pInetSvc;
    //
    //  Check for proper access.
    //

    err = TsApiAccessCheck( TCP_QUERY_STATISTICS );

    if( err != NO_ERROR ) {
        return (NET_API_STATUS)err;
    }

	pService->AcquireServiceShareLock();
	
	if(g_IsShuttingDown)
	{
		pService->ReleaseServiceShareLock();
		return (NET_API_STATUS)ERROR_REQUEST_ABORTED;
	}

	//
	// get the information list.  Determine the # instances
	//

	if(pService->QueryCurrentServiceState() != SERVICE_RUNNING)
	{
		err = ERROR_REQUEST_ABORTED;
		goto error_exit;
	}


    pInfoList = pService->GetInfoList();
    if (IsListEmpty(pInfoList))
    {
       err = ERROR_INVALID_PARAMETER;
       goto error_exit;
    }
 //
    //  Return the proper statistics based on the infolevel.
    //

    switch( Level ) {

    case 0 : 
		dwEntries = 0;
		for (pEntry = pInfoList->Flink; pEntry != pInfoList; pEntry = pEntry->Flink)
		{
			dwEntries++;
		}

		if (dwEntries == 0)
		{
			err = ERROR_INVALID_PARAMETER;
			goto error_exit;
		}


		dwAlloc = sizeof(SMTP_STATISTICS_BLOCK_ARRAY) + dwEntries * sizeof(SMTP_STATISTICS_BLOCK);
		pSmtpStatsBlockArray = (PSMTP_STATISTICS_BLOCK_ARRAY)MIDL_user_allocate(dwAlloc);
		if (!pSmtpStatsBlockArray)
		{
			err = ERROR_NOT_ENOUGH_MEMORY;
			goto error_exit;
		}

		pSmtpStatsBlockArray->cEntries = dwEntries;
		pStatsBlock = pSmtpStatsBlockArray->aStatsBlock;
		for (pEntry = pInfoList->Flink; pEntry != pInfoList; pEntry = pEntry->Flink)
		{
			pSmtpInfo = (PSMTP_INSTANCE_LIST_ENTRY)
								CONTAINING_RECORD(pEntry,SMTP_INSTANCE_LIST_ENTRY,ListEntry);

			pStatsBlock->dwInstance = pSmtpInfo->dwInstanceId;

			pSmtpInfo->pSmtpServerStatsObj->CopyToStatsBuffer(&(pStatsBlock->Stats_0));
		
			pStatsBlock++;
		}

		pBuffer->StatInfo0 = pSmtpStatsBlockArray;
        
		break;

    default :
        err = ERROR_INVALID_LEVEL;
        break;
    }

error_exit:

	pBuffer->StatInfo0 = pSmtpStatsBlockArray;

	pService->ReleaseServiceShareLock();
    return (NET_API_STATUS)err;

}   // SmtprQueryStatistics

/*

NET_API_STATUS
NET_API_FUNCTION
SmtprQueryStatistics(
    IN SMTP_HANDLE pszServer,
    IN DWORD Level,
    IN LPSTAT_INFO pBuffer,
	IN DWORD dwInstance
    )
{
    APIERR err;
	PSMTP_IIS_SERVICE		pService;
	PSMTP_SERVER_INSTANCE pInstance;

    _ASSERT( pBuffer != NULL );
    UNREFERENCED_PARAMETER(pszServer);

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheck( TCP_QUERY_STATISTICS );

    if( err != NO_ERROR ) {
        return (NET_API_STATUS)err;
    }


	//
	// get a pointer to the global service
	//

	pService = (


	pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
	if(pInstance == NULL)
	{
		return((NET_API_STATUS) ERROR_INVALID_PARAMETER);
	}

    //
    //  Return the proper statistics based on the infolevel.
    //

    switch( Level ) {

    case 0 : 
		
		LPSMTP_STATISTICS_0 pstats0;

		if (!pInstance->GetStatistics(Level, (PCHAR*) &pstats0))
  		{
			err = GetLastError();	
		}
		else
		{			
			pBuffer->StatInfo0 = pstats0;
		}
        break;

    default :
        err = ERROR_INVALID_LEVEL;
        break;
    }

	pInstance->Dereference();
    return (NET_API_STATUS)err;

}   // SmtprQueryStatistics  */



NET_API_STATUS
NET_API_FUNCTION
SmtprClearStatistics(
    SMTP_HANDLE pszServer,
	IN DWORD dwInstance
    )
{
    APIERR err;
	PSMTP_SERVER_INSTANCE pInstance;

    UNREFERENCED_PARAMETER(pszServer);

    //
    //  Check for proper access.
    //

    err = TsApiAccessCheck( TCP_CLEAR_STATISTICS );
    if( err != NO_ERROR ) {
        return (NET_API_STATUS)err;
    }

	pInstance = FindIISInstance((PSMTP_IIS_SERVICE) g_pInetSvc, dwInstance);
	if(pInstance == NULL)
	{
		return((NET_API_STATUS) ERROR_INVALID_PARAMETER);
	}

    //
    //  Clear the statistics.
    //

    pInstance->ClearStatistics();

	pInstance->Dereference();
    return (NET_API_STATUS)err;

}   // SmtprClearStatistics

VOID
ClearStatistics(
        VOID
        )
{

    return;

} // ClearStatistics
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpctrs\smtpctrs.h ===
//#---------------------------------------------------------------
//  File:		smtpctrs.h
//
//  Synopsis:	Offset definitions for the MSN Server's
//				counter objects & counters.
//
//				These offsets *must* start at 0 and be
//				multiples of 2.  In the MsnOpenPerformanceData
//				procecedure, they will be added to the MSN
//				Server's "First Counter" and "First Help"
//				values in order to determine the absolute
//				location of the counter & object names
//				and corresponding help text in the registry.
//
//				This file is used by the MSNCTRS.DLL DLL
//				code as well as the MSNCTRS.INI definition
//				file.  MSNCTRS.INI is parsed by the LODCTR
//				utility to load the object & counter names
//				into the registry.
//
//	Copyright (C) 1995 Microsoft Corporation
//	All rights reserved.
//
//  Authors:	toddch - based on msn sources by rkamicar, keithmo
//----------------------------------------------------------------

#ifndef _SMTPCTRS_H_
#define _SMTPCTRS_H_


//
// disabled tracing by default for the perfmon client code
//
#ifndef	NOTRACE
#define	NOTRACE
#endif

//
//  The SMTP Server counter object.
//

#define SMTP_COUNTER_OBJECT					0


//
//  The individual counters.
//

#define SMTP_BYTES_SENT_TTL_COUNTER						2
#define SMTP_BYTES_SENT_PER_SEC_COUNTER					4
#define SMTP_BYTES_RCVD_TTL_COUNTER						6
#define	SMTP_BYTES_RCVD_PER_SEC_COUNTER					8
#define SMTP_BYTES_TTL_COUNTER							10
#define SMTP_BYTES_TTL_PER_SEC_COUNTER					12

#define SMTP_BYTES_SENT_MSG_COUNTER						14
#define SMTP_BYTES_SENT_MSG_PER_SEC_COUNTER				16
#define SMTP_BYTES_RCVD_MSG_COUNTER						18
#define	SMTP_BYTES_RCVD_MSG_PER_SEC_COUNTER				20
#define SMTP_BYTES_MSG_COUNTER							22
#define SMTP_BYTES_MSG_PER_SEC_COUNTER					24

#define SMTP_MSG_RCVD_TTL_COUNTER						26
#define SMTP_MSG_RCVD_PER_SEC_COUNTER					28
#define SMTP_AVG_RCPTS_PER_MSG_RCVD_COUNTER				30
#define SMTP_BASE_AVG_RCPTS_PER_MSG_RCVD_COUNTER		32
#define SMTP_PCT_LCL_RCPTS_PER_MSG_RCVD_COUNTER			34
#define SMTP_BASE_PCT_LCL_RCPTS_PER_MSG_RCVD_COUNTER	36
#define SMTP_PCT_RMT_RCPTS_PER_MSG_RCVD_COUNTER			38
#define SMTP_BASE_PCT_RMT_RCPTS_PER_MSG_RCVD_COUNTER	40
#define SMTP_MSG_RCVD_REFUSED_SIZE_COUNTER				42
#define SMTP_MSG_RCVD_REFUSED_CADDR_COUNTER				44
#define SMTP_MSG_RCVD_REFUSED_MAIL_COUNTER				46


#define SMTP_MSG_DLVR_TTL_COUNTER						48
#define SMTP_MSG_DLVR_PER_SEC_COUNTER					50
#define SMTP_MSG_DLVR_RETRIES_TTL_COUNTER				52
#define SMTP_AVG_RETRIES_PER_MSG_DLVR_COUNTER			54
#define SMTP_BASE_AVG_RETRIES_PER_MSG_DLVR_COUNTER		56
#define SMTP_MSG_FWD_TTL_COUNTER						58
#define SMTP_MSG_FWD_PER_SEC_COUNTER					60
#define SMTP_NDR_GENERATED_COUNTER						62
#define SMTP_LOCALQ_LENGTH_COUNTER						64
#define SMTP_RETRYQ_LENGTH_COUNTER						66
#define SMTP_NUM_MAILFILE_HANDLES_COUNTER				68
#define SMTP_NUM_QUEUEFILE_HANDLES_COUNTER				70
#define SMTP_CATQ_LENGTH_COUNTER						72

#define SMTP_MSG_SENT_TTL_COUNTER						74
#define SMTP_MSG_SENT_PER_SEC_COUNTER					76
#define SMTP_MSG_SEND_RETRIES_TTL_COUNTER				78
#define SMTP_AVG_RETRIES_PER_MSG_SEND_COUNTER			80
#define SMTP_BASE_AVG_RETRIES_PER_MSG_SEND_COUNTER		82
#define SMTP_AVG_RCPTS_PER_MSG_SENT_COUNTER				84
#define SMTP_BASE_AVG_RCPTS_PER_MSG_SENT_COUNTER		86
#define SMTP_REMOTEQ_LENGTH_COUNTER						88

#define SMTP_DNS_QUERIES_TTL_COUNTER					90
#define SMTP_DNS_QUERIES_PER_SEC_COUNTER				92
#define SMTP_REMOTE_RETRY_QUEUE_LENGTH_COUNTER			94
#define SMTP_PICKUP_QUEUE_LENGTH_COUNTER				96

#define SMTP_CONN_IN_TTL_COUNTER						98
#define SMTP_CONN_IN_CURR_COUNTER						100
#define SMTP_CONN_OUT_TTL_COUNTER						102
#define SMTP_CONN_OUT_CURR_COUNTER						104
#define SMTP_CONN_OUT_REFUSED_COUNTER					106

#define SMTP_ERR_TTL_COUNTER							108
#define SMTP_ERR_PER_SEC_COUNTER						110

#define SMTP_DIR_DROPS_TTL_COUNTER						112
#define SMTP_DIR_DROPS_PER_SEC_COUNTER					114
#define SMTP_RT_LOOKUPS_TTL_COUNTER						116
#define SMTP_RT_LOOKUPS_PER_SEC_COUNTER					118
#define SMTP_ETRN_MSGS_TTL_COUNTER						120
#define SMTP_ETRN_MSGS_PER_SEC_COUNTER					122

#define SMTP_MSG_BADMAIL_NO_RECIPIENTS_COUNTER          124
#define SMTP_MSG_BADMAIL_HOP_COUNT_EXCEEDED_COUNTER     126
#define SMTP_MSG_BADMAIL_FAILURE_GENERAL_COUNTER        128
#define SMTP_MSG_BADMAIL_BAD_PICKUP_FILE_COUNTER        130
#define SMTP_MSG_BADMAIL_EVENT_COUNTER                  132
#define SMTP_MSG_BADMAIL_NDR_OF_DSN_COUNTER             134
#define SMTP_MSG_PENDING_ROUTING_COUNTER                136
#define SMTP_MSG_PENDING_UNREACHABLE_LINK_COUNTER       138
#define SMTP_SUBMITTED_MESSAGES_COUNTER                 140
#define SMTP_DSN_FAILURES_COUNTER                       142
#define SMTP_MSG_IN_LOCAL_DELIVERY_COUNTER              144

#define SMTP_CAT_SUBMISSIONS_COUNTER                    146
#define SMTP_CAT_SUBMISSIONS_PER_SEC_COUNTER            148
#define SMTP_CAT_COMPLETIONS_COUNTER                    150
#define SMTP_CAT_COMPLETIONS_PER_SEC_COUNTER            152
#define SMTP_CAT_CURRENT_CATEGORIZATIONS_COUNTER        154
#define SMTP_CAT_SUCCEEDED_CATEGORIZATIONS_COUNTER      156
#define SMTP_CAT_HARD_FAILURES_COUNTER                  158
#define SMTP_CAT_RETRY_FAILURES_COUNTER                 160
#define SMTP_CAT_RETRY_OUTOFMEMORY_COUNTER              162
#define SMTP_CAT_RETRY_DSLOGON_COUNTER                  164
#define SMTP_CAT_RETRY_DSCONNECTION_COUNTER             166
#define SMTP_CAT_RETRY_GENERIC_COUNTER                  168
#define SMTP_CAT_MSGS_OUT_COUNTER                       170
#define SMTP_CAT_MSGS_CREATED_COUNTER                   172
#define SMTP_CAT_MSGS_ABORTED_COUNTER                   174
#define SMTP_CAT_RECIPS_PRECAT_COUNTER                  176
#define SMTP_CAT_RECIPS_POSTCAT_COUNTER                 178
#define SMTP_CAT_RECIPS_NDRD_COUNTER                    180
#define SMTP_CAT_RECIPS_UNRESOLVED_COUNTER              182
#define SMTP_CAT_RECIPS_AMBIGUOUS_COUNTER               184
#define SMTP_CAT_RECIPS_ILLEGAL_COUNTER                 186
#define SMTP_CAT_RECIPS_LOOP_COUNTER                    188
#define SMTP_CAT_RECIPS_GENERICFAILURE_COUNTER          190
#define SMTP_CAT_RECIPS_INMEMORY_COUNTER                192
#define SMTP_CAT_SENDERS_UNRESOLVED_COUNTER             194
#define SMTP_CAT_SENDERS_AMBIGUOUS_COUNTER              196
#define SMTP_CAT_ADDRESS_LOOKUPS_COUNTER                198
#define SMTP_CAT_ADDRESS_LOOKUPS_PER_SEC_COUNTER        200
#define SMTP_CAT_ADDRESS_LOOKUP_COMPLETIONS_COUNTER     202
#define SMTP_CAT_ADDRESS_LOOKUP_COMPLETIONS_PER_SEC_COUNTER 204
#define SMTP_CAT_ADDRESS_LOOKUPS_NOT_FOUND_COUNTER      206
#define SMTP_CAT_MAILMSG_DUPLICATE_COLLISIONS_COUNTER   208
#define SMTP_CAT_LDAP_CONNECTIONS_COUNTER               210
#define SMTP_CAT_LDAP_CONNECTION_FAILURES_COUNTER       212
#define SMTP_CAT_LDAP_OPEN_CONNECTIONS_COUNTER          214
#define SMTP_CAT_LDAP_BINDS_COUNTER                     216
#define SMTP_CAT_LDAP_BIND_FAILURES_COUNTER             218
#define SMTP_CAT_LDAP_SEARCHES_COUNTER                  220
#define SMTP_CAT_LDAP_SEARCHES_PER_SEC_COUNTER          222
#define SMTP_CAT_LDAP_PAGED_SEARCHES_COUNTER            224
#define SMTP_CAT_LDAP_SEARCH_FAILURES_COUNTER           226
#define SMTP_CAT_LDAP_PAGED_SEARCH_FAILURES_COUNTER     228
#define SMTP_CAT_LDAP_SEARCHES_COMPLETED_COUNTER        230
#define SMTP_CAT_LDAP_SEARCHES_COMPLETED_PER_SEC_COUNTER 232
#define SMTP_CAT_LDAP_PAGED_SEARCHES_COMPLETED_COUNTER  234
#define SMTP_CAT_LDAP_SEARCHES_COMPLETED_FAILURE_COUNTER 236
#define SMTP_CAT_LDAP_PAGED_SEARCHES_COMPLETED_FAILURE_COUNTER 238
#define SMTP_CAT_LDAP_GENERAL_COMPLETION_FAILURES_COUNTER 240
#define SMTP_CAT_LDAP_ABANDONED_SEARCHES_COUNTER        242
#define SMTP_CAT_LDAP_PENDING_SEARCHES_COUNTER          244

// SERVICE_START
// CONNECTION_START
// LAST_CLEAR

#endif  // _SMTPCTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpctrs\perfutil.h ===
//#---------------------------------------------------------------
//  File:		perfutil.h
//
//  Synopsis:	This file supports routines used to parse and
//				create Performance Monitor Data Structures.
//				It actually supports Performance Object types with
//				multiple instances
//
//	Copyright (C) 1995 Microsoft Corporation
//	All rights reserved.
//
//  Authors:	rkamicar - based on msn sources by Russ Blake
//----------------------------------------------------------------

#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//	(assumes dword is 4 bytes long and pointer is a dword in size)
#define ALIGN_ON_DWORD(x) ((VOID *)(((DWORD) x & 0x00000003) ? (((DWORD) x & 0xFFFFFFFC) + 4) : ((DWORD) x)))

extern WCHAR  GLOBAL_STRING[];	// Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];		// get data from foreign computers
extern WCHAR  COSTLY_STRING[];
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL	1
#define QUERY_ITEMS	2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY	4

//
// The definition of the only routine of perfutil.c, It builds part of a
// performance data instance (PERF_INSTANCE_DEFINITION) as described in
// winperf.h
//

HANDLE MonOpenEventLog ();
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

typedef struct _LOCAL_HEAP_INFO_BLOCK {
	DWORD   AllocatedEntries;
	DWORD   AllocatedBytes;
	DWORD   FreeEntries;
	DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;


//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

#define HEAP_PROBE()	{ \
	DWORD   dwHeapStatus[5]; \
	NTSTATUS CallStatus; \
	dwHeapStatus[4] = __LINE__; \
	if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
		REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,	\
			&dwHeapStatus, sizeof(dwHeapStatus));  \
	} else {  \
		REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
			&CallStatus, sizeof (DWORD)); \
	} \
}

#else

#define HEAP_PROBE()	;

#endif

#endif  //_PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpctrs\perfsmtp.c ===
//---------------------------------------------------------------
//  File:       perfsmtp.c
//
//  Synopsis:   This file implements the Extensible Performance
//              Objects for the SMTP service.
//
//  Copyright (C) 1996 Microsoft Corporation
//  All rights reserved.
//
//  Authors:    toddch - based on rkamicar, keithmo source
//----------------------------------------------------------------
#ifdef  THIS_FILE
#undef  THIS_FILE
#endif
static  char    __szTraceSourceFile[] = __FILE__;
#define THIS_FILE   __szTraceSourceFile

#define NOTRACE

#define  INITGUID

#include <nt.h>         // For ntrtl.h
#include <ntrtl.h>      // RtlLargeInteger*()
#include <nturtl.h>     // For windows.h
#include <windows.h>
#include <winperf.h>
#include <lm.h>
#include <string.h>
#include <stdio.h>
#include "smtpdata.h"   // The counter descriptions
#include "smtpctrs.h"   // more counter descriptions
#include "perfutil.h"   // Perfmon support
#include "smtps.h"      // Registry Key strings.
#include "smtpapi.h"        // RPC interface wrappers


#include "dbgtrace.h"

#define ALIGN_ON_QWORD(x)  ((VOID *)(((ULONG_PTR)(x) + ((8)-1)) & ~((ULONG_PTR)(8)-1)))

//
//  Private globals.
//

DWORD   cOpens  = 0;                // Active "opens" reference count.
BOOL    fInitOK   = FALSE;          // TRUE if DLL initialized OK.

//
//  Public prototypes.
//

PM_OPEN_PROC    OpenSmtpPerformanceData;
PM_COLLECT_PROC CollectSmtpPerformanceData;
PM_CLOSE_PROC   CloseSmtpPerformanceData;



//
//  Public functions.
//

/*******************************************************************

    NAME:   OpenSmtpPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate
                performance counters with the registry.

    ENTRY:      lpDeviceNames - Pointer to object ID of each device
                    to be opened.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo 07-Jun-1993 Created.

********************************************************************/
DWORD APIENTRY
OpenSmtpPerformanceData(LPWSTR lpDeviceNames)
{
    PERF_COUNTER_DEFINITION *pctr;
    DWORD   i;
    DWORD   dwFirstCounter = 0;
    DWORD   dwFirstHelp = 0;
    DWORD   err  = NO_ERROR;
    HKEY    hkey = NULL;
    DWORD   size;
    DWORD   type;
    BOOL    fOpenRegKey = FALSE;

#ifndef NOTRACE
    //
    // make sure that tracing is enabled
    //
    InitAsyncTrace();
#endif

    //
    // we need to have another level of scoping here for TraceFunctEnter()
    // to work
    //
    {
    TraceFunctEnter("OpenSmtpPerformanceData");

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). The registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem.
    //
    if(!fInitOK)
    {
        //
        // This is the *first* open - update the indicies in
        // our table with the offset of our counters within the
        // perfmon key.
        //
        DebugTrace(0, "Initializing.");

        //
        //  Open the service's Performance key and get the
        // offsets of our counters within the PerfLib MULTI_SZ.
        //
        err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           SMTP_PERFORMANCE_KEY,
                           0,
                           KEY_READ,
                           &hkey);
        if(err == NO_ERROR) {
            fOpenRegKey = TRUE;
            size = sizeof(DWORD);

            err = RegQueryValueEx(hkey,
                                  "First Counter",
                                  NULL,
                                  &type,
                                  (LPBYTE)&dwFirstCounter,
                                  &size);
        } else {
            DebugTrace(0, "No 'First Counter' key (err = %d) in '%s'",
                    err, SMTP_PERFORMANCE_KEY);
        }
        if(err == NO_ERROR) {
            size = sizeof(DWORD);

            err = RegQueryValueEx(hkey,
                                  "First Help",
                                  NULL,
                                  &type,
                                  (LPBYTE)&dwFirstHelp,
                                  &size);
        } else {
            DebugTrace(0, "No 'First Help' key (err = %d) in '%s'",
                    err, SMTP_PERFORMANCE_KEY);
        }

        if (NO_ERROR == err)
        {
            //
            //  Update the object & counter name & help indicies.
            //
            SmtpDataDefinition.SmtpObjectType.ObjectNameTitleIndex += dwFirstCounter;
            SmtpDataDefinition.SmtpObjectType.ObjectHelpTitleIndex += dwFirstHelp;
    
            pctr = &SmtpDataDefinition.SmtpBytesSentTtl;
    
            for(i = 0; i < NUMBER_OF_SMTP_COUNTERS; i++) {
                pctr->CounterNameTitleIndex += dwFirstCounter;
                pctr->CounterHelpTitleIndex += dwFirstHelp;
                pctr++;
            }
            //
            //  Remember that we initialized OK.
            //
            fInitOK = TRUE;
        } else {
            DebugTrace(0, "No 'First Help' key (err = %d) in '%s'",
                    err, SMTP_PERFORMANCE_KEY);
        }

        if (fOpenRegKey)
        {
            err = RegCloseKey(hkey);
            // This should never fail!
            _ASSERT(err == ERROR_SUCCESS);
        }
    }
    //
    //  Bump open counter.
    //
    cOpens++;

    TraceFunctLeave();
    } // end of TraceFunctEnter() scoping

    return NO_ERROR;

}   // OpenSmtpPerformanceData

/*******************************************************************

    NAME:   CollectSmtpPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate

    ENTRY:  lpValueName - The name of the value to retrieve.

                lppData - On entry contains a pointer to the buffer to
                    receive the completed PerfDataBlock & subordinate
                    structures.  On exit, points to the first bytes
                    *after* the data structures added by this routine.

                lpcbTotalBytes - On entry contains a pointer to the
                    size (in BYTEs) of the buffer referenced by lppData.
                    On exit, contains the number of BYTEs added by this
                    routine.

                lpNumObjectTypes - Receives the number of objects added
                    by this routine.

    RETURNS:    DWORD - Win32 status code.  MUST be either NO_ERROR
                    or ERROR_MORE_DATA.

    HISTORY:
        KeithMo 07-Jun-1993 Created.

********************************************************************/
DWORD APIENTRY
CollectSmtpPerformanceData(LPWSTR    lpValueName,
                          LPVOID  * lppData,
                          LPDWORD   lpcbTotalBytes,
                          LPDWORD   lpNumObjectTypes)
{
    DWORD                       dwQueryType;
    ULONG                       cbRequired;
    DWORD                       * pdwCounter;
    DWORD                       * pdwEndCounter;
    unsigned __int64            * pliCounter;
    SMTP_COUNTER_BLOCK          * pCounterBlock;
    SMTP_DATA_DEFINITION        * pSmtpDataDefinition;
    SMTP_INSTANCE_DEFINITION    * pSmtpInstanceDefinition;
    SMTP_INSTANCE_DEFINITION    * pInstanceTotalDefinition;
    PSMTP_STATISTICS_BLOCK_ARRAY    pSmtpStatsBlockArray;
    PSMTP_STATISTICS_BLOCK      pSmtpStatsBlock;
    LPSMTP_STATISTICS_0         pSmtpStats;
    NET_API_STATUS              neterr;
    DWORD                       dwInstance;
    DWORD                       dwInstanceIndex;
    DWORD                       dwInstanceCount;
    CHAR                        temp[INSTANCE_NAME_SIZE];
    PBYTE			 pchBufferNext = NULL;
    DWORD                       ii;


    TraceFunctEnter("CollectSmtpPerformanceData");

//    DebugTrace(0, " lpValueName     = %08lX (%ls)", lpValueName, lpValueName);
    DebugTrace(0, " lppData         = %08lX (%08lX)",   lppData, *lppData);
    DebugTrace(0, " lpcbTotalBytes  = %08lX (%08lX)",
                                        lpcbTotalBytes, *lpcbTotalBytes);
    DebugTrace(0, " lpNumObjectTypes= %08lX (%08lX)",
                                        lpNumObjectTypes, *lpNumObjectTypes);

    //
    //  No need to even try if we failed to open...
    //

    if(!fInitOK)
    {
        OpenSmtpPerformanceData(NULL);
        if (!fInitOK) {
            ErrorTrace(0, "Initialization failed, aborting.");

            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            //
            //  According to the Performance Counter design, this
            //  is a successful exit.  Go figure.
            //

            TraceFunctLeave();
            return NO_ERROR;
        }
    }

    //
    //  Determine the query type.
    //

    dwQueryType = GetQueryType(lpValueName);

    if(dwQueryType == QUERY_FOREIGN)
    {
        ErrorTrace(0, "Foreign queries not supported.");

        //
        //  We don't do foreign queries.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        TraceFunctLeave();
        return NO_ERROR;
    }

    if(dwQueryType == QUERY_ITEMS)
    {
        //
        //  The registry is asking for a specific object.  Let's
        //  see if we're one of the chosen.
        //

        if(!IsNumberInUnicodeList(
                        SmtpDataDefinition.SmtpObjectType.ObjectNameTitleIndex,
                        lpValueName))
        {
            ErrorTrace(0, "%ls not a supported object type.", lpValueName);

            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            TraceFunctLeave();
            return NO_ERROR;
        }
    }

    //
    //  Query the statistics and see if there has been enough space allocated.
    //  The number of instances will be returned in dwInstanceCount
    //

    neterr = SmtpQueryStatistics( NULL, 0, (LPBYTE *) &pSmtpStatsBlockArray);

    if( neterr != NERR_Success )
    {
        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        TraceFunctLeave();
        return NO_ERROR;
    }


    //
    // Check the space requirement add one to the number of instances for the totals.
    //

    dwInstanceCount = pSmtpStatsBlockArray->cEntries;
    if(*lpcbTotalBytes < (sizeof(SMTP_DATA_DEFINITION) +
            (dwInstanceCount + 1) * (sizeof(SMTP_INSTANCE_DEFINITION) + SIZE_OF_SMTP_PERFORMANCE_DATA)))
     {
        ErrorTrace(0, "%lu bytes of buffer insufficient, need %lu.",
                                            *lpcbTotalBytes, cbRequired);

        //
        //  Nope.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        //
        // Free the returned buffer
        //

        NetApiBufferFree((LPBYTE)pSmtpStatsBlockArray);


        TraceFunctLeave();
        return ERROR_MORE_DATA;
    }


    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    pSmtpDataDefinition = (SMTP_DATA_DEFINITION *)*lppData;
    CopyMemory(pSmtpDataDefinition, &SmtpDataDefinition,
                                            sizeof(SMTP_DATA_DEFINITION));

    //
    // Initialize the Total Instance
    //
    pSmtpInstanceDefinition = (SMTP_INSTANCE_DEFINITION *)(pSmtpDataDefinition + 1);

    pInstanceTotalDefinition = pSmtpInstanceDefinition;
    CopyMemory(pInstanceTotalDefinition, &SmtpInstanceDefinition, sizeof(PERF_INSTANCE_DEFINITION));

    //
    // For the Total Instance update the namelength, insert the name, add 1 for null.
    //
    sprintf(temp,"_Total");

    pInstanceTotalDefinition->PerfInstanceDef.NameLength =
            2 * (MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,temp,-1,
            (pInstanceTotalDefinition->InstanceName),INSTANCE_NAME_SIZE)) + 1;

    // update ByteLength
    pInstanceTotalDefinition->PerfInstanceDef.ByteLength = sizeof(PERF_INSTANCE_DEFINITION) + DWORD_MULTIPLE(pInstanceTotalDefinition->PerfInstanceDef.NameLength);
    pchBufferNext= (PBYTE)pInstanceTotalDefinition + pInstanceTotalDefinition->PerfInstanceDef.ByteLength;
    pchBufferNext = ALIGN_ON_QWORD (pchBufferNext);
    pInstanceTotalDefinition->PerfInstanceDef.ByteLength = (ULONG)((ULONG_PTR)pchBufferNext - (ULONG_PTR)pInstanceTotalDefinition);

    ZeroMemory((PVOID)pchBufferNext, SIZE_OF_SMTP_PERFORMANCE_DATA);


    //
    // Begin looping through Instances.
    //

    pSmtpStatsBlock = pSmtpStatsBlockArray->aStatsBlock;

    for (ii = 0; ii < dwInstanceCount; ii++)

    {
        dwInstance = pSmtpStatsBlock->dwInstance;
        pSmtpStats = &(pSmtpStatsBlock->Stats_0);


        //
        // Copy the (constant, initialized) Instance Definition to the block for the instance.
        //

        pSmtpInstanceDefinition = (SMTP_INSTANCE_DEFINITION *)((PBYTE)pSmtpInstanceDefinition +
                    pSmtpInstanceDefinition->PerfInstanceDef.ByteLength + SIZE_OF_SMTP_PERFORMANCE_DATA);

        CopyMemory(pSmtpInstanceDefinition, &SmtpInstanceDefinition, sizeof(SMTP_INSTANCE_DEFINITION));

        //
        // update the namelength, insert the name, add 1 for null.
        //
        sprintf(temp,"SMTP %u", dwInstance);
        pSmtpInstanceDefinition->PerfInstanceDef.NameLength =
                2 * (MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,temp,-1,
                (pSmtpInstanceDefinition->InstanceName),INSTANCE_NAME_SIZE)) + 1;
        // update ByteLength
        pSmtpInstanceDefinition->PerfInstanceDef.ByteLength = sizeof(PERF_INSTANCE_DEFINITION) + DWORD_MULTIPLE(pSmtpInstanceDefinition->PerfInstanceDef.NameLength);
        pchBufferNext= (PBYTE)pSmtpInstanceDefinition + pSmtpInstanceDefinition->PerfInstanceDef.ByteLength;
        pchBufferNext = ALIGN_ON_QWORD (pchBufferNext);
        pSmtpInstanceDefinition->PerfInstanceDef.ByteLength = (ULONG)((ULONG_PTR)pchBufferNext - (ULONG_PTR)pSmtpInstanceDefinition);


        //
        //  Fill in the counter block.
        //

        pCounterBlock = (SMTP_COUNTER_BLOCK *)((PBYTE)pSmtpInstanceDefinition + pSmtpInstanceDefinition->PerfInstanceDef.ByteLength );
 

        pCounterBlock->PerfCounterBlock.ByteLength = SIZE_OF_SMTP_PERFORMANCE_DATA;

        //
        //  Get the pointer to the first (unsigned __int64) counter.  This
        //  pointer *must* be quadword aligned.
        //

        pliCounter = (unsigned __int64 *)(pCounterBlock + 1);

        DebugTrace(0, "pSmtpDataDefinition = %08lX", pSmtpDataDefinition);
        DebugTrace(0, "pCounterBlock    = %08lX", pCounterBlock);
        DebugTrace(0, "ByteLength       = %08lX",
                            pCounterBlock->PerfCounterBlock.ByteLength);
        DebugTrace(0, "pliCounter       = %08lX", pliCounter);

        //
        //  Move the 'unsigned __int64's into the buffer.
        //

        *pliCounter++ = pSmtpStats->BytesSentTotal;
        *pliCounter++ = pSmtpStats->BytesSentTotal;
        *pliCounter++ = pSmtpStats->BytesRcvdTotal;
        *pliCounter++ = pSmtpStats->BytesRcvdTotal;
        *pliCounter++ = pSmtpStats->BytesSentTotal + pSmtpStats->BytesRcvdTotal;
        *pliCounter++ = pSmtpStats->BytesSentTotal + pSmtpStats->BytesRcvdTotal;

        *pliCounter++ = pSmtpStats->BytesSentMsg;
        *pliCounter++ = pSmtpStats->BytesSentMsg;
        *pliCounter++ = pSmtpStats->BytesRcvdMsg;
        *pliCounter++ = pSmtpStats->BytesRcvdMsg;
        *pliCounter++ = pSmtpStats->BytesSentMsg + pSmtpStats->BytesRcvdMsg;
        *pliCounter++ = pSmtpStats->BytesSentMsg + pSmtpStats->BytesRcvdMsg;

        //
        //  Now move the DWORDs into the buffer.
        //

        pdwCounter = (DWORD *)pliCounter;

        DebugTrace(0, "pdwCounter       = %08lX", pdwCounter);

        // Messages Received
        *pdwCounter++ = pSmtpStats->NumMsgRecvd;
        *pdwCounter++ = pSmtpStats->NumMsgRecvd;
        *pdwCounter++ = pSmtpStats->NumRcptsRecvd;
        *pdwCounter++ = pSmtpStats->NumMsgRecvd * 100;
        *pdwCounter++ = pSmtpStats->NumRcptsRecvdLocal;
        *pdwCounter++ = pSmtpStats->NumRcptsRecvd;
        *pdwCounter++ = pSmtpStats->NumRcptsRecvdRemote;
        *pdwCounter++ = pSmtpStats->NumRcptsRecvd;
        *pdwCounter++ = pSmtpStats->MsgsRefusedDueToSize;
        *pdwCounter++ = pSmtpStats->MsgsRefusedDueToNoCAddrObjects;
        *pdwCounter++ = pSmtpStats->MsgsRefusedDueToNoMailObjects;

        // MTA Deliveries
        *pdwCounter++ = pSmtpStats->NumMsgsDelivered;
        *pdwCounter++ = pSmtpStats->NumMsgsDelivered;
        *pdwCounter++ = pSmtpStats->NumDeliveryRetries;
        *pdwCounter++ = pSmtpStats->NumDeliveryRetries;
        *pdwCounter++ = pSmtpStats->NumMsgsDelivered * 100;
        *pdwCounter++ = pSmtpStats->NumMsgsForwarded;
        *pdwCounter++ = pSmtpStats->NumMsgsForwarded;
        *pdwCounter++ = pSmtpStats->NumNDRGenerated;
        *pdwCounter++ = pSmtpStats->LocalQueueLength;
        *pdwCounter++ = pSmtpStats->RetryQueueLength;
        *pdwCounter++ = pSmtpStats->NumMailFileHandles;
        *pdwCounter++ = pSmtpStats->NumQueueFileHandles;
        *pdwCounter++ = pSmtpStats->CatQueueLength;

        // Messages Sent
        *pdwCounter++ = pSmtpStats->NumMsgsSent;
        *pdwCounter++ = pSmtpStats->NumMsgsSent;
        *pdwCounter++ = pSmtpStats->NumSendRetries;
        *pdwCounter++ = pSmtpStats->NumSendRetries;
        *pdwCounter++ = pSmtpStats->NumMsgsSent * 100;
        *pdwCounter++ = pSmtpStats->NumRcptsSent;
        *pdwCounter++ = pSmtpStats->NumMsgsSent * 100;
        *pdwCounter++ = pSmtpStats->RemoteQueueLength;

        // DNS lookups
        *pdwCounter++ = pSmtpStats->NumDnsQueries;
        *pdwCounter++ = pSmtpStats->NumDnsQueries;
        *pdwCounter++ = pSmtpStats->RemoteRetryQueueLength;

        // Connections
        *pdwCounter++ = pSmtpStats->NumConnInOpen;
        *pdwCounter++ = pSmtpStats->NumConnInOpen - pSmtpStats->NumConnInClose;
        *pdwCounter++ = pSmtpStats->NumConnOutOpen;
        *pdwCounter++ = pSmtpStats->NumConnOutOpen - pSmtpStats->NumConnOutClose;
        *pdwCounter++ = pSmtpStats->NumConnOutRefused;

        *pdwCounter++ = pSmtpStats->NumProtocolErrs;
        *pdwCounter++ = pSmtpStats->NumProtocolErrs;

        *pdwCounter++ = pSmtpStats->DirectoryDrops;
        *pdwCounter++ = pSmtpStats->DirectoryDrops;
        *pdwCounter++ = pSmtpStats->RoutingTableLookups;
        *pdwCounter++ = pSmtpStats->RoutingTableLookups;
        *pdwCounter++ = pSmtpStats->ETRNMessages;
        *pdwCounter++ = pSmtpStats->ETRNMessages;

        // new AQueue counters
        *pdwCounter++ = pSmtpStats->MsgsBadmailNoRecipients;
        *pdwCounter++ = pSmtpStats->MsgsBadmailHopCountExceeded;
        *pdwCounter++ = pSmtpStats->MsgsBadmailFailureGeneral;
        *pdwCounter++ = pSmtpStats->MsgsBadmailBadPickupFile;
        *pdwCounter++ = pSmtpStats->MsgsBadmailEvent;
        *pdwCounter++ = pSmtpStats->MsgsBadmailNdrOfDsn;
        *pdwCounter++ = pSmtpStats->MsgsPendingRouting;
        *pdwCounter++ = pSmtpStats->MsgsPendingUnreachableLink;
        *pdwCounter++ = pSmtpStats->SubmittedMessages;
        *pdwCounter++ = pSmtpStats->DSNFailures;
        *pdwCounter++ = pSmtpStats->MsgsInLocalDelivery;

        // Cat counters
        *pdwCounter++ = pSmtpStats->CatPerfBlock.CatSubmissions;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.CatCompletions;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.CurrentCategorizations;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.SucceededCategorizations;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.HardFailureCategorizations;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.RetryFailureCategorizations;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.RetryOutOfMemory;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.RetryDSLogon;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.RetryDSConnection;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.RetryGeneric;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.MessagesSubmittedToQueueing;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.MessagesCreated;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.MessagesAborted;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.PreCatRecipients;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.PostCatRecipients;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.NDRdRecipients;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.UnresolvedRecipients;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.AmbiguousRecipients;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.IllegalRecipients;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LoopRecipients;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.GenericFailureRecipients;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.RecipsInMemory;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.UnresolvedSenders;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.AmbiguousSenders;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.AddressLookups;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.AddressLookupCompletions;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.AddressLookupsNotFound;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.MailmsgDuplicateCollisions;

        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.Connections;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.ConnectFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.OpenConnections;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.Binds;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.BindFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.Searches;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PagedSearches;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.SearchFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PagedSearchFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.SearchesCompleted;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PagedSearchesCompleted;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.SearchCompletionFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PagedSearchCompletionFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.GeneralCompletionFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.AbandonedSearches;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PendingSearches;
        *pdwCounter++ = 0; // padding

        _ASSERT((BYTE *)pdwCounter - (BYTE *)pCounterBlock ==
                                    SIZE_OF_SMTP_PERFORMANCE_DATA);


        pdwEndCounter = pdwCounter;

        //
        // Increment the Total Block.
        //

        pCounterBlock = (SMTP_COUNTER_BLOCK *)((PCHAR)pInstanceTotalDefinition + pInstanceTotalDefinition->PerfInstanceDef.ByteLength);

        pCounterBlock->PerfCounterBlock.ByteLength = SIZE_OF_SMTP_PERFORMANCE_DATA;

        //
        //  Get the pointer to the first (unsigned __int64) counter.  This
        //  pointer *must* be quadword aligned.
        //

        pliCounter = (unsigned __int64 *)(pCounterBlock + 1);

        //
        //  Increment the 'unsigned __int64's in the buffer.
        //

        *pliCounter++ = *pliCounter + pSmtpStats->BytesSentTotal;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesSentTotal;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesRcvdTotal;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesRcvdTotal;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesSentTotal + pSmtpStats->BytesRcvdTotal;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesSentTotal + pSmtpStats->BytesRcvdTotal;

        *pliCounter++ = *pliCounter + pSmtpStats->BytesSentMsg;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesSentMsg;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesRcvdMsg;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesRcvdMsg;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesSentMsg + pSmtpStats->BytesRcvdMsg;
        *pliCounter++ = *pliCounter + pSmtpStats->BytesSentMsg + pSmtpStats->BytesRcvdMsg;

        //
        //  Increment the DWORDs in the buffer.
        //

        pdwCounter = (DWORD *)pliCounter;

        // Increment the Messages Received
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgRecvd;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgRecvd;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumRcptsRecvd;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgRecvd * 100;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumRcptsRecvdLocal;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumRcptsRecvd;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumRcptsRecvdRemote;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumRcptsRecvd;
        *pdwCounter++ = *pdwCounter + pSmtpStats->MsgsRefusedDueToSize;
        *pdwCounter++ = *pdwCounter + pSmtpStats->MsgsRefusedDueToNoCAddrObjects;
        *pdwCounter++ = *pdwCounter + pSmtpStats->MsgsRefusedDueToNoMailObjects;

        // Increment the MTA Deliveries
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsDelivered;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsDelivered;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumDeliveryRetries;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumDeliveryRetries;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsDelivered * 100;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsForwarded;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsForwarded;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumNDRGenerated;
        *pdwCounter++ = *pdwCounter + pSmtpStats->LocalQueueLength;
        *pdwCounter++ = *pdwCounter + pSmtpStats->RetryQueueLength;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMailFileHandles;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumQueueFileHandles;
        *pdwCounter++ = *pdwCounter + pSmtpStats->CatQueueLength;

        // Increment the Messages Sent
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsSent;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsSent;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumSendRetries;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumSendRetries;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsSent * 100;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumRcptsSent;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumMsgsSent * 100;
        *pdwCounter++ = *pdwCounter + pSmtpStats->RemoteQueueLength;

        // Increment the DNS lookups
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumDnsQueries;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumDnsQueries;
        *pdwCounter++ = *pdwCounter + pSmtpStats->RemoteRetryQueueLength;

        // Increment the Connections
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumConnInOpen;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumConnInOpen - pSmtpStats->NumConnInClose;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumConnOutOpen;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumConnOutOpen - pSmtpStats->NumConnOutClose;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumConnOutRefused;

        *pdwCounter++ = *pdwCounter + pSmtpStats->NumProtocolErrs;
        *pdwCounter++ = *pdwCounter + pSmtpStats->NumProtocolErrs;

        *pdwCounter++ = *pdwCounter +pSmtpStats->DirectoryDrops;
        *pdwCounter++ = *pdwCounter +pSmtpStats->DirectoryDrops;
        *pdwCounter++ = *pdwCounter +pSmtpStats->RoutingTableLookups;
        *pdwCounter++ = *pdwCounter +pSmtpStats->RoutingTableLookups;
        *pdwCounter++ = *pdwCounter +pSmtpStats->ETRNMessages;
        *pdwCounter++ = *pdwCounter +pSmtpStats->ETRNMessages;

        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsBadmailNoRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsBadmailHopCountExceeded;
        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsBadmailFailureGeneral;
        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsBadmailBadPickupFile;
        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsBadmailEvent;
        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsBadmailNdrOfDsn;
        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsPendingRouting;
        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsPendingUnreachableLink;
        *pdwCounter++ = *pdwCounter +pSmtpStats->SubmittedMessages;
        *pdwCounter++ = *pdwCounter +pSmtpStats->DSNFailures;
        *pdwCounter++ = *pdwCounter +pSmtpStats->MsgsInLocalDelivery;


        // Cat counters
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.CatSubmissions;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.CatCompletions;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.CurrentCategorizations;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.SucceededCategorizations;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.HardFailureCategorizations;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.RetryFailureCategorizations;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.RetryOutOfMemory;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.RetryDSLogon;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.RetryDSConnection;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.RetryGeneric;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.MessagesSubmittedToQueueing;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.MessagesCreated;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.MessagesAborted;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.PreCatRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.PostCatRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.NDRdRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.UnresolvedRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.AmbiguousRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.IllegalRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.LoopRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.GenericFailureRecipients;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.RecipsInMemory;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.UnresolvedSenders;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.AmbiguousSenders;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.AddressLookups;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.AddressLookupCompletions;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.AddressLookupsNotFound;
        *pdwCounter++ = *pdwCounter +pSmtpStats->CatPerfBlock.MailmsgDuplicateCollisions;
        //
        // LDAP counters are already global
        //
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.Connections;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.ConnectFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.OpenConnections;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.Binds;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.BindFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.Searches;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PagedSearches;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.SearchFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PagedSearchFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.SearchesCompleted;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PagedSearchesCompleted;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.SearchCompletionFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PagedSearchCompletionFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.GeneralCompletionFailures;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.AbandonedSearches;
        *pdwCounter++ = pSmtpStats->CatPerfBlock.LDAPPerfBlock.PendingSearches;
        *pdwCounter++ = 0; // padding


        _ASSERT((BYTE *)pdwCounter - (BYTE *)pCounterBlock ==
                                    SIZE_OF_SMTP_PERFORMANCE_DATA);

        //
        // Increment in the returned statistics block
        //

        pSmtpStatsBlock++;
    }


    //
    //  Free the API buffer.
    //
    //MIDL_user_free((LPBYTE)pSmtpStats);

    NetApiBufferFree((LPBYTE)pSmtpStatsBlockArray);



    dwInstanceCount++;  // for the _Totals instance.

    pSmtpDataDefinition->SmtpObjectType.TotalByteLength =  (DWORD)((PBYTE)pdwEndCounter- (PBYTE)pSmtpDataDefinition);
    pSmtpDataDefinition->SmtpObjectType.NumInstances = dwInstanceCount;


    //
    //  Update arguments for return.
    //

    *lppData        = (PVOID) pdwEndCounter;
    *lpNumObjectTypes = 1;
    *lpcbTotalBytes   = (DWORD)((BYTE *)pdwEndCounter - (BYTE *)pSmtpDataDefinition);


    DebugTrace(0, "pData            = %08lX", *lppData);
    DebugTrace(0, "NumObjectTypes   = %08lX", *lpNumObjectTypes);
    DebugTrace(0, "cbTotalBytes     = %08lX", *lpcbTotalBytes);
    DebugTrace(0, "sizeof *pSmtpStat = %08lX", sizeof *pSmtpStats);

    //
    //  Success!  Honest!!
    //
    TraceFunctLeave();
    return NO_ERROR;


}   // CollectSmtpPerformanceData

/*******************************************************************

    NAME:   CloseSmtpPerformanceData

    SYNOPSIS:   Terminates the performance counters.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo 07-Jun-1993 Created.

********************************************************************/
DWORD APIENTRY
CloseSmtpPerformanceData(VOID)
{
    TraceFunctEnter("CloseSmtpPerformanceData");
    //
    //  No real cleanup to do here.
    //
    cOpens--;

    TraceFunctLeave();
    //
    // shuts down and flushes all trace statements
    //
#ifndef NOTRACE
    TermAsyncTrace();
#endif

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpctrs\smtpdata.c ===
//#---------------------------------------------------------------
//  File:       smtpdata.h
//
//  Synopsis:   Constant data structures for the SMTP
//              Server's counter objects & counters.
//
//  Copyright (C) 1995 Microsoft Corporation
//  All rights reserved.
//
//  Authors:    toddch - based on msn sources by rkamicar, keithmo
//----------------------------------------------------------------
#ifdef  THISFILE
#undef  THISFILE
#endif
static  const char  __szTraceSourceFile[] = __FILE__;
#define THISFILE    __szTraceSourceFile

#define NOTRACE

#include <windows.h>
#include <winperf.h>
#include "smtpctrs.h"
#include "smtpdata.h"

//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

SMTP_DATA_DEFINITION SmtpDataDefinition =
{
    {
        sizeof(SMTP_DATA_DEFINITION) +      // Total Length of at least one instance
            sizeof(SMTP_INSTANCE_DEFINITION) +
            SIZE_OF_SMTP_PERFORMANCE_DATA,
        sizeof(SMTP_DATA_DEFINITION),       // Definition Length
        sizeof(PERF_OBJECT_TYPE),           // Header Length
        SMTP_COUNTER_OBJECT,                // Name Index into Title DB
        0,                               // String
        SMTP_COUNTER_OBJECT,                // Help Index into Title DB
        0,                               // String
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_SMTP_COUNTERS,
        0,                                  // Default
        PERF_NO_INSTANCES,
        0,                                  // UNICODE instance strings
                                            // These two aren't needed since
                                            // we're not a High Perf. Timer
        { 0, 0 },                           // Sample Time in "Object" units
        { 0, 0 }                            // Freq. of "Object" units in hz.
    },

    {   // SmtpBytesSentTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_SENT_TTL_COUNTER,            // Name Index into Title DB
        0,                                   // String
        SMTP_BYTES_SENT_TTL_COUNTER,            // Help Index into Title DB
        0,
        -6,                                     // Scale (1/10000)
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_SENT_TTL_OFFSET
    },

    {   // SmtpBytesSentPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_SENT_PER_SEC_COUNTER,
        0,
        SMTP_BYTES_SENT_PER_SEC_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_SENT_PER_SEC_OFFSET
    },

    {   // SmtpBytesRcvdTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_RCVD_TTL_COUNTER,
        0,
        SMTP_BYTES_RCVD_TTL_COUNTER,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_RCVD_TTL_OFFSET
    },

    {   // SmtpBytesRcvdPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_RCVD_PER_SEC_COUNTER,
        0,
        SMTP_BYTES_RCVD_PER_SEC_COUNTER,
        0,
        -3,                                     // Scale (1/1)
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_RCVD_PER_SEC_OFFSET
    },

    {   // SmtpBytesTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_TTL_COUNTER,
        0,
        SMTP_BYTES_TTL_COUNTER,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_TTL_OFFSET
    },

    {   // SmtpBytesTtlPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_TTL_PER_SEC_COUNTER,
        0,
        SMTP_BYTES_TTL_PER_SEC_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_TTL_PER_SEC_OFFSET
    },

    {   // SmtpBytesSentMsg
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_SENT_MSG_COUNTER,            // Name Index into Title DB
        0,                                   // String
        SMTP_BYTES_SENT_MSG_COUNTER,            // Help Index into Title DB
        0,
        -6,                                     // Scale (1/10000)
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_SENT_MSG_OFFSET
    },

    {   // SmtpBytesSentMsgPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_SENT_MSG_PER_SEC_COUNTER,
        0,
        SMTP_BYTES_SENT_MSG_PER_SEC_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_SENT_MSG_PER_SEC_OFFSET
    },

    {   // SmtpBytesRcvdMsg
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_RCVD_MSG_COUNTER,
        0,
        SMTP_BYTES_RCVD_MSG_COUNTER,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_RCVD_MSG_OFFSET
    },

    {   // SmtpBytesRcvdMsgPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_RCVD_MSG_PER_SEC_COUNTER,
        0,
        SMTP_BYTES_RCVD_MSG_PER_SEC_COUNTER,
        0,
        -3,                                     // Scale (1/1)
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_RCVD_MSG_PER_SEC_OFFSET
    },

    {   // SmtpBytesMsg
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_MSG_COUNTER,
        0,
        SMTP_BYTES_MSG_COUNTER,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_MSG_OFFSET
    },

    {   // SmtpBytesMsgPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BYTES_MSG_PER_SEC_COUNTER,
        0,
        SMTP_BYTES_MSG_PER_SEC_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(unsigned __int64),
        SMTP_BYTES_MSG_PER_SEC_OFFSET
    },

    {   // SmtpMsgRcvdTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_RCVD_TTL_COUNTER,
        0,
        SMTP_MSG_RCVD_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_RCVD_TTL_OFFSET
    },

    {   // SmtpMsgRcvdPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_RCVD_PER_SEC_COUNTER,
        0,
        SMTP_MSG_RCVD_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_MSG_RCVD_PER_SEC_OFFSET
    },

    {   // SmtpAvgRcptsPerMsgRcvd
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_AVG_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        SMTP_AVG_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        SMTP_AVG_RCPTS_PER_MSG_RCVD_OFFSET
    },

    {   // SmtpBaseAvgRcptsPerMsgRcvd
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BASE_AVG_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        SMTP_BASE_AVG_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        SMTP_BASE_AVG_RCPTS_PER_MSG_RCVD_OFFSET
    },

    {   // SmtpPctLclRcptsPerMsgRcvd
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_PCT_LCL_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        SMTP_PCT_LCL_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        SMTP_PCT_LCL_RCPTS_PER_MSG_RCVD_OFFSET
    },

    {   // SmtpBasePctLclRcptsPerMsgRcvd
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BASE_PCT_LCL_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        SMTP_BASE_PCT_LCL_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        SMTP_BASE_PCT_LCL_RCPTS_PER_MSG_RCVD_OFFSET
    },

    {   // SmtpPctRmtRcptsPerMsgRcvd
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_PCT_RMT_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        SMTP_PCT_RMT_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        SMTP_PCT_RMT_RCPTS_PER_MSG_RCVD_OFFSET
    },

    {   // SmtpBasePctRmtRcptsPerMsgRcvd
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BASE_PCT_RMT_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        SMTP_BASE_PCT_RMT_RCPTS_PER_MSG_RCVD_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        SMTP_BASE_PCT_RMT_RCPTS_PER_MSG_RCVD_OFFSET
    },

    {   // SmtpMsgRcvdRefusedSize
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_RCVD_REFUSED_SIZE_COUNTER,
        0,
        SMTP_MSG_RCVD_REFUSED_SIZE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_RCVD_REFUSED_SIZE_OFFSET
    },

    {   // SmtpMsgRcvdRefusedCAddr
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_RCVD_REFUSED_CADDR_COUNTER,
        0,
        SMTP_MSG_RCVD_REFUSED_CADDR_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_RCVD_REFUSED_CADDR_OFFSET
    },
    
    {   // SmtpMsgRcvdRefusedMail
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_RCVD_REFUSED_MAIL_COUNTER,
        0,
        SMTP_MSG_RCVD_REFUSED_MAIL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_RCVD_REFUSED_MAIL_OFFSET
    },

    {   // SmtpMsgDlvrTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_DLVR_TTL_COUNTER,
        0,
        SMTP_MSG_DLVR_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_DLVR_TTL_OFFSET
    },

    {   // SmtpMsgDlvrPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_DLVR_PER_SEC_COUNTER,
        0,
        SMTP_MSG_DLVR_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_MSG_DLVR_PER_SEC_OFFSET
    },

    {   // SmtpMsgDlvrRetriesTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_DLVR_RETRIES_TTL_COUNTER,
        0,
        SMTP_MSG_DLVR_RETRIES_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_DLVR_RETRIES_TTL_OFFSET
    },

    {   // SmtpAvgRetriesPerMsgDlvr
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_AVG_RETRIES_PER_MSG_DLVR_COUNTER,
        0,
        SMTP_AVG_RETRIES_PER_MSG_DLVR_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        SMTP_AVG_RETRIES_PER_MSG_DLVR_OFFSET
    },

    {   // SmtpBaseAvgRetriesPerMsgDlvr
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BASE_AVG_RETRIES_PER_MSG_DLVR_COUNTER,
        0,
        SMTP_BASE_AVG_RETRIES_PER_MSG_DLVR_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        SMTP_BASE_AVG_RETRIES_PER_MSG_DLVR_OFFSET
    },

    {   // SmtpMsgFwdTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_FWD_TTL_COUNTER,
        0,
        SMTP_MSG_FWD_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_FWD_TTL_OFFSET
    },

    {   // SmtpMsgFwdPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_FWD_PER_SEC_COUNTER,
        0,
        SMTP_MSG_FWD_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_MSG_FWD_PER_SEC_OFFSET
    },

    {   // SmtpNdrGenerated
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_NDR_GENERATED_COUNTER,
        0,
        SMTP_NDR_GENERATED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_NDR_GENERATED_OFFSET
    },

    {   // SmtpLocalQLength
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_LOCALQ_LENGTH_COUNTER,
        0,
        SMTP_LOCALQ_LENGTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_LOCALQ_LENGTH_OFFSET
    },

    {   // SmtpRetryQLength
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_RETRYQ_LENGTH_COUNTER,
        0,
        SMTP_RETRYQ_LENGTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_RETRYQ_LENGTH_OFFSET
    },

    {   // SmtpNumMailFileHandles
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_NUM_MAILFILE_HANDLES_COUNTER,
        0,
        SMTP_NUM_MAILFILE_HANDLES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_NUM_MAILFILE_HANDLES_OFFSET
    },

    {   // SmtpNumQueueFileHandles
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_NUM_QUEUEFILE_HANDLES_COUNTER,
        0,
        SMTP_NUM_QUEUEFILE_HANDLES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_NUM_QUEUEFILE_HANDLES_OFFSET
    },

    {   // SmtpCatQLength
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CATQ_LENGTH_COUNTER,
        0,
        SMTP_CATQ_LENGTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CATQ_LENGTH_OFFSET
    },

    {   // SmtpMsgSentTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_SENT_TTL_COUNTER,
        0,
        SMTP_MSG_SENT_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_SENT_TTL_OFFSET
    },

    {   // SmtpMsgSentPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_SENT_PER_SEC_COUNTER,
        0,
        SMTP_MSG_SENT_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_MSG_SENT_PER_SEC_OFFSET
    },

    {   // SmtpMsgSendRetriesTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_SEND_RETRIES_TTL_COUNTER,
        0,
        SMTP_MSG_SEND_RETRIES_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_SEND_RETRIES_TTL_OFFSET
    },

    {   // SmtpAvgRetriesPerMsgSend
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_AVG_RETRIES_PER_MSG_SEND_COUNTER,
        0,
        SMTP_AVG_RETRIES_PER_MSG_SEND_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        SMTP_AVG_RETRIES_PER_MSG_SEND_OFFSET
    },

    {   // SmtpBaseAvgRetriesPerMsgSend
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BASE_AVG_RETRIES_PER_MSG_SEND_COUNTER,
        0,
        SMTP_BASE_AVG_RETRIES_PER_MSG_SEND_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        SMTP_BASE_AVG_RETRIES_PER_MSG_SEND_OFFSET
    },

    {   // SmtpAvgRcptsPerMsgSent
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_AVG_RCPTS_PER_MSG_SENT_COUNTER,
        0,
        SMTP_AVG_RCPTS_PER_MSG_SENT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        SMTP_AVG_RCPTS_PER_MSG_SENT_OFFSET
    },

    {   // SmtpBaseAvgRcptsPerMsgSent
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_BASE_AVG_RCPTS_PER_MSG_SENT_COUNTER,
        0,
        SMTP_BASE_AVG_RCPTS_PER_MSG_SENT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        SMTP_BASE_AVG_RCPTS_PER_MSG_SENT_OFFSET
    },

    {   // SmtpRemoteQLength
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_REMOTEQ_LENGTH_COUNTER,
        0,
        SMTP_REMOTEQ_LENGTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_REMOTEQ_LENGTH_OFFSET
    },

    {   // SmtpDnsQueriesTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_DNS_QUERIES_TTL_COUNTER,
        0,
        SMTP_DNS_QUERIES_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_DNS_QUERIES_TTL_OFFSET
    },

    {   // SmtpDnsQueriesPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_DNS_QUERIES_PER_SEC_COUNTER,
        0,
        SMTP_DNS_QUERIES_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_DNS_QUERIES_PER_SEC_OFFSET
    },

    {   // SmtpRemoteRetryQueueLemgth
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_REMOTE_RETRY_QUEUE_LENGTH_COUNTER,
        0,
        SMTP_REMOTE_RETRY_QUEUE_LENGTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_REMOTE_RETRY_QUEUE_LENGTH_OFFSET
    },

    {   // SmtpConnInTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CONN_IN_TTL_COUNTER,
        0,
        SMTP_CONN_IN_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CONN_IN_TTL_OFFSET
    },

    {   // SmtpConnInCurr
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CONN_IN_CURR_COUNTER,
        0,
        SMTP_CONN_IN_CURR_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CONN_IN_CURR_OFFSET
    },

    {   // SmtpConnOutTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CONN_OUT_TTL_COUNTER,
        0,
        SMTP_CONN_OUT_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CONN_OUT_TTL_OFFSET
    },

    {   // SmtpConnOutCurr
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CONN_OUT_CURR_COUNTER,
        0,
        SMTP_CONN_OUT_CURR_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CONN_OUT_CURR_OFFSET
    },

    {   // SmtpConnOutRefused
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CONN_OUT_REFUSED_COUNTER,
        0,
        SMTP_CONN_OUT_REFUSED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CONN_OUT_REFUSED_OFFSET
    },

    {   // SmtpErrTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_ERR_TTL_COUNTER,
        0,
        SMTP_ERR_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_ERR_TTL_OFFSET
    },

    {   // SmtpErrPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_ERR_PER_SEC_COUNTER,
        0,
        SMTP_ERR_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_ERR_PER_SEC_OFFSET
    },

    {   // SmtpDirectoryDropsTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_DIR_DROPS_TTL_COUNTER,
        0,
        SMTP_DIR_DROPS_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_DIR_DROPS_OFFSET
    },

    {   // SmtpDirectoryDropsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_DIR_DROPS_PER_SEC_COUNTER,
        0,
        SMTP_DIR_DROPS_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_DIR_DROPS_PER_SEC_OFFSET
    },

    {   // SmtpRoutingTblLookupsTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_RT_LOOKUPS_TTL_COUNTER,
        0,
        SMTP_RT_LOOKUPS_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_RT_LOOKUPS_OFFSET
    },

    {   // SmtpRoutingTblLookupsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_RT_LOOKUPS_PER_SEC_COUNTER,
        0,
        SMTP_RT_LOOKUPS_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_RT_LOOKUPS_PER_SEC_OFFSET
    },

    {   // SmtpETRNMsgsTtl
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_ETRN_MSGS_TTL_COUNTER,
        0,
        SMTP_ETRN_MSGS_TTL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_ETRN_MSGS_OFFSET
    },

    {   // SmtpETRNMsgsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_ETRN_MSGS_PER_SEC_COUNTER,
        0,
        SMTP_ETRN_MSGS_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_ETRN_MSGS_PER_SEC_OFFSET
    },

    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_BADMAIL_NO_RECIPIENTS_COUNTER,
        0,
        SMTP_MSG_BADMAIL_NO_RECIPIENTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_BADMAIL_NO_RECIPIENTS_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_BADMAIL_HOP_COUNT_EXCEEDED_COUNTER,
        0,
        SMTP_MSG_BADMAIL_HOP_COUNT_EXCEEDED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_BADMAIL_HOP_COUNT_EXCEEDED_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_BADMAIL_FAILURE_GENERAL_COUNTER,
        0,
        SMTP_MSG_BADMAIL_FAILURE_GENERAL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_BADMAIL_FAILURE_GENERAL_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_BADMAIL_BAD_PICKUP_FILE_COUNTER,   
        0,
        SMTP_MSG_BADMAIL_BAD_PICKUP_FILE_COUNTER,   
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_BADMAIL_BAD_PICKUP_FILE_OFFSET     
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_BADMAIL_EVENT_COUNTER,            
        0,
        SMTP_MSG_BADMAIL_EVENT_COUNTER,              
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_BADMAIL_EVENT_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_BADMAIL_NDR_OF_DSN_COUNTER,
        0,
        SMTP_MSG_BADMAIL_NDR_OF_DSN_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_BADMAIL_NDR_OF_DSN_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_PENDING_ROUTING_COUNTER,   
        0,
        SMTP_MSG_PENDING_ROUTING_COUNTER,   
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_PENDING_ROUTING_OFFSET         
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_PENDING_UNREACHABLE_LINK_COUNTER,
        0,
        SMTP_MSG_PENDING_UNREACHABLE_LINK_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_PENDING_UNREACHABLE_LINK_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_SUBMITTED_MESSAGES_COUNTER,
        0,
        SMTP_SUBMITTED_MESSAGES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_SUBMITTED_MESSAGES_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_DSN_FAILURES_COUNTER,
        0,
        SMTP_DSN_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_DSN_FAILURES_OFFSET
    },
    {   
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_MSG_IN_LOCAL_DELIVERY_COUNTER,   
        0,
        SMTP_MSG_IN_LOCAL_DELIVERY_COUNTER,   
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MSG_IN_LOCAL_DELIVERY_OFFSET   
    },
    {   // CatSubmissions
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_SUBMISSIONS_COUNTER,
        0,
        SMTP_CAT_SUBMISSIONS_COUNTER,
        
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CATSUBMISSIONS_OFFSET
    },
    {   // CatSubmissionsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_SUBMISSIONS_PER_SEC_COUNTER,
        0,
        SMTP_CAT_SUBMISSIONS_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_CATSUBMISSIONS_OFFSET
    },
    {   // CatCompletions
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_COMPLETIONS_COUNTER,
        0,
        SMTP_CAT_COMPLETIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CATCOMPLETIONS_OFFSET
    },
    {   // CatCompletionsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_COMPLETIONS_PER_SEC_COUNTER,
        0,
        SMTP_CAT_COMPLETIONS_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_CATCOMPLETIONS_OFFSET
    },
    {   // CatCurrentCategorizations
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_CURRENT_CATEGORIZATIONS_COUNTER,
        0,
        SMTP_CAT_CURRENT_CATEGORIZATIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CURRENTCATEGORIZATIONS_OFFSET
    },
    {   // CatSucceededCategorizations
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_SUCCEEDED_CATEGORIZATIONS_COUNTER,
        0,
        SMTP_CAT_SUCCEEDED_CATEGORIZATIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_SUCCEEDEDCATEGORIZATIONS_OFFSET
    },
    {   // CatHardFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_HARD_FAILURES_COUNTER,
        0,
        SMTP_CAT_HARD_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_HARDFAILURECATEGORIZATIONS_OFFSET
    },
    {   // CatRetryFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RETRY_FAILURES_COUNTER,
        0,
        SMTP_CAT_RETRY_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_RETRYFAILURECATEGORIZATIONS_OFFSET
    },
    {   // CatOutOfMemoryFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RETRY_OUTOFMEMORY_COUNTER,
        0,
        SMTP_CAT_RETRY_OUTOFMEMORY_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_RETRYOUTOFMEMORY_OFFSET
    },
    {   // CatDsLogonFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RETRY_DSLOGON_COUNTER,
        0,
        SMTP_CAT_RETRY_DSLOGON_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_RETRYDSLOGON_OFFSET
    },
    {   // CatDsConnectionFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RETRY_DSCONNECTION_COUNTER,
        0,
        SMTP_CAT_RETRY_DSCONNECTION_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_RETRYDSCONNECTION_OFFSET
    },
    {   // CatGenericRetryFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RETRY_GENERIC_COUNTER,
        0,
        SMTP_CAT_RETRY_GENERIC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_RETRYDSLOGON_OFFSET
    },
    {   // CatMsgsOut
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_MSGS_OUT_COUNTER,
        0,
        SMTP_CAT_MSGS_OUT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MESSAGESSUBMITTEDTOQUEUEING_OFFSET
    },
    {   // CatMsgsCreated
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_MSGS_CREATED_COUNTER,
        0,
        SMTP_CAT_MSGS_CREATED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MESSAGESCREATED_OFFSET
    },
    {   // CatMsgsAborted
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_MSGS_ABORTED_COUNTER,
        0,
        SMTP_CAT_MSGS_ABORTED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MESSAGESABORTED_OFFSET
    },
    {   // CatRecipsPreCat
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_PRECAT_COUNTER,
        0,
        SMTP_CAT_RECIPS_PRECAT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_PRECATRECIPIENTS_OFFSET
    },
    {   // CatRecipsPostCat
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_POSTCAT_COUNTER,
        0,
        SMTP_CAT_RECIPS_POSTCAT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_POSTCATRECIPIENTS_OFFSET
    },
    {   // CatRecipsNDRd
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_NDRD_COUNTER,
        0,
        SMTP_CAT_RECIPS_NDRD_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_NDRDRECIPIENTS_OFFSET
    },
    {   // CatRecipsUnresolved
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_UNRESOLVED_COUNTER,
        0,
        SMTP_CAT_RECIPS_UNRESOLVED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_UNRESOLVEDRECIPIENTS_OFFSET
    },
    {   // CatRecipsAmbiguous
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_AMBIGUOUS_COUNTER,
        0,
        SMTP_CAT_RECIPS_AMBIGUOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_AMBIGUOUSRECIPIENTS_OFFSET
    },
    {   // CatRecipsIllegal
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_ILLEGAL_COUNTER,
        0,
        SMTP_CAT_RECIPS_ILLEGAL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_ILLEGALRECIPIENTS_OFFSET
    },
    {   // CatRecipsLoop
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_LOOP_COUNTER,
        0,
        SMTP_CAT_RECIPS_LOOP_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_LOOPRECIPIENTS_OFFSET
    },
    {   // CatRecipsGenericFailure
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_GENERICFAILURE_COUNTER,
        0,
        SMTP_CAT_RECIPS_GENERICFAILURE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_GENERICFAILURERECIPIENTS_OFFSET
    },
    {   // CatRecipsInMemory
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_RECIPS_INMEMORY_COUNTER,
        0,
        SMTP_CAT_RECIPS_INMEMORY_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_RECIPSINMEMORY_OFFSET
    },
    {   // CatSendersUnresolved
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_SENDERS_UNRESOLVED_COUNTER,
        0,
        SMTP_CAT_SENDERS_UNRESOLVED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_UNRESOLVEDSENDERS_OFFSET
    },
    {   // CatSendersAmbiguous
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_SENDERS_AMBIGUOUS_COUNTER,
        0,
        SMTP_CAT_SENDERS_AMBIGUOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_AMBIGUOUSSENDERS_OFFSET
    },
    {   // CatAddressLookups
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_ADDRESS_LOOKUPS_COUNTER,
        0,
        SMTP_CAT_ADDRESS_LOOKUPS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_ADDRESSLOOKUPS_OFFSET
    },
    {   // CatAddressLookupsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_ADDRESS_LOOKUPS_PER_SEC_COUNTER,
        0,
        SMTP_CAT_ADDRESS_LOOKUPS_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_ADDRESSLOOKUPS_OFFSET
    },
    {   // CatAddressCompletions
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_ADDRESS_LOOKUP_COMPLETIONS_COUNTER,
        0,
        SMTP_CAT_ADDRESS_LOOKUP_COMPLETIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_ADDRESSLOOKUPCOMPLETIONS_OFFSET
    },
    {   // CatAddressCompletionsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_ADDRESS_LOOKUP_COMPLETIONS_PER_SEC_COUNTER,
        0,
        SMTP_CAT_ADDRESS_LOOKUP_COMPLETIONS_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_ADDRESSLOOKUPCOMPLETIONS_OFFSET
    },
    {   // CatAddressLookupsNotFound
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_ADDRESS_LOOKUPS_NOT_FOUND_COUNTER,
        0,
        SMTP_CAT_ADDRESS_LOOKUPS_NOT_FOUND_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_ADDRESSLOOKUPSNOTFOUND_OFFSET
    },
    {   // CatMailMsgDuplicateCollisions
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_MAILMSG_DUPLICATE_COLLISIONS_COUNTER,
        0,
        SMTP_CAT_MAILMSG_DUPLICATE_COLLISIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_MAILMSGDUPLICATECOLLISIONS_OFFSET
    },
    {   // CatLDAPConnections
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_CONNECTIONS_COUNTER,
        0,
        SMTP_CAT_LDAP_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CONNECTIONS_OFFSET
    },
    {   // CatLDAPConnectionFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_CONNECTION_FAILURES_COUNTER,
        0,
        SMTP_CAT_LDAP_CONNECTION_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_CONNECTFAILURES_OFFSET
    },
    {   // CatLDAPOpenConnections
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_OPEN_CONNECTIONS_COUNTER,
        0,
        SMTP_CAT_LDAP_OPEN_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_OPENCONNECTIONS_OFFSET
    },
    {   // CatLDAPBinds
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_BINDS_COUNTER,
        0,
        SMTP_CAT_LDAP_BINDS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_BINDS_OFFSET
    },
    {   // CatLDAPBindFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_BIND_FAILURES_COUNTER,
        0,
        SMTP_CAT_LDAP_BIND_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_BINDFAILURES_OFFSET
    },
    {   // CatLDAPSearches
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_SEARCHES_COUNTER,
        0,
        SMTP_CAT_LDAP_SEARCHES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_SEARCHES_OFFSET
    },
    {   // CatLDAPSearchesPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_SEARCHES_PER_SEC_COUNTER,
        0,
        SMTP_CAT_LDAP_SEARCHES_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_SEARCHES_OFFSET
    },
    {   // CatLDAPPagedSearches
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_PAGED_SEARCHES_COUNTER,
        0,
        SMTP_CAT_LDAP_PAGED_SEARCHES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_PAGEDSEARCHES_OFFSET
    },
    {   // CatLDAPSearchFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_SEARCH_FAILURES_COUNTER,
        0,
        SMTP_CAT_LDAP_SEARCH_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_SEARCHFAILURES_OFFSET
    },
    {   // CatLDAPPagedSearchFailures
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_PAGED_SEARCH_FAILURES_COUNTER,
        0,
        SMTP_CAT_LDAP_PAGED_SEARCH_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_PAGEDSEARCHFAILURES_OFFSET
    },
    {   // CatLDAPSearchesCompleted
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_SEARCHES_COMPLETED_COUNTER,
        0,
        SMTP_CAT_LDAP_SEARCHES_COMPLETED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_SEARCHESCOMPLETED_OFFSET
    },
    {   // CatLDAPSearchesCompletedPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_SEARCHES_COMPLETED_PER_SEC_COUNTER,
        0,
        SMTP_CAT_LDAP_SEARCHES_COMPLETED_PER_SEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        SMTP_SEARCHESCOMPLETED_OFFSET
    },
    {   // CatLDAPPagedSearchesCompleted
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_PAGED_SEARCHES_COMPLETED_COUNTER,
        0,
        SMTP_CAT_LDAP_PAGED_SEARCHES_COMPLETED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_PAGEDSEARCHESCOMPLETED_OFFSET
    },
    {   // CatLDAPSearchesCompeltedFailure
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_SEARCHES_COMPLETED_FAILURE_COUNTER,
        0,
        SMTP_CAT_LDAP_SEARCHES_COMPLETED_FAILURE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_SEARCHCOMPLETIONFAILURES_OFFSET
    },
    {   // CatLDAPPagedSearchesCompletedFailure
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_PAGED_SEARCHES_COMPLETED_FAILURE_COUNTER,
        0,
        SMTP_CAT_LDAP_PAGED_SEARCHES_COMPLETED_FAILURE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_PAGEDSEARCHCOMPLETIONFAILURES_OFFSET
    },
    {   // CatLDAPGeneralCompletionFailure
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_GENERAL_COMPLETION_FAILURES_COUNTER,
        0,
        SMTP_CAT_LDAP_GENERAL_COMPLETION_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_GENERALCOMPLETIONFAILURES_OFFSET
    },
    {   // CatLDAPAbandonedSearches
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_ABANDONED_SEARCHES_COUNTER,
        0,
        SMTP_CAT_LDAP_ABANDONED_SEARCHES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_ABANDONEDSEARCHES_OFFSET
    },
    {   // CatLDAPPendingSearches
        sizeof(PERF_COUNTER_DEFINITION),
        SMTP_CAT_LDAP_PENDING_SEARCHES_COUNTER,
        0,
        SMTP_CAT_LDAP_PENDING_SEARCHES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SMTP_PENDINGSEARCHES_OFFSET
    }
};


// Initialize the Instance Data Structure.  Parts will be updated at collection time.

SMTP_INSTANCE_DEFINITION         SmtpInstanceDefinition =
{
    {
        sizeof(SMTP_INSTANCE_DEFINITION),   // ByteLength
        0,                                  // ParentObjectTitleIndex
        0,                                  // ParentObjectInstance
        PERF_NO_UNIQUE_ID,                  // UniqueID
        sizeof(PERF_INSTANCE_DEFINITION),   // OffsetToName
        0                                   // NameLength (will be updated)
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpctrs\perfmsg.h ===
//#---------------------------------------------------------------
//  File:		perfmsg.h
//
//  Synopsis:	This file provides the macros and definitions
//				used by the extensible counters for reporting
//				events to the event logging facility.

//
//	Copyright (C) 1995 Microsoft Corporation
//	All rights reserved.
//
//  Authors:	toddch - based on msn sources by rkamicar, a-robw
//----------------------------------------------------------------

#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  "smtpctrs"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//	Levels:  LOG_NONE = No event log messages ever
//			LOG_USER = User event log messages (e.g. errors)
//			LOG_DEBUG = Minimum Debugging
//			LOG_VERBOSE = Maximum Debugging
//

#define  LOG_NONE	0
#define  LOG_USER	1
#define  LOG_DEBUG	2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//	REPORT_xxx (message_value, message_level)
//	where:
//		xxx is the severity to be displayed in the event log
//		message_value is the numeric ID from above
//		message_level is the "filtering" level of error reporting
//			using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the
//
//	REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpctrs\perfutil.c ===
//#---------------------------------------------------------------
//  File:		perfutil.c
//
//  Synopsis:	This file implements the utility routines used
//				to construct the common parts of a
//				PERF_INSTANCE_DEFINITION (see winperf.h) and
//				perform event logging functions.
//
//	Copyright (C) 1995 Microsoft Corporation
//	All rights reserved.
//
//  Authors:	toddch - based on msn sources by rkamicar, Russ Blake
//----------------------------------------------------------------
#ifdef	THISFILE
#undef	THISFILE
#endif
static	const char	__szTraceSourceFile[] = __FILE__;
#define	THISFILE	__szTraceSourceFile

#define NOTRACE
//
//  include files
//
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "smtpctrs.h"	// error message definition
#include "perfmsg.h"
#include "perfutil.h"

//
// Global data definitions.
//

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";	// pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT	1
#define DELIMITER   2
#define INVALID	3

#define EvalThisChar(c,d) (\
	(c == d) ? DELIMITER : \
	(c == 0) ? DELIMITER : \
	(c < (WCHAR)'0') ? INVALID : \
	(c > (WCHAR)'9') ? INVALID : \
	DIGIT)

DWORD
GetQueryType (
	IN LPWSTR lpValue
)
/*++

GetQueryType

	returns the type of query described in the lpValue string so that
	the appropriate processing method may be used

Arguments

	IN lpValue
		string passed to PerfRegQuery Value for processing

Return Value

	QUERY_GLOBAL
		if lpValue == 0 (null pointer)
		lpValue == pointer to Null string
		lpValue == pointer to "Global" string

	QUERY_FOREIGN
		if lpValue == pointer to "Foriegn" string

	QUERY_COSTLY
		if lpValue == pointer to "Costly" string

	otherwise:

	QUERY_ITEMS

--*/
{
	WCHAR   *pwcArgChar, *pwcTypeChar;
	BOOL	bFound;

	if (lpValue == 0) {
		return QUERY_GLOBAL;
	} else if (*lpValue == 0) {
		return QUERY_GLOBAL;
	}

	// check for "Global" request

	pwcArgChar = lpValue;
	pwcTypeChar = GLOBAL_STRING;
	bFound = TRUE;  // assume found until contradicted

	// check to the length of the shortest string

	while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
		if (*pwcArgChar++ != *pwcTypeChar++) {
			bFound = FALSE; // no match
			break;		// bail out now
		}
	}

	if (bFound) return QUERY_GLOBAL;

	// check for "Foreign" request

	pwcArgChar = lpValue;
	pwcTypeChar = FOREIGN_STRING;
	bFound = TRUE;  // assume found until contradicted

	// check to the length of the shortest string

	while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
		if (*pwcArgChar++ != *pwcTypeChar++) {
			bFound = FALSE; // no match
			break;		// bail out now
		}
	}

	if (bFound) return QUERY_FOREIGN;

	// check for "Costly" request

	pwcArgChar = lpValue;
	pwcTypeChar = COSTLY_STRING;
	bFound = TRUE;  // assume found until contradicted

	// check to the length of the shortest string

	while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
		if (*pwcArgChar++ != *pwcTypeChar++) {
			bFound = FALSE; // no match
			break;		// bail out now
		}
	}

	if (bFound) return QUERY_COSTLY;

	// if not Global and not Foreign and not Costly,
	// then it must be an item list

	return QUERY_ITEMS;

}


BOOL
IsNumberInUnicodeList (
	IN DWORD   dwNumber,
	IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

	IN dwNumber
		DWORD number to find in list

	IN lpwszUnicodeList
		Null terminated, Space delimited list of decimal numbers

Return Value:

	TRUE:
			dwNumber was found in the list of unicode number strings

	FALSE:
			dwNumber was not found in the list.

--*/
{
	DWORD   dwThisNumber;
	WCHAR   *pwcThisChar;
	BOOL	bValidNumber;
	BOOL	bNewItem;
	WCHAR   wcDelimiter;	// could be an argument to be more flexible

	if (lpwszUnicodeList == 0) return FALSE;	// null pointer, # not founde

	pwcThisChar = lpwszUnicodeList;
	dwThisNumber = 0;
	wcDelimiter = (WCHAR)' ';
	bValidNumber = FALSE;
	bNewItem = TRUE;

	while (TRUE) {
		switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
			case DIGIT:
				// if this is the first digit after a delimiter, then
				// set flags to start computing the new number
				if (bNewItem) {
					bNewItem = FALSE;
					bValidNumber = TRUE;
				}
				if (bValidNumber) {
					dwThisNumber *= 10;
					dwThisNumber += (*pwcThisChar - (WCHAR)'0');
				}
				break;

			case DELIMITER:
				// a delimter is either the delimiter character or the
				// end of the string ('\0') if when the delimiter has been
				// reached a valid number was found, then compare it to the
				// number from the argument list. if this is the end of the
				// string and no match was found, then return.
				//
				if (bValidNumber) {
					if (dwThisNumber == dwNumber) return TRUE;
					bValidNumber = FALSE;
				}
				if (*pwcThisChar == 0) {
					return FALSE;
				} else {
					bNewItem = TRUE;
					dwThisNumber = 0;
				}
				break;

			case INVALID:
				// if an invalid character was encountered, ignore all
				// characters up to the next delimiter and then start fresh.
				// the invalid number is not compared.
				bValidNumber = FALSE;
				break;

			default:
				break;

		}
		pwcThisChar++;
	}

}   // IsNumberInUnicodeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpmd\ansimeta.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       ansimeta.h

   Abstract:

        WRAPPER functions for ANSI calls of UNICODE ADMCOM interface

   Environment:

      Win32 User Mode

   Author:

      jaroslad  (jan 1997)

--*/

#ifndef _ANSIMETA__H
#define _ANSIMETA__H

#include <tchar.h>
#include <afx.h>

#include <iadmw.h>




class ANSI_smallIMSAdminBase
    {

        
    public:
		IMSAdminBase * m_pcAdmCom;   //interface pointer to Metabase Admin

		ANSI_smallIMSAdminBase (){m_pcAdmCom=0;};

	  void SetInterfacePointer(IMSAdminBase * a_pcAdmCom) {a_pcAdmCom = m_pcAdmCom;}
          virtual HRESULT STDMETHODCALLTYPE AddKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) ;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) ;
        
        
        virtual HRESULT STDMETHODCALLTYPE EnumKeys( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
            /* [in] */ DWORD dwMDEnumObjectIndex) ;
        
        virtual HRESULT STDMETHODCALLTYPE CopyKey( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ BOOL bMDOverwriteFlag,
            /* [in] */ BOOL bMDCopyFlag) ;
        
        virtual HRESULT STDMETHODCALLTYPE RenameKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName) ;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ PMETADATA_RECORD pmdrMDData) ;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) ;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType) ;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE EnumData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [in] */ DWORD dwMDEnumDataIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) ;
        
        
        virtual HRESULT STDMETHODCALLTYPE CopyData( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ BOOL bMDCopyFlag) ;
        
        virtual HRESULT STDMETHODCALLTYPE OpenKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDAccessRequested,
            /* [in] */ DWORD dwMDTimeOut,
            /* [out] */ PMETADATA_HANDLE phMDNewHandle) ;
        
        virtual HRESULT STDMETHODCALLTYPE CloseKey( 
            /* [in] */ METADATA_HANDLE hMDHandle) ;
        
        
        virtual HRESULT STDMETHODCALLTYPE SaveData( void) ;
        
     };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpmd\jd_misc.h ===
#if !defined (JD_MISC_H)
#define JD_MISC_H 

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    jd_misc.h

Abstract:
	header file for jd_misc.cpp


Author:

    jaroslad  

Revision History:
    06-01-96      ( Jaroslad ) Original.

--*/

#include <windows.h>

int random(int low, int high);


enum Tptr_type {TYPE_TCHAR,TYPE_INT,TYPE_LONG, TYPE_WORD,TYPE_DWORD,TYPE_LPCTSTR};
enum Topt_mand {OPT,MAND}; // switches can be optional or mandatory


struct SParamDef
{
	_TCHAR *sw;     // letter for switch
	int  param_number; //number of parameters (0-zero,1 means exactly one,
					   // >1 means not more param than
	void * ptr;  // pointer to assign value of switch (depends on sw_type)
    
	enum Tptr_type  ptr_type;
	enum Topt_mand  opt_mand;

	_TCHAR * text_desc;  //description for usage print
	_TCHAR * text_param; //what param the switch requires 
					   //(if in usage is '...-c [file]' text_param is "file" )
	WORD * param_read; //same as curr_param_read, but used to export value to caller
	WORD  curr_param_read; // current nuber of params already assigned to ptr;
						// applies only with param_number >1
};
typedef struct SParamDef TParamDef;


void DisplayUsageAndExit( _TCHAR **argv, TParamDef *tt);
void DisplayUsage( _TCHAR **argv, TParamDef *tt);

void ParseParam(int argc, _TCHAR ** argv, TParamDef * tt);

int time_printf(_TCHAR *format, ...);

void fatal_error_printf(_TCHAR *format, ...);
void error_printf(_TCHAR *format, ...);




#define YES			TRUE
#define NO			FALSE

#define SUCCESS     TRUE
#define FAILURE     FALSE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpmd\admutil.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       admutil.cpp

   Abstract:

        IADMCOM interface WRAPPER functions implemetation

   Environment:

      Win32 User Mode

   Author:

      jaroslad  (jan 1997)

--*/



#define INITGUID

#include <tchar.h>
#include <afx.h>

#ifdef UNICODE
    #include <iadmw.h>
    #define IADM_PBYTE
#else
    #include "ansimeta.h"
    //convert when using ANSI interface
    #define IADM_PBYTE   (PBYTE)
#endif

#include <iiscnfg.h>

#include <ole2.h>

#include <ctype.h>  //import toupper
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

#include "admutil.h"
#include "tables.h"
#include <jd_misc.h>


//////////////////////////////
//global variable definition
DWORD g_dwTIMEOUT_VALUE =30000;

DWORD g_dwDELAY_AFTER_OPEN_VALUE=0;
//////////////////////////////

//*********************

CString FindCommonPath(CString a_strPath1, CString a_strPath2)
{
    CString strCommonPath=_TEXT("");
    int MinLength=a_strPath1.GetLength();
    int i;
    //find shorter from strings
    if(a_strPath2.GetLength() < MinLength)
            MinLength=a_strPath2.GetLength();
    for(i=0; i<MinLength; i++)
    {
        if(a_strPath1.GetAt(i)!=a_strPath2.GetAt(i) )
            // common path cannot be any longer;
            break;
    }
    //  now find the previous '/' and all before '/' is the common path
    for(i=i-1; i>=0;i--)
    {
        if(a_strPath1.GetAt(i)==_T('/'))
        {
            strCommonPath=a_strPath1.Left(i+1);//take the trailing '/' with you
            //strRelSrcPath=strPath1.Mid(i+1);
            //strRelDstPath=strPath2.Mid(i+1);
            break;
        }
    }
    return strCommonPath;
}


//**********************************************************************
//IMPLEMENTATION  of CAdmNode
//**********************************************************************



//return the position of '/' that is iSeqNumber in the order
//e.g: GetSlashIndex("aaa/bbb/ccc/ddd",2) returns position of 2nd index that equals 7)
INT CAdmNode::GetSlashIndex(const CString& strPath, INT iSeqNumber)
{
    INT count=0;
    if (iSeqNumber==0)
        return 0;
    for(INT i=0; i<strPath.GetLength();i++)
    {
        if(strPath[i]==_T('/'))
            if((++count)==iSeqNumber)
                return i;
    }
    return -1;

}

//return the count of '/' in strPath

INT CAdmNode::GetCountOfSlashes(const CString& strPath)
{
    INT count=0;
    for(INT i=0; i<strPath.GetLength();i++)
    {
        if(strPath[i]==_T('/'))
            count++;
    }
    return count;
}

//return selement within the given string with sequence number wIndex
//e.g.: GetPartOfPath("aaa/bbb/ccc",1,1) will return "bbb"
//e.g.: GetPartOfPath("aaa/bbb/ccc",1) will return "bbb/ccc"
//e.g.: GetPartOfPath("aaa/bbb/ccc",0,1) will return "aaa/bbb"

//iStart- sequence number of first slash
//iEnd- sequence number of last slash
CString CAdmNode::GetPartOfPath(const CString& strPath, INT iStart, INT iEnd)
{
    if(iEnd!=-1 && iEnd <= iStart)
        return _TEXT("");
    INT i=0;
    INT iPosBegin = GetSlashIndex(strPath,iStart);
    if(iPosBegin==-1) //not found (exceeds number of slashes available in strPath
    {
        return _TEXT("");
    }
    iPosBegin+=((iStart==0)?0:1); //adjust iPosBegin

    INT iPosEnd = GetSlashIndex(strPath,iEnd);
    CString strToReturn;
    if(iEnd==-1 || iPosEnd==-1)
        strToReturn = strPath.Mid(iPosBegin);
    else
        strToReturn = strPath.Mid(iPosBegin,iPosEnd-iPosBegin);
    if(iStart==0 && strToReturn==_TEXT("") && strPath!=_TEXT(""))
        return _TEXT("/"); //this had to be root
    else
        return strToReturn;
}


//within path can be given computer name, service, instance number
// function will split the path to Computer, Service, Instance, Path relative to instance
//

void CAdmNode::SetPath(CString a_strPath)
{
    if(a_strPath.IsEmpty())
        return;

    // change backslashes
    for(int i=0; i<a_strPath.GetLength(); i++)
    {
        // skip DBCS
        if(IsDBCSLeadByte(a_strPath[i]))
        {
            i++;
            continue;
        }
        if(a_strPath[i]==_T('\\'))
            a_strPath.SetAt(i,_T('/'));
    }

    //trim  leading '/'
    while (a_strPath.GetLength()!=0 && a_strPath[0]==_T('/'))
        a_strPath=a_strPath.Mid(1);


    int iSvc=-1;

    if( IsServiceName(GetPartOfPath(a_strPath,1,2))) //get the second name within path
    { //if second is service then first has to be computer name
        strComputer = GetPartOfPath(a_strPath,0,1);
        strService  = GetPartOfPath(a_strPath,1,2);
        if( IsNumber(GetPartOfPath(a_strPath,2,3))) {
            strInstance = GetPartOfPath(a_strPath,2,3);
            strIPath = GetPartOfPath(a_strPath,3); //store the rest
        }
        else {
            strIPath = GetPartOfPath(a_strPath,2); //store the rest

        }
    }
    else if( IsServiceName(GetPartOfPath(a_strPath,0,1))) //get the second name within path
    { //if second is service then first has to be computer name
        strComputer = _TEXT("");
        strService  = GetPartOfPath(a_strPath,0,1);
        if( IsNumber(GetPartOfPath(a_strPath,1,2))) {
            strInstance = GetPartOfPath(a_strPath,1,2);
            strIPath = GetPartOfPath(a_strPath,2); //store the rest
        }
        else {
            strIPath = GetPartOfPath(a_strPath,1); //store the rest
        }
    }
    else
    {
        strIPath = a_strPath;
    }

    //in IPath there can be Property name at the end
    INT iCount= GetCountOfSlashes(strIPath);
    CString LastName= GetPartOfPath(strIPath,iCount); //get last name within path;

     if(MapPropertyNameToCode(LastName)!=NAME_NOT_FOUND)
     {  //the Last name in the path is valid Property name
        strProperty = LastName;
        strIPath = GetPartOfPath(strIPath,0,iCount); //Strip Last name from IPath
     }
}

CString CAdmNode::GetLMRootPath(void)
{
    return _T("/")+CString(IIS_MD_LOCAL_MACHINE_PATH);
}



CString CAdmNode::GetLMServicePath(void)
{
    if(strService.IsEmpty())
        return GetLMRootPath();
    else
        return GetLMRootPath()+_T("/")+strService;
}

CString CAdmNode::GetLMInstancePath(void)
{
    if(strInstance.IsEmpty())
        return GetLMServicePath();
    else
        return GetLMServicePath()+_T("/")+strInstance;
}

CString CAdmNode::GetLMNodePath(void)
{
    if(strIPath.IsEmpty())
        return GetLMInstancePath();
    else
        return GetLMInstancePath()+_T("/")+strIPath;
}

CString CAdmNode::GetServicePath(void)
{
    if(strService.IsEmpty())
        return _TEXT("");
    else
        return _T("/")+strService;
}

CString CAdmNode::GetInstancePath(void)
{
    if(!strInstance.IsEmpty())
        return GetServicePath() + _T("/")+ strInstance;
    else
        return GetServicePath();
}

CString CAdmNode::GetNodePath(void)
{

    if(!strIPath.IsEmpty())
        return GetInstancePath() + _T("/")+ strIPath;
    else
        return GetInstancePath();
}



CString CAdmNode::GetParentNodePath(void)
{
    CString strNodePath;
    strNodePath = GetNodePath();

    if(strNodePath.IsEmpty())
        return strNodePath;
    else
    {
        int i= strNodePath.GetLength()-1; //point to the end of strNodePath
        if (strNodePath.Right(1)==_T("/"))
            i--;
        for(; i>=0; i--)
        {
            if(strNodePath.GetAt(i)==_T('/'))
                return strNodePath.Left(i+1);
        }
        return _TEXT("");
    }
}
//can return _TEXT("") for nonamed
CString CAdmNode::GetCurrentNodeName(void)
{
    CString strNodePath;
    strNodePath = GetNodePath();

    if(strNodePath.IsEmpty())
        return strNodePath;
    else
    {
        int i= strNodePath.GetLength()-1; //point to the end of strNodePath
        if (strNodePath.Right(1)==_T("/"))
            i--;
        for(int count=0; i>=0; i--, count++) //search backward for '/'
        {
            if(strNodePath.GetAt(i)==_T('/'))
                return strNodePath.Mid(i+1,count);
        }
        return strNodePath;
    }
}


CString CAdmNode::GetRelPathFromService(void)
{
    CString str=strService;
    if (!strInstance.IsEmpty())
        str=str+_T("/")+strInstance;
    if (!strIPath.IsEmpty())
        str=str+_T("/")+strIPath;
    return str;
}

CString CAdmNode::GetRelPathFromInstance(void)
{
    if(strInstance.IsEmpty())
        return strIPath;
    else
        return  strInstance+_T("/")+strIPath;
}

//**********************************************************************
//**********************************************************************
//IMPLEMENTATION  of CAdmProp object
//**********************************************************************
//**********************************************************************

CAdmProp::CAdmProp(METADATA_RECORD &a_mdr)
{
    memcpy (&mdr,&a_mdr,sizeof(METADATA_RECORD));
}

void CAdmProp::SetValue(DWORD a_dwValue)
{
    if(mdr.pbMDData!=0)
        delete mdr.pbMDData;
    mdr.dwMDDataLen= sizeof(DWORD);
    mdr.pbMDData = (PBYTE) new char[mdr.dwMDDataLen];
    memcpy(mdr.pbMDData,&a_dwValue,mdr.dwMDDataLen);


}


void CAdmProp::SetValue(CString a_strValue)
{
    if(mdr.pbMDData!=0)
        delete mdr.pbMDData;
    mdr.dwMDDataLen = (a_strValue.GetLength()+1)*sizeof(_TCHAR);
    mdr.pbMDData = (PBYTE) new _TCHAR [mdr.dwMDDataLen/sizeof(_TCHAR)];
    memcpy(mdr.pbMDData,LPCTSTR(a_strValue),(mdr.dwMDDataLen-1)*sizeof(_TCHAR));
    ((_TCHAR *)mdr.pbMDData)[mdr.dwMDDataLen/sizeof(_TCHAR)-1]=0; //terminate with zero
}

void CAdmProp::SetValue(LPCTSTR *a_lplpszValue, DWORD a_dwValueCount)
{
    if(mdr.pbMDData!=NULL)
    {
        delete mdr.pbMDData;
        mdr.pbMDData=0;
    }
    mdr.dwMDDataLen=0;
    for(DWORD i=0; i< a_dwValueCount; i++)
    {
        if(a_lplpszValue[i]==NULL)
            break;

        mdr.dwMDDataLen += (_tcslen(a_lplpszValue[i])+1)*sizeof(_TCHAR);
    }
    mdr.dwMDDataLen+=sizeof(_TCHAR); // two 0 at the end
    mdr.pbMDData = (PBYTE) new char[mdr.dwMDDataLen];
    //merge strings in one area of memory
    DWORD j=0; //index to destination where stings will be merged
    for( i=0; i< a_dwValueCount; i++) //index to aray of strings
    {
        if(a_lplpszValue[i]==NULL)
            break;
        DWORD k=0; //index within string
        while(a_lplpszValue[i][k]!=0)
            ((_TCHAR *)mdr.pbMDData)[j++]=a_lplpszValue[i][k++];
        ((_TCHAR *)mdr.pbMDData)[j++]=0;
    }
    ((_TCHAR *)mdr.pbMDData)[j++]=0;
}

void
CAdmProp::SetValue(
    LPBYTE pbValue,
    DWORD dwValueLength
    )
{
    if( mdr.pbMDData != NULL )
    {
        delete mdr.pbMDData;
    }
    mdr.dwMDDataLen = dwValueLength;
    mdr.pbMDData = (PBYTE) new BYTE[mdr.dwMDDataLen];
    memcpy( mdr.pbMDData, pbValue, mdr.dwMDDataLen );
}


//sets the value depending on GetDataType()

BOOL CAdmProp::SetValueByDataType(LPCTSTR *a_lplpszPropValue, DWORD* a_lpdwPropValueLength, WORD a_wPropValueCount)
{
//process the value
    WORD i;
    if(a_wPropValueCount!=0)
    {   DWORD dwValue=0;
        switch(GetDataType())
        {
        case DWORD_METADATA:
            {
                for (i=0;i<a_wPropValueCount;i++)
                {
                    if( _tcslen(a_lplpszPropValue[i]) > 2 && a_lplpszPropValue[i][0]==_T('0') && _toupper(a_lplpszPropValue[i][1])==_T('X'))
                    {   _TCHAR * lpszX;
                        dwValue += _tcstoul(a_lplpszPropValue[i]+2, &lpszX, 16);
                    }
                    else if(IsNumber(a_lplpszPropValue[i]))
                        dwValue += _ttol(a_lplpszPropValue[i]);
                    else
                    {
                        DWORD dwMapped=MapValueNameToCode(a_lplpszPropValue[i],GetIdentifier());

                        if(dwMapped==NAME_NOT_FOUND)
                        {
                            Print(_TEXT("value not resolved: %s\n"),a_lplpszPropValue[i]);
                            return FALSE;
                        }
                        else
                        // it has to be checked if adding can be performed
                            dwValue |= dwMapped;
                    }
                }
                SetValue(dwValue);
            }
            break;
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
            {
                CString strValue=_TEXT("");
                for (i=0;i<a_wPropValueCount;i++)
                {
                    strValue += a_lplpszPropValue[i];
                }
                SetValue(strValue);
            }
            break;
        case MULTISZ_METADATA:
            {
                SetValue(a_lplpszPropValue, a_wPropValueCount);
            }
            break;
        case BINARY_METADATA:
            SetValue( (LPBYTE)a_lplpszPropValue[0], a_lpdwPropValueLength[0] );
            break;
        default:
            return FALSE;
        }
    }
    return TRUE;
}

void CAdmProp::Print(const _TCHAR * format,...)
{
   _TCHAR buffer[2000];
   va_list marker;
   va_start( marker, format );     /* Initialize variable arguments. */
   _vstprintf(buffer,format, marker);
   _tprintf(_TEXT("%s"),buffer);

   va_end( marker );              /* Reset variable arguments.      */

}


void CAdmProp::PrintProperty(void)
{
    CString strPropName=tPropertyNameTable::MapCodeToName(mdr.dwMDIdentifier);
    BOOL    fSecure =(mdr.dwMDAttributes&METADATA_SECURE);

    //print code or name of property
    if(strPropName.IsEmpty())
        Print(_TEXT("%-30ld: "), mdr.dwMDIdentifier);
    else
    {
	if(getenv("MDUTIL_PRINT_ID")!=NULL) //let's print out Identifier numeric values when environment variable is set
        	Print(_TEXT("%ld %-25s: "), mdr.dwMDIdentifier,LPCTSTR(strPropName));
	else
	        Print(_TEXT("%-30s: "), LPCTSTR(strPropName));
    }
    CString strFlagsToPrint=_TEXT("");

    strFlagsToPrint+=_TEXT("[");
    if(mdr.dwMDAttributes&METADATA_INHERIT)
        strFlagsToPrint+=_TEXT("I");
    if(mdr.dwMDAttributes&METADATA_SECURE)
        strFlagsToPrint+=_TEXT("P");
    if(mdr.dwMDAttributes&METADATA_REFERENCE)
        strFlagsToPrint+=_TEXT("R");
    if(mdr.dwMDUserType==IIS_MD_UT_SERVER)
        strFlagsToPrint+=_TEXT("S");
    if(mdr.dwMDUserType==IIS_MD_UT_FILE)
        strFlagsToPrint+=_TEXT("F");
    if(mdr.dwMDUserType==IIS_MD_UT_WAM)
        strFlagsToPrint+=_TEXT("W");
    if(mdr.dwMDUserType==ASP_MD_UT_APP)
        strFlagsToPrint+=_TEXT("A");
    strFlagsToPrint+=_TEXT("]");
    Print(_TEXT("%-8s"),LPCTSTR(strFlagsToPrint));

    //print property value
    DWORD i;
    switch (mdr.dwMDDataType) {
    case DWORD_METADATA:
#ifndef SHOW_SECURE
        if ( fSecure )
        {
            Print(_TEXT("(DWORD)  ********"), *(DWORD *)(mdr.pbMDData));
        }
        else
#endif
        {
            Print(_TEXT("(DWORD)  0x%x"), *(DWORD *)(mdr.pbMDData));
            // try to convert to readable info
            CString strNiceContent;
            strNiceContent=tValueTable::MapValueContentToString(*(DWORD *)(mdr.pbMDData), mdr.dwMDIdentifier);
            if(!strNiceContent.IsEmpty())
                Print(_TEXT("={%s}"),LPCTSTR(strNiceContent));
            else //at least decimal value can be useful
                Print(_TEXT("={%ld}"),*(DWORD *)(mdr.pbMDData));
        }
        break;
    case BINARY_METADATA:

        Print(_TEXT("(BINARY) 0x"));
        for (i = 0; i < mdr.dwMDDataLen; i++) {
#ifndef SHOW_SECURE
            if ( fSecure )
            {
                Print(_TEXT(" * " ));
            }
            else
#endif
            {
                Print(_TEXT("%02x "), ((PBYTE)(mdr.pbMDData))[i]);
            }
        }
        break;

    case STRING_METADATA:
    case EXPANDSZ_METADATA:
        if(mdr.dwMDDataType==STRING_METADATA)
                Print(_TEXT("(STRING) "));
        else
                Print(_TEXT("(EXPANDSZ) "));
#ifndef SHOW_SECURE
        if( fSecure )
        { //do not expose the length of secure data
           Print( _TEXT("\"********************\"" ));
        }
        else
#endif
        {
          Print(_TEXT("\""));
          for (i = 0; i < mdr.dwMDDataLen/sizeof(_TCHAR); i++) {
            if(((_TCHAR *)(mdr.pbMDData))[i]==0)
            {
                if( i+1 == mdr.dwMDDataLen/sizeof(_TCHAR))
                { //we are at the end print only terminating "
                    Print(_TEXT("\""));
                }
                else
                {
                    Print(_TEXT("\" \""));
                }
            }
            if(((_TCHAR *)(mdr.pbMDData))[i]=='\r')
                Print(_TEXT("\t"));
            else
            {
               // if(mdr.dwMDAttributes&METADATA_SECURE)
               // {
               //     Print( _TEXT("*" ));
               // }
               // else
               // {
                    Print( _TEXT("%c"), ((_TCHAR *)(mdr.pbMDData))[i]);
               // }
            }
          }
        }
        break;
    case MULTISZ_METADATA:
        Print(_TEXT("(MULTISZ) ")); //0 should be separator of mulisz strings

#ifndef SHOW_SECURE
        if( fSecure )
        { //do not expose the length of secure data
           Print( _TEXT("\"********************\"" ));
            }
        else
#endif
        {
            Print(_TEXT("\""));
            for (i = 0; i < mdr.dwMDDataLen/sizeof(_TCHAR); i++) {
                if(((_TCHAR *)(mdr.pbMDData))[i]==0)
                {
                    if( i+1 == mdr.dwMDDataLen/sizeof(_TCHAR) || (mdr.dwMDDataLen/sizeof(_TCHAR)-i==2 && ((_TCHAR *)(mdr.pbMDData))[i]==0 && ((_TCHAR *)(mdr.pbMDData))[i+1]==0))
                    { //we are at the end print only terminating "
                        Print(_TEXT("\"")); break;
                    }
                    else
                    {
                        Print(_TEXT("\" \""));
                    }
                }
                else
                    Print(_TEXT("%c"),((_TCHAR *)(mdr.pbMDData))[i]);
            }
        }
        break;
    default:
        Print(_TEXT("(UNKNOWN) "));
        break;
    }
    Print(_TEXT("\n"));
}

//**********************************************************************
//**********************************************************************
//IMPLEMENTATION  of CAdmUtil object
//**********************************************************************
//**********************************************************************


//nesting for recursive enumeration
static void nest_print(BYTE bLevel)
{
    for(int i=0; i<=bLevel;i++)
        _tprintf(_T(" "));
}

CAdmUtil::CAdmUtil (const CString & strComputer)
{
    EnablePrint(); // by default print error messages


    pcAdmCom=0;
    m_hmd=0;
    pbDataBuffer=new BYTE [DEFAULTBufferSize];
    wDataBufferSize=DEFAULTBufferSize;

#if UNICODE
    pcAdmCom=0;
#else
    pcAdmCom=new ANSI_smallIMSAdminBase;  //we will access metabase through wrapper class
#endif

    //Open (strComputer);
}

void CAdmUtil::Open (const CString & strComputer)
{
    IClassFactory * pcsfFactory = NULL;
    COSERVERINFO csiMachineName;
    COSERVERINFO *pcsiParam = NULL;
    OLECHAR rgchMachineName[MAX_PATH];


#if UNICODE
   //release previous interface if needed
    if(pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->Release();
        pcAdmCom=0;
    }
    //convert to OLECHAR[];
    if (!strComputer.IsEmpty())
    {
           wsprintf( rgchMachineName, L"%s", LPCTSTR(strComputer));

#else
   //release previous interface if needed
    if(pcAdmCom!=0 &&pcAdmCom->m_pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->m_pcAdmCom->Release();
        pcAdmCom->m_pcAdmCom=0;
    }
    //convert to OLECHAR[];
    if (!strComputer.IsEmpty())
    {
            wsprintfW( rgchMachineName, L"%S", LPCTSTR(strComputer));
#endif
    }
    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;
    pcsiParam = &csiMachineName;
    csiMachineName.pwszName =  (strComputer.IsEmpty())?NULL:rgchMachineName;

    hresError = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);

    if (FAILED(hresError))
    {
     Error(_TEXT("CoGetClassObject"));
    }
    else {
        hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase,
#if UNICODE
                         (void **) &pcAdmCom);
#else
                         (void **) &pcAdmCom->m_pcAdmCom);
#endif
        if (FAILED(hresError)) Error(_TEXT("CreateInstance"));
        pcsfFactory->Release();
    }
}



void CAdmUtil::Close (void)
{
    //release the interface
#if UNICODE
    if(pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->Release();
        pcAdmCom=0;
    }

#else
    if(pcAdmCom!=0 &&pcAdmCom->m_pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->m_pcAdmCom->Release();
        pcAdmCom->m_pcAdmCom=0;
    }
#endif
}



CAdmUtil::~CAdmUtil (void)
{
    //release the interface
    if(pbDataBuffer!=NULL)
        delete [] pbDataBuffer;
    //the following may fail if class is static
#if UNICODE
    if(pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->Release();
        pcAdmCom=0;
    }

#else
    if(pcAdmCom!=0 &&pcAdmCom->m_pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->m_pcAdmCom->Release();
        pcAdmCom->m_pcAdmCom=0;
    }
#endif
}

//*******************************************************************************
//with fCreate set to TRUE the node will be created if it doesn't exist

METADATA_HANDLE CAdmUtil::OpenObject(CAdmNode & a_AdmNode, DWORD dwPermission, BOOL fCreate)
{
    METADATA_HANDLE hmdToReturn = 0;

    //try to open the full path
    CString strPathToOpen=a_AdmNode.GetLMNodePath();

    hresError = pcAdmCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
        IADM_PBYTE LPCTSTR(strPathToOpen), dwPermission, g_dwTIMEOUT_VALUE, &hmdToReturn);

    if (FAILED(hresError)) {
        if ( ((dwPermission==(dwPermission|METADATA_PERMISSION_READ)) || fCreate==FALSE) ||(hresError != RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND))) {
            CString strErrMsg=_TEXT("OpenKey");
            strErrMsg += _TEXT("(\"")+a_AdmNode.GetNodePath()+_TEXT("\")");
            Error(LPCTSTR(strErrMsg));
        }
        else {
            //!!!!!!!!!!!!!Place the dialog to ask to create the path
            // open the service object for write
            METADATA_HANDLE hmdServicePathHandle;
            hresError = pcAdmCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                IADM_PBYTE LPCTSTR(a_AdmNode.GetLMServicePath()), METADATA_PERMISSION_WRITE, g_dwTIMEOUT_VALUE, &hmdServicePathHandle);

            if (FAILED(hresError))
            {
                CString strErrMsg=_TEXT("OpenKey");
                strErrMsg += _TEXT("(\"")+a_AdmNode.GetServicePath()+_TEXT(",WRITE")+_TEXT("\")");
                Error(LPCTSTR(strErrMsg));
            }
            else {
                // create the node
                hresError = pcAdmCom->AddKey(hmdServicePathHandle,
                                    IADM_PBYTE LPCTSTR(a_AdmNode.GetRelPathFromInstance()));
                if (FAILED(hresError)) {
                    CString strErrMsg=_TEXT("AddKey");
                    strErrMsg += _TEXT("(\"")+a_AdmNode.GetRelPathFromInstance()+_TEXT("\")");
                    Error(LPCTSTR(strErrMsg));
                }

                //close the service object
                pcAdmCom->CloseKey(hmdServicePathHandle);
                if (FAILED(hresError))  Error(_TEXT("CloseKey"));
                else {
                    // now finally we can open the full path
                    hresError = pcAdmCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                        IADM_PBYTE LPCTSTR(strPathToOpen), dwPermission, g_dwTIMEOUT_VALUE, &hmdToReturn);
                    if (FAILED(hresError))
                    {
                        CString strErrMsg=_TEXT("OpenKey");
                        strErrMsg += _TEXT("(\"")+a_AdmNode.GetServicePath()+_TEXT(",WRITE")+_TEXT("\")");
                        Error(LPCTSTR(strErrMsg));
                    }
                }
            }
        }
    }
    Sleep(g_dwDELAY_AFTER_OPEN_VALUE);
    return hmdToReturn;
}

//*******************************************************************************
void CAdmUtil::CloseObject(METADATA_HANDLE hmd)
{
    HRESULT hresStore=hresError;
    hresError=pcAdmCom->CloseKey(hmd);
    if (FAILED(hresError)) Error(_TEXT("CloseData"));
    else    hresError=hresStore; //restore the previous hresError


}
//*******************************************************************************

void CAdmUtil::CreateObject(CAdmNode & a_AdmNode)
{
        OpenObjectTo_hmd(a_AdmNode, METADATA_PERMISSION_WRITE, TRUE/* fCreate*/);
}

#if 0
    METADATA_HANDLE hmdToReturn = 0;

    //try to open the full path
    CString strPathToOpen=a_AdmNode.GetLMNodePath();

    METADATA_HANDLE hmdServicePathHandle;
    hresError = pcAdmCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
            IADM_PBYTE LPCTSTR(a_AdmNode.GetLMServicePath()), METADATA_PERMISSION_WRITE, g_dwTIMEOUT_VALUE, &hmdServicePathHandle);
    if (FAILED(hresError))
    {
        CString strErrMsg=_TEXT("OpenKey");
        strErrMsg += _TEXT("(\"")+a_AdmNode.GetServicePath()+_TEXT(",WRITE")+_TEXT("\")");
        Error(LPCTSTR(strErrMsg));
    }
    else
    {
        // create the node
        hresError = pcAdmCom->AddKey(hmdServicePathHandle,
                            IADM_PBYTE LPCTSTR(a_AdmNode.GetRelPathFromInstance()));
        if (FAILED(hresError)) {
            CString strErrMsg=_TEXT("AddKey");
            strErrMsg += _TEXT("(\"")+a_AdmNode.GetRelPathFromInstance()+_TEXT("\")");
            Error(LPCTSTR(strErrMsg));
        }
        //close the service object
        CloseObject(hmdServicePathHandle);
    }
#endif


// This function enables to reuse open handles in order to improve performance
// !!it supports only one acticve handle (otherwise the processing may fail)

METADATA_HANDLE CAdmUtil::OpenObjectTo_hmd(CAdmNode & a_AdmNode, DWORD dwPermission, BOOL fCreate)
{
        CString strPathToOpen=a_AdmNode.GetLMNodePath();
        if(m_hmd!=0 && strPathToOpen.CompareNoCase(m_strNodePath)==0 && m_dwPermissionOfhmd == dwPermission )
        {  //we can reuse already opened node

        }
        else
        {
                if(m_hmd != 0)
                {
                        CloseObject(m_hmd);
                        m_hmd=0;
                }
                m_hmd = OpenObject(a_AdmNode, dwPermission, fCreate);
                m_dwPermissionOfhmd = dwPermission;
                m_strNodePath = strPathToOpen;
        }
    return m_hmd;
}

void CAdmUtil::CloseObject_hmd(void)
{
	if(m_hmd != 0)
	{
		CloseObject(m_hmd);
		m_hmd=0;
	}
}
//*******************************************************************************

void CAdmUtil::GetProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp)
{
    DWORD dwRequiredDataLen=0;
    WORD wDataBufferSize=0;
    PBYTE DataBuffer=0;

    DWORD dwPropertyCode=a_AdmProp.GetIdentifier();

    if(dwPropertyCode==0)   Error(_TEXT("Property name not found"));
    else
    {
        //MD_SET_DATA_RECORD(&a_AdmProp.mdr,
        //                 0,
        //                 METADATA_INHERIT | METADATA_PARTIAL_PATH,
        //                 0,
        //                 0,
        //                 wDataBufferSize,
        //                 pbDataBuffer);

        //a_AdmProp.SetIdentifier(dwPropertyCode); //has to be set beforehand
        a_AdmProp.SetDataType(0);
        a_AdmProp.SetUserType(0);
        a_AdmProp.SetAttrib(0);

        METADATA_HANDLE hmd = OpenObjectTo_hmd(a_AdmNode,
                                         METADATA_PERMISSION_READ);
        if (SUCCEEDED(hresError))
        {
            hresError = pcAdmCom->GetData(hmd,
                IADM_PBYTE  _TEXT(""),
        &a_AdmProp.mdr, &dwRequiredDataLen);
            if (FAILED(hresError)) {
                if (hresError == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
    ///////////             delete []pbDataBuffer;
                    pbDataBuffer=new BYTE[dwRequiredDataLen];
                    if (pbDataBuffer==0) {
                        hresError = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                        Error(_TEXT("Buffer resize failed"));
                    }
                    else {
                        a_AdmProp.mdr.dwMDDataLen = dwRequiredDataLen;
                        a_AdmProp.mdr.pbMDData = pbDataBuffer;
                        hresError = pcAdmCom->GetData(hmd,
                        IADM_PBYTE _TEXT(""), &a_AdmProp.mdr, &dwRequiredDataLen);
                        if (FAILED(hresError)) Error(_TEXT("GetData"));
                    }
                }
                else
                     Error(_TEXT("GetData"));;

            }
            //CloseObject (hmd);  we might reuse it
        }

    }
}

//if lplpszPropertyValue[1]==NULL it means there is only one value (it is not a multistring)


void CAdmUtil::SetProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp)
{
    METADATA_HANDLE hmd = OpenObjectTo_hmd(a_AdmNode,
                                         METADATA_PERMISSION_WRITE,TRUE/*create node if doesn't exist*/);
    if (SUCCEEDED(hresError))
    {
        SetProperty(&a_AdmProp.mdr,hmd);
        //CloseObject(hmd); we will reuse it
    }
}


void CAdmUtil::SetProperty(PMETADATA_RECORD a_pmdrData,METADATA_HANDLE a_hmd)
{
    hresError = pcAdmCom->SetData(a_hmd,
                            IADM_PBYTE _TEXT(""), a_pmdrData);
    if (FAILED(hresError))  Error(_TEXT("SetData"));

}

void CAdmUtil::SaveData(void)
{
        if (m_hmd!=0)
        {  //we have to close reusable handle in order to save successfully
                CloseObject(m_hmd);
                m_hmd=0;
        }
    hresError = pcAdmCom->SaveData();
        if (FAILED(hresError)) Error(_TEXT("SaveData"));
}

//****************************************************************************
//DELETE PROPERTY

void CAdmUtil::DeleteProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp)
{
    METADATA_HANDLE hmd = OpenObjectTo_hmd(a_AdmNode,
                                         METADATA_PERMISSION_WRITE,TRUE/*create node if doesn't exist*/);
    if (SUCCEEDED(hresError))
    {
        DeleteProperty(&a_AdmProp.mdr,hmd);
        // CloseObject(hmd); we will reuse it
    }
}


void CAdmUtil::DeleteProperty(PMETADATA_RECORD a_pmdrData,METADATA_HANDLE a_hmd)
{
    hresError = pcAdmCom->DeleteData(a_hmd,
                IADM_PBYTE  _TEXT(""), a_pmdrData->dwMDIdentifier,ALL_METADATA);
    if (FAILED(hresError))  Error(_TEXT("DeleteData"));

}

//****************************************************************************
//DELETE OBJECT

void CAdmUtil::DeleteObject(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp)
{
    CAdmNode NodeToOpen = a_AdmNode.GetParentNodePath();
    METADATA_HANDLE hmd = OpenObjectTo_hmd(NodeToOpen,
                                         METADATA_PERMISSION_WRITE,FALSE/*create node if doesn't exist*/);
    if (SUCCEEDED(hresError))
    {
        CString strToDelete=a_AdmNode.GetCurrentNodeName();
        if(strToDelete==_TEXT(""))
            strToDelete=_TEXT("//"); //empty name has to be wrapped with '/'
        DeleteObject(hmd,strToDelete);
        //CloseObject(hmd); we will reuse it
    }
}

void CAdmUtil::DeleteObject(METADATA_HANDLE a_hmd, CString& a_strObjectName)
{
    hresError = pcAdmCom->DeleteKey(a_hmd, IADM_PBYTE LPCTSTR(a_strObjectName));
    if (FAILED(hresError))  Error(_TEXT("DeleteKey"));

}






void CAdmUtil::EnumPropertiesAndPrint(CAdmNode& a_AdmNode,
                                      CAdmProp a_AdmProp, //cannot be passed by reference
                                      BYTE bRecurLevel,
                                      METADATA_HANDLE a_hmd,
                                      CString & a_strRelPath)
{
    CAdmProp mdrData=a_AdmProp;
    DWORD dwRequiredDataLen=0;
    PBYTE DataBuffer=0;
    METADATA_HANDLE hmdMain;

    if(a_hmd==0) //if handle was not passed then open one
    {
        hmdMain = OpenObjectTo_hmd(a_AdmNode, METADATA_PERMISSION_READ);
        if (FAILED(hresError))
                return;
    }
    else
        hmdMain = a_hmd;

    for (int j=0;;j++) { //cycle for properties
        MD_SET_DATA_RECORD(&mdrData.mdr,
                       0,
                       a_AdmProp.mdr.dwMDAttributes,
                       a_AdmProp.mdr.dwMDUserType,
                       a_AdmProp.mdr.dwMDDataType,
                       dwRequiredDataLen,
                       pbDataBuffer);

        hresError = pcAdmCom->EnumData(hmdMain,
            IADM_PBYTE LPCTSTR(a_strRelPath), &mdrData.mdr,j, &dwRequiredDataLen);
        if (FAILED(hresError))
        {
            if(hresError == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS))
            {
                hresError=0; //NO MORE ITEMS IS NOT ERROR FOR US
                break; //end of items
            }
            else if (hresError == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER))
            {
                delete pbDataBuffer;
                pbDataBuffer=new BYTE[dwRequiredDataLen];
                if (pbDataBuffer==0)
                {
                    hresError = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    Error(_TEXT("Buffer resize failed"));
                }
                else
                {
                    mdrData.mdr.dwMDDataLen = dwRequiredDataLen;
                    mdrData.mdr.pbMDData = pbDataBuffer;
                    hresError = pcAdmCom->EnumData(hmdMain,
                            IADM_PBYTE LPCTSTR(a_strRelPath), &mdrData.mdr,j, &dwRequiredDataLen);
                    if (FAILED(hresError)) Error(_TEXT("GetData"));
                }
            }
            else
                Error(_TEXT("EnumData"));
        }
        //else
          //  Error(_TEXT("EnumData"));

        if(SUCCEEDED(hresError)) //we  enumerated successfully, let's print
        {
            nest_print(bRecurLevel+1);

            mdrData.PrintProperty();
        }
        else
        {
            break;
        }
    }  //end for j   - cycle for properties
    //if(a_hmd==0)
    //    CloseObject(hmdMain); we will reuse it //close only if we opened at the beginning
}


void CAdmUtil::EnumAndPrint(CAdmNode&   a_AdmNode,
                            CAdmProp&   a_AdmProp,
                            BOOL        a_fRecursive,
                            BYTE        a_bRecurLevel,
                            METADATA_HANDLE a_hmd,
                            CString&    a_strRelPath)
{
    _TCHAR NameBuf[METADATA_MAX_NAME_LEN];

    METADATA_HANDLE hmdMain;

    if(a_hmd==0) //if handle was not passed then open one
    {
        hmdMain = OpenObjectTo_hmd(a_AdmNode, METADATA_PERMISSION_READ);
        if (FAILED(hresError))
                return;
    }
    else
        hmdMain = a_hmd;


    //printf("[RELATIVE PATH : \"%s\"]\n",LPCTSTR(a_strRelPath));
    //print the properties of the node
    EnumPropertiesAndPrint(a_AdmNode,a_AdmProp,a_bRecurLevel,hmdMain,a_strRelPath);


    for (int i=0; ;i++) {  //cycle for subnodes
        hresError = pcAdmCom->EnumKeys(hmdMain,
            IADM_PBYTE LPCTSTR(a_strRelPath), IADM_PBYTE NameBuf, i);
        if(FAILED(hresError)) {
            if(hresError == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS)) {
                hresError=0; //NO MORE ITEMS IS NOT ERROR FOR US
                break; //end of cycle
            }
            else
            {
                Error(_TEXT("EnumKeys"));
                break;
            }

        }
        else {

          //process and print node info

            CString strNewRelPath( a_strRelPath );
            if(NameBuf[0]==0) //empty name
                strNewRelPath+=_TEXT("//"); //add two slashes -> this is required by metabase
            else
            {
                UINT  nLen;
                //if(strNewRelPath.GetLength()>=1 && strNewRelPath.Right(1)==_TEXT("/")) {
                if( (nLen=strNewRelPath.GetLength())>=1 && (strNewRelPath.GetAt(nLen-1)=='/') ) {
                }
                else {
                    strNewRelPath+=_TEXT("/"); //add only if it is not at the end of string.
                }
                strNewRelPath+=NameBuf;
            }
            CString strStringToPrint( a_AdmNode.GetNodePath() );
            UINT  nLen = strStringToPrint.GetLength();

            //if (strStringToPrint.Right(2)==_TEXT("//"))
            if ((nLen > 2) && strStringToPrint.GetAt(nLen-1)=='/'
                           && strStringToPrint.GetAt(nLen-2)=='/' )
            {
                strStringToPrint += strNewRelPath.Mid(1); //strip first '/'
            }
            else
            {
                strStringToPrint += strNewRelPath;
            }
            LPCTSTR lpszStr=LPCTSTR(strStringToPrint);
            this->Print(_TEXT("[%s]\n"),lpszStr );

            if(a_fRecursive)
            {
                EnumAndPrint(a_AdmNode,a_AdmProp ,a_fRecursive, a_bRecurLevel+1, hmdMain,strNewRelPath);
            }
            else
            {  //no recursion

            }
        }
    } //end for i  - cycle for nodes
    //if(a_hmd==0)
    //    CloseObject(hmdMain); //we will reuse it //close only if we opened at the beginning
}


//****************************************************************
//  the following function is somehow complicated because
//  metadata copy function doesn't support copying of one object to another place with different name
//  e.g. ComAdmCopyKey will copy /W3SVC/1//scripts/oldscripts1 /W3SVC/1//oldscripts2
//                          will create /W3SVC/1//oldscripts2/oldscripts1
//

void CAdmUtil::CopyObject(CAdmNode& a_AdmNode,
                          CAdmNode& a_AdmNodeDst)
{
    CString strSrcPath=a_AdmNode.GetNodePath();
    CString strDstPath=a_AdmNodeDst.GetNodePath();


    CString strCommonPath; //=_TEXT("");
    CString strRelSrcPath=strSrcPath; //relative to common path
    CString strRelDstPath=strDstPath; //relative to common path


    //we cannot open Source Path for reading because if will diable wrining to all parent nodes
    //e.g. copy /W3SVC/1//scripts/oldscripts /W3SVC/1//oldscripts would fail
    //It is necessary to find common partial path and open metabase object for that common partial path for READ/WRITE

    //!!!!!!!!!!!!!!!!! assume that paths are not case sensitive

    int MinLength=strSrcPath.GetLength();
    int i;
    //find shorter from strings
    if(strDstPath.GetLength() < MinLength)
            MinLength=strDstPath.GetLength();
    for(i=0; i<MinLength; i++)
    {
        if(strSrcPath.GetAt(i)!=strDstPath.GetAt(i) )
            // common path cannot be any longer;
            break;
    }
    //  now find the previous '/' and all before '/' is the common path
    for(i=i-1; i>=0;i--)
    {
        if(strSrcPath.GetAt(i)==_T('/'))
        {
            strCommonPath=strSrcPath.Left(i+1);//take the trailing '/' with you
            strRelSrcPath=strSrcPath.Mid(i+1);
            strRelDstPath=strDstPath.Mid(i+1);
            break;
        }
    }




    _TCHAR NameBuf[METADATA_MAX_NAME_LEN];

    METADATA_HANDLE hmdCommon=0;

    CAdmNode CommonNode;
    CommonNode.SetPath(strCommonPath);


    hmdCommon = OpenObjectTo_hmd(CommonNode, METADATA_PERMISSION_READ+METADATA_PERMISSION_WRITE);
    if (FAILED(hresError))
            return;

// Altered by Adam Stone on 30-Jan-97  The following code was changed to comply with
// the changes to the metabase ComMDCopyKey function.
    // Copy the metadata to the destination
    hresError = pcAdmCom->CopyKey (hmdCommon,
                                    IADM_PBYTE LPCTSTR(strRelSrcPath),
                                    hmdCommon,
                                    IADM_PBYTE LPCTSTR(strRelDstPath),
                                    FALSE, // Do NOT overwrite
                                    TRUE); // Copy do NOT move

    if (FAILED(hresError)) // if the node already exists, it is error
    {
        CString strErrMsg=_TEXT("CopyKey");
        strErrMsg += _TEXT("(\"")+a_AdmNodeDst.GetRelPathFromInstance()+_TEXT("\")");
        Error(LPCTSTR(strErrMsg));
    }

// All of the commented out code has become unneccessary as of 30-Jan-97  because of a change
// in the metabase.  ComMDCopyKey now copies to the destination, overwriting if
// requested.  It used to copy to a child of the destination object.
/*  // create the node
*   hresError = pcAdmCom->AddKey(hmdCommon,
*                       IADM_PBYTE LPCTSTR(strRelDstPath));
*   if (FAILED(hresError)) { //if the node exists, it is error)
*       CString strErrMsg=_TEXT("AddKey");
*       strErrMsg += _TEXT("(\"")+a_AdmNodeDst.GetRelPathFromInstance()+_TEXT("\")");
*       Error(LPCTSTR(strErrMsg));
*   }
*   else //no error when creating new node
*   {
*       for (i=0; ;i++) {  //cycle for subnodes
*           hresError = pcAdmCom->EnumKeys(hmdCommon,
*               IADM_PBYTE LPCTSTR(strRelSrcPath), (PBYTE)NameBuf, i);
*           if(FAILED(hresError)) {
*               if(hresError == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS)) {
*                   hresError=0; //this is not an error
*                   break; //end of cycle
*               }
*               else
*               {
*                   Error(_TEXT("EnumKeys"));
*                   break;
*               }
*
*           }
*           else {
*
*             //process and copy node child node
*
*               CString strNewRelSrcPath=strRelSrcPath;
*               if(NameBuf[0]==0) //empty name
*                   strNewRelSrcPath+=_TEXT("//"); //add two slashes -> this is required by metabase
*               else
*               {   if(strNewRelSrcPath.GetLength()>=1 && strNewRelSrcPath.Right(1)==_TEXT("/")) {
*                   }
*                   else {
*                       strNewRelSrcPath+=_TEXT("/"); //add only if it is not at the end of string.
*                   }
*                   strNewRelSrcPath+=NameBuf;
*               }
*               hresError = pcAdmCom->CopyKey(
*                   hmdCommon, (PBYTE) LPCTSTR(strNewRelSrcPath),
*                   hmdCommon, (PBYTE) LPCTSTR(strRelDstPath),TRUE,TRUE);
*               if(FAILED(hresError)) {
*                   Error(_TEXT("CopyKey"));
*               }
*
*
*           }
*       } //end for i  - cycle for nodes
*
*
*       //WE COPIED ALL NODES, COPY PARAMETERS NOW
*       CAdmProp mdrData;
*       DWORD dwRequiredDataLen=0;
*       PBYTE DataBuffer=0;
*
*
*
*       for (int j=0;;j++) { //cycle for properties
*           MD_SET_DATA_RECORD(&mdrData.mdr,
*                          0,
*                          0,
*                          0,
*                          0,
*                          dwRequiredDataLen,
*                          pbDataBuffer);
*
*           hresError = pcAdmCom->EnumData(hmdCommon,
*                           (PBYTE) LPCTSTR(strRelSrcPath)
*                           , &mdrData.mdr,j, &dwRequiredDataLen);
*           if (FAILED(hresError))
*           {
*               if(hresError == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS))
*               {
*                   hresError=0; //NO MORE ITEMS IS NOT ERROR FOR US
*                   break; //end of items
*               }
*               else if (hresError == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER))
*               {
///////////                 delete pbDataBuffer;
*                   pbDataBuffer=new BYTE[dwRequiredDataLen];
*                   if (pbDataBuffer==0)
*                   {
*                       hresError = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
*                       Error(_TEXT("Buffer resize failed"));
*                   }
*                   else
*                   {
*                       mdrData.mdr.dwMDDataLen = dwRequiredDataLen;
*                       mdrData.mdr.pbMDData = pbDataBuffer;
*                       hresError = pcAdmCom->EnumData(hmdCommon,
*                           (PBYTE) LPCTSTR(strRelSrcPath)
*                           , &mdrData.mdr,j, &dwRequiredDataLen);
*                       if (FAILED(hresError)) Error(_TEXT("GetData"));
*                   }
*               }
*               else
*                   Error(_TEXT("EnumData"));
*           }
*           else
*               Error(_TEXT("EnumData"));
*
*           if(SUCCEEDED(hresError)) //we  enumerated successfully, let's print
*           {
*               hresError = pcAdmCom->SetData(hmdCommon, (PBYTE) LPCTSTR(strRelDstPath),&mdrData.mdr);
*               if (FAILED(hresError))  Error(_TEXT("SetData"));
*           }
*           else
*           {
*               break;
*           }
*       }  //end for j   - cycle for properties
*   }
*/


    //CloseObject(hmdCommon); //we will reuse handle //close only if we opened at the beginning

}

void CAdmUtil::RenameObject(CAdmNode& a_AdmNode,
                          CAdmNode& a_AdmNodeDst)
{
    CString strSrcPath=a_AdmNode.GetNodePath();
    CString strDstPath=a_AdmNodeDst.GetNodePath();


    CString strCommonPath=_TEXT("");
    CString strRelSrcPath=strSrcPath; //relative to common path
    CString strRelDstPath=strDstPath; //relative to common path


    //we cannot open Source Path for reading because if will diable wrining to all parent nodes
    //e.g. copy /W3SVC/1//scripts/oldscripts /W3SVC/1//oldscripts would fail
    //It is necessary to find common partial path and open metabase object for that common partial path for READ/WRITE

    //!!!!!!!!!!!!!!!!! assume that paths are not case sensitive

    int MinLength=strSrcPath.GetLength();
    int i;
    //find shorter from strings
    if(strDstPath.GetLength() < MinLength)
            MinLength=strDstPath.GetLength();
    for(i=0; i<MinLength; i++)
    {
        if(strSrcPath.GetAt(i)!=strDstPath.GetAt(i) )
            // common path cannot be any longer;
            break;
    }
    //  now find the previous '/' and all before '/' is the common path
    for(i=i-1; i>=0;i--)
    {
        if(strSrcPath.GetAt(i)==_T('/'))
        {
            strCommonPath=strSrcPath.Left(i+1);//take the trailing '/' with you
            strRelSrcPath=strSrcPath.Mid(i); // keep the trailing '/' in case it's "//"
            strRelDstPath=strDstPath.Mid(i+1);
            break;
        }
    }




    _TCHAR NameBuf[METADATA_MAX_NAME_LEN];

    METADATA_HANDLE hmdCommon=0;

    CAdmNode CommonNode;
    CommonNode.SetPath(strCommonPath);


    hmdCommon = OpenObjectTo_hmd(CommonNode, METADATA_PERMISSION_READ+METADATA_PERMISSION_WRITE);
    if (FAILED(hresError))
            return;

    hresError = pcAdmCom->RenameKey (hmdCommon,
                                    IADM_PBYTE LPCTSTR(strRelSrcPath),
                                    IADM_PBYTE LPCTSTR(strRelDstPath)
                                   );


    if (FAILED(hresError)) // if the node already exists, it is error
    {
        CString strErrMsg=_TEXT("RenameKey");
        strErrMsg += _TEXT("(\"")+a_AdmNodeDst.GetRelPathFromInstance()+_TEXT("\")");
        Error(LPCTSTR(strErrMsg));
    }

    //CloseObject(hmdCommon); //we will reuse it//close only if we opened at the beginning

}



//**********************************************************************
//IMPLEMENTATION  of AdmUtil
//**********************************************************************


void CAdmUtil::Run(CString& strCommand, CAdmNode& a_AdmNode, CAdmProp& a_AdmProp, CAdmNode& a_AdmDstNode,
                LPCTSTR *a_lplpszPropValue,
                DWORD *a_lpdwPropValueLength,
                WORD wPropValueCount)

{

    DWORD dwCommandCode=0;

    dwCommandCode = tCommandNameTable::MapNameToCode(strCommand);

    switch(dwCommandCode)
    {

    case CMD_SAVE:
    SaveData();
    if (FAILED(hresError)) {}
    else{
        Print(_TEXT("saved\n"));
    }
    break;

    case CMD_CREATE:
    {
        if (a_AdmNode.GetProperty()!=_TEXT("")) //property name cannot be used
            Error(_TEXT("property name for CREATE not supported"));
    //    else if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
    //        Error(_TEXT("service name for CREATE is missing"));
        else
        {
            CreateObject(a_AdmNode);
            if( SUCCEEDED(QueryLastHresError()))
            {
              //  SaveData(); //end of transaction
                if( SUCCEEDED(QueryLastHresError()))
                {
                    Print(_TEXT("created \"%s\"\n"), LPCTSTR(a_AdmNode.GetNodePath()));
                }
            }
        }
    }
    break;
    case CMD_SET:
    {
        CAdmProp AdmPropToGet;
        AdmPropToGet = a_AdmProp;
        AdmPropToGet.SetAttrib(0);
        AdmPropToGet.SetUserType(0);
        AdmPropToGet.SetDataType(0);

        DisablePrint(); //do not print any error message
        GetProperty(a_AdmNode, AdmPropToGet);
        EnablePrint(); //continue printing error messages

        //*************************SETTING ATTRIB, DATATYPE, USERTYPE
        // if the parameter exists in the metabase, then existing ATTRIB, DATATYPE, USERTYPE
        //              will be used , but this can be overwritten from a_AdmProp
        // if the parameter doesn't exists in the metabase, then default ATTRIB, DATATYPE, USERTYPE
        //              (see tables.cpp) will be used , but this can be overwritten from a_AdmProp

        if(FAILED(QueryLastHresError()))
        {  //store the value to be set into a_AdmProp
                //FIND DEFAULT SETTINGS
                DWORD dwPropCode=a_AdmProp.GetIdentifier();
                tPropertyNameTable * PropNameTableRecord = tPropertyNameTable::FindRecord(dwPropCode);
                if (PropNameTableRecord!=NULL)
                {
                        AdmPropToGet.SetIdentifier(PropNameTableRecord->dwCode);
                        AdmPropToGet.SetAttrib(PropNameTableRecord->dwDefAttributes) ;
                        AdmPropToGet.SetUserType(PropNameTableRecord->dwDefUserType);
                        AdmPropToGet.SetDataType(PropNameTableRecord->dwDefDataType);
                }
        }
        else
        {  //reuse the existing settings
                if( a_AdmProp.GetDataType()!=0 &&(a_AdmProp.GetDataType()!= AdmPropToGet.GetDataType()))
                {
                        Error(_TEXT("Cannot redefine data type from %s to %s"),
                                tDataTypeNameTable::MapCodeToName(AdmPropToGet.GetDataType()),
                                tDataTypeNameTable::MapCodeToName(a_AdmProp.GetDataType()));
                        break;
                }
        }
        // use settings passed to the function if set
        if(!a_AdmProp.IsSetDataType())
                a_AdmProp.SetDataType(AdmPropToGet.GetDataType()); //reuse existing data type
        if(!a_AdmProp.IsSetUserType())
                a_AdmProp.SetUserType(AdmPropToGet.GetUserType()); //reuse existing user type
        if(!a_AdmProp.IsSetAttrib())
                a_AdmProp.SetAttrib(AdmPropToGet.GetAttrib()); //reuse exixting attrib




        if(a_AdmProp.SetValueByDataType( (LPCTSTR *)a_lplpszPropValue, a_lpdwPropValueLength, wPropValueCount)==0)
             Error(_TEXT("SetValueByDataType failed"));
        else
        {
           // if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
           //     Error(_TEXT("service name for SET is missing"));
           // else
            if (a_AdmNode.GetProperty()!=_TEXT(""))
            {
                SetProperty(a_AdmNode, a_AdmProp);
                if( SUCCEEDED(QueryLastHresError()))
                {
                    //SaveData(); //end of transaction
                    if( SUCCEEDED(QueryLastHresError()))
                    {
                        GetProperty(a_AdmNode, a_AdmProp);
                        if(SUCCEEDED(QueryLastHresError()))
                            a_AdmProp.PrintProperty();
                    }
                }
            }else
                Error(_TEXT("property name missing for SET command"));
        }
        break;
    }
    case CMD_DELETE:

        //if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
        //    Error(_TEXT("service name for DELETE is missing"));
        if (IsServiceName(a_AdmNode.GetService()) && a_AdmNode.GetInstance()==_TEXT("") && a_AdmNode.GetIPath()==_TEXT("") && a_AdmNode.GetProperty()==_TEXT(""))
            Error(_TEXT("cannot delete service"));
        else if (a_AdmNode.GetInstance()==_TEXT("1") && a_AdmNode.GetIPath()==_TEXT("") && a_AdmNode.GetProperty()==_TEXT("")) //property name cannot be used
            Error(_TEXT("cannot delete 1. instance"));
        else if (a_AdmNode.GetProperty()!=_TEXT(""))
        {
            DeleteProperty(a_AdmNode, a_AdmProp);
        }
        else
        {
            DeleteObject(a_AdmNode, a_AdmProp);
        }
            //if( SUCCEEDED(QueryLastHresError()))
            //{
            //  GetProperty(a_AdmNode, a_AdmProp);
            //  if(SUCCEEDED(QueryLastHresError()))
            //      a_AdmProp.PrintProperty();
            //}
        if(SUCCEEDED(QueryLastHresError()))
        {
            //SaveData(); //end of transaction
            if( SUCCEEDED(QueryLastHresError()))
            {
                Print(_TEXT("deleted \"%s"), LPCTSTR(a_AdmNode.GetNodePath()));
                if(a_AdmNode.GetProperty()!=_TEXT(""))
                    Print(_TEXT("%s"),LPCTSTR(((a_AdmNode.GetNodePath().Right(1)==_TEXT("/"))?_TEXT(""):_TEXT("/"))+
                                    a_AdmNode.GetProperty()));
                Print(_TEXT("\"\n"));
            }

        }
        break;

    case CMD_GET:
        //    if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
        //        Error(_TEXT("service name for GET is missing"));

        //    else
            if (a_AdmNode.GetProperty()!=_TEXT(""))
            {
                GetProperty(a_AdmNode, a_AdmProp);
                if(SUCCEEDED(QueryLastHresError()))
                    a_AdmProp.PrintProperty();
            }
            else
            {
                EnumPropertiesAndPrint(a_AdmNode, a_AdmProp);
            }
        break;
    case CMD_COPY:

            if(a_AdmDstNode.GetNodePath()==_TEXT(""))
                Error(_TEXT("destination path is missing"));
            else if(a_AdmNode.GetProperty()!=_TEXT("") || a_AdmDstNode.GetProperty()!=_TEXT(""))
                Error(_TEXT("copying of properties (parameters) not supported\n"));
            //else if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("service name in source path for COPY is missing"));
            //else if (a_AdmDstNode.GetService()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("service name for destination path COPY is missing"));
            //else if (a_AdmNode.GetInstance()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("instance number in source path for COPY is missing"));
            //else if (a_AdmDstNode.GetInstance()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("instance number in destination path for COPY is missing"));

            else
            {
                CopyObject(a_AdmNode,a_AdmDstNode);
                if(SUCCEEDED(QueryLastHresError()))
                {
                    //SaveData(); //end of transaction
                    if( SUCCEEDED(QueryLastHresError()))
                    {

                        Print(_TEXT("copied from %s to %s\n"), LPCTSTR(a_AdmNode.GetNodePath()),LPCTSTR(a_AdmDstNode.GetNodePath()));
                    }
                }
                break;
            }
        break;
    case CMD_RENAME:
            if(a_AdmDstNode.GetNodePath()==_TEXT(""))
                Error(_TEXT("destination path is missing"));
            else if(a_AdmNode.GetProperty()!=_TEXT("") || a_AdmDstNode.GetProperty()!=_TEXT(""))
                Error(_TEXT("renaming of properties (parameters) not supported"));
            //else if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("service name in source path for RENAME is missing"));
            //else if (a_AdmDstNode.GetService()==_TEXT(""))
            //    Error(_TEXT("service name for destination path RENAME is missing"));
            //else if (a_AdmNode.GetInstance()==_TEXT(""))
            //    Error(_TEXT("instance number in source path for RENAME is missing"));
            //else if (a_AdmDstNode.GetInstance()==_TEXT(""))
            //   Error(_TEXT("instance number in destination path for RENAME is missing"));
            else if (a_AdmNode.GetInstance()==_TEXT("1") && a_AdmNode.GetIPath()==_TEXT(""))
                Error(_TEXT("cannot rename 1. instance"));
            else if (a_AdmNode.GetRelPathFromService().CompareNoCase(a_AdmDstNode.GetRelPathFromService())==0)
                Error(_TEXT("cannot rename to itself"));
            else
            {  //check if one of the paths is not the child of the other one
                CString str1=a_AdmNode.GetRelPathFromService();
                CString str2=a_AdmDstNode.GetRelPathFromService();

                CString strCommonPath=FindCommonPath(str1,str2);

                if(strCommonPath.CompareNoCase(str1)==0 ||
                        strCommonPath.CompareNoCase(str1)==0)
                    Error(_TEXT("cannot rename - one path is the child of the other"));
                else
                { //O.K.
                    //CopyObject(a_AdmNode,a_AdmDstNode);
                    //if(SUCCEEDED(QueryLastHresError()))
                    //{
                    //    DeleteObject(a_AdmNode,a_AdmProp);
                    //    if(SUCCEEDED(QueryLastHresError()))
                    //    {
                    //       // SaveData(); //end of transaction
                    //        if( SUCCEEDED(QueryLastHresError()))
                    //        {
                    //            Print("renamed from %s to %s\n", LPCTSTR(a_AdmNode.GetNodePath()),LPCTSTR(a_AdmDstNode.GetNodePath()));
                    //        }
                    //    }
                    // }
                    RenameObject(a_AdmNode,a_AdmDstNode);
                    if(SUCCEEDED(QueryLastHresError()))
                    {
                      // SaveData(); //end of transaction
                       if( SUCCEEDED(QueryLastHresError()))
                       {

                           Print(_TEXT("renamed from %s to %s\n"), LPCTSTR(a_AdmNode.GetNodePath()),LPCTSTR(a_AdmDstNode.GetNodePath()));
                       }
                    }
                }
            }

            break;

    case CMD_ENUM:
            EnumAndPrint(a_AdmNode, a_AdmProp, FALSE/*no recursion*/);
            break;
    case CMD_ENUM_ALL:
            EnumAndPrint(a_AdmNode, a_AdmProp,TRUE/*no recursion*/);
            break;
    case CMD_APPCREATEINPROC:
            AppCreateInProc(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPDELETE:
            AppDelete(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPRENAME:
            AppRename(a_AdmNode,a_AdmDstNode,a_AdmNode.GetComputer());
            break;

    case CMD_APPCREATEOUTPROC:
            AppCreateOutProc(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPGETSTATUS:
            AppGetStatus(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPUNLOAD:
            AppUnLoad(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;


    default:
        Print(_TEXT("Command not recognized: %s\n"),strCommand);
        hresError=RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        return ;

    }
    return;
}


//if hresError is 0, we will set it to invalid parameter

void CAdmUtil::Error(const _TCHAR * format,...)
{
   _TCHAR buffer[2000];
   va_list marker;
   va_start( marker, format );     /* Initialize variable arguments. */

   int x=_vstprintf(buffer, format, marker);

   va_end( marker );              /* Reset variable arguments.      */
    if(hresError==0)
    {
        if(fPrint)
    {
            _ftprintf(stderr,_TEXT("Error: %s\n"),buffer);
    }

        hresError=RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER); //little trick
    }
    else
    {


        if(fPrint)
        {
            _ftprintf(stderr,_TEXT("Error: %s - HRES(0x%x)   %s\n"), buffer, hresError/*, ConvertHresToDword(hresError),ConvertHresToDword(hresError)*/,ConvertReturnCodeToString(ConvertHresToDword(hresError)));
	    if(getenv("MDUTIL_ASCENT_LOG")!=NULL)
	    {
		//we got to do some ascent logging

		FILE *fpAscent;
		fpAscent=fopen("Ascent.log","a");
		if (fpAscent)
		{
			//new variation description
			fprintf(fpAscent,"Variation1: METADATA ACCESS (by mdutil.exe)\n");
			fprintf(fpAscent,"Explain: READ OR WRITE OPERATION TO METADATA \n");

			//variation summary
			fprintf(fpAscent,"Attempted: 1 \n");
			fprintf(fpAscent,"Passed: 0 \n");
			fprintf(fpAscent,"Failed: 1 \n");


			_ftprintf(fpAscent,_TEXT("Error: Operation failed with HRES(0x%x)\n"), hresError);

			fclose(fpAscent);
		}
	    }
	}
    }

    if(fPrint)
    {
	  if(getenv("MDUTIL_BLOCK_ON_ERROR")!=NULL && hresError!=0x80070003)  //path not found
	  {
		_ftprintf(stdout,_TEXT("\nHit SPACE to continue or Ctrl-C to abort.\n"));
		while(1)
		{
			while(!_kbhit())
			{
				;
			}

			if(_getch()==' ')
			{
				_ftprintf(stdout,_TEXT("Continuing...\n"));
				break;
			}
		}
	  }
     }

}

void CAdmUtil::Print(const _TCHAR * format,...)
{

   va_list marker;
   va_start( marker, format );     /* Initialize variable arguments. */
   if(fPrint)
    _vtprintf(format, marker);
   va_end( marker );              /* Reset variable arguments.      */
}


LPTSTR ConvertReturnCodeToString(DWORD ReturnCode)
{
    LPTSTR RetCode = NULL;
    switch (ReturnCode) {
    case ERROR_SUCCESS:
        RetCode = _TEXT("ERROR_SUCCESS");
        break;
    case ERROR_PATH_NOT_FOUND:
        RetCode = _TEXT("ERROR_PATH_NOT_FOUND");
        break;
    case ERROR_INVALID_HANDLE:
        RetCode = _TEXT("ERROR_INVALID_HANDLE");
        break;
    case ERROR_INVALID_DATA:
        RetCode =_TEXT("ERROR_INVALID_DATA");
        break;
    case ERROR_INVALID_PARAMETER:
        RetCode =_TEXT("ERROR_INVALID_PARAMETER");
        break;
    case ERROR_NOT_SUPPORTED:
        RetCode =_TEXT("ERROR_NOT_SUPPORTED");
        break;
    case ERROR_ACCESS_DENIED:
        RetCode =_TEXT("ERROR_ACCESS_DENIED");
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        RetCode =_TEXT("ERROR_NOT_ENOUGH_MEMORY");
        break;
    case ERROR_FILE_NOT_FOUND:
        RetCode =_TEXT("ERROR_FILE_NOT_FOUND");
        break;
    case ERROR_DUP_NAME:
        RetCode =_TEXT("ERROR_DUP_NAME");
        break;
    case ERROR_PATH_BUSY:
        RetCode =_TEXT("ERROR_PATH_BUSY");
        break;
    case ERROR_NO_MORE_ITEMS:
        RetCode =_TEXT("ERROR_NO_MORE_ITEMS");
        break;
    case ERROR_INSUFFICIENT_BUFFER:
        RetCode =_TEXT("ERROR_INSUFFICIENT_BUFFER");
        break;
    case ERROR_PROC_NOT_FOUND:
        RetCode =_TEXT("ERROR_PROC_NOT_FOUND");
        break;
    case ERROR_INTERNAL_ERROR:
        RetCode =_TEXT("ERROR_INTERNAL_ERROR");
        break;
    case MD_ERROR_NOT_INITIALIZED:
        RetCode =_TEXT("MD_ERROR_NOT_INITIALIZED");
        break;
    case MD_ERROR_DATA_NOT_FOUND:
        RetCode =_TEXT("MD_ERROR_DATA_NOT_FOUND");
        break;
    case ERROR_ALREADY_EXISTS:
        RetCode =_TEXT("ERROR_ALREADY_EXISTS");
        break;
    case MD_WARNING_PATH_NOT_FOUND:
        RetCode =_TEXT("MD_WARNING_PATH_NOT_FOUND");
        break;
    case MD_WARNING_DUP_NAME:
        RetCode =_TEXT("MD_WARNING_DUP_NAME");
        break;
    case MD_WARNING_INVALID_DATA:
        RetCode =_TEXT("MD_WARNING_INVALID_DATA");
        break;
    case ERROR_INVALID_NAME:
        RetCode =_TEXT("ERROR_INVALID_NAME");
        break;
    default:
        RetCode= _TEXT("");//RetCode = "Unrecognized Error Code");
        break;
    }
    return (RetCode);
}

DWORD ConvertHresToDword(HRESULT hRes)
{
    return HRESULTTOWIN32(hRes);
}

LPTSTR ConvertHresToString(HRESULT hRes)
{
    LPTSTR strReturn = NULL;

    if ((HRESULT_FACILITY(hRes) == FACILITY_WIN32) ||
        (HRESULT_FACILITY(hRes) == FACILITY_ITF) ||
        (hRes == 0)) {
        strReturn = ConvertReturnCodeToString(ConvertHresToDword(hRes));
    }
    else {
        switch (hRes) {
        case CO_E_SERVER_EXEC_FAILURE:
            strReturn =_TEXT("CO_E_SERVER_EXEC_FAILURE");
            break;
        default:
            strReturn =_TEXT("Unrecognized hRes facility");
        }
    }
    return(strReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpmd\main.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       main.cpp

   Abstract:

       command line admin tool main function

   Environment:

      Win32 User Mode

   Author: 
     
      jaroslad  (jan 1997)

--*/

#include <tchar.h>

#include <afx.h>

#include <string.h>
#include <stdlib.h>
#include <stdio.h>   


#include "admutil.h"
#include "tables.h"
#include "jd_misc.h"    



CAdmUtil oAdmin;  //admin object

#define MAX_NUMBER_OF_SMALL_VALUES  100
#define MAX_NUMBER_OF_VALUES  10100
#define MAX_NUMBER_OF_DEFAULT_ARGS  10110


//structure stores the command line arguments

struct tAdmutilParams
{
    WORD fHelp; //print help - flag
    WORD fFullHelp; //print help - flag
    WORD fNoSave; //do not save metabase
    LPCTSTR lpszCommand;
    LPCTSTR lpszComputer;
    WORD  wInstance;
    LPCTSTR lpszService;
    LPCTSTR lpszPath;
    LPCTSTR lpszComputerDst; //for COPY destination
    WORD  wInstanceDst;     //for COPY destination
    LPCTSTR lpszServiceDst; //for COPY destination
    LPCTSTR lpszPathDst;        //for COPY destination

    LPCTSTR lplpszDefaultArg[MAX_NUMBER_OF_DEFAULT_ARGS];
    WORD wDefaultArgCount;

    LPCTSTR lpszPropName;

    LPCTSTR lplpszPropAttrib[MAX_NUMBER_OF_SMALL_VALUES];
    WORD  wPropAttribCount;
    LPCTSTR lplpszPropDataType[MAX_NUMBER_OF_SMALL_VALUES];
    WORD wPropDataTypeCount;
    LPCTSTR lplpszPropUserType[MAX_NUMBER_OF_SMALL_VALUES];
    WORD wPropUserTypeCount;
    LPCTSTR lplpszPropValue[MAX_NUMBER_OF_VALUES]; //pointer to array of values (e.g multisz type allows the multiple values for one property
    DWORD lpdwPropValueLength[MAX_NUMBER_OF_VALUES];
    WORD  wPropValueCount;
    WORD  wPropFileValueCount;
};

tAdmutilParams Params;
_TCHAR **g_argv;
int g_argc;

static BOOL CompareOutput(_TCHAR *FileToCompare,_TCHAR* FileTemplate);

// definition of command line syntax with some help text -this is the input for ParseParam()

TParamDef CmdLineArgDesc[]=
{
 {_TEXT(""),MAX_NUMBER_OF_DEFAULT_ARGS, (void *) Params.lplpszDefaultArg,TYPE_LPCTSTR,OPT, _TEXT("Command [param ...]"),_TEXT("CMD [param param]"),&Params.wDefaultArgCount},
 {_TEXT("svc") ,1, (void *) &Params.lpszService,TYPE_LPCTSTR,OPT,_TEXT("service (MSFTPSVC, W3SVC)")},
 {_TEXT("s"), 1, (void *) &Params.lpszComputer,TYPE_LPCTSTR,OPT, _TEXT("name of computer to administer"),_TEXT("comp"),},          
 {_TEXT("i") ,1, &Params.wInstance, TYPE_WORD, OPT,_TEXT("instance number"),_TEXT("inst")},
 {_TEXT("path"),1, (void *) &Params.lpszPath,   TYPE_LPCTSTR,OPT, _TEXT("path "),_TEXT("path")},
 {_TEXT("pathdst"),1, (void *) &Params.lpszPathDst, TYPE_LPCTSTR,OPT, _TEXT("destination path (use for COPY only)"),_TEXT("path")},
 {_TEXT("prop"),1, (void *) &Params.lpszPropName, TYPE_LPCTSTR,OPT, _T("property (IIS parameter) name")},
 {_TEXT("attrib"),MAX_NUMBER_OF_SMALL_VALUES, (void *) Params.lplpszPropAttrib,TYPE_LPCTSTR,OPT, _T("property attributes"),_T(""),&Params.wPropAttribCount},
 {_TEXT("utype"),MAX_NUMBER_OF_SMALL_VALUES, (void *) Params.lplpszPropUserType,TYPE_LPCTSTR,OPT, _T("property user type"),_T(""),&Params.wPropUserTypeCount},
 {_TEXT("dtype"),MAX_NUMBER_OF_SMALL_VALUES, (void *) Params.lplpszPropDataType,TYPE_LPCTSTR,OPT, _T("property data type"),_T(""),&Params.wPropDataTypeCount},
 {_TEXT("value"),MAX_NUMBER_OF_VALUES, (void *) Params.lplpszPropValue,TYPE_LPCTSTR,OPT, _T("property values"),_T(""),&Params.wPropValueCount},
 {_TEXT("fvalue"),MAX_NUMBER_OF_VALUES, (void *) Params.lplpszPropValue,TYPE_LPCTSTR,OPT, _T("property values as files"),_T(""),&Params.wPropFileValueCount},
 {_TEXT("nosave"),0, &Params.fNoSave,TYPE_WORD,OPT, _T("do not save metabase"),_T("")},
 {_TEXT("timeout"),1, &g_dwTIMEOUT_VALUE,TYPE_DWORD,OPT, _T("timeout for metabase access in ms (default is 30000 sec"),_T("")},
 {_TEXT("delayafteropen"),1, &g_dwDELAY_AFTER_OPEN_VALUE,TYPE_DWORD,OPT, _T("delay after opening node (default is 0 sec)"),_T("")},
 {_TEXT("help"),0, &Params.fFullHelp,TYPE_WORD,OPT, _T("print full help"),_T("")},
 {_TEXT("?"),0, &Params.fHelp,TYPE_WORD,OPT, _T("print help"),_T("")},  
  {NULL,0, NULL ,         TYPE_TCHAR, OPT, 
   _T("IIS K2 administration utility that enables the manipulation with metabase parameters\n")
   _T("\n")
   _T("Notes:\n")
   _T(" Simpified usage of mdutil doesn't require any switches.\n")
   _T(" \n")
   _T(" mdutil GET      path             - display chosen parameter\n")
   _T(" mdutil SET      path value ...   - assign the new value\n")
   _T(" mdutil ENUM     path             - enumerate all parameters for given path\n")
   _T(" mdutil ENUM_ALL path             - recursively enumerate all parameters\n")
   _T(" mdutil DELETE   path             - delete given path or parameter\n")
   _T(" mdutil CREATE   path             - create given path\n")
   _T(" mdutil COPY     pathsrc pathdst  - copy all from pathsrc to pathdst (will create pathdst)\n")
   _T(" mdutil RENAME   pathsrc pathdst  - rename chosen path\n")
   _T(" mdutil SCRIPT   scriptname       - runs the script\n")
   _T(" mdutil APPCREATEINPROC  w3svc/1/root - Create an in-proc application \n")
   _T(" mdutil APPCREATEOUTPROC w3svc/1/root - Create an out-proc application\n")
   _T(" mdutil APPDELETE        w3svc/1/root - Delete the application if there is one\n")
   _T(" mdutil APPRENAME        w3svc/1/root/dira w3svc/1/root/dirb - Rename the application \n")
   _T(" mdutil APPUNLOAD        w3svc/1/root - Unload an application from w3svc runtime lookup table.\n")
   _T(" mdutil APPGETSTATUS     w3svc/1/root - Get status of the application\n")
   _T("\n")
   _T("  -path has format: {computer}/{service}/{instance}/{URL}/{Parameter}\n")
   _T("\n")
   _T("Samples:\n")
   _T("  mdutil GET W3SVC/1/ServerBindings     \n")
   _T("  mdutil SET JAROSLAD2/W3SVC/1/ServerBindings \":81:\"\n")
   _T("  mdutil COPY W3SVC/1/ROOT/iisadmin W3SVC/2/ROOT/adm\n")
   _T("  mdutil ENUM_ALL W3SVC\n")
   _T("  mdutil ENUM W3SVC/1\n")
   _T("\n")
   _T("Additional features\n")
   _T("  set MDUTIL_BLOCK_ON_ERROR environment variable to block mdutil.exe after error (except ERROR_PATH_NOT_FOUND)\n")
   _T("  set MDUTIL_ASCENT_LOG environment variable to force mdutil.exe to append errors to ascent log\n")
   _T("  set MDUTIL_PRINT_ID environment variable to force mdutil.exe to print metadata numeric identifiers along with friendly names\n")
 }
};


BOOL
ReadFromFiles( 
    LPTSTR*  lplpszPropValue,
    DWORD*  lpdwPropValueLength,
    DWORD   dwPropFileValueCount 
    )
{
    DWORD dwL;

    while ( dwPropFileValueCount-- )
    {
        FILE* fIn = _tfopen( lplpszPropValue[dwPropFileValueCount], _T("rb") );
        if ( fIn == NULL )
        {
            return FALSE;
        }
        if ( fseek( fIn, 0, SEEK_END ) == 0 )
        {
            dwL = ftell( fIn );
            fseek( fIn, 0, SEEK_SET );
        }
        else
        {
            fclose( fIn );
            return FALSE;
        }
        if ( (lplpszPropValue[dwPropFileValueCount] = (LPTSTR)malloc( dwL )) == NULL )
        {
            fclose( fIn );
            return FALSE;
        }
        if ( fread( lplpszPropValue[dwPropFileValueCount], 1, dwL, fIn ) != dwL )
        {
            fclose( fIn );
            return FALSE;
        }
        fclose( fIn );
        lpdwPropValueLength[dwPropFileValueCount] = dwL;
    }

    return TRUE;
}

///////////////////////////////

class CScript
{
    FILE * m_fpScript;
    void GetNextToken(/*OUT*/ LPTSTR * lplpszToken);
    DWORD CleanWhiteSpaces(void);
public:
    CScript(void) {m_fpScript=0;};
    DWORD Open(LPCTSTR lpszFile);
    DWORD Close(void);
    DWORD GetNextLineTokens(int *argc, /*OUT*/ _TCHAR *** argv);
};



DWORD CScript::CleanWhiteSpaces()
{

    if(m_fpScript!=NULL)
    {
        int LastChar=0;
        _TINT c=0;
        while(1)
        {   
            LastChar=c;
            c=_fgettc(m_fpScript);
            if(c==_T('\t') || c==_T(' ') || c==_T('\r'))
            {   continue;
            }
            if(c==_T('\\'))
            {
                int cc=_fgettc(m_fpScript);
                if (cc==_T('\r')) //continue with the next line of the file
                {
                    if(_fgettc(m_fpScript)!=_T('\n'))
                    {
                        fseek( m_fpScript, -1, SEEK_CUR );
                    }
                    continue;
                }
                else if (cc==_T('\n')) //continue with the next line of the file
                {   
                    continue;
                }   
                else
                {
                    fseek( m_fpScript, -2, SEEK_CUR );
                    break;
                }
            }
            if(c==WEOF)
            {   break;
            }
            else
            {   fseek( m_fpScript, -1, SEEK_CUR ); //return back one position
                break;
            }
        }
    }
    return 0;
}

void CScript::GetNextToken(LPTSTR * lplpszToken)
{
    enum {TERMINATE_QUOTE, TERMINATE_WHITESPACE};
    long flag=TERMINATE_WHITESPACE;

    //clean white spaces
    CleanWhiteSpaces();
    //store the beginning offset of token
    long Offset = ftell(m_fpScript);
    _TINT c=_fgettc(m_fpScript);
    long CurrentOffset=0;
    
    if(c==WEOF)
    {
        *lplpszToken=NULL;
        return ;
    }
    if (c==_T('\n')){
        *lplpszToken=_T("\n");
        return ;
    }
    else
    {
        if (c==_T('\"')) { //token ends with " or the end of the line
            flag=TERMINATE_QUOTE;
            Offset = ftell(m_fpScript);
        }
        else {
            flag=TERMINATE_WHITESPACE;
        }
        
        // find the end of the token
        while(1) {
            CurrentOffset=ftell(m_fpScript);
            c=_fgettc(m_fpScript);
            
            if(c==_T('\n')){
                break;
            }

            if(c==WEOF)
            {
                break;
            }

            
            if( (flag==TERMINATE_QUOTE && c==_T('\"')) || (
                    flag==TERMINATE_WHITESPACE && (c==_T(' ') || c==_T('\t') || c==_T('\r')) ) ){
                break;
            }
        }
        

        //get the token size
        long TokenSize = CurrentOffset - Offset;
        
        if(TokenSize!=0)
        {
            // allocate mamory for the token
            *lplpszToken = new _TCHAR[ TokenSize+1 ];
            //read the token
            fseek( m_fpScript, Offset, SEEK_SET);
            for(int i=0;i<TokenSize;i++)
                (*lplpszToken)[i]=(TCHAR)_fgettc(m_fpScript);
            //terminate the token
            (*lplpszToken)[i]=0; 
        }
        else
        { //empty string
            *lplpszToken=new _TCHAR[1 ];
            (*lplpszToken)[0]=0;
        }
        //discard double quote if it was at the end of the token
        c=_fgettc(m_fpScript);
        if(c!=_T('\"'))
            fseek( m_fpScript, ((c==WEOF)?0:-1), SEEK_CUR );
    }
}
    


DWORD CScript::Open(LPCTSTR lpszFile)
{
    m_fpScript = _tfopen(  lpszFile, _T("rt") );
    if(m_fpScript==NULL)
        return GetLastError();
    else
        return ERROR_SUCCESS;
}

DWORD CScript::Close()
{
    if( m_fpScript!=NULL)
        fclose( m_fpScript);
    return GetLastError();
}


DWORD CScript::GetNextLineTokens(int *argc, /*OUT*/ _TCHAR *** argv)
{
    for(int i=1;i<*argc;i++) {
        delete  (*argv)[i];
        (*argv)[i]=0;
    }
    *argc=0;
    if(*argv==NULL)
        (*argv)=new LPTSTR [ MAX_NUMBER_OF_VALUES ];

    (*argv)[(*argc)++]=_T("mdutil"); //set zero parameter
    
    LPTSTR lpszNextToken=NULL;
    while((*argc)<MAX_NUMBER_OF_VALUES) {
        GetNextToken(&lpszNextToken);
        if(lpszNextToken==NULL )  //end of file
            break;
    
        if(_tcscmp(lpszNextToken,_T("\n"))==0)  //new line
            break;
        (*argv)[(*argc)++]=lpszNextToken;
        
    }
    return GetLastError();
}


int  MainFunc(int argc, _TCHAR **argv); //declaration



//MAIN FUNCTION
int __cdecl main(int argc, CHAR **_argv)
{


    //  convert parameters from SBCS to UNICODE;
    _TCHAR **argv= new LPTSTR [argc];
    for (int i=0;i<argc;i++)
    {
        argv[i]=new _TCHAR[strlen(_argv[i])+1];
        #ifdef UNICODE
            MultiByteToWideChar(0, 0, _argv[i], -1, argv[i],strlen(_argv[i])+1 );
        #else
            strcpy(argv[i],_argv[i]);
        #endif  
    }
    

    DWORD dwCommandCode=0;

    DWORD retval=0;
    HRESULT hRes;
    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hRes)) {
        fatal_error_printf(_T("CoInitializeEx\n"));
    }

    //extract command line parameters
    ParseParam(argc,argv,CmdLineArgDesc); 
    //**************************
    //PRINT HELP ON REQUEST
    if(Params.fFullHelp)
    {
        //print help
        DisplayUsage(argv,CmdLineArgDesc);
        PrintTablesInfo();
    }
    else if(Params.wDefaultArgCount==0 || Params.fHelp)
    {
        //print help
        DisplayUsage(argv,CmdLineArgDesc);
    }
    else
    {
            if (Params.wDefaultArgCount>0)
    { 
        //first default has to be command
        Params.lpszCommand=Params.lplpszDefaultArg[0];
        dwCommandCode = tCommandNameTable::MapNameToCode(Params.lplpszDefaultArg[0]);
        if( Params.wDefaultArgCount>1)
        {   //second default 
                Params.lpszPath=Params.lplpszDefaultArg[1];
        }
            if(dwCommandCode==CMD_SCRIPT)  //process script
            { 
                tAdmutilParams StoredParams=Params;

                CScript Script;
                DWORD dwRes;
                if((dwRes=Script.Open(Params.lpszPath))!=ERROR_SUCCESS)
                    fatal_error_printf(_T("cannot open script file %s (error %d)\n"),Params.lpszPath,dwRes);

                int l_argc=0;
                _TCHAR ** l_argv=NULL;
                while(1)
                {
                    Script.GetNextLineTokens(&l_argc,&l_argv);
                    if(l_argc==1) //end of script file
                        break;
                    Params=StoredParams; 
                    _tprintf(_T(">"));
                    for(int i=1;i<l_argc;i++)
                        _tprintf(_T("%s "),l_argv[i]);
                    _tprintf(_T("\n"));
                    DWORD retval1=MainFunc(l_argc,l_argv);
                    retval = ((retval==0) ? retval1:retval);
                }
                if (oAdmin.GetpcAdmCom()!=NULL)
                {
                    if(Params.fNoSave)
                    {}
                    else
                        oAdmin.SaveData();
                }

            }
            else
            {
                retval=MainFunc(argc,argv); //run only one command typed on the command line
                if (oAdmin.GetpcAdmCom()!=NULL)
                {
                    if(Params.fNoSave)
                    {}
                    else
                        oAdmin.SaveData();
                }
            }
        }   
    
        
    }

    //close admin object
    oAdmin.Close(); 
    //close wam adm object
    oAdmin.CloseWamAdm();

    CoUninitialize();
    //Cleanup of parameters
    if(argv!=0)
    {
        for (int i=0;i<argc;i++)
        {
            delete [] argv[i];
        }
        delete argv;
    }

    return retval;

}

int  MainFunc(int argc, _TCHAR **argv)
{   
    g_argc=argc;
    g_argv=argv;
    DWORD retval;
    
    LPCTSTR lpszCommand=0;

    CAdmNode AdmNode;
    CAdmProp AdmProp;
    CAdmNode AdmDstNode;

    int i;
    
    DWORD dwCommandCode=0;

    //extract command line parameters
    ParseParam(argc,argv,CmdLineArgDesc); 
    

    //PROCESS THE DEFAULT PARAMETERS
    // trick: place the default arguments into variables that apply for non default one (see Params structure)
    
    if (Params.wDefaultArgCount>0)
    { //first default has to be command
        Params.lpszCommand=Params.lplpszDefaultArg[0];
        dwCommandCode = tCommandNameTable::MapNameToCode(Params.lplpszDefaultArg[0]);
        if( Params.wDefaultArgCount>1)
        {//second deault has to be path
                Params.lpszPath=Params.lplpszDefaultArg[1];
        }
        if( Params.wDefaultArgCount>2)
        {
            switch(dwCommandCode)
            { 

            case CMD_SET:
                //the rest of default args are values
                Params.wPropValueCount=0;
                for(i=2;i<Params.wDefaultArgCount;i++)
                {
                    Params.lplpszPropValue[i-2] = Params.lplpszDefaultArg[i];
                    Params.wPropValueCount++;
                }
                break;
             case CMD_DELETE:
             case CMD_CREATE:
             case CMD_GET:
             case CMD_ENUM:
             case CMD_ENUM_ALL:
                 if( Params.wDefaultArgCount>2)
                 {
                    error_printf(_T("maximum default arguments number exceeds expected (2)\n"));
                    return 1;
                 }
                 
                        break;
             case CMD_COPY:
             case CMD_RENAME: 
             case CMD_APPRENAME: 
                 if( Params.wDefaultArgCount>3)
                 {
                    error_printf(_T("maximum default arguments number exceeds expected (3)\n"));
                    return 1;
                 }

                 else
                    Params.lpszPathDst=Params.lplpszDefaultArg[2];
                 break;

             default:
                error_printf(_T("command not recognized: %s or number of parameters doesn't match\n"),Params.lpszCommand);
                return 1;

            }
        }
    } //end of default argument handling

        
    //extract computer,service,instance, if stored in Path
    AdmNode.SetPath(Params.lpszPath);

    //valid only for copy function
    AdmDstNode.SetPath(Params.lpszPathDst);

    //process computer, service, instance, property name arguments
    if(Params.lpszComputer!=NULL) {
        if(!AdmNode.GetComputer().IsEmpty()) {
            error_printf(_T("computer name entered more than once\n"));
            return 1;
        }
        else
            AdmNode.SetComputer(Params.lpszComputer);
    }

    if(Params.lpszService!=NULL) {
        if(!AdmNode.GetService().IsEmpty()) {
            error_printf(_T("service name entered more than once\n"));
            return 1;
        }
        else {
            if(IsServiceName(Params.lpszService))
                AdmNode.SetService(Params.lpszService);
            else {
                error_printf(_T("service name not recognized: %s\n"), Params.lpszService);
                return 1;
            }
        }
    }

    if(Params.wInstance!=0) 
    {
        if(!AdmNode.GetInstance().IsEmpty()) {
            error_printf(_T("instance entered more than once\n"));
            return 1;
        }
        else {
            _TCHAR buf[30];
            //!!! maybe ltoa should be used
            AdmNode.SetInstance(_itot(Params.wInstance,buf,10));
        }
    }

    //******************************************        
    //process attrib, utype, dtype, value

    //property name first
    CString strProp=AdmNode.GetProperty();
    if(Params.lpszPropName!=NULL && !strProp.IsEmpty())
    {
        error_printf(_T("property name entered more than once\n"));
        return 1;
    }
    else if (Params.lpszPropName!=NULL)
    {
        AdmNode.SetProperty(Params.lpszPropName);

    }
    if(IsNumber(AdmNode.GetProperty()))
    {
        AdmProp.SetIdentifier(_ttol(AdmNode.GetProperty()));
    }
    else
    {
        DWORD dwIdentifier=MapPropertyNameToCode(AdmNode.GetProperty());
        if(dwIdentifier==NAME_NOT_FOUND)
        {}
        else
            AdmProp.SetIdentifier(dwIdentifier) ;
    }
    
    //process the attrib entered on command line
    if(Params.wPropAttribCount!=0)
    {   DWORD dwAttrib=0;
        for (i=0;i<Params.wPropAttribCount;i++)
        {
            if(IsNumber(Params.lplpszPropAttrib[i]))
                dwAttrib += _ttol(Params.lplpszPropAttrib[i]);
            else
            {
                DWORD dwMapped=MapAttribNameToCode(Params.lplpszPropAttrib[i]);
                if(dwMapped==NAME_NOT_FOUND)
                {
                    error_printf(_T("attribute name not resolved: %s\n"), Params.lplpszPropAttrib[i]);
                    return 1;
                }
                else
                    dwAttrib |= dwMapped;
            }
        }
        //overwrite the default attrib
        AdmProp.SetAttrib(dwAttrib) ;
    }

    //process the usertype entered on command line
    if(Params.wPropUserTypeCount!=0)
    {   DWORD dwUserType=0;
        for (i=0;i<Params.wPropUserTypeCount;i++)
        {
            if(IsNumber(Params.lplpszPropUserType[i]))
                dwUserType += _ttol(Params.lplpszPropUserType[i]);
            else
            {
                DWORD dwMapped=MapUserTypeNameToCode(Params.lplpszPropUserType[i]);
                if(dwMapped==NAME_NOT_FOUND)
                {
                    error_printf(_T("user type not resolved: %s\n"), Params.lplpszPropUserType[i]);
                    return 1;
                }
                else
                    dwUserType |= dwMapped;
            }
        }
        //overwrite the default UserType
        AdmProp.SetUserType(dwUserType) ;
    }


    //process the datatype entered on command line
    if(Params.wPropDataTypeCount!=0)
    {   DWORD dwDataType=0;
        for (i=0;i<Params.wPropDataTypeCount;i++)
        {
            if(IsNumber(Params.lplpszPropDataType[i]))
                dwDataType += _ttol(Params.lplpszPropDataType[i]);
            else
            {
                DWORD dwMapped=MapDataTypeNameToCode(Params.lplpszPropDataType[i]);
                if(dwMapped==NAME_NOT_FOUND)
                {
                    error_printf(_T("DataType type not resolved: %s\n"), Params.lplpszPropDataType[i]);
                    return 1;

                }
                else
                    dwDataType |= dwMapped;
            }
        }
        //overwrite the default DataTypeType
        AdmProp.SetDataType(dwDataType) ;
    }
//LPCTSTR lplpszPropValue[MAX_NUMBER_OF_PROPERTY_VALUES]; //pointer to array of values (e.g multisz type allows the multiple values for one property
//WORD  wPropValueCount;

    
    //create admin object
    if(oAdmin.GetpcAdmCom()==NULL)
    {
        oAdmin.Open(AdmNode.GetComputer());
        if( FAILED(oAdmin.QueryLastHresError()))
        {
            retval= ConvertHresToDword(oAdmin.QueryLastHresError());
        }
    }
    
    
    if(oAdmin.GetpcAdmCom()!=NULL)
    {
        //
        // read from files if Params.wPropFileValueCount != 0
        //

        if ( Params.wPropFileValueCount )
        {
            if ( !ReadFromFiles( (LPTSTR*)Params.lplpszPropValue, Params.lpdwPropValueLength, Params.wPropFileValueCount ) )
            {
                error_printf(_T("Can't read value from file %s"), Params.lplpszPropValue[0] );
                return 1;
            }
            Params.wPropValueCount = Params.wPropFileValueCount;
        }

        oAdmin.Run(CString(Params.lpszCommand), 
            AdmNode, 
            AdmProp, 
            AdmDstNode,
            Params.lplpszPropValue,
            Params.lpdwPropValueLength,
            Params.wPropValueCount);
            retval=ConvertHresToDword(oAdmin.QueryLastHresError());
        
    }
    return ((retval==0)?0:1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpmd\ansimeta.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       ansimeta.cpp

   Abstract:

        WRAPPER functions for ANSI calls of UNICODE ADMCOM interface

   Environment:

      Win32 User Mode

   Author:

      jaroslad  (jan 1997)

--*/


#include "ansimeta.h"
#include <mbstring.h>


WCHAR * ConvertToUnicode(unsigned char * pszString);


WCHAR * ConvertToUnicode(CHAR * pszString)
{
	return ConvertToUnicode((unsigned char *) pszString);
}

WCHAR * ConvertToUnicode(unsigned char * pszString)
{ 
	if (pszString==NULL)
		return NULL;
	int Size_wszString = (_mbslen((const unsigned char *) pszString)+1)*sizeof(WCHAR);
	WCHAR * pwszString = new WCHAR[Size_wszString];
	if (pwszString== NULL)
	{
		return NULL;
	}
	MultiByteToWideChar(0, 0, (char *) pszString, -1, pwszString, Size_wszString);
	return pwszString;
}


CHAR * ConvertToMultiByte(WCHAR * pwszString)
{
	if(pwszString==NULL)
		return NULL;
	int Size_szString = (wcslen(pwszString)*sizeof(WCHAR)+1);
	CHAR * pszString = new CHAR[Size_szString];
	if (pszString== NULL)
	{
		return NULL;
	}
	WideCharToMultiByte(0, 0, pwszString, -1, pszString,Size_szString, NULL,NULL );
	return pszString;
}


HRESULT ConvertMetadataToAnsi(PMETADATA_RECORD pmdrMDData)
{		 
		HRESULT hRes=ERROR_SUCCESS;
     
		//convert data if STRING, EXPAND STRING or MULTISZ
		switch(pmdrMDData->dwMDDataType )
		{
		case STRING_METADATA:
	        case EXPANDSZ_METADATA:
		{
			CHAR * pszData= ConvertToMultiByte((WCHAR *) pmdrMDData->pbMDData);
			if (pszData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
			strcpy((char *)pmdrMDData->pbMDData,pszData);
			pmdrMDData->dwMDDataLen=strlen((char *)pmdrMDData->pbMDData)+1;
			delete [] pszData;
			break;
		}
		case MULTISZ_METADATA:
		{
			WCHAR *pwszMultiString = (WCHAR *) pmdrMDData->pbMDData;
			DWORD dwAnsiDataLen=0;
			do
			{
				CHAR * pszData= ConvertToMultiByte(pwszMultiString);
				if (pszData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
				strcpy((char *)(pmdrMDData->pbMDData)+dwAnsiDataLen,pszData);
				dwAnsiDataLen+=strlen(pszData)+1;
				pwszMultiString+=_mbslen((const unsigned char *)pszData)+1; //move pointer to the next string in MULTISZ
				delete [] pszData;
			}while((void *) pwszMultiString < (void *) (pmdrMDData->pbMDData+pmdrMDData->dwMDDataLen));
			pmdrMDData->dwMDDataLen=dwAnsiDataLen;
			break;
		}
		}
Exit:
	return hRes;
}

HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::AddKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) 
{
	HRESULT hRes=0;
	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);
	if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->AddKey(hMDHandle, pwszMDPath);
	
Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	return hRes;
}

        
HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::DeleteKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) 
{
	HRESULT hRes=0;
	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

	if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->DeleteKey(hMDHandle, pwszMDPath);
	
Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	return hRes;

}
        
        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::EnumKeys( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
            /* [in] */ DWORD dwMDEnumObjectIndex) 
{
	HRESULT hRes=0;
	CHAR * pszMDName1=0;

	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);
	WCHAR pwszMDName[METADATA_MAX_NAME_LEN];


	if ((pwszMDPath==0) || (pwszMDName==0)) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->EnumKeys(hMDHandle, pwszMDPath,pwszMDName,dwMDEnumObjectIndex);

	//convert pszMDName to ANSI
	pszMDName1=ConvertToMultiByte(pwszMDName);
	strcpy((char *)pszMDName,pszMDName1); 
Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	if( pszMDName1!=0) delete [] pszMDName1;
	return hRes;
}


        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::CopyKey( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ BOOL bMDOverwriteFlag,
            /* [in] */ BOOL bMDCopyFlag) 

{
	HRESULT hRes=0;

	WCHAR * pwszMDSourcePath=ConvertToUnicode(pszMDSourcePath);
	WCHAR * pwszMDDestPath=ConvertToUnicode(pszMDDestPath);

	if ((pwszMDSourcePath==0) || (pwszMDDestPath==0) ){ hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->CopyKey(hMDSourceHandle, pwszMDSourcePath, 
					hMDDestHandle, pwszMDDestPath, bMDOverwriteFlag, bMDCopyFlag);
Exit:
	//release memory
	if( pwszMDSourcePath!=0) delete [] pwszMDSourcePath;
	if( pwszMDDestPath!=0) delete [] pwszMDDestPath;
	return hRes;
}



        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::RenameKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName) 
{
	HRESULT hRes=0;

	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);
	WCHAR * pwszMDNewName=ConvertToUnicode(pszMDNewName);

	if ((pwszMDPath==0) || (pwszMDNewName==0)) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->RenameKey(hMDHandle, pwszMDPath,pwszMDNewName);
Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	if( pwszMDNewName!=0) delete [] pwszMDNewName;
	return hRes;
}




        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::SetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ PMETADATA_RECORD pmdrMDData) 
{
	HRESULT hRes=0;
	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

	if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	
     
	//convert data if STRING, EXPAND STRING or MULTISZ
	switch(pmdrMDData->dwMDDataType )
	{
	case STRING_METADATA:
	case EXPANDSZ_METADATA:
	{
		WCHAR * pwszData= ConvertToUnicode((CHAR *) pmdrMDData->pbMDData);
		if (pwszData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
		PBYTE  pbMDStoreData=pmdrMDData->pbMDData;
		DWORD dwMDStoreDataLen=pmdrMDData->dwMDDataLen;
		pmdrMDData->pbMDData= (PBYTE) pwszData;
		pmdrMDData->dwMDDataLen=(wcslen((WCHAR *)pmdrMDData->pbMDData)+1)*sizeof(WCHAR);

		hRes= this->m_pcAdmCom->SetData(hMDHandle, pwszMDPath,pmdrMDData);

		pmdrMDData->dwMDDataLen = dwMDStoreDataLen;
		pmdrMDData->pbMDData = pbMDStoreData;
		delete [] pwszData;
		break;
	}
	case MULTISZ_METADATA:
	{
		CHAR *pszMultiString = (CHAR *) pmdrMDData->pbMDData;
		WCHAR *pwszMDData=new WCHAR[(pmdrMDData->dwMDDataLen)];
		if (pwszMDData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
		DWORD dwUniDataLen=0;
		do
		{
			WCHAR * pwszData= ConvertToUnicode(pszMultiString);
			if (pwszData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
			wcscpy(pwszMDData+dwUniDataLen,pwszData);
			dwUniDataLen+=wcslen(pwszData)+1;
			delete [] pwszData;

			while(*(pszMultiString++)!=0); //move pointer to the next string in MULTISZ
		}while(*pszMultiString!=0);
		pwszMDData[dwUniDataLen++]=0;

		//store original values
		PBYTE pbMDStoreData=pmdrMDData->pbMDData;
		DWORD dwMDStoreDataLen=pmdrMDData->dwMDDataLen;
		
		pmdrMDData->dwMDDataLen=dwUniDataLen*sizeof(WCHAR);
		pmdrMDData->pbMDData= (PBYTE) pwszMDData;

		hRes= this->m_pcAdmCom->SetData(hMDHandle, pwszMDPath,pmdrMDData);

		delete [] pwszMDData;
		//restore original values
		pmdrMDData->dwMDDataLen = dwMDStoreDataLen;
		pmdrMDData->pbMDData = pbMDStoreData;
		break;
	}
	default:
	{
		hRes= this->m_pcAdmCom->SetData(hMDHandle, pwszMDPath,pmdrMDData);
	}
	} //end of switch

Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	return hRes;
}


        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::GetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) 
{
	HRESULT hRes=0;
	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

	if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->GetData(hMDHandle, pwszMDPath,pmdrMDData,pdwMDRequiredDataLen);
	if(SUCCEEDED(hRes))
	{
		ConvertMetadataToAnsi(pmdrMDData);
	}
	
Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	return hRes;
}


        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::DeleteData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType) 
{
	HRESULT hRes=0;
	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

	if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->DeleteData(hMDHandle, pwszMDPath,dwMDIdentifier,dwMDDataType);
	
Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	return hRes;
}

        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::EnumData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [in] */ DWORD dwMDEnumDataIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) 
        
{
	HRESULT hRes=0;
	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

	if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->EnumData(hMDHandle, pwszMDPath,pmdrMDData,dwMDEnumDataIndex,pdwMDRequiredDataLen);
	if(SUCCEEDED(hRes))
	{
		ConvertMetadataToAnsi(pmdrMDData);
	}
	
Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	return hRes;
}        
        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::CopyData( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ BOOL bMDCopyFlag) 
{
	HRESULT hRes=0;

	WCHAR * pwszMDSourcePath=ConvertToUnicode(pszMDSourcePath);
	WCHAR * pwszMDDestPath=ConvertToUnicode(pszMDDestPath);


	if ((pwszMDSourcePath==0) || (pwszMDDestPath==0) ) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->CopyData(hMDSourceHandle, pwszMDSourcePath, 
					hMDDestHandle, pwszMDDestPath, dwMDAttributes,
					dwMDUserType,dwMDDataType,bMDCopyFlag);
Exit:
	//release memory
	if( pwszMDSourcePath!=0) delete [] pwszMDSourcePath;
	if( pwszMDDestPath!=0) delete [] pwszMDDestPath;

	return hRes;
}
        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::OpenKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDAccessRequested,
            /* [in] */ DWORD dwMDTimeOut,
            /* [out] */ PMETADATA_HANDLE phMDNewHandle) 
{
	HRESULT hRes=0;
	WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

	if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

	//call real interface function
	if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
	hRes= this->m_pcAdmCom->OpenKey(hMDHandle, pwszMDPath, dwMDAccessRequested, dwMDTimeOut, phMDNewHandle);
	
Exit:
	//release memory
	if( pwszMDPath!=0) delete [] pwszMDPath;
	return hRes;
}
        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::CloseKey( 
            /* [in] */ METADATA_HANDLE hMDHandle) 
{
	if(this->m_pcAdmCom==0) { return CO_E_NOTINITIALIZED;}
	return this->m_pcAdmCom->CloseKey(hMDHandle);
	
}        
        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::SaveData( void) 
{
	if(this->m_pcAdmCom==0) {return CO_E_NOTINITIALIZED;}
	return this->m_pcAdmCom->SaveData();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpmd\vptool.cpp ===
/*===================================================================
Microsoft ASP

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Package Management Tool

File: main.cpp

Owner: leijin

Note:
===================================================================*/


#include <tchar.h>

#include "admutil.h"
#include <stdio.h>
#include <objbase.h>
#include <initguid.h>

//#ifdef _WAMREG_LINK_DIRECT
//#include "..\wmrgexp.h"
//#endif

#include <iwamreg.h>

#define SIZE_STRING_BUFFER  1024


void CAdmUtil::OpenWamAdm (const CString & strComputer)
{
    IClassFactory * pcsfFactory = NULL;
    COSERVERINFO csiMachineName;
    COSERVERINFO *pcsiParam = NULL;
    OLECHAR rgchMachineName[MAX_PATH];

    //release previous interface if needed
    if(pIWamAdm!=0)
    {
	//reuse the interface
	return;
        //pIWamAdm->Release();
        //pIWamAdm=0;
    }
    //convert to OLECHAR[];
    #if UNICODE
        wsprintfW( rgchMachineName, L"%s", LPCTSTR(strComputer));
    #else
            wsprintfW( rgchMachineName, L"%S", LPCTSTR(strComputer));
    #endif
            
    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;
    pcsiParam = &csiMachineName;
    csiMachineName.pwszName =  (strComputer.IsEmpty())?NULL:rgchMachineName;

    hresError = CoGetClassObject(CLSID_WamAdmin, CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);

    if (FAILED(hresError))
    {
     Error(_T("Failed to CoGetClassObject of WamAdm object"));
    }
    else {
        hresError = pcsfFactory->CreateInstance(NULL, IID_IWamAdmin, (void **) &pIWamAdm);
        if (FAILED(hresError)) Error(_T("Failed to CreateInstance of WamAdm object"));
        pcsfFactory->Release();
    }
}

void CAdmUtil::CloseWamAdm (void)
{
	if(pIWamAdm!=0)
    {
        pIWamAdm->Release();
        pIWamAdm=0;
    }
}

void CAdmUtil::AppCreateInProc(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT     hr = NOERROR;
    //  
    INT         cSize = 0;
    INT         cch = 0;
#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    
    OpenWamAdm(strComputer);

    if (SUCCEEDED(hresError) && pIWamAdm!=0)
    {
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppCreate(wszMetabasePath, TRUE);
        if (FAILED(hresError))
            {
            Error(_T("create failed"));
            }
        else
            {
            Print(_T("application created\n"));
            }
    }

    //CloseWamAdm();

    return;
}

void CAdmUtil::AppCreateOutProc(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];
    
    
    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    OpenWamAdm(strComputer);
    if (SUCCEEDED(hresError)&& pIWamAdm!=0)
    {
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppCreate(wszMetabasePath, FALSE);
        if (FAILED(hresError))
        {
            Error(_T("create failed"));
        }
        else
        {
            Print(_T("application created\n"));
        }
    }
    //CloseWamAdm();
    return;
}

void CAdmUtil::AppDelete(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];


    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    OpenWamAdm(strComputer);
    if (SUCCEEDED(hresError)&& pIWamAdm!=0)
        {
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppDelete(wszMetabasePath,FALSE);
        if (FAILED(hresError))
            {
            Error(_T("delete failed"));
            }   
        else
            {
            Print(_T("application deleted\n"));
            }
        }
    //CloseWamAdm();
    return;
}

void CAdmUtil::AppRename(CAdmNode& a_AdmNode, CAdmNode& a_AdmDstNode, const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];

    WCHAR       wszMetabaseDstPath[SIZE_STRING_BUFFER];

    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, LPCTSTR(a_AdmNode.GetLMNodePath()), -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }

    wcscat(wszMetabaseDstPath,L"/");
    cSize = MultiByteToWideChar(0, 0, LPCTSTR(a_AdmDstNode.GetLMNodePath()), -1, wszMetabaseDstPath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
    wcscat(wszMetabaseDstPath,L"/");

#else
    wcscpy(wszMetabasePath,LPCTSTR(a_AdmNode.GetLMNodePath()));
    wcscpy(wszMetabaseDstPath,LPCTSTR(a_AdmDstNode.GetLMNodePath()));
#endif


    OpenWamAdm(strComputer);
    if (SUCCEEDED(hresError)&& pIWamAdm!=0)
        {
	    CloseObject_hmd(); //close reusable handle; it may conflict with WAM
            hresError = pIWamAdm->AppDeleteRecoverable(wszMetabasePath,TRUE /*Recursive*/);
            if (FAILED(hresError))
            {
                Error(_T("AppDeleteRecoverable() failed"));
            }   
            else
            {
                RenameObject(a_AdmNode,a_AdmDstNode);
                if(FAILED(QueryLastHresError()))
                {
                   Error(_T("node failed to be renamed"));
                }
                else
                {  
	          CloseObject_hmd(); //close reusable handle; it may conflict with WAM
                  hresError = pIWamAdm->AppRecover(wszMetabaseDstPath,TRUE /*Recursive*/);
 	          if (FAILED(hresError))
                  {
                     Error(_T("AppRecover() failed"));
                  }
		  else
                  {
                     Print(_T("application renamed\n"));
                  }
                }
             }
        }
    //CloseWamAdm();
    return;
}


void CAdmUtil::AppUnLoad(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];


    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    OpenWamAdm(strComputer);
    if (SUCCEEDED(hresError)&& pIWamAdm!=0)
        {
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppUnLoad(wszMetabasePath,FALSE);
        if (FAILED(hresError))
            {
            Error(_T("Unload application failed"));
            }
        else
            {
            Print(_T("application unloaded\n"));
            }

        }
    //CloseWamAdm();
    return;
}

void CAdmUtil::AppGetStatus(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];
    

    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("The Metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    OpenWamAdm(strComputer);
    if (SUCCEEDED(hresError)&& pIWamAdm!=0)
        {
        DWORD dwStatus;
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppGetStatus(wszMetabasePath, &dwStatus);
        if (FAILED(hresError))
            {
            Error(_T("GetStatus of application  %s failed"));
            }
        else
            {
            if (dwStatus == APPSTATUS_NOTDEFINED)
                {
                Print(_T("Application is not defined\n"));
                }
            else if (dwStatus == APPSTATUS_STOPPED)
                {
                Print(_T("Application is stopped\n"));
                }
            else if (dwStatus == APPSTATUS_RUNNING)
                {
                Print(_T("Application is running\n"));
                }
            else
                {
                Print(_T("Application is in unknown state\n"));
                }
            }                   
        }
    //CloseWamAdm();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\storedrv\ntff.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpmd\tables.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       tables.h

   Abstract:

        mapping tables to convert various info between text and binary

   Environment:

      Win32 User Mode

   Author: 
     
	  jaroslad  (jan 1997)

--*/

#if !defined (__JD_TABLES_H)
#define __JD_TABLES_H 


#include <afx.h>
#ifdef UNICODE
	#include <iadmw.h>
#else
	#include "ansimeta.h"
#endif

//constanst to be returned by functions that map name to code
//
#define NAME_NOT_FOUND 0xFFFFFFFE

BOOL IsNumber(const CString& name);



BOOL IsServiceName(const CString& name);


//**********************************************************************
// PROPERTY NAME TABLE DEFINITION
//**********************************************************************
struct tPropertyNameTable;
 
tPropertyNameTable gPropertyNameTable[];

struct tPropertyNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwDefAttributes; //default attributes (metadata compatible)
	DWORD dwDefUserType;   //default user type (metadata compatible)
	DWORD dwDefDataType;   //default data type (metadata compatible)
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static tPropertyNameTable * FindRecord(DWORD dwCode, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
	static tPropertyNameTable * FindRecord(const CString strName, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
	
	static DWORD MapNameToCode(const CString& strName, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
	static CString MapCodeToName(DWORD dwCode, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
};

DWORD MapPropertyNameToCode(const CString & strName);



//**********************************************************************
// VALUE TABLE DEFINITION
//**********************************************************************

struct tValueTable ;
tValueTable gValueTable[];

struct tValueTable 
{
	enum {TYPE_EXCLUSIVE=1};
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwRelatedPropertyCode; // code of the Property this value can be used for
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD  MapNameToCode(const CString& strName, DWORD dwRelatedPropertyCode, tValueTable * ValueTable=::gValueTable);
	static CString MapValueContentToString(DWORD dwValueContent, DWORD dwRelatedPropertyCode, tValueTable * ValueTable=::gValueTable);

};

DWORD  MapValueNameToCode(const CString & strName, DWORD dwRelatedPropertyCode);



//**********************************************************************
// COMMAND NAME TABLE DEFINITION 
//**********************************************************************

struct tCommandNameTable ;
tCommandNameTable gCommandNameTable[];

struct tCommandNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD  MapNameToCode(const CString& strName, tCommandNameTable * CommandNameTable=::gCommandNameTable);
};

DWORD MapCommandNameToCode(const CString & strName);

enum
{	CMD_SET=1,
	CMD_GET,
	CMD_COPY,
	CMD_DELETE,
	CMD_ENUM,
	CMD_ENUM_ALL,
	CMD_CREATE,
	CMD_RENAME,
	CMD_SCRIPT,
	CMD_SAVE,
	CMD_APPCREATEINPROC,
	CMD_APPCREATEOUTPROC,
	CMD_APPDELETE,
        CMD_APPRENAME,
	CMD_APPUNLOAD,
	CMD_APPGETSTATUS,
};

//**********************************************************************
// PROPERTY ATTRIB NAME TABLE DEFINITION
//**********************************************************************
struct tAttribNameTable ;
tAttribNameTable gAttribNameTable[];


struct tAttribNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD MapNameToCode(const CString& strName, tAttribNameTable * AttribNameTable=::gAttribNameTable);
};

DWORD MapAttribNameToCode(const CString & strName);


//**********************************************************************
// PROPERTY DATA TYPE NAME TABLE DEFINITION 
//**********************************************************************

struct tDataTypeNameTable ;
tDataTypeNameTable gDataTypeNameTable[];

struct tDataTypeNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD  MapNameToCode(const CString& strName, tDataTypeNameTable * DataTypeNameTable=::gDataTypeNameTable);
	static CString MapCodeToName(DWORD a_dwCode, tDataTypeNameTable * DataTypeNameTable=::gDataTypeNameTable);

};

DWORD MapDataTypeNameToCode(const CString & strName);

//**********************************************************************
// PROPERTY USER TYPE NAME TABLE DEFINITION AND IMPLEMENTATION
//**********************************************************************

struct tUserTypeNameTable ;
tUserTypeNameTable gUserTypeNameTable[];


struct tUserTypeNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD  MapNameToCode(const CString& strName, tUserTypeNameTable * UserTypeNameTable=::gUserTypeNameTable);
};

DWORD MapUserTypeNameToCode(const CString & strName);



void PrintTablesInfo(void);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpmd\jd_misc.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    jd_misc.cpp

Abstract:
	variety of assisting functions
	  - command line parameters parsing
	  - displaying the error messages
	  - creating the random file
          - creating the unique identifier based on thread and process
Author:

    jaroslad  

Revision History:
     06-01-96      ( Jaroslad ) Original.

--*/

#include <tchar.h>
#include "jd_misc.h"

#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>

int random (int low, int high)
{
	return ( low+((long)rand()*(long)high)/RAND_MAX );
}


/* Sample structure demonstating how to use comand line definition structure

  TParamDef CmdLineParam[]=
{
 {"c" ,1, &FtpServerIpAddr,TYPE_TCHAR,OPT, "ftp server computer name", "computer"},
 {"b", 0, &fStop,       TYPE_INT,  OPT, "binary flag"},
 {"start", 0, &fStart,     TYPE_INT,  OPT, "start service"},
 {"pause", 0, &fPause,     TYPE_INT,  OPT, "pause service"},
 {"s" ,1, &ServiceName,    TYPE_TCHAR, MAND,"service name","svc"},

 { {NULL,0, NULL ,         TYPE_TCHAR, OPT, "Place the description of the program here" };

*/

void DisplayUsage( _TCHAR **argv, TParamDef *tt)
{
	_tprintf(_T("Usage:\n\t%s "), argv[0]);
	for(int i=0; tt[i].sw!=0;i++)
	{
		if(tt[i].sw[0]==0) //default (do not need switch) parameters
		{
			_tprintf(_T("%s "),(tt[i].text_param!=NULL)?tt[i].text_param:_T("parm"));
		}
		else
		{
			_tprintf(_T("-%s "),tt[i].sw);
			if(tt[i].param_number==1)
				_tprintf(_T("[%s] "),(tt[i].text_param!=NULL)?tt[i].text_param:_T("parm"));
			else if(tt[i].param_number>1)
				_tprintf(_T("[[%s]...] "),(tt[i].text_param!=NULL)?tt[i].text_param:_T("parm"));
		}
	}

	_tprintf(_T("\n\n"));
	for(i=0; tt[i].sw!=0; i++)
	{
		if(tt[i].sw[0]==0) //default parameters
		{
			_tprintf(_T("\"no switch\"  %s\n"),tt[i].text_desc);
		}
		else if(tt[i].text_desc!=NULL)
		{
			_tprintf(_T("-%-6s %s\n"),tt[i].sw,tt[i].text_desc);
		}
	}
	//print description
	if( tt[i].text_desc!=NULL && tt[i].text_desc[0]!=0)
	{
		_tprintf(_T("\nDescription:\n"));
		_tprintf(_T("%s \n"), tt[i].text_desc);
	}
}

void DisplayUsageAndExit( _TCHAR **argv, TParamDef *tt)
{
	DisplayUsage( argv, tt);
	
	exit(1);
}

//structure that makes easy lexical parsing of the command line arguments

struct sParamLex
{
	int argc;
	TCHAR **argv;
	_TCHAR ParamBuffer[400];
	int iCurrentParamChar;  //character index within the current parameter being processed
	int iCurrentParam;      //index to the current parameter that is processed 
public:
	sParamLex(int argc,_TCHAR **argv):argc(argc),argv(argv){iCurrentParamChar=0; iCurrentParam=1;};
	BOOL IsNextSwitch();
	BOOL IsEnd();
	LPTSTR ReadNext();
};

BOOL sParamLex::IsNextSwitch()
{
	if(IsEnd())
		return FALSE;
	if (argv[iCurrentParam][iCurrentParamChar]==_T('-'))
		return TRUE;
	else
		return FALSE;
}

BOOL sParamLex::IsEnd()
{
	if(iCurrentParam>=argc)
		return TRUE;
	else
		return FALSE;
}

LPTSTR sParamLex::ReadNext()
{
	LPTSTR lpszRetval;
	if (IsEnd())
		return NULL;
	if(IsNextSwitch())
	{	int i=0;
		iCurrentParamChar++; //skip '/' or '-'
		while (argv[iCurrentParam][iCurrentParamChar]!=0 && argv[iCurrentParam][iCurrentParamChar]!=_T(':'))
			ParamBuffer[i++]=argv[iCurrentParam][iCurrentParamChar++];
		if(argv[iCurrentParam][iCurrentParamChar]==_T(':'))
			iCurrentParamChar++;
		if(argv[iCurrentParam][iCurrentParamChar]==0)
		{
			iCurrentParam++; iCurrentParamChar=0;
		}
		ParamBuffer[i]=0;
		lpszRetval=ParamBuffer;
	}
	else
	{
		lpszRetval=&argv[iCurrentParam][iCurrentParamChar];
		iCurrentParam++; iCurrentParamChar=0;
	}
	return lpszRetval;
}


void ParseParam(int argc, _TCHAR ** argv, TParamDef * tt)
{
	
	for(int i=0; tt[i].sw!=NULL ; i++)
	{
		tt[i].curr_param_read=0; //initialize 
	}
	
	sParamLex paramLex(argc,argv);
	
	BOOL fParseBegin=TRUE;
	while(!paramLex.IsEnd())
	{
		int k;
		if(paramLex.IsNextSwitch())
		{
			_TCHAR * sw = paramLex.ReadNext();
			/*find the switch in switch table*/ 
			for( k=0; tt[k].sw!=NULL ;k++)
			{ 
				if(tt[k].sw[0]==0) continue; //skip the default parameters
				if(_tcscmp(tt[k].sw, sw)==0 /*equal*/ )
					break;	
			}
			if(tt[k].sw == NULL) //switch not found
			{	_tprintf(_T("invalid switch \"%s\"\n"),sw);/*error*/
				DisplayUsageAndExit(argv,tt);
			}
		}
		else if( fParseBegin==TRUE && (_tcscmp(tt[0].sw, _T(""))==0 /*equal*/ ) )
		{ //default parameters (has to be the first record in arg description)
			k=0; 
		}
		else
		{
			_tprintf(_T("default arguments not expected\n"));/*error*/
			DisplayUsageAndExit(argv,tt);
		}
			
		
		if(tt[k].param_number==0) //switch without parameters
		{
			if(paramLex.IsEnd()==FALSE && paramLex.IsNextSwitch()==FALSE)
			{
				_tprintf(_T("switch \"%s\" takes no parameters \n"),tt[k].sw);
				DisplayUsageAndExit(argv,tt);
			}
			tt[k].curr_param_read++;
			*((int *)tt[k].ptr)=1;
		}
		else if(tt[k].param_number>0) //swith with more then 0ne parameter
		{
			if(paramLex.IsEnd()==TRUE || paramLex.IsNextSwitch()==TRUE)
			{  _tprintf(_T(" switch \"%s\" expects parameter\n"),tt[k].sw);//error
				DisplayUsageAndExit(argv,tt);
			}
			else
			{
				_TCHAR * prm;
			
				do
				{	
					prm=paramLex.ReadNext();
				
					if(tt[k].param_number <= tt[k].curr_param_read)
					{
						_tprintf(_T("number of parameters for switch -%s exceeds maximum allowed (%d)\n"),tt[k].sw,tt[k].param_number); 
						DisplayUsageAndExit(argv,tt);
					}		
					

					if(tt[k].ptr_type==TYPE_TCHAR || tt[k].ptr_type==TYPE_LPCTSTR)
						*(((_TCHAR **)tt[k].ptr) + tt[k].curr_param_read++)=prm;
					else if(tt[k].ptr_type==TYPE_INT ||tt[k].ptr_type==TYPE_WORD)
						*(((int *)tt[k].ptr) + tt[k].curr_param_read++)=_ttoi(prm);
					else if(tt[k].ptr_type==TYPE_LONG || tt[k].ptr_type==TYPE_DWORD)
						*(((long *)tt[k].ptr) + tt[k].curr_param_read++)=_ttol(prm);
					
				}while (paramLex.IsEnd()==FALSE && paramLex.IsNextSwitch()==FALSE);
		
			}
		}//end tt[k].param_number
		
	} // end while
	for(i=0; tt[i].sw!=0;i++) //check for mandatory switches
	{
		if (tt[i].opt_mand==MAND && tt[i].curr_param_read==0)
		{
			_tprintf(_T("mandatory switch -%s missing\n"),tt[i].sw);
			DisplayUsageAndExit(argv,tt);
		}

		if(tt[i].param_read!=NULL) // set number of params for switch
			*tt[i].param_read=tt[i].curr_param_read;

	}
}




/******************************************
  time_printf
*******************************************/


int time_printf(_TCHAR *format, ...)
{
   static CRITICAL_SECTION cs;
   static BOOL fInit=0;
   va_list marker;

   if(fInit==0)
   {
	   fInit=1;
	   InitializeCriticalSection(&cs);
   }

   _TCHAR buf[80]; 	
   
   EnterCriticalSection(&cs);
   va_start( marker, format );     /* Initialize variable arguments. */
   _tprintf(_TEXT("%s - "),_tstrtime(buf));
   _vtprintf(format,marker);
   LeaveCriticalSection(&cs);
   va_end( marker );              /* Reset variable arguments.      */
 //  printf("%s%s",bufa,bufb); //for multithreaded will be printed as one line
   return 1;
}

void error_printf(_TCHAR *format, ...)
{
   va_list marker;

   va_start( marker, format );     /* Initialize variable arguments. */
   _tprintf(_TEXT("Error: "));
   int x=_vftprintf(stderr,format,marker);
   va_end( marker );              /* Reset variable arguments.      */
   
}

void fatal_error_printf(_TCHAR *format, ...)
{
   va_list marker;
 
   va_start( marker, format );     /* Initialize variable arguments. */
   _tprintf(_TEXT("Error: "));
   int x=_vftprintf(stderr,format,marker);
   va_end( marker );              /* Reset variable arguments.      */
   exit(EXIT_FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpmd\admutil.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       admutil.cpp

   Abstract:

        IMSAdminBase interface WRAPPER functions definition

   Environment:

      Win32 User Mode

   Author:

          jaroslad  (jan 1997)

--*/


#if !defined (ADMUTIL_H)
#define ADMUTIL_H

#include <afx.h>
#ifdef UNICODE
	#include <iadmw.h>
#else
	#include "ansimeta.h"
#endif
#include <iwamreg.h>

class CAdmUtil;

//************************************************************************
//CAdmNode DEFINITION
//- store all the complex information about accessing MetaObject or MetaData


class CAdmNode
{
        CString strComputer; //computer to access
        CString strService;
        CString strInstance;
        CString strIPath; //path relative to instance
                                          //(/LM/{strService}/{strInstance}/{strIPath} gives the full path to MEtaObject
        CString strProperty; // name of the MetaData within given Path


        static INT              GetSlashIndex(const CString& strPath, INT iSeqNumber);
        static INT              GetCountOfSlashes(const CString& strPath);
        static CString  GetPartOfPath(const CString& strPath, INT iStart, INT iEnd=-1);

public:
        CAdmNode(const CString& a_strPath=CString("")) {SetPath(a_strPath);};
        void SetPath(CString a_strPath);

        //magic functions to provide various kinds of paths within metabase
        CString GetLMRootPath(void);
        CString GetLMServicePath(void);
        CString GetLMInstancePath(void);
        CString GetLMNodePath(void);
        CString GetServicePath(void);
        CString GetInstancePath(void);
        CString GetNodePath(void);
        CString GetRelPathFromService(void);
        CString GetRelPathFromInstance(void);

        CString GetParentNodePath(void);
        CString GetCurrentNodeName(void);

        //access to METADATA_RECORD items
        CString GetComputer(void)  {return strComputer;};
        CString GetService(void)  {return strService;};
        CString GetInstance(void)  {return strInstance;};
        CString GetIPath(void)  {return strIPath;};
        CString GetProperty(void)  {return strProperty;};

        //setting the METADATA_RECORD items
        void SetComputer(const CString& a_strComputer)  {strComputer=a_strComputer;};
        void SetService(const CString& a_strService)    {strService=a_strService;};
        void SetInstance(const CString& a_strInstance)  {strInstance=a_strInstance;};
        void SetIPath(const CString& a_strIPath)        {strIPath=a_strIPath;};
        void SetProperty(const CString& a_strProperty)  {strProperty=a_strProperty;};


        friend CAdmUtil;
};


//************************************************************************
//CAdmProp DEFINITION
//
// -convenience wrapper for METADATA_RECORD


class CAdmProp
{
        enum {USERTYPESET=0x01,DATATYPESET=0x02,ATTRIBSET=0x04}; //value indicates that the variable was not set
                                                           //0 cannot be used, because that is valid value
        METADATA_RECORD mdr;
        DWORD dwFlags;

public:
        CAdmProp(){dwFlags=0;mdr.dwMDIdentifier=0; mdr.dwMDAttributes=0; mdr.dwMDUserType=0;
                                        mdr.dwMDDataType=0;mdr.pbMDData=0; mdr.dwMDDataLen=0;};
        CAdmProp(METADATA_RECORD &a_mdr);
	CAdmProp(const CString &a_strProperty);
        void SetIdentifier(DWORD a_dwIdentif) {mdr.dwMDIdentifier=a_dwIdentif;};
        void SetAttrib(DWORD a_dwAttrib) {mdr.dwMDAttributes=a_dwAttrib;dwFlags|=ATTRIBSET;};
        void SetUserType(DWORD a_dwUserType) {mdr.dwMDUserType=a_dwUserType;dwFlags|=USERTYPESET;};
        void SetDataType(DWORD a_dwDataType) {mdr.dwMDDataType=a_dwDataType;dwFlags|=DATATYPESET;};

        BOOL IsSetAttrib(void)
                { return (((dwFlags&ATTRIBSET)!=0)?TRUE:FALSE); };
        BOOL IsSetUserType(void)
                {return (((dwFlags&USERTYPESET)!=0)?TRUE:FALSE); };
        BOOL IsSetDataType(void)
                {return (((dwFlags&DATATYPESET)!=0)?TRUE:FALSE); };


        DWORD GetAttrib(void) {return mdr.dwMDAttributes;};
        DWORD GetDataType(void) {return mdr.dwMDDataType;};
        DWORD GetUserType(void) {return mdr.dwMDUserType;};
        DWORD GetIdentifier(void) {return mdr.dwMDIdentifier;};
        PBYTE GetMDData(void) {return mdr.pbMDData;};
        DWORD GetMDDataLen(void) {return mdr.dwMDDataLen;};

        void SetValue(DWORD a_dwValue);
        void SetValue(CString a_strValue);
        void SetValue(LPCTSTR *a_lplpszValue, DWORD a_dwValueCount); //for multisz
        void SetValue(LPBYTE pbValue, DWORD dwValueLength ); //for binary
        BOOL SetValueByDataType(LPCTSTR *a_lplpszPropValue,DWORD* a_lpdwPropValueLength,WORD a_wPropValueCount);

        void PrintProperty(void);


        virtual void Print(const _TCHAR *format,...);


        friend CAdmUtil;
};

//************************************************************************
//CAdmUtil DEFINITION
//
//-convenience wrapper for calling IMSAdminBase interface functions

//defined in admutil.cpp
extern DWORD g_dwTIMEOUT_VALUE;
extern DWORD g_dwDELAY_AFTER_OPEN_VALUE;


class CAdmUtil
{
        static enum {
                DEFAULTBufferSize=4
        };

#ifdef UNICODE
        IMSAdminBase * pcAdmCom;   //interface pointer to Metabase Admin
#else
		ANSI_smallIMSAdminBase * pcAdmCom;   //interface pointer to Metabase Admin Ansi Wrapper
#endif
		IWamAdmin*	pIWamAdm; //interface pointer to Wam Admin

		METADATA_HANDLE m_hmd;    //metabase handle that micht be reused for sequence of commands
		CString m_strNodePath;    //related to m_hmd - if h_hmd!=NULL it points to m_strNodePath
		DWORD m_dwPermissionOfhmd; //related to m_hmd  

        PBYTE pbDataBuffer;   //buffer to get data from METABASE (used for METADATA_RECORD)
        WORD wDataBufferSize; //size of the above buffer
protected:
        BOOL fPrint ; //print Error messages
        HRESULT hresError;    //store the last HRESULT of calling interface IMSAdminBase interface function
                                                  // this is used to store some other error as is OUT_OF_MEMORY or INVALID_PARAMETER



        //with wIndex it is possible to open more than one METADATA object, opening multiple object is not available outside the class
        void OpenObject(WORD wIndex, LPCSTR lpszService,WORD wInstance, LPCSTR lpszPath, DWORD dwPermission=METADATA_PERMISSION_WRITE+METADATA_PERMISSION_READ, BOOL fCreate=TRUE);
        void CloseObject(WORD wIndex);

        METADATA_HANDLE OpenObjectTo_hmd(CAdmNode & a_AdmNode,
                        DWORD dwPermission=METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE,
                        BOOL fCreate=FALSE);
		void CloseObject_hmd(void);
      
public:
        CAdmUtil(const CString & strComputer=CString(""));
        ~CAdmUtil();
#ifdef UNICODE
		IMSAdminBase * GetpcAdmCom(void) {return pcAdmCom;}; 
#else
		IMSAdminBase * GetpcAdmCom(void) {return (pcAdmCom==0)?0:pcAdmCom->m_pcAdmCom;}; 
#endif

        //connect to computer, call class factory for IMSAdminBase
        void Open(const CString & strComputer);
        //close connection to computer, throw away IMSAdminBase
        void Close(void);


        //OPEN , CLOSE, CREATE, DELETE, COPY METAOBJECT
        METADATA_HANDLE OpenObject(CAdmNode & a_AdmNode,
                                                DWORD dwPermission=METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE,
                                                BOOL fCreate=FALSE);
        void CloseObject(METADATA_HANDLE hmd);
        void CreateObject(CAdmNode & a_AdmNode);
        void DeleteObject(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp);
        void DeleteObject(METADATA_HANDLE a_hmd, CString& a_strNodeNameToDelete);
        void CopyObject(CAdmNode&       a_AdmNode,  CAdmNode&   a_AdmNodeDst);
        void RenameObject(CAdmNode&     a_AdmNode,  CAdmNode&   a_AdmNodeDst);

        void GetProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp);

        void SetProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp);
        void SetProperty(PMETADATA_RECORD a_pmdrData, METADATA_HANDLE a_hmd);

        void DeleteProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp);
        void DeleteProperty(PMETADATA_RECORD a_pmdrData, METADATA_HANDLE a_hmd);

        //ENUMERATE
        void EnumPropertiesAndPrint(CAdmNode& a_AdmNode,
                                                                          CAdmProp a_AdmProp,
                                                                          BYTE bRecurLevel=0,
                                                                          METADATA_HANDLE a_hmd=0,
                                                                          CString & a_strRelPath=CString(""));
        void EnumAndPrint(CAdmNode&     a_AdmNode,
                                                        CAdmProp&       a_AdmProp,
                                                        BOOL            a_fRecursive=FALSE,
                                                        BYTE            a_bRecurLevel=0,
                                                        METADATA_HANDLE a_hmd=0,
                                                        CString&        a_strRelPath=CString(""));
        //SAVE METABASE DATA
        void SaveData(void);

        //FUNCTION TO RUN CHOSEN METABASE COMMAND WITH GIVEN PARAMATERS
        void Run(CString& strCommand,  //command to run
                         CAdmNode& a_AdmNode,        //PATH TO METABASE OBJECT
                         CAdmProp& a_AdmProp,        //METADATA object
                         CAdmNode& a_AdmDstNode=CAdmNode(""), //DESTINATION PATH (as used for COPY)
                         LPCTSTR *a_lplpszPropValue=0,   //VALUES TO BE STORED (for SET command)
                         DWORD *a_lpdwPropValueLength=0,        //LENGTH OF VALUES TO BE STORED (for SET command)
                         WORD wPropValueCount=0);       //NUMBER OF VALUES TO BE STORED

        //virtual functions for Error and regular messages to be printed.
        // these can be redefined in order to fit custom needs
        virtual void Error(const _TCHAR * format,...);
        virtual void Print(const _TCHAR * format,...);

        //Disable and enable to print error or regular messages
        void EnablePrint(void) {fPrint=TRUE;};
        void DisablePrint(void) {fPrint=FALSE;};

        HRESULT QueryLastHresError(void) {return hresError;};
        void SetLastHresError(HRESULT hr) {hresError=hr;};

	//defined in vptool
	void OpenWamAdm(const CString & strComputer);
	void CloseWamAdm(void);
	void AppCreateInProc(const _TCHAR* szPath,const CString & strComputer);
	void AppCreateOutProc(const _TCHAR* szPath,const CString & strComputer);
	void AppDelete(const _TCHAR* szPath,const CString & strComputer);
        void AppRename(CAdmNode& a_AdmNode, CAdmNode& a_AdmDstNode, const CString & strComputer);
	void AppUnLoad(const _TCHAR* szPath,const CString & strComputer);
	void AppGetStatus(const _TCHAR* szPath,const CString & strComputer);

};


//runs administration command based on given parameters



LPTSTR ConvertHresToString(HRESULT hRes);
DWORD ConvertHresToDword(HRESULT hRes);
LPTSTR ConvertReturnCodeToString(DWORD ReturnCode);

CString FindCommonPath(CString a_strPath1,CString a_strPath2);

#define M_LOCAL_MACHINE "/LM/"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\smtpmd\tables.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       tables.cpp

   Abstract:

        mapping tables to convert various info between text and binary

   Environment:

      Win32 User Mode

   Author:

      jaroslad  (jan 1997)

--*/


#include "tables.h"

#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include <iiscnfgp.h>  //get MD_* constants
#include "smtpinet.h"
//#include "pop3s.h"
//#include "imaps.h"


BOOL IsNumber(const CString & name)
{
    for(INT i=0;i<name.GetLength();i++)
    {
        if (name[i]<_T('0') || name[i]>_T('9'))
            return FALSE;
    }
    return TRUE;
}



BOOL IsServiceName(const CString& name)
{
    BOOL fRetval=FALSE;

    if(name.CompareNoCase(_T("W3SVC"))==0 || name.CompareNoCase(_T("MSFTPSVC"))==0 ||
    name.CompareNoCase(_T("NNTPSVC"))==0 || name.CompareNoCase(_T("SMTPSVC"))==0)
    {
        fRetval=TRUE;
    }
    return fRetval;
}





//**********************************************************************
// COMMAND NAME TABLE IMPLEMENTATION
//**********************************************************************


//constants defined in tables.h
struct tCommandNameTable gCommandNameTable[]=
{
    {CMD_SET, _T("SET")},
    {CMD_GET, _T("GET")},
    {CMD_GET, _T("G")},
    {CMD_COPY, _T("COPY")},
    {CMD_DELETE, _T("DELETE")},
    {CMD_DELETE, _T("DEL")},
    {CMD_ENUM, _T("ENUM")},
    {CMD_ENUM, _T("E")},
    {CMD_ENUM_ALL,_T("ENUM_ALL")},
    {CMD_CREATE, _T("CREATE")},
    {CMD_RENAME, _T("RENAME")},
    {CMD_SCRIPT, _T("SCRIPT")},
    {CMD_SAVE, _T("SAVE")},
    {CMD_APPCREATEINPROC, _T("APPCREATEINPROC")},
    {CMD_APPCREATEOUTPROC, _T("APPCREATEOUTPROC")},
    {CMD_APPDELETE, _T("APPDELETE")},
    {CMD_APPUNLOAD, _T("APPUNLOAD")},
    {CMD_APPGETSTATUS, _T("APPGETSTATUS")},

    //the end
    {0,0}

};

DWORD MapCommandNameToCode(const CString & strName)
{
    return tCommandNameTable::MapNameToCode(strName);
}


DWORD tCommandNameTable::MapNameToCode(const CString & strName, tCommandNameTable * CommandNameTable)
{
    for(int i=0; CommandNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(CommandNameTable[i].lpszName)==0)
            return CommandNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}

#if 0
CString tCommandNameTable::MapCodeToName(DWORD dwCode, tCommandNameTable * CommandNameTable)
{
    for(int i=0; CommandNameTable[i].lpszName!=0;i++)
    {
        if(dwCode==CommandNameTable[i].dwCode)
            return CommandNameTable[i].dwName;
    }
    return 0;
}
#endif



//**********************************************************************
// PROPERTY NAME TABLE IMPLEMENTATION
//**********************************************************************

#define MD_USE_HOST_NAME             (IIS_MD_HTTP_BASE+66 )
#define MD_NET_LOGON_WKS             (IIS_MD_HTTP_BASE+65 )

tPropertyNameTable  gPropertyNameTable[]=
{
//  These are global to all services and should only be set at
//  the IIS root
    {MD_MAX_BANDWIDTH                ,_T("MaxBandwidth"),           METADATA_NO_ATTRIBUTES, /*SHOULD BE GLOBAL*/IIS_MD_UT_SERVER,       DWORD_METADATA},
    {MD_KEY_TYPE                     ,_T("KeyType"),        METADATA_NO_ATTRIBUTES, /*SHOULD BE GLOBAL*/IIS_MD_UT_SERVER,       STRING_METADATA},
//  These properties are applicable to both HTTP and FTP virtual
//  servers
    {MD_CONNECTION_TIMEOUT           ,_T("ConnectionTimeout"),      METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_MAX_CONNECTIONS              ,_T("MaxConnections"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_COMMENT               ,_T("ServerComment"),          METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   STRING_METADATA},
    {MD_SERVER_STATE                 ,_T("ServerState"),            METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_COMMAND               ,_T("ServerCommand"),          METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_AUTOSTART             ,_T("ServerAutostart"),        METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_CLUSTER_SERVER_COMMAND       ,_T("ClusterServerCommand"),   METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_CLUSTER_ENABLED              ,_T("ClusterEnabled"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_SIZE                  ,_T("ServerSize"),             METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_LISTEN_BACKLOG        ,_T("ServerListenBacklog"),    METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_LISTEN_TIMEOUT        ,_T("ServerListenTimeout"),    METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_DOWNLEVEL_ADMIN_INSTANCE     ,_T("DownlevelAdminInstance"), METADATA_INHERIT      , IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_BINDINGS              ,_T("ServerBindings"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   MULTISZ_METADATA},
    { MD_SERVER_CONFIGURATION_INFO    ,   _T("ServerConfigurationInfo"),METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},

    //internals
    {MD_SERVER_PLATFORM              ,_T("ServerPlatform"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_VERSION_MAJOR         ,_T("MajorVersion"),           METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_VERSION_MINOR         ,_T("MinorVersion"),           METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SERVER_CAPABILITIES          ,_T("Capabilities"),           METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},

//  These properties are specific to HTTP and belong to the virtual
//  server
//    {MD_SECURE_PORT                  ,_T("SecurePort"),             METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {MD_SECURE_BINDINGS              ,_T("SecureBindings"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   MULTISZ_METADATA},
    {MD_NTAUTHENTICATION_PROVIDERS   ,_T("NTAuthenticationProviders"),  METADATA_INHERIT,       IIS_MD_UT_SERVER,/*??*/STRING_METADATA},
    {MD_SCRIPT_TIMEOUT               ,_T("ScriptTimeout"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_CACHE_EXTENSIONS             ,_T("CacheExtensions"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,/*??*/DWORD_METADATA},
    {MD_CREATE_PROCESS_AS_USER       ,_T("CreateProcessAsUser"),        METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_CREATE_PROC_NEW_CONSOLE      ,_T("CreateProcNewConsole"),   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_POOL_IDC_TIMEOUT             ,_T("PoolIDCTimeout"),         METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_ALLOW_KEEPALIVES             ,_T("AllowKeepAlives"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_FILTER_LOAD_ORDER            ,_T("FilterLoadOrder"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,/*??*/STRING_METADATA},
    {MD_FILTER_IMAGE_PATH            ,_T("FilterImagePath"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_FILTER_STATE                 ,_T("FilterState"),                METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_FILTER_ENABLED                   ,_T("FilterEnabled"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_FILTER_FLAGS                     ,_T("FilterFlags"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_FILTER_DESCRIPTION               ,_T("FilterDescription"),        METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},

    { MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS, _T("AllowPathInfoForScriptMappings"), METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA },
    { MD_AUTH_CHANGE_URL                 ,_T("AuthChangeUrl"),  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_AUTH_EXPIRED_URL, _T("AuthExpiredUrl"),     METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_AUTH_NOTIFY_PWD_EXP_URL, _T("NotifyPwdExpUrl"), METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_AUTH_EXPIRED_UNSECUREURL, _T("AuthExpiredUnsecureUrl"),     METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL, _T("NotifyPwdExpUnsecureUrl"), METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_ADV_NOTIFY_PWD_EXP_IN_DAYS, _T("NotifyPwdExpInDays"),   METADATA_INHERIT,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_AUTH_CHANGE_FLAGS, _T("AuthChangeFlags"),   METADATA_INHERIT,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_ADV_CACHE_TTL, _T("AdvCacheTTL"),   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_NET_LOGON_WKS, _T("NetLogonWks"),METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_USE_HOST_NAME, _T("UseHostName"),METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
#if defined(CAL_ENABLED)
    #define MD_CAL_VC_PER_CONNECT        (IIS_MD_HTTP_BASE+130)
    #define MD_CAL_AUTH_RESERVE_TIMEOUT  (IIS_MD_HTTP_BASE+131)
    #define MD_CAL_SSL_RESERVE_TIMEOUT   (IIS_MD_HTTP_BASE+132)
    #define MD_CAL_W3_ERROR              (IIS_MD_HTTP_BASE+133)

    {MD_CAL_VC_PER_CONNECT, "CalVcPerConnect",METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_CAL_AUTH_RESERVE_TIMEOUT, "CalAuthReserveTimeout",METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_CAL_SSL_RESERVE_TIMEOUT, "CalSslReserveTimeout",METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_CAL_W3_ERROR, "CalW3Error",METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
#endif
    { MD_IN_PROCESS_ISAPI_APPS        , _T("InProcessIsapiApps") ,METADATA_INHERIT, IIS_MD_UT_SERVER, MULTISZ_METADATA},
    { MD_CUSTOM_ERROR_DESC            , _T("CustomErrorDesc")    ,METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, MULTISZ_METADATA},

    {MD_MAPCERT                      ,_T("MapCert"),                    METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {MD_MAPNTACCT                    ,_T("MaPNTAccT"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {MD_MAPNAME                      ,_T("MapName"),                    METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {MD_MAPENABLED                   ,_T("MapEnabled"),                 METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {MD_MAPREALM                     ,_T("MapRealm"),                   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {MD_MAPPWD                       ,_T("MapPwd"),                     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {MD_ITACCT                       ,_T("ITACCT"),                     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {MD_CPP_CERT11                   ,_T("CppCert11"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {MD_SERIAL_CERT11                ,_T("SerialCert11"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {MD_CPP_CERTW                    ,_T("CppCertw"),                   METADATA_SECURE,IIS_MD_UT_SERVER, BINARY_METADATA},
    {MD_SERIAL_CERTW                 ,_T("SerialCertw"),                METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {MD_CPP_DIGEST                   ,_T("CppDigest"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {MD_SERIAL_DIGEST                ,_T("SerialDigest"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {MD_CPP_ITA                      ,_T("CppIta"),                 METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {MD_SERIAL_ITA                   ,_T("SerialIta"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
// Virtual root properties - note MD_ACCESS_PERM is also generally set at
// the virtual directory.  These are used for both HTTP and FTP
    {MD_VR_PATH                   ,_T("VrPath"),                    METADATA_INHERIT,IIS_MD_UT_FILE,STRING_METADATA},
    {MD_VR_USERNAME               ,_T("VrUsername"),                METADATA_INHERIT,IIS_MD_UT_FILE,STRING_METADATA},
    {MD_VR_PASSWORD               ,_T("VrPassword") ,           METADATA_INHERIT|METADATA_SECURE,IIS_MD_UT_FILE,     STRING_METADATA},
    {MD_VR_ACL                    ,_T("VrAcl"),                 METADATA_INHERIT,IIS_MD_UT_FILE,BINARY_METADATA},
// This is used to flag down updated vr entries - Used for migrating vroots
    {MD_VR_UPDATE                    ,_T("VrUpdate"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_FILE,DWORD_METADATA},
//  Logging related attributes
    {MD_LOG_TYPE                      ,_T("LogType"),                   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGFILE_DIRECTORY            ,_T("LogFileDirectory"),           METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGFILE_PERIOD               ,_T("LogFilePeriod"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGFILE_TRUNCATE_SIZE        ,_T("LogFileTruncateSize"),        METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGSQL_DATA_SOURCES          ,_T("LogSqlDataSources"),          METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGSQL_TABLE_NAME            ,_T("LogSqlTableName"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGSQL_USER_NAME             ,_T("LogSqlUserName"),             METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGSQL_PASSWORD              ,_T("LogSqlPassword"),             METADATA_SECURE,IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_LOGEXT_FIELD_MASK               ,_T("ExtLogFieldMask"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGEXT_FIELD_MASK2              ,_T("ExtLogFieldMask2"),           METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOG_PLUGIN_ORDER                ,_T("LogPluginOrder"),             METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
//  These are FTP specific properties
    {MD_EXIT_MESSAGE                 ,_T("ExitMessage"),                METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_GREETING_MESSAGE             ,_T("GreetingMessage"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,/*!!*/MULTISZ_METADATA},
    {MD_MAX_CLIENTS_MESSAGE          ,_T("MaxClientsMessage"),      METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_MSDOS_DIR_OUTPUT             ,_T("MSDOSDirOutput"),         METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_ALLOW_ANONYMOUS              ,_T("AllowAnonymous"),         METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_ANONYMOUS_ONLY               ,_T("AnonymousOnly"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOG_ANONYMOUS                ,_T("LogAnonymous"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOG_NONANONYMOUS             ,_T("LogNonAnonymous"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
//  These are SSL specific properties
    {MD_SSL_PUBLIC_KEY               ,_T("SslPublicKey"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,BINARY_METADATA},
    {MD_SSL_PRIVATE_KEY              ,_T("SslPrivateKey"),          METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,BINARY_METADATA},
    {MD_SSL_KEY_PASSWORD             ,_T("SslKeyPassword"),         METADATA_SECURE,IIS_MD_UT_SERVER,BINARY_METADATA},
//  File and Directory related properties - these should be added in the
//  metabase with a user type of IIS_MD_UT_FILE
    {MD_AUTHORIZATION                ,_T("Authorization"),              METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_AUTHORIZATION_PERSISTENCE    ,_T("AuthorizationPersistence"),   METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_REALM                        ,_T("Realm"),                      METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {MD_HTTP_EXPIRES                 ,_T("HttpExpires"),                METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {MD_HTTP_PICS                    ,_T("HtpPics"),                    METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {MD_HTTP_CUSTOM                  ,_T("HttpCustom"),             METADATA_INHERIT,   IIS_MD_UT_FILE,MULTISZ_METADATA},
    {MD_DIRECTORY_BROWSING           ,_T("DirectoryBrowsing"),          METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_DEFAULT_LOAD_FILE            ,_T("DefaultLoadFile"),            METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {MD_CONTENT_NEGOTIATION          ,    _T("ContentNegotiation"),     METADATA_INHERIT    ,IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_CUSTOM_ERROR                 ,_T("CustomError"),                METADATA_INHERIT,   IIS_MD_UT_FILE,MULTISZ_METADATA},
    {MD_FOOTER_DOCUMENT              ,_T("FooterDocument"),         METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {MD_FOOTER_ENABLED               ,_T("FooterEnabled"),              METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_HTTP_REDIRECT                    ,_T("HttpRedirect"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_FILE,STRING_METADATA},
    {MD_DEFAULT_LOGON_DOMAIN         ,_T("DefaultLogonDomain"), METADATA_INHERIT,      IIS_MD_UT_FILE,STRING_METADATA},
    {MD_LOGON_METHOD                 ,_T("LogonMethod"),            METADATA_INHERIT,      IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_SCRIPT_MAPS                     ,_T("ScriptMaps"),              METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA},
    {MD_SCRIPT_TIMEOUT                     ,_T("ScriptTimeout"),        METADATA_INHERIT,IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_MIME_MAP                     ,_T("MimeMap"),                    METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA},
    {MD_ACCESS_PERM                  ,_T("AccessPerm"),             METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_SSL_ACCESS_PERM          ,_T("SslAccessPerm"),             METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_IP_SEC                       ,_T("IpSec")   ,                   METADATA_INHERIT,IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_ANONYMOUS_USER_NAME          ,_T("AnonymousUserName"),      METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {MD_ANONYMOUS_PWD                ,_T("AnonymousPwd"),               METADATA_INHERIT|METADATA_SECURE,IIS_MD_UT_FILE,STRING_METADATA},
    {MD_ANONYMOUS_USE_SUBAUTH        ,_T("AnonymousUseSubAuth"),        METADATA_INHERIT,IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_DONT_LOG                     ,_T("DontLOG"),                    METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_ADMIN_ACL                    ,_T("AdminAcl"),                   METADATA_INHERIT,   IIS_MD_UT_FILE,BINARY_METADATA},
    {MD_SSI_EXEC_DISABLED                ,_T("SSIExecDisabled"),            METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_DO_REVERSE_DNS                   ,_T("DoReverseDns"),               METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_WIN32_ERROR                  ,_T("Win32Error"),            0,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_ALLOW_REPLACE_ON_RENAME          ,_T("AllowReplaceOnRename"),       METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA},
    {MD_CC_NO_CACHE                  ,_T("CacheControlNoCache"),             METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_CC_MAX_AGE                  ,_T("CacheControlMaxAge"),             METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_CC_OTHER                  ,_T("CacheControlOther"),             METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
// ASP and WAM params
    {MD_ASP_BUFFERINGON                  ,_T("CacheControlOther"),  METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    { MD_ASP_BUFFERINGON                  , _T("AspBufferingOn"),       METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_LOGERRORREQUESTS             , _T("AspLogErrorRequests"),  METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
    { MD_ASP_SCRIPTERRORSSENTTOBROWSER    , _T("AspScriptErrorSentToBrowser"),METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_SCRIPTERRORMESSAGE           , _T("AspScriptErrorMessage"),METADATA_INHERIT, ASP_MD_UT_APP, STRING_METADATA},
    { MD_ASP_SCRIPTFILECACHESIZE          , _T("AspScriptFileCacheSize"),METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
    { MD_ASP_SCRIPTENGINECACHEMAX         , _T("AspScriptEngineCacheMax"),METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
    { MD_ASP_SCRIPTTIMEOUT                , _T("AspScriptTimeout"),     METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_SESSIONTIMEOUT               , _T("AspSessionTimeout"),    METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_ENABLEPARENTPATHS            , _T("AspEnableParentPaths"), METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_MEMFREEFACTOR                , _T("AspMemFreeFactor"),     METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
    { MD_ASP_MINUSEDBLOCKS                , _T("AspMinUseDblocks"),     METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
    { MD_ASP_ALLOWSESSIONSTATE            , _T("AspAllowSessionState"), METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_SCRIPTLANGUAGE               , _T("AspScriptLanguage")     ,METADATA_INHERIT, ASP_MD_UT_APP, STRING_METADATA},
    { MD_ASP_ALLOWOUTOFPROCCMPNTS         , _T("AspAllowOutOfProcCmpnts"),METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_EXCEPTIONCATCHENABLE         , _T("AspExceptionCatchEnable"),METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_CODEPAGE                     , _T("AspCodepage")           ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_SCRIPTLANGUAGELIST           , _T("AspScriptLanguages")    ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_ENABLESERVERDEBUG            , _T("AspEnableServerDebug")  ,METADATA_INHERIT,ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_ENABLECLIENTDEBUG            , _T("AspEnableClientDebug")  ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
    { MD_ASP_TRACKTHREADINGMODEL          , _T("AspTrackThreadingModel") ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
// WAM params
    { MD_APP_ROOT                     , _T("AppRoot"),      METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA},
    { MD_APP_ISOLATED                 , _T("AppIsolated"),  METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
    { MD_APP_WAM_CLSID                , _T("AppWamClsid"),  METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA},
    { MD_APP_PACKAGE_ID               , _T("AppPackageId"), METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA},
    { MD_APP_PACKAGE_NAME             , _T("ApPackageName"),METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA},
    { MD_APP_LAST_OUTPROC_PID         , _T("AppLastOutprocId"), METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
// SMTP parameters
    {MD_COMMAND_LOG_MASK,   _T("CmdLogMask"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_FLUSH_MAIL_FILE,    _T("FlushMailFiles"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_BATCH_MSG_LIMIT,    _T("BatchMsgLimit"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_MAIL_OBJECTS,   _T("MaxMailObjects"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_ROUTING_THREADS,    _T("RoutingThreads"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAIL_QUEUE_DIR, _T("MailQueueDir"),     METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SHOULD_PICKUP_MAIL, _T("ShouldPickUpMail"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_DIR_BUFFERS,    _T("MaxDirectoryBuffers"),  METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_DIR_CHANGE_IO_SIZE,_T("DirectoryBuffSize"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_DIR_PENDING_IOS,_T("NumDirPendingIos"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAIL_PICKUP_DIR,    _T("MailPickupDir"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SHOULD_DELIVER, _T("ShouldDeliver"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAIL_DROP_DIR,  _T("MailDropDir"),      METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_ROUTING_DLL,    _T("RoutingDll"),       METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_REVERSE_NAME_LOOKUP,_T("EnableReverseLookup"),  METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_NAME_RESOLUTION_TYPE,_T("NameResolution"),      METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_HOP_COUNT,      _T("MaxHopCount"),      METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_SMTP_ERRORS,    _T("MaxErrors"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_MSG_SIZE,   _T("MaxMsgSize"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_MSG_SIZE_B4_CLOSE,_T("MaxMsgSizeBeforeClose"),  METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_OUTBOUND_TIMEOUT,   _T("MaxOutTimeout"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_OUTBOUND_CONNECTION,_T("MaxOutConnections"),    METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_RECIPIENTS, _T("MaxRcpts"),         METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_LOCAL_RETRY_ATTEMPTS,_T("MaxRetryAttempts"),    METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_LOCAL_RETRY_MINUTES ,_T("MaxRetryMinutes"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_REMOTE_RETRY_ATTEMPTS,_T("MaxRemoteRetryAttempts"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_REMOTE_RETRY_MINUTES,_T("MaxRemoteRetryMinutes"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SHARE_RETRY_MINUTES,_T("MaxShareRetryMinutes"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SHOULD_PIPELINE_OUT,_T("PipelineInput"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SHOULD_PIPELINE_IN, _T("PipelineOutput"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMARTHOST_TYPE, _T("SmartHostUseType"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMARTHOST_NAME, _T("SmartHost"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_CONNECT_RESPONSE,   _T("ConnectResponse"),      METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_DEFAULT_DOMAIN_VALUE,_T("DefaultDomain"),       METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_BAD_MAIL_DIR,   _T("BadMailDir"),       METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_ROUTING_SOURCES,    _T("OldRoutingSources"),       METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA},
    {MD_SMTP_DS_HOST,       _T("Host"),     METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_NAMING_CONTEXT,     _T("NamingContext"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_ACCOUNT,        _T("Account"),      METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_PASSWORD,       _T("Password"),     METADATA_SECURE, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_DATA_DIRECTORY,     _T("DataDirectory"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_DEFAULT_MAIL_ROOT,      _T("DefaultMailRoot"),      METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_BIND_TYPE,      _T("BindType"),     METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_SCHEMA_TYPE,        _T("SchemaType"),       METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_TYPE,        _T("DSType"),       METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
//    {MD_REMOTE_HANG_TIME,   _T("RemoteHangTime"),       METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA},
    {MD_MASQUERADE_NAME,    _T("MasqueradeName"),       METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_DO_MASQUERADE,  _T("ShouldMasquerade"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_REMOTE_SMTP_PORT,   _T("RemoteSMTPPort"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SSLPORT,        _T("SSLPort"),          METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_POSTMASTER_EMAIL,   _T("AdminEmail"),       METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_POSTMASTER_NAME,    _T("AdminName"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_ETRN_DAYS,      _T("ETRNDays"),         METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_LOCAL_DOMAINS,  _T("LocalDomains"),     METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA},
    {MD_DOMAIN_ROUTING, _T("DomainRouting"),        METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA},
    {MD_REMOTE_TIMEOUT, _T("RemoteTimeout"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SEND_NDR_TO,    _T("SendNDRTo"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SEND_BAD_TO,    _T("SendBADTo"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_ALWAYS_USE_SSL, _T("AlwaysUseSSL"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_REMOTE_SECURE_PORT, _T("RemoteSecurePort"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_OUT_CONN_PER_DOMAIN,_T("MaxOutConPerDomain"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_LIMIT_REMOTE_CONNECTIONS,_T("LimitRemoteConnections"),METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_REMOTE_SECURE_PORT, _T("RemoteSecurePort"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SORT_TEMP_DIR,  _T("MailSortTmpDir"),       METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_SERVICE_VERSION,_T("ServiceVersion"),      METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SMTP_EXTENSION_DLLS,_T("ExtensionDlls"),        METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA},
//    {MD_SMTP_NUM_RESOLVER_SOCKETS,_T("NumResolverSockets"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SMTP_USE_MX_RESOLVER,_T("UseMxResolver"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_FQDN_VALUE,     _T("FQDNValue"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_UPDATED_FQDN,   _T("UpdatedFQDN"),      METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_UPDATED_DEFAULT_DOMAIN,_T("UpdatedDefDomain"),  METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_ETRN_SUBDOMAINS,    _T("ETRNSubdomains"),       METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA},
//    {MD_MAX_POOL_THREADS,   _T("MaxPoolThreads"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SASL_LOGON_DOMAIN,  _T("SASLLogonDom"),     METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
//    {MD_SERVER_SS_AUTH_MAPPING, _T("SSAuthMapping"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_CLEARTEXT_AUTH_PROVIDER,   _T("CTAProvider"),      METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
//    {MD_ALWAYS_USE_SASL,    _T("AlwaysUseSASL"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SMTP_AUTHORIZATION, _T("SMTPAuth"),     METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_MAX_SMTP_AUTHLOGON_ERRORS,  _T("AuthLogonErrors"),      METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_ROUTE_ACTION,   _T("RouteAction"),      METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_ROUTE_ACTION_TYPE,  _T("RouteActionType"),      METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_ROUTE_USER_NAME,    _T("RouteUserName"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_ROUTE_PASSWORD, _T("RoutePassword"),        METADATA_SECURE, IIS_MD_UT_FILE, STRING_METADATA},
//    {MD_SMTP_PREFERRED_AUTH,    _T("PreferredAuth"),        METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA},
    {MD_SMTP_MAX_REMOTEQ_THREADS,    _T("MaxRemQThreads"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_MAX_LOCALQ_THREADS,    _T("MaxLocQThreads"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_AUTHORIZED_TURN_LIST,    _T("AuthTURNList"),        METADATA_INHERIT, IIS_MD_UT_FILE, MULTISZ_METADATA},
    {MD_SMTP_CSIDE_ETRN_DELAY,    _T("CSideEtrnDelay"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_CSIDE_ETRN_DOMAIN,    _T("CSideEtrnDomain"),        METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
//    {MD_SMTP_VALIDATE_HELO_ARG,    _T("ValidateHelo"),        METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_IP_RELAY_ADDRESSES                   ,_T("IpRelayAddresses"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {MD_SMTP_RELAY_FOR_AUTH_USERS, _T("RelayForAuth"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SYSTEM_ROUTING_THREADS, _T("SysRoutingThreads"),    METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SHOW_BINARY_MIME, _T("AdvertiseBMIME"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SHOW_CHUNKING, _T("AdvertiseCHUNK"),    METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_CONNECT_TIMEOUT, _T("CONNECTTimeOut"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_MAILFROM_TIMEOUT, _T("MAILFROMTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_RCPTTO_TIMEOUT, _T("RCPTTOTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_DATA_TIMEOUT, _T("DATATimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_BDAT_TIMEOUT, _T("BDATTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_AUTH_TIMEOUT, _T("AUTHTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_SASL_TIMEOUT, _T("SASLTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_HELO_TIMEOUT, _T("HELOTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_TURN_TIMEOUT, _T("TURNTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_RSET_TIMEOUT, _T("RSETTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
//    {MD_SMTP_QUIT_TIMEOUT, _T("QUITTimeOut"),   METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_HELO_NODOMAIN, _T("HeloNoDomain"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_MAIL_NO_HELO, _T("MailNoHelo"),    METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_AQUEUE_DLL,  _T("AQDll"),   METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
//    {MD_MAPIDRV_DLL,  _T("MAPIDRVDll"), METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
//    {MD_CAT_DLL,  _T("CATDll"), METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_DOMAIN_VALIDATION_FLAGS,  _T("DomainValidationFlags"),  METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_DS_DOMAIN,  _T("DSDomain"),    METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_DS_USE_CAT, _T("DSUseCAT"),    METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_DS_FLAGS, _T("DSFlags"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_DS_PORT, _T("DSPort"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_REMOTE_RETRY_THRESHOLD, _T("RetryThreshold"),  METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_REMOTE_PROGRESSIVE_RETRY_MINUTES, _T("RemoteRetryMinString"),  METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},

    {MD_SMTP_EXPIRE_LOCAL_DELAY_MIN, _T("LocalDelayDSNMinutes"),    METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_EXPIRE_LOCAL_NDR_MIN, _T("LocalNDRMinutes"),   METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_EXPIRE_REMOTE_DELAY_MIN, _T("RemoteDelayDSNMinutes"),  METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_EXPIRE_REMOTE_NDR_MIN, _T("RemoteNDRMinutes"),     METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
    {MD_SMTP_USE_TCP_DNS,_T("UseTcpDns"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_DSN_OPTIONS,_T("DSNOptions"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_DSN_LANGUAGE_ID,_T("DSNLangID"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_SMTP_SSL_REQUIRE_TRUSTED_CA, _T("VerifySSLCertIssuer"), METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA},
    {MD_SMTP_SSL_CERT_HOSTNAME_VALIDATION, _T("VerifySSLCertSubject"), METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA},
    {MD_SMTP_DISABLE_PICKUP_DOT_STUFF, _T("DisablePickupDotStuff"), METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA},
    {MD_SMTP_DENIED_IP_ACTION, _T("DeniedIpAction"), METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA},
    {MD_SMTP_POST_DNS_SMARTHOST, _T("PostDnsSmarthost"), METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA},
    {0,0}
};


DWORD MapPropertyNameToCode(const CString & strName)
{
    return tPropertyNameTable::MapNameToCode(strName);
}

// function finds the record within given property name table,
// with the name equal to parameter lpszName
tPropertyNameTable * tPropertyNameTable::FindRecord(const CString strName, tPropertyNameTable * PropertyNameTable)
{
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if( strName.CompareNoCase(PropertyNameTable[i].lpszName)==0)
            return PropertyNameTable+i;
    }
    return 0;
}

tPropertyNameTable * tPropertyNameTable::FindRecord(DWORD dwCode, tPropertyNameTable * PropertyNameTable)
{
    if(dwCode==0)
            return NULL;
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if( dwCode==PropertyNameTable[i].dwCode)
            return PropertyNameTable+i;
    }
    return 0;
}

DWORD tPropertyNameTable::MapNameToCode(const CString & strName, tPropertyNameTable * PropertyNameTable)
{
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(PropertyNameTable[i].lpszName)==0)
            return PropertyNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}

CString tPropertyNameTable::MapCodeToName(DWORD dwCode, tPropertyNameTable * PropertyNameTable)
{
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if(dwCode == PropertyNameTable[i].dwCode)
            return PropertyNameTable[i].lpszName;
    }
    return _T("");
}


//**********************************************************************
// PROPERTY ATTRIB NAME TABLE  IMPLEMENTATION
//**********************************************************************


//constants defined in imd.h
struct tAttribNameTable gAttribNameTable[]=
{
    {METADATA_NO_ATTRIBUTES, _T("NO_ATTRIBUTES")},
    {METADATA_INHERIT, _T("INHERIT")},
    {METADATA_PARTIAL_PATH, _T("PARTIAL_PATH")},
    {METADATA_SECURE,_T("SECURE")},
    {METADATA_INSERT_PATH,_T("INSERT_PATH")},
//  {METADATA_REFERENCE,_T("REFERENCE")},
//  {METADATA_MASTER_ROOT_HANDLE, _T("MASTER_ROOT_HANDLE")},
//the end
    {0,0}
};

DWORD MapAttribNameToCode(const CString & strName)
{
    return tAttribNameTable::MapNameToCode(strName);
}


DWORD tAttribNameTable::MapNameToCode(const CString& strName, tAttribNameTable * AttribNameTable)
{
    for(int i=0; AttribNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(AttribNameTable[i].lpszName)==0)
            return AttribNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}


//**********************************************************************
// PROPERTY DATA TYPE NAME TABLE MPLEMENTATION
//**********************************************************************

//constants defined in imd.h
tDataTypeNameTable  gDataTypeNameTable[]=
{
    {DWORD_METADATA,    _T("DWORD")},
    {STRING_METADATA,   _T("STRING")},
    {BINARY_METADATA,   _T("BINARY")},
    {EXPANDSZ_METADATA, _T("EXPANDSZ")},
    {MULTISZ_METADATA,  _T("MULTISZ")},
//the end
    {0,0}
};

DWORD MapDataTypeNameToCode(const CString & strName)
{
    return tDataTypeNameTable::MapNameToCode(strName);
}


DWORD tDataTypeNameTable::MapNameToCode(const CString& strName, tDataTypeNameTable * DataTypeNameTable)
{
    for(int i=0; DataTypeNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(DataTypeNameTable[i].lpszName)==0)
            return DataTypeNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}

CString tDataTypeNameTable::MapCodeToName(DWORD a_dwCode, tDataTypeNameTable * DataTypeNameTable)
{
    for(int i=0; DataTypeNameTable[i].lpszName!=0;i++)
    {
        if(a_dwCode==DataTypeNameTable[i].dwCode)
            return DataTypeNameTable[i].lpszName;
    }
    return _T("");
}


//**********************************************************************
// PROPERTY USER TYPE NAME TABLE  IMPLEMENTATION
//**********************************************************************

//constants defined in iiscnfg.h
struct tUserTypeNameTable gUserTypeNameTable[]=
{
    {IIS_MD_UT_SERVER, _T("UT_SERVER")},
    {IIS_MD_UT_FILE, _T("UT_FILE")},
    {IIS_MD_UT_WAM,  _T("UT_WAM")},
    {ASP_MD_UT_APP,  _T("UT_APP")},
//the end
    {0,0}

};

DWORD MapUserTypeNameToCode(const CString & strName)
{
    return tUserTypeNameTable::MapNameToCode(strName);
}


DWORD tUserTypeNameTable::MapNameToCode(const CString& strName, tUserTypeNameTable * UserTypeNameTable)
{
    for(int i=0; UserTypeNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(UserTypeNameTable[i].lpszName)==0)
            return UserTypeNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}



//**********************************************************************
// PROPERTY PREDEFINED VALUES TABLE IMPLEMENTATION
//**********************************************************************

//constants defined in iiscnfg.h

//Predefined values table
struct tValueTable gValueTable[]=
{
//  Valid values for MD_AUTHORIZATION
    {MD_AUTH_ANONYMOUS               ,_T("Anonymous"),  MD_AUTHORIZATION},
    {MD_AUTH_BASIC                   ,_T("Basic"),      MD_AUTHORIZATION},
    {MD_AUTH_NT                      ,_T("NT"),     MD_AUTHORIZATION},
    {MD_AUTH_MD5                     ,_T("MD5"),        MD_AUTHORIZATION},
    {MD_AUTH_MAPBASIC                ,_T("MapBasic"),   MD_AUTHORIZATION},
//  Valid values for MD_ACCESS_PERM
    {MD_ACCESS_READ                  ,_T("Read"),   MD_ACCESS_PERM},
    {MD_ACCESS_WRITE                 ,_T("Write"),  MD_ACCESS_PERM},
    {MD_ACCESS_EXECUTE               ,_T("Execute"),    MD_ACCESS_PERM},
    {MD_ACCESS_SSL                   ,_T("SSL"),        MD_ACCESS_PERM},// Require SSL
    {MD_ACCESS_NEGO_CERT             ,_T("NegoCert"),   MD_ACCESS_PERM},// Allow client SSL certs
    {MD_ACCESS_REQUIRE_CERT          ,_T("RequireCert"),MD_ACCESS_PERM},// Require client SSL certs
    {MD_ACCESS_MAP_CERT              ,_T("MapCert"),MD_ACCESS_PERM},// Map SSL cert to NT account
    {MD_ACCESS_SSL128                ,_T("SSL128"), MD_ACCESS_PERM},// Require 128 bit SSL
    {MD_ACCESS_SCRIPT                ,_T("Script"), MD_ACCESS_PERM},// Script
    {MD_ACCESS_NO_REMOTE_READ        ,_T("NoRemoteRead"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_WRITE       ,_T("NoRemoteWrite"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_EXECUTE     ,_T("NoRemoteExecute"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_SCRIPT      ,_T("NoRemoteScript"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_MASK                  ,_T("MaskAll"),    MD_ACCESS_PERM},
//  Valid values for MD_SSL_ACCESS_PERM
    {MD_ACCESS_READ                  ,_T("Read"),   MD_SSL_ACCESS_PERM},
    {MD_ACCESS_WRITE                 ,_T("Write"),  MD_SSL_ACCESS_PERM},
    {MD_ACCESS_EXECUTE               ,_T("Execute"),    MD_SSL_ACCESS_PERM},
    {MD_ACCESS_SSL                   ,_T("SSL"),        MD_SSL_ACCESS_PERM},// Require SSL
    {MD_ACCESS_NEGO_CERT             ,_T("NegoCert"),   MD_SSL_ACCESS_PERM},// Allow client SSL certs
    {MD_ACCESS_REQUIRE_CERT          ,_T("RequireCert"),MD_SSL_ACCESS_PERM},// Require client SSL certs
    {MD_ACCESS_MAP_CERT              ,_T("MapCert"),MD_SSL_ACCESS_PERM},// Map SSL cert to NT account
    {MD_ACCESS_SSL128                ,_T("SSL128"), MD_SSL_ACCESS_PERM},// Require 128 bit SSL
    {MD_ACCESS_SCRIPT                ,_T("Script"), MD_SSL_ACCESS_PERM},// Script
    {MD_ACCESS_NO_REMOTE_READ        ,_T("NoRemoteRead"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_WRITE       ,_T("NoRemoteWrite"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_EXECUTE     ,_T("NoRemoteExecute"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_SCRIPT      ,_T("NoRemoteScript"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_MASK                  ,_T("MaskAll"),    MD_SSL_ACCESS_PERM},
//  Valid values for MD_DIRECTORY_BROWSING
    {MD_DIRBROW_SHOW_DATE            ,_T("Date"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_TIME            ,_T("Time"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_SIZE            ,_T("Size"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_EXTENSION       ,_T("Extension"), MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_LONG_DATE            ,_T("LongDate"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_ENABLED              ,_T("Enabled"),   MD_DIRECTORY_BROWSING},// Allow directory browsing
    {MD_DIRBROW_LOADDEFAULT          ,_T("LoadDefault"),MD_DIRECTORY_BROWSING},// Load default doc if exists
    {MD_DIRBROW_MASK                 ,_T("MaskAll"),        MD_DIRECTORY_BROWSING},
//  Valid values for MD_LOGON_METHOD
    {MD_LOGON_INTERACTIVE    ,_T("Interactive"),    MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
    {MD_LOGON_BATCH          ,_T("Batch"),      MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
    {MD_LOGON_NETWORK        ,_T("Network"),        MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_FILTER_STATE
    {MD_FILTER_STATE_LOADED          ,_T("Loaded"), MD_FILTER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_FILTER_STATE_UNLOADED        ,_T("Unloaded"),   MD_FILTER_STATE,    tValueTable::TYPE_EXCLUSIVE },
//  Valid values for MD_FILTER_FLAGS
    {/*SF_NOTIFY_SECURE_PORT*/0x00000001         ,_T("SecurePort"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_NONSECURE_PORT*/0x00000002      ,_T("NonSecurePort"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_READ_RAW_DATA*/0x000008000      ,_T("ReadRawData"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_PREPROC_HEADERS*/0x00004000     ,_T("PreprocHeaders"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_AUTHENTICATION*/0x00002000      ,_T("Authentication"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_URL_MAP*/0x00001000         ,_T("UrlMap"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ACCESS_DENIED*/0x00000800       ,_T("AccessDenied"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_SEND_RESPONSE*/0x00000040       ,_T("SendResponse"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_SEND_RAW_DATA*/0x00000400       ,_T("SendRawData"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_LOG*/0x00000200         ,_T("NotifyLog"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_END_OF_REQUEST*/0x00000080  ,_T("EndOfRequest"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_END_OF_NET_SESSION*/0x00000100  ,_T("EndOfNetSession"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_AUTHENTICATIONEX*/  0x20000000  ,_T("AuthenticationX"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_REQUEST_SECURITY_CONTEXT_CLOSE*/0x10000000,_T("RequestSecurityContextClose"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_RENEGOTIATE_CERT*/0x08000000,   _T("RenegotiateCert"), MD_FILTER_FLAGS},

    {/*SF_NOTIFY_ORDER_HIGH*/0x00080000   ,_T("OrderHigh"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ORDER_MEDIUM*/0x00040000   ,_T("OrderMedium"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ORDER_LOW*/0x00020000   ,_T("OrderLow"), MD_FILTER_FLAGS},

//  Valid values for MD_SERVER_STATE
    {MD_SERVER_STATE_STARTING        ,_T("Starting"),   MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STARTED         ,_T("Started"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STOPPING        ,_T("Stopping"),   MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STOPPED         ,_T("Stopped"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_PAUSING         ,_T("Pausing"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_PAUSED          ,_T("Paused"),     MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_CONTINUING      ,_T("Continuing"), MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_SERVER_COMMAND
    {MD_SERVER_COMMAND_START         ,_T("Start"),      MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_STOP          ,_T("Stop"),       MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_PAUSE         ,_T("Pause"),      MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_CONTINUE      ,_T("Continue"),   MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_SERVER_SIZE
    {MD_SERVER_SIZE_SMALL            ,_T("Small"),  MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_SIZE_MEDIUM           ,_T("Medium"), MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_SIZE_LARGE            ,_T("Large"),  MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},

    //{APPCMD_NONE, _T("None"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_VERIFY, _T("Verify"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_GETSTATUS, _T("GetStatus"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATE, _T("Create"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATEINPROC, _T("CreateInProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATEOUTPROC, _T("CreateOutProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CHANGETOINPROC, _T("ChangeToInProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CHANGETOOUTPROC, _T("ChangeToOutProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_DELETE, _T("Delete"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_UNLOAD, _T("Unload"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},

    //{APPSTATUS_Error, _T("Error"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Created, _T("Created"),    MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Deleted, _T("Deleted"),    MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_UnLoaded, _T("Unloaded"),  MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Killed, _T("Killed"),  MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Running, _T("Running"),    MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Stopped, _T("Stopped"),    MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_NoApplication, _T("NoApplication"),    MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_AppSubNode, _T("AppSubNode"),  MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},


// NEED LOGGING Updates
#if 0
    {MD_LOGTYPE_NONE     ,_T("LOGTYPE_NONE")},
    {MD_LOGTYPE_FILE     ,_T("LOGTYPE_FILE")},
    {MD_LOGTYPE_ODBC     ,_T("LOGTYPE_ODBC")},
    {MD_LOGFILE_PERIOD_MAXSIZE   ,_T("LOGFILE_PERIOD_MAXSIZE")},
    {MD_LOGFILE_PERIOD_DAILY     ,_T("LOGFILE_PERIOD_DAILY")},
    {MD_LOGFILE_PERIOD_WEEKLY    ,_T("LOGFILE_PERIOD_WEEKLY")},
    {MD_LOGFILE_PERIOD_MONTHLY   ,_T("LOGFILE_PERIOD_MONTHLY")},
#endif
//the end
    {0,0}
};

DWORD  MapValueNameToCode(const CString & strName,DWORD dwRelatedPropertyCode)
{
    return tValueTable::MapNameToCode(strName, dwRelatedPropertyCode);
}


DWORD  tValueTable::MapNameToCode(const CString& strName, DWORD dwRelatedPropertyCode, tValueTable * ValueTable)
{
    for(int i=0; ValueTable[i].lpszName!=0;i++)
    {
        if((strName.CompareNoCase(ValueTable[i].lpszName)==0) && ValueTable[i].dwRelatedPropertyCode==dwRelatedPropertyCode)
            return ValueTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}

CString  tValueTable::MapValueContentToString(DWORD dwValueContent, DWORD dwRelatedPropertyCode, tValueTable * ValueTable)
{
    CString strResult=_T("");
    for(int i=0; ValueTable[i].lpszName!=0;i++)
    {
        if(ValueTable[i].dwRelatedPropertyCode==dwRelatedPropertyCode)
        {
            if(ValueTable[i].dwFlags==tValueTable::TYPE_EXCLUSIVE)
            {
                if (ValueTable[i].dwCode == dwValueContent)
                    return ValueTable[i].lpszName;
            }
            else if ((ValueTable[i].dwCode & dwValueContent) == ValueTable[i].dwCode)
            {
                strResult = strResult + ValueTable[i].lpszName + _T(" ");
            }

        }
    }
    strResult.TrimRight();
    return strResult;
}


//prints info about what is stored in tables so that user can see the predefined names and values

void PrintTablesInfo(void)
{
    //Print supported property names
    _tprintf(_T("***The following list of property names (IIS parameters) is supported:\n"));
    _tprintf(_T("------------------------------------------------------------------------------\n"));
    _tprintf(_T("%-25s: \t%-10s %s\n"),_T("Property Name"), _T("Data type"), _T("Attributes and User Type"));
    _tprintf(_T("\t\t--Predefined Values\n"));
    _tprintf(_T("------------------------------------------------------------------------------\n"));
    for(int i=0; gPropertyNameTable[i].lpszName!=NULL; i++)
    {
       _tprintf(_T("%-25s: \t%-10s "),gPropertyNameTable[i].lpszName,
            LPCTSTR(_T("(")+tDataTypeNameTable::MapCodeToName(gPropertyNameTable[i].dwDefDataType)+_T(")")));
        if( (METADATA_INHERIT & gPropertyNameTable[i].dwDefAttributes) == METADATA_INHERIT)
        {   _tprintf(_T("INHERIT\t"));
        }
        if( (IIS_MD_UT_SERVER & gPropertyNameTable[i].dwDefUserType) == IIS_MD_UT_SERVER)
        {   _tprintf(_T("UT_SERVER\t"));
        }

        if( (IIS_MD_UT_FILE & gPropertyNameTable[i].dwDefUserType) == IIS_MD_UT_FILE)
        {   _tprintf(_T("UT_FILE "));
        }

        _tprintf(_T("\n"));

        //print list of applicable values

        for(int j=0; gValueTable[j].lpszName!=NULL;j++)
        {
            if( gValueTable[j].dwRelatedPropertyCode==gPropertyNameTable[i].dwCode)
            {
                _tprintf(_T("\t\t %-15s (=0x%x)\n"),gValueTable[j].lpszName,gValueTable[j].dwCode);

            }
        }
    }
    _tprintf(_T("\n***The following list of user types (for IIS parameters) is supported:\n"));
    for(i=0; gUserTypeNameTable[i].lpszName!=NULL; i++)
    {
        _tprintf(_T("%s "),gUserTypeNameTable[i].lpszName);
    }

    _tprintf(_T("\n\n***The following list of data types (for IIS parameters) is supported:\n"));
    for(i=0; gDataTypeNameTable[i].lpszName!=NULL; i++)
    {
        _tprintf(_T("%s  "),gDataTypeNameTable[i].lpszName);
    }
    _tprintf(_T("\n\n***The following list of attributes (for IIS parameters) is supported:\n"));
    for( i=0; gAttribNameTable[i].lpszName!=NULL; i++)
    {
        _tprintf(_T("%s  "),gAttribNameTable[i].lpszName);
    }
    _tprintf(_T("\n"));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\storedrv\atl.cpp ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:       atl.cpp
//
//  Contents:   Includes atlimpl.cpp, so that we don't rely on atl.dll
//
//  Classes:    All ATL classes.
//
//  Functions:  All ATL functions.
//
//  History:    October 23, 1997 - Milans, Created.
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "statreg.h"
#include "statreg.cpp"
#include "atlimpl.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\storedrv\makefile.inc ===
$(O)\seo.h $(O)\seo_i.c : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

!ifndef INETAMSG_MC_PATH
INETAMSG_MC_PATH=..\..\..\inc
!endif
$(O)\smtpmsg.h $(O)\smtpmsg.rc $(O)\msg00001.bin: ..\server\smtpmsg.mc $(STAXINC)\export\phatqmsg.mc $(INETAMSG_MC_PATH)\inetamsg.mc
    copy /a $(INETAMSG_MC_PATH)\inetamsg.mc + /a ..\server\smtpmsg.mc + /a $(STAXINC)\export\phatqmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\smtpmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\smtpmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\storedrv\ntfs.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1998,1999 Microsoft Corporation
//
//  File:       ntfs.h
//
//  Contents:   Header file for NTFS-base message class
//
//-----------------------------------------------------------------------------
#ifndef __NTFS_H_
#define __NTFS_H_

#include "resource.h"       // main symbols
#include "listmacr.h"
#include "evntwrap.h"
#include "perf.h"


//
// Class IDs
//
EXTERN_C const CLSID CLSID_NtfsStoreDriver;
EXTERN_C const CLSID CLSID_NtfsEnumMessages;
EXTERN_C const CLSID CLSID_NtfsPropertyStream;

/////////////////////////////////////////////////////////////////////////////
// CDriverUtils

class CDriverUtils
{
public:
	CDriverUtils();
	~CDriverUtils();

	static HRESULT LoadStoreDirectory(
				DWORD	dwInstanceId,
				LPTSTR	szStoreDirectory,
				DWORD	*pdwLength
				);

	static HRESULT GetStoreFileName(
				LPTSTR	szStoreDirectory,
				LPTSTR	szStoreFilename,
				DWORD	*pdwLength
				);

	static HRESULT GetStoreFileFromPath(
				LPTSTR					szStoreFilename,
				IMailMsgPropertyStream	**ppStream,
				PFIO_CONTEXT			*phContentFile,
				BOOL					fCreate,
				BOOL					fIsFAT,
                IMailMsgProperties      *pMsg,
				GUID					guidInstance = GUID_NULL
				);

	static HRESULT SetMessageContext(
				IMailMsgProperties		*pMsg,
				LPBYTE					pbContext,
				DWORD					dwLength
				);

	static HRESULT GetMessageContext(
				IMailMsgProperties		*pMsg,
				LPBYTE					pbContext,
				DWORD					*pdwLength
				);

	static HRESULT IsStoreDirectoryFat(
				LPTSTR	szStoreDirectory,
				BOOL	*pfIsFAT
				);

#if 0
	static HANDLE CreateFileCallback(
				LPSTR	szFilename,
				LPVOID	lpvData,
				DWORD	*pdwSize,
				DWORD	*pdwSizeHigh
				);
#endif

private:
	static DWORD			s_dwCounter;
};

typedef struct {
	DWORD		dwSignature;
	DWORD		dwVersion;
	GUID		guidInstance;
} NTFS_STREAM_HEADER;

#define STREAM_OFFSET				sizeof(NTFS_STREAM_HEADER)
#define STREAM_SIGNATURE			'rvDN'
#define STREAM_SIGNATURE_INVALID	'rvD!'
#define STREAM_SIGNATURE_PRECOMMIT	'rvDp'
#define STREAM_SIGNATURE_NOOFFSET	'MMCv'

//
// These are internal status codes used by CNtfsStoreDriver::SetHandle
// to report on the status of the current stream
//
// They aren't errors because SetHandle does actually load the stream.
// they are hints to the caller telling them that mailmsg won't be
// able to parse the stream.
//
#define FACILITY_NTFSDRV        0x6b1
#define NTFSDRV_S_HRESULT(_x_) \
    MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_NTFSDRV, (_x_))
#define S_NO_FIRST_COMMIT       NTFSDRV_S_HRESULT(1)
#define S_INVALIDSTREAM         NTFSDRV_S_HRESULT(2)

/////////////////////////////////////////////////////////////////////////////
// CNtfsStoreDriver

class ATL_NO_VTABLE CNtfsStoreDriver :
	public IMailMsgStoreDriver,
	public ISMTPStoreDriver,
	public IEventIsCacheable,
	public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public CComCoClass<CNtfsStoreDriver, &CLSID_NtfsStoreDriver>,
    public IMailMsgStoreDriverValidateContext
{
public:
    CNtfsStoreDriver();
    ~CNtfsStoreDriver();

	LONG AddUsage()
		{ return(InterlockedIncrement(&m_lRefCount)); }

	LONG ReleaseUsage()
		{ return(InterlockedDecrement(&m_lRefCount)); }

	DWORD GetInstance()
		{ return(m_dwInstance); }

	BOOL IsShuttingDown()
		{ return(m_fIsShuttingDown); }

	/***************************************************************************/
	//
	// Implementation of IUnknown
	//

	HRESULT STDMETHODCALLTYPE QueryInterface(
				REFIID		iid,
				void		**ppvObject
				);

	ULONG STDMETHODCALLTYPE AddRef();

	ULONG STDMETHODCALLTYPE Release();

	/***************************************************************************/
	//
	// IMailMsgStoreDriver
	//
	HRESULT STDMETHODCALLTYPE AllocMessage(
				IMailMsgProperties		*pMsg,
				DWORD					dwFlags,
				IMailMsgPropertyStream	**ppStream,
				PFIO_CONTEXT			*phContentFile,
				IMailMsgNotify			*pNotify
				);

	HRESULT STDMETHODCALLTYPE EnumMessages(
				IMailMsgEnumMessages	**ppEnum
				);

	HRESULT STDMETHODCALLTYPE ReOpen(
				IMailMsgProperties		*pMsg,
				IMailMsgPropertyStream	**ppStream,
				PFIO_CONTEXT			*phContentFile,
				IMailMsgNotify			*pNotify
				);

	HRESULT STDMETHODCALLTYPE Delete(
				IMailMsgProperties		*pMsg,
				IMailMsgNotify			*pNotify
				);

	HRESULT STDMETHODCALLTYPE CloseContentFile(
				IMailMsgProperties		*pMsg,
				PFIO_CONTEXT			hContentFile
				);

	HRESULT STDMETHODCALLTYPE ReAllocMessage(
				IMailMsgProperties		*pOriginalMsg,
				IMailMsgProperties		*pNewMsg,
				IMailMsgPropertyStream	**ppStream,
				PFIO_CONTEXT		*phContentFile,
				IMailMsgNotify			*pNotify
				);

	HRESULT STDMETHODCALLTYPE SupportWriteContent() { return S_OK; }

	/***************************************************************************/
	//
	// ISMTPStoreDriver
	//
	HRESULT STDMETHODCALLTYPE Init(
				DWORD dwInstance,
				IUnknown *pBinding,
				IUnknown *pServer,
				DWORD dwReason,
				IUnknown **ppStoreDriver
				);

	HRESULT STDMETHODCALLTYPE PrepareForShutdown(
				DWORD dwReason
				);

	HRESULT STDMETHODCALLTYPE Shutdown(
				DWORD dwReason
				);

	HRESULT STDMETHODCALLTYPE LocalDelivery(
				IMailMsgProperties *pMsg,
				DWORD dwRecipCount,
				DWORD *pdwRecipIndexes,
				IMailMsgNotify *pNotify
				);

	HRESULT STDMETHODCALLTYPE EnumerateAndSubmitMessages(
				IMailMsgNotify *pNotify
				);

	//
	// IEventIsCahceable
	//
	HRESULT STDMETHODCALLTYPE IsCacheable();

    //
    //  IMailMsgStoreDriverValidateContext
    //
    HRESULT STDMETHODCALLTYPE ValidateMessageContext(
                                        BYTE *pbContext,
                                        DWORD cbContext);

DECLARE_REGISTRY_RESOURCEID(IDR_NTFSDRV)

BEGIN_COM_MAP(CNtfsStoreDriver)
    COM_INTERFACE_ENTRY(IMailMsgStoreDriver)
    COM_INTERFACE_ENTRY(ISMTPStoreDriver)
    COM_INTERFACE_ENTRY(IEventIsCacheable)
    COM_INTERFACE_ENTRY(IMailMsgStoreDriverValidateContext)
END_COM_MAP()

	GUID GetInstanceGuid() { return m_guidInstance; }

    BOOL IsFAT() { return m_fIsFAT; }

private:

	LONG				m_lRefCount;

	DWORD				m_dwInstance;

	TCHAR				m_szQueueDirectory[MAX_PATH * 2];
	BOOL				m_fInitialized;
	BOOL				m_fIsShuttingDown;
	ISMTPServer			*m_pSMTPServer;

	// Reference count
	LONG				m_ulRefCount;

	BOOL				m_fIsFAT;

	// our instance guid
	GUID			    m_guidInstance;

public:

    //Use list entry to maintain the list to keep track of current
    //instances of sink of this type
    LIST_ENTRY  m_InstLEntry;

public:
    //Global array of instances
    static DWORD                sm_cCurrentInstances;
    static CRITICAL_SECTION     sm_csLockInstList;
    static LIST_ENTRY           sm_ListHead;

    //for controlling the retry queue
    static void LockList () {EnterCriticalSection (&CNtfsStoreDriver::sm_csLockInstList);}
    static void UnLockList() {LeaveCriticalSection (&CNtfsStoreDriver::sm_csLockInstList);}

    //Lookup and insert into array
    static IUnknown * LookupSinkInstance(DWORD dwVirtualServerId, REFIID iidBinding)
    {
        PLIST_ENTRY  pCurrentListEntry;
        CNtfsStoreDriver * pStoreInstance = NULL;

        //Initialize
        pCurrentListEntry = &sm_ListHead;

        //Look at the next entry to see if we are not at the end of the queue
        while(pCurrentListEntry->Flink != &sm_ListHead)
        {
            //Get the object pointed by the next entry
            pStoreInstance = CONTAINING_RECORD( pCurrentListEntry->Flink, CNtfsStoreDriver, m_InstLEntry);

            //If the entry has same virtual server id we are done
            //NK** : check binding too in MM3 timeframe
            if(dwVirtualServerId == pStoreInstance->m_dwInstance)
            {
                    return (IUnknown *)(ISMTPStoreDriver *)pStoreInstance;
            }

            pCurrentListEntry = pCurrentListEntry->Flink;
        }
        return NULL;
    }

    static HRESULT InsertSinkInstance(PLIST_ENTRY  pListEntry)
    {
        CNtfsStoreDriver::sm_cCurrentInstances++;
        //insert at the start of the list
        InsertHeadList(&sm_ListHead, pListEntry);
        return S_OK;
    }

    static HRESULT RemoveSinkInstance(IUnknown * pISinkInstance)
    {
        PLIST_ENTRY  pCurrentListEntry;
        CNtfsStoreDriver * pStoreInstance = NULL;

        //Initialize
        pCurrentListEntry = &sm_ListHead;

        //Look at the next entry to see if we are not at the end of the queue
        while(pCurrentListEntry->Flink != &sm_ListHead)
        {
            //Get the object pointed by the next entry
            pStoreInstance = CONTAINING_RECORD( pCurrentListEntry->Flink, CNtfsStoreDriver, m_InstLEntry);

            //If the entry has same instance pointer we are done
            //check binding too in MM3 timeframe
            if(pISinkInstance == (IUnknown *)(ISMTPStoreDriver *)pStoreInstance)
            {
                RemoveEntryList(pCurrentListEntry->Flink);
                CNtfsStoreDriver::sm_cCurrentInstances--;
                pStoreInstance->m_InstLEntry.Flink = NULL;
                pStoreInstance->m_InstLEntry.Blink = NULL;
                return S_OK;
            }

            pCurrentListEntry = pCurrentListEntry->Flink;
        }

        return(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }

public:
    PerfObjectInstance *m_ppoi;
    static CEventLogWrapper    *g_pEventLog;

};

/////////////////////////////////////////////////////////////////////////////
// CNtfsStoreDriver

class ATL_NO_VTABLE CNtfsEnumMessages :
	public IMailMsgEnumMessages,
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public CComCoClass<CNtfsEnumMessages, &CLSID_NtfsEnumMessages>
{
public:
    CNtfsEnumMessages();
    ~CNtfsEnumMessages();

	HRESULT SetStoreDirectory(
				LPTSTR	szStoreDirectory,
				BOOL	fIsFAT
				);

	HRESULT SetInfo(
				CNtfsStoreDriver	*pDriver
				)
	{
		_ASSERT(pDriver);
		m_pDriver = pDriver;
		pDriver->AddUsage();
		return(S_OK);
	}

	/***************************************************************************/
	//
	// Implementation of IUnknown
	//

	HRESULT STDMETHODCALLTYPE QueryInterface(
				REFIID		iid,
				void		**ppvObject
				);

	ULONG STDMETHODCALLTYPE AddRef();

	ULONG STDMETHODCALLTYPE Release();

	//
	// IMailMsgEnumMessages
	//
	HRESULT STDMETHODCALLTYPE Next(
				IMailMsgProperties		*pMsg,
				IMailMsgPropertyStream	**ppStream,
				PFIO_CONTEXT			*phContentFile,
				IMailMsgNotify			*pNotify
				);

DECLARE_REGISTRY_RESOURCEID(IDR_NTFSENUM)

BEGIN_COM_MAP(CNtfsEnumMessages)
    COM_INTERFACE_ENTRY(IMailMsgEnumMessages)
END_COM_MAP()

private:
	CNtfsStoreDriver	*m_pDriver;
	BOOL				m_fIsFAT;

	TCHAR			m_szEnumPath[MAX_PATH * 2];
	TCHAR			m_szStorePath[MAX_PATH * 2];
	HANDLE			m_hEnum;
	WIN32_FIND_DATA	m_Data;

	// Reference count
	LONG			m_ulRefCount;

};

/////////////////////////////////////////////////////////////////////////////
// CNtfsPropertyStream

class ATL_NO_VTABLE CNtfsPropertyStream :
	public IMailMsgPropertyStream,
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public CComCoClass<CNtfsPropertyStream, &CLSID_NtfsPropertyStream>
{
public:

    CNtfsPropertyStream();
    ~CNtfsPropertyStream();

	//
	// guidInstance should be GUID_NULL when we are loading an existing
	// stream from disk, or an instance guid for the driver when we are
	// creating a new stream;
	//
	HRESULT SetHandle(
				HANDLE			    hStream,
				GUID			    guidInstance,
                BOOL                fLiveStream,
                IMailMsgProperties  *pMsg);

	HRESULT SetInfo(
				CNtfsStoreDriver	*pDriver
				)
	{
		_ASSERT(pDriver);
		m_pDriver = pDriver;
		pDriver->AddUsage();
        IncCtr((pDriver->m_ppoi), NTFSDRV_MSG_STREAMS_OPEN);
		return(S_OK);
	}

	/***************************************************************************/
	//
	// Implementation of IUnknown
	//

	HRESULT STDMETHODCALLTYPE QueryInterface(
				REFIID		iid,
				void		**ppvObject
				);

	ULONG STDMETHODCALLTYPE AddRef();

	ULONG STDMETHODCALLTYPE Release();

	//
	// IMailMsgPropertyStream
	//
	HRESULT STDMETHODCALLTYPE GetSize(
				IMailMsgProperties	*pMsg,
				DWORD			*pdwSize,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE ReadBlocks(
				IMailMsgProperties	*pMsg,
				DWORD				dwCount,
				DWORD				*pdwOffset,
				DWORD				*pdwLength,
				BYTE				**ppbBlock,
				IMailMsgNotify		*pNotify
				);

	HRESULT STDMETHODCALLTYPE StartWriteBlocks(
				IMailMsgProperties	*pMsg,
				DWORD 			cBlocks,
				DWORD			cBytes);

	HRESULT STDMETHODCALLTYPE EndWriteBlocks(
				IMailMsgProperties	*pMsg);

	HRESULT STDMETHODCALLTYPE CancelWriteBlocks(
				IMailMsgProperties	*pMsg);

	HRESULT STDMETHODCALLTYPE WriteBlocks(
				IMailMsgProperties	*pMsg,
				DWORD				dwCount,
				DWORD				*pdwOffset,
				DWORD				*pdwLength,
				BYTE				**ppbBlock,
				IMailMsgNotify		*pNotify
				);

DECLARE_REGISTRY_RESOURCEID(IDR_NTFSSTM)

BEGIN_COM_MAP(CNtfsPropertyStream)
    COM_INTERFACE_ENTRY(IMailMsgPropertyStream)
END_COM_MAP()

	GUID GetInstanceGuid() { return m_guidInstance; }

private:
	HANDLE				m_hStream;
	CNtfsStoreDriver	*m_pDriver;

    // how many times have we seen EndWriteBlocks? (and thus a full commit)
    BOOL                m_cCommits;

	// Reference count
	LONG				m_ulRefCount;

	// do we have header information?
	BOOL				m_fStreamHasHeader;

    // is the stream being used for validation?
    BOOL                m_fValidation;

	// the instance GUID under which this was created
	GUID				m_guidInstance;

    // the hresult that we returned from StartWriteBlocks.  if we failed
    // then we also fail writeblocks
    HRESULT             m_hrStartWriteBlocks;
};


#define DECLARE_STD_IUNKNOWN_METHODS(ClassRoot, Interface)	\
HRESULT STDMETHODCALLTYPE C##ClassRoot::QueryInterface(		\
			REFIID		iid,								\
			void		**ppvObject							\
			)												\
{															\
	if (iid == IID_IUnknown)								\
		*ppvObject = (IUnknown *)(##Interface *)this;		\
	else if (iid == IID_##Interface)						\
		*ppvObject = (##Interface *)this;					\
	else													\
		return(E_NOINTERFACE);								\
	AddRef();												\
	return(S_OK);											\
}															\
ULONG STDMETHODCALLTYPE C##ClassRoot::AddRef()				\
{															\
	return(InterlockedIncrement(&m_ulRefCount));			\
}															\
ULONG STDMETHODCALLTYPE C##ClassRoot::Release()				\
{															\
	LONG	lRefCount = InterlockedDecrement(&m_ulRefCount);\
	if (lRefCount == 0)										\
		delete this;										\
	return(lRefCount);										\
}

#endif //__NTFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\storedrv\ntfs.cpp ===
//+----------------------------------------------------------------------------
//
//  Ntfs.cpp : Implementation of NTFS Store driver classes
//
//  Copyright (C) 1998, Microsoft Corporation
//
//  File:       ntfs.cpp
//
//  Contents:   Implementation of NTFS Store driver classes.
//
//  Classes:    CNtfsStoreDriver, CNtfsPropertyStream
//
//  Functions:
//
//  History:    3/31/98     KeithLau        Created
//
//-----------------------------------------------------------------------------

#include "stdafx.h"

#include "filehc.h"
#include "mailmsg.h"
#include "mailmsgi.h"

#include "mailmsgprops.h"

#include "seo.h"
#include "seo_i.c"

#include "Ntfs.h"

#include "smtpmsg.h"

HANDLE g_hTransHeap = NULL;

//
// Instantiate the CLSIDs
//
#ifdef __cplusplus
extern "C"{
#endif

const CLSID CLSID_NtfsStoreDriver       = {0x609b7e3a,0xc918,0x11d1,{0xaa,0x5e,0x00,0xc0,0x4f,0xa3,0x5b,0x82}};
const CLSID CLSID_NtfsEnumMessages      = {0xbbddbdec,0xc947,0x11d1,{0xaa,0x5e,0x00,0xc0,0x4f,0xa3,0x5b,0x82}};
const CLSID CLSID_NtfsPropertyStream    = {0x6d7572ac,0xc939,0x11d1,{0xaa,0x5e,0x00,0xc0,0x4f,0xa3,0x5b,0x82}};

#ifdef __cplusplus
}
#endif

//
// Define the store file prefix and extension
//
#define NTFS_STORE_FILE_PREFIX                  _T("\\NTFS_")
#define NTFS_STORE_FILE_WILDCARD                _T("*")
#define NTFS_STORE_FILE_EXTENSION               _T(".EML")
#define NTFS_FAT_STREAM_FILE_EXTENSION_1ST      _T(".STM")
#define NTFS_FAT_STREAM_FILE_EXTENSION_LIVE     _T(".STL")
#define NTFS_STORE_FILE_PROPERTY_STREAM_1ST     _T(":PROPERTIES")
#define NTFS_STORE_FILE_PROPERTY_STREAM_LIVE    _T(":PROPERTIES-LIVE")
#define NTFS_STORE_BACKSLASH                    _T("\\")
#define NTFS_QUEUE_DIRECTORY_SUFFIX             _T("\\Queue")
#define NTFS_DROP_DIRECTORY_SUFFIX              _T("\\Drop")

#define SMTP_MD_ID_BEGIN_RESERVED   0x00009000
#define MD_MAIL_QUEUE_DIR               (SMTP_MD_ID_BEGIN_RESERVED+11 )
#define MD_MAIL_DROP_DIR                (SMTP_MD_ID_BEGIN_RESERVED+18 )

/////////////////////////////////////////////////////////////////////////////
// CDriverUtils

//
// Define the registry path location in the registry
//
#define NTFS_STORE_DIRECTORY_REG_PATH   _T("Software\\Microsoft\\Exchange\\StoreDriver\\Ntfs\\%u")
#define NTFS_STORE_DIRECTORY_REG_NAME   _T("StoreDir")

//
// Instantiate static
//
DWORD CDriverUtils::s_dwCounter = 0;
CEventLogWrapper *CNtfsStoreDriver::g_pEventLog = NULL;

CDriverUtils::CDriverUtils()
{
}

CDriverUtils::~CDriverUtils()
{
}

HRESULT CDriverUtils::LoadStoreDirectory(
            DWORD   dwInstanceId,
            LPTSTR  szStoreDirectory,
            DWORD   *pdwLength
            )
{
    HKEY    hKey = NULL;
    DWORD   dwRes;
    DWORD   dwType;
    TCHAR   szStoreDirPath[MAX_PATH];
    HRESULT hrRes = S_OK;

    _ASSERT(szStoreDirectory);
    _ASSERT(pdwLength);

    TraceFunctEnter("CDriverUtils::LoadStoreDirectory");

    // Build up the registry path given instance ID
    wsprintf(szStoreDirPath, NTFS_STORE_DIRECTORY_REG_PATH, dwInstanceId);

    // Open the registry key
    dwRes = (DWORD)RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                szStoreDirPath,
                0,
                KEY_ALL_ACCESS,
                &hKey);
    if (dwRes != ERROR_SUCCESS)
    {
        hrRes = HRESULT_FROM_WIN32(dwRes);
        goto Cleanup;
    }

    // Adjust the buffer size for character type ...
    (*pdwLength) *= sizeof(TCHAR);
    dwRes = (DWORD)RegQueryValueEx(
                hKey,
                NTFS_STORE_DIRECTORY_REG_NAME,
                NULL,
                &dwType,
                (LPBYTE)szStoreDirectory,
                pdwLength);
    if (dwRes != ERROR_SUCCESS)
    {
        hrRes = HRESULT_FROM_WIN32(dwRes);
        ErrorTrace((LPARAM)0, "Failed to load store driver directory %u", dwRes);
    }
    else
    {
        hrRes = S_OK;
        DebugTrace((LPARAM)0, "Store directory is %s", szStoreDirectory);
    }

Cleanup:

    if (hKey)
        RegCloseKey(hKey);

    TraceFunctLeave();
    return(hrRes);
}

HRESULT CDriverUtils::GetStoreFileName(
            LPTSTR  szStoreDirectory,
            LPTSTR  szStoreFilename,
            DWORD   *pdwLength
            )
{
    _ASSERT(szStoreDirectory);
    _ASSERT(szStoreFilename);
    _ASSERT(pdwLength);

    DWORD       dwLength = *pdwLength;
    DWORD       dwStrLen;
    FILETIME    ftTime;

    dwStrLen = lstrlen(szStoreDirectory);
    if (dwLength <= dwStrLen)
        return(HRESULT_FROM_WIN32(ERROR_MORE_DATA));

    lstrcpy(szStoreFilename, szStoreDirectory);
    dwLength -= dwStrLen;
    szStoreFilename += dwStrLen;
    *pdwLength = dwStrLen;

    GetSystemTimeAsFileTime(&ftTime);

    dwStrLen = lstrlen(NTFS_STORE_FILE_PREFIX) +
                lstrlen(NTFS_STORE_FILE_EXTENSION) +
                26;
    if (dwLength <= dwStrLen)
        return(HRESULT_FROM_WIN32(ERROR_MORE_DATA));
    wsprintf(szStoreFilename,
            "%s%08x%08x%08x%s",
            NTFS_STORE_FILE_PREFIX,
            ftTime.dwLowDateTime,
            ftTime.dwHighDateTime,
            InterlockedIncrement((PLONG)&s_dwCounter),
            NTFS_STORE_FILE_EXTENSION);

    *pdwLength += (dwStrLen + 1);

    return(S_OK);
}

HRESULT CDriverUtils::GetStoreFileFromPath(
            LPTSTR                  szStoreFilename,
            IMailMsgPropertyStream  **ppStream,
            PFIO_CONTEXT            *ppFIOContentFile,
            BOOL                    fCreate,
            BOOL                    fIsFAT,
            IMailMsgProperties      *pMsg,
            GUID                    guidInstance
            )
{
    // OK, got a file, get the content handle and property stream
    HRESULT hrRes = S_OK;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    HANDLE  hStream = INVALID_HANDLE_VALUE;
    TCHAR   szPropertyStream[MAX_PATH << 1];
    BOOL    fDeleteOnCleanup = FALSE;

    _ASSERT(fCreate || (guidInstance == GUID_NULL));

    IMailMsgPropertyStream  *pIStream = NULL;

    TraceFunctEnter("CDriverUtils::GetStoreFileFromPath");

    if (ppFIOContentFile)
    {
        // Open the content ...
        hFile = CreateFile(
                    szStoreFilename,
                    GENERIC_READ | GENERIC_WRITE,   // Read / Write
                    FILE_SHARE_READ,                // Shared read
                    NULL,                           // Default security
                    (fCreate)?CREATE_NEW:OPEN_EXISTING, // Create new or open existing file
                    FILE_FLAG_OVERLAPPED |          // Overlapped access
                    FILE_FLAG_SEQUENTIAL_SCAN,      // Seq scan
                    //FILE_FLAG_WRITE_THROUGH,      // Write through cache
                    NULL);                          // No template
        if (hFile == INVALID_HANDLE_VALUE)
            goto Cleanup;
    }

    DebugTrace(0, "--- start ---");
    if (ppStream)
    {
        DebugTrace((LPARAM)0, "Handling stream in %s", fIsFAT?"FAT":"NTFS");

        BOOL fTryLiveStream = !fCreate;
        BOOL fNoLiveStream = FALSE;
        BOOL fLiveWasCorrupt = FALSE;

        do {
            // Open the alternate file stream
            lstrcpy(szPropertyStream, szStoreFilename);

            if (fTryLiveStream) {
                DebugTrace((LPARAM) 0, "TryingLive");
                lstrcat(szPropertyStream,
                    fIsFAT?NTFS_FAT_STREAM_FILE_EXTENSION_LIVE:
                           NTFS_STORE_FILE_PROPERTY_STREAM_LIVE);
            } else {
                DebugTrace((LPARAM) 0, "Trying1st");
                lstrcat(szPropertyStream,
                    fIsFAT?NTFS_FAT_STREAM_FILE_EXTENSION_1ST:
                           NTFS_STORE_FILE_PROPERTY_STREAM_1ST);
            }

            DebugTrace((LPARAM) 0, "File: %s", szPropertyStream);

            hStream = CreateFile(
                        szPropertyStream,
                        GENERIC_READ | GENERIC_WRITE,   // Read / Write
                        FILE_SHARE_READ,                                // No sharing
                        NULL,                           // Default security
                        (fCreate)?
                        CREATE_NEW:                     // Create new or
                        OPEN_EXISTING,                  // Open existing file
                        FILE_FLAG_SEQUENTIAL_SCAN,      // Seq scan
                        //FILE_FLAG_WRITE_THROUGH,      // Write through cache
                        NULL);                          // No template
            if (hStream == INVALID_HANDLE_VALUE) {
                DebugTrace((LPARAM) 0, "Got INVALID_HANDLE_VALUE\n");
                if (fTryLiveStream && GetLastError() == ERROR_FILE_NOT_FOUND) {
                    DebugTrace((LPARAM) 0, "livestream and FILE_NOT_FOUND\n");
                    hrRes = S_INVALIDSTREAM;
                    fNoLiveStream = TRUE;
                } else if (GetLastError() == ERROR_FILE_NOT_FOUND) {
                    DebugTrace((LPARAM) 0, "no primary stream either\n");
                    hrRes = S_NO_FIRST_COMMIT;
                } else {
                    DebugTrace((LPARAM) 0, 
                        "Returning CreateFile error %lu\n", GetLastError());
                    hrRes = HRESULT_FROM_WIN32(GetLastError());
                    goto Cleanup;
                }
            } else {
                hrRes = CoCreateInstance(
                            CLSID_NtfsPropertyStream,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IMailMsgPropertyStream,
                            (LPVOID *)&pIStream);
                if (FAILED(hrRes))
                    goto Cleanup;

                hrRes = ((CNtfsPropertyStream *)pIStream)->SetHandle(hStream,
                                                                     guidInstance,
                                                                     fTryLiveStream,
                                                                     pMsg);
                if (FAILED(hrRes)) {
                    if (fCreate) fDeleteOnCleanup = TRUE;
                    goto Cleanup;
                }
            }

            if (hrRes == S_INVALIDSTREAM || hrRes == S_NO_FIRST_COMMIT) {
                if (hrRes == S_INVALIDSTREAM) {
                    DebugTrace((LPARAM) 0, 
                        "SetHandle returned S_INVALIDSTREAM\n");
                } else {
                    DebugTrace((LPARAM) 0, 
                        "SetHandle returned S_NO_FIRST_COMMIT\n");
                }
                if (fTryLiveStream) {
                    // if we were working with the live stream then retry with
                    // the 1st commited stream
                    fTryLiveStream = FALSE;
                    fLiveWasCorrupt = !fNoLiveStream;
                    DebugTrace((LPARAM) 0, "Trying regular stream\n");
                    if (pIStream) {
                        pIStream->Release();
                        pIStream = NULL;
                    }
                    if (hrRes == S_NO_FIRST_COMMIT) hrRes = S_INVALIDSTREAM;
                } else {
                    // the 1st committed stream was invalid.  this can
                    // only occur when the message was not acked.
                    //
                    // if the live stream existed and this one is invalid
                    // then something is weird, so we go down the eventlog
                    // path (returning S_OK).  S_OK works because currently
                    // pStream->m_fStreamHasHeader is set to 0.  Either
                    // the mailmsg signature check will fail or mailmsg
                    // won't be able to read the entire master header.
                    // either way will cause the message to be ignored and
                    // eventlog'd
                    //
                    // CEnumNtfsMessages::Next will delete the message
                    // for us
                    if (hrRes == S_INVALIDSTREAM) {
                        if (fLiveWasCorrupt && !fNoLiveStream) {
                            hrRes = S_OK;
                            DebugTrace((LPARAM) 0, "Returning S_OK because there was no live stream\n");
                        } else {
                            hrRes = S_NO_FIRST_COMMIT;
                            DebugTrace((LPARAM) 0, "Returning S_NO_FIRST_COMMIT\n");
                        }
                    } else {
                        DebugTrace((LPARAM) 0, "Returning S_NO_FIRST_COMMIT\n");
                    }
                }
            } else {
                DebugTrace((LPARAM) 0, "SetHandle returned other error %x\n", hrRes);
            }
            _ASSERT(SUCCEEDED(hrRes));
            if (FAILED(hrRes)) goto Cleanup;
        } while (hrRes == S_INVALIDSTREAM);
    }

    // Fill in the return values
    if (ppStream) {
        *ppStream = pIStream;
    }
    if (ppFIOContentFile) {
        *ppFIOContentFile = AssociateFile(hFile);
        if (*ppFIOContentFile == NULL) {
            goto Cleanup;
        }
    }

    TraceFunctLeave();
    return(hrRes);

Cleanup:
    if (hrRes == S_OK) hrRes = HRESULT_FROM_WIN32(GetLastError());
    if (SUCCEEDED(hrRes)) hrRes = E_FAIL;

    if (hStream != INVALID_HANDLE_VALUE) {
        CloseHandle(hStream);
    }
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
    if (fDeleteOnCleanup) {
        // this only happens at file creation time.  There is no 
        // live file to worry about.  The below code is too simplistic
        // if we do have to delete a live stream.
        _ASSERT(fCreate);
        DeleteFile(szStoreFilename);
        DeleteFile(szPropertyStream);
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT CDriverUtils::SetMessageContext(
            IMailMsgProperties      *pMsg,
            LPBYTE                  pbContext,
            DWORD                   dwLength
            )
{
    HRESULT hrRes   = S_OK;
    BYTE    pbData[(MAX_PATH * 2) + sizeof(CLSID)];

    _ASSERT(pMsg);

    if (dwLength > (MAX_PATH * 2))
        return(E_INVALIDARG);

    MoveMemory(pbData, &CLSID_NtfsStoreDriver, sizeof(CLSID));
    MoveMemory(pbData + sizeof(CLSID), pbContext, dwLength);
    dwLength += sizeof(CLSID);
    hrRes = pMsg->PutProperty(
                IMMPID_MPV_STORE_DRIVER_HANDLE,
                dwLength,
                pbData);

    // make S_FALSE return S_OK
    if (SUCCEEDED(hrRes)) hrRes = S_OK;

    return(hrRes);
}

HRESULT CDriverUtils::GetMessageContext(
            IMailMsgProperties      *pMsg,
            LPBYTE                  pbContext,
            DWORD                   *pdwLength
            )
{
    HRESULT hrRes   = S_OK;
    DWORD   dwLength;

    _ASSERT(pMsg);
    _ASSERT(pbContext);
    _ASSERT(pdwLength);

    dwLength = *pdwLength;

    hrRes = pMsg->GetProperty(
                IMMPID_MPV_STORE_DRIVER_HANDLE,
                dwLength,
                pdwLength,
                pbContext);

    if (SUCCEEDED(hrRes))
    {
        dwLength = *pdwLength;

        // Verify length and CLSID
        if ((dwLength < sizeof(CLSID)) ||
            (*(CLSID *)pbContext != CLSID_NtfsStoreDriver))
            hrRes = NTE_BAD_SIGNATURE;
        else
        {
            // Copy the context info
            dwLength -= sizeof(CLSID);
            MoveMemory(pbContext, pbContext + sizeof(CLSID), dwLength);
            *pdwLength = dwLength;
        }
    }

    return(hrRes);
}

HRESULT CDriverUtils::IsStoreDirectoryFat(
            LPTSTR  szStoreDirectory,
            BOOL    *pfIsFAT
            )
{
    HRESULT hrRes = S_OK;
    TCHAR   szDisk[MAX_PATH];
    TCHAR   szFileSystem[MAX_PATH];
    DWORD   lSerial, lMaxLen, lFlags;
    DWORD   dwLength;
    UINT    uiErrorMode;

    _ASSERT(szStoreDirectory);
    _ASSERT(pfIsFAT);

    TraceFunctEnter("CDriverUtils::IsStoreDirectoryFat");

    // OK, find the root drive, make sure we handle UNC names
    dwLength = lstrlen(szStoreDirectory);
    if (dwLength < 2)
        return(E_INVALIDARG);

    szDisk[0] = szStoreDirectory[0];
    szDisk[1] = szStoreDirectory[1];
    if ((szDisk[0] == _T('\\')) && (szDisk[1] == _T('\\')))
    {
        DWORD   dwCount = 0;
        LPTSTR  pTemp = szDisk + 2;

        DebugTrace((LPARAM)0, "UNC Name: %s", szStoreDirectory);

        // Handle UNC
        szStoreDirectory += 2;
        while (*szStoreDirectory)
            if (*pTemp = *szStoreDirectory++)
                if (*pTemp++ == _T('\\'))
                {
                    dwCount++;
                    if (dwCount == 2)
                        break;
                }
        if (dwCount == 2)
            *pTemp = _T('\0');
        else if (dwCount == 1)
        {
            *pTemp++ = _T('\\');
            *pTemp = _T('\0');
        }
        else
            return(E_INVALIDARG);
    }
    else
    {
        DebugTrace((LPARAM)0, "Local drive: %s", szStoreDirectory);

        // Local path
        if (!_istalpha(szDisk[0]) || (szDisk[1] != _T(':')))
            return(E_INVALIDARG);
        szDisk[2] = _T('\\');
        szDisk[3] = _T('\0');
    }

    // Call the system to determine what file system we have here,
    // we set the error mode here to avoid unsightly pop-ups.
    uiErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    if (GetVolumeInformation(
                szDisk,
                NULL, 0,
                &lSerial, &lMaxLen, &lFlags,
                szFileSystem, MAX_PATH))
    {
        DebugTrace((LPARAM)0, "File system is: %s", szFileSystem);

        if (!lstrcmpi(szFileSystem, _T("NTFS")))
            *pfIsFAT = FALSE;
        else if (!lstrcmpi(szFileSystem, _T("FAT")))
            *pfIsFAT = TRUE;
        else if (!lstrcmpi(szFileSystem, _T("FAT32")))
            *pfIsFAT = TRUE;
        else
            hrRes = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
    }
    else
        hrRes = HRESULT_FROM_WIN32(GetLastError());
    SetErrorMode(uiErrorMode);

    TraceFunctLeave();
    return(hrRes);
}


/////////////////////////////////////////////////////////////////////////////
// CNtfsStoreDriver
//

//
// Instantiate static
//
DWORD                CNtfsStoreDriver::sm_cCurrentInstances = 0;
CRITICAL_SECTION     CNtfsStoreDriver::sm_csLockInstList;
LIST_ENTRY           CNtfsStoreDriver::sm_ListHead;

CNtfsStoreDriver::CNtfsStoreDriver()
{
    m_fInitialized = FALSE;
    m_fIsShuttingDown = FALSE;
    *m_szQueueDirectory = _T('\0');
    m_pSMTPServer = NULL;
    m_lRefCount = 0;
    m_fIsFAT = TRUE; // Assume we ARE on a fat partition until we discover otherwise
    UuidCreate(&m_guidInstance);
    m_ppoi = NULL;
    m_InstLEntry.Flink = NULL;
    m_InstLEntry.Blink = NULL;
}

CNtfsStoreDriver::~CNtfsStoreDriver() {
    CNtfsStoreDriver::LockList();
    if (m_InstLEntry.Flink != NULL) {
        _ASSERT(m_InstLEntry.Blink != NULL);
        HRESULT hr = CNtfsStoreDriver::RemoveSinkInstance(
                        (IUnknown *)(ISMTPStoreDriver *)this);
        _ASSERT(SUCCEEDED(hr));
    }
    _ASSERT(m_InstLEntry.Flink == NULL);
    _ASSERT(m_InstLEntry.Blink == NULL);
    CNtfsStoreDriver::UnLockList();
}

DECLARE_STD_IUNKNOWN_METHODS(NtfsStoreDriver, IMailMsgStoreDriver)

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::AllocMessage(
            IMailMsgProperties      *pMsg,
            DWORD                   dwFlags,
            IMailMsgPropertyStream  **ppStream,
            PFIO_CONTEXT            *phContentFile,
            IMailMsgNotify          *pNotify
            )
{
    HRESULT hrRes = S_OK;
    TCHAR   szStoreFileName[MAX_PATH << 1];
    DWORD   dwLength;

    _ASSERT(pMsg);
    _ASSERT(ppStream);
    _ASSERT(phContentFile);

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::AllocMessage");

    if (!m_fInitialized)
        return(E_FAIL);

    if (m_fIsShuttingDown)
    {
        DebugTrace((LPARAM)this, "Failing because shutting down");
        return(HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS));
    }

    if (!pMsg || !ppStream || !phContentFile)
        return(E_POINTER);

    do {

        // Get a file name
        dwLength = sizeof(szStoreFileName);
        hrRes = CDriverUtils::GetStoreFileName(
                    m_szQueueDirectory,
                    szStoreFileName,
                    &dwLength);
        if (FAILED(hrRes))
            return(hrRes);

        // Create the file
        hrRes = CDriverUtils::GetStoreFileFromPath(
                    szStoreFileName,
                    ppStream,
                    phContentFile,
                    TRUE,
                    m_fIsFAT,
                    pMsg,
                    m_guidInstance
                    );

    } while (hrRes == HRESULT_FROM_WIN32(ERROR_FILE_EXISTS));

    //
    // GetStoreFileFromPath can return S_NO_FIRST_COMMIT and no handle
    // treat this as an error.
    //
    if (S_NO_FIRST_COMMIT == hrRes) hrRes = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    if (FAILED(hrRes))
        return(hrRes);

    ((CNtfsPropertyStream *)*ppStream)->SetInfo(this);

    // OK, save the file name as a store driver context
    hrRes = CDriverUtils::SetMessageContext(
                pMsg,
                (LPBYTE)szStoreFileName,
                dwLength * sizeof(TCHAR));
    if (FAILED(hrRes))
    {
        // Release all file resources
        ReleaseContext(*phContentFile);
        DecCtr(m_ppoi, NTFSDRV_MSG_BODIES_OPEN);
        _VERIFY((*ppStream)->Release() == 0);
    } else {
        // Update counters
        IncCtr(m_ppoi, NTFSDRV_QUEUE_LENGTH);
        IncCtr(m_ppoi, NTFSDRV_NUM_ALLOCS);
        IncCtr(m_ppoi, NTFSDRV_MSG_BODIES_OPEN);
    }


    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::EnumMessages(
            IMailMsgEnumMessages    **ppEnum
            )
{
    HRESULT             hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::EnumMessages");

    if (!m_fInitialized)
        return(E_FAIL);

    if (m_fIsShuttingDown)
    {
        DebugTrace((LPARAM)this, "Failing because shutting down");
        return(HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS));
    }

    if (!ppEnum)
        return E_POINTER;

    hrRes = CoCreateInstance(
                CLSID_NtfsEnumMessages,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IMailMsgEnumMessages,
                (LPVOID *)ppEnum);
    if (SUCCEEDED(hrRes))
    {
        ((CNtfsEnumMessages *)(*ppEnum))->SetInfo(this);
        hrRes = ((CNtfsEnumMessages *)(*ppEnum))->SetStoreDirectory(
                    m_szQueueDirectory,
                    m_fIsFAT);
    }
    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::ReOpen(
            IMailMsgProperties      *pMsg,
            IMailMsgPropertyStream  **ppStream,
            PFIO_CONTEXT            *phContentFile,
            IMailMsgNotify          *pNotify
            )
{
    HRESULT hrRes = S_OK;
    TCHAR   szStoreFileName[MAX_PATH * 2];
    DWORD   dwLength = MAX_PATH * 2;

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::ReOpen");

    if (!m_fInitialized)
        return(E_FAIL);

    if (!pMsg)
        return E_POINTER;

    if (m_fIsShuttingDown)
    {
        // We allow reopen to occur when we are pending shutdown.
        // This gives a chance to reopen the streams and commit any
        // unchanged data
        DebugTrace((LPARAM)this, "ReOpening while shutting down ...");
    }

    // Now we have to load the file name from the context
    dwLength *= sizeof(TCHAR);
    hrRes = CDriverUtils::GetMessageContext(
                pMsg,
                (LPBYTE)szStoreFileName,
                &dwLength);
    if (FAILED(hrRes))
        return(hrRes);

    // Got the file name, just open the files
    hrRes = CDriverUtils::GetStoreFileFromPath(
                szStoreFileName,
                ppStream,
                phContentFile,
                FALSE,
                m_fIsFAT,
                pMsg);
    //
    // GetStoreFileFromPath can return S_NO_FIRST_COMMIT and no handle
    // treat this as an error.
    //
    if (S_NO_FIRST_COMMIT == hrRes) hrRes = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    if (SUCCEEDED(hrRes) && ppStream) {
        ((CNtfsPropertyStream *)*ppStream)->SetInfo(this);
    }

    if (SUCCEEDED(hrRes)) {
        if (phContentFile) IncCtr(m_ppoi, NTFSDRV_MSG_BODIES_OPEN);
    }


    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::ReAllocMessage(
            IMailMsgProperties      *pOriginalMsg,
            IMailMsgProperties      *pNewMsg,
            IMailMsgPropertyStream  **ppStream,
            PFIO_CONTEXT            *phContentFile,
            IMailMsgNotify          *pNotify
            )
{
    HRESULT hrRes = S_OK;
    TCHAR   szStoreFileName[MAX_PATH * 2];
    DWORD   dwLength = MAX_PATH * 2;

    IMailMsgPropertyStream  *pStream;
    PFIO_CONTEXT            hContentFile;

    _ASSERT(pOriginalMsg);
    _ASSERT(pNewMsg);
    _ASSERT(ppStream);
    _ASSERT(phContentFile);

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::ReAllocMessage");

    if (!m_fInitialized)
        return(E_FAIL);

    if (m_fIsShuttingDown)
    {
        DebugTrace((LPARAM)this, "Failing because shutting down");
        return(HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS));
    }

    // Now we have to load the file name from the context
    dwLength *= sizeof(TCHAR);
    hrRes = CDriverUtils::GetMessageContext(
                pOriginalMsg,
                (LPBYTE)szStoreFileName,
                &dwLength);
    if (FAILED(hrRes))
        return(hrRes);

    // Allocate a new message
    hrRes = AllocMessage(
                pNewMsg,
                0,
                &pStream,
                &hContentFile,
                NULL);
    if (FAILED(hrRes))
        return(hrRes);

    // Copy the content from original message to new message
    hrRes = pOriginalMsg->CopyContentToFile(
                hContentFile,
                NULL);
    if (SUCCEEDED(hrRes))
    {
        *ppStream = pStream;
        *phContentFile = hContentFile;
    }
    else
    {
        HRESULT myRes;

        // Delete on failure
        pStream->Release();
        ReleaseContext(hContentFile);
        DecCtr(m_ppoi, NTFSDRV_MSG_BODIES_OPEN);
        myRes = Delete(pNewMsg, NULL);
        _ASSERT(myRes);
    }
    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::Delete(
            IMailMsgProperties      *pMsg,
            IMailMsgNotify          *pNotify
            )
{
    HRESULT hrRes = S_OK;
    TCHAR   szStoreFileName[MAX_PATH * 2];
    TCHAR   szStoreFileNameStl[MAX_PATH * 2];
    DWORD   dwLength = MAX_PATH * 2;

    _ASSERT(pMsg);

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::Delete");

    if (!m_fInitialized)
        return(E_FAIL);

    if (!pMsg)
        return E_POINTER;

    if (m_fIsShuttingDown)
    {
        // We would allow deletes during shutdown
        DebugTrace((LPARAM)this, "Deleteing while shutting down ...");
    }

    // Now we have to load the file name from the context
    dwLength *= sizeof(TCHAR);
    hrRes = CDriverUtils::GetMessageContext(
                pMsg,
                (LPBYTE)szStoreFileName,
                &dwLength);
    if (FAILED(hrRes))
        return(hrRes);

    // Got the file name, delete the file
    // For FAT, we know we can force delete the stream, but we are not
    // so sure about the content file. So we always try to delete the
    // content file first, if it succeeds, we delete the stream file.
    // If it fails, we will keep the stream intact so we can at least
    // use the stream to debug what's going on.
    if (!DeleteFile(szStoreFileName)) {
        DWORD cRetries = 0;
        hrRes = HRESULT_FROM_WIN32(GetLastError());
        // in hotmail we've found that delete sometimes fails with
        // a sharing violation even though we've closed all handles.
        // in this case we try again
        for (cRetries = 0; 
             hrRes == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) && cRetries < 5; 
             cRetries++)
        {
            Sleep(0);
            if (DeleteFile(szStoreFileName)) {
                hrRes = S_OK;
            } else {
                hrRes = HRESULT_FROM_WIN32(GetLastError());
            } 
        }
        _ASSERT(SUCCEEDED(hrRes));
        ErrorTrace((LPARAM) this, 
                   "DeleteFile(%s) failed with %lu, cRetries=%lu, hrRes=%x", 
                   szStoreFileName, GetLastError(), cRetries, hrRes);
    } else if (m_fIsFAT) {
        // Wiped the content, now wipe the stream
        DWORD cRetries = 0;
        lstrcpy(szStoreFileNameStl, szStoreFileName);
        lstrcat(szStoreFileName, NTFS_FAT_STREAM_FILE_EXTENSION_1ST);
        if (!DeleteFile(szStoreFileName)) {
            hrRes = HRESULT_FROM_WIN32(GetLastError());
            for (cRetries = 0; 
                 hrRes == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) && cRetries < 5; 
                 cRetries++)
            {
                Sleep(0);
                if (DeleteFile(szStoreFileName)) {
                    hrRes = S_OK;
                } else {
                    hrRes = HRESULT_FROM_WIN32(GetLastError());
                } 
            }
            _ASSERT(SUCCEEDED(hrRes));
            ErrorTrace((LPARAM) this, 
                       "DeleteFile(%s) failed with %lu, cRetries=%lu, hrRes=%x", 
                       szStoreFileName, GetLastError(), cRetries, hrRes);
        }
        lstrcat(szStoreFileNameStl, NTFS_FAT_STREAM_FILE_EXTENSION_LIVE);
        // this can fail, since we don't always have a live stream
        DeleteFile(szStoreFileNameStl);
    }

    if (SUCCEEDED(hrRes)) {
        DecCtr(m_ppoi, NTFSDRV_QUEUE_LENGTH);
        IncCtr(m_ppoi, NTFSDRV_NUM_DELETES);
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::CloseContentFile(
            IMailMsgProperties      *pMsg,
            PFIO_CONTEXT            hContentFile
            )
{
    HRESULT hrRes = S_OK;

    _ASSERT(pMsg);
    _ASSERT(hContentFile!=NULL);

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::CloseContentFile");

    if (!m_fInitialized)
        return (E_FAIL);

    if (m_fIsShuttingDown)
    {
        // We would allow content files to be closed during shutdown
        DebugTrace((LPARAM)this, "Closing content file while shutting down ...");
    }

#ifdef DEBUG
    TCHAR szStoreFileName[MAX_PATH * 2];
    DWORD dwLength = MAX_PATH * 2;
    dwLength *= sizeof(TCHAR);
    _ASSERT(SUCCEEDED(CDriverUtils::GetMessageContext(pMsg,(LPBYTE)szStoreFileName,&dwLength)));
#endif

    ReleaseContext(hContentFile);
    DecCtr(m_ppoi, NTFSDRV_MSG_BODIES_OPEN);

    TraceFunctLeave();
    return (hrRes);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::Init(
            DWORD dwInstance,
            IUnknown *pBinding,
            IUnknown *pServer,
            DWORD dwReason,
            IUnknown **ppStoreDriver
            )
{
    HRESULT hrRes = S_OK;
    DWORD   dwLength = sizeof(m_szQueueDirectory);
    REFIID  iidStoreDriverBinding = GUID_NULL;
    IUnknown * pTempStoreDriver = NULL;

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::Init");

    // We will treat all dwReasons as equal ...
    //NK** : We need to treat binding change differently in order to set the correct
    //enumeration status - we do it before returning from here

    if (m_fInitialized)
        return(HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED));

    if (m_fIsShuttingDown)
        return(HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS));

    // Try to load the store directory
    DebugTrace((LPARAM)this, "Initializing instance %u", dwInstance);

    //Grab a lock for the duration of this function
    //
    CNtfsStoreDriver::LockList();
    pTempStoreDriver = CNtfsStoreDriver::LookupSinkInstance(dwInstance, iidStoreDriverBinding);

    if(pTempStoreDriver)
    {
        //Found a valid store driver
        pTempStoreDriver->AddRef();
        *ppStoreDriver = (IUnknown *)(ISMTPStoreDriver *)pTempStoreDriver;
        CNtfsStoreDriver::UnLockList();
        return S_OK;
    }


        DWORD BuffSize = sizeof(m_szQueueDirectory);

        // Get the SMTP server interface
        m_pSMTPServer = NULL;
        if (pServer &&
            !SUCCEEDED(pServer->QueryInterface(IID_ISMTPServer, (LPVOID *)&m_pSMTPServer)))
            m_pSMTPServer = NULL;

        // Read the metabase if we have a server, otherwise read from the registry
        if(m_pSMTPServer)
        {
            hrRes = m_pSMTPServer->ReadMetabaseString(MD_MAIL_QUEUE_DIR, (unsigned char *) m_szQueueDirectory, &BuffSize, FALSE);
            if (FAILED(hrRes))
            {
                //retry once, then fall through
                ErrorTrace((LPARAM)this, "failed to read queue directory from metabase -%x", hrRes);
                BuffSize = sizeof(m_szQueueDirectory);
                hrRes = m_pSMTPServer->ReadMetabaseString(MD_MAIL_QUEUE_DIR, (unsigned char *) m_szQueueDirectory, &BuffSize, FALSE);
            }
        }
        else
        {
            DebugTrace((LPARAM)this, "NTFSDRV Getting config from registry");
            hrRes = CDriverUtils::LoadStoreDirectory(
                                      dwInstance,
                                      m_szQueueDirectory,
                                      &dwLength);
            if (SUCCEEDED(hrRes))
            {
                // Deduce the queue directory
                lstrcat(m_szQueueDirectory, NTFS_QUEUE_DIRECTORY_SUFFIX);
            }
        }

        // return failure code if we failed to get a queue directory, to avoid message loss.
        if (FAILED(hrRes))
        {
            ErrorTrace((LPARAM)this, "CNtfsStoreDriver::Init failed -%x", hrRes);
            CNtfsStoreDriver::UnLockList();
            return hrRes;
        }
        // Detect the file system
        hrRes = CDriverUtils::IsStoreDirectoryFat(
                    m_szQueueDirectory,
                    &m_fIsFAT);

        m_fInitialized = TRUE;

        m_fIsShuttingDown = FALSE;
        m_dwInstance = dwInstance;
        m_lRefCount = 0;

        //NK** MAke binding GUID a member and start storing it

        DebugTrace((LPARAM)this, "Queue directory: %s", m_szQueueDirectory);

        // Return a store driver only if we succeeded initialization
        if (ppStoreDriver)
        {
            *ppStoreDriver = (IUnknown *)(ISMTPStoreDriver *)this;
            AddRef();

            // if we are the first instance then initialize perfmon
            if (IsListEmpty(&sm_ListHead)) {
                InitializePerformanceStatistics();
            }

            CNtfsStoreDriver::InsertSinkInstance(&m_InstLEntry);
        }

    WCHAR wszPerfInstanceName[MAX_INSTANCE_NAME];
    _snwprintf(wszPerfInstanceName, MAX_INSTANCE_NAME, L"SMTP #%u", dwInstance);
    wszPerfInstanceName[MAX_INSTANCE_NAME-1] = L'\0';
    m_ppoi = CreatePerfObjInstance(wszPerfInstanceName);

    TraceFunctLeaveEx((LPARAM)this);

    // Always return S_OK
    CNtfsStoreDriver::UnLockList();
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::PrepareForShutdown(
            DWORD dwReason
            )
{
    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::PrepareForShutdown");

    m_fIsShuttingDown = TRUE;

    TraceFunctLeaveEx((LPARAM)this);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::Shutdown(
            DWORD dwReason
            )
{
    DWORD   dwWaitTime = 0;
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::Shutdown");

    m_fIsShuttingDown = TRUE;

    _ASSERT(m_lRefCount == 0);

#if 0
    // BUG - 80960
    // Now wait for all our references to come back
    while (m_lRefCount)
    {
        _ASSERT(m_lRefCount >= 0);
        Sleep(100);
        dwWaitTime += 100;
        DebugTrace((LPARAM)this,
                "[%u ms] Waiting for objects to be released (%u outstanding)",
                dwWaitTime, m_lRefCount);
    }
#endif

    if(m_pSMTPServer)
    {
        m_pSMTPServer->Release();
        m_pSMTPServer = NULL;
    }

    if (m_ppoi) {
        delete m_ppoi;
        m_ppoi = NULL;
    }

    CNtfsStoreDriver::LockList();
    hr = CNtfsStoreDriver::RemoveSinkInstance((IUnknown *)(ISMTPStoreDriver *)this);
    // if we are the last instance then shutdown perfmon
    if (IsListEmpty(&sm_ListHead)) {
        ShutdownPerformanceStatistics();
    }
    CNtfsStoreDriver::UnLockList();
    if(FAILED(hr))
    {
        //We failed to remove this sink from the global list
        _ASSERT(0);
    }

    m_fInitialized = FALSE;
    m_fIsShuttingDown = FALSE;

    TraceFunctLeaveEx((LPARAM)this);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::LocalDelivery(
            IMailMsgProperties *pMsg,
            DWORD dwRecipCount,
            DWORD *pdwRecipIndexes,
            IMailMsgNotify *pNotify
            )
{
    HRESULT hrRes = S_OK;
    TCHAR   szStoreFileName[MAX_PATH * 2];
    TCHAR   szCopyFileName[MAX_PATH * 2];
    LPTSTR  pszFileName;
    DWORD   dwLength = MAX_PATH * 2;

    _ASSERT(pMsg);

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::LocalDelivery");

    TraceFunctLeaveEx((LPARAM)this);
    return (hrRes);
}

static void LogEventCorruptMessage(CEventLogWrapper *pEventLog,
                                   IMailMsgProperties *pMsg,
                                   char *pszQueueDirectory,
                                   HRESULT hrLog)
{
    HRESULT hr;
    char szMessageFile[MAX_PATH];
    DWORD dwLength = sizeof(szMessageFile);
    const char *rgszSubstrings[] = { szMessageFile, pszQueueDirectory };

    hr = CDriverUtils::GetMessageContext(pMsg, (LPBYTE) szMessageFile, &dwLength);
    if (FAILED(hr)) {
        strcpy(szMessageFile, "<unknown>");
    }

    pEventLog->LogEvent(NTFSDRV_INVALID_FILE_IN_QUEUE,
                        2,
                        rgszSubstrings,
                        EVENTLOG_WARNING_TYPE,
                        hrLog,
                        LOGEVENT_DEBUGLEVEL_MEDIUM,
                        szMessageFile,
                        LOGEVENT_FLAG_ALWAYS);
}

static void DeleteNeverAckdMessage(CEventLogWrapper *pEventLog,
                                   IMailMsgProperties *pMsg,
                                   char *pszQueueDirectory,
                                   HRESULT hrLog,
                                   BOOL fIsFAT)
{
    HRESULT hr;
    char szMessageFile[MAX_PATH+50];
    char szMessageFileSTL[MAX_PATH+50];
    DWORD dwLength = MAX_PATH;
    TraceFunctEnter("DeleteNeverAckdMessage");

    hr = CDriverUtils::GetMessageContext(pMsg, (LPBYTE) szMessageFile, &dwLength);
    if (FAILED(hr)) {
        _ASSERT(FALSE && "GetMessageContext failed");
        return;
    }

    DebugTrace((LPARAM) 0, "Deleting: %s\n", szMessageFile);
    DeleteFile(szMessageFile);
    if (fIsFAT) {
        // Wiped the content, now wipe the stream
        lstrcpy(szMessageFileSTL, szMessageFile);
        lstrcat(szMessageFile, NTFS_FAT_STREAM_FILE_EXTENSION_1ST);
        DeleteFile(szMessageFile);
        lstrcat(szMessageFileSTL, NTFS_FAT_STREAM_FILE_EXTENSION_LIVE);
        // this can fail, since we don't always have a live stream
        DeleteFile(szMessageFileSTL);
    }
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::EnumerateAndSubmitMessages(
            IMailMsgNotify *pNotify
            )
{
    HRESULT hrRes = S_OK;

    IMailMsgEnumMessages    *pEnum = NULL;

    TraceFunctEnterEx((LPARAM)this, "CNtfsStoreDriver::EnumerateAndSubmitMessages");

    if (!m_fInitialized)
        return (E_FAIL);

    if (m_fIsShuttingDown)
        goto Shutdown;

    // Assert we got all the pieces ...
    if (!m_pSMTPServer) return S_FALSE;

    // Now, get an enumerator from our peer IMailMsgStoreDriver and
    // start enumerating away ...
    hrRes = EnumMessages(&pEnum);
    if (SUCCEEDED(hrRes))
    {
        IMailMsgProperties      *pMsg = NULL;
        IMailMsgPropertyStream  *pStream = NULL;
        PFIO_CONTEXT            hContentFile = NULL;

        do
        {
            // Check for shut down
            if (m_fIsShuttingDown)
                goto Shutdown;

            // Create an instance of the message object, note
            // we reuse messages from a failed attempt
            if (!pMsg)
            {
                hrRes = CoCreateInstance(
                            CLSID_MsgImp,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IMailMsgProperties,
                            (LPVOID *)&pMsg);

                // Next, check if we are over the inbound cutoff limit. If so, we will release the message
                // and not proceed.
                if (SUCCEEDED(hrRes))
                {
                    DWORD   dwCreationFlags;
                    hrRes = pMsg->GetDWORD(
                                IMMPID_MPV_MESSAGE_CREATION_FLAGS,
                                &dwCreationFlags);
                    if (FAILED(hrRes) ||
                        (dwCreationFlags & MPV_INBOUND_CUTOFF_EXCEEDED))
                    {
                        // If we fail to get this property of if the inbound cutoff
                        // exceeded flag is set, discard the message and return failure
                        if (SUCCEEDED(hrRes))
                        {
                            DebugTrace((LPARAM)this, "Failing because inbound cutoff reached");
                            hrRes = E_OUTOFMEMORY;
                        }
                        pMsg->Release();
                        pMsg = NULL;
                    }
                }

                // Now if we are out of memory, we would probably
                // keep failing, so lets just return and get on with
                // delivery
                if (!SUCCEEDED(hrRes))
                {
                    break;
                }
            }

            // Get the next message
            hrRes = pEnum->Next(
                        pMsg,
                        &pStream,
                        &hContentFile,
                        NULL);
            // Next() cleans up its own mess if it fails
            if (SUCCEEDED(hrRes))
            {
                DWORD   dwStreamSize = 0;

                IncCtr(m_ppoi, NTFSDRV_MSG_BODIES_OPEN);
                DebugTrace((LPARAM) this, "Next returned success\n");

                // We delete streams which are too short to contain
                // a master header
                hrRes = pStream->GetSize(pMsg, &dwStreamSize, NULL);
                DebugTrace((LPARAM) this, "GetSize returned %x, %x\n", dwStreamSize, hrRes);
                if (!SUCCEEDED(hrRes) || dwStreamSize < 1024)
                {
                    pStream->Release();
                    ReleaseContext(hContentFile);
                    DeleteNeverAckdMessage(g_pEventLog,
                                           pMsg,
                                           m_szQueueDirectory,
                                           hrRes,
                                           m_fIsFAT);
                    DecCtr(m_ppoi, NTFSDRV_MSG_BODIES_OPEN);
                    continue;
                }

                DebugTrace((LPARAM) this, "Submitting to mailmsg\n");
                // Submit the message, this call will actually do the
                // bind to the store driver
                if (m_fIsShuttingDown)
                    hrRes = E_FAIL;
                else
                {
                    IMailMsgBind    *pBind = NULL;

                    // Bind and submit
                    hrRes = pMsg->QueryInterface(
                                IID_IMailMsgBind,
                                (LPVOID *)&pBind);
                    if (SUCCEEDED(hrRes))
                    {
                        hrRes = pBind->BindToStore(
                                    pStream,
                                    (IMailMsgStoreDriver *)this,
                                    hContentFile);
                        pBind->Release();
                        if (SUCCEEDED(hrRes))
                        {
                            // Relinquish the extra refcount added by bind(2 -> 1)
                            pStream->Release();

                            hrRes = m_pSMTPServer->SubmitMessage(
                                        pMsg);
                            if (!SUCCEEDED(hrRes))
                            {

                                // Relinquish the usage count added by bind (1 -> 0)
                                IMailMsgQueueMgmt   *pMgmt = NULL;

                                hrRes = pMsg->QueryInterface(
                                            IID_IMailMsgQueueMgmt,
                                            (LPVOID *)&pMgmt);
                                if (SUCCEEDED(hrRes))
                                {
                                    pMgmt->ReleaseUsage();
                                    pMgmt->Release();
                                }
                                else
                                {
                                    _ASSERT(hrRes == S_OK);
                                }
                            } else {
                                // update counter
                                IncCtr(m_ppoi, NTFSDRV_QUEUE_LENGTH);
                                IncCtr(m_ppoi, NTFSDRV_NUM_ENUMERATED);
                            }
                            // Whether or not the message is submitted, release our
                            // refcount
                            pMsg->Release();
                            pMsg = NULL;
                        }
                    }
                    else
                    {
                        _ASSERT(hrRes == S_OK);
                    }
                }
                if (!SUCCEEDED(hrRes))
                {
                    // Clean up the mess ...
                    pStream->Release();
                    ReleaseContext(hContentFile);
                    DecCtr(m_ppoi, NTFSDRV_MSG_BODIES_OPEN);

                    if (m_fIsShuttingDown)
                        goto Shutdown;

                    //
                    // log an event about the message being corrupt
                    //
                    LogEventCorruptMessage(g_pEventLog,
                                           pMsg,
                                           m_szQueueDirectory,
                                           hrRes);

                    // We might want to discard this message and go on
                    // with other messages. We will re-use this message
                    // object upstream.
                    hrRes = S_OK;
                }
                else
                {
                    // Make sure we will not accidentally delete or
                    // reuse the message
                    pMsg = NULL;
                }
            }

        } while (SUCCEEDED(hrRes));

        // We distinguish the successful end of enumeration
        if (hrRes == HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES))
            hrRes = S_OK;

        // Release the enumerator, of course ...
        pEnum->Release();

        // Release any residual messages
        if (pMsg)
            pMsg->Release();
    }

    TraceFunctLeaveEx((LPARAM)this);
    return (S_OK);

Shutdown:

    // Release the enumerator, of course ...
    if(pEnum)
        pEnum->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return (HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS));
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::IsCacheable()
{
    // signal that only one instance of the sink should be created
    return (S_OK);
}

HRESULT STDMETHODCALLTYPE CNtfsStoreDriver::ValidateMessageContext(
                                        	BYTE *pbContext,
                                        	DWORD cbContext)
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CMailMsgEnumMessages
//

CNtfsEnumMessages::CNtfsEnumMessages()
{
    *m_szEnumPath = _T('\0');
    m_hEnum = INVALID_HANDLE_VALUE;
    m_pDriver = NULL;
    m_fIsFAT = TRUE; // Assume we are FAT until we discover otherwise
}

CNtfsEnumMessages::~CNtfsEnumMessages()
{
    *m_szEnumPath = _T('\0');
    if (m_hEnum != INVALID_HANDLE_VALUE)
    {
        if (!FindClose(m_hEnum))
        {
            _ASSERT(FALSE);
        }
        m_hEnum = INVALID_HANDLE_VALUE;
    }
    if (m_pDriver)
        m_pDriver->ReleaseUsage();
}


HRESULT CNtfsEnumMessages::SetStoreDirectory(
            LPTSTR  szStoreDirectory,
            BOOL    fIsFAT
            )
{
    if (!szStoreDirectory)
        return(E_FAIL);

    // Mark the file system
    m_fIsFAT = fIsFAT;

    if (lstrlen(szStoreDirectory) >= MAX_PATH)
    {
        _ASSERT(FALSE);
        return(E_FAIL);
    }

    lstrcpy(m_szEnumPath, szStoreDirectory);
    lstrcat(m_szEnumPath, NTFS_STORE_FILE_PREFIX);
    lstrcat(m_szEnumPath, NTFS_STORE_FILE_WILDCARD);
    lstrcat(m_szEnumPath, NTFS_STORE_FILE_EXTENSION);
    lstrcpy(m_szStorePath, szStoreDirectory);
    lstrcat(m_szStorePath, NTFS_STORE_BACKSLASH);
    return(S_OK);
}

DECLARE_STD_IUNKNOWN_METHODS(NtfsEnumMessages, IMailMsgEnumMessages)

HRESULT STDMETHODCALLTYPE CNtfsEnumMessages::Next(
            IMailMsgProperties      *pMsg,
            IMailMsgPropertyStream  **ppStream,
            PFIO_CONTEXT            *phContentFile,
            IMailMsgNotify          *pNotify
            )
{
    HRESULT hrRes = S_OK;
    TCHAR   szFQPN[MAX_PATH * 2];

    if (!pMsg || !ppStream || !phContentFile) return E_POINTER;

    BOOL fFoundFile = FALSE;
    TraceFunctEnter("CNtfsEnumMessages::Next");

    while (!fFoundFile) {
        _ASSERT(m_pDriver);
        if (m_pDriver->IsShuttingDown())
            return(HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS));

        if (m_hEnum == INVALID_HANDLE_VALUE)
        {
            m_hEnum = FindFirstFile(m_szEnumPath, &m_Data);
            if (m_hEnum == INVALID_HANDLE_VALUE)
            {
                return(HRESULT_FROM_WIN32(GetLastError()));
            }
        }
        else
        {
            if (!FindNextFile(m_hEnum, &m_Data))
            {
                return(HRESULT_FROM_WIN32(GetLastError()));
            }
        }

        // Digest the data ...
        while (m_Data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            // Make sure it's not a directory
            if (!FindNextFile(m_hEnum, &m_Data))
            {
                return(HRESULT_FROM_WIN32(GetLastError()));
            }
        }

        // OK, got a file, get the content handle and property stream
        lstrcpy(szFQPN, m_szStorePath);
        lstrcat(szFQPN, m_Data.cFileName);
        hrRes = CDriverUtils::GetStoreFileFromPath(
                    szFQPN,
                    ppStream,
                    phContentFile,
                    FALSE,
                    m_fIsFAT,
                    pMsg);
        if (hrRes == S_NO_FIRST_COMMIT) {
            DebugTrace((LPARAM) this, "Got no first commit, doing a delete\n");
            // this means that we never ACK'd the message.  silently delete it
            if (*ppStream) (*ppStream)->Release();
            ReleaseContext(*phContentFile);
            DeleteFile(szFQPN);
            if (m_fIsFAT) {
                TCHAR szFileName[MAX_PATH * 2];
                lstrcpy(szFileName, szFQPN);
                lstrcat(szFileName, NTFS_FAT_STREAM_FILE_EXTENSION_1ST);
                DeleteFile(szFileName);
                lstrcpy(szFileName, szFQPN);
                lstrcat(szFileName, NTFS_FAT_STREAM_FILE_EXTENSION_LIVE);
                DeleteFile(szFileName);
            }
        } else if (FAILED(hrRes)) {
            // couldn't open the file.  try the next one
            DebugTrace((LPARAM) this, "GetStoreFileFromPath returned %x\n", hrRes);
        } else {
            CNtfsPropertyStream *pNtfsStream =
                (CNtfsPropertyStream *) (*ppStream);

            // skip over items made with this instance of the ntfs store driver
            if (pNtfsStream->GetInstanceGuid() ==
                m_pDriver->GetInstanceGuid())
            {
                (*ppStream)->Release();
                ReleaseContext(*phContentFile);
            } else {
                fFoundFile = TRUE;
            }
        }
    }

    // We got the handles successfully opened, now write the filename
    // as the store driver context
    hrRes = CDriverUtils::SetMessageContext(
                pMsg,
                (LPBYTE)szFQPN,
                (lstrlen(szFQPN) + 1) * sizeof(TCHAR));
    if (FAILED(hrRes))
    {
        // Release all file resources
        ReleaseContext(*phContentFile);
        _VERIFY((*ppStream)->Release() == 0);
    }
    else
    {
        ((CNtfsPropertyStream *)(*ppStream))->SetInfo(m_pDriver);
    }

    return(hrRes);
}


/////////////////////////////////////////////////////////////////////////////
// CNtfsPropertyStream
//

CNtfsPropertyStream::CNtfsPropertyStream()
{
    m_hStream = INVALID_HANDLE_VALUE;
    m_pDriver = NULL;
    m_fValidation = FALSE;
    // this will make us fail writeblocks if they don't call startwriteblocks
    // first
    m_hrStartWriteBlocks = E_FAIL;
}

CNtfsPropertyStream::~CNtfsPropertyStream()
{
    if (m_hStream != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hStream);
        m_hStream = INVALID_HANDLE_VALUE;
    }
    if (m_pDriver) {
        DecCtr((m_pDriver->m_ppoi), NTFSDRV_MSG_STREAMS_OPEN);
        m_pDriver->ReleaseUsage();
    }
}

DECLARE_STD_IUNKNOWN_METHODS(NtfsPropertyStream, IMailMsgPropertyStream)

//
// IMailMsgPropertyStream
//
HRESULT STDMETHODCALLTYPE CNtfsPropertyStream::GetSize(
            IMailMsgProperties  *pMsg,
            DWORD           *pdwSize,
            IMailMsgNotify  *pNotify
            )
{
    DWORD   dwHigh, dwLow;
    DWORD   cStreamOffset = m_fStreamHasHeader ? STREAM_OFFSET : 0;

    _ASSERT(m_pDriver || m_fValidation);
    if (!m_fValidation && (!m_pDriver || m_pDriver->IsShuttingDown()))
        return(HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS));

    if (m_hStream == INVALID_HANDLE_VALUE)
        return(E_FAIL);

    if (!pdwSize) return E_POINTER;

    dwLow = GetFileSize(m_hStream, &dwHigh);
    if (dwHigh)
        return(HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW));

    *pdwSize = dwLow - cStreamOffset;
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CNtfsPropertyStream::ReadBlocks(
            IMailMsgProperties  *pMsg,
            DWORD               dwCount,
            DWORD               *pdwOffset,
            DWORD               *pdwLength,
            BYTE                **ppbBlock,
            IMailMsgNotify      *pNotify
            )
{
    DWORD   dwSizeRead;
    DWORD   dwStreamSize;
    DWORD   dwOffsetToRead;
    DWORD   dwLengthToRead;
    HRESULT hrRes = S_OK;
    DWORD   cStreamOffset = m_fStreamHasHeader ? STREAM_OFFSET : 0;

    TraceFunctEnterEx((LPARAM)this, "CNtfsPropertyStream::ReadBlocks");

    if (m_hStream == INVALID_HANDLE_VALUE)
        return(E_FAIL);

    if (!pdwOffset || !pdwLength || !ppbBlock) {
        return E_POINTER;
    }

    if (!m_pDriver && !m_fValidation) {
        return E_UNEXPECTED;
    }

    _ASSERT(m_pDriver || m_fValidation);
    if (m_pDriver && m_pDriver->IsShuttingDown())
    {
        DebugTrace((LPARAM)this, "Reading while shutting down ...");
    }

    // Need to get the file size to determine if there is enough bytes
    // to read for each block. Note that WriteBlocks are to be serialzed so
    // ReadBlocks and WriteBlocks should not be overlapped.
    dwStreamSize = GetFileSize(m_hStream, NULL);
    if (dwStreamSize == 0xffffffff)
    {
        hrRes = HRESULT_FROM_WIN32(GetLastError());
        if (hrRes == S_OK)
            hrRes = STG_E_READFAULT;
        ErrorTrace((LPARAM)this, "Failed to get size of stream (%08x)", hrRes);
        return(hrRes);
    }

    for (DWORD i = 0; i < dwCount; i++, pdwOffset++, pdwLength++, ppbBlock++)
    {
        // For each block, check beforehand that we are not reading past
        // the end of the file. Make sure to be weary about overflow cases
        dwOffsetToRead = (*pdwOffset) + cStreamOffset;
        dwLengthToRead = *pdwLength;
        if ((dwOffsetToRead > dwStreamSize) ||
            (dwOffsetToRead > (dwOffsetToRead + dwLengthToRead)) ||
            ((dwOffsetToRead + dwLengthToRead) > dwStreamSize))
        {
            // Insufficient bytes, abort immediately
            ErrorTrace((LPARAM)this, "Insufficient bytes: Read(%u, %u); Size = %u",
                        dwOffsetToRead, dwLengthToRead, dwStreamSize);
            hrRes = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
            break;
        }

        if (SetFilePointer(
                    m_hStream,
                    dwOffsetToRead,
                    NULL,
                    FILE_BEGIN) == 0xffffffff)
        {
            hrRes = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        if (!ReadFile(
                    m_hStream,
                    *ppbBlock,
                    dwLengthToRead,
                    &dwSizeRead,
                    NULL))
        {
            hrRes = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
        else if (dwSizeRead != dwLengthToRead)
        {
            hrRes = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
            break;
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

HRESULT CNtfsPropertyStream::SetHandle(HANDLE			   hStream,
				                       GUID			       guidInstance,
                                       BOOL                fLiveStream,
                                       IMailMsgProperties  *pMsg)
{
    TraceFunctEnter("CNtfsPropertyStream::SetHandle");

    if (hStream == INVALID_HANDLE_VALUE) return(E_FAIL);
    m_hStream = hStream;
    DWORD dw;
    NTFS_STREAM_HEADER header;

    //
    // if guidInstance is non-NULL then we are dealing with a fresh
    // stream and need to write the header block
    //
    if (guidInstance != GUID_NULL) {
        DebugTrace((LPARAM) this, "writing NTFSDRV header");
        header.dwSignature = STREAM_SIGNATURE_PRECOMMIT;
        header.dwVersion = 1;
        header.guidInstance = guidInstance;
        if (!WriteFile(m_hStream, &header, sizeof(header), &dw, NULL)) {
            return HRESULT_FROM_WIN32(GetLastError());
        }
        m_fStreamHasHeader = TRUE;
        m_guidInstance = guidInstance;
        m_cCommits = 0;
    } else {
        DebugTrace((LPARAM) this, "reading NTFSDRV header, fLiveStream = %lu", fLiveStream);

        // if we are working with :PROPERTIES then we want to set the
        // commit count to 1 so that the next set of writes will go to
        // :PROPERTIES-LIVE
        m_cCommits = (fLiveStream) ? 2 : 1;

        // read the header.  if we can't read it, or there aren't enough
        // bytes to read it, then assume that the header wasn't fully
        // written out.
        if (!ReadFile(m_hStream, &header, sizeof(header), &dw, NULL) ||
            dw != sizeof(header))
        {
            header.dwSignature = STREAM_SIGNATURE_PRECOMMIT;
        }

        // act according to what we find in the signature
        switch (header.dwSignature) {
            case STREAM_SIGNATURE: {
                DebugTrace((LPARAM) this, "signature is valid");
                // the signature (and thus the stream) is valid
                m_fStreamHasHeader = TRUE;
                m_guidInstance = header.guidInstance;
                break;
            }
            case STREAM_SIGNATURE_PRECOMMIT: {
                DebugTrace((LPARAM) this, "signature is STREAM_SIGNATURE_PRECOMMIT");
                // a commit was never completed
                return S_NO_FIRST_COMMIT;
                break;
            }
            case STREAM_SIGNATURE_INVALID: {
                DebugTrace((LPARAM) this, "signature is STREAM_SIGNATURE_INVALID");
                // the valid-stream signature was never written
                IMailMsgValidate *pValidate = NULL;
                HRESULT hr;

                // assume that the stream is valid, and go through a full
                // check
                m_fStreamHasHeader = TRUE;
                m_guidInstance = header.guidInstance;

                // this flag allows the read stream operations to take place
                // before the stream is fully setup
                m_fValidation = TRUE;

                // validate stream can only be trusted on the first
                // property stream.  this is because it can detect
                // truncated streams, but not streams with corrupted
                // properties.  the first stream (:PROPERTIES) can be
                // truncated, but not corrupted.
                //
                // if we see the invalid signature on a :PROPERTIES-LIVE
                // stream then we will always assume that it is corrupted
                // and fall back to the initial stream.
                //
                // call into mailmsg to see if the stream is valid.  if
                // it isn't then we won't allow it to be loaded
                DebugTrace((LPARAM) this, "Calling ValidateStream\n");
                if (fLiveStream ||
                    FAILED(pMsg->QueryInterface(IID_IMailMsgValidate,
                                                (void **) &pValidate)) ||
                    FAILED(pValidate->ValidateStream(this)))
                {
                    DebugTrace((LPARAM) this, "Stream contains invalid data");
                    m_fStreamHasHeader = FALSE;
                    m_guidInstance = GUID_NULL;
                    if (pValidate) pValidate->Release();
                    return S_INVALIDSTREAM;
                }

                // we are done with the validation routines
                if (pValidate) pValidate->Release();
                m_fValidation = FALSE;

                DebugTrace((LPARAM) this, "Stream contains valid data");
                break;
            }
            default: {
                // if it is anything else then it could be a file with
                // no header (older builds generated these) or it could be
                // invalid data.  mailmsg will figure it out.
                m_fStreamHasHeader = FALSE;
                m_guidInstance = GUID_NULL;

                DebugTrace((LPARAM) this, "Unknown signature %x on stream",
                    header.dwSignature);
            }
        }
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CNtfsPropertyStream::StartWriteBlocks(
            IMailMsgProperties  *pMsg,
            DWORD               cBlocksToWrite,
            DWORD               cBytesToWrite)
{
    TraceFunctEnter("CNtfsPropertyStream::StartWriteBlocks");

    NTFS_STREAM_HEADER header;
    DWORD dw;
    m_hrStartWriteBlocks = S_OK;

    // if we have seen one full commit, then fork the stream and start
    // writing to the live stream
    if (m_cCommits == 1) {
        char szLiveStreamFilename[MAX_PATH * 2];
        BOOL fIsFAT = m_pDriver->IsFAT();
        char szFatLiveStreamExtension[] = NTFS_FAT_STREAM_FILE_EXTENSION_LIVE;
        char szNtfsLiveStreamExtension[] = NTFS_STORE_FILE_PROPERTY_STREAM_LIVE;
        const DWORD cCopySize = 64 * 1024;

        // get the filename of the message from the mailmsg object
        //
        // we need to save space in szLiveStreamFilename for the largest
        // extension that we might tack on
        DWORD dwLength = sizeof(char) * ((MAX_PATH * 2) -
                    max(sizeof(szNtfsLiveStreamExtension),
                        sizeof(szFatLiveStreamExtension)));
        m_hrStartWriteBlocks = CDriverUtils::GetMessageContext(pMsg,
                                             (LPBYTE) szLiveStreamFilename,
                                             &dwLength);
        if (FAILED(m_hrStartWriteBlocks)) {
            ErrorTrace((LPARAM) this,
                       "GetMessageContext failed with %x",
                       m_hrStartWriteBlocks);
            TraceFunctLeave();
            return m_hrStartWriteBlocks;
        }

        // allocate memory up front that will be used for copying the
        // streams
        BYTE *lpb = new BYTE[cCopySize];
        if (lpb == NULL) {
            m_hrStartWriteBlocks = E_OUTOFMEMORY;
            ErrorTrace((LPARAM) this, "pvMalloc failed to allocate 64k");
            TraceFunctLeave();
            return m_hrStartWriteBlocks;
        }

        // we know that we have enough space for the strcats because
        // we saved space for it in the GetMessageContext call above
        strcat(szLiveStreamFilename,
            (m_pDriver->IsFAT()) ? szFatLiveStreamExtension :
                                   szNtfsLiveStreamExtension);

        // open the new stream
        HANDLE hLiveStream = CreateFile(szLiveStreamFilename,
                                        GENERIC_READ | GENERIC_WRITE,
                                        FILE_SHARE_READ,
                                        NULL,
                                        CREATE_ALWAYS,
                                        FILE_FLAG_SEQUENTIAL_SCAN,
                                        NULL);
        if (hLiveStream == INVALID_HANDLE_VALUE) {
            delete[] (lpb);
            ErrorTrace((LPARAM) this,
                "CreateFile(%s) failed with %lu",
                szLiveStreamFilename,
                GetLastError());
            m_hrStartWriteBlocks = HRESULT_FROM_WIN32(GetLastError());
            TraceFunctLeave();
            return m_hrStartWriteBlocks;
        }

        // copy the data between the two streams
        BOOL fCopyFailed = FALSE;
        DWORD i = 0, cRead = cCopySize, cWritten;
        SetFilePointer(m_hStream, 0, NULL, FILE_BEGIN);
        while (!fCopyFailed && cRead == cCopySize) {
            if (ReadFile(m_hStream,
                         lpb,
                         cCopySize,
                         &cRead,
                         NULL))
            {
                // if this is the first block then we will touch the
                // signature to mark it as invalid.  it will get
                // rewritten as valid once this commit is complete
                if (i == 0) {
                    DWORD *pdwSignature = (DWORD *) lpb;
                    if (*pdwSignature == STREAM_SIGNATURE) {
                        *pdwSignature = STREAM_SIGNATURE_PRECOMMIT;
                    }
                }
                if (WriteFile(hLiveStream,
                              lpb,
                              cRead,
                              &cWritten,
                              NULL))
                {
                    _ASSERT(cWritten == cRead);
                    fCopyFailed = (cWritten != cRead);
                    if (fCopyFailed) {
                        SetLastError(ERROR_WRITE_FAULT);
                        ErrorTrace((LPARAM) this,
                            "WriteFile didn't write enough bytes"
                            "cWritten = %lu, cRead = %lu",
                            cWritten, cRead);
                    }
                } else {
                    fCopyFailed = TRUE;
                    ErrorTrace((LPARAM) this, "WriteFile failed with %lu",
                        GetLastError());
                }
            } else {
                ErrorTrace((LPARAM) this, "ReadFile failed with %lu",
                    GetLastError());
                fCopyFailed = TRUE;
            }
            i++;
        }

        delete[] (lpb);

        if (fCopyFailed) {
            // there isn't any way to delete the incomplete stream here.
            // however we gave it an invalid signature above, so it won't
            // be loaded during enumeration
            CloseHandle(hLiveStream);

            m_hrStartWriteBlocks = HRESULT_FROM_WIN32(GetLastError());
            TraceFunctLeave();
            return m_hrStartWriteBlocks;
        }

        // close the handle to the current stream and point the stream handle
        // to the new one
        CloseHandle(m_hStream);
        m_hStream = hLiveStream;
    } else {
	    header.dwSignature = STREAM_SIGNATURE_INVALID;
        if (m_fStreamHasHeader) {
            if (SetFilePointer(m_hStream, 0, NULL, FILE_BEGIN) == 0) {
                if (!WriteFile(m_hStream, &header, sizeof(header.dwSignature), &dw, NULL)) {
                    m_hrStartWriteBlocks = HRESULT_FROM_WIN32(GetLastError());
                }
            } else {
                m_hrStartWriteBlocks = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    TraceFunctLeave();
    return m_hrStartWriteBlocks;
}

HRESULT STDMETHODCALLTYPE CNtfsPropertyStream::EndWriteBlocks(
            IMailMsgProperties  *pMsg)
{
    HRESULT hr = S_OK;
    DWORD dw;
    NTFS_STREAM_HEADER header;

    _ASSERT(SUCCEEDED(m_hrStartWriteBlocks));
    if (FAILED(m_hrStartWriteBlocks)) {
        return m_hrStartWriteBlocks;
    }

	header.dwSignature = STREAM_SIGNATURE;
    if (m_fStreamHasHeader) {
        if (SetFilePointer(m_hStream, 0, NULL, FILE_BEGIN) == 0) {
            if (!WriteFile(m_hStream, &header, sizeof(header.dwSignature), &dw, NULL)) {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        } else {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    if (hr == S_OK) m_cCommits++;
    return hr;
}

HRESULT STDMETHODCALLTYPE CNtfsPropertyStream::CancelWriteBlocks(
            IMailMsgProperties  *pMsg)
{
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CNtfsPropertyStream::WriteBlocks(
            IMailMsgProperties  *pMsg,
            DWORD               dwCount,
            DWORD               *pdwOffset,
            DWORD               *pdwLength,
            BYTE                **ppbBlock,
            IMailMsgNotify      *pNotify
            )
{
    DWORD   dwSizeWritten;
    HRESULT hrRes = S_OK;
    DWORD   cStreamOffset = m_fStreamHasHeader ? STREAM_OFFSET : 0;

    TraceFunctEnterEx((LPARAM)this, "CNtfsPropertyStream::WriteBlocks");

    if (!pdwOffset || !pdwLength || !ppbBlock) {
        return E_POINTER;
    }

    if (!m_pDriver) {
        return E_UNEXPECTED;
    }

    _ASSERT(m_pDriver);
    if (m_pDriver->IsShuttingDown())
    {
        DebugTrace((LPARAM)this, "Writing while shutting down ...");
    }

    if (m_hStream == INVALID_HANDLE_VALUE)
        return(E_FAIL);

    if (FAILED(m_hrStartWriteBlocks))
        return m_hrStartWriteBlocks;

    for (DWORD i = 0; i < dwCount; i++, pdwOffset++, pdwLength++, ppbBlock++)
    {
        if (SetFilePointer(
                    m_hStream,
                    (*pdwOffset) + cStreamOffset,
                    NULL,
                    FILE_BEGIN) == 0xffffffff)
        {
            hrRes = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        if (!WriteFile(
                    m_hStream,
                    *ppbBlock,
                    *pdwLength,
                    &dwSizeWritten,
                    NULL) ||
            (dwSizeWritten != *pdwLength))
        {
            hrRes = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
    }

    if (SUCCEEDED(hrRes))
    {
        if (!FlushFileBuffers(m_hStream))
            hrRes = HRESULT_FROM_WIN32(GetLastError());
    }
    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\storedrv\dllmain.cpp ===
// dllmain.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f imsgps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "filehc.h"
#include "mailmsg.h"

#include "seo.h"

#include "ntfs.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_NtfsStoreDriver, CNtfsStoreDriver)
    OBJECT_ENTRY(CLSID_NtfsEnumMessages, CNtfsEnumMessages)
    OBJECT_ENTRY(CLSID_NtfsPropertyStream, CNtfsPropertyStream)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TrHeapCreate();
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);

        //Initialize the critical section used to control access to the
        //global ntfsstore driver instance list
        InitializeCriticalSection(&CNtfsStoreDriver::sm_csLockInstList);
        
        //Init the head of the list
        InitializeListHead(&CNtfsStoreDriver::sm_ListHead);

        // initialize eventlogging
        CNtfsStoreDriver::g_pEventLog = new CEventLogWrapper();
        if (CNtfsStoreDriver::g_pEventLog)
            CNtfsStoreDriver::g_pEventLog->Initialize("smtpsvc");
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();

        if (CNtfsStoreDriver::g_pEventLog)
        {
            delete CNtfsStoreDriver::g_pEventLog;
            CNtfsStoreDriver::g_pEventLog = NULL;
        }

        TrHeapDestroy();
        DeleteCriticalSection(&CNtfsStoreDriver::sm_csLockInstList);

    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\storedrv\ntfsdrct.h ===
/*==========================================================================*\

    Module:        ipcctrs.h

    Copyright Microsoft Corporation 1998, All Rights Reserved.

    Author:        WayneC, MinYang

    Descriptions:  Object and Counter definitions for ExIPC.

\*==========================================================================*/

//
//  Object and Counter definitions
//

#define OBJECT_NTFSDRV                          0

#define NTFSDRV_QUEUE_LENGTH                    2
#define NTFSDRV_NUM_ALLOCS                      4
#define NTFSDRV_NUM_DELETES                     6
#define NTFSDRV_NUM_ENUMERATED                  8
#define NTFSDRV_MSG_BODIES_OPEN                 10
#define NTFSDRV_MSG_STREAMS_OPEN                12
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\storedrv\perf.h ===
/*==========================================================================*\

    Module:        perf.h

    Copyright Microsoft Corporation 1998, All Rights Reserved.

    Author:        WayneC, MinYang

    Descriptions:  Interface functions accessing perf object instances.

    Modified:      Awetmore - for NTFSDRV usage
    
\*==========================================================================*/


#ifndef __PERF_H__
#define __PERF_H__

#include "snprflib.h"
#include "ntfsdrct.h"

#define DEFAULT_PERF_UPDATE_INTERVAL  1000    // milliseconds

#define IncCtr(ppoi,x)   { LPDWORD pDword; if (ppoi) { pDword = ppoi->GetDwordCounter(x); if (pDword) InterlockedIncrement((PLONG)pDword); }}
#define DecCtr(ppoi,x)   { LPDWORD pDword; if (ppoi) { pDword = ppoi->GetDwordCounter(x); if (pDword) InterlockedDecrement((PLONG)pDword); }}
#define AddCtr(ppoi,x,y) { LPDWORD pDword; if (ppoi) { pDword = ppoi->GetDwordCounter(x); if (pDword) InterlockedExchangeAdd((PLONG)pDword, (LONG)y); }}
#define SetCtr(ppoi,x,y) { LPDWORD pDword; if (ppoi) { pDword = ppoi->GetDwordCounter(x); if (pDword) (*pDword)=y; } }

BOOL InitializePerformanceStatistics ();
void ShutdownPerformanceStatistics ();

PerfObjectInstance * CreatePerfObjInstance (LPCWSTR pwstrInstanceName);

extern BOOL  g_fPerfCounters;

#endif // __PERF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\storedrv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ntfsdrv.rc
//
#define IDS_PROJNAME                    100
#define IDR_NTFSDRV                     101
#define IDR_NTFSSTM                     102
#define IDR_NTFSENUM                    103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\storedrv\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__2DB263A4_499F_11D1_B78F_0080C731C893__INCLUDED_)
#define AFX_STDAFX_H__2DB263A4_499F_11D1_B78F_0080C731C893__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#ifdef _ASSERT
#undef _ASSERT
#endif //_ASSERT
#include <transmem.h>
#include <dbgtrace.h>

#endif // !defined(AFX_STDAFX_H__2DB263A4_499F_11D1_B78F_0080C731C893__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\storedrv\perf.cpp ===
/*==========================================================================*\

    Module:        perf.cpp

    Copyright Microsoft Corporation 1998, All Rights Reserved.

    Author:        AWetmore

    Descriptions:  Perf Object Definitions.
    
\*==========================================================================*/

#include "stdafx.h"
#include "perf.h"

//////////////////////////////////////////////////////////////////////////////
//
// Perf object definitions.
//
//////////////////////////////////////////////////////////////////////////////
PerfLibrary          * g_cplNtfsDrv  = NULL;
PerfObjectDefinition * g_cpodNtfsDrv = NULL;


//////////////////////////////////////////////////////////////////////////////
//
// Global flag for updating perf counters.
//
//////////////////////////////////////////////////////////////////////////////
BOOL  g_fPerfCounters  = FALSE;
DWORD g_dwPerfInterval = DEFAULT_PERF_UPDATE_INTERVAL;


//$--InitializePerformanceStatistics-------------------------------------------
//
// This function initializes the perf counters defined above. It also checks
//  the registry to see if we want to monitor the perf counters.
//
//-----------------------------------------------------------------------------
BOOL InitializePerformanceStatistics ()
{
    HKEY  hKey   = NULL;
    LONG  status = 0;
    DWORD size   = MAX_PATH;
    DWORD type   = REG_DWORD;
    DWORD fPerf  = 0;
    DWORD msec   = 0;

    //
    // Check the registry to see if we want to monitor the perf counters.
    //
    status = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                           "SYSTEM\\CurrentControlSet\\Services\\NtfsDrv\\Performance",
                           0L,
                           KEY_ALL_ACCESS,
                           &hKey);

    if (status != ERROR_SUCCESS)
        goto Exit;

#if 0
    status = RegQueryValueEx (hKey, 
                              "EnablePerfCounters",
                              NULL,
                              &type,
                              (LPBYTE)&fPerf,
                              &size);

    if (status != ERROR_SUCCESS || 0 == fPerf)
        goto Exit;

    //
    // Check the desired update period.
    //
    type = REG_DWORD;
    status = RegQueryValueEx (hKey,
                              "UpdateInterval",
                              NULL,
                              &type,
                              (LPBYTE)&msec,
                              &size);
    
    if (status == ERROR_SUCCESS)
    {
        // make sure 0 < msec <= 0x7FFFFFFF
        if (msec > 0 && !(msec & 0x80000000) && type == REG_DWORD)
            g_dwPerfInterval = msec;
    }
#endif

    //
    // Initialize the perf counters.
    //
    g_cplNtfsDrv = new PerfLibrary (L"NTFSDrv");
    if (!g_cplNtfsDrv)
        goto Exit;

    g_cpodNtfsDrv = g_cplNtfsDrv->AddPerfObjectDefinition (L"NTFSDRV_OBJ", OBJECT_NTFSDRV, TRUE);
    if (!g_cpodNtfsDrv)
        goto Exit;

    if (!g_cpodNtfsDrv->AddPerfCounterDefinition(NTFSDRV_QUEUE_LENGTH,         PERF_COUNTER_RAWCOUNT) ||
        !g_cpodNtfsDrv->AddPerfCounterDefinition(NTFSDRV_NUM_ALLOCS,           PERF_COUNTER_RAWCOUNT) ||
        !g_cpodNtfsDrv->AddPerfCounterDefinition(NTFSDRV_NUM_DELETES,          PERF_COUNTER_RAWCOUNT) ||
        !g_cpodNtfsDrv->AddPerfCounterDefinition(NTFSDRV_NUM_ENUMERATED,       PERF_COUNTER_RAWCOUNT) ||
        !g_cpodNtfsDrv->AddPerfCounterDefinition(NTFSDRV_MSG_BODIES_OPEN,  PERF_COUNTER_RAWCOUNT) ||
        !g_cpodNtfsDrv->AddPerfCounterDefinition(NTFSDRV_MSG_STREAMS_OPEN, PERF_COUNTER_RAWCOUNT))
    {
        goto Exit;
    }

    g_fPerfCounters = g_cplNtfsDrv->Init();

Exit:
    if (hKey)
        CloseHandle (hKey);

    if (!g_fPerfCounters && g_cplNtfsDrv)
    {
        delete g_cplNtfsDrv;
        g_cplNtfsDrv  = NULL;
        g_cpodNtfsDrv = NULL;
    }

    return g_fPerfCounters;
}


//$--ShutdownPerformanceStatistics--------------------------------------------
//
// This function shuts down the perf objects.
//
//-----------------------------------------------------------------------------
void ShutdownPerformanceStatistics ()
{
    if (g_cplNtfsDrv)
    {
        delete g_cplNtfsDrv;
        g_cplNtfsDrv  = NULL;
        g_cpodNtfsDrv = NULL;
    }
}

//$--CreatePerfObjInstance-----------------------------------------------------
//
// This function relays the creation of perf object instance to the global
//  perf object definition.
//
//-----------------------------------------------------------------------------
PerfObjectInstance * CreatePerfObjInstance (LPCWSTR pwstrInstanceName)
{
    PerfObjectInstance * ppoi = NULL;

    if (g_cpodNtfsDrv)
        ppoi = g_cpodNtfsDrv->AddPerfObjectInstance (pwstrInstanceName);

    return ppoi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\admcmn.h ===
#ifndef _ADMCMN_INCLUDED_
#define _ADMCMN_INCLUDED_

//  ATL code:
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//  Debugging support:
#undef _ASSERT
#include <dbgtrace.h>

//  The Metabase:
#include <iadm.h>
#include <iiscnfg.h>

//  ADSI interfaces:
#include <iads.h>
#include <adsiid.h>
#include <adserr.h>

//  Useful macros
#include "admmacro.h"

//	Error handling routines:
#include "admerr.h"

//  MultiSZ class:
#include "cmultisz.h"

//  Metabase key wrapper:
#include "metakey.h"

//  Base IADs implementation:
#include "adsimpl.h"

//  U2 detection code:
#include "u2detect.h"

//	Property cache
#include "iprops.hxx"

//	ADSI Interface macros
#define RRETURN(x)	return(x);
#include "intf.hxx"
#include "macro.h"
#include "cmacro.h"
#include "fsmacro.h"
#include "adsmacro.h"

// Dispatcher
#include "cdispmgr.hxx"

#endif // _ADMCMN_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\admerr.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	admerr.h

Abstract:

	Common error handling operations:

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _ADMERR_INCLUDED_
#define _ADMERR_INCLUDED_

//
//	Win32 => Localized string
//

//  ! You must define this in your .rc file !
#define IDS_UNKNOWN_ERROR                                       500

void Win32ErrorToString ( DWORD dwError, WCHAR * wszError, DWORD cchMax );

//
// Creation of Error Objects:
//

const int MAX_DESCRIPTION_LENGTH = 1000;

HRESULT CreateException ( 
	HINSTANCE	hInstance, 
	REFIID 		riid,
	LPCWSTR		wszHelpFile,
	DWORD		dwHelpContext,
	LPCWSTR		wszSourceProgId,
	LPCWSTR		wszDescription
	);

HRESULT CreateException ( 
	HINSTANCE	hInstance, 
	REFIID 		riid,
	LPCWSTR		wszHelpFile,
	DWORD		dwHelpContext,
	LPCWSTR		wszSourceProgId,
	int			nDescriptionId
	);

inline HRESULT	CreateExceptionFromWin32Error (
	HINSTANCE	hInstance,
	REFIID		riid,
	LPCWSTR		wszHelpFile,
	DWORD		dwHelpContext,
	LPCWSTR		wszSourceProgId,
	DWORD		dwErrorCode
	);

inline HRESULT	CreateExceptionFromHresult (
	HINSTANCE	hInstance,
	REFIID		riid,
	LPCWSTR		wszHelpFile,
	DWORD		dwHelpContext,
	LPCWSTR		wszSourceProgId,
	HRESULT		hr
	);

//--------------------------------------------------------------------
//
//	Inlined functions:
//
//--------------------------------------------------------------------

inline HRESULT	CreateExceptionFromWin32Error (
	HINSTANCE	hInstance,
	REFIID		riid,
	LPCWSTR		wszHelpFile,
	DWORD		dwHelpContext,
	LPCWSTR		wszSourceProgId,
	DWORD		dwErrorCode
	)
{
	WCHAR	wszException [ MAX_DESCRIPTION_LENGTH ];

	Win32ErrorToString ( dwErrorCode, wszException, MAX_DESCRIPTION_LENGTH );

	return CreateException ( 
		hInstance,
		riid,
		wszHelpFile,
		dwHelpContext,
		wszSourceProgId,
		wszException
		);
}

inline HRESULT	CreateExceptionFromHresult (
	HINSTANCE	hInstance,
	REFIID		riid,
	LPCWSTR		wszHelpFile,
	DWORD		dwHelpContext,
	LPCWSTR		wszSourceProgId,
	HRESULT		hr
	)
{
	DWORD	dwErrorCode	= HRESULTTOWIN32 ( hr );

	_ASSERT ( dwErrorCode != NOERROR );

	return CreateExceptionFromWin32Error (
		hInstance,
		riid,
		wszHelpFile,
		dwHelpContext,
		wszSourceProgId,
		dwErrorCode
		);
}

#endif // _ADMERR_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\admerr.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	AdmErr.cpp

Abstract:

	Common Error handling routines

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "admerr.h"

//$-------------------------------------------------------------------
//
//	Win32ErrorToString
//
//	Description:
//
//		Translates a Win32 error code to a localized string.
//
//	Parameters:
//
//		dwError		- The error code
//		wszError	- The allocated error 
//
//	Returns:
//
//		
//
//--------------------------------------------------------------------

void Win32ErrorToString ( DWORD dwError, WCHAR * wszError, DWORD cchMax )
{
	TraceFunctEnter ( "Win32ErrorToString" );

	_ASSERT ( !IsBadWritePtr ( wszError, cchMax * sizeof(WCHAR) ) );

	HRESULT		hr 				= NOERROR;
	DWORD		dwFormatFlags;

	//----------------------------------------------------------------
	//
	//	Map error codes here:
	//

	//
	//----------------------------------------------------------------

	dwFormatFlags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS;

	if ( !FormatMessage ( dwFormatFlags, NULL, dwError, 0,      // Lang ID - Should be nonzero?
			wszError, cchMax - 1, NULL ) ) {

		// Didn't work, so put in a default message:

		WCHAR   wszFormat [ 256 ];

		wszFormat[0] = L'\0';
		if ( !LoadStringW ( _Module.GetResourceInstance (), IDS_UNKNOWN_ERROR, wszFormat, 256 ) ||
			!*wszFormat ) {

            _ASSERT ( FALSE );  // Define IDS_UNKNOWN_ERROR in your .rc file!
			wcscpy ( wszFormat, L"Unknown Error (%1!d!)" );
		}

		FormatMessage (
			FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
			wszFormat, 
			IDS_UNKNOWN_ERROR, 
			0, 
			wszError, 
			cchMax - 1,
			(va_list *) &dwError
			);
	}
	//
	// We need to strip out any " from the string, because
	// Javascript will barf.
	//

	LPWSTR  pch;

	for ( pch = wszError; *pch; pch++ ) {

		if ( *pch == L'\"' ) {
			*pch = L'\'';
		}
	}

	//
	// Strip off any trailing control characters.
	//
	for (pch = &wszError[wcslen(wszError) - 1];
		pch >= wszError && iswcntrl(*pch);
		pch --) {

		*pch = 0;
	}

	TraceFunctLeave ();
}

//$-------------------------------------------------------------------
//
//	CreateException
//
//	Description:
//
//		Creates an OLE Error object and return DISP_E_EXCEPTION
//
//	Parameters:
//
//		hInstance		- The instance of the dll.
//		riid			- Which interface caused the exception.
//		wszHelpFile		- file to get user help.
//		dwHelpContext	- Context to get user help.
//		wszSourceProgId	- ProgID of the class which caused the exception.
//		nDescriptionId	- resource ID of the error string.
//
//	Returns:
//
//		E_FAIL	- Couldn't create the exception.
//		DISP_E_EXCEPTION	- Successfully created the exception.
//				return this value to IDispatch::Invoke.
//
//--------------------------------------------------------------------

HRESULT CreateException ( 
	HINSTANCE	hInstance,
	REFIID 		riid, 
	LPCWSTR		wszHelpFile,
	DWORD		dwHelpContext,
	LPCWSTR		wszSourceProgId,
	int			nDescriptionId
	)
{
	WCHAR						wszDescription[ MAX_DESCRIPTION_LENGTH + 1 ];

	wcscpy ( wszDescription, _T("Unknown Exception") );

	_VERIFY ( ::LoadString ( hInstance, nDescriptionId, wszDescription, MAX_DESCRIPTION_LENGTH ) );

	return CreateException (
		hInstance,
		riid,
		wszHelpFile,
		dwHelpContext,
		wszSourceProgId,
		wszDescription
		);
}

//$-------------------------------------------------------------------
//
//	CreateException
//
//	Description:
//
//		Creates an OLE Error object and return DISP_E_EXCEPTION
//
//	Parameters:
//
//		hInstance		- The instance of the dll.
//		riid			- Which interface caused the exception.
//		wszHelpFile		- file to get user help.
//		dwHelpContext	- Context to get user help.
//		wszSourceProgId	- ProgID of the class which caused the exception.
//		wszDescription	- The error string to display to the user.
//
//	Returns:
//
//		E_FAIL	- Couldn't create the exception.
//		DISP_E_EXCEPTION	- Successfully created the exception.
//				return this value to IDispatch::Invoke.
//
//--------------------------------------------------------------------

HRESULT CreateException ( 
	HINSTANCE	hInstance,
	REFIID 		riid, 
	LPCWSTR		wszHelpFile,
	DWORD		dwHelpContext,
	LPCWSTR		wszSourceProgId,
	LPCWSTR		wszDescription
	)
{
	TraceFunctEnter ( "CreateException" );

	CComPtr <ICreateErrorInfo>	pICreateErr;
	CComPtr <IErrorInfo>		pIErr;
    CComPtr <IErrorInfo>        pOldError;
	HRESULT						hr	= NOERROR;

    if ( S_OK == GetErrorInfo ( NULL, &pOldError ) ) {
        // Don't overwrite the existing error info:
		SetErrorInfo ( 0, pOldError );
        hr = DISP_E_EXCEPTION;
        goto Exit;
    }

	hr = CreateErrorInfo (&pICreateErr);

	if ( FAILED (hr) ) {
		FatalTrace ( 0, "CreateErrorInfo failed", hr );
		goto Exit;
	}

	pICreateErr->SetGUID		( riid );
	pICreateErr->SetHelpFile	( const_cast <LPWSTR> (wszHelpFile) );
	pICreateErr->SetHelpContext	( dwHelpContext );
	pICreateErr->SetSource		( const_cast <LPWSTR> (wszSourceProgId) );
	pICreateErr->SetDescription	( (LPWSTR) wszDescription );

	hr = pICreateErr->QueryInterface (IID_IErrorInfo, (void **) &pIErr);

	if ( FAILED(hr) ) {
		DebugTraceX ( 0, "QI(CreateError) failed %x", hr );
		FatalTrace ( 0, "Can't create exception" );
		hr = E_FAIL;
		goto Exit;
	}

	SetErrorInfo ( 0, pIErr );
	hr = DISP_E_EXCEPTION;

Exit:
	TraceFunctLeave ();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\adsimp.inl ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:  adsimp.inl
//
//  Contents:  Inline for standard implementations
//
//  History:   5/4/98     KeithLau    Created.
//
//----------------------------------------------------------------------------


//
// This declares methods for the following:
// IADsExtension
// IUnknown
// IDispatch
// IPrivateUnknown
// IPrivateDispatch
//
// The following are implemented partially inline:
// IUnknown (AddRef & Release)
// IPrivateUnknown (AddRef & Release)
//
	DECLARE_GET_CONTROLLING_UNKNOWN()						
															
private:													
	long					_lRefCount;
	IUnknown				*_pUnkOuter;					
    IADs FAR				*_pADs;							
    CAggregateeDispMgr FAR	*_pDispMgr;						
    BOOL					_fDispInitialized;				

															
public:														
	STDMETHODIMP NonDelegatingQueryInterface(				
		REFIID iid,											
		LPVOID FAR* ppv										
		)													
	{														
		if (IsEqualIID(iid, THIS_IID)) {
			*ppv = (IADsUser FAR *) this;					
		} else if (IsEqualIID(iid, IID_IADsExtension)) {	
			*ppv = (IADsExtension FAR *) this;				
		} else if (IsEqualIID(iid, IID_IDispatch)) {	
			*ppv = (IDispatch FAR *) this;
		} else if (IsEqualIID(iid, IID_IADs)) {
			*ppv = (IADs FAR *) this;		
		} else if (IsEqualIID(iid, IID_IPrivateUnknown)) {
			*ppv = (IPrivateUnknown FAR *) this;		
		} else if (IsEqualIID(iid, IID_IPrivateDispatch)) {	
			*ppv = (IPrivateDispatch FAR *) this;		
		} else if (IsEqualIID(iid, IID_IUnknown)) {			
			*ppv = (INonDelegatingUnknown FAR *) this;		
		} else {											
			*ppv = NULL;									
			return E_NOINTERFACE;							
		}													
		NonDelegatingAddRef();
		return(S_OK);										
	}														

	STDMETHOD_(ULONG, NonDelegatingAddRef) (void)			
	{ 
		return(InterlockedIncrement(&_lRefCount));
	}

	STDMETHOD_(ULONG, NonDelegatingRelease) (void)			
	{														
		long lTemp = InterlockedDecrement(&_lRefCount);		
		if (!lTemp) delete this;							
		return(lTemp);										
	}														

	STDMETHODIMP QueryInterface(							
		REFIID iid,											
		LPVOID FAR* ppv										
		)													
	{														
		HRESULT hr = S_OK;
		if (_pUnkOuter == (LPVOID)this)
			hr = NonDelegatingQueryInterface(iid,ppv);
		else
   			hr = _pUnkOuter->QueryInterface(iid,ppv);
		return(hr);
	}														

	STDMETHOD_(ULONG, AddRef) (void)						
	{ 
		return (_pUnkOuter == (LPVOID)this)?NonDelegatingAddRef():_pUnkOuter->AddRef();
	}
	STDMETHOD_(ULONG, Release) (void)						
	{
		return (_pUnkOuter == (LPVOID)this)?NonDelegatingRelease():_pUnkOuter->Release();
	}
															
//    DECLARE_IDispatch_METHODS								
    DECLARE_IPrivateUnknown_METHODS							
    DECLARE_IPrivateDispatch_METHODS						
															
    STDMETHOD(Operate)(THIS_								
				DWORD   dwCode,								
				VARIANT varUserName,						
				VARIANT varPassword,						
				VARIANT varReserved							
				);											
															
    STDMETHOD(PrivateGetIDsOfNames)(THIS_					
				REFIID riid,								
				OLECHAR FAR* FAR* rgszNames,				
				unsigned int cNames,						
				LCID lcid,									
				DISPID FAR* rgdispid);						
															
    STDMETHOD(PrivateInvoke)(THIS_							
				DISPID dispidMember,						
				REFIID riid,								
				LCID lcid,									
				WORD wFlags,								
				DISPPARAMS FAR* pdispparams,				
				VARIANT FAR* pvarResult,					
				EXCEPINFO FAR* pexcepinfo,					
				unsigned int FAR* puArgErr					
				);											

/*
	void SetVoid(void *pVoid)
	{
		_pUnkOuter = (IUnknown *)pVoid;
	}
*/
	HRESULT FinalConstruct()
	{
		IADs FAR *  pADs = NULL;
		CAggregateeDispMgr FAR * pDispMgr = NULL;
		HRESULT hr = S_OK;

		_lRefCount			= 0;
		_pADs				= NULL;
		_pDispMgr			= NULL;
		_fDispInitialized	= FALSE;

		_pUnkOuter = GetControllingUnknown();
		if (!_pUnkOuter)
			_pUnkOuter = (IUnknown *)(IADs *)this;

		pDispMgr = new CAggregateeDispMgr;
		if (pDispMgr == NULL) {
			hr = E_OUTOFMEMORY;
		}
		BAIL_ON_FAILURE(hr);

		hr = pDispMgr->LoadTypeInfoEntry(
					THIS_LIBID,
					THIS_IID,
					this,
					DISPID_VALUE
					//DISPID_REGULAR
					);
		BAIL_ON_FAILURE(hr);

		//
		// Store the IADs Pointer, but again do NOT ref-count
		// this pointer - we keep the pointer around, but do
		// a release immediately.
		//

		if (_pUnkOuter != (LPVOID)this)
		{
			hr = _pUnkOuter->QueryInterface(IID_IADs, (void **)&pADs);
			if (SUCCEEDED(hr))
			{
				_pADs = pADs;
				pADs->Release();
			}
			else
			{
				BAIL_ON_FAILURE(hr);
			}
		}
		else
		{
			_pADs = (IADs FAR *)this;
		}

		_pDispMgr = pDispMgr;

		return(hr);

	Exit:
		delete  pDispMgr;
		return(hr);
	}

	HRESULT FinalRelease()
	{
		if (_pDispMgr)
			delete _pDispMgr;
		return(S_OK);
	}

	STDMETHODIMP                                                          
	GetTypeInfoCount(unsigned int FAR* pctinfo)                      
	{                                                                     
		if (_pADs == (LPVOID)this)                                        
		{                                                                 
			RRETURN(ADSIGetTypeInfoCount(pctinfo));                       
		}                                                                 
		else                                                              
		{                                                                 
			RRETURN(_pADs->GetTypeInfoCount(pctinfo));                    
		}                                                                 
	}                                                                     
																		  
	STDMETHODIMP                                                          
	GetTypeInfo(unsigned int itinfo, LCID lcid,                      
			ITypeInfo FAR* FAR* pptinfo)                                  
	{                                                                     
		if (_pADs == (LPVOID)this)                                        
		{                                                                 
			RRETURN(ADSIGetTypeInfo(itinfo,                               
										   lcid,                          
										   pptinfo                        
										   ));                            
		}                                                                 
		else                                                              
		{                                                                 
			RRETURN(_pADs->GetTypeInfo(itinfo,                            
										   lcid,                          
										   pptinfo                        
										   ));                            
		}                                                                 
	}                                                                     
	STDMETHODIMP                                                          
	GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 
			unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         
	{                                                                     
		if (_pADs == (LPVOID)this)                                        
		{                                                                 
			RRETURN(ADSIGetIDsOfNames(iid,                                
											 rgszNames,                   
											 cNames,                      
											 lcid,                        
											 rgdispid                     
											 ));                          
		}                                                                 
		else                                                              
		{                                                                 
			RRETURN(_pADs->GetIDsOfNames(iid,                             
											 rgszNames,                   
											 cNames,                      
											 lcid,                        
											 rgdispid                     
											 ));                          
		}                                                                 
	}                                                                     
																		  
	STDMETHODIMP                                                          
	Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               
			unsigned short wFlags, DISPPARAMS FAR* pdispparams,           
			VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           
			unsigned int FAR* puArgErr)                                   
	{                                                                     
		if (_pADs == (LPVOID)this)                                        
		{                                                                 
			RRETURN (ADSIInvoke(dispidMember,                             
									   iid,                               
									   lcid,                              
									   wFlags,                            
									   pdispparams,                       
									   pvarResult,                        
									   pexcepinfo,                        
									   puArgErr                           
									   ));                                
		}                                                                 
		else                                                              
		{                                                                 
			RRETURN (_pADs->Invoke(dispidMember,                          
									   iid,                               
									   lcid,                              
									   wFlags,                            
									   pdispparams,                       
									   pvarResult,                        
									   pexcepinfo,                        
									   puArgErr                           
									   ));                                
		}                                                                 
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\admmacro.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	admmacro.h

Abstract:

	Useful macros used by all admin objects.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _ADMMACRO_INCLUDED_
#define _ADMMACRO_INCLUDED_

//
// Bit mask handling
//

#define IS_FLAG_SET(dw, flag) (((dw & flag) != 0) ? TRUE : FALSE)
#define SET_FLAG(dw, flag)    dw |= flag
#define RESET_FLAG(dw, flag)  dw &= ~(flag)
#define SET_FLAG_IF(cond, dw, flag)\
    if (cond)                      \
    {                              \
        SET_FLAG(dw, flag);        \
    }                              \
    else                           \
    {                              \
        RESET_FLAG(dw, flag);      \
    }


//
//	Error handling:
//

#define BAIL_ON_FAILURE(hr)	\
{							\
	if ( FAILED(hr) ) {		\
		goto Exit;			\
	}						\
}
#define BAIL_WITH_FAILURE(hr, hrFailureCode)	\
{							\
	(hr) = (hrFailureCode);	\
	goto Exit;				\
}

#define TRACE_HRESULT(hr)    \
{                           \
    if ( FAILED(hr) ) {     \
        DebugTrace ( 0, "Returning error: %x", hr );    \
    }                       \
}

//
//	Data validation macros:
//

#define IS_VALID_THIS_POINTER()			( !IsBadWritePtr ( (void *) this, sizeof (*this) ) )
#define IS_VALID_STRING(str)			( !IsBadStringPtr ( (str), (DWORD) -1 ) )
#define IS_VALID_STRING_LEN(str,len)	( !IsBadStringPtr ( (str), (len) ) )
#define IS_VALID_IN_PARAM(pIn)			( !IsBadReadPtr ( (pIn), sizeof ( *(pIn) ) ) )
#define IS_VALID_OUT_PARAM(pOut)		( !IsBadWritePtr ( (pOut), sizeof ( *(pOut) ) ) )

#define IS_VALID_READ_ARRAY(arr,cItems)		( !IsBadReadPtr ( (arr), (cItems) * sizeof ( *(arr) ) ) )
#define IS_VALID_WRITE_ARRAY(arr,cItems)	( !IsBadWritePtr ( (arr), (cItems) * sizeof ( *(arr) ) ) )

//
//	AssertValid for classes:
//

#ifdef DEBUG
	#define DECLARE_ASSERT_VALID()	void AssertValid ( ) const;
	#define DECLARE_VIRTUAL_ASSERT_VALID()	virtual void AssertValid ( ) const;
#else
	#define DECLARE_ASSERT_VALID()	inline void AssertValid ( ) const { }
	#define DECLARE_VIRTUAL_ASSERT_VALID()	inline void AssertValid ( ) const { }
#endif

//
//	Sizing macros:
//

inline DWORD STRING_BYTE_LENGTH ( LPWSTR wsz )
{
    if ( wsz == NULL ) {
        return 0;
    }

    return ( lstrlen ( wsz ) + 1 ) * sizeof wsz[0];
}

//	Use only for statically sized arrays:
#define ARRAY_SIZE(arr)	( sizeof (arr) / sizeof ( (arr)[0] ) )

inline DWORD CB_TO_CCH ( DWORD cb )
{
	return cb / sizeof (WCHAR);
}

inline DWORD CCH_TO_CB ( DWORD cch )
{
	return cch * sizeof (WCHAR);
}

//
//	Bit macros:
//

inline void SetBitFlag ( DWORD * pbv, DWORD bit, BOOL fFlag )
{
	_ASSERT ( IS_VALID_OUT_PARAM ( pbv ) );
	_ASSERT ( bit != 0 );

	if ( fFlag ) {
		*pbv |= bit;
	}
	else {
		*pbv &= ~bit;
	}
}

inline BOOL GetBitFlag ( DWORD bv, DWORD bit )
{
	return !!(bv & bit);
}

//
//	Macros for ole types that aren't wrapped using ATL:
//

inline void SAFE_FREE_BSTR ( BSTR & str )
{
	if ( str != NULL ) {
		::SysFreeString ( str );
		str = NULL;
	}
}

#define SAFE_RELEASE(x) { if ( (x) ) { (x)->Release(); (x) = NULL; } }

#endif // _ADMMACRO_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\adsmacro.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:  adsmacro.h
//
//  Contents:  Macros for standard method declarations
//
//  History:   4/24/98     KeithLau    Created.
//
//----------------------------------------------------------------------------

#define DISPID_REGULAR	1

//
// This provides implementations for the following:
// IADsExtension
// IUnknown (QI)
// IDispatch
// IPrivateUnknown (QI)
// IPrivateDispatch
//
//	DEFINE_DELEGATING_IDispatch_Implementation(ClassName)

#define DECLARE_METHOD_IMPLEMENTATION_FOR_STANDARD_EXTENSION_INTERFACES(BaseName, ClassName, IID)	\
	DEFINE_IPrivateDispatch_Implementation(ClassName)		\
	DEFINE_IADsExtension_Implementation(ClassName)			\
															\
	STDMETHODIMP											\
	C##BaseName::Operate(									\
		THIS_ DWORD dwCode,									\
		VARIANT varUserName,								\
		VARIANT varPassword,								\
		VARIANT varFlags									\
		)													\
	{														\
		RRETURN(E_NOTIMPL);									\
	}														\
															\
	STDMETHODIMP											\
	C##BaseName::ADSIInitializeObject(						\
		THIS_ BSTR lpszUserName,							\
		BSTR lpszPassword,									\
		long lnReserved										\
		)													\
	{														\
		RRETURN(S_OK);										\
	}														\
															\
	STDMETHODIMP											\
	C##BaseName::ADSIReleaseObject()						\
	{														\
		delete this;										\
		RRETURN(S_OK);										\
	}														\
															\
	STDMETHODIMP											\
	C##BaseName::ADSIInitializeDispatchManager(				\
		long dwExtensionId									\
		)													\
	{														\
		HRESULT hr = S_OK;									\
		if (_fDispInitialized) {							\
			RRETURN(E_FAIL);								\
		}													\
		hr = _pDispMgr->InitializeDispMgr(dwExtensionId);	\
		if (SUCCEEDED(hr)) {								\
			_fDispInitialized = TRUE;						\
		}													\
		RRETURN(hr);										\
	}														\
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\adsimpl.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	AdsImpl.cpp

Abstract:

	Implements a simple version of the IADs interface.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include <iads.h>
#include <adsiid.h>
#include <adserr.h>
#include "adsimpl.h"

#define STR_PROVIDER_NAME	_T("IIS")
#define STR_SCHEMA_PATH     _T("schema")

CIADsImpl::CIADsImpl ( ) :
	m_dwInstance ( 1 )
{
}

CIADsImpl::~CIADsImpl ( )
{
}

//
//	IADs Methods:
//

HRESULT CIADsImpl::get_Name		( BSTR * pstrName )
{
	return GetName ( pstrName );
}

HRESULT CIADsImpl::get_Class	( BSTR * pstrClass )
{
	return GetClass ( pstrClass );
}

HRESULT CIADsImpl::get_GUID		( BSTR * pstrGUID )
{
	return GetString ( _T(""), pstrGUID );
}

HRESULT CIADsImpl::get_Schema	( BSTR * pstrSchema )
{
    return BuildSchemaPath ( pstrSchema );
}

HRESULT CIADsImpl::get_ADsPath	( BSTR * pstrADsPath )
{
	return BuildAdsPath ( TRUE, pstrADsPath );
}

HRESULT CIADsImpl::get_Parent	( BSTR * pstrParent )
{
	return BuildAdsPath ( FALSE, pstrParent );
}

HRESULT CIADsImpl::Get			( BSTR strName, VARIANT * pvar )
{
	if ( ! lstrcmpi ( strName, _T("KeyType") ) ) {
		V_VT (pvar) = VT_BSTR;
		V_BSTR (pvar) = ::SysAllocString ( m_strClass );
		return NOERROR;
	}
	else {
		return E_ADS_PROPERTY_NOT_SUPPORTED;
	}
}

HRESULT CIADsImpl::Put			( BSTR strName, VARIANT var )
{
	return E_ADS_PROPERTY_NOT_SUPPORTED;
}

HRESULT CIADsImpl::GetEx		( BSTR strName, VARIANT * pvar )
{
	return Get ( strName, pvar );
}

HRESULT CIADsImpl::PutEx		( long lControlCode, BSTR strName, VARIANT var )
{
	return E_ADS_PROPERTY_NOT_SUPPORTED;
}

HRESULT CIADsImpl::GetInfo ( )
{
	return NOERROR;
}

HRESULT CIADsImpl::SetInfo ( )
{
	return NOERROR;
}

HRESULT CIADsImpl::GetInfoEx	( VARIANT varProps, long lnReserved )
{
	return NOERROR;
}

//
//	Data accessors:
//

HRESULT	CIADsImpl::SetString ( CComBSTR & str, LPCWSTR wsz )
{
	if ( wsz != NULL ) {
		str = wsz;
	}
	else {
		str = _T("");
	}

	if ( !str ) {
		return E_OUTOFMEMORY;
	}
	else {
		return NOERROR;
	}
}

HRESULT	CIADsImpl::GetString ( LPCWSTR wsz, BSTR * pstr )
{
	CComBSTR	str;

	if ( wsz != NULL ) {
		str = wsz;
	}
	else {
		str = _T("");
	}

	if ( !str ) {
		return E_OUTOFMEMORY;
	}

	*pstr = str.Detach();
	return NOERROR;
}

HRESULT	CIADsImpl::SetComputer	( LPCWSTR wszComputer )
{
	return SetString ( m_strComputer, wszComputer );
}

HRESULT	CIADsImpl::SetService	( LPCWSTR wszService )
{
	return SetString ( m_strService, wszService );
}

HRESULT	CIADsImpl::SetInstance	( DWORD dwInstance )
{
	m_dwInstance = dwInstance;
	return NOERROR;
}

HRESULT	CIADsImpl::SetName		( LPCWSTR wszName )
{
	return SetString ( m_strName, wszName );
}

HRESULT CIADsImpl::SetClass ( LPCWSTR wszClass )
{
	return SetString ( m_strClass, wszClass );
}

HRESULT CIADsImpl::SetIADs ( IADs* pADs )
{
    m_pADs = pADs;
    return NOERROR;
}

HRESULT	CIADsImpl::GetComputer ( BSTR * pstrComputer )
{
	return GetString ( m_strComputer, pstrComputer );
}

HRESULT	CIADsImpl::GetService	( BSTR * pstrService )
{
	return GetString ( m_strService, pstrService );
}

HRESULT	CIADsImpl::GetInstance	( DWORD * pdwInstance )
{
	*pdwInstance = m_dwInstance;

	return NOERROR;
}

HRESULT	CIADsImpl::GetName		( BSTR * pstrName )
{
	return GetString ( m_strName, pstrName );
}

HRESULT CIADsImpl::GetClass ( BSTR * pstrClass )
{
	return GetString ( m_strClass, pstrClass );
}

HRESULT CIADsImpl::GetIADs ( IADs** ppADs )
{
    *ppADs = (IADs*)m_pADs;
    if( *ppADs ) (*ppADs)->AddRef();
    return NOERROR;
}

BSTR CIADsImpl::QueryComputer ( )
{
    if( !lstrcmpi(m_strComputer, _T("localhost")) )
        return NULL;

    return (BSTR) m_strComputer;
}

DWORD CIADsImpl::QueryInstance ( )
{
    return m_dwInstance;
}

HRESULT	CIADsImpl::BuildAdsPath ( BOOL fIncludeName, BSTR * pstrPath )
{
	DWORD		cchRequired;
	CComBSTR	strPath;

	cchRequired = 
			lstrlen ( STR_PROVIDER_NAME ) +     //  IIS
            3 +                                 //  ://
			m_strComputer.Length() +            //  <computer>
            1 +                                 //  /
			m_strService.Length() +             //  <service>
            1 +                                 //  /
			25;		// 25 to include NULL terminator & size of Instance #.

	if ( fIncludeName ) {
		cchRequired += 1 + m_strName.Length();  //  /<Name>
	}

	strPath.Attach ( ::SysAllocStringLen ( NULL, cchRequired ) );

	if ( !strPath ) {
		return E_OUTOFMEMORY;
	}

	if ( fIncludeName ) {
		wsprintf ( 
					strPath, 
					_T("%s://%s/%s/%d/%s"),
					STR_PROVIDER_NAME,
					m_strComputer,
					m_strService,
					m_dwInstance,
					m_strName
					);
	}
	else {
		wsprintf ( 
					strPath, 
					_T("%s://%s/%s/%d"),
					STR_PROVIDER_NAME,
					m_strComputer,
					m_strService,
					m_dwInstance
					);
	}

	*pstrPath = strPath.Detach();
	return NOERROR;
}

HRESULT CIADsImpl::BuildSchemaPath ( BSTR * pstrPath )
{
    DWORD       cchRequired;
    CComBSTR    strPath;

    cchRequired =
			lstrlen ( STR_PROVIDER_NAME ) +     //  IIS
            3 +                                 //  ://
			m_strComputer.Length() +            //  <computer>
            1 +                                 //  /
			lstrlen ( STR_SCHEMA_PATH ) +       //  <schema path>
            1 +                                 //  /
			m_strClass.Length () +              //  <class>
			25;		// 25 to include NULL terminator plus buffer.

    strPath.Attach ( ::SysAllocStringLen ( NULL, cchRequired ) );

    if ( !strPath ) {
        return E_OUTOFMEMORY;
    }

    wsprintf (
                strPath,
                _T("%s://%s/%s/%s"),
                STR_PROVIDER_NAME,
                m_strComputer,
                STR_SCHEMA_PATH,
                m_strClass
                );

    *pstrPath = strPath.Detach();
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\adsimpl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	AdsImpl.h

Abstract:

	A simple implementation of the IADs interface for the
	admin objects

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _ADSIMPL_INCLUDED_
#define _ADSIMPL_INCLUDED_


//
//	Macros to implement the required IADs methods:
//

#define DECLARE_IADS_METHODS()	\
public:                         \
	STDMETHODIMP get_Name	( BSTR * pstrName );	\
	STDMETHODIMP get_Class	( BSTR * pstrClass );	\
	STDMETHODIMP get_GUID	( BSTR * pstrGUID );	\
	STDMETHODIMP get_Schema	( BSTR * pstrSchema );	\
	STDMETHODIMP get_ADsPath( BSTR * pstrADsPath );	\
	STDMETHODIMP get_Parent	( BSTR * pstrParent );	\
	STDMETHODIMP GetInfo 	( );					\
	STDMETHODIMP SetInfo 	( );					\
	STDMETHODIMP Get		( BSTR strName, VARIANT * pvar );	\
	STDMETHODIMP Put		( BSTR strName, VARIANT var );		\
	STDMETHODIMP GetEx		( BSTR strName, VARIANT * pvar );	\
	STDMETHODIMP PutEx		( long lControlCode, BSTR strName, VARIANT var );	\
	STDMETHODIMP GetInfoEx	( VARIANT varProps, long lnReserved );				\
	STDMETHODIMP get_IADsPointer	( IADs** ppADs);				\
	STDMETHODIMP put_IADsPointer	( IADs* pADs);				\
    STDMETHODIMP get_KeyType ( BSTR* pstrKeyType);                   \
    STDMETHODIMP put_KeyType ( BSTR strKeyType );                    \

#define DECLARE_GET_IADS_PROPERTY(cls,m_IADsImpl,prop)		\
	STDMETHODIMP cls :: get_##prop ( BSTR * pstr##prop )	\
	{														\
		return m_IADsImpl . get_##prop( pstr##prop );		\
	}

#define DECLARE_SIMPLE_IADS_IMPLEMENTATION(cls,m_IADsImpl)	\
	DECLARE_GET_IADS_PROPERTY(cls,m_IADsImpl,Name)		\
	DECLARE_GET_IADS_PROPERTY(cls,m_IADsImpl,Class)		\
	DECLARE_GET_IADS_PROPERTY(cls,m_IADsImpl,GUID)		\
	DECLARE_GET_IADS_PROPERTY(cls,m_IADsImpl,Schema)	\
	DECLARE_GET_IADS_PROPERTY(cls,m_IADsImpl,Parent)	\
	DECLARE_GET_IADS_PROPERTY(cls,m_IADsImpl,ADsPath)	\
	\
	STDMETHODIMP cls :: GetInfo ( )		\
	{ return m_IADsImpl.m_pADs->GetInfo (); }	\
	STDMETHODIMP cls :: SetInfo ( )		\
	{ return m_IADsImpl.m_pADs->SetInfo (); }	\
	STDMETHODIMP cls :: Get ( BSTR strName, VARIANT * pvar )	\
	{ return m_IADsImpl.m_pADs->Get ( strName, pvar ); }				\
	STDMETHODIMP cls :: Put ( BSTR strName, VARIANT var )		\
	{ return m_IADsImpl.m_pADs->Put ( strName, var ); }					\
	STDMETHODIMP cls :: GetEx ( BSTR strName, VARIANT * pvar )	\
	{ return m_IADsImpl.m_pADs->GetEx ( strName, pvar ); }                      \
	STDMETHODIMP cls :: PutEx ( long lControlCode, BSTR strName, VARIANT var )	\
	{ return m_IADsImpl.m_pADs->PutEx ( lControlCode, strName, var ); }         \
	STDMETHODIMP cls :: GetInfoEx ( VARIANT varProps, long lnReserved )         \
	{ return m_IADsImpl.m_pADs->GetInfoEx ( varProps, lnReserved ); }           \
	\
	STDMETHODIMP cls :: get_Server ( BSTR * pstrServer )		\
	{ return m_IADsImpl.GetComputer ( pstrServer ); }			\
	STDMETHODIMP cls :: put_Server ( BSTR strServer )			\
	{ return m_IADsImpl.SetComputer ( strServer ); }			\
	STDMETHODIMP cls :: get_ServiceInstance ( long * plInstance )	\
	{ return m_IADsImpl.GetInstance ( (DWORD *) plInstance ); }		\
	STDMETHODIMP cls :: put_ServiceInstance ( long lInstance )		\
	{ return m_IADsImpl.SetInstance ( lInstance ); }				\
    STDMETHODIMP cls :: get_IADsPointer ( IADs** ppADs )                    \
    { return m_IADsImpl.GetIADs ( ppADs ); }                                \
    STDMETHODIMP cls :: put_IADsPointer ( IADs* pADs )                      \
    { return m_IADsImpl.SetIADs ( pADs ); }                                 \
    STDMETHODIMP cls :: get_KeyType ( BSTR* pstrKeyType)                    \
    {                                                                       \
        VARIANT     var;                                                    \
        HRESULT     hr = NOERROR;                                           \
        CComBSTR strTemp = _T("KeyType");			\
        if (!strTemp) return E_OUTOFMEMORY;	\
        hr = m_IADsImpl.m_pADs->Get( strTemp, &var );       \
        *pstrKeyType = V_BSTR(&var);                                        \
        return hr;                                                          \
    }                                                                       \
    STDMETHODIMP cls :: put_KeyType ( BSTR strKeyType )                     \
    {                                                                       \
        VARIANT     var;                                                    \
        V_VT(&var) = VT_BSTR;                                               \
        V_BSTR(&var) = strKeyType;                                          \
        CComBSTR strTemp = _T("KeyType");			\
        if (!strTemp) return E_OUTOFMEMORY;	\
        return m_IADsImpl.m_pADs->Put( strTemp, var);       \
    }                                                                       \


//$-------------------------------------------------------------------
//
//	Class:		CIADsImpl
//
//	Description:
//
//		Provides a simple implementation of the IADs interface.
//
//--------------------------------------------------------------------

class CIADsImpl
{
//
//	Methods:
//
public:
	CIADsImpl ( );
	~CIADsImpl ( );

	//
	//	IADs implementation:
	//

	DECLARE_IADS_METHODS()

	//
	//	Accessors:
	//

	HRESULT		SetComputer	( LPCWSTR wszComputer );
	HRESULT		SetService	( LPCWSTR wszService );
	HRESULT		SetInstance	( DWORD dwInstance );
	HRESULT		SetName		( LPCWSTR wszName );
	HRESULT		SetClass    ( LPCWSTR wszSchema );
	HRESULT		SetIADs      ( IADs* pADs );

	HRESULT		GetComputer ( BSTR * pstrComputer );
	HRESULT		GetService	( BSTR * pstrService );
	HRESULT		GetInstance	( DWORD * pdwInstance );
	HRESULT		GetName		( BSTR * pstrName );
	HRESULT		GetClass    ( BSTR * pstrSchema );
	HRESULT		GetIADs      ( IADs** ppADs );

    BSTR        QueryComputer   ( );
    DWORD       QueryInstance   ( );

protected:
	HRESULT		SetString	( CComBSTR & str, LPCWSTR wsz );
	HRESULT		GetString	( LPCWSTR wsz, BSTR * pstr );
	HRESULT		BuildAdsPath ( BOOL fIncludeName, BSTR * pstrPath );
	HRESULT		BuildSchemaPath ( BSTR * pstrPath );

//
//	Data:
//
private:
	CComBSTR	m_strComputer;
	CComBSTR	m_strService;
	DWORD		m_dwInstance;
	CComBSTR	m_strName;

    CComBSTR    m_strClass;
	CComBSTR	m_strSchema;

public:
    CComPtr<IADs>   m_pADs;
};

#endif // _ADSIMPL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\cmacro.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cmacro.h
//
//  Contents:  Macros for adsi methods
//
//  History:   21-04-97     sophiac    Created.
//
//----------------------------------------------------------------------------

#define DEFINE_CONTAINED_IADs_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_Name(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                              \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_ADsPath(retval));                            \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_Class(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Parent(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Schema(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_GUID(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    RRETURN(_pADs->Get(bstrName, pvProp));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    RRETURN(_pADs->Put(bstrName, vProp));                             \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    RRETURN(_pADs->GetEx(bstrName, pvProp));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    RRETURN(_pADs->PutEx(lnControlCode, bstrName, vProp));            \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetInfo(THIS_)                                                   \
{                                                                     \
    RRETURN(_pADs->GetInfo());                                        \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::SetInfo(THIS_ )                                                  \
{                                                                     \
    RRETURN(_pADs->SetInfo());                                        \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(_pADs->GetInfoEx(vProperties, lnReserved));               \
}


#define DEFINE_CONTAINED_IDSObject_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetObjectAttributes(                                             \
    PADS_ATTR_DEF pAttributeEntries,                                  \
    DWORD dwNumAttributes,                                            \
    DWORD *pdwNumAttributesModified                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->SetObjectAttributes(                             \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        pdwNumAttributesModified                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectAttributes(                                             \
    PADS_ATTR_NAME pAttributeNames,                                   \
    DWORD dwNumberAttributes,                                         \
    PADS_ATTR_DEF *ppAttributeEntries,                                \
    DWORD * pdwNumAttributesReturned                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectAttributes(                             \
                        pAttributeNames,                              \
                        dwNumberAttributes,                           \
                        ppAttributeEntries,                           \
                        pdwNumAttributesReturned                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateDSObject(                                                  \
    LPWSTR pszRDNName,                                                \
    PADS_ATTR_DEF pAttributeEntries,                                  \
    DWORD dwNumAttributes                                             \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->CreateDSObject(                                  \
                        pszRDNName,                                   \
                        pAttributeEntries,                            \
                        dwNumAttributes                               \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteDSObject(                                                  \
    LPWSTR pszRDNName                                                 \
    )                                                                 \
                                                                      \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->DeleteDSObject(                                  \
                        pszRDNName                                    \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectInformation(                                            \
    THIS_ PADS_OBJECT_INFO  *  ppObjInfo                              \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectInformation(                            \
                            ppObjInfo                                 \
                            );                                        \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IADsContainer_Implementation(cls)          \
STDMETHODIMP                                                          \
cls::get_Filter(THIS_ VARIANT FAR* pVar )                             \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Filter( pVar );                    \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Filter(THIS_ VARIANT Var )                                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Filter( Var );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Hints(THIS_ VARIANT FAR* pVar )                              \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Hints( pVar );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Hints(THIS_ VARIANT Var )                                    \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Hints( Var );                      \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Count(THIS_ long FAR* retval)                                \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Count( retval );                   \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get__NewEnum(THIS_ IUnknown * FAR * retval )                     \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get__NewEnum( retval );                \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObject(THIS_ BSTR ClassName, BSTR RelativeName,               \
               IDispatch * FAR * ppObject )                           \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->GetObject( ClassName, RelativeName, ppObject ); \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Create(THIS_ BSTR ClassName, BSTR RelativeName,                  \
            IDispatch * FAR * ppObject )                               \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr =_pADsContainer->Create( ClassName, RelativeName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Delete(THIS_ BSTR ClassName, BSTR SourceName )                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->Delete( ClassName, SourceName );       \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::CopyHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                           \
        hr = _pADsContainer->CopyHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::MoveHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                           \
        hr = _pADsContainer->MoveHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     

#define DEFINE_CONTAINED_IIsBaseObject_Implementation(cls)            \
STDMETHODIMP                                                          \
cls::GetDataPaths(THIS_ BSTR bstrName, LONG lnAttribute,              \
                  VARIANT FAR* pvProp)                                \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pIIsBaseObject) {                                           \
        hr = _pIIsBaseObject->GetDataPaths( bstrName, lnAttribute, pvProp);   \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetPropertyAttribObj(THIS_ BSTR bstrName,                        \
                          IDispatch * FAR *ppObject)                  \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pIIsBaseObject) {                                           \
        hr = _pIIsBaseObject->GetPropertyAttribObj(bstrName, ppObject); \
    }                                                                 \
    RRETURN(hr);                                                      \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\guids.cpp ===
//
//  Keep the top part in sync with stdafx.h
//


#pragma warning( disable : 4511 )

#include <ctype.h>
extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

//
//  ATL:
//

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <atlimpl.cpp>

//
//  GUIDS:
//

#define INITGUIDS
#include "initguid.h"

#include <iadm.h>

#include <iads.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\macro.h ===
//
//              This NonDelegating interface is completely for 3rd-party 
//              extension objects based on our implementation only. NO need 
//              to export to ADISclients or 3rd part writer or typelib.  
//              Will put it here for now. Move -> ?? 
//

#ifndef _INonDelegatingUnknown
#define _INonDelegatingUnknown
interface INonDelegatingUnknown
{
    virtual HRESULT STDMETHODCALLTYPE
    NonDelegatingQueryInterface(const IID&, void **) = 0; 

    virtual ULONG STDMETHODCALLTYPE 
    NonDelegatingAddRef() = 0;

    virtual ULONG STDMETHODCALLTYPE 
    NonDelegatingRelease() = 0;
};
#endif


#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}

#define DEFINE_IADsPutGet_UnImplementation(cls)                          \
STDMETHODIMP                                                             \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                             \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                     \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}


#define DEFINE_IPrivateDispatch_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::ADSIGetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ADSIGetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::ADSIGetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ADSIInvoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}


#define DEFINE_IADsExtension_Implementation(cls)                        \
STDMETHODIMP                                                            \
cls::PrivateGetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,            \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)           \
{                                                                       \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                           \
                                         rgszNames,                     \
                                         cNames,                        \
                                         lcid,                          \
                                         rgdispid                       \
                                         ));                            \
}                                                                       \
                                                                        \
STDMETHODIMP                                                            \
cls::PrivateInvoke(DISPID dispidMember, REFIID iid, LCID lcid,          \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,             \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,             \
        unsigned int FAR* puArgErr)                                     \
{                                                                       \
        RRETURN (_pDispMgr->Invoke(dispidMember,                        \
                                   iid,                                 \
                                   lcid,                                \
                                   wFlags,                              \
                                   pdispparams,                         \
                                   pvarResult,                          \
                                   pexcepinfo,                          \
                                   puArgErr                             \
                                   ));                                  \
}


#define DEFINE_DELEGATING_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
	if (_pADs == (LPVOID)this)                                        \
	{                                                                 \
        RRETURN(ADSIGetTypeInfoCount(pctinfo));                       \
	}                                                                 \
	else                                                              \
	{                                                                 \
        RRETURN(_pADs->GetTypeInfoCount(pctinfo));                    \
	}                                                                 \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
	if (_pADs == (LPVOID)this)                                        \
	{                                                                 \
        RRETURN(ADSIGetTypeInfo(itinfo,                               \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
	}                                                                 \
	else                                                              \
	{                                                                 \
        RRETURN(_pADs->GetTypeInfo(itinfo,                            \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
	}                                                                 \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
	if (_pADs == (LPVOID)this)                                        \
	{                                                                 \
        RRETURN(ADSIGetIDsOfNames(iid,                                \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
	}                                                                 \
	else                                                              \
	{                                                                 \
        RRETURN(_pADs->GetIDsOfNames(iid,                             \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
	}                                                                 \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
	if (_pADs == (LPVOID)this)                                        \
	{                                                                 \
        RRETURN (ADSIInvoke(dispidMember,                             \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
	}                                                                 \
	else                                                              \
	{                                                                 \
        RRETURN (_pADs->Invoke(dispidMember,                          \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
	}                                                                 \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\cmultisz.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	cmultisz.cpp

Abstract:

	Defines a class for manipulating registry style Multi-Sz's.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "cmultisz.h"

DWORD CMultiSz::Count ( ) const
{
	TraceQuietEnter ( "CMultiSz::Count" );

	LPCWSTR	msz		= m_msz;
	DWORD	cCount	= 0;

	_ASSERT ( m_msz );

	// this loop doesn't count \0\0 correctly, so that's a special case:
	if ( msz[0] == NULL && msz[1] == NULL ) {
		return 0;
	}

	do {

		cCount++;
		while ( *msz++ != NULL )
			// Empty while
			;

	} while ( *msz );

	return cCount;
}

SAFEARRAY * CMultiSz::ToSafeArray ( ) const
{
	TraceFunctEnter ( "CMultiSz::ToSafeArray" );

	SAFEARRAY *		psaResult	= NULL;
	DWORD			cCount		= 0;
	HRESULT			hr			= NOERROR;
	DWORD			i;
	const WCHAR *	wszCurrent	= NULL;

	if ( m_msz == NULL ) {
		goto Exit;
	}

	_ASSERT ( IS_VALID_STRING ( m_msz ) );

	// Get the array size:
	cCount = Count ();

	// Allocate a safearray of that size:
	SAFEARRAYBOUND	rgsaBounds[1];

	rgsaBounds[0].cElements	= cCount;
	rgsaBounds[0].lLbound	= 0;

	psaResult = SafeArrayCreate ( VT_BSTR, 1, rgsaBounds );

	if ( !psaResult ) {
		FatalTrace ( (LPARAM) this, "Failed to allocate array" );
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// Assign each member to the array:
	for ( 	wszCurrent = m_msz, i = 0;
			i < cCount;
			i++, wszCurrent += lstrlen (wszCurrent) + 1 ) {

		_ASSERT ( wszCurrent && *wszCurrent );
		_ASSERT ( IS_VALID_STRING ( wszCurrent ) );

		long	rgIndex[1];
		BSTR	strCopy;

		strCopy = ::SysAllocString ( wszCurrent );
		if ( strCopy == NULL ) {
			FatalTrace ( (LPARAM) this, "Out of memory" );
			goto Exit;
		}

		rgIndex[0] = i;
		hr = SafeArrayPutElement ( psaResult, rgIndex, (void *) strCopy );

		if ( FAILED(hr) ) {
			ErrorTraceX ( (LPARAM) this, "Failed to allocate element[%d]: %x", i, hr );
			FatalTrace ( (LPARAM) this, "Out of memory" );
			goto Exit;
		}
	}

Exit:
	// If something went wrong, free the resulting safe array:
	if ( FAILED(hr) ) {
		if ( psaResult ) {
			SafeArrayDestroy ( psaResult );
            psaResult = NULL;
		}
	}

	TraceFunctLeave ();
	return psaResult;
}

void CMultiSz::FromSafeArray ( SAFEARRAY * psaStrings )
{
	TraceFunctEnter ( "CMultiSz::FromSafeArray" );

	HRESULT		hr	= NOERROR;
	LPWSTR		msz = NULL;
	DWORD		cch	= 0;
	long		i;
	long		nLowerBound;
	long		nUpperBound;
	LPCWSTR *	pwszCurrent;
	LPWSTR		wszCopyTo;

	if ( psaStrings == NULL ) {
		m_msz	= NULL;
		goto Exit;
	}

	_ASSERT ( SafeArrayGetDim ( psaStrings ) == 1 );

	// Count the number of characters needed for the multi_sz:
	hr = SafeArrayGetLBound ( psaStrings, 1, &nLowerBound );
	_ASSERT ( SUCCEEDED(hr) );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = SafeArrayGetUBound ( psaStrings, 1, &nUpperBound );
	_ASSERT ( SUCCEEDED(hr) );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	//
	//	Special case: The empty array:
	//
	if ( nLowerBound > nUpperBound ) {
		WCHAR *		mszNew;

		mszNew = new WCHAR [2];

		if ( mszNew != NULL ) {
			delete m_msz;
			m_msz = mszNew;
			m_msz[0] = NULL;
			m_msz[1] = NULL;
		}
		goto Exit;
	}

	cch = 0;
	for ( i = nLowerBound; i <= nUpperBound; i++ ) {
		long		rgIndex[1];

		pwszCurrent = NULL;

		rgIndex[0] = i;

		hr = SafeArrayLock( psaStrings );
		if (SUCCEEDED(hr)) {
			hr = SafeArrayPtrOfIndex( psaStrings, rgIndex, (void **) &pwszCurrent );
			_VERIFY(SUCCEEDED(SafeArrayUnlock( psaStrings )));
		}

		_ASSERT ( SUCCEEDED(hr) );

		_ASSERT ( IS_VALID_STRING ( *pwszCurrent ) );

		if ( FAILED(hr) || !*pwszCurrent ) {
			if (!FAILED(hr)) hr = E_FAIL;
			goto Exit;
		}

		cch += lstrlen ( *pwszCurrent ) + 1;
	}
	// Add the final NULL terminator:
	cch += 1;

	// Allocate a multi_sz of that size:
	msz	= new WCHAR [ cch ];

	if ( msz == NULL ) {
		goto Exit;
	}

	wszCopyTo = msz;

	// Copy each string into the multi_sz:

	for ( i = nLowerBound; i <= nUpperBound; i++ ) {
		long		rgIndex[1];

		pwszCurrent = NULL;

		rgIndex[0] = i;

		hr = SafeArrayLock( psaStrings );
		if (SUCCEEDED(hr)) {
			hr = SafeArrayPtrOfIndex( psaStrings, rgIndex, (void **) &pwszCurrent );
			_VERIFY(SUCCEEDED(SafeArrayUnlock( psaStrings )));
		}

		_ASSERT ( SUCCEEDED(hr) );

		_ASSERT ( IS_VALID_STRING ( *pwszCurrent ) );

		if ( FAILED(hr) || !*pwszCurrent ) {
			if (!FAILED(hr)) hr = E_FAIL;			
			goto Exit;
		}

		lstrcpy ( wszCopyTo, *pwszCurrent );
		wszCopyTo += lstrlen ( *pwszCurrent ) + 1;
	}
	// Add the final NULL terminator:
	*wszCopyTo = NULL;

	_ASSERT ( CountChars ( msz ) == cch );

	_ASSERT ( SUCCEEDED(hr) );
	delete m_msz;
	m_msz = msz;

Exit:
	if ( FAILED(hr) && msz) {
		delete msz;
	}

	TraceFunctLeave ();
	return;
}

DWORD CMultiSz::CountChars ( LPCWSTR mszSource )
{
	TraceQuietEnter ( "CMultiSz::CountChars" );

	DWORD		cch	= 0;
	LPCWSTR		msz	= mszSource;

	// _ASSERT ( msz is a multi sz string )
	_ASSERT ( IS_VALID_STRING ( msz ) );

	do {

		while ( *msz != NULL ) {
			msz++;
			cch++;
		}

		// Count the NULL terminator:
		msz++;
		cch++;

	} while ( *msz );

	// Count the NULL terminator:
	cch++;

	_ASSERT ( !IsBadReadPtr ( mszSource, cch * sizeof (WCHAR) ) );

	_ASSERT ( mszSource[cch - 1] == NULL );
	_ASSERT ( mszSource[cch - 2] == NULL );

	return cch;
}

LPWSTR CMultiSz::Duplicate ( LPCWSTR msz )
{
	TraceQuietEnter ( "CMultiSz::Duplicate" );

	LPWSTR	mszResult	= NULL;
	DWORD	cch			= 0;

	if ( msz == NULL ) {
		goto Exit;
	}

	cch = CountChars ( msz );

	mszResult = new WCHAR [ cch ];

	if ( mszResult == NULL ) {
		goto Exit;
	}

	CopyMemory ( mszResult, msz, cch * sizeof (WCHAR) );

	_ASSERT ( cch == CountChars ( mszResult ) );

Exit:
	return mszResult;
}

LPWSTR CMultiSz::CreateEmptyMultiSz ( )
{
	LPWSTR		mszResult;

	mszResult = new WCHAR [ 2 ];
	if ( mszResult ) {
		mszResult[0] = _T('\0');
		mszResult[1] = _T('\0');
	}

	return mszResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//		multiple IDispatch-callable interfaces.
//
//  Classes:	CAggregateeDispMgr
//
//  Functions:	None external.
//
//  History:    ??-???-??   KrishnaG   created
//		07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//

//
// Necessary system headers.
//
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//
#include "dbgtrace.h"
#include "macro.h"
#include "admmacro.h"
#include "iprops.hxx"
#include "cdispmgr.hxx"

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:	Simplified from Win4AssertEx, to make this dispatch manager
//  		not depend on other files.
//
//----------------------------------------------------------------------------
static void
AssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[256+1];

    _snprintf(szAssertCaption, 256, "File: %s line %u, thread id %d",
	szFile, iLine, GetCurrentThreadId());

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
	DebugBreak();
    }
}
# define DispMgrAssert(x)  (void)((x) || (AssertEx(__FILE__, __LINE__, #x),0))
#else
# define AssertEx(f,l,m)   
# define DispMgrAssert(x)  
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(
    LONG ExtensionId,
    LONG TypeInfoId,
    LONG DispId,
    DISPID *pResult
    )
{
    if (DispId == DISPID_UNKNOWN){

    	*pResult = DispId;

    }else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
	                DispId < 0 || DispId >= 0x10000){

	    //
	    // Might happen if some object has very large dispid's.
	    // But we can't handle it if it does.
	    //
	    *pResult = DISPID_UNKNOWN;
    }
    else{

	    *pResult = ((ExtensionId & 0xff) << 24) |((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

    }

}


static inline void
MakeDISPIDs(
    LONG ExtensionId,
    LONG TypeInfoId,
    DISPID *rgdispid,
    unsigned int cNames
    )
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(ExtensionId, TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CAggregateeDispMgr::CAggregateeDispMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
    _dwExtensionID = 0;
}

CAggregateeDispMgr::~CAggregateeDispMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;
        pTypeInfo->Release();

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

}

void
CAggregateeDispMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}


STDMETHODIMP
CAggregateeDispMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregateeDispMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

//
// NOTE: This works only for single names; if multiple names are
// passed we die big time. This is help us get going using VB's _NewEnum
//

STDMETHODIMP
CAggregateeDispMgr::GetIDsOfNames(REFIID iid, LPWSTR *rgszNames,
        unsigned int cNames, LCID lcid, DISPID *rgdispid)
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {

            // 
            // aggregatee no longer needs to include extension id
            // in dispid.  
            //

            MakeDISPIDs(0, pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
	hr = S_OK;
	for (DWORD dw = 0; dw < cNames; dw++) {
	    if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
		    (PDWORD)(rgdispid + dw)))) {
		hr = DISP_E_UNKNOWNNAME;
		rgdispid[dw] = DISPID_UNKNOWN;
	    }
	}
	if (SUCCEEDED(hr)) {

            // 
            // aggregatee no longer needs to include extension id
            // in dispid.  
            //

	    MakeDISPIDs(0, _dwPropCacheID, rgdispid, cNames);
	}
    }

    return hr;
}

STDMETHODIMP
CAggregateeDispMgr::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,
	unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
	EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CAggregateeDispMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CAggregateeDispMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CAggregateeDispMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CAggregateeDispMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CAggregateeDispMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

    return S_OK;

Exit:
    return hr;
}

STDMETHODIMP
CAggregateeDispMgr::TypeInfoInvoke(DISPID dispidMember, REFIID iid, LCID lcid,
	unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
	EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

    	//
	    // One of the special DISPIDs.
	    //
	    // If we have an interface pointer for it, use that.
	    // If we don't, and we have a base IDispatch pointer,
	    //   pass it to the base pointer's Invoke() method.
	    // If we don't, and we don't have a base IDispatch pointer,
	    //   return failure.
	    //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
	    break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

	    if (!pInterfacePtr) {

	        BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);

	    }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else {

        //                           	
	    // A regular DISPID of ours.
	    //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

	    if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
	        pInterfacePtr = getInterfacePtr(typeinfoid);
	        pTypeInfo = getTypeInfo(typeinfoid);
	        if (!pTypeInfo)
		        //
		    // Shouldn't happen.
		    //
		    BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
	    }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = AggregateeDynamicDispidInvoke(
                        _pPropertyCache,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

Exit:
    return hr;
}


HRESULT
AggregateeDynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid,pvarResult);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        if (pdispparams[0].cArgs != 1){
            //
            // We only handle one arg for now
            //
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

Exit:
    return(hr);

}


HRESULT
CAggregateeDispMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CAggregateeDispMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CAggregateeDispMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    DispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}

typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;


PTYPEINFO_TABLE gpAggregateeTypeInfoTable = NULL;

ITypeInfo *
AggregateeFindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}


PTYPEINFO_TABLE
AggregateeAddTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid,
    ITypeInfo * pTypeInfo
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = (PTYPEINFO_TABLE)LocalAlloc(LPTR, sizeof(TYPEINFO_TABLE));
    if (!pTemp) {
        return NULL;
    }

    memcpy(&pTemp->iid, &iid, sizeof(GUID));
    pTemp->pTypeInfo = pTypeInfo;
    pTemp->pNext = pTypeInfoTable;

    return pTemp;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
AggregateeLoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    DispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (hr)
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CAggregateeDispMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    pTypeInfo = ::AggregateeFindTypeInfo(gpAggregateeTypeInfoTable, iid);
    if (!pTypeInfo) {

        hr = AggregateeLoadTypeInfo(libid, iid, &pTypeInfo);
        BAIL_ON_FAILURE(hr);

        gpAggregateeTypeInfoTable = ::AggregateeAddTypeInfo(gpAggregateeTypeInfoTable, iid, pTypeInfo);
        if (!gpAggregateeTypeInfoTable) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }
    }
// this caused a BVT break, putting back in
// awetmore - 83980
// in svcs\adsi\adsiis you can see that IIS has removed this as well
    pTypeInfo->AddRef();


    hr = AddTypeInfo(pTypeInfo, pIntf);
    BAIL_ON_FAILURE(hr);

    if (SpecialId == -4) {
	hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
	hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

Exit:
    if (pTypeInfo)
	pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CAggregateeDispMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}

void
AggregateeFreeTypeInfoTable()
{
    PTYPEINFO_TABLE pTypeInfoTable = NULL;
    PTYPEINFO_TABLE pTemp = NULL;
    ITypeInfo * pTypeInfo = NULL;

    pTypeInfoTable = gpAggregateeTypeInfoTable;

    while (pTypeInfoTable) {

        pTypeInfo = pTypeInfoTable->pTypeInfo;

        pTypeInfo->Release();


        pTemp = pTypeInfoTable;

        pTypeInfoTable = pTypeInfoTable->pNext;

        LocalFree(pTemp);
    }
}

HRESULT
CAggregateeDispMgr::InitializeDispMgr(
    DWORD dwExtensionID
    )
{
    if (dwExtensionID > 255) {
        return(E_FAIL);
    }
    _dwExtensionID = dwExtensionID;

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\fsmacro.h ===
#define PUT_PROPERTY_LONG(this, Property) \
                RRETURN(put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ))

#define GET_PROPERTY_LONG(this, Property) \
                RRETURN(get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_BSTR(this, Property) \
                RRETURN(put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ))

#define GET_PROPERTY_BSTR(this, Property) \
                RRETURN(get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ))

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_DATE(this, Property) \
                RRETURN(put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ))

#define GET_PROPERTY_DATE(this, Property) \
                RRETURN(get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_VARIANT(this, Property) \
                RRETURN(put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ))

#define GET_PROPERTY_VARIANT(this, Property) \
                RRETURN(get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\cmultisz.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	cmultisz.h

Abstract:

	Defines the CMultiSz class for dealing with multi_sz's (These are
	a double null terminated list of strings).

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _CMULTISZ_INCLUDED_
#define _CMULTISZ_INCLUDED_

//$-------------------------------------------------------------------
//
//	Class:	CMultiSz
//
//	Description:
//
//		Handles double-null terminated strings.
//
//	Interface:
//
//
//
//--------------------------------------------------------------------

class CMultiSz
{
public:
	// Construction & Destruction:
	inline CMultiSz		( );
	inline CMultiSz		( LPCWSTR msz );
	inline ~CMultiSz	( );

	// Properties of the multi_sz:
	DWORD				Count ( ) const;
	inline DWORD		SizeInBytes ( ) const;

	// Overloaded operators:
	inline 				operator LPCWSTR( );
	inline BOOL			operator!		( ) const;
	inline const CMultiSz &		operator= ( LPCWSTR wszMultiByte );
	inline const CMultiSz &		operator= ( const CMultiSz & msz );

	// Copying:
	inline LPWSTR		Copy			( ) const;

	// Attaching & Detaching:
	inline void			Attach			( LPWSTR msz );
	inline LPWSTR		Detach			( );
	inline void			Empty			( );

	// !!!magnush - remove these after move to VARIANT:
	// Safearray <--> Multisz:
	SAFEARRAY *			ToSafeArray		( ) const;
	void				FromSafeArray	( /* const */ SAFEARRAY * psaStrings );

private:
	// Data:
	LPWSTR		m_msz;

	// Private Methods:
	static DWORD		CountChars		( LPCWSTR msz );
	static LPWSTR		Duplicate		( LPCWSTR msz );
	static LPWSTR		CreateEmptyMultiSz	( );
};

// Inlined functions:

inline CMultiSz::CMultiSz ()
{
	m_msz	= NULL;
}

inline CMultiSz::CMultiSz ( LPCWSTR msz )
{
	m_msz	= Duplicate ( msz );
}

inline CMultiSz::~CMultiSz ()
{
	delete m_msz;
}

inline DWORD CMultiSz::SizeInBytes () const
{
	return sizeof ( WCHAR ) * CountChars ( m_msz );
}

inline CMultiSz::operator LPCWSTR()
{
	return m_msz;
}

inline BOOL CMultiSz::operator! () const
{
	return (m_msz == NULL) ? TRUE : FALSE;
}

inline const CMultiSz & CMultiSz::operator= ( const CMultiSz & msz )
{
	if ( &msz != this ) {
		m_msz = Duplicate ( msz.m_msz );
	}

	return *this;
}

inline const CMultiSz & CMultiSz::operator= ( LPCWSTR wszMultiByte )
{
	delete m_msz;
	m_msz = Duplicate ( wszMultiByte );

	return *this;
}

inline LPWSTR CMultiSz::Copy ( ) const
{
	return Duplicate ( m_msz );
}

inline void CMultiSz::Attach ( LPWSTR msz )
{
	if ( m_msz != msz ) {
		delete m_msz;
		m_msz	= msz;
	}
}

inline LPWSTR CMultiSz::Detach ( )
{
	LPWSTR	mszResult = m_msz;
	m_msz	= NULL;
	return mszResult;
}

inline void CMultiSz::Empty ( )
{
	delete m_msz;
	m_msz	= NULL;
}

#endif // _CMULTISZ_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\metakey.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metakey.cpp

Abstract:

	A class to help manipulate metabase keys.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "metakey.h"

#define MD_DEFAULT_TIMEOUT      5000
static BOOL IsValidIntegerSubKey ( LPCWSTR wszSubKey );

//$-------------------------------------------------------------------
//
//	CreateMetabaseObject
//
//	Description:
//
//		Creates an instance of the metabase object on the given
//		machine and initializes it.
//
//	Parameters:
//
//		wszMachine - The machine to create the metabase on.
//		ppMetabase - Returns the resulting metabase pointer.
//
//	Returns:
//
//		Error code from CoCreateInstance or the metabase routines.
//
//--------------------------------------------------------------------

HRESULT CreateMetabaseObject ( LPCWSTR wszMachine, IMSAdminBase ** ppMetabaseResult )
{
	TraceFunctEnter ( "CreateMetabaseObject" );

	// Check parameters:
	_ASSERT ( ppMetabaseResult != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppMetabaseResult ) );

	if ( ppMetabaseResult == NULL ) {
		FatalTrace ( 0, "Bad Return Pointer" );

		TraceFunctLeave ();
		return E_POINTER;
	}

	// Variables:
	HRESULT				hr	= NOERROR;
	IMSAdminBase		*pMetabase;
	IMSAdminBase		*pMetabaseT;
	MULTI_QI			mqi[1];
	COSERVERINFO		coserver;

	// Zero the out parameter:
	*ppMetabaseResult = NULL;

	// QI for IID_IMSAdminBase:
	mqi[0].pIID	= &IID_IMSAdminBase;
	mqi[0].pItf	= NULL;
	mqi[0].hr	= 0;

	// Which remote server to talk to:
	coserver.dwReserved1	= 0;
	coserver.dwReserved2	= 0;
	coserver.pwszName		= const_cast<LPWSTR> (wszMachine);
	coserver.pAuthInfo		= NULL;

	// Create the object:
	hr = CoCreateInstanceEx (
		CLSID_MSAdminBase,
		NULL,
		CLSCTX_ALL,
		wszMachine ? &coserver : NULL,
		1,
		mqi );

	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "CoCreate(metabase) failed %x", hr );
		goto Exit;
	}

	if ( FAILED(mqi[0].hr) ) {
		hr = mqi[0].hr;
		ErrorTraceX ( 0, "QI(metabase) failed %x", hr );
		goto Exit;
	}

	// Get the interface pointer:
	pMetabaseT = (IMSAdminBase *) mqi[0].pItf;

	// this gets us a version of the metabase which won't go through COM
	// proxy/stubs, so ACL checking will work properly.  If it fails we'll
	// just continue to use the marshalled version.
	_ASSERT(pMetabaseT != NULL);
	pMetabase = NULL;
	if (FAILED(pMetabaseT->UnmarshalInterface((IMSAdminBaseW **)&pMetabase))) {
	    pMetabase = pMetabaseT;
	} else {
		pMetabaseT->Release();
	}

	// Return the interface pointer:
	_ASSERT ( pMetabase );
	*ppMetabaseResult = pMetabase;

Exit:
	TraceFunctLeave ();
	return hr;

	// pMetabase will be released automatically.
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::CMetabaseKey
//
//	Description:
//
//		Initializes the CMetabaseKey
//
//	Parameters:
//
//		pMetabase - a pointer to the metabase object.
//
//--------------------------------------------------------------------

CMetabaseKey::CMetabaseKey ( IMSAdminBase * pMetabase )
{
	_ASSERT ( pMetabase );

	m_pMetabase				= pMetabase;
	m_hKey					= NULL;
	m_cChildren				= 0;
	m_cIntegerChildren		= 0;
	m_indexCursor			= 0;
	m_dwMaxIntegerChild		= 0;

	pMetabase->AddRef ();
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::~CMetabaseKey
//
//	Description:
//
//		Destroys the metabase key
//
//--------------------------------------------------------------------

CMetabaseKey::~CMetabaseKey ( )
{
	Close ();

	if ( m_pMetabase ) {
		m_pMetabase->Release ();
	}
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::Open
//
//	Description:
//
//		Opens a key and associates that key with this object.
//
//	Parameters:
//
//		hParentKey - the already open key to use a base.
//		szPath - path of the key to open
//		dwPermissions - READ or WRITE access.
//
//	Returns:
//
//		see IMSAdminBase::OpenKey
//
//--------------------------------------------------------------------

HRESULT CMetabaseKey::Open ( METADATA_HANDLE hParentKey, IN LPCWSTR szPath, DWORD dwPermissions )
{
	TraceFunctEnter ( "CMetabaseKey::Open" );

	HRESULT		hr	= NOERROR;

	Close ();

	hr = m_pMetabase->OpenKey ( 
		hParentKey,
		szPath,
		dwPermissions,
		MD_DEFAULT_TIMEOUT,
		&m_hKey
		);

	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open key %s: %x", szPath, hr );
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::Attach
//
//	Description:
//
//		Attaches this object to an already opened metabase key.
//
//	Parameters:
//
//		hKey - the opened metabase key
//
//--------------------------------------------------------------------

void CMetabaseKey::Attach ( METADATA_HANDLE hKey )
{
	Close ();

	_ASSERT ( hKey != NULL );
	m_hKey = hKey;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::Detach
//
//	Description:
//
//		Detaches the metabase key from this object and returns it
//
//	Returns:
//
//		The key handle that this object is holding.
//
//--------------------------------------------------------------------

METADATA_HANDLE CMetabaseKey::Detach ( )
{
	METADATA_HANDLE	hKeyResult;

	hKeyResult = m_hKey;
	m_hKey = NULL;

	return hKeyResult;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::Close
//
//	Description:
//
//		Closes the key that this object has open.
//
//--------------------------------------------------------------------

void CMetabaseKey::Close ( )
{
	TraceFunctEnter ( "CMetabaseKey::Close" );

	HRESULT		hr;

	if ( m_hKey ) {
		hr = m_pMetabase->CloseKey ( m_hKey );

		_ASSERT ( SUCCEEDED(hr) );
		m_hKey = NULL;
	}

	TraceFunctLeave ();
}

void CMetabaseKey::GetLastChangeTime ( FILETIME * pftGMT, LPCWSTR wszPath )
{
	_ASSERT ( m_hKey );
	_ASSERT ( IS_VALID_OUT_PARAM ( pftGMT ) );

	HRESULT		hr;

	hr = m_pMetabase->GetLastChangeTime ( m_hKey, wszPath, pftGMT, FALSE );
	_ASSERT ( SUCCEEDED(hr) );
}

HRESULT CMetabaseKey::EnumObjects ( IN LPCWSTR wszPath, LPWSTR wszSubKey, DWORD dwIndex )
{
	TraceFunctEnter ( "CMetabaseKey::EnumObjects" );

	HRESULT		hr;

	hr = m_pMetabase->EnumKeys ( m_hKey, wszPath, wszSubKey, dwIndex );

	TraceFunctLeave ();
	return hr;
}

HRESULT CMetabaseKey::DeleteKey ( LPCWSTR wszPath )
{
	TraceFunctEnter ( "CMetabaseKey::DeleteKey" );

	HRESULT		hr;

    hr = m_pMetabase->DeleteKey ( m_hKey, wszPath );

    TraceFunctLeave ();
    return hr;
}

HRESULT CMetabaseKey::DeleteAllData ( LPCWSTR wszPath )
{
	TraceFunctEnter ( "CMetabaseKey::DeleteAllData" );

	HRESULT		hr;

    hr = m_pMetabase->DeleteAllData ( m_hKey, wszPath, ALL_METADATA, ALL_METADATA );

    TraceFunctLeave ();
    return hr;
}

HRESULT CMetabaseKey::ChangePermissions ( DWORD dwPermissions )
{
	TraceFunctEnter ( "CMetabaseKey::ChangePermissions" );

	HRESULT		hr;

    _ASSERT (
        dwPermissions == METADATA_PERMISSION_WRITE ||
        dwPermissions == METADATA_PERMISSION_READ
        );

    hr = m_pMetabase->ChangePermissions ( m_hKey, 10, dwPermissions );

    TraceFunctLeave ();
    return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::Save
//
//	Description:
//
//		Saves the changes.
//
//--------------------------------------------------------------------

HRESULT CMetabaseKey::Save ( )
{
	TraceFunctEnter ( "CMetabaseKey::Save" );

	HRESULT		hr = NOERROR;

/*
    This call is now unnecessary.

	hr = m_pMetabase->SaveData ( );
*/

	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::GetChildCount
//
//	Description:
//
//		Returns the number of subkeys of the current metabase key.
//
//	Parameters:
//
//		pcChildren - resulting number of subkeys.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::GetChildCount ( OUT DWORD * pcChildren )
{
	_ASSERT ( m_hKey != NULL );

	if ( m_cChildren != 0 ) {
		*pcChildren = m_cChildren;
		return NOERROR;
	}

	HRESULT		hr;

	hr = CountSubkeys ( 
		NULL,
		&m_cChildren, 
		&m_cIntegerChildren, 
		NULL,
		&m_dwMaxIntegerChild 
		);

	*pcChildren = m_cChildren;
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::GetIntegerChildCount
//
//	Description:
//
//		Returns the number of integer subkeys of the current key.
//
//	Parameters:
//
//		pcIntegerChildren - the number of integer subkeys of the currently
//			opened key.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::GetIntegerChildCount ( OUT DWORD * pcIntegerChildren )
{
	_ASSERT ( m_hKey != NULL );

	if ( m_cChildren != 0 ) {
		*pcIntegerChildren = m_cIntegerChildren;
		return NOERROR;
	}

	HRESULT		hr;

	hr = CountSubkeys ( 
		NULL,
		&m_cChildren, 
		&m_cIntegerChildren, 
		NULL,
		&m_dwMaxIntegerChild 
		);

	*pcIntegerChildren = m_cIntegerChildren;
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::GetCustomChildCount
//
//	Description:
//
//		Returns the number of subkeys of the current metabase key
//		for which fpIsCustomKey returns true.
//
//	Parameters:
//
//		pcCustomChildren - resulting number of subkeys.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::GetCustomChildCount ( 
	KEY_TEST_FUNCTION	fpIsCustomKey,
	OUT DWORD * 		pcCustomChildren 
	)
{
	_ASSERT ( m_hKey != NULL );
	_ASSERT ( fpIsCustomKey );
	_ASSERT ( IS_VALID_OUT_PARAM ( pcCustomChildren ) );

	HRESULT		hr;

	hr = CountSubkeys ( 
		fpIsCustomKey, 
		&m_cChildren, 
		&m_cIntegerChildren, 
		pcCustomChildren, 
		&m_dwMaxIntegerChild 
		);

	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::BeginChildEnumeration
//
//	Description:
//
//		Sets up the object to enumerate subkeys.
//		Call before calling NextChild or NextIntegerChild.
//
//--------------------------------------------------------------------

void CMetabaseKey::BeginChildEnumeration	 	( )
{
	TraceFunctEnter ( "CMetabaseKey::BeginChildEnumeration" );

	_ASSERT ( m_hKey != NULL );

	HRESULT	hr;

	m_indexCursor	= 0;

	StateTrace ( (LPARAM) this, "Changing to Read Permission" );
	hr = m_pMetabase->ChangePermissions ( m_hKey, 1, METADATA_PERMISSION_READ );
	_ASSERT ( SUCCEEDED(hr) );
	if ( FAILED (hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to change permissions to read: %x", hr );
	}

	TraceFunctLeave ();
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::NextChild
//
//	Description:
//
//		Returns the name of the next subkey.
//		Call BeginChildEnumeration before calling NextChild
//
//	Parameters:
//
//		szChildKey - the resulting key name
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::NextChild ( OUT LPWSTR wszChildKey )
{
	TraceFunctEnter ( "CMetabaseKey::NextChild" );

	_ASSERT ( IS_VALID_OUT_PARAM ( wszChildKey ) );

	_ASSERT ( m_hKey != NULL );
	_ASSERT ( m_indexCursor < m_cChildren );

	HRESULT		hr;

	*wszChildKey = NULL;

	// Use the m_indexCursor to enumerated the next child:
	hr = m_pMetabase->EnumKeys ( m_hKey, _T(""), wszChildKey, m_indexCursor );
	if ( FAILED (hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to get next child: %x", hr );
		goto Exit;
	}

	m_indexCursor++;

Exit:
	// This means that you called NextChild more times than
	// was possible:
	_ASSERT ( HRESULTTOWIN32 ( hr ) != ERROR_NO_MORE_ITEMS );

	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::NextIntegerChild
//
//	Description:
//
//		Returns the name of the next integer subkey.
//		Call BeginChildEnumeration before calling NextIntegerChild
//
//	Parameters:
//
//		pdwID - the integer value of the subkey.
//		szIntegerChildKey - the subkey name string.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::NextIntegerChild ( OUT DWORD * pdwID, OUT LPWSTR wszIntegerChildKey )
{
	TraceFunctEnter ( "CMetabaseKey::NextChild" );

	_ASSERT ( IS_VALID_OUT_PARAM ( pdwID ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( wszIntegerChildKey ) );

	_ASSERT ( m_hKey != NULL );
	_ASSERT ( m_indexCursor < m_cChildren );

	HRESULT		hr;
	BOOL		fFoundInteger;

	*pdwID				= 0;
	*wszIntegerChildKey 	= NULL;

	for ( fFoundInteger = FALSE; !fFoundInteger; ) {

		// Use the m_indexCursor to enumerated the next child:
		hr = m_pMetabase->EnumKeys ( m_hKey, _T(""), wszIntegerChildKey, m_indexCursor );
		if ( FAILED (hr) ) {
			goto Exit;
		}

		if ( IsValidIntegerSubKey ( wszIntegerChildKey ) ) {
			fFoundInteger = TRUE;
			*pdwID = _wtoi ( wszIntegerChildKey );
		}

		m_indexCursor++;
	}

Exit:
	// This means that you called NextIntegerChild more times than
	// was possible:
	_ASSERT ( HRESULTTOWIN32 ( hr ) != ERROR_NO_MORE_ITEMS );

	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::NextCustomChild
//
//	Description:
//
//		Returns the name of the next subkey for which fpIsCustomKey
//		returns true.
//		Call BeginChildEnumeration before calling NextCustomChild
//
//	Parameters:
//
//		fpIsCustomKey	- function that returns true if a given key
//			should be returned.
//		szChildKey - the resulting key name
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::NextCustomChild ( 
	KEY_TEST_FUNCTION	fpIsCustomKey,
	OUT LPWSTR wszChildKey 
	)
{
	TraceFunctEnter ( "CMetabaseKey::NextCustomChild" );

	_ASSERT ( fpIsCustomKey );
	_ASSERT ( IS_VALID_OUT_PARAM ( wszChildKey ) );

	_ASSERT ( m_hKey != NULL );
	_ASSERT ( m_indexCursor < m_cChildren );

	HRESULT		hr;
	BOOL		fFoundCustomKey;

	*wszChildKey = NULL;

	for ( fFoundCustomKey = FALSE; !fFoundCustomKey; ) {

		// Use the m_indexCursor to enumerated the next child:
		hr = m_pMetabase->EnumKeys ( m_hKey, _T(""), wszChildKey, m_indexCursor );
		if ( FAILED (hr) ) {
			goto Exit;
		}

		if ( fpIsCustomKey ( wszChildKey ) ) {
			fFoundCustomKey = TRUE;
		}

		m_indexCursor++;
	}

Exit:
	// This means that you called NextCustomChild more times than
	// was possible:
	_ASSERT ( HRESULTTOWIN32 ( hr ) != ERROR_NO_MORE_ITEMS );

	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::CreateChild
//
//	Description:
//
//		Creates the given path under the currently opened key.
//		Changes the current key to write permission.
//		Note: Does not call SaveData.
//
//	Parameters:
//
//		szChildPath - name of the subkey to create.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::CreateChild ( IN LPWSTR wszChildPath )
{
	TraceFunctEnter ( "CMetabaseKey::CreateChild" );

	_ASSERT ( wszChildPath );
	_ASSERT ( m_hKey != NULL );
	
	HRESULT		hr;

	StateTrace ( (LPARAM) this, "Changing to Write Permission" );
	hr = m_pMetabase->ChangePermissions ( m_hKey, MD_DEFAULT_TIMEOUT, METADATA_PERMISSION_WRITE );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = m_pMetabase->AddKey ( m_hKey, wszChildPath );
	if ( FAILED (hr) ) {
		goto Exit;
	}

/*
	// !!!magnush - Should we save the data now?
	hr = m_pMetabase->SaveData ();
	if ( FAILED (hr) ) {
		goto Exit;
	}
*/

	m_cChildren++;
	if ( IsValidIntegerSubKey ( wszChildPath ) ) {
		m_cIntegerChildren++;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::DestroyChild
//
//	Description:
//
//		Deletes the given subkey
//		Changes the current key to write permission.
//		Note: Does not call SaveData
//
//	Parameters:
//
//		szChildPath - the name of the subkey to delete.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::DestroyChild ( IN LPWSTR wszChildPath )
{
	TraceFunctEnter ( "CMetabaseKey::DestroyChild" );

	_ASSERT ( wszChildPath );
	_ASSERT ( m_hKey != NULL );

	HRESULT	hr;

	StateTrace ( (LPARAM) this, "Changing to Write Permission" );
	hr = m_pMetabase->ChangePermissions ( m_hKey, MD_DEFAULT_TIMEOUT, METADATA_PERMISSION_WRITE );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = m_pMetabase->DeleteKey ( m_hKey, wszChildPath );
	if ( FAILED (hr) ) {
		goto Exit;
	}

/*
	// !!!magnush - Should we save the data now?
	hr = m_pMetabase->SaveData ();
	if ( FAILED (hr) ) {
		goto Exit;
	}
*/

	m_cChildren--;
	if ( IsValidIntegerSubKey ( wszChildPath ) ) {
		m_cIntegerChildren--;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::CreateIntegerChild
//
//	Description:
//
//		Creates an integer subkey of the currently open key.
//		This key will be 1 + the highest integer subkey.
//
//	Parameters:
//
//		pdwID - the resulting integer value.
//		szChildPath - the resulting subkey path.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::CreateIntegerChild ( OUT DWORD * pdwID, OUT LPWSTR wszChildPath )
{
	TraceFunctEnter ( "CMetabaseKEy::CreateIntegerChild" );

	_ASSERT ( IS_VALID_OUT_PARAM ( pdwID ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( wszChildPath ) );
	_ASSERT ( m_hKey != NULL );

	HRESULT		hr	= NOERROR;
	DWORD		dwId;

	*pdwID 			= 0;
	*wszChildPath 	= NULL;

	for ( dwId = 1; dwId != 0; dwId++ ) {
		//
		//	Keep trying to add an instance key until it works:
		//

		wsprintf ( wszChildPath, _T("%d"), dwId );

		hr = CreateChild ( wszChildPath );
		if ( SUCCEEDED(hr) ) {
			// We created the child, so lets get out of here.
			break;
		}
		else if ( HRESULTTOWIN32 ( hr ) == ERROR_ALREADY_EXISTS ) {
			// Child already exists, try the next one.
			continue;
		}
		else {
			// Real error: report it and bail.
			ErrorTrace ( (LPARAM) this, "Error %d adding %s\n", HRESULTTOWIN32(hr), wszChildPath );
			goto Exit;
		}
	}

	if ( dwId == 0 ) {
		hr = E_FAIL;
		goto Exit;
	}
	
	_ASSERT ( SUCCEEDED(hr) );
	if ( dwId > m_dwMaxIntegerChild ) {
		m_dwMaxIntegerChild = dwId;
	}

	*pdwID = dwId;

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::DestroyIntegerChild
//
//	Description:
//
//		Deletes the given integer subkey.
//
//	Parameters:
//
//		i - the subkey to delete
//
//	Returns:
//
//		metabase error code
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::DestroyIntegerChild ( IN DWORD i )
{
	TraceFunctEnter ( "CMetabaseKey::DestroyIntegerChild" );

	_ASSERT ( i != 0 );
	_ASSERT ( m_hKey != NULL );

	WCHAR	wszChild [ METADATA_MAX_NAME_LEN ];
	HRESULT	hr;

	wsprintf ( wszChild, _T("%d"), i );

	hr = DestroyChild ( wszChild );

	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::CountSubKeys
//
//	Description:
//
//		Returns the number of subkeys and integer subkeys of the
//		current metabase key.
//		Changes the key to read permission.
//
//	Parameters:
//
//		fpIsCustomKey - Function that takes a key and returns true
//			if that key should be included in the custom child count.
//		pcSubKeys - number of subkeys.
//		pcIntegerSubKeys - number of integer subkeys.
//		pcCustomChildren - the number of keys for which fpIsCustomKey
//			returns true.
//		pdwMaxIntegerSubkey - the highest integer subkey value.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT CMetabaseKey::CountSubkeys ( 
	KEY_TEST_FUNCTION	fpIsCustomKey,
	OUT DWORD * 		pcSubKeys, 
	OUT DWORD *			pcIntegerSubKeys,
	OUT DWORD * 		pcCustomSubKeys,
	OUT DWORD * 		pdwMaxIntegerSubKey
	)
{
	TraceFunctEnter ( "CMetabaseKey::CountSubKeys" );

	_ASSERT ( pcSubKeys );
	_ASSERT ( IS_VALID_OUT_PARAM ( pcSubKeys ) );
	_ASSERT ( pcIntegerSubKeys );
	_ASSERT ( IS_VALID_OUT_PARAM ( pcIntegerSubKeys ) );
//	_ASSERT ( pcCustomSubKeys );
//	_ASSERT ( IS_VALID_OUT_PARAM ( pcCustomSubKeys ) );
	_ASSERT ( m_hKey != NULL );

	// Zero the out parameter:
	*pcSubKeys				= 0;
	*pcIntegerSubKeys		= 0;
	*pdwMaxIntegerSubKey	= 0;
	if ( pcCustomSubKeys ) {
		*pcCustomSubKeys		= 0;
	}

	HRESULT	hr					= NOERROR;
	DWORD	cItems				= 0;
	DWORD	cIntegerItems		= 0;
	DWORD	cCustomItems		= 0;
	DWORD	dwMaxIntegerSubKey	= 0;
	WCHAR	wszName [ METADATA_MAX_NAME_LEN ];
	DWORD	i					= 0;

	StateTrace ( (LPARAM) this, "Changing to Read Permission" );
	hr = m_pMetabase->ChangePermissions ( m_hKey, 1, METADATA_PERMISSION_READ );
	_ASSERT ( SUCCEEDED(hr) );
	if ( FAILED (hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to change permissions to read: %x", hr );
		goto Exit;
	}

	// Because I can't do a count here, I have to assume that the error means
	// there are no more items:
	for ( cItems = 0, cIntegerItems = 0, cCustomItems = 0, i = 0; 
		/* Don't know how long it will last */; 
		i++ ) {

		hr = m_pMetabase->EnumKeys ( m_hKey, _T(""), wszName, i );

		if ( HRESULTTOWIN32 ( hr ) == ERROR_NO_MORE_ITEMS ) {
			// This is expected, end the loop:
			hr = NOERROR;
			break;
		}

		if ( FAILED (hr) ) {
			// Unexpected error case.

			ErrorTraceX ( 0, "Failed to enum object %d : %x", i, hr );
			goto Exit;
		}

		cItems++;

		if ( IsValidIntegerSubKey ( wszName ) ) {
			DWORD	dwSubkey;

			cIntegerItems++;
			dwSubkey = _wtoi ( wszName );

			if ( dwSubkey > dwMaxIntegerSubKey ) {
				dwMaxIntegerSubKey = dwSubkey;
			}
		}
		else {
			// Don't count this one:
			ErrorTrace ( 0, "Bad subkey number: %d", i );
		}

		if ( fpIsCustomKey && fpIsCustomKey ( wszName ) ) {
			cCustomItems++;
		}

		_ASSERT ( i < 0xf000000 ); // Infinite loop
	}

	// Now we have the count of items in cItems.
	*pcSubKeys				= cItems;
	*pcIntegerSubKeys		= cIntegerItems;
	*pdwMaxIntegerSubKey	= dwMaxIntegerSubKey;
	if ( pcCustomSubKeys ) {
		*pcCustomSubKeys		= cCustomItems;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

BOOL IsValidIntegerSubKey ( LPCWSTR wszSubKey )
{
	TraceQuietEnter ( "IsValidIntegerSubKey" );

	WCHAR	wszIntegerKey [ METADATA_MAX_NAME_LEN ];
	DWORD	dwItemValue;

	dwItemValue = _wtoi ( wszSubKey );
	wsprintf ( wszIntegerKey, _T("%d"), dwItemValue );

	// If the key is nonzero AND
	// The key is just the itoa value of the number:
	if ( dwItemValue != 0 &&
		 lstrcmp ( wszIntegerKey, wszSubKey ) == 0 ) {

		 return TRUE;
	}
	else {
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma warning( disable : 4511 )

#include <ctype.h>
extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

//  ATL code:
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//  Debugging support:
#undef _ASSERT
#include <dbgtrace.h>

//  The Metabase:
#include <iadm.h>
#include <iiscnfg.h>

#include "admmacro.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\u2detect.cpp ===
#include "stdafx.h"
#include "u2detect.h"

#define DebugPrint

#define MAX_MACHINE_NAME_SIZE   256
#define PROGID_PM_AUTH_SERVERS  L"MemAdmin.BrokServers"


HRESULT GetAdminIntf( 
    LPTSTR      pszMachName, 
    REFCLSID    rClsID, 
    const IID   *pIID, 
    PVOID       *ppIntf
    )
{
    static DWORD    dwNameSize = 0;
    static TCHAR    szLocalName[MAX_MACHINE_NAME_SIZE];
    HRESULT         hr = NOERROR;
    MULTI_QI        mqi;
    COSERVERINFO    CoSrv;
    COSERVERINFO    *pCoSrv = NULL;

    if (ppIntf)
        *ppIntf = NULL;

    // QI for IID_IBrokServers:
    mqi.pIID    = pIID;
    mqi.pItf    = NULL;
    mqi.hr    = 0;

    if (pszMachName)
    {
        if (dwNameSize == 0)
        {
            dwNameSize = MAX_MACHINE_NAME_SIZE;
            if (!GetComputerName( szLocalName, &dwNameSize ))
                dwNameSize = 0;
        }

        if (lstrcmpi( TEXT("localhost"), pszMachName) == 0 || 
            ( dwNameSize > 0 && lstrcmpi( szLocalName, pszMachName) == 0 ))
        {
            pCoSrv = NULL;
        }
        else
        {
            // Which remote server to talk to:
            //
            ZeroMemory( &CoSrv, sizeof(CoSrv) );
            CoSrv.pAuthInfo   = NULL;

#ifdef UNICODE
            LPWSTR pwszRemoteHost = pszMachName;
            CoSrv.pwszName    =    pwszRemoteHost;
#else
            WCHAR wszRemoteHost[MAX_MACHINE_NAME_SIZE];

            mbstowcs( wszRemoteHost, pszMachName, strlen(pszMachName) + 1 );
            CoSrv.pwszName    =    wszRemoteHost;
#endif

            pCoSrv = &CoSrv;
        }
    }

    // Create the DCOM object:
    //
    hr = CoCreateInstanceEx( rClsID, 
                             NULL, 
                             CLSCTX_SERVER | CLSCTX_REMOTE_SERVER, 
                             pCoSrv, 
                             1, 
                             &mqi );
    if ( FAILED(hr) )
    {
        return hr;
    }

    // Get and save the interface pointer:
    //
    if (ppIntf != NULL)
    {
        // Check in MULTI_QI for errors only if we built the MULTI_QI structure
        // otherwise, let the supplier of MULTI_QI check it themselves
        //
        if ( FAILED(mqi.hr) )
        {
            hr = mqi.hr;
            return hr;
        }

        *ppIntf = mqi.pItf;
        ((IUnknown *)*ppIntf)->AddRef();

        _ASSERT ( *ppIntf != NULL );
    }

    return S_OK;
}


BOOL IsNTSecurity( 
    LPTSTR pszMachine, 
    BSTR bstrSvcName, 
    LONG lInstanceID )
{
    HRESULT hr;
    IDispatch *pIDispatch = NULL;
    CLSID clsid;
    DISPID dispid ;
    OLECHAR* GetSecModeMethod = L"GetSecurityMode" ;
    OLECHAR* InitMethod =       L"Init" ;
    VARIANTARG vargs[3] ;
    DISPPARAMS param;
    CComVariant varSecurityMode;
    BOOL bNT;

    bNT = TRUE;   // default to NT security

    hr = ::CLSIDFromProgID( PROGID_PM_AUTH_SERVERS, &clsid );
    if (FAILED(hr))
    {
        DebugPrint( "P&M is probably not installed\n");
        goto Cleanup;
    }

    //hr = ::CoCreateInstance( clsid, NULL, CLSCTX_SERVER, IID_IDispatch,
    //                         (void**)&pIDispatch );
    hr = GetAdminIntf( pszMachine, clsid, &IID_IDispatch, (void**)&pIDispatch );

    if (FAILED(hr))
    {
        DebugPrint( "CoCreateInstance Failed: 0x%x\n", hr );
        goto Cleanup;
    }
    DebugPrint( "CoCreateInstance Succeeded\n");

    //  Get the method ID for Init()
    //
    hr = pIDispatch->GetIDsOfNames(IID_NULL,
                                   &InitMethod,
                                   1,
                                   GetUserDefaultLCID(),
                                   &dispid) ;
    if (FAILED(hr))
    {
        DebugPrint( "Query GetIDsOfNames failed: 0x%x", hr) ;
        goto Cleanup;
    }

    param.cArgs = param.cNamedArgs = 0; // No parameter to Init           
    param.rgvarg = NULL;
    param.rgdispidNamedArgs = NULL;

    hr = pIDispatch->Invoke(dispid,
                            IID_NULL,
                            GetUserDefaultLCID(),
                            DISPATCH_METHOD,
                            &param,     // No parameter to Init
                            NULL, 
                            NULL,
                            NULL) ;
    //
    //  Since Init() are not critical, ignore the return code for now
    //

    //  Get the method ID for GetSecurityMode()
    //
    dispid = 0;
    hr = pIDispatch->GetIDsOfNames(IID_NULL,
                                   &GetSecModeMethod,
                                   1,
                                   GetUserDefaultLCID(),
                                   &dispid) ;
    if (FAILED(hr))
    {
        DebugPrint( "Query GetIDsOfNames failed: 0x%x", hr) ;
        goto Cleanup;
    }

    DebugPrint( "Invoke the GetSecurityMode method\n" );

    // Allocate and initialize a VARIANT argument.

    VariantInit(&vargs[0]) ;     // Initialize the VARIANT.
    VariantInit(&vargs[1]) ;     // Initialize the VARIANT.

    vargs[0].vt = VT_I4;             // Type of 2nd arg
    vargs[0].lVal = lInstanceID;     // 2nd parameter
    vargs[1].vt = VT_BSTR;           // Type of 1st arg to the method
    vargs[1].bstrVal = bstrSvcName;  // 1st parameter

    param.cArgs = 2;                 // Number of arguments
    param.rgvarg = vargs;            // Arguments
    param.cNamedArgs = 0;            // Number of named args
    param.rgdispidNamedArgs = NULL;  // Named arguments

    hr = pIDispatch->Invoke(dispid,
                            IID_NULL,
                            GetUserDefaultLCID(),
                            DISPATCH_METHOD,
                            &param,
                            &varSecurityMode, 
                            NULL,
                            NULL) ;
    if (FAILED(hr))
    {
        DebugPrint( "Invoke call failed: 0x%x\n", hr );
        goto Cleanup;
    }

    if (V_VT( &varSecurityMode ) != VT_I4)
    {
        DebugPrint( "Unexpected result type %d\n", V_VT(&varSecurityMode) & 0xffff);
    }

    bNT = V_BOOL( &varSecurityMode );

Cleanup:
    if (pIDispatch)
        pIDispatch->Release();

    return bNT;
}


VOID DeleteMapping( 
    LPTSTR pszMachine, 
    BSTR bstrSvcName, 
    LONG lInstanceID )
{
    HRESULT hr;
    IDispatch *pIDispatch = NULL;
    CLSID clsid;
    DISPID dispid ;
    OLECHAR* DeleteMappingMethod = L"ClearMapping" ;
    OLECHAR* InitMethod =       L"Init" ;
    VARIANTARG vargs[3] ;
    DISPPARAMS param;
    BOOL bNT;

    bNT = TRUE;   // default to NT security

    hr = ::CLSIDFromProgID( PROGID_PM_AUTH_SERVERS, &clsid );
    if (FAILED(hr))
    {
        DebugPrint( "P&M is probably not installed\n");
        goto Cleanup;
    }

    hr = GetAdminIntf( pszMachine, clsid, &IID_IDispatch, (void**)&pIDispatch );

    if (FAILED(hr))
    {
        DebugPrint( "CoCreateInstance Failed: 0x%x\n", hr );
        goto Cleanup;
    }
    DebugPrint( "CoCreateInstance Succeeded\n");

    //  Get the method ID for Init()
    //
    hr = pIDispatch->GetIDsOfNames(IID_NULL,
                                   &InitMethod,
                                   1,
                                   GetUserDefaultLCID(),
                                   &dispid) ;
    if (FAILED(hr))
    {
        DebugPrint( "Query GetIDsOfNames failed: 0x%x", hr) ;
        goto Cleanup;
    }

    param.cArgs = param.cNamedArgs = 0; // No parameter to Init           
    param.rgvarg = NULL;
    param.rgdispidNamedArgs = NULL;

    hr = pIDispatch->Invoke(dispid,
                            IID_NULL,
                            GetUserDefaultLCID(),
                            DISPATCH_METHOD,
                            &param,     // No parameter to Init
                            NULL, 
                            NULL,
                            NULL) ;
    //
    //  Since Init() are not critical, ignore the return code for now
    //

    //  Get the method ID for GetSecurityMode()
    //
    dispid = 0;
    hr = pIDispatch->GetIDsOfNames(IID_NULL,
                                   &DeleteMappingMethod,
                                   1,
                                   GetUserDefaultLCID(),
                                   &dispid) ;
    if (FAILED(hr))
    {
        DebugPrint( "Query GetIDsOfNames failed: 0x%x", hr) ;
        goto Cleanup;
    }

    DebugPrint( "Invoke the ClearMapping method\n" );

    // Allocate and initialize a VARIANT argument.

    VariantInit(&vargs[0]) ;     // Initialize the VARIANT.
    VariantInit(&vargs[1]) ;     // Initialize the VARIANT.

    vargs[0].vt = VT_I4;             // Type of 2nd arg
    vargs[0].lVal = lInstanceID;     // 2nd parameter
    vargs[1].vt = VT_BSTR;           // Type of 1st arg to the method
    vargs[1].bstrVal = bstrSvcName;  // 1st parameter

    param.cArgs = 2;                 // Number of arguments
    param.rgvarg = vargs;            // Arguments
    param.cNamedArgs = 0;            // Number of named args
    param.rgdispidNamedArgs = NULL;  // Named arguments

    hr = pIDispatch->Invoke(dispid,
                            IID_NULL,
                            GetUserDefaultLCID(),
                            DISPATCH_METHOD,
                            &param,
                            NULL, 
                            NULL,
                            NULL) ;
    if (FAILED(hr))
    {
        DebugPrint( "Invoke call failed: 0x%x\n", hr );
        goto Cleanup;
    }

    DebugPrint( "Membership Server Mapping Deleted Successfully\n");

Cleanup:
    if (pIDispatch)
        pIDispatch->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\u2detect.h ===
BOOL IsNTSecurity( LPTSTR pszMachine, BSTR bstrSvcName, LONG lInstanceID );

VOID DeleteMapping( LPTSTR pszMachine, BSTR bstrSvcName, LONG lInstanceID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\adsiisex\adsiisex.cpp ===
#include <windows.h>
#include <ole2.h>

#include <atlbase.h>
#include <iads.h>

#include "adsiisex.hxx"

#include "nntpadm.h"
#include "smtpadm.h"

//--------------------------------------------------------------------
//
//	Macros:
//
//--------------------------------------------------------------------

#define BAIL_ON_FAILURE(hr)	\
{							\
	if ( FAILED(hr) ) {		\
		goto Exit;			\
	}						\
}
#define BAIL_WITH_FAILURE(hr, hrFailureCode)	\
{							\
	(hr) = (hrFailureCode);	\
	goto Exit;				\
}

#define ARRAY_SIZE(arr) (sizeof (arr) / sizeof ( (arr)[0] ) )

//--------------------------------------------------------------------
//
//	Types:
//
//--------------------------------------------------------------------

typedef struct tagExtClassEntry
{
	DWORD			dwId;
	LPCWSTR			wszClass;
	const CLSID *	clsid;
	const IID *		iid;
	LPCWSTR			wszInstancePrefix;
} EXT_CLASS_ENTRY;

enum {
	NNTP_REBUILD_ID		= 1,
	NNTP_SESSIONS_ID,
	NNTP_FEEDS_ID,
	NNTP_EXPIRES_ID,
	NNTP_GROUPS_ID,
	SMTP_SESSIONS_ID,
	SMTP_ALIAS_ID,
	SMTP_USER_ID,
	SMTP_DL_ID,
};

#define NNTPSVC_KEY     _T("NNTPSVC/")
#define SMTPSVC_KEY     _T("SMTPSVC/")

//--------------------------------------------------------------------
//
//	Global data:
//
//--------------------------------------------------------------------


static EXT_CLASS_ENTRY s_rgClasses [] = {

	{ NNTP_REBUILD_ID, _T("IIsNntpRebuild"), &CLSID_CNntpAdminRebuild, &IID_INntpAdminRebuild, NNTPSVC_KEY },
	{ NNTP_SESSIONS_ID, _T("IIsNntpSessions"), &CLSID_CNntpAdminSessions, &IID_INntpAdminSessions, NNTPSVC_KEY },
	{ NNTP_FEEDS_ID, _T("IIsNntpFeeds"), &CLSID_CNntpAdminFeeds, &IID_INntpAdminFeeds, NNTPSVC_KEY },
	{ NNTP_EXPIRES_ID, _T("IIsNntpExpiration"), &CLSID_CNntpAdminExpiration, &IID_INntpAdminExpiration, NNTPSVC_KEY },
	{ NNTP_GROUPS_ID, _T("IIsNntpGroups"), &CLSID_CNntpAdminGroups, &IID_INntpAdminGroups, NNTPSVC_KEY },

	{ SMTP_SESSIONS_ID, _T("IIsSmtpSessions"), &CLSID_CSmtpAdminSessions, &IID_ISmtpAdminSessions, SMTPSVC_KEY },
	{ SMTP_ALIAS_ID, _T("IIsSmtpAlias"), &CLSID_CSmtpAdminAlias, &IID_ISmtpAdminAlias, SMTPSVC_KEY },
	{ SMTP_USER_ID, _T("IIsSmtpUser"), &CLSID_CSmtpAdminUser, &IID_ISmtpAdminUser, SMTPSVC_KEY },
	{ SMTP_DL_ID, _T("IIsSmtpDL"), &CLSID_CSmtpAdminDL, &IID_ISmtpAdminDL, SMTPSVC_KEY },
};

//--------------------------------------------------------------------
//
//	Function Prototypes:
//
//--------------------------------------------------------------------

template <class Type>
HRESULT InitializeClass ( 
	IUnknown *		pUnk, 
	const IID *		pIID, 
	LPCWSTR			wszServer, 
	DWORD			dwInstance,
	Type *			pIgnored
	);

static int FindClassIndex ( LPCWSTR wszClass );
static void MakeUpperCase ( LPWSTR wsz );
static HRESULT ExtractInstanceFromPath ( LPCWSTR wszPath, LPCWSTR wszSearch, DWORD * pdwInstance );

//
// Extension DLL interface
//

extern "C"
{
	BOOL STDAPICALLTYPE IsExtensionClass ( LPCWSTR wszClass );

	HRESULT STDAPICALLTYPE CreateExtensionClass ( 
							IADs FAR *				pADs,
							LPCWSTR					wszClass,
							LPCWSTR					wszServerName,
							LPCWSTR					wszAdsPath,
							const GUID *			piid,
							void **					ppObject
							);
}

// Variable declarations to make sure we have the types right:

static IS_EXTENSION_CLASS_FUNCTION			fp1 = IsExtensionClass;
static CREATE_EXTENSION_CLASS_FUNCTION		fp2 = CreateExtensionClass;

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/);

//--------------------------------------------------------------------
//
//	Functions:
//
//--------------------------------------------------------------------

template <class Type>
HRESULT InitializeClass ( 
	IUnknown *		pUnk, 
	const IID *		pIID, 
	LPCWSTR			wszServer, 
	DWORD			dwInstance,
    IADs *          pADs,
	Type *			pIgnored
	)
{
	HRESULT			hr			= NOERROR;
	CComPtr<Type>	pObject;

	hr = pUnk->QueryInterface ( *pIID, (void **) &pObject );
	BAIL_ON_FAILURE(hr);

	hr = pObject->put_Server ( const_cast<BSTR> (wszServer) );
	BAIL_ON_FAILURE(hr);

	hr = pObject->put_ServiceInstance ( dwInstance );
	BAIL_ON_FAILURE(hr);

	hr = pObject->put_IADsPointer ( pADs );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

int FindClassIndex ( LPCWSTR wszClass )
{
	int i;

	for ( i = 0; i < ARRAY_SIZE(s_rgClasses); i++ ) {
		if ( ! lstrcmpi ( wszClass, s_rgClasses[i].wszClass ) ) {
			return i;
		}
	}

	return -1;
}

void MakeUpperCase ( LPWSTR wsz )
{
	while ( *wsz ) {
		*wsz = towupper ( *wsz );
		wsz++;
	}
}

HRESULT ExtractInstanceFromPath ( 
	LPCWSTR 	wszPath, 
	LPCWSTR 	wszSearch, 
	DWORD * 	pdwInstance 
	)
{
	HRESULT		hr = NOERROR;
	DWORD		dwInstance = 0;
	CComBSTR	strPath;
	CComBSTR	strSearch;
	LPWSTR		wszMatch;
	LPWSTR		wszInstance;

	//
	//	Convert everything to upper case:
	//

	strPath		= wszPath;
	strSearch	= wszSearch;
	if ( !strPath || !strSearch ) {
		BAIL_WITH_FAILURE(hr, E_FAIL);
	}

	MakeUpperCase ( strPath );
	MakeUpperCase ( strSearch );

	wszMatch = wcsstr ( strPath, strSearch );
	if ( !wszMatch ) {
		BAIL_WITH_FAILURE(hr, E_FAIL);
	}

	wszInstance = wszMatch + wcslen ( strSearch );

	dwInstance = (DWORD) _wtoi ( wszInstance );

	if ( dwInstance == 0 ) {
		BAIL_WITH_FAILURE(hr, E_FAIL);
	}

	*pdwInstance = dwInstance;

Exit:
	return hr;
}

//
// Extension DLL interface
//

BOOL STDAPICALLTYPE 
IsExtensionClass ( 
	LPCWSTR wszClass 
	)
{
	return ( FindClassIndex ( wszClass ) != -1 );
}

HRESULT STDAPICALLTYPE 
CreateExtensionClass (
	IADs FAR *				pADs,
	LPCWSTR					wszClass,
	LPCWSTR					wszServerName,
	LPCWSTR					wszAdsPath,
	const GUID *			piid,
	void **					ppObject
	)
{
	HRESULT				hr	= NOERROR;
	int 				index;
	DWORD				dwId;
	const GUID *		clsidClass;
	const GUID *		iidClass;
	LPCWSTR				wszInstancePrefix;

	DWORD				dwInstance;
	CComPtr<IUnknown>	pUnk;

	index = FindClassIndex ( wszClass );
	if ( index == -1 ) {
		BAIL_WITH_FAILURE(hr, E_FAIL);
	}

	dwId 				= s_rgClasses[index].dwId;
	clsidClass			= s_rgClasses[index].clsid;
	iidClass			= s_rgClasses[index].iid;
	wszInstancePrefix	= s_rgClasses[index].wszInstancePrefix;

	//
	//	Parse the path:
	//

	hr = ExtractInstanceFromPath ( wszAdsPath, wszInstancePrefix, &dwInstance );
	BAIL_ON_FAILURE(hr);

	//
	//	Create the object:
	//

	hr = CoCreateInstance ( *clsidClass, NULL, CLSCTX_ALL, IID_IUnknown, (void **) &pUnk );
	BAIL_ON_FAILURE(hr);

	//
	//	Now initialize the class:
	//

	switch ( dwId ) {

		case NNTP_REBUILD_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(INntpAdminRebuild *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		case NNTP_SESSIONS_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(INntpAdminSessions *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		case NNTP_FEEDS_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(INntpAdminFeeds *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		case NNTP_EXPIRES_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(INntpAdminExpiration *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		case NNTP_GROUPS_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(INntpAdminGroups *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		case SMTP_SESSIONS_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(ISmtpAdminSessions *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		case SMTP_ALIAS_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(ISmtpAdminAlias *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		case SMTP_USER_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(ISmtpAdminUser *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}
		
		case SMTP_DL_ID:
		{
			hr = InitializeClass ( 
								pUnk, 
								iidClass, 
								wszServerName, 
								dwInstance, 
								pADs, 
								(ISmtpAdminDL *) NULL
								);
			BAIL_ON_FAILURE(hr);

			break;
		}

		default:
			BAIL_WITH_FAILURE(hr,E_FAIL);
	}

	//
	//	Get the desired interface:
	//

	hr = pUnk->QueryInterface ( *piid, ppObject );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
    }
    return TRUE;    // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\regmacro.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	regmacro.h

Abstract:

	Useful macros to do registration stuff

Author:

	KeithLau			4/27/98			Created

Revision History:

--*/

#ifndef _REGMACRO_H_
#define _REGMACRO_H_

#define EXTENSION_BASE_PATH		_T("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\%s\\%s")
#define EXTENSION_BASE_PATH2	_T("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\%s")

typedef struct _EXT_REGISTRATION_INFO
{
	LPTSTR	szClassName;
	CLSID	*clsid;
	IID		*iid;

} EXT_REGISTRATION_INFO, *LPEXT_REGISTRATION_INFO;

extern EXT_REGISTRATION_INFO	rgRegistrationInfo[];
extern DWORD					dwRegistrationInfo;

//
// Declare the start of the extension registration entries
//
#define BEGIN_EXTENSION_REGISTRATION_MAP			\
EXT_REGISTRATION_INFO rgRegistrationInfo[] = {

//
// Declare each entry of extensions
//
#define EXTENSION_REGISTRATION_MAP_ENTRY(ClassName, BaseName)\
	{ _T(#ClassName), (CLSID *)&CLSID_C##BaseName, (IID *)&IID_I##BaseName },

//
// Declare the end of the extension registration entries
//
#define END_EXTENSION_REGISTRATION_MAP				\
	NULL };											\
DWORD dwRegistrationInfo =							\
	(sizeof(rgRegistrationInfo)/					\
		sizeof(EXT_REGISTRATION_INFO))-1;

//
// Register the extension bindings in the registry
//
HRESULT RegisterExtensions()
{	
	HRESULT	hrRes;
	HRESULT	hrTemp;
	HKEY	hKeyTemp;
	DWORD	dwDisposition;
	TCHAR	szSubKey[1024];
	LPTSTR	szCLSID;
	LPTSTR	szIID;

	hrTemp = S_OK;
	for (DWORD i = 0; i < dwRegistrationInfo; i++)
	{
		hrRes = StringFromCLSID(
				*(rgRegistrationInfo[i].clsid), 
				&szCLSID);
		if (FAILED(hrRes))
		{
			hrTemp = hrRes;
			continue;
		}

		hrRes = StringFromIID(
				*(rgRegistrationInfo[i].iid), 
				&szIID);
		if (FAILED(hrRes))
		{
			hrTemp = hrRes;
			continue;
		}

		wsprintf(szSubKey, 
				EXTENSION_BASE_PATH, 
				rgRegistrationInfo[i].szClassName,
				szCLSID);

		if (RegCreateKeyEx(
				HKEY_LOCAL_MACHINE,
				szSubKey,
				NULL, 
				_T(""), 
				REG_OPTION_NON_VOLATILE, 
				KEY_ALL_ACCESS, 
				NULL,
				&hKeyTemp, 
				&dwDisposition) != ERROR_SUCCESS)
		{
			hrTemp = E_UNEXPECTED;
			continue;
		}

		if (RegSetValueEx(
					hKeyTemp, 
					_T("Interfaces"), 
					NULL, 
					REG_MULTI_SZ,
					(BYTE*)szIID,
					lstrlen(szIID) * sizeof(TCHAR)) != ERROR_SUCCESS)
		{
			hrTemp = E_UNEXPECTED;
			RegCloseKey(hKeyTemp);
			continue;
		}

		RegCloseKey(hKeyTemp);
	}

	return(hrTemp);
}

//
// Unregister the extension bindings in the registry
//
HRESULT UnregisterExtensions()
{	
	HRESULT	hrRes;
	TCHAR	szSubKey[1024];
	LPTSTR	szCLSID;

	for (DWORD i = 0; i < dwRegistrationInfo; i++)
	{
		hrRes = StringFromCLSID(
				*(rgRegistrationInfo[i].clsid), 
				&szCLSID);
		if (FAILED(hrRes))
			continue;

		wsprintf(szSubKey, 
				EXTENSION_BASE_PATH, 
				rgRegistrationInfo[i].szClassName,
				szCLSID);
		RegDeleteKey(HKEY_LOCAL_MACHINE, szSubKey);

		wsprintf(szSubKey, 
				EXTENSION_BASE_PATH2, 
				rgRegistrationInfo[i].szClassName);
		RegDeleteKey(HKEY_LOCAL_MACHINE, szSubKey);
	}

	return(S_OK);
}

#endif // _REGMACRO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\adsiisex\guids.cpp ===
#include <windows.h>
#include <ole2.h>
#include "iads.h"

//
//  ATL:
//

#include "atlbase.h"
#include <atlimpl.cpp>

//
//  GUIDS:
//

#define INITGUID
#include "initguid.h"

#include "nntpadm.h"
#include "smtpadm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\admcmn\metakey.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metakey.h

Abstract:

	CMetabaseKey - A class to help manipulate metabase keys.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _METAKEY_INCLUDED_
#define _METAKEY_INCLUDED_

//
// Creating a metabase object:
//

HRESULT CreateMetabaseObject ( LPCWSTR wszMachine, IMSAdminBase ** ppMetabase );

//
//	The metabase key class:
//

typedef BOOL (*KEY_TEST_FUNCTION) ( LPCWSTR szKey );

class CMetabaseKey
{
public:
	CMetabaseKey	( IMSAdminBase * pMetabase );
	~CMetabaseKey	( );

	//
	// METADATA_HANDLE manipulation:
	//

	inline HRESULT	Open	( IN LPCWSTR szPath, DWORD dwPermissions = METADATA_PERMISSION_READ );
	HRESULT			Open	( IN METADATA_HANDLE hParentKey, IN LPCWSTR szPath, DWORD dwPermissions = METADATA_PERMISSION_READ );
	void			Attach	( METADATA_HANDLE hKey );
	METADATA_HANDLE	Detach	( );
	void			Close 	( );

	HRESULT			EnumObjects ( IN LPCWSTR wszPath, LPWSTR wszSubKey, DWORD dwIndex );
    HRESULT         ChangePermissions ( DWORD dwNewPermissions );
    HRESULT         DeleteKey ( IN LPCWSTR wszPath );
    HRESULT         DeleteAllData ( IN LPCWSTR wszPath = _T("") );

	void			GetLastChangeTime ( FILETIME * pftGMT, LPCWSTR wszPath = _T("") );
	HRESULT			Save	( );

	METADATA_HANDLE	QueryHandle ( ) { return m_hKey; }
	IMSAdminBase *	QueryMetabase ( ) { return m_pMetabase; }

	//
	// Getting metabase values:
	//

    inline HRESULT GetData		( LPCWSTR wszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType, VOID * pvData, DWORD * cbData, DWORD dwFlags );
    inline HRESULT GetDataSize	( LPCWSTR wszPath, DWORD dwPropID, DWORD dwDataType, DWORD * pcbSize, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );

    inline HRESULT GetDword		( LPCWSTR wszPath, DWORD dwPropID, DWORD * pdwValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetString	( LPCWSTR wszPath, DWORD dwPropID, LPWSTR wszValue, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetMultiSz	( LPCWSTR wszPath, DWORD dwPropID, LPWSTR mszValue, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetBinary	( LPCWSTR wszPath, DWORD dwPropID, void * pvData, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );

	// These routines default to the current metabase key path:
    inline HRESULT GetDword		( DWORD dwPropID, DWORD * pdwValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetString	( DWORD dwPropID, LPWSTR wszValue, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetMultiSz	( DWORD dwPropID, LPWSTR mszValue, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetBinary	( DWORD dwPropID, void * pvData, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );

	//
	// Setting metabase values:
	//

    inline HRESULT SetData		( LPCWSTR wszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType, VOID * pvData, DWORD cbData, DWORD dwFlags );

    inline HRESULT SetDword		( LPCWSTR wszPath, DWORD dwPropID, DWORD dwValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetString	( LPCWSTR wszPath, DWORD dwPropID, LPCWSTR wszValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetMultiSz	( LPCWSTR wszPath, DWORD dwPropID, LPCWSTR mszValue, DWORD cbData, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetBinary	( LPCWSTR wszPath, DWORD dwPropID, void * pvData, DWORD cbData, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );

	inline HRESULT DeleteData	( LPCWSTR wszPath, DWORD dwPropID, DWORD dwDataType );

	// These routines default to the current metabase key path:
    inline HRESULT SetDword		( DWORD dwPropID, DWORD dwValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetString	( DWORD dwPropID, LPCWSTR wszValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetMultiSz	( DWORD dwPropID, LPCWSTR mszValue, DWORD cbData, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetBinary	( DWORD dwPropID, void * pvData, DWORD cbData, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );

	inline HRESULT DeleteData	( DWORD dwPropID, DWORD dwDataType );


	//
	// Subkey manipulation:
	//

	HRESULT		GetChildCount			( OUT DWORD * pcChildren );
	HRESULT		GetIntegerChildCount	( OUT DWORD * pcIntegerChildren );
	HRESULT		GetCustomChildCount		( 
		IN KEY_TEST_FUNCTION func, 
		OUT DWORD * pcCustomChildren 
		);

	void		BeginChildEnumeration	( );
	HRESULT		NextChild				( OUT LPWSTR wszChildKey );
	HRESULT		NextIntegerChild		( OUT DWORD * pdwID, OUT LPWSTR wszIntegerChildKey );
	HRESULT		NextCustomChild			( 
		IN KEY_TEST_FUNCTION fpIsCustomKey, 
		OUT LPWSTR wszChildKey 
		);

	HRESULT		CreateChild			( IN LPWSTR wszChildPath );
	HRESULT		DestroyChild		( IN LPWSTR wszChildPath );
	HRESULT		CreateIntegerChild	( OUT DWORD * pdwID, OUT LPWSTR wszChildPath );
	HRESULT		DestroyIntegerChild	( IN DWORD i );

private:
	IMSAdminBase *		m_pMetabase;
	METADATA_HANDLE		m_hKey;

	DWORD				m_indexCursor;
	DWORD				m_cChildren;
	DWORD				m_cIntegerChildren;
	DWORD				m_dwMaxIntegerChild;

	HRESULT	CountSubkeys ( 
		IN  KEY_TEST_FUNCTION fpIsCustomKey,
		OUT DWORD * pcChildren, 
		OUT DWORD * pcIntegerChildren,
		OUT DWORD * pcCustomChildren, 
		OUT DWORD * pdwMaxIntegerChild 
		);
};

//--------------------------------------------------------------------
//
//	Inlined Functions:
//
//--------------------------------------------------------------------

inline HRESULT CMetabaseKey::Open ( IN LPCWSTR szPath, DWORD dwPermissions )
{
	return Open ( METADATA_MASTER_ROOT_HANDLE, szPath, dwPermissions );
}

//--------------------------------------------------------------------
//
//	Simple GetData wrappers:
//
//--------------------------------------------------------------------

inline HRESULT CMetabaseKey::GetDword ( LPCWSTR wszPath, DWORD dwPropID, DWORD * pdwValue, DWORD dwFlags, DWORD dwUserType )
{
	DWORD	dwDummy	= sizeof (DWORD);

	return GetData ( wszPath, dwPropID, dwUserType, DWORD_METADATA, pdwValue, &dwDummy, dwFlags );
}

inline HRESULT CMetabaseKey::GetString ( LPCWSTR wszPath, DWORD dwPropID, LPWSTR wszValue, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( wszPath, dwPropID, dwUserType, STRING_METADATA, wszValue, &cbMax, dwFlags );
}

inline HRESULT CMetabaseKey::GetMultiSz ( LPCWSTR wszPath, DWORD dwPropID, LPWSTR mszValue, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( wszPath, dwPropID, dwUserType, MULTISZ_METADATA, mszValue, &cbMax, dwFlags );
}

inline HRESULT CMetabaseKey::GetBinary ( LPCWSTR wszPath, DWORD dwPropID, void * pvData, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( wszPath, dwPropID, dwUserType, BINARY_METADATA, pvData, &cbMax, dwFlags );
}

// These routines default to the current metabase key path:
inline HRESULT CMetabaseKey::GetDword ( DWORD dwPropID, DWORD * pdwValue, DWORD dwFlags, DWORD dwUserType )
{
	DWORD	dwDummy	= sizeof (DWORD);

	return GetData ( _T(""), dwPropID, dwUserType, DWORD_METADATA, pdwValue, &dwDummy, dwFlags );
}

inline HRESULT CMetabaseKey::GetString ( DWORD dwPropID, LPWSTR wszValue, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( _T(""), dwPropID, dwUserType, STRING_METADATA, wszValue, &cbMax, dwFlags );
}

inline HRESULT CMetabaseKey::GetMultiSz ( DWORD dwPropID, LPWSTR mszValue, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( _T(""), dwPropID, dwUserType, MULTISZ_METADATA, mszValue, &cbMax, dwFlags );
}

inline HRESULT CMetabaseKey::GetBinary ( DWORD dwPropID, void * pvData, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( _T(""), dwPropID, dwUserType, BINARY_METADATA, pvData, &cbMax, dwFlags );
}

//--------------------------------------------------------------------
//
//	Simple SetData wrappers:
//
//--------------------------------------------------------------------

inline HRESULT CMetabaseKey::SetDword ( LPCWSTR wszPath, DWORD dwPropID, DWORD dwValue, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( wszPath, dwPropID, dwUserType, DWORD_METADATA, &dwValue, sizeof (DWORD), dwFlags );
}

inline HRESULT CMetabaseKey::SetString ( LPCWSTR wszPath, DWORD dwPropID, LPCWSTR wszValue, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( 
		wszPath, 
		dwPropID, 
		dwUserType, 
		STRING_METADATA, 
		(void *) wszValue, 
		sizeof (WCHAR) * (lstrlen ( wszValue ) + 1), 
		dwFlags 
		);
}

inline HRESULT CMetabaseKey::SetMultiSz ( LPCWSTR wszPath, DWORD dwPropID, LPCWSTR mszValue, DWORD cbData, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( wszPath, dwPropID, dwUserType, MULTISZ_METADATA, (void *) mszValue, cbData, dwFlags );
}

inline HRESULT CMetabaseKey::SetBinary ( LPCWSTR wszPath, DWORD dwPropID, void * pvData, DWORD cbData, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( wszPath, dwPropID, dwUserType, BINARY_METADATA, pvData, cbData, dwFlags );
}

// These routines default to the current metabase key path:
inline HRESULT CMetabaseKey::SetDword ( DWORD dwPropID, DWORD dwValue, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( _T(""), dwPropID, dwUserType, DWORD_METADATA, &dwValue, sizeof (DWORD), dwFlags );
}

inline HRESULT CMetabaseKey::SetString ( DWORD dwPropID, LPCWSTR wszValue, DWORD dwFlags, DWORD dwUserType )
{
	_ASSERT ( !IsBadStringPtr ( wszValue, -1 ) );

	return SetData ( 
		_T(""), 
		dwPropID, 
		dwUserType,
		STRING_METADATA, 
		(void *) wszValue, 
		sizeof (WCHAR) * ( lstrlen ( wszValue ) + 1 ),
		dwFlags
		);
}

inline HRESULT CMetabaseKey::SetMultiSz ( DWORD dwPropID, LPCWSTR mszValue, DWORD cbData, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( _T(""), dwPropID, dwUserType, MULTISZ_METADATA, (void *) mszValue, cbData, dwFlags );
}

inline HRESULT CMetabaseKey::SetBinary ( DWORD dwPropID, void * pvData, DWORD cbData, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( _T(""), dwPropID, dwUserType, BINARY_METADATA, pvData, cbData, dwFlags );
}

inline HRESULT CMetabaseKey::DeleteData ( DWORD dwPropID, DWORD dwDataType )
{
	return DeleteData ( _T(""), dwPropID, dwDataType );
}

inline HRESULT CMetabaseKey::DeleteData ( LPCWSTR wszPath, DWORD dwPropID, DWORD dwDataType )
{
	TraceQuietEnter ( "CMetabaseKey:DeleteData" );

	HRESULT		hRes;

	hRes = m_pMetabase->DeleteData ( m_hKey, wszPath, dwPropID, dwDataType );
	if ( hRes == MD_ERROR_DATA_NOT_FOUND ) {
		hRes = NOERROR;
	}

	//	Trace the error code:
	if ( FAILED(hRes) ) {
		ErrorTraceX ( 0, "DeleteData failed unexpectedly: Prop(%d) Error(%x)", dwPropID, hRes );
	}

	return hRes;
}

//--------------------------------------------------------------------
//
//	The real work - Set & Get arbitrary metadata:
//
//--------------------------------------------------------------------

inline HRESULT CMetabaseKey::GetDataSize ( 
	LPCWSTR		wszPath, 
	DWORD 		dwPropID, 
	DWORD		dwDataType,
	DWORD *		pcbSize, 
	DWORD		dwFlags, 
	DWORD		dwUserType
	)
{
	TraceQuietEnter ( "CMetabaseKey::GetDataSize" );

    HRESULT         hRes;
    METADATA_RECORD mdRecord;
    DWORD			dwDummy			= 0;
    DWORD           dwRequiredLen	= 0;

	_ASSERT ( !IsBadWritePtr ( pcbSize, sizeof (DWORD) ) );

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = 0;
    mdRecord.pbMDData        = (PBYTE) &dwDummy;

    hRes = m_pMetabase->GetData( m_hKey,
                                      wszPath,
                                      &mdRecord,
                                      &dwRequiredLen );

    *pcbSize = dwRequiredLen;

	if ( HRESULTTOWIN32 ( hRes ) == ERROR_INSUFFICIENT_BUFFER ) {
		// Of course the buffer is too small!
		hRes = NOERROR;
	}

	//	Trace the error code:
	if ( FAILED(hRes) && hRes != MD_ERROR_DATA_NOT_FOUND ) {
		ErrorTraceX ( 0, "GetDataSize failed unexpectedly: Prop(%d) Error(%x)", dwPropID, hRes );
	}

    return hRes;
}

inline HRESULT CMetabaseKey::GetData (
	LPCWSTR  	pszPath,
	DWORD       dwPropID,
	DWORD       dwUserType,
	DWORD       dwDataType,
	VOID *      pvData,
	DWORD *     pcbData,
	DWORD       dwFlags )
{
	TraceQuietEnter ( "CMetabaseKey::GetData" );

    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen;

	_ASSERT ( !IsBadReadPtr ( pcbData, sizeof (DWORD) ) );
	_ASSERT ( !IsBadWritePtr ( pvData, *pcbData ) );

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = *pcbData;
    mdRecord.pbMDData        = (PBYTE) pvData;

    hRes = m_pMetabase->GetData( m_hKey,
                                      pszPath,
                                      &mdRecord,
                                      &dwRequiredLen );

    if ( SUCCEEDED( hRes )) {
        *pcbData = mdRecord.dwMDDataLen;
    }
    else {
	    *pcbData = dwRequiredLen;
	}

	//	Trace the error code:
	if ( FAILED(hRes) && hRes != MD_ERROR_DATA_NOT_FOUND ) {
		ErrorTraceX ( 0, "GetData failed unexpectedly: Prop(%d) Error(%x)", dwPropID, hRes );
	}

    return hRes;
}

inline HRESULT CMetabaseKey::SetData ( 
	LPCWSTR 	pszPath,
	DWORD       dwPropID,
	DWORD       dwUserType,
	DWORD       dwDataType,
	VOID *      pvData,
	DWORD       cbData,
	DWORD       dwFlags )
{
	TraceQuietEnter ( "CMetabaseKey::SetData" );

    METADATA_RECORD mdRecord;
    HRESULT         hRes;

	_ASSERT ( !IsBadReadPtr ( pvData, cbData ) );

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = cbData;
    mdRecord.pbMDData        = (PBYTE) pvData;

    hRes = m_pMetabase->SetData( m_hKey,
                                      pszPath,
                                      &mdRecord );

	//	Trace the error code:
	if ( FAILED(hRes) ) {
		ErrorTraceX ( 0, "GetData failed unexpectedly: Prop(%d) Error(%x)", dwPropID, hRes );
	}

	return hRes;
}

#endif // _METAKEY_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\admin\adsiisex\makefile.inc ===
$(O)\nntpadm.h $(O)\nntpadm_i.c : $(STAXINC)\export\nntpadm.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\nntpadm_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpadm_i.c \
    -header $@ \
    -tlb $(O)\nntpadm.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpadm.h $(O)\smtpadm_i.c : $(STAXINC)\export\smtpadm.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpadm_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpadm_i.c \
    -header $@ \
    -tlb $(O)\smtpadm.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**


copytlb:
#    xcopy /verifd $(STAXINC)\export\activeds.tlb .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\basetrac\dbgext\tracext.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: traceext.cpp
//
//  Description:    Debug extension to dump callstack info generated by 
//      basetrac.lib
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/29/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <string.h>
#include <dbgtrace.h>
#include <imagehlp.h>

//Since we are a debugger extension...we will do away with the niceties of C++
//Object encapsulation
#define protected   public
#define private     public

#include <basetrac.h>
#include <transdbg.h>

TRANS_DEBUG_EXTENSION(dumpcallstack)
{
    CCallStackEntry_Base *pkbebAddress = NULL; //address in other process
    BYTE pbCallStack[sizeof(CCallStackEntry_Base)];
    CCallStackEntry_Base *pkbeb = (CCallStackEntry_Base *) pbCallStack;
    DWORD_PTR rgdwptrCallStack[100]; //Buffer for storing call stack data
    DWORD dwStackDepth = 0;
    UCHAR  szSymbol[100];
    ULONG_PTR Displacement = 0;
    ULONG cbBytesRead = 0;
    LPSTR szCallStackType = NULL;

    if (!szArg)
    {
        dprintf("ERROR: Unable to parse arg\n");
        return;
    }

    pkbebAddress = (CCallStackEntry_Base *) GetExpression(szArg);
    if (!ReadMemory((ULONG_PTR) pkbebAddress, pbCallStack,
                    sizeof(CCallStackEntry_Base), &cbBytesRead))
    {
        dprintf("ERROR: Unable to read call stack entry\n");
        return;
    }
    
    if (!ReadMemory((ULONG_PTR) pkbeb->m_pdwptrCallers, 
                    (BYTE *) rgdwptrCallStack, 
                    sizeof(DWORD_PTR)*pkbeb->m_dwCallStackDepth,
                    &cbBytesRead))
    {
        dprintf("ERROR: Unable to read call stack info\n");
        return;
    }

    //See if this entry was ever used..don't dump it if it wasn't
    if (TRACKING_OBJECT_UNUSED == pkbeb->m_dwCallStackType)
        return;

    dprintf("======================================================\n");
    switch(pkbeb->m_dwCallStackType)
    {
      case TRACKING_OBJECT_CONSTRUCTOR:
         szCallStackType = "Object Creation";
         break;
      case TRACKING_OBJECT_ADDREF:
         szCallStackType = "AddRef";
         break;
      case TRACKING_OBJECT_RELEASE:
         szCallStackType = "Release";
         break;
      case TRACKING_OBJECT_DESTRUCTOR:
         szCallStackType = "Object Descructor";
         break;
      default:
         szCallStackType = "User Defined";
    }
    dprintf("Call stack Type: %s (0x%08X)\n", szCallStackType, pkbeb->m_dwCallStackType);
    dprintf("Call stack Depth: %d\n", pkbeb->m_dwCallStackDepth);
    dprintf("Dumping info stored at 0x%08X\n", pkbebAddress);
    for(dwStackDepth = 0; dwStackDepth < pkbeb->m_dwCallStackDepth; dwStackDepth++)
    {
        if (!rgdwptrCallStack[dwStackDepth])
            break;
        GetSymbol((PVOID) rgdwptrCallStack[dwStackDepth], szSymbol, &Displacement);
        dprintf("\t(0x%08X) - %s+0x%X\n", rgdwptrCallStack[dwStackDepth], 
                 szSymbol, Displacement);
    }
    dprintf("======================================================\n");
}

//---[ dumpstacks ]------------------------------------------------------------
//
//
//  Description: 
//      Debugger extension to handle dumping callstack info generated by
//      basetrac.lib
//  Parameters: 
//      szArg    String passed in by debugger
//        ptracbAddress    Pointer to CDebugTrackingObject_Base
//  Returns:
//      -
//  History:
//      10/29/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
TRANS_DEBUG_EXTENSION(dumpstacks)
{
    CDebugTrackingObject_Base *ptracbAddress = NULL; //address on other process
    BYTE pbTrackingObj[sizeof(CDebugTrackingObject_Base)];
    CDebugTrackingObject_Base *ptracb = (CDebugTrackingObject_Base *) pbTrackingObj;
    CCallStackEntry_Base *pkbebAddress = NULL; //address in other process
    ULONG cbBytesRead = 0;
    CHAR szAddress[20];
    DWORD cEntriesToPrint = 0;
    DWORD c2ndPassEntriesToPrint = 0;


    if (!szArg)
    {
        dprintf("USAGE: dumpstacks <address>\n");
        return;
    }
    
    //Get address and read object into memory
    ptracbAddress = (CDebugTrackingObject_Base *) GetExpression(szArg);
    if (!ReadMemory((ULONG_PTR) ptracbAddress, pbTrackingObj, 
                    sizeof(CDebugTrackingObject_Base), &cbBytesRead))
    {
        dprintf("ERROR: Unable to read memory at location 0x%%08X\n", ptracbAddress);
        return;
    }

    if (TRACKING_OBJ_SIG != ptracb->m_dwSignature)
    {
        dprintf("ERROR: Invalid Signature on tracking object\n");
        return;
    }


    //Loop through stack entries and dump them
    pkbebAddress = ptracb->m_pkbebCallStackEntries;

    cEntriesToPrint = ptracb->m_cCurrentStackEntries;
    if (cEntriesToPrint > ptracb->m_cCallStackEntries) //we've wrapped
    {
        cEntriesToPrint = ptracb->m_cCallStackEntries - 
                 (ptracb->m_cCurrentStackEntries % ptracb->m_cCallStackEntries);
        pkbebAddress = (CCallStackEntry_Base *) ( ((BYTE *)pkbebAddress) 
                 + ((ptracb->m_cCurrentStackEntries % 
                     ptracb->m_cCallStackEntries)) *
                   ptracb->m_cbCallStackEntries);
        
        c2ndPassEntriesToPrint = ptracb->m_cCallStackEntries - cEntriesToPrint;
    }

    dprintf("======================================================\n");
    dprintf("Dumping saved call stack info\n");
    dprintf("\t%d Call Stack Entries Logged\n", ptracb->m_cCurrentStackEntries);
    dprintf("\t%d Call Stack Entries Saved\n", c2ndPassEntriesToPrint+cEntriesToPrint);

    if (!cEntriesToPrint) //Nothing to do
        return;

    while(pkbebAddress && cEntriesToPrint)
    {
        wsprintf(szAddress, "0x%08X", pkbebAddress);
        dumpcallstack(hCurrentProcess, hCurrentThread, dwCurrentPc, pExtensionApis, szAddress);
        pkbebAddress = (CCallStackEntry_Base *) ( ((BYTE *)pkbebAddress) 
                        + ptracb->m_cbCallStackEntries);
        cEntriesToPrint--;
    }

    //OK Reset the address and do the first half of the circular buffer.
    pkbebAddress = ptracb->m_pkbebCallStackEntries;
    while(pkbebAddress && c2ndPassEntriesToPrint)
    {
        wsprintf(szAddress, "0x%08X", pkbebAddress);
        dumpcallstack(hCurrentProcess, hCurrentThread, dwCurrentPc, 
                      pExtensionApis, szAddress);
        pkbebAddress = (CCallStackEntry_Base *) ( ((BYTE *)pkbebAddress) 
                        + ptracb->m_cbCallStackEntries);
        c2ndPassEntriesToPrint--;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\asynccon\src\asynccon.cxx ===
/*++

   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        asynccon.cxx

   Abstract:


   Author:

--*/

#include <windows.h>
#include <winsock2.h>
#include <dbgtrace.h>
#include <asynccon.hxx>

CAsyncConnection::CAsyncConnection(DWORD PortNo, DWORD TimeOut, char * HostName, USERCALLBACKFUNC CallBack)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncConnection::CAsyncConnection()");

	m_Signature = ASYNCCON_SIGNATURE;
	m_RegisterWaitHandle = NULL;
	m_SignalHandle = NULL;
	AsyncSock = INVALID_SOCKET;
	m_IsFirstTime = TRUE;
	m_fCloseSocket = TRUE;
	m_Error = 0;
	m_fTimedOut = TRUE;
	NextIpToTry = 0;
	m_TimeOut = TimeOut;
	m_IpAddress = 0;
	m_Port = PortNo;
	m_cActiveThreads = 0;
    m_cRefCount = 0;

	lstrcpyn(m_HostName, HostName, sizeof(m_HostName) -1 );
	m_CallBackFunc = CallBack;

	ZeroMemory(m_pLocalIpAddresses, sizeof(m_pLocalIpAddresses));
	ZeroMemory(m_LocalIpAddresses, sizeof(m_LocalIpAddresses));

    TraceFunctLeaveEx((LPARAM)this);
}

CAsyncConnection::~CAsyncConnection()
{
	int Retval = 0;

    TraceFunctEnterEx((LPARAM) this, "CAsyncConnection::~CAsyncConnection()");

    //NK** We call the destructor after decrementing the thread count
    //so it should be zero.
	_ASSERT(GetThreadCount() == 0);
    _ASSERT(GetRefCount() == 0);

	if(m_RegisterWaitHandle)
	{
		UnregisterWait(m_RegisterWaitHandle);
		m_RegisterWaitHandle = NULL;
	}

	if(m_SignalHandle)
	{
		CloseHandle(m_SignalHandle);
		m_SignalHandle = NULL;
	}

	if(m_fCloseSocket && (AsyncSock != INVALID_SOCKET))
	{
		ResetSocketToBlockingMode();
		Retval = closesocket(AsyncSock);
		AsyncSock = INVALID_SOCKET;
	}

	m_Signature = ASYNCCON_SIGNATURE_FREE;

	DebugTrace((LPARAM) this, "Deleteing async conn %X", this);

    TraceFunctLeaveEx((LPARAM)this);
}


void CAsyncConnection::AsyncConnectCallback(PVOID ThisPtr, BOOLEAN fTimedOut)
{
	CAsyncConnection * ThisQueue = (CAsyncConnection *) ThisPtr;
	BOOL fRet = TRUE;

	_ASSERT(ThisQueue->IsValid());

	ThisQueue->SetTimedOutFlag(fTimedOut);

	if(!ThisQueue->IsFirstTime())
	{
		//Call the users callback routine.
		fRet = ThisQueue->ExecuteUserCallBackRoutine(ThisPtr, fTimedOut);
	}
	else
	{
		//If this is the first time we got into this routine,
		//we need to make the first gethostbyname() call, then
		//issue the first asyn connect.
		fRet = ThisQueue->MakeFirstAsyncConnect();
		if(!fRet)
		{
			//let the user know that the gethostbyname failed.
			fRet = ThisQueue->ExecuteUserCallBackRoutine(ThisPtr, fTimedOut);
		}
	}

    //Dec the ref count if it is zero that means no more threads are going to come in
    //here after this
	if(ThisQueue->DecRefCount() == 0)
        delete ThisQueue;
    
}

void CAsyncConnection::StoreHostent(struct hostent *pHostent)
{
	TraceFunctEnterEx((LPARAM)this, "CAsyncConnection::StoreHostent");

	// Initialize our HOSTENT
	if (pHostent)
		CopyMemory(&m_Hostent, pHostent, sizeof(HOSTENT));
	else
		ZeroMemory(&m_Hostent, sizeof(HOSTENT));

	// Provide our own buffer for IP addresses
	m_Hostent.h_addr_list = (char **)m_pLocalIpAddresses;

	ZeroMemory(m_pLocalIpAddresses, sizeof(m_pLocalIpAddresses));
	ZeroMemory(m_LocalIpAddresses, sizeof(m_LocalIpAddresses));

	// Now we copy all IP addresses from the returned HOSTENT to our own
	// data buffers
	if (pHostent)
	{
		struct in_addr	*pin;
		DWORD			dwIndex;
		BOOL			fAddressConverted = FALSE;

		for (dwIndex = 0; pHostent->h_addr_list[dwIndex]; dwIndex++)
		{
			pin = (struct in_addr *)pHostent->h_addr_list[dwIndex];

			//Save all IP addresses up to _MAX_HOSTENT_IP_ADDRESSES
			if (dwIndex < _MAX_HOSTENT_IP_ADDRESSES)
			{
				m_pLocalIpAddresses[dwIndex] = &m_LocalIpAddresses[dwIndex];
				m_LocalIpAddresses[dwIndex] = *pin;
				DebugTrace((LPARAM)this, "IP Address [%2u]: %u.%u.%u.%u",
						dwIndex,
						pin->s_net, pin->s_imp,
						pin->s_impno, pin->s_lh);

			}
			else
				break;
		}

		// Terminate the list and leave
		m_pLocalIpAddresses[dwIndex] = NULL;
	}
	
	TraceFunctLeaveEx((LPARAM)this);
}

BOOL CAsyncConnection::AsyncConnectSuccessfull(void)
{
	BOOL fRet = FALSE;
	int SockRet = 0;
	WSANETWORKEVENTS NetworkEvents;

    TraceFunctEnterEx((LPARAM) this, "CAsyncConnection::AsyncConnectSuccessfull");

	if(!m_Error &&!m_fTimedOut && !IsFirstTime())
	{
		SockRet = WSAEnumNetworkEvents(AsyncSock, m_SignalHandle, &NetworkEvents);
		if(SockRet == 0)
		{
			m_Error = NetworkEvents.iErrorCode[FD_CONNECT_BIT];
			if(m_Error == 0)
			{
				fRet = TRUE;
			}
		}
	}

	ResetSocketToBlockingMode();

	if(fRet)
	{
		//if the connection was successful, set the flag that
		//tells the destructor not to close the socket.
		SetCloseSocketFlag(FALSE);
	}
	else
	{
		//if we got here, it means either means we timed out,
		//or the connect itself was unsuccessfull.
		
		ErrorTrace((LPARAM) this, "%s had error %d connecting", m_HostName, m_Error);

		CloseAsyncSocket();
	}

	m_Error = 0;
    TraceFunctLeaveEx((LPARAM)this);
	return fRet;
}

BOOL CAsyncConnection::IssueTcpConnect(SOCKADDR_IN  &connect_addr)
{
	BOOL fRet = FALSE;
	DWORD Error = 0;
	DWORD IpAddress = 0;

    TraceFunctEnterEx((LPARAM) this, "CAsyncConnection::IssueTcpConnect");

    ErrorTrace((LPARAM) this, "Connecting to %s over %d", m_HostName, m_Port);

	IpAddress = (DWORD) connect_addr.sin_addr.s_addr;
    connect_addr.sin_family =  AF_INET;
    connect_addr.sin_port = htons((u_short) m_Port);

	if(CheckIpAddress(connect_addr.sin_addr.s_addr, m_Port))
	{
        //We increment the ref count
        //We decrement if we complete synchronously or fail
        IncRefCount();
        SetConnectedIpAddress(IpAddress);
		if(connect (GetSockethandle(), (PSOCKADDR) &connect_addr, sizeof(connect_addr)) == 0)
		{
            DecRefCount();
			fRet = TRUE;
		}
		else 
		{
			Error = WSAGetLastError();
			if(Error == WSAEWOULDBLOCK)
			{
				fRet = TRUE;
			}
			else
			{
                DecRefCount();
				m_Error = Error;
			}
		}
	}

    TraceFunctLeaveEx((LPARAM)this);
	return fRet;
}

BOOL CAsyncConnection::MakeNewConnection(void)
{
	struct hostent *hp = NULL;
	BOOL fRet = FALSE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncConnection::MakeNewConnections");

	//nope, try gethostbyname()
	hp = gethostbyname (m_HostName);
	if ( hp != NULL )
	{
		StoreHostent(hp);
		//if(ConnectToHost())
		//{
			fRet = TRUE;
		//}
	}
	else
	{
		//failed...lets get out of  here
		m_Error = WSAGetLastError();

		if(m_Error == ERROR_INVALID_PARAMETER)
		{
			m_Error = WSAHOST_NOT_FOUND;
		}

		ZeroMemory(m_pLocalIpAddresses, sizeof(m_pLocalIpAddresses));
		ZeroMemory(m_LocalIpAddresses, sizeof(m_LocalIpAddresses));
		ZeroMemory(&m_Hostent, sizeof(m_Hostent));
		m_Hostent.h_addr_list = (char **)m_pLocalIpAddresses;
		NextIpToTry = 0;

	}

	SetFirstTime(FALSE);	
    TraceFunctLeaveEx((LPARAM)this);
	return fRet;
}

BOOL CAsyncConnection::DoGetHostByName(void)
{
	struct hostent *hp = NULL;
	BOOL fRet = FALSE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncConnection::DoGetHostByName");

    DebugTrace((LPARAM) this, "resolving %s in DoGetHost", m_HostName);

	ZeroMemory(m_pLocalIpAddresses, sizeof(m_pLocalIpAddresses));
	ZeroMemory(m_LocalIpAddresses, sizeof(m_LocalIpAddresses));
	ZeroMemory(&m_Hostent, sizeof(m_Hostent));
	m_Hostent.h_addr_list = (char **)m_pLocalIpAddresses;
	NextIpToTry = 0;

	if(m_HostName[0] == '[')
	{
		fRet = TRUE;
	}
	else if(hp = gethostbyname (m_HostName))
	{
		StoreHostent(hp);
		fRet = TRUE;
	}

    TraceFunctLeaveEx((LPARAM)this);
	return fRet;
}

BOOL CAsyncConnection::MakeFirstAsyncConnect(void)
{
	struct hostent *hp = NULL;
	BOOL fRet = FALSE;
	BOOL fDomainLiteral = FALSE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncConnection::MakeFirstAsyncConnect");

    DebugTrace((LPARAM) this, "resolving %s", m_HostName);

	if(m_HostName[0] == '[')
	{
		fDomainLiteral = TRUE;

		if(ConnectToHost())
			fRet = TRUE;
	}
	else if (hp = gethostbyname (m_HostName))
	{
		StoreHostent(hp);
		if(ConnectToHost())
		{
			fRet = TRUE;
		}
	}
	else
	{
		m_Error = WSAGetLastError();
	}

	if(!fRet || fDomainLiteral)
	{
		//failed...lets get out of  here
		//m_Error = WSAGetLastError();

		ZeroMemory(m_pLocalIpAddresses, sizeof(m_pLocalIpAddresses));
		ZeroMemory(m_LocalIpAddresses, sizeof(m_LocalIpAddresses));
		ZeroMemory(&m_Hostent, sizeof(m_Hostent));
		m_Hostent.h_addr_list = (char **)m_pLocalIpAddresses;
		NextIpToTry = 0;
	}

	SetFirstTime(FALSE);	
    TraceFunctLeaveEx((LPARAM)this);
	return fRet;
}

BOOL CAsyncConnection::ConnectToHost(void)
{
	unsigned long InetAddr = 0;
    char * pEndIp = NULL;
	char * pRealHost = NULL;
	char OldChar = '\0';
	struct hostent *hp = NULL;
	BOOL fRet = FALSE;
	BOOL IsDomainLiteral = FALSE;
	SOCKADDR_IN  connect_addr;

    TraceFunctEnterEx((LPARAM) this, "ConnectToHost");

	_ASSERT(AsyncSock == INVALID_SOCKET);

	AsyncSock = socket(AF_INET, SOCK_STREAM, 0);
	if(AsyncSock == INVALID_SOCKET)
	{
		m_Error = WSAGetLastError();
        ErrorTrace((LPARAM) this, "socket returned %d", m_Error);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
	}

	SetSocketOptions();

	//turn the socket into non-blocking mode and ask winsock to notify
	//us when the connect happens
	m_Error = WSAEventSelect(AsyncSock, m_SignalHandle, FD_CONNECT);
	if(m_Error == SOCKET_ERROR)
	{
		m_Error = WSAGetLastError();
		closesocket(AsyncSock);
		AsyncSock = INVALID_SOCKET;
        ErrorTrace((LPARAM) this, "WSAEventSelect returned %d", m_Error);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
	}

	pRealHost = m_HostName;

    //see if this is a domain literal
    if(pRealHost[0] == '[')
    {
		pEndIp = strchr(pRealHost, ']');
		if(pEndIp == NULL)
		{
			m_Error = WSAHOST_NOT_FOUND;
			goto Exit;
		}

			//save the old character
			OldChar = *pEndIp;

			//null terminate the string
		*pEndIp = '\0';
		IsDomainLiteral = TRUE;
		pRealHost++;
    }

	if(IsFirstTime())
	{
		SetFirstTime(FALSE);	

		//Is this an ip address
 		InetAddr = inet_addr( (char *) pRealHost );
		if(InetAddr != INADDR_NONE)
		{
			if(IsDomainLiteral)
			{
				//put back the old character
				*pEndIp = OldChar;
			}

			CopyMemory(&connect_addr.sin_addr, &InetAddr, 4);

			return IssueTcpConnect(connect_addr);
		}
	}

	if(m_Hostent.h_addr_list[NextIpToTry] != NULL)
	{
		CopyMemory(&connect_addr.sin_addr, m_Hostent.h_addr_list[NextIpToTry], m_Hostent.h_length);

		IncNextIpToTry();

		DebugTrace((LPARAM) this, "connecting to %s with IpAddress %s",
               m_HostName, inet_ntoa( *(struct in_addr UNALIGNED *) &connect_addr.sin_addr));

		fRet = IssueTcpConnect(connect_addr);
	}
	else
	{
		fRet = FALSE;
	}

Exit:

	 if(IsDomainLiteral)
	 {
		//put back the old character
		*pEndIp = OldChar;
	 }

    //could not connect to any of smarthosts' IP addresses
    //ErrorTrace((LPARAM) 0, "could not connect to host %s , error =%i", HostName, RetError);
    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

BOOL CAsyncConnection::ConnectToHost(DWORD IpAddress)
{
	unsigned long InetAddr = 0;
    char * pEndIp = NULL;
	char * pRealHost = NULL;
	char OldChar = '\0';
	struct hostent *hp = NULL;
	BOOL fRet = FALSE;
	BOOL IsDomainLiteral = FALSE;
	SOCKADDR_IN  connect_addr;

    TraceFunctEnterEx((LPARAM) this, "ConnectToHost(DWORD)");

	_ASSERT(AsyncSock == INVALID_SOCKET);

	AsyncSock = socket(AF_INET, SOCK_STREAM, 0);
	if(AsyncSock == INVALID_SOCKET)
	{
		m_Error = WSAGetLastError();
        ErrorTrace((LPARAM) this, "socket returned %d", m_Error);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
	}

	SetSocketOptions();

	//turn the socket into non-blocking mode and ask winsock to notify
	//us when the connect happens
	m_Error = WSAEventSelect(AsyncSock, m_SignalHandle, FD_CONNECT);
	if(m_Error == SOCKET_ERROR)
	{
		m_Error = WSAGetLastError();
		closesocket(AsyncSock);
		AsyncSock = INVALID_SOCKET;
        ErrorTrace((LPARAM) this, "WSAEventSelect returned %d", m_Error);
        TraceFunctLeaveEx((LPARAM)this);
        return FALSE;
	}

	pRealHost = m_HostName;

    //see if this is a domain literal
    if(pRealHost[0] == '[')
    {
		pEndIp = strchr(pRealHost, ']');
		if(pEndIp == NULL)
		{
			m_Error = WSAHOST_NOT_FOUND;
			goto Exit;
		}

			//save the old character
			OldChar = *pEndIp;

			//null terminate the string
		*pEndIp = '\0';
		IsDomainLiteral = TRUE;
		pRealHost++;
    }

	if(IsFirstTime())
	{
		SetFirstTime(FALSE);	

		//Is this an ip address
 		InetAddr = inet_addr( (char *) pRealHost );
		if(InetAddr != INADDR_NONE)
		{
			if(IsDomainLiteral)
			{
				//put back the old character
				*pEndIp = OldChar;
			}

			CopyMemory(&connect_addr.sin_addr, &InetAddr, 4);

			return IssueTcpConnect(connect_addr);
		}
	}

	CopyMemory(&connect_addr.sin_addr, &IpAddress, 4);

	DebugTrace((LPARAM) this, "connecting to %s with IpAddress %s",
               m_HostName, inet_ntoa( *(struct in_addr UNALIGNED *) &connect_addr.sin_addr));

	fRet = IssueTcpConnect(connect_addr);

Exit:

	 if(IsDomainLiteral)
	 {
		//put back the old character
		*pEndIp = OldChar;
	 }

    //could not connect to any of smarthosts' IP addresses
    //ErrorTrace((LPARAM) 0, "could not connect to host %s , error =%i", HostName, RetError);
    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\blockmgr\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\basetrac\lib\basetrac.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: basetrac.cpp
//
//  Description:    Tracking of COM-base AddRef's and releases for debug
//      builds.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/28/98 - MikeSwa Created
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <string.h>
#include <dbgtrace.h>
#include <basetrac.h>
#include <imagehlp.h>

CCallStackEntry_Base::CCallStackEntry_Base()
{
    m_dwCallStackType = TRACKING_OBJECT_UNUSED;
    m_dwCallStackDepth = 0;
    m_pdwptrCallers = 0;
}

/*
 -	GetCallStack
 -
 *	Purpose:
 *		Uses the imagehlp APIs to get the call stack.
 *
 *	Parameters:
 *		pdwCaller			An array of return addresses
 *		cFind				Count of stack frames to get
 *
 *	Returns:
 *		VOID
 *
 *  This is a 64-aware version the function from Exchmem.
 *
 */
void CCallStackEntry_Base::GetCallers()
{
    BOOL            fMore;
    STACKFRAME      stkfrm = {0};
    CONTEXT         ctxt;
    HANDLE			hThread;
    HANDLE			hProcess;
    DWORD           cFramesLeft = m_dwCallStackDepth;
    DWORD_PTR      *pdwptrCurrentCaller = m_pdwptrCallers;
    DWORD           i = 0;
    DWORD           dwMachineType =
#ifdef _M_IX86
                        IMAGE_FILE_MACHINE_I386;
#elif defined(_M_AMD64)
                        IMAGE_FILE_MACHINE_AMD64;
#elif defined(_M_IA64)
                        IMAGE_FILE_MACHINE_IA64;
#else
                        IMAGE_FILE_MACHINE_UNKNOWN;
#endif


// This debug code does not currently work on IA64
// Currently, the NT headers to not contain
// the definitions required to make this work:
//  - 64-bit ReadProcessMemory
//  - IA64 Context Full
    if (!m_dwCallStackDepth || !m_pdwptrCallers)
        return;

    hThread = GetCurrentThread();
    hProcess = GetCurrentProcess();

    ZeroMemory(&ctxt, sizeof(CONTEXT));
    ZeroMemory(m_pdwptrCallers, m_dwCallStackDepth * sizeof(DWORD_PTR));

#ifndef CONTEXT_FULL
#define CONTEXT_FULL 0
#pragma message ("Warning: CONTEXT_FULL is not defined in winnt.h")
#endif //CONTEXT_FULL not defined
    ctxt.ContextFlags = CONTEXT_FULL;

    if (!GetThreadContext(hThread, &ctxt))
    {
        stkfrm.AddrPC.Offset = 0;
    }
    else
    {
#if defined(_M_IX86)
        _asm
        {
            mov stkfrm.AddrStack.Offset, esp
            mov stkfrm.AddrFrame.Offset, ebp
            mov stkfrm.AddrPC.Offset, offset DummyLabel
DummyLabel:
        }
#elif defined(_M_MRX000)
        stkfrm.AddrPC.Offset = ctxt.Fir;
        stkfrm.AddrStack.Offset = ctxt.IntSp;
        stkfrm.AddrFrame.Offset = ctxt.IntSp;
#elif defined(_M_ALPHA)
        stkfrm.AddrPC.Offset = ctxt.Fir;
        stkfrm.AddrStack.Offset = ctxt.IntSp;
        stkfrm.AddrFrame.Offset = ctxt.IntSp;
#elif defined(_M_PPC)
        stkfrm.AddrPC.Offset = ctxt.Iar;
        stkfrm.AddrStack.Offset = ctxt.Gpr1;
        stkfrm.AddrFrame.Offset = ctxt.Gpr1;
#else
        stkfrm.AddrPC.Offset = 0;
#endif
    }

    stkfrm.AddrPC.Mode = AddrModeFlat;
    stkfrm.AddrStack.Mode = AddrModeFlat;
    stkfrm.AddrFrame.Mode = AddrModeFlat;


    //Eat the first 2 callers
    for (i = 0; i < 2; i++)
    {
        fMore = StackWalk(
                        dwMachineType,
                        hProcess,
                        hThread,
                        &stkfrm,
                        &ctxt,
                        NULL,
                        SymFunctionTableAccess,
                        SymGetModuleBase,
                        NULL);
        if (!fMore)
            break;
    }

	while (fMore && (cFramesLeft > 0))
	{
        fMore = StackWalk(
                        dwMachineType,
                        hProcess,
                        hThread,
                        &stkfrm,
                        &ctxt,
                        NULL,
                        SymFunctionTableAccess,
                        SymGetModuleBase,
                        NULL);

        if (!fMore)
            break;

        *pdwptrCurrentCaller++ = (DWORD_PTR) stkfrm.AddrPC.Offset;
        cFramesLeft -= 1;
    }
}

CDebugTrackingObject_Base::CDebugTrackingObject_Base()
{
    m_dwSignature = TRACKING_OBJ_SIG;
    m_cCurrentStackEntries = 0;
    m_cCallStackEntries = 0;
    m_cbCallStackEntries = 0;
}

CDebugTrackingObject_Base::~CDebugTrackingObject_Base()
{
    _ASSERT(0 == m_lReferences);
}

void CDebugTrackingObject_Base::LogTrackingEvent(DWORD dwTrackingReason)
{
    CCallStackEntry_Base *pkbeCurrent = NULL;
    DWORD dwIndex = InterlockedIncrement((PLONG) &m_cCurrentStackEntries)-1;
    dwIndex %= m_cCallStackEntries;

    //find pointer to current call stack entry
    pkbeCurrent = (CCallStackEntry_Base *)
        (((BYTE *) m_pkbebCallStackEntries) + dwIndex*m_cbCallStackEntries);
    pkbeCurrent->m_dwCallStackType = dwTrackingReason;
    pkbeCurrent->GetCallers();
}

ULONG CDebugTrackingObject::AddRef()
{
    LogTrackingEvent(TRACKING_OBJECT_ADDREF);
    return CBaseObject::AddRef();
}

ULONG CDebugTrackingObject::Release()
{
    _ASSERT(m_lReferences);
    LogTrackingEvent(TRACKING_OBJECT_RELEASE);
    return CBaseObject::Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\cmmprops\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\asynccon\src\ntqio.cxx ===
#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}

HANDLE
WINAPI
SmtpRegisterWaitForSingleObject(
    HANDLE hObject,
    WAITORTIMERCALLBACKFUNC Callback,
    PVOID Context,
    ULONG dwMilliseconds
    )
{
    HANDLE WaitHandle ;
    NTSTATUS Status ;

    Status = RtlRegisterWait(
                &WaitHandle,
                hObject,
                Callback,
                Context,
                dwMilliseconds,
                0);            // Need WIN32 specifier

    if ( NT_SUCCESS( Status ) )
    {
        return WaitHandle ;
    }
    
	BaseSetLastNTError( Status );
    return NULL ;
}

BOOL
WINAPI
SmtpUnregisterWait(
    HANDLE WaitHandle
    )
/*++

Routine Description:

    This function cancels a wait for a particular object.

Arguments:

    WaitHandle - Handle returned from RegisterWaitForSingleObject

Return Value:

    TRUE - The wait was cancelled
    FALSE - an error occurred, use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;

    if ( WaitHandle )
    {
        Status = RtlDeregisterWait( WaitHandle );

        if ( NT_SUCCESS( Status ) )
        {
            return TRUE ;
        }

        BaseSetLastNTError( Status );

        return FALSE ;

    }

    SetLastError( ERROR_INVALID_HANDLE );

    return FALSE ;
}

BOOL
WINAPI
SmtpQueueUserWorkItem(
    LPTHREAD_START_ROUTINE Function,
    PVOID Context,
    BOOL PreferIo
    )
/*++

Routine Description:

    This function queues a work item to a thread out of the thread pool.  The
    function passed is invoked in a different thread, and passed the Context
    pointer.  The caller can specify whether the thread pool should select
    a thread that has I/O pending, or any thread.

Arguments:

    Function -  Function to call

    Context -   Pointer passed to the function when it is invoked.

    PreferIo -  Indictes to the thread pool that this thread will perform
                I/O.  A thread that starts an asynchronous I/O operation
                must wait for it to complete.  If a thread exits with
                outstanding I/O requests, those requests will be cancelled.
                This flag is a hint to the thread pool that this function
                will start I/O, so that a thread with I/O already pending
                will be used.

Return Value:

    TRUE - The work item was queued to another thread.
    FALSE - an error occurred, use GetLastError() for more information.

--*/

{
    NTSTATUS Status ;

    Status = RtlQueueWorkItem(
                (WORKERCALLBACKFUNC) Function,
                Context,
                PreferIo ? WT_EXECUTEINIOTHREAD : 0 );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\cmmprops\cmmprops.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cmmprops.cpp

Abstract:

    This module contains the implementation of the property search class

Author:

    Keith Lau   (keithlau@microsoft.com)

Revision History:

    keithlau    03/05/98    created

--*/

#include <windows.h>
#include <malloc.h>
#include <stdlib.h>
#include <search.h>

#include "dbgtrace.h"
#include "signatur.h"
#include "cmmprops.h"
#include "cmmtypes.h"
#include "stddef.h"


long g_cCPropertyTableCreations = 0;
long g_cCPropertyTableSearchs = 0;

extern DWORD g_fValidateSignatures;

// =================================================================
// Implementation of CPropertyTableItem
//
CPropertyTableItem::CPropertyTableItem(
            CBlockManager               *pBlockManager,
            LPPROPERTY_TABLE_INSTANCE   pInstanceInfo
            )
{
    _ASSERT(pInstanceInfo);
    _ASSERT(pBlockManager);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::CPropertyTableItem");

    m_pInstanceInfo = pInstanceInfo;
    m_pBlockManager = pBlockManager;
    m_fLoaded = FALSE;

    m_dwCurrentFragment = 0;
    m_faOffsetToFragment = 0;
    m_dwCurrentItem = 0;
    m_dwCurrentItemInFragment = 0;
    m_faOffsetToCurrentItem = INVALID_FLAT_ADDRESS;

    TraceFunctLeaveEx((LPARAM)this);
}

CPropertyTableItem::~CPropertyTableItem()
{
    _ASSERT(m_pInstanceInfo);
    _ASSERT(m_pBlockManager);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::~CPropertyTableItem");

    m_pInstanceInfo = NULL;
    m_pBlockManager = NULL;
    m_fLoaded = FALSE;
    m_dwCurrentFragment = 0;
    m_faOffsetToFragment = 0;
    m_dwCurrentItem = 0;
    m_dwCurrentItemInFragment = 0;
    m_faOffsetToCurrentItem = INVALID_FLAT_ADDRESS;

    TraceFunctLeaveEx((LPARAM)this);
}


HRESULT CPropertyTableItem::AddItem(
            LPPROPERTY_ITEM pItem,
            DWORD           *pdwIndex,
            FLAT_ADDRESS    *pfaOffsetToItem
            )
{
    HRESULT hrRes = S_OK;
    DWORD   cNumSleeps = 0;
    const DWORD MAX_ADDITEM_SLEEPS = 5;
    DWORD   dwPropertyId;
    DWORD   dwFragmentNumber;
    DWORD   dwItemsInFragment;
    DWORD   dwItemInFragment;
    DWORD   dwSize;
    FLAT_ADDRESS    faOffset;

    _ASSERT(pdwIndex);
    _ASSERT(m_pInstanceInfo);
    _ASSERT(m_pBlockManager);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::AddItem");

    for (;;)
    {
        // OK, first we determine if we need to create a new fragment
        // before we move on ...
        dwPropertyId = m_pInstanceInfo->dwProperties;

        // Find out about our fragment type
        dwItemsInFragment = 1 << m_pInstanceInfo->dwItemBits;
        dwItemInFragment = dwPropertyId & (dwItemsInFragment - 1);
        dwFragmentNumber = dwPropertyId >> m_pInstanceInfo->dwItemBits;
        dwSize = m_pInstanceInfo->dwItemSize;

        // See if we already have the desired fragment
        hrRes = ReadFragmentFromFragmentNumber(dwFragmentNumber);
        if (!SUCCEEDED(hrRes))
        {
            // It's some other error, return failure ...
            if (hrRes != STG_E_PATHNOTFOUND)
            {
                ErrorTrace((LPARAM)this,
                            "Unable to ReadFragmentFromFragmentNumber");
                TraceFunctLeaveEx((LPARAM)this);
                return(hrRes);
            }

            if (dwFragmentNumber && (m_dwCurrentFragment < dwFragmentNumber))
            {
                // This is really embarassing, we are on a new fragment
                // but the fragment(s) before that are still not created
                // yet, we got to retry at this point ...
                continue;
            }

            // OK, so the fragment is not created yet, see if we need to
            // create it. THe first entry in a new fragment is responsible
            // for creating the fragment
            if (!dwItemInFragment)
            {
                // Build a new fragment structure ...
                DWORD                   dwOffset;
                FLAT_ADDRESS            faOffsetSlot;
                FLAT_ADDRESS            *pfaOffset;
                PROPERTY_TABLE_FRAGMENT ifFragment;
                ifFragment.dwSignature = PROPERTY_FRAGMENT_SIGNATURE_VALID;
                ifFragment.faNextFragment = INVALID_FLAT_ADDRESS;

                // The next ten or so lines of code is very tricky.
                // If we are at the first fragment (i.e. no fragments
                // have been created yet), then we would actually have to
                // fill in the offset of the allocated block into the
                // m_pInstanceInfo->faFirstFragment variable. Note that
                // pfaOffset is passed into AtomicAllocWriteAndIncrement
                // and the value is assigned INSIDE the locked region,
                // which makes this assignment thread-safe.
                //
                // For the other case, we need to fill in the parent's
                // faNextFragment member to link to the newly allocated
                // block. Now, since ReadFragmentFromFragmentNumber must
                // have failed beforehand at the node right before us.
                // m_faOffsetToFragment actually points to our parent's
                // fragment. So we pass in the offset of our parent's
                // faNextFragment value so the atomic operation can
                // fill it in for us.
                if (!dwFragmentNumber)
                {
                    // Hook up the first fragment
                    // _ASSERT(m_pInstanceInfo->faFirstFragment == 
                    //                  INVALID_FLAT_ADDRESS);
                    pfaOffset = &(m_pInstanceInfo->faFirstFragment);
                    faOffsetSlot = INVALID_FLAT_ADDRESS;
                }
                else
                {
                    // Hook up subsequent fragments to its parent
                    //_ASSERT(m_Fragment.faNextFragment == INVALID_FLAT_ADDRESS);
                    //_ASSERT(m_dwCurrentFragment == dwFragmentNumber);
                    pfaOffset = &faOffset;
                    faOffsetSlot = m_faOffsetToFragment +
                            offsetof(PROPERTY_TABLE_FRAGMENT, faNextFragment);
                }

                // Attempt to create the fragment, add the item to
                // the beginning of the new fragment, and increment the
                // property count in one atomic shot
                dwOffset = (dwItemInFragment * dwSize) +
                            sizeof(PROPERTY_TABLE_FRAGMENT);
                hrRes = m_pBlockManager->AtomicAllocWriteAndIncrement(
                            m_pInstanceInfo->dwFragmentSize,
                            pfaOffset,
                            faOffsetSlot,
                            INVALID_FLAT_ADDRESS,
                            (LPBYTE)&ifFragment,
                            sizeof(PROPERTY_TABLE_FRAGMENT),
                            (LPBYTE)pItem,
                            dwOffset,
                            dwSize,
                            &(m_pInstanceInfo->dwProperties),
                            dwPropertyId,
                            1,
                            &m_bcContext
                            );
                if (pfaOffsetToItem) *pfaOffsetToItem = *pfaOffset + dwOffset;
                if (!SUCCEEDED(hrRes))
                {
                    // We can fail for 2 reasons: Error or Retry; we bail
                    // out if it's an error.
                    if (hrRes != HRESULT_FROM_WIN32(ERROR_RETRY))
                    {
                        // Bail out!
                        ErrorTrace((LPARAM)this,
                            "Failed to AtomicAllocWriteAndIncrement (%08x)",
                            hrRes);
                        break;
                    }
                }
                else
                {
                    // Success
                    DebugTrace((LPARAM)this,
                            "Succeeded to AtomicAllocWriteAndIncrement!");

                    // We might want to update some internal members
                    // First, hook up the previous fragment to this new
                    // fragment.
                    _ASSERT(*pfaOffset != INVALID_FLAT_ADDRESS);
                    CopyMemory(&m_Fragment,
                                &ifFragment,
                                sizeof(PROPERTY_TABLE_FRAGMENT));
                    m_dwCurrentFragment = dwFragmentNumber;
                    m_faOffsetToFragment = *pfaOffset;
                    m_dwCurrentItem = dwPropertyId;
                    m_dwCurrentItemInFragment = dwItemInFragment;
                    m_fLoaded = TRUE;
                    break;
                }

                // Oooops, someone beat us in using this property ID,
                // we must retry immediately. Note since the state already
                // changed we would not be required to wait.
                continue;
            }

            // This is the most expensive case, basically, there is nothing
            // we can do but give up the time slice, I think besides changing
            // algorithm, this is the bast since I'd rather context switch
            // right away than switch after exhausting the time quanta
            Sleep(0);

            //
            // If we keep on doing this, then it is likely that there is 
            // some problem... that our conditions will never be met.
            //
            if (cNumSleeps > MAX_ADDITEM_SLEEPS) {
                FatalTrace((LPARAM) this, 
                    "Looping in AddItem...potential corrupt P1 - bailing");
                hrRes = E_FAIL;
                _ASSERT(0 && "Potential loop condition (corrupt msg) detected - contact SMTP dev");
                break;
            }
            cNumSleeps++;
            ErrorTrace((LPARAM) this,
                "Looping for the %d time in AddItem", cNumSleeps);
            continue;
        }

        // This is the simplest case where we don't have to create a new
        // fragment so all we do is attempt an atomic write and increment
        // Still, there will be a window where some other thread might
        // beat us in using this property ID. In that case, we will retry
        // immediately.
        faOffset = m_faOffsetToFragment + sizeof(PROPERTY_TABLE_FRAGMENT) +
                        (dwItemInFragment * dwSize);
        hrRes = m_pBlockManager->AtomicWriteAndIncrement(
                        (LPBYTE)pItem,
                        faOffset,
                        dwSize,
                        &(m_pInstanceInfo->dwProperties),
                        dwPropertyId,
                        1,
                        &m_bcContext
                        );
        if (pfaOffsetToItem) *pfaOffsetToItem = faOffset;
        if (!SUCCEEDED(hrRes))
        {
            // We can fail for 2 reasons: Error or Retry; we bail
            // out if it's an error.
            if (hrRes != HRESULT_FROM_WIN32(ERROR_RETRY))
            {
                // Bail out!
                ErrorTrace((LPARAM)this,
                    "Failed to AtomicWriteAndIncrement (%08x)",
                    hrRes);
                break;
            }
        }
        else
        {
            // Success
            DebugTrace((LPARAM)this,
                    "Succeeded to AtomicWriteAndIncrement!");
            break;
        }

        // Retry scenario ...

    } // for (;;)

    // Fill in info ...
    if (SUCCEEDED(hrRes))
    {
        *pdwIndex = dwPropertyId;
    }
    
    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

HRESULT CPropertyTableItem::UpdateItem(
            DWORD           dwIndex,
            LPPROPERTY_ITEM pItem,
            FLAT_ADDRESS    *pfaOffsetToItem
            )
{
    HRESULT hrRes = S_OK;

    _ASSERT(m_pInstanceInfo);
    _ASSERT(m_pBlockManager);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::UpdateItem");

    // Atomically set the item
    m_fLoaded = FALSE;
    m_dwCurrentItem = dwIndex;
    hrRes = GetOrSetNextExistingItem(pItem, PIO_ATOMIC_WRITE_ITEM, pfaOffsetToItem);
    
    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

HRESULT CPropertyTableItem::GetItemAtIndex(
            DWORD           dwIndex,
            LPPROPERTY_ITEM pItem,
            LPFLAT_ADDRESS  pfaOffset
            )
{
    HRESULT hrRes;
    
    _ASSERT(m_pInstanceInfo);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::GetItemAtIndex");

    // Just pre-set to what we want, and call GetOrSetNextExistingItem ...
    m_fLoaded = FALSE;
    m_dwCurrentItem = dwIndex;
    hrRes = GetOrSetNextExistingItem(pItem, PIO_READ_ITEM, pfaOffset);

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

HRESULT CPropertyTableItem::GetNextItem(
            LPPROPERTY_ITEM pItem
            )
{
    HRESULT hrRes;
    
    _ASSERT(m_pInstanceInfo);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::GetNextItem");

    // Just call GetOrSetNextExistingItem ...
    hrRes = GetOrSetNextExistingItem(pItem, PIO_READ_ITEM);

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


HRESULT CPropertyTableItem::GetOrSetNextExistingItem(
            // This looks at m_dwCurrentItem for index
            LPPROPERTY_ITEM pItem,
            DWORD           dwOperation,
            LPFLAT_ADDRESS  pfaOffset
            )
{
    HRESULT hrRes = S_OK;
    DWORD   dwCurrentItem;
    
    _ASSERT(m_pInstanceInfo);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::GetOrSetNextExistingItem");

    // See if we are still in range
    dwCurrentItem = m_dwCurrentItem;
    if (m_fLoaded)
        dwCurrentItem++;

    // If we are at the end, respond so.
    if (dwCurrentItem == m_pInstanceInfo->dwProperties)
    {
        m_fLoaded = FALSE;
        return(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
    }

    // We are blatantly out-of-range!
    if (dwCurrentItem > m_pInstanceInfo->dwProperties)
    {
        m_fLoaded = FALSE;
        return(STG_E_INVALIDPARAMETER);
    }

    m_dwCurrentItem = dwCurrentItem;

    // See if we are still in the current fragment
    if (!m_fLoaded ||
        (++m_dwCurrentItemInFragment >= (DWORD)(1 << m_pInstanceInfo->dwItemBits)))
    {
        FLAT_ADDRESS    faOffsetOfFragment;
        
        // We need to load a fragment
        if (!m_fLoaded)
        {
            DWORD   dwWhichFragment =
                        m_dwCurrentItem >> m_pInstanceInfo->dwItemBits;

            // Get the offset to the current fragment
            hrRes = ReadFragmentFromFragmentNumber(dwWhichFragment);
            if (!SUCCEEDED(hrRes))
                return(hrRes);
            _ASSERT(SUCCEEDED(hrRes));
            
            // Calculate the current item w.r.t the fragment
            m_dwCurrentItemInFragment = m_dwCurrentItem &
                        ((1 << m_pInstanceInfo->dwItemBits) - 1);
        }
        else
        {
            // Walk to next node
            faOffsetOfFragment = m_Fragment.faNextFragment;
            hrRes = ReadFragment(faOffsetOfFragment);
            if (!SUCCEEDED(hrRes))
            {
                ErrorTrace((LPARAM)this,
                            "Unable to load fragmentat offset %u",
                            (DWORD)faOffsetOfFragment);
                TraceFunctLeaveEx((LPARAM)this);
                return(hrRes);
            }

            // Okay, reset the current item
            m_dwCurrentFragment++;
            m_dwCurrentItemInFragment = 0;
        }
    }

    // Make sure what we have makes sense
    _ASSERT(m_dwCurrentItemInFragment < (DWORD)(1 << m_pInstanceInfo->dwItemBits));

    FLAT_ADDRESS    faOperateOffset =
                    m_faOffsetToFragment + sizeof(PROPERTY_TABLE_FRAGMENT) +
                    (m_dwCurrentItemInFragment * m_pInstanceInfo->dwItemSize);

    switch (dwOperation)
    {
    case PIO_READ_ITEM:

        // OK, Issue a read to get the item entry.
        DebugTrace((LPARAM)this, "Reading item");
        hrRes = ReadItem(faOperateOffset, pItem);
        if (SUCCEEDED(hrRes))
            m_faOffsetToCurrentItem = faOperateOffset;
        break;
    
    case PIO_WRITE_ITEM:
    case PIO_ATOMIC_WRITE_ITEM:

        // OK, Issue a write to set the item entry.
        DebugTrace((LPARAM)this, "Writing item%s",
                (dwOperation == PIO_ATOMIC_WRITE_ITEM)?" atomically":"");
        hrRes = WriteItem(faOperateOffset, pItem,
                    (dwOperation == PIO_ATOMIC_WRITE_ITEM));
        if (SUCCEEDED(hrRes))
            m_faOffsetToCurrentItem = faOperateOffset;
        break;

    default:
        _ASSERT(FALSE);
        ErrorTrace((LPARAM)this,
                "Invalid operation %u", dwOperation);
        hrRes = STG_E_INVALIDFUNCTION;
    }

    if (SUCCEEDED(hrRes) && pfaOffset)
        *pfaOffset = faOperateOffset;

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

inline HRESULT CPropertyTableItem::ReadFragmentFromFragmentNumber(
            DWORD           dwFragmentNumber
            )
{
    HRESULT hrRes;
    FLAT_ADDRESS    faOffsetOfFragment;
    
    _ASSERT(m_pInstanceInfo);

    TraceFunctEnterEx((LPARAM)this,
                "CPropertyTableItem::ReadFragmentFromFragmentNumber");

    // Note this is strictly internal so we don't do much checking

    // Initially point to sentinel
    m_fLoaded = FALSE;
    m_dwCurrentFragment = 0;
    faOffsetOfFragment = m_pInstanceInfo->faFirstFragment;
    do
    {
        // Now if we are only one away from the desired node, but the
        // fragment does not exist, we will return a special code to
        // indicate that
        if (faOffsetOfFragment == INVALID_FLAT_ADDRESS)
        {
            DebugTrace((LPARAM)this,
                        "Unable to load fragment at offset %u (INVALID_FLAT_ADDRESS)",
                        (DWORD)faOffsetOfFragment);
            hrRes = STG_E_PATHNOTFOUND;
            break;
        }

        hrRes = ReadFragment(faOffsetOfFragment);
        if (!SUCCEEDED(hrRes))
        {
            ErrorTrace((LPARAM)this,
                        "Unable to load fragment %u at offset %u",
                        dwFragmentNumber, (DWORD)faOffsetOfFragment);
            break;
        }

        // Walk to next node
        m_dwCurrentFragment++;
        faOffsetOfFragment = m_Fragment.faNextFragment;

    } while (dwFragmentNumber--);

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

inline HRESULT CPropertyTableItem::ReadFragment(
            FLAT_ADDRESS    faOffset
            )
{
    HRESULT hrRes;
    DWORD   dwSize;

    _ASSERT(m_pBlockManager);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::ReadFragment");

    // Is the fragment correct?
    if (faOffset == INVALID_FLAT_ADDRESS)
        return(STG_E_INVALIDPARAMETER);

    // Load up the minimal fragment header
    hrRes = m_pBlockManager->ReadMemory(
                    (LPBYTE)&m_Fragment,
                    faOffset,
                    sizeof(PROPERTY_TABLE_FRAGMENT),
                    &dwSize,
                    &m_bcContext);
    if (SUCCEEDED(hrRes))
    {
        if(g_fValidateSignatures && m_Fragment.dwSignature != PROPERTY_FRAGMENT_SIGNATURE_VALID)
            ForceCrashIfNeeded();

        m_fLoaded = TRUE;
        m_faOffsetToFragment = faOffset;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

inline HRESULT CPropertyTableItem::ReadItem(
            FLAT_ADDRESS    faOffset,
            LPPROPERTY_ITEM pItem
            )
{
    HRESULT hrRes;
    DWORD   dwSize;

    _ASSERT(m_pBlockManager);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::ReadItem");

    hrRes = m_pBlockManager->ReadMemory(
                (LPBYTE)pItem,
                faOffset,
                m_pInstanceInfo->dwItemSize,
                &dwSize,
                &m_bcContext);

    DebugTrace((LPARAM)this,
                "Loaded item from offset %u, HRESULT = %08x",
                (DWORD)faOffset, hrRes);

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

inline HRESULT CPropertyTableItem::WriteItem(
            FLAT_ADDRESS    faOffset,
            LPPROPERTY_ITEM pItem,
            BOOL            fAtomic
            )
{
    HRESULT hrRes;
    DWORD   dwSize;

    _ASSERT(m_pBlockManager);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTableItem::WriteItem");

    if (fAtomic)
    {
        hrRes = m_pBlockManager->AtomicWriteAndIncrement(
                    (LPBYTE)pItem,
                    faOffset,
                    m_pInstanceInfo->dwItemSize,
                    NULL,   // No increment value, just a write
                    0,
                    0,
                    &m_bcContext);
    }
    else
    {
        hrRes = m_pBlockManager->WriteMemory(
                    (LPBYTE)pItem,
                    faOffset,
                    m_pInstanceInfo->dwItemSize,
                    &dwSize,
                    &m_bcContext);
    }

    DebugTrace((LPARAM)this,
                "Written item to offset %u, HRESULT = %08x",
                (DWORD)faOffset, hrRes);

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

// =================================================================
// Implementation of CPropertyTable
//

CPropertyTable::CPropertyTable(
            PROPERTY_TABLE_TYPES        pttTableType,
            DWORD                       dwValidSignature,
            CBlockManager               *pBlockManager,
            LPPROPERTY_TABLE_INSTANCE   pInstanceInfo,
            LPPROPERTY_COMPARE_FUNCTION pfnCompare,
            const LPINTERNAL_PROPERTY_ITEM  pInternalProperties,
            DWORD                       dwInternalProperties
            )
{
    _ASSERT(pBlockManager);
    _ASSERT(pInstanceInfo);
    _ASSERT(pfnCompare);


    TraceFunctEnterEx((LPARAM)this, "CPropertyTable::CPropertyTable");

    // Invalidate before initialization
    m_dwSignature = CPROPERTY_TABLE_SIGNATURE_INVALID;

    if (pttTableType == PTT_PROPERTY_TABLE)
    {
        // Enforce very strict checking of consistency
        if (!pInternalProperties)
        {
            _ASSERT(!dwInternalProperties);
        }
        else
        {
            _ASSERT(dwInternalProperties);
        }
    }
    else
    {
        // These parameters must not be set if the table is other
        // than a property table
        _ASSERT(!pInternalProperties);
        _ASSERT(!dwInternalProperties);
    }

    // Initialize internals
    m_dwTableType           = pttTableType;
    m_pBlockManager         = pBlockManager;
    m_pfnCompare            = pfnCompare;
    m_pInstanceInfo         = pInstanceInfo;
    m_pInternalProperties   = pInternalProperties;
    m_dwInternalProperties  = dwInternalProperties;
    m_dwValidInstanceSignature = dwValidSignature;

    // Validate the instance info structure
    /*
    _ASSERT(IsInstanceInfoValid());
    _ASSERT(m_pInstanceInfo->dwFragmentSize ==
            ((m_pInstanceInfo->dwItemSize << m_pInstanceInfo->dwItemBits) +
            sizeof(PROPERTY_TABLE_FRAGMENT)));
    */

    // figure out what sort of mailmsg property table we are creating.
    // if its the global property table then setup member variables to 
    // do property caching.
    //
    // There is no reason to cache recipient property offsets at this
    // time since the recipient property table is instantiated, used
    // once, then thrown away.  we'd spend more time making the cache
    // then the linear search in SearchForProperty costs
    if (m_dwValidInstanceSignature == GLOBAL_PTABLE_INSTANCE_SIGNATURE_VALID) {
        m_iCachedPropsBase = IMMPID_MP_BEFORE__+1;
        m_cCachedProps = IMMPID_MP_AFTER__ - m_iCachedPropsBase;
    } else {
        m_iCachedPropsBase = 0xffffffff;
        m_cCachedProps = 0;
    }

    // this is allocated and filled in lazily in InitializePropCache()
    m_rgCachedProps = NULL;

    // Validate the property table object
    m_dwSignature = CPROPERTY_TABLE_SIGNATURE_VALID;

    TraceFunctLeaveEx((LPARAM)this);
}

CPropertyTable::~CPropertyTable()
{
    _ASSERT(IsValid());

    TraceFunctEnterEx((LPARAM)this, "CPropertyTable::~CPropertyTable");

    // Invalidate!
    m_dwSignature = CPROPERTY_TABLE_SIGNATURE_INVALID;

    // free memory
    if (m_rgCachedProps) {
        _ASSERT(m_cCachedProps != 0);
        CMemoryAccess::FreeBlock(m_rgCachedProps);
        m_rgCachedProps = NULL;
        m_iCachedPropsBase = 0xffffffff;
        m_cCachedProps = 0;
    }

    // Wipe out all info so we make sure we AV if we access this
    // afterwards
    // Initialize internals
    m_dwTableType           = PTT_INVALID_TYPE;
    m_pBlockManager         = NULL;
    m_pfnCompare            = NULL;
    m_pInstanceInfo         = NULL;
    m_pInternalProperties   = NULL;
    m_dwInternalProperties  = 0;

    TraceFunctLeaveEx((LPARAM)this);
}

BOOL CPropertyTable::IsValid()
{
    return((m_dwSignature == CPROPERTY_TABLE_SIGNATURE_VALID));
}

BOOL CPropertyTable::IsInstanceInfoValid()
{
    BOOL    fRet = FALSE;

    TraceFunctEnterEx((LPARAM)this, "CPropertyTable::IsInstanceInfoValid");

    if (m_pInstanceInfo &&
        m_pInstanceInfo->dwSignature == m_dwValidInstanceSignature)
    {
        fRet = TRUE;
    }
    else
    {
        FatalTrace((LPARAM)this, "Invalid signature");
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(fRet);
}

HRESULT CPropertyTable::GetCount(
            DWORD       *pdwCount
            )
{
    _ASSERT(IsInstanceInfoValid());
    _ASSERT(pdwCount);

    if (!IsInstanceInfoValid())
        return(STG_E_INVALIDHEADER);

    *pdwCount = m_pInstanceInfo->dwProperties;
    return(S_OK);
}


HRESULT CPropertyTable::GetPropertyItem(
            LPVOID          pvPropKey,
            LPPROPERTY_ITEM pItem
            )
{
    HRESULT hrRes           = S_OK;
    DWORD   dwCurrentItem   = 0;

    _ASSERT(IsInstanceInfoValid());
    _ASSERT(m_pfnCompare);
    _ASSERT(pvPropKey);
    _ASSERT(pItem);

    TraceFunctEnter("CPropertyTable::GetPropertyItem");

    hrRes = SearchForProperty(pvPropKey, pItem, NULL, NULL);
        
    TraceFunctLeave();
    return(hrRes);
}

HRESULT CPropertyTable::GetPropertyItemAndValue(
            LPVOID          pvPropKey,
            LPPROPERTY_ITEM pItem,
            DWORD           dwLength,
            DWORD           *pdwLengthRead,
            LPBYTE          pbValue
            )
{
    HRESULT         hrRes;
    FLAT_ADDRESS    faItemOffset;

    _ASSERT(IsInstanceInfoValid());
    _ASSERT(m_pBlockManager);
    _ASSERT(pvPropKey);
    _ASSERT(pdwLengthRead);
    _ASSERT(pItem);
    _ASSERT(pbValue);

    TraceFunctEnterEx((LPARAM)this, "CPropertyTable::GetPropertyItemAndValue");

    // First, find the property
    hrRes = SearchForProperty(pvPropKey, pItem, NULL, &faItemOffset);
    if (SUCCEEDED(hrRes))
    {
        // OK, the item is found. Since the offset and length fields could
        // have changed between SearchForProperty and now, we need a protected
        // call to make sure we read the most up to date info as well as no
        // other thread can change it while we are reading.
        hrRes = m_pBlockManager->AtomicDereferenceAndRead(
                            pbValue,
                            &dwLength,
                            (LPBYTE)pItem,
                            faItemOffset,
                            m_pInstanceInfo->dwItemSize,
                            offsetof(PROPERTY_ITEM, faOffset),
                            offsetof(PROPERTY_ITEM, dwSize),
                            NULL);

        *pdwLengthRead = dwLength;

        DebugTrace((LPARAM)this,
                    "AtomicDereferenceAndRead: offset %u, size %u, HRESULT = %08x",
                    (DWORD)pItem->faOffset, pItem->dwSize, hrRes);
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT CPropertyTable::GetPropertyItemAndValueUsingIndex(
            DWORD           dwIndex,
            LPPROPERTY_ITEM pItem,
            DWORD           dwLength,
            DWORD           *pdwLengthRead,
            LPBYTE          pbValue
            )
{
    HRESULT         hrRes;
    FLAT_ADDRESS    faItemOffset;

    _ASSERT(IsInstanceInfoValid());
    _ASSERT(m_pBlockManager);
    _ASSERT(pdwLengthRead);
    _ASSERT(pItem);
    _ASSERT(pbValue);

    // We've read nothing so far
    *pdwLengthRead = 0;

    TraceFunctEnterEx((LPARAM)this, "CPropertyTable::GetPropertyItemAndValueUsingIndex");

    CPropertyTableItem      ptiItem(m_pBlockManager, m_pInstanceInfo);

    // First, load the specified property
    hrRes = ptiItem.GetItemAtIndex(dwIndex, pItem, &faItemOffset);
    if (SUCCEEDED(hrRes))
    {
        // OK, the item is found. Since the offset and length fields could
        // have changed between SearchForProperty and now, we need a protected
        // call to make sure we read the most up to date info as well as no
        // other thread can change it while we are reading.
        hrRes = m_pBlockManager->AtomicDereferenceAndRead(
                            pbValue,
                            &dwLength,
                            (LPBYTE)pItem,
                            faItemOffset,
                            m_pInstanceInfo->dwItemSize,
                            offsetof(PROPERTY_ITEM, faOffset),
                            offsetof(PROPERTY_ITEM, dwSize),
                            NULL);

        // Set the length read if we succeeded
        if (SUCCEEDED(hrRes))
            *pdwLengthRead = pItem->dwSize;

        DebugTrace((LPARAM)this,
                    "AtomicDereferenceAndRead: offset %u, size %u, HRESULT = %08x",
                    (DWORD)pItem->faOffset, pItem->dwSize, hrRes);
    }

    TraceFunctLeave();
    return(hrRes);
}


HRESULT CPropertyTable::PutProperty(
            LPVOID          pvPropKey,
            LPPROPERTY_ITEM pItem,
            DWORD           dwSize,
            LPBYTE          pbValue
            )
{
    HRESULT         hrRes;
    FLAT_ADDRESS    faItemOffset;
    DWORD           dwIndex;
    BOOL            fGrow           = FALSE;
    BOOL            fCreate         = FALSE;
    MAX_PROPERTY_ITEM MaxItem;
    PROPERTY_ITEM   *pItemCopy  = (PROPERTY_ITEM *) &MaxItem;

    CBlockContext   bcContext;

    _ASSERT(IsInstanceInfoValid());
    _ASSERT(m_pBlockManager);
    _ASSERT(pvPropKey);
    _ASSERT(pItem);
    _ASSERT(fMaxPropertyItemSizeValid());
    // pbValue can be NULL

    TraceFunctEnterEx((LPARAM)this, "CPropertyTable::PutProperty");

    if (!pbValue && dwSize) 
    {
        hrRes = E_POINTER;
        goto Exit;
    }  

    //
    // OK, since the search will destroy the extra property info,
    // we must save it somewhere.   If the size is larger than our
    // max size, then we need to bail.
    //
    if (!fPropertyItemSizeValid(m_pInstanceInfo->dwItemSize))
    {
        FatalTrace((LPARAM) this, 
            "Message propety items size %d is invalid... assuming P1 corrupt",
            m_pInstanceInfo->dwItemSize);
        hrRes = HRESULT_FROM_WIN32(ERROR_FILE_CORRUPT);
        goto Exit;
    }

    MoveMemory((LPVOID)pItemCopy, (LPVOID)pItem, m_pInstanceInfo->dwItemSize);

    // First, see if the property exists
    hrRes = SearchForProperty(pvPropKey, pItem, &dwIndex, &faItemOffset);
    if (SUCCEEDED(hrRes))
    {
        // If we don't need to specify the value, we can skip this junk
        if (pbValue)
        {
            if (pItem->dwMaxSize >= dwSize)
            {
                // Best scenario: these's enough space for the new value
                DebugTrace((LPARAM)this,
                            "Replacing property %u at offset %u, %u bytes",
                            dwIndex, (DWORD)pItem->faOffset, dwSize);

                // Update pItem
                pItem->dwSize = dwSize;
            }
            else
            {
                // We must grow the property, then
                DebugTrace((LPARAM)this,
                            "Growing property %u at offset %u, from %u to %u bytes",
                            dwIndex, (DWORD)pItem->faOffset, pItem->dwSize, dwSize);
                fGrow = TRUE;
            }
        }
    }
    else
    {
        // See if the property is not found ...
        if (hrRes != STG_E_UNKNOWN)
        {
            // Nope, this is a genuine error!
            ErrorTrace((LPARAM)this,
                        "Error searching property: HRESULT = %08x", hrRes);
            goto Exit;
        }

        // Create a new property
        DebugTrace((LPARAM)this,
                    "Creating new property, %u bytes", dwSize);
        fCreate = TRUE;
    }

    // See if we need any new space ...
    if (pbValue)
    {
        if (fCreate || fGrow)
        {
            FLAT_ADDRESS    faOffset;
            DWORD           dwAllocSize;

            // Allocate some new memory
            DebugTrace((LPARAM)this, "Allocating %u bytes", dwSize);

            hrRes = m_pBlockManager->AllocateMemory(
                            dwSize,
                            &faOffset,
                            &dwAllocSize,
                            &bcContext);
            if (!SUCCEEDED(hrRes))
            {
                DebugTrace((LPARAM)this, "Allocating failed: HRESULT = %08x", hrRes);
                goto Exit;
            }

            // Update pItem
            pItem->faOffset = faOffset;
            pItem->dwSize = dwSize;
            pItem->dwMaxSize = dwAllocSize;
        }

        // Atomically write the value
        hrRes = m_pBlockManager->AtomicWriteAndIncrement(
                    pbValue,
                    pItem->faOffset,
                    pItem->dwSize,
                    NULL,
                    0,
                    0,
                    &bcContext);
    }

    if (SUCCEEDED(hrRes))
    {
        CPropertyTableItem  ptiItem(
                                m_pBlockManager,
                                m_pInstanceInfo);
        FLAT_ADDRESS faOffsetToItem;

        if (fCreate)
        {
            // Atomically create the record
            MoveMemory((LPVOID)pItemCopy, (LPVOID)pItem, sizeof(PROPERTY_ITEM));
            hrRes = ptiItem.AddItem(pItemCopy, &dwIndex, &faOffsetToItem);
            DebugTrace((LPARAM)this,
                    "AddItem: HRESULT = %08x, new index = %u", hrRes, dwIndex);
        }
        else
        {
            // Atomically update the item record
            hrRes = ptiItem.UpdateItem(dwIndex, pItem, &faOffsetToItem);
            DebugTrace((LPARAM)this,
                    "UpdateItem: HRESULT = %08x, index = %u", hrRes, dwIndex);
        }

        if (m_rgCachedProps && SUCCEEDED(hrRes)) {
            _ASSERT(faOffsetToItem != INVALID_FLAT_ADDRESS);
            UpdatePropCache(pItem, faOffsetToItem, dwIndex);
        }
    }

    if (SUCCEEDED(hrRes) && fCreate)
        hrRes = S_FALSE;

  Exit:
    TraceFunctLeave();
    return(hrRes);
}

int __cdecl CompareInternalProperties(const void *pElem1, const void *pElem2)
{
    if (((LPINTERNAL_PROPERTY_ITEM)pElem1)->idProp ==
        ((LPINTERNAL_PROPERTY_ITEM)pElem2)->idProp)
        return(0);
    else
    {
        if (((LPINTERNAL_PROPERTY_ITEM)pElem1)->idProp >
            ((LPINTERNAL_PROPERTY_ITEM)pElem2)->idProp)
            return(1);
    }
    return(-1);
}

//
// This function allocates and fills in m_rgCachedProps
//
void CPropertyTable::InitializePropCache() {
    TraceFunctEnterEx((LPARAM) this, "CPropertyTable::InitializePropCache");
    // it should only be called when there are properties to cache
    _ASSERT(m_cCachedProps);

    //
    //  Previously, this was a dynamic allocation based on
    //  the property stream read in.  However, we do not
    //  return an error in this function...  bailing without
    //  initializing the cache will cause the calling code to
    //  fall back on not using the cache.  A later check of
    //  the item size will return ERROR_FILE_CORRUPT
    //
    if (!fPropertyItemSizeValid(m_pInstanceInfo->dwItemSize))
    {
        _ASSERT(fMaxPropertyItemSizeValid());
        _ASSERT(0 && "Invalid property item size");
        FatalTrace((LPARAM) this, 
            "Message propety item size %d is invalid... assuming P1 corrupt",
            m_pInstanceInfo->dwItemSize);
        goto Exit;
    }

    // its okay if this allocation failed.  in that case we won't have
    // the m_rgCachedProps array and will do linear lookups
    if (FAILED(CMemoryAccess::AllocBlock((void **) &m_rgCachedProps, 
                                         sizeof(PROPCACHEITEM) * m_cCachedProps)))
    {
        m_rgCachedProps = NULL;
    } else {
        InterlockedIncrement(&g_cCPropertyTableCreations);

        // invalidate all items in the cache
        for (DWORD i = 0; i < m_cCachedProps; i++) {
            m_rgCachedProps[i].fa = INVALID_FLAT_ADDRESS;
        }

        // update the cache from what is already in the table
        FLAT_ADDRESS fa;
        DWORD dwCurrentItem = 0;
        MAX_PROPERTY_ITEM MaxItem;
        PROPERTY_ITEM *pItem = (PROPERTY_ITEM *) &MaxItem;

        CPropertyTableItem ptiItem(m_pBlockManager, m_pInstanceInfo);
        HRESULT hrRes = ptiItem.GetItemAtIndex(dwCurrentItem, pItem, &fa);
        while (SUCCEEDED(hrRes))
        {
            // put every item that we come across into the cache
            UpdatePropCache(pItem, fa, dwCurrentItem);

            // Get the next one. We can do this because the item object
            // is single-threaded
            hrRes = ptiItem.GetNextItem(pItem);
            if (SUCCEEDED(hrRes)) ptiItem.GetOffsetToCurrentItem(&fa);
            dwCurrentItem++;
        }
        _ASSERT(hrRes == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
    }

  Exit:
    TraceFunctLeave();
}

//
// set an item in the property cache.  to invalidate an item pass in
// INVALID_FLAT_ADDRESS for fa.
//
void CPropertyTable::UpdatePropCache(LPPROPERTY_ITEM pItem,
                                     FLAT_ADDRESS fa,
                                     DWORD dwIndex) 
{
    TraceFunctEnter("CPropertyTable::UpdatePropCache");
    
    int iCachedProp;
    if (m_dwValidInstanceSignature == GLOBAL_PTABLE_INSTANCE_SIGNATURE_VALID) {
        GLOBAL_PROPERTY_ITEM *pGlobalItem = (GLOBAL_PROPERTY_ITEM *) pItem;
        iCachedProp = MapCachedProp(pGlobalItem->idProp);
    } else {
        iCachedProp = -1;
    }
    if (iCachedProp != -1) {
        DebugTrace((LPARAM) this, 
            "iCachedProp = 0x%x  fa = 0x%x  dwIndex = 0x%x m_rgCachedProps = 0x%x",
            iCachedProp, fa, dwIndex, m_rgCachedProps);
        m_rgCachedProps[iCachedProp].fa = fa;
        m_rgCachedProps[iCachedProp].dwIndex = dwIndex;
    }

    TraceFunctLeave();
}

HRESULT CPropertyTable::SearchForProperty(
            LPVOID          pvPropKey,
            LPPROPERTY_ITEM pItem,
            DWORD           *pdwIndexToItem,
            FLAT_ADDRESS    *pfaOffsetToItem
            )
{
    HRESULT hrRes           = S_OK;
    DWORD   dwCurrentItem   = 0;
    PROP_ID idProp;

    InterlockedIncrement(&g_cCPropertyTableSearchs);

    _ASSERT(IsInstanceInfoValid());
    _ASSERT(m_pBlockManager);
    _ASSERT(m_pfnCompare);
    _ASSERT(pvPropKey);
    _ASSERT(pItem);

    TraceFunctEnter("CPropertyTable::SearchForProperty");

    // Create an instance of the item object
    CPropertyTableItem  ptiItem(
                            m_pBlockManager,
                            m_pInstanceInfo);

    idProp = *(PROP_ID *) pvPropKey;

    // First, search the well-known properties
    if (m_dwInternalProperties &&
        m_dwTableType == PTT_PROPERTY_TABLE)
    {
        LPINTERNAL_PROPERTY_ITEM    pInternalItem = NULL;
        INTERNAL_PROPERTY_ITEM      KeyItem;

        // Bsearch
        KeyItem.idProp = idProp;
        pInternalItem = (LPINTERNAL_PROPERTY_ITEM)bsearch(
                                &KeyItem,
                                m_pInternalProperties,
                                m_dwInternalProperties,
                                sizeof(INTERNAL_PROPERTY_ITEM),
                                CompareInternalProperties);

        if (pInternalItem)
        {
            hrRes = ptiItem.GetItemAtIndex(pInternalItem->dwIndex, pItem);
            ptiItem.GetOffsetToCurrentItem(pfaOffsetToItem);
            if (pdwIndexToItem)
                *pdwIndexToItem = pInternalItem->dwIndex;
            return(hrRes);
        }

        // This is not a well-known property
        dwCurrentItem = m_dwInternalProperties;
    }

    DebugTrace((LPARAM)this, "Scanning Property table");

    //
    // see if its in the property cache
    //

    // get an index into the cache array
    int iCachedProp = MapCachedProp(idProp);

    // we lazily initialize the property cache the first time that we need it
    if (iCachedProp != -1 && !m_rgCachedProps) InitializePropCache();

    // if the cache is initialize and this should be in the case then
    // search for it
    if (iCachedProp != -1 && m_rgCachedProps) {
        // see if this cache item is valid, and verify that it points to
        // the item that the user wanted
        if ((pItem != NULL) &&
            (m_rgCachedProps[iCachedProp].fa != INVALID_FLAT_ADDRESS) &&
            SUCCEEDED(ptiItem.ReadItem(m_rgCachedProps[iCachedProp].fa, pItem)) &&
            SUCCEEDED(m_pfnCompare(pvPropKey, pItem))) 
        {
            // we've got a winner!
            *pfaOffsetToItem = m_rgCachedProps[iCachedProp].fa;
            if (pdwIndexToItem)
                *pdwIndexToItem = m_rgCachedProps[iCachedProp].dwIndex;
            return S_OK;
        }
    } else if (iCachedProp != -1) {
        // this case can be hit if we couldn't allocate memory for the
        // property cache.  we just need to set iCachedProp back to -1
        // so that we do a linear search
        iCachedProp = -1;
    }
    hrRes = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);

    //
    // Linear Search    
    //

#ifdef DEBUG
    //
    // In debug builds we do the linear search if we couldn't find it
    // in the cache.  we then make sure that the linear search failed
    // as well.
    //
    if (1) {
#else
    //
    // in retail builds we only do this when the data wasn't in the cache
    //
    if (iCachedProp == -1) {
#endif
        // Linear search
        FLAT_ADDRESS fa;
        MAX_PROPERTY_ITEM MaxItem;

        // we don't want to walk with pItem because if we don't find the
        // item then we will trash whatever the user had placed in pItem
        PROPERTY_ITEM *pThisItem = NULL;

        //
        //  Sanity check size of property item (firewall corrupt messages)
        //
        if (!fPropertyItemSizeValid(m_pInstanceInfo->dwItemSize))
        {
            hrRes = HRESULT_FROM_WIN32(ERROR_FILE_CORRUPT);
            FatalTrace((LPARAM) this, 
                    "Property Items size %d to large... message corrupt", 
                    m_pInstanceInfo->dwItemSize);
        }
        else 
        {

            pThisItem = (PROPERTY_ITEM *) &MaxItem;

            hrRes = ptiItem.GetItemAtIndex(dwCurrentItem, pThisItem, &fa);
            while (SUCCEEDED(hrRes))
            {
                // Call the user-supplied compare function
                hrRes = m_pfnCompare(pvPropKey, pThisItem);
                if (SUCCEEDED(hrRes))
                    break;

                // Get the next one. We can do this because the item object
                // is single-threaded
                hrRes = ptiItem.GetNextItem(pThisItem);
                dwCurrentItem++;
            }
        }
#ifdef DEBUG
        // if the item was found here, but not found in the cache,
        // then there is an inconsistency that needs to be debugged.
        if (iCachedProp != -1 && SUCCEEDED(hrRes)) {
            DebugTrace(0, "iCachedProp = %i", iCachedProp);
            _ASSERT(FALSE);
            // we dont' want debug builds to behave differently then
            // retail builds, so force it to fail
            hrRes = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        }
#endif

        // if we found the item then copy it from pThisItem to pItem
        if (SUCCEEDED(hrRes)) {
            memcpy(pItem, pThisItem, m_pInstanceInfo->dwItemSize);
        }
    }

    // OKay, if we have no more items, then we cannot find the item,
    // otherwise, we let the error code percolate up
    if (!SUCCEEDED(hrRes) &&
        hrRes == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
    {
        // Property not found
        hrRes = STG_E_UNKNOWN;
    }
    else
    {
        // Fill in the offset
        ptiItem.GetOffsetToCurrentItem(pfaOffsetToItem);
        if (pdwIndexToItem)
            *pdwIndexToItem = dwCurrentItem;
    }
        
    TraceFunctLeave();
    return(hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\blockmgr\blockmgr.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

        blockmgr.cpp

Abstract:

        This module contains the implementation of the block memory manager

Author:

        Keith Lau       (keithlau@microsoft.com)

Revision History:

        keithlau        02/27/98        created

--*/

#include "windows.h"

#include "dbgtrace.h"

#include "filehc.h"
#include "signatur.h"
#include "blockmgr.h"

//
// I really wanted to keep the memory manager completely independent from
// the rest of the stuff, but I realized it makes more sense to have the
// memory manager be aware of the IMailMsgPropertyStream so hrer goes ...
//
// If you remove CommitDirtyBlocks, you can get rid of the include below.
//
#include "mailmsg.h"

//
// A commit writes the entire stream, but possibly using several iterations.
// This specifies how many blocks to write in each iteration.
//
#define CMAILMSG_COMMIT_PAGE_BLOCK_SIZE			256

// Global (set by registry key) indicating that property pages be filled with
// a byte pattern after allocation
extern DWORD g_fFillPropertyPages;

/***************************************************************************/
// Debug stuff
//
#ifndef _ASSERT
#define _ASSERT(x)		if (!(x)) DebugBreak()
#endif

#ifdef DEBUG_TRACK_ALLOCATION_BOUNDARIES

HRESULT SetAllocationBoundary(
			FLAT_ADDRESS		faOffset,
			LPBLOCK_HEAP_NODE	pNode
			)
{
	DWORD	dwBit;

	faOffset &= BLOCK_HEAP_PAYLOAD_MASK;
	faOffset >>= 2;
	dwBit = (DWORD)(faOffset & 7);
	faOffset >>= 3;
	pNode->stAttributes.rgbBoundaries[faOffset] |= (0x80 >> dwBit);
	return(S_OK);
}

HRESULT VerifyAllocationBoundary(
			FLAT_ADDRESS		faOffset,
			DWORD				dwLength,
			LPBLOCK_HEAP_NODE	pNode
			)
{
	DWORD		dwStartingBit;
	DWORD		dwStartingByte;
	DWORD		dwBitsToScan;

	// 7f because we can start on a boundary and be perfectly cool
	BYTE		bStartingMask = 0x7f;
	BYTE		bEndingMask   = 0xff;

	faOffset &= BLOCK_HEAP_PAYLOAD_MASK;
	faOffset >>= 2;		// DWORD per bit

	// Determine the start
	// note : these casts are safe because the value in faOffset is
	// only 10-bits (BLOCK_HEAP_PAYLOAD_MASK) at this point.
	dwStartingBit = (DWORD)(faOffset & 7);
	dwStartingByte = (DWORD)(faOffset >> 3);
	bStartingMask >>= dwStartingBit;

	// Determine the number of bits to scan, each bit corresponds
	// to a DWORD, rounded up to next DWORD
	dwBitsToScan = dwLength + 3;
	dwBitsToScan >>= 2;

	// Scan it
	// Case 1: Start and End bits within the same byte
	if ((dwStartingBit + dwBitsToScan) <= 8)
	{
		DWORD	dwBitsFromRight = 8 - (dwStartingBit + dwBitsToScan);
		bEndingMask <<= dwBitsFromRight;

		bStartingMask = bStartingMask & bEndingMask;

		if (pNode->stAttributes.rgbBoundaries[dwStartingByte] & bStartingMask)
			return(TYPE_E_OUTOFBOUNDS);
	}
	else
	// Case 2: Multiple bytes
	{
		if (pNode->stAttributes.rgbBoundaries[dwStartingByte++] & bStartingMask)
			return(TYPE_E_OUTOFBOUNDS);

		dwBitsToScan -= (8 - dwStartingBit);
		while (dwBitsToScan >= 8)
		{
			// See if we cross any boundaries
			if (dwBitsToScan >= 32)
			{
				if (*(UNALIGNED DWORD *)(pNode->stAttributes.rgbBoundaries + dwStartingByte) != 0)
					return(TYPE_E_OUTOFBOUNDS);
				dwStartingByte += 4;
				dwBitsToScan -= 32;
			}
			else if (dwBitsToScan >= 16)
			{
				if (*(UNALIGNED WORD *)(pNode->stAttributes.rgbBoundaries + dwStartingByte) != 0)
					return(TYPE_E_OUTOFBOUNDS);
				dwStartingByte += 2;
				dwBitsToScan -= 16;
			}
			else
			{
				if (pNode->stAttributes.rgbBoundaries[dwStartingByte++] != 0)
					return(TYPE_E_OUTOFBOUNDS);
				dwBitsToScan -= 8;
			}
		}

		// Final byte
		if (dwBitsToScan)
		{
			bEndingMask <<= (8 - dwBitsToScan);
			if (pNode->stAttributes.rgbBoundaries[dwStartingByte] & bEndingMask)
				return(TYPE_E_OUTOFBOUNDS);
		}
	}
	return(S_OK);
}

#endif


/***************************************************************************/
// Memory accessor class
//
CPool CBlockMemoryAccess::m_Pool((DWORD)'pBMv');

HRESULT CBlockMemoryAccess::AllocBlock(
			LPVOID	*ppvBlock,
			DWORD	dwBlockSize
			)
{
	TraceFunctEnterEx((LPARAM)this, "CBlockMemoryAccess::AllocBlock");

    _ASSERT(dwBlockSize == BLOCK_HEAP_NODE_SIZE);

	LPVOID pvBlock = m_Pool.Alloc();
    if (pvBlock) {
        ((LPBLOCK_HEAP_NODE) pvBlock)->stAttributes.fFlags = 0;
    } else if (SUCCEEDED(CMemoryAccess::AllocBlock(ppvBlock, BLOCK_HEAP_NODE_SIZE)))
    {
        pvBlock = *ppvBlock;
        ((LPBLOCK_HEAP_NODE) pvBlock)->stAttributes.fFlags = BLOCK_NOT_CPOOLED;
    }

	if (pvBlock)
	{
		ZeroMemory(((LPBLOCK_HEAP_NODE)pvBlock)->rgpChildren, sizeof(LPBLOCK_HEAP_NODE) * BLOCK_HEAP_ORDER);

#ifdef DEBUG_TRACK_ALLOCATION_BOUNDARIES
        ZeroMemory(((LPBLOCK_HEAP_NODE)pvBlock)->stAttributes.rgbBoundaries, BLOCK_HEAP_PAYLOAD >> 5);
#endif

        // If debugging registry key is set, init the payload to a byte pattern of '????'
        if(g_fFillPropertyPages)
        {
            FillMemory(((LPBLOCK_HEAP_NODE)pvBlock)->rgbData,
                sizeof(((LPBLOCK_HEAP_NODE)pvBlock)->rgbData), 0x3F);
        }

		*ppvBlock = pvBlock;
        TraceFunctLeaveEx((LPARAM) this);
		return(S_OK);
    }

	*ppvBlock = NULL;
	ErrorTrace((LPARAM)this, "CBlockMemoryAccess::AllocBlock failed");

	TraceFunctLeaveEx((LPARAM)this);
	return(E_OUTOFMEMORY);
}

HRESULT CBlockMemoryAccess::FreeBlock(
			LPVOID	pvBlock
			)
{
	TraceFunctEnterEx((LPARAM)this, "CBlockMemoryAccess::FreeBlock");

    if ((((LPBLOCK_HEAP_NODE) pvBlock)->stAttributes.fFlags) &
        BLOCK_NOT_CPOOLED)
    {
        CMemoryAccess::FreeBlock(pvBlock);
    } else {
    	m_Pool.Free(pvBlock);
    }
	return(S_OK);
}


HRESULT CMemoryAccess::AllocBlock(
			LPVOID	*ppvBlock,
			DWORD	dwBlockSize
			)
{
	TraceFunctEnterEx(0, "CMemoryAccess::AllocBlock");

	LPVOID pvBlock = (LPVOID) new BYTE[dwBlockSize];
	if (pvBlock)
	{
		ZeroMemory(pvBlock, dwBlockSize);
		*ppvBlock = pvBlock;
		return(S_OK);
	}

	*ppvBlock = NULL;

	return(E_OUTOFMEMORY);
}

HRESULT CMemoryAccess::FreeBlock(
			LPVOID	pvBlock
			)
{
	TraceFunctEnterEx(0, "CMemoryAccess::FreeBlock");

    delete[] pvBlock;
    TraceFunctLeave();
    return S_OK;
}


/***************************************************************************/
// CBlockContext implementation
//

BOOL CBlockContext::IsValid()
{
	return((m_dwSignature == BLOCK_CONTEXT_SIGNATURE_VALID));
}

void CBlockContext::Set(
			LPBLOCK_HEAP_NODE	pLastAccessedNode,
			FLAT_ADDRESS		faLastAccessedNodeOffset
			)
{
	m_pLastAccessedNode = pLastAccessedNode;
	m_faLastAccessedNodeOffset = faLastAccessedNodeOffset;
	m_dwSignature = BLOCK_CONTEXT_SIGNATURE_VALID;
}

void CBlockContext::Invalidate()
{
	m_dwSignature = BLOCK_CONTEXT_SIGNATURE_INVALID;
}


/***************************************************************************/
// CBlockManager implementation
//

CBlockManager::CBlockManager(
			IMailMsgProperties		*pMsg,
			CBlockManagerGetStream	*pParent
			)
{
	TraceFunctEnterEx((LPARAM)this, "CBlockManager::CBlockManager");

	// Initialize
	m_dwSignature = BLOCK_HEAP_SIGNATURE_VALID;
	m_pRootNode = NULL;
	m_faEndOfData = 0;
	m_idNodeCount = 0;
	m_pParent = pParent;
	m_pMsg = pMsg;
	SetDirty(FALSE);
#ifdef DEBUG
    m_fCommitting = FALSE;
#endif

	TraceFunctLeaveEx((LPARAM)this);
}


CBlockManager::~CBlockManager()
{
	TraceFunctEnterEx((LPARAM)this, "CBlockManager::~CBlockManager");

	// Releases all blocks
	Release();

	// Finally, invalidate signature
	m_dwSignature = BLOCK_HEAP_SIGNATURE_INVALID;

	TraceFunctLeaveEx((LPARAM)this);
}

HRESULT CBlockManager::SetStreamSize(
			DWORD	dwStreamSize
			)
{
	// Initialize the stream size, this is only used when binding a
	// fresh MailMsg object to an existing stream.
	m_faEndOfData = (FLAT_ADDRESS)dwStreamSize;
	m_idNodeCount = ((dwStreamSize + BLOCK_HEAP_PAYLOAD_MASK) >> BLOCK_HEAP_PAYLOAD_BITS);
	return(S_OK);
}

BOOL CBlockManager::IsValid()
{
	return(m_dwSignature == BLOCK_HEAP_SIGNATURE_VALID);
}

HRESULT CBlockManager::GetStream(
			IMailMsgPropertyStream	**ppStream,
			BOOL					fLockAcquired
			)
{
	_ASSERT(ppStream);
	if (!ppStream || !m_pParent)
		return(E_POINTER);

	HRESULT hrRes = m_pParent->GetStream(ppStream, fLockAcquired);
	return(hrRes);
}

HRESULT CBlockManager::MoveToNode(
				LPBLOCK_HEAP_NODE	*ppNode,
				HEAP_NODE_ID		idTargetNode,
				BOOL				fLockAcquired
				)
{
	HRESULT				hrRes = S_OK;
	LPBLOCK_HEAP_NODE	pNode;
	HEAP_NODE_ID		idNode;

	if (!ppNode || !*ppNode)
		return(E_POINTER);

	if (idTargetNode >= m_idNodeCount)
		return(STG_E_INVALIDPARAMETER);

	pNode = *ppNode;
	idNode = pNode->stAttributes.idNode;

	// Jump if in the same parent node
	if (idNode && idTargetNode)
	{
		if (((idNode - 1) >> BLOCK_HEAP_ORDER_BITS) ==
			((idTargetNode - 1) >> BLOCK_HEAP_ORDER_BITS))
		{
			HEAP_NODE_ID		idChildNode = (idTargetNode - 1) & BLOCK_HEAP_ORDER_MASK;
			LPBLOCK_HEAP_NODE	pParent 	= pNode->stAttributes.pParentNode;

			*ppNode = pParent->rgpChildren[idChildNode];
			if (!*ppNode)
				hrRes = LoadBlockIfUnavailable(
							idTargetNode,
							pParent,
							idChildNode,
							ppNode,
							fLockAcquired);
			return(hrRes);
		}
	}
	hrRes = GetNodeFromNodeId(
					idTargetNode,
					ppNode,
					fLockAcquired);
	return(hrRes);
}

HRESULT CBlockManager::GetNextNode(
				LPBLOCK_HEAP_NODE	*ppNode,
				BOOL				fLockAcquired
				)
{
	if (!ppNode || !*ppNode)
		return(E_POINTER);

	HRESULT hrRes = MoveToNode(
				ppNode,
				(*ppNode)->stAttributes.idNode + 1,
				fLockAcquired);
	if (FAILED(hrRes))
		*ppNode = NULL;
	return(hrRes);
}

HRESULT CBlockManager::LoadBlockIfUnavailable(
				HEAP_NODE_ID		idNode,
				LPBLOCK_HEAP_NODE	pParent,
				HEAP_NODE_ID		idChildNode,
				LPBLOCK_HEAP_NODE	*ppNode,
				BOOL				fLockAcquired
				)
{
	_ASSERT(ppNode);

	if (*ppNode)
		return(S_OK);

	HRESULT	hrRes = S_OK;
	IMailMsgPropertyStream	*pStream;

	hrRes = GetStream(&pStream, fLockAcquired);
	if (!SUCCEEDED(hrRes))
		return(E_UNEXPECTED);

	// Calculate the stream offset and load the block

	// idNode shifted really contains an offset not a full pointer here so we
	// can (and must) cast it for the call to ReadBlocks to be OK
	DWORD	dwOffset = (DWORD)(idNode << BLOCK_HEAP_PAYLOAD_BITS);

	if (!fLockAcquired)
		WriteLock();

	if (!*ppNode)
	{
		LPBLOCK_HEAP_NODE	pNode = NULL;
		DWORD				dwLength = BLOCK_HEAP_PAYLOAD;

		hrRes = m_bma.AllocBlock(
					(LPVOID *)&pNode,
					BLOCK_HEAP_NODE_SIZE);
		if (SUCCEEDED(hrRes))
		{
			LPBYTE	pTemp = pNode->rgbData;
			hrRes = pStream->ReadBlocks(
						m_pMsg,
						1,
						&dwOffset,
						&dwLength,
						&pTemp,
						NULL);

			if (FAILED(hrRes) &&
				(hrRes != HRESULT_FROM_WIN32(ERROR_HANDLE_EOF)))
			{
				HRESULT	myRes = m_bma.FreeBlock(pNode);
				_ASSERT(SUCCEEDED(myRes));
			}
			else
			{
				if (pParent)
					pParent->rgpChildren[idChildNode] = pNode;
				pNode->stAttributes.pParentNode = pParent;
                RESET_BLOCK_FLAGS(pNode->stAttributes.fFlags);
				pNode->stAttributes.idChildNode = idChildNode;
				pNode->stAttributes.idNode = idNode;
				pNode->stAttributes.faOffset = dwOffset;
				*ppNode = pNode;
				hrRes = S_OK;
			}
		}
	}

	if (!fLockAcquired)
		WriteUnlock();

	return(hrRes);
}

inline HRESULT CBlockManager::GetEdgeListFromNodeId(
			HEAP_NODE_ID		idNode,
			HEAP_NODE_ID		*rgEdgeList,
			DWORD				*pdwEdgeCount
			)
{
	DWORD			dwCurrentLevel;
	HEAP_NODE_ID	*pEdge = rgEdgeList;

	// This is a strictly internal call, we are assuming the caller
	// will be optimized and will handle cases for idNode <=
	// BLOCK_HEAP_ORDER. Processing only starts for 2 layers or more
	// Debug: make sure we are within range
	_ASSERT(idNode > BLOCK_HEAP_ORDER);
	_ASSERT(idNode <= NODE_ID_ABSOLUTE_MAX);

	// Strip off the root node
	idNode--;

	// We need to do depth minus 1 loops since the top edge will be
	// the remainder of the final loop
	for (dwCurrentLevel = 0;
		 dwCurrentLevel < (MAX_HEAP_DEPTH - 1);
		 )
	{
		// The quotient is the parent node in the upper level,
		// the remainder is the the edge from the parent to the
		// current node.
		*pEdge++ = idNode & BLOCK_HEAP_ORDER_MASK;
		idNode >>= BLOCK_HEAP_ORDER_BITS;
		idNode--;
		dwCurrentLevel++;

		// If the node is less than the number of children per node,
		// we are done.
		if (idNode < BLOCK_HEAP_ORDER)
			break;
	}
	*pEdge++ = idNode;
	*pdwEdgeCount = dwCurrentLevel + 1;
	return(S_OK);
}

//
// Inner-loop optimized for O(1) cost.
//
HRESULT CBlockManager::GetNodeFromNodeId(
			HEAP_NODE_ID		idNode,
			LPBLOCK_HEAP_NODE	*ppNode,
			BOOL				fLockAcquired
			)
{
	HRESULT hrRes = S_OK;

	_ASSERT(IsValid());
	_ASSERT(ppNode);

	// If top level node, we return immediately. Note this is
	// supposed to be the case 90% of the time
	hrRes = LoadBlockIfUnavailable(0, NULL, 0, &m_pRootNode, fLockAcquired);
	if (!idNode || FAILED(hrRes))
	{
		*ppNode = m_pRootNode;
		return(hrRes);
	}

	LPBLOCK_HEAP_NODE	pNode	= m_pRootNode;
	LPBLOCK_HEAP_NODE	*ppMyNode = &m_pRootNode;

	// Now, see if the referenced node exists
	if (idNode >= m_idNodeCount)
		return(STG_E_INVALIDPARAMETER);

	// Optimize for 1 hop, we would scarcely have to go into
	// the else case ...
	if (idNode <= BLOCK_HEAP_ORDER)
	{
		ppMyNode = &(m_pRootNode->rgpChildren[idNode - 1]);
		hrRes = LoadBlockIfUnavailable(idNode, m_pRootNode, idNode - 1, ppMyNode, fLockAcquired);
		if (SUCCEEDED(hrRes))
			*ppNode = *ppMyNode;
	}
	else
	{
		HEAP_NODE_ID		rgEdgeList[MAX_HEAP_DEPTH];
		DWORD				dwEdgeCount;
		HEAP_NODE_ID		CurrentEdge;
		HEAP_NODE_ID		idFactor = 0;

		// Debug: make sure we are within range
		_ASSERT(idNode <= NODE_ID_ABSOLUTE_MAX);

		// Get the edge list, backwards
		GetEdgeListFromNodeId(idNode, rgEdgeList, &dwEdgeCount);
		_ASSERT(dwEdgeCount >= 2);

		// Walk the list backwards
		while (dwEdgeCount--)
		{
			// Find the next bucket and calculate the node ID
			CurrentEdge = rgEdgeList[dwEdgeCount];
			ppMyNode = &(pNode->rgpChildren[CurrentEdge]);
			idFactor <<= BLOCK_HEAP_ORDER_BITS;
			idFactor += (CurrentEdge + 1);

			hrRes = LoadBlockIfUnavailable(idFactor, pNode, CurrentEdge, ppMyNode, fLockAcquired);
			if (FAILED(hrRes))
				break;

			// Set the current node to the bucket in the layer below
			pNode = *ppMyNode;
		}

		// Fill in the results ...
		*ppNode = pNode;
	}

	return(hrRes);
}

//
// Identical optimizations as GetNodeFromNodeId, O(1) cost.
//
HRESULT CBlockManager::GetParentNodeFromNodeId(
			HEAP_NODE_ID		idNode,
			LPBLOCK_HEAP_NODE	*ppNode
			)
{
	HRESULT	hrRes = S_OK;

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::GetParentNodeFromNodeId");

	_ASSERT(IsValid());
	_ASSERT(ppNode);

	// The root node has no parent, this should be avoided
	// before calling this function, be we will fail gracefully
	if (!idNode)
	{
		_ASSERT(idNode != 0);
		*ppNode = NULL;
		return(STG_E_INVALIDPARAMETER);
	}

	// Note m_pRootNode can be NULL if idNode is zero!
	_ASSERT(m_pRootNode);

	LPBLOCK_HEAP_NODE	pNode	= m_pRootNode;
	LPBLOCK_HEAP_NODE	*ppMyNode = &m_pRootNode;

	// Optimize for 1 hop, we would scarcely have to go into
	// the else case ...
	if (idNode > BLOCK_HEAP_ORDER)
	{
		HEAP_NODE_ID		rgEdgeList[MAX_HEAP_DEPTH];
		DWORD				dwEdgeCount;
		HEAP_NODE_ID		CurrentEdge;
		HEAP_NODE_ID		idFactor = 0;

		// Debug: make sure we are within range
		_ASSERT(idNode <= NODE_ID_ABSOLUTE_MAX);

		// Get the edge list, backwards
		GetEdgeListFromNodeId(idNode, rgEdgeList, &dwEdgeCount);
		_ASSERT(dwEdgeCount >= 2);

		// Walk the list backwards
		--dwEdgeCount;
		while (dwEdgeCount)
		{
			// Find the next bucket and calculate the node ID
			CurrentEdge = rgEdgeList[dwEdgeCount];
			ppMyNode = &(pNode->rgpChildren[CurrentEdge]);
			idFactor <<= BLOCK_HEAP_ORDER_BITS;
			idFactor += (CurrentEdge + 1);

			hrRes = LoadBlockIfUnavailable(idFactor, pNode, CurrentEdge, ppMyNode, TRUE);
			if (FAILED(hrRes))
				break;

			// Set the current node to the bucket in the layer below
			pNode = *ppMyNode;

			dwEdgeCount--;
		}
	}

	// Fill in the results ...
	*ppNode = *ppMyNode;
	TraceFunctLeaveEx((LPARAM)this);
	return(hrRes);
}

#define GetNodeIdFromOffset(faOffset)	((faOffset) >> BLOCK_HEAP_PAYLOAD_BITS)

HRESULT CBlockManager::InsertNodeGivenPreviousNode(
			LPBLOCK_HEAP_NODE	pNodeToInsert,
			LPBLOCK_HEAP_NODE	pPreviousNode
			)
{
	HRESULT		hrRes = S_OK;

	_ASSERT(IsValid());

	_ASSERT(pNodeToInsert);

	LPBLOCK_HEAP_NODE_ATTRIBUTES	pAttrib		= &pNodeToInsert->stAttributes;

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::InsertNodeGivenPreviousNode");

	if (!pPreviousNode)
	{
		// This is the root node ...
		DebugTrace((LPARAM)this, "Inserting the root node");

		pAttrib->pParentNode = NULL;
		pAttrib->idChildNode = 0;
		pAttrib->idNode = 0;
		pAttrib->faOffset = 0;
        DEFAULT_BLOCK_FLAGS(pAttrib->fFlags);

		m_pRootNode = pNodeToInsert;

		TraceFunctLeaveEx((LPARAM)this);
		return(S_OK);
	}
	else
	{
		LPBLOCK_HEAP_NODE_ATTRIBUTES	pOldAttrib	= &pPreviousNode->stAttributes;

		// Fill out the attributes for the new node, we have a special case for the first node
		// after the root, where we need to explicitly point its parent to the root node
		if (pOldAttrib->idNode == 0)
		{
			pAttrib->pParentNode = m_pRootNode;

			// We are child Id 0 again
			pAttrib->idChildNode = 0;
		}
		else
		{
			pAttrib->pParentNode = pOldAttrib->pParentNode;
			pAttrib->idChildNode = pOldAttrib->idChildNode + 1;
		}
		pAttrib->idNode = pOldAttrib->idNode + 1;
		pAttrib->faOffset = pOldAttrib->faOffset + BLOCK_HEAP_PAYLOAD;
        DEFAULT_BLOCK_FLAGS(pAttrib->fFlags);

		if (pOldAttrib->idChildNode < BLOCK_HEAP_ORDER_MASK)
		{
			// We are in the same parent node, so it's simple
			DebugTrace((LPARAM)this, "Inserting node at slot %u",
					pAttrib->idChildNode);

			pAttrib->pParentNode->rgpChildren[pAttrib->idChildNode] = pNodeToInsert;

			TraceFunctLeaveEx((LPARAM)this);
			return(S_OK);
		}
	}

	// The previous node and the new node have different parents,
	// so we got to work from scratch ...
	LPBLOCK_HEAP_NODE	pNode = NULL;

	// We might as well search from the top ...
	hrRes = GetParentNodeFromNodeId(pAttrib->idNode, &pNode);
	if (SUCCEEDED(hrRes))
	{
		// Update the affected attributes
		DebugTrace((LPARAM)this, "Inserting node at slot 0");

		pAttrib->pParentNode = pNode;
		pAttrib->idChildNode = 0;

		// Hook up our parent
		pNode->rgpChildren[0] = pNodeToInsert;
	}
	else
	{
		// The only reason for failre is that the parent
		// of the requested parent is not allocated
		_ASSERT(hrRes == STG_E_INVALIDPARAMETER);
	}

	TraceFunctLeaveEx((LPARAM)this);
	return(hrRes);
}

HRESULT CBlockManager::GetAllocatedSize(
			FLAT_ADDRESS	*pfaSizeAllocated
			)
{
	HRESULT	hrRes	= S_OK;

	_ASSERT(IsValid());
	_ASSERT(pfaSizeAllocated);

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::GetAllocatedSize");

	if (!pfaSizeAllocated)
		hrRes = STG_E_INVALIDPARAMETER;
	else
		*pfaSizeAllocated = AtomicAdd(&m_faEndOfData, 0);

	TraceFunctLeaveEx((LPARAM)this);
	return(hrRes);
}

HRESULT CBlockManager::AllocateMemory(
			DWORD				dwSizeDesired,
			FLAT_ADDRESS		*pfaOffsetToAllocatedMemory,
			DWORD				*pdwSizeAllocated,
			CBlockContext		*pContext	// Optional
			)
{
	HRESULT			hrRes					= S_OK;

	_ASSERT(IsValid());
	_ASSERT(pfaOffsetToAllocatedMemory);
	_ASSERT(pdwSizeAllocated);

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::AllocateMemory");

	hrRes = AllocateMemoryEx(
					TRUE,
					dwSizeDesired,
					pfaOffsetToAllocatedMemory,
					pdwSizeAllocated,
					pContext);

	TraceFunctLeaveEx((LPARAM)this);
	return (hrRes);
}

HRESULT CBlockManager::AllocateMemoryEx(
			BOOL				fAcquireLock,
			DWORD				dwSizeDesired,
			FLAT_ADDRESS		*pfaOffsetToAllocatedMemory,
			DWORD				*pdwSizeAllocated,
			CBlockContext		*pContext	// Optional
			)
{
	DWORD			dwSize;
	FLAT_ADDRESS	faOffset;
	FLAT_ADDRESS	faStartOfBlock;
	HEAP_NODE_ID	idNode;
	HEAP_NODE_ID	idCurrentNode			= 0;
	HEAP_NODE_ID	idLastNodeToCreate		= 0;
	HRESULT			hrRes					= S_OK;
	BOOL			fMarkStart				= FALSE;

	LPBLOCK_HEAP_NODE	pNode				= NULL;

	_ASSERT(IsValid());
	_ASSERT(pfaOffsetToAllocatedMemory);
	_ASSERT(pdwSizeAllocated);

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::AllocateMemoryEx");

	// First of all, we do an atomic reservation of the memory
	// which allows multiple threads to concurrently call
	// AllocateMemory
	// DWORD-align the allocation
	dwSizeDesired += BLOCK_DWORD_ALIGN_MASK;
	dwSizeDesired &= ~(BLOCK_DWORD_ALIGN_MASK);
	faStartOfBlock = AtomicAdd(&m_faEndOfData, dwSizeDesired);

	// Fill this in first so if we succeed, we won't have to fill
	// this in everywhere and if this fails, it's no big deal.
	*pdwSizeAllocated = dwSizeDesired;

	DebugTrace((LPARAM)this, "Allocating %u bytes", dwSizeDesired);

	// OK, we have two scenarios.
	// 1) The current block is large enough to honor the request
	// 2) We need one or more extra blocks to accomodate the
	// request.
	idNode = GetNodeIdFromOffset(faStartOfBlock);

	// Calculate all the required parameters
	faOffset = faStartOfBlock & BLOCK_HEAP_PAYLOAD_MASK;
	dwSize = BLOCK_HEAP_PAYLOAD - (DWORD)faOffset;

	// Invalidate the context
	if (pContext)
		pContext->Invalidate();

	if (idNode < m_idNodeCount)
	{
		// The starting node exists
		hrRes = GetNodeFromNodeId(idNode, &pNode);
        if (FAILED(hrRes)) {
            TraceFunctLeave();
            return hrRes;
        }

		_ASSERT(pNode);

#ifdef DEBUG_TRACK_ALLOCATION_BOUNDARIES

		// Set the beginning of the allocation
		SetAllocationBoundary(faStartOfBlock, pNode);

#endif

		// Set the context here, most likely a write will follow immediately
		if (pContext)
			pContext->Set(pNode, pNode->stAttributes.faOffset);

		if (dwSize >= dwSizeDesired)
		{
			// Scenario 1: enough space left
			DebugTrace((LPARAM)this, "Allocated from existing node");

			// Just fill in the output parameters
			*pfaOffsetToAllocatedMemory = faStartOfBlock;
			TraceFunctLeaveEx((LPARAM)this);
			return(S_OK);
		}

		// Scenario 2a: More blocks needed, starting from the
		// next block, see how many more we need
		dwSizeDesired -= dwSize;
	}
	else
	{
		// Scenario 2b: More blocks needed.

		// NOTE: This should be a rare code path except for
		// high contention ...

		// Now we have again 2 cases:
		// 1) If our offset is in the middle of a block, then
		// we know another thread is creating the current block
		// and all we have to do is to wait for the block to be
		// created, but create any subsequent blocks.
		// 2) If we are exactly at the start of the block, then
		// it is the responsibility of the current thread to
		// create the block.
		if (faOffset != 0)
		{
			// Scenario 1: We don't have to create the current block.
			// so skip the current block
			dwSizeDesired -= dwSize;
		}
	}

	DebugTrace((LPARAM)this, "Creating new node");

	// We must grab an exclusive lock before we go ahead and
	// create any blocks
#ifndef BLOCKMGR_DISABLE_CONTENTION_CONTROL
	if (fAcquireLock) WriteLock();
#endif

	// At this point, we can do whatever we want with the node
	// list and nodes. We will try to create all the missing
	// nodes, whether or not it lies in our desired region or not.
	//
	// We need to do this because if an allocation failed before,
	// we have missing nodes between the end of the allocated nodes
	// and the current node we are allocating. Since these nodes
	// contain links to the deeper nodes, we will break if we have
	// missing nodes.
	//
	// This is necessary since this function is not serailzed
	// elsewhere. So a thread entering later than another can
	// grab the lock before the earlier thread. If we don't
	// fill in the bubbles, the current thread will still have
	// to wait for the earlier blocks to be created by the
	// earlier thread. We would also have chaos if our allocations
	// worked and the ones in front of us failed. This may be
	// a bottleneck for all threads on this message, but once
	// we're done this lock, they'll all unblock. Moreover, if
	// we fail, they will all have to fail!

	// Figure out how many blocks to create, up to the known limit
	idLastNodeToCreate =
		(m_faEndOfData + BLOCK_HEAP_PAYLOAD_MASK) >> BLOCK_HEAP_PAYLOAD_BITS;

	// We know where the block starts, question is whether we're
	// successful or not.
	*pfaOffsetToAllocatedMemory = faStartOfBlock;

	// The node count could have changed while we were waiting
	// for the lock, so we have to refresh our records.
	// Better yet, if another thread already created our blocks
	// for us, we can just leave ...
	idCurrentNode = m_idNodeCount;

	if (idCurrentNode < idLastNodeToCreate)
	{
		LPBLOCK_HEAP_NODE	pNewNode	= NULL;
		BOOL				fSetContext	= TRUE;

		// No such luck, gotta go in and do the hard work ...

		if (!pContext)
			fSetContext = FALSE;

		// Now, we have a function that inserts a node given
		// the pervious node (not the parent), so we have to
		// go find the previous node. This has got to be
		// there unless our node list is messed up.
		pNode = NULL;
		if (idCurrentNode > 0)
		{
			// This is not the root, so we can find its prev.
			hrRes = GetNodeFromNodeId(idCurrentNode - 1, &pNode, TRUE);
            if (FAILED(hrRes)) {
#ifndef BLOCKMGR_DISABLE_CONTENTION_CONTROL
	            if (fAcquireLock) WriteUnlock();
#endif
                TraceFunctLeave();
                return hrRes;
            }
			_ASSERT(pNode);
			_ASSERT(pNode->stAttributes.idNode == (idCurrentNode -1));
		}

		while (idCurrentNode < idLastNodeToCreate)
		{
			hrRes = m_bma.AllocBlock((LPVOID *)&pNewNode, sizeof(BLOCK_HEAP_NODE));
			if (!SUCCEEDED(hrRes))
			{
				// We can't proceed, but what we've got is cool
				DebugTrace((LPARAM)this,
						"Failed to allocate node %u", idCurrentNode);
				break;
			}

			DebugTrace((LPARAM)this, "Allocated node %u", idCurrentNode);

#ifdef DEBUG_TRACK_ALLOCATION_BOUNDARIES

			// Need to do some work here
			ZeroMemory(pNewNode->stAttributes.rgbBoundaries,
						sizeof(pNewNode->stAttributes.rgbBoundaries));

			// See if we have to mark the start of the
#endif

			// Got the block, fill in the info and insert the block
			// Again, we shouldn't fail if we get this far.
			hrRes = InsertNodeGivenPreviousNode(pNewNode, pNode);
			_ASSERT(SUCCEEDED(hrRes));

			// Set the context value here if we need to note if the
			// following condition is TRUE, we were in scenario 2b above.
			if (idCurrentNode == idNode)
			{
				if (fSetContext)
				{
					// The context is actually the node that marks the
					// start of the reserved block
					// Note we only need to do this if we were in scenario
					// 2b above.
					pContext->Set(pNewNode, pNewNode->stAttributes.faOffset);
					fSetContext = FALSE;
				}

#ifdef DEBUG_TRACK_ALLOCATION_BOUNDARIES

				// Set the beginning of the allocation
				SetAllocationBoundary(faStartOfBlock, pNewNode);

#endif
			}

			// Next
			pNode = pNewNode;
			idCurrentNode++;
		}

		// Now update the counter to reflect what we've created.
		m_idNodeCount = idCurrentNode;
	}

#ifndef BLOCKMGR_DISABLE_CONTENTION_CONTROL
	if (fAcquireLock) WriteUnlock();
#endif

	TraceFunctLeaveEx((LPARAM)this);
	return (hrRes);
}

BOOL CBlockManager::IsMemoryAllocated(
			FLAT_ADDRESS		faOffset,
			DWORD				dwLength
			)
{
	// Note we chack for actually allocated memory by checking
	// m_idNodeCount, where m_faEndOfData includes data that is
	// reserved but not yet allocated.
	HEAP_NODE_ID	idNode = GetNodeIdFromOffset(faOffset);
	if (idNode < m_idNodeCount)
	{
		idNode = GetNodeIdFromOffset(faOffset + dwLength - 1);
		if (idNode < m_idNodeCount)
			return(TRUE);
		_ASSERT(FALSE);
	}

	_ASSERT(FALSE);
	return(FALSE);
}

HRESULT CBlockManager::OperateOnMemory(
			DWORD			dwOperation,
			LPBYTE			pbBuffer,
			FLAT_ADDRESS	faTargetOffset,
			DWORD			dwBytesToDo,
			DWORD			*pdwBytesDone,
			CBlockContext	*pContext	// Optional
			)
{
	BOOL				fUseContext	= (pContext != NULL);
	BOOL				fBounddaryCheck = !(dwOperation & BOP_NO_BOUNDARY_CHECK);
	BOOL				fLockAcquired = (dwOperation & BOP_LOCK_ACQUIRED);
	DWORD   			dwHopsAway	= 0;
	HRESULT				hrRes		= S_OK;
	LPBLOCK_HEAP_NODE	pNode		= NULL;

	_ASSERT(IsValid());
	_ASSERT(pbBuffer);
	_ASSERT(pdwBytesDone);

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::OperateOnMemory");

	// Mask out the operation
	dwOperation &= BOP_OPERATION_MASK;

	if (fUseContext)
	{
		FLAT_ADDRESS	faOffset = pContext->m_faLastAccessedNodeOffset;

		// We will not continue if a bad context is passed in
		if (!pContext->IsValid())
			fUseContext = FALSE;
		else
		{
			// More debug sanity checks
			_ASSERT(pContext->m_pLastAccessedNode->stAttributes.faOffset
						== faOffset);

			// We will see if the context really helps
			if (faOffset <= faTargetOffset)
			{
				// Let's see how many hops away
				dwHopsAway = (DWORD)
					((faTargetOffset - faOffset) >> BLOCK_HEAP_PAYLOAD_BITS);

				// Not worth it if more than a number of hops away
				if (dwHopsAway > BLOCK_MAX_ALLOWED_LINEAR_HOPS)
					fUseContext = FALSE;
			}
			else
				fUseContext = FALSE;
		}
	}

	if (fUseContext)
	{
        DebugTrace((LPARAM) this, "using context");
		// Quickly access the starting target node ...
		pNode = pContext->m_pLastAccessedNode;
		while (dwHopsAway--)
		{
			hrRes = GetNextNode(&pNode, fLockAcquired);
			if (FAILED(hrRes))
			{
				fUseContext = FALSE;
				break;
			}
		}
	}
	if (!fUseContext)
	{
        DebugTrace((LPARAM) this, "ignoring context");
		// Okay, gotta find the desired node from scratch ...
		hrRes = GetNodeFromNodeId( GetNodeIdFromOffset(faTargetOffset),
									&pNode,
									fLockAcquired);
		if (!SUCCEEDED(hrRes))
		{
			ErrorTrace((LPARAM)this, "GetNodeIdFromOffset failed");
			TraceFunctLeaveEx((LPARAM)this);
			return(STG_E_INVALIDPARAMETER);
		}

		_ASSERT(pNode);
	}

    DebugTrace((LPARAM) this, "pNode = 0x%x", pNode);

    _ASSERT(pNode != NULL);

	if (!IsMemoryAllocated(faTargetOffset, dwBytesToDo))
	{
		ErrorTrace((LPARAM)this,
				"Specified range is unallocated");
		TraceFunctLeaveEx((LPARAM)this);
		return(STG_E_INVALIDPARAMETER);
	}

	// Clear the counter ...
	*pdwBytesDone = 0;

	// Do the actual processing
	switch (dwOperation)
	{
	case BOP_READ:
	case BOP_WRITE:
		{
			DWORD dwChunkSize;
			DWORD dwBytesDone = 0;

			faTargetOffset &= BLOCK_HEAP_PAYLOAD_MASK;
			dwChunkSize = (DWORD)(BLOCK_HEAP_PAYLOAD - faTargetOffset);
			while (dwBytesToDo)
			{
				if (dwBytesToDo < dwChunkSize)
					dwChunkSize = dwBytesToDo;

#ifdef DEBUG_TRACK_ALLOCATION_BOUNDARIES
				if (fBounddaryCheck)
				{
					// Make sure we are not stepping over boundaries
					hrRes = VerifyAllocationBoundary(faTargetOffset,
										dwChunkSize,
										pNode);
					if (!SUCCEEDED(hrRes))
						break;
				}
#endif

				if (dwOperation == BOP_READ)
				{
					DebugTrace((LPARAM)this,
							"Reading %u bytes", dwChunkSize);
					MoveMemory((LPVOID)pbBuffer,
							   (LPVOID)&(pNode->rgbData[faTargetOffset]),
							   dwChunkSize);
				}
				else
				{
					DebugTrace((LPARAM)this,
							"Writing %u bytes", dwChunkSize);
					MoveMemory((LPVOID)&(pNode->rgbData[faTargetOffset]),
							   (LPVOID)pbBuffer,
							   dwChunkSize);

					// Set the block to dirty
					pNode->stAttributes.fFlags |= BLOCK_IS_DIRTY;

					SetDirty(TRUE);
				}

				// Adjust the read buffer for the next read/write
				pbBuffer += dwChunkSize;

				// Adjust the counters
				dwBytesToDo -= dwChunkSize;
				dwBytesDone += dwChunkSize;

				// After the first operation, the offset will always
				// be zero, and the default chunk size is a full payload
				faTargetOffset = 0;
				dwChunkSize = BLOCK_HEAP_PAYLOAD;

				// Read next chunk
				if (dwBytesToDo)
				{
					// See if we have to load this ...
					hrRes = GetNextNode(&pNode, fLockAcquired);
					if (FAILED(hrRes))
						break;
				}
			}

			// Fill out how much we've done
			*pdwBytesDone = dwBytesDone;
		}
		break;

	default:
		ErrorTrace((LPARAM)this,
				"Invalid operation %u", dwOperation);
		hrRes = STG_E_INVALIDFUNCTION;
	}

	// Update context if succeeded
	if (SUCCEEDED(hrRes) && pContext)
	{
		pContext->Set(pNode, pNode->stAttributes.faOffset);
	}

	TraceFunctLeaveEx((LPARAM)this);
	return(hrRes);
}

HRESULT CBlockManager::ReadMemory(
			LPBYTE			pbBuffer,
			FLAT_ADDRESS	faTargetOffset,
			DWORD			dwBytesToRead,
			DWORD			*pdwBytesRead,
			CBlockContext	*pContext	// Optional
			)
{
	return(OperateOnMemory(
					BOP_READ,
					pbBuffer,
					faTargetOffset,
					dwBytesToRead,
					pdwBytesRead,
					pContext));
}

HRESULT CBlockManager::WriteMemory(
			LPBYTE			pbBuffer,
			FLAT_ADDRESS	faTargetOffset,
			DWORD			dwBytesToWrite,
			DWORD			*pdwBytesWritten,
			CBlockContext	*pContext	// Optional
			)
{
	return(OperateOnMemory(
					BOP_WRITE,
					pbBuffer,
					faTargetOffset,
					dwBytesToWrite,
					pdwBytesWritten,
					pContext));
}

HRESULT CBlockManager::ReleaseNode(
			LPBLOCK_HEAP_NODE	pNode
			)
{
	HRESULT	hrRes = S_OK;
	HRESULT	tempRes;

	// Release all children recursively
	for (DWORD i = 0; i < BLOCK_HEAP_ORDER; i++)
		if (pNode->rgpChildren[i])
		{
			tempRes = ReleaseNode(pNode->rgpChildren[i]);
			if (FAILED(tempRes))
				hrRes = tempRes;
			pNode->rgpChildren[i] = NULL;
		}

	// Release self
	m_bma.FreeBlock(pNode);
	return(hrRes);
}

HRESULT CBlockManager::Release()
{
	HRESULT				hrRes		= S_OK;

	_ASSERT(IsValid());

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::Release");

	// This function assumes that no more threads are using this
	// class and no new threads are inside trying to reserve
	// memory. Though, for good measure, this function still
	// grabs a write lock so that at least it does not get
	// corrupt when stray threads are still lingering around.

	// Grab the lock before we go in and destroy the node list
#ifndef BLOCKMGR_DISABLE_CONTENTION_CONTROL
	WriteLock();
#endif

	if (m_pRootNode)
	{
		hrRes = ReleaseNode(m_pRootNode);
		if (SUCCEEDED(hrRes))
			m_pRootNode = NULL;
	}

#ifndef BLOCKMGR_DISABLE_CONTENTION_CONTROL
	WriteUnlock();
#endif

	TraceFunctLeaveEx((LPARAM)this);
	return (hrRes);
}

HRESULT CBlockManager::AtomicDereferenceAndRead(
			LPBYTE			pbBuffer,
			DWORD			*pdwBufferSize,
			LPBYTE			pbInfoStruct,
			FLAT_ADDRESS	faOffsetToInfoStruct,
			DWORD			dwSizeOfInfoStruct,
			DWORD			dwOffsetInInfoStructToOffset,
			DWORD			dwOffsetInInfoStructToSize,
			CBlockContext	*pContext	// Optional
			)
{
	HRESULT			hrRes				= S_OK;
	FLAT_ADDRESS	faOffset;
	DWORD			dwSizeToRead;
	DWORD			dwSizeRead;

	_ASSERT(IsValid());
	_ASSERT(pbBuffer);
	_ASSERT(pdwBufferSize);
	_ASSERT(pbInfoStruct);
	// pContext can be NULL

	TraceFunctEnterEx((LPARAM)this,
			"CBlockManager::AtomicDereferenceAndRead");

#ifndef BLOCKMGR_DISABLE_ATOMIC_FUNCS
	// Acquire the synchronization object
	WriteLock();
#endif

	do
	{
		BOOL	fInsufficient	= FALSE;
		DWORD	dwBufferSize	= *pdwBufferSize;

		// Read the info struct
		DebugTrace((LPARAM)this, "Reading information structure");
		hrRes = OperateOnMemory(
						BOP_READ | BOP_LOCK_ACQUIRED,
						pbInfoStruct,
						faOffsetToInfoStruct,
						dwSizeOfInfoStruct,
						&dwSizeRead,
						pContext);
		if (!SUCCEEDED(hrRes))
			break;

		// Fill out the parameters
		faOffset = *(UNALIGNED FLAT_ADDRESS *)(pbInfoStruct + dwOffsetInInfoStructToOffset);
		dwSizeToRead = *(UNALIGNED DWORD *)(pbInfoStruct + dwOffsetInInfoStructToSize);

		DebugTrace((LPARAM)this, "Reading %u bytes from offset %u",
					dwSizeToRead, (DWORD)faOffset);

		// See if we have enough buffer
		if (dwBufferSize < dwSizeToRead)
		{
			fInsufficient = TRUE;
			DebugTrace((LPARAM)this,
				"Insufficient buffer, only reading %u bytes",
				dwBufferSize);
		}
		else
			dwBufferSize = dwSizeToRead;

		// Do the read
		hrRes = OperateOnMemory(
						BOP_READ | BOP_LOCK_ACQUIRED,
						pbBuffer,
						faOffset,
						dwBufferSize,
						&dwSizeRead,
						pContext);
		if (!SUCCEEDED(hrRes))
			break;

		*pdwBufferSize = dwSizeToRead;

		// If we had insufficient buffer, we must return the
		// correct HRESULT
		if (fInsufficient)
			hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

	} while (0);

#ifndef BLOCKMGR_DISABLE_ATOMIC_FUNCS
	WriteUnlock();
#endif

	TraceFunctLeaveEx((LPARAM)this);
	return (hrRes);
}

inline HRESULT CBlockManager::WriteAndIncrement(
			LPBYTE			pbBuffer,
			FLAT_ADDRESS	faOffset,
			DWORD			dwBytesToWrite,
			DWORD			*pdwValueToIncrement,
			DWORD			dwIncrementValue,
			CBlockContext	*pContext	// Optional
			)
{
	HRESULT		hrRes				= S_OK;
	DWORD		dwSize;

	_ASSERT(IsValid());
	_ASSERT(pbBuffer);
	// pdwValueToIncrement and pContext can be NULL

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::WriteAndIncrement");

	// Very simple, this function assumes no contention since the caller
	// is already supposed to be in some sort of atomic operation
	hrRes = OperateOnMemory(
				BOP_WRITE | BOP_LOCK_ACQUIRED,
				pbBuffer,
				faOffset,
				dwBytesToWrite,
				&dwSize,
				pContext);
	if (SUCCEEDED(hrRes))
	{
		// This must be true if the write succeeded, but then ...
		_ASSERT(dwBytesToWrite == dwSize);

		// The write is successful, then increment the value in
		// an interlocked fashion. We do that such that simultaneous
		// reads will be locked out properly. Simultaneous writes
		// should be serialized by design but we do this for good
		// measure in case the caller is not aware of this requirement.
		if (pdwValueToIncrement)
			AtomicAdd(pdwValueToIncrement, dwIncrementValue);
	}

	TraceFunctLeaveEx((LPARAM)this);
	return (hrRes);
}

HRESULT CBlockManager::AtomicWriteAndIncrement(
			LPBYTE			pbBuffer,
			FLAT_ADDRESS	faOffset,
			DWORD			dwBytesToWrite,
			DWORD			*pdwValueToIncrement,
			DWORD			dwReferenceValue,
			DWORD			dwIncrementValue,
			CBlockContext	*pContext	// Optional
			)
{
	HRESULT		hrRes				= S_OK;

	_ASSERT(IsValid());
	_ASSERT(pbBuffer);
	// pdwValueToIncrement and pContext can be NULL

	TraceFunctEnterEx((LPARAM)this,
			"CBlockManager::AtomicWriteAndIncrement");

	// Since acquiring the synchronization is potentially costly,
	// we do a final sanity check to make sure no thread had
	// beaten us in taking this slot
	if (pdwValueToIncrement &&
		*pdwValueToIncrement != dwReferenceValue)
	{
		DebugTrace((LPARAM)this, "Aborting due to change in property count");
		TraceFunctLeaveEx((LPARAM)this);
		return(HRESULT_FROM_WIN32(ERROR_RETRY));
	}

#ifndef BLOCKMGR_DISABLE_ATOMIC_FUNCS
	// This is a pass-thru call to the WriteAndIncrement but
	// after acquiring the synchronization object
	WriteLock();
#endif

	// The wait for the lock could have been long, so we do a second
	// check to see if we're out of luck after all this ...
	if (pdwValueToIncrement &&
		*pdwValueToIncrement != dwReferenceValue)
	{
#ifndef BLOCKMGR_DISABLE_ATOMIC_FUNCS
		// Gotta release it!
		WriteUnlock();
#endif

		DebugTrace((LPARAM)this, "Aborting after acquiring lock");
		TraceFunctLeaveEx((LPARAM)this);
		return(HRESULT_FROM_WIN32(ERROR_RETRY));
	}

	hrRes = WriteAndIncrement(
					pbBuffer,
					faOffset,
					dwBytesToWrite,
					pdwValueToIncrement,
					dwIncrementValue,
					pContext);

#ifndef BLOCKMGR_DISABLE_ATOMIC_FUNCS
	WriteUnlock();
#endif

	TraceFunctLeaveEx((LPARAM)this);
	return (hrRes);
}

HRESULT CBlockManager::AtomicAllocWriteAndIncrement(
			DWORD			dwDesiredSize,
			FLAT_ADDRESS	*pfaOffsetToAllocatedMemory,
			FLAT_ADDRESS	faOffsetToWriteOffsetToAllocatedMemory,
			FLAT_ADDRESS	faOffsetToWriteSizeOfAllocatedMemory,
			LPBYTE			pbInitialValueForAllocatedMemory,
			DWORD			dwSizeOfInitialValue,
			LPBYTE			pbBufferToWriteFrom,
			DWORD			dwOffsetInAllocatedMemoryToWriteTo,
			DWORD			dwSizeofBuffer,
			DWORD			*pdwValueToIncrement,
			DWORD			dwReferenceValue,
			DWORD			dwIncrementValue,
			CBlockContext	*pContext	// Optional
			)
{
	HRESULT		hrRes				= S_OK;
	DWORD		dwAllocatedSize;
	DWORD		dwSize;

	_ASSERT(IsValid());
	_ASSERT(pfaOffsetToAllocatedMemory);
	_ASSERT(pbBufferToWriteFrom);
	_ASSERT(pdwValueToIncrement);
	// pContext can be NULL

	TraceFunctEnterEx((LPARAM)this,
			"CBlockManager::AtomicAllocWriteAndIncrement");

	// Since acquiring the synchronization is potentially costly,
	// we do a final sanity check to make sure no thread had
	// beaten us in taking this slot
	if (*pdwValueToIncrement != dwReferenceValue)
	{
		DebugTrace((LPARAM)this, "Aborting due to change in property count");
		TraceFunctLeaveEx((LPARAM)this);
		return(HRESULT_FROM_WIN32(ERROR_RETRY));
	}

#ifndef BLOCKMGR_DISABLE_ATOMIC_FUNCS
	// This is a pass-thru call to AllocateMemoryEx and
	// WriteAndIncrement after acquiring the synchronization object
	WriteLock();
#endif

	// The wait for the lock could have been long, so we do a second
	// check to see if we're out of luck after all this ...
	if (*pdwValueToIncrement != dwReferenceValue)
	{
#ifndef BLOCKMGR_DISABLE_ATOMIC_FUNCS
		// Gotta release it!
		WriteUnlock();
#endif

		DebugTrace((LPARAM)this, "Aborting after acquiring lock");
		TraceFunctLeaveEx((LPARAM)this);
		return(HRESULT_FROM_WIN32(ERROR_RETRY));
	}

	// Try to allocate the requested block
	hrRes = AllocateMemoryEx(
					FALSE,
					dwDesiredSize,
					pfaOffsetToAllocatedMemory,
					&dwAllocatedSize,
					pContext);
	if (SUCCEEDED(hrRes))
	{
		// Okay, initialize the memory allocated
		if (pbInitialValueForAllocatedMemory)
		{
			hrRes = WriteMemory(
						pbInitialValueForAllocatedMemory,
						*pfaOffsetToAllocatedMemory,
						dwSizeOfInitialValue,
						&dwSize,
						pContext);

			// See if we need to write the size and offset info
			if (SUCCEEDED(hrRes))
			{
				if (faOffsetToWriteOffsetToAllocatedMemory !=
						INVALID_FLAT_ADDRESS)
					hrRes = WriteMemory(
								(LPBYTE)pfaOffsetToAllocatedMemory,
								faOffsetToWriteOffsetToAllocatedMemory,
								sizeof(FLAT_ADDRESS),
								&dwSize,
								pContext);

				if (SUCCEEDED(hrRes) &&
					faOffsetToWriteSizeOfAllocatedMemory !=
						INVALID_FLAT_ADDRESS)
					hrRes = WriteMemory(
								(LPBYTE)&dwAllocatedSize,
								faOffsetToWriteSizeOfAllocatedMemory,
								sizeof(DWORD),
								&dwSize,
								pContext);
			}
		}

		if (SUCCEEDED(hrRes))
		{
			// OK, since we got the memory, the write should not
			// fail, but we check the result anyway.
			hrRes = WriteAndIncrement(
							pbBufferToWriteFrom,
							*pfaOffsetToAllocatedMemory +
								dwOffsetInAllocatedMemoryToWriteTo,
							dwSizeofBuffer,
							pdwValueToIncrement,
							dwIncrementValue,
							pContext);
		}
	}

#ifndef BLOCKMGR_DISABLE_ATOMIC_FUNCS
	WriteUnlock();
#endif


	TraceFunctLeaveEx((LPARAM)this);
	return (hrRes);
}

HRESULT CBlockManager::MarkBlockAs(
			LPBYTE			pbData,
			BOOL			fClean
			)
{
	LPBLOCK_HEAP_NODE				pNode;

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::MarkBlockAs");

	// Find the attributes record from the data pointer
	pNode = CONTAINING_RECORD(pbData, BLOCK_HEAP_NODE, rgbData);
	_ASSERT(pNode);

	_ASSERT(pNode->stAttributes.fFlags & BLOCK_PENDING_COMMIT);

	// Cannot be pending and dirty
	_ASSERT(!(pNode->stAttributes.fFlags & BLOCK_IS_DIRTY));

	// Undo the dirty bit and mark as pending
	pNode->stAttributes.fFlags &= ~(BLOCK_PENDING_COMMIT);
	if (!fClean) {
		pNode->stAttributes.fFlags |= BLOCK_IS_DIRTY;
		SetDirty(TRUE);
	}

	TraceFunctLeaveEx((LPARAM)this);
	return(S_OK);
}

HRESULT CBlockManager::CommitDirtyBlocks(
			FLAT_ADDRESS			faStartingOffset,
			FLAT_ADDRESS			faLengthToScan,
			DWORD					dwFlags,
			IMailMsgPropertyStream	*pStream,
			BOOL					fDontMarkAsCommit,
			BOOL                    fComputeBlockCountsOnly,
			DWORD                   *pcBlocksToWrite,
			DWORD                   *pcTotalBytesToWrite,
			IMailMsgNotify			*pNotify
			)
{
	HRESULT				hrRes = S_OK;
	HEAP_NODE_ID		idNode;
	LPBLOCK_HEAP_NODE	pNode;
	DWORD				dwBlocksToScan;
	BOOL				fLimitedLength;
	DWORD				dwCount = 0;
	DWORD				rgdwOffset[CMAILMSG_COMMIT_PAGE_BLOCK_SIZE];
	DWORD				rgdwSize[CMAILMSG_COMMIT_PAGE_BLOCK_SIZE];
	LPBYTE				rgpData[CMAILMSG_COMMIT_PAGE_BLOCK_SIZE];
	DWORD				*pdwOffset;
	DWORD				*pdwSize;
	LPBYTE				*ppbData;

	_ASSERT(pStream);

	TraceFunctEnterEx((LPARAM)this, "CBlockManager::CommitDirtyBlocks");

	fLimitedLength = FALSE;
	pNode = NULL;
	if (faStartingOffset != INVALID_FLAT_ADDRESS)
	{
		idNode = GetNodeIdFromOffset(faStartingOffset);
		if (idNode >= m_idNodeCount)
		{
			hrRes = STG_E_INVALIDPARAMETER;
			goto Cleanup;
		}

		hrRes = GetNodeFromNodeId(idNode, &pNode);
		if (!SUCCEEDED(hrRes))
			goto Cleanup;

		if (faLengthToScan != INVALID_FLAT_ADDRESS)
		{
			// See how many blocks to scan, rounding up
			faLengthToScan += (faStartingOffset & BLOCK_HEAP_PAYLOAD_MASK);
			faLengthToScan += BLOCK_HEAP_PAYLOAD_MASK;
			dwBlocksToScan = (DWORD)(faLengthToScan >> BLOCK_HEAP_PAYLOAD_BITS);
			fLimitedLength = TRUE;
		}
		else
			dwBlocksToScan = 0;
	}
	else
	{
		hrRes = STG_E_INVALIDPARAMETER;
		goto Cleanup;
	}

	// Loop until we fill up the array or have no more blocks
	dwCount = 0;
	pdwOffset = rgdwOffset;
	pdwSize = rgdwSize;
	ppbData = rgpData;
	while (pNode)
	{
		if (fLimitedLength && !dwBlocksToScan--)
			break;

		if ((dwFlags & MAILMSG_GETPROPS_COMPLETE) ||
			(pNode->stAttributes.fFlags & BLOCK_IS_DIRTY))
		{
			// Make sure we are not full ...
			if (dwCount == CMAILMSG_COMMIT_PAGE_BLOCK_SIZE)
			{
				*pcBlocksToWrite += dwCount;

				if (!fComputeBlockCountsOnly) {
					// We are full, then write out the blocks
					hrRes = pStream->WriteBlocks(
								m_pMsg,
								dwCount,
								rgdwOffset,
								rgdwSize,
								rgpData,
								pNotify);
					if (!SUCCEEDED(hrRes))
						break;

					if (!fDontMarkAsCommit) {
						// Go back and mark all blocks as clean
						ppbData = rgpData;
						while (--dwCount)
							MarkBlockAs(*ppbData++, TRUE);
					}
				}
				dwCount = 0;

				// Reset our pointers and go on
				pdwOffset = rgdwOffset;
				pdwSize = rgdwSize;
				ppbData = rgpData;
			}

			if (!fComputeBlockCountsOnly && !fDontMarkAsCommit) {
				// Undo the dirty bit and mark as pending
				pNode->stAttributes.fFlags &= BLOCK_CLEAN_MASK;
				pNode->stAttributes.fFlags |= BLOCK_PENDING_COMMIT;
			}

			// Fill in the array elements

			// faOffset really contains an offset not a full pointer here so we
			// can (and must) cast it for the calls to WriteBlocks to be OK
			*pdwOffset++ = (DWORD)pNode->stAttributes.faOffset;

			*pdwSize++ = BLOCK_HEAP_PAYLOAD;
			*ppbData++ = pNode->rgbData;
			*pcTotalBytesToWrite += BLOCK_HEAP_PAYLOAD;
			dwCount++;
		}

		// Next node, pNode == NULL if no more nodes
		hrRes = GetNextNode(&pNode, FALSE);
        if (hrRes == STG_E_INVALIDPARAMETER) hrRes = S_OK;
        DebugTrace((LPARAM) this, "hrRes = %x", hrRes);
	}

	if (SUCCEEDED(hrRes) && dwCount)
	{
		*pcBlocksToWrite += dwCount;

		if (!fComputeBlockCountsOnly) {
			// Write out the remaining blocks
			hrRes = pStream->WriteBlocks(
						m_pMsg,
						dwCount,
						rgdwOffset,
						rgdwSize,
						rgpData,
						pNotify);
		}
	}

    if (FAILED(hrRes)) SetCommitMode(FALSE);

	if (!fComputeBlockCountsOnly && !fDontMarkAsCommit && dwCount) {
		// Go back and mark all blocks to the correct state
		ppbData = rgpData;
		while (--dwCount)
			MarkBlockAs(*ppbData++, SUCCEEDED(hrRes));
	}

Cleanup:

	TraceFunctLeaveEx((LPARAM)this);
	return(hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\cache2\src\cache2.cpp ===
/*++

	Cache2.cpp

	this file implements the main library support for the cache.

--*/


#include	<windows.h>
#include	"dbgtrace.h"
#include	"cache2.h"


BOOL				CScheduleThread::s_fInitialized ;
CRITICAL_SECTION	CScheduleThread::s_critScheduleList ;
HANDLE				CScheduleThread::s_hShutdown ;
HANDLE				CScheduleThread::s_hThread ;
CScheduleThread		CScheduleThread::s_Head( TRUE ) ;
DWORD				CScheduleThread::dwNotificationSeconds = 5 ;

//
//	Is the Caching library initialized ?
//
static	BOOL	fInitialized ;

CRITICAL_SECTION	g_CacheShutdown ;


BOOL    __stdcall
CacheLibraryInit()	{

	InitializeCriticalSection( &g_CacheShutdown ) ;

	if( !fInitialized ) {
		fInitialized = TRUE ;
		return	CScheduleThread::Init() ;
	}
	return	TRUE ;
}

BOOL    __stdcall
CacheLibraryTerm() {

	_ASSERT( fInitialized ) ;

	CScheduleThread::Term() ;

	DeleteCriticalSection( &g_CacheShutdown ) ;
	fInitialized = FALSE ;
	return	TRUE ;

}
			




DWORD	WINAPI	
CScheduleThread::ScheduleThread(	
						LPVOID	lpv
						) {
/*++

Routine Description :

	This function implements the thread which loops through
	all the Cache item's which are registered.  We invoke each
	one's Schedule method which gives it a change to bump TTL's etc...

Arguments :

	lpv - unused

Return Value :

	Always 0.

--*/



	while( 1 ) {

		DWORD	dwWait = WaitForSingleObject( s_hShutdown, dwNotificationSeconds * 100 ) ;

		if( dwWait == WAIT_TIMEOUT ) {

			EnterCriticalSection( &s_critScheduleList ) ;

			for( CScheduleThread* p = s_Head.m_pNext; p!=&s_Head; p = p->m_pNext ) {
				p->Schedule() ;
			}

			LeaveCriticalSection( &s_critScheduleList ) ;

		}	else	{

			break ;

		}
	}
	return	0 ;
}

BOOL
CScheduleThread::Init() {
/*++

Routine Description :

	Initialize the scheduler thread.
	Creates necessary threads, shutdown events, etc...

Arguments :

	None

Return Value :

	TRUE if successfull

--*/

	s_fInitialized = FALSE ;
	InitializeCriticalSection( &s_critScheduleList ) ;

	s_hShutdown = CreateEvent(	0,
								FALSE,
								FALSE,
								0 ) ;
	if( s_hShutdown != 0 ) {
	
		DWORD	dwJunk ;
		s_hThread = CreateThread(	0,
									0,
									ScheduleThread,
									0,
									0,
									&dwJunk ) ;
		if( s_hThread != 0 ) {
			s_fInitialized = TRUE ;
			return	TRUE ;
		}
	}
	DeleteCriticalSection(&s_critScheduleList);
	return	FALSE ;
}

void
CScheduleThread::Term()	{
/*++

Routine Description :

	Terminates the scheduler thread - destroys all objects.

Arguments :

	None.

Return Value :

	None.

--*/

	if( s_fInitialized ) {
		if( s_hShutdown ) {
			SetEvent( s_hShutdown ) ;
		}
		if( s_hThread ) {
			WaitForSingleObject( s_hThread, INFINITE ) ;
			CloseHandle( s_hThread ) ;
		}
		if( s_hShutdown )
			CloseHandle( s_hShutdown ) ;

		s_hShutdown = 0 ;
		s_hThread = 0 ;

		DeleteCriticalSection(&s_critScheduleList);

		s_fInitialized = FALSE ;
	}
}


CScheduleThread::CScheduleThread(	BOOL fSpecial ) {
/*++

Routine Description :

	Special constructor which makes the empty doubly linked list !

Arguments :

	None.

Return Value :

	TRUE if successfull.

--*/


	m_pPrev = this ;
	m_pNext = this ;

}

	

CScheduleThread::CScheduleThread() :
	m_pPrev( 0 ),
	m_pNext( 0 )	{
/*++

Routine Description :

	Creates an object placed on the Sheduler's queue
	for regular execution.	

Arguments :

	None.

Return Value :

	None.

--*/

	_ASSERT( s_fInitialized ) ;
//	_ASSERT( s_Head.m_pPrev != 0 ) ;
//	_ASSERT( s_Head.m_pNext != 0 ) ;
//	_ASSERT( s_Head.m_pPrev->m_pNext == &s_Head ) ;
//	_ASSERT( s_Head.m_pNext->m_pPrev == &s_Head ) ;

}

void
CScheduleThread::AddToSchedule()	{
/*++

Routine Description :

	Creates an object placed on the Sheduler's queue
	for regular execution.	

Arguments :

	None.

Return Value :

	None.

--*/

	_ASSERT( s_fInitialized ) ;

	EnterCriticalSection( &s_critScheduleList ) ;

	_ASSERT( s_Head.m_pPrev != 0 ) ;
	_ASSERT( s_Head.m_pNext != 0 ) ;
	_ASSERT( s_Head.m_pPrev->m_pNext == &s_Head ) ;
	_ASSERT( s_Head.m_pNext->m_pPrev == &s_Head ) ;

	CScheduleThread*	pNext = &s_Head ;
	CScheduleThread*	pPrev = s_Head.m_pPrev ;
	m_pPrev = pPrev ;
	m_pNext = pNext ;
	pPrev->m_pNext = this ;
	pNext->m_pPrev = this ;
	LeaveCriticalSection( &s_critScheduleList ) ;


}

CScheduleThread::~CScheduleThread() {
/*++

Routine Description :

	Destroys a CScheduleThread object - removes it from
	the queue of objects called by the schedule thread.

Arguments :

	None.

Return Value :

	None.

--*/


	if( !s_fInitialized ) {
		return ;
	}

	_ASSERT( m_pPrev == 0 ) ;
	_ASSERT( m_pNext == 0 ) ;

	if( this == &s_Head ) {
		DeleteCriticalSection( &s_critScheduleList ) ;
	}
}

void
CScheduleThread::RemoveFromSchedule() {
/*++

Routine Description :

	Destroys a CScheduleThread object - removes it from
	the queue of objects called by the schedule thread.

Arguments :

	None.

Return Value :

	None.

--*/


	EnterCriticalSection( &s_critScheduleList ) ;

	CScheduleThread*	pNext = m_pNext ;
	CScheduleThread*	pPrev = m_pPrev ;

	_ASSERT( pNext != 0 ) ;
	_ASSERT( pPrev != 0 ) ;

	pNext->m_pPrev = pPrev ;
	pPrev->m_pNext = pNext ;

	m_pPrev = 0 ;
	m_pNext = 0 ;

	LeaveCriticalSection( &s_critScheduleList ) ;
}


CAllocatorCache::CAllocatorCache(	
					DWORD	cbSize,
					DWORD	cMaxElements
					) :
	m_cbSize( cbSize ),
	m_cElements( 0 ),
	m_cMaxElements( cMaxElements ),
	m_pHead( 0 )	{
/*++

Routine Description :

	Construct the CAllocatorCache - we're ready to go as soon
	as this finishes !

Args :
	cbSize - Largest size of any element requested !
	cMaxElements - Maximum number of elements we'll hold in our free list !

Returns :
	Nothing

--*/
}

CAllocatorCache::~CAllocatorCache()	{
/*++

Routine Description :

	Destroy the CAllocatorCache - release all the memory back
	to the system heap !

Args :
	None.

Returns :
	Nothing

--*/

	FreeSpace* p = m_pHead ;
	FreeSpace* pNext = 0 ;
	do	{
		if( p ) {
			pNext = p->m_pNext ;
			::delete	(BYTE*)	p ;				
		}
		p = pNext ;
	}	while( p ) ;
}

void*
CAllocatorCache::Allocate(	size_t	cb )	{
/*++

Routine Description :

	This function allocates memory from our allocation cache.

Arguments :

	cb - the size of the allocation requested !

Return Value :

	Pointer to the allocated memory !

--*/

	_ASSERT( cb <= m_cbSize ) ;

	LPVOID	lpvReturn = m_pHead ;

	if( lpvReturn ) {

#ifdef	DEBUG
		//
		//	Check that the memory contains what we filled it with
		//	when it was released !
		//
		BYTE	*pb = (BYTE*)lpvReturn ;
		BYTE	*pbMax = pb+m_cbSize ;
		pb += sizeof( FreeSpace ) ;
		for(	;
				pb < pbMax;
				pb++ )	{
			_ASSERT( *pb == 0xCC ) ;
		}
#endif
		
		m_pHead = m_pHead->m_pNext ;
		m_cElements -- ;

	}	else	{

		lpvReturn = (LPVOID) ::new BYTE[m_cbSize] ;

	}
	return	lpvReturn ;
}

void
CAllocatorCache::Free(	void*	pv )	{
/*++

Routine Description :

	This function allocates memory from our allocation cache.

Arguments :

	cb - the size of the allocation requested !

Return Value :

	Pointer to the allocated memory !

--*/

#ifdef	DEBUG
	FillMemory( pv, m_cbSize, 0xCC ) ;
#endif

	if( m_cElements < m_cMaxElements ) {
		FreeSpace*	pFreeSpace = (FreeSpace*)pv ;
		pFreeSpace->m_pNext = m_pHead ;
		m_pHead = pFreeSpace ;
		m_cElements++ ;
	}	else	{
		::delete	(BYTE*)	pv ;
	}
}

#ifdef	DEBUG
//
//	Number of CacheState objects allocated !
//
long	CacheState::g_cCacheState = 0 ;
#endif


CacheState::CacheState(	class	CLRUList*	p,
						long	cClientRefs
						) :
		m_dwSignature( CACHESTATE_SIGNATURE ),
		m_pOwner( p ),
		m_cRefs( 1 ),
		m_lLRULock( 0 )	{

	//
	//	Must add a positive number of client references only !
	//
	_ASSERT( cClientRefs >= 0 ) ;

	TraceFunctEnter( "CacheState::CacheState" ) ;
	DebugTrace( (DWORD_PTR)this, "p %x cClientRefs %x", p, cClientRefs ) ;

	GetSystemTimeAsFileTime( &m_LastAccess ) ;	

	if( cClientRefs ) {
		CheckOut( 0, cClientRefs ) ;
	}
#ifdef	DEBUG
	InterlockedIncrement( &g_cCacheState ) ;
#endif
}

CacheState::~CacheState()	{

	TraceFunctEnter( "CacheState::~CacheState" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;

#ifdef	DEBUG
	InterlockedDecrement( &g_cCacheState ) ;
#endif
}
	

void
CacheState::LRUReference(	class	CLRUList*	pLRU ) {

	TraceFunctEnter( "CacheState::LRUReference" ) ;
	DebugTrace( (DWORD_PTR)this, "pLRU %x m_lLRULock %x", pLRU, m_lLRULock ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;

	if( pLRU ) {
		//
		//	Only put into the CLRUList once !
		//
		if( InterlockedIncrement( (long*)&m_lLRULock ) == 1 ) {
			//
			//	Add a reference while we are in transit in the work queue !
			//
			long l = AddRef() ;
			DebugTrace( DWORD_PTR(this), "Added a Reference to %x l %x", this, l ) ;
			pLRU->AddWorkQueue( this ) ;
		}
	}
}

//
//	Reference counting support - Add a reference
//
long
CacheState::AddRef()	{
/*++

Routine Description :

	Add a reference to this piece of Cache State.
	Note - we distinguish different types of references -
	This is a reference from a Cache onto the item

Arguments :

	None.

Return Value :

	Number of References

--*/

	TraceFunctEnter( "CacheState::AddRef" ) ;

	return	InterlockedIncrement( (long*)&m_cRefs ) ;
}


//
//	Keeping track of clients - remove a client ref !
//
long	
CacheState::CheckInNoLocks(	
			class	CAllocatorCache* pAlloc
			)	{
/*++

Routine Description :

	A client is returning an item to the cache.
	This function will remove a client reference,
	and perform appropriate processing !

Arguments :

	pAlloc - the cache used to allocate and free
		ourselves

Return Value :

	Number of References
	if 0 then we've been destroyed !

--*/

	TraceFunctEnter( "CacheState::CheckIn" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	_ASSERT( IsMasterReference() ) ;

	long result = InterlockedExchangeAdd( (long*)&m_cRefs, -CLIENT_REF ) - CLIENT_REF ;

	DebugTrace( (DWORD_PTR)this, "pAlloc %x result %x", pAlloc, result ) ;

	_ASSERT( (result & CLIENT_BITS) >= 0 ) ;

	if( result == 0 ) {
		//
		//	If this function is called then somebody has a lock on the state object, 
		//	that somebody must have an independent reference other than what's getting 
		//	checked in - so this should never happen !
		//
		_ASSERT( 1==0 ) ;
		if( !pAlloc )	{
			delete	this ;
		}	else	{
			Destroy(0) ;
			pAlloc->Free( this ) ;	
		}
	}	else	{
		//
		//	was this the last client reference ?
		//
		if( (result & CLIENT_BITS) == 0 )	{
			//
			//	Yes - go and put this in the modify queue !
			//
			LRUReference( m_pOwner ) ;
		}
	}
	return	result ;
}



//
//	Keeping track of clients - remove a client ref !
//
long	
CacheState::CheckIn(	
			class	CAllocatorCache* pAlloc
			)	{
/*++

Routine Description :

	A client is returning an item to the cache.
	This function will remove a client reference,
	and perform appropriate processing !

Arguments :

	pAlloc - the cache used to allocate and free
		ourselves

Return Value :

	Number of References
	if 0 then we've been destroyed !

--*/

	TraceFunctEnter( "CacheState::CheckIn" ) ;

	m_lock.ShareLock() ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	_ASSERT( IsMasterReference() ) ;

	long result = InterlockedExchangeAdd( (long*)&m_cRefs, -CLIENT_REF+1 ) - CLIENT_REF+1 ;

	DebugTrace( (DWORD_PTR)this, "pAlloc %x result %x", pAlloc, result ) ;

	_ASSERT( (result & CLIENT_BITS) >= 0 ) ;

	if( result == 0 ) {
		m_lock.ShareUnlock() ;
		if( !pAlloc )	{
			delete	this ;
		}	else	{
			Destroy(0) ;
			pAlloc->Free( this ) ;	
		}
	}	else	{
		//
		//	was this the last client reference ?
		//
		if( (result & CLIENT_BITS) == 0 )	{
			//
			//	Yes - go and put this in the modify queue !
			//
			LRUReference( m_pOwner ) ;
		}
		m_lock.ShareUnlock() ;
	}
	return	Release(pAlloc,0) ;
}

//
//	Keeping track of clients - Add a client ref !
//
long
CacheState::CheckOut(	
				class	CLRUList*	p,
				long	cClientRefs
				)	{
/*++

Routine Description :

	Add a reference to this piece of Cache State.
	Note - we distinguish different types of references -
	This is a reference from a CLIENT onto the item

Arguments :

	p -The LRU List managing this guys expiration
	cClientRefs - the number of refences to add

Return Value :

	Number of References

--*/

	//
	//	Must add a positive number of references !
	//
	_ASSERT( cClientRefs > 0 ) ;

	TraceFunctEnter( "CacheState::CheckOut" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	//_ASSERT( IsMasterReference() ) ;
	
	long	result = InterlockedExchangeAdd( (long*)&m_cRefs, CLIENT_REF*cClientRefs ) ;

	DebugTrace( (DWORD_PTR)this, "p %x result %x", p, result + (CLIENT_REF*cClientRefs) ) ;

	if( p ) {
		//
		//	Was this the first time this thing was checked out ?
		//
		if( (result & CLIENT_BITS) == 0 ) {
			//
			//	Yes - go and put this in the modify queue !
			//
			LRUReference( m_pOwner ) ;
		}
	}
	return	result + CLIENT_REF ;
}

//
//	Remove a reference - when we return 0 we're destroyed !
//
long
CacheState::Release(	class	CAllocatorCache	*pAlloc,
						void*	pv
						)	{
/*++

Routine Description :

	A cache is removing an item from the cache.
	This function will remove a client reference,
	and perform appropriate processing !

Arguments :

	pAlloc - the cache used to allocate and free
		ourselves

Return Value :

	Number of References
	if 0 then we've been destroyed !

--*/

	TraceFunctEnter( "CacheState::Release" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	long result = InterlockedDecrement( (long*)&m_cRefs ) ;


	DebugTrace( (DWORD_PTR)this, "pAlloc %x pv %x result %x", pAlloc, pv, result ) ;

	_ASSERT( !(result & 0x8000) ) ;
	if( result == 0 ) {
		if( !pAlloc )	{
			delete	this ;
		}	else	{
			Destroy(pv) ;
			pAlloc->Free( this ) ;	
		}
	}
	return	result ;
}

//
//	Provided to deal with failures during initialization of items
//	being insert into the cache - this function ensures that the
//	cache item ends up on the list for destruction !
//
void
CacheState::FailedCheckOut(	
				class	CLRUList*	p,
				long	cClientRefs,
				CAllocatorCache*	pAllocator,
				void*	pv
				)	{
/*++

Routine Description :

	Called after a failure has occurred when putting an item into
	the cache.  The item is referenced by the hash table but will end
	up not being referenced by clients.
	We removed a client reference if necessary, and we also put
	onto the LRU action list so that this thing eventually gets
	destroyed by expiration.

Arguments :

	p - the LRU list we should be on
	cClientRefs - Number of client references put on us !
	pAllocator - if NOT NULL then we can remove the final reference
		and destroy this thing !

Return Value :

	None.

--*/

	TraceFunctEnter( "CacheState::FailedCheckOut" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	_ASSERT( p != 0 ) ;
	_ASSERT( p==m_pOwner ) ;

	DebugTrace( (DWORD_PTR)this, "Args - p %x cClientRefs %x, pAllocator %x pv %x",
		p, cClientRefs, pAllocator, pv ) ;
	
	if( cClientRefs ) {
		long lSubtract = cClientRefs * CLIENT_REF ;
		long result = InterlockedExchangeAdd( (long*)&m_cRefs, -lSubtract ) - lSubtract;

		DebugTrace( (DWORD_PTR)this, "result %x", result ) ;

		_ASSERT( (result & CLIENT_BITS) == 0 ) ;
		_ASSERT( result != 0 ) ;
	}
	//
	//	Must not be checked out !
	//
	_ASSERT( !IsCheckedOut() ) ;
	//
	//	Should end up with only one reference - the hash table
	//	when failures occur !
	//
	_ASSERT( m_cRefs == 1 || m_cRefs == 2 ) ;

	if( pAllocator ) {
		long l = Release( pAllocator, pv ) ;
		DebugTrace( (DWORD_PTR)this, "l %x", l ) ;
		_ASSERT( l==0 ) ;
	}	else	{
		LRUReference( m_pOwner ) ;
	}
}


long
CacheState::ExternalCheckIn( ) {
/*++

Routine Description :

	This function exposes the check-in logic as
	used by people who aren't holding any cache locks

Arguments :

	NOne.

Return Value :

	Number of references.
	0 means we were destroyed shouldn't happen though !


--*/

	TraceFunctEnter( "CacheState::ExternalCheckIn" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	long	l = CheckIn( 0 ) ;	

	DebugTrace( (DWORD_PTR)this, "CheckIn results %x", l ) ;
	return	l ;
}


long
CacheState::ExternalCheckInNoLocks( ) {
/*++

Routine Description :

	This function exposes the check-in logic as
	used by people who aren't holding any cache locks

Arguments :

	NOne.

Return Value :

	Number of references.
	0 means we were destroyed shouldn't happen though !


--*/

	TraceFunctEnter( "CacheState::ExternalCheckInNoLocks" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	long	l = CheckInNoLocks( 0 ) ;	

	DebugTrace( (DWORD_PTR)this, "CheckIn results %x", l ) ;
	return	l ;
}


//
//	The following support functions are used to support manipulating
//	these objects in the various kinds of doubly linked lists we may reside in
//
//
BOOL
CacheState::FLockCandidate(	BOOL	fExpireChecks,
							FILETIME&	filetime,
							BOOL&	fToYoung
							) {
/*++

Routine Description :

	Figure out if this cache element could be deleted, and if so lock
	him up and return with the lock held !

Arguments :

	The expiration time !

Return Value :

	TRUE if the lock is held and this guy should be expired !

--*/

	TraceQuietEnter( "CacheState::FlockCandidate" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	fToYoung = FALSE ;

	m_lock.ExclusiveLock() ;

	BOOL	fReturn = TRUE ;
	if( fExpireChecks ) {
		fToYoung = !OlderThan( filetime ) ;
		fReturn &=
			m_lLRULock == 0 &&
			IsMasterReference() &&
			!IsCheckedOut() &&
			!fToYoung ;
	}

	if( fReturn )	{

		DebugTrace( (DWORD_PTR)this, "Item is a good candidate - get references!" ) ;

		REFSITER	refsiter( &m_ReferencesList ) ;
		while( !refsiter.AtEnd() ) {
			if( !refsiter.Current()->m_lock.TryExclusiveLock() )	{
				break ;
			}
			refsiter.Next() ;
		}
		//
		//	Try again later !
		//
		if( refsiter.AtEnd() ) {	
			if( !IsCheckedOut() ) {
			
				DebugTrace( (DWORD_PTR)this, "Item is TOTALLY Locked including all children!" ) ;

				return	TRUE ;
			}
		}

		//
		//	Undo our locks !
		//	
		refsiter.Prev() ;
		while(!refsiter.AtEnd() ) {
			refsiter.Current()->m_lock.ExclusiveUnlock() ;	
			refsiter.Prev() ;
		}
	}
	m_lock.ExclusiveUnlock() ;
	return	FALSE ;
}



BOOL
CacheState::FLockExpungeCandidate(	CacheState*&	pMaster	) {
/*++

Routine Description :

	This function is used when we are locking down a cache item that 
	is being considered for Expunge.  We cannot expunge items that do not
	master the cache item - so we have to be carefull in our locking.

Arguments :
	
	None.

Return Value :

	TRUE if this item is the Master Cache Entry, FALSE otherwise !

	NOTE: If this returns FALSE no locks are held !!!!!


--*/

	TraceFunctEnter( "CacheState::FlockExpungeCandidate" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;

	CacheState*	pExtraRef = 0 ;
	m_lock.ExclusiveLock() ;

	pMaster = GetMasterReference() ;
	if( pMaster == this ) {
	REFSITER	refsiter( &pMaster->m_ReferencesList ) ;
		while( !refsiter.AtEnd() ) {
			refsiter.Current()->m_lock.ExclusiveLock() ;
			refsiter.Next() ;
		}	
	}	else	{
		//
		//	We are not the master cache element - so there 
		//	must be another Cache Item somewhere that is, 
		//	and we must be in his list - let's try to find him !
		//
		_ASSERT( !m_ReferencesList.IsEmpty() ) ;
		//
		//	Acquire the Master's lock !
		//
		CacheState*	pMaster2 = pMaster ;
		//
		//	Did we add an extra reference to the master !
		//
		if( !pMaster->m_lock.TryExclusiveLock() )	{
			//
			//	Because the easy way of locking the Master failed, 
			//	we need to AddRef() and Release() him because once 
			//	we drop our lock, we have no idea of his lifetime !
			//
			pExtraRef = pMaster ;
			long l = pMaster->AddRef() ;
			DebugTrace( DWORD_PTR(pMaster), "Added Ref to %x result %x this %x", pMaster, l, this ) ;
			m_lock.ExclusiveUnlock() ;
			pMaster->m_lock.ExclusiveLock() ;
			m_lock.ExclusiveLock() ;
			pMaster2 = GetMasterReference() ;
			_ASSERT(	pMaster2 == pMaster || 
						pMaster2 == this 
						) ;

			//
			//	If the master has changed in this window, then 
			//	we must now be an isolated element !
			//
			if( pMaster2 != pMaster ) {
				_ASSERT( m_ReferencesList.IsEmpty() ) ;
				_ASSERT( pMaster2 == this ) ;
				pMaster->ExclusiveUnlock() ;
			}
			pMaster = pMaster2 ;
		}
	}
	//
	//	Check to see whether there is an extra reference that 
	//	now needs to be removed !
	//
	if( pExtraRef ) {
		long l = pExtraRef->Release(0,0) ;
		DebugTrace( DWORD_PTR(pExtraRef), "Removed temporary reference result %x pExtraRef %x this %x pMaster %x", 
			l, pExtraRef, this, pMaster ) ;
	}
	return	TRUE ;
}

void
CacheState::ReleaseLocks(	CacheState*	pMaster )	{
/*++

Routine Description : 

	Given a guy in the cache who has had all of his locks acquired exclusively
	we drop all of these locks !

Arguments : 

	None.

Return Value : 

	None.

--*/

	TraceFunctEnter("CacheState::ReleaseLocks" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;
	_ASSERT( GetMasterReference() == pMaster ) ;

	if( pMaster == this ) {
		REFSITER	refsiter( &m_ReferencesList ) ;
		while( !refsiter.AtEnd() ) {
			CacheState*	p = refsiter.Current() ;
			p->m_lock.ExclusiveUnlock() ;
			refsiter.Next() ;
		} ;
	}	else	{
		pMaster->m_lock.ExclusiveUnlock() ;
	}
	m_lock.ExclusiveUnlock() ;
}



//
//
//
void
CacheState::FinishCandidate(	CacheState*	pMaster	)	{
/*++

Routine Description :

	Given a guy in the cache who is prime for destruction - finish him off !

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter("CacheState::FinishCandidate" ) ;

	_ASSERT( pMaster == GetMasterReference() ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;

	//_ASSERT( !IsCheckedOut() ) ;
	//_ASSERT( m_lLRULock == 0 ) ;

	RemoveFromLRU() ;

	if( pMaster == this ) {
		REFSITER	refsiter( &m_ReferencesList ) ;
		while( !refsiter.AtEnd() ) {
			CacheState*	p = refsiter.RemoveItem() ;
			DebugTrace( (DWORD_PTR)this, "Remove item %x", p ) ;
			p->RemoveCacheReference( TRUE ) ;
			p->m_lock.ExclusiveUnlock() ;
			long l = Release(0, 0) ;
			DebugTrace( DWORD_PTR(this), "ref %x this %x removed %x", l, this, p ) ;
			_ASSERT( l > 0 ) ;
		} ;
	}	else	{
		//
		//	just remove ourselves from the list !
		//
		m_ReferencesList.RemoveEntry() ;
		RemoveCacheReference( FALSE ) ;
		pMaster->m_lock.ExclusiveUnlock() ;
		long	l = pMaster->Release( 0, 0 ) ;
		DebugTrace( DWORD_PTR(pMaster), "Removed ref from master %x result %x this %x", 
			pMaster, l, this ) ;
	}
		
	//
	//	Once we've finished this guy off, it's on it's way to its doom and should not go back into LRU lists !
	//
	m_pOwner = 0 ;
	m_lock.ExclusiveUnlock() ;
}


void
CacheState::RemoveFromLRU()	{
	m_LRUList.RemoveEntry() ;
}




//
//
//
void
CacheState::IsolateCandidate()	{
/*++

Routine Description :

	Given a guy in the cache who is prime for destruction - finish him off !

	This piece of CacheState may be either a duplicate 'Name' for the same 
	cacheitem, or the master name for the item.
	If we are a duplicate name then we need to isolate ourselves from the 
	master name !

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter("CacheState::IsolateCandidate" ) ;

	_ASSERT( m_dwSignature == CACHESTATE_SIGNATURE ) ;

	_ASSERT( !IsCheckedOut() ) ;
	//_ASSERT( m_lLRULock == 0 ) ;

	m_lock.ExclusiveLock() ;
	CacheState*	pMaster = GetMasterReference() ;

	_ASSERT( pMaster != 0 ) ;

	if( pMaster == 0 ) {

		_ASSERT( m_ReferencesList.IsEmpty() ) ;
		_ASSERT( m_LRUList.IsEmpty() ) ;

	}	else	{

		if( pMaster == this ) {
			//
			//	this list should be empty !
			//
			//_ASSERT( m_ReferencesList.IsEmpty() ) ;
			//
			//	Just in case, dump everything out !
			//
			REFSITER	refsiter( &m_ReferencesList ) ;
			while( !refsiter.AtEnd() ) {
				CacheState*	p = refsiter.RemoveItem() ;
				p->m_lock.ExclusiveLock() ;
				p->RemoveCacheReference( FALSE ) ;
				p->m_lock.ExclusiveUnlock() ;
				long l = pMaster->Release(0, 0) ;
				DebugTrace( (DWORD_PTR)this, "result %x Remove item %x", l, p ) ;
				_ASSERT( l > 0 ) ;
			} ;
		}	else	{
			//
			//	We are not the master cache element - so there 
			//	must be another Cache Item somewhere that is, 
			//	and we must be in his list - let's try to find him !
			//
			_ASSERT( !m_ReferencesList.IsEmpty() ) ;

			//
			//	Acquire the Master's lock !
			//
			CacheState*	pMaster2 = pMaster ;
			//
			//	Did we add an extra reference to the master !
			//
			CacheState*	pExtraRef = 0 ;
			if( !pMaster->m_lock.TryExclusiveLock() )	{
				//
				//	Because the easy way of locking the Master failed, 
				//	we need to AddRef() and Release() him because once 
				//	we drop our lock, we have no idea of his lifetime !
				//
				pExtraRef = pMaster ;
				long l = pMaster->AddRef() ;
				DebugTrace( DWORD_PTR(pMaster), "Added a ref to %x result %x this %x", pMaster, l, this ) ;
				m_lock.ExclusiveUnlock() ;
				pMaster->m_lock.ExclusiveLock() ;
				m_lock.ExclusiveLock() ;
				pMaster2 = GetMasterReference() ;
				_ASSERT(	pMaster2 == pMaster || 
							pMaster2 == this 
							) ;
			}
			//
			//	Now remove this element from the cache !
			//
			if( pMaster2 == pMaster ) {	
				m_ReferencesList.RemoveEntry() ;
				RemoveCacheReference( FALSE ) ;
				pMaster->m_lock.ExclusiveUnlock() ;
				long	l = pMaster2->Release( 0, 0 ) ;
				DebugTrace( DWORD_PTR(pMaster2), "REmoved ref from master %x result %x this %x", pMaster2, l, this ) ;
			}	else	{
				pMaster->ExclusiveUnlock() ;
				_ASSERT( pMaster2 != 0 ) ;
			}
			//
			//	Check to see whether there is an extra reference that 
			//	now needs to be removed !
			//
			if( pExtraRef ) {
				long l = pExtraRef->Release(0,0) ;
				DebugTrace( DWORD_PTR(pExtraRef), "Removed temp ref from pExtraRef %x result %x this %x, pMaster %x", 
					pExtraRef, l, this, pMaster ) ;
			}
		}
		m_LRUList.RemoveEntry() ;
	}
	m_lock.ExclusiveUnlock() ;
}


#ifdef	DEBUG
BOOL
CacheState::IsOlder(	FILETIME	filetimeIn,
						FILETIME&	filetimeOut
						) {
/*++

Routine Description  :

	Check that our entry is older than the incoming time -
	NOTE, we will grab the ShareLock on the entry so that nobody
	else touches the time !

Arguments :

	filetimeIn - The time that this should be older than
	filetimeOut - Gets our time if possible

Return Value :

	TRUE if we are older than the specified time !

--*/

	BOOL	fReturn = TRUE ;
	filetimeOut = filetimeIn ;

	m_lock.ShareLock() ;

//	if( m_pData ) {
		fReturn = OlderThan( filetimeIn ) ;
		filetimeOut = m_LastAccess ;
//	}

	m_lock.ShareUnlock() ;

	return	fReturn ;
}
#endif




typedef	TDListIterator<	LRULIST	>	LRUITER ;

CLRUList::CLRUList() :
	m_lqModify( FALSE ),
	m_cMaxElements( 0 ),
	m_dwAverageInserts( 0 ),
	m_cCheckedOut( 0 ), 
	m_cItems ( 0 )	{
/*++

Routine Description :

	Do very basic initialization of the LRU List.
	Much more needs to be done through our Init() function.
	
Arguments :

	None.

Return Value :

	None.

--*/
	//TraceFunctEnter( "CLRUList::CLRUList" ) ;

	m_qwExpire.QuadPart = 0 ;
}

void
CLRUList::Init(	DWORD	dwMaxInstances,
				DWORD	dwLifetimeSeconds
				)	{
/*++

Routine Description :

	Set up our member variables !
	
Arguments :

	None.

Return Value :

	None.

--*/


	m_cMaxElements = dwMaxInstances ;
	m_qwExpire.QuadPart = DWORDLONG(dwLifetimeSeconds) * DWORDLONG( 10000000 ) ;


}

		

void
CLRUList::AddWorkQueue( 	CacheState*	pbase ) {

	TraceFunctEnter( "CLRUList::AddWorkQueue" ) ;
	DebugTrace( (DWORD_PTR)this, "pbase %x", pbase ) ;

	_ASSERT( pbase->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;

	m_lqModify.Append( pbase ) ;

}

void
CLRUList::DrainWorkQueue()	{

	CacheState*	pbase = 0 ;
	while( (pbase = m_lqModify.Remove()) != 0 ) {
	
		_ASSERT( !pbase->InCache() ) ;
		_ASSERT( !pbase->IsInLRUList() ) ;
		_ASSERT(pbase->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;

		long l = pbase->Release( 0, 0 ) ;
		_ASSERT( l==0 ) ;
	}
}

//
//	This function examines each item in the Work Queue and does
//	appropriate processing !
//
void
CLRUList::ProcessWorkQueue(	CAllocatorCache*	pAllocatorCache, 
							LPVOID				lpv 
							)	{

	TraceQuietEnter( "CLRUList::ProcessWorkQueue" ) ;

	FILETIME	filetimeNow ;
	GetSystemTimeAsFileTime( &filetimeNow ) ;

	CacheState*	pbase = 0 ;
	while( (pbase = m_lqModify.Remove()) != 0 ) {
		//
		//	examine the LRU item - and take appropriate action !
		//
		pbase->m_lock.ShareLock() ;

		//
		//	NOW - check to see if the item has been removed from the hash table - 
		//	in which case we just release our reference and move on !
		//

		if( !pbase->InCache() )		{
			pbase->m_lock.ShareUnlock() ;
			long l = pbase->Release( pAllocatorCache, lpv ) ;
		}	else	{

			long l = pbase->Release( pAllocatorCache, lpv ) ;
			//
			//	If the item is still in the hash table this should not have released the last reference !!!
			//
			_ASSERT( l != 0 ) ;

			_ASSERT(pbase->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;


			BOOL	fOut = pbase->IsCheckedOut() ;
			BOOL	fLRU = pbase->IsInLRUList() ;

			DebugTrace( (DWORD_PTR)this, "pbase %x fOut %x fLRU %x", pbase, fOut, fLRU ) ;

			//
			//	There are 4 cases -
			//
			//                 in LRU   out LRU
			//	checked in        A        X
			//	checked out       X        B
			//
			//	A - remove item from LRU List
			//	B - put item in LRU list
			//	X - No work required !
			//
			if( fOut == fLRU ) {

				if( fLRU ) {
					//
					//	Remove Item from LRU list !
					//
					m_LRUList.Remove( pbase ) ;

				}	else	{
					//
					//	put item in LRU list !
					//
				
					pbase->m_LastAccess = filetimeNow ;

					m_LRUList.PushBack( pbase ) ;
					
				}
			}
			pbase->m_lLRULock = 0 ;
			pbase->m_lock.ShareUnlock() ;
			_ASSERT(pbase->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;
		}
	}


#ifdef	DEBUG	
		//
		//	Backwards iterator !
		//
		FILETIME	filetimeCur = filetimeNow ;
		LRUITER	iter( m_LRUList, FALSE ) ;	
		while( !iter.AtEnd() )	{
			FILETIME	filetimeNew ;
			_ASSERT( iter.Current()->IsOlder( filetimeCur, filetimeNew ) ) ;
			filetimeCur = filetimeNew ;
			iter.Prev() ;
		}
#endif

}

//
//
//
void
CLRUList::Expire(	
		CacheTable*	pTable,
		CAllocatorCache*	pCache,
		DWORD&	countExpired,
		void*	pv
		) {
/*++

Routine Description :

	This function expires items in the LRU List.
	We pick a bunch of guys to kick out of the cache.

Arguments :

	pTable - The object we use to manipulate locking
		and to remove items !
	countExpunged - Out parameter gets the number
		of items we've removed from the cache !

Return Value : 	

	None.

--*/

	TraceQuietEnter( "CLRUList::Expire" ) ;

	//DebugTrace( (DWORD_PTR)this, "Args - pTable %x pcache %x pv %x",
	//	pTable, pCache, pv ) ;

	countExpired = 0 ;

	//
	//	First get the list of candidates !
	//

	BOOL	fExpireChecks = TRUE ;

	LRULIST	list ;

	FILETIME	filetimeNow ;
	GetSystemTimeAsFileTime( &filetimeNow ) ;

	ULARGE_INTEGER	ulNow ;
	ulNow.LowPart = filetimeNow.dwLowDateTime ;
	ulNow.HighPart = filetimeNow.dwHighDateTime ;

	ulNow.QuadPart -= m_qwExpire.QuadPart ;

	filetimeNow.dwLowDateTime = ulNow.LowPart ;
	filetimeNow.dwHighDateTime = ulNow.HighPart ;

	CACHELOCK&	lock = pTable->GetLock() ;

	//
	//	First find the candidates !
	//
	lock.ExclusiveLock() ;

	//
	//	This will remove items from any list !
	//
	ProcessWorkQueue( pCache, pv ) ;

	{
		LRUITER	iter = m_LRUList ;	
		BOOL	fTerm = FALSE ;
		while( !iter.AtEnd() && !fTerm )	{
			CacheState*	pState = iter.Current() ;
			//DebugTrace( (DWORD_PTR)this, "Examining pState %x", pState ) ;
			_ASSERT(pState->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;
			BOOL	fLocked =  pState->FLockCandidate( fExpireChecks, filetimeNow, fTerm ) ;
			
			if( fExpireChecks ) {
				if( fTerm && m_cItems > (long)m_cMaxElements ) {
					fExpireChecks = FALSE ;
					fTerm = FALSE ;
				}
			}	else	{
				if( m_cItems <= (long)m_cMaxElements ) 
					fTerm = TRUE ;
			}

			if( fLocked )	{
				if( !pTable->RemoveEntry( pState ) )	{
					pState->m_lock.ExclusiveUnlock() ;
				}	else	{
					CacheState*	pTemp = iter.RemoveItem() ;
					_ASSERT( pTemp == pState ) ;
					_ASSERT(pState->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;
					list.PushFront( pTemp ) ;
					continue ;
				}
			}	
			iter.Next() ;
		}
	}

	lock.ExclusiveToPartial() ;

	LRUITER	iter = list ;
	while( !iter.AtEnd() ) {
		CacheState*	pState = iter.RemoveItem() ;
	
		//DebugTrace( (DWORD_PTR)this, "Destroying pState %x", pState ) ;

		_ASSERT(pState->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;
		//
		//	This entry has been removed from the cache -
		//	time to clean it up !
		//
		pState->FinishCandidate(pState) ;
		//
		//	This should remove the final reference !
		//
		long l = pState->Release( pCache, pv ) ;	
		_ASSERT( l==0 ) ;
	}
	lock.PartialUnlock() ;
}


BOOL
CLRUList::Empty(	
		CacheTable*	pTable,
		CAllocatorCache*	pCache,
		void*	pv
		) {
/*++

Routine Description :

	This function empties everything out of the cache !

Arguments :

	pTable - The object we use to manipulate locking
		and to remove items !

Return Value : 	

	None.

--*/

	TraceFunctEnter( "CLRUList::Empty" ) ;

	DebugTrace( (DWORD_PTR)this, "Args - pTable %x pcache %x pv %x",
		pTable, pCache, pv ) ;

	BOOL	fReturn = TRUE ;
	FILETIME	filetimeNow ;

	ZeroMemory( &filetimeNow, sizeof( filetimeNow ) ) ;

	//
	//	First get the list of candidates !
	//

	//
	//	This will remove items from any list !
	//
	ProcessWorkQueue( 0, 0 ) ;

	LRULIST	list ;

	{
		LRUITER	iter = m_LRUList ;	
		BOOL	fTerm = FALSE ;
		while( !iter.AtEnd() )	{
			CacheState*	pState = iter.Current() ;
			DebugTrace( (DWORD_PTR)this, "Examining pState %x", pState ) ;
			_ASSERT(pState->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;
			BOOL fLock = pState->FLockCandidate( FALSE, filetimeNow, fTerm ) ;

			_ASSERT( fLock ) ;

			if( fLock ) {
				if( !pTable->RemoveEntry( pState ) )	{
					fReturn = FALSE ;
					pState->m_lock.ExclusiveUnlock() ;
				}	else	{
					CacheState*	pTemp = iter.RemoveItem() ;
					_ASSERT( pTemp == pState ) ;
					_ASSERT(pState->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;
					list.PushFront( pTemp ) ;
					continue ;
				}
			}	
			iter.Next() ;
		}
	}

	LRUITER	iter = list ;
	while( !iter.AtEnd() ) {
		CacheState*	pState = iter.RemoveItem() ;
	
		DebugTrace( (DWORD_PTR)this, "Destroying pState %x", pState ) ;

		_ASSERT(pState->m_dwSignature == CacheState::CACHESTATE_SIGNATURE ) ;
		//
		//	This entry has been removed from the cache -
		//	time to clean it up !
		//
		pState->FinishCandidate(pState) ;
		//
		//	This should remove the final reference !
		//
		long l = pState->Release( pCache, pv ) ;	
		_ASSERT( l==0 ) ;
	}
	return	TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\cmmprops\cmmsprop.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cmmsprop.cpp

Abstract:

	This module contains the implementation of the special property class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	04/19/98	created

--*/

#include "windows.h"
#include <stdlib.h>
#include "dbgtrace.h"

#include "cmmsprop.h"

// =================================================================
// Implementation of CSpecialPropertyTable
//
int __cdecl CompareProperties(const void *pElem1, const void *pElem2)
{
	return(
		(((LPSPECIAL_PROPERTY_ITEM)pElem1)->idProp ==
		 ((LPSPECIAL_PROPERTY_ITEM)pElem2)->idProp) ?
		 0 :
			((((LPSPECIAL_PROPERTY_ITEM)pElem1)->idProp >
			((LPSPECIAL_PROPERTY_ITEM)pElem2)->idProp) ?
				1 : -1)
		);
}

CSpecialPropertyTable::CSpecialPropertyTable(
			LPPTABLE	pPropertyTable
			)
{
	_ASSERT(pPropertyTable);
	_ASSERT(pPropertyTable->pProperties);

	m_pProperties	= pPropertyTable->pProperties;
	m_dwProperties	= pPropertyTable->dwProperties;
	m_fIsSorted		= pPropertyTable->fIsSorted;
}

CSpecialPropertyTable::~CSpecialPropertyTable()
{
}

HRESULT CSpecialPropertyTable::GetProperty(
				PROP_ID		idProp,
				LPVOID		pContext,
				LPVOID		pParam,
				DWORD		ptBaseType,
				DWORD		cbLength,
				DWORD		*pcbLength,
				LPBYTE		pbBuffer,
				BOOL		fCheckAccess
				)
{
	HRESULT					hrRes	= S_OK;
	LPSPECIAL_PROPERTY_ITEM	pItem;

	TraceFunctEnterEx((LPARAM)this, "CSpecialPropertyTable::GetProperty");

	if (!pcbLength || !pbBuffer)
		return(E_POINTER);

	// Find the property
	pItem = SearchForProperty(idProp);

	// Found?
	if (pItem)
	{
		// Access check if applicable
		if (fCheckAccess && !(pItem->fAccess & PA_READ))
			hrRes = E_ACCESSDENIED;
		else
		{
			// Check the type
			if ((ptBaseType != PT_NONE) &&
				(ptBaseType != pItem->ptBaseType))
				hrRes = TYPE_E_TYPEMISMATCH;
			else
			{
				// Call the special get accessor
				hrRes = pItem->pfnGetAccessor(
							idProp,
							pContext,
							pParam,
							cbLength,
							pcbLength,
							pbBuffer);
			}
		}
	}
	else
		hrRes = S_FALSE;

	TraceFunctLeave();
	return(hrRes);
}

HRESULT CSpecialPropertyTable::PutProperty(
				PROP_ID		idProp,
				LPVOID		pContext,
				LPVOID		pParam,
				DWORD		ptBaseType,
				DWORD		cbLength,
				LPBYTE		pbBuffer,
				BOOL		fCheckAccess
				)
{
	HRESULT					hrRes	= S_OK;
	LPSPECIAL_PROPERTY_ITEM	pItem;

	TraceFunctEnterEx((LPARAM)this, "CSpecialPropertyTable::PutProperty");

	if (!pbBuffer)
		return(E_POINTER);

	// Find the property
	pItem = SearchForProperty(idProp);

	// Found?
	if (pItem)
	{
		// Access check if applicable
		if (fCheckAccess && !(pItem->fAccess & PA_WRITE))
			hrRes = E_ACCESSDENIED;
		else
		{
			// Check the type
			if ((ptBaseType != PT_NONE) &&
				(ptBaseType != pItem->ptBaseType))
				hrRes = TYPE_E_TYPEMISMATCH;
			else
			{
				// Call the special put accessor
				hrRes = pItem->pfnPutAccessor(
							idProp,
							pContext,
							pParam,
							cbLength,
							pbBuffer);
			}
		}
	}
	else
		hrRes = S_FALSE;

	TraceFunctLeave();
	return(hrRes);
}

LPSPECIAL_PROPERTY_ITEM CSpecialPropertyTable::SearchForProperty(
			PROP_ID	idProp
			)
{
	LPSPECIAL_PROPERTY_ITEM	pItem = NULL;

	TraceFunctEnter("CSpecialPropertyTable::SearchForProperty");

	// If the table is sorted, we do a bsearch, otherwise we do
	// a inear search
	if (m_fIsSorted)
	{
		SPECIAL_PROPERTY_ITEM	KeyItem;

		DebugTrace(NULL, "Property table is sorted");

		// Fill in the property name to look for
		KeyItem.idProp = idProp;

		// Bsearch
		pItem = (LPSPECIAL_PROPERTY_ITEM)bsearch(
						&KeyItem,
						m_pProperties,
						m_dwProperties,
						sizeof(SPECIAL_PROPERTY_ITEM),
						CompareProperties);
	}
	else
	{
		DWORD			i;
		LPSPECIAL_PROPERTY_ITEM pCurrentItem;

		DebugTrace(NULL, "Property table is not sorted");

		// Linear search
		pItem = NULL;
		for (i = 0, pCurrentItem = m_pProperties; 
				i < m_dwProperties; 
				i++, pCurrentItem++)
			if (pCurrentItem->idProp == idProp)
			{
				pItem = pCurrentItem;
				break;
			}
	}

	TraceFunctLeave();
	return(pItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\codepageconvert\codepageconvert.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 2000, Microsoft Corporation
//
// File: CodePageConvert.cpp
//
// Contents: Implementation of functions
// HrCodePageConvert
// HrCodePageConvert
// HrCodePageConvertFree
// HrCodePageConvertInternal
//
// History:
// aszafer  2000/03/15  created
//
//-------------------------------------------------------------

#include "CodePageConvert.h"
#include "dbgtrace.h"

//+------------------------------------------------------------
//
// Function: HrCodePageConvert
//
// Synopsis: Converts a zero terminated string to a different code page
//
// NOTES: 
//   caller needs to provide buffer where target string is returned
//
// Arguments:
//    uiSourceCodePage          Source Code Page
//    pszSourceString           Source String
//    uiTargetCodePage          Target Code Page
//    pszTargetString           p to prealloc buffer where target string is returned
//    cbTargetStringBuffer      cbytes of preallocated buffer for target string 
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY if dynamic allocation of an internal buffer fails
//  HRESULT_FROM_WIN32(GetLastError()) if Wide<->Multibyte calls fail
//  HRESULT_FROM_WIN32 (ERROR_INSUFFICIENT_BUFFER) if
//                      uiSourceCodePage = uiTargetCodePage and 
//                      cbTargetStringBuffer is too small
//         
// History:
// aszafer  2000/03/29  created
//
//-------------------------------------------------------------
HRESULT HrCodePageConvert (
    IN UINT uiSourceCodePage,           // Source code page
    IN LPSTR pszSourceString,           // Source String 
    IN UINT uiTargetCodePage,           // Target code page
    OUT LPSTR pszTargetString,          // p to buffer where target string is returned
    IN int cbTargetStringBuffer)       // cbytes in buffer for target string
{

    HRESULT hr = S_OK;

    TraceFunctEnter("HrCodePageConvert");

    _ASSERT(pszSourceString);
    _ASSERT(pszTargetString);
    _ASSERT(cbTargetStringBuffer);
    
    //
    // Take care of trivial cases first
    //
    if (uiTargetCodePage == uiSourceCodePage){
    
        if (pszTargetString == pszSourceString)
            goto CLEANUP ;

        if (lstrlen(pszSourceString) < cbTargetStringBuffer){

            lstrcpy(pszTargetString,pszSourceString);
 
        }else{

            DebugTrace(0,
             "Insufficient cbTargetStringBuffer = %08lx",cbTargetStringBuffer);
            hr = HRESULT_FROM_WIN32 (ERROR_INSUFFICIENT_BUFFER) ;

        }

        goto CLEANUP ;
    }


    //
    // If case is not trivial, call into HrCodePageConvertInternal
    //
    hr = HrCodePageConvertInternal (
            uiSourceCodePage,               // source code page
            pszSourceString,                // source string
            uiTargetCodePage,               // target code page
            pszTargetString,                // target string or NULL
            cbTargetStringBuffer,          // cb in target string or 0 
            NULL );                           // NULL or p to where target string is returned


    if (FAILED(hr))
        DebugTrace(0,"HrCodePageConvertInternal failed hr =  %08lx", hr);
   

CLEANUP:

   DebugTrace(0,"returning %08lx", hr);
   TraceFunctLeave();

    return hr;
}


//+------------------------------------------------------------
//
// Function: HrCodePageConvert
//
// Synopsis: Converts a zero terminated string to a different code page
//
// NOTES: 
//   1. if the fucntion succeeds, the caller needs to call 
//      HrCodePageConvertFree (*ppszTargetString) when done,
//      to free memory allocated inside this function
//   2. if the function fails, it will internally free all allocated memory
//
// Arguments:
//    uiSourceCodePage          Source Code Page
//    pszSourceString           Source String
//    uiTargetCodePage          Target Code Page
//    ppszTargetString          p to where to return target string
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY if dynamic allocation of an internal buffer fails
//  HRESULT_FROM_WIN32(GetLastError()) if Wide<->Multibyte calls fail
//         
// History:
// aszafer  2000/03/29  created
//
//-------------------------------------------------------------
HRESULT HrCodePageConvert (
    IN UINT uiSourceCodePage,           // Source code page
    IN LPSTR pszSourceString,           // Source string
    IN UINT uiTargetCodePage,           // Target code page
    OUT LPSTR * ppszTargetString)       // p to where target string is returned
{

    HRESULT hr = S_OK;
    LPSTR pszTargetString = NULL;
    
    TraceFunctEnter("HrCodePageConvert");

    _ASSERT(pszSourceString);
    _ASSERT(ppszTargetString);
    
    //
    // Take care of trivial cases first
    //
    if (uiTargetCodePage == uiSourceCodePage){
    
        pszTargetString = new CHAR[lstrlen(pszSourceString) + 1];
        if (pszTargetString == NULL) {

            hr = E_OUTOFMEMORY ;
            DebugTrace(0,"alloc for pszTargetString failed hr =  %08lx", hr);
            goto CLEANUP ;
        
        }      

        lstrcpy(pszTargetString,pszSourceString);
        *ppszTargetString = pszTargetString;
        goto CLEANUP ;
    }


    //
    // If case is not trivial, call into HrCodePageConvertInternal
    //
    hr = HrCodePageConvertInternal (
            uiSourceCodePage,               // source code page
            pszSourceString,                // source string
            uiTargetCodePage,               // target code page
            NULL,                             // target string or NULL
            0,                                // cb in target string or 0 
            ppszTargetString );             // NULL or p to where target string is returned


    if (FAILED(hr))
        DebugTrace(0,"HrCodePageConvertInternal failed hr =  %08lx", hr);
  
    
CLEANUP:
 
    DebugTrace(0,"returning %08lx", hr);
    TraceFunctLeave();

    return hr;
}

//+------------------------------------------------------------
//
// Function: HrCodePageConvertInternal
//
// Synopsis: Converts a zero terminated string to a different code page
//
// NOTES: 
//   pointers to Source and Target strings may be the same 
//
// Arguments:
//    uiSourceCodePage          Source Code Page
//    pszSourceString           Source String
//    uiTargetCodePage          Target Code Page
//
//    either: 
//    pszTargetString           p to buffer prealloc by caller where target string
//                              is returned
//    cbTargetStringBuffer      cbytes in prealloc buffer for target string
//    ppszTargetString          NULL,
//
//    or:
//    pszTargetString           NULL
//    cbTargetStringBuffer      0
//    ppszTargetString          p to where target string is to be returned
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY if dynamic allocation of an internal buffer fails
//  HRESULT_FROM_WIN32(GetLastError()) if Wide<->Multibyte calls fail
//         
// History:
// aszafer  2000/03/29  created
//
//-------------------------------------------------------------
HRESULT HrCodePageConvertInternal (
    IN UINT uiSourceCodePage,               // source code page
    IN LPSTR pszSourceString,               // source string
    IN UINT uiTargetCodePage,               // target code page
    OUT LPSTR pszTargetString,              // target string or NULL
    IN int cbTargetStringBuffer,           // cb in target string or 0 
    OUT LPSTR* ppszTargetString )           // NULL or p to where target string is returned
{

    HRESULT hr = S_OK;
    WCHAR wsz[TEMPBUFFER_WCHARS] ;
    int cwch = sizeof(wsz)/sizeof(WCHAR) ;
    WCHAR* pwsz = wsz ;
    CHAR* psz ;
    int iSourceStringLengh ; 
    int cch ;
    BOOL fAlloc1 = FALSE ;
    BOOL fAlloc2 = FALSE ;

    TraceFunctEnter("HrCodePageConvertInternal");

    _ASSERT(((pszTargetString != NULL) && (cbTargetStringBuffer != 0)) ||
            (ppszTargetString != NULL) );

    psz = pszTargetString;
    cch = cbTargetStringBuffer;
    
    //
    // If stack allocated temp buffer may not be sufficient
    // for unicode string, allocate from heap 
    //
    iSourceStringLengh = lstrlen(pszSourceString) + 1 ; //includes terminator
    if (iSourceStringLengh > TEMPBUFFER_WCHARS){
        //
        // Here we assume that each character in the source code page
        // can be represented by a single unicode character
        //
        cwch = iSourceStringLengh ;
        pwsz = new WCHAR[iSourceStringLengh];
        
        if (pwsz == NULL) {

            hr = E_OUTOFMEMORY ;
            DebugTrace(0,"alloc for pwsz failed hr =  %08lx", hr);
            goto CLEANUP ;    
        }    

        fAlloc1 = TRUE ;
    }
    
    //
    // Convert to unicode
    //
    cwch = MultiByteToWideChar(
                uiSourceCodePage,               // code page 
                0,                                // dwFlags
                pszSourceString,                // string to map
                -1 ,                              // number of bytes in string
                pwsz,                             // wide-character buffer
                cwch );                           // size of buffer

    if(cwch == 0) {
    
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugTrace(0,"MultiByteToWideChar2 failed hr =  %08lx", hr);
        _ASSERT(FAILED(hr));
        goto CLEANUP ;
    }

    //
    // If cbTargetStringBuffer == 0, allocate space for target string
    //
    if (cbTargetStringBuffer == 0){

        cch = WideCharToMultiByte(
                uiTargetCodePage,             // codepage 
                0,                              // dwFlags
                pwsz,                           // wide-character string
                cwch,                           // number of wchars in string
                NULL,                           // buffer for new string
                0,                              // size of buffer
                NULL,                           // default for unmappable chars
                NULL);                          // set when default char used

        if(cch == 0) {
        
            hr = HRESULT_FROM_WIN32(GetLastError());
            DebugTrace(0,"WideCharToMultiByte1 failed hr =  %08lx", hr);
            _ASSERT(FAILED(hr));
            goto CLEANUP ;
        } 


        psz = new CHAR[cch];
        if (psz == NULL) {
        
            hr = E_OUTOFMEMORY ;
            DebugTrace(0,"alloc for psz failed hr =  %08lx", hr);
            goto CLEANUP ;
        
        }
        fAlloc2 = TRUE ;
    }

    //
    // Convert to target code page
    //
    cch = WideCharToMultiByte(
                uiTargetCodePage,                     // codepage 
                0,                                      // dwFlags
                pwsz,                                   // wide-character string
                cwch,                                   // number of wchars in string
                psz,                                    // buffer for new string
                cch,                                    // size of buffer
                NULL,                                   // default for unmappable chars
                NULL);                                  // set when default char used

    if(cch == 0) {
    
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugTrace(0,"WideCharToMultiByte2 failed hr =  %08lx", hr);
        _ASSERT(FAILED(hr));
        goto CLEANUP ;
    }

    //
    // If target string had to be allocated, output pointer to it
    //
    if (cbTargetStringBuffer == 0)
        *ppszTargetString = psz ;

        
CLEANUP:

    if (fAlloc1)
        delete[] pwsz ;

    if (FAILED(hr)){

        if (fAlloc2)
            delete[] psz ;
     }
        
    DebugTrace(0,"returning %08lx", hr);
    TraceFunctLeave();

    return hr;
}

//+------------------------------------------------------------
//
// Function: HrCodePageConvertFree
//
// Synopsis: Use to free memory if HrCodePageConvert or HrCodePageConvertInternal
//           allocate buffer for target string
//
// Arguments:
//    pszTargetString           p to buffer to be freed
//
// History:
// aszafer  2000/03/29  created
//
//-------------------------------------------------------------
VOID HrCodePageConvertFree(LPSTR pszTargetString)
{
    _ASSERT(pszTargetString);

    delete pszTargetString;

}


//+------------------------------------------------------------
//
// Function: wcsutf8cmpi
//
// Synopsis: Compare a Unicode string to a UTF8 string and see
//           if they are identical
//
// Arguments: pwszStr1 - Unicode string
//            pszStr2 - UTF8 string
//
// Returns:   S_OK - identical
//            S_FALSE - different
//            E_* - error
//
//-------------------------------------------------------------
HRESULT wcsutf8cmpi(LPWSTR pwszStr1, LPCSTR pszStr2) {
    int rc;
    HRESULT hr;
    WCHAR wszStr2[TEMPBUFFER_WCHARS];
    LPWSTR pwszStr2 = wszStr2;
    DWORD cStr2;

    // convert string 2 to wide
    cStr2 = MultiByteToWideChar(CP_UTF8, 0, pszStr2, -1, pwszStr2, 0);
    if (cStr2 > (sizeof(wszStr2) / sizeof(WCHAR)) ) {
        pwszStr2 = new WCHAR[cStr2 + 1];
        if (pwszStr2 == NULL) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }
    rc = MultiByteToWideChar(CP_UTF8, 0, pszStr2, -1, pwszStr2, cStr2);
    if (rc == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // do the comparison
    rc = _wcsicmp(pwszStr1, pwszStr2);
    if (rc == 0) hr = S_OK; else hr = S_FALSE;

Exit:
    if (pwszStr2 != wszStr2) {
        delete[] pwszStr2;
    }
    
    return hr;
}



//+------------------------------------------------------------
//
// Function: CodePageConvertFree
//
// Synopsis: Free memory allocated in CodePageConvert
//
// Arguments:
//  pwszTargetString: Memory to free
//
// Returns: NOTHING
//
// History:
// jstamerj 2001/03/20 16:37:28: Created.
//
//-------------------------------------------------------------
VOID CodePageConvertFree(
    IN  LPWSTR pwszTargetString)
{
    delete [] pwszTargetString;
} // CodePageConvertFree



//+------------------------------------------------------------
//
// Function: HrConvertToUnicodeWithAlloc
//
// Synopsis: Convet an MBCS string to unicode (And allocate the
//           unicode string buffer)
//
// Arguments:
//  uiSourceCodePage: Source code page
//  pszSourceString: Source string
//  ppwszTargetString: Out parameter -- will be set to pointer to
//  allocated buffer.  This should be free'd with CodePageConvertFree
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  or error from MultiByteToWideChar
//
// History:
// jstamerj 2001/03/20 16:38:52: Created.
//
//-------------------------------------------------------------
HRESULT HrConvertToUnicodeWithAlloc(
    IN  UINT  uiSourceCodePage,
    IN  LPSTR pszSourceString,
    OUT LPWSTR* ppwszTargetString)
{
    return HrConvertToUnicodeWithAlloc(
        uiSourceCodePage,
        lstrlen(pszSourceString),
        pszSourceString,
        ppwszTargetString);
}

HRESULT HrConvertToUnicodeWithAlloc(
    IN  UINT  uiSourceCodePage,
    IN  DWORD dwcbSourceString,
    IN  LPSTR pszSourceString,
    OUT LPWSTR* ppwszTargetString)
{
    HRESULT hr = S_OK;
    int ich = 0;
    int ich2 = 0;
    LPWSTR pwszTmp = NULL;
    TraceFunctEnterEx((LPARAM)0, "HrConvertToUnicodeWithAlloc");

    ich = MultiByteToWideChar(
        uiSourceCodePage,
        0,
        pszSourceString,
        dwcbSourceString,
        NULL,
        0);
    if(ich == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM)0, "MultiByteToWideChar failed hr %08lx", hr);
        goto CLEANUP;
    }

    pwszTmp = new WCHAR[ich + 1];
    if(pwszTmp == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }

    ich2 = MultiByteToWideChar(
        uiSourceCodePage,
        0,
        pszSourceString,
        dwcbSourceString,
        pwszTmp,
        ich);
    if(ich2 == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM)0, "MultiByteToWideChar2 failed hr %08lx", hr);
        goto CLEANUP;
    }
    pwszTmp[ich] = '\0';
    //  
    // Success!
    //
    *ppwszTargetString = pwszTmp;

 CLEANUP:
    if(FAILED(hr))
    {
        if(pwszTmp)
            delete [] pwszTmp;
    }
    DebugTrace((LPARAM)0, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)0);
    return hr;
} // HrConvertToUnicodeWithAlloc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\crchash\crchash.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    crchash.cpp

Abstract:
	CRC Hash function
*/

//
//
// Hashing function adopted from the INN code (see copyright below)
//

/*
    Copyright 1988 Jon Zeeff (zeeff@b-tech.ann-arbor.mi.us)
    You can use this code in any manner, as long as you leave my name on it
    and don't hold me responsible for any problems with it.

 * This is a simplified version of the pathalias hashing function.
 * Thanks to Steve Belovin and Peter Honeyman
 *
 * hash a string into a long int.  31 bit crc (from andrew appel).
 * the crc table is computed at run time by crcinit() -- we could
 * precompute, but it takes 1 clock tick on a 750.
 *
 * This fast table calculation works only if POLY is a prime polynomial
 * in the field of integers modulo 2.  Since the coefficients of a
 * 32-bit polynomial won't fit in a 32-bit word, the high-order bit is
 * implicit.  IT MUST ALSO BE THE CASE that the coefficients of orders
 * 31 down to 25 are zero.  Happily, we have candidates, from
 * E. J.  Watson, "Primitive Polynomials (Mod 2)", Math. Comp. 16 (1962):
 *  x^32 + x^7 + x^5 + x^3 + x^2 + x^1 + x^0
 *  x^31 + x^3 + x^0
 *
 * We reverse the bits to get:
 *  111101010000000000000000000000001 but drop the last 1
 *         f   5   0   0   0   0   0   0
 *  010010000000000000000000000000001 ditto, for 31-bit crc
 *     4   8   0   0   0   0   0   0
 */

#include <windows.h>
#include "crchash.h"

static long CrcTable[128];
static BOOL bInitialized = FALSE;

/*
 - crcinit - initialize tables for hash function
 */
void crcinit()
{
    INT i, j;
    DWORD sum;

	if(bInitialized) return;

    for (i = 0; i < 128; ++i) {
        sum = 0;
        for (j = 7 - 1; j >= 0; --j) {
            if (i & (1 << j)) {
                sum ^= POLY >> j;
            }
        }
        CrcTable[i] = sum;
    }

	bInitialized = TRUE;
} // crcinit

/*
 - hash - Honeyman's nice hashing function
 */
DWORD CRCHash(const BYTE*	Key, DWORD Length)
{
    DWORD sum = 0;

    while ( Length-- ) {

        sum = (sum >> 7) ^ CrcTable[(sum ^ (*Key++)) & 0x7f];
    }
    return(sum);

}

/*
 - hash - Honeyman's nice hashing function
 */
DWORD CRCHashNoCase(const BYTE*	Key, DWORD Length)
{
    DWORD sum = 0;

    while ( Length-- ) {
        BYTE thisKey = (BYTE) tolower((char) (*Key++));
        sum = (sum >> 7) ^ CrcTable[(sum ^ thisKey) & 0x7f];
    }
    return(sum);

}



/*
 - hash - Honeyman's nice hashing function
 */
DWORD CRCHashWithPrecompute(	DWORD	sum,	const BYTE*	Key, DWORD Length)
{
    while ( Length-- ) {

        sum = (sum >> 7) ^ CrcTable[(sum ^ (*Key++)) & 0x7f];
    }
    return(sum);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\cstream\cstream.cpp ===
#define INC_OLE2
#include <windows.h>
#include <windowsx.h>
#include <cstream.h>
#include <dbgtrace.h>

#define Tracefn(fn)	

CImpIStream::CImpIStream(void)
{
	SYSTEMTIME st;

	Tracefn("CImpIStream::CImpIStream");
    m_cRef = 1;

	m_cbSeek = 0;
	m_statstg.cbSize.LowPart = 0;
	memset(&m_statstg,0,sizeof(STATSTG));

	GetSystemTime(&st);
	SystemTimeToFileTime(&st,&m_statstg.ctime);
}


CImpIStream::~CImpIStream(void)
{
	Tracefn("CImpIStream::~CImpIStream");
}

STDMETHODIMP CImpIStream::QueryInterface(
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppvObject)
{
	Tracefn("CImpIStream::QueryInterface");

	*ppvObject=NULL;

    if (IsEqualIID(riid, IID_IUnknown)
    	|| IsEqualIID(riid,IID_IStream))
        *ppvObject=(LPVOID)this;

	if( *ppvObject != NULL )
	{
        ((LPUNKNOWN)*ppvObject)->AddRef();
		return NOERROR;
	}

	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CImpIStream::AddRef(void)
{
	Tracefn("CImpIStream::AddRef");
    InterlockedIncrement(&m_cRef);
	return m_cRef;
}

STDMETHODIMP_(ULONG) CImpIStream::Release(void)
{
    ULONG cRefT;
	Tracefn("CImpIStream::Release");
    cRefT = InterlockedDecrement(&m_cRef);
    if( 0 == cRefT )
        delete this;
    return cRefT;
}

STDMETHODIMP CImpIStream::Read(
    void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbRead)
{
	Tracefn("CImpIStream::Read");
	return E_NOTIMPL;
}

STDMETHODIMP CImpIStream::Write(
    const void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
	Tracefn("CImpIStream::Write");
	return E_NOTIMPL;
}

STDMETHODIMP CImpIStream::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER __RPC_FAR *plibNewPosition)
{
	Tracefn("CImpIStream::Seek")
	return E_NOTIMPL;
}

STDMETHODIMP CImpIStream::SetSize(
    ULARGE_INTEGER libNewSize)
{
	Tracefn("CImpIStream::SetSize");
	return E_NOTIMPL;
}

STDMETHODIMP CImpIStream::CopyTo(
    IStream __RPC_FAR *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER __RPC_FAR *pcbRead,
    ULARGE_INTEGER __RPC_FAR *pcbWritten)
{
	Tracefn("CImpIStream::CopyTo");
	return E_NOTIMPL;
}


STDMETHODIMP CImpIStream::Commit(
    DWORD grfCommitFlags)
{
	Tracefn("CImpIStream::Commit");
	return S_OK;
}

STDMETHODIMP CImpIStream::Revert( void)
{
	Tracefn("CImpIStream::Revert");
	return E_NOTIMPL;
}

STDMETHODIMP CImpIStream::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
	Tracefn("CImpIStream::LockRegion");
	return E_NOTIMPL;
}

STDMETHODIMP CImpIStream::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
	Tracefn("CImpIStream::UnlockRegion");
	return E_NOTIMPL;
}

STDMETHODIMP CImpIStream::Stat(
    STATSTG __RPC_FAR *pstatstg,
    DWORD grfStatFlag)
{
	STATSTG * pstat = NULL;
	Tracefn("CImpIStream::Stat");

	if( !pstatstg )
		return STG_E_INVALIDPOINTER;

	memcpy(pstatstg,&m_statstg,sizeof(STATSTG));

	return NOERROR;
}

STDMETHODIMP CImpIStream::Clone(
    IStream __RPC_FAR *__RPC_FAR *ppstm)
{
	Tracefn("CImpIStream::Clone");
	return E_NOTIMPL;
}


/* -------------------------------------------------------------------------
CStreamMem
------------------------------------------------------------------------- */
CStreamMem::CStreamMem(void)
{
	Tracefn("CStreamMem::CStreamMem");
	m_pvData = NULL;
	m_fExternalData = FALSE;
}

CStreamMem::CStreamMem(PVOID pvData,ULONG cbSize)
{
	Tracefn("CStreamMem::CStreamMem");
	m_pvData = pvData;
	m_cbSeek = 0;
	m_statstg.cbSize.LowPart = cbSize;
	m_fExternalData = TRUE;
}

CStreamMem::~CStreamMem(void)
{
	Tracefn("CStreamMem::~CStreamMem");
	if( m_pvData && !m_fExternalData )
		free(m_pvData);				
}

STDMETHODIMP CStreamMem::GetPointerFromStream(PVOID *ppv,DWORD *pdwSize)
{
	HRESULT hr = NOERROR;

	if( NULL == ppv || NULL == pdwSize )
		return STG_E_INVALIDPOINTER;

	if( NULL != m_pvData )
	{
		*ppv = m_pvData;
		*pdwSize = m_statstg.cbSize.LowPart;			
	}
	else
	{
		*ppv = NULL;
		*pdwSize = 0;
	}
	return hr;
}


// IStream
STDMETHODIMP CStreamMem::Read(
	void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbRead)
{
	SYSTEMTIME st;
	ULONG cbRead = 0;
	Tracefn("CStreamMem::Read");

	if( pcbRead != NULL )
		*pcbRead = 0;

	_ASSERT(m_cbSeek <= m_statstg.cbSize.LowPart);

	// anything to do?
	if( cb == 0 || m_statstg.cbSize.LowPart == 0 || m_cbSeek == m_statstg.cbSize.LowPart )
		return NOERROR;

	// determine amount to copy
	cbRead = min(cb,m_statstg.cbSize.LowPart - m_cbSeek);

	if( cbRead > 0 )
	{
		// copy it
		CopyMemory(pv,(PBYTE)m_pvData + m_cbSeek,cbRead);

		// adjust seek pointer
		m_cbSeek += cbRead;
	}

	// update access time
	GetSystemTime(&st);
	SystemTimeToFileTime(&st,&m_statstg.atime);

	if( pcbRead != NULL )
		*pcbRead = cbRead;

	_ASSERT(m_cbSeek <= m_statstg.cbSize.LowPart);

	return NOERROR;
}

STDMETHODIMP CStreamMem::Write(
    const void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
	ULONG cbNewSize = 0;
	PVOID pvMem = NULL;
	SYSTEMTIME st;
	Tracefn("CStreamMem::Write");

	if( pcbWritten != NULL)
		*pcbWritten = 0;

	// external data is readonly
	if( m_fExternalData )
		return STG_E_MEDIUMFULL;

	// anything to do?
	if( cb == 0 )
		return NOERROR;

	// determine new size
	cbNewSize = max(m_cbSeek + cb, m_statstg.cbSize.LowPart);

	if( m_pvData == NULL )
	{
		// no memory alloc yet
		if( NULL == (m_pvData = malloc(cbNewSize)) )
			return STG_E_MEDIUMFULL;
		m_statstg.cbSize.LowPart = cbNewSize;
	}
	else if( cbNewSize > m_statstg.cbSize.LowPart )
	{
		// grow existing memory
		if( NULL == (pvMem = realloc(m_pvData,cbNewSize)) )
			return STG_E_MEDIUMFULL;
		m_pvData = pvMem;
		m_statstg.cbSize.LowPart = cbNewSize;
	}

	// copy mem
	CopyMemory((PBYTE)m_pvData + m_cbSeek,pv,cb);

	// adjust seek pointer
	m_cbSeek += cb;

	// set the number of bytes actually written
	m_statstg.cbSize.LowPart = max(m_statstg.cbSize.LowPart,m_cbSeek);

	// return bytes written
	if( pcbWritten != NULL)
		*pcbWritten = cb;

	// update modify time
	GetSystemTime(&st);
	SystemTimeToFileTime(&st,&m_statstg.mtime);

	return NOERROR;
}


STDMETHODIMP CStreamMem::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER __RPC_FAR *plibNewPosition)
{
	Tracefn("CStreamMem::Seek");
	// can we handle the seek?
	if( dlibMove.HighPart != 0 )
		return STG_E_WRITEFAULT;

	// handle the seek request
	switch( dwOrigin)
	{
		case STREAM_SEEK_SET:
			if( dlibMove.LowPart > m_statstg.cbSize.LowPart )
				return STG_E_WRITEFAULT;
			m_cbSeek = dlibMove.LowPart;
			break;
		case STREAM_SEEK_CUR:
			if( dlibMove.LowPart + m_cbSeek > m_statstg.cbSize.LowPart )
				return STG_E_WRITEFAULT;
			m_cbSeek += (int)dlibMove.LowPart;
			break;
		case STREAM_SEEK_END:
			if ((int)dlibMove.LowPart > 0 ||
				(ULONG)(-(int)dlibMove.LowPart) > m_statstg.cbSize.LowPart)
			{
				return STG_E_WRITEFAULT;
			}
			m_cbSeek = m_statstg.cbSize.LowPart + (int)dlibMove.LowPart;
			break;
	}

	// return new seek position
	if( plibNewPosition )
	{
		plibNewPosition->HighPart = 0;
		plibNewPosition->LowPart = m_cbSeek;
	}
	
	return NOERROR;
}

STDMETHODIMP CStreamMem::SetSize(
    ULARGE_INTEGER libNewSize)
{
	PVOID pvMem = NULL;
	Tracefn("CStreamMem::SetSize");

	// external data is readonly
	if( m_fExternalData )
		return STG_E_MEDIUMFULL;

	// can we handle the new size?
	if( libNewSize.HighPart != 0 )
		return STG_E_MEDIUMFULL;

	// alloc mem
	if( !m_pvData )
		pvMem = malloc(libNewSize.LowPart);
	else
		pvMem = realloc(m_pvData,libNewSize.LowPart);
	if( !pvMem )
		return STG_E_MEDIUMFULL;

	// save mem info
	m_pvData = pvMem;
	m_statstg.cbSize.LowPart = libNewSize.LowPart;

	// adjust the number of bytes actually written
	m_statstg.cbSize.LowPart = min(m_statstg.cbSize.LowPart,m_statstg.cbSize.LowPart);

	return NOERROR;
}

STDMETHODIMP CStreamMem::CopyTo(
    IStream __RPC_FAR *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER __RPC_FAR *pcbRead,
    ULARGE_INTEGER __RPC_FAR *pcbWritten)
{
	Tracefn("CStreamMem::CopyTo");
	HRESULT hr = NOERROR;
	ULONG cbBytes = 0;
	ULONG cbWritten = 0;

	if( pstm == NULL )
		return STG_E_INVALIDPOINTER;

	cbBytes = min(m_statstg.cbSize.LowPart - m_cbSeek,cb.LowPart);

	if( pcbRead )
		pcbRead->QuadPart = cbBytes;

	if( cbBytes == 0 )
		return NOERROR;

	hr = pstm->Write((PBYTE)m_pvData + m_cbSeek,cbBytes,&cbWritten);
	if( pcbWritten )
		pcbWritten->QuadPart = cbWritten;
	return hr;
}


/* -------------------------------------------------------------------------
CStreamFile
------------------------------------------------------------------------- */
CStreamFile::CStreamFile(HANDLE hFile,BOOL fCloseHandle, BOOL fReadOnly)
{
	Tracefn("CStreamFile::CStreamFile");
	_ASSERT(hFile != INVALID_HANDLE_VALUE);

	if( hFile == INVALID_HANDLE_VALUE )
		return;
	m_fCloseHandle = fCloseHandle;
	m_fReadOnly = fReadOnly;
	m_hFile = hFile;
	m_statstg.cbSize.LowPart = GetFileSize(m_hFile,NULL);
}

CStreamFile::~CStreamFile(void)
{
	Tracefn("CStreamFile::~CStreamFile");
	if( m_fCloseHandle && m_hFile != INVALID_HANDLE_VALUE )
		CloseHandle(m_hFile);
	m_hFile = INVALID_HANDLE_VALUE;
}

// IStream
STDMETHODIMP CStreamFile::Read(
	void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbRead)
{
	SYSTEMTIME st;
	Tracefn("CStreamFile::Read");

	if( m_hFile == INVALID_HANDLE_VALUE )
		return STG_E_INVALIDHANDLE;

	if( !pcbRead )
		return STG_E_INVALIDPOINTER;

	*pcbRead = 0;

	// anything to do?
	if( cb == 0 || m_statstg.cbSize.LowPart == 0 || m_cbSeek == m_statstg.cbSize.LowPart )
		return NOERROR;

	if( !ReadFile(m_hFile,pv,cb,pcbRead,NULL) )
		return HRESULT_FROM_WIN32(GetLastError());

	// adjust seek pointer
	m_cbSeek += *pcbRead;

	// update access time
	GetSystemTime(&st);
	SystemTimeToFileTime(&st,&m_statstg.atime);

	return NOERROR;
}

STDMETHODIMP CStreamFile::Write(
    const void __RPC_FAR *pv,
    ULONG cb,
    ULONG __RPC_FAR *pcbWritten)
{
	ULONG cbNewSize = 0;
	ULONG cbWritten = 0;
	PVOID pvMem = NULL;
	SYSTEMTIME st;

	Tracefn("CStreamFile::Write");

	if( m_hFile == INVALID_HANDLE_VALUE )
		return STG_E_INVALIDHANDLE;

	if (m_fReadOnly)
		return STG_E_MEDIUMFULL;

	if( pcbWritten != NULL )
		*pcbWritten = 0;

	// anything to do?
	if( cb == 0 )
		return NOERROR;

	if( !WriteFile(m_hFile,pv,cb,&cbWritten,NULL) )
		return HRESULT_FROM_WIN32(GetLastError());

	m_cbSeek += cbWritten;
	if( m_cbSeek > m_statstg.cbSize.LowPart )
	{
		m_statstg.cbSize.LowPart = m_cbSeek;
		if( !SetEndOfFile(m_hFile) )
			return HRESULT_FROM_WIN32(GetLastError());
	}
	
	if( pcbWritten != NULL )
		*pcbWritten = cbWritten;

	// update modify time
	GetSystemTime(&st);
	SystemTimeToFileTime(&st,&m_statstg.mtime);

	return NOERROR;
}


STDMETHODIMP CStreamFile::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER __RPC_FAR *plibNewPosition)
{
	Tracefn("CStreamFile::Seek");

	if( m_hFile == INVALID_HANDLE_VALUE )
		return STG_E_INVALIDHANDLE;

	// handle the seek request
	switch( dwOrigin)
	{
		case STREAM_SEEK_SET:
			m_cbSeek = dlibMove.LowPart;
			break;
		case STREAM_SEEK_CUR:
			m_cbSeek += (int)dlibMove.LowPart;
			break;
		case STREAM_SEEK_END:
			m_cbSeek = m_statstg.cbSize.LowPart + (int)dlibMove.LowPart;
			break;
	}

	// do seek
	if( -1L == SetFilePointer(m_hFile,m_cbSeek,NULL,FILE_BEGIN) )
		return HRESULT_FROM_WIN32(GetLastError());

	// return new seek position
	if( plibNewPosition )
	{
		plibNewPosition->HighPart = 0;
		plibNewPosition->LowPart = m_cbSeek;
	}

	return NOERROR;
}

STDMETHODIMP CStreamFile::SetSize(
    ULARGE_INTEGER libNewSize)
{
	Tracefn("CStreamFile::SetSize");
	HRESULT hr = NOERROR;

	if( m_hFile == INVALID_HANDLE_VALUE )
		return STG_E_INVALIDHANDLE;

	// can we handle the new size?
	if( libNewSize.HighPart != 0 )
		return STG_E_MEDIUMFULL;

	// seek to new end of file
	if( -1L == SetFilePointer(m_hFile,libNewSize.LowPart,NULL,FILE_BEGIN) )
		return HRESULT_FROM_WIN32(GetLastError());

	// set end of file
	if( !SetEndOfFile(m_hFile) )
	{
		// get the error
		hr = HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{
		// save new size.
		m_statstg.cbSize.LowPart = libNewSize.LowPart;
	}

	// restore seek pointer
	if( -1L == SetFilePointer(m_hFile,m_cbSeek,NULL,FILE_BEGIN) )
		hr = HRESULT_FROM_WIN32(GetLastError());

	return hr;
}

STDMETHODIMP CStreamFile::Commit(
    DWORD grfCommitFlags)
{
	Tracefn("CStreamFile::Commit");
	HRESULT hr = S_OK;
	if( m_hFile == INVALID_HANDLE_VALUE )
		return STG_E_INVALIDHANDLE;

	if(!FlushFileBuffers(m_hFile))
		hr = HRESULT_FROM_WIN32(GetLastError());
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\dbgdumpx\dbgdumpx.c ===
/*++

Copyright (c) 1990, 1998 Microsoft Corporation

Module Name:

    dbgdumpx.c
    *WAS* kdextlib.c

Abstract:

    Library routines for dumping data structures given a meta level descrioption

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:
    The implementation tends to avoid memory allocation and deallocation as much as possible.
    Therefore We have choosen an arbitrary length as the default buffer size. A mechanism will
    be provided to modify this buffer length through the debugger extension commands.

Revision History:

    11-Nov-1994 SethuR  Created
    19-April-1998 Mikeswa Modify for Exchange Platinum
    22-Sept-1998 Mikeswa moved to IIS
    22-July-1999 Mikeswa and back to platinum
    24-March-2000 Mikeswa and back to IIS

--*/

#include <windows.h>
#include <imagehlp.h>
#include <transdbg.h>
#include <dbgdumpx.h>
#include <stdlib.h>

char  *s_rgszMonth[ 12 ] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
};

char *s_rgszWeekDays[7] =
{
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};

char *NewLine  = "\n";
#define FIELD_NAME_LENGTH 30
char FieldIndent[5 + 2*FIELD_NAME_LENGTH] = "                                  ";

#define GET_STRUCT_VALUE(Type, pvStruct, Offset) \
    (*(Type *)(((char *)pvStruct) + Offset))

#define FIELD_BUFFER_SIZE 100

BOOL
kdextAtoi(
    LPSTR lpArg,
    int *pRet
);

int
kdextStrlen(
    LPSTR lpsz
);

int
kdextStrnicmp(
    LPSTR lpsz1,
    LPSTR lpsz2,
    int cLen
);


PWINDBG_OUTPUT_ROUTINE               g_lpOutputRoutine;
PWINDBG_GET_EXPRESSION               g_lpGetExpressionRoutine;
PWINDBG_GET_SYMBOL                   g_lpGetSymbolRoutine;
PWINDBG_READ_PROCESS_MEMORY_ROUTINE  g_lpReadMemoryRoutine;
HANDLE                               g_hCurrentProcess;

#define    NL      1
#define    NONL    0

#define DEFAULT_UNICODE_DATA_LENGTH 512
USHORT s_UnicodeStringDataLength = DEFAULT_UNICODE_DATA_LENGTH;
WCHAR  s_UnicodeStringData[DEFAULT_UNICODE_DATA_LENGTH];
WCHAR *s_pUnicodeStringData = s_UnicodeStringData;

#define DEFAULT_ANSI_DATA_LENGTH 512
USHORT s_AnsiStringDataLength = DEFAULT_ANSI_DATA_LENGTH;
CHAR  s_AnsiStringData[DEFAULT_ANSI_DATA_LENGTH];
CHAR *s_pAnsiStringData = s_AnsiStringData;

/*
 * Fetches the data at the given address
 */
BOOLEAN
GetDataEx( DWORD_PTR dwAddress, PVOID ptr, ULONG size, PULONG pBytesRead)
{
    BOOL b;
    SIZE_T BytesRead;

    if (pBytesRead)
        *pBytesRead = 0;

    b = KdExtReadMemory((LPVOID) dwAddress, ptr, size, &BytesRead );

    if (!pBytesRead && (BytesRead != size)) {
        return FALSE;
    }

    if (!b) {
        /* If we have an out param... try reading less */
        if (!pBytesRead || !size)
            return FALSE;

        /* maybe our buffer size is too big... try to read 1 byte */
        b = KdExtReadMemory((LPVOID) dwAddress, ptr, 1, &BytesRead );
        if (!b)
           return FALSE;

        /* Try to find the best size... this is useful for strings */
        while (!b && (--size > 0)) {
            b = KdExtReadMemory((LPVOID) dwAddress, ptr, size, &BytesRead );
        }
    }

    if (pBytesRead)
        *pBytesRead = (ULONG)BytesRead;

    return TRUE;
}

BOOLEAN
GetData( DWORD_PTR dwAddress, PVOID ptr, ULONG size)
{
   return GetDataEx(dwAddress, ptr, size, NULL);
}

/*
 * Displays a byte in hexadecimal
 */
VOID
PrintHexChar( UCHAR c )
{
    PRINTF( "%c%c", "0123456789abcdef"[ (c>>4)&7 ], "0123456789abcdef"[ c&7 ] );
}

/*
 * Displays a buffer of data in hexadecimal
 */
VOID
PrintHexBuf( PUCHAR buf, ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        PRINTF( " " );
    }
}

/*
 * Displays a unicode string
 */
BOOL
PrintStringW(LPSTR msg, PUNICODE_STRING puStr, BOOL nl )
{
    UNICODE_STRING UnicodeString;
    BOOLEAN        b;

    if( msg )
        PRINTF( msg );

    if( puStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    UnicodeString.Buffer        = s_pUnicodeStringData;
    UnicodeString.MaximumLength = s_UnicodeStringDataLength;
    UnicodeString.Length = (puStr->Length > s_UnicodeStringDataLength)
                            ? s_UnicodeStringDataLength
                            : puStr->Length;

    b = GetData((DWORD_PTR) puStr->Buffer, UnicodeString.Buffer, (ULONG) UnicodeString.Length);

    if (b)    {
        PRINTF("%wZ%s", &UnicodeString, nl ? "\n" : "" );
    }

    return b;
}

/*
 * Displays a ANSI string
 */
BOOL
PrintStringA(LPSTR msg, PANSI_STRING pStr, BOOL nl )
{
    ANSI_STRING AnsiString;
    BOOL        b;

    if( msg )
        PRINTF( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    AnsiString.Buffer        = s_pAnsiStringData;
    AnsiString.MaximumLength = s_AnsiStringDataLength;
    AnsiString.Length = (pStr->Length > (s_AnsiStringDataLength - 1))
                        ? (s_AnsiStringDataLength - 1)
                        : pStr->Length;

    b = KdExtReadMemory(
                (LPVOID) pStr->Buffer,
                AnsiString.Buffer,
                AnsiString.Length,
                NULL);

    if (b)    {
        AnsiString.Buffer[ AnsiString.Length ] = '\0';
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
    }

    return b;
}

/*
 * Displays a GUID
 */

BOOL
PrintGuid(
    GUID *pguid)
{
    ULONG i;

    PRINTF( "%08x-%04x-%04x", pguid->Data1, pguid->Data2, pguid->Data3 );
    for (i = 0; i < 8; i++) {
        PRINTF("%02x",pguid->Data4[i]);
    }
    return( TRUE );
}

/*
 * Displays a LARGE_INTEGER
 */

BOOL
PrintLargeInt(
    LARGE_INTEGER *bigint)
{
    PRINTF( "%08x:%08x", bigint->HighPart, bigint->LowPart);
    return( TRUE );
}

/*
 * Displays a DWORD size class signature
 */
BOOL
PrintClassSignature(
    CHAR * pch)
{
    PRINTF("0x%08X (%c%c%c%c)", *((DWORD *)pch), *(pch), *(pch+1), *(pch+2), *(pch+3));
    return( TRUE );
}

/*
 * Displays a standard LIST_ENTRY structure
 */
BOOL
PrintListEntry(DWORD_PTR dwAddress, CHAR * pch)
{
    PLIST_ENTRY pli = (PLIST_ENTRY) pch;
    LIST_ENTRY  liCurrent;
    PLIST_ENTRY pliCurrent = pli->Flink;
    DWORD       cEntries= 0;
    BOOL        fListOK = TRUE;

    //figure out how many entries there are
    while (pliCurrent != (PLIST_ENTRY) dwAddress)
    {
        cEntries++;
        if ((cEntries > 1000) ||
            !GetData((DWORD_PTR) pliCurrent, &liCurrent, sizeof(LIST_ENTRY)))
        {
            fListOK = FALSE;
            break;
        }
        pliCurrent = liCurrent.Flink;
    }

    PRINTF("0x%p ", dwAddress);
    if (fListOK)
        PRINTF("(%d entries)", cEntries);
    else
        PRINTF("(Unable to determine how many entries)");

    PRINTF(NewLine);
    PRINTF("%s    FLINK: 0x%p%s", FieldIndent, pli->Flink, NewLine);
    PRINTF("%s    BLINK: 0x%p", FieldIndent, pli->Blink);
    return( TRUE );
}


/*
 * Displays a human readable FILETIME
 */
BOOL PrintFileTime(FILETIME *pft, BOOL fLocalize)
{
    SYSTEMTIME	st;
    FILETIME ftDisplay = *pft;
    BOOL     fInit = TRUE;

    ZeroMemory(&st, sizeof(SYSTEMTIME));

    //Translate to local timezone if requested
    if (fLocalize)
        FileTimeToLocalFileTime(pft, &ftDisplay);

    //Only convert if non-zero
    if (!pft->dwLowDateTime && !pft->dwHighDateTime)
    {
        fInit = FALSE;
    }
    else if (!FileTimeToSystemTime(&ftDisplay, &st))
    {
        PRINTF("Unable to convert %08X %08X to a SYSTEMTIME - error %d",
            ftDisplay.dwLowDateTime,ftDisplay.dwHighDateTime, GetLastError());
        return FALSE;
    }

    if (fInit)
    {
        PRINTF("%s, %d %s %04d %02d:%02d:%02d %s",
            s_rgszWeekDays[st.wDayOfWeek],
            st.wDay, s_rgszMonth[ st.wMonth - 1 ],
            st.wYear, st.wHour, st.wMinute, st.wSecond,
            fLocalize ? "(localized)" : "");
    }
    else
    {
        PRINTF("FILETIME is zero");
    }
    return TRUE;
}

/*
 * Displays a the values of a bitmask
 */
BOOL
PrintBitMaskValues(
    DWORD BitMaskValue,
    FIELD_DESCRIPTOR *pFieldDescriptor)
{
    BOOL fFirstFlag;
    BIT_MASK_DESCRIPTOR *pBitMaskDescr;

    pBitMaskDescr = pFieldDescriptor->AuxillaryInfo.pBitMaskDescriptor;
    fFirstFlag = TRUE;
    if (pBitMaskDescr != NULL)
    {
        while (pBitMaskDescr->BitmaskName != NULL)
        {
            if (((BitMaskValue & pBitMaskDescr->BitmaskValue) ==
                  pBitMaskDescr->BitmaskValue) && //need to check all bits of bit mask
                //If descriptor value is 0.. it will always match any bit mask
                //it should only when the actual BitMaskValue is 0 as well
                (pBitMaskDescr->BitmaskValue || !BitMaskValue))
            {
                if (fFirstFlag)
                {
                    fFirstFlag = FALSE;
                    PRINTF("%s  ( %-s", FieldIndent, pBitMaskDescr->BitmaskName);
                }
                else
                {
                    PRINTF( " |\n" );
                    PRINTF("%s    %-s", FieldIndent, pBitMaskDescr->BitmaskName);
                }
            }
            pBitMaskDescr++;
        }
        PRINTF(" )");
        return TRUE;
    }
    return FALSE;
}

/*
 * Displays all the fields of a given struct. This is the driver routine that is called
 * with the appropriate descriptor array to display all the fields in a given struct.
 */

VOID
PrintStructFields( DWORD_PTR dwAddress, BYTE *ptr, FIELD_DESCRIPTOR *pFieldDescriptors, DWORD cIndentLevel)
{
    DWORD i,j;
    BYTE pbBuffer[FIELD_BUFFER_SIZE];
    DWORD BitMaskValue = 0;
    DWORD cbGetData = 0;
    CHAR  szTmpName[FIELD_NAME_LENGTH];

    //Make sure FieldIndent is correct
    for (j = 0; j < cIndentLevel%(FIELD_NAME_LENGTH/2); j++)
        lstrcat(FieldIndent, "  ");

    // Display the fields in the struct.
    for( i=0; pFieldDescriptors->Name; i++, pFieldDescriptors++ ) {

        // Indentation to begin the struct display.
        PRINTF( "    " );

        for (j = 0; j < cIndentLevel%(FIELD_NAME_LENGTH/2); j++)
            PRINTF("  "); //print 2 spaces for every indent level


        if( strlen( pFieldDescriptors->Name ) > FIELD_NAME_LENGTH ) {
            memcpy(szTmpName, pFieldDescriptors->Name, FIELD_NAME_LENGTH-3);
            szTmpName[FIELD_NAME_LENGTH-3] = '\0';
            PRINTF( "%s... ", szTmpName);
        } else {
            PRINTF( "%-30s ", pFieldDescriptors->Name );
        }

        switch( pFieldDescriptors->FieldType ) {
        case FieldTypeByte:
        case FieldTypeChar:
           PRINTF( "%-16d%s",
               *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ),
               NewLine );
           break;
        case FieldTypeBoolean:
           PRINTF( "%-16s%s",
               *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
               NewLine);
           break;
        case FieldTypeBool:
            PRINTF( "%-16s%s",
                *(BOOL *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
                NewLine);
            break;
        case FieldTypePointer:
            PRINTF( "@0x%p%s",
                *(DWORD_PTR *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLine );
            break;
        case FieldTypeLong:
            PRINTF( "%-16d%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLine );
            break;
        case FieldTypeULong:
        case FieldTypeDword:
            PRINTF( "%-16u%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLine );
            break;
        case FieldTypeShort:
            PRINTF( "%-16X%s",
                *(SHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLine );
            break;
        case FieldTypeUShort:
            PRINTF( "%-16X%s",
                *(USHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLine );
            break;
        case FieldTypeGuid:
            PrintGuid( (GUID *)(((char *)ptr) + pFieldDescriptors->Offset) );
            PRINTF( NewLine );
            break;
        case FieldTypePStr:  //pointer to a string
            if (GetDataEx(GET_STRUCT_VALUE(DWORD_PTR, ptr,
                pFieldDescriptors->Offset), pbBuffer, FIELD_BUFFER_SIZE, &cbGetData))
            {
                //make sure the string is terminated
                pbBuffer[FIELD_BUFFER_SIZE - 1] = '\0';
                PRINTF( "%s", (LPSTR) pbBuffer );
            }
            else if (!GET_STRUCT_VALUE(DWORD_PTR, ptr, pFieldDescriptors->Offset))
            {
                PRINTF( "<Null String>");
            }
            else
            {
                PRINTF("ERROR: Unable to read string a 0x%p",
                    GET_STRUCT_VALUE(DWORD_PTR, ptr, pFieldDescriptors->Offset));
            }
            PRINTF( NewLine );
            break;
        case FieldTypePWStr:
            if (GetDataEx(GET_STRUCT_VALUE(DWORD_PTR, ptr, pFieldDescriptors->Offset),
                pbBuffer, FIELD_BUFFER_SIZE, &cbGetData))
            {
                //make sure the string is terminated
                pbBuffer[FIELD_BUFFER_SIZE - 1] = '\0';
                pbBuffer[FIELD_BUFFER_SIZE - 2] = '\0';
                PRINTF( "%ws", (LPWSTR) pbBuffer );
            }
            else
            {
                PRINTF("ERROR: Unable to read string a 0x%p",
                    GET_STRUCT_VALUE(DWORD_PTR, ptr, pFieldDescriptors->Offset));
            }
            PRINTF( NewLine );
            break;
        case FieldTypeStrBuffer:  //member is a character array
            PRINTF( "%.100s%s", (CHAR *)(((char *)ptr) + pFieldDescriptors->Offset), NewLine);
            break;
        case FieldTypeWStrBuffer:
            PRINTF( "%.100ws%s", (WCHAR *)(((char *)ptr) + pFieldDescriptors->Offset), NewLine);
            break;
        case FieldTypeUnicodeString:
            PrintStringW( NULL, (UNICODE_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NONL );
            PRINTF( NewLine );
            break;
        case FieldTypeAnsiString:
            PrintStringA( NULL, (ANSI_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NONL );
            PRINTF( NewLine );
            break;
        case FieldTypeSymbol:
            {
                UCHAR SymbolName[ 200 ];
                ULONG_PTR Displacement;
                PVOID sym = (PVOID)(*(ULONG_PTR *)(((char *)ptr) + pFieldDescriptors->Offset ));

                g_lpGetSymbolRoutine( sym, SymbolName, &Displacement );
                PRINTF( "%-16s%s",
                        SymbolName,
                        NewLine );
            }
            break;
        case FieldTypeEnum:
            {
               ULONG EnumValue;
               ENUM_VALUE_DESCRIPTOR *pEnumValueDescr;
               // Get the associated numerical value.

               EnumValue = *((ULONG *)((BYTE *)ptr + pFieldDescriptors->Offset));

               if ((pEnumValueDescr = pFieldDescriptors->AuxillaryInfo.pEnumValueDescriptor)
                    != NULL) {
                   //
                   // An auxilary textual description of the value is
                   // available. Display it instead of the numerical value.
                   //

                   LPSTR pEnumName = NULL;

                   while (pEnumValueDescr->EnumName != NULL) {
                       if (EnumValue == pEnumValueDescr->EnumValue) {
                           pEnumName = pEnumValueDescr->EnumName;
                           break;
                       }
                       pEnumValueDescr++;
                   }

                   if (pEnumName != NULL) {
                       PRINTF( "%-16s ", pEnumName );
                   } else {
                       PRINTF( "%-4d (%-10s) ", EnumValue,"Unknown!");
                   }

               } else {
                   //
                   // No auxilary information is associated with the ehumerated type
                   // print the numerical value.
                   //
                   PRINTF( "%-16d",EnumValue);
               }
               PRINTF( NewLine );
            }
            break;

        case FieldTypeByteBitMask:
            BitMaskValue = GET_STRUCT_VALUE(BYTE, ptr, pFieldDescriptors->Offset);
            PRINTF("0x%02X ", (BYTE) BitMaskValue);
            PRINTF( NewLine );
            if (PrintBitMaskValues(BitMaskValue, pFieldDescriptors))
                PRINTF( NewLine );
            break;
        case FieldTypeWordBitMask:
            BitMaskValue = GET_STRUCT_VALUE(WORD, ptr, pFieldDescriptors->Offset);
            PRINTF("0x%04X ", (WORD) BitMaskValue);
            PRINTF( NewLine );
            if (PrintBitMaskValues(BitMaskValue, pFieldDescriptors))
                PRINTF( NewLine );
            break;
        case FieldTypeDWordBitMask:
            BitMaskValue = GET_STRUCT_VALUE(DWORD, ptr, pFieldDescriptors->Offset);
            PRINTF("0x%08X ", (DWORD) BitMaskValue);
            PRINTF( NewLine );
            if (PrintBitMaskValues(BitMaskValue, pFieldDescriptors))
                PRINTF( NewLine );
            break;
        case FieldTypeStruct:
            PRINTF( "@0x%p%s",
                (dwAddress + pFieldDescriptors->Offset ),
                NewLine );
            break;
        case FieldTypeLargeInteger:
            PrintLargeInt( (LARGE_INTEGER *)(((char *)ptr) + pFieldDescriptors->Offset) );
            PRINTF( NewLine );
            break;
        case FieldTypeClassSignature:
            PrintClassSignature(((char *)ptr) + pFieldDescriptors->Offset);
            PRINTF( NewLine );
            break;
        case FieldTypeListEntry:
            PrintListEntry(dwAddress + pFieldDescriptors->Offset,
                           ((char *)ptr) + pFieldDescriptors->Offset);
            PRINTF( NewLine );
            break;
        case FieldTypeLocalizedFiletime:
            PrintFileTime((FILETIME *) (((char *)ptr) + pFieldDescriptors->Offset), TRUE);
            PRINTF( NewLine );
            break;
        case FieldTypeFiletime:
            PrintFileTime((FILETIME *) (((char *)ptr) + pFieldDescriptors->Offset), FALSE);
            PRINTF( NewLine );
            break;
        case FieldTypeEmbeddedStruct:
            PRINTF( "Dumping %s@0x%p%s",
                ((STRUCT_DESCRIPTOR *) (pFieldDescriptors->AuxillaryInfo.pStructDescriptor))->StructName,
                dwAddress+ pFieldDescriptors->Offset, NewLine );
            PrintStructFields(dwAddress+pFieldDescriptors->Offset,
                              ((char *)ptr) + pFieldDescriptors->Offset,
                              ((STRUCT_DESCRIPTOR *) (pFieldDescriptors->AuxillaryInfo.pStructDescriptor))->FieldDescriptors,
                              cIndentLevel+1);
            break;
       default:
            PRINTF( "Unrecognized field type %d for %s\n", pFieldDescriptors->FieldType, pFieldDescriptors->Name );
            break;
        }
    }

    //Make sure FieldIndent is correct when we leave
    FieldIndent[lstrlen(FieldIndent)-(cIndentLevel%(FIELD_NAME_LENGTH/2))] = '\0';

}

LPSTR LibCommands[] = {
    "help -- This command ",
    "dump <Struct Type Name>@<address expr> ",
    0
};

PT_DEBUG_EXTENSION(_help)
{
    int i;

    SETCALLBACKS();

    PRINTF("\n");

    for( i=0; ExtensionNames[i]; i++ )
        PRINTF( "%s\n", ExtensionNames[i] );

    for( i=0; LibCommands[i]; i++ )
        PRINTF( "   %s\n", LibCommands[i] );

    for( i=0; Extensions[i]; i++) {
        PRINTF( "   %s\n", Extensions[i] );
    }

    return;
}

#define NAME_DELIMITER '@'
#define INVALID_INDEX 0xffffffff
#define MIN(x,y)  ((x) < (y) ? (x) : (y))

ULONG SearchStructs(LPSTR lpArgument)
{
    ULONG             i = 0;
    STRUCT_DESCRIPTOR *pStructs = Structs;
    ULONG             NameIndex = INVALID_INDEX;
    int               ArgumentLength = kdextStrlen(lpArgument);
    BOOLEAN           fAmbiguous = FALSE;


    while ((pStructs->StructName != 0)) {
        int StructLength;
        StructLength = kdextStrlen(pStructs->StructName);
        if (StructLength >= ArgumentLength) {
            int Result = kdextStrnicmp(
                            lpArgument,
                            pStructs->StructName,
                            ArgumentLength);

            if (Result == 0) {
                if (StructLength == ArgumentLength) {
                    // Exact match. They must mean this struct!
                    fAmbiguous = FALSE;
                    NameIndex = i;
                    break;
                } else if (NameIndex != INVALID_INDEX) {
                    // We have encountered duplicate matches. Print out the
                    // matching strings and let the user disambiguate.
                   fAmbiguous = TRUE;
                   break;
                } else {
                   NameIndex = i;
                }
            }
        }
        pStructs++;i++;
    }

    if (fAmbiguous) {
       PRINTF("Ambigous Name Specification -- The following structs match\n");
       PRINTF("%s\n",Structs[NameIndex].StructName);
       PRINTF("%s\n",Structs[i].StructName);
       while (pStructs->StructName != 0) {
           if (kdextStrnicmp(lpArgument,
                        pStructs->StructName,
                        MIN(kdextStrlen(pStructs->StructName),ArgumentLength)) == 0) {
               PRINTF("%s\n",pStructs->StructName);
           }
           pStructs++;
       }
       PRINTF("Dumping Information for %s\n",Structs[NameIndex].StructName);
    }

    return(NameIndex);
}

VOID DisplayStructs()
{
    STRUCT_DESCRIPTOR *pStructs = Structs;

    PRINTF("The following structs are handled .... \n");
    while (pStructs->StructName != 0) {
        PRINTF("\t%s\n",pStructs->StructName);
        pStructs++;
    }
}

PT_DEBUG_EXTENSION(_dump)
{
    DWORD_PTR dwAddress;
    BYTE *pDataBuffer = NULL;

    SETCALLBACKS();

    if( szArg && *szArg ) {
        // Parse the argument string to determine the structure to be displayed.
        // Scan for the NAME_DELIMITER ( '@' ).

        LPSTR lpName = (LPSTR) szArg;
        LPSTR lpArgs;
        ULONG Index;

        for (lpArgs = (LPSTR) szArg;
                *lpArgs != NAME_DELIMITER && *lpArgs != 0; lpArgs++) {
             ;
        }

        if (*lpArgs == NAME_DELIMITER) {
            //
            // The specified command is of the form
            // dump <name>@<address expr.>
            //
            // Locate the matching struct for the given name. In the case
            // of ambiguity we seek user intervention for disambiguation.
            //
            // We do an inplace modification of the argument string to
            // facilitate matching.
            //
            *lpArgs = '\0';

            Index = SearchStructs(lpName);

            //
            // Let us restore the original value back.
            //

            *lpArgs = NAME_DELIMITER;

            if (INVALID_INDEX != Index) {

                pDataBuffer = (BYTE *) LocalAlloc(0, Structs[Index].StructSize);
                if (!pDataBuffer)
                    return;

                //Eat up any extra @'s
                do {lpArgs++;} while ('@' == *lpArgs);

                dwAddress = (g_lpGetExpressionRoutine)( lpArgs );
                if (pDataBuffer &&
                    GetData(dwAddress,pDataBuffer,Structs[Index].StructSize)) {

                    PRINTF(
                        "++++++++++++++++ %s@0x%p ++++++++++++++++\n",
                        Structs[Index].StructName,
                        dwAddress);
                    PrintStructFields(
                        dwAddress,
                        pDataBuffer,
                        Structs[Index].FieldDescriptors, 0);
                    PRINTF(
                        "++++++++++++++++ size is %.10d bytes +++++++++++++++\n",
                        Structs[Index].StructSize);
                    PRINTF(
                        "---------------- %s@0x%p ----------------\n",
                        Structs[Index].StructName,
                        dwAddress);
                } else {
                    PRINTF("Error reading Memory @ %lx\n",dwAddress);
                }
            } else {
                // No matching struct was found. Display the list of
                // structs currently handled.

                DisplayStructs();
            }
        } else {
            //
            // The command is of the form
            // dump <name>
            //
            // Currently we do not handle this. In future we will map it to
            // the name of a global variable and display it if required.
            //

            DisplayStructs();
        }
    } else {
        //
        // display the list of structs currently handled.
        //

        DisplayStructs();
    }

    if (pDataBuffer)
        LocalFree(pDataBuffer);

    return;
}


PT_DEBUG_EXTENSION(_dumpoffsets)
{
    if( szArg && *szArg ) {

        LPSTR lpName = (LPSTR) szArg;
        LPSTR lpArgs = NULL;
        CHAR  chSave = '\0';
        FIELD_DESCRIPTOR *pFieldDescriptors = NULL;
        ULONG Index;

        for (lpArgs = (LPSTR) szArg;
                !isspace((UCHAR)*lpArgs) && *lpArgs != 0; lpArgs++) {
             ;
        }

        if (TRUE) {
            chSave = *lpArgs;
            *lpArgs = '\0';

            Index = SearchStructs(lpName);

            //
            // Let us restore the original value back.
            //

            *lpArgs = chSave;

            if (INVALID_INDEX != Index) {

                PRINTF(
                    "++++++++++++++++ %s ++++++++++++++++\n",
                    Structs[Index].StructName);
                for (pFieldDescriptors = Structs[Index].FieldDescriptors;
                     pFieldDescriptors && pFieldDescriptors->Name;
                     pFieldDescriptors++)
                {
                    PRINTF("\t0x%08X\t%s\n",
                    pFieldDescriptors->Offset, pFieldDescriptors->Name);
                }
                PRINTF(
                    "++++++++++++++++ size is %.10d bytes +++++++++++++++\n",
                    Structs[Index].StructSize);
                PRINTF(
                    "---------------- %s ----------------\n",
                    Structs[Index].StructName);
            } else {
                // No matching struct was found. Display the list of
                // structs currently handled.

                DisplayStructs();
            }
        } else {
            //
            // The command is of the form
            // dump <name>
            //
            // Currently we do not handle this. In future we will map it to
            // the name of a global variable and display it if required.
            //

            DisplayStructs();
        }
    } else {
        //
        // display the list of structs currently handled.
        //

        DisplayStructs();
    }

    return;
}
/*
 * KD Extensions should not link with the C-Runtime library routines. So,
 * we implement a few of the needed ones here.
 */

BOOL
kdextAtoi(
    LPSTR lpArg,
    int *pRet
)
{
    int n, cbArg, val = 0;
    BOOL fNegative = FALSE;

    cbArg = kdextStrlen( lpArg );

    if (cbArg > 0) {
        for (n = 0; lpArg[n] == ' '; n++) {
            ;
        }
        if (lpArg[n] == '-') {
            n++;
            fNegative = TRUE;
        }
        for (; lpArg[n] >= '0' && lpArg[n] <= '9'; n++) {
            val *= 10;
            val += (int) (lpArg[n] - '0');
        }
        if (lpArg[n] == 0) {
            *pRet = (fNegative ? -val : val);
            return( TRUE );
        } else {
            return( FALSE );
        }
    } else {
        return( FALSE );
    }

}

int
kdextStrlen(
    LPSTR lpsz
)
{
    int c;

    if (lpsz == NULL) {
        c = 0;
    } else {
        for (c = 0; lpsz[c] != 0; c++) {
            ;
        }
    }

    return( c );
}


#define UPCASE_CHAR(c)  \
    ( (((c) >= 'a') && ((c) <= 'z')) ? ((c) - 'a' + 'A') : (c) )

int
kdextStrnicmp(
    LPSTR lpsz1,
    LPSTR lpsz2,
    int cLen
)
{
    int nDif, i;

    for (i = nDif = 0; nDif == 0 && i < cLen; i++) {
        nDif = UPCASE_CHAR(lpsz1[i]) - UPCASE_CHAR(lpsz2[i]);
    }

    return( nDif );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\dnslib\dnsincs.h ===
#ifndef _DNSINCS_H_
#define _DNSINCS_H_

#define  INCL_INETSRV_INCS

#include <atq.h>
#include <dbgtrace.h>

#include <dns.h>
#include <dnsapi.h>
#include <time.h>

#include <rwnew.h>
#include <cpool.h>
#include <address.hxx>
#include "cdns.h"

// Definitions of functions/macros used in DNS library
#ifndef ARRAY_SIZE
#define ARRAY_SIZE(x) (sizeof(x)/sizeof(*x))
#endif

DWORD ResolveHost(
    LPSTR pszHost,
    PIP_ARRAY pipDnsServers,
    DWORD fOptions,
    DWORD *rgdwIpAddresses,
    DWORD *pcIpAddresses);

DWORD GetHostByNameEx(
    LPSTR pszHost,
    PIP_ARRAY pipDnsServers,
    DWORD fOptions,
    DWORD *rgdwIpAddresses,
    DWORD *pcIpAddresses);

DWORD ProcessCNAMEChain(
    PDNS_RECORD pDnsRecordList,
    LPSTR pszHost,
    LPSTR *ppszChainTail,
    DWORD *pdwIpAddresses,
    ULONG *pcIpAddresses);

DWORD GetCNAMEChainTail(
    PDNS_RECORD *rgCNAMERecord,
    ULONG cCNAMERecord,
    LPSTR pszHost,
    LPSTR *ppszChainTail);

void FindARecord(
    LPSTR pszHost,
    PDNS_RECORD pDnsRecordList,
    DWORD *rgdwIpAddresses,
    ULONG *pcIpAddresses);

DWORD MyDnsQuery(
    LPSTR pszHost,
    WORD wType,
    DWORD fOptions,
    PIP_ARRAY pipDnsServers,
    PDNS_RECORD *ppDnsRecordList);

int MyDnsNameCompare(
    LPSTR pszHost,
    LPSTR pszFqdn);

#define MAX_CNAME_RECORDS 5

#endif // _DNSINCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\dnslib\adns.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    send.c

Abstract:

    Domain Name System (DNS) Library

    Send response routines.

Author:

    Jim Gilroy (jamesg)     October, 1996

Revision History:

--*/

#include "dnsincs.h"

WORD    gwTransactionId = 1;

VOID
DnsCompletion(
    PVOID        pvContext,
    DWORD        cbWritten,
    DWORD        dwCompletionStatus,
    OVERLAPPED * lpo
    )
{
    BOOL WasProcessed = TRUE;
    CAsyncDns *pCC = (CAsyncDns *) pvContext;

    _ASSERT(pCC);
    _ASSERT(pCC->IsValid());

    //
    // if we could not process a command, or we were
    // told to destroy this object, close the connection.
    //
    WasProcessed = pCC->ProcessClient(cbWritten, dwCompletionStatus, lpo);
}

void DeleteDnsRec(PSMTPDNS_RECS pDnsRec)
{
    DWORD Loop = 0;
    PLIST_ENTRY  pEntry = NULL;
    PMXIPLIST_ENTRY pQEntry = NULL;

    if(pDnsRec == NULL)
    {
        return;
    }

    while (pDnsRec->DnsArray[Loop] != NULL)
    {
        if(pDnsRec->DnsArray[Loop]->DnsName[0])
        {
            while(!IsListEmpty(&pDnsRec->DnsArray[Loop]->IpListHead))
            {
                pEntry = RemoveHeadList (&pDnsRec->DnsArray[Loop]->IpListHead);
                pQEntry = CONTAINING_RECORD( pEntry, MXIPLIST_ENTRY, ListEntry);
                delete pQEntry;
            }

            delete pDnsRec->DnsArray[Loop];
        }
        Loop++;
    }

    if(pDnsRec)
    {
        delete pDnsRec;
        pDnsRec = NULL;
    }
}

CAsyncDns::CAsyncDns(void)
{
    m_signature = DNS_CONNECTION_SIGNATURE_VALID;            // signature on object for sanity check

    m_cPendingIoCount = 0;

    m_cThreadCount = 0;

    m_cbReceived = 0;
    
    m_BytesToRead = 0;

    m_dwIpServer = 0;

    m_dwFlags = 0;

    m_fUdp = TRUE;

    m_FirstRead = TRUE;

    m_pMsgRecv = NULL;
    m_pMsgRecvBuf = NULL;

    m_pMsgSend = NULL;
    m_pMsgSendBuf = NULL;
    m_cbSendBufSize = 0;
    
    m_pAtqContext = NULL;

    m_HostName [0] = '\0';

    m_pTcpRegIpList = NULL;
    m_fIsGlobalDnsList = FALSE;
}

CAsyncDns::~CAsyncDns(void)
{
    PATQ_CONTEXT pAtqContext = NULL;

    TraceFunctEnterEx((LPARAM)this, "CAsyncDns::~CAsyncDns");

    //
    // If we failed to connect to a DNS server, the following code attempts to
    // mark that DNS server down and fire off a query to another DNS server that
    // is marked UP.
    //

    if(m_pMsgSend)
    {
        delete [] m_pMsgSendBuf;
        m_pMsgSend = NULL;
        m_pMsgSendBuf = NULL;
    }

    if(m_pMsgRecv)
    {
        delete [] m_pMsgRecvBuf;
        m_pMsgRecv = NULL;
        m_pMsgRecvBuf = NULL;
    }

    //release the context from Atq
    pAtqContext = (PATQ_CONTEXT)InterlockedExchangePointer( (PVOID *)&m_pAtqContext, NULL);
    if ( pAtqContext != NULL )
    {
       AtqFreeContext( pAtqContext, TRUE );
    }

    m_signature = DNS_CONNECTION_SIGNATURE_FREE;            // signature on object for sanity check
}

BOOL CAsyncDns::ReadFile(
            IN LPVOID pBuffer,
            IN DWORD  cbSize /* = MAX_READ_BUFF_SIZE */
            )
{
    BOOL fRet = TRUE;

    _ASSERT(pBuffer != NULL);
    _ASSERT(cbSize > 0);

    ZeroMemory(&m_ReadOverlapped, sizeof(m_ReadOverlapped));

    m_ReadOverlapped.LastIoState = DNS_READIO;

    IncPendingIoCount();

    fRet = AtqReadFile(m_pAtqContext,      // Atq context
                        pBuffer,            // Buffer
                        cbSize,             // BytesToRead
                        (OVERLAPPED *)&m_ReadOverlapped) ;

    if(!fRet)
    {
        DisconnectClient();
        DecPendingIoCount();
    }

    return fRet;
}

BOOL CAsyncDns::WriteFile(
            IN LPVOID pBuffer,
            IN DWORD  cbSize /* = MAX_READ_BUFF_SIZE */
            )
{
    BOOL fRet = TRUE;

    _ASSERT(pBuffer != NULL);
    _ASSERT(cbSize > 0);

    ZeroMemory(&m_WriteOverlapped, sizeof(m_WriteOverlapped));
    m_WriteOverlapped.LastIoState = DNS_WRITEIO;

    IncPendingIoCount();

    fRet = AtqWriteFile(m_pAtqContext,      // Atq context
                        pBuffer,            // Buffer
                        cbSize,             // BytesToRead
                        (OVERLAPPED *) &m_WriteOverlapped) ;

    if(!fRet)
    {
        DisconnectClient();
        DecPendingIoCount();
    }

    return fRet;
}

DNS_STATUS
CAsyncDns::SendPacket(void)
{

    return 0;
}


//
//  Public send routines
//

DNS_STATUS
CAsyncDns::Dns_Send(
    )
/*++

Routine Description:

    Send a DNS packet.

    This is the generic send routine used for ANY send of a DNS message.

    It assumes nothing about the message type, but does assume:
        - pCurrent points at byte following end of desired data
        - RR count bytes are in HOST byte order

Arguments:

    pMsg - message info for message to send

Return Value:

    TRUE if successful.
    FALSE on send error.

--*/
{
    INT         err = 0;
    BOOL        fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncDns::Dns_Send");


    DebugTrace((LPARAM) this, "Sending DNS request for %s", m_HostName);

    fRet = WriteFile(m_pMsgSendBuf, (DWORD) m_cbSendBufSize);
    
    if(!fRet)
    {
        err = GetLastError();
    }

    return( (DNS_STATUS)err );

} // Dns_Send


//-----------------------------------------------------------------------------------
// Description:
//      Kicks off an async query to DNS.
//
// Arguments:
//      IN pszQuestionName - Name to query for.
//
//      IN wQuestionType - Record type to query for.
//
//      IN dwFlags - DNS configuration flags for SMTP. Currently these dictate
//          what transport is used to talk to DNS (TCP/UDP). They are:
//
//              DNS_FLAGS_NONE - Use UDP initially. If that fails, or if the
//                  reply is truncated requery using TCP.
//
//              DNS_FLAGS_TCP_ONLY - Use TCP only.
//
//              DNS_FLAGS_UDP_ONLY - Use UDP only.
//
//      IN MyFQDN - FQDN of this machine (for MX record sorting)
//
//      IN fUdp - Should UDP or TCP be used for this query? When dwFlags is
//          DNS_FLAGS_NONE the initial query is UDP, and the retry query, if the
//          response was truncated, is TCP. Depending on whether we're retrying
//          this flag should be set appropriately by the caller.
//
// Returns:
//      ERROR_SUCCESS if an async query was pended
//      Win32 error if an error occurred and an async query was not pended. All
//          errors from this function are retryable (as opposed NDR'ing the message)
//          so the message is re-queued if an error occurred.
//-----------------------------------------------------------------------------------
DNS_STATUS
CAsyncDns::Dns_QueryLib(
        IN      DNS_NAME            pszQuestionName,
        IN      WORD                wQuestionType,
        IN      DWORD               dwFlags,
        IN      BOOL                fUdp,
        IN      CDnsServerList      *pTcpRegIpList,
        IN      BOOL                fIsGlobalDnsList)
{
    DNS_STATUS      status = ERROR_NOT_ENOUGH_MEMORY;

    TraceFunctEnterEx((LPARAM) this, "CAsyncDns::Dns_QueryLib");

    _ASSERT(pTcpRegIpList);

    DNS_LOG_ASYNC_QUERY(
        pszQuestionName,
        wQuestionType,
        dwFlags,
        fUdp,
        pTcpRegIpList);

    m_dwFlags = dwFlags;

    m_fUdp = fUdp;

    m_pTcpRegIpList = pTcpRegIpList;

    m_fIsGlobalDnsList = fIsGlobalDnsList;

    lstrcpyn(m_HostName, pszQuestionName, sizeof(m_HostName));

    //
    //  build send packet
    //

    m_pMsgSendBuf = new BYTE[DNS_TCP_DEFAULT_PACKET_LENGTH ];

    if( NULL == m_pMsgSendBuf )
    {
        TraceFunctLeaveEx((LPARAM) this);
        return (DNS_STATUS) ERROR_NOT_ENOUGH_MEMORY;
    }

    DWORD dwBufSize = DNS_TCP_DEFAULT_PACKET_LENGTH ;
    
    
    if( !m_fUdp )
    {
        m_pMsgSend = (PDNS_MESSAGE_BUFFER)(m_pMsgSendBuf+2);
        dwBufSize -= 2;
    }
    else
    {
        m_pMsgSend = (PDNS_MESSAGE_BUFFER)(m_pMsgSendBuf);
    }

    if( !DnsWriteQuestionToBuffer_UTF8 ( m_pMsgSend,
                                      &dwBufSize,
                                         pszQuestionName,
                                      wQuestionType,
                                      gwTransactionId++,
                                      !( dwFlags & DNS_QUERY_NO_RECURSION ) ) )
    {
        DNS_PRINTF_ERR("Unable to create query message.\n");
        ErrorTrace((LPARAM) this, "Unable to create DNS query for %s", pszQuestionName);
        TraceFunctLeaveEx((LPARAM) this);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    m_cbSendBufSize = (WORD) dwBufSize;

    if( !m_fUdp )
    {
        *((u_short*)m_pMsgSendBuf) = htons((WORD)dwBufSize );
        m_cbSendBufSize += 2;
    }
    
    if (m_pMsgSend)
    {
        status = DnsSendRecord();
    }
    else
    {
        status = ERROR_INVALID_NAME;
    }

    TraceFunctLeaveEx((LPARAM) this);
    return status;
}

void CAsyncDns::DisconnectClient(void)
{
    SOCKET  hSocket;

    hSocket = (SOCKET)InterlockedExchangePointer( (PVOID *)&m_DnsSocket, (PVOID) INVALID_SOCKET );
    if ( hSocket != INVALID_SOCKET )
    {
       if ( QueryAtqContext() != NULL )
       {
            AtqCloseSocket(QueryAtqContext() , TRUE);
       }
    }
}

//
//  TCP routines
//

DNS_STATUS
CAsyncDns::Dns_OpenTcpConnectionAndSend()
/*++

Routine Description:

    Connect via TCP or UDP to a DNS server. The server list is held
    in a global variable read from the registry.

Arguments:

    None

Return Value:

    ERROR_SUCCESS on success
    Win32 error on failure

--*/
{
    INT     err = 0;
    DWORD   dwErrServList = ERROR_SUCCESS;
    BOOL    fThrottle = FALSE;

    TraceFunctEnterEx((LPARAM) this, "CAsyncDns::Dns_OpenTcpConnectionAndSend");

    //
    //  setup a TCP socket
    //      - INADDR_ANY -- let stack select source IP
    //
    if(!m_fUdp)
    {
        m_DnsSocket = Dns_CreateSocket(SOCK_STREAM);

        BOOL fRet = FALSE;

        //Alway enable linger so sockets that connect to the server.
        //This will send a hard close to the server which will cause
        //the servers TCP/IP socket table to be flushed very early.
        //We should see very few, if any, sockets in the TIME_WAIT
        //state
        struct linger Linger;

        Linger.l_onoff = 1;
        Linger.l_linger = 0;
        err = setsockopt(m_DnsSocket, SOL_SOCKET, SO_LINGER, (const char FAR *)&Linger, sizeof(Linger));

    }
    else
    {
        m_DnsSocket = Dns_CreateSocket(SOCK_DGRAM);    
    }

    if ( m_DnsSocket == INVALID_SOCKET )
    {
        err = WSAGetLastError();

        if ( !err )
        {
            err = WSAENOTSOCK;
        }

        ErrorTrace((LPARAM) this, "Received error %d opening a socket to DNS server", err);

        return( err );
    }


    m_RemoteAddress.sin_family = AF_INET;
    m_RemoteAddress.sin_port = DNS_PORT_NET_ORDER;

    //
    // Passing in fThrottle enables functionality in CTcpRegIpList to limit the
    // number of connections to servers on PROBATION (see ResetTimeoutServers...).
    // Throttling is disabled if Failover is disabled, because the tracking for
    // throttling is protocol (TCP/UDP) specific.
    //
    fThrottle = !FailoverDisabled();

    //
    // Get a working DNS server from the set of servers for this machine and
    // connect to it. The CTcpRegIpList has logic to keep track of the state
    // of DNS servers (UP or DOWN) and logic to retry DOWN DNS servers.
    //

    dwErrServList = GetDnsList()->GetWorkingServerIp(&m_dwIpServer, fThrottle);

    while(ERROR_SUCCESS == dwErrServList)
    {
        DNS_PRINTF_DBG("Connecting to DNS server %s over %s.\n",
                inet_ntoa(*((in_addr *)(&m_dwIpServer))), IsUdp() ? "UDP/IP" : "TCP/IP");

        m_RemoteAddress.sin_addr.s_addr = m_dwIpServer;
        err = connect(m_DnsSocket, (struct sockaddr *) &m_RemoteAddress, sizeof(SOCKADDR_IN));
        if ( !err )
        {
            DNS_PRINTF_MSG("Connected to DNS %s over %s.\n",
                inet_ntoa(*((in_addr *)(&m_dwIpServer))), IsUdp() ? "UDP/IP" : "TCP/IP");
            break;
        }
        else
        {
            DNS_PRINTF_ERR("Failed WinSock connect() to %s over %s, Winsock err - %d.\n",
                inet_ntoa(*((in_addr *)(&m_dwIpServer))), IsUdp() ? "UDP/IP" : "TCP/IP",
                WSAGetLastError());

            if(FailoverDisabled())
                break;

            GetDnsList()->MarkDown(m_dwIpServer, err, IsUdp());
            dwErrServList = GetDnsList()->GetWorkingServerIp(&m_dwIpServer, fThrottle);
            continue;
        }
    }

    if(!FailoverDisabled() &&
        (DNS_ERROR_NO_DNS_SERVERS == dwErrServList || ERROR_RETRY == dwErrServList))
    {
        //
        // If no servers are UP, just try a DOWN server. We must not simply
        // exit and ack the queue into retry in this situation. Consider the
        // case where all servers are DOWN. If we rely exclusively on GetWorking-
        // ServerIp(), then we will never try DNS till the retry time for the
        // DNS servers expires. Even if the admin kicks the queues, they will
        // go right back into retry because GetWorkingServerIp() will fail.
        //
        // Instead, if everything is DOWN, we will try SOMETHING by calling
        // GetAnyServerIp().
        //
        // -- If this fails, and ProcessClient gets the error ProcessClient
        // will try to failover to another DNS server. For this it calls
        // GetWorkingServerIp() which will fail, and the connection is acked
        // retry. Note that ProcessClient must not use GetAnyServerIp. If it
        // uses this function we are in danger of continuously looping trying
        // to spin connections to GetAnyServerIp.
        //
        // -- If the connection should fail in the connect below (for TCP/IP)
        // the failover logic is straightforward. We will simply ack the queue
        // to retry right away.
        //

        dwErrServList = GetDnsList()->GetAnyServerIp(&m_dwIpServer);
        if(DNS_ERROR_NO_DNS_SERVERS == dwErrServList)
        {
            // No configured servers error: this can happen if the serverlist
            // was deleted underneath us. Just fail the connection for now.
            DNS_PRINTF_ERR("No DNS servers available to query.\n");
            err = DNS_ERROR_NO_DNS_SERVERS;
            ErrorTrace((LPARAM) this, "No DNS servers. Error - %d", dwErrServList);
            return err;
        }

        m_RemoteAddress.sin_addr.s_addr = m_dwIpServer;
        err = connect(m_DnsSocket, (struct sockaddr *) &m_RemoteAddress, sizeof(SOCKADDR_IN));
    }

    _ASSERT(ERROR_SUCCESS == dwErrServList);

    //
    //  We have a connection to DNS
    //
    if(ERROR_SUCCESS == err)
    {
        // Re-associate the handle to the ATQ
        // Call ATQ to associate the handle
        if (!AtqAddAsyncHandle(
                        &m_pAtqContext,
                        NULL,
                        (LPVOID) this,
                        DnsCompletion,
                        30, // ATQ_TIMEOUT_INTERVAL
                        (HANDLE) m_DnsSocket))
        {
            return GetLastError();
        }

        //
        //  send desired packet
        //

        err = Dns_Send();
   }
   else
   {
       DNS_PRINTF_DBG("Unable to open a connection to a DNS server.\n");
       if(m_DnsSocket != INVALID_SOCKET)
       {
           closesocket(m_DnsSocket);
           m_DnsSocket = INVALID_SOCKET;
       }
   }

   return( (DNS_STATUS)err );

}   // Dns_OpenTcpConnectionAndSend

BOOL CAsyncDns::ProcessReadIO(IN      DWORD InputBufferLen,
                              IN      DWORD dwCompletionStatus,
                              IN      OUT  OVERLAPPED * lpo)
{
    BOOL fRet = TRUE;
    DWORD    DataSize = 0;
    DNS_STATUS DnsStatus = 0;
    PDNS_RECORD pRecordList = NULL;
    WORD wMessageLength = 0;

    TraceFunctEnterEx((LPARAM) this, "BOOL CAsyncDns::ProcessReadIO");

    //add up the number of bytes we received thus far
    m_cbReceived += InputBufferLen;

    //
    // read atleast 2 bytes
    //
    
    if(!m_fUdp && m_FirstRead && ( m_cbReceived < 2 ) )
    {
        fRet = ReadFile(&m_pMsgRecvBuf[m_cbReceived],DNS_TCP_DEFAULT_PACKET_LENGTH-1 );
        return fRet;
    }

    //
    // get the size of the message
    //
    
    if(!m_fUdp && m_FirstRead && (m_cbReceived >= 2))
    {
        DataSize = ntohs(*(u_short *)m_pMsgRecvBuf);

        //
        // add 2 bytes for the field which specifies the length of data
        //
        
        m_BytesToRead = DataSize + 2; 
        m_FirstRead = FALSE;
    }


    //
    // pend another read if we have n't read enough
    //
    
    if(!m_fUdp && (m_cbReceived < m_BytesToRead))
    {
        DWORD cbMoreToRead = m_BytesToRead - m_cbReceived;

        if(m_cbReceived + m_BytesToRead >= DNS_TCP_DEFAULT_PACKET_LENGTH)
        {
            ErrorTrace((LPARAM)this,
                "Size field in DNS packet is corrupt - %08x: ",
                DataSize);

            DNS_PRINTF_ERR("Reply packet from DNS server is corrupt.\n");
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }

        fRet = ReadFile(&m_pMsgRecvBuf[m_cbReceived], cbMoreToRead);
    }
    else
    {

        if( !m_fUdp )
        {
            //
            // message length is 2 bytes less to take care of the msg length
            // field.
            //
            //m_pMsgRecv->MessageLength = (WORD) m_cbReceived - 2;
            m_pMsgRecv = (PDNS_MESSAGE_BUFFER)(m_pMsgRecvBuf+2);
            
        }
        else
        {
            //m_pMsgRecv->MessageLength = (WORD) m_cbReceived;
            m_pMsgRecv = (PDNS_MESSAGE_BUFFER)m_pMsgRecvBuf;
        }
            

        SWAP_COUNT_BYTES(&m_pMsgRecv->MessageHead);
        //
        // We queried over UDP and the reply from DNS was truncated because the response
        // was longer than the UDP packet size. We requery DNS using TCP unless SMTP is
        // configured to use UDP only. RetryAsyncDnsQuery sets the members of this CAsyncDns
        // object appropriately depending on whether if fails or succeeds. After calling
        // RetryAsyncDnsQuery, this object must be deleted.
        //

        if(IsUdp() && !(m_dwFlags & DNS_FLAGS_UDP_ONLY) && m_pMsgRecv->MessageHead.Truncation)
        {
            //
            // Abort if we queried on TCP and got a truncated response. This is an illegal
            // response from DNS. If we don't abort we could loop forever.
            //

            if(m_dwFlags & DNS_FLAGS_TCP_ONLY)
            {
                DNS_PRINTF_ERR("Unexpected response. Reply packet had "
                    "truncation bit set, though query was over TCP/IP.\n");

                _ASSERT(0 && "Shouldn't have truncated reply over TCP");
                return FALSE;
            }
        
            DNS_PRINTF_MSG("Truncated UDP response. Retrying query over TCP.\n");

            DebugTrace((LPARAM) this, "Truncated reply - reissuing query using TCP");
            RetryAsyncDnsQuery(FALSE); // FALSE == Do not use UDP
            return FALSE;
        }

        wMessageLength = (WORD)( m_fUdp ? ( m_cbReceived ) : ( m_cbReceived - 2 ));

        DnsStatus = DnsExtractRecordsFromMessage_UTF8(m_pMsgRecv,
            wMessageLength, &pRecordList);

        DNS_LOG_RESPONSE(DnsStatus, pRecordList, (PBYTE)m_pMsgRecv, wMessageLength);
        DnsProcessReply(DnsStatus, pRecordList);
        DnsRecordListFree(pRecordList, TRUE);
    }

    TraceFunctLeaveEx((LPARAM) this);
    return fRet;
}

BOOL CAsyncDns::ProcessClient (IN DWORD InputBufferLen,
                               IN DWORD            dwCompletionStatus,
                               IN OUT  OVERLAPPED * lpo)
{
    BOOL    RetStatus = FALSE;
    DWORD dwDnsTransportError = ERROR_SUCCESS;

    TraceFunctEnterEx((LPARAM) this, "CAsyncDns::ProcessClient()");

    IncThreadCount();

    //if lpo == NULL, then we timed out. Send an appropriate message
    //then close the connection
    if( (lpo == NULL) && (dwCompletionStatus == ERROR_SEM_TIMEOUT))
    {
        dwDnsTransportError = ERROR_SEM_TIMEOUT;

        //
        // fake a pending IO as we'll dec the overall count in the
        // exit processing of this routine needs to happen before
        // DisconnectClient else completing threads could tear us down
        //
        IncPendingIoCount();
        DNS_PRINTF_ERR("Timeout waiting for DNS server response.\n");
        DebugTrace( (LPARAM)this, "Async DNS client timed out");
        DisconnectClient();
    }
    else if((InputBufferLen == 0) || (dwCompletionStatus != NO_ERROR))
    {
        dwDnsTransportError = ERROR_RETRY; 

        DebugTrace((LPARAM) this,
            "CAsyncDns::ProcessClient: InputBufferLen = %d dwCompletionStatus = %d"
            "  - Closing connection", InputBufferLen, dwCompletionStatus);

        DNS_PRINTF_ERR("Connection dropped by DNS server - Win32 error %d.\n",
            dwCompletionStatus);
        DisconnectClient();
    }
    else if (lpo == (OVERLAPPED *) &m_ReadOverlapped)
    {
        if(m_DnsSocket == INVALID_SOCKET && InputBufferLen > 0)
        {
            //
            // This is to firewall against an ATQ bug where we callback with an
            // nonzero InputBufferLen after the ATQ disconnect. We shouldn't be
            // doing further processing after this point.
            //

            ErrorTrace((LPARAM)this, "Connection already closed, callback should not occur"); 
        }
        else
        {
            //A client based async IO completed
            DNS_PRINTF_DBG("Response received from DNS server.\n");
            RetStatus = ProcessReadIO(InputBufferLen, dwCompletionStatus, lpo);
            if(!FailoverDisabled())
                GetDnsList()->ResetServerOnConnect(m_RemoteAddress.sin_addr.s_addr);
        }
    }
    else if(lpo == (OVERLAPPED *) &m_WriteOverlapped)
    {
        RetStatus = ReadFile(m_pMsgRecvBuf, DNS_TCP_DEFAULT_PACKET_LENGTH);
        if(!RetStatus)
        {
            DNS_PRINTF_ERR("Network error on connection to DNS server.\n");
            ErrorTrace((LPARAM) this, "ReadFile failed");
            dwDnsTransportError = ERROR_RETRY;
        }
    }

    DebugTrace((LPARAM)this,"ASYNC DNS - Pending IOs: %d", m_cPendingIoCount);

    // Do NOT Touch the member variables past this POINT!
    // This object may be deleted!

    //
    // decrement the overall pending IO count for this session
    // tracing and ASSERTs if we're going down.
    //

    DecThreadCount();

    if (DecPendingIoCount() == 0)
    {
        DisconnectClient();

        DebugTrace((LPARAM)this,"ASYNC DNS - Pending IOs: %d", m_cPendingIoCount);
        DebugTrace((LPARAM)this,"ASYNC DNS - Thread count: %d", m_cThreadCount);

        if(ERROR_SUCCESS != dwDnsTransportError && !FailoverDisabled())
        {
            GetDnsList()->MarkDown(QueryDnsServer(), dwDnsTransportError, IsUdp());
            RetryAsyncDnsQuery(IsUdp());
        }

        delete this;
    }

    return TRUE;
}


DNS_STATUS
CAsyncDns::DnsSendRecord()
/*++

Routine Description:

    Send message, receive response.

Arguments:

    aipDnsServers -- specific DNS servers to query;
        OPTIONAL, if specified overrides normal list associated with machine

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status = 0;

    m_pMsgRecvBuf = (BYTE*) new BYTE[DNS_TCP_DEFAULT_PACKET_LENGTH];

    if(m_pMsgRecvBuf == NULL)
    {
        return( DNS_ERROR_NO_MEMORY );        
    }


    status = Dns_OpenTcpConnectionAndSend();
    return( status );
}

SOCKET
CAsyncDns::Dns_CreateSocket(
    IN  INT         SockType
    )
/*++

Routine Description:

    Create socket.

Arguments:

    SockType -- SOCK_DGRAM or SOCK_STREAM

Return Value:

    socket if successful.
    Otherwise INVALID_SOCKET.

--*/
{
    SOCKET      s;

    //
    //  create socket
    //

    s = socket( AF_INET, SockType, 0 );
    if ( s == INVALID_SOCKET )
    {
        return INVALID_SOCKET;
    }

    return s;
}

//-----------------------------------------------------------------------------
//  Description:
//      Constructor and Destructor for class to maintain a list of IP addresses
//      (for DNS servers) and their state (UP or DOWN). The IP addresses are
//      held in an IP_ARRAY.
//-----------------------------------------------------------------------------
CDnsServerList::CDnsServerList()
{
    m_IpListPtr = NULL;

    //
    // Shortcut to quickly figure out how many servers are down. This keeps track
    // of how many servers are marked up currently. Used in ResetServersIfNeeded
    // primarily to avoid checking the state of all servers in the usual case when
    // all servers are up.
    //

    m_cUpServers = 0;
    m_prgdwFailureTick = NULL;
    m_prgServerState = NULL;
    m_prgdwFailureCount = NULL;
    m_prgdwConnections = NULL;
    m_dwSig = TCP_REG_LIST_SIGNATURE;
}

CDnsServerList::~CDnsServerList()
{
    if(m_IpListPtr)
        delete [] m_IpListPtr;

    if(m_prgdwFailureTick)
        delete [] m_prgdwFailureTick;

    if(m_prgServerState)
        delete [] m_prgServerState;

    if(m_prgdwFailureCount)
        delete [] m_prgdwFailureCount;

    if(m_prgdwConnections)
        delete [] m_prgdwConnections;

    m_IpListPtr = NULL;
    m_prgdwFailureTick = NULL;
    m_prgServerState = NULL;
    m_prgdwFailureCount = NULL;
    m_prgdwConnections = NULL;
}

//-----------------------------------------------------------------------------
//  Description:
//      Copies the the IP address list to m_IpListPtr by allocating a new block
//      of memory. If this fails due to out of memory, there's little we can do
//      so we just NULL out the server list and return FALSE indicating error.
//       
//  Arguments:
//      IpPtr - Ptr to IP_ARRAY of servers, this can be NULL in which case
//          we assume that there are no servers. On shutdown, the SMTP code
//          calls this with NULL.
//
//      This argument is copied.
//
//  Returns:
//      TRUE if the update succeeded.
//      FALSE if it failed.
//-----------------------------------------------------------------------------
BOOL CDnsServerList::Update(PIP_ARRAY IpPtr)
{
    BOOL fFatalError = FALSE;
    BOOL fRet = FALSE;
    DWORD cbIpArraySize = 0;

    TraceFunctEnterEx((LPARAM) this, "CDnsServerList::Update");

    m_sl.ExclusiveLock();

    if(m_IpListPtr)  {
        delete [] m_IpListPtr;
        m_IpListPtr = NULL;
    }

    if(m_prgdwFailureTick) {
        delete [] m_prgdwFailureTick;
        m_prgdwFailureTick = NULL;
    }

    if(m_prgServerState) {
        delete [] m_prgServerState;
        m_prgServerState = NULL;
    }

    if(m_prgdwConnections) {
        delete [] m_prgdwConnections;
        m_prgdwConnections = NULL;
    }

    // Note: IpPtr can be NULL
    if(IpPtr == NULL) {
        m_IpListPtr = NULL;
        m_cUpServers = 0;
        goto Exit;
    }

    // Copy the IpPtr
    cbIpArraySize = sizeof(IP_ARRAY) +
        sizeof(IP_ADDRESS) * (IpPtr->cAddrCount - 1);

    m_IpListPtr = (PIP_ARRAY)(new BYTE[cbIpArraySize]);
    if(!m_IpListPtr) {
        fFatalError = TRUE;
        goto Exit;
    }

    CopyMemory(m_IpListPtr, IpPtr, cbIpArraySize);

    m_cUpServers = IpPtr->cAddrCount;
    m_prgdwFailureTick = new DWORD[m_cUpServers];
    m_prgServerState = new SERVER_STATE[m_cUpServers];
    m_prgdwFailureCount = new DWORD[m_cUpServers];
    m_prgdwConnections = new DWORD[m_cUpServers];

    if(!m_prgdwFailureTick  ||
       !m_prgServerState    ||
       !m_prgdwFailureCount ||
       !m_prgdwConnections)
    {
        ErrorTrace((LPARAM) this, "Out of memory initializing DNS server list");
        fFatalError = TRUE;
        goto Exit;
    }

    for(int i = 0; i < m_cUpServers; i++) {
        m_prgdwFailureTick[i] = 0;
        m_prgServerState[i] = DNS_STATE_UP;
        m_prgdwFailureCount[i] = 0;
        m_prgdwConnections[i] = 0;
    }

    fRet = TRUE;

Exit:
    if(fFatalError) {
        if(m_prgServerState) {
            delete [] m_prgServerState;
            m_prgServerState = NULL;
        }

        if(m_prgdwFailureTick) {
            delete [] m_prgdwFailureTick;
            m_prgdwFailureTick = NULL;
        }

        if(m_IpListPtr) {
            delete [] m_IpListPtr;
            m_IpListPtr = NULL;
        }

        if(m_prgdwFailureCount) {
            delete [] m_prgdwFailureCount;
            m_prgdwFailureCount = NULL;
        }

        if(m_prgdwConnections) {
            delete [] m_prgdwConnections;
            m_prgdwConnections = NULL;
        }

        m_cUpServers = 0;
    }

    m_sl.ExclusiveUnlock();
    TraceFunctLeaveEx((LPARAM) this);
    return fRet;
}

//-----------------------------------------------------------------------------
//  Description:
//      Checks to see if the DNS serverlist has changed, and calls update only
//      if it has. This allows us to preserve the failure-counts and state
//      information if the serverlist has not changed.
//  Arguments:
//      IN PIP_ARRAY pipServers - (Possibly) new server-list
//  Returns:
//      TRUE if UpdateIfChanged was successful (does NOT indicate if list was
//          changed.
//      FALSE if we hit a failure during the update.
//-----------------------------------------------------------------------------
BOOL CDnsServerList::UpdateIfChanged(
    PIP_ARRAY pipServers)
{
    BOOL fUpdate = FALSE;
    BOOL fRet = TRUE;

    TraceFunctEnterEx((LPARAM) this, "CDnsServerList::UpdateIfChanged");

    m_sl.ShareLock();

    if(!m_IpListPtr && !pipServers) {

        // Both NULL, no update needed
        fUpdate = FALSE;

    } else if(!m_IpListPtr || !pipServers) {

        // If one is NULL but not the other, the update is needed
        fUpdate = TRUE;

    } else {

        // Both are non-NULL
        if(m_IpListPtr->cAddrCount != pipServers->cAddrCount) {

            // First check if the server count is different
            fUpdate = TRUE;

        } else {

            // If the servercount is identical, we can do a memcmp of the serverlist
            fUpdate = !!memcmp(m_IpListPtr->aipAddrs, pipServers->aipAddrs,
                            sizeof(IP_ADDRESS) * m_IpListPtr->cAddrCount);

        }
    }

    m_sl.ShareUnlock();

    if(fUpdate) {
        DebugTrace((LPARAM)this, "Updating serverlist");
        TraceFunctLeaveEx((LPARAM)this);
        return Update(pipServers);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

//-----------------------------------------------------------------------------
//  Description:
//      Creates a copy of m_IpListPtr and returns it to the caller. Note that
//      we cannot simply return m_IpListPtr, since that could change, so we
//      must return a copy of the list.
//  Arguments:
//      OUT PIP_ARRAY *ppipArray - The allocated copy is returned through this
//  Returns;
//      TRUE if a copy could be made successfully
//      FALSE if an error occurred (out of memory allocating copy).
//  Notes:
//      Caller must de-allocate copy by calling delete (MSVCRT heap).
//-----------------------------------------------------------------------------
BOOL CDnsServerList::CopyList(
    PIP_ARRAY *ppipArray)
{
    BOOL fRet = FALSE;
    ULONG cbArraySize = 0;
    
    TraceFunctEnterEx((LPARAM)this, "CDnsServerList::CopyList");
    *ppipArray = NULL;

    m_sl.ShareLock();
    if(!m_IpListPtr || m_IpListPtr->cAddrCount == 0) {
        fRet = FALSE;
        goto Exit;
    }

    cbArraySize =
            sizeof(IP_ARRAY) +
            sizeof(IP_ADDRESS) * (m_IpListPtr->cAddrCount - 1);

    *ppipArray = (PIP_ARRAY) new BYTE[cbArraySize];
    if(!*ppipArray) {
        fRet = FALSE;
        goto Exit;
    }

    CopyMemory(*ppipArray, m_IpListPtr, cbArraySize);
    fRet = TRUE;

Exit:
    m_sl.ShareUnlock();
    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

//-----------------------------------------------------------------------------
//  Description:
//      Return the IP address of a server known to be UP. This function also
//      checks to see if any servers currently marked DOWN should be reset to
//      the UP state again (based on a retry interval).
//  Arguments:
//      DWORD *pdwIpServer - Sets the DWORD pointed to, to the IP address of
//          a server in the UP state.
//      BOOL fThrottle - Connections to a failing server are restricted. We do
//          not want to spin off hundreds of async DNS queries to a server
//          that may actually be unreachable or down. If a server is
//          suspiciously non-responsive, we will want to spin off a limited
//          number of connections to it. If all of them fail we will mark the
//          connection as DOWN, and if one of them succeeds, we will mark the
//          server UP. The number of connections to a server is throttled if
//          it is in the DNS_STATUS_PROBATION state. ResetTimeoutServers...
//          sets this state.
//  Returns:
//      ERROR_SUCCESS - If a DNS server in the UP state was found
//      ERROR_RETRY - If all DNS servers are currently DOWN or in PROBATION
//          and the MAX number of allowed connections for PROBATION servers
//          has been reached.
//      DNS_ERROR_NO_DNS_SERVERS - If no DNS servers are configured
//-----------------------------------------------------------------------------
DWORD CDnsServerList::GetWorkingServerIp(DWORD *pdwIpServer, BOOL fThrottle)
{
    DWORD dwErr = ERROR_RETRY;
    int iServer = 0;

    _ASSERT(pdwIpServer != NULL);

    *pdwIpServer = INADDR_NONE;

    // Check if any servers were down and bring them up if the timeout has expired
    ResetTimeoutServersIfNeeded();

    m_sl.ShareLock();
    if(m_IpListPtr == NULL || m_IpListPtr->cAddrCount == 0) {
        dwErr = DNS_ERROR_NO_DNS_SERVERS;
        goto Exit;
    }

    if(m_cUpServers == 0) {
        dwErr = ERROR_RETRY;
        goto Exit;
    }

    for(iServer = 0; iServer < (int)m_IpListPtr->cAddrCount; iServer++) {

        if(m_prgServerState[iServer] != DNS_STATE_DOWN) {

            if(fThrottle && !AllowConnection(iServer))
                continue;

            dwErr = ERROR_SUCCESS;
            *pdwIpServer = m_IpListPtr->aipAddrs[iServer];
            break;
        }
    }

Exit:
    m_sl.ShareUnlock();
    return dwErr;
}

//-----------------------------------------------------------------------------
//  Description:
//      Marks a server in the list as down and sets the next retry time for
//      that server. The next retry time is calculated modulo MAX_TICK_COUNT.
//  Arguments:
//      dwIp -- IP address of server to mark as DOWN
//      dwErr -- Error from DNS or network
//      fUdp -- TRUE if protocol used was UDP, FALSE if TCP
//-----------------------------------------------------------------------------
void CDnsServerList::MarkDown(
    DWORD dwIp,
    DWORD dwErr,
    BOOL fUdp)
{
    int iServer = 0;
    DWORD cUpServers = 0;

    //
    // Set to TRUE only when a server is actually marked DOWN. For instance,
    // we've failed < ErrorsBeforeFailover() times, there's no need to
    // log an event in MarkDown.
    //
    BOOL fLogEvent = FALSE; 

    TraceFunctEnterEx((LPARAM) this, "CDnsServerList::MarkDown");

    m_sl.ExclusiveLock();

    DNS_PRINTF_DBG("Marking DNS server %s as down.\n",
        inet_ntoa(*((in_addr *)(&dwIp))));

    if(m_IpListPtr == NULL || m_IpListPtr->cAddrCount == 0 || m_cUpServers == 0)
        goto Exit;

    // Find the server to mark as down among all the UP servers
    for(iServer = 0; iServer < (int)m_IpListPtr->cAddrCount; iServer++) {
        if(m_IpListPtr->aipAddrs[iServer] == dwIp)
            break;
    }

    if(iServer >= (int)m_IpListPtr->cAddrCount ||
            m_prgServerState[iServer] == DNS_STATE_DOWN)
        goto Exit;


    //
    // A DNS server is not marked down till it has failed a number of times
    // consecutively. This protects against occasional errors from DNS servers
    // which can occur under heavy load. Even if 0.5% of connections have
    // errors from DNS - on a heavily stressed server, with say 100 DNS queries
    // per minute, we would end up with a server going down every 2 mins.
    //

    m_prgdwFailureCount[iServer]++;

    if(m_prgdwConnections[iServer] > 0)
        m_prgdwConnections[iServer]--;

    if(m_prgdwFailureCount[iServer] < ErrorsBeforeFailover()) {

        ErrorTrace((LPARAM) this,
            "%d consecutive errors connecting to server %08x, error=%d", 
            m_prgdwFailureCount[iServer], dwIp, dwErr);

        goto Exit;
    }

    // Mark server down
    m_prgServerState[iServer] = DNS_STATE_DOWN;
    m_prgdwConnections[iServer] = 0;

    _ASSERT(m_cUpServers > 0);
    m_cUpServers--;
    m_prgdwFailureTick[iServer] = GetTickCount();

    fLogEvent = TRUE;

Exit:
    cUpServers = m_cUpServers;
    m_sl.ExclusiveUnlock();

    // Log events outside the ExclusiveLock()
    if(fLogEvent)
        LogServerDown(dwIp, fUdp, dwErr, cUpServers);

    TraceFunctLeaveEx((LPARAM) this);
    return;
}

//-----------------------------------------------------------------------------
//  Description:
//      If a server has been failing, we keep track of the number of
//      consecutive failures in m_prgdwFailureCount. This function is called
//      when we successfully connect to the server and we want to reset the
//      failure count.
//  Arguments:
//      dwIp - IP Address of server to reset failure count for
//  Note:
//      This function is called for every successful query so it needs to be
//      kept simple and quick especially in the usual case - when there is no
//      Reset to be done.
//-----------------------------------------------------------------------------
void CDnsServerList::ResetServerOnConnect(DWORD dwIp)
{
    int iServer = 0;
    BOOL fShareLock = TRUE;

    TraceFunctEnterEx((LPARAM) this, "CDnsServerList::ResetServerOnConnect");

    m_sl.ShareLock();

    if(!m_IpListPtr || m_IpListPtr->cAddrCount == 0)
        goto Exit;

    // Find the server to reset
    for(iServer = 0;
        iServer < (int)m_IpListPtr->cAddrCount &&
        dwIp != m_IpListPtr->aipAddrs[iServer];
        iServer++);

    if(iServer >= (int)m_IpListPtr->cAddrCount)
        goto Exit;

    // Nothing to do if the specified server is UP and has a zero failure count
    if(!m_prgdwFailureCount[iServer] && m_prgServerState[iServer] == DNS_STATE_UP)
        goto Exit;

    m_sl.ShareUnlock();
    m_sl.ExclusiveLock();

    fShareLock = FALSE;

    // Re-verify that we still have something to do after ShareUnlock->ExclusiveLock
    if(!m_prgdwFailureCount[iServer] && m_prgServerState[iServer] == DNS_STATE_UP)
        goto Exit;

    DebugTrace((LPARAM) this,
        "Resetting server %08x, State=%d, Failure count=%d, Connection count=%d",
        dwIp, m_prgServerState[iServer], m_prgdwFailureCount[iServer],
        m_prgdwConnections[iServer]);

    // If server was in the state DOWN/PROBATION, bring it UP
    if(m_prgServerState[iServer] != DNS_STATE_UP) {

        // Servers on PROBATION are already UP, so no need to inc UpServers
        if(m_prgServerState[iServer] == DNS_STATE_DOWN)
            m_cUpServers++;

        m_prgServerState[iServer] = DNS_STATE_UP;
        m_prgdwFailureTick[iServer] = 0;
        _ASSERT(m_cUpServers <= (int)m_IpListPtr->cAddrCount);
    }

    // Clear all failures
    m_prgdwFailureCount[iServer] = 0;
    m_prgdwConnections[iServer] = 0;

Exit:
    if(fShareLock)
        m_sl.ShareUnlock();
    else
        m_sl.ExclusiveUnlock();

    TraceFunctLeaveEx((LPARAM) this);
}

//-----------------------------------------------------------------------------
//  Description:
//      Checks if any servers are DOWN, and if the retry time has expired for
//      those servers. If so those servers will be brought up and marked in the
//      PROBATION state. We do not want to transition servers that were DOWN
//      directly to UP, because we are still not sure whether or not these
//      servers are really responding. While in the PROBATION state, we allow
//      only a limited number of connections to a server, so as not to cause
//      all remote-queues to choke up trying to connect to a possibly non-
//      functional server. If one of these connections succeeds, the server
//      will be marked back UP and all remote-queues will be able to use this
//      server again. If all the (limited number of) connections fail, the
//      server will go from the PROBATION state to DOWN again.
//  Arguments:
//      None.
//  Returns:
//      Nothing.
//-----------------------------------------------------------------------------
void CDnsServerList::ResetTimeoutServersIfNeeded()
{
    int iServer = 0;
    DWORD dwElapsedTicks = 0;
    DWORD dwCurrentTick = 0;

    //
    // Quick check - if all servers are up (usual case) or there are no configured
    // servers, there's nothing for us to do.
    //

    m_sl.ShareLock();
    if(m_IpListPtr == NULL || m_IpListPtr->cAddrCount == 0 || m_cUpServers == m_IpListPtr->cAddrCount) {

        m_sl.ShareUnlock();
        return;
    }

    m_sl.ShareUnlock();

    // Some servers are down... figure out which need to be brought up
    m_sl.ExclusiveLock();

    // Re-check that no one modified the list while we didn't have the sharelock
    if(m_IpListPtr == NULL || m_IpListPtr->cAddrCount == 0 || m_cUpServers == m_IpListPtr->cAddrCount) {
        m_sl.ExclusiveUnlock();
        return;
    }

    dwCurrentTick = GetTickCount();

    for(iServer = 0; iServer < (int)m_IpListPtr->cAddrCount; iServer++) {

        if(m_prgServerState[iServer] != DNS_STATE_DOWN)
            continue;

        //
        // Note: This also takes care of the special case where dwCurrentTick occurs
        // after the wraparound and m_prgdwFailureTick occurs before the wraparound.
        // This is because, in that case, the elapsed time is:
        //
        //   time since wraparound + time before wraparound that failure occurred - 1
        //   (-1 is because it's 0 time to transition from MAX_TICK_VALUE to 0)
        //
        //      = dwCurrentTick + (MAX_TICK_VALUE - m_prgdwFailureTick[iServer]) - 1
        //
        //   Since MAX_TICK_VALUE == -1
        //
        //      = dwCurrentTick + (-1 - m_prgdwFailureTick[iServer]) - 1
        //      = dwCurrentTick - m_prgdwFailureTick[iServer]
        //

        dwElapsedTicks = dwCurrentTick - m_prgdwFailureTick[iServer];

#define TICKS_TILL_RETRY        10 * 60 * 1000 // 10 minutes

        if(dwElapsedTicks > TICKS_TILL_RETRY) {
            m_prgServerState[iServer] = DNS_STATE_PROBATION;
            m_prgdwFailureTick[iServer] = 0;
            m_prgdwConnections[iServer] = 0;
            m_cUpServers++;
            _ASSERT(m_cUpServers <= (int)m_IpListPtr->cAddrCount);
        }
    }

    m_sl.ExclusiveUnlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\domhash\_domhash.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992, 1998.
//
//  File:       _domhash.cpp
//
//  Contents:   PREFIX table implementation
//
//  History:    SethuR -- Implemented
//              MikeSwa -- Modified for Domain Name lookup 2/98
//
//  Notes:
//  2/98        The major difference between the DFS version and the domain 
//              name lookup is the size of the table, the ability for 
//              wildcard lookups (*.foo.com), and the reverse order of the 
//              lookup (com hashes first in foo.com).  To make the code more
//              readable given its new purpose, the files, structures, and
//              functions have been given non DFS-centric names.  A quick 
//              mapping of the major files is (for those familiar with the 
//              DFS code):
//                  domhash.h  (prefix.h)    -   Public include file
//                  _domhash.h (prefixp.h)   -   Private inlcude file 
//                  domhash.c  (prefix.c)    -   Implementation of API
//                  _domhash.c (prefixp.c)   -   Private helper functions.
//
//--------------------------------------------------------------------------

#include "_domhash.h"

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (        \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )

//+---------------------------------------------------------------------------
//
//  Function:   _AllocateNamePageEntry
//
//  Synopsis:   private fn. for allocating a name page entry
//
//  Arguments:  [pNamePageList] -- name page list to allocate from
//
//              [cLength]  -- length of the buffer in TCHAR's
//
//  Returns:    NULL if unsuccessfull otherwise valid pointer
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PTSTR _AllocateNamePageEntry(PNAME_PAGE_LIST pNamePageList,
                             ULONG           cLength)
{
   TraceFunctEnterEx((LPARAM) NULL, "_AllocateNamePageEntry");
   PNAME_PAGE pTempPage = pNamePageList->pFirstPage;
   PTSTR pBuffer = NULL;

   while (pTempPage != NULL)
   {
       if (pTempPage->cFreeSpace > (LONG)cLength)
          break;
       else
          pTempPage = pTempPage->pNextPage;
   }

   if (pTempPage == NULL)
   {
       pTempPage = ALLOCATE_NAME_PAGE();

       if (pTempPage != NULL)
       {
           INITIALIZE_NAME_PAGE(pTempPage);
           pTempPage->pNextPage = pNamePageList->pFirstPage;
           pNamePageList->pFirstPage = pTempPage;
           pTempPage->cFreeSpace = FREESPACE_IN_NAME_PAGE;
       }
   }

   if ((pTempPage != NULL) && (pTempPage->cFreeSpace >= (LONG)cLength))
   {
       pTempPage->cFreeSpace -= cLength;
       pBuffer = &pTempPage->Names[pTempPage->cFreeSpace];
   }

   TraceFunctLeave();
   return pBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\domhash\domhash.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992, 1998.
//
//  File:       domhash.c
//
//  Contents:   Implementation of public API for domain name lookup table
//
//  History:    SethuR -- Implemented
//              MikeSwa -- Modified for Domain Name lookup 2/98
//
//  Notes:
//  2/98        The major difference between the DFS version and the domain
//              name lookup is the size of the table, the ability for
//              wildcard lookups (*.foo.com), and the reverse order of the
//              lookup (com hashes first in foo.com).  To make the code more
//              readable given its new purpose, the files, structures, and
//              functions have been given non DFS-centric names.  A quick
//              mapping of the major files is (for those familiar with the
//              DFS code):
//                  domhash.h    (prefix.h)    -   Public include file
//                  _domhash.h   (prefixp.h)   -   Private include file
//                  domhash.cpp  (prefix.c)    -   Implementation of API
//                  _domhash.cpp (prefixp.c)   -   Private helper functions.
//
//--------------------------------------------------------------------------

#include "_domhash.h"
#include <stdio.h>

#define _ASSERT_DOMAIN_STRING(pstr) _ASSERT((_tcslen(pstr->Buffer)*sizeof(TCHAR)) == pstr->Length)

//---[ DOMAIN_NAME_TABLE ]-----------------------------------------------------
//
//
//  Description:
//      Class constructor
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
DOMAIN_NAME_TABLE::DOMAIN_NAME_TABLE()
{
    ULONG i;
    m_dwSignature       = DOMAIN_NAME_TABLE_SIG;
    m_cLookupAttempts   = 0;
    m_cLookupSuccesses  = 0;
    m_cLookupCollisions = 0;
    m_cHashCollisions   = 0;
    m_cStringCollisions = 0;
    m_cBucketsUsed      = 0;
    INITIALIZE_DOMAIN_NAME_TABLE_ENTRY(&RootEntry);

    // Initialize the various buckets.
    for (i = 0;i < NO_OF_HASH_BUCKETS;i++)
    {
        INITIALIZE_BUCKET(Buckets[i]);
    }

    NamePageList.pFirstPage = NULL;
}

//---[ ~DOMAIN_NAME_TABLE ]----------------------------------------------------
//
//
//  Description:
//      Class destructor - Dumps some stats to stderr
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
DOMAIN_NAME_TABLE::~DOMAIN_NAME_TABLE()
{
    PNAME_PAGE  pCurrentPage = NamePageList.pFirstPage;
    PNAME_PAGE  pNextPage = NULL;

#ifdef DEBUG
    //$$TODO find a more appropriate way to dump this (don't use *printf)
    ULONG   cTotalCollisions    = m_cHashCollisions + m_cStringCollisions;
    ULONG   ulPercentHash        = cTotalCollisions ? (m_cHashCollisions*100/cTotalCollisions) : 0;
    ULONG   ulPercentDesign      = cTotalCollisions ? (m_cStringCollisions*100/cTotalCollisions) : 0;
    ULONG   ulPercentCollisions  = m_cLookupAttempts ? (m_cLookupCollisions*100/m_cLookupAttempts) : 0;
    ULONG   ulAveCollisions      = m_cLookupCollisions ? (cTotalCollisions/m_cLookupCollisions) : 0;

    fprintf(stderr, "\nHash statistics\n");
    fprintf(stderr, "==============================================\n");
    fprintf(stderr, "Total lookup attempts                   %d\n", m_cLookupAttempts);
    fprintf(stderr, "Total lookup successes                  %d\n", m_cLookupSuccesses);
    fprintf(stderr, "Total lookups with hash collisions      %d\n", m_cLookupCollisions);
    fprintf(stderr, "%% of lookups with hash collisions       %d%%\n", ulPercentCollisions);
    fprintf(stderr, "Total hash Collisions                   %d\n", cTotalCollisions);
    fprintf(stderr, "Average length of lookups collisions    %d\n", ulAveCollisions);
    fprintf(stderr, "Hash collisions due to hash function    %d\n", m_cHashCollisions);
    fprintf(stderr, "Hash collisions due to string parent    %d\n", m_cStringCollisions);
    fprintf(stderr, "%% of collsions because of hash function %d%%\n", ulPercentHash);
    fprintf(stderr, "%% of collsions because of basic design  %d%%\n", ulPercentDesign);
    fprintf(stderr, "Total number of buckets used            %d\n", m_cBucketsUsed);
    fprintf(stderr, "%% buckets used                          %d%%\n", m_cBucketsUsed*100/NO_OF_HASH_BUCKETS);

    DumpTableContents();
#endif //DEBUG

    //Free Name pages
    while (pCurrentPage)
    {
        pNextPage = pCurrentPage->pNextPage;
        FREE_NAME_PAGE(pCurrentPage);
        pCurrentPage = pNextPage;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   DOMAIN_NAME_TABLE::HrInit
//
//  Synopsis:   Member function for initializing the domain name table
//
//  Returns:    HRESULT - S_OK on success
//
//  History:    04-18-94  SethuR Created (as DfsInitializePrefixTable)
//              03-03-98  MikeSwa modified for Domain Table
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT DOMAIN_NAME_TABLE::HrInit()
{
    TraceFunctEnterEx((LPARAM) this, "DOMAIN_NAME_TABLE::HrInit");
    HRESULT hr = S_OK;

    // Initialize the name page list.
    NamePageList.pFirstPage = ALLOCATE_NAME_PAGE();
    if (NamePageList.pFirstPage != NULL)
    {
        INITIALIZE_NAME_PAGE(NamePageList.pFirstPage);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceFunctLeave();
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DOMAIN_NAME_TABLE::HrPrivInsertDomainName
//
//  Synopsis:   API for inserting a path in the prefix table
//
//  Arguments:  [pPath]  -- the path to be looked up.
//
//              [pvNewData] -- BLOB associated with the path
//
//              [dwDomainNameTableFlags] -- flags that describe insert options
//                  DMT_INSERT_AS_WILDCARD -
//                      Set if the domain is NOT a wildcard
//                      domain, but it should be treated as one (more efficient
//                      than reallocated a string to prepend "*.").
//                  DMT_REPLACE_EXISTRING -
//                      Replace existing data if it exists.  Old data is saved
//                      in ppvOldData.
//
//              [ppvOldData] -- Old Data (if any) that was previously associated
//                      with this domain name.  If NULL, previous data will
//                      not be returned
//  Returns:    HRESULT - S_OK on success
//
//  History:    04-18-94  SethuR Created (as DfsInsertInPrefixTable)
//              03-02-98  MikeSwa Modified for Domain Table
//              05-11-98  MikeSwa... modified to support replace and treat
//                          as wildcard options.
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT DOMAIN_NAME_TABLE::HrPrivInsertDomainName(
                                IN  PDOMAIN_STRING  pstrDomainName,
                                IN  DWORD dwDomainNameTableFlags,
                                IN  PVOID pvNewData,
                                OUT PVOID *ppvOldData)
{
    TraceFunctEnterEx((LPARAM) this, "DOMAIN_NAME_TABLE::HrPrivInsertDomainName");
    HRESULT                 hr = S_OK;
    TCHAR                   Buffer[MAX_PATH_SEGMENT_SIZE];
    PTCHAR                  NameBuffer = Buffer;
    USHORT                  cbNameBuffer = sizeof(Buffer);
    DOMAIN_STRING           Path,Name;
    ULONG                   BucketNo;
    PDOMAIN_NAME_TABLE_ENTRY pEntry = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pParentEntry = NULL;
    BOOL                    fNameFound = FALSE;
    BOOL                    fWildcard = FALSE;
    BOOL                    fReplaced = FALSE;

    _ASSERT_DOMAIN_STRING(pstrDomainName);

    // There is one special case, i.e., in which the domain name is '*'.
    // Since this is the WILDCARD_CHAR which is treated in a special
    // way, we do the processing upfront.

    if (pstrDomainName->Length == 0 || pvNewData == NULL)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (ppvOldData)
        *ppvOldData = NULL;


    Path.Length = pstrDomainName->Length;
    Path.MaximumLength = pstrDomainName->MaximumLength;
    Path.Buffer = pstrDomainName->Buffer;
    pParentEntry = &RootEntry;

    //Check if wildcard "*."
    if (DMT_INSERT_AS_WILDCARD & dwDomainNameTableFlags)
    {
        fWildcard = TRUE;
        _ASSERT(!fAdjustPathIfWildcard(pstrDomainName, &Path));
    }
    else if (fAdjustPathIfWildcard(pstrDomainName, &Path))
    {
        fWildcard = TRUE;
    }
    else if (fIsWildcardRoot(pstrDomainName))
    {
        if (RootEntry.pWildCardData != NULL)
        {
            hr = DOMHASH_E_DOMAIN_EXISTS;
        }
        else
        {
            RootEntry.pWildCardData = pvNewData;
        }
        goto Exit;
    }


    if (Path.Length >= MAX_PATH_SEGMENT_SIZE) {
        NameBuffer = (PTCHAR) pvMalloc(Path.Length + sizeof(TCHAR));
        if (NameBuffer == NULL) {
            hr = E_OUTOFMEMORY;
            DebugTrace((LPARAM) hr, "ERROR: Unable to allocate %d non-paged bytes", (Path.Length + sizeof(TCHAR)) );
            goto Exit;
        } else {
            cbNameBuffer = Path.Length + sizeof(TCHAR);
        }
    }

    while (Path.Length > 0)
    {
        Name.Length = 0;
        Name.Buffer = NameBuffer;
        Name.MaximumLength = cbNameBuffer;

        // Process the name segment
        BucketNo = ulSplitCaseInsensitivePath(&Path,&Name);

        if (Name.Length > 0)
        {
            // Lookup the table to see if the name segment already exists.
            LookupBucket(&(Buckets[BucketNo]),&Name,pParentEntry,&pEntry,&fNameFound);

            DebugTrace((LPARAM) pEntry, "Returned pEntry");

            if (pEntry == NULL)
            {
                // Initialize the new entry and initialize the name segment.
                pEntry = ALLOCATE_DOMAIN_NAME_TABLE_ENTRY(this);

                if (!pEntry)
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }

                INITIALIZE_DOMAIN_NAME_TABLE_ENTRY(pEntry);

                // Allocate the name space entry if there is no entry in the
                // name page.
                if (!fNameFound)
                {
                    PTSTR pBuffer;

                    // Allocate the entry in the name page.
                    pBuffer = ALLOCATE_NAME_PAGE_ENTRY(NamePageList,(Name.Length/sizeof(TCHAR)));

                    if (pBuffer != NULL)
                    {
                        RtlCopyMemory(pBuffer,Name.Buffer,Name.Length);
                        pEntry->PathSegment = Name;
                        pEntry->PathSegment.Buffer = pBuffer;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        //We shan't leak memory
                        FREE_DOMAIN_NAME_TABLE_ENTRY(pEntry);
                        pEntry = NULL;
                        break;
                    }
                }
                else
                    pEntry->PathSegment = Name;

                // thread the entry to point to the parent.
                pEntry->pParentEntry = pParentEntry;

                // Insert the entry in the bucket.
                if (0 == Buckets[BucketNo].NoOfEntries)
                    InterlockedIncrement((PLONG) &m_cBucketsUsed);

                INSERT_IN_BUCKET(Buckets[BucketNo],pEntry);

                // Insert the entry in the parent's children list.
                INSERT_IN_CHILD_LIST(pEntry, pParentEntry);
            }
            else
            {
                // Increment the no. of children associated with  this entry
                pEntry->NoOfChildren++;
            }

            pParentEntry = pEntry;
        }
        else
        {
            hr = E_INVALIDARG;
            DebugTrace((LPARAM) hr, "ERROR: Unable to insert domain name");
            break;
        }
    }

    if (SUCCEEDED(hr))
    {
        // The entry was successfully inserted in the prefix table. Update
        // the data (BLOB) associated with it.
        // We do it outside the loop to prevent redundant comparisons within
        // the loop.

        if (fWildcard)
        {
            if (pEntry->pWildCardData)  //make sure we aren't writing over anything
            {
                if (ppvOldData)
                    *ppvOldData = pEntry->pWildCardData;

                if (DMT_REPLACE_EXISTRING & dwDomainNameTableFlags)
                {
                    fReplaced = TRUE;
                    pEntry->pWildCardData = pvNewData;
                }
                else
                {
                    hr = DOMHASH_E_DOMAIN_EXISTS;
                }
            }
            else
            {
                pEntry->pWildCardData = pvNewData;
            }
        }
        else
        {
            if (pEntry->pData) //make sure we aren't writing over anything
            {
                if (ppvOldData)
                    *ppvOldData = pEntry->pData;

                if (DMT_REPLACE_EXISTRING & dwDomainNameTableFlags)
                {
                    fReplaced = TRUE;
                    pEntry->pData = pvNewData;
                }
                else
                {
                    hr = DOMHASH_E_DOMAIN_EXISTS;
                }
            }
            else
            {
                pEntry->pData = pvNewData;
            }
        }
    }

    // If a new entry was not successfully inserted we need to walk up the chain
    // of parent entries to undo the increment to the reference count and
    // remove the entries from their parent links.
    if (FAILED(hr) || //hr could be set in above if statement
        fReplaced) //remove extra child counts
    {
        while (pParentEntry != NULL)
        {
            PDOMAIN_NAME_TABLE_ENTRY pMaybeTempEntry;

            pMaybeTempEntry = pParentEntry;
            pParentEntry = pParentEntry->pParentEntry;

            if (pParentEntry && --pMaybeTempEntry->NoOfChildren == 0) {
                //
                // If pParentEntry == NULL, pMaybeTempEntry is
                // RootEntry. Do not try to remove it.
                //

                _ASSERT(FAILED(hr) && "We shouldn't get here during replace");
                REMOVE_FROM_CHILD_LIST(pMaybeTempEntry);
                REMOVE_FROM_BUCKET(pMaybeTempEntry);
                FREE_DOMAIN_NAME_TABLE_ENTRY(pMaybeTempEntry);
            }
        }
    }

  Exit:

    TraceFunctLeave();
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DOMAIN_NAME_TABLE::HrFindDomainName
//
//  Synopsis:   Method API for looking up a name segment in a prefix table
//
//  Arguments:  IN  pPath  -- the path to be looked up.
//
//              OUT ppData -- placeholder for the BLOB for the prefix.
//
//              IN  fExtactMatch -- FALSE if wildcard matches are allowed
//
//  Returns:    HRESULT - S_OK on success
//
//  History:    04-18-94  SethuR Created (as DfsLookupPrefixTable)
//              03-02-98  MikeSwa Modified for Domain Table
//              06-03-98  MikeSwa Modified to use new HrLookupDomainName
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT DOMAIN_NAME_TABLE::HrFindDomainName(
                               PDOMAIN_STRING      pPath,
                               PVOID               *ppData,
                               BOOL                fExactMatch)
{
    TraceFunctEnterEx((LPARAM) this, "DOMAIN_NAME_TABLE::HrFindDomainName");
    HRESULT                  hr     = S_OK;
    PDOMAIN_NAME_TABLE_ENTRY pEntry = NULL;
    BOOL                     fExactMatchFound = FALSE;
    _ASSERT_DOMAIN_STRING(pPath);

    if (pPath->Length == 0)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = HrLookupDomainName(pPath, &fExactMatchFound, &pEntry);

        // Update the BLOB placeholder with the results of the lookup.
        if (SUCCEEDED(hr))
        {
            _ASSERT(pEntry);
            if (fExactMatchFound && pEntry->pData)
            {
                //exact match found & non-wildcard data is there... use it!
                *ppData = pEntry->pData;
            }
            else if (fExactMatch) //exact match requested, but none found
            {
                hr = DOMHASH_E_NO_SUCH_DOMAIN;
            }
            else //exact match not requested
            {
                //Find the first ancestor with wildcard data
                while (pEntry->pParentEntry && !pEntry->pWildCardData)
                {
                    _ASSERT(pEntry != &RootEntry);
                    pEntry = pEntry->pParentEntry;
                }
                *ppData = pEntry->pWildCardData;
                if (!*ppData) //no wildcard match found
                {
                    _ASSERT(pEntry == &RootEntry); //We should search back to root
                    hr = DOMHASH_E_NO_SUCH_DOMAIN;
                }
            }
        }
        else if (!fExactMatch && (DOMHASH_E_NO_SUCH_DOMAIN == hr))
        {
            //if we don't require an exact match.... check the wildcard root
            if (RootEntry.pWildCardData)
            {
                hr = S_OK;
                *ppData = RootEntry.pWildCardData;
            }
        }

    }
    TraceFunctLeave();
    return hr;

}

//+---------------------------------------------------------------------------
//
//  Function:   DOMAIN_NAME_TABLE::HrRemoveDomainName
//
//  Synopsis:   private fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pPath]  -- the path to be removed from table.
//              [ppvData] - Data that WAS stored in entry
//
//  Returns:    HRESULT
//                  S_OK on success
//                  DOMHASH_E_NO_SUCH_DOMAIN if not found
//
//  History:    04-18-94  SethuR Created (as DfsRemoveFromPrefixTable)
//              03-03-98  MikeSwa - Updated for Domain Table
//              06-03-98  MikeSwa - Modified to use new HrLookupDomainName
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT DOMAIN_NAME_TABLE::HrRemoveDomainName(PDOMAIN_STRING  pPath, PVOID *ppvData)
{
    TraceFunctEnterEx((LPARAM) this, "DOMAIN_NAME_TABLE::HrRemoveDomainName");
    HRESULT         hr  = S_OK;
    DOMAIN_STRING   Path;
    BOOL            fWildcard = FALSE;
    BOOL            fExactMatchFound = FALSE;
    _ASSERT_DOMAIN_STRING(pPath);

    PDOMAIN_NAME_TABLE_ENTRY pEntry = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pTempEntry = NULL;

    if (!ppvData)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (pPath->Length == 0)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    Path.Length = pPath->Length;
    Path.MaximumLength = pPath->MaximumLength;
    Path.Buffer = pPath->Buffer;

    if (fAdjustPathIfWildcard(pPath, &Path))
    {
        fWildcard = TRUE;
    }
    else if (fIsWildcardRoot(pPath))
    {
        *ppvData = RootEntry.pWildCardData;
        if (!*ppvData)
        {
            hr = DOMHASH_E_NO_SUCH_DOMAIN;
        }
        RootEntry.pWildCardData = NULL;
        goto Exit;
    }


    hr = HrLookupDomainName(&Path, &fExactMatchFound, &pEntry);

    if (SUCCEEDED(hr))
    {

        if (!fExactMatchFound)
        {
            //only a partial match was found
            hr = DOMHASH_E_NO_SUCH_DOMAIN;
            goto Exit;
        }

        // Destroy the association between the data associated with
        // this prefix.
        if (!fWildcard)
        {
            *ppvData = pEntry->pData;
            pEntry->pData = NULL;
        }
        else
        {
            *ppvData = pEntry->pWildCardData;
            pEntry->pWildCardData = NULL;
        }

        if (!*ppvData) //no data of of requested type in entry
        {
            //Make sure this isn't a completely NULL data leaf node (ie no way to delete it)
            _ASSERT(pEntry->pFirstChildEntry || pEntry->pData || pEntry->pWildCardData);
            hr = DOMHASH_E_NO_SUCH_DOMAIN;
            goto Exit;
        }

        // found an exact match for the given path name in the table.
        // traverse the list of parent pointers and delete them if
        // required.

        RemoveTableEntry(pEntry);
    }


  Exit:
    TraceFunctLeave();
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DOMAIN_NAME_TABLE::HrLookupDomainName
//
//  Synopsis:   Private function for looking up an *entry* in the table.  It
//              makes no guarantees that there is user data available for the
//              returned entry.  This is the caller's responsibility.  It will
//              match the longest partial path... check fExactMatch to see
//              if an exact match was found
//
//  Arguments:  IN  pPath  -- the path to be looked up.
//
//              OUT pfExactMatch -- Exact Match was found
//
//              OUT ppEntry -- The matching entry for the path.
//
//
//  Returns:    HRESULT
//                  S_OK on success
//                  DOMHASH_E_NO_SUCH_DOMAIN if not found
//                  E_OUTOFMEMORY
//
//  History:    04-18-94  SethuR Created (as _LookupPrefixTable)
//              03-03-98  MikeSwa Modified for Domain Table
//              06-03-98  MikeSwa ExactMatch changed to OUT parameter
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT DOMAIN_NAME_TABLE::HrLookupDomainName(
                            DOMAIN_STRING            *pPath,
                            BOOL                     *pfExactMatch,
                            PDOMAIN_NAME_TABLE_ENTRY  *ppEntry)
{
    TraceFunctEnterEx((LPARAM) this, "DOMAIN_NAME_TABLE::HrLookupDomainName");
    HRESULT                 hr = S_OK;
    DOMAIN_STRING           Path = *pPath;
    TCHAR                   Buffer[MAX_PATH_SEGMENT_SIZE];
    PTCHAR                  NameBuffer = Buffer;
    USHORT                  cbNameBuffer = sizeof(Buffer);
    DOMAIN_STRING           Name;
    ULONG                   BucketNo;
    BOOL                    fPrefixFound = FALSE;
    PDOMAIN_NAME_TABLE_ENTRY pEntry = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pParentEntry = &RootEntry;
    BOOL                    fNameFound = FALSE;

    _ASSERT(Path.Buffer[0] != PATH_DELIMITER);

    *pfExactMatch = FALSE;

    if (Path.Length >= MAX_PATH_SEGMENT_SIZE) {
        NameBuffer = (PTCHAR) pvMalloc(Path.Length + sizeof(TCHAR));
        if (NameBuffer == NULL) {
            hr = E_OUTOFMEMORY;
            DebugTrace((LPARAM) hr, "ERROR: Unable to allocate %d non-paged bytes", (Path.Length + sizeof(TCHAR)) );
            goto Exit;
        } else {
            cbNameBuffer = Path.Length + sizeof(TCHAR);
        }
    }

    while (Path.Length > 0)
    {
        Name.Length = 0;
        Name.Buffer = NameBuffer;
        Name.MaximumLength = cbNameBuffer;

        BucketNo = ulSplitCaseInsensitivePath(&Path,&Name);

        if (Name.Length > 0)
        {
            // Process the name segment
            // Lookup the bucket to see if the entry exists.
            LookupBucket(&(Buckets[BucketNo]),&Name,pParentEntry,&pEntry,&fNameFound);

            DebugTrace((LPARAM) pEntry, "Returned pEntry");

            if (pEntry != NULL)
            {
                *pfExactMatch = TRUE;
                _ASSERT(fNameFound && "Lookup bucket is broken");
                // Cache the data available for this prefix if any.
                 *ppEntry = pEntry;
            }
            else
            {
                *pfExactMatch = FALSE;
                break;
            }

            // set the stage for processing the next name segment.
            pParentEntry = pEntry;
        }
    }

    //Not even a partial match was found
    if (!*ppEntry)
    {
        _ASSERT(FALSE == *pfExactMatch);
        hr = DOMHASH_E_NO_SUCH_DOMAIN;
        DebugTrace((LPARAM) hr, "INFO: Path %s not found", pPath->Buffer);
    }


  Exit:

    TraceFunctLeave();
    return hr;
}

//---[ DOMAIN_NAME_TABLE::HrIterateOverSubDomains ]----------------------------
//
//
//  Description:
//
//  Parameters:
//      IN strDomain    - Domain string to search for subdomains of
//                        (should not start with "*.")
//      IN pfn          - Mapping function (described below)
//      IN pvContext    - Context ptr pass to mapping function
//
//  Notes:
//      VOID DomainTableInteratorFunction(
//          IN PVOID pvContext, //context passed to HrIterateOverSubDomains
//          IN PVOID pvData, //data entry to look at
//          IN BOOL fWildcardData, //true if data is a wildcard entry
//          OUT BOOL *pfContinue, //TRUE if iterator should continue to the next entry
//          OUT BOOL *pfRemoveEntry); //TRUE if entry should be deleted
//
//  Returns:
//      S_OK on success
//      DOMHASH_E_NO_SUCH_DOMAIN if there is no matching domain or subdomains
//  History:
//      6/5/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT DOMAIN_NAME_TABLE::HrIterateOverSubDomains(
        IN DOMAIN_STRING *pstrDomain,
        IN DOMAIN_ITR_FN pfn,
        IN PVOID pvContext)
{
    HRESULT hr = S_OK;
    PDOMAIN_NAME_TABLE_ENTRY pEntry = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pRootEntry = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pNextEntry = NULL;
    BOOL    fExactMatchFound = FALSE;
    BOOL    fContinue        = TRUE;
    BOOL    fDelete          = FALSE;
    DWORD   cDomainsFound    = 0;
    BOOL    fWildcard        = FALSE;

    _ASSERT(pfn && "Invalid Param - pfn");
    _ASSERT((!pstrDomain || (WILDCARD_CHAR != pstrDomain->Buffer[0])) && "Invalid param - string starts with '*'");

    if (pstrDomain)
    {
        hr = HrLookupDomainName(pstrDomain, &fExactMatchFound, &pEntry);

        if (FAILED(hr))
            goto Exit;

        if (!fExactMatchFound) //there must be an entry at root of subtree
        {
            hr = DOMHASH_E_NO_SUCH_DOMAIN;
            goto Exit;
        }

        _ASSERT(pEntry);
    }
    else
    {
        //if !pstrDomain.., iterate over entire hash table
        pEntry = &RootEntry;
    }

    pRootEntry = pEntry;

    //Traverse all the child entries of pRootEntry (preorder)
    while (pEntry)
    {
        //get next entry before it is deleted
        pNextEntry = pNextTableEntry(pEntry, pRootEntry);

        //This check must be done before call to RemoveTableEntry
        //If there is no wildcard data, then entry might be deleted
        //after call to RemoveTableEntry (if it has no children)
        fWildcard = (NULL != pEntry->pWildCardData);

        if (pEntry->pData)
        {
            cDomainsFound++;
            pfn(pvContext, pEntry->pData, FALSE, &fContinue, &fDelete);
            if (fDelete)
            {
                pEntry->pData = NULL;
                RemoveTableEntry(pEntry);
            }
            if (!fContinue)
                break;
        }

        if (fWildcard)
        {
            cDomainsFound++;
            pfn(pvContext, pEntry->pWildCardData, TRUE, &fContinue, &fDelete);
            if (fDelete)
            {
                pEntry->pWildCardData = NULL;
                RemoveTableEntry(pEntry);
            }
            if (!fContinue)
                break;
        }
        pEntry = pNextEntry;
    }

    if (!cDomainsFound)
        hr = DOMHASH_E_NO_SUCH_DOMAIN;

  Exit:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DOMAIN_NAME_TABLE::pvNextDomainName
//
//  Synopsis:   Enumerates the entries in the table in ordered fashion.
//              Note that state is maintained between calls to
//              pvNextDomainName - the caller must ensure that the table
//              is not modified between calls to pNextTableEntry by acquiring
//              an external read lock
//
//  Arguments:  IN OUT PVOID *ppvContext - context used to hold place
//
//  Returns:    Valid pointer to data associated with the next Prefix Table
//              entry, or NULL if at the end of the enumeration.
//
//-----------------------------------------------------------------------------
PVOID DOMAIN_NAME_TABLE::pvNextDomainName(IN OUT PVOID *ppvContext)
{
    PDOMAIN_NAME_TABLE_ENTRY pEntry, pNextEntry;
    PVOID   pvData = NULL;
    bool fDataUsed = false;

    _ASSERT(ppvContext);

    if ((PVOID) this == *ppvContext)
    {
        *ppvContext = NULL;
        goto Exit;
    }

    //Find entry to get data for
    if (!*ppvContext)
    {
        //We're starting over
        pNextEntry = &RootEntry;

        //Find first entry with valid data
        while (pNextEntry != NULL &&
               pNextEntry->pData == NULL &&
               pNextEntry->pWildCardData == NULL)
        {
            pNextEntry = pNextTableEntry(pNextEntry);
        }
    }
    else
    {
        //Use context provided as starting point
        if (ENTRY_SIG == **((DWORD**) ppvContext))
        {
            pNextEntry = (PDOMAIN_NAME_TABLE_ENTRY) *ppvContext;
        }
        else
        {
            _ASSERT(WILDCARD_SIG == **((DWORD **) ppvContext));
            pNextEntry = CONTAINING_RECORD(*ppvContext, DOMAIN_NAME_TABLE_ENTRY, dwWildCardSig);
            _ASSERT(ENTRY_SIG == pNextEntry->dwEntrySig);
            fDataUsed = true;
        }

        //If this is a next entry... either pData or pWildCard should be non-NULL
        _ASSERT(pNextEntry->pData || pNextEntry->pWildCardData);
    }

    pEntry = pNextEntry;

    //Save data to return in pvData
    if (pEntry != NULL)
    {
        if (pEntry->pData && !fDataUsed)
        {
            pvData = pEntry->pData;
        }
        else
        {
            _ASSERT(pEntry->pWildCardData);
            pvData = pEntry->pWildCardData;
        }
    }

    //Determine what context to return
    if (pNextEntry != NULL)
    {
        if (!fDataUsed && pNextEntry->pWildCardData && pEntry->pData)
        {
            //use wildcard data next time through
            *ppvContext = (PVOID) &(pNextEntry->dwWildCardSig);
        }
        else
        {
            do //find next entry that does not point to NULL info
            {
                pNextEntry = pNextTableEntry( pNextEntry );
            } while ( pNextEntry != NULL &&
                      pNextEntry->pData == NULL &&
                      pNextEntry->pWildCardData == NULL);
            *ppvContext = (PVOID) pNextEntry;
            _ASSERT(*ppvContext != (PVOID) this);  //so our sentinal value works
            if (NULL == *ppvContext)
            {
                *ppvContext = (PVOID) this;
            }
        }
    }

  Exit:

    return pvData;
}

//+----------------------------------------------------------------------------
//
//  Function:   pNextTableEntry
//
//  Synopsis:   Given a pointer to a Prefix Table Entry, this function will
//              return a pointer to the "next" prefix table entry.
//
//              The "next" entry is chosen as follows:
//                  If the start entry has a valid child, the child is
//                      is returned.
//                  else if the start entry has a valid sibling, the sibling
//                      is returned
//                  else the first valid sibling of the closest ancestor is
//                      returned.
//
//  Arguments:  [pEntry] -- The entry to start from.
//              [pRootEntry] -- Root node of subtree being enumerated
//                              (NULL or address of root entry will do all)
//
//  Returns:    Pointer to the next DOMAIN_NAME_TABLE_ENTRY that has a valid
//              pData, or NULL if there are no more entries.
//
//  Note:       You must have a read lock over a sequence of calls into this
//              function (you cannot release it between calls).
//  History;
//      06/09/98 - Mikeswa modified to accept RootEntry
//
//-----------------------------------------------------------------------------
PDOMAIN_NAME_TABLE_ENTRY
DOMAIN_NAME_TABLE::pNextTableEntry(IN PDOMAIN_NAME_TABLE_ENTRY pEntry,
                                   IN PDOMAIN_NAME_TABLE_ENTRY pRootEntry)
{
    PDOMAIN_NAME_TABLE_ENTRY pNextEntry = NULL;
    _ASSERT(pEntry);

    if (pEntry->pFirstChildEntry != NULL)
    {
        pNextEntry = pEntry->pFirstChildEntry;
    }
    else if ((pEntry->pSiblingEntry != NULL) && //if there is a sibling entry
            (pEntry != pRootEntry))             //this is not the root entry

    {
        //Should have same parent
        _ASSERT(pEntry->pParentEntry == pEntry->pSiblingEntry->pParentEntry);
        pNextEntry = pEntry->pSiblingEntry;
    }
    else
    {
        for (pNextEntry = pEntry->pParentEntry;
            pNextEntry != NULL &&
            pNextEntry->pSiblingEntry == NULL &&
            pNextEntry != pRootEntry;
            pNextEntry = pNextEntry->pParentEntry)
        {
            //NOTHING;
        }

        if (pNextEntry == pRootEntry)
        {
            pNextEntry = NULL;
        }
        else if (pNextEntry != NULL)
        {
            pNextEntry = pNextEntry->pSiblingEntry;
        }

    }
    return pNextEntry;
}
//---[ DOMAIN_NAME_TABLE::DumpTableContents ]----------------------------------
//
//
//  Description:
//      Print out contents of table.  Intended primarily for leak detection
//      during table destructor
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void DOMAIN_NAME_TABLE::DumpTableContents()
{
    PDOMAIN_NAME_TABLE_ENTRY    pEntry = NULL;
    DOMAIN_STRING               Path;
    CHAR                        Buffer[MAX_PATH_SEGMENT_SIZE+1];
    DWORD                       cLeaks = 0;

    Path.Length = 0;
    Path.MaximumLength = MAX_PATH_SEGMENT_SIZE;
    Path.Buffer = Buffer;

    //Check for leaked entries
    pEntry = pNextTableEntry(&RootEntry);
    if (pEntry)
    {
        fprintf(stderr, "\nFOUND LEAKED ENTRIES!!\n\n");
        fprintf(stderr, "Entry ID    # Children  pData       pWildCard    Path\n");
        fprintf(stderr, "===========================================================================\n");
        while(pEntry)
        {
            _ASSERT(pEntry);
            GET_DOMAIN_NAME_TABLE_ENTRY_PATH(pEntry, &Path);
            fprintf(stderr, "0x%p  %10.10d  0x%p  0x%p   %s\n", pEntry,
                pEntry->NoOfChildren, pEntry->pData, pEntry->pWildCardData, Path.Buffer);
            cLeaks++;
            pEntry = pNextTableEntry(pEntry);
        }
        fprintf(stderr, "===========================================================================\n");
        fprintf(stderr, "Total Leaks: %d\n", cLeaks);
    }
}

//---[ DOMAIN_NAME_TABLE::RemoveTableEntry ]------------------------------------
//
//
//  Description:
//      Removes an entry from the table
//  Parameters:
//      IN  pentry  - Entry to remove
//  Returns:
//      -
//  History:
//      6/8/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void DOMAIN_NAME_TABLE::RemoveTableEntry(IN PDOMAIN_NAME_TABLE_ENTRY pEntry)
{
    PDOMAIN_NAME_TABLE_ENTRY pTempEntry = NULL;
    while (pEntry != NULL)
    {
        pTempEntry = pEntry;
        pEntry = pEntry->pParentEntry;
        if (pEntry && (--pTempEntry->NoOfChildren) == 0)
        {
            _ASSERT(!pTempEntry->pData && !pTempEntry->pWildCardData);
            //
            // pEntry == NULL means pTempEntry is pTable->RootEntry.
            // Do not try to remove it. (we also do not maintain a child count
            // on it).
            //
            REMOVE_FROM_CHILD_LIST(pTempEntry);
            REMOVE_FROM_BUCKET(pTempEntry);
            FREE_DOMAIN_NAME_TABLE_ENTRY(pTempEntry);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\domhash\_domhash.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992, 1998.
//
//  File:       prefix.hxx
//
//  Contents:   PREFIX table definition
//
//  History:    SethuR -- Implemented as DFS PERFIX table
//              Mikeswa 2/98 - updated for use as SMTP Domain Name Hash
//
//  Notes:      The DFS prefix table data structure consists of three
//              entities and methods to manipulate them. They are the
//              DOMAIN_NAME_TABLE_ENTRY,DOMAIN_NAME_TABLE_BUCKET and the
//              DOMAIN_NAME_TABLE.
//
//              The DOMAIN_NAME_TABLE is a hash table of DOMAIN_NAME_TABLE_ENTRY's
//              wherein collisions are resolved through linear chaining. The
//              hash table is organized as an array of collision lists
//              (DOMAIN_NAME_TABLE_BUCKET). A brief description with each of
//              these entities is attached to the declaration.
//
//              There are certain characterstics that distinguish this
//              hash table from other hash tables. These are the extensions
//              provided to accomodate the special operations.
//
//  2/98        The major difference between the DFS version and the domain
//              name lookup is the size of the table, the ability for
//              wildcard lookups (*.foo.com), and the reverse order of the
//              lookup (com hashes first in foo.com).  To make the code more
//              readable given its new purpose, the files, structures, and
//              functions have been given non DFS-centric names.  A quick
//              mapping of the major files is (for those familiar with the
//              DFS code):
//                  domhash.h    (prefix.h)    -   Public include file
//                  _domhash.h   (prefixp.h)   -   Private inlcude file
//                  domhash.cpp  (prefix.c)    -   Implementation of API
//                  _domhash.cpp (prefixp.c)   -   Private helper functions.
//
//--------------------------------------------------------------------------

#ifndef ___DOMHASH_H__
#define ___DOMHASH_H__

#include <domhash.h>
#include <transmem.h>

//
// MAX_PATH_SEGMENT_SIZE is simply used as a good size buffer to do prefix
// lookups and insertions. This should save us from having to allocate for
// most cases.
//

#define MAX_PATH_SEGMENT_SIZE  256
#define PATH_DELIMITER _TEXT('.')
#define WILDCARD_CHAR  _TEXT('*')
#define COMPARE_MEMORY(s,d,l)   memcmp(s,d,l)

#ifndef UNICODE
//Optimized ASCII version to handle 99% case
#define DOMHASH_TO_UPPER(mychar) \
    ((mychar) < 'a')   ? (mychar) \
                       : (((mychar) <= 'z') \
                       ? ((mychar) - 'a' + 'A') : mychar)
#else
#define DOMHASH_TO_UPPER(mychar) _towupper(mychar)
#endif //UNICODE

//---[ fAdjustPathIfWildcard ]-------------------------------------------------
//
//
//  Description:
//      Checks if a path is a wildcard path (starts with "*.") and moves the
//      begining of the domain to point past the first 2 characters if so.
//  Parameters:
//      IN  pDomainSource    Domain to check
//      OUT pDomainDest      Domain to modify
//  Returns:
//      TRUE if pPath is a wildcarded domain, FALSE otherwise
//
//-----------------------------------------------------------------------------
inline BOOL fAdjustPathIfWildcard(IN  DOMAIN_STRING *pDomainSource,
                                  OUT DOMAIN_STRING *pDomainDest)
{
    //Check if wildcard "*."
    if (pDomainSource->Length > 2 &&
        pDomainSource->Buffer[0] == WILDCARD_CHAR &&
        pDomainSource->Buffer[1] == PATH_DELIMITER)
    {
        //Adjust path to point past starting "*."
        pDomainDest->Length -= 2*sizeof(TCHAR);
        pDomainDest->MaximumLength -= 2*sizeof(TCHAR);
        pDomainDest->Buffer += 2;
        return TRUE;
    }
    return FALSE;
}

//---[ fIsWildcardRoot ]-------------------------------------------------------
//
//
//  Description:
//      Checks is given domain is the wildcard root domains (single character
//      that is WILDCARD_CHAR.
//  Parameters:
//      IN pPath    Domain to check
//  Returns:
//      TRUE if root wildcard, FALSE otherwise
//
//-----------------------------------------------------------------------------
inline BOOL fIsWildcardRoot(IN DOMAIN_STRING *pPath)
{
    //Check if 1 char long, and that char is WILDCARD_CHAR
    return(pPath->Length == sizeof(TCHAR) &&
           pPath->Buffer[0] == WILDCARD_CHAR);
}

//---[ ALLOCATE_DOMAIN_STRING ]------------------------------------------------
//
//
//  Description:
//      Allocates a new DOMAIN_STRING structure and initializes with copy of
//      given string.
//  Parameters:
//      szDomainName    string to initialize structure with
//  Returns:
//      PDOMAIN_STRING  on success
//      NULL on failure
//
//-----------------------------------------------------------------------------
inline PDOMAIN_STRING ALLOCATE_DOMAIN_STRING(PTSTR szDomainName)
{
    PDOMAIN_STRING  pDomainString = NULL;
    USHORT  usStringLength = 0;
    PSTR    pBuffer = NULL;

    _ASSERT(szDomainName);

    if (!szDomainName)
        goto Exit;

    usStringLength = (USHORT)_tcslen(szDomainName);

    pBuffer = (PSTR) pvMalloc(sizeof(TCHAR) * (usStringLength+1));
    if (!pBuffer)
        goto Exit;

    memcpy(pBuffer, szDomainName, (sizeof(TCHAR) * (usStringLength+1)));

    pDomainString = (PDOMAIN_STRING) pvMalloc(sizeof(DOMAIN_STRING));
    if (!pDomainString)
        goto Exit;

    pDomainString->Length = usStringLength*sizeof(TCHAR);
    pDomainString->MaximumLength = pDomainString->Length;
    pDomainString->Buffer = pBuffer;

    pBuffer = NULL;

  Exit:
    if (pBuffer)
        FreePv(pBuffer);

    return pDomainString;

}
//---[ ulSplitCaseInsensitivePath ]--------------------------------------------
//
//
//  Description:
//      Spits path around delimited characters and returns a hash (bucket number)
//      for the current string between delimiters.
//  Parameters:
//      pPath       Path to split (modified to maintain place in path)
//      pName       the leftmost component of the path(PDOMAIN_STRING )
//
//  SideEffects: structures pointed to by pName and pPath are modified.
//
//  PreRequisite: pName be associated with a valid buffer.
//
//  History:    04-18-94  SethuR Created (as SPLIT_CASE_INSENSITIVE_PATH macro)
//              03-03-98  MikeSwa Made into C++ inline function - reversed order
//                        of search.
//  Returns:
//      Hash Bucket Number corresponding to the path name
//
//  NOTE:
//      pName grows backswords from pPath... if pPath is "machine.foo.com",
//      then pName will point to "MOC", "OOF", and "ENIHCAM" on successive calls.
//      This is because the hierarchy of the domain name is from right to left.
//
//-----------------------------------------------------------------------------
inline ULONG ulSplitCaseInsensitivePath(IN  OUT PDOMAIN_STRING  pPath,
                                        OUT     PDOMAIN_STRING  pName)
{
    TraceFunctEnterEx((LPARAM) NULL, "ulSplitCaseInsensitivePath");
    TCHAR *pPathBuffer   = (pPath)->Buffer;
    TCHAR *pNameBuffer   = (pName)->Buffer;
    TCHAR *pPathBufferStart = pPathBuffer-1;
    ULONG  BucketNo = 0;

    //Start from end of string
    pPathBuffer += ((pPath)->Length / sizeof(TCHAR) -1 );

    while ((pPathBufferStart != pPathBuffer) &&
           ((*pNameBuffer = *pPathBuffer--) != PATH_DELIMITER))
    {
        *pNameBuffer = DOMHASH_TO_UPPER(*pNameBuffer);
        BucketNo *= 131;  //First prime after ASCII character codes
        BucketNo += *pNameBuffer;
        pNameBuffer++;
    }

    BucketNo = BucketNo % NO_OF_HASH_BUCKETS;
    *pNameBuffer = _TEXT('\0');
    (pName)->Length = (USHORT)((CHAR *)pNameBuffer - (CHAR *)(pName)->Buffer);

    //Set Path Length to not include before the portion we have already scanned
    (pPath)->Length = (USHORT)((CHAR *)pPathBuffer - (CHAR *)pPathBufferStart);

    TraceFunctLeave();
    return(BucketNo);
}

//+---------------------------------------------------------------------------
//
//  Function:   LookupBucket
//
//  Synopsis:   lookups the bucket for an entry.
//
//  Arguments:  IN  [Bucket] -- the bucket to be used (DOMAIN_NAME_TABLE_BUCKET)
//
//              IN  [Name]   -- the name to be looked up (DOMAIN_STRING )
//
//              IN  [pParentEntry] -- the parent entry of the entry we are
//                                searching for.
//
//              OUT [pEntry] -- placeholder for the desired entry.
//
//              OUT [fNameFound] -- indicates if the name was found.
//
//  SideEffects: Name,fNameFound and pEntry are modified
//
//  History:    04-18-94  SethuR Created (as macro)
//              03-03-98  MikeSwa - Updated for Domain Table as inline function
//
//  Notes:
//
//              We only store one copy of a string irrespective of the no. of
//              places it appears in, e.g. foo.bar and foo1.bar will result
//              in only one copy of bar being stored. This implies that the
//              lookup routine will have to return sufficient info. to prevent
//              the allocation of memory space for a string. If on exit
//              fNameFound is set to TRUE then this indicates that a similar
//              string was located in the table and the Name.Buffer field is
//              modified to point to the first instance of the string in
//              the table.
//
//----------------------------------------------------------------------------
inline void DOMAIN_NAME_TABLE::LookupBucket(
                         IN  PDOMAIN_NAME_TABLE_BUCKET pBucket,
                         IN  PDOMAIN_STRING  pName,
                         IN  PDOMAIN_NAME_TABLE_ENTRY pParentEntry,
                         OUT PDOMAIN_NAME_TABLE_ENTRY *ppEntry,
                         OUT BOOL *pfNameFound)
{
    TraceFunctEnterEx((LPARAM) this, "DOMAIN_NAME_TABLE::LookupBucket");
    PDOMAIN_NAME_TABLE_ENTRY pCurEntry = pBucket->SentinelEntry.pNextEntry;
    ULONG   cHashCollisions = 0;
    ULONG   cStringCollisions = 0;
    BOOL    fHashCollision = TRUE;


    *pfNameFound = FALSE;
    *ppEntry = NULL;

    InterlockedIncrement((PLONG) &m_cLookupAttempts);

    //NOTE: This is a linear search of all the hash collisions for and multiple
    //instances of a domains name section.
    while (pCurEntry != &(pBucket->SentinelEntry))
    {
        fHashCollision = TRUE;
        if (pCurEntry->PathSegment.Length == pName->Length)
        {
            //Only do mem compare if length is the same

            //only do compare if we haven't found a string match
            if ((!*pfNameFound) &&
                    (!COMPARE_MEMORY(pCurEntry->PathSegment.Buffer,
                             pName->Buffer,
                             pName->Length)))
            {
                 *pfNameFound = TRUE;
                 pName->Buffer = pCurEntry->PathSegment.Buffer;
            }

            //If *pfNameFound is set, then a match has already been found
            //and pName->Buffer points to our internal copy.  We only need
            //to do a pointer compare
            if (*pfNameFound &&
               (pCurEntry->PathSegment.Buffer == pName->Buffer))
            {
                if (pCurEntry->pParentEntry == pParentEntry)
                {
                    *ppEntry = pCurEntry;
                    break;
                }
                fHashCollision = FALSE;
                cStringCollisions++; //correct string wrong parent
            }
        }

        if (fHashCollision)
            cHashCollisions++;  //multiple strings in this bucket

        pCurEntry = pCurEntry->pNextEntry;
    }

    if (*ppEntry)
    {
        //Lookup succeeded
        InterlockedIncrement((PLONG) &m_cLookupSuccesses);
    }


    if (cHashCollisions || cStringCollisions)
    {
        InterlockedIncrement((PLONG) &m_cLookupCollisions);
        if (cHashCollisions)
        {
            InterlockedExchangeAdd((PLONG) &m_cHashCollisions, cHashCollisions);
        }
        if (cStringCollisions)
        {
            InterlockedExchangeAdd((PLONG) &m_cStringCollisions, cStringCollisions);
        }
    }
    TraceFunctLeave();
}

//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_BUCKET
//
//  Synopsis:   Initializes a hash bucket.
//
//  Arguments:  [Bucket] -- the bucket to be initialized(DOMAIN_NAME_TABLE_BUCKET)
//
//  SideEffects: the bucket is intialized ( the collision list and count are
//               initialized
//
//  History:    04-18-94  SethuR Created
//              03-05-98  MikeSwa - made into inline function (instead of macro)
//
//----------------------------------------------------------------------------

void inline INITIALIZE_BUCKET(DOMAIN_NAME_TABLE_BUCKET &Bucket)                                           \
{
   (Bucket).SentinelEntry.pNextEntry = &(Bucket).SentinelEntry;
   (Bucket).SentinelEntry.pPrevEntry = &(Bucket).SentinelEntry;
   (Bucket).NoOfEntries = 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   INSERT_IN_BUCKET
//
//  Synopsis:   inserts the entry in the bucket
//
//  Arguments:  [Bucket] -- the bucket to be initialized(DOMAIN_NAME_TABLE_BUCKET)
//
//              [pEntry] -- the entry to be inserted
//
//  SideEffects: Bucket is modified to include the entry
//
//  History:    04-18-94  SethuR Created
//              03-05-98  MikeSwa - updated to count total buckets used and
//                          made into inline function (instead of macro)
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

void inline INSERT_IN_BUCKET(DOMAIN_NAME_TABLE_BUCKET &Bucket,
                         PDOMAIN_NAME_TABLE_ENTRY pEntry)                                     \
{
    (Bucket).NoOfEntries++;
    (pEntry)->pPrevEntry = (Bucket).SentinelEntry.pPrevEntry;
    (pEntry)->pNextEntry = &((Bucket).SentinelEntry);
    ((Bucket).SentinelEntry.pPrevEntry)->pNextEntry = (pEntry);
    (Bucket).SentinelEntry.pPrevEntry = (pEntry);
}

//+---------------------------------------------------------------------------
//
//  Function:   REMOVE_FROM_BUCKET
//
//  Synopsis:   removes the entry from the bucket
//
//  Arguments:  [pEntry] -- the entry to be inserted
//
//  SideEffects: Bucket is modified to exclude the entry
//
//  History:    04-18-94  SethuR Created
//              03-03-98  MikeSwa - Updated for Domain Table as inline function
//
//----------------------------------------------------------------------------

void inline REMOVE_FROM_BUCKET(PDOMAIN_NAME_TABLE_ENTRY pEntry)
{
    PDOMAIN_NAME_TABLE_ENTRY pPrevEntry = (pEntry)->pPrevEntry;
    PDOMAIN_NAME_TABLE_ENTRY pNextEntry = (pEntry)->pNextEntry;

    pPrevEntry->pNextEntry = pNextEntry;
    pNextEntry->pPrevEntry = pPrevEntry;
}

//+---------------------------------------------------------------------------
//
//  Function:   INSERT_IN_CHILD_LIST
//
//  Synopsis:   Inserts this entry in the parent's list of children
//
//  Arguments:  [pEntry] -- the entry to be inserted
//
//              [pParentEntry] -- the entry into whose list of children
//                      pEntry has to be inserted.
//
//  SideEffects: Parent's list of children is modified.
//
//  History:    01-09-96  MilanS Created
//              03-03-98  MikeSwa - Updated for Domain Table as inline function
//
//----------------------------------------------------------------------------

void inline INSERT_IN_CHILD_LIST(PDOMAIN_NAME_TABLE_ENTRY pEntry,
                                 PDOMAIN_NAME_TABLE_ENTRY pParentEntry)
{
    PDOMAIN_NAME_TABLE_ENTRY pLastChild;

    if (pParentEntry->pFirstChildEntry == NULL) {
        pParentEntry->pFirstChildEntry = pEntry;
    } else {
        for (pLastChild = pParentEntry->pFirstChildEntry;
                pLastChild->pSiblingEntry != NULL;
                    pLastChild = pLastChild->pSiblingEntry) {
             //NOTHING;
        }
        pLastChild->pSiblingEntry = pEntry;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   REMOVE_FROM_CHILD_LIST
//
//  Synopsis:   Removes an entry from its parent's list of children
//
//  Arguments:  [pEntry] -- the Entry to remove from children list.
//
//  SideEffects: The children list of pParentEntry is modified.
//
//  History:    01-09-96  MilanS Created
//              03-03-98  MikeSwa - Updated for Domain Table as inline function
//
//  Notes:      This routine will ASSERT if pEntry is not in the parent's
//              list of children.
//
//-----------------------------------------------------------------------------

void inline REMOVE_FROM_CHILD_LIST(PDOMAIN_NAME_TABLE_ENTRY pEntry)                                       \
{
    PDOMAIN_NAME_TABLE_ENTRY pParentEntry = pEntry->pParentEntry;
    PDOMAIN_NAME_TABLE_ENTRY pPrevSibling;

    if (pParentEntry->pFirstChildEntry == pEntry) {
        pParentEntry->pFirstChildEntry = pEntry->pSiblingEntry;
    } else {
        for (pPrevSibling = pParentEntry->pFirstChildEntry;
                pPrevSibling->pSiblingEntry != pEntry;
                    pPrevSibling = pPrevSibling->pSiblingEntry) {
             _ASSERT(pPrevSibling->pSiblingEntry != NULL);
        }
        pPrevSibling->pSiblingEntry = pEntry->pSiblingEntry;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_NAME_PAGE
//
//  Synopsis:   initializes the name page
//
//  Arguments:  [pNamePage] -- the NAME_PAGE to be initialized
//
//  SideEffects: the name page is initialized
//
//  History:    04-18-94  SethuR Created
//              03-03-98  MikeSwa - Updated for Domain Table as inline function
//
//----------------------------------------------------------------------------

void inline INITIALIZE_NAME_PAGE(PNAME_PAGE pNamePage)
{
    pNamePage->pNextPage = NULL;
    pNamePage->cFreeSpace = FREESPACE_IN_NAME_PAGE - 1;
    pNamePage->Names[FREESPACE_IN_NAME_PAGE - 1] = _TEXT('\0');
}

//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_DOMAIN_NAME_TABLE_ENTRY
//
//  Synopsis:   initializes the prefix table entry
//
//  Arguments:  [pEntry] -- the entry to be initialized
//
//  SideEffects: the prefix table entry is modified
//
//  History:    04-18-94  SethuR Created
//              03-03-98  MikeSwa - Updated for Domain Table as inline function
//
//----------------------------------------------------------------------------

void inline INITIALIZE_DOMAIN_NAME_TABLE_ENTRY(PDOMAIN_NAME_TABLE_ENTRY pEntry)
{
    ZeroMemory( pEntry, sizeof( DOMAIN_NAME_TABLE_ENTRY ) );
    pEntry->NoOfChildren = 1;
    pEntry->dwEntrySig = ENTRY_SIG;
    pEntry->dwWildCardSig = WILDCARD_SIG;
}

//---[ GET_DOMAIN_NAME_TABLE_ENTRY_PATH ]--------------------------------------
//
//
//  Description:
//      Walks up the list of parent entries and re-generates the full path
//      From the partial path information stored at each entry.
//
//      This is not very quick, and is intended for debugging purposes only
//  Parameters:
//      IN  pEntry   Entry to get info for
//      OUT pPath    Already allocated string to hold Path info
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void inline GET_DOMAIN_NAME_TABLE_ENTRY_PATH(PDOMAIN_NAME_TABLE_ENTRY pEntry,
                                             PDOMAIN_STRING pPath)
{
    PTSTR   pPathBuffer = NULL;
    PTSTR   pPathBufferStop = NULL;
    PTSTR   pEntryBuffer = NULL;
    PTSTR   pEntryBufferStop = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pParentEntry = NULL;

    _ASSERT(pEntry);
    _ASSERT(pPath);
    _ASSERT(pPath->Buffer);

    pPathBuffer = pPath->Buffer;
    pPathBufferStop = pPathBuffer + ((pPath)->MaximumLength / sizeof(TCHAR) -1 );

    while (pEntry && pEntry->pParentEntry && pPathBuffer < pPathBufferStop)
    {
        //dump current entries portion of the string
        if (pPathBuffer != pPath->Buffer) //already made first pass -- Add delimter
        {
            *pPathBuffer++ = PATH_DELIMITER;
        }

        pEntryBuffer = pEntry->PathSegment.Buffer;
        pEntryBufferStop = pEntryBuffer;
        pEntryBuffer += (pEntry->PathSegment.Length / sizeof(TCHAR) -1 );

        while (pPathBuffer < pPathBufferStop && pEntryBuffer >= pEntryBufferStop)
        {
            *pPathBuffer++ = *pEntryBuffer--;
        }
        pEntry = pEntry->pParentEntry;
    }

    _ASSERT(pEntry);
    *pPathBuffer = '\0';
}

//+---------------------------------------------------------------------------
//
//  Function:   ALLOCATION ROUTINES
//
//  Synopsis:   Allocation routines for Domain Name Table
//
//  History:    04-18-94  SethuR Created
//              02-98     MikeSwa Modified for use in Domain Name Table
//
//----------------------------------------------------------------------------

#define PREFIX_TABLE_ENTRY_SEGMENT_SIZE PAGE_SIZE


extern
PTSTR _AllocateNamePageEntry(PNAME_PAGE_LIST pPageList,ULONG cLength);

PTSTR inline ALLOCATE_NAME_PAGE_ENTRY(NAME_PAGE_LIST &PageList, ULONG cLength)                           \
{
    return
    (
     ((PageList).pFirstPage->cFreeSpace -= (cLength)) >= 0
     ?
       &(PageList).pFirstPage->Names[(PageList).pFirstPage->cFreeSpace]
     :
       (
        (PageList).pFirstPage->cFreeSpace += (cLength)
        ,
        _AllocateNamePageEntry(&(PageList),(cLength))
       )
    );
}


PNAME_PAGE inline ALLOCATE_NAME_PAGE(void)
{
    return (PNAME_PAGE)pvMalloc(sizeof(NAME_PAGE));
}

void inline FREE_NAME_PAGE(PNAME_PAGE pPage)
{
    FreePv(pPage);
}

PDOMAIN_NAME_TABLE_ENTRY inline ALLOCATE_DOMAIN_NAME_TABLE_ENTRY(PDOMAIN_NAME_TABLE pTable)
{
    return (PDOMAIN_NAME_TABLE_ENTRY)pvMalloc(sizeof(DOMAIN_NAME_TABLE_ENTRY));
}

void inline FREE_DOMAIN_NAME_TABLE_ENTRY(PDOMAIN_NAME_TABLE_ENTRY pEntry)
{
    _ASSERT(pEntry);
    FreePv(pEntry);
}

void inline  FREE_DOMAIN_STRING(PDOMAIN_STRING pDomainString)
{
    if (pDomainString)
    {
        if (pDomainString->Buffer)
            FreePv(pDomainString->Buffer);
        FreePv(pDomainString);
    }
}

#endif // ___DOMHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\dnslib\dnsutils.cpp ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        dnsutils.cpp

   Abstract:

        This file defines the functions for resolving a name using
        DNS by querying a specified set of DNS servers.

   Author:

           Gautam Pulla ( GPulla )    05-Dec-2001

   Project:

          SMTP Server DLL

   Revision History:


--*/

#include "dnsincs.h"

//-----------------------------------------------------------------------------
//  Description:
//      Resolves a host by querying a specified set of DNS servers. The cache
//      is also queried if the servers parameter is NULL (i.e. the local DNS
//      servers configured on the machine are used). If this fails we failover
//      to the winsock version of gethostbyname() to resolve the name. This
//      queries the default DNS servers on the box and also does other lookups
//      like WINS and NetBIOS.
//
//  Arguments:
//      IN LPSTR pszHost - Host to resolve
//
//      IN PIP_ARRAY pipDnsServers - DNS servers to use. Pass in NULL if the
//          default list of DNS servers should be used.
//
//      IN DWORD fOptions - Flags to pass in to the DNSAPI.
//
//      OUT DWORD *rgdwIpAddresses - Pass in array which will be filled in
//          with the IP addresses returned by the resolve.
//
//      IN OUT DWORD *pcIpAddresses - Pass in number max number of IP
//          addresses that can be returned in the array. On successful return
//          this is set to the number of IP addresses found.
//
//  Returns:
//      ERROR_SUCCESS if the hostname was resolved.
//      Win32 error if the hostname could not be found or there was some other
//          error.
//-----------------------------------------------------------------------------
DWORD ResolveHost(
    LPSTR pszHost,
    PIP_ARRAY pipDnsServers,
    DWORD fOptions,
    DWORD *rgdwIpAddresses,
    DWORD *pcIpAddresses)
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwAddr = INADDR_NONE;
    INT i = 0;
    INT cIpAddresses = 0;
    INT cBufferSize = *pcIpAddresses;
    HOSTENT *hp = NULL;

    TraceFunctEnterEx((LPARAM) pszHost, "ResolveHost");

    DebugTrace((LPARAM) pszHost, "Resolving host %s", pszHost);

    _ASSERT(pszHost && rgdwIpAddresses && pcIpAddresses && *pcIpAddresses > 0);

    dwAddr = inet_addr(pszHost);
    if(dwAddr != INADDR_NONE) {

        DebugTrace((LPARAM) pszHost, "Resolving %s as an address literal", pszHost);
        DNS_PRINTF_MSG("%s is a literal IP address\n", pszHost);

        if(!*pcIpAddresses) {
            _ASSERT(0 && "Passing in zero length buffer!");
            TraceFunctLeaveEx((LPARAM) pszHost);
            return ERROR_RETRY;
        }

        *pcIpAddresses = 1;
        rgdwIpAddresses[0] = dwAddr;
        TraceFunctLeaveEx((LPARAM) pszHost);
        return ERROR_SUCCESS;
    }
    
    dwStatus = GetHostByNameEx(
                    pszHost,
                    pipDnsServers,
                    fOptions,
                    rgdwIpAddresses,
                    pcIpAddresses);

    if(dwStatus == ERROR_SUCCESS) {
        DebugTrace((LPARAM) pszHost, "GetHostByNameEx resolved %s", pszHost);
        TraceFunctLeaveEx((LPARAM) pszHost);
        return ERROR_SUCCESS;
    }

    DebugTrace((LPARAM) pszHost, "GetHostByNameEx failed, trying gethostbyname");

    DNS_PRINTF_MSG("Cannot resolve using DNS only, calling gethostbyname as last resort.\n");
    DNS_PRINTF_MSG("This will query\n");
    DNS_PRINTF_MSG("- Global DNS servers.\n");
    DNS_PRINTF_MSG("- DNS cache.\n");
    DNS_PRINTF_MSG("- WINS/NetBIOS.\n");
    DNS_PRINTF_MSG("- .hosts file.\n");

    // GetHostByNameEx failed, failover to gethostbyname
    *pcIpAddresses = 0;

    hp = gethostbyname(pszHost);
    if(hp == NULL) {
        DNS_PRINTF_DBG("Winsock's gethostbyname() failed.\n");
        ErrorTrace((LPARAM) pszHost, "gethostbyname failed, Error: %d", GetLastError());
        TraceFunctLeaveEx((LPARAM) pszHost);
        return ERROR_RETRY;
    }


    // Copy results to return buffer
    for(i = 0; hp->h_addr_list[i] != NULL; i++) {

        if(cIpAddresses >= cBufferSize)
            break;

        CopyMemory(&rgdwIpAddresses[cIpAddresses], hp->h_addr_list[i], 4);
        cIpAddresses++;
    }
 
    if(!cIpAddresses) {
        ErrorTrace((LPARAM) pszHost, "No IP address returned by gethostbyname");
        TraceFunctLeaveEx((LPARAM) pszHost);
        return ERROR_RETRY;
    }

    DebugTrace((LPARAM) pszHost, "gethostbyname succeeded resolving: %s", pszHost);
    *pcIpAddresses = cIpAddresses;

    TraceFunctLeaveEx((LPARAM) pszHost);
    return ERROR_SUCCESS;
}

//-----------------------------------------------------------------------------
//  Description:
//      Resolves a host by querying DNS and returns a list of IP addresses for
//      the host. The host is resolved for CNAME and A records.
//  Arguments:
//      IN LPSTR pszHost --- Hostname to be resolved
//      IN PIP_ARRAY pipDnsServers --- DNS servers to use
//      IN DWORD fOptions --- Options to be passed into DnsQuery_A
//      OUT DWORD *rgdwIpAddresses --- Buffer to write IP addresses to
//      IN OUT DWORD *pcIpAddresses --- Pass in number of IP addresses that can
//      be returned in rgdwIpAddresses. On successful return, this is set to the
//          number of IP addresses obtained from the resolution.
//  Returns:
//      ERROR_SUCCESS if the resolution succeeded
//      DNS_ERROR_RCODE_NAME_ERROR if the host does not exist
//      DNS_INFO_NO_RECORDS if the host cannot be resolved
//      ERROR_INVALID_ARGUMENT if a permanent error occurred, such as a
//          configuration error on the DNS server (CNAME loop for instance).
//      Win32 error code if there is some other problem.
//-----------------------------------------------------------------------------
DWORD GetHostByNameEx(
    LPSTR pszHost,
    PIP_ARRAY pipDnsServers,
    DWORD fOptions,
    DWORD *rgdwIpAddresses,
    DWORD *pcIpAddresses)
{
    PDNS_RECORD pDnsRecordList = NULL;
    PDNS_RECORD pDnsRecordListTail = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    LPSTR pszChainTail = NULL;
    DWORD cBufferSize = *pcIpAddresses;

    TraceFunctEnterEx((LPARAM) pszHost, "GetHostByNameEx");

    //
    // Check for A records for pszHost.
    //

    _ASSERT(pszHost && rgdwIpAddresses && pcIpAddresses && *pcIpAddresses > 0);

    DebugTrace((LPARAM) pszHost, "Querying for A records for %s", pszHost);
    dwStatus = MyDnsQuery(
                    pszHost,
                    DNS_TYPE_A,
                    fOptions,
                    pipDnsServers,
                    &pDnsRecordList);

    if(DNS_INFO_NO_RECORDS == dwStatus) {

        //
        // If this is hit, it's almost always because there are no
        // records for pszHost on the server. Even if pszHost is an
        // alias, the A record query will normally return CNAME records
        // as well.
        //

        DNS_PRINTF_MSG("No A records for %s in DNS.\n", pszHost);
        DNS_PRINTF_MSG("Querying for CNAME records instead.\n", pszHost);

        DebugTrace((LPARAM) pszHost, "A query for %s failed, trying CNAME", pszHost);
        dwStatus = MyDnsQuery(
                        pszHost,
                        DNS_TYPE_CNAME,
                        fOptions,
                        pipDnsServers,
                        &pDnsRecordList);

    }
    
    DebugTrace((LPARAM) pszHost, "Return status from last DNS query: %d", dwStatus);

    //
    // At this point:
    //
    // (1) If pszHost is an alias, the A query has returned all the records
    //     we need to resolve it; because good (read "all") DNS servers return
    //     the relevant CNAME records even when queried for A records.
    // (2) If pszHost is an alias and the DNS server doesn't return CNAME records
    //     in a reply to the A query, we would have queried specifically for CNAME
    //     records.
    // (3) If pszHost is a proper hostname, the A query has returned all the
    //     records we need to resolve it.
    // (4) Or something has failed.
    //
    // So now we can drop down (if we haven't failed) and chain the CNAME records
    // (if there are any).
    //

    DNS_LOG_RESPONSE(dwStatus, pDnsRecordList, NULL, 0);

    if(ERROR_SUCCESS != dwStatus) {
        ErrorTrace((LPARAM) pszHost,
            "Query for %s failed, failing resolve. Status: %d", pszHost, dwStatus);
        goto Exit;
    }

    _ASSERT(pDnsRecordList);

    //
    // ProcessCNAMEChain chains CNAME records and tries to get an IP address
    // for pszHost by following the chain. Zero length chains, which correspond
    // to the situation where there are no CNAME records, but a direct A record
    // for pszHost is available are also handled.
    //
    // For legal configurations in DNS, ProcessCNAMEChain will return a list of
    // IP addresses 99% of the time. pszChainTail will be set to the hostname
    // of the CNAME chain tail. The rare exceptional case where an IP address
    // is not returned even when the configuration is legal is described below.
    //
    // If ProcessCNAMEChain does not return an IP address for pszHost, then the
    // DNS server did not return any records for the initial A query. It only
    // returned CNAME records for the subsequent CNAME query. This can be if:
    //
    // (1) This is a weird DNS server. DNS servers will almost always return
    //     CNAME records for a hostname in the initial A query if it has them.
    //     i.e if you have.
    //
    //          random.com  CNAME   mail.com
    //          mail.com    A       10.10.10.10
    //
    //     The the first A query for random.com returned no records. This is
    //     technically correct because there are no A records for random.com.
    //     However all sane DNS servers return both the CNAME and A records as
    //     additional records anyway, so this DNS server must be a bit funky.
    //
    //     To be robust, we must chain the CNAME record to mail.com, and then
    //     re-query for an A record for mail.com.
    //
    // (2) pszHost has only CNAME records. So the initial A query will fail,
    //     and the subsequent CNAME query will return only CNAME records. i.e.
    //     if you have:
    //
    //          random.com  CNAME   mail.com
    //          No A records for mail.com
    //
    //     Then the A query for random.com may return no records and the CNAME
    //     query for random.com may return only the CNAME records. This is a
    //     actually an illegal configuration, but we must go through the
    //     complete process anyway in case situation (1) caused this.
    //
    // In either case, if ProcessCNAMEChain returns successfully, pszChainTail
    // is set to the tail of the chain and we can query for A records for
    // pszChainTail.
    //

    *pcIpAddresses = cBufferSize;
    dwStatus = ProcessCNAMEChain(
                    pDnsRecordList,
                    pszHost,
                    &pszChainTail,
                    rgdwIpAddresses,
                    pcIpAddresses);

    if(ERROR_SUCCESS != dwStatus) {
        ErrorTrace((LPARAM) pszHost, "Failed to process CNAME chain: %d", dwStatus);
        goto Exit;
    }
    
    // Success: IP address(es) obtained
    if(*pcIpAddresses > 0) {
        DebugTrace((LPARAM) pszHost,
            "Got %d IP addresses, success resolve", *pcIpAddresses);
        goto Exit;
    }

    DebugTrace((LPARAM) pszHost,
        "Chained CNAME chain, but no A records available for for chain-tail: %s",
        pszChainTail);

    _ASSERT(*pcIpAddresses == 0);

    //
    // No CNAME chain was found, which means that pszHost should have a direct
    // A record. But there is no such A record, or we would have an IP address
    // from ProcessCNAMEChain. So the resolve has failed.
    //

    if(!pszChainTail) {
        ErrorTrace((LPARAM) pszHost, "Chain tail NULL. Failed resolve");
        dwStatus = DNS_INFO_NO_RECORDS;
        goto Exit;
    }

    //
    // At this point, a CNAME chain has been followed but no IP address was
    // found for pszChainTail. This could be because of situation (1) or (2)
    // described in the comment above for ProcessCNAMEChain. We need to query
    // for an A record for the tail of the CNAME chain.
    //

    DebugTrace((LPARAM) pszHost, "Querying A records for chain tail: %s", pszChainTail);
    dwStatus = MyDnsQuery(
                    pszChainTail,
                    DNS_TYPE_A,
                    fOptions,
                    pipDnsServers,
                    &pDnsRecordListTail);

    DebugTrace((LPARAM) pszHost, "A query retstatus: %d", pszChainTail);

    if(ERROR_SUCCESS == dwStatus) {

        _ASSERT(pDnsRecordListTail);

        *pcIpAddresses = cBufferSize;
        FindARecord(
            pszChainTail,
            pDnsRecordListTail,
            rgdwIpAddresses,
            pcIpAddresses);

    }

    if(*pcIpAddresses == 0) {
        ErrorTrace((LPARAM) pszHost, "No A records found for chain tail: %s", pszChainTail);
        dwStatus = DNS_INFO_NO_RECORDS;
    }

Exit:
    if(pDnsRecordListTail) {
        //DnsRecordListFree(pDnsRecordListTail, DnsFreeRecordListDeep);
        DnsFreeRRSet(pDnsRecordListTail, TRUE);
    }

    if(pDnsRecordList) {
        //DnsRecordListFree(pDnsRecordList, DnsFreeRecordListDeep);
        DnsFreeRRSet(pDnsRecordList, TRUE);
    }

    TraceFunctLeaveEx((LPARAM) pszHost);
    return dwStatus;
}

//-----------------------------------------------------------------------------
//  Description:
//      Given a list of records returned from a successful CNAME query for a
//      DNS name, this function traverses the chain and obtains the IP addresses
//      for the hosts at the end of the chain tail if present. The tail of the
//      chain is also returned.
//  Arguments:
//      IN PDNS_RECORD pDnsRecordList - Recordlist from CNAME query
//      IN LPSTR pszHost - Host to resolve (head of chain)
//      OUT LPSTR *ppszChainTail - Tail of chain (points to memory within
//          pDnsRecordList). If no IP addresses are returned, we must requery
//          for A records for *ppszChainTail.
//      OUT DWORD *rgdwIpAddresses - If the resolve worked, on return, this
//          array is filled with the IP addresses for pszHost.
//      IN OUT ULONG *pcIpAddresses - On calling this function pass in the
//          number of IP addresses that can be accomodated into rgdwIpAddresses.
//          On return, this is set to the number of IP addresses found for
//          pszHost.
//  Returns:
//      ERROR_SUCCESS
//      ERROR_INVALID_DATA
//      This function always succeeds (no memory allocated)
//-----------------------------------------------------------------------------
DWORD ProcessCNAMEChain(
    PDNS_RECORD pDnsRecordList,
    LPSTR pszHost,
    LPSTR *ppszChainTail,
    DWORD *rgdwIpAddresses,
    ULONG *pcIpAddresses)
{
    DWORD dwReturn = ERROR_RETRY;
    LPSTR pszRealHost = pszHost;
    PDNS_RECORD pDnsRecord = pDnsRecordList;
    PDNS_RECORD rgCNAMERecord[MAX_CNAME_RECORDS];
    ULONG cCNAMERecord = 0;
    INT i = 0;
    INT j = 0;

    TraceFunctEnterEx((LPARAM) pszHost, "ProcessCNAMEChain");

    _ASSERT(ppszChainTail && rgdwIpAddresses && pcIpAddresses && *pcIpAddresses > 0);

    //
    // Filter out the CNAME records (if any) so that we can chain them
    //

    while(pDnsRecord) {

        if(DNS_TYPE_CNAME == pDnsRecord->wType) {

            DNS_PRINTF_MSG("Processing CNAME: %s   CNAME   %s\n",
                pDnsRecord->nameOwner, pDnsRecord->Data.CNAME.nameHost);

            DebugTrace((LPARAM) pszHost, "CNAME record: %s -> %s",
                pDnsRecord->nameOwner, pDnsRecord->Data.CNAME.nameHost);

            rgCNAMERecord[cCNAMERecord] = pDnsRecord;
            cCNAMERecord++;

            if(cCNAMERecord >= MAX_CNAME_RECORDS) {
                DNS_PRINTF_ERR("Too many CNAME records to process\n");
                ErrorTrace((LPARAM) pszHost, "Too many CNAME records (max=%d)."
                    " Failed resolve", MAX_CNAME_RECORDS);
                TraceFunctLeaveEx((LPARAM) pszHost);
                return ERROR_INVALID_DATA;
            }
        }

        pDnsRecord = pDnsRecord->pNext;
    }

    if(cCNAMERecord > 0) {

        DNS_PRINTF_DBG("CNAME records found. Chaining CNAMEs.\n");
        DebugTrace((LPARAM) pszHost, "Chaining CNAME records to: %s", pszHost);
        dwReturn = GetCNAMEChainTail(rgCNAMERecord, cCNAMERecord,
                        pszHost, ppszChainTail);

        if(ERROR_INVALID_DATA == dwReturn) {
            ErrorTrace((LPARAM) pszHost, "No chain tail from GetCNAMEChainTail: %d", dwReturn);
            TraceFunctLeaveEx((LPARAM) pszHost);
            goto Exit;
        }

        _ASSERT(*ppszChainTail);
    } else {
        DNS_PRINTF_DBG("No CNAME records in reply.\n");
    }


    DebugTrace((LPARAM) pszHost,
        "GetCNAMEChainTail succeeded. Chain tail: %s", *ppszChainTail);

    //
    // If pszHost chains through some CNAME records to *ppszChainTail, then
    // the host we should really be looking for is *ppszChainTail.
    //

    if(*ppszChainTail)
        pszRealHost = *ppszChainTail;

    FindARecord(pszRealHost, pDnsRecordList, rgdwIpAddresses, pcIpAddresses);
    dwReturn = ERROR_SUCCESS;

Exit:
    TraceFunctLeaveEx((LPARAM) pszHost);
    return dwReturn;
}


//-----------------------------------------------------------------------------
//  Description:
//      Handles CNAME chaining. It is possible (although not recommended) to
//      have chains of CNAME records. If the host pointed to by a CNAME record
//      itself has a CNAME record pointing to another host for instance. In the
//      interests of robustness we follow such CNAME chains to an extent even
//      though CNAME chains are illegal according to the RFC.
//
//      We run through all the CNAME records in an O(n^2) loop examining each
//      pair of CNAME records for a "parent-child" relationship. If there is
//      such a relationship, these records are "linked" to each other. We
//      create a "directed graph" whose nodes are CNAME records and whose
//      edges represent the "parent-child" relationship between CNAME records.
//
//      Since the number of CNAME records allowed is small (MAX_CNAME_RECORDS),
//      the cost of creating this graph is at most O(MAX_CNAME_RECORDS^2) which
//      is still quite small.
//
//      Once the graph has been created, we traverse every valid chain and
//      return the tail of the first one we find that starts in pszHost.
//
//  Arguments:
//      IN PDNS_RECORD rgCNAMERecord --- Pass in an array of CNAME PDNS_RECORDS
//      IN ULONG cCNAMERecord --- Number of PDNS_RECORDS in rgCNAMERecord
//      IN LPSTR pszHost --- Hostname which we are trying to resolve
//      OUT LPSTR *ppszChainTail --- Tail of CNAME chain starting at pszHost.
//          This is NULL if the return value is not ERROR_SUCCESS.
//  Returns:
//      ERROR_SUCCESS - If we successfully built a CNAME chain in which case
//          *ppszChainTail points to the tail of the chain.
//      ERROR_INVALID_DATA - If a CNAME chain loop was detected, or a valid
//          CNAME chain could not be built.
//  Note:
//      No memory is allocated in this function, and any errors returned are
//      permanent.
//-----------------------------------------------------------------------------
DWORD GetCNAMEChainTail(
    PDNS_RECORD *rgCNAMERecord,
    ULONG cCNAMERecord,
    LPSTR pszHost,
    LPSTR *ppszChainTail)
{
    DWORD dwReturn = ERROR_INVALID_DATA;
    ULONG i = 0;
    ULONG j = 0;
    ULONG cCNAMELoopDetect = 0; // Keeps track of chain length
    struct TREE_NODE
    {
        PDNS_RECORD pDnsRecord;
        TREE_NODE *pParent;
        TREE_NODE *rgChild[3];
        ULONG cChild;
    };
    TREE_NODE rgNode[MAX_CNAME_RECORDS];
    TREE_NODE *pNode = NULL;

    TraceFunctEnterEx((LPARAM) pszHost, "GetCNAMEChainTail");

    *ppszChainTail = NULL;

    ZeroMemory(rgNode, sizeof(rgNode));
    for(i = 0; i < cCNAMERecord; i++)
        rgNode[i].pDnsRecord = rgCNAMERecord[i];

    //
    // If there are 2 nodes with the following CNAME records:
    //
    //      foo.com     CNAME   bar.com
    //      bar.com     CNAME   foo.bar
    //
    // Then, we define the second one to be the child of the first -- i.e.
    // they "chain up". We will build up a tree of such parent/child nodes.
    //
    // For all nodes i, check if any other node j is a child of i. If
    // it is, add it as a child of i provided there is room (only 3 nodes
    // may be added as children of a given node. Each node also has a back
    // pointer, pointing to its parent node. If there are more than 3
    // children we won't worry about it. You shouldn't have CNAME chains
    // in the first place, let alone *multiple* CNAME chains involving the
    // *same* record.
    //

    DebugTrace((LPARAM) pszHost, "Building chaining graph");

    for(i = 0; i < cCNAMERecord; i++) {

        for(j = 0; j < cCNAMERecord; j++) {

            if(i == j)
                continue;

            DebugTrace((LPARAM) pszHost, "Comparing: %s and %s",
                rgNode[i].pDnsRecord->Data.CNAME.nameHost,
                rgNode[j].pDnsRecord->nameOwner);

            if(DnsNameCompare_A(rgNode[i].pDnsRecord->Data.CNAME.nameHost,
                    rgNode[j].pDnsRecord->nameOwner)) {


                if(rgNode[i].cChild > ARRAY_SIZE(rgNode[i].rgChild)) {
                    ErrorTrace((LPARAM) pszHost,
                        "Cannot chain (too many children): %s -> %s",
                        rgNode[i].pDnsRecord->Data.CNAME.nameHost,
                        rgNode[j].pDnsRecord->nameOwner);

                    DNS_PRINTF_DBG("The following record has too many aliases (max = 3).\n");
                    DNS_PRINTF_DBG("This is not a fatal error, but some aliases will be"
                        " ignored.\n");
                    DNS_PRINT_RECORD(rgNode[i].pDnsRecord);
                    continue;
                }

                DNS_PRINTF_MSG("%s is an alias for %s\n",
                    rgNode[i].pDnsRecord->Data.CNAME.nameHost,
                    rgNode[j].pDnsRecord->nameOwner);                    

                DebugTrace((LPARAM) pszHost, "Chained: %s -> %s",
                    rgNode[i].pDnsRecord->Data.CNAME.nameHost,
                    rgNode[j].pDnsRecord->nameOwner);

                rgNode[i].rgChild[rgNode[i].cChild] = &rgNode[j];
                rgNode[j].pParent = &rgNode[i];
                rgNode[i].cChild++;
                break;
            }
        }
    }

    //
    // For every leaf node, we traverse backwards till we hit the parent node
    // at the root, and check if the parent node is a CNAME for pszHost. If it
    // is, then the leaf node is the tail end of a valid CNAME chain. 
    //
    // At the end of this loop, we have looked at every CNAME chain.
    //  (a) Either we found a valid CNAME chain or,
    //  (b) No valid CNAME chain exists or,
    //  (c) There is a loop in some CNAME chain.
    //

    for(i = 0; i < cCNAMERecord; i++) {

        pNode = &rgNode[i];

        //
        // Not a leaf node
        //

        if(pNode->cChild > 0)
            continue;

        DebugTrace((LPARAM) pszHost, "Starting with CNAME record: (%s %s)",
            pNode->pDnsRecord->nameOwner, pNode->pDnsRecord->Data.CNAME.nameHost);

        //
        // Traverse backwards till we hit a node without a parent.
        //

        while(pNode->pParent != NULL && cCNAMELoopDetect < cCNAMERecord) {
            cCNAMELoopDetect++;
            pNode = pNode->pParent;
            DebugTrace((LPARAM) pszHost, "Next record in chain is: (%s %s)",
                pNode->pDnsRecord->nameOwner,
                pNode->pDnsRecord->Data.CNAME.nameHost);
        }

        //
        // The CNAME chain can't be longer than the number of records unless
        // there's a loop. In such a case error out with a permanent error.
        //

        if(cCNAMELoopDetect == cCNAMERecord) {

            DNS_PRINTF_ERR("CNAME loop detected, abandoning resolution.\n");
            ErrorTrace((LPARAM) pszHost, "CNAME loop detected\n");
            dwReturn = ERROR_INVALID_DATA;
            goto Exit;
        }

        //
        // Does the root node (pNode) match *ppszHost? If so, we found a chain.
        // Set *ppszHost to the tail of the CNAME chain.
        //

        if(MyDnsNameCompare(pszHost, pNode->pDnsRecord->nameOwner)) {

            *ppszChainTail = rgNode[i].pDnsRecord->Data.CNAME.nameHost;
            dwReturn = ERROR_SUCCESS;
            DebugTrace((LPARAM) pszHost, "Found complete chain from %s to %s",
                pszHost, pNode->pDnsRecord->Data.CNAME.nameHost);

            DNS_PRINTF_MSG("%s is an alias for %s\n", pszHost, pNode->pDnsRecord->nameOwner);
            break;
        }
    }
Exit:
    TraceFunctLeaveEx((LPARAM) pszHost);
    return dwReturn;
}

//-----------------------------------------------------------------------------
//  Description:
//      Given a hostname and a list of PDNS_RECORDs, this function searches
//      the list for A records matching the hostname and returns the IP
//      addresses in the A records.
//  Arguments:
//      IN LPSTR pszHost --- Host for which to look for A records. Can be
//          a NetBIOS name, in which case we only try to match the "prefix".
//          See MyDnsQuery and MyDnsNameCompare documentation for what prefixes
//          are.
//      IN PDNS_RECORD pDnsRecordList --- List of records to scan.
//      OUT DWORD *rgdwIpAddresses --- Pass in an array which will be filled
//          in with the IP addresses found.
//      IN OUT ULONG *pcIpAddresses --- Pass in the number of IP addresses
//          that can be stored in rgdwIpAddresses. On return, this is
//          initialized to the number of IP addresses found. We will only
//          return as many IP addresses as there is space for.
//  Returns:
//      Nothing.
//      This function always succeeds (no memory allocated)
//-----------------------------------------------------------------------------
void FindARecord(
    LPSTR pszHost,
    PDNS_RECORD pDnsRecordList,
    DWORD *rgdwIpAddresses,
    ULONG *pcIpAddresses)
{
    ULONG i = 0;
    PDNS_RECORD pDnsRecord = pDnsRecordList;

    TraceFunctEnterEx((LPARAM) pszHost, "FindARecord");

    DNS_PRINTF_DBG("Checking reply for A record for %s\n", pszHost);
    DebugTrace((LPARAM) pszHost, "Looking for A record for %s", pszHost);

    _ASSERT(pszHost && rgdwIpAddresses && pcIpAddresses && *pcIpAddresses > 0);

    while(pDnsRecord) {

        if(DNS_TYPE_A == pDnsRecord->wType) {
            DebugTrace((LPARAM) pszHost, "Comparing with %s",
                pDnsRecord->nameOwner);
        }

        if(DNS_TYPE_A == pDnsRecord->wType &&
            MyDnsNameCompare(pszHost, pDnsRecord->nameOwner)) {

            if(i > *pcIpAddresses)
                break;

            rgdwIpAddresses[i] = pDnsRecord->Data.A.ipAddress;
            i++;
        }
        pDnsRecord = pDnsRecord->pNext;
    }

    DNS_PRINTF_MSG("%d A record(s) found for %s\n", i, pszHost);
    DebugTrace((LPARAM) pszHost, "Found %d matches", i);
    *pcIpAddresses = i;
    TraceFunctLeaveEx((LPARAM) pszHost);
}

//-----------------------------------------------------------------------------
//  Description:
//      When querying for DNS to resolve hostnames, SMTP may also be asked to
//      resolve NetBIOS names. In this case we must append the DNS suffixes
//      configured for this machine before sending queries to the DNS server.
//      This option can be toggled by setting the DNS_QUERY_TREAT_AS_FQDN flag
//      to DnsQuery. MyDnsQuery is a simple wrapper function that checks if the
//      name we are querying for is a NetBIOS name, and if is, it turns on
//      the DNS_QUERY_TREAT_AS_FQDN flag to try the suffixes. Of course, if
//      we are using suffixes, the returned *ppDnsRecordList will contain
//      records that may not match pszHost. So checking for matching records
//      should be done using MyDnsNameCompare instead of straight string
//      comparison.
//  Arguments:
//      Same as arguments to DnsQuery_A
//  Returns:
//      Same as return value from DnsQuery_A
//-----------------------------------------------------------------------------
DWORD MyDnsQuery(
    LPSTR pszHost,
    WORD wType,
    DWORD fOptions,
    PIP_ARRAY pipDnsServers,
    PDNS_RECORD *ppDnsRecordList)
{
    BOOL fGlobal = TRUE;

    if(NULL != strchr(pszHost, '.'))
        fOptions |= DNS_QUERY_TREAT_AS_FQDN;
    else
        _ASSERT(0 == (fOptions & DNS_QUERY_TREAT_AS_FQDN));

    if(pipDnsServers)
        fGlobal = FALSE;

    DNS_LOG_API_QUERY(
        pszHost,        // Host to query for
        DNS_TYPE_A,     // Query type
        fOptions,       // Flags for DNSAPI
        fGlobal,        // Are the global DNS servers being used
        pipDnsServers); // Serverlist

    return DnsQuery_A(
                pszHost,
                wType,
                fOptions,
                pipDnsServers,
                ppDnsRecordList,
                NULL);
}

//-----------------------------------------------------------------------------
//  Description:
//      Comparing DNS names is more than just a simple string comparison. Since
//      the DNS API may append suffixes to the query before sending it to DNS,
//      the returned records may not contain the exact same name as the name
//      passed into MyDnsQuery. Specifically, the returned records may contain
//      the name we passed into MyDnsQuery plus a suffix name. Since MyDnsQuery
//      appends a suffix if we are trying to resolve a NetBIOS name, the returned
//      record may not exactly match the name passed into MyDnsQuery for NetBIOS
//      names. This function checks if pszHost is a NetBIOS name, and if it is,
//      we will try to match only the "prefix".
//  Arguments:
//      IN LPSTR pszHost --- NetBIOS-name/FQDN to match
//      IN LPSTR pszFqdn --- FQDN from DNS reply to match against (possibly
//          includes a suffix appended by DnsQuery)
//  Returns:
//      TRUE if strings match
//      FALSE otherwise
//-----------------------------------------------------------------------------
BOOL MyDnsNameCompare(
    LPSTR pszHost,
    LPSTR pszFqdn)
{
    int cbHost = 0;
    int cbFqdn = 0;
    CHAR ch = '\0';
    BOOL fRet = FALSE;

    // Not a NetBIOS name... can do a straight string comparison
    if(NULL != strchr(pszHost, '.'))
        return DnsNameCompare_A(pszHost, pszFqdn);

    //
    // If it is a NetBIOS name, pszFqdn must be pszHost + Suffix, otherwise the
    // names don't match. First remove the suffix.
    //

    cbHost = lstrlen(pszHost);
    cbFqdn = lstrlen(pszFqdn);

    //
    // If pszFqdn == (pszHost+Suffix) then cbFqdn) must be >= cbHost
    //

    if(cbFqdn < cbHost)
        return 1;

    // The prefix and suffix should be joined with a '.' in between
    if(pszFqdn[cbHost] != '.' && pszFqdn[cbHost] != '\0')
        return 1;

    // Remove the suffix and compare prefixes.
    ch = pszFqdn[cbHost];
    pszFqdn[cbHost] = '\0';
    fRet = !lstrcmpi(pszHost, pszFqdn);
    pszFqdn[cbHost] = ch;
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\evntwrap\src\evntwrap.cpp ===
/*
 * An event log wrapper to simplify event logging for DLLs and to add
 * a few extra features.
 */

#include <windows.h>
#include <stdio.h>
#include "dbgtrace.h"
#include "stierr.h"
#include "crchash.h"
#include "evntwrap.h"
#include "rwex.h"

static CExShareLock g_lockHash;

#define STAX_EVENT_SOURCE_SYSTEM_PATH_PREFIX \
    "System\\CurrentControlSet\\Services\\EventLog\\System\\"
#define STAX_EVENT_SOURCE_APPLICATION_PATH_PREFIX \
    "System\\CurrentControlSet\\Services\\EventLog\\Application\\"

#define MAX_STAX_EVENT_SOURCE_PATH_PREFIX \
    ((sizeof(STAX_EVENT_SOURCE_SYSTEM_PATH_PREFIX) > \
      sizeof(STAX_EVENT_SOURCE_APPLICATION_PATH_PREFIX)) ? \
      sizeof(STAX_EVENT_SOURCE_SYSTEM_PATH_PREFIX) : \
      sizeof(STAX_EVENT_SOURCE_APPLICATION_PATH_PREFIX)) 


//
// Register your event source in the registry.
//
// Parameters:
//   szEventSource - the name of the eventsource
//   szMessageFile - the full path to the DLL which contains the
//                   eventlog strings
//
HRESULT CEventLogWrapper::AddEventSourceToRegistry(char *szEventSource,
                                                   char *szEventMessageFile,
                                                   BOOL fApplication) 
{
    HRESULT hr = S_OK;
    DWORD ec;
    HKEY hkEventSource = NULL;
    char szRegPath[1024] = STAX_EVENT_SOURCE_SYSTEM_PATH_PREFIX;
    DWORD dwDisposition;
    DWORD dwTypesSupported = 0x7;

    if (fApplication) {
        strcpy(szRegPath, 
            STAX_EVENT_SOURCE_APPLICATION_PATH_PREFIX);
    }

    strncat(szRegPath, szEventSource, 
        sizeof(szRegPath) - MAX_STAX_EVENT_SOURCE_PATH_PREFIX);

    //
    // open the path in the registry
    //
    ec = RegCreateKey(HKEY_LOCAL_MACHINE, 
                      szRegPath, 
                      &hkEventSource);
    if (ec != ERROR_SUCCESS) goto bail;

    // 
    // set the necessary keys
    //
    ec = RegSetValueEx(hkEventSource,
                       "EventMessageFile",
                       0,
                       REG_SZ,
                       (const BYTE *) szEventMessageFile,
                       strlen(szEventMessageFile));
    if (ec != ERROR_SUCCESS) goto bail;

    ec = RegSetValueEx(hkEventSource,
                       "TypesSupported",
                       0,
                       REG_DWORD,
                       (const BYTE *) &dwTypesSupported,
                       sizeof(DWORD));
    if (ec != ERROR_SUCCESS) goto bail;

bail:
    if (ec != ERROR_SUCCESS && hr == S_OK) hr = HRESULT_FROM_WIN32(ec);

    if (hkEventSource) {
        RegCloseKey(hkEventSource);
        hkEventSource = NULL;
    }

    return hr;
}

//
// Unregister your event source in the registry.
//
// Parameters:
//   szEventSource - the name of the eventsource
//
HRESULT CEventLogWrapper::RemoveEventSourceFromRegistry(char *szEventSource,
                                                        BOOL fApplication) 
{
    HRESULT hr = S_OK;
    DWORD ec;
    char szRegPath[1024] = STAX_EVENT_SOURCE_SYSTEM_PATH_PREFIX;

    if (fApplication) {
        strcpy(szRegPath, 
               STAX_EVENT_SOURCE_APPLICATION_PATH_PREFIX);
    }

    strncat(szRegPath, szEventSource,
        sizeof(szRegPath) - MAX_STAX_EVENT_SOURCE_PATH_PREFIX);

    // delete the key and its values
    ec = RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath);
    if (ec != ERROR_SUCCESS) hr = HRESULT_FROM_WIN32(ec);

    return hr;
}

DWORD ComputeHash(CEventLogHashKey  *pHashKey) {
    DWORD iHash;
    iHash = CRCHash((BYTE*)pHashKey->m_szKey, strlen(pHashKey->m_szKey) + 1);
    iHash *= pHashKey->m_idMessage;
    return iHash;
}

//
// Initialize the event logging library.
//
// Parameters:
//   szEventSource - the name of the eventsource
//
HRESULT CEventLogWrapper::Initialize(char *szEventSource) {
    HRESULT hr = S_OK;
    BOOL f;

    crcinit();

    f = m_hash.Init(&CEventLogHashItem::m_pNext,
                    100,
                    100,
                    ComputeHash,
                    2,
                    &CEventLogHashItem::GetKey,
                    &CEventLogHashItem::MatchKey);

    if (f) {
        m_hEventLog = RegisterEventSource(NULL, szEventSource);
        if (m_hEventLog == NULL) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    } else {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    return hr;
}

//
// Write an event to the event log
//
// Parameters:
//   idMessage - the eventlog ID
//   cSubstrings - count of strings in rgszSubstrings
//   rgszSubstrings - substrings for the eventlog text
//   wType - eventlog error type.  Should be EVENTLOG_WARNING_TYPE,
//     EVENTLOG_INFORMATIONAL_TYPE or EVENTLOG_ERROR_TYPE.
//   errCode - Win32 error code to log (or 0)
//   iDebugLevel - debug level of the event.  1 = highest priority,
//     2^16 = lowest priority.  normally anything above 2^15 isn't
//     logged.
//   szKey - a key which is used along with idMessage to uniquely
//     identify this eventlog.  It is used to control the options.
//   dwOptions - options for logging this event.
// Optional Parameters:
//   iMessageString - call FormatMessage on errCode and save
//     the string into rgszSubstrings[iMessageString].
//   HMODULE hModule - module with extra error codes for
//     FormatMessage.
//
// Returns:
//   S_OK - event logged
//   S_FALSE - event not logged
//   E_* - error occured
//
HRESULT CEventLogWrapper::LogEvent(DWORD idMessage,
                                   WORD cSubstrings,
                                   LPCSTR *rgszSubstrings,
                                   WORD wEventType,
                                   DWORD errCode,
                                   WORD iDebugLevel,
                                   LPCSTR szKey,
                                   DWORD dwOptions,
                                   DWORD iMessageString,
                                   HMODULE hModule)
{
    HRESULT hr = S_OK;
    void *pRawData = NULL;
    DWORD cbRawData = 0;
    char szError[MAX_PATH] = "";
    char szEmptyKey[MAX_PATH] = "";

    if (m_hEventLog == NULL) {
        return E_UNEXPECTED;
    }

    //
    // Also include errCode in raw data form
    // where people can view it from EventViewer
    // 
    if (errCode != 0) {
        cbRawData = sizeof(errCode);
        pRawData = &errCode;
    }

    if (NULL == szKey) {
        szKey = szEmptyKey;
    }

    CEventLogHashItem *pHashItem = NULL;
    DWORD dwLogMode = dwOptions & LOGEVENT_FLAG_MODEMASK;

    //
    // call FormatMessage and get an error string if that is what one
    // of the substrings should be
    //
    if (iMessageString != 0xffffffff) {
        // if its a win32 HRESULT then un-hresult it
        if ((errCode & 0x0fff0000) == (FACILITY_WIN32 << 16)) {
            errCode = errCode & 0xffff;
        }

        // rgszSubstrings should already have a slot saved for the message
        _ASSERT(iMessageString < cSubstrings);
        FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM |
                       FORMAT_MESSAGE_IGNORE_INSERTS |
                       ((hModule) ? FORMAT_MESSAGE_FROM_HMODULE : 0),
                       hModule,
                       errCode,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       szError,
                       sizeof(szError),
                       NULL);
		DWORD err = GetLastError();
        rgszSubstrings[iMessageString] = szError;
    }


    //
    // if this event is setup for onetime or perodic logging then check
    // with the hash table to see if this event has been logged before
    // and when it was last logged
    // if Key is NULL, it implies that it doesn't care about option
    //
    if ( (dwLogMode != LOGEVENT_FLAG_ALWAYS) && (szKey) ) {
        CEventLogHashKey hashkey;
        hashkey.m_szKey = (char *) szKey;
        hashkey.m_idMessage = idMessage;

        // search for this item
        g_lockHash.ShareLock();
        pHashItem = m_hash.SearchKey(&hashkey);

        if (pHashItem != NULL) {
            // if it was found then check to see if we should allow logging
            if ((dwLogMode == LOGEVENT_FLAG_ONETIME) ||
                (dwLogMode == LOGEVENT_FLAG_PERIODIC && 
                 !(pHashItem->PeriodicLogOkay())))
            {
                // this event has been logged before, so do nothing
                g_lockHash.ShareUnlock();
                return S_FALSE;
            }
        }
        g_lockHash.ShareUnlock();
    }

    //
    // log the event
    //
    if (!ReportEvent(m_hEventLog,
                     wEventType,
                     0,
                     idMessage,
                     NULL,
                     cSubstrings,
                     cbRawData,
                     rgszSubstrings,
                     pRawData))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // for any logging mode besides ALWAYS we need to update the hash
    // table.  we don't insert events which are always logged into the
    // hash table. Again, it the key is NULL, we do nothing about it
    //
    if ( SUCCEEDED(hr) && (dwLogMode != LOGEVENT_FLAG_ALWAYS) && (szKey) ) {
        g_lockHash.ExclusiveLock();
        if (pHashItem) {
            pHashItem->UpdateLogTime();
        } else {
            pHashItem = new CEventLogHashItem();
            if (pHashItem) {
                hr = pHashItem->InitializeKey(szKey, idMessage);
                if (SUCCEEDED(hr)) {
                    if (!m_hash.InsertData(*pHashItem)) {
                        hr = E_OUTOFMEMORY;
                    }
                }

                if (FAILED(hr)) {
                    delete pHashItem;
                    pHashItem = NULL;
                }
            } else {
                hr = E_OUTOFMEMORY;
            }
        }
        g_lockHash.ExclusiveUnlock();
    }

    return hr;
}

//
// Reset any history about events using this message and key,
// so that the next LogEvent with one-time or periodic logging
// will cause the event to be logged.
//
// Parameters:
//   idMessage - the eventlog ID
//   szKey - a key which is used along with idMessage to uniquely
//     identify this eventlog.
//
HRESULT CEventLogWrapper::ResetEvent(DWORD idMessage, LPCSTR szKey) {
    HRESULT hr = S_OK;
    CEventLogHashKey hashkey;

    if (m_hEventLog == NULL) {
        return E_UNEXPECTED;
    }

    hashkey.m_szKey = (char *) szKey;
    hashkey.m_idMessage = idMessage;

    g_lockHash.ExclusiveLock();
    if (!m_hash.Delete(&hashkey)) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }
    g_lockHash.ExclusiveUnlock();

    return hr;
}

CEventLogWrapper::~CEventLogWrapper() {
    if (m_hEventLog) {
        DeregisterEventSource(m_hEventLog);
        m_hEventLog = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\dnslib\mxdns.cpp ===
#include "dnsincs.h"
#include <stdlib.h>

extern void DeleteDnsRec(PSMTPDNS_RECS pDnsRec);

CAsyncMxDns::CAsyncMxDns(char *MyFQDN)
{
    lstrcpyn(m_FQDNToDrop, MyFQDN, sizeof(m_FQDNToDrop));
    m_fUsingMx = TRUE;
    m_Index = 0;
    m_LocalPref = 256;
    m_SeenLocal = FALSE;
    m_AuxList = NULL;
    m_fMxLoopBack = FALSE;

    ZeroMemory (m_Weight, sizeof(m_Weight));
    ZeroMemory (m_Prefer, sizeof(m_Prefer));
}

//-----------------------------------------------------------------------------
//  Description:
//      Given a pDnsRec (array of host IP pairs) and an index into it, this
//      tries to resolve the host at the Index position. It is assumed that
//      the caller (GetMissingIpAddresses) has checked that the host at that
//      index lacks an IP address.
//  Arguments:
//      IN PSMTPDNS_RECS pDnsRec --- Array of (host, IP) pairs.
//      IN DWORD Index --- Index of host in pDnsRec to set IP for.
//  Returns:
//      TRUE --- Success IP was filled in for host.
//      FALSE --- Either the host was not resolved from DNS or an error
//          occurred (like "out of memory").
//-----------------------------------------------------------------------------
BOOL CAsyncMxDns::GetIpFromDns(PSMTPDNS_RECS pDnsRec, DWORD Index)
{
    MXIPLIST_ENTRY * pEntry = NULL;
    BOOL fReturn = FALSE;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD rgdwIpAddresses[SMTP_MAX_DNS_ENTRIES];
    DWORD cIpAddresses = SMTP_MAX_DNS_ENTRIES;
    PIP_ARRAY pipDnsList = NULL;

    TraceFunctEnterEx((LPARAM) this, "CAsyncMxDns::GetIpFromDns");

    fReturn = GetDnsIpArrayCopy(&pipDnsList);
    if(!fReturn)
    {
        ErrorTrace((LPARAM) this, "Unable to get DNS server list copy");
        TraceFunctLeaveEx((LPARAM) this);
        return FALSE;
    }

    dwStatus = ResolveHost(
                    pDnsRec->DnsArray[Index]->DnsName,
                    pipDnsList,
                    DNS_QUERY_STANDARD,
                    rgdwIpAddresses,
                    &cIpAddresses);

    if(dwStatus == ERROR_SUCCESS)
    {
        fReturn = TRUE;
        for (DWORD Loop = 0; !IsShuttingDown() && Loop < cIpAddresses; Loop++)
        {
            pEntry = new MXIPLIST_ENTRY;
            if(pEntry != NULL)
            {
                pDnsRec->DnsArray[Index]->NumEntries++;
                CopyMemory(&pEntry->IpAddress, &rgdwIpAddresses[Loop], 4);
                InsertTailList(&pDnsRec->DnsArray[Index]->IpListHead, &pEntry->ListEntry);
            }
            else
            {
                fReturn = FALSE;
                ErrorTrace((LPARAM) this, "Not enough memory");
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                break;
            }
        }
    }
    else
    {
        ErrorTrace((LPARAM) this, "gethostbyname failed on %s", pDnsRec->DnsArray[Index]->DnsName);
        SetLastError(ERROR_NO_MORE_ITEMS);
    }

    ReleaseDnsIpArray(pipDnsList);

    TraceFunctLeaveEx((LPARAM) this);
    return fReturn;
}

//-----------------------------------------------------------------------------
//  Description:
//      This runs through the list of hosts (MX hosts, or if no MX records were
//      returned, the single target host) and verifies that they all have been
//      resolved to IP addresses. If any have been found that do not have IP
//      addresses, it will call GetIpFromDns to resolve it.
//  Arguments:
//      IN PSMTPDNS_RECS pDnsRec -- Object containing Host-IP pairs. Hosts
//          without and IP are filled in.
//  Returns:
//      TRUE -- Success, all hosts have IP addresses.
//      FALSE -- Unable to resolve all hosts to IP addresses, or some internal
//          error occurred (like "out of memory" or "shutdown in progress".
//-----------------------------------------------------------------------------
BOOL CAsyncMxDns::GetMissingIpAddresses(PSMTPDNS_RECS pDnsRec)
{
    DWORD    Count = 0;
    DWORD    Error = 0;
    BOOL    fSucceededOnce = FALSE;

    if(pDnsRec == NULL)
    {
        return FALSE;
    }

    while(!IsShuttingDown() && pDnsRec->DnsArray[Count] != NULL)
    {
        if(IsListEmpty(&pDnsRec->DnsArray[Count]->IpListHead))
        {
            SetLastError(NO_ERROR);
            if(!GetIpFromDns(pDnsRec, Count))
            {
                Error = GetLastError();
                if(Error != ERROR_NO_MORE_ITEMS)
                {
                    return FALSE;
                }
            }
            else
            {
                fSucceededOnce = TRUE;
            }
                
        }
        else
        {
            fSucceededOnce = TRUE;
        }
            

        Count++;
    }

    return ( fSucceededOnce );

}

int MxRand(char * host)
{
   int hfunc = 0;
   unsigned int seed = 0;;

   seed = rand() & 0xffff;

   hfunc = seed;
   while (*host != '\0')
    {
       int c = *host++;

       if (isascii((UCHAR)c) && isupper((UCHAR)c))
             c = tolower(c);

       hfunc = ((hfunc << 1) ^ c) % 2003;
    }

    hfunc &= 0xff;

    return hfunc;
}


BOOL CAsyncMxDns::CheckList(void)
{
    MXIPLIST_ENTRY * pEntry = NULL;
    BOOL fRet = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD rgdwIpAddresses[SMTP_MAX_DNS_ENTRIES];
    DWORD cIpAddresses = SMTP_MAX_DNS_ENTRIES;
    PIP_ARRAY   pipDnsList = NULL;

    TraceFunctEnterEx((LPARAM) this, "CAsyncDns::CheckList");
    
    if(m_Index == 0)
    {
        DebugTrace((LPARAM) this, "m_Index == 0 in CheckList");

        m_fUsingMx = FALSE;

        DeleteDnsRec(m_AuxList);

        m_AuxList = new SMTPDNS_RECS;
        if(m_AuxList == NULL)
        {
            ErrorTrace((LPARAM) this, "m_AuxList = new SMTPDNS_RECS failed");
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }

        ZeroMemory(m_AuxList, sizeof(SMTPDNS_RECS));

        m_AuxList->NumRecords = 1;

        m_AuxList->DnsArray[0] = new MX_NAMES;
        if(m_AuxList->DnsArray[0] == NULL)
        {
            ErrorTrace((LPARAM) this, "m_AuxList->DnsArray[0] = new MX_NAMES failed");
            TraceFunctLeaveEx((LPARAM)this);
            return FALSE;
        }
        
        m_AuxList->DnsArray[0]->NumEntries = 0;
        InitializeListHead(&m_AuxList->DnsArray[0]->IpListHead);
        lstrcpyn(m_AuxList->DnsArray[0]->DnsName, m_HostName,
            sizeof(m_AuxList->DnsArray[m_Index]->DnsName));

        fRet = GetDnsIpArrayCopy(&pipDnsList);
        if(!fRet)
        {
            ErrorTrace((LPARAM) this, "Unable to get DNS server list copy");
            TraceFunctLeaveEx((LPARAM) this);
            return FALSE;
        }

        dwStatus = ResolveHost(
                        m_HostName,
                        pipDnsList,
                        DNS_QUERY_STANDARD,
                        rgdwIpAddresses,
                        &cIpAddresses);

        if(dwStatus == ERROR_SUCCESS && cIpAddresses)
        {
            for (DWORD Loop = 0; Loop < cIpAddresses; Loop++)
            {
                pEntry = new MXIPLIST_ENTRY;
                if(pEntry != NULL)
                {
                    m_AuxList->DnsArray[0]->NumEntries++;
                    CopyMemory(&pEntry->IpAddress, &rgdwIpAddresses[Loop], 4);
                    InsertTailList(&m_AuxList->DnsArray[0]->IpListHead, &pEntry->ListEntry);
                }
                else
                {
                    fRet = FALSE;
                    ErrorTrace((LPARAM) this, "pEntry = new MXIPLIST_ENTRY failed in CheckList");
                    break;
                }
            }
        }
        else
        {
            fRet = FALSE;
        }

        ReleaseDnsIpArray(pipDnsList);
    }

    TraceFunctLeaveEx((LPARAM)this);
    return fRet;
}

BOOL CAsyncMxDns::SortMxList(void)
{
    BOOL fRet = TRUE;

   /* sort the records */
   for (DWORD i = 0; i < m_Index; i++)
    {
        for (DWORD j = i + 1; j < m_Index; j++)
          {
              if (m_Prefer[i] > m_Prefer[j] ||
                            (m_Prefer[i] == m_Prefer[j] && m_Weight[i] > m_Weight[j]))
              {
                       DWORD temp;
                       MX_NAMES  *temp1;

                        temp = m_Prefer[i];
                        m_Prefer[i] = m_Prefer[j];
                        m_Prefer[j] = temp;
                        temp1 = m_AuxList->DnsArray[i];
                        m_AuxList->DnsArray[i] = m_AuxList->DnsArray[j];
                        m_AuxList->DnsArray[j] = temp1;
                        temp = m_Weight[i];
                        m_Weight[i] = m_Weight[j];
                        m_Weight[j] = temp;
                }
          }

        if (m_SeenLocal && m_Prefer[i] >= m_LocalPref)
        {
            /* truncate higher preference part of list */
            m_Index = i;
        }
   }

    m_AuxList->NumRecords = m_Index;

    if(!CheckList())
    {
        DeleteDnsRec(m_AuxList);
        m_AuxList = NULL;
        fRet = FALSE;
    }

    return fRet;
}

void CAsyncMxDns::ProcessMxRecord(PDNS_RECORD pnewRR)
{
    DWORD Len = 0;

    TraceFunctEnterEx((LPARAM) this, "CAsyncDns::ProcessMxRecord");

    //
    // Leave room for NULL-termination of array
    //
    if(m_Index >= SMTP_MAX_DNS_ENTRIES-1)
    {
        DebugTrace((LPARAM) this, "SMTP_MAX_DNS_ENTRIES reached for %s", m_HostName);    
        TraceFunctLeaveEx((LPARAM)this);
        return;
    }

    if((pnewRR->wType == DNS_TYPE_MX) && pnewRR->Data.MX.nameExchange)
    {
        Len = lstrlen(pnewRR->Data.MX.nameExchange);
        if(pnewRR->Data.MX.nameExchange[Len - 1] == '.')
        {
            pnewRR->Data.MX.nameExchange[Len - 1] = '\0';
        }

        DebugTrace((LPARAM) this, "Received MX rec %s with priority %d for %s", pnewRR->Data.MX.nameExchange, pnewRR->Data.MX.wPreference, m_HostName);

        if(lstrcmpi(pnewRR->Data.MX.nameExchange, m_FQDNToDrop))
        {
            m_AuxList->DnsArray[m_Index] = new MX_NAMES;

            if(m_AuxList->DnsArray[m_Index])
            {
                m_AuxList->DnsArray[m_Index]->NumEntries = 0;;
                InitializeListHead(&m_AuxList->DnsArray[m_Index]->IpListHead);
                lstrcpyn(m_AuxList->DnsArray[m_Index]->DnsName,pnewRR->Data.MX.nameExchange, sizeof(m_AuxList->DnsArray[m_Index]->DnsName));
                m_Weight[m_Index] = MxRand (m_AuxList->DnsArray[m_Index]->DnsName);
                m_Prefer[m_Index] = pnewRR->Data.MX.wPreference;
                m_Index++;
            }
            else
            {
                DebugTrace((LPARAM) this, "Out of memory allocating MX_NAMES for %s", m_HostName);
            }
        }
        else
        {
            if (!m_SeenLocal || pnewRR->Data.MX.wPreference < m_LocalPref)
                    m_LocalPref = pnewRR->Data.MX.wPreference;

                m_SeenLocal = TRUE;
        }
    }
    else if(pnewRR->wType == DNS_TYPE_A)
    {
        MXIPLIST_ENTRY * pEntry = NULL;

        for(DWORD i = 0; i < m_Index; i++)
        {
            if(lstrcmpi(pnewRR->nameOwner, m_AuxList->DnsArray[i]->DnsName) == 0)
            {
                pEntry = new MXIPLIST_ENTRY;

                if(pEntry != NULL)
                {
                    m_AuxList->DnsArray[i]->NumEntries++;;
                    pEntry->IpAddress = pnewRR->Data.A.ipAddress;
                    InsertTailList(&m_AuxList->DnsArray[i]->IpListHead, &pEntry->ListEntry);
                }

                break;
            }
        }
    }

    TraceFunctLeaveEx((LPARAM)this);
}

void CAsyncMxDns::ProcessARecord(PDNS_RECORD pnewRR)
{
    MXIPLIST_ENTRY * pEntry = NULL;

    if(pnewRR->wType == DNS_TYPE_A)
    {
        pEntry = new MXIPLIST_ENTRY;

        if(pEntry != NULL)
        {
            pEntry->IpAddress = pnewRR->Data.A.ipAddress;
            InsertTailList(&m_AuxList->DnsArray[0]->IpListHead, &pEntry->ListEntry);
        }
    }
}

//-----------------------------------------------------------------------------
//  Description:
//      Checks to see if any of the IP addresses returned by DNS belong to this
//      machine. This is a common configuration when there are backup mail
//      spoolers. To avoid mail looping, we should delete all MX records that
//      are less preferred than the record containing the local IP address.
//
//  Arguments:
//      None.
//  Returns:
//      TRUE if no loopback
//      FALSE if loopback detected
//-----------------------------------------------------------------------------
BOOL CAsyncMxDns::CheckMxLoopback()
{
    ULONG i = 0;
    ULONG cLocalIndex = 0;
    BOOL fSeenLocal = TRUE;
    DWORD dwIpAddress = INADDR_NONE;
    DWORD dwLocalPref = 256;
    PLIST_ENTRY pListHead = NULL;
    PLIST_ENTRY pListTail = NULL;
    PLIST_ENTRY pListCurrent = NULL;
    PMXIPLIST_ENTRY pMxIpListEntry = NULL;
    
    TraceFunctEnterEx((LPARAM)this, "CAsyncMxDns::CheckMxLoopback");

    if(!m_AuxList)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return TRUE;
    }

    //
    // m_AuxList is a sorted list of MX records. Scan through it searching
    // for an MX record with a local-IP address. cLocalIndex is set to the
    // index, within m_AuxList, of this record.
    //

    while(m_AuxList->DnsArray[cLocalIndex] != NULL)
    {
        pListTail = &(m_AuxList->DnsArray[cLocalIndex]->IpListHead);
        pListHead = m_AuxList->DnsArray[cLocalIndex]->IpListHead.Flink;
        pListCurrent = pListHead;

        while(pListCurrent != pListTail)
        {
            pMxIpListEntry = CONTAINING_RECORD(pListCurrent, MXIPLIST_ENTRY, ListEntry);
            dwIpAddress = pMxIpListEntry->IpAddress;

            if(IsAddressMine(dwIpAddress))
            {
                DNS_PRINTF_MSG("Local host's IP is one of the target IPs.\n");
                DNS_PRINTF_MSG("Discarding all equally or less-preferred IP addresses.\n"); 

                DebugTrace((LPARAM)this, "Local record found in MX list, name=%s, pref=%d, ip=%08x",
                                m_AuxList->DnsArray[cLocalIndex]->DnsName,
                                m_Prefer[cLocalIndex],
                                dwIpAddress);

                // All records with preference > m_Prefer[cLocalIndex] should be deleted. Since
                // m_AuxList is sorted by preference, we need to delete everthing with index >
                // cLocalIndex. However since there may be some records with preference == local-
                // preference, which occur before cLocalIndex, we walk backwards till we find
                // the first record with preference = m_Prefer[cLocalIndex].

                dwLocalPref = m_Prefer[cLocalIndex];
                
                while(cLocalIndex > 0 && dwLocalPref == m_Prefer[cLocalIndex])
                    cLocalIndex--;

                if(dwLocalPref != m_Prefer[cLocalIndex])
                    cLocalIndex++;

                fSeenLocal = TRUE;

                // All records > cLocalIndex are even less preferred than this one,
                // (since m_AuxList already sorted) and will be deleted.
                goto END_SEARCH; 
            }

            pListCurrent = pListCurrent->Flink;
        }
            
        cLocalIndex++;
    }

END_SEARCH:
    //
    // If a local-IP address was found, delete all less-preferred records
    //
    if(fSeenLocal)
    {
        DebugTrace((LPARAM)this,
            "Deleting all MX records with lower preference than %d", m_Prefer[cLocalIndex]);

        for(i = cLocalIndex; m_AuxList->DnsArray[i] != NULL; i++)
        {
            if(!m_AuxList->DnsArray[i]->DnsName[0])
                continue;

            while(!IsListEmpty(&(m_AuxList->DnsArray[i]->IpListHead)))
            {
                pListCurrent = RemoveHeadList(&(m_AuxList->DnsArray[i]->IpListHead));
                pMxIpListEntry = CONTAINING_RECORD(pListCurrent, MXIPLIST_ENTRY, ListEntry);
                delete pMxIpListEntry;
            }

            delete m_AuxList->DnsArray[i];
            m_AuxList->DnsArray[i] = NULL;
        }
        m_AuxList->NumRecords = cLocalIndex;

        // No records left
        if(m_AuxList->NumRecords == 0)
        {
            DNS_PRINTF_ERR("DNS configuration error (loopback), messages will be NDRed.\n");
            DNS_PRINTF_ERR("Local host's IP address is the most preferred MX record.\n");

            ErrorTrace((LPARAM)this, "Possible misconfiguration: most preferred MX record is loopback");
            _ASSERT(m_AuxList->pMailMsgObj == NULL);
            delete m_AuxList;
            m_AuxList = NULL;
            return FALSE;
        }
    }


    TraceFunctLeaveEx((LPARAM)this);
    return TRUE;
}

void CAsyncMxDns::DnsProcessReply(
    DWORD status,
    PDNS_RECORD pRecordList)
{
    TraceFunctEnterEx((LPARAM) this, "CAsyncDns::DnsParseMessage");
    PDNS_RECORD pTmp = NULL;

    m_SeenLocal = FALSE;
    m_LocalPref = 256;

    m_AuxList = new SMTPDNS_RECS;
    if(!m_AuxList)
    {
        return;
    }

    ZeroMemory(m_AuxList, sizeof(SMTPDNS_RECS));
    
    //
    //  Due to Raid #122555 m_fUsingMx is always TRUE in this function
    //    - hence we will always go a GetHostByName() if there is no MX
    //      record.  It would be better Perf if we did a A record lookup.
    //
    DebugTrace((LPARAM) this, "Parsed DNS record for %s. status = 0x%08x", m_HostName, status);

    switch(status)
    {
    case ERROR_SUCCESS:
        //
        //  Got the DNS record we want.
        //
        DNS_PRINTF_MSG("Processing MX/A records in reply.\n");

        DebugTrace((LPARAM) this, "Success: DNS record parsed");
        pTmp = pRecordList;
        while( pTmp )
        {
            if( m_fUsingMx )
            {
                ProcessMxRecord( pTmp );
            }
            else
            {
                ProcessARecord( pTmp );
            }
            pTmp = pTmp->pNext;
        }

        if(m_fUsingMx)
        {
            //
            //  SortMxList sorts the MX records by preference and calls
            //  gethostbyname() to resolve A records for Mail Exchangers
            //  if needed (when the A records are not returned in the
            //  supplementary info).
            //

            DNS_PRINTF_MSG("Sorting MX records by priority.\n");
            if(SortMxList())
            {
                status = ERROR_SUCCESS;
                DebugTrace((LPARAM) this, "SortMxList() succeeded.");
            }
            else
            {
                status = ERROR_RETRY; 
                ErrorTrace((LPARAM) this, "SortMxList() failed. Message will stay queued.");
            }
        }
        break;
 
    case DNS_ERROR_RCODE_NAME_ERROR:
        //  Fall through to using gethostbyname()

    case DNS_INFO_NO_RECORDS:
        //  Non authoritative host not found.
        //  Fall through to using gethostbyname()

    default:
        DebugTrace((LPARAM) this, "Error in query: status = 0x%08x.", status);

        //
        //  Use gethostbyname to resolve the hostname:
        //  One issue with our approach is that sometimes we will NDR the message
        //  on non-permanent errors, "like WINS server down", when gethostbyname
        //  fails. However, there's no way around it --- gethostbyname doesn't
        //  report errors in a reliable manner, so it's not possible to distinguish
        //  between permanent and temporary errors.
        //

        if (!CheckList ()) {

            if(status == DNS_ERROR_RCODE_NAME_ERROR) {

                DNS_PRINTF_ERR("Host does not exist in DNS. Messages will be NDRed.\n");
                ErrorTrace((LPARAM) this, "Authoritative error");
                status = ERROR_NOT_FOUND;
            } else {

                DNS_PRINTF_ERR("Host could not be resolved. Messages will be retried later.\n");
                ErrorTrace((LPARAM) this, "Retryable error");
                status = ERROR_RETRY;
            }

        } else {

            DebugTrace ((LPARAM) this, "Successfully resolved using gethostbyname");
            status = ERROR_SUCCESS;
        }
        
        break;
    }

    //
    // Make a last ditch effort to fill in the IP addresses for any hosts
    // that are still unresolved.
    //

    if(m_AuxList && status == ERROR_SUCCESS)
    {
        if(!GetMissingIpAddresses(m_AuxList))
        {
            DeleteDnsRec(m_AuxList);
            m_AuxList = NULL;
            status = ERROR_RETRY;
            goto Exit;
        }

        if(!CheckMxLoopback())
        {
            m_fMxLoopBack = TRUE;
            DeleteDnsRec(m_AuxList);
            m_AuxList = NULL;
            TraceFunctLeaveEx((LPARAM) this);
            return;
        }
    }

    //
    // End of resolve: HandleCompleted data examines the DnsStatus and results, and sets up
    // member variables of CAsyncMxDns to either NDR messages, connect to the remote host
    // or ack this queue for retry when the object is deleted.
    //
Exit:
    HandleCompletedData(status);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\export\makefile.inc ===
copyfiles:
!if "$(_NTTREE)" != ""
	perl -S xcopy2binplace.pl /verifd ..\$(O)\*.* $(_NTTREE)\staxpt\export\lib
!endif

!if "$(_NTTREE_NO_SPLIT)" != ""
	perl -S xcopy2binplace.pl /verifd ..\$(O)\*.* $(_NTTREE_NO_SPLIT)\staxpt\export\lib
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\fcache2\sdcache.h ===
/*++

	SDCACHE.H

	This file defines the interface to the Security 


--*/

#ifndef	_SDCACHE_H_
#define	_SDCACHE_H_

typedef
BOOL
(WINAPI	*CACHE_ACCESS_CHECK)(	IN	PSECURITY_DESCRIPTOR	pSecurityDescriptor,
								IN	HANDLE					hClientToken,
								IN	DWORD					dwDesiredAccess, 
								IN	PGENERIC_MAPPING		GenericMapping, 
								IN	PRIVILEGE_SET*			PrivilegeSet, 
								IN	LPDWORD					PrivilegeSetLength,
								IN	LPDWORD					GrantedAccess, 
								IN	LPBOOL					AccessStatus
								) ;





//
//	Define the key for the hash tables we will be using !
//
class	CSDKey	{
private : 
	//
	//	pointer to the GENERIC_MAPPING portion of the key
	//
	PGENERIC_MAPPING		m_pMapping ;
	//
	//	pointer to the security descriptor portion of the key.
	//
	PSECURITY_DESCRIPTOR	m_pSecDesc ;
	//
	//	No use of default constructor allowed !
	//
	CSDKey() ;
	//
	//	CSDObject is allowed access to our inner members !
	//
	friend	class	CSDObject ;

public : 

	//
	//	the length of the security descriptor !
	//	this is publicly available, but should be read only !
	//
	int						m_cbSecDesc ;

	//
	//	Can only construct a key if these are provided 
	//
	inline
	CSDKey(	PGENERIC_MAPPING	pg, 
			PSECURITY_DESCRIPTOR	pSecDesc
			) : 
		m_pMapping( pg ), 
		m_pSecDesc( pSecDesc ), 
		m_cbSecDesc( GetSecurityDescriptorLength( pSecDesc ) )	{
		_ASSERT(IsValid()) ;
	}

	//
	//	Check that we're correctly initialized !
	//
	BOOL
	IsValid() ;

	//
	//	compare two keys for equality !
	//
	static
	int	
	MatchKey(	CSDKey left, CSDKey	right ) ;

	//
	//	compute the hash function of this key !
	//
	static	
	DWORD
	HashKey(	CSDKey	Key ) ;
} ;


class	CSDObjectContainer	; 

//
//	This is a variable length object that is placed within the buckets
//	of a hash table.  Each object contains a Security Descriptor, and 
//	the GENERIC_MAPPING relevant to evaluating that Security Descriptor.
//
class	CSDObject	{
private : 

	enum	CONSTANTS	{
		SIGNATURE = 'ODSC', 
		DEAD_SIGNATURE	= 'ODSX'
	} ;

	//
	//	help us recognize this thing in the debugger.
	//
	DWORD			m_dwSignature ;

	//
	//	The refcount for this item.
	//
	volatile	long	m_cRefCount ;

	//
	//	The item we use to chain this into a hash bucket.
	//
	DLIST_ENTRY		m_list ;

	//
	//	Store our Hash Value so that we have easy access to it !
	//
	DWORD			m_dwHash ;

	//
	//	Back pointer to the CSDContainer holding our locks !
	//
	CSDObjectContainer*	m_pContainer ;

	//
	//	The GENERIC_MAPPING structure the client provided and associated
	//	with the use of this security descriptor.
	//
	GENERIC_MAPPING	m_mapping ;

	//
	//	This is a variable length field containing the 
	//	Security descriptor we're holding.
	//
	DWORD			m_rgdwSD[1] ;

	//
	//	Return the security descriptor we're holding within ourselves.
	//
	inline	
	PSECURITY_DESCRIPTOR
	SecurityDescriptor()	{
		return	(PSECURITY_DESCRIPTOR)&(m_rgdwSD[0]) ;
	}

	//
	//	Return the length of the internally held security descriptor.
	//
	inline	
	DWORD
	SecurityDescriptorLength()	{
		return	GetSecurityDescriptorLength(SecurityDescriptor()) ;
	}

	//
	//	Not available to external clients !
	//
	CSDObject() ; 

public : 

    typedef		DLIST_ENTRY*	(*PFNDLIST)( class	CSDObject*  ) ; 

	//
	//	Construct a security descriptor object for the cache !
	//
	inline
	CSDObject(	DWORD			dwHash,
				CSDKey&			key, 
				CSDObjectContainer*	p
				) : 
		m_dwSignature( SIGNATURE ), 
		m_cRefCount( 2 ), 
		m_dwHash( dwHash ), 
		m_pContainer( p ),
		m_mapping( *key.m_pMapping )	{
		CopyMemory( m_rgdwSD, key.m_pSecDesc, GetSecurityDescriptorLength(key.m_pSecDesc) ) ;
	}

	//
	//	Our trivial destructor just makes it easy to recognize
	//	released objects in the debugger .
	//
	~CSDObject( )	{
		m_dwSignature = DEAD_SIGNATURE ;
	}

	//
	//	Need a special operator new to get our variable size part correct !
	//
	void*
	operator	new(	size_t	size, CSDKey&	key ) ;

	//
	//	Handle the release correctly !
	//	
	void
	operator	delete( void* ) ;


	//
	//	We don't allow just anybody to Add References to us !
	//
	inline
	long
	AddRef()	{
		return	InterlockedIncrement((long*)&m_cRefCount) ;
	}

	//
	//	Anybody is allowed to remove a reference from us !
	//
	long
	Release() ;


	//
	//	Check that we are a valid object !
	//
	BOOL
	IsValid() ;

	//
	//	Determine whether the client has access or not !
	//
	BOOL
	AccessCheck(	HANDLE	hToken, 
					ACCESS_MASK	accessMask,
					CACHE_ACCESS_CHECK	pfnAccessCheck
					) ;	

	//---------------------------
	//	
	//	Hash table support functions - 
	//	the following set of functions support the use of these objects
	//	in the standard hash tables defined in fdlhash.h
	//

	//
	//	Get the offset to the doubly linked list within the object.
	//
	inline	static
	DLIST_ENTRY*
	HashDLIST(	CSDObject*	p ) {
		return	&p->m_list ;
	}

	//
	//	Get the hash value out of the object !
	//
	inline	static	DWORD
	ReHash(	CSDObject*	p )		{
		_ASSERT(	p->IsValid() ) ;
		return	p->m_dwHash ;
	}

	//
	//	return our key to the caller !
	//
	inline	CSDKey
	GetKey()	{
		_ASSERT( IsValid() ) ;
		return	CSDKey( &m_mapping, SecurityDescriptor() ) ;
	}
} ;


//
//	This defines a hash table containing security descriptors !
//
typedef	TFDLHash<	class	CSDObject, 
					class	CSDKey, 
					&CSDObject::HashDLIST >	SDTABLE ;

//
//	This object provides the locking and hash table for a specified set
//	of security descriptors !
//
class	CSDObjectContainer	{
private : 

	enum	CONSTANTS	{
		SIGNATURE = 'CDSC', 
		DEAD_SIGNATURE	= 'CDSX', 
		INITIAL_BUCKETS = 32, 
		INCREMENT_BUCKETS = 16, 
		LOAD = 8
	} ;

	//
	//	The signature of the Security Descriptor Container !
	//
	DWORD	m_dwSignature ;

	//
	//	The lock that protects this hash table !
	//
	CShareLockNH	m_lock ;

	//
	//	A hash table instance !
	//
	SDTABLE			m_table ;

	//
	//	our friends include CSDObject which needs to unlike 
	//	out of our hash table upon destruction.
	//
	friend	class	CSDObject ;

public : 

	//
	//	construct one of these guys !
	//
	CSDObjectContainer() : 
		m_dwSignature( SIGNATURE )	{
	}

	//
	//	Our trivial destructor just makes it easy to recognize
	//	released objects in the debugger .
	//
	~CSDObjectContainer()	{
		m_dwSignature = DEAD_SIGNATURE ;
		
	}

	//
	//	Initialize this particular table
	//
	inline
	BOOL
	Init()	{
		return
			m_table.Init(	INITIAL_BUCKETS, 
							INCREMENT_BUCKETS, 
							LOAD, 
							CSDKey::HashKey, 
							CSDObject::GetKey, 
							CSDKey::MatchKey, 
							CSDObject::ReHash
							) ;
	}

	//
	//	Now - find or create a given security descriptor 
	//	item !
	//
	CSDObject*
	FindOrCreate(	DWORD	dwHash, 
					CSDKey&	key 
					) ;

} ;

typedef	CRefPtr2<CSDObject>			PTRCSDOBJ ;
typedef	CHasRef<CSDObject,FALSE>	HCSDOBJ ;

//
//	This class provides our external interface for caching security descriptors.
//
class	CSDMultiContainer	{
private : 

	enum	CONSTANTS	{
		SIGNATURE = 'ODSC', 
		DEAD_SIGNATURE	= 'ODSX',
		CONTAINERS=37			// pick a nice prime number !
	} ;

	//
	//	our signature !
	//
	DWORD		m_dwSignature ;
	//
	//	a bunch of child containers !
	//
	CSDObjectContainer	m_rgContainer[CONTAINERS] ;
public : 

	inline
	CSDMultiContainer() : 
		m_dwSignature( SIGNATURE )	{
	}

	inline
	HCSDOBJ
	FindOrCreate(	PGENERIC_MAPPING		pMapping, 
					PSECURITY_DESCRIPTOR	pSecDesc
					)	{

		CSDKey	key( pMapping, pSecDesc ) ;
		DWORD	dwHash = CSDKey::HashKey( key ) ;
		DWORD	i = dwHash % CONTAINERS ;

		return	m_rgContainer[i].FindOrCreate(	dwHash, key ) ;
	}

	BOOL
	Init() ;

} ;

#endif	_SDCACHE_H_	// end of the security descriptor cache !
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\fcache2\dll\fcachimp.h ===
/*++

	FCACHIMP.H

	This file contains a lot of the internal guts of the 
	File Handle Cache structures.


--*/


#ifndef	_FCACHIMP_H_
#define	_FCACHIMP_H_

#define	_FILEHC_IMPLEMENTATION_
#ifndef _NT4_TEST_
#endif
#include	"atq.h"
#include	"irtlmisc.h"
#include	"xmemwrpr.h"
#include	"dbgtrace.h"
#include	"cache2.h"
#include	"filehc.h"
#include	"dotstuff.h"
#include	"sdcache.h"

// Non Public portions -
	

#include	"refptr2.h"
#include	"rwnew.h"
#include	"crchash.h"


//
//	Define a smart pointer for Dot Stuffing objects !
//
typedef	CRefPtr2< IDotManipBase >	DOTPTR ;
typedef	CRefPtr2HasRef< IDotManipBase >	DOTHASREFPTR ;


//
//	The following defines all of the functions that we call into
//	IIS and Atq to accomplish our async IO stuff !
//
typedef	
BOOL
(*PFNAtqInitialize)(
    IN DWORD dwFlags
    );

typedef	
BOOL
(*PFNAtqTerminate)(
    VOID
    );

typedef	
BOOL
(WINAPI
*PFNAtqAddAsyncHandle)(
    OUT PATQ_CONTEXT * ppatqContext,
    IN  PVOID          EndpointObject,
    IN  PVOID          ClientContext,
    IN  ATQ_COMPLETION pfnCompletion,
    IN  DWORD          TimeOut,
    IN  HANDLE         hAsyncIO
    );

typedef
BOOL
(*PFNAtqCloseSocket)(
    PATQ_CONTEXT patqContext,
    BOOL         fShutdown
    );

typedef
BOOL
(*PFNAtqCloseFileHandle)(
    PATQ_CONTEXT patqContext
    );


typedef
VOID
(*PFNAtqFreeContext)(
    IN PATQ_CONTEXT   patqContext,
    BOOL              fReuseContext
    );


typedef	
BOOL
(WINAPI
*PFNAtqReadFile)(
    IN  PATQ_CONTEXT patqContext,
    IN  LPVOID       lpBuffer,
    IN  DWORD        BytesToRead,
    IN  OVERLAPPED * lpo OPTIONAL
    );

typedef
BOOL
(WINAPI
*PFNAtqWriteFile)(
    IN  PATQ_CONTEXT patqContext,
    IN  LPCVOID      lpBuffer,
    IN  DWORD        BytesToWrite,
    IN  OVERLAPPED * lpo OPTIONAL
    );

typedef	
BOOL
(WINAPI
*PFNAtqIssueAsyncIO)(
    IN  PATQ_CONTEXT patqContext,
    IN  LPVOID      lpBuffer,
    IN  DWORD        BytesToWrite,
    IN  OVERLAPPED * lpo OPTIONAL
    );

typedef	
BOOL
(WINAPI
*PFNInitializeIISRTL)();

// call before unloading
typedef
void
(WINAPI
*PFNTerminateIISRTL)();



//
//	The DLL's we load to do this stuff !
//
extern	HINSTANCE			g_hIsAtq ;
extern	HINSTANCE			g_hIisRtl ;
//
//	Function pointers for all our thunks into IIS stuff !
//
extern	PFNAtqInitialize	g_AtqInitialize ;
extern	PFNAtqTerminate		g_AtqTerminate ;
extern	PFNAtqAddAsyncHandle	g_AtqAddAsyncHandle ;
extern	PFNAtqCloseFileHandle	g_AtqCloseFileHandle ;
extern	PFNAtqFreeContext		g_AtqFreeContext ;
extern	PFNAtqIssueAsyncIO		g_AtqReadFile ;
extern	PFNAtqIssueAsyncIO		g_AtqWriteFile ;
extern	PFNInitializeIISRTL		g_InitializeIISRTL ;
extern	PFNTerminateIISRTL		g_TerminateIISRTL ;

//
//	The lifetime of each cache entry - in seconds !
//
extern	DWORD	g_dwLifetime ;	// default is 30 minutes
//
//	The maximum number of elements the cache should allow
//
extern	DWORD	g_cMaxHandles ;	// default - 10000 items !
//
//	The number of subcaches we should use - larger number can
//	increase parallelism and reduce contention !
//
extern	DWORD	g_cSubCaches ;


//
//	These constants are used within the API's
//	on structures we export to users !
//
enum	INTERNAL_CONSTANTS	{
	ATQ_ENABLED_CONTEXT = 'banE',
	FILE_CONTEXT = 'eliF',
	CACHE_CONTEXT = 'caCF',
	DEL_FIO = 'eliX',
	DEL_CACHE_CONTEXT = 'caCX',
	ILLEGAL_CONTEXT = 'ninU'
} ;

//
//	The function that initializes all of the data structures for the
//	name cache manager !
//
extern	BOOL	InitNameCacheManager() ;
extern	void	TermNameCacheManager() ;


struct	DOT_STUFF_MANAGER	{
/*++

	This class will manage the offsets and stuff that we need to track dot stuffing changes

--*/

	//
	//	This is the accumulated bias against the users writes which we add to
	//	the offsets of their writes !
	//
	int	m_cbCumulativeBias ;
	
	//
	//	The object which intercepts and manipulates buffers !
	//
	DOTPTR	m_pManipulator ;

	//
	//	Set our intial state to a blank slate !
	//
	DOT_STUFF_MANAGER() :
		m_cbCumulativeBias( 0 ),
		m_pManipulator( 0 )	{
	}

	//
	//	Helper function which manipulates the requested IO !
	//
	BOOL
	IssueAsyncIO(
			IN	PFNAtqIssueAsyncIO	pfnIO,
			IN	PATQ_CONTEXT	patqContext,
			IN	LPVOID			lpb,
			IN	DWORD			BytesToTransfer,
			IN	DWORD			BytesAvailable,
			IN	FH_OVERLAPPED*	lpo,
			IN	BOOL			fFinalIO,
			IN	BOOL			fTerminatorIncluded
			) ;

	//
	//	Helper function for when we need to capture the IO when it completes
	//
	BOOL
	IssueAsyncIOAndCapture(
			IN	PFNAtqIssueAsyncIO	pfnIO,
			IN	PATQ_CONTEXT		patqContext,
			IN	LPVOID				lpb,
			IN	DWORD				BytesToTransfer,
			IN	FH_OVERLAPPED*		lpo,
			IN	BOOL				fFinalIO,
			IN	BOOL				fTerminatorIncluded
			) ;


	//
	//	This function manipulates completions that were issued by IssueAsyncIO()
	//
	static	void
	AsyncIOCompletion(	
			IN	FIO_CONTEXT*	pContext,
			IN	FH_OVERLAPPED*	lpo,
			IN	DWORD			cb,
			IN	DWORD			dwCompletionStatus
			) ;

	static	void
	AsyncIOAndCaptureCompletion(	
			IN	FIO_CONTEXT*	pContext,
			IN	FH_OVERLAPPED*	lpo,
			IN	DWORD			cb,
			IN	DWORD			dwCompletionStatus
			) ;

	//
	//	Setup the dot stuffing state of this item !
	//
	BOOL
	SetDotStuffing(	BOOL	fEnable,
					BOOL	fStripDots
					) ;

	//
	//	Setup the dot scanning state of this item !
	//
	BOOL
	SetDotScanning(	BOOL	fEnable	) ;

	//
	//	Return the results of our dot scanning efforts !
	//
	BOOL
	GetStuffState(	BOOL&	fStuffed ) ;

} ;



struct	FIO_CONTEXT_INTERNAL	{
	DWORD		m_dwHackDword ;	
	//
	//	The context signature !
	//
	DWORD		m_dwSignature ;
	//
	//	The file handle associated with the completion context !
	//
	HANDLE		m_hFile ;
    //
    //  Offset to lines header to back fill from
    //
    DWORD       m_dwLinesOffset;
    //
    //  Header length, nntp aware only
    //
    DWORD       m_dwHeaderLength;
	//
	//	Pointer to the AtqContext associated with this file !
	//
	PATQ_CONTEXT	m_pAtqContext ;

	BOOL
	IsValid()	{
		if( m_dwSignature == DEL_FIO )	{
			return	FALSE ;
		}	else	if( m_dwSignature == ILLEGAL_CONTEXT ) {
			if( m_hFile != INVALID_HANDLE_VALUE )
				return	FALSE ;
			if( m_pAtqContext != 0 )
				return	FALSE ;
		}	else if( m_dwSignature == FILE_CONTEXT ) {
			if( m_hFile == INVALID_HANDLE_VALUE )
				return	FALSE ;
			if( m_pAtqContext != 0 )
				return	FALSE ;
		}	else if( m_dwSignature == ATQ_ENABLED_CONTEXT ) {
			if( m_hFile == INVALID_HANDLE_VALUE )
				return	FALSE ;
			if( m_pAtqContext == 0 )
				return	FALSE ;
			if( m_pAtqContext->hAsyncIO != m_hFile && m_pAtqContext->hAsyncIO != 0 )
				return	FALSE ;
		}	else	{
			return	FALSE ;
		}
		return	TRUE ;
	}

	//
	//	
	//
	FIO_CONTEXT_INTERNAL() :
		m_dwSignature( ILLEGAL_CONTEXT ),
		m_hFile( INVALID_HANDLE_VALUE ),
		m_pAtqContext( 0 ) {
	}

	~FIO_CONTEXT_INTERNAL()	{
		//
		//	Make sure we haven't been destroyed once already !
		//
		_ASSERT( m_dwSignature !=	DEL_FIO ) ;
		if( m_hFile != INVALID_HANDLE_VALUE ) {
			_ASSERT( IsValid() ) ;
			if( m_pAtqContext != 0 ) {
				_VERIFY( g_AtqCloseFileHandle( m_pAtqContext ) ) ;
				//
				//	NOTE : probably destroyed on an expiration
				//	thread - can't reuse the AtqContext !
				//
				g_AtqFreeContext( m_pAtqContext, FALSE ) ;
			}	else	{
				_VERIFY( CloseHandle( m_hFile ) ) ;
			}
		}
		//
		//	Mark this thing as dead !
		//
		m_dwSignature = DEL_FIO ;
	}

} ;



class	CFileCacheKey	{
/*++

Class Description :

	This class is the key for entries into our file handle cache !

--*/
private :

	//
	//	This constructor is private -
	//
	CFileCacheKey() ;

	//
	//	Constants for our class
	//
	enum	CONSTANTS	{
		BUFF_SIZE	= 254,
	} ;

	//
	//	Buffer for the path !
	//
	char		m_szBuff[BUFF_SIZE] ;
	//
	//	Length of the path !
	//
	DWORD		m_cbPathLength ;
public :

	//
	//	Pointer to the path !	
	//
	LPSTR		m_lpstrPath ;

	//
	//	Determine whether we have a valid Cache Key !
	//
	BOOL
	IsValid()  ;

	//
	//	Construct one of these objects from the user provided key !
	//
	CFileCacheKey(	LPSTR	lpstr	) ;
	
	//
	//	We must have a Copy Constructor ! -
	//	It is only used the MultiCacheEx<>, so
	//	we safely wipe out the RHS CFileCacheKey !
	//
	CFileCacheKey(	CFileCacheKey&	key ) ;

	//
	//	Tell the client whether we're usable !
	//
	BOOL
	FInit()	;

	//
	//	Destroy ourselves !
	//
	~CFileCacheKey() ;

	static
	DWORD
	FileCacheHash(	CFileCacheKey*	p )	;

	static
	int
	MatchKey(	CFileCacheKey*	pLHS, CFileCacheKey*  pRHS ) ;
} ;



class	CCacheKey	{
private : 
	//
	//	The name of this name cache !	
	//
	LPSTR			m_lpstrName ;
	//
	//	Client provided arguments for the name cache !
	//
	CACHE_KEY_COMPARE	m_pfnCompare ;
	//
	//
	//
	CACHE_DESTROY_CALLBACK	m_pfnKeyDestroy ;
	//
	//
	//
	CACHE_DESTROY_CALLBACK	m_pfnDataDestroy ;
	//
	//	Can't construct without arguments 
	//
	CCacheKey() ;
	//
	//	A CNameCacheInstance gets to peek inside !
	//
	friend	class	CNameCacheInstance ;
	//
	//	The key's of name caches get to peek inside at 
	//	the function pointers we hold within !
	//
	friend	class	CNameCacheKey ;
public : 
	//
	//	Client provided hash function 
	//	
	CACHE_KEY_HASH		m_pfnHash ;
	
	inline
	CCacheKey(	LPSTR	lpstrName, 
				CACHE_KEY_COMPARE	pfnCompare, 
				CACHE_KEY_HASH		pfnKeyHash, 
				CACHE_DESTROY_CALLBACK	pfnKeyDestroy, 
				CACHE_DESTROY_CALLBACK	pfnDataDestroy
				) : 
		m_lpstrName( lpstrName ), 
		m_pfnCompare( pfnCompare ),
		m_pfnHash( pfnKeyHash ),
		m_pfnKeyDestroy( pfnKeyDestroy ), 
		m_pfnDataDestroy( pfnDataDestroy )	{
		_ASSERT(IsValid()) ;
	}

	//
	//	Check that we're correctly setup !
	//
	BOOL
	IsValid() ;

	//
	//	Free the embedded string !
	//	called by the destructor for ~CNameCacheInstance !
	//
	void
	FreeName()	{
		delete[]	m_lpstrName ;
	}
	

	//
	//	Compare two keys for equality !
	//
	static	int	
	MatchKey(	CCacheKey*	pKeyLeft,	
				CCacheKey*	pKeyRight
				) ;

	//
	//	Compute the hash function of a key !	
	//
	static	DWORD
	HashKey(	CCacheKey*	pKeyLeft ) ;
} ;	


class	CNameCacheKey	{
protected : 
	enum	CONSTANTS	{
		//
		//	Number of bytes we use off stack when we need to 
		//	extract a key for a client !
		//
		CB_STACK_COMPARE=2048,
		//
		//	Number of bytes we will embed within a key !
		//
		CB_EMBEDDED=192
	} ;

	//
	//	Byte array holding embeddable portion of the key !
	//
	BYTE					m_rgbData[CB_EMBEDDED] ;
	//
	//	The hash function of our key !
	//
	DWORD					m_dwHash ;
	//
	//	user provided key comparison function !
	//
	class	CCacheKey*		m_pCacheData ;
	//
	//	Number of bytes used to hold the key
	//
	DWORD					m_cbKey ;
	//
	//	Number of bytes used to hold client data !
	//
	DWORD					m_cbData ;
	//
	//	pointer for any portion we could not hold completely 
	//	within the key object !
	//
	LPBYTE					m_lpbExtra ;

	//
	//	Nobody is allowed to create these guys externally !
	//
	CNameCacheKey() : 
		m_dwHash( 0 ), 
		m_pCacheData( 0 ), 
		m_cbKey( 0 ),
		m_cbData( 0 ),
		m_lpbExtra( 0 ),
		m_pSD( 0 ) {
	}

	//
	//	Available for derived classes !
	//
	CNameCacheKey(
			DWORD	dwHash, 
			CCacheKey*	pCacheData, 
			PTRCSDOBJ&	pSD
			) : 
		m_dwHash( dwHash ), 
		m_pCacheData( pCacheData ), 
		m_pSD( pSD ), 
		m_lpbExtra( 0 ), 
		m_cbData( 0 )	{
	}

public : 

	//
	//	pointer to a Security Descriptor that a user associated
	//	with this name !
	//
	PTRCSDOBJ				m_pSD ;

	//
	//	Construct this guy from a copy - note the copy may be 
	//	a derived class with a different implementation !
	//
	CNameCacheKey(	CNameCacheKey&	key )	{

		_ASSERT(key.fCopyable() ) ;
		_ASSERT(key.m_cbKey != 0 ) ;
		_ASSERT(key.IsValid() ) ;

		m_cbKey = key.m_cbKey ;
		m_cbData = key.m_cbData ;

		CopyMemory( m_rgbData, key.m_rgbData, min(sizeof(m_rgbData), m_cbData+m_cbKey) ) ;

		m_dwHash = key.m_dwHash ;		
		m_pCacheData = key.m_pCacheData ;
		m_pSD = key.m_pSD ;
		m_lpbExtra = key.m_lpbExtra ;

		//
		//	Make the key useless and invalid !
		//		
		key.m_cbKey = 0 ;
		key.m_cbData = 0 ;
		key.m_lpbExtra = 0 ;

		_ASSERT(IsValid()) ;
	} 

	//
	//	Check that the key appears to be in a valid state !
	//
	virtual	BOOL
	IsValid()	{
		BOOL	fValid = TRUE ;

		fValid &= m_cbKey != 0 ;
		if( m_cbKey + m_cbData < sizeof(m_rgbData) ) {
			fValid &= m_lpbExtra == 0 ;
		}	else	{
			fValid &= m_lpbExtra != 0 ;
		}
		_ASSERT( fValid ) ;
		//fValid &= m_pSD != 0 ;
		fValid &= m_pCacheData != 0 ;
		_ASSERT( fValid ) ;
		return	fValid ;
	}

	//
	//	this function gets the key that we need to compare out of the object
	//
	virtual	inline
	LPBYTE	RetrieveKey(	DWORD&	cb ) {
		_ASSERT( IsValid() ) ;
		cb = m_cbKey ;
		if( m_cbKey < sizeof(m_rgbData) ) {
			if( m_cbKey != 0 ) {
				return	m_rgbData ;
			}	else	{
				return	0 ;
			}
		}	
		_ASSERT( m_lpbExtra != 0 ) ;
		return	m_lpbExtra ;
	}

	//
	//	return the data portion of the key to the caller !
	//
	virtual	inline
	LPBYTE	RetrieveData(	DWORD&	cb )	{
		cb = m_cbData ;
		if( cb==0 ) {
			return	0 ;
		}
		if( (m_cbKey + m_cbData) < sizeof( m_rgbData ) ) {
			return	&m_rgbData[m_cbKey] ;
		}	else	if( m_cbKey < sizeof( m_rgbData ) ) {
			return	m_lpbExtra ;
		}	else	{
			return	&m_lpbExtra[m_cbKey] ;
		}
	}


	//
	//	Destructor is virtual as we have derived classes !
	//	(although we probably aren't destroyed through pointers).
	//
	virtual
	~CNameCacheKey()	{
		if(	m_pCacheData )	{
			if( m_pCacheData->m_pfnKeyDestroy ) {
				DWORD	cb ;
				LPBYTE	lpb = RetrieveData( cb ) ;
				if( lpb )	{
					m_pCacheData->m_pfnKeyDestroy(	cb, lpb ) ;
				}
			}
			if( m_pCacheData->m_pfnDataDestroy ) {
				DWORD	cb ;
				LPBYTE	lpb = RetrieveData( cb ) ;
				if( lpb ) {
					m_pCacheData->m_pfnDataDestroy( cb, lpb ) ;
				}
			}
		}
		if( m_lpbExtra )	{
			delete[]	m_lpbExtra ;
		}
	}

	//
	//	Define a virtual function to determine whether a derived
	//	class is copyable !
	//
	virtual	inline	BOOL
	fCopyable()	{	return	FALSE ;	}

	//
	//	Define virtual function for doing stuff when we get
	//	a match on the name !
	//
	virtual	inline	void
	DoWork(	CNameCacheKey*	pKey ) {}

	//
	//	Helper function gets the hash value for the key !
	//
	static	inline
	DWORD
	NameCacheHash(	CNameCacheKey*	p )	{
		return	p->m_dwHash ;
	}

	//
	//	Compare two keys !
	//
	static
	int
	MatchKey(	CNameCacheKey*	pLHS, 
				CNameCacheKey*  pRHS 
				)	{

		LPBYTE	lpbLHS, lpbRHS ;
		DWORD	cbLHS, cbRHS ;

		lpbLHS = pLHS->RetrieveKey( cbLHS ) ;
		lpbRHS = pRHS->RetrieveKey( cbRHS ) ;

		_ASSERT(lpbLHS && lpbRHS && cbLHS && cbRHS ) ;

		int	i = pLHS->m_pCacheData->m_pfnCompare( cbLHS, lpbLHS, cbRHS, lpbRHS ) ;

		if( i==0 ) {
			pLHS->DoWork( pRHS ) ;
			pRHS->DoWork( pLHS ) ;
		}
		return	i ;
	}

	//
	//	
	//
	BOOL	DelegateAccessCheck(	HANDLE		hToken, 
									ACCESS_MASK	accessMask, 
									CACHE_ACCESS_CHECK	pfnAccessCheck
									)	{
		if( !m_pSD ) {
			return	TRUE ;
		}	else	{
			return	m_pSD->AccessCheck(	hToken, accessMask, pfnAccessCheck ) ;
		}
	}

} ;

//
//	This object is only used to search for existing entries in the 
//	cache !
//
class	CNameCacheKeySearch : public	CNameCacheKey	{
private : 

	//
	//	This points to client provided buffers for the key 
	//
	LPBYTE		m_lpbClientKey ;

	//
	//	Client provided length of the key 
	//
	DWORD		m_cbClientKey ;

	//
	//	Client provided context for the read callback 
	//
	LPVOID		m_lpvContext ;

	//
	//	Client provided function pointer which gets to examine the data 
	//	in the key !
	//
	CACHE_READ_CALLBACK		m_pfnCallback ;

	//
	//	should we extract the security descriptor !
	//
	BOOL		m_fGetSD ;
	
public : 

	//
	//	Construct one of these 
	//
	CNameCacheKeySearch(
		LPBYTE	lpbKey, 
		DWORD	cbKey, 
		DWORD	dwHash, 
		LPVOID	lpvContext,
		CACHE_READ_CALLBACK	pfnCallback, 
		BOOL	fGetSD
		) :	m_lpbClientKey( lpbKey ), 
		m_cbClientKey( cbKey ), 
		m_lpvContext( lpvContext ),
		m_pfnCallback( pfnCallback ), 
		m_fGetSD( fGetSD )	{
		m_dwHash = dwHash ;
	}

	//
	//	Determine whether a search key is valid !
	//
	BOOL
	IsValid()	{
		_ASSERT( m_lpbClientKey != 0 ) ;
		_ASSERT( m_cbClientKey != 0 ) ;

		return	m_lpbClientKey != 0 &&
				m_cbClientKey != 0 ;
	}

	//
	//	this function gets the key that we need to compare out of the object
	//
	inline
	LPBYTE	RetrieveKey(	DWORD&	cb ) {
		_ASSERT( IsValid() ) ;
		cb = m_cbClientKey ;
		return	m_lpbClientKey ;
	}

	//
	//	called when we have a match for an item in the cache - 
	//	this gives us a chance to let the caller see the embedded
	//	data associated with the name !
	//
	void
	DoWork(	CNameCacheKey*	pBuddy )	{
		if( m_fGetSD ) {
			m_pSD = pBuddy->m_pSD ;
		}
		DWORD	cbData ;
		LPBYTE	lpbData = pBuddy->RetrieveData( cbData ) ;
		if( cbData < sizeof( m_rgbData ) ) {
			CopyMemory( m_rgbData, lpbData, cbData ) ;
			m_cbData = cbData ;
		}	else	{
			if( m_pfnCallback )	{
				m_pfnCallback(	cbData, 
								lpbData, 
								m_lpvContext
								) ;
				m_pfnCallback = 0 ;
			}
		}
	}	

	//
	//	second chance to call the client callback 
	//	We may just copy the client's data out of his key 
	//	buffer to avoid expensive work in his function callbacks !
	//
	void
	PostWork()	{
		if( m_pfnCallback )	{
			m_pfnCallback( m_cbData, m_rgbData, m_lpvContext ) ;
		}
	}
} ;

//
//	This is the object we setup when we wish to insert an item into 
//	the name cache - we do all the mem allocs etc... that are 
//	required !
//	
class	CNameCacheKeyInsert	:	public	CNameCacheKey	{
public : 

	CNameCacheKeyInsert(	
		LPBYTE	lpbKey, 
		DWORD	cbKey, 
		LPBYTE	lpbData, 
		DWORD	cbData, 
		DWORD	dwHash, 
		CCacheKey*	pCacheData, 
		PTRCSDOBJ&	pCSDOBJ, 
		BOOL&	fInit
		) : CNameCacheKey(	dwHash, pCacheData, pCSDOBJ ) {

		_ASSERT( lpbKey != 0 ) ;
		_ASSERT( cbKey != 0 ) ;
		_ASSERT(	(lpbData == 0 && cbData == 0) ||
					(lpbData != 0 && cbData != 0) ) ;
		_ASSERT( pCacheData != 0 ) ;
		//_ASSERT( pCSDOBJ != 0 ) ;
	
		fInit = TRUE ;

		if(	cbKey < sizeof( m_rgbData ) ) {
			CopyMemory( m_rgbData, lpbKey, cbKey ) ;
			m_cbKey = cbKey ;
			if( cbData != 0 ) {
				if( cbData + cbKey < sizeof( m_rgbData ) ) {
					CopyMemory( m_rgbData+m_cbKey, lpbData, cbData ) ;
				}	else	{
					m_lpbExtra = new	BYTE[cbData] ;
					if( m_lpbExtra == 0 ) {
						fInit = FALSE ;
					}	else	{
						CopyMemory( m_lpbExtra, lpbData, cbData ) ;
					}
				}
			}
			m_cbData = cbData ;
		}	else	{
			m_lpbExtra = new	BYTE[cbData+cbKey] ;
			if( !m_lpbExtra ) {
				fInit = FALSE ;
			}	else	{
				CopyMemory( m_lpbExtra, lpbKey, cbKey ) ;
				m_cbKey = cbKey ;
				if( lpbData ) {
					CopyMemory( m_lpbExtra+m_cbKey, lpbData, cbData ) ;
				}
				m_cbData = cbData;
			}
		}
		_ASSERT( !fInit || IsValid() ) ;
	}


	//
	//	indicate whether this object is copyable !
	//
	BOOL
	fCopyable( )	{
		return	TRUE ;
	}

} ;



#define	FILECACHE_MAX_PATH	768


class	CFileCacheObject : public	CRefCount2	{
private :
	//
	//	My Signature !
	//
	DWORD							m_dwSignature ;

	//
	//	The optional file handle context
	//
	FIO_CONTEXT_INTERNAL			m_AtqContext ;

	//
	//	The optional file handle which is not assoicated with a
	//	completion context !
	//
	FIO_CONTEXT_INTERNAL			m_Context ;

	//
	//	The size of the file - high and low DWORD's
	//
	DWORD							m_cbFileSizeLow ;
	DWORD							m_cbFileSizeHigh ;

	//
	//	The lock used to protect this object !
	//
	class	CShareLockNH			m_lock ;
	//
	//	These constructors are private as we only want
	//	to have one possible construction method in the public space !
	//
	CFileCacheObject( CFileCacheObject& ) ;

	//
	//	Our constructors are our friends !
	//
	friend	class	CRichFileCacheConstructor ;
	friend	class	CFileCacheConstructor ;

	//
	//	some functions are friends so that they can get to the Dot Stuff managers !
	//
	

	//
	//	The completion function we give to ATQ!
	//
	static
	void
	Completion(	CFileCacheObject*	p,
				DWORD	cbTransferred,
				DWORD	dwStatus,
				FH_OVERLAPPED*	pOverlapped
				) ;
				

public :

	//
	//	Public member required by templates
	//
	class	ICacheRefInterface*	m_pCacheRefInterface ;

	//
	//	The code that does dot stuffing things !
	//
	DOT_STUFF_MANAGER				m_ReadStuffs ;
	//
	//	The code that does dot stuffing on writes !
	//
	DOT_STUFF_MANAGER				m_WriteStuffs ;

	//
	//	The following represent the Dot Stuffing state of an FIO_CONTEXT
	//	that has been inserted into the file handle cache.
	//	This state is meaningless until the file has been inserted into the
	//	cache !
	//
	//	Was the message examined to determine its dot stuff state !
	//
	BOOL							m_fFileWasScanned ;
	//
	//	If m_fFileWasScanned == TRUE then this will tell us whether the
	//	file need to be dot stuffed for protocols that require transmission
	//	to occur with dots !
	//
	BOOL							m_fRequiresStuffing ;
	//
	//	This is set by the user either through AssociateFileEx() or CacheRichCreateFile,
	//	in either case, if TRUE it indicates that this file should be stored with
	//	extra dot stuffing - i.e. the NNTP on the wire format.  if FALSE then this
	//	is stored without Dot Stuffing - i.e. the Exchange Store's native format.
	//
	BOOL							m_fStoredWithDots ;
	//
	//	This is set by the user either directly through SetIsFileDotTerminated()	
	//	or through AssociateFileEx(), as well as through FCACHE_RICHCREATE_CALLBACK
	//	And is used by ProduceDotStuffedContextInContext() to determine whether
	//	the terminating dot is present !
	//	
	BOOL							m_fStoredWithTerminatingDot ;
	
	//	
	//	Construct a CFileCacheObject !	
	//
	CFileCacheObject(	BOOL	fStoredWithDots,
						BOOL	fStoredWithTerminatingDot  ) ;

#ifdef	DEBUG
	//
	//	The destructor just marks our signature as dead !
	//
	~CFileCacheObject() ;
#endif

	//
	//	Get the containing CFIleCacheObject from this context
	//
	static
	CFileCacheObject*
	CacheObjectFromContext(	PFIO_CONTEXT	p	) ;

	//
	//	Another version for getting the Containing CFileCacheObject !
	//
	static
	CFileCacheObject*
	CacheObjectFromContext(	FIO_CONTEXT_INTERNAL*	p	) ;

	//
	//	Initialize this CFileCacheObject !
	//
	BOOL
	Init(	CFileCacheKey&	key,
			class	CFileCacheConstructorBase&	constructor,
			void*	pv
			) ;
	
	//
	//	Set up the Async File Handle !
	//
	FIO_CONTEXT_INTERNAL*
	AsyncHandle(	HANDLE	hFile	) ;

	//
	//	Set up the synchronous File Handle
	//
	void
	SyncHandle(	HANDLE	hFile	) ;

	//
	//	get the correct containing file context !
	//
	FIO_CONTEXT_INTERNAL*
	GetAsyncContext(	class	CFileCacheKey&	key,
						class	CFileCacheConstructorBase&	constructor
						) ;


	FIO_CONTEXT_INTERNAL*
	GetSyncContext(		class	CFileCacheKey&	key,
						class	CFileCacheConstructorBase&	constructor
						) ;

	//
	//	get the async context for this handle, only if it is setup correctly !
	//
	FIO_CONTEXT_INTERNAL*
	GetAsyncContext() ;

	//
	//	get the async context for this handle, only if it is setup correctly !
	//
	FIO_CONTEXT_INTERNAL*
	GetSyncContext() ;

	//
	//	Do appropriate release of this item, depending
	//	on whether its cached or not !
	//
	void
	Return() ;

	//
	//	Add a client reference to an item in the file handle cache !
	//
	void
	Reference()	;

	//
	//	Return the size of the file !
	//
	inline	DWORD
	GetFileSize(	DWORD*	pcbFileSizeHigh )	{
		DWORD	cbFileSizeLow = 0 ;
		m_lock.ShareLock() ;

		if( m_pCacheRefInterface != 0 )		{
			*pcbFileSizeHigh = m_cbFileSizeHigh ;
			cbFileSizeLow = m_cbFileSizeLow ;
		}	else	{
			if( m_Context.m_hFile != INVALID_HANDLE_VALUE ) {
				cbFileSizeLow = ::GetFileSize( m_Context.m_hFile, pcbFileSizeHigh ) ;
			}	else	{
				_ASSERT( m_AtqContext.m_hFile != INVALID_HANDLE_VALUE ) ;
				cbFileSizeLow = ::GetFileSize( m_AtqContext.m_hFile, pcbFileSizeHigh ) ;
			}
		}
		m_lock.ShareUnlock() ;
		return	cbFileSizeLow;
	}

	//
	//	Set the size of the file !
	//
	void
	SetFileSize() ;

	//
	//	Insert the item into the cache !
	//
	BOOL
	InsertIntoCache(	CFileCacheKey&	key,
						BOOL			fKeepReference
						)	;

	//
	//	Close the handles associated with an item !
	//
	BOOL
	CloseNonCachedFile(	) ;

	//
	//	Return to the caller our Dot Stuffing state !
	//
	BOOL
	GetStuffState(	BOOL	fReads,
					BOOL&	fRequiresStuffing,
					BOOL&	fStoredWithDots
					) ;

	//
	//	Setup the Stuff State
	//
	void
	SetStuffState(	BOOL	fWasScanned,
					BOOL	fRequiresStuffing
					) ;

	BOOL
	CompleteDotStuffing(	
					BOOL			fReads,
					BOOL			fStripDots
					) ;
} ;	


class	CFileCacheConstructorBase	{
/*++

Class Description :

	Define some basic functionality for how we create
	CFileCacheObject objects.

--*/
protected :
	//
	//	Can only build derived classes of these !
	//
	CFileCacheConstructorBase( BOOL fAsync ) :
		m_fAsync( fAsync ) {}
public :

	//
	//	All constructors must publicly declare which kind of handle
	//	they are producing !
	//
	BOOL	m_fAsync ;

	//
	//	Allocate mem for CFileCacheObject - do minimal init !
	//
	CFileCacheObject*
	Create( CFileCacheKey&	key,
			void*	pv
			) ;

	
	//
	//	Release mem for CFileCacheObject -
	//	called on error allocation paths of MultiCacheEx<>
	//
	void
	Release(	CFileCacheObject*	p,
				void*	pv
				) ;

	//
	//	Release mem for CFileCacheObject -
	//	called on expiration paths of MultiCacheEx<>
	//
	static
	void
	StaticRelease(	CFileCacheObject*	p,
					void*	pv
					) ;

	//
	//	Produce the handle that the user wants placed into the
	//	CFileCacheObject !
	//
	virtual
	HANDLE
	ProduceHandle(	CFileCacheKey&	key,
					DWORD&			cbFileSizeLow,
					DWORD&			cbFileSizeHigh
					) = 0	;

	//
	//	PostInit Function is virtual - does the major
	//	amount of initialization work, which depends
	//	on how the client asked for the cache object !
	//
	virtual
	BOOL
	PostInit(	CFileCacheObject&	object,
			CFileCacheKey&		key,
			void*	pv
			) = 0 ;
		
} ;

class	CRichFileCacheConstructor	:	public	CFileCacheConstructorBase	{
private :

	//
	//	Void pointer provided by client !
	//
	LPVOID	m_lpv ;
	
	//
	//	Function pointer provided by client !
	//
	FCACHE_RICHCREATE_CALLBACK	m_pCreate ;

	//
	//	No Default Construction - or copying !
	//
	CRichFileCacheConstructor() ;
	CRichFileCacheConstructor( CRichFileCacheConstructor& ) ;
	CRichFileCacheConstructor&	operator=( CRichFileCacheConstructor & ) ;


	//
	//	These two BOOL's capture the dot stuffing state until
	//	PostInit() is called !
	//
	BOOL	m_fFileWasScanned ;
	BOOL	m_fRequiresStuffing ;
	BOOL	m_fStoredWithDots ;
	BOOL	m_fStoredWithTerminatingDot ;

public :

	//
	//	Construct a CFileCacheConstructor - just copy these args into members !
	//
	CRichFileCacheConstructor(
			LPVOID	lpv,
			FCACHE_RICHCREATE_CALLBACK	pCreate,
			BOOL	fAsync
			)  ;

	//
	//	Produce the handle we are going to use !
	//
	HANDLE
	ProduceHandle(	CFileCacheKey&	key,
					DWORD&			cbFileSizeLow,
					DWORD&			cbFileSizeHigh
					)	;

	//
	//	Do the deep initialization of the CFileCacheObject !
	//
	BOOL
	PostInit(	CFileCacheObject&	object,
			CFileCacheKey&		key,
			void*	pv
			) ;



} ;
	

class	CFileCacheConstructor	:	public	CFileCacheConstructorBase	{
private :

	//
	//	Void pointer provided by client !
	//
	LPVOID	m_lpv ;
	
	//
	//	Function pointer provided by client !
	//
	FCACHE_CREATE_CALLBACK	m_pCreate ;

	//
	//	No Default Construction !
	//
	CFileCacheConstructor() ;

public :
	
	//
	//	Construct a CFileCacheConstructor - just copy these args into members !
	//
	CFileCacheConstructor(
			LPVOID	lpv,
			FCACHE_CREATE_CALLBACK	pCreate,
			BOOL	fAsync
			)  ;

	//
	//	Produce the handle we are going to use !
	//
	HANDLE
	ProduceHandle(	CFileCacheKey&	key,
					DWORD&			cbFileSizeLow,
					DWORD&			cbFileSizeHigh
					)	;

	//
	//	Do the deep initialization of the CFileCacheObject !
	//
	BOOL
	PostInit(	CFileCacheObject&	object,
			CFileCacheKey&		key,
			void*	pv
			) ;
} ;


//
//	Define what a file cache object looks like !
//
typedef	MultiCacheEx<	CFileCacheObject,
						CFileCacheKey,
						CFileCacheConstructorBase
						>	FILECACHE ;

//
//	Define what a name cache object looks like !
//
typedef	MultiCacheEx<	CFileCacheObject, 
						CNameCacheKey, 
						CFileCacheConstructorBase
						>	NAMECACHE ;

//
//	Define out Expunge object !
//
class	CFileCacheExpunge : public	FILECACHE::EXPUNGEOBJECT	{
private :

	//
	//	Define the string we need to match !
	//
	LPSTR	m_lpstrName ;
	DWORD	m_cbName ;

public :

	CFileCacheExpunge(	LPSTR	lpstrName,
						DWORD	cbName ) :
		m_lpstrName( lpstrName ),
		m_cbName( cbName )	{}

	BOOL
	fRemoveCacheItem(	CFileCacheKey*	pKey,
						CFileCacheObject*	pObject
						) ;

} ;

	

//
//	Define an instance of our Name Cache !
//
class	CNameCacheInstance :	public	NAME_CACHE_CONTEXT	{
private : 
	enum	CONSTANTS	{
		SIGNATURE	= 'CCNF', 
		DEAD_SIGNATURE = 'CCNX'
	} ;
	//
	//	Number of client references !
	//
	volatile	long	m_cRefCount ;
	//
	//	The entry we provided for our containing hash table 
	//	to keep track of these things !
	//
	DLIST_ENTRY		m_list ;
public : 

    typedef     DLIST_ENTRY*    (*PFNDLIST)( class  CNameCacheInstance* p ) ; 

	//
	//	the key for this item !
	//
	CCacheKey		m_key ;

	//
	//	The embedded Name Cache implementation !
	//
	NAMECACHE		m_namecache ;

	//
	//	The 'DUD' pointer we use !
	//
	CFileCacheObject*	m_pDud ;

	//
	//	The function pointer we are to use for evaluating security descriptors - may be NULL !
	//
	CACHE_ACCESS_CHECK	m_pfnAccessCheck ;

	//
	//	Construct this guy - makes a copy of the key.
	//	Note : CCacheKey itself does shallow copies, it does 
	//	not duplicate embedded strings !
	//
	CNameCacheInstance(	CCacheKey&	key	) ;

	//
	//	Destroy ourselves - free any associated memory !
	//
	~CNameCacheInstance() ;

	//	
	//	Check that this item is in a valid state !
	//	should only be called after successfully calling Init() !
	//
	BOOL
	IsValid() ;

	//
	//	Add a reference to this Name Cache table !
	//
	long
	AddRef() ;

	//
	//	Release a reference to this name cache table !
	//
	long	
	Release() ;

	//
	//	Initialize this guy !
	//
	BOOL
	fInit() ;

	inline	static
	DLIST_ENTRY*
	HashDLIST(	CNameCacheInstance*	p ) {
		return	&p->m_list ;
	}

	inline		CCacheKey*
	GetKey()	{
		return	&m_key ;
	}

} ;

typedef	TFDLHash<	class	CNameCacheInstance, 
					class	CCacheKey*, 
					&CNameCacheInstance::HashDLIST
					>	NAMECACHETABLE ;


#endif	//_FCACHIMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\fcache2\dotstuff.h ===
/*++

	dotstuff.h

	This header files defines some of the Dot Stuffing helper objects that 
	we have built for the File Handle Cache.

--*/

#include	"refptr2.h"


class	IDotManipBase : public	CRefCount2	{
protected : 
	//
	//	Return the number of bytes in the buffer that should pass
	//	through the IO operation !
	//
	virtual
	BOOL
	InternalProcessBuffer(	
				BYTE*	lpb,			// The users original buffer
				DWORD	cbIn,			// Number of bytes to look at in orignal buffer
				DWORD	cbAvailable,	// Number of bytes available in the original buffer
				DWORD	&cbRemains,		// Number of bytes we left in the original Buffer - can be zero
				BYTE*	&lpbOut,		// An output buffer that holds a portion of the string !
				DWORD	&cbOut,			// The amount of stuff in our output buffer
				int		&cBias			// Whether we should offset associated IO's to overwrite
										// previous results !
				) = 0 ;


	//
	//	This is the number of times the string as appeared in the message - 
	//	NOTE : This can be initialized to -1 if we are examining the message
	//	to determine that it needs to be dot stuffed.  This is because
	//	the terminating CRLF.CRLF will set occurrences to 0, indicating that
	//	there is no issue.
	//
	long	m_cOccurrences ;

	//
	//	Private constructor allows us to initialize m_cOccurrences !
	//
	IDotManipBase( long	l )	: 
		m_cOccurrences( l )	{
	}

public : 
/*++

	This class defines a pure virtual API used by our Dot Manipulation 
	classes to define how they interact with other code.

--*/

	//
	//	Destruction is always virtual !
	//
	virtual	~IDotManipBase()	{}

	//
	//	Publicly exposed API !
	//
	inline	BOOL
	ProcessBuffer(	BYTE*	lpb,
					DWORD	cbIn,
					DWORD	cbAvailable,
					DWORD	&cbRemains,
					BYTE*	&lpbOut,
					DWORD	&cbOut,
					int		&cBias,
					BOOL	fFinalBuffer = FALSE, 
					BOOL	fTerminatorPresent = FALSE
					)	{
		//
		//	Validate the callers arguments as much as possible !
		//
		_ASSERT( lpb != 0 ) ;
		_ASSERT( cbIn != 0 ) ;
		_ASSERT( cbAvailable >= cbIn ) ;

		//
		//	Ensure that these are correctly setup !
		//
		cbRemains = 0 ;
		lpbOut = 0 ;
		cbOut = 0 ;
		cBias = 0 ;

		BOOL	fReturn = 
			InternalProcessBuffer( 
							lpb, 
							cbIn, 
							cbAvailable,
							cbRemains,
							lpbOut,
							cbOut, 
							cBias
							) ;

		//
		//	Do some checking on the results of the call !
		//
		_ASSERT( cBias <= 0 ) ;
		_ASSERT( (lpbOut == 0 && cbOut == 0) || (lpbOut != 0 && cbOut != 0) ) ;
		_ASSERT( cbRemains <= cbAvailable ) ;
		
		return	fReturn ;
	}

	//
	//	Return the number of times we saw a pattern matching the 
	//	sequence specified when we were constructed !
	//
	long
	NumberOfOccurrences()	{
		return	m_cOccurrences ;
	}
} ;

extern	BYTE	szDot[] ;
extern	BYTE	szDotStuffed[] ;
extern	BYTE	szShrink[] ;
extern	BYTE	szGrow[] ;

class	CDotScanner	:	public	IDotManipBase		{
/*++

	This class detects messages which have Dot Stuffing issues.
	We can operate in one of two modes - determine if the message flowing by
	is dot stuffed, or determine if the message flowing by would need
	to be dot stuffed.

--*/
private : 

	enum	{
		SIGNATURE = 'futs',		// should appear as 'stuf' in the debugger !
		DEAD_SIGNATURE = 'futx'
	} ; 

	//
	//	Our signature !
	//
	DWORD	m_dwSignature ;
	
	//
	//	This is the string we are interested in detecting : 
	//
	BYTE	*m_pchMatch ;
	
	//
	//	This is our current match state !
	//
	BYTE	*m_pchState ;

	//
	//	Don't allow copies and stuff so make these private !
	//
	CDotScanner( CDotScanner& ) ;
	CDotScanner&	operator=( CDotScanner& ) ;

public : 

	CDotScanner(	BOOL	fWillGetTerminator = TRUE ) : 
		IDotManipBase(  (fWillGetTerminator ? -1 : 0) ),
		m_dwSignature( SIGNATURE ),
		m_pchMatch( szDotStuffed ),
		m_pchState( szDotStuffed )	{
		m_cRefs = 0 ;	// Hack - our base class CRefCount2 doesn't do what we want !
	}

	~CDotScanner(	)	{
		m_dwSignature = DEAD_SIGNATURE ;
	}

	//
	//	See if the user specified pattern occurs in the buffer !
	//
	BOOL
	InternalProcessBuffer(
				BYTE*	lpb,			// The users original buffer
				DWORD	cbIn,			// Number of bytes to look at in orignal buffer
				DWORD	cbAvailable,	// Number of bytes available in the original buffer
				DWORD	&cbRemains,		// Number of bytes we left in the original Buffer - can be zero
				BYTE*	&lpbOut,		// An output buffer that holds a portion of the string !
				DWORD	&cbOut,			// The amount of stuff in our output buffer
				int		&cBias			// Whether we should offset associated IO's to overwrite
										// previous results !
				) ;
} ;

class	CDotModifier	:	public	IDotManipBase	{
/*++

	This class is used to detect messages that need to be dot-stuffed
	or de-dot stuffed.  We can either remove or insert dot-stuffing as 
	required on the fly, depending on how we are constructed !

--*/
private : 
	enum	{
		SIGNATURE = 'mtod',		// should appear as 'stuf' in the debugger !
		DEAD_SIGNATURE = 'mtox'
	} ; 

	//
	//	Our signature !
	//
	DWORD	m_dwSignature ;
	
	//
	//	This is the string we are interested in detecting : 
	//
	BYTE	*m_pchMatch ;

	//
	//	This is our current match state !
	//
	BYTE	*m_pchState ;

	//
	//	This is the string we want to have replace the string we're detecting
	//
	BYTE	*m_pchReplace ;

	//
	//	Number of characters in the matching and replacement string.
	//
	int		m_cchMatch ;
	int		m_cDiff ;


	//
	//	This is the total offset we've accumulated in the stream !
	//
	long	m_cOffsetBytes ;

	//
	//	Don't allow copies and stuff so make these private !
	//
	CDotModifier( CDotModifier& ) ;
	CDotModifier&	operator=( CDotModifier& ) ;

public : 

	//
	//	Initialize our state - cannot fail !
	//
	CDotModifier(	
			BYTE*	szMatch = szDotStuffed, 
			BYTE*	szReplace = szShrink
			) :
		IDotManipBase( 0 ),
		m_dwSignature( SIGNATURE ), 
		m_pchMatch( szMatch ),
		m_pchState( szMatch ),
		m_pchReplace( szReplace ),
		m_cchMatch( strlen( (const char*)szMatch) ), 
		m_cDiff( strlen( (const char*)szReplace) - strlen( (const char*)szMatch ) ),
		m_cOffsetBytes( 0 )	{
		m_cRefs = 0 ;	// HACK - our base class CRefCount2 doesn't do what we want !
	}

	//
	//	Just mark our Signature DWORD - handy for debugging !
	//
	~CDotModifier()	{
		m_dwSignature = DEAD_SIGNATURE ;
	}

	//
	//	Modify dot sequences as they go by !
	//
	BOOL
	InternalProcessBuffer(
				BYTE*	lpb,			// The users original buffer
				DWORD	cbIn,			// Number of bytes to look at in orignal buffer
				DWORD	cbAvailable,	// Number of bytes available in the original buffer
				DWORD	&cbRemains,		// Number of bytes we left in the original Buffer - can be zero
				BYTE*	&lpbOut,		// An output buffer that holds a portion of the string !
				DWORD	&cbOut,			// The amount of stuff in our output buffer
				int		&cBias			// Whether we should offset associated IO's to overwrite
										// previous results !
				) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\gethost\gethost.cpp ===
#include <windows.h>
#include <svcguid.h>
#include <winsock2.h>
#include <dbgtrace.h>
#include <dnsapi.h>
#include <dbgtrace.h>
#include <cpool.h>
#include <address.hxx>
#include <rwnew.h>
#include <dnsreci.h>
#include <listmacr.h>

//shamelessy stolen from the NT winsock code....

GUID HostnameGuid = SVCID_INET_HOSTADDRBYNAME;
GUID AddressGuid =  SVCID_INET_HOSTADDRBYINETSTRING;
GUID IANAGuid    =  SVCID_INET_SERVICEBYNAME;
//
// Utility to turn a list of offsets into a list of addresses. Used
// to convert structures returned as BLOBs.
//

VOID
FixList(PCHAR ** List, PCHAR Base)
{
    if(*List)
    {
        PCHAR * Addr;

        Addr = *List = (PCHAR *)( ((ULONG_PTR)*List + Base) );
        while(*Addr)
        {
            *Addr = (PCHAR)(((ULONG_PTR)*Addr + Base));
            Addr++;
        }
    }
}


//
// Routine to convert a hostent returned in a BLOB to one with
// usable pointers. The structure is converted in-place.
//
VOID
UnpackHostEnt(struct hostent * hostent)
{
     PCHAR pch;

     pch = (PCHAR)hostent;

     if(hostent->h_name)
     {
         hostent->h_name = (PCHAR)((ULONG_PTR)hostent->h_name + pch);
     }
     FixList(&hostent->h_aliases, pch);
     FixList(&hostent->h_addr_list, pch);
}
//
// The protocol restrictions list for all emulation operations. This should
// limit the invoked providers to the set that know about hostents and
// servents. If not, then the special SVCID_INET GUIDs should take care
// of the remainder.
//
AFPROTOCOLS afp[2] = {
                      {AF_INET, IPPROTO_UDP},
                      {AF_INET, IPPROTO_TCP}
                     };

LPBLOB GetGostByNameI(PCHAR pResults,
    DWORD dwLength,
    LPSTR lpszName,
    LPGUID lpType,
    LPSTR *  lppName)
{
    PWSAQUERYSETA pwsaq = (PWSAQUERYSETA)pResults;
    int err;
    HANDLE hRnR;
    LPBLOB pvRet = 0;
    INT Err = 0;

    //
    // create the query
    //
    ZeroMemory(pwsaq,sizeof(*pwsaq));
    pwsaq->dwSize = sizeof(*pwsaq);
    pwsaq->lpszServiceInstanceName = lpszName;
    pwsaq->lpServiceClassId = lpType;
    pwsaq->dwNameSpace = NS_ALL;
    pwsaq->dwNumberOfProtocols = 2;
    pwsaq->lpafpProtocols = &afp[0];

	//don't go though the cache
    err = WSALookupServiceBeginA(pwsaq,
                                 LUP_RETURN_BLOB | LUP_RETURN_NAME | LUP_FLUSHCACHE,
                                 &hRnR);

    if(err == NO_ERROR)
    {
        //
        // The query was accepted, so execute it via the Next call.
        //
        err = WSALookupServiceNextA(
                                hRnR,
                                0,
                                &dwLength,
                                pwsaq);
        //
        // if NO_ERROR was returned and a BLOB is present, this
        // worked, just return the requested information. Otherwise,
        // invent an error or capture the transmitted one.
        //

        if(err == NO_ERROR)
        {
            if(pvRet = pwsaq->lpBlob)
            {
                if(lppName)
                {
                    *lppName = pwsaq->lpszServiceInstanceName;
                }
            }
            else
            {
                err = WSANO_DATA;
            }
        }
        else
        {
            //
            // WSALookupServiceEnd clobbers LastError so save
            // it before closing the handle.
            //

            err = GetLastError();
        }
        WSALookupServiceEnd(hRnR);

        //
        // if an error happened, stash the value in LastError
        //

        if(err != NO_ERROR)
        {
            SetLastError(err);
        }
    }
    return(pvRet);
}


struct hostent FAR * GetHostByName(PCHAR Buffer, DWORD BuffSize, DWORD dwFlags, char * HostName)
{
	struct hostent * hent = NULL;	
	LPBLOB pBlob = NULL;

	pBlob = GetGostByNameI(Buffer, BuffSize, HostName, &HostnameGuid, 0);

	if(pBlob)
	{
		hent = (struct hostent *) pBlob;
		UnpackHostEnt(hent);
	}
	else
	{
		if(GetLastError() == WSASERVICE_NOT_FOUND)
		{
			SetLastError(WSAHOST_NOT_FOUND);
		}
	}
	return hent;
}



BOOL GetIpAddressFromDns(char * HostName, PSMTPDNS_RECS pDnsRec, DWORD Index)
{
    TraceFunctEnter("GetIpAddressFromDns");
    
    PDNS_RECORD pDnsRecord = NULL;
	MXIPLIST_ENTRY * pEntry = NULL;
	PDNS_RECORD pTempDnsRecord;
	DNS_STATUS  DnsStatus = 0;
	DWORD	Error = NO_ERROR;
	BOOL fReturn = TRUE;

	DnsStatus = DnsQuery_A(HostName, DNS_TYPE_A, DNS_QUERY_BYPASS_CACHE, NULL, &pDnsRecord, NULL);

    pTempDnsRecord = pDnsRecord;

	while ( pTempDnsRecord )
	{
		if(pTempDnsRecord->wType == DNS_TYPE_A)
		{
			pEntry = new MXIPLIST_ENTRY;
			if(pEntry != NULL)
			{
				pDnsRec->DnsArray[Index]->NumEntries++;
				pEntry->IpAddress  = pTempDnsRecord->Data.A.ipAddress;
				InsertTailList(&pDnsRec->DnsArray[Index]->IpListHead, &pEntry->ListEntry);
			}
			else
			{
				fReturn = FALSE;
				Error = ERROR_NOT_ENOUGH_MEMORY;
				break;
			}
		}

		pTempDnsRecord = pTempDnsRecord->pNext;
	}

    DnsFreeRRSet( pDnsRecord, TRUE );

	if(Error)
	{
		SetLastError (ERROR_NOT_ENOUGH_MEMORY);
	}

    TraceFunctLeave();
	return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\fcache2\dll\fcache.cpp ===
/*++

	FCACHE.CPP

	The file implements the file handle cache used by NNTP.

--*/

#pragma	warning( disable : 4786 )

#include	"fcachimp.h"

#if	defined(_X86_)
#define	SZATQINITIALIZE			"AtqInitialize"
#define	SZATQTERMINATE			"AtqTerminate"
#define	SZATQADDASYNCHANDLE		"_AtqAddAsyncHandle@24"
#define	SZATQCLOSEFILEHANDLE	"_AtqCloseFileHandle@4"
#define	SZATQCLOSESOCKET		"_AtqCloseSocket@8"
#define	SZATQFREECONTEXT		"_AtqFreeContext@8"
#define	SZATQREADFILE			"_AtqReadFile@16"
#define	SZATQWRITEFILE			"_AtqWriteFile@16"
#elif defined(_AMD64_) || defined(_IA64_)
#define	SZATQINITIALIZE			"AtqInitialize"
#define	SZATQTERMINATE			"AtqTerminate"
#define	SZATQADDASYNCHANDLE		"AtqAddAsyncHandle"
#define	SZATQCLOSEFILEHANDLE	"AtqCloseFileHandle"
#define	SZATQCLOSESOCKET		"_AtqCloseSocket"
#define	SZATQFREECONTEXT		"AtqFreeContext"
#define	SZATQREADFILE			"AtqReadFile"
#define	SZATQWRITEFILE			"AtqWriteFile"
#else
#error "No Target Architecture"
#endif



//
//	The DLL's we load to do this stuff !
//
HINSTANCE			g_hIsAtq = 0 ;
HINSTANCE			g_hIisRtl = 0 ;
//
//	Function pointers for all our thunks into IIS stuff !
//
PFNAtqInitialize	g_AtqInitialize = 0 ;
PFNAtqTerminate		g_AtqTerminate = 0 ;
PFNAtqAddAsyncHandle	g_AtqAddAsyncHandle = 0 ;
PFNAtqCloseFileHandle	g_AtqCloseFileHandle = 0 ;
PFNAtqFreeContext		g_AtqFreeContext = 0 ;
PFNAtqIssueAsyncIO		g_AtqReadFile = 0 ;
PFNAtqIssueAsyncIO		g_AtqWriteFile = 0 ;
PFNInitializeIISRTL		g_InitializeIISRTL = 0 ;
PFNTerminateIISRTL		g_TerminateIISRTL = 0 ;

//
//	These are the globals used by the file handle cache !
//

//
//	Keep track of how ofter we're initialized !
//
static	long	g_cIOInits = 0 ;
//
//	Keep track of how often the cache is initialized !
//
static	long	g_cCacheInits = 0 ;
//
//	Keep track of the global cache !
//
static	FILECACHE*	g_pFileCache = 0 ;
//
//	Keep track of the global Name Cache !
//
static	NAMECACHE*	g_pNameCache = 0 ;
//
//	Keep track of all the different security descriptors floating through
//	the system !
//
static	CSDMultiContainer*	g_pSDCache = 0 ;
//
//	Protect our globals - setup and destroyed in DllMain() !
//
CRITICAL_SECTION	g_critInit ;


BOOL
WriteWrapper(	IN	PATQ_CONTEXT	patqContext,
				IN	LPVOID			lpBuffer,
				IN	DWORD			cbTransfer,
				IN	LPOVERLAPPED	lpo
				)	{
/*++

Routine Description :

	Issue a Write IO against the ATQ Context.
	If we're trying to do a synchronous IO, bypass ATQ so that the ATQ
	IO Reference count doesn't get messed up !

Arguments :

	SAME as ATQWriteFile

Return Value :

	Same as ATQWriteFile !

--*/

	if( (UINT_PTR)(lpo->hEvent) & 0x1 )		{
		DWORD	cbResults ;
		BOOL	fResult =
				WriteFile(
					patqContext->hAsyncIO,
					(LPCVOID)lpBuffer,
					cbTransfer,
					&cbResults,
					(LPOVERLAPPED)lpo
					) ;
		if( fResult || GetLastError() == ERROR_IO_PENDING ) {
			return	TRUE ;
		}
		return	FALSE ;
	}	else	{
		return	g_AtqWriteFile(
					patqContext,
					(LPVOID)lpBuffer,
					cbTransfer,
					(LPOVERLAPPED)lpo
					) ;
	}
}

BOOL
ReadWrapper(	IN	PATQ_CONTEXT	patqContext,
				IN	LPVOID			lpBuffer,
				IN	DWORD			cbTransfer,
				IN	LPOVERLAPPED	lpo
				)	{
/*++

Routine Description :

	Issue a Read IO against the ATQ Context.
	If we're trying to do a synchronous IO, bypass ATQ so that the ATQ
	IO Reference count doesn't get messed up !

Arguments :

	SAME as ATQWriteFile

Return Value :

	Same as ATQWriteFile !

--*/


	if( (UINT_PTR)(lpo->hEvent) & 0x1 )		{
		DWORD	cbResults ;
		BOOL	fResult =
				ReadFile(
					patqContext->hAsyncIO,
					lpBuffer,
					cbTransfer,
					&cbResults,
					(LPOVERLAPPED)lpo
					) ;
		if( fResult || GetLastError() == ERROR_IO_PENDING ) {
			return	TRUE ;
		}
		return	FALSE ;

	}	else	{
		return	g_AtqReadFile(
					patqContext,
					(LPVOID)lpBuffer,
					cbTransfer,
					(LPOVERLAPPED)lpo
					) ;
	}
}


BOOL
DOT_STUFF_MANAGER::IssueAsyncIO(
		IN	PFNAtqIssueAsyncIO	pfnIO,
		IN	PATQ_CONTEXT	patqContext,
		IN	LPVOID			lpb,
		IN	DWORD			BytesToTransfer,
		IN	DWORD			BytesAvailable,
		IN	FH_OVERLAPPED*	lpo,
		IN	BOOL			fFinalIO,
		IN	BOOL			fTerminatorIncluded
		)	{
/*++

Routine Description :

	This function munges an IO the user has given us to
	do stuff to its dot stuffing.

Arguments :

	pfnIO - Pointer to the ATQ function which will do the IO
	patqContext - the ATQ context we're using to issue the IO
	lpb - the buffer the users data lives in !
	BytesToTransfer - the number of bytes the user wants us to transfer
	BytesAvailable - the number of bytes in the buffer we can touch if need be !
	lpo - The users overlapped structure
	fFinalIO - if TRUE this is the last IO
	fTerminatorIncluded - if TRUE the "\r\n.\r\n" is included in the message

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	static	BYTE	rgbTerminator[5] = { '\r', '\n', '.', '\r', '\n' } ;

	_ASSERT( lpo != 0 ) ;
	_ASSERT( patqContext != 0 ) ;
	_ASSERT( lpb != 0 ) ;
	_ASSERT( BytesToTransfer != 0 ) ;
	_ASSERT( lpo != 0 ) ;

	//
	//	Assume everything works !
	//
	BOOL	fResult = TRUE ;

	//
	//	Munge the OVERLAPPED structure to preserve callers original state !
	//
	lpo->Reserved1 = BytesToTransfer ;
	lpo->Reserved2 = 0 ;

	//
	//	Check to see whether we need to do anything funky to this IO !
	//
	if( m_pManipulator == 0 )	{
		//
		//	Issue the IO the way the user requested it - note if they
		//	are completing the IO directly, we want to skip ATQ so that
		//	the IO reference count doesn't become bogus !
		//
		return	pfnIO(	patqContext,
						lpb,
						BytesToTransfer,
						(LPOVERLAPPED)lpo
						) ;
	}	else	{

		//
		//	All right - wherever this IO goes, we get first crack before
		//	the callers completion function !
		//
		lpo->Reserved3 = (UINT_PTR)lpo->pfnCompletion ;
		lpo->pfnCompletion = DOT_STUFF_MANAGER::AsyncIOCompletion ;

		//
		//	Okay we need to process the buffer thats passing through,
		//	and we may need to do something to the data !
		//




		DWORD	BytesToScan = BytesToTransfer ;
		DWORD	BytesAvailableToStuff = BytesAvailable ;
		BOOL	fAppend = FALSE ;

		if( fFinalIO )	{
			if( fTerminatorIncluded )	{
				if( BytesToTransfer <= sizeof( rgbTerminator ) ) {
					//
					//	This is a bizarre case - it means that part of the terminating
					//	sequence has already gone by, and we may have already modified
					//	the terminating dot !!!
					//
					//	So, what should we do here ? Just do some math and blast out the
					//	terminating sequence as we know it should be !
					//
					int	iTermBias = - (int)(sizeof(rgbTerminator) - BytesToTransfer) ;
					//
					//	Offset the write -
					//
					lpo->Offset = DWORD(((long)lpo->Offset) + m_cbCumulativeBias + iTermBias) ;
					//
					//	Now issue the users requested IO operation !
					//
					return	pfnIO(	patqContext,
									rgbTerminator,
									sizeof( rgbTerminator ),
									(LPOVERLAPPED)lpo
									) ;
				}	else	{
					BytesToTransfer -= sizeof( rgbTerminator ) ; // 5 comes from magic CRLF.CRLF
					BytesAvailable -= sizeof( rgbTerminator ) ;
					fAppend = TRUE ;
				}
			}
		}

		DWORD	cbActual = 0 ;
		LPBYTE	lpbOut = 0 ;
		DWORD	cbOut = 0 ;
		int		cBias = 0 ;

		fResult =
			m_pManipulator->ProcessBuffer(
								(LPBYTE)lpb,
								BytesToTransfer,
								BytesAvailable,
								cbActual,
								lpbOut,
								cbOut,
								cBias
								) ;

		//
		//	Add up the total amount by which we are offseting IO's within
		//	the target file !
		//
		m_cbCumulativeBias += cBias ;

		if( fResult	)	{
			//
			//	Are we going to do an extra IO ?
			//

			FH_OVERLAPPED	ovl ;
			FH_OVERLAPPED	*povl = lpo ;
			HANDLE			hEvent = 0;

			if( lpbOut && cbOut != 0 )	{
				_ASSERT( cbOut != 0 ) ;

				//
				//	Assume this fails and mark fResult appropriately
				//
				fResult = FALSE ;
				//HANDLE	hEvent = GetPerThreadEvent() ;
				hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
				povl = &ovl ;
				if( hEvent == 0 )	{

					//
					//	Fatal error - die !
					//
					SetLastError( ERROR_OUTOFMEMORY ) ;
					return	FALSE ;
				}	else	{
					CopyMemory( &ovl, lpo, sizeof( ovl ) ) ;
					ovl.hEvent = (HANDLE)(((DWORD_PTR)hEvent) | 0x1) ;	// we want to get the completion here !
					//
					//	NOW - if fAppend is TRUE then we need to add the terminator to buffer that came from ProcessBuffer !
					//
					if( fAppend )	{
						CopyMemory( lpbOut + cbOut, rgbTerminator, sizeof( rgbTerminator ) ) ;
						cbOut += sizeof( rgbTerminator ) ;
					}
				}
			}	else	{
				//
				//	if fAppend is TRUE then we need to add the terminator
				//
				if( fAppend )	{
					CopyMemory( ((BYTE*)lpb) + cbActual, rgbTerminator, sizeof( rgbTerminator ) ) ;
					cbActual += sizeof( rgbTerminator ) ;
				}
			}

			//
			//	Adjust the offset we're writing into the file to account for the accumulated effects of dot stuffing !
			//
			povl->Offset = DWORD(((long)povl->Offset) + m_cbCumulativeBias) ;

			if( (fResult =
					pfnIO(	patqContext,
							lpb,
							cbActual,
							(OVERLAPPED*)povl
							))	)	{

				//
				//	Did we issue the users IO or our own ?
				//
				if( povl != &ovl )	{
					//
					//	Okay update the bias !
					//
					m_cbCumulativeBias += cbActual - BytesToTransfer ;

				}	else	{
					//
					//	Okay - we did our own IO !
					//
					DWORD	cbTransferred ;		
					_VERIFY(WaitForSingleObject(hEvent, INFINITE) ==
								WAIT_OBJECT_0);
					fResult = GetOverlappedResult(	patqContext->hAsyncIO,
													(OVERLAPPED*)povl,
													&cbTransferred,
													FALSE );
					if (fResult)	{
						//
						//	Make sure all of our bytes transferred !
						//
						_ASSERT( cbTransferred == cbActual ) ;
						//
						//	Record the buffer we issued the IO within !
						//
						lpo->Reserved2 = (UINT_PTR)lpbOut ;
						//
						//	Offset the write -
						//
						lpo->Offset = DWORD(((long)lpo->Offset) + m_cbCumulativeBias + (int)cbTransferred) ;
						//
						//	NOW - compute the correct bias !
						//
						m_cbCumulativeBias += (int)cbTransferred + (int)cbOut - (int)BytesToTransfer ;
						//
						//	Now issue the users requested IO operation !
						//
						if (((DWORD_PTR) lpo->hEvent) & 0x1) {
							// If they are doing an sync operation then we need
							// to wait for it to complete so that we can clean up
							// lpbOut.
							HANDLE hEventOrig = lpo->hEvent;

							lpo->hEvent = (HANDLE)(((DWORD_PTR)hEvent) | 0x1) ; // we want to get the completion here !

							BOOL f = pfnIO( patqContext,
											lpbOut,
											cbOut,
											(LPOVERLAPPED)lpo
											) ;
							if (f) {
								// wait for the IO to finish
								_VERIFY(WaitForSingleObject(hEvent, INFINITE)
									== WAIT_OBJECT_0);

								// call our completion function to clean up
								// our allocated memory.  by setting pfn
								// to NULL we ensure that we never call
								// a user's completion function
								lpo->Reserved3 = NULL;
								AsyncIOCompletion(NULL, lpo, 0, 0);

								// signal the caller's event so that they
								// don't block
								lpo->hEvent = hEventOrig;
								_VERIFY(SetEvent((HANDLE) ((DWORD_PTR) hEventOrig & ~0x1)));
							}
						} else {
							return  pfnIO(  patqContext,
											lpbOut,
											cbOut,
											(LPOVERLAPPED)lpo
											) ;
						}
					}
					if (hEvent)	_VERIFY( CloseHandle(hEvent) );
				}
			}	// pfnIO()
		}	//	fResult == TRUE !
	}
	//
	//	If we fall through to here, some kind of fatal error occurred !
	//
	return	fResult ;
} ;


BOOL
DOT_STUFF_MANAGER::IssueAsyncIOAndCapture(
		IN	PFNAtqIssueAsyncIO	pfnIO,
		IN	PATQ_CONTEXT	patqContext,
		IN	LPVOID			lpb,
		IN	DWORD			BytesToTransfer,
		IN	FH_OVERLAPPED*	lpo,
		IN	BOOL			fFinalIO,
		IN	BOOL			fTerminatorIncluded
		)	{
/*++

Routine Description :

	This function munges an IO the user has given us to
	do stuff to its dot stuffing.

Arguments :

	pfnIO - Pointer to the ATQ function which will do the IO
	patqContext - the ATQ context we're using to issue the IO
	lpb - the buffer the users data lives in !
	BytesToTransfer - the number of bytes the user wants us to transfer
	lpo - The users overlapped structure
	fFinalIO - if TRUE this is the last IO
	fTerminatorIncluded - if TRUE the "\r\n.\r\n" is included in the message

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	_ASSERT( lpo != 0 ) ;
	_ASSERT( patqContext != 0 ) ;
	_ASSERT( lpb != 0 ) ;
	_ASSERT( BytesToTransfer != 0 ) ;
	_ASSERT( lpo != 0 ) ;

	//
	//	Assume everything works !
	//
	BOOL	fResult = TRUE ;

	//
	//	Munge the OVERLAPPED structure to preserve callers original state !
	//
	lpo->Reserved1 = BytesToTransfer ;
	lpo->Reserved2 = 0 ;

	//
	//	Check to see whether we need to do anything funky to this IO !
	//
	if( m_pManipulator == 0 )	{

		return	pfnIO(	patqContext,
						lpb,
						BytesToTransfer,
						(LPOVERLAPPED)lpo
						) ;

	}	else	{

		//
		//	The user shouldn't do synchronous reads against us - if they
		//	want us to filter the IO's
		//
		_ASSERT( ((UINT_PTR)lpo->hEvent & 0x1) == 0 ) ;

		//
		//	Setup the overlapped so that we can process the read completion !
		//
		m_pManipulator->AddRef() ;
		lpo->Reserved1 = (UINT_PTR)BytesToTransfer ;
		lpo->Reserved2 = (UINT_PTR)lpb ;
		lpo->Reserved3 = (UINT_PTR)lpo->pfnCompletion ;
		lpo->Reserved4 = (UINT_PTR)((IDotManipBase*)m_pManipulator) ;
		lpo->pfnCompletion = DOT_STUFF_MANAGER::AsyncIOAndCaptureCompletion ;
		if( fFinalIO && fTerminatorIncluded )	{
			//
			//	Assume user doesn't use high bit of BytesToTransfer - !
			//
			lpo->Reserved1 |= 0x80000000 ;
		}

		fResult = pfnIO(
						patqContext,
						lpb,
						BytesToTransfer,
						(LPOVERLAPPED)lpo
						) ;

	}
	//
	//	If we fall through to here, some kind of fatal error occurred !
	//
	return	fResult ;
} ;



void
DOT_STUFF_MANAGER::AsyncIOCompletion(
		IN	FIO_CONTEXT*	pContext,
		IN	FH_OVERLAPPED*	lpo,
		IN	DWORD			cb,
		IN	DWORD			dwStatus
		)	{
/*++

Routine Description :

	This function munges the IO completion so that it looks
	totally legit to the user !

Arguments :

	pContext - the FIO_CONTEXT that issued the IO
	lpo -		the extended overlap structure issued by the client
	cb	-		the number of bytes transferred
	dwStatus -	the result of the IO !

Return Value :

	None.

--*/


	//
	//	Get the original number of bytes the caller requested to be transferred !
	//
	DWORD	cbTransferred = (DWORD)lpo->Reserved1 ;
	//
	//	Find out if there was any additional memory we allocated that should now be freed !
	//
	LPBYTE	lpb = (LPBYTE)lpo->Reserved2 ;
	//
	//	Free the memory if present !
	//
	if( lpb )	{
		delete[]	lpb ;
	}

	//
	//	Now call the original IO requestor !
	//
	PFN_IO_COMPLETION	pfn = (PFN_IO_COMPLETION)lpo->Reserved3 ;

	if (pfn != NULL) {
		pfn(	pContext,
			lpo,
			cbTransferred,
			dwStatus
			) ;
	}
}

void
DOT_STUFF_MANAGER::AsyncIOAndCaptureCompletion(
		IN	FIO_CONTEXT*	pContext,
		IN	FH_OVERLAPPED*	lpo,
		IN	DWORD			cb,
		IN	DWORD			dwCompletionStatus
		)	{


/*++

Routine Description :

	This function munges the IO completion so that it looks
	totally legit to the user !

Arguments :

	pContext - the FIO_CONTEXT that issued the IO
	lpo -		the extended overlap structure issued by the client
	cb	-		the number of bytes transferred
	dwStatus -	the result of the IO !

Return Value :

	None.

--*/


	//
	//	Get the original number of bytes the caller requested to be transferred !
	//
	DWORD	cbTransferred = cb ;

	//
	//	Check to see if we have some work to do on the users buffer !
	//
	if( lpo->Reserved4 )	{

		//
		//	Find out if this was the final read and included the terminator !
		//
		BOOL	fFinal = !(!(lpo->Reserved1 & 0x80000000)) ;

		//
		//	Find out if there was any additional memory we allocated that should now be freed !
		//
		LPBYTE	lpb = (LPBYTE)lpo->Reserved2 ;
		_ASSERT( lpb != 0 ) ;

		//
		//	Okay - get the pointer to our object !
		//
		IDotManipBase*	pBase = (IDotManipBase*)lpo->Reserved4 ;
		DWORD	cbRemains ;
		BYTE*	lpbOut ;
		DWORD	cbOut ;
		int		cBias ;
		DWORD	cbScan = cb ;
		if( fFinal )	{
			cbScan -= 5 ;
		}

		BOOL	fResult =
		pBase->ProcessBuffer(	lpb,
								cbScan,
								cbScan,
								cbRemains,
								lpbOut,
								cbOut,
								cBias
								) ;

		//
		//	Dot scanning only should occur - buffer shouldn't change !
		//
		_ASSERT( fResult ) ;
		_ASSERT( lpbOut == 0 ) ;
		_ASSERT( cbRemains == cbScan ) ;
		_ASSERT( cbOut == 0 ) ;
		_ASSERT( cBias == 0 ) ;

		pBase->Release() ;
	}

	//
	//	Now call the original IO requestor !
	//
	PFN_IO_COMPLETION	pfn = (PFN_IO_COMPLETION)lpo->Reserved3 ;

	_ASSERT( pfn != 0 ) ;

	pfn(	pContext,
			lpo,
			cbTransferred,
			dwCompletionStatus
			) ;


}

BOOL
DOT_STUFF_MANAGER::SetDotStuffing(	BOOL	fEnable,
									BOOL	fStripDots
									)	{
/*++

Routine Description :

	This function sets the manager to do some dot stuffing state.
	Erases any previous dot stuffing state.

Arguments :

	fEnable - TURN dot stuffing on
	fStripDots - Remove Dots

Return Value :

	TRUE if successfull !

--*/

	//
	//	Destroy any existing dot stuffing state !
	//
	m_pManipulator = 0 ;

	//
	//	NOW - set up the new dot stuffing state !
	//

	if( fEnable	)	{
		BYTE*	lpbReplace = szShrink ;
		if( !fStripDots )	{
			lpbReplace = szGrow ;
		}
		m_pManipulator = new	CDotModifier(	szDotStuffed,
												lpbReplace
												) ;
		return	m_pManipulator != 0 ;
	}
	return	TRUE ;
}


BOOL
DOT_STUFF_MANAGER::SetDotScanning(	BOOL	fEnable	)	{
/*++

Routine Description :

	This function sets the manager to do some dot stuffing state.
	Erases any previous dot stuffing state.

Arguments :

	fEnable - TURN dot scanning on

Return Value :

	TRUE if successfull !

--*/

	//
	//	Destroy any existing dot stuffing state !
	//
	m_pManipulator = 0 ;

	//
	//	NOW - set up the new dot stuffing state !
	//

	if( fEnable	)	{
		m_pManipulator = new	CDotScanner(	FALSE ) ;
		return	m_pManipulator != 0 ;
	}
	return	TRUE ;
}

BOOL
DOT_STUFF_MANAGER::GetStuffState(	OUT	BOOL&	fStuffed	)	{
/*++

Routine Description :

	This function returns the results of our dot stuffing operations !

Arguments :

	fStuffed - OUT parameter -
		will return FALSE if no dots were processed, scanned or modified
		TRUE otherwise

Return Value :

	TRUE if we were actually scanning the IO's on this context
	FALSE otherwise - FALSE implies that fStuffed is useless


--*/

	fStuffed = FALSE ;

	if( m_pManipulator	)	{
		fStuffed = m_pManipulator->NumberOfOccurrences() != 0 ;
		return	TRUE ;
	}
	return	FALSE ;
}

//
//	Determine whether we have a valid Cache Key !
//
BOOL
CFileCacheKey::IsValid() {
/*++

Routine Description :

	This function is for debug and _ASSERT's -
	check to see whether the Key is in a valid state !

Arguments :

	Nont.

Return Value :

	TRUE if we are valid,
	FALSE otherwise !

--*/

	if( m_lpstrPath == 0 )
		return	FALSE ;
	if( m_cbPathLength == 0 )
		return	FALSE ;
	if( strlen( m_lpstrPath )+1 != m_cbPathLength )
		return	FALSE ;
	if( m_cbPathLength < BUFF_SIZE &&
		m_lpstrPath != m_szBuff )
		return	FALSE ;
	if( m_cbPathLength >= BUFF_SIZE &&
		m_lpstrPath == m_szBuff )
		return	FALSE ;
	return	TRUE ;
}

//
//	Construct one of these objects from the user provided key !
//
CFileCacheKey::CFileCacheKey(	LPSTR	lpstr	) :
	m_cbPathLength( strlen( lpstr ) + 1 ),
	m_lpstrPath( 0 )	{
/*++

Routine Description :

	This function constructs the CFileCacheKey from the specified
	file name !

Arguments :

	lpstr - The File name

Return Value :

	None.

--*/

	TraceFunctEnter( "CFileCacheKey::CFileCacheKey" ) ;

	if( m_cbPathLength > BUFF_SIZE ) {
		m_lpstrPath = new char[m_cbPathLength] ;
	}	else	{
		m_lpstrPath = m_szBuff ;
	}

	DebugTrace( (DWORD_PTR)this, "m_cbPathLength %x m_lpstrPath %x",
		m_cbPathLength, m_lpstrPath ) ;

	if( m_lpstrPath ) {
		CopyMemory( m_lpstrPath, lpstr, m_cbPathLength ) ;
	}	else	{
		m_cbPathLength = 0 ;
	}
}

//
//	We must have a Copy Constructor ! -
//	It is only used the MultiCacheEx<>, so
//	we safely wipe out the RHS CFileCacheKey !
//
CFileCacheKey::CFileCacheKey(	CFileCacheKey&	key ) {
/*++

Routine Description :

	Copy an existing file key, into another !

	We are only used by MultiCacheEx<> when it is initializing
	an entry for the cache - we know that the memory of the RHS
	may be dynamically allocated, and we take that memory rather
	than copy it.  Must set RHS's pointers to NULL so that it
	doesn't do a double free !

Arguments :

	key - RHS of the initialization

Return Value :

	None.

--*/

	TraceFunctEnter( "CFileCacheKey::Copy Constructor" ) ;

	if( key.m_cbPathLength > BUFF_SIZE ) {
		m_lpstrPath = key.m_lpstrPath ;
		key.m_lpstrPath = 0 ;
		key.m_cbPathLength = 0 ;
	}	else	{
		CopyMemory( m_szBuff, key.m_lpstrPath, key.m_cbPathLength ) ;
		m_lpstrPath = m_szBuff ;
	}
	m_cbPathLength = key.m_cbPathLength ;

	DebugTrace( (DWORD_PTR)this, "m_lpstrPath %x m_cbPathLength %x key.m_lpstrPath %x key.m_cbPathLength %x",
		m_lpstrPath, m_cbPathLength, key.m_lpstrPath, key.m_cbPathLength ) ;

	_ASSERT( IsValid() ) ;
}

//
//	Tell the client whether we're usable !
//
BOOL
CFileCacheKey::FInit()	{
/*++

Routine Description :

	Figure out if we are correctly constructed !
	The only time we can fail to be constructed is when
	memory needs to be allocated - which fortunately
	doesn't occur within MultiCacheEx<> - which doesn't
	check for Key initialization !

Arguments :

	None.

Return Value :

	TRUE if we're ready for use !
	FALSE otherwise !

--*/

	TraceFunctEnter( "CFileCacheKey::FInit" ) ;

	BOOL	fReturn = m_lpstrPath != 0 ;

	_ASSERT( !fReturn || IsValid() ) ;

	DebugTrace( (DWORD_PTR)this, "m_lpstrPath %x", m_lpstrPath ) ;

	return	fReturn ;
}

//
//	Destroy ourselves !
//
CFileCacheKey::~CFileCacheKey() {
/*++

Routine Description :

	Release any memory we've acquired if necessary !

Arguments :

	None.

Return Value :

	None.

--*/
	TraceFunctEnter( "CFileCacheKey::~CFIleCacheKey" ) ;

	DebugTrace( (DWORD_PTR)this, "m_lpstrPath %x m_lpstrPath %s",
		m_lpstrPath, m_lpstrPath ? m_lpstrPath : "NULL" ) ;

	if( m_lpstrPath != 0 ) {
		_ASSERT( IsValid() ) ;
		if( m_lpstrPath != m_szBuff ) {
			delete[]	m_lpstrPath ;
		}
	}
}

DWORD
CFileCacheKey::FileCacheHash(	CFileCacheKey*	p )	{
/*++

Routine Description :

	This function computes the hash value of a key.
	We call out to CRCHash - a very robust hash algorithm.

Arguments :

	p - the key we need to hash

Return Value :

	The hash value !

--*/
	_ASSERT( p != 0 ) ;
	_ASSERT( p->IsValid(  ) ) ;
	return	CRCHash( (const BYTE*)p->m_lpstrPath, p->m_cbPathLength ) ;
}

int
CFileCacheKey::MatchKey(	CFileCacheKey*	pLHS, CFileCacheKey*  pRHS ) {
/*++

Routine Description :

	Determine whether the two keys match !

Arguments :

	pLHS - A key to compare
	pRHS - the other key to compare

Return Value :

	0 if unequal !

--*/
	_ASSERT( pLHS != 0 ) ;
	_ASSERT( pRHS != 0 ) ;
	_ASSERT( pLHS->IsValid() ) ;
	_ASSERT( pRHS->IsValid() ) ;

	int	iReturn = pLHS->m_cbPathLength - pRHS->m_cbPathLength ;
	if( iReturn == 0 )
		iReturn = memcmp( pLHS->m_lpstrPath, pRHS->m_lpstrPath, pLHS->m_cbPathLength ) ;

	return	iReturn ;
}




BOOL
WINAPI
DllMain(	HMODULE		hInst,
			DWORD		dwReason,
			LPVOID		lpvReserved
			)	{
/*++

Routine Description :

	Called by the C-Runtimes to initialize our DLL.
	We will set up a critical section used in our init calls !

Arguments :

	hInst - handle to our module
	dwReason - why we were called
	lpvReserved -

Return Value :

	TRUE always - we can't fail

--*/

	if( dwReason == DLL_PROCESS_ATTACH ) {

		InitializeCriticalSection( &g_critInit ) ;
		DisableThreadLibraryCalls( hInst ) ;

	}	else	if( dwReason == DLL_PROCESS_DETACH ) {

		DeleteCriticalSection( &g_critInit ) ;

	}	else	{
		//
		//	We should not get any other notifications -
		//	we explicitly disable them !
		//
		_ASSERT( FALSE ) ;
	}
	return	TRUE ;
}


//
//	Cache Initialization Constants - These parameters control
//	the cache's behaviour !  How many files we'll hold etc...
//

//
//	The lifetime of each cache entry - in seconds !
//
DWORD	g_dwLifetime = 30 * 60 ;	// default is 30 minutes

//
//	The maximum number of elements the cache should allow
//
DWORD	g_cMaxHandles = 10000 ;	// default - 10000 items !

//
//	The number of subcaches we should use - larger number can
//	increase parallelism and reduce contention !
//
DWORD	g_cSubCaches = 64 ;

//
//	Define our registry key settings !
//
LPSTR	StrParmKey = "System\\CurrentControlSet\\Services\\Inetinfo\\Parameters";
LPSTR	StrLifetimeKey = "FileCacheLifetimeSeconds" ;
LPSTR	StrMaxHandlesKey = "FileCacheMaxHandles" ;
LPSTR	StrSubCachesKey = "FileCacheSubCaches" ;

void
GetRegistrySettings()	{
    DWORD error;
    HKEY key = NULL;
    DWORD valueType;
    DWORD dataSize;

    TraceFunctEnter("GetRegistrySettings") ;

	//
	//	First compute some defaults based on the amount of memory we have !
	//
	MEMORYSTATUS	memStatus ;
	memStatus.dwLength = sizeof( MEMORYSTATUS ) ;
	GlobalMemoryStatus( &memStatus ) ;

	DWORD	cMaxHandles = (DWORD)(memStatus.dwTotalPhys / (32 * 1024 * 1024)) ;
	if( cMaxHandles == 0 ) cMaxHandles = 1 ;
	cMaxHandles *= 800 ;
	if( cMaxHandles > 50000 ) {
		cMaxHandles = 50000 ;
	}
	g_cMaxHandles = cMaxHandles ;

    //
    // Open root key
    //

    error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                StrParmKey,
                NULL,
                KEY_QUERY_VALUE,
                &key
                );

    if ( error != NO_ERROR ) {
        ErrorTrace(0,"Error %d opening %s\n",error,StrParmKey);
        return ;
    }

	DWORD	dwLifetime = g_dwLifetime ;
	dataSize = sizeof( dwLifetime ) ;
	error = RegQueryValueEx(
						key,
						StrLifetimeKey,
						NULL,
						&valueType,
						(LPBYTE)&dwLifetime,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	The registry entry is in minutes - convert to milliseconds
		//
		g_dwLifetime = dwLifetime ;

	}

	dataSize = sizeof( DWORD ) ;
	error = RegQueryValueEx(
						key,
						StrMaxHandlesKey,
						NULL,
						&valueType,
						(LPBYTE)&cMaxHandles,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {
		//
		//	Should be a valid switch
		//
		g_cMaxHandles = cMaxHandles ;
	}

	DWORD	cSubCaches = g_cSubCaches ;
	dataSize = sizeof( cSubCaches ) ;
	error = RegQueryValueEx(
						key,
						StrSubCachesKey,
						NULL,
						&valueType,
						(LPBYTE)&cSubCaches,
						&dataSize
						) ;
	if( (error == ERROR_SUCCESS) && (valueType == REG_DWORD) ) {

		//
		//	Should be a valid switch
		//
		g_cSubCaches = cSubCaches ;

	}

    if (key)
        RegCloseKey(key);
}




FILEHC_EXPORT
BOOL
InitializeCache()	{
/*++

Routine Description :

	Initializes the file handle cache for use by clients !

Arguments :

	None.

Return Value :

	TRUE if initialized - FALSE if not
	if we return FALSE don't call TerminateCache()

--*/
	InitAsyncTrace() ;
	TraceFunctEnter( "InitializeCache" ) ;

	EnterCriticalSection( &g_critInit ) ;

	crcinit() ;

	if( !FIOInitialize( 0 ) ) {
		DebugTrace( (DWORD_PTR)0, "FIOInitialize - failed GLE %x", GetLastError() ) ;
		LeaveCriticalSection( &g_critInit ) ;
		TermAsyncTrace();
		return	FALSE ;
	}

	BOOL	fReturn = TRUE ;
	if( InterlockedIncrement( &g_cCacheInits ) == 1 ) {

		GetRegistrySettings() ;

		//
		//	Initialize STAXMEM !
		//
		if( CreateGlobalHeap( 0, 0, 0, 0 ) )	{
			fReturn = FALSE ;
			if( CacheLibraryInit() ) {
				if(	InitNameCacheManager() )	{
					g_pFileCache = new	FILECACHE() ;
					if( g_pFileCache ) {
						if( g_pFileCache->Init(	CFileCacheKey::FileCacheHash,
												CFileCacheKey::MatchKey,
												g_dwLifetime, // One hour expiration !
												g_cMaxHandles,  // large number of handles !
												g_cSubCaches,	// Should be plenty of parallelism
												0		 // No statistics for now !
												) )	{
							fReturn = TRUE ;
						}	else	{
							delete	g_pFileCache ;
						}
					}
				}
			}
			if( !fReturn ) {
				CacheLibraryTerm() ;
				DestroyGlobalHeap() ;
			}
		}
	}

	if( !fReturn ) {
		long l = InterlockedDecrement( &g_cCacheInits ) ;
		_ASSERT( l >= 0 ) ;
	}

	DebugTrace( (DWORD_PTR)0, "FIOInitialize - result %x GLE %x", fReturn, GetLastError() ) ;

	LeaveCriticalSection( &g_critInit ) ;

	if (!fReturn) {
		TermAsyncTrace();
	}

	return	fReturn ;
}

FILEHC_EXPORT
BOOL
TerminateCache()	{

/*++

Routine Description :

	Initializes the file handle cache for use by clients !

Arguments :

	None.

Return Value :

	TRUE if initialized - FALSE if not
	if we return FALSE don't call TerminateCache()

--*/

	TraceFunctEnter( "TerminateCache" ) ;

	EnterCriticalSection( &g_critInit ) ;

	//
	//	We must be initialized - check this !
	//
	_ASSERT( g_pFileCache ) ;

	long l = InterlockedDecrement( &g_cCacheInits ) ;
	_ASSERT( l>=0 ) ;
	if( l==0 )	{
		TermNameCacheManager() ;
		delete	g_pFileCache ;
		g_pFileCache = 0 ;
		CacheLibraryTerm() ;
		DestroyGlobalHeap() ;
	}

	BOOL	fRet = FIOTerminate( ) ;
	DWORD	dw = GetLastError() ;
	_ASSERT( fRet ) ;

	TermAsyncTrace() ;

	LeaveCriticalSection( &g_critInit ) ;

	return	fRet ;
}



FILEHC_EXPORT
BOOL
FIOInitialize(
    IN DWORD dwFlags
    )	{
/*++

Routine Description :

	Initialize the DLL to deal with Async IO handled through ATQ !

Arguments :

	dwFlags - Place holder means nothing now !

Return Value :

	TRUE if succesfull initialized !

--*/

	InitAsyncTrace() ;
	BOOL	fReturn = TRUE ;

	EnterCriticalSection( &g_critInit ) ;

	if( InterlockedIncrement( &g_cIOInits ) == 1 ) {

		_VERIFY( CreateGlobalHeap( 0, 0, 0, 0 ) ) ;

#ifndef _NT4_TEST_
		g_hIisRtl = LoadLibrary( "iisrtl.dll" ) ;
		fReturn = fReturn && (g_hIisRtl != 0) ;
		if( fReturn ) {

			g_InitializeIISRTL = (PFNInitializeIISRTL)GetProcAddress( g_hIisRtl, "InitializeIISRTL" ) ;
			g_TerminateIISRTL = (PFNTerminateIISRTL)GetProcAddress( g_hIisRtl, "TerminateIISRTL" ) ;

			fReturn = fReturn && (g_InitializeIISRTL != 0) && (g_TerminateIISRTL != 0) ;

			if( fReturn )
				fReturn = fReturn && g_InitializeIISRTL() ;
		}
#endif
		if( fReturn ) {
			//
			//	Load up IIS !
			//
			g_hIsAtq = LoadLibrary("isatq.dll" ) ;
			g_AtqInitialize =	(PFNAtqInitialize)GetProcAddress( g_hIsAtq, SZATQINITIALIZE ) ;
			g_AtqTerminate =	(PFNAtqTerminate)GetProcAddress( g_hIsAtq, SZATQTERMINATE ) ;
			g_AtqAddAsyncHandle=	(PFNAtqAddAsyncHandle)GetProcAddress( g_hIsAtq, SZATQADDASYNCHANDLE ) ;
			g_AtqCloseFileHandle=	(PFNAtqCloseFileHandle)GetProcAddress( g_hIsAtq, SZATQCLOSEFILEHANDLE ) ;
			g_AtqFreeContext=		(PFNAtqFreeContext)GetProcAddress( g_hIsAtq, SZATQFREECONTEXT ) ;
			g_AtqReadFile =			(PFNAtqIssueAsyncIO)GetProcAddress( g_hIsAtq, SZATQREADFILE ) ;
			g_AtqWriteFile =		(PFNAtqIssueAsyncIO)GetProcAddress( g_hIsAtq, SZATQWRITEFILE ) ;

			fReturn	=	fReturn &&
						(g_AtqInitialize != 0) &&
						(g_AtqTerminate != 0) &&
						(g_AtqAddAsyncHandle != 0) &&
						(g_AtqCloseFileHandle != 0) &&
						(g_AtqFreeContext != 0) &&
						(g_AtqReadFile != 0) &&
						(g_AtqWriteFile != 0) ;
		}
		if( fReturn )	{
			_ASSERT( dwFlags == 0 ) ;
			fReturn = g_AtqInitialize( 0 ) ;

		}
	}
	if( !fReturn ) {
		InterlockedDecrement( &g_cIOInits ) ;
	}

	LeaveCriticalSection( &g_critInit ) ;

	if (!fReturn) TermAsyncTrace();

	return	fReturn ;
}

FILEHC_EXPORT
BOOL
FIOTerminate(
    VOID
    )	{
/*++

Routine Description :

	Terminate Async IO in our DLL !

Arguments :

	NULL

Return Value :

	TRUE if there were no errors during uninit !

--*/

	EnterCriticalSection( &g_critInit ) ;

	BOOL	fReturn = TRUE ;
	long l = InterlockedDecrement( &g_cIOInits ) ;
	if( l == 0 ) {
		fReturn = g_AtqTerminate( ) ;
#ifndef _NT4_TEST_
        g_TerminateIISRTL() ;
        FreeLibrary( g_hIisRtl ) ;
        g_hIisRtl = 0 ;
#endif
        FreeLibrary( g_hIsAtq ) ;
        g_hIsAtq = 0 ;
    	_VERIFY( DestroyGlobalHeap() ) ;
	}
	//
	//	Save the error code so TermAsyncTrace() don't confuse things !
	//
	DWORD	dw = GetLastError() ;

	_ASSERT( l >= 0 ) ;

	TermAsyncTrace() ;

	SetLastError( dw ) ;

	LeaveCriticalSection( &g_critInit ) ;

	return	fReturn ;
}



FILEHC_EXPORT
BOOL
FIOReadFileEx(
    IN  PFIO_CONTEXT	pfioContext,
    IN  LPVOID			lpBuffer,
    IN  DWORD			BytesToRead,
	IN	DWORD			BytesAvailable,
    IN  FH_OVERLAPPED * lpo,
	IN	BOOL			fFinalRead,	// Is this the final write ?
	IN	BOOL			fIncludeTerminator	// if TRUE contains CRLF.CRLF terminator which shouldn't be stuffed
    )	{
/*++

Routine description :

	Issue an Async Write IO against the file -
	Use the underlying ATQ to do it !

Arguments :

	pfioContext - the IO Context we gave to the client !
	lpBuffer - the buffer to write from !
	BytesToRead - Number of bytes we want to transfer !
	BytesAvailable - Number of bytes in the buffer we can mess with !
	lpo - the overlapped to return when this completes !

Return Value :

	TRUE if successfull - FALSE otherwise !

--*/

	TraceFunctEnter( "FIOReadFileEx" ) ;

	_ASSERT( pfioContext != 0 );
	_ASSERT( lpBuffer != 0 ) ;
	_ASSERT( BytesToRead != 0 ) ;
	_ASSERT( lpo != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;
	_ASSERT( BytesAvailable >= BytesToRead ) ;


	FIO_CONTEXT_INTERNAL*	pInternal = (FIO_CONTEXT_INTERNAL*)pfioContext ;

	_ASSERT( pInternal->m_dwSignature == ATQ_ENABLED_CONTEXT ) ;
	_ASSERT( pInternal->m_pAtqContext != 0 ) ;

	DebugTrace( (DWORD_PTR)pfioContext, "fioContext %x lpBuffer %x BytesToRead %x lpo %x",
		pfioContext, lpBuffer, BytesToRead , lpo ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( pInternal ) ;
	_ASSERT( pCache != 0 ) ;

	return	pCache->m_ReadStuffs.IssueAsyncIOAndCapture(
							ReadWrapper,
							pInternal->m_pAtqContext,
							(LPVOID)lpBuffer,
							BytesToRead,
							lpo,
							fFinalRead,
							fIncludeTerminator
							) ;
}


FILEHC_EXPORT
BOOL
FIOReadFile(
    IN  PFIO_CONTEXT	pfioContext,
    IN  LPVOID		lpBuffer,
    IN  DWORD		BytesToRead,
    IN  FH_OVERLAPPED * lpo
    )	{
/*++

Routine description :

	Issue an Async Read IO against the file -
	Use the underlying ATQ to do it !

Arguments :

	pfioContext - the IO Context we gave to the client !
	lpBuffer - the buffer to read into !
	BytesToRead - Number of bytes we want to get !
	lpo - the overlapped to return when this completes !

Return Value :

	TRUE if successfull - FALSE otherwise !

--*/

	TraceFunctEnter( "FIOReadFile" ) ;

	_ASSERT( pfioContext != 0 ) ;
	_ASSERT( lpBuffer != 0 ) ;
	_ASSERT( BytesToRead != 0 ) ;
	_ASSERT( lpo != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;


	FIO_CONTEXT_INTERNAL*	pInternal = (FIO_CONTEXT_INTERNAL*)pfioContext ;

	_ASSERT( pInternal->m_dwSignature == ATQ_ENABLED_CONTEXT ) ;
	_ASSERT( pInternal->m_pAtqContext != 0 ) ;

	DebugTrace( (DWORD_PTR)pfioContext, "fioContext %x lpBuffer %x BytesToRead %x lpo %x",
		pfioContext, lpBuffer, BytesToRead, lpo ) ;

	return	FIOReadFileEx(	pfioContext,
							lpBuffer,
							BytesToRead,
							BytesToRead,
							lpo,
							FALSE,
							FALSE
							) ;
}

FILEHC_EXPORT
BOOL
FIOWriteFileEx(
    IN  PFIO_CONTEXT	pfioContext,
    IN  LPVOID		lpBuffer,
    IN  DWORD		BytesToWrite,
	IN	DWORD		BytesAvailable,
    IN  FH_OVERLAPPED * lpo,
	IN	BOOL			fFinalWrite,	// Is this the final write ?
	IN	BOOL			fIncludeTerminator	// if TRUE contains CRLF.CRLF terminator which shouldn't be stuffed
    )	{
/*++

Routine description :

	Issue an Async Write IO against the file -
	Use the underlying ATQ to do it !

Arguments :

	pfioContext - the IO Context we gave to the client !
	lpBuffer - the buffer to write from !
	BytesToRead - Number of bytes we want to transfer !
	BytesAvailable - Number of bytes in the buffer we can mess with !
	lpo - the overlapped to return when this completes !

Return Value :

	TRUE if successfull - FALSE otherwise !

--*/

	TraceFunctEnter( "FIOWriteFileEx" ) ;

	_ASSERT( pfioContext != 0 );
	_ASSERT( lpBuffer != 0 ) ;
	_ASSERT( BytesToWrite != 0 ) ;
	_ASSERT( lpo != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;
	_ASSERT( BytesAvailable >= BytesToWrite ) ;


	FIO_CONTEXT_INTERNAL*	pInternal = (FIO_CONTEXT_INTERNAL*)pfioContext ;

	_ASSERT( pInternal->m_dwSignature == ATQ_ENABLED_CONTEXT ) ;
	_ASSERT( pInternal->m_pAtqContext != 0 ) ;

	DebugTrace( (DWORD_PTR)pfioContext, "fioContext %x lpBuffer %x BytesToWrite %x lpo %x",
		pfioContext, lpBuffer, BytesToWrite, lpo ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( pInternal ) ;
	_ASSERT( pCache != 0 ) ;

	return	pCache->m_WriteStuffs.IssueAsyncIO(
							WriteWrapper,
							pInternal->m_pAtqContext,
							(LPVOID)lpBuffer,
							BytesToWrite,
							BytesAvailable,
							lpo,
							fFinalWrite,
							fIncludeTerminator
							) ;
}



FILEHC_EXPORT
BOOL
FIOWriteFile(
    IN  PFIO_CONTEXT	pfioContext,
    IN  LPCVOID		lpBuffer,
    IN  DWORD		BytesToWrite,
    IN  FH_OVERLAPPED * lpo
    )	{
/*++

Routine description :

	Issue an Async Write IO against the file -
	Use the underlying ATQ to do it !

Arguments :

	pfioContext - the IO Context we gave to the client !
	lpBuffer - the buffer to write from !
	BytesToRead - Number of bytes we want to transfer !
	lpo - the overlapped to return when this completes !

Return Value :

	TRUE if successfull - FALSE otherwise !

--*/

	TraceFunctEnter( "FIOWriteFile" ) ;

	_ASSERT( pfioContext != 0 );
	_ASSERT( lpBuffer != 0 ) ;
	_ASSERT( BytesToWrite != 0 ) ;
	_ASSERT( lpo != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;


	FIO_CONTEXT_INTERNAL*	pInternal = (FIO_CONTEXT_INTERNAL*)pfioContext ;

	_ASSERT( pInternal->m_dwSignature == ATQ_ENABLED_CONTEXT ) ;
	_ASSERT( pInternal->m_pAtqContext != 0 ) ;

	DebugTrace( (DWORD_PTR)pfioContext, "fioContext %x lpBuffer %x BytesToWrite %x lpo %x",
		pfioContext, lpBuffer, BytesToWrite, lpo ) ;

	return	FIOWriteFileEx(	pfioContext,
							(LPVOID)lpBuffer,
							BytesToWrite,
							BytesToWrite,
							lpo,
							FALSE,
							FALSE
							) ;
}

//
//	Associate a file with an async context !
//
FILEHC_EXPORT
PFIO_CONTEXT
AssociateFileEx(	HANDLE	hFile,
					BOOL	fStoredWithDots,
					BOOL	fStoredWithTerminatingDot
					)	{
/*++

Routine Description :

	Return to the client an FIO_CONTEXT that they can use to do IO's etc !

Arguments :

	hFile - the file handle that should be in the context !
	fStoredWithDots - if TRUE then this object was stored with dot stuffing !

Return Value :

	the context they got - NULL on failure !

--*/

	TraceFunctEnter( "AssociateFileEx" ) ;

	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	PFIO_CONTEXT	pReturn = 0 ;

	CFileCacheObject*	pObject = new	CFileCacheObject(	fStoredWithDots,
															fStoredWithTerminatingDot
															) ;
	if( pObject ) {

		pReturn = (PFIO_CONTEXT)pObject->AsyncHandle( hFile ) ;
		if( !pReturn )
			pObject->Release() ;
	}

	DebugTrace( (DWORD_PTR)pObject, "pObject %x hFile %x pReturn %x", pObject, hFile, pReturn ) ;

	return	pReturn ;
}


//
//	Associate a file with an async context !
//
FILEHC_EXPORT
PFIO_CONTEXT
AssociateFile(	HANDLE	hFile	)	{
/*++

Routine Description :

	Return to the client an FIO_CONTEXT that they can use to do IO's etc !

Arguments :

	hFile - the file handle that should be in the context !
	fStoredWithDots - if TRUE then this object was stored with dot stuffing !

Return Value :

	the context they got - NULL on failure !

--*/

	TraceFunctEnter( "AssoicateFile" ) ;

	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	return	AssociateFileEx( hFile, FALSE, FALSE ) ;
}




//
//	Release a Context !
//
FILEHC_EXPORT
void
ReleaseContext(	PFIO_CONTEXT	pContext )	{
/*++

Routine Description :

	Given a context we've previously given to clients -
	release it back to the cache or the appropriate place !
	(May not have been from the cache!)

Arguments :

	The PFIO_CONTEXT !

Return Value :

	False if there was some kind of error !

--*/

	TraceFunctEnter( "ReleaseContext" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;


	DebugTrace( (DWORD_PTR)pContext, "Release pContext %x pCache %x", pContext, pCache ) ;

	//
	//	Now do the right thing, whether this is from a cache or whatever !
	//
	pCache->Return() ;

}

FILEHC_EXPORT
void
AddRefContext(	PFIO_CONTEXT	pContext )	{
/*++

Routine Description :

	Given a context we've previously given to clients -
	Add a reference to it !

Arguments :

	The PFIO_CONTEXT !

Return Value :

	False if there was some kind of error !

--*/

	TraceFunctEnter( "AddRefContext" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;


	DebugTrace( (DWORD_PTR)pContext, "AddRef pContext %x pCache %x", pContext, pCache ) ;

	//
	//	Now do the right thing, whether this is from a cache or whatever !
	//
	pCache->Reference() ;
}


FILEHC_EXPORT
BOOL
CloseNonCachedFile(	PFIO_CONTEXT	pFIOContext)	{
/*++

Routine Description :

	This function closes the handle within an FIO_CONTEXT
	if the context is not in the cache !

Arguments :

	pFIOContext - the context who's handle we are to close !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	TraceFunctEnter( "CloseNonCachedFile" ) ;

	_ASSERT( pFIOContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pFIOContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;


	DebugTrace( (DWORD_PTR)pFIOContext, "CloseNonCachedFile pContext %x pCache %x", pFIOContext, pCache ) ;

	//
	//	Now do the right thing, whether this is from a cache or whatever !
	//
	return	pCache->CloseNonCachedFile() ;
}




FILEHC_EXPORT
FIO_CONTEXT*
CacheCreateFile(	IN	LPSTR	lpstrName,
					IN	FCACHE_CREATE_CALLBACK	pfnCallback,
					IN	LPVOID	lpv,
					IN	BOOL	fAsyncContext
					)	{
/*++

Routine Description :

	This function creates a FIO_CONTEXT for the specified file.

Arguments :


Return Value :

	An FIO_CONTEXT that can be used for sync or async IO's

--*/

	TraceFunctEnter( "CacheCreateFile" ) ;

	FIO_CONTEXT*	pReturn = 0 ;
	CFileCacheKey	keySearch(lpstrName) ;

	if( keySearch.FInit() ) {
		CFileCacheConstructor	constructor(	lpv,
												pfnCallback,
												fAsyncContext
												) ;
		CFileCacheObject*	p = g_pFileCache->FindOrCreate(
													keySearch,
													constructor
													) ;

		DebugTrace( (DWORD_PTR)p, "CacheObject %x", p ) ;


		if( p ) {
			if( fAsyncContext ) {
				pReturn = (FIO_CONTEXT*)p->GetAsyncContext(	keySearch,
															constructor
															) ;
			}	else	{
				pReturn = (FIO_CONTEXT*)p->GetSyncContext(	keySearch,
															constructor
															) ;
			}
			if( pReturn == 0  ) {
				g_pFileCache->CheckIn( p ) ;
			}
		}
	}

	DebugTrace( (DWORD_PTR)pReturn, "Result %x lpstrName %x %s pfnCallback %x lpv %x fAsync %x",
		pReturn, lpstrName, lpstrName ? lpstrName : "NULL", pfnCallback, lpv, fAsyncContext ) ;

	//
	//	Note keySearch's destructor takes care of memory we allocated !
	//
	return	pReturn ;
}


FILEHC_EXPORT
FIO_CONTEXT*
CacheRichCreateFile(
					IN	LPSTR	lpstrName,
					IN	FCACHE_RICHCREATE_CALLBACK	pfnCallback,
					IN	LPVOID	lpv,
					IN	BOOL	fAsyncContext
					)	{
/*++

Routine Description :

	This function creates a FIO_CONTEXT for the specified file.

Arguments :


Return Value :

	An FIO_CONTEXT that can be used for sync or async IO's

--*/

	TraceFunctEnter( "CacheRichCreateFile" ) ;

	FIO_CONTEXT*	pReturn = 0 ;
	CFileCacheKey	keySearch(lpstrName) ;

	if( keySearch.FInit() ) {
		CRichFileCacheConstructor	constructor(
												lpv,
												pfnCallback,
												fAsyncContext
												) ;
		CFileCacheObject*	p = g_pFileCache->FindOrCreate(
													keySearch,
													constructor
													) ;

		DebugTrace( (DWORD_PTR)p, "CacheObject %x", p ) ;


		if( p ) {
			if( fAsyncContext ) {
				pReturn = (FIO_CONTEXT*)p->GetAsyncContext(	keySearch,
															constructor
															) ;
			}	else	{
				pReturn = (FIO_CONTEXT*)p->GetSyncContext(	keySearch,
															constructor
															) ;
			}
			if( pReturn == 0  ) {
				g_pFileCache->CheckIn( p ) ;
			}
		}
	}

	DebugTrace( (DWORD_PTR)pReturn, "Result %x lpstrName %x %s pfnCallback %x lpv %x fAsync %x",
		pReturn, lpstrName, lpstrName ? lpstrName : "NULL", pfnCallback, lpv, fAsyncContext ) ;

	//
	//	Note keySearch's destructor takes care of memory we allocated !
	//
	return	pReturn ;
}

BOOL
ReadUtil(	IN	FIO_CONTEXT*	pContext,
			IN	DWORD			ibOffset,
			IN	DWORD			cbToRead,
			IN	BYTE*			lpb,
			IN	HANDLE			hEvent,
			IN	BOOL			fFinal
			)	{
/*++

Routine Description :

	This function will issue a Read against the user's FIO_CONTEXT
	and will complete it synchronously.

Arguments :

	pContext - the FIO_CONTEXT to issue the read against !
	cbToRead - Number of bytes to read !
	lpb - Pointer to the buffer where the data goes !
	hEvent - Event to use to complete IO's
	fFinal - TRUE if this is the last IO !

Return Vlaue :

	TRUE if successfull !

--*/

	FH_OVERLAPPED	ovl ;
	ZeroMemory( &ovl, sizeof( ovl ) ) ;

	ovl.Offset = ibOffset ;
	ovl.hEvent = (HANDLE)(((DWORD_PTR)hEvent) | 0x1) ;	// we want to get the completion here !


	if( FIOReadFileEx(	pContext,
						lpb,
						cbToRead,
						cbToRead,
						&ovl,
						fFinal,
						FALSE
						)	)	{

		DWORD	cbTransfer = 0 ;
		if( GetOverlappedResult(	pContext->m_hFile,
									(LPOVERLAPPED)&ovl,
									&cbTransfer,
									TRUE ) )	{
			return	TRUE ;
		}
	}
	return	FALSE ;
}


BOOL
WriteUtil(	IN	FIO_CONTEXT*	pContext,
			IN	DWORD			ibOffset,
			IN	DWORD			cbToWrite,
			IN	DWORD			cbAvailable,
			IN	BYTE*			lpb,
			IN	HANDLE			hEvent,
			IN	BOOL			fFinal,
			IN	BOOL			fTerminatorIncluded
			)	{
/*++

Routine Description :

	This function will issue a Write against the user's FIO_CONTEXT
	and will complete it synchronously.

Arguments :

	pContext - the FIO_CONTEXT to issue the read against !
	cbToRead - Number of bytes to read !
	lpb - Pointer to the buffer where the data goes !
	hEvent - Event to use to complete IO's
	fFinal - TRUE if this is the last IO !

Return Vlaue :

	TRUE if successfull !

--*/

	FH_OVERLAPPED	ovl ;
	ZeroMemory( &ovl, sizeof( ovl ) ) ;

	ovl.Offset = ibOffset ;
	ovl.hEvent = (HANDLE)(((DWORD_PTR)hEvent) | 0x1) ;	// we want to get the completion here !

	if( FIOWriteFileEx(	pContext,
						lpb,
						cbToWrite,
						cbAvailable,
						&ovl,
						fFinal,
						fTerminatorIncluded
						)	)	{

		DWORD	cbTransfer = 0 ;
		if( GetOverlappedResult(	pContext->m_hFile,
									(LPOVERLAPPED)&ovl,
									&cbTransfer,
									TRUE ) )	{
			return	TRUE ;
		}
	}
	return	FALSE ;
}



FIO_CONTEXT*
ProduceDotStuffedContext(	IN	FIO_CONTEXT*	pContext,
							IN	LPSTR			lpstrName,
							IN	BOOL			fWantItDotStuffed
							)	{
/*++

Routine Description :

	This function will examine the provided FIO_CONTEXT and produce
	a FIO_CONTEXT that contains the necessary dot stuffing if the original
	doesn't suffice.

Arguments :

	pContext - the original FIO_CONTEXT
	lpstrName - the file name associated with the original context
	fWantItDotStuffed -

Return Value :

	Possibly the original FIO_CONTEXT with an additional reference
	or a New FIO_CONTEXT or NULL on failure !

--*/


	TraceFunctEnter( "ProduceDotStuffedContext" ) ;

	_ASSERT( pContext != 0 ) ;
	//_ASSERT( lpstrName != 0 ) ;

	FIO_CONTEXT*	pReturn = 0 ;
	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	//
	//	Okay lets see if the original Context is good enough !
	//
	if(	(fWantItDotStuffed &&
			(pCache->m_fStoredWithDots ||
			(!pCache->m_fStoredWithDots &&
			(pCache->m_fFileWasScanned && !pCache->m_fRequiresStuffing) ) )) ||
		(!fWantItDotStuffed &&
			(!pCache->m_fStoredWithDots ||
			(pCache->m_fStoredWithDots &&
			(pCache->m_fFileWasScanned && !pCache->m_fRequiresStuffing) ) ))
			)		{
		//
		//	Just duplicate the same FIO_CONTEXT !
		//
		AddRefContext( pContext ) ;
		return	pContext ;
	}	else	{
		//
		//	We need to produce a new FIO_CONTEXT !!!
		//
		//
		//	First get the temp directory !
		//
		char	szDirectory[MAX_PATH] ;
		char	szFileName[MAX_PATH] ;
		DWORD	cch = GetTempPath( sizeof( szDirectory ), szDirectory ) ;
		if( cch != 0 ) {

			DWORD	id = GetTempFileName(	szDirectory,
											"DST",
											0,
											szFileName
											) ;
			if( id != 0 ) {

				HANDLE	hFile = CreateFile(	szFileName,
											GENERIC_READ | GENERIC_WRITE,
											FILE_SHARE_READ,
											0,
											CREATE_ALWAYS,
											FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_SEQUENTIAL_SCAN,
											INVALID_HANDLE_VALUE
											) ;

				DWORD	dw = GetLastError() ;
				DebugTrace( DWORD(0), "GLE - %x", dw ) ;

				if( hFile != INVALID_HANDLE_VALUE ) {
					pReturn = AssociateFileEx(	hFile,
												fWantItDotStuffed,
												pCache->m_fStoredWithTerminatingDot
												) ;
					if( pReturn )	{
						//
						//	The file handle is now held by the context and should
						//	not be directly manipulated ever again !
						//
						hFile = INVALID_HANDLE_VALUE ;
						//
						//	We want to know if our temp copy has any changes !
						//
						BOOL	fModified = FALSE ;
						//
						//	Now - do the stuffing !
						//
						BOOL	fSuccess = ProduceDotStuffedContextInContext(
													pContext,
													pReturn,
													fWantItDotStuffed,
													&fModified
													)  ;
						//
						//	If there was a failure - release things !
						//
						if( !fSuccess )		{
							ReleaseContext( pReturn ) ;
							pReturn = 0 ;
						}	else	if( !fModified )	{
							//
							//	All that work for nothing !
							//
							ReleaseContext( pReturn ) ;
							AddRefContext( pContext ) ;
							pReturn = pContext ;
						}
					}
				} else {
                    ErrorTrace((LPARAM) NULL,
                        "Dotstuff CreateFile failed with %d for %s",
                        dw, szFileName);
                }
				//
				//	A failure might require us to release the handle !
				//
				if( hFile != INVALID_HANDLE_VALUE )
					_VERIFY (CloseHandle( hFile )) ;
			}
		}
	}
	return	pReturn ;
}



BOOL
ProduceDotStuffedContextInContext(
							IN	FIO_CONTEXT*	pContextSource,
							IN	FIO_CONTEXT*	pContextDestination,
							IN	BOOL			fWantItDotStuffed,
							OUT	BOOL*			pfModified
							)	{
/*++

Routine Description :

	This function will examine the provided FIO_CONTEXT and produce
	a FIO_CONTEXT that contains the necessary dot stuffing if the original
	doesn't suffice.

Arguments :

	pContextSource - the original FIO_CONTEXT
	pContextDestination - the destination FIO_CONTEXT !
	fWantItDotStuffed -

Return Value :

	Possibly the original FIO_CONTEXT with an additional reference
	or a New FIO_CONTEXT or NULL on failure !

--*/


	TraceFunctEnter( "ProduceDotStuffedContext" ) ;

	_ASSERT(	pContextSource ) ;
	_ASSERT(	pContextDestination ) ;

	//
	//	Check arguments !
	//
	if( pContextSource == 0 ||
		pContextDestination == 0 ||
		pfModified == 0 )	{
		SetLastError( ERROR_INVALID_PARAMETER ) ;
		return	FALSE ;
	}


#ifdef	DEBUG
	{
		FIO_CONTEXT_INTERNAL*	pSourceInternal = (FIO_CONTEXT_INTERNAL*)pContextSource ;

		_ASSERT( pSourceInternal->IsValid() ) ;
		_ASSERT( pSourceInternal->m_dwSignature != ILLEGAL_CONTEXT ) ;

		CFileCacheObject*	pSourceCache = CFileCacheObject::CacheObjectFromContext( pSourceInternal ) ;

		FIO_CONTEXT_INTERNAL*	pDestInternal = (FIO_CONTEXT_INTERNAL*)pContextDestination ;

		_ASSERT( pSourceInternal->IsValid() ) ;
		_ASSERT( pSourceInternal->m_dwSignature != ILLEGAL_CONTEXT ) ;

		CFileCacheObject*	pDestCache = CFileCacheObject::CacheObjectFromContext( pDestInternal ) ;

		_ASSERT( pDestCache->m_fStoredWithDots == fWantItDotStuffed ) ;
	}
#endif

	//
	//	First allocate the things we'll need !
	//
	//HANDLE	hEvent = GetPerThreadEvent() ;
	HANDLE	hEvent = CreateEvent( NULL, FALSE, FALSE, NULL ) ;
	if( hEvent == 0 )	{
		SetLastError( ERROR_OUTOFMEMORY ) ;
		return	FALSE ;
	}

	//
	//	Allocate the memory we use to do the copy !
	//
	DWORD	cbRead = 32 * 1024 ;
	DWORD	cbExtra = 1024 ;
	BYTE*	lpb = new	BYTE[cbRead+cbExtra] ;
	if( lpb == 0 )	{
		SetLastError( ERROR_OUTOFMEMORY ) ;
		if (hEvent) {
			_VERIFY( CloseHandle(hEvent) );
			hEvent = 0;
		}
		return FALSE	;
	}

	DWORD	cbSizeHigh = 0 ;
	DWORD	cbSize = GetFileSizeFromContext( pContextSource, &cbSizeHigh ) ;
	DWORD	ibOffset = 0 ;

	_ASSERT( cbSize != 0 ) ;

	//
	//	Now figure out what manipulations we should do to the destination !
	//
	BOOL	fSourceScanned ;
	BOOL	fSourceStuffed ;
	BOOL	fSourceStoredWithDots ;

	fSourceScanned =
	GetDotStuffState( pContextSource, FALSE, &fSourceStuffed, &fSourceStoredWithDots ) ;
	SetDotScanningOnReads( pContextSource, FALSE ) ;

	BOOL	fTerminatorIncluded = GetIsFileDotTerminated( pContextSource ) ;
	SetIsFileDotTerminated( pContextDestination, fTerminatorIncluded ) ;

	BOOL	fSuccess = TRUE ;

	if( fWantItDotStuffed )	{
		if( !fSourceStoredWithDots &&
			(!fSourceScanned || (fSourceScanned && fSourceStuffed) ) )		{

			fSuccess = SetDotStuffingOnWrites( pContextDestination, TRUE, FALSE ) ;

		}
	}	else	{
		if( fSourceStoredWithDots &&
			(!fSourceScanned || (fSourceScanned && fSourceStuffed) ) )	{

			fSuccess = SetDotStuffingOnWrites( pContextDestination, TRUE, TRUE ) ;
		}
	}
	//
	//  Now if everything has been good so far, go ahead and do the IO's !
	//
	if( fSuccess )	{
		do	{
			DWORD	cbToRead = min( cbSize, cbRead ) ;
			cbSize -= cbToRead ;

			fSuccess =
			ReadUtil(	pContextSource,
						ibOffset,
						cbToRead,
						lpb,
						hEvent,
						cbSize == 0
						) ;

			if( fSuccess )	{
				fSuccess =
					WriteUtil(	pContextDestination,
								ibOffset,
								cbToRead,
								cbRead + cbExtra,
								lpb,
								hEvent,
								cbSize == 0,
								fTerminatorIncluded
								) ;
			}
			ibOffset += cbToRead ;
		}	while( cbSize && fSuccess )	;
	}
	//
	//	Preserve the error codes !
	//
	DWORD	dw = GetLastError() ;

	if( fSuccess )	{
		BOOL	fModified = FALSE ;
		BOOL	fStoredWithDots = FALSE ;
		BOOL	fResult = GetDotStuffState( pContextDestination, FALSE, &fModified, &fStoredWithDots ) ;
		SetDotStuffingOnWrites( pContextDestination, FALSE, FALSE ) ;
		if( fResult && !fSourceScanned )	{
			SetDotStuffState( pContextSource, TRUE, fModified ) ;
		}
		if( pfModified )	{
			*pfModified = fModified ;
		}
	}
	//
	//	release our pre-allocated stuff !
	//
	delete [] lpb ;
	SetLastError( dw ) ;
	if (hEvent) {
		_VERIFY( CloseHandle(hEvent) );
		hEvent = 0;
	}
	return	fSuccess ;
}




FILEHC_EXPORT
BOOL
InsertFile(	IN	LPSTR	lpstrName,
			IN	FIO_CONTEXT*	pContext,
			IN	BOOL	fKeepReference
			)	{
/*++

Routine Description :

	This function creates a FIO_CONTEXT for the specified file.

Arguments :


Return Value :

	An FIO_CONTEXT that can be used for sync or async IO's

--*/

	TraceFunctEnter( "InsertFile" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;
	CFileCacheKey	keySearch(lpstrName) ;

	BOOL	fReturn = FALSE ;
	if( keySearch.FInit() ) {
		fReturn = pCache->InsertIntoCache( keySearch, fKeepReference ) ;
	}


	DebugTrace( (DWORD_PTR)pContext, "Insert %x %s pContext %x fKeep %x fReturn %x",
		lpstrName, lpstrName ? lpstrName : "NULL", pContext, fKeepReference, fReturn ) ;


	//
	//	Note keySearch's destructor takes care of memory we allocated !
	//
	return	fReturn;
}

FILEHC_EXPORT
DWORD
GetFileSizeFromContext(
			IN	FIO_CONTEXT*	pContext,
			OUT	DWORD*			pcbFileSizeHigh
			)	{
/*++

Routine Description :

	This function creates a FIO_CONTEXT for the specified file.

Arguments :


Return Value :

	An FIO_CONTEXT that can be used for sync or async IO's

--*/

	TraceFunctEnter( "GetFileSizeFromContext" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	return	pCache->GetFileSize( pcbFileSizeHigh ) ;
}

FILEHC_EXPORT
BOOL
GetIsFileDotTerminated(
			IN	FIO_CONTEXT*	pContext
			)	{
/*++

Routine Description :

	Tell the caller whether there is a terminating DOT in the file !

Arguments :

	pContext - the context we are to look at !

Return Value :

	TRUE if there is a terminating dot, FALSE otherwise !


--*/

	TraceFunctEnter( "GetIsFileDotTerminated" ) ;


	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	return	pCache->m_fStoredWithTerminatingDot ;
}


FILEHC_EXPORT
void
SetIsFileDotTerminated(
			IN	FIO_CONTEXT*	pContext,
			IN	BOOL			fIsTerminatedWithDot
			)	{
/*++

Routine Description :

	Tell the caller whether there is a terminating DOT in the file !

Arguments :

	pContext - the context we are to look at !

Return Value :

	TRUE if there is a terminating dot, FALSE otherwise !


--*/

	TraceFunctEnter( "GetIsFileDotTerminated" ) ;


	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	pCache->m_fStoredWithTerminatingDot = fIsTerminatedWithDot ;
}



FILEHC_EXPORT
BOOL
SetDotStuffingOnWrites(
			IN	FIO_CONTEXT*	pContext,
			IN	BOOL			fEnable,
			IN	BOOL			fStripDots
			)	{
/*++

Routine Description :

	This function modifies an FIO_CONTEXT to do dot stuffing on writes.
	We can turn on or off the dot stuffing properties.

Arguments :

	pContext - the FIO_CONTEXT that we want to modify !
	fEnable - if TRUE than we want to turn on some dot stuffing behaviours !
	fStripDots - if TRUE we want to remove Dots, FALSE means insert dots !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	TraceFunctEnter( "SetDotStuffingOnWrites" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	//
	//	Do some checking on whats going on here !
	//
	if( fEnable )	{
		if( pCache->m_fStoredWithDots ) {
			_ASSERT( !fStripDots ) ;
		}	else	{
			_ASSERT( fStripDots ) ;
		}
	}

	return	pCache->m_WriteStuffs.SetDotStuffing(	fEnable,
													fStripDots
													) ;
}

FILEHC_EXPORT
BOOL
SetDotScanningOnWrites(
				IN	FIO_CONTEXT*	pContext,
				IN	BOOL			fEnable
				)	{
/*++

Routine Description :

	This function modifies an FIO_CONTEXT to do dot stuffing on writes.
	We can turn on or off the dot stuffing properties.

Arguments :

	pContext - the FIO_CONTEXT that we want to modify !
	fEnable - if TRUE than we want to turn on some dot scanning behaviours !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	TraceFunctEnter( "SetDotScanningOnWrites" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	return	pCache->m_WriteStuffs.SetDotScanning(	fEnable	) ;
}

FILEHC_EXPORT
void
CompleteDotStuffingOnWrites(
				IN	FIO_CONTEXT*	pContext,
				IN	BOOL			fStripDots
				)	{

	TraceFunctEnter( "CompleteDotStuffingOnWrites" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	pCache->CompleteDotStuffing(	FALSE, fStripDots ) ;
}

FILEHC_EXPORT
BOOL
SetDotScanningOnReads(
				IN	FIO_CONTEXT*	pContext,
				IN	BOOL			fEnable
				)	{
/*++

Routine Description :

	This function modifies an FIO_CONTEXT to do dot stuffing on writes.
	We can turn on or off the dot stuffing properties.

Arguments :

	pContext - the FIO_CONTEXT that we want to modify !
	fEnable - if TRUE than we want to turn on some dot scanning behaviours !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	TraceFunctEnter( "SetDotScanningOnReads" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	return	pCache->m_ReadStuffs.SetDotScanning(	fEnable	) ;
}


FILEHC_EXPORT
BOOL
GetDotStuffState(	IN	FIO_CONTEXT*	pContext,
					IN	BOOL			fReads,
					OUT	BOOL*			pfStuffed,
					OUT	BOOL*			pfStoredWithDots
					)	{
/*++

Routine Description :

	This function gets the information from our DOT_STUFF_MANAGER
	objects as to whether we saw dots go into the streamed in file.

Arguments :

	pContext - the FIO_CONTEXT we want to examine
	fReads -   do we want to know the dot stuff state that resulted
		from reads or from writes - if TRUE then its reads
	pfStuffed - OUT parameter indicating whether

Return Value :


--*/

	TraceFunctEnter( "GetDotStuffState" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;
	_ASSERT( pfStuffed != 0 ) ;

	if( pfStuffed == 0 )	{
		SetLastError( ERROR_INVALID_PARAMETER ) ;
		return	FALSE;
	}

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	return	pCache->GetStuffState( fReads, *pfStuffed, *pfStoredWithDots ) ;
}


FILEHC_EXPORT
void
SetDotStuffState(	IN	FIO_CONTEXT*	pContext,
					IN	BOOL			fWasScanned,
					IN	BOOL			fRequiresStuffing
					)	{
/*++

Routine Description :

	This function gets the information from our DOT_STUFF_MANAGER
	objects as to whether we saw dots go into the streamed in file.

Arguments :

	pContext - the FIO_CONTEXT we want to examine
	fReads -   do we want to know the dot stuff state that resulted
		from reads or from writes - if TRUE then its reads
	pfStuffed - OUT parameter indicating whether

Return Value :


--*/

	TraceFunctEnter( "GetDotStuffState" ) ;

	_ASSERT( pContext != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;

	_ASSERT( p->IsValid() ) ;
	_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;

	CFileCacheObject*	pCache = CFileCacheObject::CacheObjectFromContext( p ) ;

	pCache->SetStuffState( fWasScanned, fRequiresStuffing ) ;
}



FILEHC_EXPORT
void
CacheRemoveFiles(	IN	LPSTR	lpstrName,
					IN	BOOL	fAllPrefixes
					)	{
/*++

Routine Description :

	This function kicks something out of the file handle cache.
	Depending on our arguments we may kick only one item - or many !

Arguments :

	lpstrName - the name of the item to kick out OR the prefix of all the files
		we are to kick out of the cache !
	fAllPrefixes - if the is TRUE then lpstrName is the prefix of a set of files
		that should be discarded, if FALSE lpstrName is the exact file name.

Return Value :

	None.

--*/

	_ASSERT( lpstrName != 0 ) ;
	_ASSERT( g_cIOInits != 0 ) ;

	if( lpstrName == 0 ) {
		SetLastError( ERROR_INVALID_PARAMETER ) ;
	}	else	{
		if( !fAllPrefixes )	{
			CFileCacheKey	key( lpstrName ) ;
			g_pFileCache->ExpungeKey(	&key ) ;
		}	else	{
			CFileCacheExpunge	expungeObject( lpstrName, lstrlen( lpstrName ) ) ;
			g_pFileCache->ExpungeItems( &expungeObject ) ;
		}
	}
}




BOOL
CFileCacheExpunge::fRemoveCacheItem(	CFileCacheKey*	pKey,
						CFileCacheObject*	pObject
						)	{
/*++

Routine Description :

	This function determines whether we want the item booted out of the cache.

Arguments :

	pKey - the key of the cache item !
	pObject - pointer to the file cache object !

Return Value :

	TRUE if it should be booted !


--*/

	_ASSERT( pKey != 0 ) ;

	return	strncmp(	pKey->m_lpstrPath, m_lpstrName, m_cbName ) == 0 ;
}






CFileCacheObject::CFileCacheObject(	BOOL	fStoredWithDots,
									BOOL	fStoredWithTerminatingDot
									) :
	m_dwSignature( CACHE_CONTEXT ),
	m_pCacheRefInterface( 0 ),
	m_cbFileSizeLow( 0 ),
	m_cbFileSizeHigh( 0 ),
	m_fFileWasScanned( FALSE ),
	m_fRequiresStuffing( FALSE ),
	m_fStoredWithDots( fStoredWithDots ),
	m_fStoredWithTerminatingDot( fStoredWithTerminatingDot )	{
/*++

Routine Description :

	Do minimal initialization of a CFileCacheObject -
	save work for later when the Cache can have better locking !

Arguments :

	fCached - whether we are being created in the cache or not !

Return Value :

	None/

--*/

}


#ifdef	DEBUG
CFileCacheObject::~CFileCacheObject()	{
/*++

Routine Description :

	Cleanup this object - not much to do, in debug builds we mark
	the signature so we can recognize deleted objects and more
	add some more powerfull _ASSERT's

Arguments :

	Noen.

Return Value :

	None.

--*/
	_ASSERT( m_dwSignature != DEL_CACHE_CONTEXT ) ;
	m_dwSignature = DEL_CACHE_CONTEXT ;
}
#endif

CFileCacheObject*
CFileCacheObject::CacheObjectFromContext(	PFIO_CONTEXT	p	) {
/*++

Routine Description :

	Given a client PFIO_CONTEXT get the starting address of
	the containing CFileCacheObject -

Arguments :

	p - clients PFIO_CONTEXT

Return Value :

	Pointer to containing CFileCacheObject - should never be NULL !

--*/

	_ASSERT( p ) ;
	CFileCacheObject*	pReturn = 0 ;
	if( p->m_dwSignature == ATQ_ENABLED_CONTEXT ) {
		pReturn = CONTAINING_RECORD( p, CFileCacheObject, m_AtqContext ) ;
	}	else	{
		pReturn = CONTAINING_RECORD( p, CFileCacheObject, m_Context ) ;
	}
	_ASSERT( pReturn->m_dwSignature == CACHE_CONTEXT ) ;
	return	pReturn ;
}

CFileCacheObject*
CFileCacheObject::CacheObjectFromContext(	FIO_CONTEXT_INTERNAL*	p	) {
/*++

Routine Description :

	Given a client PFIO_CONTEXT_INTERNAL get the starting address of
	the containing CFileCacheObject -

Arguments :

	p - clients PFIO_CONTEXT

Return Value :

	Pointer to containing CFileCacheObject - should never be NULL !

--*/


	_ASSERT( p ) ;
	CFileCacheObject*	pReturn = 0 ;
	if( p->m_dwSignature == ATQ_ENABLED_CONTEXT ) {
		pReturn = CONTAINING_RECORD( p, CFileCacheObject, m_AtqContext ) ;
	}	else	{
		pReturn = CONTAINING_RECORD( p, CFileCacheObject, m_Context ) ;
	}
	_ASSERT( pReturn->m_dwSignature == CACHE_CONTEXT ) ;
	return	pReturn ;
}


FIO_CONTEXT_INTERNAL*
CFileCacheObject::AsyncHandle(	HANDLE	hFile	)	{
/*++

Routine Description :

	Take the given handle and setup this CFileCacheObject
	to support async IO.

Arguments :

	hFile - users File Handle !

Return Value :

	pointer to the FIO_CONTEXT_INTERNAL if successfull,
	NULL otherwise !

--*/

	TraceFunctEnter( "CFileCacheObject::AsyncHandle" ) ;

	FIO_CONTEXT_INTERNAL*	pReturn = 0 ;
	DWORD dwError = 0;
	_ASSERT( m_Context.IsValid() ) ;
	_ASSERT( m_AtqContext.IsValid() ) ;

	if(	g_AtqAddAsyncHandle(	&m_AtqContext.m_pAtqContext,
							NULL,
							this,
							(ATQ_COMPLETION)Completion,
							INFINITE,
							hFile
							) )	{
		//
		//	Successfully added this ATQ !
		//
		m_AtqContext.m_dwSignature = ATQ_ENABLED_CONTEXT ;
		m_AtqContext.m_hFile = hFile ;
		pReturn = &m_AtqContext ;

		_ASSERT( m_AtqContext.m_pAtqContext != 0 ) ;
	} else {

		//
		//  Need to free the ATQ Context even if AtqAddAsyncHandle failed.
		//  See comment in atqmain.cxx
		//
		dwError = GetLastError();
		if (m_AtqContext.m_pAtqContext != NULL) {
		    //
		    // AtqFreeContext has a side-effect of closing the handle associated
		    // with it.  (It's possible that AtqAddAsyncHandle will return context
		    // even if it fails)  To keep this from happening, we yank the handle
		    // out of the context.
		    //
		    m_AtqContext.m_pAtqContext->hAsyncIO = NULL;
			//
			//  Free the context, but try to reuse this context
			//
			g_AtqFreeContext( m_AtqContext.m_pAtqContext, TRUE ) ;
			m_AtqContext.m_pAtqContext = NULL;
		}
	}

	DebugTrace( (DWORD_PTR)this, "hFile %x pReturn %x GLE %x", hFile, pReturn, dwError ) ;

	_ASSERT( m_Context.IsValid() ) ;
	_ASSERT( m_AtqContext.IsValid() ) ;
	_ASSERT( pReturn == 0 || pReturn->IsValid() ) ;

	return	pReturn ;
}


FIO_CONTEXT_INTERNAL*
CFileCacheObject::GetAsyncContext(
		class	CFileCacheKey&	key,
		class	CFileCacheConstructorBase&	constructor
		)	{
/*++

Routine Description :

	This function does the necessary work to produce
	an async context from the provided constructor !

Arguments :

	constructor - the guy who can make the file handle !

Return Value :

	The FIO_CONTEXT to use !

--*/

	TraceFunctEnter( "CFileCacheObject::GetAsyncContext" ) ;

	FIO_CONTEXT_INTERNAL*	pReturn = 0 ;
	m_lock.ShareLock() ;
	if(	m_AtqContext.m_hFile != INVALID_HANDLE_VALUE ) {
		pReturn = (FIO_CONTEXT_INTERNAL*)&m_AtqContext ;
		m_lock.ShareUnlock() ;

		DebugTrace( (DWORD_PTR)this, "ShareLock - pReturn %x", pReturn ) ;

		return	pReturn ;
	}

	if( !m_lock.SharedToExclusive() ) {

		m_lock.ShareUnlock() ;
		m_lock.ExclusiveLock() ;
		if( m_AtqContext.m_hFile != INVALID_HANDLE_VALUE ) {
			pReturn = (FIO_CONTEXT_INTERNAL*)&m_AtqContext ;
		}
	}

	DebugTrace( (DWORD_PTR)this, "Exclusive - pReturn %x", pReturn ) ;

	if( !pReturn ) {
		HANDLE	hFile = constructor.ProduceHandle(	key,
													m_cbFileSizeLow,
													m_cbFileSizeHigh
													) ;
		if( hFile != INVALID_HANDLE_VALUE ) {
			pReturn = AsyncHandle( hFile ) ;
			if( !pReturn ) {
				_VERIFY (CloseHandle( hFile )) ;
			}
		}
		DebugTrace( (DWORD_PTR)this, "Exclusive - pReturn %x hFile %x", pReturn, hFile ) ;
	}
	m_lock.ExclusiveUnlock() ;

	_ASSERT( pReturn==0 || pReturn->IsValid() ) ;

	return	pReturn ;
}

FIO_CONTEXT_INTERNAL*
CFileCacheObject::GetAsyncContext()	{
/*++

Routine Description :

	This function returns the ASYNC FIO_CONTEXT if it is available !


--*/
	TraceFunctEnter( "CFileCacheObject::GetAsyncContext" ) ;


	FIO_CONTEXT_INTERNAL*	pReturn = 0 ;
	m_lock.ShareLock() ;
	if(	m_AtqContext.m_hFile != INVALID_HANDLE_VALUE ) {
		pReturn = (FIO_CONTEXT_INTERNAL*)&m_AtqContext ;
		DebugTrace( (DWORD_PTR)this, "ShareLock - pReturn %x", pReturn ) ;
	}
	m_lock.ShareUnlock() ;
	return	pReturn ;
}




FIO_CONTEXT_INTERNAL*
CFileCacheObject::GetSyncContext(
		class	CFileCacheKey&	key,
		class	CFileCacheConstructorBase&	constructor
		)	{
/*++

Routine Description :

	This function does the necessary work to produce
	an async context from the provided constructor !

Arguments :

	constructor - the guy who can make the file handle !

Return Value :

	The FIO_CONTEXT to use !

--*/

	TraceFunctEnter( "CFileCacheObject::GetSyncContext" ) ;

	FIO_CONTEXT_INTERNAL*	pReturn = 0 ;
	m_lock.ShareLock() ;
	if(	m_Context.m_hFile != INVALID_HANDLE_VALUE ) {
		pReturn = (FIO_CONTEXT_INTERNAL*)&m_Context ;
		m_lock.ShareUnlock() ;

		DebugTrace( (DWORD_PTR)this, "ShareLock - pReturn %x", pReturn ) ;

		return	pReturn ;
	}

	if( !m_lock.SharedToExclusive() ) {

		m_lock.ShareUnlock() ;
		m_lock.ExclusiveLock() ;
		if( m_Context.m_hFile != INVALID_HANDLE_VALUE ) {
			pReturn = (FIO_CONTEXT_INTERNAL*)&m_Context ;
		}
	}

	DebugTrace( (DWORD_PTR)this, "Exclusive - pReturn %x", pReturn ) ;

	if( !pReturn ) {
		DWORD	cbFileSizeLow = 0 ;
		DWORD	cbFileSizeHigh = 0 ;
		HANDLE	hFile = constructor.ProduceHandle(	key,
													cbFileSizeLow,
													cbFileSizeHigh
													) ;
		if( hFile != INVALID_HANDLE_VALUE ) {

			_ASSERT( m_cbFileSizeLow == 0 || m_cbFileSizeLow == cbFileSizeLow ) ;
			_ASSERT( m_cbFileSizeHigh == 0 || m_cbFileSizeHigh == cbFileSizeHigh ) ;
			m_cbFileSizeLow = cbFileSizeLow ;
			m_cbFileSizeHigh = cbFileSizeHigh ;
			SyncHandle( hFile ) ;
			pReturn = (FIO_CONTEXT_INTERNAL*)&m_Context ;
		}
		DebugTrace( (DWORD_PTR)this, "Exclusive - pReturn %x hFile %x", pReturn, hFile ) ;
	}
	m_lock.ExclusiveUnlock() ;

	_ASSERT( pReturn==0 || pReturn->IsValid() ) ;

	return	pReturn ;
}


FIO_CONTEXT_INTERNAL*
CFileCacheObject::GetSyncContext()	{
/*++

Routine Description :

	This function returns the ASYNC FIO_CONTEXT if it is available !


--*/
	TraceFunctEnter( "CFileCacheObject::GetAsyncContext" ) ;


	FIO_CONTEXT_INTERNAL*	pReturn = 0 ;
	m_lock.ShareLock() ;
	if(	m_Context.m_hFile != INVALID_HANDLE_VALUE ) {
		pReturn = (FIO_CONTEXT_INTERNAL*)&m_Context ;
		DebugTrace( (DWORD_PTR)this, "ShareLock - pReturn %x", pReturn ) ;
	}
	m_lock.ShareUnlock() ;
	return	pReturn ;
}



void
CFileCacheObject::SyncHandle(	HANDLE	hFile ) {
/*++

Routine description :

	We have a file handle setup for synchronous IO -
	save it away into our context structures !

Arguments :

	hFile - The file handle

Return Value :

	None - we always succeed !

--*/

	TraceFunctEnter( "CFileCacheObject::SyncHandle" ) ;

	m_Context.m_dwSignature = FILE_CONTEXT ;
	m_Context.m_hFile = hFile ;


	DebugTrace( (DWORD_PTR)this, "m_hFile %x", m_Context.m_hFile ) ;

	_ASSERT( m_Context.IsValid() ) ;
	_ASSERT( m_AtqContext.IsValid() ) ;
}

void
CFileCacheObject::Return()	{
/*++

Routine Description :

	This function returns a CFileCacheObject to its origin.
	We may have been created stand-alone (outside the cache)
	so we have to determine which case occurred.

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CFileCacheObject::Return" ) ;

	m_lock.ShareLock() ;

	DebugTrace( (DWORD_PTR)this, "m_pCacheRefInterface %x m_cRefs %x", m_pCacheRefInterface, m_cRefs ) ;

	if( m_pCacheRefInterface == 0 ) {
    	LONG l = InterlockedDecrement(&m_cRefs);
		m_lock.ShareUnlock() ;
		_ASSERT(l >= 0);
		if( l==0 )
			delete	this ;
	}	else	{
		m_lock.ShareUnlock() ;
		g_pFileCache->CheckIn( this ) ;
	}
}

void
CFileCacheObject::Reference()	{
/*++

Routine Description :

	This function adds a client reference to the file cache obejct.
	Does so in a thread safe manner !

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CFileCacheObject::Reference" ) ;

	m_lock.ShareLock() ;

	DebugTrace( (DWORD_PTR)this, "m_pCacheRefInterface %x m_cRefs %x", m_pCacheRefInterface, m_cRefs ) ;

	if( m_pCacheRefInterface == 0 ) {
		AddRef() ;
	}	else	{
		g_pFileCache->CheckOut( this ) ;
	}
	m_lock.ShareUnlock() ;
}


void
CFileCacheObject::SetFileSize()	{
/*++

Routine Description :

	This function will reset our file size members based on
	the handle we are holding within ourselves !

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CFileCacheObject::SetFileSize" ) ;

	DebugTrace( (DWORD_PTR)this, "m_pCacheRefInterface %x", m_pCacheRefInterface ) ;

	if( m_Context.m_hFile != INVALID_HANDLE_VALUE ) {
		m_cbFileSizeLow = ::GetFileSize( m_Context.m_hFile, &m_cbFileSizeHigh ) ;
	}	else	{
		_ASSERT( m_AtqContext.m_hFile != INVALID_HANDLE_VALUE ) ;
		m_cbFileSizeLow = ::GetFileSize( m_AtqContext.m_hFile, &m_cbFileSizeHigh ) ;
	}
}



BOOL
CFileCacheObject::InsertIntoCache(
					CFileCacheKey&	keySearch,
					BOOL			fKeepReference
					)	{
/*++

Routine Description :

	This function inserts this item into the cache,
	ensuring that our reference count is correctly maintained !

Arguments :

	key - the name this item has in the cache
	fKeepReference - whether we want to keep the reference the client provided !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	BOOL	fReturn = FALSE ;
	m_lock.ExclusiveLock() ;

	SetFileSize() ;

	_ASSERT( m_pCacheRefInterface == 0 ) ;

	//
	//	Now insert the item into the cache !
	//
	if( m_AtqContext.m_pAtqContext->hAsyncIO != 0 )		{

		//
		//	Capture the dot stuffing state for all time !
		//
		m_fFileWasScanned = m_WriteStuffs.GetStuffState( m_fRequiresStuffing ) ;
		//
		//	Disable all additional Dot Stuffing !
		//
		m_WriteStuffs.SetDotStuffing( FALSE, FALSE ) ;
		//
		//	Manage the references on this guy carefully !
		//
		long	cClientRefs = m_cRefs ;
		if( !fKeepReference )
			cClientRefs -- ;

		_ASSERT( cClientRefs >= 0 ) ;
			fReturn = g_pFileCache->Insert(
											keySearch,
											this,
											cClientRefs
											) ;

		if( fReturn )	{
			m_cRefs = 1 ;
		}
	}
	m_lock.ExclusiveUnlock() ;
	return	fReturn ;
}



BOOL
CFileCacheObject::CompleteDotStuffing(
					BOOL			fReads,
					BOOL			fStripDots
					)	{
/*++

Routine Description :

	This function inserts this item into the cache,
	ensuring that our reference count is correctly maintained !

Arguments :

	key - the name this item has in the cache
	fKeepReference - whether we want to keep the reference the client provided !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	BOOL	fReturn = FALSE ;
	m_lock.ExclusiveLock() ;
	//
	//	Now insert the item into the cache !
	//
	if( m_AtqContext.m_pAtqContext->hAsyncIO != 0 )		{

		//
		//	Capture the dot stuffing state for all time !
		//
		if( fReads )	{
			m_fFileWasScanned = m_ReadStuffs.GetStuffState( m_fRequiresStuffing ) ;
			//
			//	Disable all additional Dot Stuffing !
			//
			m_ReadStuffs.SetDotStuffing( FALSE, FALSE ) ;
		}	else	{
			m_fFileWasScanned = m_WriteStuffs.GetStuffState( m_fRequiresStuffing ) ;
			if( !fStripDots )	{
				m_fRequiresStuffing = !m_fRequiresStuffing ;
			}
			//
			//	Disable all additional Dot Stuffing !
			//
			m_WriteStuffs.SetDotStuffing( FALSE, FALSE ) ;
		}
	}
	m_lock.ExclusiveUnlock() ;
	return	fReturn ;
}


BOOL
CFileCacheObject::CloseNonCachedFile(	)	{
/*++

Routine Description :

	This function closes the file handle within out ATQ context
	member !

Arguments :

	key - the name this item has in the cache
	fKeepReference - whether we want to keep the reference the client provided !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	BOOL	fReturn = FALSE ;
	m_lock.ShareLock() ;
	if( m_pCacheRefInterface == 0 &&
		m_AtqContext.m_hFile != INVALID_HANDLE_VALUE )	{
		fReturn = g_AtqCloseFileHandle( m_AtqContext.m_pAtqContext ) ;
	}
	m_lock.ShareUnlock() ;
	return	fReturn ;
}

BOOL
CFileCacheObject::GetStuffState(	BOOL	fReads,
									BOOL&	fRequiresStuffing,
									BOOL&	fStoredWithDots
									)	{
/*++

Routine Description :

	This function returns what we know about the dot stuffing state of the file !

Arguments :

	fReads - if the file has not been put in the cache then we want to get
		the dot stuffing state as computed by any reads we issued !
	fRequiresStuffing - OUT parameter which gets whether the message requires stuffing !

Return Value :

	TRUE if we know the dot stuff state, FALSE otherwise !

--*/

	BOOL	fReturn = FALSE ;
	m_lock.ShareLock() ;
	fStoredWithDots = m_fStoredWithDots ;
	if( m_pCacheRefInterface == 0 )	{
		fReturn = (fReads ? m_ReadStuffs.GetStuffState( fRequiresStuffing ) :
							m_WriteStuffs.GetStuffState( fRequiresStuffing )) ;
		if( !fReturn && m_fFileWasScanned ) {
			fReturn = m_fFileWasScanned ;
			fRequiresStuffing = m_fRequiresStuffing ;
		}
	}	else	{
		fRequiresStuffing = m_fRequiresStuffing ;
		fReturn = m_fFileWasScanned ;
	}
	m_lock.ShareUnlock() ;
	return	fReturn ;
}

void
CFileCacheObject::SetStuffState(	BOOL	fWasScanned,
									BOOL	fRequiresStuffing
									)	{
/*++

Routine Description :

	This routine sets the dot stuffing state !

Arguments :

	fReads - if the file has not been put in the cache then we want to get
		the dot stuffing state as computed by any reads we issued !
	fRequiresStuffing - OUT parameter which gets whether the message requires stuffing !

Return Value :

	TRUE if we know the dot stuff state, FALSE otherwise !

--*/

	m_lock.ExclusiveLock() ;
	m_fFileWasScanned = fWasScanned ;
	m_fRequiresStuffing = fRequiresStuffing ;
	m_lock.ExclusiveUnlock() ;
}


BOOL
CFileCacheObject::Init(	CFileCacheKey&	key,
						class	CFileCacheConstructorBase&	constructor,
						void*	pv
						)	{
/*++

Routine Description :

	Initialize a CFileCacheObject for use in the cache !
	Turns around and calls the constuctor - because there are different
	types of them, and they have appropriate virtual functions !

Arguments :

	key - Key used to create us in the cache
	constructor - constructor object that is building us
	pv -

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	TraceFunctEnter( "CFileCacheObject::Init" ) ;

	BOOL	fReturn = FALSE ;

	DebugTrace( (DWORD_PTR)this, "key %x constructor %x pv %x m_fAsync %x",
		&key, &constructor, pv, constructor.m_fAsync ) ;

	if( constructor.m_fAsync ) {
		fReturn = GetAsyncContext( key, constructor ) != 0 ;
	}	else	{
		fReturn = GetSyncContext( key, constructor ) != 0 ;
	}
	if( fReturn ) {
		constructor.PostInit( *this, key, pv ) ;
	}

	DebugTrace( (DWORD_PTR)this, "Init - fReturn %x", fReturn ) ;

	return	fReturn ;
}

void
CFileCacheObject::Completion(
					CFileCacheObject*	pObject,
					DWORD	cbTransferred,
					DWORD	dwStatus,
					FH_OVERLAPPED*	pOverlapped
					)	{

	TraceFunctEnter( "CFileCacheObject::Completion" ) ;

	_ASSERT( pObject != 0 ) ;
	_ASSERT( pObject->m_AtqContext.IsValid() ) ;
	_ASSERT( pObject->m_AtqContext.m_dwSignature == ATQ_ENABLED_CONTEXT ) ;
	_ASSERT( pOverlapped->pfnCompletion != 0 ) ;

	DebugTrace( (DWORD_PTR)pObject, "Complete - pObject %x cb %x dw %x pOvl %x pfn %x",
		pObject, cbTransferred, dwStatus, pOverlapped, pOverlapped->pfnCompletion ) ;

	//
	//	Before doing anything with this - give a chance to our dot manipulation
	//	code to handle this !
	//


	//
	//	Call their completion function !
	//
	pOverlapped->pfnCompletion( (PFIO_CONTEXT)&pObject->m_AtqContext,
								pOverlapped,
								cbTransferred,
								dwStatus
								) ;
}


CFileCacheConstructor::CFileCacheConstructor(
		LPVOID	lpv,
		FCACHE_CREATE_CALLBACK	pCreate,
		BOOL	fAsync
		) :
	CFileCacheConstructorBase( fAsync ),
	m_lpv( lpv ),
	m_pCreate( pCreate )	{
/*++

Routine Description :

	This function sets up a File Cache Constructor object -
	we capture the arguments that are going to be used if
	the cache decides the item isn't found and wants to use us !

Arguments :

	lpv - Arg to pass to callback function
	pCreate - the function which can create a handle
	fAsync - TRUE if we want to do Async IO on the handle

Return Value :

	None.

--*/
}


CFileCacheObject*
CFileCacheConstructorBase::Create(
				CFileCacheKey&	key,
				void*	pv
				)	{
/*++

Routine Description :

	This function creates allocates mem for and
	does initial construction of CFileCacheObject's

Arguments :

	key - contains name of the file
	pv -

Return Value :

	Pointer to a newly allocated CFileCacheObject

--*/
	return	new	CFileCacheObject(FALSE,FALSE) ;
}


void
CFileCacheConstructorBase::Release(
				CFileCacheObject*	p,
				void*	pv
				)	{
/*++

Routine Description :

	This function releases a CFileCacheObject !

Arguments :

	p - the object ot be released !
	pv -

Return Value :

	Nothing !

--*/

	p->Release() ;
}

void
CFileCacheConstructorBase::StaticRelease(
				CFileCacheObject*	p,
				void*	pv
				)	{
/*++

Routine Description :

	This function releases a CFileCacheObject !

Arguments :

	p - the object ot be released !
	pv -

Return Value :

	Nothing !

--*/
	p->Release() ;
}


CRichFileCacheConstructor::CRichFileCacheConstructor(
		LPVOID	lpv,
		FCACHE_RICHCREATE_CALLBACK	pCreate,
		BOOL	fAsync
		) :
	CFileCacheConstructorBase( fAsync ),
	m_lpv( lpv ),
	m_fStoredWithDots( FALSE ),
	m_fStoredWithTerminatingDot( FALSE ),
	m_pCreate( pCreate )	{
/*++

Routine Description :

	This function sets up a File Cache Constructor object -
	we capture the arguments that are going to be used if
	the cache decides the item isn't found and wants to use us !

Arguments :

	lpv - Arg to pass to callback function
	pCreate - the function which can create a handle
	fAsync - TRUE if we want to do Async IO on the handle

Return Value :

	None.

--*/
}




HANDLE
CRichFileCacheConstructor::ProduceHandle(
										CFileCacheKey&	key,
										DWORD&	cbFileSizeLow,
										DWORD&	cbFileSizeHigh
										)	{
/*++

Routine Description :

	This function initializes a CFileCacheObject.
	This function is virtual, and this is one of the several
	ways that CFileCacheObjects can be setup.

Arguments :

	object - the CFileCacheObject we are to initialize
	key - the filename key used to create ue
	pv - Extra args

Return Value :

	TRUE if we successfully initialize !

--*/

	TraceFunctEnter( "CRichFileCacheConstructor::ProduceHandle" ) ;

	_ASSERT( cbFileSizeLow == 0 ) ;
	_ASSERT( cbFileSizeHigh == 0 ) ;

	BOOL	fReturn = FALSE ;

	//
	//	We have work to do to create the file !
	//

	HANDLE	h = m_pCreate(	key.m_lpstrPath,
							m_lpv,
							&cbFileSizeLow,
							&cbFileSizeHigh,
							&m_fFileWasScanned,
							&m_fRequiresStuffing,
							&m_fStoredWithDots,
							&m_fStoredWithTerminatingDot
							) ;

	DebugTrace( (DWORD_PTR)this, "h %x lpstrPath %x m_lpv %x cbFilesize %x",
		h, key.m_lpstrPath, m_lpv, cbFileSizeLow ) ;

	return	h ;
}


BOOL
CRichFileCacheConstructor::PostInit(
					CFileCacheObject&	object,
					CFileCacheKey&		key,
					void*	pv
					)	{

	object.m_fFileWasScanned = m_fFileWasScanned ;
	object.m_fRequiresStuffing = m_fRequiresStuffing ;
	object.m_fStoredWithDots = m_fStoredWithDots ;
	object.m_fStoredWithTerminatingDot = m_fStoredWithTerminatingDot ;

	return	TRUE ;
}





HANDLE
CFileCacheConstructor::ProduceHandle(	CFileCacheKey&	key,
										DWORD&	cbFileSizeLow,
										DWORD&	cbFileSizeHigh
										)	{
/*++

Routine Description :

	This function initializes a CFileCacheObject.
	This function is virtual, and this is one of the several
	ways that CFileCacheObjects can be setup.

Arguments :

	object - the CFileCacheObject we are to initialize
	key - the filename key used to create ue
	pv - Extra args

Return Value :

	TRUE if we successfully initialize !

--*/

	TraceFunctEnter( "CFileCacheConstructor::ProduceHandle" ) ;

	//_ASSERT( cbFileSizeLow == 0 ) ;
	//_ASSERT( cbFileSizeHigh == 0 ) ;

	BOOL	fReturn = FALSE ;

	//
	//	We have work to do to create the file !
	//

	HANDLE	h = m_pCreate(	key.m_lpstrPath,
							m_lpv,
							&cbFileSizeLow,
							&cbFileSizeHigh
							) ;

	DebugTrace( (DWORD_PTR)this, "h %x lpstrPath %x m_lpv %x cbFilesize %x",
		h, key.m_lpstrPath, m_lpv, cbFileSizeLow ) ;

	return	h ;
}


BOOL
CFileCacheConstructor::PostInit(
					CFileCacheObject&	object,
					CFileCacheKey&		key,
					void*	pv
					)	{
	return	TRUE ;
}

#if 0
BOOL
CFileCacheConstructor::Init(
					CFileCacheObject&	object,
					CFileCacheKey&		key,
					void*	pv
					)	{
/*++

Routine Description :

	This function initializes a CFileCacheObject.
	This function is virtual, and this is one of the several
	ways that CFileCacheObjects can be setup.

Arguments :

	object - the CFileCacheObject we are to initialize
	key - the filename key used to create ue
	pv - Extra args

Return Value :

	TRUE if we successfully initialize !

--*/

	DWORD	cbFileSize = 0 ;
	BOOL	fReturn = FALSE ;

	object.m_Lock.ExclusiveLock() ;

	if( (m_fAsync &&
		object.m_AtqContext.m_hFile == INVALID_HANDLE_VALUE)	||
		(!m_fAsync &&
		object.m_Context.m_hFile == INVALID_HANDLE_VALUE) )	{

		//
		//	We have work to do to create the file !
		//

		HANDLE	h = m_pCreate(	key.m_lpstrPath,
								m_lpv,
								&cbFileSize
								) ;

		if( h != INVALID_HANDLE_VALUE ) {

			_ASSERT( cbFileSize != 0 ) ;

			if( m_fAsync ) {
				if( object.AsyncHandle( h ) != 0 ) {
					fReturn = TRUE ;
				}	else	{
					CloseHandle( h ) ;
				}
			}	else	{
				fReturn = TRUE ;
				object.SyncHandle( h ) ;
			}
		}
	}
	object.m_Lock.ExclusiveUnlock() ;
	return	fReturn ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\fcache2\dotstuff\dotstuff.cpp ===
/*++

	DotStuff.cpp

	This file contains the definitions of classes that can be used to define
	Dot Stuffing operations and modifications through FILE IO.



--*/


#include	<windows.h>
#include    "xmemwrpr.h"
#include	"dbgtrace.h"
#include	"filehc.h"
#include	"dotstuff.h"


//
//	Define the sequence of characters we look for in dot stuffing situations
//
BYTE	szDot[] = "\r\n.\r\n" ;
BYTE	szDotStuffed[] = "\r\n." ;
BYTE	szShrink[] = "\r\n" ;
BYTE	szGrow[] = "\r\n.." ;



BOOL	
CDotScanner::InternalProcessBuffer(	
					BYTE*	lpb,			// The users original buffer
					DWORD	cbIn,			// Number of bytes to look at in orignal buffer
					DWORD	cbAvailable,	// Number of bytes available in the original buffer
					DWORD	&cbRemains,		// Number of bytes we left in the original Buffer - can be zero
					BYTE*	&lpbOut,		// An output buffer that holds a portion of the string !
					DWORD	&cbOut,			// The amount of stuff in our output buffer
					int		&cBias			// Whether we should offset associated IO's to overwrite
											// previous results !
					)	{

/*++

Routine Description :

	This function examines all the bytes in the incoming buffer
	and determines whether we will have a dot stuffing issue with
	this buffer.

Arguments :

	lpb - the buffer containing the text we are examining.
	cbIn - the number of bytes to examine in the buffer
	cbAvailable - total space we can touch in the buffer !
	cbRemains - The number of bytes that are in the buffer when we're done !
	lpbOut -

Return Value :

	Number of bytes the caller should use - always the same as cbIn !

--*/

	//
	//	Validate our arguments !
	//
	_ASSERT( lpb != 0 ) ;
	_ASSERT( cbIn != 0 ) ;
	_ASSERT( cbAvailable >= cbIn ) ;
	_ASSERT( cbRemains == 0 ) ;
	_ASSERT( lpbOut == 0 ) ;
	_ASSERT( cbOut == 0 ) ;
	_ASSERT( cBias == 0 ) ;

	//
	//	We treat the buffer read-only and leave the buffer
	//	exactly as we found it !
	//
	cbRemains = cbIn ;
	//
	//	Attempt to match the inbound string !
	//
	BYTE*	lpbMax = lpb + cbIn ;

	while( lpb < lpbMax )	{
		if( *lpb == *m_pchState )	{
			m_pchState++ ;
			if( *m_pchState == '\0' ) {
				m_cOccurrences ++ ;
				m_pchState = m_pchMatch ;
			}
		}	else	{
			m_pchState = m_pchMatch ;
			if( *lpb == *m_pchState )
				m_pchState++ ;
		}
		lpb++ ;
	}
	
	return	TRUE ;
}


BOOL
CDotModifier::InternalProcessBuffer(	
				BYTE*	lpb,
				DWORD	cbIn,
				DWORD	cbAvailable,
				DWORD	&cbRemains,
				BYTE*	&lpbOut,
				DWORD	&cbOut,
				int		&cBias
				)	{
/*++

Routine Description :

	This function exists to munge buffers - converting occurrences
	of one string within the buffer to another, specified when
	our object was constructed.  Amongst our challenges - we get
	called repeatedly with only portions of the users buffer provided
	which means that we may recognize a pattern after most of it has
	passed us by.  This is why we have cBias as an out parameter -
	it allows us to tell the caller to overwrite a portion of his
	last data.

Arguments :

	lpb - The buffer to be scanner
	cbIn - Number of scannable bytes in the buffer
	cbAvailable - The amount of space we can mess with in the buffer,
		hopefully this is larger than cbIn !
	cbRemains - where we return the number of bytes we left in the
		users buffer
	lpbOut - An optional out buffer that we may return to the caller -
		this occurs if cbAvailable is so small that we cannot do all
		the manipulations we'd like to do in place !
	cbOut - Return the number of usefull bytes in lpbOut
	cBias - if we figure out that a prior buffer we've examined
		contains a portion of the pattern to be replaced, this is
		the offset we should add to a file offset to cause the
		correct overwriting to occur !

Return Value ;

	TRUE if successfull FALSE otherwise -
	Note we can only fail if we need to allocate memory and fail to do so !


--*/
	cbRemains = 0 ;
	lpbOut = 0 ;
	cbOut = 0 ;
	cBias = 0 ;

	//
	//	Validate our arguments !
	//
	_ASSERT( lpb != 0 ) ;
	//_ASSERT( cbIn != 0 ) ;	Actually - we can be called with this set to 0 in a recursive case !
	//							it's okay - we handle it correctly !
	_ASSERT( cbAvailable >= cbIn ) ;
	_ASSERT( cbRemains == 0 ) ;
	_ASSERT( lpbOut == 0 ) ;
	_ASSERT( cbOut == 0 ) ;
	_ASSERT( cBias == 0 ) ;

	//
	//	Attempt to match the inbound string !
	//
	BYTE*	lpbOriginal = lpb ;
	BYTE*	lpbMax = lpb + cbIn ;
	BYTE*	lpbMaxAvail = lpb + cbAvailable ;

	//
	//	Basic Pattern matching loop, that replaces one string with another !
	//
	while( lpb < lpbMax )	{

		//
		//	invariants for our loop !
		//
		_ASSERT( lpb >= lpbOriginal ) ;
		_ASSERT( lpbMax >= lpb ) ;
		_ASSERT( lpbMaxAvail >= lpbMax ) ;

		if( *lpb == *m_pchState )	{
			lpb++ ;
			//
			//	NOTE : lpb Now bytes to the BYTE following the matched sequence !
			//
			m_pchState++ ;
			if( *m_pchState == '\0' ) {
				//
				//	Reset the matching state stuff !
				//
				m_pchState = m_pchMatch ;
				//
				//	Count the number of times we've matched the pattern !
				//
				m_cOccurrences ++ ;
				//
				//	First figure out where we want to write the replacement pattern -
				//	Because we keep getting passed buffers, we need to deal with the case
				//	where a large hunk of the matching pattern passed through on a previous
				//	call, and we want to rewrite a portion of the file !
				//
				BYTE*	lpbOverwrite = lpb - m_cchMatch ;
				if( lpbOverwrite < lpbOriginal )	{
					cBias = (int)(lpbOverwrite - lpbOriginal) ;
					_ASSERT( cBias < 0 ) ;
					lpbOverwrite = lpbOriginal ;
				}
				//
				//	cBias always computes out to a negative or zero number - we want
				//	to add its absolute value to lpbTemp, so we take advantage of the
				//	fact that we know it is negative !
				//
				_ASSERT( cBias <= 0 ) ;
				BYTE*	lpbTemp = lpbMax + m_cDiff - cBias ;
				if(	lpbTemp <= lpbMaxAvail )	{
					//
					//	Move all the bytes around cause of the Pattern Match !
					//
					MoveMemory( lpb + m_cDiff - cBias, lpb, lpbMax - lpb ) ;
					//
					//	Put the replacement pattern into place !
					//
					CopyMemory( lpbOverwrite, m_pchReplace, m_cchMatch+m_cDiff ) ;
					//
					//	Now adjust where the buffer terminates and continue !
					//
					lpbMax += m_cDiff - cBias ;
					lpb += m_cDiff - cBias ;
				}	else	{
					//
					//	Get a buffer to hold the overflow ! - First do some arithmetic to figure
					//	out how much memory we should allocate, that would guarantee that we can
					//	hold everything that results.
					//
					DWORD	cDiff = ((m_cDiff < 0) ? -m_cDiff : m_cDiff) ;
					DWORD	cbRequired = (((DWORD)(lpbMax - lpb + 1 + m_cchMatch) * (m_cchMatch + cDiff)) / m_cchMatch) + 1 - cBias;

					//
					//	Now allocate the buffer - Note that we add an arbitrary 10 characters so the caller can always
					//	append a CRLF.CRLF sequence !
					//
					lpbTemp = new	BYTE[cbRequired+10] ;
					if( !lpbTemp )	{
						SetLastError( ERROR_OUTOFMEMORY ) ;
						return	FALSE ;
					}	else	{

						BYTE*	lpbFront = lpbTemp + m_cDiff + m_cchMatch ;
						//
						//	NOW - Move all the bytes EXCLUDING the MATCHED bytes into the new buffer,
						//	BUT leave space for the for the matched pattern !
						//
						MoveMemory( lpbFront, lpb, lpbMax - lpb ) ;
						//
						//	NOW - Zap the bytes into the destination
						//
						CopyMemory( lpbTemp, m_pchReplace, m_cchMatch+m_cDiff ) ;
						//
						//	Now - recursively invoke ourselves to finish the job - because we allocated a big
						//	enough buffer we should not recurse again !
						//
						BYTE*	lpbRecurseOut = 0 ;
						DWORD	cbRecurseOut = 0 ;
						int		cRecurseBias = 0 ;
						lpbOut = lpbTemp ;							
						BOOL	fResult =
							InternalProcessBuffer(	
											lpbFront,
											(DWORD)(lpbMax - lpb),
											cbRequired - m_cDiff - m_cchMatch,
											cbOut,
											lpbRecurseOut,
											cbRecurseOut,
											cRecurseBias
											) ;
						cbOut += m_cDiff + m_cchMatch ;
						_ASSERT( fResult ) ;
						_ASSERT( cRecurseBias == 0 ) ;
						_ASSERT( lpbRecurseOut == 0 ) ;
						_ASSERT( cbRecurseOut == 0 ) ;
						//
						//	Well we're all done - return the correct results to the caller !
						//
						cbRemains = (DWORD)(lpbOverwrite - lpbOriginal) ;
						return	TRUE ;
					}
				}

			}
		}	else	{
			m_pchState = m_pchMatch ;
			if( *lpb == *m_pchState )
				m_pchState++ ;
			lpb++ ;
		}
	}

	_ASSERT( lpbMax >= lpbOriginal ) ;
	_ASSERT( cBias <= 0 ) ;

	//
	//	Let the caller know how much usable stuff remains
	//	in his buffer - could be nothing !
	//
	cbRemains = (DWORD)(lpbMax - lpbOriginal) ;
	return	TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\fcache2\dll\namecach.cpp ===
/*++

	NAMECACH.CPP

	This file implements the Name Cache functionality that is 
	part of the file handle cache.


--*/

#pragma	warning( disable : 4786 )
#include	"fcachimp.h"

BOOL
CCacheKey::IsValid()	{
/*++

Routine Description : 

	Determine whether the CCacheKey has been correctly constructed !

Arguments : 

	None.

Return Value : 

	TRUE if correctly constructed, FALSE otherwise 

--*/

	_ASSERT(	m_lpstrName != 0 ) ;
	_ASSERT(	*m_lpstrName != '\0' ) ;
	_ASSERT(	m_pfnCompare != 0 ) ;

	return	m_lpstrName != 0 &&
			*m_lpstrName != '\0' && 
			m_pfnCompare != 0 ;
}

int
CCacheKey::MatchKey(	CCacheKey*	pKeyLeft, 
						CCacheKey*	pKeyRight
						)	{
/*++

Routine description : 

	Compare 2 CacheKey's, and return -1 if pKeyLeft < pKeyRight, 
	0 if pKeyLeft==pKeyRight and 1 if pKeyLeft > pKeyRight.

Arguments : 

	pKeyLeft, pKeyRight the two keys to order

Return Value : 

	integer with memcmp() semantics.

--*/

	_ASSERT( pKeyLeft != 0 && pKeyRight != 0 ) ;
	_ASSERT( pKeyLeft->IsValid() ) ;
	_ASSERT( pKeyRight->IsValid() ) ;

	LONG_PTR	i = lstrcmp(	pKeyLeft->m_lpstrName, pKeyRight->m_lpstrName ) ;
	if( i==0 ) {
		i = (LONG_PTR)(pKeyLeft->m_pfnCompare) - (LONG_PTR)(pKeyRight->m_pfnCompare) ;
		if( i==0 ) {
			i = (LONG_PTR)(pKeyLeft->m_pfnHash) - (LONG_PTR)(pKeyRight->m_pfnHash) ;
			if( i==0 ) {
				i = (LONG_PTR)(pKeyLeft->m_pfnKeyDestroy) - (LONG_PTR)(pKeyRight->m_pfnKeyDestroy) ;
				if( i==0 ) {
					i = (LONG_PTR)(pKeyLeft->m_pfnDataDestroy) - (LONG_PTR)(pKeyRight->m_pfnDataDestroy) ;
				}
			}
		}
	}
	return	int(i) ;
}

DWORD
CCacheKey::HashKey(	CCacheKey*	pKey )	{
/*++

Routine Description : 

	This function computes a hash function for this item - we just 
	use our standard string hash function !

Arguments : 

	pKey - The key to compute the hash function of

Return Value : 

	The Hash Value !

--*/

	_ASSERT( pKey != 0 ) ;
	_ASSERT( pKey->IsValid() ) ;

	return	CRCHash(	(LPBYTE)pKey->m_lpstrName, lstrlen(pKey->m_lpstrName) ) ;
}

//--------
//	These two globals keep track of all the Name Cache Instance's created by clients
//
//	Protect a hash table of Name Cache's 
//
CShareLockNH	g_NameLock ;
//
//	A hash table of Name Cache's 
//
NAMECACHETABLE*	g_pNameTable = 0 ;
//
//	The global table of Security Descriptors !
//
CSDMultiContainer*	g_pSDContainer = 0 ;
//-------

BOOL
InitNameCacheManager()	{

	TraceFunctEnter( "InitNameCacheManager" ) ;

	_ASSERT( g_pNameTable == 0 ) ;
	_ASSERT( g_pSDContainer == 0 ) ;

	g_pNameTable = new	NAMECACHETABLE() ;
	if( !g_pNameTable ) {
		return	FALSE ;
	}

	g_pSDContainer = new	CSDMultiContainer() ;
	if( !g_pSDContainer ) {
		delete	g_pNameTable ;
		g_pNameTable = 0 ;
		return	FALSE ;
	}

	BOOL	fSuccess = 
		g_pNameTable->Init(	8, 
							4, 
							2, 
							CCacheKey::HashKey, 
							CNameCacheInstance::GetKey, 
							CCacheKey::MatchKey
							) ;

	if( fSuccess ) {
		fSuccess = g_pSDContainer->Init() ;
	}	
	if( !fSuccess ) {
		_ASSERT( g_pNameTable != 0 ) ;
		_ASSERT( g_pSDContainer != 0 ) ;
		delete	g_pNameTable ;
		delete	g_pSDContainer ;
		g_pNameTable = 0 ;
		g_pSDContainer = 0 ;
		_ASSERT( g_pNameTable == 0 ) ;
		_ASSERT( g_pSDContainer == 0 ) ;
	}	else	{
		_ASSERT( g_pNameTable != 0 ) ;
		_ASSERT( g_pSDContainer != 0 ) ;
	}
	return	fSuccess ;
}

void
TermNameCacheManager()	{

	TraceFunctEnter( "TermNameCacheManager" ) ;

	if( g_pNameTable ) {
		delete	g_pNameTable ;
	}
	if(	g_pSDContainer )	{
		delete	g_pSDContainer ;
	}
	g_pNameTable = 0 ;
	g_pSDContainer = 0 ;
}


CNameCacheInstance::CNameCacheInstance(	CCacheKey	&key ) : 
	m_key(key), 
	m_cRefCount( 2 ), m_pDud( 0 ), m_pfnAccessCheck( 0 )
	{
/*++

Routine Description : 

	This function initializes a name cache instance - assume client starts with 
	one reference, and the containing hash table contains one reference.

Arguments : 

	None.

Return Value : 

	None.

--*/
	m_dwSignature = SIGNATURE ;	
}

static	char	szNull[] = "\0" ;

CNameCacheInstance::~CNameCacheInstance()	{
/*++

Routine Description : 

	Destroy everything associated with this name cache - 
	NOTE ! - embedded key does not free strings within its destructor !
	Call FreeName() to do so here !

Arguments : 

	None.

Return Value : 

	None.


--*/

	TraceFunctEnter( "CNameCacheInstance::~CNameCacheInstance" ) ;

	if( m_pDud ) {
		m_pDud->Return() ;
		m_pDud = 0 ;
		//
		//	Remove the DUD Key from the cache ASAP !
		//
		DWORD	dwHashName = m_key.m_pfnHash( (LPBYTE)szNull, sizeof( szNull ) - 1 ) ;

		CNameCacheKeySearch	keySearch(	(LPBYTE)szNull, 
										sizeof(szNull)-1, 
										dwHashName, 
										0, 
										0, 
										FALSE
										) ;

		DebugTrace( DWORD_PTR(&keySearch), "Created Search Key" ) ;

		//
		//	Now attempt to remove the key !
		//
		BOOL	fSuccess = 
			m_namecache.ExpungeKey(	&keySearch	) ;	

	}

	m_key.FreeName() ;
	m_dwSignature = DEAD_SIGNATURE ;
}

BOOL
CNameCacheInstance::IsValid()	{
/*++

Routine Description : 

	This function checks that we are in a valid state.
	
Arguments : 

	None.

Return Value : 

	TRUE if we are valid !

--*/

	_ASSERT(	m_dwSignature == SIGNATURE ) ;
	_ASSERT(	m_pDud != 0 ) ;

	return	m_dwSignature == SIGNATURE && 
			m_pDud != 0 ;
}

long
CNameCacheInstance::AddRef()	{
/*++

Routine Description : 

	Add a reference to a Name Cache Instance.

Arguments : 

	None.

Return Value : 

	The resulting ref count, should always be greater than 0 !

--*/
	_ASSERT( IsValid() ) ;
	long l = InterlockedIncrement(	(long*)&m_cRefCount ) ;
	_ASSERT( l > 0 ) ;
	return	 l ;
}

long
CNameCacheInstance::Release()	{
/*++

Routine Description : 

	This function removes a reference form a Name Cache Instance object.

	If the reference count drops to one, that means that the only reference
	remaining on the object is the one from the hash table.
	So we grab the hash table lock exclusively, so we can prevent new references
	from being added, and we then do a InterlockedCompareExchange to drop 
	the reference count to 0.  We need to do this to ensure that between
	the time we decrement the ref. count and the time we grab the lock, that 
	another user doesn't simultaneously raise and drop the ref. count.
	This prevents double frees.

Arguments : 

	None.

Return Value : 

	the final ref count - 0 if the object is destroyed !

--*/
	TraceFunctEnter( "CNameCacheInstance::Release" ) ;

	DebugTrace( DWORD_PTR(this), "Dropping reference to Name Cache" ) ;

	CNameCacheInstance*	pdelete = 0 ;
	long	l = InterlockedDecrement( (long*)&m_cRefCount ) ;
	if( l==1 ) {
		g_NameLock.ExclusiveLock( ) ;
		if( InterlockedCompareExchange( (long*)&m_cRefCount, 0, 1 ) == 1 ) {
			g_pNameTable->Delete( this ) ;
			pdelete = this ;
		}
		g_NameLock.ExclusiveUnlock() ;
	}
	if( pdelete ) {
		l = 0 ;
		delete	pdelete ;
	}
	return	l ;
}

BOOL
CNameCacheInstance::fInit()	{
/*++

Routine Description : 

	This function initializes the name cache.

Arguments : 

	None.

Return Value : 

	None.

--*/

	TraceFunctEnter( "CNameCacheInstance::fInit" ) ;

	BOOL	fInit = 
	m_namecache.Init(	CNameCacheKey::NameCacheHash,
						CNameCacheKey::MatchKey,
						g_dwLifetime, // One hour expiration !
						g_cMaxHandles,  // large number of handles !
						g_cSubCaches,	// Should be plenty of parallelism
						0		 // No statistics for now !
						) ;

	if( fInit ) {
		m_pDud = new CFileCacheObject( FALSE, FALSE ) ;
		if (!m_pDud) {
		    fInit = FALSE;
		    _ASSERT(fInit);         // Out of memory
		}
	}

	if( fInit ) {
		PTRCSDOBJ	ptrcsd ;
		DWORD	dwHash = m_key.m_pfnHash( (LPBYTE)szNull, sizeof(szNull)-1 ) ;

		//
		//	Insert the dud element with an artificial name into the name cache !
		//
		CNameCacheKeyInsert	keyDud(	(LPBYTE)szNull, 
									sizeof(szNull)-1,
									0, 
									0,  
									dwHash,
									&m_key, 
									ptrcsd, 
									fInit 
									) ;
		_ASSERT( fInit ) ;

		fInit = 
		m_namecache.Insert(	dwHash, 
							keyDud, 		
							m_pDud,
							1
							) ;

		if( !fInit ) {
			delete	m_pDud ;
			m_pDud = 0 ;
		}
	}

	DebugTrace( DWORD_PTR(this), "Initialized Name Cache - %x", fInit ) ;
	return	fInit ;
}
	

FILEHC_EXPORT
PNAME_CACHE_CONTEXT	
FindOrCreateNameCache(
		//
		//	Must not be NULL ! - this is CASE SENSITVE !
		//
		LPSTR	lpstrName, 
		//
		//	Must not be NULL !
		//
		CACHE_KEY_COMPARE		pfnKeyCompare, 
		//
		//	This may be NULL, in which case the cache will provide one !
		//
		CACHE_KEY_HASH			pfnKeyHash, 
		//
		//	The following two function pointers may be NULL !
		//
		CACHE_DESTROY_CALLBACK	pfnKeyDestroy, 
		CACHE_DESTROY_CALLBACK	pfnDataDestroy
		)	{
/*++

Routine Description : 

	This function finds an existing Name Cache or creates a new one.
	If we find an existing Name Cache we add a reference to it.

	NOTE : 

	References MUST be ADDED only when the lock is held.
	This must be done so that synchronization with CNameCacheInstance::Release()
	is done correctly !

Arguments : 

	lpstrName - User provided Name for the name cache
	pfnKeyCompare - compares keys within the name cache
	pfnKeyDestroy - called when a key is destroyed within the name cache !
	pfnDataDestroy - called when data within the name cache is destroyed !

Return Value : 

	Context for a Name Cache.
	NULL if failed !

--*/

	TraceFunctEnter( "FindOrCreateNameCache" ) ;

	_ASSERT( lpstrName != 0 ) ;
	_ASSERT( *lpstrName != '\0' ) ;
	_ASSERT( pfnKeyCompare != 0 ) ;

	if( pfnKeyHash == 0 ) {
		pfnKeyHash = (CACHE_KEY_HASH)CRCHash ;
	}

	//
	//	Build a key and look for it in the hash table !
	//	
	CCacheKey	key(	lpstrName, 
						pfnKeyCompare, 
						pfnKeyHash,
						pfnKeyDestroy, 
						pfnDataDestroy
						) ;
	DWORD	dwHash = CCacheKey::HashKey(&key) ;
	CNameCacheInstance*	pInstance = 0 ;
	g_NameLock.ShareLock() ;
	NAMECACHETABLE::ITER	iter = g_pNameTable->SearchKeyHashIter(	dwHash, 
																	&key, 	
																	pInstance
																	) ;
	if( pInstance ) {
		//
		//	We found it - AddRef before releasing locks !
		//
		_ASSERT( pInstance->IsValid() ) ;
		pInstance->AddRef() ;
		g_NameLock.ShareUnlock() ;
	}	else	{
		//
		//	Convert to a partial lock while we construct a new item - 
		//	NOTE - we may have to search again !
		//
		if( !g_NameLock.SharedToPartial() ) {
			g_NameLock.ShareUnlock() ;
			g_NameLock.PartialLock() ;
			iter = g_pNameTable->SearchKeyHashIter(	dwHash,		
													&key, 
													pInstance
													) ;
		}
		if( pInstance != 0 ) {
			//
			//	found it - AddRef before releasing locks !
			//
			_ASSERT( pInstance->IsValid() ) ;
			pInstance->AddRef() ;
		}	else	{
			//
			//	Copy users strings for new item in the table !
			//
			LPSTR	lpstr = new	char[lstrlen(lpstrName)+1] ;
			if( lpstr ) {
				lstrcpy( lpstr, lpstrName ) ;
				CCacheKey	key2(	lpstr, 
									pfnKeyCompare,
									pfnKeyHash, 
									pfnKeyDestroy, 
									pfnDataDestroy
									) ;
				_ASSERT( CCacheKey::HashKey(&key2) == dwHash ) ;
				pInstance = new CNameCacheInstance(	key2 ) ;
				if( !pInstance ) {
					//
					//	failure clean up !
					//
					delete[]	lpstr ;
				}	else	{
					BOOL	fInsert = FALSE ;
					if( pInstance->fInit() ) {
						_ASSERT( pInstance->IsValid() ) ;
						//
						//	Everything's ready to go - insert into hash table !
						//
						g_NameLock.FirstPartialToExclusive() ;
						fInsert = 
							g_pNameTable->InsertDataHashIter(	iter, 
																dwHash, 
																&key2, 
																pInstance 
																) ;
						g_NameLock.ExclusiveUnlock() ;
					}	else	{
						g_NameLock.PartialUnlock() ;
					}

					//
					//	check if we have to clean up an error case !
					//
					if( !fInsert ) {
						pInstance->Release() ;
						pInstance = 0 ;
					}
					//
					//	return to caller now, skip PartialUnlock() which 
					//	was taken care of by the conversion to Exclusive above !
					//
					DebugTrace( DWORD_PTR(pInstance), "Returning Name Cache To Caller" ) ;

					return	pInstance ;
				}
			}
		}
		g_NameLock.PartialUnlock() ;
	}
	DebugTrace(DWORD(0), "Failed to find or create Name Cache" );
	return	pInstance ;
}


FILEHC_EXPORT
BOOL	__stdcall
SetNameCacheSecurityFunction(
		//
		//	Must not be NULL !
		//
		PNAME_CACHE_CONTEXT		pNameCache, 
		//
		//	This is the function pointer that will be used to evaluate security - 
		//	this may be NULL - if it is we will use the Win32 Access Check !
		//
		CACHE_ACCESS_CHECK		pfnAccessCheck
		)	{
/*++

Routine Description : 

	This function will set the function pointer used for evaluating Security Descriptors found in the
	name cache.

Arguments : 

	pNameCache - Pointer to the Name Cache who's properties we are to set !
	pfnAccessCheck - pointer to a function which can perform the AccessCheck() call !

Return Value : 

	TRUE if successfull !

--*/

	TraceFunctEnter( "SetNameCacheSecurityFunction" ) ;

	CNameCacheInstance*	pInstance = (CNameCacheInstance*)pNameCache ;
	if( !pInstance ) 
		return	FALSE ;

	pInstance->m_pfnAccessCheck = pfnAccessCheck ;
	return	TRUE ;	
}


//
//	API's for releasing the NAME CACHE !
//
//	The caller must guarantee the thread safety of this call - This function must not 
//	be called if any other thread is simultanesouly executing within 
//	CacheFindContectFromName(), AssociateContextWithName(), AssociateDataWithName(), or InvalidateName() 
//
FILEHC_EXPORT
long	__stdcall
ReleaseNameCache(
		//
		//	Must not be NULL !
		//
		PNAME_CACHE_CONTEXT		pNameCache
		)	{
/*++

Routine Description : 

	This function releases the NameCache Object associated with the 
	client's PNAME_CACHE_CONTEXT !

Arguments : 

	pNameCache - A context previously provided to the client through
		FindOrCreateNameCache !

Return Value : 

	Resulting Reference Count - 0 means the NAME CACHE has been destroyed !

--*/

	TraceFunctEnter( "ReleaseNameCache" ) ;

	_ASSERT( pNameCache != 0 ) ;

	CNameCacheInstance*	pInstance = (CNameCacheInstance*)pNameCache ;
	
	_ASSERT( pInstance->IsValid() ) ;
	return	pInstance->Release() ;
}

//
//	Find the FIO_CONTEXT that is associated with some user name.
//
//	The function returns TRUE if the Name was found in the cache.
//	FALSE if the name was not found in the cache.
//	
//	If the function returns FALSE then the pfnCallback function will not be 
//	called.
//
//	If the function returns TRUE, ppFIOContext may return a NULL pointer
//	if the user has only called AssociateDataWithName().
//
//
FILEHC_EXPORT
BOOL	__stdcall
FindContextFromName(
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for Key to the cache item - pfnKeyCompare() used 
					//	to compare keys !
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName, 
					//
					//	User provides function which is called with the key once the key comparison
					//	matches the key.  This lets the user do some extra checking that they're getting 
					//	what they want.
					//
					IN	CACHE_READ_CALLBACK	pfnCallback,
					IN	LPVOID	lpvClientContext,
					//
					//	Ask the cache to evaluate the embedded security descriptor
					//	if hToken is 0 then we ignore and security descriptor data 
					//
					IN	HANDLE		hToken,
					IN	ACCESS_MASK	accessMask,
					//
					//	We have a separate mechanism for returning the FIO_CONTEXT
					//	from the cache.
					//
					OUT	FIO_CONTEXT**	ppContext
					)	{
/*++

Routine Description : 

	This function attempts to find the FIO_CONTEXT for a specified name !

Arguments : 

	See Above

Return Value : 
	
	TRUE if something was found matching in the case - 
		*ppContext may still be NULL however !
	
--*/

	TraceFunctEnter( "FindContextFromName" ) ;

	CNameCacheInstance*	pInstance = (CNameCacheInstance*)pNameCache ;

	_ASSERT( pInstance->IsValid() ) ;

	BOOL	fFound = FALSE ;

	//	
	//	Verify other arguments !
	//
	_ASSERT( lpbName != 0 ) ;
	_ASSERT( cbName != 0 ) ;

	DWORD	dwHashName = pInstance->m_key.m_pfnHash( lpbName, cbName ) ;

	CNameCacheKeySearch	keySearch(	lpbName, 
									cbName, 
									dwHashName, 
									lpvClientContext, 
									pfnCallback, 
									hToken != NULL
									) ;

	DebugTrace( DWORD_PTR(&keySearch), "Created Search Key" ) ;

	//
	//	Now do the search !
	//
	CFileCacheObject*	p 	= 
		pInstance->m_namecache.Find(	dwHashName, 
										keySearch
										) ;	

	DebugTrace( DWORD_PTR(p), "found instance item %x, m_pDud %x", p, pInstance->m_pDud ) ;
	
	if( p ) {						
		BOOL	fAccessGranted = TRUE ;
		if( hToken != NULL )	{
			fAccessGranted = 
				keySearch.DelegateAccessCheck(	hToken, 
												accessMask, 
												pInstance->m_pfnAccessCheck
												) ;
		}
		if( fAccessGranted )	{
			keySearch.PostWork() ;
			fFound = TRUE ;
		}	else	{
			SetLastError( ERROR_ACCESS_DENIED ) ;
		}

		if( p != pInstance->m_pDud ) {
			PFIO_CONTEXT pFIO = (FIO_CONTEXT*)p->GetAsyncContext() ;
			if( pFIO == 0 ) {
				p->Return() ;
				SetLastError(	ERROR_NOT_SUPPORTED ) ;
			}
			*ppContext = pFIO ;
		}	else	{
			//
			//	Need to drop the dud reference !
			//
			p->Return() ;
		}
	}	else	{
		SetLastError(	ERROR_PATH_NOT_FOUND ) ;
	} 
	DebugTrace( DWORD_PTR(p), "Returning %x GLE %x", fFound, GetLastError() ) ;
	return	fFound ;
}



//
//	Find the FIO_CONTEXT that is associated with some user name.
//
//	The function returns TRUE if the Name was found in the cache.
//	FALSE if the name was not found in the cache.
//	
//	If the function returns FALSE then the pfnCallback function will not be 
//	called.
//
//	If the function returns TRUE, ppFIOContext may return a NULL pointer
//	if the user has only called AssociateDataWithName().
//
//
FILEHC_EXPORT
BOOL	__stdcall
FindSyncContextFromName(
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for Key to the cache item - pfnKeyCompare() used 
					//	to compare keys !
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName, 
					//
					//	User provides function which is called with the key once the key comparison
					//	matches the key.  This lets the user do some extra checking that they're getting 
					//	what they want.
					//
					IN	CACHE_READ_CALLBACK	pfnCallback,
					IN	LPVOID	lpvClientContext,
					//
					//	Ask the cache to evaluate the embedded security descriptor
					//	if hToken is 0 then we ignore and security descriptor data 
					//
					IN	HANDLE		hToken,
					IN	ACCESS_MASK	accessMask,
					//
					//	We have a separate mechanism for returning the FIO_CONTEXT
					//	from the cache.
					//
					OUT	FIO_CONTEXT**	ppContext
					)	{
/*++

Routine Description : 

	This function attempts to find the FIO_CONTEXT for a specified name !

Arguments : 

	See Above

Return Value : 
	
	TRUE if something was found matching in the case - 
		*ppContext may still be NULL however !
	
--*/

	TraceFunctEnter( "FindContextFromName" ) ;

	CNameCacheInstance*	pInstance = (CNameCacheInstance*)pNameCache ;

	_ASSERT( pInstance->IsValid() ) ;

	BOOL	fFound = FALSE ;

	//	
	//	Verify other arguments !
	//
	_ASSERT( lpbName != 0 ) ;
	_ASSERT( cbName != 0 ) ;

	DWORD	dwHashName = pInstance->m_key.m_pfnHash( lpbName, cbName ) ;

	CNameCacheKeySearch	keySearch(	lpbName, 
									cbName, 
									dwHashName, 
									lpvClientContext, 
									pfnCallback, 
									hToken != NULL
									) ;

	DebugTrace( DWORD_PTR(&keySearch), "Created Search Key" ) ;

	//
	//	Now do the search !
	//
	CFileCacheObject*	p 	= 
		pInstance->m_namecache.Find(	dwHashName, 
										keySearch
										) ;	

	DebugTrace( DWORD_PTR(p), "found instance item %x, m_pDud %x", p, pInstance->m_pDud ) ;
	
	if( p ) {						
		BOOL	fAccessGranted = TRUE ;
		if( hToken != NULL )	{
			fAccessGranted = 
				keySearch.DelegateAccessCheck(	hToken, 
												accessMask,
												pInstance->m_pfnAccessCheck
												) ;
		}
		if( fAccessGranted )	{
			keySearch.PostWork() ;
			fFound = TRUE ;
		}	else	{
			SetLastError( ERROR_ACCESS_DENIED ) ;
		}

		if( p != pInstance->m_pDud ) {
			PFIO_CONTEXT pFIO = (FIO_CONTEXT*)p->GetSyncContext() ;
			if( pFIO == 0 ) {
				p->Return() ;
				SetLastError(	ERROR_NOT_SUPPORTED ) ;
			}
			*ppContext = pFIO ;
		}	else	{
			//
			//	Need to drop the dud reference !
			//
			p->Return() ;
		}
	}	else	{
		SetLastError(	ERROR_PATH_NOT_FOUND ) ;
	} 
	DebugTrace( DWORD_PTR(p), "Returning %x GLE %x", fFound, GetLastError() ) ;
	return	fFound ;
}


//
//	Cache Associate context with name !
//	This insert a Name into the Name cache, that will find the specified FIO_CONTEXT !
//
FILEHC_EXPORT
BOOL	__stdcall
AssociateContextWithName(	
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for the Name of the cache item.
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName, 
					//
					//	User may provide some arbitrary data to assoicate with the name !
					//	
					IN	LPBYTE	lpbData, 
					IN	DWORD	cbData, 
					//
					//	User may provide a self relative security descriptor to 
					//	be associated with the name !
					//
					IN	PGENERIC_MAPPING		pGenericMapping,
					IN	PSECURITY_DESCRIPTOR	pSecurityDescriptor,
					//
					//	User provides the FIO_CONTEXT that the name should reference
					//
					FIO_CONTEXT*		pContext,
					//
					//	User specifies whether they wish to keep their reference on the FIO_CONTEXT
					//
					BOOL				fKeepReference
					)	{
/*++

Routine Description : 

	This function inserts an item into the name cache !

Arguments : 

Return Value : 

	TRUE if successfully inserted, FALSE otherwise
	if FALSE is returned the FIO_CONTEXT's reference count is unchanged, 
		no matter what fKeepReference was passed as !	


--*/

	TraceFunctEnter( "AssociateContextWithName" ) ;

	_ASSERT(	pNameCache != 0 ) ;
	_ASSERT(	lpbName != 0 ) ;
	_ASSERT(	cbName != 0 ) ;
	_ASSERT(	*lpbName != '\0' ) ;
	
	CNameCacheInstance*	pInstance = (CNameCacheInstance*)pNameCache ;
	_ASSERT( pInstance->IsValid() ) ;

	CFileCacheObject*	pCache = 0 ;
	if( pContext != 0 ) {
		FIO_CONTEXT_INTERNAL*	p = (FIO_CONTEXT_INTERNAL*)pContext ;
		_ASSERT( p->IsValid() ) ;
		_ASSERT( p->m_dwSignature != ILLEGAL_CONTEXT ) ;
		pCache = CFileCacheObject::CacheObjectFromContext( p ) ;
	}	else	{
		_ASSERT( !fKeepReference ) ;
		pCache = pInstance->m_pDud ;
		fKeepReference = TRUE ;
	}

	_ASSERT( pCache != 0 ) ;

	DebugTrace( DWORD_PTR(pSecurityDescriptor), "Doing SD Search, pCache %x pDud %x fKeep %x", 
		pCache, pInstance->m_pDud, fKeepReference ) ;

	PTRCSDOBJ	pCSD ; 
	//
	//	First, get a hold of a SD if appropriate !
	//
	if(	pSecurityDescriptor != 0 ) {
		_ASSERT(	pGenericMapping != 0 ) ;
		pCSD = g_pSDContainer->FindOrCreate(	pGenericMapping, 
												pSecurityDescriptor 
												) ;
		//
		//	Failed to hold the security descriptor - fail out to the caller !
		//
		if( pCSD == 0 ) {
			SetLastError(	ERROR_OUTOFMEMORY ) ;
			return	FALSE ;
		}	
	}

	DebugTrace( DWORD(0), "Found SD %x", pCSD ) ;

	//
	//	Now build the key and insert into the name cache !
	//
	BOOL	fSuccess = FALSE ;

	DWORD	dwHashName = pInstance->m_key.m_pfnHash( lpbName, cbName ) ;

	DebugTrace( 0, "Computed Hash Value %x", dwHashName ) ;

	CNameCacheKeyInsert	key(	lpbName, 
								cbName, 
								lpbData, 
								cbData, 
								dwHashName, 
								&pInstance->m_key, 
								pCSD, 
								fSuccess
								) ;

	if( !fSuccess ) {
		SetLastError( ERROR_OUTOFMEMORY ) ;
		return	FALSE ;
	}					

	fSuccess = 
	pInstance->m_namecache.Insert(	dwHashName, 
									key, 		
									pCache
									) ;


	DebugTrace( 0, "Insert Completed with %x", fSuccess ) ;

	if( fSuccess ) {
		if( !fKeepReference ) {
			pCache->Return() ;
		}
	}	else	{
		SetLastError(	ERROR_DUP_NAME ) ;
	}
	return	fSuccess ;
}

//
//	This function breaks the association that any names may have with the specified FIO_CONTEXT, 
//	and discards all data related to the specified names from the Name cache.
//
FILEHC_EXPORT
BOOL	
InvalidateAllNames(	FIO_CONTEXT*	pContext ) ;

//
//	This function allows the user to remove a single name and all associated data
//	from the name cache.
//
FILEHC_EXPORT
BOOL
InvalidateName(	
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for the Name of the cache item.
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName
					)	{
/*++

Routine Description : 

	This function removes the specified name and its associations from the cache !

Arguments : 

	pNameCache - the Name cache in which this operation applies
	lpbName - the Name of the item we are to remove
	cbName - the length of the name we are to remove 

Return Value : 

	TRUE if successfully removed from the cache 
	FALSE otherwise !

--*/



	TraceFunctEnter( "InvalidateName" ) ;

	CNameCacheInstance*	pInstance = (CNameCacheInstance*)pNameCache ;

	_ASSERT( pInstance->IsValid() ) ;

	BOOL	fFound = FALSE ;

	//	
	//	Verify other arguments !
	//
	_ASSERT( lpbName != 0 ) ;
	_ASSERT( cbName != 0 ) ;

	DWORD	dwHashName = pInstance->m_key.m_pfnHash( lpbName, cbName ) ;

	CNameCacheKeySearch	keySearch(	lpbName, 
									cbName, 
									dwHashName, 
									0, 
									0, 
									FALSE
									) ;

	DebugTrace( DWORD_PTR(&keySearch), "Created Search Key" ) ;

	//
	//	Now attempt to remove the key !
	//
	BOOL	fSuccess = 
		pInstance->m_namecache.ExpungeKey(	&keySearch	) ;	

	return	fSuccess ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\fcache2\sdcache\sdcache.cpp ===
/*++

	SDCACHE.CPP

	This file implements the security descriptor cache.
	Our goal is to enable the file handle cache to consume less memory
	representing security descriptors, by enabling duplicate 
	security descriptors to be detected and referenced in here.

--*/

#include	<windows.h>
#include	<dbgtrace.h>
#include	"fdlhash.h"
#include	"rwnew.h"
#include	"refptr2.h"
#include	"xmemwrpr.h"
#include	"sdcache.h"
//#include	"cintrnl.h"


BOOL
IsSelfRelativeSecurityDescriptor(	PSECURITY_DESCRIPTOR	pSecDesc ) {
	SECURITY_DESCRIPTOR_CONTROL	control ;
	DWORD	dwRevision ;
	if (GetSecurityDescriptorControl( pSecDesc, &control, &dwRevision ))
		return	(control & SE_SELF_RELATIVE) != 0;
	else
		return FALSE;
}



BOOL
CSDKey::IsValid()	{
/*++

Routine Description : 

	This function validates that the key object is correctly constructed.
	We do NOT allow any NULL pointers, and we must have valid self relative
	security descriptors embedded.

Arguments : 

	NONE.

Return Value : 

	TRUE if correctly initialized, FALSE otherwise 

--*/

	_ASSERT( m_pMapping != 0 ) ;
	_ASSERT( m_pSecDesc != 0 ) ;
	_ASSERT( IsValidSecurityDescriptor( m_pSecDesc ) ) ;
	_ASSERT( IsSelfRelativeSecurityDescriptor( m_pSecDesc ) ) ;
	_ASSERT( m_cbSecDesc > 0 ) ;
	_ASSERT( (DWORD)m_cbSecDesc == GetSecurityDescriptorLength( m_pSecDesc ) ) ;

	return	m_pMapping != 0 &&
			m_pSecDesc != 0 &&
			IsValidSecurityDescriptor( m_pSecDesc ) &&
			IsSelfRelativeSecurityDescriptor( m_pSecDesc ) &&
			m_cbSecDesc > 0 && 
			(DWORD)m_cbSecDesc == GetSecurityDescriptorLength( m_pSecDesc ) ;
}

int	
CSDKey::MatchKey(	CSDKey left, 
					CSDKey	right 
					) {
/*++

Routine Description : 

	This function must compare 2 security descriptor keys, 
	and correctly define an ordering on the keys.
	(The hash table we're used in sorts buckets).

Arguments : 

	left, right - the two keys to be compared 
	
Return Value : 

	-1 if left < right
	0  if left == right
	1  if left > right 

--*/

	//
	//	Validate our arguments !
	//
	_ASSERT( left.IsValid() ) ;
	_ASSERT( right.IsValid() ) ;
	//
	//	perform the comparison !
	//
	int	iResult = memcmp( left.m_pMapping, right.m_pMapping, sizeof(GENERIC_MAPPING));
	if( iResult != 0 ) {
		iResult = left.m_cbSecDesc - right.m_cbSecDesc ;
		if( iResult == 0 ) {
			iResult = memcmp( left.m_pSecDesc, right.m_pSecDesc, left.m_cbSecDesc ) ;
		}
	}
	return	iResult ;
}

DWORD
CSDKey::HashKey(	CSDKey	Key ) {
/*++

Routine Description : 

	This function computes a hash on security descriptors.
	We ignore the GENERIC_MAPPING part of the key - this 
	will vary very rarely.
	We're a static function so we can be passed as a function 
	pointer.
	We simply look at the security descriptor as an array of DWORD's
	and sum them up.

Arguments : 

	Key - compute the hash of this security descriptor	

Return Value : 

	A Hash Value - no failure cases can occur

--*/


	//
	//	Very simple - sum all of the bits in the security descriptor !
	//
	_ASSERT( Key.IsValid() ) ;

	DWORD	cb = (DWORD)Key.m_cbSecDesc ;
	cb /= 4 ;

	DWORD*	pdw = (DWORD*)Key.m_pSecDesc ;
	DWORD*	pdwEnd = pdw + cb ;
	DWORD	Sum = 0 ;
	while( pdw != pdwEnd )	{
		Sum += *pdw++ ;
	}
	return	Sum ;
}



void*
CSDObject::operator	new(	size_t	size,	
							CSDKey&	key 
							)	{
/*++

Routine Description : 

	This function allocates memory of a CSDObject, 
	we require special handle because CSDObjects are variable length.

Arguments : 

	size - the size as generated by the compiler
	key -  the security descriptor we're going to stick in here

Return Value : 

	Allocated memory - NULL if failure 

--*/


	_ASSERT( size >= sizeof(CSDObject) ) ;
	_ASSERT( key.IsValid() ) ;

	size += key.m_cbSecDesc - sizeof( DWORD ) ;

	return	::new	BYTE[size] ;
} 


void
CSDObject::operator delete(	void*	lpv ) {
/*++

Routine Description : 

	Release a CSDObject !

Arguments : 
	
	lpv - where the CSDObject was before it was destructed

Return Value : 

	None.

--*/

	::delete(lpv) ;
}


long
CSDObject::Release()	{
/*++

Routine Description : 

	This function drops a reference to a CSDObject.
	WARNING - we will grab locks on the CSDObjectContainer 
	that is holding this item, the last reference MUST NEVER
	BE RELEASED WITHIN A LOCK !

	If the reference count drops to one, that means that the only reference
	remaining on the object is the one from the hash table.
	So we grab the hash table lock exclusively, so we can prevent new references
	from being added, and we then do a InterlockedCompareExchange to drop 
	the reference count to 0.  We need to do this to ensure that between
	the time we decrement the ref. count and the time we grab the lock, that 
	another user doesn't simultaneously raise and drop the ref. count.

Arguments : 

	None.

Return Value : 

	the resulting refcount.

--*/
	_ASSERT( IsValid() ) ;
	CSDObject*	pdelete = 0 ;
	long l = InterlockedDecrement( (long*)&m_cRefCount ) ;
	_ASSERT( l>=1 ) ;
	if( l == 1 ) {
		m_pContainer->m_lock.ExclusiveLock() ;		
		if( InterlockedCompareExchange( (long*)&m_cRefCount, 0, 1) == 1 ) {
			m_pContainer->m_table.Delete( this ) ;
			pdelete = this ;
		}
		m_pContainer->m_lock.ExclusiveUnlock() ;
	}
	if( pdelete )	{
		delete	pdelete ;
		l = 0 ;
	}
	return	l ;
}


//
//	Check that we are a valid object !
//
BOOL
CSDObject::IsValid()	{
/*++

Routine Description : 

	This function checks that we were properly constructed - 
	if allocation of our memory succeeds, nothing should stand
	in the way of producing a completely initialized object !

Arguments : 

	None.

Return Value : 

	TRUE if correctly constructed, FALSE otherwise !

--*/
	_ASSERT( m_dwSignature == SIGNATURE ) ;
	_ASSERT( m_pContainer != 0 ) ;
	_ASSERT( m_cRefCount >= 0 ) ;

	CSDKey	key( &m_mapping, SecurityDescriptor() ) ;
	_ASSERT( key.IsValid() ) ;
	_ASSERT( CSDKey::HashKey( key ) == m_dwHash ) ;

	return	m_dwSignature == SIGNATURE &&
			m_pContainer != 0 && 
			m_cRefCount >= 0 &&
			key.IsValid() &&
			CSDKey::HashKey( key ) == m_dwHash ;
}

BOOL
CSDObject::AccessCheck(	HANDLE	hToken, 
						ACCESS_MASK	accessMask,
						CACHE_ACCESS_CHECK	pfnAccessCheck
						)	{
/*++

Routine Description : 

	This function performs an ACCESS Check to determine whether
	a client has the specified permissions to the object.


Arguments : 

	hToken - Client Token
	accessMask - the Client's desired access 

Return Value : 

	TRUE if the client has access, 
	FALSE otherwise !

--*/


	if( hToken == 0 ) 
		return	TRUE ;

	_ASSERT( hToken != 0 ) ;
	_ASSERT( accessMask != 0 ) ;
	_ASSERT( IsValid() ) ;

    BYTE    psFile[256] ;
    DWORD   dwPS = sizeof( psFile ) ;
    DWORD   dwGrantedAccess = 0 ;
    BOOL    fAccess = FALSE ;

    BOOL    f = FALSE ;

	if( pfnAccessCheck ) {
		f = pfnAccessCheck(	SecurityDescriptor(),
							hToken,
							accessMask, 
							&m_mapping, 
							(PRIVILEGE_SET*)psFile, 
							&dwPS, 
							&dwGrantedAccess, 
							&fAccess
							) ;
	}	else	{
		f = ::AccessCheck(  SecurityDescriptor(),
                            hToken,
                            accessMask,
                            &m_mapping,
                            (PRIVILEGE_SET*)psFile,
                            &dwPS,
                            &dwGrantedAccess,
                            &fAccess
                            ) ;
	}
    DWORD   dw = GetLastError() ;

	return	f && fAccess ;
}



//
//	Now - find or create a given security descriptor 
//	item !
//
CSDObject*
CSDObjectContainer::FindOrCreate(	DWORD	dwHash, 
									CSDKey&	key 
									)	{
/*++

Routine Description : 

	This function will either locate a matching security 
	descriptor in the cache, or return a pointer to a new
	CSDObject created and placed into the cache.

	NOTE : We must always ADD a reference while the lock is held, 
	because Release() will try to re-enter the lock and remove
	the object from the hash table !

Arguments : 

	dwHash - the hash of the sought security descriptor
	key -	describes the security descriptor and GENERIC_MAPPING
		we are to locate !

Return Value : 

	A pointer to a CSDObject in the cache, or NULL if failure.
	A NULL means the object was not found, and we couldn't allocate
	memory to insert a new one !

--*/

	_ASSERT( key.IsValid() ) ;
	_ASSERT( CSDKey::HashKey(key) == dwHash ) ;

	CSDObject*	pObject = 0 ;
	m_lock.ShareLock() ;
	SDTABLE::ITER	iter = 
		m_table.SearchKeyHashIter(	dwHash,		
									key, 
									pObject
									) ;
	if( pObject )	{	
		pObject->AddRef() ;
		m_lock.ShareUnlock() ;
	}	else	{
		if( !m_lock.SharedToPartial() ) {
			m_lock.ShareUnlock() ;
			m_lock.PartialLock() ;
			iter = m_table.SearchKeyHashIter(	dwHash,
												key, 
												pObject
												) ;
		} 
		if( pObject != 0 ) {
			pObject->AddRef() ;
		}	else	{
			pObject = new( key )	CSDObject( dwHash, key, this ) ;
			if( pObject != 0 ) {
				m_lock.FirstPartialToExclusive() ;
				BOOL	fInsert = 
					m_table.InsertDataHashIter(	iter, 
												dwHash, 
												key, 
												pObject
												) ;	
				m_lock.ExclusiveUnlock() ;
				if( !fInsert ) {
					pObject->Release() ;
					pObject = 0 ;
				}
				return	pObject ;
			}
		}	
		m_lock.PartialUnlock() ;
	}	
	return	pObject ;
}	// End FindOrCreate()


CSDMultiContainer::Init()	{
/*++

Routine Description : 

	Initialize everything so we're ready to go !

Arguments : 

	None.

Return Value : 

	TRUE if successfull, FALSE otherwise !


--*/

	BOOL	fReturn = TRUE ;
	for( int i=0; i<CONTAINERS && fReturn; i++ )	{
		fReturn &= m_rgContainer[i].Init() ;
	}
	return	fReturn ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\hashmap\src\crchash.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    crchash.cpp

Abstract:
	CRC Hash function
*/

//
//
// Hashing function adopted from the INN code (see copyright below)
//

/*
    Copyright 1988 Jon Zeeff (zeeff@b-tech.ann-arbor.mi.us)
    You can use this code in any manner, as long as you leave my name on it
    and don't hold me responsible for any problems with it.

 * This is a simplified version of the pathalias hashing function.
 * Thanks to Steve Belovin and Peter Honeyman
 *
 * hash a string into a long int.  31 bit crc (from andrew appel).
 * the crc table is computed at run time by crcinit() -- we could
 * precompute, but it takes 1 clock tick on a 750.
 *
 * This fast table calculation works only if POLY is a prime polynomial
 * in the field of integers modulo 2.  Since the coefficients of a
 * 32-bit polynomial won't fit in a 32-bit word, the high-order bit is
 * implicit.  IT MUST ALSO BE THE CASE that the coefficients of orders
 * 31 down to 25 are zero.  Happily, we have candidates, from
 * E. J.  Watson, "Primitive Polynomials (Mod 2)", Math. Comp. 16 (1962):
 *  x^32 + x^7 + x^5 + x^3 + x^2 + x^1 + x^0
 *  x^31 + x^3 + x^0
 *
 * We reverse the bits to get:
 *  111101010000000000000000000000001 but drop the last 1
 *         f   5   0   0   0   0   0   0
 *  010010000000000000000000000000001 ditto, for 31-bit crc
 *     4   8   0   0   0   0   0   0
 */

#include <windows.h>
#include "crchash.h"

static long CrcTable[128];
static BOOL bInitialized = FALSE;

/*
 - crcinit - initialize tables for hash function
 */
void crcinit()
{
    INT i, j;
    DWORD sum;

	if(bInitialized) return;

    for (i = 0; i < 128; ++i) {
        sum = 0;
        for (j = 7 - 1; j >= 0; --j) {
            if (i & (1 << j)) {
                sum ^= POLY >> j;
            }
        }
        CrcTable[i] = sum;
    }

	bInitialized = TRUE;
} // crcinit

/*
 - hash - Honeyman's nice hashing function
 */
DWORD CRCHash(const BYTE*	Key, DWORD Length)
{
    DWORD sum = 0;

    while ( Length-- ) {

        sum = (sum >> 7) ^ CrcTable[(sum ^ (*Key++)) & 0x7f];
    }
    return(sum);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\hashmap\src\crchash.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    crchash.h

Abstract:
	CRC Hash function
*/

#ifndef __CRCHASH_H
#define __CRCHASH_H

#define POLY 0x48000000L    /* 31-bit polynomial (avoids sign problems) */

extern long CrcTable[128];
void crcinit();

DWORD CRCHash(IN const BYTE * Key, IN DWORD KeyLength);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\hashmap\src\directry.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    directry.cpp

Abstract:

    This module contains definition for the CDirectory base class

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

	Alex Wetmore (AWetmore) split into directry.cpp (from hash.cpp)

--*/

#include <windows.h>
#include <xmemwrpr.h>
#include <dbgtrace.h>
#include "directry.h"
#include "hashmacr.h"

BOOL
CDirectory::IsValid()	{

	if( !(DWORD(1<<m_cBitDepth) <= m_cMaxDirEntries)	)	{
		return	FALSE ;
	}
	if( m_pDirectory == NULL )
		return	FALSE ;

	if( IsBadWritePtr( (LPVOID)m_pDirectory, m_cMaxDirEntries ) )
		return	FALSE ;

	//
	//	Now go and check that m_cDeepPages is correct - we can do this
	//	by spinning through the directory and seeing how many entries
	//	are unique (only occur once)!
	//	Note that non-unique values must occur in consecutive
	//	locations.
	//

	DWORD	UniqueCount = 0 ;
	for( DWORD	i=0; i < DWORD(1<<m_cBitDepth); ) {

		for( DWORD j=i+1; j < DWORD(1 << m_cBitDepth); j++ ) {
			if( m_pDirectory[j] != m_pDirectory[i] )
				break ;
		}
		if( j == (i+1) ) {
			if( m_pDirectory[i] != 0 ) {
				UniqueCount ++ ;
			}
		}
		i = j ;
	}
	if( UniqueCount != m_cDeepPages ) {
		return	FALSE ;
	}

	return	TRUE ;
}

BOOL
CDirectory::IsValidPageEntry(
					PMAP_PAGE	MapPage,
					DWORD		PageNum,
					DWORD		TopLevelIndex ) {
/*++

Routine Description :

	Given an actual Hash Table page, check that all of our
	directory information is consistent with the page contents.
	This function is mostly used for _ASSERT checking.

Arguments :

	MapPage - The Hash Table page we are checking.
	PageNum - The Number of the Page we are examining.
	TopLevelIndex - The index to this CDirectory object within
		the containing top level directory.  This is basically
		the m_cTopBits of a HashValue which selects this directory !

Return Value :

	TRUE if everything is correct
	FALSE otherwise.

--*/


    DWORD startPage, endPage;
	DWORD	dirDepth = m_cTopBits + m_cBitDepth ;

	//
	//	Pages cannot be split accross directory boundaries, which means
	//	they must have more depth than the top tier of the directory !
	//
	if( MapPage->PageDepth < m_cTopBits )
		return FALSE ;

	//
	//	The m_cTopBits of the Page's HashPrefix must put this page into
	//	this sub-directory - check that they do !
	//
	//  BUGBUG -- this was disabled.  since m_pDirectory[] is now a ptr
	//  in CHashMap there wasn't a simple way to generate TopLevelIndex
	//  (awetmore)
	//
//	if( (MapPage->HashPrefix >> (MapPage->PageDepth-m_cTopBits)) !=
//		TopLevelIndex )
//		return	FALSE ;

    //
    // Get the range of directory entries that point to this page
    //
    startPage = MapPage->HashPrefix << (dirDepth - MapPage->PageDepth);
    endPage = ((MapPage->HashPrefix+1) << (dirDepth - MapPage->PageDepth));

	//
	//	Now make sure that we are working with only m_cBitDepth bits and we'll be set !
	//
	startPage &= (0x1 << m_cBitDepth) - 1 ;
	endPage &= (0x1 << (m_cBitDepth)) - 1 ;
	//
	//	It could be that this page fills the entire directory,
	//	in which case we'll end up with endPage == startPage
	//	Test for this and fix the limits !
	//
	if( endPage == 0 ) {
		endPage = (1 << (m_cBitDepth)) ;
	}

	_ASSERT( startPage < endPage ) ;
	_ASSERT( endPage <= DWORD(1<<m_cBitDepth) ) ;

    //DebugTraceX( 0, "SetDirPtrs:Adjusting links for %x. start = %d end = %d", MapPage, startPage, endPage );

    //
    // Are the numbers within range
    //
    if ( (startPage >= endPage) ||
         (endPage > DWORD(1<<m_cBitDepth)) )
    {
        ErrorTraceX( 0, "Cannot map entries for page %d %d %d %d\n", PageNum, startPage, endPage, 0 );
        return FALSE;
    }

	//
	//	Check that all of the directory entries that should reference this page,
	//	actually do so !
	//
	for( DWORD i=startPage; i<endPage; i++ ) {
		if( m_pDirectory[i] != PageNum ) {
			return	FALSE ;
		}
	}
	return	TRUE ;
}


CDirectory::~CDirectory()	{
/*++

Routine Description :

	This function blows away any memory we allocated and
	cleans up everything.  We can not assume that InitializeDirectory()
	was called, as errors may have occurred during boot-up
	that caused InitializeDirectory() to not be called,
	or to fail when it was called.

Arguments :

	None.

Return Value :

	None.

--*/

	if( m_pDirectory ) {

		_ASSERT( m_cBitDepth != 0 ) ;
		_ASSERT( m_cMaxDirEntries != 0 ) ;


		if( m_fHeapAllocate ) {
			delete[]	m_pDirectory ;
		}	else	{
			_VERIFY( VirtualFree( m_pDirectory, 0, MEM_RELEASE ) ) ;
		}
		m_pDirectory = 0 ;
	}

}


LPDWORD
CDirectory::AllocateDirSpace(	WORD	cBitDepth,
								DWORD&	cMaxEntries,
								BOOL&	fHeapAllocate
								) {
/*++

Routine Description :

	Use VirtualAlloc to get some memory to use as a directory.

Arguments ;

	cBitDepth - Number of bits of depth we have to be able to
		hold !

	cMaxEntries - OUT parameter - this gets the maximum number
		of Entries there can be in the directory

	fHeapAllocate - OUT parameter - this gets whether we use the
		CRuntime allocator or VirtualAlloc !

Return Value :

	Pointer to allocated memory if successfull, NULL otherwise.

--*/

	TraceQuietEnter( "CDirectory::AllocateDirSpace" ) ;

	LPDWORD	lpdwReturn = 0 ;
	fHeapAllocate = FALSE ;
	cMaxEntries = 0 ;
	DWORD	cbAlloc = (1 << cBitDepth) * sizeof( DWORD ) ;

	//
	//	Test for OVerflow !!
	//
	if( cbAlloc < DWORD(1 << cBitDepth) || cBitDepth >= 32 ) {
		return	0 ;
	}

	if( cbAlloc < 4096 ) {

		DWORD	cBits = (cBitDepth <6) ? 6 : cBitDepth ;
		DWORD	cdw = (1<<cBits) ;
		
		lpdwReturn = new	DWORD[cdw] ;
		if( lpdwReturn != 0 ) {
			ZeroMemory( lpdwReturn, sizeof(DWORD)*cdw ) ;
			fHeapAllocate = TRUE ;
			cMaxEntries = cdw ;
		}

	}	else	{

		lpdwReturn = (LPDWORD)
						VirtualAlloc(	0,
										cbAlloc,
										MEM_COMMIT,
										PAGE_READWRITE
										) ;

		if( lpdwReturn == 0 ) {

			ErrorTrace( (DWORD_PTR)this, "VirtualAlloc failed cause of %x",
					GetLastError() ) ;

		}	else	{

			MEMORY_BASIC_INFORMATION	mbi ;

			SIZE_T	dwReturn = VirtualQuery(	
									lpdwReturn,
									&mbi,
									sizeof( mbi ) ) ;

			_ASSERT( dwReturn == sizeof( mbi ) ) ;

			cMaxEntries = (DWORD)(mbi.RegionSize / sizeof( DWORD )) ;

		}
	}

	return	lpdwReturn ;
}

BOOL
CDirectory::InitializeDirectory(
					WORD	cTopBits,
					WORD	cInitialDepth
					) {
/*++

Routine Description :

	Allocate inital memory for holding the directory.

Arguments :

	wTopBits - Number of bits that are being used by
		the containing Top Level directory which calls us.

	cInitialDepth - Number of bits of depth we are to
		start out with.

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/

	TraceQuietEnter( "CDirectory::InitializeDirectory" ) ;

	m_pDirectory = AllocateDirSpace( cInitialDepth,
									m_cMaxDirEntries,
									m_fHeapAllocate ) ;

	if( m_pDirectory != 0 ) {
		
		m_cTopBits = cTopBits ;
		m_cBitDepth = cInitialDepth ;

		_ASSERT( IsValid() ) ;
		
	}

	return	TRUE ;
}

PDWORD
CDirectory::GetIndex(	
				DWORD	HashValue
				) {
/*++

Routine Description :

	Given a hash value, return a pointer to a location within
	the Directory corresponding to the hash value.
	The containing Directory has used th top m_cTopBits to select
	us, so we must use the following m_cBitDepth bits
	to find our entry.

	****** ASSUMES LOCK IS HELD - EXCLUSIVE OR SHARED ******

Arguments :

	HashValue - The value we wish to find.

Return Value :

	We always return a NON-NULL pointer to the Page Number
	within the directory.

--*/

	//
	//	Get the relevant m_cTopBits + m_cBitDepth bits
	//

	DWORD	Index =
		
				HashValue >> (32 - (m_cTopBits + m_cBitDepth)) ;

	//
	//	Remove the m_cTopBits leaving us with only m_cBitDepth bits !
	//

	Index &= ((1 << m_cBitDepth) - 1) ;

	_ASSERT( Index < DWORD(1<<m_cBitDepth) ) ;

	return	&m_pDirectory[Index] ;

}

BOOL
CDirectory::ExpandDirectory(
				WORD	cBitsExpand
				)	{
/*++

Routine Description :

	The directory needs to grow in bit depth.
	We will try to allocate a larger piece of memory to hold
	the directory in, and then use the old directory
	to build the new one.

	****** ASSUMES LOCK IS HELD EXCLUSIVE *******

Arguments :

	cBitsExpand - Number of bits in depth to grow by !

Return Value :

	TRUE if successfull, false otherwise !

--*/

	PDWORD	pOldDirectory = m_pDirectory ;
	BOOL	fOldHeapAllocate = m_fHeapAllocate ;

	DWORD	cNewEntries = (0x1 << (m_cBitDepth + cBitsExpand)) * sizeof( DWORD ) ;
	if( cNewEntries > m_cMaxDirEntries ) {

		DWORD	cNewMaxDirEntries = 0 ;
		m_pDirectory = AllocateDirSpace( m_cBitDepth + cBitsExpand,
										cNewMaxDirEntries,
										m_fHeapAllocate
										) ;

		if( m_pDirectory == 0 ) {

			m_pDirectory = pOldDirectory ;
			m_fHeapAllocate = fOldHeapAllocate ;

			_ASSERT( IsValid() ) ;

			return	FALSE ;

		}	else	{

			m_cMaxDirEntries = cNewMaxDirEntries ;
	
		}

	}	

	//
	//	Copy and Expand the old directory into the new, but
	//	start from the tail ends, so that we can do this in
	//	place if we are not allocating new memory.
	//

	DWORD	cRepeat = (0x1 << cBitsExpand) - 1 ;
	
	for( int	idw = (0x1 << m_cBitDepth) - 1; idw >= 0; idw -- ) {

		DWORD	iBase = idw << cBitsExpand ;

		for( int	iRepeat = cRepeat; iRepeat >= 0 ; iRepeat -- ) {

			m_pDirectory[ iBase + iRepeat ] = pOldDirectory[idw] ;

		}
	}
	m_cBitDepth += cBitsExpand ;

	m_cDeepPages = 0 ;	

	if( pOldDirectory != m_pDirectory ) {

		if( fOldHeapAllocate ) {
			delete[]	pOldDirectory ;
		}	else	{
			_VERIFY( VirtualFree( pOldDirectory, 0, MEM_RELEASE ) ) ;
		}

	}

	_ASSERT( IsValid() ) ;

	return	TRUE ;
}


BOOL
CDirectory::SetDirectoryPointers(
					IN	PMAP_PAGE	MapPage,
					IN	DWORD		PageNumber
					)	{

/*++

Routine Description :

	This function sets up the entries within a directory to ensure
	that the page is correctly referenced by the directory.

Arguments :

	MapPage - The page we want the directory to reference
	PageNumber - The number of the page
	MaxDirEntries -

Return Value :

	TRUE if successfull,
	FALSE otherwise.


--*/

	DWORD	dirDepth = m_cBitDepth + m_cTopBits ;
	DWORD	startPage, endPage ;
	
    //
    // Get the range of directory entries that point to this page
    //
    startPage = MapPage->HashPrefix << (dirDepth - MapPage->PageDepth);
    endPage = ((MapPage->HashPrefix+1) << (dirDepth - MapPage->PageDepth));

	//
	//	Now make sure that we are working with only m_cBitDepth bits and we'll be set !
	//
	startPage &= (0x1 << m_cBitDepth) - 1 ;
	endPage &= (0x1 << (m_cBitDepth)) - 1 ;
	//
	//	It could be that this page fills the entire directory,
	//	in which case we'll end up with endPage == startPage
	//	Test for this and fix the limits !
	//
	if( endPage == 0 ) {
		endPage = (1 << (m_cBitDepth)) ;
	}

	_ASSERT( startPage < endPage ) ;
	_ASSERT( endPage <= DWORD(1<<m_cBitDepth) ) ;

    DebugTraceX( 0, "SetDirPtrs:Adjusting links for %x. start = %d end = %d\n",
        MapPage, startPage, endPage );

	//
	// Do the actual mapping
	//
	DWORD	OldValue = m_pDirectory[startPage] ;
	for ( DWORD	j = startPage; j < endPage; j++ )
	{
		m_pDirectory[j] = PageNumber ;
	}

	//
	//	Whenever we split page, we always create 2 pages which are at the new depth,
	//	and if that new depth is the full depth of the directory, then we must have
	//	increased the number of deep pages by 2.
	//
	if( (startPage+1) == endPage ) {

		//
		//	OldValue == 0 implies that this is occurring during boot-up when
		//	we have not set the surrounding Page Values. So only increment by 1
		//	in that case, as we will call SetDirectoryPointer for the neighbor !
		//
		if( OldValue != 0 ) {
			m_cDeepPages += 2 ;
		}	else	{
			m_cDeepPages += 1 ;
		}

	}

	//
	//	By now, everything must be back to a valid state !
	//
	_ASSERT( IsValid() ) ;

    return TRUE;
}

BOOL
CDirectory::IsDirectoryInitGood(
	DWORD	MaxPagesInUse
	)	{
/*++

Routine Description :

	Check that all of the directory entries were completely
	initialized - the directory should contain no
	illegal Page NUmbers such as 0 or 0xFFFFFFFF.

Arguments :

	MaxPagesInUse -	The number of pages actually being used
		in the hash table - if the directory has a page number
		larger than this than something screwy is afoot !

Return Value :

	None.

--*/

	for( DWORD	i=0; i < DWORD(1<<m_cBitDepth); i++ )	{
		if( m_pDirectory[i] == 0 || m_pDirectory[i] > MaxPagesInUse )
			return	FALSE ;
	}

	return	TRUE ;
}

void
CDirectory::Reset()	{
/*++

Routine Description :

	Restore directory to clean state.

Arguments :

	None.

Return Value :

	None.

--*/

	m_cDeepPages = 0 ;
	if( m_pDirectory != 0 ) {
		ZeroMemory( m_pDirectory, m_cMaxDirEntries * sizeof( DWORD ) ) ;
	}
}

BOOL
CDirectory::SaveDirectoryInfo(
		HANDLE		hFile,
		DWORD		&cbBytes
		) {
/*++

Routine Description :

	Save the contents of the directory info the file at the
	current file pointer position within the file.
	

Arguments :

	hFile - The file in which we are to save the directory info.
	cbBytes - Out parameter which gets the number of bytes we put
		into the directory.

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/

	DWORD	cbWrite = 0 ;
	cbBytes = 0 ;
	BOOL	fReturn =
		WriteFile(	hFile,
					&m_cBitDepth,
					sizeof( m_cBitDepth ),
					&cbWrite,
					0 ) ;
	if( fReturn ) {

		cbBytes += cbWrite ;
		cbWrite = 0 ;
		fReturn &= WriteFile(	hFile,
								m_pDirectory,
								sizeof( DWORD ) * DWORD(1<<m_cBitDepth),
								&cbWrite,
								0 ) ;
		cbBytes += cbWrite ;
	}
	return	fReturn ;
}

BOOL
CDirectory::LoadDirectoryInfo(
		HANDLE		hFile,
		DWORD		&cbBytes
		)	{
/*++

Routine Description :
	
	Load a previously saved directory from a file. (Saved with SaveDirectoryInfo()).

Arguments :

	hFile - The file from which we are to read the directory info.
	cbBytes - Number of bytes read from the file !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	cbBytes = 0 ;
	WORD	BitDepth ;
	DWORD	cbRead = 0 ;

	BOOL	fReturn = ReadFile(	hFile,
								&BitDepth,
								sizeof( BitDepth ),
								&cbRead,
								0 ) ;
	if( fReturn ) {

		cbBytes += cbRead ;
		cbRead = 0 ;

		//
		//	Initialzie to current directory - if there's room will
		//	read directly into current directory !
		//
		PDWORD	pNewDirectory = m_pDirectory ;
		BOOL	fHeapAllocate = m_fHeapAllocate ;

		//
		//	Compute how big a directory we need to hold this stuff !
		//
		DWORD	cNewEntries = (0x1 << BitDepth) * sizeof( DWORD ) ;
		DWORD	cNewMaxDirEntries = 0 ;

		if( m_pDirectory == 0 ||
			cNewEntries > m_cMaxDirEntries ) {

			pNewDirectory = AllocateDirSpace( BitDepth,	cNewMaxDirEntries, fHeapAllocate ) ;

			if( pNewDirectory == 0 ) {

				_ASSERT( IsValid() ) ;

				return	FALSE ;

			}	
		}

		fReturn &= ReadFile(	hFile,
								pNewDirectory,
								sizeof( DWORD ) * (1<<BitDepth),
								&cbRead,
								0 ) ;
		
		if( !fReturn ) {

			if( pNewDirectory != m_pDirectory ) {
				if( fHeapAllocate ) {
					_VERIFY( VirtualFree( pNewDirectory, 0, MEM_RELEASE ) ) ;
				}	else	{
					delete[]	pNewDirectory ;
				}
				pNewDirectory = 0 ;
			}

		}	else	{

			//
			//	Adjust out parm to caller for bytes we read !
			//
			cbBytes += cbRead ;

			//
			//	Set members to correct values !
			//
			m_cBitDepth = BitDepth ;
			m_cMaxDirEntries = cNewMaxDirEntries  ;

			if( pNewDirectory != m_pDirectory ) {

				//
				//	Must be non-zero since we read into pNewDirectory !
				//
				_ASSERT( pNewDirectory != 0 ) ;

				//
				//	Release old directory stuff !
				//
				if( m_pDirectory != 0 )		{
					if( m_fHeapAllocate ) {
						delete[]	m_pDirectory ;
					}	else	{
						_VERIFY( VirtualFree( m_pDirectory, 0, MEM_RELEASE ) ) ;
					}
				}

				m_pDirectory = pNewDirectory ;
				m_fHeapAllocate = fHeapAllocate ;


			}

		}
	}

	//
	//	Whether succes
	//
	_ASSERT( IsValid() ) ;

	return	fReturn ;
}

BOOL
CDirectory::LoadDirectoryInfo(
		LPVOID		lpv,
		DWORD		cbSize,
		DWORD		&cbBytes
		)	{
/*++

Routine Description :
	
	Load a previously saved directory from a file. (Saved with SaveDirectoryInfo()).

Arguments :

	hFile - The file from which we are to read the directory info.
	cbBytes - Number of bytes read from the file !

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	cbBytes = 0 ;
	WORD	BitDepth ;
	DWORD	cbRead = 0 ;
	BOOL	fReturn = FALSE ;

	cbRead = 0 ;

	if( cbSize <= sizeof( WORD ) ) {
		return	FALSE ;
	}

	BitDepth = ((WORD*)lpv)[0] ;
	cbBytes += sizeof( WORD ) ;

	//
	//	Initialzie to current directory - if there's room will
	//	read directly into current directory !
	//
	PDWORD	pNewDirectory = m_pDirectory ;
	BOOL	fHeapAllocate = m_fHeapAllocate ;

	//
	//	Compute how big a directory we need to hold this stuff !
	//
	DWORD	cNewEntries = (0x1 << BitDepth) ;
	DWORD	cNewMaxDirEntries = m_cMaxDirEntries; // was 0 ;

	if( m_pDirectory == 0 ||
		cNewEntries > m_cMaxDirEntries ) {

		pNewDirectory = AllocateDirSpace( BitDepth,	cNewMaxDirEntries, fHeapAllocate ) ;

		if( pNewDirectory == 0 ) {

			return	FALSE ;

		}	
	}

	if( !((cNewEntries * sizeof( DWORD )) <= (cbSize - sizeof(WORD))) ) {

		if( pNewDirectory != m_pDirectory )	{
			if( fHeapAllocate ) {
				delete[]	pNewDirectory ;
			}	else	{
				_VERIFY( VirtualFree( pNewDirectory, 0, MEM_RELEASE ) ) ;
			}
		}
		pNewDirectory = 0 ;

	}	else	{

		cbRead = cNewEntries * sizeof( DWORD ) ;

		//
		//	Copy in the directory !
		//
		CopyMemory( pNewDirectory, &((WORD*)lpv)[1], cbRead ) ;

		//
		//	Adjust out parm to caller for bytes we read !
		//
		cbBytes += cbRead ;

		//
		//	Set members to correct values !
		//
		m_cBitDepth = BitDepth ;
		m_cMaxDirEntries = cNewMaxDirEntries  ;

		if( pNewDirectory != m_pDirectory ) {

			//
			//	Must be non-zero since we read into pNewDirectory !
			//
			_ASSERT( pNewDirectory != 0 ) ;

			//
			//	Release old directory stuff !
			//
			if( m_pDirectory != 0 )	{
				if( m_fHeapAllocate )	{
					delete[]	m_pDirectory ;
				}	else	{
					_VERIFY( VirtualFree( m_pDirectory, 0, MEM_RELEASE ) ) ;
				}
			}

			m_pDirectory = pNewDirectory ;
			m_fHeapAllocate = fHeapAllocate ;

		}
		//
		//	Now go and check that m_cDeepPages is correct - we can do this
		//	by spinning through the directory and seeing how many entries
		//	are unique (only occur once)!
		//	Note that non-unique values must occur in consecutive
		//	locations.
		//

		DWORD	UniqueCount = 0 ;
		for( DWORD	i=0; i < DWORD(1<<m_cBitDepth); ) {

			for( DWORD j=i+1; j < DWORD(1 << m_cBitDepth); j++ ) {
				if( m_pDirectory[j] != m_pDirectory[i] )
					break ;
			}
			if( j == (i+1) ) {
				if( m_pDirectory[i] != 0 ) {
					UniqueCount ++ ;
				}
			}
			i = j ;
		}
		m_cDeepPages = UniqueCount ;


		fReturn = TRUE ;

	}
	//
	//	Whether succes
	//
	_ASSERT( IsValid() ) ;

	return	fReturn ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\hashmap\src\hashinln.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pagelock.h

Abstract:

    This module contains inline code for classes defined in hashmap.h

--*/

#ifndef _PAGELOCK_
#define _PAGELOCK_

#include "pageent.h"


//
// the class decleration for CPageLock is in hashmap.h
//
#include "hashmap.h"

inline
CPageLock::CPageLock() :
	m_pPage( 0 ),
	m_pDirectory( 0 ),
	m_pPageSecondary( 0 ),
	m_fPageShared (FALSE) 
#ifdef	DEBUG
	,m_fExclusive( FALSE ) 
#endif
	{}

#ifdef	DEBUG
//
//	In debug builds - _ASSERT check that all our members
//	are set to NULL before we are destroyed - as we release locks
//	we will set these to NULL !
//
inline
CPageLock::~CPageLock()	{
	_ASSERT( m_pPage == 0 ) ;
	_ASSERT( m_pDirectory == 0 ) ;
}
#endif

inline	void
CPageLock::AcquireDirectoryShared( 
				CDirectory*	pDirectory	
				)	{
/*++

Routine Description : 

	Lock the directory for access and record
	what directory we locked for later release.

Agruments : 

	pDirectory - pointer to the directory the caller
		wants shared access to

Return Value : 

	None.

--*/

	//
	//	Caller can only grab one directory at a time
	//
	_ASSERT( m_pDirectory == 0 ) ;

	//
	//	Directory locks must always be grabbed before 
	//	pages are !
	//
	_ASSERT( m_pPage == 0 ) ;

#ifdef	DEBUG
	m_fExclusive = FALSE ;
#endif
	m_pDirectory = pDirectory ;
	m_pDirectory->m_dirLock.ShareLock() ;

	_ASSERT( m_pDirectory->IsValid() ) ;
}

inline	void
CPageLock::AcquireDirectoryExclusive(	
				CDirectory*	pDirectory 
				)	{
/*++

Routine Description : 
	
	Lock the directory for exclusive access, and record for 
	later release

Arguments : 

	pDirectory - Directory caller wants exclusive access to !

Return Value : 

	None.

--*/

	//
	//	Caller can only have on directory locked at a time !
	//
	_ASSERT( m_pDirectory == 0 ) ;

	//
	//	Directory objects must be grabbed before pages
	//
	_ASSERT( m_pPage == 0 ) ;

#ifdef	DEBUG
	m_fExclusive = TRUE ;
#endif
	m_pDirectory = pDirectory ;
	m_pDirectory->m_dirLock.ExclusiveLock() ;


	_ASSERT( m_pDirectory->IsValid() ) ;
}


inline	PMAP_PAGE
CPageLock::AcquirePageShared(	
					PageEntry	*pageEntry,
					HANDLE	hFile,
					DWORD	PageNumber,
					BOOL	fDropDirectory
					)	{
/*++

Routine Description : 

	Get an shared lock on a page

Arguments : 

	page - The PageEntry object which manages access to the specified 
		PageNumber
	hFile - The file containing the page of data
	PageNumber - The page we want loaded into memory and exclusive access to

Return Value : 

	Pointer to the page in memory if successfull, NULL otherwise !

--*/

	//
	//	Only one page can be locked at a time
	//
	_ASSERT( m_pPage == 0 ) ;

	PMAP_PAGE	ret = pageEntry->AcquirePageShared( hFile, PageNumber, m_fPageShared, this, fDropDirectory ) ;

	//
	//	Only if the call to the PageEntry object succeeded 
	//	are we left holding a lock. So only update our m_pPage
	//	pointer in the success case, as we don't want to mistakenly
	//	release a lock we don't have in the future.
	//
	if( ret )	{
		m_pPage = pageEntry ;


		_ASSERT( m_pDirectory == 0 || m_pDirectory->IsValid() ) ;
	}

	return		ret ;
}

inline	PMAP_PAGE
CPageLock::AcquirePageExclusive(	
					PageEntry	*pageEntry,
					HANDLE	hFile,
					DWORD	PageNumber,
					BOOL	fDropDirectory
					)	{
/*++

Routine Description : 

	Get an shared lock on a page

Arguments : 

	page - The PageEntry object which manages access to the specified 
		PageNumber
	hFile - The file containing the page of data
	PageNumber - The page we want loaded into memory and exclusive access to

Return Value : 

	Pointer to the page in memory if successfull, NULL otherwise !

--*/

	//
	//	Only one page can be locked at a time
	//
	_ASSERT( m_pPage == 0 ) ;
	_ASSERT( m_pPageSecondary == 0 ) ;

	PMAP_PAGE	ret = pageEntry->AcquirePageExclusive( hFile, PageNumber, m_fPageShared, this, fDropDirectory ) ;

	//
	//	Only if the call to the PageEntry object succeeded 
	//	are we left holding a lock. So only update our m_pPage
	//	pointer in the success case, as we don't want to mistakenly
	//	release a lock we don't have in the future.
	//
	if( ret )	{
		m_pPage = pageEntry ;


		_ASSERT( m_pDirectory == 0 || m_pDirectory->IsValid() ) ;
	}

	return		ret ;
}


inline	BOOL
CPageLock::AddPageExclusive(	
					PageEntry	*pageEntry,
					HANDLE	hFile,
					DWORD	PageNumber
					)	{
/*++

Routine Description : 

	Get an shared lock on a page

Arguments : 

	page - The PageEntry object which manages access to the specified 
		PageNumber
	hFile - The file containing the page of data
	PageNumber - The page we want loaded into memory and exclusive access to

Return Value : 

	Pointer to the page in memory if successfull, NULL otherwise !

--*/

	//
	//	Only one secondary page can be locked at a time - and only 
	//	after the primary page is locked !
	//
	_ASSERT( m_pPage != 0 ) ;
	_ASSERT( m_pPageSecondary == 0 ) ;

	BOOL	ret = FALSE ;

	if( pageEntry == m_pPage ) {
		return	TRUE ;
	}	else	{
	
		BOOL	fShared = FALSE ;
		ret = pageEntry->AcquireSlotExclusive( hFile, PageNumber, fShared ) ;

		_ASSERT( fShared == FALSE ) ;

		//
		//	Only if the call to the PageEntry object succeeded 
		//	are we left holding a lock. So only update our m_pPage
		//	pointer in the success case, as we don't want to mistakenly
		//	release a lock we don't have in the future.
		//
		if( ret )	{
			m_pPageSecondary = pageEntry ;


			_ASSERT( m_pDirectory == 0 || m_pDirectory->IsValid() ) ;
		}
	}

	return		ret ;
}


inline	void
CPageLock::ReleaseAllShared(
					PMAP_PAGE	page
					)	{
/*++

Routine Description : 

	

--*/

	if( m_pDirectory ) 
		m_pDirectory->m_dirLock.ShareUnlock() ;

	if( m_pPage )
		m_pPage->ReleasePage( page, m_fPageShared ) ;

	if( m_pPageSecondary ) 
		m_pPageSecondary->ReleasePage( 0, FALSE ) ;

#ifdef	DEBUG
	_ASSERT( !m_fExclusive ) ;
#endif
	m_pDirectory = 0 ;
	m_pPage = 0 ;
	m_pPageSecondary = 0 ;
}

//
//	Release all of our locks - we had an exclusive lock on the directory !
//
inline	void
CPageLock::ReleaseAllExclusive(
					PMAP_PAGE	page
					)	{

	if( m_pDirectory ) {
		m_pDirectory->m_dirLock.ExclusiveUnlock() ;
	}

	if( m_pPage ) 
		m_pPage->ReleasePage( page, m_fPageShared ) ;

	if( m_pPageSecondary ) 
		m_pPageSecondary->ReleasePage( 0, FALSE ) ;


#ifdef	DEBUG
	_ASSERT( m_fExclusive ) ;
#endif
	m_pDirectory = 0 ;
	m_pPage = 0 ;
	m_pPageSecondary = 0 ;
}

//
//	Release the directory !
//
inline	void	
CPageLock::ReleaseDirectoryExclusive()	{

	if( m_pDirectory ) {
		m_pDirectory->m_dirLock.ExclusiveUnlock() ;
	}
	m_pDirectory = 0 ;
}



//
// Flush a page
//

inline 
BOOL CHashMap::FlushPage( 
					HPAGELOCK&	hLock,	
					PVOID Base, 
					BOOL	fDirtyOnly  
					) 
{
	return	hLock.m_pPage->FlushPage( m_hFile, Base, fDirtyOnly ) ;
}



#endif // _PAGELOCK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\hashmap\src\directry.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    lookup.h

Abstract:

    This module contains class declarations/definitions for

        CDirectory

--*/

#ifndef _DIRECTRY_
#define _DIRECTRY_

#include "hashmap.h"

//
//	CDirectory - 
//
//	This class is used to manage subdirectories - structures which
//	allows us to index Hash values to the pages which contain the
//	Hash Table entry.
//
class	CDirectory	{
private : 
	//
	//	This is set to TRUE if we allocate the memory holding 
	//	the directory from the heap instead of through VirtualAlloc.
	//
	BOOL			m_fHeapAllocate ;
	
	//
	//	Pointer to array of DWORDs which makes up the directory !
	//
	LPDWORD			m_pDirectory ;

	//
	//	Number of DWORDs we can put in location pointed to be m_pDirectory
	//	before we need to allocate a larger piece of memory !
	//
	DWORD			m_cMaxDirEntries ;

	//
	//	Number of Bits that have been used to select a CDirectory object - 
	//	this will be the same of all CDirectory objects within a given hash
	//	table.  Store it here for convenient bit fiddling.
	//
	WORD			m_cTopBits ;

	//
	//	Helper function for handling VirtualAlloc's
	//

	LPDWORD			AllocateDirSpace(	WORD	cBitDepth,
										DWORD&	cMaxEntries, 
										BOOL&	fHeapAllocate 
										) ;

public : 

	//
	//	Number of bits that are significant for this directory - 
	//	note that _ASSERT( (1<<m_cBitDepth) <= m_cMaxDirEntries) must 
	//	always be true !
	//	
	WORD			m_cBitDepth ;

	//
	//	Reader/Writer lock controlling access to the directory !
	//	This is public so callers can lock it directly !
	//
	_RWLOCK			m_dirLock ;

	//
	//	Number of pages referenced by the directory which are at the
	//	maximum bit depth (m_cBitDepth) of the directory.
	//	When this goes to zero, we should be able to collapse the directory.
	//	This is publicly accessible, as CHashMap will manipulate this
	//	directly.
	//
	DWORD			m_cDeepPages ;

	//
	//	Initialize to an Illegal state - InitializeDirectory() 
	//	must be called before this will be usefull !
	//
	CDirectory() : 
		m_pDirectory( 0 ), 
		m_cMaxDirEntries( 0 ), 
		m_cTopBits( 0 ),
		m_cBitDepth( 0 ),
		m_cDeepPages( 0 )
		{}  ;

	//
	//	Release any memory we allocated.  Don't assume that 
	//	InitializeDirectory() was called, or completed successfully
	//	if it was called.
	//
	~CDirectory() ;

	//
	//	Set up the directory !
	//
	BOOL	InitializeDirectory(
					WORD	cTopBits,
					WORD	cInitialDepth
					) ;


	//
	// reset the directory back to its initial state
	//
	void Reset(void);

	//
	//	Find an entry within the directory !
	//
	PDWORD	GetIndex(	DWORD	HashValue ) ;	

	//
	//	Grow the directory !
	//
	BOOL	ExpandDirectory(	WORD	cBitsExpand ) ;

	//
	//	Grow the directory to the specified bit depth 
	//
	BOOL	SetDirectoryDepth(	WORD	cBitsDepth )	{
				if( (m_cBitDepth + m_cTopBits) < cBitsDepth )
					return	ExpandDirectory( cBitsDepth - (m_cBitDepth + m_cTopBits)  ) ;
				return	TRUE ;
				}

	//
	//	For the given hash table page, make sure that the appropriate
	//	directory entries reference it !
	//
	BOOL	SetDirectoryPointers(	
						PMAP_PAGE	MapPage,
						DWORD		PageNumber 
						) ;

	//
	//	Check that the directory was fully initialized - we should
	//	have no Page Numbers of '0', which would indicate missing
	//	pages.
	//
	BOOL	IsDirectoryInitGood(DWORD MaxPagesInUse) ;
	
	//
	//	Check that the Directory appears to be set up safely !
	//
	BOOL	IsValid() ;

	//
	//	Check that the Directory is consistent with the data in the Page !
	//	This is mainly for use in _ASSERT checking that our data structures
	//	are consistent !!!!
	//
	BOOL	IsValidPageEntry( 
				PMAP_PAGE	MapPage, 
				DWORD		PageNum,
				DWORD		TopLevelIndex ) ;

	BOOL 	SaveDirectoryInfo(
		HANDLE		hFile, 
		DWORD		&cbBytes );

	BOOL LoadDirectoryInfo(
		HANDLE		hFile, 
		DWORD		&cbBytes);

	BOOL LoadDirectoryInfo(
		LPVOID		lpv, 
		DWORD		cbSize,
		DWORD		&cbBytes);
	

	void 	*operator new(size_t size);
	void 	operator delete(void *p, size_t size);
};

inline void *CDirectory::operator new(size_t size) { 
	return HeapAlloc(GetProcessHeap(), 0, size); 
}

inline void CDirectory::operator delete(void *p, size_t size) { 
	_VERIFY(HeapFree(GetProcessHeap(), 0, p)); 
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\hashmap\src\rw.cpp ===
//
// This file contains test implmentations of reader and writer locks.
// These are intended to be used with the template class in rw.h so that
// different implementations can be plugged in and tested.
// 
// The semantics of the read/write classes should be as follows : 
//	Functions CAN NOT be recursively called,
//	Multiple Readers should be able to enter the lock 
//	Only a single writer may execute at a time.
//



#include	<windows.h>
#include    <xmemwrpr.h>
#include	<limits.h>
#include	"rw.h"

long	const	BlockValue = (-LONG_MAX) / 2; 
							// Large in magnitude, negative value.  Used to 
							// indicate a waiting writer in cReadLock


CShareLock::CShareLock( ) : cReadLock( 0  ), cOutRdrs( 0 )	{
	InitializeCriticalSection( &critWriters ) ;
	hWaitingWriters = CreateSemaphore( NULL, 0, 1, NULL ) ;
	hWaitingReaders = CreateSemaphore( NULL, 0, LONG_MAX, NULL ) ;
}

CShareLock::~CShareLock( ) {
	CloseHandle( hWaitingWriters );
	CloseHandle( hWaitingReaders );
	DeleteCriticalSection( &critWriters ) ;
}


void
CShareLock::ShareLock( ) {
	long	sign = InterlockedIncrement( &cReadLock ) ;
	if( sign > 0 ) {
		return ;
	}	else 	{
		// There must be a writer in the lock.  Wait for him to leave.
		// The InterlockedIncrement recorded our presence so that the writer
		// can later release the correct number of threads.
		WaitForSingleObject( hWaitingReaders, INFINITE ) ;
	}
}

void
CShareLock::ShareUnlock( ) {
	//
	// Leave the lock.  The return value will be negative if there is a writer
	// waiting.
	BOOL fWriterWaiting = InterlockedDecrement( &cReadLock ) < 0 ;

	if( fWriterWaiting ) {
		//
		// The following increment occurs when there is writer waiting, but
		// readers own the lock.  So although cReadLock is temporarily inaccurate
		// about the number of readers waiting for the lock, it is not inaccurate 
		// when it matters in WriteUnlock (which assumes a writer owns the lock.)
		//
		long junk = InterlockedIncrement( &cReadLock ) ;	// restore the value in cReadLock, so that we
												// end up with an accurate count of readers waiting
												// for entry.  

		long sign = InterlockedDecrement( &cOutRdrs ) ;	// Make sure we don't lose track of the 
												// number for readers who have left the lock.
		//
		// Are we the last reader out of the lock ?
		//
		if( sign == 0 ) {
			//
			// Definately the last reader out !
			//
			ReleaseSemaphore( hWaitingWriters, 1, &junk ) ;
		}
	}
}

void
CShareLock::ExclusiveLock( ) {
	// Only one writer allowed to try for the lock at a time.
	//
	EnterCriticalSection( &critWriters ) ;

	//
	// Need to track the number of readers who leave the lock while we 
	// are trying to grab it.
	//
	cOutRdrs = 0 ;
	// Grab the lock 
 	long	oldsign = InterlockedExchange( &cReadLock, BlockValue ) ;
	// How many readers left while we grabbed the lock ??
	long	oldval = InterlockedExchange( &cOutRdrs, oldsign ) ;

	//
	// Accurately track all the readers who left the lock.
	//
	long	cursign = 1 ;	// Initialize to 1 so that if while loop not executed
							// following if statement works correctly.
	while( oldval++ ) 
		cursign = InterlockedDecrement( &cOutRdrs ) ; 

	//
	// Do we own the lock ?  Only if there were no readers, or they have all left already.
	//
	if( oldsign == 0 || cursign == 0 ) {
		// We have the lock
	}	else	{
		// Wait for a reader to signal us.
		WaitForSingleObject( hWaitingWriters, INFINITE ) ;
	}
}



void
CShareLock::ExclusiveUnlock( ) 	{

	// Estimate how many readers are waiting for the lock
	long	cWaiting = cReadLock - BlockValue ;

	// This Exchange allows any readers who have just arrived to grab the lock.
	// Also, it accounts for cWaiting of the blocked readers.
	long	cNewWaiting = InterlockedExchange( &cReadLock, cWaiting ) - BlockValue ;
	
	// cNewWaiting is the EXACT number of blocked readers - we will increment cReadLock
	// until we have accounted for the difference between our estimate and the correct
	// number !
	long	cTotal = cNewWaiting ;	// Save cNewWaiting for later use
	while( cNewWaiting-- > cWaiting ) 
		InterlockedIncrement( &cReadLock ) ;

	if( cTotal > 0 ) {
		long	junk = 0 ;
		ReleaseSemaphore( hWaitingReaders, cTotal, &junk ) ;	// let all those readers go!
	}
	// Let the next writer take his shot at the lock!
	LeaveCriticalSection( &critWriters ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\hashmap\src\rw.h ===
#ifndef	_CRW_H
#define	_CRW_H
						
#include	<limits.h>

//
// This class contains the meat - does actual locking etc...
//
class	CShareLock {
private : 
	long	cReadLock ;			// Number of Readers who have passed through the lock OR 
								// the number of readers waiting for the lock (will be negative).
								// A value of 0 means nobody in the lock
	long	cOutRdrs ;			// The number of readers remainin in the lock if 
								// there is a writer waiting.  This can become temporarily negative
	CRITICAL_SECTION	critWriters ; 	// Critical section to allow only one writer into the lock at a time
	HANDLE	hWaitingWriters ;	// Semaphore for waiting writers to block on (Only 1 ever, others will 
								// be queued on critWriters)
	HANDLE	hWaitingReaders ;	// Semaphore for waiting readers to block on 
public : 
	CShareLock( ) ;
	~CShareLock( ) ;

	void	ShareLock( ) ;
	void	ShareUnlock( ) ;
	void	ExclusiveLock( ) ;
	void	ExclusiveUnlock( ) ;
	void 	*operator new(size_t size);
	void 	operator delete(void *p, size_t size);
} ;

inline void *CShareLock::operator new(size_t size) { 
	return HeapAlloc(GetProcessHeap(), 0, size); 
}

inline void CShareLock::operator delete(void *p, size_t size) { 
	HeapFree(GetProcessHeap(), 0, p);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\hashmap\src\hashmacr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntpmacr.h

Abstract:

    This module contains macross for the NNTP server.

Author:

    Johnson Apacible (JohnsonA)     26-Sept-1995

Revision History:

--*/

#ifndef _NNTPMACR_
#define _NNTPMACR_


#define ALLOCATE_HEAP( nBytes ) LocalAlloc( 0, nBytes )
#define FREE_HEAP( _heap )      LocalFree( (PVOID)(_heap) )

//
// try/finally macros
//

#define START_TRY               __try {
#define END_TRY                 }
#define TRY_EXCEPT              } __except(EXCEPTION_EXECUTE_HANDLER) {
#define START_FINALLY           } __finally {

//
// tracing
//

#define INIT_TRACE              InitAsyncTrace( )
#define TERM_TRACE              TermAsyncTrace( )
#define ENTER( _x_ )            TraceFunctEnter( _x_ );
#define LEAVE                   TraceFunctLeave( );

//
// Convert FILETIME TO LIs
//

#define LI_FROM_FILETIME( _pLi, _pFt ) {               \
            (_pLi)->LowPart = (_pFt)->dwLowDateTime;   \
            (_pLi)->HighPart = (_pFt)->dwHighDateTime; \
            }

#define FILETIME_FROM_LI( _pFt, _pLi ) {               \
            (_pFt)->dwLowDateTime = (_pLi)->LowPart;   \
            (_pFt)->dwHighDateTime = (_pLi)->HighPart; \
            }

//
// CRITICAL SECTIONS
//

#define INIT_LOCK( _l )     InitializeCriticalSection( _l )
#define ACQUIRE_LOCK( _l )  EnterCriticalSection( _l )
#define RELEASE_LOCK( _l )  LeaveCriticalSection( _l )
#define DELETE_LOCK( _l )   DeleteCriticalSection( _l )

//
// LockStatistics
//

#define LockStatistics( )						ACQUIRE_LOCK( &StatLock );
#define UnlockStatistics( )						RELEASE_LOCK( &StatLock );
#define IncrementStat( _x )						(NntpStat. ## _x)++;
#define DecrementStat( _x )						(NntpStat. ## _x)--;
#define InterlockedIncrementStat( _x )			InterlockedIncrement((LPLONG)&(NntpStat. ## _x));
#define InterlockedDecrementStat( _x )			InterlockedDecrement((LPLONG)&(NntpStat. ## _x));
#define InterlockedExchangeAddStat( _x, _y )	InterlockedExchangeAdd( (PLONG)&(NntpStat. ## _x), (LONG)(_y) )
//#define AddByteStat( _x, _y ) \
//        ((NntpStat. ## _x).QuadPart += (_y));
#define AddByteStat( _x, _y ) \
        if( (ULONG)InterlockedExchangeAdd( (PLONG)&((NntpStat. ## _x).LowPart), (LONG)(_y)) \
			> ( ULONG_MAX - (ULONG)(_y) ) ) InterlockedIncrement( (LPLONG)&((NntpStat. ## _x).HighPart) );

//
// debug constants\macros
//

#define  NNTP_DEBUG_REGISTRY        0x00000004
#define  NNTP_DEBUG_EXPIRE          0x00000008
#define  NNTP_DEBUG_LOCKS           0x00000010
#define  NNTP_DEBUG_ARTMAP          0x00000020
#define  NNTP_DEBUG_HISTORY         0x00000040
#define  NNTP_DEBUG_HEAP            0x00000080
#define  NNTP_DEBUG_HASH            0x00000100
#define  NNTP_DEBUG_SECURITY        0x00000200
#define  NNTP_DEBUG_FEEDMGR         0x00000400
#define  NNTP_DEBUG_FEEDBLOCK       0x00000800

//
// on debug build define all inline functions as regular functions.
// copied from msndef.h
//

#if DBG
#define INLINE
#else
#define INLINE      inline
#endif

//
// from extcmk2.h
//

#define fCharInSet(ch, set) (NULL !=strchr(set, ch))
#define STRLEN(sz) (sizeof(sz)-1)
#define	fWhitespace(ch) fCharInSet(ch, szWSChars)
#define	fWhitespaceNull(ch) fCharInSet(ch, szWSNullChars)
#define	fWhitespaceNewLine(ch) fCharInSet(ch, szWSNLChars)
#define	fNewLine(ch) fCharInSet(ch, szNLChars)

#ifndef	Assert
#define Assert _ASSERT
#endif

#endif // _NNTPMACR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\hashmap\src\hashmap.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    hash.cpp

Abstract:

    This module contains definition for the CHashMap base class

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

--*/

#include <windows.h>
#include <dbgtrace.h>
#include <xmemwrpr.h>
#include "hashmacr.h"
#include "pageent.h"
#include "hashmap.h"
#include "crchash.h"
#include "rw.h"
#include "directry.h"
#include "hashinln.h"


DWORD	IKeyInterface::cbJunk = 0 ;


//
// Mask array to get the bit of the hash value used to choose
// between the Hi or Lo Offset array in the leaf page.
//

DWORD
LeafMask[] = {
        0x80000000, 0x40000000, 0x20000000, 0x10000000,
        0x08000000, 0x04000000, 0x02000000, 0x01000000,
        0x00800000, 0x00400000, 0x00200000, 0x00100000,
        0x00080000, 0x00040000, 0x00020000, 0x00010000,
        0x00008000, 0x00004000, 0x00002000, 0x00001000,
        0x00000800, 0x00000400, 0x00000200, 0x00000100,
        0x00000080, 0x00000040, 0x00000020
        };


//
//	Release the directory !
//
void
CPageLock::ReleaseDirectoryShared()	{

	if( m_pDirectory ) {
		m_pDirectory->m_dirLock.ShareUnlock() ;
	}
	m_pDirectory = 0 ;
}


//
// Routine Description :
//
// 	This function will get shared access to the directory
// 	appropriate for the supplied hash value.  Once we have
// 	shared access to the directory, we will get a pointer
// 	to the directory entry for the specified Hash Value.
//
// Arguments :
//
// 	HashValue - The computed hash value which we want
// 		to find within the directory.
// 	lock - An HPAGELOCK structure which accumulates pointers
// 		to all the objects which are required to lock
// 		a single hash table entry.
//
// Return Value :
//
// 	A pointer to the DWORD Directory entry
//
inline PDWORD
CHashMap::LoadDirectoryPointerShared(
        DWORD HashValue,
		HPAGELOCK&	lock
        )
{
    ENTER("LoadDirectoryPointer")

	//
	//	Select a directory object !
	//

	DWORD	iDirectory = HashValue >> (32 - m_TopDirDepth) ;
	lock.AcquireDirectoryShared( m_pDirectory[iDirectory] ) ;
	return	lock.m_pDirectory->GetIndex( HashValue ) ;

} // LoadDirectoryPointerShared


//
// Routine Description :
//
// 	This function will get EXCLUSIVE access to the directory
// 	appropriate for the supplied hash value.  Once we have
// 	exclusive access to the directory, we will get a pointer
// 	to the directory entry for the specified Hash Value.
//
// Arguments :
//
// 	HashValue - The computed hash value which we want
// 		to find within the directory.
// 	lock - An HPAGELOCK structure which accumulates pointers
// 		to all the objects which are required to lock
// 		a single hash table entry.
//
// Return Value :
//
// 	A pointer to the DWORD Directory entry
//
inline	PDWORD
CHashMap::LoadDirectoryPointerExclusive(
		DWORD	HashValue,
		HPAGELOCK&	lock
        )
{

	DWORD	iDirectory = HashValue >> (32 - m_TopDirDepth) ;
	lock.AcquireDirectoryExclusive( m_pDirectory[iDirectory] ) ;
	return	lock.m_pDirectory->GetIndex( HashValue ) ;

} // LoadDirectoryPointerExclusive

//
// Routine Description :
//
// 	This function will split a directory, however we do it without
// 	grabbing any locks etc...  This is done only during boot-up when
// 	access to the hash tables are through a single thread.
// 	Additionally, we will initialize all the pointers to the Page !
//
// Arguments :
//
// 	MapPage -	The page we are currently examining, we need to
// 		grow the directory depth to accomodate this page.
//
// Return Value :
//
// 	TRUE if successfull, FALSE otherwise !
//
BOOL
CHashMap::I_SetDirectoryDepthAndPointers(
			PMAP_PAGE	MapPage,
			DWORD		PageNum
			)
{

	//
	//	Do some error checking on the page's data !
	//
	if( MapPage->PageDepth < m_TopDirDepth ||
		MapPage->PageDepth >= 32 ) {

		//
		//	Clearly bogus page depth - fail
		//
		SetLastError( ERROR_INTERNAL_DB_CORRUPTION ) ;
		return	FALSE ;

	}

	DWORD	iDirectory = MapPage->HashPrefix >> (MapPage->PageDepth - m_TopDirDepth) ;

	BOOL	fSuccess = m_pDirectory[iDirectory]->SetDirectoryDepth( MapPage->PageDepth ) ;

	if( fSuccess ) {

		fSuccess &= m_pDirectory[iDirectory]->SetDirectoryPointers( MapPage, PageNum ) ;

	}

	_ASSERT(	!fSuccess ||
				m_pDirectory[iDirectory]->IsValidPageEntry( MapPage, PageNum, iDirectory ) ) ;

	return	fSuccess ;
}


CHashMap::CHashMap()
{

	ENTER("CHashMap::CHashMap");

	// Initialize() marks this as active later on...
	m_active = FALSE;

    // initialize crc table used for hashing
    CRCInit();

	// initialize critical sections
	InitializeCriticalSection( &m_PageAllocator ) ;

    // initialize member variables
	m_fCleanInitialize = FALSE;
	m_TopDirDepth = 0 ;
    m_dirDepth = NUM_TOP_DIR_BITS;
    m_pageEntryThreshold = 0;
    m_pageMemThreshold = 0;
	m_fNoBuffering = FALSE ;
    m_hFile = INVALID_HANDLE_VALUE;
    m_hFileMapping = NULL;

	//
	//	The maximum number of pages should start out
	//	same as the number of CDirectory objects - we can't have
	//	two CDirectory objects referencing the same page, ever !
	//
    //m_maxPages = (1 << m_TopDirDepth) + 1 ;

    m_headPage = NULL;
	m_UpdateLock = 0 ;
    m_initialPageDepth = NUM_TOP_DIR_BITS ;
    m_nPagesUsed = 0;
    m_nInsertions = 0;
    m_nEntries = 0;
    m_nDeletions = 0;
    m_nSearches = 0;
    m_nDupInserts = 0;
    m_nPageSplits = 0;
    m_nDirExpansions = 0;
    m_nTableExpansions = 0;
	m_Fraction = 1 ;

	LEAVE;
} // CHashMap

CHashMap::~CHashMap(VOID)
{
	TraceFunctEnter( "CHashMap::~CHashMap" ) ;

    //
    // Shutdown the hash table
    //
    Shutdown( );

	//
	//	Delete the critical section we use for protecting
	//	the allocation of new pages
	//
	DeleteCriticalSection( &m_PageAllocator ) ;

	//
	//	Need to free resources in the page cache
	//
	m_pPageCache = 0 ;
}

//
// Routine Description:
//
//   This routine shuts down the hash table.
//
// Arguments:
//
//   fLocksHeld - TRUE if the dir locks are held,
// 		if this is FALSE we should grab the locks ourself !
//
// Return Value:
//
//     TRUE, if shutdown is successful.
//     FALSE, otherwise.
//
VOID
CHashMap::Shutdown(BOOL	fLocksHeld)
{
    ENTER("Shutdown")

	//
	//	Make the service inactive !!
	//
    if ( !m_active )
    {
        _ASSERT( m_hFile == INVALID_HANDLE_VALUE );
        return;
    }

    //
    // Save statistics
    //
    FlushHeaderStats( TRUE );

	//
	//	Should we try to save our directory structures !
	//
	if( m_active && m_fCleanInitialize ) {

		//
		//	Save the directory !
		//

		//
		//	Determine the name of the file we would save the directory in !
		//
		HANDLE	hDirectoryFile = INVALID_HANDLE_VALUE ;
		char	szDirFile[MAX_PATH] ;

		//
		//	Try to build the filename of the file holding the directory !
		//
		ZeroMemory(szDirFile, sizeof(szDirFile) ) ;
		lstrcpy( szDirFile, m_hashFileName ) ;
		char	*pchDot = strrchr( szDirFile, '.' ) ;

		if( pchDot && strchr( pchDot, '\\' ) == 0 ) {

			lstrcpy( pchDot, ".hdr" ) ;

			hDirectoryFile = CreateFile(
											szDirFile,
											GENERIC_READ | GENERIC_WRITE,
											0,
											0,
											CREATE_ALWAYS,
											FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
											INVALID_HANDLE_VALUE ) ;


		}

		//
		//	We were able to open a file where we think the directory information
		//	will be saved - lets try to read in the directory !!!
		//
		if( hDirectoryFile != INVALID_HANDLE_VALUE ) {

			DWORD	cbWrite = 0 ;

			//
			//	Keep Track of whether we need to delete the file due to failure !
			//
			BOOL	fDirectoryInit = FALSE ;

			//
			//	We save the hash table header info into the directory file so that
			//	we can double check that we have the right file when opening it up !!!
			//
			if( WriteFile(	hDirectoryFile,
						(LPVOID)m_headPage,
						sizeof( *m_headPage ),
						&cbWrite,
						0 ) )	{

				//
				//	Assume that everything will succeed now !
				//
				fDirectoryInit = TRUE ;

				//
				//	Looks good ! lets set up our directories !
				//
				DWORD	cb = 0 ;
				for( DWORD i=0; (i < DWORD(1<<m_TopDirDepth)) && fDirectoryInit ; i++ ) {
					fDirectoryInit &=
						m_pDirectory[i]->SaveDirectoryInfo( hDirectoryFile, cb ) ;
				}
			}
			_VERIFY( CloseHandle( hDirectoryFile ) ) ;

			//
			//	If we successfully read the directory file - DELETE it !!!
			//	This prevents us from ever mistakenly reading a directory file
			//	which is not up to date with the hash tables !
			//

			if( !fDirectoryInit )
				_VERIFY( DeleteFile( szDirFile ) ) ;
		}

	}

	if( m_pPageCache && m_hFile != INVALID_HANDLE_VALUE ) {
		m_pPageCache->FlushFileFromCache( m_hFile ) ;
	}

    //
    // Destroy mapping
    //
    I_DestroyPageMapping( );

	//
	// Delete directory objects !
	//
	DWORD i;
	for( i=0; i < DWORD(1<<m_TopDirDepth); i++ ) {
		delete m_pDirectory[i] ;
		m_pDirectory[i] = NULL ;
	}

	XDELETE m_dirLock;
	m_dirLock = NULL;

    //
    // We are not active
    //
    m_active = FALSE;

    LEAVE
    return;
} // Shutdown


//
// Routine Description:
//
//     This routine acquires a critical section
//
// Arguments:
//
//     DirEntry - The directory entry to protect
//
// Return Value:
//
//     A handle to the lock.  This handle should be used for
//     ReleaseLock.
//
inline	PMAP_PAGE
CHashMap::AcquireLockSetShared(
                IN DWORD PageNumber,
				OUT	HPAGELOCK&	lock,
				IN	BOOL		fDropDirectory
                )


{

	return	m_pPageCache->AcquireCachePageShared( m_hFile, PageNumber, m_Fraction, lock, fDropDirectory ) ;
} // AcquireLockSetShared

inline	PMAP_PAGE
CHashMap::AcquireLockSetExclusive(
                IN DWORD PageNumber,
				OUT	HPAGELOCK&	lock,
				BOOL	fDropDirectory
                )

/*++

Routine Description:

    This routine acquires a critical section

Arguments:

    DirEntry - The directory entry to protect

Return Value:

    A handle to the lock.  This handle should be used for
    ReleaseLock.

--*/

{

	return	m_pPageCache->AcquireCachePageExclusive( m_hFile, PageNumber, m_Fraction, lock, fDropDirectory ) ;

} // AcquireLockSetExclusve

inline	BOOL
CHashMap::AddLockSetExclusive(
                IN DWORD PageNumber,
				OUT	HPAGELOCK&	lock
                )

/*++

Routine Description:

    This routine acquires a critical section

Arguments:

    DirEntry - The directory entry to protect

Return Value:

    A handle to the lock.  This handle should be used for
    ReleaseLock.

--*/

{

	_ASSERT( lock.m_pPageSecondary == 0 ) ;

	return	m_pPageCache->AddCachePageExclusive( m_hFile, PageNumber, m_Fraction, lock ) ;

} // AcquireLockSetExclusve




    //
    // releases both the page lock and the backup lock
    //

inline	VOID
CHashMap::ReleasePageShared(
						PMAP_PAGE	page,
						HPAGELOCK&	hLock
						)		{
	CPageCache::ReleasePageShared( page, hLock ) ;
	ReleaseBackupLockShared() ;
}

inline	VOID
CHashMap::ReleasePageExclusive(
						PMAP_PAGE	page,
						HPAGELOCK&	hLock
						)	{
	CPageCache::ReleasePageExclusive( page, hLock ) ;
	ReleaseBackupLockShared() ;
}


//
// Routine Description:
//
//     This routine compacts the leaf page.  It goes through the delete
//     list and collapses it.
//
//     *** Assumes DirLock is held exclusive OR Page lock is held ***
//
// Arguments:
//
// 	HLock - The lock used to grab the page !
//     MapPage - Page to be compressed.
//
// Return Value:
//
//     TRUE, if page compacted
//     FALSE, otherwise
//
BOOL
CHashMap::CompactPage(
			IN HPAGELOCK&	HLock,
            IN PMAP_PAGE MapPage
            )
{
    SHORT offsetValue;

    //
    // used to do the move
    //

    DWORD srcOffset;
    WORD entrySize = 0;
    DWORD bytesToMove;

    PDELENTRYHEADER entry;
    WORD ptr;
    WORD nextPtr;

    DebugTraceX(0, "Entering CompactPage. Page = %x\n", MapPage );

    //
    // return if there is nothing to compact
    //

    if ( (ptr = MapPage->DeleteList.Blink) == 0 )
    {

        _ASSERT(MapPage->FragmentedBytes == 0);
        return FALSE;
    }

    //
    // Scan the delete list and compact it
    //

    while ( ptr != 0 )
    {

        entry = (PDELENTRYHEADER)GET_ENTRY(MapPage,ptr);
        entrySize = entry->EntrySize;
        nextPtr = entry->Link.Blink;

        srcOffset = ptr + entrySize;
        bytesToMove = MapPage->NextFree - srcOffset;

        MoveMemory(
            (PVOID)entry,
            (PVOID)((PCHAR)MapPage + srcOffset),
            bytesToMove
            );

        MapPage->NextFree -= entrySize;

        //
        // adjust indices of other entries
        //

        for ( DWORD i = 0; i < MAX_LEAF_ENTRIES ; i++ )
        {

            offsetValue = MapPage->Offset[i];

            //
            // check if this is a deleted entry
            //

            if ( offsetValue > 0 )
            {

                //
                // Now adjust offsets that were affected by this move
                //

                if ( (WORD)offsetValue > ptr )
                {
                    MapPage->Offset[i] -= entrySize;
					_ASSERT(MapPage->Offset[i] > 0);
					_ASSERT(MapPage->Offset[i] <= HASH_PAGE_SIZE);
                }
            }
        }

        //
        // process next entry
        //

        ptr = nextPtr;
    }

    //
    // All done.
    //

    MapPage->FragmentedBytes = 0;
    MapPage->DeleteList.Flink = 0;
    MapPage->DeleteList.Blink = 0;

    FlushPage( HLock, MapPage );

    return TRUE;

} // CompactPage

//
// Routine Description:
//
//     This routine expands the directory by increasing the page depth.
//     The old directory is deleted and a new one created.
//
//     *** Assumes DirLock is held exclusive ***
//
// Arguments:
//
//     nBitsExpand - Number of bits to increment the Page depth with.
//
// Return Value:
//
//     TRUE, if expansion ok
//     FALSE, otherwise
//
BOOL
CHashMap::ExpandDirectory(
		IN HPAGELOCK&	hPageLock,
        IN WORD nBitsExpand
        )
{
    DWORD status = ERROR_SUCCESS ;

	_ASSERT( hPageLock.m_pDirectory != 0 ) ;
#ifdef	DEBUG
	_ASSERT( hPageLock.m_fExclusive ) ;
#endif

    IncrementDirExpandCount( );

	return	hPageLock.m_pDirectory->ExpandDirectory( WORD(nBitsExpand) ) ;
} // ExpandDirectory


//
// Routine Description:
//
//     This routine searches for an entry in the table
//     *** Assumes Page lock is held ***
//
// Arguments:
//
//     KeyString - key of the entry to delete
//     KeyLen - Length of the key
//     HashValue - Hash value of the key
//     MapPage - Page to search for entry
//     AvailIndex - Optional pointer to a DWORD which will contain the
//                 index to the first available slot if entry was
//                 not found.
//     MatchedIndex - Optional pointer to a DWORD which will contain the
//                 index to the entry.
//
// Return Value:
//
//     TRUE, if entry was found.
//     FALSE, otherwise.
//
BOOL
CHashMap::FindMapEntry(
				IN	const	IKeyInterface*	pIKey,
                IN	HASH_VALUE HashValue,
                IN	PMAP_PAGE MapPage,
				IN	const ISerialize*	pIEntryInterface,
                OUT PDWORD AvailIndex OPTIONAL,
                OUT PDWORD MatchedIndex OPTIONAL
                )

{
    DWORD curSearch;
    BOOL found = FALSE;
    INT delIndex = -1;

    if ( AvailIndex != NULL )
    {
        *AvailIndex = 0;
        (*AvailIndex)--;
    }

    //
    // Check if entry already exists
    //

    curSearch = GetLeafEntryIndex( HashValue );

    for ( DWORD i=0; i < MAX_LEAF_ENTRIES; i++ )
    {

        //
        // offset to the hash entry
        //

        SHORT entryOffset = MapPage->Offset[curSearch];

        //
        // if entry is unused and they are looking for a free entry, then
		// we are done
        //
        if (AvailIndex != NULL && entryOffset == 0)
        {
            //
            // if they are looking for a available entry and a deleted spot
			// is available, give that back, otherwise give them this entry.
            //
            if (delIndex < 0) *AvailIndex = curSearch;
			else *AvailIndex = delIndex;
            break;
        }

        //
        // skip deleted entries. Deleted entries are marked by setting the high bit
		// (thus they are negative in this compare)
        //
        if (entryOffset > 0) {
            //
            // see if this is what they are looking for
            //
		    PENTRYHEADER	entry;
    		entry = (PENTRYHEADER)GET_ENTRY(MapPage,entryOffset);

		    if ((entry->HashValue == HashValue) &&
				pIKey->CompareKeys( entry->Data )	)

//    		    (entry->KeyLen == KeyLen) &&
//        		(memcmp(entry->Key, Key, KeyLen) == 0) )

			{
                found = TRUE;
                break;
            }
        } else if ( delIndex < 0 ) {
            //
            // if this is a deleted entry and we haven't found one yet, then
			// remember where this one was
            //
            delIndex = curSearch;
        }

        //
        // Do linear probing p=1
        //

        curSearch = (curSearch + 1) % MAX_LEAF_ENTRIES;
    }

    //
    // set the out params.
    //

    if ( found ) {

        //
        // return the out params if specified
        //

        if ( MatchedIndex != NULL ) {
            *MatchedIndex = curSearch;
        }
    }

    return found;

} // FindMapEntry

//
// Routine Description:
//
//     this routine inserts or updates entries in a hashmap
//
// Arguments:
//
//     KeyString - MessageId of the entry to be searched
//     KeyLen - Length of the message id
//	   pHashEntry - pointer to the hash entry information
//     bUpdate - updates a map entry with new data
//
// Return Value:
//
//     ERROR_SUCCESS, Insert successful
//     ERROR_ALREADY_EXISTS, duplicate
//     ERROR_NOT_ENOUGH_MEMORY - Not able to insert entry because of resource
//         problems.
//
BOOL
CHashMap::InsertOrUpdateMapEntry(
                const	IKeyInterface	*pIKey,
				const	ISerialize		*pHashEntry,
				BOOL	bUpdate,
                BOOL    fDirtyOnly
                )
{
    PENTRYHEADER	entry;
    DWORD curSearch;
    DWORD status = ERROR_SUCCESS;
    HASH_VALUE HashValue = pIKey->Hash();
    PMAP_PAGE mapPage;
    BOOL splitPage = FALSE;
	BOOL fInsertComplete = FALSE, fFirstTime = TRUE;
	HPAGELOCK HLock;

    ENTER("InsertOrUpdateMapEntry")

	_ASSERT(pHashEntry != NULL);

	//
    // lock the page
    //
	mapPage = GetPageExclusive(HashValue, HLock);
	if (!mapPage) {
		SetLastError(ERROR_SERVICE_NOT_ACTIVE);
		LEAVE
		return FALSE;
	}

	//
	// if they wanted to update then remove the current entry
	//
	if (bUpdate) {
		if (FindMapEntry(pIKey, HashValue, mapPage, pHashEntry, NULL, &curSearch)) {
			// delete the entry (this is copied from the deletion portion
			// of LookupMapEntry().  search for SIMILAR1).
			DWORD entryOffset = mapPage->Offset[curSearch];
			I_DoAuxDeleteEntry(mapPage, entryOffset);
			LinkDeletedEntry(mapPage, entryOffset);
			mapPage->Offset[curSearch] |= OFFSET_FLAG_DELETED;
			mapPage->ActualCount--;
			IncrementDeleteCount();
		} else {
			ReleasePageShared(mapPage, HLock);
	        SetLastError(ERROR_FILE_NOT_FOUND);
			LEAVE;
			return FALSE;
		}
	}

	//
	// loop until we've found an error or we've had a successful insert
	//
	while (!fInsertComplete && status == ERROR_SUCCESS) {
		BOOL bFound;

		if (fFirstTime) {
			// the page is locked above, we don't need to lock here
			fFirstTime = FALSE;
		} else {
			//
    		// lock the page
    		//
			mapPage = GetPageExclusive(HashValue, HLock);
			if (!mapPage) {
				status = ERROR_SERVICE_NOT_ACTIVE;
				continue;
			}
		}

		//
		// see if the entry already exists
		//
		splitPage = FALSE;
		bFound = FindMapEntry(pIKey, HashValue, mapPage, pHashEntry, &curSearch,
			NULL);

	    if (!bFound) {
			//
			// the entry didn't already exist, lets insert it
			//
			DWORD entrySize = GetEntrySize(pIKey, pHashEntry);

	        if (curSearch == (DWORD)-1) {
				//
				// we can't add any more entries, we need to split the page
				//
	            splitPage = TRUE;
	            DebugTrace(0,"Split: Can't add anymore entries\n");
	            SetPageFlag( mapPage, HLock, PAGE_FLAG_SPLIT_IN_PROGRESS );
	        } else {
				//
				// add the entry
				//
	        	if ((entry = (PENTRYHEADER) ReuseDeletedSpace(mapPage,
											HLock, entrySize)) == NULL)
	        	{
		            //
		            // No delete space available, use the next free list
		            //
		            if ( GetBytesAvailable( mapPage ) < entrySize )
		            {
						//
						// not enough memory available, force a split
						//
		                splitPage = TRUE;
						entry = NULL;
		                DebugTrace(0,"Split: Cannot fit %d\n", entrySize);
		                SetPageFlag(mapPage, HLock, PAGE_FLAG_SPLIT_IN_PROGRESS);
		            } else {
						entry = (PENTRYHEADER)GET_ENTRY(mapPage, mapPage->NextFree);
			            mapPage->NextFree += (WORD)entrySize;
			        }
				}

				//
				// we found space to insert it, lets go for it.
				//
				if (entry) {
	        		//
			        // Update the map page header
			        //
	    		    if (mapPage->Offset[curSearch] == 0) {
			            //
			            // if this is a new entry, update the entry count
	    		        //
	        		    mapPage->EntryCount++;
	        		}

			        mapPage->Offset[curSearch] = (WORD)((PCHAR)entry - (PCHAR)mapPage);
					_ASSERT(mapPage->Offset[curSearch] > 0);
					_ASSERT(mapPage->Offset[curSearch] < HASH_PAGE_SIZE);
			        mapPage->ActualCount++;

			        //
			        // Initialized the entry data
	    		    //
	        		entry->HashValue = HashValue;
			        entry->EntrySize = (WORD)entrySize;

					LPBYTE	pbEntry = pIKey->Serialize(	entry->Data ) ;

					pHashEntry->Serialize( pbEntry ) ;

			        //entry->KeyLen = (WORD)KeyLen;
					//CopyMemory(entry->Key, Key, KeyLen);
					//pHashEntry->SerializeToPointer(entry->Key + entry->KeyLen);


					//
					//	Let derived classes do any 'extras'
					//

					I_DoAuxInsertEntry(	mapPage, mapPage->Offset[curSearch] ) ;

			        //
			        // Make sure everything gets written out
	    		    //

			        FlushPage( HLock, mapPage, fDirtyOnly );

					//
					// mark that we added them
					//
					fInsertComplete = TRUE;

			        //
	    		    // See if we need to compact pages
	        		//
			        if (mapPage->FragmentedBytes > FRAG_THRESHOLD) {
	    		        DebugTrace( 0, "Compact: Frag %d\n", mapPage->FragmentedBytes );
	        		    CompactPage( HLock, mapPage );
	        		}

			        //
			        // See if we need to split
			        //
			        if (
					  (GetBytesAvailable( mapPage ) < LEAF_SPACE_THRESHOLD) ||
			          (mapPage->EntryCount > LEAF_ENTRYCOUNT_THRESHOLD))
			        {

			            DebugTrace(0,"Split: Entries %d Space left %d\n",
			                    mapPage->EntryCount, GetBytesAvailable( mapPage ) );
			            splitPage = TRUE;
			            SetPageFlag(mapPage, HLock,
							PAGE_FLAG_SPLIT_IN_PROGRESS );
			        }
				} // if (entry)
			} // could add entry

			ReleasePageShared(mapPage, HLock);

			//
			// we need to split and add again
			//
			if (splitPage) {
				BOOL expandHash;

				//
				// lock the page exclusive
				//
        		mapPage = GetDirAndPageExclusive( HashValue, HLock );
		        if (!mapPage) {
        		    status = ERROR_SERVICE_NOT_ACTIVE;
		        }

				//
				// do the split
				//
		        if (!SplitPage(mapPage, HLock, expandHash)) {
                	//
	                // No more disk space
	                //
	                status = ERROR_DISK_FULL;
        		}
		        ReleasePageExclusive( mapPage, HLock );
    		}
	    } // wasn't in hash table already
	    else
	    {
			//
			// the page already exists
			//
	        IncrementDupInsertCount( );
	        status = ERROR_ALREADY_EXISTS;
			ReleasePageShared(mapPage, HLock);
	    }
	} // while split

	if (status == ERROR_SUCCESS) {
		IncrementInsertCount();
		UPDATE_HEADER_STATS();
	}

	SetLastError(status);
	LEAVE

	return status == ERROR_SUCCESS;
} // I_InsertMapEntry

//
// Routine Description:
//
//     This routine grabs the DirLock resource shared,
//     then acquires the page's lock shared as well,
//     and returns a pointer to the page.
//
// Arguments:
//
//     DirEntry - The directory entry to protect
//     hLock - A handle to the lock.  This handle should be used for
//         ReleaseLock.
//
// Return Value:
//
//     Pointer to the page.
//
PMAP_PAGE
CHashMap::GetDirAndPageShared(
                IN HASH_VALUE HashValue,
                OUT HPAGELOCK& hLock
                )
{
    DWORD pageNum;
    PDWORD dirEntry;
    PMAP_PAGE mapPage = 0;
    PDWORD dirPtr = NULL;
    DWORD curView = (DWORD)-1;

    //
    // Get the directory lock
    //
    AcquireBackupLockShared( );

    if ( m_active )
    {
        dirEntry = LoadDirectoryPointerShared( HashValue, hLock );
        if ( dirEntry != NULL )
        {
			pageNum = *dirEntry;
			mapPage = AcquireLockSetShared( pageNum, hLock, TRUE  );

#if 0
			//
			//	Check that the page we gets contains the hash value
			//	we are looking for.  the high mapPage->PageDepth bits of the
			//	Hash Value must be the same as the prefix !!!
			//
			_ASSERT(	mapPage == 0 ||
						((HashValue >> (32 - mapPage->PageDepth)) ^ mapPage->HashPrefix) == 0 ) ;
			_ASSERT(	mapPage == 0 ||
						hLock.m_pDirectory->IsValidPageEntry(
							mapPage,
							pageNum,
							(hLock.m_pDirectory - m_pDirectory[0]) ) ) ;
#endif
		}
    }

	if( mapPage == 0 )	{
		ReleaseBackupLockShared() ;
		hLock.ReleaseAllShared( mapPage ) ;
	}

    return mapPage;
} // GetDirAndPageShared

//
// Routine Description:
//
//     This routine grabs the DirLock resource shared,
//     then acquires the page's lock exclusive,
//     and returns a pointer to the page.
//
// Arguments:
//
//     DirEntry - The directory entry to protect
//     hLock - A handle to the lock.  This handle should be used for
//         ReleaseLock.
//
// Return Value:
//
//     Pointer to the page.
//
PMAP_PAGE
CHashMap::GetPageExclusive(
                IN HASH_VALUE HashValue,
                OUT HPAGELOCK& hLock
                )

{
    DWORD pageNum;
    PDWORD dirEntry;
    PMAP_PAGE mapPage = 0;
    PDWORD dirPtr = NULL;
    DWORD curView = (DWORD)-1;

    //
    // Get the directory lock
    //

    AcquireBackupLockShared( );

    if ( m_active )
    {
        dirEntry = LoadDirectoryPointerShared( HashValue, hLock );
        if ( dirEntry != NULL )
        {
			pageNum = *dirEntry;
			_ASSERT( m_headPage != 0 ) ;

			mapPage = AcquireLockSetExclusive( pageNum, hLock, TRUE  );

#if 0
			//
			//	Check that the page we gets contains the hash value
			//	we are looking for.  the high mapPage->PageDepth bits of the
			//	Hash Value must be the same as the prefix !!!
			//
			_ASSERT(	mapPage == 0 ||
						((HashValue >> (32 - mapPage->PageDepth)) ^ mapPage->HashPrefix) == 0 ) ;

			_ASSERT(	mapPage == 0 ||
						hLock.m_pDirectory->IsValidPageEntry(
							mapPage,
							pageNum,
							(hLock.m_pDirectory - m_pDirectory[0]) ) ) ;
#endif

		}

    }

	if( mapPage == 0 ) {
		hLock.ReleaseAllShared( mapPage ) ;
		ReleaseBackupLockShared() ;
	}

    return mapPage;

} // GetPageExclusive
//
// Routine Description:
//
//     This routine grabs the DirLock resource shared,
//     then acquires the page's lock exclusive,
//     and returns a pointer to the page.
//
// Arguments:
//
//     DirEntry - The directory entry to protect
//     hLock - A handle to the lock.  This handle should be used for
//         ReleaseLock.
//
// Return Value:
//
//     Pointer to the page.
//
BOOL
CHashMap::AddPageExclusive(
                IN DWORD	PageNum,
                OUT HPAGELOCK& hLock
                )

{
	return	AddLockSetExclusive( PageNum, hLock  );

} // AddPageExclusive

//
// Routine Description:
//
//     This routine grabs the DirLock resource exclusive,
//     then acquires the page's critical section,
//     and returns a pointer to the page.
//
// Arguments:
//
//     DirEntry - The directory entry to protect
//     hLock - A handle to the lock.  This handle should be used for
//         ReleaseLock.
//
// Return Value:
//
//     Pointer to the page.
//
PMAP_PAGE
CHashMap::GetDirAndPageExclusive(
                IN HASH_VALUE HashValue,
                OUT HPAGELOCK& hLock
                )

{
    DWORD pageNum;
    PDWORD dirEntry;
    PMAP_PAGE mapPage = 0;
    PDWORD dirPtr = NULL;
    DWORD curView = (DWORD)-1;

    //
    // Get the directory lock
    //

    AcquireBackupLockShared( );

    if ( m_active )
    {
        dirEntry = LoadDirectoryPointerExclusive( HashValue, hLock );
        if ( dirEntry != NULL )
        {
			pageNum = *dirEntry;
			_ASSERT( m_headPage != 0 ) ;

			mapPage = AcquireLockSetExclusive( pageNum, hLock, FALSE  );

#if 0
			//
			//	Check that the page we gets contains the hash value
			//	we are looking for.  the high mapPage->PageDepth bits of the
			//	Hash Value must be the same as the prefix !!!
			//
			_ASSERT(	mapPage == 0 ||
						((HashValue >> (32 - mapPage->PageDepth)) ^ mapPage->HashPrefix) == 0 ) ;

			_ASSERT(	mapPage == 0 ||
						hLock.m_pDirectory->IsValidPageEntry(
							mapPage,
							pageNum,
							(hLock.m_pDirectory - m_pDirectory[0]) ) ) ;
#endif

		}

    }

	if( mapPage == 0 ) {
		hLock.ReleaseAllExclusive( mapPage ) ;
		ReleaseBackupLockShared() ;
	}

    return mapPage;

} // GetDirAndPageExclusive

//
// Routine Description:
//
//     This routine grabs the DirLock resource shared,
//     then acquires the page's critical section,
//     and returns a pointer to the page.
//
// Arguments:
//
//     PageNumber - The page number to get the lock for
//     hLock - A handle to the lock.  This handle should be used for
//         ReleaseLock.
//
// Return Value:
//
//     Pointer to the page.
//
PMAP_PAGE
CHashMap::GetAndLockPageByNumber(
                IN DWORD PageNumber,
                OUT HPAGELOCK& hLock
                )

{
    PMAP_PAGE mapPage = 0;

    //
    // Get the directory lock
    //

    AcquireBackupLockShared( );

	//
	//	When Shutdown() calls FlushHeaderStats() in some error cases
	//	m_headPage could be zero - in which case we would return a
	//	mapPage as NULL without a call to release the lock we got through
	//	AcquireLockSet() !!
	//	So test m_headPage as well as m_active !!!
	//

    if ( m_active && m_headPage )
    {
        mapPage = AcquireLockSetExclusive( PageNumber, hLock, FALSE  );
    }
    else
    {
        DebugTraceX(0,"GetAndLockPageByNumber called while inactive\n");
    }

	if( mapPage == 0 )	{
		ReleaseBackupLockShared() ;
	}

    return mapPage;
} // GetAndLockPageByNumber

//
// Routine Description:
//
//     Acquire the page's critical section,
//     and returns a pointer to the page.
//
// 	***** Assume caller has Dir Lock held !  *********
//
// Arguments:
//
//     PageNumber - The page number to get the lock for
//     hLock - A handle to the lock.  This handle should be used for
//         ReleaseLock.
//
// Return Value:
//
//     Pointer to the page.
//
PMAP_PAGE
CHashMap::GetAndLockPageByNumberNoDirLock(
                IN DWORD PageNumber,
                OUT HPAGELOCK& hLock
                )

{
    PMAP_PAGE mapPage = NULL;

	//
	//	When Shutdown() calls FlushHeaderStats() in some error cases
	//	m_headPage could be zero - in which case we would return a
	//	mapPage as NULL without a call to release the lock we got through
	//	AcquireLockSet() !!
	//	So test m_headPage as well as m_active !!!
	//

    if ( m_active && m_headPage )
    {

        mapPage = AcquireLockSetExclusive( PageNumber, hLock, FALSE  );

    }
    else
    {
        DebugTraceX(0,"GetAndLockPageByNumber called while inactive\n");
    }
    return mapPage;
} // GetAndLockPageByNumberNoDirLock


BOOL
CHashMap::Initialize(
            IN LPCSTR HashFileName,
            IN DWORD Signature,
            IN DWORD MinimumFileSize,
			IN DWORD cPageEntry,
			IN DWORD cNumLocks,
			IN DWORD dwCheckFlags,
			IN HASH_FAILURE_PFN	HashFailurePfn,
			IN LPVOID	lpvFailureCallback,
			IN BOOL	fNoBuffering
            )	{

	CCACHEPTR	pCache = XNEW	CPageCache() ;
	if( pCache == 0 ) {
		SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
		return	FALSE ;
	}

	if( !pCache->Initialize(	cPageEntry, cNumLocks ) ) {
		return	FALSE ;
	}

	return	Initialize(	HashFileName,
						Signature,
						MinimumFileSize,
						1,
						pCache,
						dwCheckFlags,
						HashFailurePfn,
						lpvFailureCallback ) ;

}


DWORD
CHashMap::InitializeDirectories(
		WORD	cBitDepth
		) {
/*++

Routine Description :

	This function creates all of the necessary Directory objects !

Arguments :

	Number of bits to use to select a directory !

Returns :

	ERROR_SUCCESS if successfull - NT Error code otherwise !


--*/

    ENTER("InitializeDirectories")

	//
	//	Make sure we haven't been called already !
	//
	_ASSERT( m_TopDirDepth == cBitDepth ) ;

	if( cBitDepth > MAX_NUM_TOP_DIR_BITS ) {
		SetLastError( ERROR_INVALID_PARAMETER ) ;
		return	ERROR_INVALID_PARAMETER ;
	}

	m_TopDirDepth = cBitDepth ;

	DWORD i;
	for( i=0; i < DWORD(1<<m_TopDirDepth); i++ ) {
		m_pDirectory[i] = new CDirectory;
		if (m_pDirectory[i] == NULL) break;
		//
		//	Arbitrarily init the sub directory to 8 bits -
		//	so our directory as a whole has a depth of
		//	m_TopDirDepth + 8.
		//
		if( !m_pDirectory[i]->InitializeDirectory( m_TopDirDepth, 1 ) )	{
			break ;
		}
	}

	if( i!= DWORD(1<<m_TopDirDepth) ) {
		//
		//	Failed to initialize all the CDirectory objects - Bail out !
		//
		SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
		LEAVE
		return	ERROR_NOT_ENOUGH_MEMORY ;
	}
	return	ERROR_SUCCESS ;
}


//
// Routine Description:
//
//     This routine initializes the hash table.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE, if setup is successful.
//     FALSE, otherwise.
//
BOOL
CHashMap::Initialize(
        IN LPCSTR HashFileName,
        IN DWORD Signature,
        IN DWORD MinimumFileSize,
		IN DWORD Fraction,
		IN CCACHEPTR	pCache,
		IN DWORD dwCheckFlags,
		IN HASH_FAILURE_PFN	HashFailurePfn,
		IN LPVOID	lpvCallBack,
		IN BOOL	fNoBuffering
        )
{
    DWORD status;
    ENTER("Initialize")

	m_fNoBuffering = fNoBuffering ;

	if( Fraction == 0 ) {
		Fraction = 1 ;
	}
	m_Fraction = Fraction ;
	m_pPageCache = pCache ;

	m_dwPageCheckFlags = dwCheckFlags;

	m_dirLock = XNEW _RWLOCK;
	if (m_dirLock == NULL) {
		LEAVE
		return(FALSE);
	}

    DebugTrace( 0, "File %s MinFileSize %d\n", HashFileName, MinimumFileSize );

    if ( m_active )
    {
        DebugTrace( 0, "Routine called while active\n" );
        _ASSERT(FALSE);
        LEAVE
        return TRUE;
    }

	//
	//	Record call back information for giving fatal error
	//	notifications.
	//
	//BUGBUG
	m_HashFailurePfn = HashFailurePfn ;
	m_lpvHashFailureCallback = lpvCallBack ;

	//
	//	Initialize the many CDirectory objects
	//

#if 0
	DWORD i;
	for( i=0; i < (1<<m_TopDirDepth); i++ ) {
		m_pDirectory[i] = XNEW CDirectory;
		if (m_pDirectory[i] == NULL) break;
		//
		//	Arbitrarily init the sub directory to 8 bits -
		//	so our directory as a whole has a depth of
		//	m_TopDirDepth + 8.
		//
		if( !m_pDirectory[i]->InitializeDirectory( m_TopDirDepth, 1 ) )	{
			break ;
		}
	}

	if( i!= (1<<m_TopDirDepth) ) {
		//
		//	Failed to initialize all the CDirectory objects - Bail out !
		//
		SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
		LEAVE
		return	FALSE ;
	}
#endif


    //
    // Copy the name and signature
    //
    lstrcpy( m_hashFileName, HashFileName );
    m_HeadPageSignature = Signature;

    //
    // Set up the minimum file size
    //
    if ( MinimumFileSize < MIN_HASH_FILE_SIZE )
    {
        MinimumFileSize = MIN_HASH_FILE_SIZE;
    }

    m_maxPages = MinimumFileSize / HASH_PAGE_SIZE;

    status = I_BuildDirectory( TRUE );
    if ( status != ERROR_SUCCESS )
    {
        ErrorTrace( 0, "BuildDirectory failed with %d\n", status );
        SetLastError( status );
        LEAVE
        return FALSE;
    }

	m_fCleanInitialize = TRUE;

    m_active = TRUE;
    LEAVE
    return TRUE;
} // Initialize

//
// Routine Description:
//
//     This routine searches for a deleted entry that can be reused.
//     *** Assumes Page lock is held ***
//
// Arguments:
//
//     MapPage - Page to search for entry.
//     NeededEntrySize - Entry size requested.
//
// Return Value:
//
//     Pointer to the entry returned.
//     NULL, if no entry can be found.
//
PVOID
CHashMap::ReuseDeletedSpace(
            IN PMAP_PAGE MapPage,
			IN HPAGELOCK&	HLock,
            IN DWORD &NeededEntrySize
            )
{
    PCHAR entryPtr = NULL;
    PDELENTRYHEADER entry;

    WORD ptr;
    WORD entrySize;

    //
    // Walk the delete list and find the first fit.
    //

    ptr = MapPage->DeleteList.Flink;

    while ( ptr != 0 )
    {

        entry = (PDELENTRYHEADER)GET_ENTRY(MapPage,ptr);
        entrySize = entry->EntrySize;

        if ( entrySize >= NeededEntrySize )
        {

            DWORD diff;

            //
            // Found an entry
            //

            diff = entrySize - NeededEntrySize;

            if ( diff >= sizeof(DELENTRYHEADER) )
            {

                //
                // give the guy what it needs but maintain the header
                //

                entry->EntrySize -= (WORD)NeededEntrySize;
                entryPtr = (PCHAR)entry + diff;

            }
            else
            {

                //
                // whole entry has to go
                //

                entryPtr = (PCHAR)entry;
                if ( entry->Link.Blink == 0 )
                {
                    MapPage->DeleteList.Flink = entry->Link.Flink;
                }
                else
                {
                    PDELENTRYHEADER prevEntry;

                    prevEntry = (PDELENTRYHEADER)GET_ENTRY(MapPage,entry->Link.Blink);
                    prevEntry->Link.Flink = entry->Link.Flink;
                }

                //
                // Set the back link
                //

                if ( entry->Link.Flink == 0 )
                {
                    MapPage->DeleteList.Blink = entry->Link.Blink;
                }
                else
                {
                    PDELENTRYHEADER nextEntry;

                    nextEntry = (PDELENTRYHEADER)GET_ENTRY(MapPage,entry->Link.Flink);
                    nextEntry->Link.Blink = entry->Link.Blink;
                }

                NeededEntrySize = entrySize;
            }

            MapPage->FragmentedBytes -= (WORD)NeededEntrySize;

            FlushPage( HLock, MapPage );
            break;
        }
        ptr = entry->Link.Flink;
    }

    return (PVOID)entryPtr;

} //ReuseDeletedSpace


//
// Routine Description:
//
//     	This routine searches for the entry with the given Key
//
//		note that this routine has a lot of functionality.  with bDelete
//		set and pHashEntry set to NULL you can delete an entry.  With
//		pHashEntry set to NULL this will tell you if the hash table contains
//		an entry.
//
// Arguments:
//
//     	KeyString - Key of the entry to be searched
//	   	KeyLen - length of key
//     	pHashEntry - where to write the contents for this entry (NULL means
//					i don't care about the contents)
//     	bDelete - boolean saying if the entry should be deleted
//
// Return Value:
//
//     TRUE, entry is found.
//     FALSE, otherwise.
//
BOOL
CHashMap::LookupMapEntry(
                IN const	IKeyInterface*	pIKey,
				IN	ISerialize*				pHashEntry,
				IN	BOOL bDelete,
				IN	BOOL fDirtyOnly
                )
{
    BOOL found = TRUE;
    HASH_VALUE val;
    PMAP_PAGE mapPage;
    HPAGELOCK	hLock;
    DWORD status = ERROR_SUCCESS;
	DWORD curSearch;
	DWORD	cbRequired = 0 ;

	if( pIKey == 0 ) {
		SetLastError( ERROR_INVALID_PARAMETER ) ;
		return	FALSE ;
	}

    val = pIKey->Hash( );

    //
    // Lock the page
    //

	if (bDelete) mapPage = GetPageExclusive( val, hLock );
	else mapPage = GetDirAndPageShared( val, hLock );
    if ( !mapPage )
    {
        SetLastError(ERROR_SERVICE_NOT_ACTIVE);
        return FALSE;
    }

    //
    // Check if entry already exists
    //
    if ( FindMapEntry(
                pIKey,
                val,
                mapPage,
				pHashEntry,
                NULL,
                &curSearch
                ) )
	{
		DWORD entryOffset;

		entryOffset = mapPage->Offset[curSearch];

		//
		// they wanted the contents of the entry
		//
		if (pHashEntry) {
			PENTRYHEADER	entry;
			LPBYTE entryData;

			entry = (PENTRYHEADER)GET_ENTRY(mapPage, entryOffset);

			entryData = pIKey->EntryData( entry->Data ) ;
			if( 0==pHashEntry->Restore(entryData, cbRequired ) ) {
				ReleasePageShared( mapPage, hLock ) ;
				SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
				return	FALSE ;
			}
		}

		//
		// they wanted to delete it
		// (if this code is changed then the similar code in
		// InsertOrUpdateMapEntry has to be changed as well.  search for
		// SIMILAR1).
		//
		if (bDelete) {
	        //
	        // Let derive class do their private stuff
	        //
	        I_DoAuxDeleteEntry( mapPage, entryOffset );

	        //
	        // Link this into a chain
	        //
	        LinkDeletedEntry( mapPage, entryOffset );

	        //
	        // Set the delete bit.
	        //
	        mapPage->Offset[curSearch] |= OFFSET_FLAG_DELETED;
	        mapPage->ActualCount--;

	        //
	        // Flush
	        //
	        FlushPage( hLock, mapPage, fDirtyOnly );

	        IncrementDeleteCount( );
		}
	} else {
        found = FALSE;
        status = ERROR_FILE_NOT_FOUND;
    }

    //
    // Unlock
    //

    ReleasePageShared( mapPage, hLock );
    IncrementSearchCount( );

	if( !found )
		SetLastError( status ) ;

    return found;

} // LookupMapEntry

//
// Routine Description:
//
//     This routine splits a leaf page.
//
//     *** Exclusive DirLock assumed held ***
//
// Arguments:
//
//     OldPage - Page to split.
//     Expand - indicates whether the hash table needs to be expanded.
//
// Return Value:
//
//     TRUE, if split was successful
//     FALSE, otherwise.
//
BOOL
CHashMap::SplitPage(
            IN PMAP_PAGE OldPage,
			HPAGELOCK&	hLock,
            IN BOOL & Expand
            )
{

    PMAP_PAGE newPage;
    DWORD hashPrefix;
    SHORT offset;
    WORD newPageDepth;
    WORD oldPageDepth;
    DWORD offsetIndex;
    WORD tmpOffset[MAX_LEAF_ENTRIES];

    //
    // Do we need to split?
    //
    ENTER("SplitPage")
    DebugTrace( 0, "Splitting %x\n", OldPage );

    Expand = FALSE;
    if ( (OldPage->Flags & PAGE_FLAG_SPLIT_IN_PROGRESS) == 0 )
    {
        LEAVE
        return TRUE;
    }

	//
	//	Make sure the page depth stays reasonable !!
	//
	_ASSERT( OldPage->PageDepth <= 32 ) ;

    //
    // Update the hash prefix
    //
    oldPageDepth = OldPage->PageDepth;
    newPageDepth = OldPage->PageDepth + 1;

	DWORD	newPageNum = I_AllocatePageInFile(newPageDepth);

	if( newPageNum == INVALID_PAGE_NUM ) {

		SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
		return	FALSE ;
	}

	//
	//	Exclusively lock the new slot !
	//
	if( !AddPageExclusive( newPageNum, hLock ) ) {
		SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
		return	FALSE ;
	}

    //
    // if the new page depth is greater than the directory depth,
    // we need to expand the directory
    //

	hLock.m_pDirectory->SetDirectoryDepth( newPageDepth ) ;

    //
    // Update fields in the old page
    //
    OldPage->HashPrefix <<= 1;
    OldPage->PageDepth++;

    //
    // compute the hash prefix for the next
    //
    hashPrefix = (DWORD)(OldPage->HashPrefix | 0x1);

    //
    // Allocate and initialize a new page
    //
    //newPage = (PMAP_PAGE)
	//        ((PCHAR)m_headPage + (m_nPagesUsed * HASH_PAGE_SIZE));

	BytePage	page ;

	newPage = (PMAP_PAGE)&page ;

    I_InitializePage( newPage, hashPrefix, newPageDepth );

    //
    // All done.  Now, change links in the directory
    //
    I_SetDirectoryPointers( hLock, newPage,  newPageNum, (DWORD)-1 );

	//
	//	Release the lock on the directory !
	//
	hLock.ReleaseDirectoryExclusive() ;

    //
    // Copy the old offsets to a temp and clear them
    //
    CopyMemory(
        tmpOffset,
        OldPage->Offset,
        MAX_LEAF_ENTRIES * sizeof(WORD)
        );

    ZeroMemory( OldPage->Offset, MAX_LEAF_ENTRIES * sizeof(WORD) );
    OldPage->EntryCount = 0;
    OldPage->ActualCount = 0;

    //
    // Go through each entry and figure out where it belongs
    //
    for ( DWORD i = 0; i < MAX_LEAF_ENTRIES; i++ )
    {

        PENTRYHEADER entry;
        PCHAR destination;
        HASH_VALUE hash;

        //
        // See what this is and clear it
        //
        offset = tmpOffset[i];
        if ( offset <= 0 )
        {
            continue;
        }

        entry = (PENTRYHEADER)GET_ENTRY( OldPage, offset );
        hash = entry->HashValue;

        //
        // See which page this belongs
        //

        if ( !I_NextBitIsOne( hash, oldPageDepth ) )
        {

            //
            // Ok, this goes to the old page
            //
            offsetIndex = I_FindNextAvail( hash, OldPage );
            OldPage->Offset[offsetIndex] = offset;
			_ASSERT(OldPage->Offset[offsetIndex] > 0);
			_ASSERT(OldPage->Offset[offsetIndex] < HASH_PAGE_SIZE);
            OldPage->EntryCount++;

        }
        else
        {

            //PCHAR destination;

            //
            // new page resident
            //
            offsetIndex = I_FindNextAvail( hash, newPage );
            newPage->Offset[offsetIndex] = newPage->NextFree;
			_ASSERT(newPage->Offset[offsetIndex] > 0);
			_ASSERT(newPage->Offset[offsetIndex] < HASH_PAGE_SIZE);

            //
            // Copy to the next free list
            //
            destination = (PCHAR)GET_ENTRY(newPage,newPage->NextFree);
            newPage->NextFree += entry->EntrySize;
            newPage->EntryCount++;

            //
            // Move the bytes
            //
            CopyMemory( destination, (PCHAR)entry, entry->EntrySize );

            //
            // Do whatever the derived class needs to do
            //
            I_DoAuxPageSplit( OldPage, newPage, destination );

            //
            // Let derive class do their private stuff
            //
            I_DoAuxDeleteEntry( OldPage, offset );

            //
            // Delete this entry from the old list
            //
            LinkDeletedEntry( OldPage, offset );
        }
    }
    OldPage->ActualCount = OldPage->EntryCount;
    newPage->ActualCount = newPage->EntryCount;

    //
    // Compact the original page
    //
    (VOID)CompactPage( hLock, OldPage );

    //
    // Update statistics
    //
    //m_nPagesUsed++;
    //m_headPage->NumPages++;

    //
    // Clear the flag
    //
    OldPage->Flags &= (WORD)~PAGE_FLAG_SPLIT_IN_PROGRESS;

    IncrementSplitCount( );
    BOOL	fSuccess = FlushPage( hLock, OldPage );


	fSuccess &= RawPageWrite(
						m_hFile,
						page,
						newPageNum
						) ;
    LEAVE
    return fSuccess;

} // SplitPage

DWORD
CHashMap::I_BuildDirectory(
        IN BOOL SetupHash
        )
/*++

Routine Description:

    This routine builds the directory given a hash file.
    *** Assumes DirLock is held ***

Arguments:

    SetupHash - If TRUE, the hash table will be read and set up.
                If FALSE, the hash table is assumed to be set up.

Return Value:

    ERROR_SUCCESS - Everything went ok.
    Otherwise, the win32 error code.

--*/
{
    DWORD status;
    DWORD nPages;
    DWORD i;
    BOOL newTable = FALSE;
    ENTER("BuildDirectory")

	//
	//	BOOL to determine whether we need to read all of the pages
	//	in the hash table to rebuild the directory - assume that we will
	//	fail to open the directory file and will need to scan hash table pages.
	//
	BOOL	fDirectoryInit = FALSE ;

	//
	//	Determine the name of the file we would save the directory in !
	//
	HANDLE	hDirectoryFile = INVALID_HANDLE_VALUE ;
	char	szDirFile[MAX_PATH] ;
	LPVOID	lpvDirectory = 0 ;
	HANDLE	hMap = 0 ;
	DWORD	cbDirInfo = 0 ;

	//
	//	Try to build the filename of the file holding the directory !
	//
	BOOL	fValidDirectoryFile = FALSE ;
	ZeroMemory(szDirFile, sizeof(szDirFile) ) ;
	lstrcpy( szDirFile, m_hashFileName ) ;
	char	*pchDot = strrchr( szDirFile, '.' ) ;

	if( !pchDot ) {
		status = ERROR_INVALID_PARAMETER ;
		LEAVE
		return(status);
	}

	if( strchr( pchDot, '\\' ) == 0 ) {
		lstrcpy( pchDot, ".hdr" ) ;
		fValidDirectoryFile = TRUE ;
	}


    //
    // open and map the hash file
    //

    if ( SetupHash ) {

        status = I_SetupHashFile( newTable );
        if ( status != ERROR_SUCCESS ) {
            goto error;
        }

		if( newTable ) {
			m_initialPageDepth = NUM_TOP_DIR_BITS ;
			m_TopDirDepth = m_initialPageDepth ;
			m_maxPages = (1<<m_TopDirDepth) + 1 ;
		}
		status = InitializeDirectories( m_initialPageDepth ) ;
		if( status != ERROR_SUCCESS ) {
			goto error ;
		}

        //
        // If this is a new hash file, then set it up with defaults
        //

        if ( newTable ) {

            status = I_InitializeHashFile( );
            if ( status != ERROR_SUCCESS ) {
                goto error;
            }

			//
			//	If we are creating a new hash table, then any old files
			//	lying around with Directory information (.hdr files) are
			//	useless.  Get rid of it.  This mostly comes up in nntpbld.exe
			//

			if( fValidDirectoryFile ) {
				DeleteFile( szDirFile ) ;
			}

        }	else	{


			if( fValidDirectoryFile ) {

				hDirectoryFile = CreateFile(
												szDirFile,
												GENERIC_READ | GENERIC_WRITE,
												0,
												0,
												OPEN_EXISTING,
												FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
												INVALID_HANDLE_VALUE ) ;

				if( hDirectoryFile != INVALID_HANDLE_VALUE ) {

					cbDirInfo = GetFileSize( hDirectoryFile, 0 ) ;

					hMap = CreateFileMapping(	hDirectoryFile,
												NULL,
												PAGE_READONLY,
												0,
												0,
												0 ) ;

					if( hMap != 0 ) {

						lpvDirectory = MapViewOfFile(	hMap,
														FILE_MAP_READ,
														0,
														0,
														0 ) ;

					}

					if( lpvDirectory == 0 ) {

						if( hMap != 0 )	{
							_VERIFY( CloseHandle( hMap ) ) ;
						}

						if( hDirectoryFile != INVALID_HANDLE_VALUE ) {
							_VERIFY( CloseHandle( hDirectoryFile ) ) ;
						}

					}

				}
			}

			//
			//	We were able to open a file where we think the directory information
			//	will be saved - lets try to read in the directory !!!
			//
			if( lpvDirectory != 0 ) {

				HASH_RESERVED_PAGE	*hashCheckPage = (HASH_RESERVED_PAGE*)lpvDirectory ;
				DWORD	cbRead = 0 ;

				//
				//	We save the hash table header info into the directory file so that
				//	we can double check that we have the right file when opening it up !!!
				//

				if( CompareReservedPage( hashCheckPage, m_headPage ) ) {

					cbRead += sizeof( *hashCheckPage ) ;
					BYTE*	lpbData = (BYTE*)lpvDirectory ;

					//
					//	Time for some optimism !
					//
					fDirectoryInit = TRUE ;

					//
					//	Looks good ! lets set up our directories !
					//
					DWORD	cb = 0 ;
					for( DWORD	i=0; (i < DWORD(1<<m_TopDirDepth)) && fDirectoryInit ; i++ ) {

						cb = 0 ;
						fDirectoryInit &=
							m_pDirectory[i]->LoadDirectoryInfo( (LPVOID)(lpbData+cbRead), cbDirInfo - cbRead, cb ) ;
						if( fDirectoryInit ) {
							fDirectoryInit &= m_pDirectory[i]->IsDirectoryInitGood( m_nPagesUsed ) ;
						}
						cbRead += cb ;

					}

					//
					//	If a failure occurs we need to restore the directories
					//	to a pristine state - so spin through a quick loop to
					//	reset the directories !
					//	We do this so that we can make a second attempt to
					//	correctly initialize the directories by examining the
					//	raw hash table pages !
					//
					if( !fDirectoryInit ) {
						for( DWORD i=0; (i < DWORD(1<<m_TopDirDepth)); i++ ) {
							m_pDirectory[i]->Reset() ;
						}
					}
				}
				_VERIFY( UnmapViewOfFile( lpvDirectory ) ) ;
				_VERIFY( CloseHandle( hMap ) ) ;
				_VERIFY( CloseHandle( hDirectoryFile ) ) ;

				//
				//	If we successfully read the directory file - DELETE it !!!
				//	This prevents us from ever mistakenly reading a directory file
				//	which is not up to date with the hash tables !
				//

				if( fDirectoryInit )
					_VERIFY( DeleteFile( szDirFile ) ) ;
			}

			if( !fDirectoryInit ) 	{

				//
				// Initialize the links.  Here we go through all the pages and update the directory
				// links. We do IOs in 64K chunks for better disk throughput.
				//

				PMAP_PAGE curPage;
				nPages = m_nPagesUsed;

                DWORD nPagesLeft = nPages-1;
                DWORD cNumPagesPerIo = min( nPagesLeft, NUM_PAGES_PER_IO ) ;
                DWORD cStartPage = nPages - nPagesLeft;

                DWORD       NumIOs = (nPagesLeft / cNumPagesPerIo);
                if( (nPagesLeft % cNumPagesPerIo) != 0 ) NumIOs++;

                //  Alloc a set of pages used for each IO
                LPBYTE lpbPages = (LPBYTE)VirtualAlloc(
                                            0,
				    			            HASH_PAGE_SIZE * cNumPagesPerIo,
								            MEM_COMMIT | MEM_TOP_DOWN,
								            PAGE_READWRITE
								            ) ;

                if( lpbPages == NULL ) {
                    status = GetLastError() ;
                    goto error ;
                }

				for ( i = 1; i <= NumIOs; i++ )
				{
			        //
        			// Read 256K chunks at a time into the virtual alloc'd buffer.
                    // Reads < 256K are issued if the NumPagesPerIo for this iteration
                    // is < 256K/PageSize.
			        //
                    _ASSERT( nPagesLeft > 0 );
                    BytePage* pPage = (BytePage*)lpbPages;
					if( !RawPageRead(
                                m_hFile,
                                *pPage,
                                cStartPage,
                                cNumPagesPerIo ) )
                    {
                        _ASSERT( lpbPages );
                   		_VERIFY( VirtualFree((LPVOID)lpbPages,0,MEM_RELEASE ) ) ;
						status = GetLastError() ;
						goto	error ;
					}

                    for( DWORD j = 0; j < cNumPagesPerIo; j++ ) {
                        curPage = (PMAP_PAGE) (lpbPages+(HASH_PAGE_SIZE*j));
    					//
	    				// call verify page on this page with some checking
		    			// to make sure that its okay
			    		//
				    	if ((m_dwPageCheckFlags & HASH_VFLAG_PAGE_BASIC_CHECKS) &&
					        !VerifyPage(curPage, m_dwPageCheckFlags, NULL, NULL, NULL))
					    {
                              _ASSERT( lpbPages );
                   		    _VERIFY( VirtualFree((LPVOID)lpbPages,0,MEM_RELEASE ) ) ;
						    status = ERROR_INTERNAL_DB_CORRUPTION;
						    goto error;
					    }
                    }

                    for( j = 0; j < cNumPagesPerIo; j++ ) {
                        curPage = (PMAP_PAGE) (lpbPages+(HASH_PAGE_SIZE*j));
    					//
	    				//	Make sure the directory is of sufficient depth to deal with this
		    			//	page we are scanning !
			    		//

					    if ( !I_SetDirectoryDepthAndPointers( curPage, cStartPage+j  ) )
					    {
                            _ASSERT( lpbPages );
                   		    _VERIFY( VirtualFree((LPVOID)lpbPages,0,MEM_RELEASE ) ) ;
						    status = ERROR_INTERNAL_DB_CORRUPTION ;
						    goto	error ;
					    }
                    }

                    //  adjust num pages left and figure out the next I/O size
                    cStartPage += cNumPagesPerIo;
                    nPagesLeft -= cNumPagesPerIo;
                    cNumPagesPerIo = min( nPagesLeft, NUM_PAGES_PER_IO );
				}

                //  Free up the pages
                _ASSERT( nPagesLeft == 0 );
                _ASSERT( lpbPages );
           		_VERIFY( VirtualFree((LPVOID)lpbPages,0,MEM_RELEASE ) ) ;
                lpbPages = NULL;
			}
		}
	}

	//
	//	Check that the directory is fully initialized, we want to make sure that no
	//	Directory entries were left unitialized !
	//
	for( i=0; i<DWORD(1<<m_TopDirDepth); i++ ) {

		if( !m_pDirectory[i]->IsDirectoryInitGood( m_nPagesUsed ) ) {
			status = ERROR_INTERNAL_DB_CORRUPTION ;
			goto	error ;
		}
	}

    m_headPage->DirDepth = m_dirDepth;
	//FlushViewOfFile( (LPVOID)m_headPage, HASH_PAGE_SIZE ) ;


    LEAVE
    return ERROR_SUCCESS;

error:

	_ASSERT( GetLastError() != ERROR_NOT_ENOUGH_MEMORY ) ;

#if 0
    NntpLogEventEx(
        NNTP_EVENT_HASH_SHUTDOWN,
        0,
        (const CHAR **)NULL,
        status
        );
#endif

    I_DestroyPageMapping( );
    LEAVE
    return(status);

} // I_BuildDirectory

//
// Routine Description :
//
// 	This function gets a page out of the hash table for us.
//
// Arguments :
//
// 	None.
//
// Return Value :
//
// 	INVALID_PAGE_NUM in failure,
// 	A page number otherwise !
//
DWORD
CHashMap::I_AllocatePageInFile(WORD Depth) {
	TraceFunctEnter("CHashMap::I_AllocatePageInFile");

	DWORD	PageReturn = INVALID_PAGE_NUM ;

	EnterCriticalSection( &m_PageAllocator ) ;

	if( m_nPagesUsed >= m_maxPages ||
		(m_maxPages - m_nPagesUsed) < DEF_PAGE_RESERVE ) {

		DWORD	numPages = m_maxPages + DEF_PAGE_INCREMENT ;
		LARGE_INTEGER	liOffset ;
		liOffset.QuadPart = numPages ;
		liOffset.QuadPart *= HASH_PAGE_SIZE ;

		//
		//	We need to grow the hash table file !!!
		//

		BOOL fSuccess = SetFilePointer(
										m_hFile,
										liOffset.LowPart,
										&liOffset.HighPart,
										FILE_BEGIN ) != 0xFFFFFFFF ||
						GetLastError() == NO_ERROR ;


		if( !fSuccess ||
			!SetEndOfFile( m_hFile ) )	{

			numPages = m_maxPages + DEF_PAGE_RESERVE ;
            liOffset.QuadPart = numPages ;
			liOffset.QuadPart *= HASH_PAGE_SIZE ;

			//
			//	We need to grow the hash table file !!!
			//

			BOOL fSuccess = SetFilePointer(
											m_hFile,
											liOffset.LowPart,
											&liOffset.HighPart,
											FILE_BEGIN ) != 0xFFFFFFFF ||
							GetLastError() == NO_ERROR ;

			if( !fSuccess ||
				!SetEndOfFile( m_hFile ) )	{

				numPages = m_maxPages ;

			}

			//
			//	Call the failure notification function -
			//	we are running low on disk space and were not able to
			//	reserve as many system pages as we'd like !!!
			//

			if(	m_HashFailurePfn ) {
				m_HashFailurePfn( m_lpvHashFailureCallback, FALSE ) ;
			}
		}

		m_maxPages = numPages ;
	}

	if( m_nPagesUsed < m_maxPages ) {
		PageReturn = m_nPagesUsed ++ ;
		m_headPage->NumPages++;
		if (Depth > m_dirDepth) {
			m_dirDepth = Depth;
			m_headPage->DirDepth = Depth;
		}
		_ASSERT( m_headPage->NumPages == m_nPagesUsed ) ;

	}
	LeaveCriticalSection( &m_PageAllocator ) ;

	TraceFunctLeave();
	return (PageReturn );

}	// I_AllocatePageInFile

//
// Routine Description:
//
//     This routine cleans up the page mapping
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
VOID
CHashMap::I_DestroyPageMapping(
                            VOID
                            )
{
    //
    // Destroy the view
    //
    if ( m_headPage )
    {

        //
        // Mark table as inactive
        //
        m_headPage->TableActive = FALSE;

        //
        // Flush the hash table
        //
        (VOID)FlushViewOfFile( m_headPage, 0 );

        //
        // Close the view
        //
        (VOID) UnmapViewOfFile( m_headPage );
        m_headPage = NULL;
    }

    //
    // Destroy the file mapping
    //
    if ( m_hFileMapping )
    {

        _VERIFY( CloseHandle( m_hFileMapping ) );
        m_hFileMapping = NULL;
    }

    //
    // Close the file
    //
    if ( m_hFile != INVALID_HANDLE_VALUE )
    {
        _VERIFY( CloseHandle( m_hFile ) );
        m_hFile = INVALID_HANDLE_VALUE;
    }

    return;

} // I_DestroyPageMapping

//
// Routine Description:
//
//     This routine searches for the next available slot in the index
//     table for a given hash value.
//     *** Assumes Page lock is held ***
//
// Arguments:
//
//     HashValue - Hash value used to do the search
//     MapPage - Page to do the search
//
// Return Value:
//
//     Location of the slot.
//     0xffffffff if not successful.
//
DWORD
CHashMap::I_FindNextAvail(
                IN HASH_VALUE HashValue,
                IN PMAP_PAGE MapPage
                )
{
    DWORD curSearch;

    //
    // Check if entry already exists
    //

    curSearch = GetLeafEntryIndex( HashValue );

    for ( DWORD i=0; i < MAX_LEAF_ENTRIES; i++ ) {

        //
        // if entry is unused, then we're done.
        //

        if ( MapPage->Offset[curSearch] == 0 ) {

            //
            // if a deleted spot is available, give that back instead
            //

            return(curSearch);
        }

        //
        // Do linear probing p=1
        //

        curSearch = (curSearch + 1) % MAX_LEAF_ENTRIES;
    }

    ErrorTraceX(0,"FindNextAvail: No available entries\n");
    return ((DWORD)-1);

} // I_FindNextAvail

//
// Routine Description:
//
//     This routine writes the temporary stat values into the header.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
VOID
CHashMap::FlushHeaderStats(
        BOOL	fLockHeld
        )
{
    //
    // Lock the header page
    //

	if( InterlockedExchange( &m_UpdateLock, 1 ) == 0 ) {

		m_headPage->InsertionCount += m_nInsertions;
		m_headPage->DeletionCount += m_nDeletions;
		m_headPage->SearchCount += m_nSearches;
		m_headPage->PageSplits += m_nPageSplits;
		m_headPage->DirExpansions += m_nDirExpansions;
		m_headPage->TableExpansions += m_nTableExpansions;
		m_headPage->DupInserts += m_nDupInserts;

		FlushViewOfFile( (LPVOID)m_headPage, HASH_PAGE_SIZE ) ;

		//
		// Clear stats
		//

		m_nInsertions = 0;
		m_nDeletions = 0;
		m_nSearches = 0;
		m_nDupInserts = 0;
		m_nPageSplits = 0;
		m_nDirExpansions = 0;
		m_nTableExpansions = 0;

		m_UpdateLock = 0 ;

	}

} // FlushHeaderStats

//
// Routine Description:
//
//     Initializes a brand new hash file.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     ERROR_SUCCESS - Initialization is ok.
//
DWORD
CHashMap::I_InitializeHashFile(
        VOID
        )
{

    PMAP_PAGE curPage;
    DWORD nPages;
    DWORD dwError = ERROR_SUCCESS;

    ENTER("InitializeHashFile")

    //
    // set up the reserved page
    //

    ZeroMemory(m_headPage, HASH_PAGE_SIZE);
    m_headPage->Signature = m_HeadPageSignature;

    //
    // Allocate and initialize leaf pages.  Add 1 to the number of
    // pages to include the reserved page.
    //

    nPages = (1 << m_initialPageDepth) + 1;
    DWORD nPagesLeft = nPages-1;

    DWORD cNumPagesPerIo = min( nPagesLeft, NUM_PAGES_PER_IO ) ;
    DWORD cStartPage = nPages - nPagesLeft;

    DWORD       NumIOs = (nPagesLeft / cNumPagesPerIo);
    if( (nPagesLeft % cNumPagesPerIo) != 0 ) NumIOs++;

    LPBYTE lpbPages = (LPBYTE)VirtualAlloc(
                                    0,
									HASH_PAGE_SIZE * cNumPagesPerIo,
									MEM_COMMIT | MEM_TOP_DOWN,
									PAGE_READWRITE
									) ;

    if( lpbPages == NULL ) {
        ErrorTrace(0,"Failed to VirtualAlloc %d bytes: error is %d", HASH_PAGE_SIZE * cNumPagesPerIo, GetLastError() );
        return GetLastError();
    }

    for ( DWORD i = 1; i <= NumIOs;i++ )
    {
#if 0
		if( !RawPageRead(	m_hFile,page,i )  )	{
			return	GetLastError() ;
		}
#endif

        _ASSERT( nPagesLeft > 0 );

        //
        // initialize set of pages for this I/O
        //

        ZeroMemory( (LPVOID)lpbPages, HASH_PAGE_SIZE * cNumPagesPerIo );
        for( DWORD j = 0; j < cNumPagesPerIo; j++ ) {
            curPage = (PMAP_PAGE) (lpbPages+(HASH_PAGE_SIZE*j));
            I_InitializePage( curPage, cStartPage-1 + j, m_initialPageDepth );
        }

        //
        // write next set of pages
        //

        BytePage* pPage = (BytePage*)lpbPages;
		if( !RawPageWrite(	m_hFile,
							*pPage,
							cStartPage,
                            cNumPagesPerIo ) ) {
			dwError = GetLastError();
            goto Exit;
		}

        for( j = 0; j < cNumPagesPerIo; j++ ) {
            curPage = (PMAP_PAGE) (lpbPages+(HASH_PAGE_SIZE*j));
    		if( !I_SetDirectoryDepthAndPointers( curPage, cStartPage + j ) ) {
	    		SetLastError( ERROR_INTERNAL_DB_CORRUPTION ) ;
                dwError = GetLastError();
                goto Exit;
		    }
        }

        //  adjust num pages left and figure out the next I/O size
        cStartPage += cNumPagesPerIo;
        nPagesLeft -= cNumPagesPerIo;
        cNumPagesPerIo = min( nPagesLeft, NUM_PAGES_PER_IO );
    }

    _ASSERT( nPagesLeft == 0 );

    //
    // Indicate that everything is set.
    //
    m_nPagesUsed = nPages;
    m_headPage->NumPages = nPages;
    m_headPage->Initialized = TRUE;
    m_headPage->TableActive = TRUE;
    m_headPage->VersionNumber = HASH_VERSION_NUMBER;

    //
    // Make sure everything gets written out
    //
    (VOID)FlushViewOfFile( m_headPage, 0 );

Exit:

	if( lpbPages != 0 ) {

		_VERIFY( VirtualFree(
							(LPVOID)lpbPages,
							0,
							MEM_RELEASE
							) ) ;
    } else {
        _ASSERT( FALSE );
    }

    LEAVE
    return dwError;

} // I_InitializeHashFile

typedef unsigned __int64 QWORD;
#define QWORD_MULTIPLE(x) (((x+sizeof(QWORD)-1)/sizeof(QWORD))*sizeof(QWORD))

//
// Routine Description:
//
//     This routine initializes a new page.
//
// Arguments:
//
//     MapPage - Page to link the deleted entry
//     HashPrefix - HashPrefix for this page.
//     PageDepth - The page depth for this page.
//
// Return Value:
//
//     None.
//
VOID
CHashMap::I_InitializePage(
                IN PMAP_PAGE MapPage,
                IN DWORD HashPrefix,
                IN DWORD PageDepth
                )
{
    DebugTraceX(0,"Initializing page %x prefix %x depth %d\n",
        MapPage,HashPrefix,PageDepth);

    MapPage->HashPrefix = HashPrefix;
    MapPage->PageDepth = (BYTE)PageDepth;
    MapPage->EntryCount = 0;
    MapPage->ActualCount = 0;
    MapPage->FragmentedBytes = 0;
    MapPage->DeleteList.Flink = 0;
    MapPage->DeleteList.Blink = 0;
    MapPage->Reserved1 = 0;
    MapPage->Reserved2 = 0;
    MapPage->Reserved3 = 0;
    MapPage->Reserved4 = 0;
    MapPage->LastFree = HASH_PAGE_SIZE;
#ifdef _WIN64
    MapPage->NextFree = QWORD_MULTIPLE( (WORD)((DWORD_PTR)&MapPage->StartEntries - (DWORD_PTR)MapPage) );
#else
    MapPage->NextFree = (WORD)((DWORD_PTR)&MapPage->StartEntries - (DWORD_PTR)MapPage);
#endif

    ZeroMemory(
        MapPage->Offset,
        MAX_LEAF_ENTRIES * sizeof(WORD)
        );

    return;

} // I_InitializePage


//
// Routine Description:
//
//     This routine links a deleted entry to the DeleteList.
//
// Arguments:
//
//     MapPage - Page to link the deleted entry
//     Offset - Offset of the deleted entry from the start of page
//
// Return Value:
//
//     None.
//
VOID
CHashMap::LinkDeletedEntry(
                IN PMAP_PAGE MapPage,
                IN DWORD Offset
                )
{

    PDELENTRYHEADER delEntry;
    WORD    linkOffset;
    WORD    ptr;
    DWORD   bytesDeleted;
    BOOL    merged = FALSE;

    //
    // Insert deleted entry into deleted list.  List is sorted
    // in lower to higher offset order.
    //

    delEntry = (PDELENTRYHEADER)GET_ENTRY(MapPage,Offset);
    delEntry->Reserved = DELETE_SIGNATURE;
    delEntry->Link.Blink = 0;
    bytesDeleted = delEntry->EntrySize;

    linkOffset = (WORD)((PCHAR)delEntry - (PCHAR)MapPage);

    ptr = MapPage->DeleteList.Flink;

    while ( ptr != 0 ) {

        PDELENTRYHEADER curEntry;

        curEntry = (PDELENTRYHEADER)GET_ENTRY(MapPage,ptr);

        if ( ptr > linkOffset ) {

            WORD prevPtr;
            PDELENTRYHEADER prevEntry;

            //
            // See if we can coalese with the previous block
            //

            if ( (prevPtr = curEntry->Link.Blink) != 0 ) {

                prevEntry = (PDELENTRYHEADER)GET_ENTRY(MapPage,prevPtr);

                if ( (prevPtr + prevEntry->EntrySize) == linkOffset ) {

                    //
                    // Let's volt in...
                    //

                    prevEntry->EntrySize += delEntry->EntrySize;
                    merged = TRUE;

                    delEntry = prevEntry;
                    linkOffset = prevPtr;
                }
            }

            //
            // see if we can coalese with the next block
            //

            if ( (delEntry->EntrySize + linkOffset) == ptr ) {

                WORD nextPtr;

                //
                // OK. Do the merge.  This means deleting the current entry.
                //

                delEntry->EntrySize += curEntry->EntrySize;

                //
                // Set the links of the next node
                //

                if ( (nextPtr = curEntry->Link.Flink) == 0 ) {
                    MapPage->DeleteList.Blink = linkOffset;
                } else {
                    PDELENTRYHEADER nextEntry;

                    nextEntry = (PDELENTRYHEADER)GET_ENTRY(MapPage,nextPtr);
                    nextEntry->Link.Blink = linkOffset;
                }

                delEntry->Link.Flink = nextPtr;

                //
                // Set the links of the previous node
                //

                if ( !merged ) {

                    if ( prevPtr == 0 ) {

                        MapPage->DeleteList.Flink = linkOffset;

                    } else {

                        prevEntry->Link.Flink = linkOffset;
                    }

                    merged = TRUE;
                }
            }

            //
            // if the deleted entry still exists, then insert it to the list.
            //

            if ( !merged ) {

                if ( prevPtr != 0 ) {

                    delEntry->Link.Flink = ptr;
                    prevEntry->Link.Flink = linkOffset;

                } else {

                    delEntry->Link.Flink = ptr;
                    MapPage->DeleteList.Flink = linkOffset;
                }

                //
                // Set the back link
                //

                curEntry->Link.Blink = linkOffset;
                merged = TRUE;
            }

            break;
        }

        delEntry->Link.Blink = ptr;
        ptr = curEntry->Link.Flink;
    }

    //
    // This must be the last entry in the list.
    //

    if ( !merged ) {

        WORD prevPtr;
        PDELENTRYHEADER prevEntry;

        prevPtr = delEntry->Link.Blink;
        if ( prevPtr != 0 ) {

            //PDELENTRYHEADER prevEntry;
            prevEntry = (PDELENTRYHEADER)GET_ENTRY(MapPage,prevPtr);

            //
            // Can we merge?
            //

            if ( (prevPtr + prevEntry->EntrySize) == linkOffset ) {
                prevEntry->EntrySize += delEntry->EntrySize;
                linkOffset = prevPtr;
            } else {

                delEntry->Link.Flink = prevEntry->Link.Flink;
                prevEntry->Link.Flink = linkOffset;
            }

        } else {

            delEntry->Link.Flink = 0;
            MapPage->DeleteList.Flink = linkOffset;
        }

        MapPage->DeleteList.Blink = linkOffset;
    }

    //
    // Update the fragmented value
    //

    MapPage->FragmentedBytes += (WORD)bytesDeleted;

    return;

} // LinkDeletedEntry

//
// Routine Description:
//
//     This routine sets the directory pointer for a new page.
//
// Arguments:
//
// 	hLock - The HPAGELOCK object which is holding
// 		the lock for the directory we want to modify.
// 		The lock must be exclusive !
// 	MapPage - Page to link the deleted entry.
//     PageNumber - Page number of the new page.
//
// Return Value:
//
//     None.
//
BOOL
CHashMap::I_SetDirectoryPointers(
					IN HPAGELOCK&	hLock,
                    IN PMAP_PAGE MapPage,
                    IN DWORD PageNumber,
                    IN DWORD MaxDirEntries
                    )
{
    PDWORD dirPtr = NULL;
    DWORD curView = (DWORD)-1;

	_ASSERT( hLock.m_pDirectory != 0 ) ;
#ifdef	DEBUG
	_ASSERT( hLock.m_fExclusive ) ;
#endif

	BOOL	fReturn = hLock.m_pDirectory->SetDirectoryPointers(	MapPage,
																PageNumber ) ;

	_ASSERT( hLock.m_pDirectory->IsValidPageEntry(
									MapPage,
									PageNumber,
									(DWORD)(hLock.m_pDirectory - m_pDirectory[0]) ) ) ;

	return	fReturn ;
} // I_SetDirectoryPointers

//
// Routine Description:
//
//     This routine initializes a new hash file
//
// Arguments:
//
//     NewTable - Returns whether this is a new hash file or not.
//
// Return Value:
//
//     ERROR_SUCCESS - File successfully initialized.
//     ERROR_INTERNAL_DB_CORRUPTION - File is corrupted.
//     Win32 error on failure.
//
DWORD
CHashMap::I_SetupHashFile(
        IN BOOL &NewTable
        )
{

    DWORD fileSize = 0;
    DWORD status;

    ENTER("SetupHashFile")

    //
    // Open the hash file
    //

	DWORD	FileFlags = FILE_FLAG_OVERLAPPED | FILE_FLAG_WRITE_THROUGH | FILE_FLAG_RANDOM_ACCESS ;
	if( m_fNoBuffering ) {

		char	szVolume[MAX_PATH] ;
		strncpy( szVolume, m_hashFileName, sizeof( szVolume ) ) ;
		for(  char *pch=szVolume; *pch != '\\' && *pch != '\0'; pch++ ) ;
		if( *pch == '\\' ) pch++ ;
		*pch = '\0' ;

		DWORD	SectorsPerCluster = 0 ;
		DWORD	BytesPerSector = 0 ;
		DWORD	NumberOfFreeClusters = 0 ;
		DWORD	TotalNumberOfClusters = 0 ;
		if( GetDiskFreeSpace(	szVolume,
								&SectorsPerCluster,
								&BytesPerSector,
								&NumberOfFreeClusters,
								&TotalNumberOfClusters
								) )	{

			if( BytesPerSector > HASH_PAGE_SIZE ) {

				return	ERROR_INVALID_FLAGS ;

			}	else	if( (HASH_PAGE_SIZE % BytesPerSector) != 0 ) {

				return	ERROR_INVALID_FLAGS ;

			}

		}	else	{
			return	GetLastError() ;
		}
		FileFlags |= FILE_FLAG_NO_BUFFERING ;
	}

    NewTable = FALSE;
    m_hFile = CreateFile(
                        m_hashFileName,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ, // for MakeBackup()
                        NULL,
                        OPEN_ALWAYS,
                        FileFlags,
                        NULL
                        );

    if ( m_hFile == INVALID_HANDLE_VALUE )
    {
        status = GetLastError();
        ErrorTrace( 0, "Error %d in CreateFile.\n", status );
        goto error;
    }

    //
    // Did the file exist before? If not, then this is a new hash table.
    //

    if ( GetLastError() != ERROR_ALREADY_EXISTS )
    {
        DebugTrace( 0, "New Table detected\n" );
        NewTable = TRUE;

		//
		//	Get the initial file size correct !
		//
		if ( (DWORD)-1 == SetFilePointer( m_hFile, m_maxPages * HASH_PAGE_SIZE, NULL, FILE_BEGIN )
		   || !SetEndOfFile( m_hFile )
		   )
		{
			status = GetLastError();
			FatalTrace( 0, "Error %d in SetupHashFile size of file\n", status );
			goto error;
		}


    }
    else
    {

        //
        // Get the size of the file.  This will tell us how many pages are currently filled.
        //

        fileSize = GetFileSize( m_hFile, NULL );
        if ( fileSize == 0xffffffff )
        {
            status = GetLastError();
            ErrorTrace(0,"Error %d in GetFileSize\n",status);
            goto error;
        }

        //
        // Make sure the file size is a multiple of a page
        //

        if ( (fileSize % HASH_PAGE_SIZE) != 0 )
        {

            //
            // Not a page multiple! Corrupted!
            //

            ErrorTrace(0,"File size(%d) is not page multiple.\n",fileSize);
            status = ERROR_INTERNAL_DB_CORRUPTION;
            goto error;
        }

        m_nPagesUsed = fileSize / HASH_PAGE_SIZE;

        //
        // make sure our file is not less than the actual. That is,
        // when we map the file into memory, we want to see all of it.
        //
        if ( m_maxPages < m_nPagesUsed )
        {
            m_maxPages = m_nPagesUsed;
        }
    }

    //
    // Create File Mapping
    //

    m_hFileMapping = CreateFileMapping(
                                m_hFile,
                                NULL,
                                PAGE_READWRITE,
                                0,
                                HASH_PAGE_SIZE,
                                NULL
                                );

    if ( m_hFileMapping == NULL )
    {
        status = GetLastError();
        ErrorTrace( 0, "Error %d in CreateFileMapping\n", status );
        goto error;
    }

    //
    // create our view
    //

    m_headPage = (PHASH_RESERVED_PAGE)MapViewOfFileEx(
                                            m_hFileMapping,
                                            FILE_MAP_ALL_ACCESS,
                                            0,                      // offset high
                                            0,                      // offset low
                                            HASH_PAGE_SIZE,                      // bytes to map
                                            NULL                    // base address
                                            );

    if ( m_headPage == NULL )
    {
        status = GetLastError();
        ErrorTrace( 0, "Error %d in MapViewOfFile\n", status );
        goto error;
    }

    if ( !NewTable ) {

        //
        // See if this is a valid reserved page
        //

        if ( m_headPage->Signature != m_HeadPageSignature )
        {

            //
            // Wrong signature
            //

            ErrorTrace( 0, "Invalid Signature %x expected %x\n",
                m_headPage->Signature, m_HeadPageSignature );
            status = ERROR_INTERNAL_DB_CORRUPTION;
            goto error;
        }

        //
        // Correct version number?
        //

        if ( m_headPage->VersionNumber != HASH_VERSION_NUMBER_MCIS10 &&
				m_headPage->VersionNumber != HASH_VERSION_NUMBER )
        {

            ErrorTrace( 0, "Invalid Version %x expected %x\n",
                m_headPage->VersionNumber, HASH_VERSION_NUMBER );

            status = ERROR_INTERNAL_DB_CORRUPTION;
            goto error;
        }

		if( m_headPage->VersionNumber == HASH_VERSION_NUMBER_MCIS10 ) {
			m_initialPageDepth = 6 ;
		}	else	{
			m_initialPageDepth = 9 ;
		}
		m_TopDirDepth = m_initialPageDepth ;


        if ( !m_headPage->Initialized )
        {
            //
            // Not initialized !
            //
            ErrorTrace( 0, "Existing file uninitialized! Assuming new.\n" );
            NewTable = TRUE;
        }

        if ( m_headPage->NumPages > m_nPagesUsed )
        {
            //
            // Bad count. Corrupt file.
            //
            ErrorTrace( 0, "NumPages in Header(%d) more than actual(%d)\n",
                m_headPage->NumPages, m_nPagesUsed );

            status = ERROR_INTERNAL_DB_CORRUPTION;
            goto error;
        }

		if( m_headPage->NumPages < DWORD(1<<m_TopDirDepth) )
		{
			//
			//	For our two tier directory we must have at least one page per 2nd tier directory !
			//	This file is too small to support that, so there's a problem !
			//
			ErrorTrace( 0, "NumPages in Header(%d) less than %d\n",
					m_headPage->NumPages, DWORD(1<<m_TopDirDepth) ) ;

			status = ERROR_INTERNAL_DB_CORRUPTION ;
			goto	error ;
		}

        m_nPagesUsed = m_headPage->NumPages;

        if ( m_dirDepth < m_headPage->DirDepth )
        {
            m_dirDepth = (WORD)m_headPage->DirDepth;
        }

        //
        // Get the number of articles in the table
        //
        m_nEntries = m_headPage->InsertionCount - m_headPage->DeletionCount;
    }

    //m_hashPages = (PMAP_PAGE)((PCHAR)m_headPage + HASH_PAGE_SIZE);

    LEAVE
    return ERROR_SUCCESS;

error:

    I_DestroyPageMapping( );
    LEAVE
    return status;

} // I_SetupHashFile

//
// get the size of a hash entry
//
DWORD CHashMap::GetEntrySize(	const	ISerialize*	pIKey,
								const	ISerialize*	pHashEntry
								) {

	DWORD dwSize = sizeof(ENTRYHEADER) -	// fixed head
		 			1	+					// less 1 for Key[1]
		 			pIKey->Size() +			// Space for Key
		 			pHashEntry->Size();		// application entry length

	// Now make this size aligned to sizeof(SIZE_T)
	if (dwSize % sizeof(SIZE_T))
		dwSize += sizeof(SIZE_T) - (dwSize % sizeof(SIZE_T));

	return dwSize;
}

//
// a generic hash function (can be overridden)
//
DWORD CHashMap::Hash(LPBYTE Key, DWORD KeyLength) {
	return CRCHash(Key, KeyLength);
}

DWORD CHashMap::CRCHash(const BYTE *	Key, DWORD KeyLength) {
	return ::CRCHash(Key, KeyLength);
}

void CHashMap::CRCInit(void) {
	::crcinit();
}

//
// --- GetFirstMapEntry/GetNextMapEntry code ---
//

//
// inputs:  none
// outputs: pKey       - the key for this entry
//          pKeyLen    - the length of the key
//          pHashEntry - memory for the hash entry to be written into
// returns: TRUE/FALSE if error
//
BOOL CHashMap::GetFirstMapEntry(	IKeyInterface*	pIKey,
									DWORD&			cbKeyRequired,
									ISerialize*		pHashEntry,
									DWORD&			cbEntryRequired,
									CHashWalkContext*	pHashWalkContext,
									IEnumInterface*	pEnum
									)
{
	pHashWalkContext->m_iCurrentPage = 0;
	pHashWalkContext->m_iPageEntry = 0;
	return GetNextMapEntry(pIKey, cbKeyRequired, pHashEntry, cbEntryRequired, pHashWalkContext, pEnum );
}

BOOL CHashMap::GetNextMapEntry(	IKeyInterface*		pIKey,
								DWORD&				cbKeyRequired,
								ISerialize*			pHashEntry,
								DWORD&				cbEntryRequired,
								CHashWalkContext*	pHashWalkContext,
								IEnumInterface*		pEnum )
{
	TraceFunctEnter("CHashMap::GetNextMapEntry");

	PMAP_PAGE pPage = (PMAP_PAGE) pHashWalkContext->m_pPageBuf;
	SHORT iEntryOffset;
	PENTRYHEADER	pEntry = 0 ;
	DWORD	iPageEntry = pHashWalkContext->m_iPageEntry ;

	//
	// search for the next undeleted entry.  deleted entries are
	// marked by having their high bit set (and thus being
	// negative).
	//
	do {
		_ASSERT(pHashWalkContext->m_iPageEntry <= MAX_LEAF_ENTRIES);
		//
		// if we are done with this page then load the next page with data
		// page 0 has directory info, so we want to skip it
		//
		if (pHashWalkContext->m_iCurrentPage == 0 ||
		    iPageEntry == MAX_LEAF_ENTRIES)
		{
			do {
				pHashWalkContext->m_iCurrentPage++;
				if (!LoadWalkPage(pHashWalkContext)) {
					DebugTrace(0, "walk: no more items in hashmap");
					SetLastError(ERROR_NO_MORE_ITEMS);
					TraceFunctLeave();
					return FALSE;
				}
				iPageEntry = pHashWalkContext->m_iPageEntry ;
			} while ((pPage->ActualCount == 0)  ||
					(pEnum && !pEnum->ExaminePage( pPage )) );
		}

		iEntryOffset = pPage->Offset[iPageEntry] ;
		iPageEntry++;

		//
		// get the key, keylen, and data for the user
		//
		pEntry = (PENTRYHEADER) GET_ENTRY(pPage, iEntryOffset);

	} while ((iEntryOffset <= 0)||
			(pEnum && !pEnum->ExamineEntry( pPage, &pEntry->Data[0] )) );

	DebugTrace(0, "found entry, m_iCurrentPage = %lu, m_iPageEntry == %lu",
		pHashWalkContext->m_iCurrentPage, pHashWalkContext->m_iPageEntry);

	LPBYTE	pbEntry  = pIKey->Restore( pEntry->Data, cbKeyRequired ) ;
	if( pbEntry ) {
		if (pHashEntry->Restore( pbEntry, cbEntryRequired ) != 0 ) {
			pHashWalkContext->m_iPageEntry = iPageEntry ;
			return	TRUE ;
		}
	}
	SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
	return FALSE ;
}

//
// load a page from the hashmap into the walk buffers
//
BOOL CHashMap::LoadWalkPage(CHashWalkContext *pHashWalkContext) {
	TraceFunctEnter("CHashMap::LoadWalkPage");

	PMAP_PAGE mapPage;
	HPAGELOCK hLock;
	DWORD iPageNum = pHashWalkContext->m_iCurrentPage;

	if (iPageNum >= m_nPagesUsed) return FALSE;

	DebugTrace(0, "loading page %lu", iPageNum);

	mapPage = (PMAP_PAGE) GetAndLockPageByNumber(iPageNum, hLock);

	if (mapPage == NULL) {
		//_ASSERT(FALSE);	This _Assert can occur during shutdown of the hashtable !
		TraceFunctLeave();
		return FALSE;
	}

	memcpy(pHashWalkContext->m_pPageBuf, mapPage, HASH_PAGE_SIZE);
	pHashWalkContext->m_iPageEntry = 0;

	ReleasePageShared(mapPage, hLock);

	TraceFunctLeave();
	return TRUE;
}

//
// make a backup copy of the hashmap.  this locks the entire hashmap, syncs
// up the memory mapped portions, and makes a backup copy
//
BOOL CHashMap::MakeBackup(LPCSTR pszBackupFilename) {
	TraceFunctEnter("CHashMap::MakeBackup");

	BOOL rc = FALSE;

	if (m_active) {
		AcquireBackupLockExclusive();
		if (FlushViewOfFile((LPVOID)m_headPage, HASH_PAGE_SIZE)) {
			FlushFileBuffers(m_hFile);
			if (CopyFile(m_hashFileName, pszBackupFilename, FALSE)) {
				rc = TRUE;
			}
		}
		ReleaseBackupLockExclusive();
	}

	if (!rc) {
		DWORD ec = GetLastError();
		DebugTrace(0, "backup failed, error code = %lu", ec);
	}
	return(rc);
}

//
// hashmap.h doesn't have definations for class CShareLock, so these need to
// be local to hashmap.cpp.  If other files start needing to refer to them
// they can be moved to a header file or not made inline
//
inline VOID CHashMap::AcquireBackupLockShared() {
	m_dirLock->ShareLock();
}

inline VOID CHashMap::AcquireBackupLockExclusive() {
	m_dirLock->ExclusiveLock();
}

inline VOID CHashMap::ReleaseBackupLockShared() {
	m_dirLock->ShareUnlock();
}

inline VOID CHashMap::ReleaseBackupLockExclusive() {
	m_dirLock->ExclusiveUnlock();
}

DWORD
CalcNumPagesPerIO( DWORD nPages )
{
    //
    //  Figure out a good chunking factor ie num pages per I/O
    //  from the number of pages.
    //
    DWORD dwRem = -1;
    DWORD cNumPagesPerIo = 1;
    for( cNumPagesPerIo = NUM_PAGES_PER_IO*4;
            dwRem && cNumPagesPerIo > 1; cNumPagesPerIo /= 4 ) {
        dwRem = (nPages-1) % cNumPagesPerIo ;
        if( nPages-1 < cNumPagesPerIo ) dwRem = -1;
    }

    return cNumPagesPerIo;
}

BOOL
CHashMap::CompareReservedPage(  HASH_RESERVED_PAGE  *ppage1,
                                HASH_RESERVED_PAGE  *ppage2 )
/*++
Routine description:

    Compare to see if two HAS_RESERVED_PAGEs are virtually the same.
    By "virtually" it means we ignore the member TableActive

Arguments:

    Two pages to be compared

Return value:

    TRUE if they are virtually the same, FALSE otherwise
--*/
{
    TraceFunctEnter( "CHashMap::ComparereservedPage" );

    return (    ppage1->Signature == ppage2->Signature &&
                ppage1->VersionNumber == ppage2->VersionNumber &&
                ppage1->Initialized == ppage2->Initialized &&
                ppage1->NumPages == ppage2->NumPages &&
                ppage1->DirDepth == ppage2->DirDepth &&
                ppage1->InsertionCount == ppage2->InsertionCount &&
                ppage1->DeletionCount == ppage2->DeletionCount &&
                ppage1->SearchCount == ppage2->SearchCount &&
                ppage1->PageSplits == ppage2->PageSplits &&
                ppage1->DirExpansions == ppage1->DirExpansions &&
                ppage1->TableExpansions == ppage2->TableExpansions &&
                ppage1->DupInserts == ppage2->DupInserts );
}

#if 0
//
// Routine Description:
//
//     This routine builds the directory given a hash file.
//     *** Assumes DirLock is held ***
//
// Arguments:
//
//     SetupHash - If TRUE, the hash table will be read and set up.
//                 If FALSE, the hash table is assumed to be set up.
//
// Return Value:
//
//     ERROR_SUCCESS - Everything went ok.
//     Otherwise, the win32 error code.
//
DWORD
CHashMap::I_BuildDirectory(
        IN BOOL SetupHash
        )
{
    DWORD status;
    DWORD nPages;
    DWORD i;
    BOOL newTable = FALSE;
    PMAP_PAGE curPage;

    ENTER("BuildDirectory")

    //
    // open and map the hash file
    //

    if ( SetupHash ) {

        status = I_SetupHashFile( newTable );
        if ( status != ERROR_SUCCESS ) {
            goto error;
        }

        //
        // If this is a new hash file, then set it up with defaults
        //

        if ( newTable ) {

            status = I_InitializeHashFile( );
            if ( status != ERROR_SUCCESS ) {
                goto error;
            }
        }
    }

    m_headPage->DirDepth = m_dirDepth;
    //FlushPage( 0, m_headPage );
	FlushViewOfFile( (LPVOID)m_headPage, HASH_PAGE_SIZE ) ;

    //
    // Initialize the links.  Here we go through all the pages and update the directory
    // links
    //
	BytePage	page ;
    curPage = (PMAP_PAGE)&page ;
    nPages = m_nPagesUsed;

    for ( i = 1; i < nPages; i++ )
    {

        //
        // Set the pointers for this page
        //

		if( !RawPageRead( m_hFile, page, i ) ) {
			status = GetLastError() ;
			goto	error ;
		}

		//
		//	Make sure the directory is of sufficient depth to deal with this
		//	page we are scanning !
		//

		if ( !I_SetDirectoryDepthAndPointers( curPage, i ) )
		{
			status = ERROR_INTERNAL_DB_CORRUPTION ;
			goto	error ;
		}

		//
		// call verify page on this page with minimal checking to make sure
		// that its okay
		//
		if ((m_dwPageCheckFlags & HASH_VFLAG_PAGE_BASIC_CHECKS) &&
		    !VerifyPage(curPage, m_dwPageCheckFlags, NULL, NULL))
		{
			status = ERROR_INTERNAL_DB_CORRUPTION;
			goto error;
		}
    }

	//
	//	Check that the directory is fully initialized, we want to make sure that no
	//	Directory entries were left unitialized !
	//
	for( i=0; i<DWORD(1<<m_TopDirDepth); i++ ) {

		if( !m_pDirectory[i]->IsDirectoryInitGood() ) {
			status = ERROR_INTERNAL_DB_CORRUPTION ;
			goto	error ;
		}
	}

    LEAVE
    return ERROR_SUCCESS;

error:

	_ASSERT( GetLastError() != ERROR_NOT_ENOUGH_MEMORY ) ;

    I_DestroyPageMapping( );
    LEAVE
    return(status);

} // I_BuildDirectory

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\hashmap\src\pageent.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pageent.h

Abstract:

    This module contains class declarations/definitions for

        PageEntry

--*/

#ifndef _PAGEENT_
#define _PAGEENT_

#include "hashmap.h"
#include "directry.h"
#include <dbgtrace.h>

#define	INVALID_PAGE_NUM	0xFFFFFFFF

//
//	PageEntry - 
//
//	This class allows us to do our own management of 
//	reading and writing pages within a hash table, as well
//	as synchronizing access to the pages.
//
//	A large memory mapping would be preferable, however 
//	because we want to support hash tables that grow to 
//	extreme sizes (ie. a few gigabytes) we don't have sufficient
//	address space to do everything with a memory mapping.
//
//	So instead, we use PageEntry to help us manage 
//	the individual pages, reading and writing pages on demand.
//
class	PageEntry	{
public : 
	LPVOID				m_lpvPage ;
	DWORD				m_PageNum ;
	HANDLE				m_hFile ;
	//
	//	Keep track of whether we've made the page dirty !
	//
	BOOL				m_fDirty ;
	_RWLOCK				*m_pageLock;

	PageEntry() : 
		m_lpvPage( 0 ),
		m_PageNum( INVALID_PAGE_NUM ),
		m_pageLock( NULL ),
		m_hFile( INVALID_HANDLE_VALUE ), 
		m_fDirty( FALSE )	{
	}

	void *operator new(size_t size);
	void operator delete(void *p, size_t size);

	//
	// Set up the buffer to be used !
	//
	// Set our m_lpvPage pointer to point to the page we will use from now
	// on for Read'ing and Write'ing to the hash table.
	// This function must only be called once, and should only be called during
	// Initialization, so we will assume that it is safe to not bother grabbing
	// any locks.
	//
	void	InitializePage(LPVOID lpv, _RWLOCK	*pLock) { 
		m_lpvPage = lpv; 
		m_pageLock = pLock;
	}

	PMAP_PAGE
	AcquirePageShared(
				IN	HANDLE	hFile,
				IN	DWORD	PageNum,
				OUT	BOOL	&fShared,
				IN	class	CPageLock*	pPageLock,
				IN	BOOL	fDropDirectory
				);

	PMAP_PAGE
	AcquirePageExclusive(
				IN	HANDLE	hFile,
				IN	DWORD	PageNum,
				OUT	BOOL	&fShared,
				IN	class	CPageLock*	pPageLock,
				IN	BOOL	fDropDirectory
				);

	BOOL
	AcquireSlotExclusive(
				IN	HANDLE	hFile,
				IN	DWORD	PageNum,
				OUT	BOOL	&fShared
				) ;

	//
	//	Save a page back to the file	
	//	NOTE : entry must equal m_lpvPage !!
	//	You must call AcquirePageAndLock before 
	//	calling FlushPage !
	//
	BOOL		FlushPage( 
					HANDLE	hFile,
					LPVOID	entry, 
					BOOL	fDirtyOnly = FALSE
					) ;

	//
	//	Get rid of a page if the handle's match !
	//
	void	
	DumpPage(
				IN	HANDLE	hFile
				) ;

	//
	//	Release a page - must be paired with a successfull 
	//	call to AcquirePageLock !!
	//
	void	ReleasePage(	
					LPVOID	entry,
					BOOL fShared
					) ;
	
} ;

//
//  Private overlapped struct for additional fields like IoSize
//

typedef struct _OVERLAPPED_EXT
{
    OVERLAPPED  ovl;            // NT OVERLAPPED struct
    DWORD       dwIoSize;       // size of IO submitted
} OVERLAPPED_EXT;

typedef	BYTE	BytePage[HASH_PAGE_SIZE] ;

//
// read a page of the hash table into our buffer
//
BOOL
RawPageRead(
				HANDLE		hFile,
				BytePage&	page, 
				DWORD		PageNum,
                DWORD       NumPages = 1
				);

//
// read a page of the table into a buffer, for use during boot time.  it
// only reads the parts interesting during the boot phase
//
BOOL
RawPageReadAtBoot(
			HANDLE		hFile,
			BytePage&	page, 
			DWORD		PageNum	);

//
// write one or more pages of the hash table back to disk
//
BOOL
RawPageWrite(
				HANDLE	hFile,
				BytePage&	page, 
				DWORD	PageNum,
                DWORD   NumPages = 1
				);


inline void *PageEntry::operator new(size_t size) { 
	return HeapAlloc(GetProcessHeap(), 0, size); 
}

inline void PageEntry::operator delete(void *p, size_t size) { 
	_VERIFY(HeapFree(GetProcessHeap(), 0, p)); 
}


inline	PMAP_PAGE
CPageCache::AcquireCachePageShared(
					IN	HANDLE	hFile,
					IN	DWORD	PageNumber,
					IN	DWORD	Fraction,
					OUT	HPAGELOCK&	lock, 
					IN	BOOL	fDropDirectory
					)	{

	DWORD	lockIndex = (PageNumber * Fraction) % m_cPageEntry ;
	PageEntry*	pageEntry = &m_pPageEntry[lockIndex] ;

	return	lock.AcquirePageShared( pageEntry, hFile, PageNumber, fDropDirectory ) ;
}

inline	PMAP_PAGE
CPageCache::AcquireCachePageExclusive(
					IN	HANDLE	hFile,
					IN	DWORD	PageNumber,
					IN	DWORD	Fraction,
					OUT	HPAGELOCK&	lock, 
					IN	BOOL	fDropDirectory
					)	{

	DWORD	lockIndex = (PageNumber * Fraction) % m_cPageEntry ;
	PageEntry*	pageEntry = &m_pPageEntry[lockIndex] ;

	return	lock.AcquirePageExclusive( pageEntry, hFile, PageNumber, fDropDirectory ) ;
}


inline	BOOL
CPageCache::AddCachePageExclusive(
					IN	HANDLE	hFile,
					IN	DWORD	PageNumber,
					IN	DWORD	Fraction,
					OUT	HPAGELOCK&	lock
					)	{

	DWORD	lockIndex = (PageNumber * Fraction) % m_cPageEntry ;
	PageEntry*	pageEntry = &m_pPageEntry[lockIndex] ;

	return	lock.AddPageExclusive( pageEntry, hFile, PageNumber ) ;
}


inline	VOID 
CPageCache::ReleasePageShared( 
					PMAP_PAGE	page,
					HPAGELOCK&	hLock
					)		{
	hLock.ReleaseAllShared( page ) ;
}

inline	VOID 
CPageCache::ReleasePageExclusive(	
					PMAP_PAGE	page,
					HPAGELOCK&	hLock 
					)	{
	hLock.ReleaseAllExclusive( page ) ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\hashmap\src\scan.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    scan.cpp

Abstract:

    This module contains the scanning code for the chkhash program.

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

--*/

#include <windows.h>
#include <xmemwrpr.h>
#include "dbgtrace.h"
#include "directry.h"
#include "pageent.h"
#include "hashmap.h"

#define FOUND_ERROR(__error_flag__) {									\
	if (pdwErrorFlags != NULL) *pdwErrorFlags |= __error_flag__;		\
	SetLastError(ERROR_INTERNAL_DB_CORRUPTION);							\
	TraceFunctLeave();													\
	return FALSE;														\
}

BOOL CHashMap::VerifyPage(	PMAP_PAGE pPage,
							DWORD dwCheckFlags,
							DWORD *pdwErrorFlags,
							IKeyInterface*	pIKey,
							ISerialize	*pHashEntry)
{
	TraceQuietEnter("CHashMap::VerifyPage");

	if (!(dwCheckFlags & HASH_VFLAG_PAGE_BASIC_CHECKS)) {
		TraceFunctLeave();
		return(TRUE);
	}
	
    DWORD j, nDel = 0, nOk = 0;
    SHORT offset;

	// these are parallel arrays that are used for checking for overlapping
	// pages
	SHORT rgEntryOffset[MAX_LEAF_ENTRIES];
	SHORT rgEntryLength[MAX_LEAF_ENTRIES];
	BOOL  rgIsDeleted[MAX_LEAF_ENTRIES];
	// the size of each array
	SHORT nEntries = 0;

	// get the mask for hash bits
	DWORD cMaskDepth = 32 - pPage->PageDepth;
	DWORD dwHashMask = (0xffffffff >> cMaskDepth) << cMaskDepth;

    //
    // check every entry in the page
    //
    for (j = 0; j < MAX_LEAF_ENTRIES; j++) {
        offset = pPage->Offset[j];
        if (offset != 0) {

			//
			// make sure the entry offset is valid
			//
			if (offset > HASH_PAGE_SIZE) {
				// the entry offset is too large
				ErrorTrace(0, "offset %lu is too large on entry %lu",
					offset, j);
				FOUND_ERROR(HASH_FLAG_ENTRY_BAD_SIZE)
			}

            if (offset < 0) {
				// deleted entry
				nDel++;
				continue;
			} else {
				// this isn't a deleted entry
				nOk++;


				PENTRYHEADER pEntry = (PENTRYHEADER) GET_ENTRY(pPage, offset);

				//
				// make sure the entry size is valid
				//
				if (pEntry->EntrySize < sizeof(ENTRYHEADER) ||
					offset + pEntry->EntrySize > HASH_PAGE_SIZE)
				{
					// the size is invalid
					ErrorTrace(0, "entry size %lu is invalid on entry %lu",
						pEntry->EntrySize, j);
					FOUND_ERROR(HASH_FLAG_ENTRY_BAD_SIZE)
				}
				
	            //
	            // Make sure hash values are mapped to correct pages
	            //
				if ((dwHashMask & pEntry->HashValue) != 
					(dwHashMask & (pPage->HashPrefix << (32-pPage->PageDepth)))) 
				{
					// this entry has an invalid hash value
					ErrorTrace(0, "hash value %x does not equal prefix %x (depth = %lu)",
						pEntry->HashValue, pPage->HashPrefix,
						pPage->PageDepth);
					FOUND_ERROR(HASH_FLAG_ENTRY_BAD_HASH)
				}

				//
				// verify that the KeyLen is valid
				//
				if( pIKey != NULL ) {

					if( !pIKey->Verify( pEntry->Data, pEntry->Data, pEntry->EntrySize ) ) {
						// the keylen is invalid
						FOUND_ERROR(HASH_FLAG_ENTRY_BAD_SIZE)
					}

					if (pHashEntry != NULL && (dwCheckFlags & HASH_VFLAG_PAGE_VERIFY_DATA) ) {
						//
						// call the verify function for this entry to make sure that
						// its valid
						//
						PBYTE pEntryData = pIKey->EntryData( pEntry->Data ) ;
						if (!pHashEntry->Verify(pEntry->Data, pEntryData, pEntry->EntrySize ))
						{
							ErrorTrace(0, "CHashEntry::Verify failed");
							FOUND_ERROR(HASH_FLAG_ENTRY_BAD_DATA)
						}
					}
				}
#if 0
				if (offset + pEntry->KeyLen >
					offset + pEntry->Header.EntrySize)
				{
					// the keylen is invalid
					ErrorTrace(0, "the key length %lu is invalid",
						pEntry->KeyLen);
					FOUND_ERROR(HASH_FLAG_ENTRY_BAD_SIZE)
				}
				if (dwCheckFlags & HASH_VFLAG_PAGE_VERIFY_DATA &&
					pHashEntry != NULL)
				{
					//
					// call the verify function for this entry to make sure that
					// its valid
					//
					PBYTE pEntryData = pEntry->Key + pEntry->KeyLen;
					if (!pHashEntry->Verify(pEntry->Key, pEntry->KeyLen,
										    pEntryData))
					{
						ErrorTrace(0, "CHashEntry::Verify failed");
						FOUND_ERROR(HASH_FLAG_ENTRY_BAD_DATA)
					}
				}
#endif

				rgEntryLength[nEntries] = pEntry->EntrySize;
				rgIsDeleted[nEntries] = FALSE;
				rgEntryOffset[nEntries] = offset;
				nEntries++;
	        }
		}
    }


	//
	// walk the delete list
	//
    WORD iDeletedEntry;
    iDeletedEntry = pPage->DeleteList.Flink;
	while (iDeletedEntry != 0) {
		PDELENTRYHEADER pDelEntry;
		pDelEntry = (PDELENTRYHEADER) GET_ENTRY(pPage, iDeletedEntry);

		//
		// make sure the entry size is valid
		//
		if (pDelEntry->EntrySize < sizeof(DELENTRYHEADER) ||
			offset + pDelEntry->EntrySize > HASH_PAGE_SIZE)
		{
			// the size is invalid
			ErrorTrace(0, "entry size %lu is invalid on entry %lu",
				pDelEntry->EntrySize, j);
			FOUND_ERROR(HASH_FLAG_ENTRY_BAD_SIZE)
		}

		rgEntryOffset[nEntries] = iDeletedEntry;
		rgEntryLength[nEntries] = pDelEntry->EntrySize;
		rgIsDeleted[nEntries] = TRUE;
		nEntries++;

        iDeletedEntry = pDelEntry->Link.Flink;
	}

	//
    // Check to see that all numbers are consistent
    //
    if (nOk + nDel != pPage->EntryCount) {
        ErrorTrace(0, "page entry counts don't match (should be %i, is %i)",
			nOk + nDel, pPage->EntryCount);
		FOUND_ERROR(HASH_FLAG_BAD_ENTRY_COUNT)
    }

	//
	// do the check for overlapping entries
	//
	if (dwCheckFlags & HASH_VFLAG_PAGE_CHECK_OVERLAP) {
		//
		// GUBGUB - check for overlapping entries
		//
	}

	//TraceFunctLeave();
	return TRUE;
}

#undef FOUND_ERROR
#define FOUND_ERROR(__error_flag__) {									\
	if (pdwErrorFlags != NULL) *pdwErrorFlags |= __error_flag__;		\
	SetLastError(ERROR_INTERNAL_DB_CORRUPTION);							\
	goto error;															\
}

//
// verify that a hashmap file is okay
//
BOOL CHashMap::VerifyHashFile(	LPCSTR szFilename,
								DWORD dwSignature,
								DWORD dwCheckFlags,
								DWORD *pdwErrorFlags,
								IKeyInterface*	pIKey,
								ISerialize	*pHashEntry)
{
	TraceFunctEnter("CHashMap::VerifyHashFile");
	
    DWORD fileSize = 0;
    DWORD nPages;
    HANDLE hFile = INVALID_HANDLE_VALUE, hMap = NULL;
    DWORD dirDepth;
    DWORD nEntries;
    PDWORD pDirectory = NULL;
    DWORD i;
    BOOL ret = FALSE;
	BytePage pHeadPageBuf, pThisPageBuf;
	PHASH_RESERVED_PAGE pHeadPage = (PHASH_RESERVED_PAGE) pHeadPageBuf;
	PMAP_PAGE pThisPage = (PMAP_PAGE) pThisPageBuf;

    //
    // Open the hash file
    //
    hFile = CreateFile(szFilename,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                       NULL
                       );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
			ErrorTrace(0, "hash file not found");
			FOUND_ERROR(HASH_FLAG_NO_FILE)
        } else {
        	if (*pdwErrorFlags != NULL) *pdwErrorFlags |= HASH_FLAG_ABORT_SCAN;
            ErrorTrace(0, "Error %d in CreateFile", GetLastError());
			goto error;
        }
		_ASSERT(FALSE);
    }

    //
    // Get the size of the file.  This will tell us how many pages
    // are currently filled.
    //
    fileSize = GetFileSize(hFile, NULL);
    if (fileSize == 0xffffffff) {
        ErrorTrace(0, "Error %d in GetFileSize", GetLastError());
        if (*pdwErrorFlags != NULL) *pdwErrorFlags |= HASH_FLAG_ABORT_SCAN;
        goto error;
    }

	DebugTrace(0, "File size is %d", fileSize);

    //
    // Make sure the file size is a multiple of a page
    //
    if ((fileSize % HASH_PAGE_SIZE) != 0) {
        ErrorTrace(0, "File size(%d) is not page multiple", fileSize);
		FOUND_ERROR(HASH_FLAG_BAD_SIZE)
    }

    nPages = fileSize / HASH_PAGE_SIZE;

    DebugTrace(0, "pages allocated %d", nPages);

	//
	// read the head page
	//
	if (!RawPageRead(hFile, pHeadPageBuf, 0)) {
		ErrorTrace(0, "Error %d in in RawPageRead", GetLastError());
        *pdwErrorFlags |= HASH_FLAG_ABORT_SCAN;
        goto error;
	}

    //
    // Check the signature and the initialize bit
    //
    if (pHeadPage->Signature != dwSignature) {
        //
        // Wrong signature
        //
        ErrorTrace(0, "Invalid signature %x (expected %x)",
            pHeadPage->Signature, dwSignature);
		FOUND_ERROR(HASH_FLAG_BAD_SIGNATURE)
    }

    if (!pHeadPage->Initialized) {
        //
        // Not initialized !
        //
        ErrorTrace(0, "Existing file uninitialized!!!!.");
		FOUND_ERROR(HASH_FLAG_NOT_INIT)
    }

    if (pHeadPage->NumPages > nPages) {
        //
        // bad count. Corrupt file.
        //
        ErrorTrace(0, "NumPages in Header(%d) more than actual(%d)",
            pHeadPage->NumPages, nPages);
        FOUND_ERROR(HASH_FLAG_BAD_PAGE_COUNT)
    }

    //
    // Create links and print stats for each page
    //
    nPages = pHeadPage->NumPages;
    dirDepth = pHeadPage->DirDepth;

#if 0
	// dirDepth isn't always accurate.  when a file is first created it sets
	// dirDepth = 2, even though it makes 256 pages (and thus dirDepth should
	// be 8).  checking for this special case here...
	if (dirDepth == 2 && nPages == 257) dirDepth = 8;
#endif
    nEntries = (DWORD)(1 << dirDepth);
    if (nEntries < (nPages-1)) {
        ErrorTrace(0, "dir depth(%i) is not sufficient for pages(%i)",
			dirDepth, nPages - 1);
		FOUND_ERROR(HASH_FLAG_BAD_DIR_DEPTH)
    }

	DebugTrace(0, "dirDepth = %lu", dirDepth);

	if (dwCheckFlags & HASH_VFLAG_FILE_CHECK_DIRECTORY) {
	    //
	    // OK, build the directory
	    //
	    DebugTrace(0, "Setting up directory of %d entries",nEntries);

	    pDirectory = (PDWORD)LocalAlloc(0, nEntries * sizeof(DWORD));
	    if (pDirectory == NULL) {
	        ErrorTrace(0, "Cannot allocate directory of %d entries!!!",
				nEntries);
	        *pdwErrorFlags |= HASH_FLAG_ABORT_SCAN;
	        goto error;
	    }

	    ZeroMemory(pDirectory, nEntries * sizeof(DWORD));
	} else {
		pDirectory = NULL;
	}

	if (dwCheckFlags != 0) {
	    //
	    // verify each page
	    //
	    for ( i = 1; i < nPages; i++ ) {
	        DebugTrace(0, "Processing page %d",i);
	
			//
			// read this page
			//
			if (!RawPageRead(hFile, pThisPageBuf, i)) {
				ErrorTrace(0, "Error %d in in RawPageRead", GetLastError());
		        *pdwErrorFlags |= HASH_FLAG_ABORT_SCAN;
		        goto error;
			}
	
			if (dwCheckFlags & HASH_VFLAG_FILE_CHECK_DIRECTORY) {
				_ASSERT(pDirectory != NULL);
	
		        //
		        // Set the pointers for this page
		        //
		        DWORD startPage, endPage;
		        DWORD j;
	
		        //
		        // Get the range of directory entries that point to this page
		        //
		        startPage = pThisPage->HashPrefix << (dirDepth - pThisPage->PageDepth);
		        endPage = ((pThisPage->HashPrefix+1) << (dirDepth - pThisPage->PageDepth));
	
		        DebugTrace(0, "Directory ptrs <%d:%d>",startPage,endPage-1);
	
		        if ((startPage > nEntries) || (endPage > nEntries)) {
		            ErrorTrace(0, "Corrupt prefix for page %d",i);
		            FOUND_ERROR(HASH_FLAG_PAGE_PREFIX_CORRUPT)
		        }
	
		        for ( j = startPage; j < endPage; j++ ) {
		            pDirectory[j] = i;
		        }
			}
	
			if (dwCheckFlags & HASH_VFLAG_PAGE_BASIC_CHECKS) {
		        if (!VerifyPage(pThisPage, dwCheckFlags, pdwErrorFlags,
								pIKey, pHashEntry))
				{
					ErrorTrace(0, "invalid page data %d", i);
					goto error;
				}
			}
		}
	}

	if (dwCheckFlags & HASH_VFLAG_FILE_CHECK_DIRECTORY) {
	    //
	    // Make sure all the links have been initialized.  If not, then
		// something terrible has happened.  Do a comprehensive rebuilt.
	    //

	    for (i = 0;i < nEntries; i++) {
	        if (pDirectory[i] == 0) {
	            ErrorTrace(0, "Directory link check failed on %d",i);
	            FOUND_ERROR(HASH_FLAG_BAD_LINK)
	            goto error;
	        }
	    }
	}

    ret = TRUE;

error:

    //
    // Delete the Directory
    //

	// cleanup allocated memory
    if (pDirectory != NULL) {
        LocalFree(pDirectory);
        pDirectory = NULL;
    }

    //
    // Close the file
    //
    if (hFile != INVALID_HANDLE_VALUE) {
        _VERIFY( CloseHandle(hFile) );
        hFile = INVALID_HANDLE_VALUE;
    }

	TraceFunctLeave();
    return(ret);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\hashmap\src\pageent.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    hash.cpp

Abstract:

    This module contains definition for the PageEntry base class

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

--*/

#include <windows.h>
#include <xmemwrpr.h>
#include <dbgtrace.h>
#include "pageent.h"


void	WINAPI
FileIOCompletionRoutine(
		DWORD	dwError,
		DWORD	cbBytes,
		LPOVERLAPPED	povl
		)	{

    OVERLAPPED_EXT * povlExt = (OVERLAPPED_EXT*)povl;

	if( dwError == ERROR_SUCCESS &&
		cbBytes == povlExt->dwIoSize ) {
		(povlExt->ovl).hEvent = (HANDLE)TRUE ;
	}	else	{
		(povlExt->ovl).hEvent = (HANDLE)FALSE ;
	}
}

PMAP_PAGE
PageEntry::AcquirePageShared(
				IN	HANDLE	hFile,
				IN	DWORD	PageNum,
				OUT	BOOL	&fShared,
				IN	HPAGELOCK*	pageLock,
				IN	BOOL	fDropDirectory
				)	{
/*++

Routine Description :

	The goal is to get a page of the hash table
	into memory and then return a pointer to the page
	with a lock for the page held non-exclusively.

	So we will grab our lock in shared mode and see if
	the page is already present. If it ain't we drop
	the lock and get it exclusively and then load the page.

	The fShared Out parameter must be passed to our ReleasePage()
	function so that we can release the lock in the correct manner.


Arguments :

	hFile - File handle of the Hash table file
	PageNum - The page within the file that we want
	fShared - Out parameter - if we set this to TRUE then
		we really did manage to grab the lock in shared
		mode, otherwise we had to grab the lock exclusively
		and re-read the page.
	

Return Value :

	if successfull, we will return a pointer to our buffer
	NULL otherwise !

--*/

	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( PageNum != INVALID_PAGE_NUM ) ;

	//
	//	If the page was already loaded - use it and
	//	get a shared lock !
	//

	m_pageLock->ShareLock() ;

	if( m_PageNum == PageNum && m_hFile == hFile ) {

		fShared = TRUE ;

		if(	fDropDirectory && pageLock ) {
			pageLock->ReleaseDirectoryShared() ;
		}

		return	(PMAP_PAGE)m_lpvPage ;

	}

	m_pageLock->ShareUnlock() ;

	//
	//	Oh oh ! the page was not already in memory - need to
	//	read it from the file.  We will leave the page
	//	exclusively locked when we return from this function,
	//	as there's no easy way to get the lock exclusively,
	//	load the page, and the convert the lock to a shared lock !
	//

	fShared = FALSE ;
	m_pageLock->ExclusiveLock() ;

	if(	fDropDirectory && pageLock ) {
		pageLock->ReleaseDirectoryShared() ;
	}

	//
	//	If the file is dirty we need to flush this page !
	//
	if( m_fDirty ) {
		//
		//	Write the page to disk !
		//
		FlushPage( m_hFile, m_lpvPage, FALSE ) ;
		_ASSERT( !m_fDirty ) ;
	}

	OVERLAPPED_EXT	ovlExt ;
	ZeroMemory( &ovlExt, sizeof( ovlExt ) ) ;

	m_PageNum = PageNum ;
	m_hFile = hFile ;

	LARGE_INTEGER	liOffset ;
	liOffset.QuadPart = m_PageNum ;
	liOffset.QuadPart *= HASH_PAGE_SIZE ;

	HANDLE  hEvent = GetPerThreadEvent();
    ovlExt.ovl.hEvent = hEvent ;
    ovlExt.ovl.Offset = liOffset.LowPart ;
	ovlExt.ovl.OffsetHigh = liOffset.HighPart ;
    ovlExt.dwIoSize = HASH_PAGE_SIZE ;

	DWORD   cbResults = 0;
    BOOL	fSuccess = FALSE ;
	if( ReadFile(	hFile, m_lpvPage, HASH_PAGE_SIZE, &cbResults, (LPOVERLAPPED)&ovlExt) ||
        (GetLastError() == ERROR_IO_PENDING &&
        GetOverlappedResult( hFile, (LPOVERLAPPED) &ovlExt, &cbResults, TRUE )) ) {
		if (cbResults != ovlExt.dwIoSize) {
            fSuccess = FALSE;
        } else {
            fSuccess = TRUE;
        }
	} else {
        fSuccess = FALSE;
    }
    ResetEvent( hEvent );
    
    _ASSERT( WaitForSingleObject( hEvent, 0 ) != WAIT_OBJECT_0 );

	if( !fSuccess ) {
		m_PageNum = INVALID_PAGE_NUM ;
		m_hFile = INVALID_HANDLE_VALUE ;
		m_pageLock->ExclusiveUnlock( ) ;
		return	0 ;
	}

	return	(PMAP_PAGE)m_lpvPage ;
}

PMAP_PAGE
PageEntry::AcquirePageExclusive(
				IN	HANDLE	hFile,
				IN	DWORD	PageNum,
				OUT	BOOL	&fShared,
				IN	HPAGELOCK*	pageLock,
				IN	BOOL	fDropDirectory
				)	{
/*++

Routine Description :

	Read a page of the hash table into our buffer.
	Must grab the page lock first !!!


Arguments :

	hFile - File handle of the Hash table file
	PageNum - The page within the file that we want
	fShared - Out parameter - if we set this to TRUE then
		we really did manage to grab the lock in shared
		mode, otherwise we had to grab the lock exclusively
		and re-read the page.
	

Return Value :

	if successfull, we will return a pointer to our buffer
	NULL otherwise !

--*/

	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( PageNum != INVALID_PAGE_NUM ) ;

	//
	//	Oh oh ! the page was not already in memory - need to
	//	read it from the file.  We will leave the page
	//	exclusively locked when we return from this function,
	//	as there's no easy way to get the lock exclusively,
	//	load the page, and the convert the lock to a shared lock !
	//

	fShared = FALSE ;
	m_pageLock->ExclusiveLock() ;

	if(	fDropDirectory && pageLock ) {
		pageLock->ReleaseDirectoryShared() ;
	}

	if( m_PageNum == PageNum && m_hFile == hFile ) {

		return	(PMAP_PAGE)m_lpvPage ;

	}

	//
	//	If the file is dirty we need to flush this page !
	//
	if( m_fDirty ) {
		//
		//	Write the page to disk !
		//
		FlushPage( m_hFile, m_lpvPage, FALSE ) ;
		_ASSERT( !m_fDirty ) ;
	}

	OVERLAPPED_EXT	ovlExt ;
	ZeroMemory( &ovlExt, sizeof( ovlExt ) ) ;

	m_PageNum = PageNum ;
	m_hFile = hFile ;

	LARGE_INTEGER	liOffset ;
	liOffset.QuadPart = m_PageNum ;
	liOffset.QuadPart *= HASH_PAGE_SIZE ;

	HANDLE hEvent = GetPerThreadEvent();
	ovlExt.ovl.hEvent = hEvent ;
	ovlExt.ovl.Offset = liOffset.LowPart ;
	ovlExt.ovl.OffsetHigh = liOffset.HighPart ;
    ovlExt.dwIoSize = HASH_PAGE_SIZE ;

	DWORD   cbResults = 0;
    BOOL	fSuccess = FALSE ;
	if( ReadFile( hFile, m_lpvPage, HASH_PAGE_SIZE, &cbResults, (LPOVERLAPPED)&ovlExt ) ||
        (GetLastError() == ERROR_IO_PENDING &&
        GetOverlappedResult( hFile, (LPOVERLAPPED) &ovlExt, &cbResults, TRUE )) ) {
		if (cbResults != ovlExt.dwIoSize) {
            fSuccess = FALSE;
        } else {
            fSuccess = TRUE;
        }
	} else {
        fSuccess = FALSE;
    }
    ResetEvent( hEvent );
    
    _ASSERT( WaitForSingleObject( hEvent, 0 ) != WAIT_OBJECT_0 );


	if( !fSuccess ) {
		m_PageNum = INVALID_PAGE_NUM ;
		m_hFile = INVALID_HANDLE_VALUE ;
		m_pageLock->ExclusiveUnlock( ) ;
		return	0 ;
	}

	return	(PMAP_PAGE)m_lpvPage ;
}


BOOL
PageEntry::AcquireSlotExclusive(
				IN	HANDLE	hFile,
				IN	DWORD	PageNum,
				OUT	BOOL	&fShared
				)	{
/*++

Routine Description :

	Grab a slot used for holding pages Exclusively.
	This is used when adding pages to the hash table during
	page splits.we grab the slot so that nobody mistakenly tries to
	access the page before the write of it has completed !


Arguments :

	hFile - File handle of the Hash table file
	PageNum - The page within the file that we want
	fShared - Out parameter - if we set this to TRUE then
		we really did manage to grab the lock in shared
		mode, otherwise we had to grab the lock exclusively
		and re-read the page.
	

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( PageNum != INVALID_PAGE_NUM ) ;

	//
	//	Oh oh ! the page was not already in memory - need to
	//	read it from the file.  We will leave the page
	//	exclusively locked when we return from this function,
	//	as there's no easy way to get the lock exclusively,
	//	load the page, and the convert the lock to a shared lock !
	//

	fShared = FALSE ;
	m_pageLock->ExclusiveLock() ;

	return	TRUE ;
}



BOOL
PageEntry::FlushPage(
				HANDLE	hFile,
				LPVOID	entry, 
				BOOL	fDirtyOnly
				) {
/*++

Routine Description :

	Commit a page back to the disk.
	We've been passed the address that the user wants to flush,
	this must be a page we previously acquired throuh AcquirePageAndLock()
	so we will ensure that we get the same address as we're currently
	sitting on.

	****** Lock must be held ***********

Arguments :

	entry - Pointer to the page to be flushed ! Must be the same
		as our m_lpvPage member !

Return Value : 
	fDirtyOnly - if TRUE then we don't write the page, we only 
		mark the page as dirty !

	Nothing.
	
--*/

	_ASSERT( (LPVOID)entry == m_lpvPage ) ;
	_ASSERT( m_PageNum != INVALID_PAGE_NUM ) ;
	_ASSERT( m_hFile == hFile ) ;

	if( fDirtyOnly ) {
		m_fDirty = TRUE ;
		return	TRUE ;
	}
	
	OVERLAPPED_EXT	ovlExt ;
	ZeroMemory( &ovlExt, sizeof( ovlExt ) ) ;

	LARGE_INTEGER	liOffset ;
	liOffset.QuadPart = m_PageNum ;
	liOffset.QuadPart *= HASH_PAGE_SIZE ;

    HANDLE  hEvent = GetPerThreadEvent();
    ovlExt.ovl.hEvent = hEvent;
	ovlExt.ovl.Offset = liOffset.LowPart ;
	ovlExt.ovl.OffsetHigh = liOffset.HighPart ;
    ovlExt.dwIoSize = HASH_PAGE_SIZE ;

	DWORD   cbResults = 0;
    BOOL	fSuccess = FALSE ;
	if( WriteFile(	hFile, m_lpvPage, HASH_PAGE_SIZE, &cbResults, (LPOVERLAPPED)&ovlExt) ||
        (GetLastError() == ERROR_IO_PENDING && 
        GetOverlappedResult( hFile, (LPOVERLAPPED) &ovlExt, &cbResults, TRUE )) ) {
        
		if (cbResults == ovlExt.dwIoSize) {
		    fSuccess = TRUE;
        } else {
            fSuccess = FALSE;
        }
		m_fDirty = FALSE ;
	} else {
        fSuccess = FALSE;
    }
    ResetEvent( hEvent );

    _ASSERT( WaitForSingleObject( hEvent, 0 ) != WAIT_OBJECT_0 );

	return	fSuccess ;
}

void
PageEntry::DumpPage(
				HANDLE	hFile
				)	{
/*++

Routine Description : 

	Discard a page from the cache if it falls in the specified file !

Arguments : 

	hFile - The file we don't want anymore !

Return Value : 

	Nothing.
	
--*/

	BOOL	fMatch = FALSE ;

	m_pageLock->ShareLock() ;

	fMatch = hFile == m_hFile ;	

	m_pageLock->ShareUnlock() ;

	if( fMatch )	{
	
		m_pageLock->ExclusiveLock() ;
		if( hFile == m_hFile ) {
			//
			//	If the file is dirty we need to flush this page !
			//
			if( m_fDirty ) {
				//
				//	Write the page to disk !
				//
				FlushPage( m_hFile, m_lpvPage, FALSE ) ;
				_ASSERT( !m_fDirty ) ;
			}
			hFile = INVALID_HANDLE_VALUE ;
			m_PageNum = INVALID_PAGE_NUM ;
			m_fDirty = FALSE ;
		}
		m_pageLock->ExclusiveUnlock() ;
	}
}

void
PageEntry::ReleasePage(
				LPVOID	page,
				BOOL	fShared
				)	{
/*++

Routine Description :

	This function releases the lock we have on a page !

Arguments :

	page - pointer to the page we had earlier provided to the user
		This must be the same as m_lpvPage !!!

Return Value :

	None.

--*/	

	_ASSERT( (LPVOID)page == m_lpvPage || page == 0) ;

	if( fShared ) {

		m_pageLock->ShareUnlock() ;

	}	else	{

		m_pageLock->ExclusiveUnlock( ) ;

	}
}


/*++

Routine Description :

	Read a page of the hash table into our buffer.

Arguments :

	hFile - File handle of the Hash table file
	page - Place where we want to save the page contents.
	PageNum - The page within the file that we want

Return Value :

	TRUE or FALSE depending on success

--*/
BOOL
RawPageRead(
				HANDLE		hFile,
				BytePage&	page,
				DWORD		PageNum,
                DWORD       NumPages
				)	
{

	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;
	

	OVERLAPPED_EXT	ovlExt ;
	ZeroMemory( &ovlExt, sizeof( ovlExt ) ) ;

	LARGE_INTEGER	liOffset ;
	liOffset.QuadPart = PageNum ;
	liOffset.QuadPart *= HASH_PAGE_SIZE ;

	HANDLE  hEvent = GetPerThreadEvent() ;
	ovlExt.ovl.hEvent = hEvent;
	ovlExt.ovl.Offset = liOffset.LowPart ;
	ovlExt.ovl.OffsetHigh = liOffset.HighPart ;
    ovlExt.dwIoSize = HASH_PAGE_SIZE*NumPages ;

    DWORD   cbResults = 0;
	BOOL	fSuccess = FALSE ;
	if( ReadFile( hFile, &page, HASH_PAGE_SIZE*NumPages, &cbResults, (LPOVERLAPPED)&ovlExt )  ||
        (GetLastError() == ERROR_IO_PENDING &&
        GetOverlappedResult( hFile, (LPOVERLAPPED) &ovlExt, &cbResults, TRUE )) ) {
		if (cbResults != ovlExt.dwIoSize) {
            fSuccess = FALSE;
        } else {
            fSuccess = TRUE;
        }
	} else {
        fSuccess = FALSE;
    }
    ResetEvent( hEvent );
    
    _ASSERT( WaitForSingleObject( hEvent, 0 ) != WAIT_OBJECT_0 );

	return	fSuccess;
}

BOOL
RawPageReadAtBoot(
			HANDLE		hFile,
			BytePage&	page,
			DWORD		PageNum	)	{

/*++

Routine Description :

	Read a portion of a page of the hash table into our buffer.
	This function is called only during boot initialization, when
	we don't care to read the entire page, just the interesting
	header bits.

Arguments :

	hFile - File handle of the Hash table file
	page - Place where we want to save the page contents.
	PageNum - The page within the file that we want

Return Value :

	if successfull, we will return a pointer to our buffer
	NULL otherwise !

--*/

	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;

	OVERLAPPED_EXT	ovlExt ;
	ZeroMemory( &ovlExt, sizeof( ovlExt ) ) ;

	LARGE_INTEGER	liOffset ;
	liOffset.QuadPart = PageNum ;
	liOffset.QuadPart *= HASH_PAGE_SIZE ;

	HANDLE  hEvent = GetPerThreadEvent() ;
	ovlExt.ovl.hEvent = hEvent;
	ovlExt.ovl.Offset = liOffset.LowPart ;
	ovlExt.ovl.OffsetHigh = liOffset.HighPart ;
    ovlExt.dwIoSize = HASH_PAGE_SIZE ;

    DWORD   cbResults = 0;
	BOOL	fSuccess = FALSE ;
	if( ReadFile( hFile, &page, HASH_PAGE_SIZE, &cbResults, (LPOVERLAPPED)&ovlExt ) ||
        (GetLastError() == ERROR_IO_PENDING &&
        GetOverlappedResult( hFile, (LPOVERLAPPED) &ovlExt, &cbResults, TRUE )) ) {
		if (cbResults != ovlExt.dwIoSize) {
            fSuccess = FALSE;
        } else {
            fSuccess = TRUE;
        }
	} else {
        fSuccess = FALSE;
    }
    ResetEvent( hEvent );

    _ASSERT( WaitForSingleObject( hEvent, 0 ) != WAIT_OBJECT_0 );

	return	fSuccess;
}

/*++

Routine Description :

	Commit a page back to the disk.
	We've been passed the address that the user wants to flush,
	this must be a page we previously acquired throuh AcquirePageAndLock()
	so we will ensure that we get the same address as we're currently
	sitting on.

	****** Lock must be held ***********

Arguments :

	entry - Pointer to the page to be flushed ! Must be the same
		as our m_lpvPage member !

Return Value :

	TRUE or FALSE depending on success
	
--*/
RawPageWrite(
				HANDLE	hFile,
				BytePage&	page,
				DWORD	PageNum,
                DWORD   NumPages
				)
{

	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;
	
	OVERLAPPED_EXT	ovlExt ;
	ZeroMemory( &ovlExt, sizeof( ovlExt ) ) ;

	LARGE_INTEGER	liOffset ;
	liOffset.QuadPart = PageNum ;
	liOffset.QuadPart *= HASH_PAGE_SIZE ;

    HANDLE  hEvent = GetPerThreadEvent();
    ovlExt.ovl.hEvent = hEvent;
	ovlExt.ovl.Offset = liOffset.LowPart ;
	ovlExt.ovl.OffsetHigh = liOffset.HighPart ;
    ovlExt.dwIoSize = HASH_PAGE_SIZE*NumPages ;

    DWORD   cbResults = 0;
	BOOL	fSuccess = FALSE ;
	if( WriteFile( hFile, page, HASH_PAGE_SIZE*NumPages, &cbResults, (LPOVERLAPPED)&ovlExt ) ||
        (GetLastError() == ERROR_IO_PENDING && 
        GetOverlappedResult( hFile, (LPOVERLAPPED) &ovlExt, &cbResults, TRUE )) ) {
        
		if (cbResults == ovlExt.dwIoSize) {
		    fSuccess = TRUE;
        } else {
            fSuccess = FALSE;
        }
	} else {
        fSuccess = FALSE;
    }
    ResetEvent( hEvent );

    _ASSERT( WaitForSingleObject( hEvent, 0 ) != WAIT_OBJECT_0 );

	return	fSuccess ;	
}


CPageCache::CPageCache()	:
	m_lpvBuffers( 0 ),
	m_cPageEntry( 0 ),
	m_pPageEntry( 0 ),
	m_cpageLock( 0 ),
	m_ppageLock( 0 )	{

}

BOOL
CPageCache::Initialize(
					DWORD	cPageEntry,
					DWORD	cLocks
					) {


	MEMORYSTATUS	memStatus ;
	memStatus.dwLength = sizeof( memStatus ) ;
	GlobalMemoryStatus( &memStatus ) ;


	//
	//	If the number is zero make up a default !
	//
	if( cPageEntry == 0 ) {

		DWORD	block = (DWORD)(memStatus.dwTotalPhys / 4096) ;
		//
		//	We want to take a 3rd of available ram !
		//
		block /= 3 ;

		//  Or 4MB, whichever is smaller - bug 76833
		block = min(block, 4 * KB * KB / 4096);

		//
		//	Now we want that to be divisible evenly by 32
		//
		
		cPageEntry = block & (~(32-1)) ;

	}

	if( cPageEntry < 32 )
		cPageEntry = 32 ;

#ifndef	_USE_RWNH_
	//
	//	If the number is zero make up a default !
	//
	if( cLocks == 0 ) {

		cLocks = memStatus.dwTotalPhys / (1024 * 1024) ;

		//
		//	We will do a lock per megabyte of RAM the system has !
		//	with a limit of 256 !
		//

		if( cLocks > 256 )
			cLocks = 256 ;

	}
	
	if( cLocks < 16 )
		cLocks = 16 ;
#else
	cLocks = cPageEntry ;
#endif

	//
	//	If for some reason there's an existing array of
	//	locks than the count should not be 0.
	//
	_ASSERT( m_ppageLock == 0 ||
				m_cpageLock != 0 ) ;

	if( m_ppageLock == 0 )	{
		m_cpageLock = cLocks ;
		m_ppageLock = new	_RWLOCK[cLocks] ;
		if( m_ppageLock == 0 ) {
			m_cpageLock = 0 ;
			SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
			return	FALSE ;
		}
	}

	//
	//	These should not have been touched before now !
	//
	_ASSERT( m_lpvBuffers == 0 ) ;
	_ASSERT( m_cPageEntry == 0 ) ;

	m_cPageEntry = cPageEntry ;

	for( int i=0; i<3 && m_cPageEntry != 0 ; i++ ) {

		m_lpvBuffers = VirtualAlloc(	0,
										HASH_PAGE_SIZE * m_cPageEntry,
										MEM_COMMIT | MEM_TOP_DOWN,
										PAGE_READWRITE
										) ;

		if( m_lpvBuffers )
			break ;

		m_cPageEntry /= 2 ;
	}

	if( m_lpvBuffers == 0 ) {
		m_cPageEntry = 0 ;
		SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
		return	FALSE ;
	}

	m_pPageEntry = new PageEntry[ m_cPageEntry ] ;
	if( m_pPageEntry != 0 ) {

		DWORD	iLock = 0 ;
		BYTE*	lpb = (BYTE*)m_lpvBuffers ;
		for( DWORD i = 0; i < m_cPageEntry; i++ ) {

			m_pPageEntry[i].InitializePage( (LPVOID)lpb, &m_ppageLock[iLock] ) ;

			iLock ++ ;
			iLock %= m_cpageLock ;

			lpb += HASH_PAGE_SIZE ;

		}
	}	else	{
		_VERIFY( VirtualFree(	m_lpvBuffers,
								0,
								MEM_RELEASE
								) ) ;
		m_lpvBuffers = 0 ;

		SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
		return	FALSE ;
	}
	return	TRUE ;
}

void
CPageCache::FlushFileFromCache( 
				HANDLE	hFile
				)	{
/*++

Routine Description : 

	This function forces all pages from the specified file
	out of the cache !

Arguments : 

	hFile - Handle to the file that is to be rid of !

Return Value : 

	None.

--*/

	for( DWORD i=0; i<m_cPageEntry; i++ ) {
		m_pPageEntry[i].DumpPage( hFile ) ;
	}
}


CPageCache::~CPageCache()	{

	if( m_lpvBuffers != 0 ) {

		_VERIFY( VirtualFree(
							m_lpvBuffers,
							0,
							MEM_RELEASE
							) ) ;
	}

	if( m_pPageEntry ) {

		delete[]	m_pPageEntry ;

	}

	if( m_ppageLock ) {

		delete[]	m_ppageLock ;

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\cfactory.h ===
//+-------------------------------------------------------------------------
//
//  Class:      CMimeFilterCF
//
//  Purpose:    Class factory for Html filter class
//
//--------------------------------------------------------------------------

class CMimeFilterCF : public IClassFactory
{
public:

    CMimeFilterCF();

    virtual  HRESULT STDMETHODCALLTYPE  QueryInterface( REFIID riid,
                                                      void  ** ppvObject);

    virtual  ULONG STDMETHODCALLTYPE  AddRef();

    virtual  ULONG STDMETHODCALLTYPE  Release();

    virtual  HRESULT STDMETHODCALLTYPE  CreateInstance( IUnknown * pUnkOuter,
                                                      REFIID riid, void  * * ppvObject );

    virtual  HRESULT STDMETHODCALLTYPE  LockServer( BOOL fLock );

protected:

    friend HRESULT STDMETHODCALLTYPE DllGetClassObject( REFCLSID cid,
                                                      REFIID iid, void** ppvObj );
    virtual ~CMimeFilterCF();

    long _uRefs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\cmf.cpp ===
#define DEFINE_STRCONST
#define INITGUID
#include "mimefilt.h"
#include "wchar.h"

// global reference count
long gulcInstances = 0;

//
// global temp file name key
//

DWORD CMimeFilter::m_dwTempFileNameKey = 0;

// file extensions
const WCHAR g_wszNewsExt[] = OLESTR(".nws");
const WCHAR g_wszMailExt[] = OLESTR(".eml");
const char g_szNewsExt[] = {".nws"};
const char g_szMailExt[] = {".eml"};

const PROPSPEC g_psExtraHeaders[] = { \
{PRSPEC_PROPID,PID_HDR_NEWSGROUP},
{PRSPEC_PROPID,PID_HDR_ARTICLEID},
{PRSPEC_PROPID,PID_ATT_RECVTIME},
{0,0}
};

char g_State[][32] = { \
    {"STATE_INIT"},
    {"STATE_START"},
    {"STATE_END"},
    {"STATE_HEADER"},
    {"STATE_POST_HEADER"},
    {"STATE_BODY"},
    {"STATE_EMBEDDING"},
    {"STATE_ERROR"}
};

SCODE LoadIFilterA( char* pszFileName, IUnknown * pUnkOuter, void ** ppIUnk );
SCODE WriteStreamToFile(IStream* pStream, char* pszFileName);
BOOL GetFileClsid(char* pszAttFile,CLSID* pclsid);
void FreePropVariant(PROPVARIANT* pProp);
STDMETHODIMP AstrToWstr(char* pstr,WCHAR** ppwstr,UINT codepage);
ULONG FnameToArticleIdW(WCHAR *pwszPath);
BOOL IsMailOrNewsFile(char *pszPath);

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::CMimeFilter
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CMimeFilter::CMimeFilter(IUnknown* pUnkOuter) 
{
    EnterMethod("CMimeFilter::CMimeFilter");

    m_cRef = 0;
    m_pUnkOuter = pUnkOuter;
    m_pCImpIPersistFile = NULL;
    m_pCImpIPersistStream = NULL;
    m_ulChunkID = 0;
    m_locale = GetSystemDefaultLCID();
    m_fInitFlags = 0;

    m_pwszFileName  = NULL;
    m_pstmFile      = NULL;
    m_pMessageTree  = NULL;
    m_pMsgPropSet   = NULL;
    m_pHeaderEnum   = NULL;
    m_pHeaderProp   = NULL; 
    m_hBody         = 0;
    m_pstmBody      = NULL;
    m_cpiBody       = 0;
    m_fFirstAlt     = FALSE;
    m_pTextBuf      = NULL;
    m_cbBufSize     = 0;
    m_fRetrieved    = FALSE;
    m_pszEmbeddedFile   = NULL;
    m_pEmbeddedFilter   = NULL;
    m_fXRefFound        = FALSE;
    m_pszNewsGroups     = NULL;
    m_State = STATE_INIT;
    StateTrace((LPARAM)this,"New state %s",g_State[m_State]);

    m_pMalloc = NULL;
    m_pMimeIntl = NULL;

    // increment the global ref count
    InterlockedIncrement( &gulcInstances );
    LeaveMethod();
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::~CMimeFilter
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CMimeFilter::~CMimeFilter()
{
    EnterMethod("CMimeFilter::~CMimeFilter");

    if( m_pCImpIPersistFile != NULL )
        delete m_pCImpIPersistFile;
    if( m_pCImpIPersistStream != NULL )
        delete m_pCImpIPersistStream;
    if( m_pwszFileName != NULL )
        delete m_pwszFileName;
    if( m_pstmFile != NULL )
        m_pstmFile->Release();
    if( m_pMessageTree != NULL )
        m_pMessageTree->Release();
    if( m_pMsgPropSet != NULL )
        m_pMsgPropSet->Release();
    if( m_pHeaderEnum != NULL )
        m_pHeaderEnum->Release();
    if( m_pHeaderProp != NULL && m_fRetrieved == FALSE )
        FreePropVariant(m_pHeaderProp);
    if( m_pstmBody != NULL )
        m_pstmBody->Release();
    if( m_pTextBuf != NULL )
        delete m_pTextBuf;
    if( m_pEmbeddedFilter != NULL )
        m_pEmbeddedFilter->Release();
    if( m_pszEmbeddedFile != NULL )
    {
        if( *m_pszEmbeddedFile != 0 )
            DeleteFile(m_pszEmbeddedFile);
        delete m_pszEmbeddedFile;
    }
    if( m_pszNewsGroups != NULL )
        delete m_pszNewsGroups;
    if( m_pMalloc != NULL )
        m_pMalloc->Release();
    if( m_pMimeIntl != NULL )
        m_pMimeIntl->Release();

    // decrement the global ref count
    InterlockedDecrement( &gulcInstances );

    LeaveMethod();
}
//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::HRInit
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [pUnkOuter] -- controlling outer IUnknown
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CMimeFilter::HRInitObject()
{
    EnterMethod("CMimeFilter::FInit");
    LPUNKNOWN       pIUnknown=(LPUNKNOWN)this;

    if (NULL!=m_pUnkOuter)
        pIUnknown=m_pUnkOuter;

    // create IPersistStream interface
    if( !(m_pCImpIPersistFile = new CImpIPersistFile(this, pIUnknown)) )
        return E_OUTOFMEMORY;

    // create IPersistStream interface
    if( !(m_pCImpIPersistStream = new CImpIPersistStream(this, pIUnknown)) )
        return E_OUTOFMEMORY;
    
    LeaveMethod();
    return NOERROR;
}
//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CMimeFilter::QueryInterface( REFIID riid,
                                                          void  ** ppvObject)
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown     = 00000000-0000-0000-C000-000000000046
    // IID_IFilter      = 89BCB740-6119-101A-BCB7-00DD010655AF
    // IID_IPersist     = 0000010c-0000-0000-C000-000000000046
    // IID_IPersistFile = 0000010b-0000-0000-C000-000000000046
    // IID_IPersistFile = 00000109-0000-0000-C000-000000000046
    //                          --
    //                           |
    //                           +--- Unique!

    _ASSERT( (IID_IUnknown.Data1        & 0x000000FF) == 0x00 );
    _ASSERT( (IID_IFilter.Data1         & 0x000000FF) == 0x40 );
    _ASSERT( (IID_IPersist.Data1        & 0x000000FF) == 0x0c );
    _ASSERT( (IID_IPersistFile.Data1    & 0x000000FF) == 0x0b );
    _ASSERT( (IID_IPersistStream.Data1  & 0x000000FF) == 0x09 );

    IUnknown *pUnkTemp = NULL;
    HRESULT hr = S_OK;

    switch( riid.Data1 & 0x000000FF )
    {
    case 0x00:
        if ( IID_IUnknown == riid )
            pUnkTemp = (IUnknown *)this;
        else
            hr = E_NOINTERFACE;
        break;

    case 0x40:
        if ( IID_IFilter == riid )
            pUnkTemp = (IUnknown *)(IFilter *)this;
        else
            hr = E_NOINTERFACE;
        break;

    case 0x0c:
        if ( IID_IPersist == riid )
            pUnkTemp = (IUnknown *)(IPersist *)m_pCImpIPersistFile;
        else
            hr = E_NOINTERFACE;
        break;

    case 0x0b:
        if ( IID_IPersistFile == riid )
            pUnkTemp = (IUnknown *)(IPersistFile *)m_pCImpIPersistFile;
        else
            hr = E_NOINTERFACE;
        break;

    case 0x09:
        if ( IID_IPersistStream == riid )
            pUnkTemp = (IUnknown *)(IPersistStream *)m_pCImpIPersistStream;
        else
            hr = E_NOINTERFACE;
        break;

    default:
        hr = E_NOINTERFACE;
        break;
    }

        *ppvObject = (void  * )pUnkTemp;
    if( 0 != pUnkTemp )
    {
        pUnkTemp->AddRef();
    }
    return(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CMimeFilter::AddRef()
{
    return InterlockedIncrement( &m_cRef );
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CMimeFilter::Release()
{
    unsigned long uTmp = InterlockedDecrement( &m_cRef );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}




//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::Init
//
//  Synopsis:   Initializes instance of NNTP filter
//
//  Arguments:  [grfFlags] -- flags for filter behavior
//              [cAttributes] -- number of attributes in array pAttributes
//              [pAttributes] -- array of attributes
//              [pFlags]      -- Set to 0 version 1
//
//  Note:   Since for now we only need  one type of filtering for news
//          articles we can disregard the arguments.
//--------------------------------------------------------------------------

STDMETHODIMP CMimeFilter::Init( ULONG grfFlags,
        ULONG cAttributes, FULLPROPSPEC const * pAttributes, ULONG * pFlags )
{
    EnterMethod("CMimeFilter::Init");

    HRESULT hr = S_OK ;

    DebugTrace((LPARAM)this,"grfFlags = 0x%08x, cAttributes = %d",grfFlags,cAttributes);

    m_fInitFlags = grfFlags;

    // get MimeOLE global allocator interface
    if( m_pMalloc == NULL )
    {
        hr = CoCreateInstance(CLSID_IMimeAllocator, NULL, CLSCTX_INPROC_SERVER, 
            IID_IMimeAllocator, (LPVOID *)&m_pMalloc);
        if (FAILED(hr))
        {
            TraceHR(hr);
            goto Exit;
        }
    }

    // do we have an existing IMimeMessageTree
    if( m_pMessageTree != NULL )
    {
        if( m_pHeaderProp != NULL && m_fRetrieved == FALSE )
            FreePropVariant(m_pHeaderProp);
        m_pHeaderProp = NULL;
        if( m_pHeaderEnum != NULL )
            m_pHeaderEnum->Release();
        m_pHeaderEnum = NULL;
        if( m_pMsgPropSet != NULL )
            m_pMsgPropSet->Release();
        m_pMsgPropSet = NULL;

        // yes, reset it's state
        hr = m_pMessageTree->InitNew();

    }
    else
    {
        // no, create a new one
        hr = CoCreateInstance(CLSID_IMimeMessageTree, NULL, CLSCTX_INPROC_SERVER, 
            IID_IMimeMessageTree, (LPVOID *)&m_pMessageTree);
    }
    if (FAILED(hr))
    {
        TraceHR(hr);
        goto Exit;
    }

    // load message file into message object
    hr = m_pMessageTree->Load(m_pstmFile);
    if (FAILED(hr))
    {
        TraceHR(hr);
        goto Exit;
    }

    // reset chunk id
    m_ulChunkID = 0;

    // set state
    m_State     = STATE_START;
    StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
    m_fFirstAlt = FALSE;
    m_fRetrieved    = FALSE;
    m_fXRefFound    = FALSE;
    m_SpecialProp   = PROP_NEWSGROUP;

        if( pFlags != NULL )
                *pFlags = 0;

Exit:
    if( FAILED(hr) )
    {
        m_State = STATE_ERROR;
        StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
    }


    LeaveMethod();
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::GetChunk
//
//  Synopsis:   Gets the next chunk and returns chunk information in ppStat
//
//  Arguments:  [pStat] -- chunk information returned here
//
//--------------------------------------------------------------------------

STDMETHODIMP CMimeFilter::GetChunk( STAT_CHUNK * pStat )
{
    EnterMethod("CMimeFilter::GetChunk");
    HRESULT hr = S_OK;
    BOOL    fForceBreak = FALSE;

    // common pStat information
    pStat->locale         = GetLocale() ;
    pStat->cwcStartSource = 0 ;
    pStat->cwcLenSource   = 0 ;

    while( TRUE )
    {
        // get started
        if( m_State == STATE_START )
        {
            HBODY hBody = 0;

            // get m_hBody for IBL_ROOT
            hr = m_pMessageTree->GetBody(IBL_ROOT,NULL,&hBody);
            if (FAILED(hr))
            {
                TraceHR(hr);
                break;
            }

            // get IMimePropertySet interface
            hr = m_pMessageTree->BindToObject(hBody,IID_IMimePropertySet,(void**)&m_pMsgPropSet);
            if (FAILED(hr))
            {
                TraceHR(hr);
                break;
            }

            // set new state
            if( m_fInitFlags & IFILTER_INIT_APPLY_INDEX_ATTRIBUTES )
            {
                // get header enumerator
                hr = m_pMsgPropSet->EnumProps(NULL,&m_pHeaderEnum);
                if (FAILED(hr))
                {
                    TraceHR(hr);
                    break;
                }

                // caller wants properties and text
                m_State = STATE_HEADER;
                StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
            }
            else
            {
                // caller want text only
                m_State = STATE_BODY;
                StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
            }
        }

        // process headers
        else if( m_State == STATE_HEADER )
        {
            ENUMPROPERTY rgHeaderRow;
            
            // free last prop variant if necessary
            if( m_fRetrieved == FALSE && m_pHeaderProp != NULL )
            {
                FreePropVariant(m_pHeaderProp);
                m_pHeaderProp = NULL;
            }

            // get the next header line
            hr = m_pHeaderEnum->Next(1,&rgHeaderRow,NULL);
            // if got the next header line
            if( hr == S_OK )
            {
                // get the header data
                                static char szEmptyString[] = "";
                PROPVARIANT varProp;
                varProp.vt = VT_LPSTR;
                hr = m_pMsgPropSet->GetProp(rgHeaderRow.pszName,0,&varProp);
                                // workaround for Bcc: problem
                                if (hr == MIME_E_NOT_FOUND) {

                                        varProp.pszVal = szEmptyString;
                                        varProp.vt = VT_LPSTR;
                                        hr = S_OK;
                                }

                if( FAILED(hr) )
                {
                    TraceHR(hr);
                    break;
                }

                // clear retrieved flag
                m_fRetrieved = FALSE;

                // header specific pStat information
                pStat->flags                       = CHUNK_VALUE;
                pStat->breakType                   = CHUNK_EOP;
                
                // map header to property id or lpwstr
                hr = MapHeaderProperty(&rgHeaderRow, varProp.pszVal, &pStat->attribute);

                if( varProp.pszVal != NULL && varProp.pszVal != szEmptyString )
                    m_pMalloc->PropVariantClear(&varProp);

                // free header row
                _VERIFY(SUCCEEDED(m_pMalloc->FreeEnumPropertyArray(
                    1,&rgHeaderRow,FALSE)));
                break;
            }
            // if no more headers
            else if( hr == S_FALSE )
            {
                // release enumerator
                m_pHeaderEnum->Release();
                m_pHeaderEnum = NULL;

                // set state to post header processing
                m_State = STATE_POST_HEADER;
                StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
            }
            // an error occured
            else
            {
                TraceHR(hr);
                break;
            }
        }

        // process extra headers
        else if( m_State == STATE_POST_HEADER )
        {
            // free last prop variant if necessary
            if( m_fRetrieved == FALSE && m_pHeaderProp != NULL )
            {
                FreePropVariant(m_pHeaderProp);
                m_pHeaderProp = NULL;
            }

            // are we at the end of special props?
            if( m_SpecialProp == PROP_END )
            {
                // set state to body
                m_State = STATE_BODY;
                StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
            }
            else
            {
                // clear retrieved flag
                m_fRetrieved = FALSE;

                // map special props
                hr = MapSpecialProperty(&pStat->attribute);
                m_SpecialProp++;
                if( SUCCEEDED(hr) && hr != S_FALSE )
                    break;
            }
        }

        // process body
        else if( m_State == STATE_BODY )
        {
            // is there an existing body part pStream
            if( m_pstmBody != NULL )
            {
                // free last body part
                m_pstmBody->Release();
                m_pstmBody = NULL;
            }

            // get next body part
            hr = GetNextBodyPart();

            // if got the next body part
            if( hr == S_OK )
            {
                // is this body part an embedding
                if( m_pEmbeddedFilter != NULL )
                {
                    // set state to embedding
                    m_State = STATE_EMBEDDING;
                    StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
                    fForceBreak = TRUE;
                }
                else
                {
                    // clear retrieved flag
                    m_fRetrieved = FALSE;

                    // body specific pStat information
                    pStat->flags                       = CHUNK_TEXT;
                    pStat->breakType                   = CHUNK_NO_BREAK;
                    pStat->attribute.guidPropSet       = CLSID_Storage;
                    pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
                    pStat->attribute.psProperty.propid = PID_STG_CONTENTS;

                    break;
                }
            }
            // if no more body parts
            else if( hr == MIME_E_NOT_FOUND )
            {
                // set state to end
                m_State = STATE_END;
                StateTrace((LPARAM)this,"New state %s",g_State[m_State]);

                // return no more body chunks
                hr = FILTER_E_END_OF_CHUNKS;
                break;
            }
            // an error occured
            else
            {
                TraceHR(hr);
                break;
            }
        }

        // process embedded objects
        else if( m_State == STATE_EMBEDDING )
        {
            // get the chunks from the embedded object
            _ASSERT(m_pEmbeddedFilter != NULL);
            hr = m_pEmbeddedFilter->GetChunk(pStat);
            if( FAILED(hr) )
            {
                // free embedding's IFilter
                m_pEmbeddedFilter->Release();
                m_pEmbeddedFilter = NULL;

                // delete the file
                if( m_pszEmbeddedFile != NULL && *m_pszEmbeddedFile != 0 )
                {
                    _VERIFY(DeleteFile(m_pszEmbeddedFile));
                    *m_pszEmbeddedFile = 0;
                }

                // back to processing body parts
                m_State = STATE_BODY;
                StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
                continue;
            }
            // This flag is set for the first Chunk after we load an embedded filter
            // to make sure there is a break for different body parts
            if (fForceBreak&&pStat->breakType==CHUNK_NO_BREAK)
                pStat->breakType = CHUNK_EOP;
            fForceBreak = FALSE;
            // got a chunk
            break;
        }

        // handle error state
        else if( m_State == STATE_ERROR )
        {
            // we shouldn't get here!
            _ASSERT(hr != S_OK);
            break;
        }

        // handle done state
        else if( m_State == STATE_END )
        {
            hr = FILTER_E_END_OF_CHUNKS;
            break;
        }
    }

    if( FAILED(hr) && hr != FILTER_E_END_OF_CHUNKS )
    {
        m_State = STATE_ERROR;
        StateTrace((LPARAM)this,"New state %s",g_State[m_State]);
    }
    else
    {
        // get chunk id
        pStat->idChunk        = GetNextChunkId();
        pStat->idChunkSource  = pStat->idChunk;
    }


    LeaveMethod();
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::GetText
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcOutput] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//--------------------------------------------------------------------------

STDMETHODIMP CMimeFilter::GetText( ULONG * pcwcOutput, WCHAR * awcOutput )
{
    EnterMethod("CMimeFilter::GetText");
    HRESULT hr = S_OK;
        DWORD cch;
    
    switch( m_State )
    {
    case STATE_BODY:
        hr = FILTER_E_NO_MORE_TEXT;
        break;
    case STATE_EMBEDDING:
        // current chunk is an embedded object
        _ASSERT(m_pEmbeddedFilter != NULL);
        hr = m_pEmbeddedFilter->GetText(pcwcOutput,awcOutput);
        break;
    default:
        // shouldn't get here
        hr = FILTER_E_NO_TEXT;
        break;
    }

    LeaveMethod();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMimeFilter::GetValue
//
//  Synopsis:   Retrieves value from current chunk
//
//----------------------------------------------------------------------------

STDMETHODIMP CMimeFilter::GetValue( PROPVARIANT ** ppPropValue )
{
    EnterMethod("CMimeFilter::GetValue");
    HRESULT hr = S_OK;
    ULONG   cb = 0;
    char*   pszSrc = NULL;

    if( ppPropValue == NULL )
        return E_INVALIDARG;

    switch( m_State )
    {
    case STATE_HEADER:
    case STATE_POST_HEADER:
        // has current chunk already been retrieved
        if( m_fRetrieved || m_pHeaderProp == NULL )
        {
            hr = FILTER_E_NO_MORE_VALUES;
            TraceHR(hr);
            break;
        }

        // use pProp allocated in GetChunk()
        *ppPropValue = m_pHeaderProp;

        // set data retrieved flag
        m_fRetrieved = TRUE;
                m_pHeaderProp = NULL;
        break;
    case STATE_EMBEDDING:
        // current chunk is an embedded object
        _ASSERT(m_pEmbeddedFilter != NULL);
        hr = m_pEmbeddedFilter->GetValue(ppPropValue);
        break;
    default:
        // shouldn't get here
        hr = FILTER_E_NO_VALUES;
        break;
    }

    if( FAILED(hr) )
    {
        if( *ppPropValue != NULL )
        {
            if( (*ppPropValue)->pwszVal != NULL )
                CoTaskMemFree((*ppPropValue)->pwszVal);
            CoTaskMemFree(*ppPropValue);
        }
        *ppPropValue = NULL;
    }

    LeaveMethod();
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilter::GetNextChunkId
//
//  Synopsis:   Return a brand new chunk id. Chunk id overflow is very unlikely.
//
//--------------------------------------------------------------------------

ULONG CMimeFilter::GetNextChunkId()
{
    EnterMethod("CMimeFilter::GetNextChunkId");
    _ASSERT( m_ulChunkID != 0xFFFFFFFF );

    LeaveMethod();
    return ++m_ulChunkID;
}


// This method gets the next body part to be indexed.
// The MIME message is represented as a tree with
// interior nodes and leaf nodes. Only leaf nodes 
// contain content that may be indexed. Mulitpart
// Content-Type represent interior nodes, while 
// non-multipart represent leaf nodes. We traverse
// the tree using the "preorder" method. The current
// position in the tree is represented by the current
// body (m_hBody). From the current body we can get
// the next body at the same level in the tree. If 
// the body is multipart then we can get its first 
// child. If there are no more children or leaf nodes
// we backup and go down the next branch. When all
// leaves have been visited, body processing is 
// finished.
//
//  HEADER
//  IBL_ROOT, type=multipart/mixed
//      +---Child1, type=multipart/alternative
//      |       +---Child1, type=text/plain     ; process this body part
//      |       +---Child2, type=text/html      ; skip this body part
//      +---Child2, type=application/octet-stream
//
STDMETHODIMP CMimeFilter::GetNextBodyPart()
{
    EnterMethod("CMimeFilter::GetNextBodyPart");
    HRESULT         hr = S_OK;
    IMimeBody*      pBody = NULL;
    HBODY           hBodyNext = 0;

    // The outter loop gets the next child
    // or backs up a level if necessary.
    while(hr == S_OK)
    {
        // Get the next body part at this level in the tree. 
        // If no current body part then get the root body part.
        if( m_hBody == 0 )
        {
            // get the message root body
            hr = m_pMessageTree->GetBody(IBL_ROOT,NULL,&m_hBody);
        }
        else
        {
            // Special case: 
            // If the last body part was the first alternative
            // of a multipart/alternative body part then need
            // to get the parent of the current body part. 
            // See sample tree above.
            if( m_fFirstAlt )
            {
                m_fFirstAlt = FALSE;
                hr = m_pMessageTree->GetBody(IBL_PARENT, m_hBody, &m_hBody);
                if( hr == MIME_E_NOT_FOUND )
                {
                    // we've hit the top of the tree
                    // and there are no more children
                    break;
                }
            }

            // get the next body part
            hr = m_pMessageTree->GetBody(IBL_NEXT, m_hBody, &hBodyNext);
            if( hr == S_OK && hBodyNext != 0 )
                m_hBody = hBodyNext;
        }

        // did we find another body part at this level in the tree
        if( hr == MIME_E_NOT_FOUND )
        {
            // no more body parts at this level so current body part's parent
            hr = m_pMessageTree->GetBody(IBL_PARENT, m_hBody, &m_hBody);
            if( hr == MIME_E_NOT_FOUND )
            {
                // we've hit the top of the tree
                // which means we've visited all 
                // nodes in the tree.
                break;
            }

            // get the next child of the new parent
            continue;
        }
        else if( FAILED(hr) )
        {
            TraceHR(hr);
            break;
        }

Again:
        // is multipart body part
        if( S_OK == m_pMessageTree->IsContentType(m_hBody, STR_CNT_MULTIPART, NULL) )
        {
            // is it multipart/alternative
            m_fFirstAlt = (S_OK == m_pMessageTree->IsContentType(m_hBody, STR_CNT_MULTIPART, 
                STR_SUB_ALTERNATIVE));

            // get first child and try again
            hr = m_pMessageTree->GetBody(IBL_FIRST, m_hBody, &m_hBody);
            if(FAILED(hr))
            {
                // a multipart body part must always contain a child
                _ASSERT(FALSE);

                // unable to get first child
                TraceHR(hr);
                break;
            }

            // we have the first part of a multipart
            // body and we need to repeat the above 
            // logic
            goto Again;
        }
        // skip these binary types
        else if(    ( S_OK == m_pMessageTree->IsContentType(m_hBody, STR_CNT_IMAGE, NULL)) || 
                    ( S_OK == m_pMessageTree->IsContentType(m_hBody, STR_CNT_AUDIO, NULL)) ||
                    ( S_OK == m_pMessageTree->IsContentType(m_hBody, STR_CNT_VIDEO, NULL)) ) 
        {
            continue;
        }
        // every other type
        else
        {
            // application, message, and all other types
            // treat as embedding
            hr = BindEmbeddedObjectToIFilter(m_hBody);
            // if could not bind embedded object to IFilter
            // rather than aborting we just continue
            // with the next body part

            //
            // mircean 09/28/02 not all errors can be ignored
    	    // GTHR_E_SINGLE_THREADED_EMBEDDING must be returned to the gatherer to retry the document using a single threaded filter process
	        // 
	        // ignore only FILTER_E_EMBEDDING_UNAVAILABLE and E_INVALIDARG

            if(hr == FILTER_E_EMBEDDING_UNAVAILABLE ||
                hr == E_FAIL ||
                hr == E_INVALIDARG)
            {
                hr = S_OK;
                continue;
            }
            break;
        }
    }

    // release open pBody
    if( pBody != NULL )
    {
        pBody->Release();
        pBody = NULL;
    }
    LeaveMethod();
    return hr;
}

STDMETHODIMP CMimeFilter::MapHeaderProperty(ENUMPROPERTY* pHeaderRow, char* pszData, FULLPROPSPEC* pProp)
{
    EnterMethod("CMimeFilter::MapHeaderProperty");
    HRESULT hr = NOERROR;

    // alloc prop variant
    m_pHeaderProp = (PROPVARIANT*) CoTaskMemAlloc (sizeof (PROPVARIANT));
    if( m_pHeaderProp == NULL )
    {
        hr = E_OUTOFMEMORY;
        TraceHR(hr);
        return hr;
    }

    // set prop value type
    m_pHeaderProp->vt = VT_LPWSTR;
    m_pHeaderProp->pwszVal = NULL;

    // set propset guid
    pProp->guidPropSet = CLSID_NNTP_SummaryInformation;

    // default to kind to prop id
    pProp->psProperty.ulKind = PRSPEC_PROPID;
    pProp->psProperty.propid = 0;
    pProp->psProperty.lpwstr = NULL;

    if( !lstrcmpi(pHeaderRow->pszName, STR_HDR_NEWSGROUPS) )
    {
        // we need to make a copy of the newsgroup line just
        // incase we don't get a XRef line.
        int nLen = lstrlen(pszData);
        if( m_pszNewsGroups != NULL )
            delete m_pszNewsGroups;

        m_pszNewsGroups = new char[nLen+1];
        if( m_pszNewsGroups != NULL )
            lstrcpy(m_pszNewsGroups,pszData);

        // now replace delimiting commas with spaces
        char* ptmp = NULL;
        while( NULL != (ptmp = strchr(pszData,',')) )
            *ptmp = ' ';

        pProp->psProperty.propid = PID_HDR_NEWSGROUPS;
    }
    else if( !lstrcmpi(pHeaderRow->pszName, STR_HDR_SUBJECT) )
        pProp->psProperty.propid = PID_HDR_SUBJECT;
    else if( !lstrcmpi(pHeaderRow->pszName, STR_HDR_FROM) )
        pProp->psProperty.propid = PID_HDR_FROM;
    else if( !lstrcmpi(pHeaderRow->pszName, STR_HDR_MESSAGEID) )
    {
        pProp->psProperty.propid = PID_HDR_MESSAGEID;

        // remove < >'s from message id
        char* ptmp = pszData;
        if( *ptmp++ == '<' )
        {
            while( *ptmp != 0 )
            {
                if( *ptmp == '>' )
                    *ptmp = 0;
                *(ptmp-1) = *ptmp++;
            }
        }
    }
    else if( !lstrcmpi(pHeaderRow->pszName, STR_HDR_REFS) )
        pProp->psProperty.propid = PID_HDR_REFS;
    else if( !lstrcmpi(pHeaderRow->pszName, STR_HDR_XREF) )
    {
        // we take the newsgroup from the xref header
        // to get the newsgroup the message was posted to.
        char* pszSrc = pszData;
        char* pszDst = pszData;

        if ( strchr( pszSrc, ' ' ) )
        {
            while( *pszSrc != ' ' )
            {
                _ASSERT(*pszSrc != '\0');
                pszSrc++;
            }
            pszSrc++;

            if ( strchr( pszSrc, ':' ) )
            {
                while( *pszSrc != ':' )
                {
                    _ASSERT(*pszSrc != '\0');
                    *pszDst++ = *pszSrc++;
                }
            }
        }

        *pszDst = '\0';

        pProp->psProperty.propid = PID_HDR_NEWSGROUP;
        m_fXRefFound = TRUE;
    }
    else if( !lstrcmpi(pHeaderRow->pszName, STR_HDR_DATE) )
    {
        // set prop value type
        m_pHeaderProp->vt = VT_FILETIME;
        // bug #32922: If this is a mail message then it should have a receive
        // line that contains the time that the message was received at the server.
        // If this is not available (always true for nws files) then get the Date
        // header.
        // try to get received time
        hr = m_pMsgPropSet->GetProp(PIDTOSTR(STR_ATT_RECVTIME),0,m_pHeaderProp);
        // if this fails then just get the regular date header
        if( FAILED(hr) )
            hr = m_pMsgPropSet->GetProp(PIDTOSTR(PID_HDR_DATE),0,m_pHeaderProp);
        pProp->psProperty.propid = PID_HDR_DATE;
    }
    else if( !lstrcmpi(pHeaderRow->pszName, STR_HDR_LINES) )
    {
        // set prop value type
        m_pHeaderProp->vt = VT_UI4;
        m_pHeaderProp->ulVal = (ULONG)atol(pszData);
    }

    if( pProp->psProperty.propid == 0 )
    {
        // property does not have a PROPID
        // use the property name
        int cb = lstrlen(pHeaderRow->pszName);
                // _ASSERT( cb <= MAX_HEADER_BUF);
        pProp->psProperty.lpwstr = m_wcHeaderBuf;
        if( !MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,
            pHeaderRow->pszName,-1,pProp->psProperty.lpwstr,
            min(cb, MAX_HEADER_BUF) + 1) )
            return HRGetLastError();
        pProp->psProperty.ulKind = PRSPEC_LPWSTR;
    }

    if( m_pHeaderProp->vt == VT_LPWSTR )
        hr = AstrToWstr(pszData,&m_pHeaderProp->pwszVal,CP_ACP);

    LeaveMethod();
    return hr;
}


STDMETHODIMP CMimeFilter::MapSpecialProperty(FULLPROPSPEC* pProp)
{
    HRESULT hr = NOERROR;
    char*   pstr = NULL;
    EnterMethod("CMimeFilter::MapSpecialProperty");

    // alloc prop variant
    m_pHeaderProp = (PROPVARIANT*) CoTaskMemAlloc (sizeof (PROPVARIANT));
    if( m_pHeaderProp == NULL )
    {
        hr = E_OUTOFMEMORY;
        TraceHR(hr);
        return hr;
    }

    // set prop value type
    m_pHeaderProp->vt = VT_LPWSTR;
    m_pHeaderProp->pwszVal = NULL;

    // set propset guid
    pProp->guidPropSet = CLSID_NNTP_SummaryInformation;

    // default to kind to prop id
    pProp->psProperty.ulKind = PRSPEC_PROPID;
    pProp->psProperty.propid = 0;
    pProp->psProperty.lpwstr = NULL;

    switch( m_SpecialProp )
    {
    case PROP_NEWSGROUP:
        if( !m_fXRefFound && m_pszNewsGroups != NULL )
        {
            // set the XRefFound flag
            m_fXRefFound = TRUE;

            // get the first newsgroup from newsgroups line
            if( NULL != (pstr = strchr(m_pszNewsGroups,',')))
                *pstr = '\0';

            pstr = m_pszNewsGroups;

            pProp->psProperty.ulKind = g_psExtraHeaders[m_SpecialProp].ulKind;
            pProp->psProperty.propid = g_psExtraHeaders[m_SpecialProp].propid;
        }
        else
            hr = S_FALSE;
        break;

    case PROP_ARTICLEID:

        if( m_pwszFileName != NULL )
        {
            // clear retrieved flag
            m_fRetrieved = FALSE;

            // set prop value type
            m_pHeaderProp->vt = VT_UI4;
            m_pHeaderProp->ulVal = FnameToArticleIdW(m_pwszFileName);

            pProp->psProperty.ulKind = g_psExtraHeaders[m_SpecialProp].ulKind;
            pProp->psProperty.propid = g_psExtraHeaders[m_SpecialProp].propid;
        }
        else
            hr = S_FALSE;

        break;

        case PROP_RECVTIME:
        // clear retrieved flag
        m_fRetrieved = FALSE;

                // set variant type
        m_pHeaderProp->vt = VT_FILETIME;

        // try to get received time
        hr = m_pMsgPropSet->GetProp(PIDTOSTR(STR_ATT_RECVTIME),0,m_pHeaderProp);

        // if this fails then just get the regular date header
        if( FAILED(hr) )
            hr = m_pMsgPropSet->GetProp(PIDTOSTR(PID_HDR_DATE),0,m_pHeaderProp);

                // set return prop info
        pProp->psProperty.ulKind = g_psExtraHeaders[m_SpecialProp].ulKind;
        pProp->psProperty.propid = g_psExtraHeaders[m_SpecialProp].propid;
                break;

    default:
        hr = S_FALSE;
        break;
    }

    if( m_pHeaderProp->vt == VT_LPWSTR && hr == NOERROR )
        hr = AstrToWstr(pstr,&m_pHeaderProp->pwszVal,CP_ACP);

    LeaveMethod();
    return hr;
}


STDMETHODIMP CMimeFilter::BindEmbeddedObjectToIFilter(HBODY hBody)
{
    HRESULT     hr = S_OK;
    IMimeBody*  pBody = NULL;
    IStream*    pstmBody = NULL;
    PROPVARIANT varFileName = {0};
    DWORD       dwFlags = 0;
    STATSTG     stat = {0};
    BOOL        fIsMailOrNewsFile = FALSE;
    ULONG       grfFlags = m_fInitFlags;
    IMimePropertySet*   pMsgPropSet = NULL;
	//jzhao for bug w2k30744:
	//we have 3 dwords: process ID, thread ID and unique ID, convert to hex ( * 2 ), 3 connectors('_') and one final \0
    CHAR        szTempFileKey[28];
    DWORD               dwStrLen1, dwStrLen2;

    EnterMethod("CMimeFilter::BindEmbeddedObjectToIFilter");

    // get IMimePropertySet interface
    hr = m_pMessageTree->BindToObject(hBody,IID_IMimePropertySet,(void**)&pMsgPropSet);
    if (FAILED(hr))
    {
        TraceHR(hr);
        goto Exit;
    }

    // open the body
    hr = m_pMessageTree->BindToObject(hBody,IID_IMimeBody,(void**)&pBody);
    if (FAILED(hr))
    {
        TraceHR(hr);
        goto Exit;
    }

    // get stream to attached data
    hr = pBody->GetData(IET_BINARY,&pstmBody);
    if (FAILED(hr))
    {
        TraceHR(hr);
        goto Exit;
    }

    // release existing IFilter
    if( m_pEmbeddedFilter != NULL )
    {
        m_pEmbeddedFilter->Release();
        m_pEmbeddedFilter = NULL;
    }

#if 0
        // XXX: This is overwritten below

    if( SUCCEEDED(hr = pstmBody->Stat(&stat,STATFLAG_NONAME)) )
    {
        fIsMailOrNewsFile = ( IsEqualCLSID(stat.clsid,CLSID_NNTPFILE) || IsEqualCLSID(stat.clsid,CLSID_MAILFILE) );

#if 0
        // Attempt to bind stream to IFilter
        // this only works if the IFilter supports
        // IPersistStream
        hr = BindIFilterFromStream(pstmBody, NULL, (void**)&m_pEmbeddedFilter);
#else
                // this will cause the below code to write the stream to a file and do
                // its work that way.
                hr = E_FAIL;
#endif
    }

    if( FAILED(hr) )    // Always want to do this
#endif
    {
        // couldn't bind to stream, try binding to file

        // does it have a file name associated with it
        varFileName.vt = VT_LPSTR;
        hr = pMsgPropSet->GetProp(STR_ATT_FILENAME, 0, &varFileName);
        if( hr == MIME_E_NOT_FOUND )
            hr = pMsgPropSet->GetProp(STR_ATT_GENFNAME, 0, &varFileName);
        if (SUCCEEDED(hr) && varFileName.pszVal == NULL)
                hr = E_OUTOFMEMORY;
        if (FAILED(hr))
        {
            TraceHR(hr);
            goto Exit;
        }

        // create temp file name
        if( m_pszEmbeddedFile == NULL )
        {
            m_pszEmbeddedFile = new char[MAX_PATH*2];
            if( m_pszEmbeddedFile == NULL )
            {
                hr = E_OUTOFMEMORY;
                TraceHR(hr);
                goto Exit;
            }
        }
        else if( *m_pszEmbeddedFile != '\0' )
        {
            // we have an existing file so delete it
            DeleteFile(m_pszEmbeddedFile);
        }
        *m_pszEmbeddedFile = '\0';

        // get the temp dir
        GetTempPath(MAX_PATH,m_pszEmbeddedFile);

        // add the temp file key
        _VERIFY( SUCCEEDED( GenTempFileKey( szTempFileKey, 28 ) ) );
        strncat( m_pszEmbeddedFile, szTempFileKey, 28 );

        // sometime the filename could be too long for the buffer, we need to check that
        dwStrLen1 = lstrlen (m_pszEmbeddedFile);
        if(dwStrLen1 < MAX_PATH - 1)
		{
			strncat(m_pszEmbeddedFile, varFileName.pszVal, MAX_PATH - dwStrLen1 - 1);
		}
        else
        {
            hr = ERROR_FILENAME_EXCED_RANGE;
            TraceHR(hr);
			goto Exit;
		}

		// null terminate it
		m_pszEmbeddedFile[MAX_PATH-1] = '\0';

        // copy stream to file
        hr = WriteStreamToFile(pstmBody,m_pszEmbeddedFile);
        if( FAILED(hr) )
        {
            // couldn't copy stream to file
            TraceHR(hr);
            goto Exit;
        }

        // load ifilter
        hr = LoadIFilterA(m_pszEmbeddedFile, NULL, (void**)&m_pEmbeddedFilter);
        if( FAILED(hr) )
        {
            // no IFilter found for this embedded file
            // rather than aborting we just goto the next
            // body part
            TraceHR(hr);
            DebugTrace((LPARAM)this,"No IFilter for = %s",varFileName.pszVal);
            goto Exit;
        }
        fIsMailOrNewsFile = IsMailOrNewsFile(m_pszEmbeddedFile);
    }

    // init ifilter
    if( fIsMailOrNewsFile )
    {
        // use the flags from Init call, but do not include any properties.
        grfFlags = m_fInitFlags & ~IFILTER_INIT_APPLY_INDEX_ATTRIBUTES & ~IFILTER_INIT_APPLY_OTHER_ATTRIBUTES;
    }
    hr = m_pEmbeddedFilter->Init(grfFlags,0,NULL,&dwFlags);
    if( FAILED(hr) )
    {
        // unable to init IFilter
        TraceHR(hr);
        goto Exit;
    }

Exit:
    // clean up
    if(varFileName.pszVal)
        m_pMalloc->PropVariantClear(&varFileName);
    if(pBody)
        pBody->Release();
    if(pstmBody)
        pstmBody->Release();
    if(pMsgPropSet)
        pMsgPropSet->Release();

    LeaveMethod();
    return hr;
}


STDMETHODIMP CMimeFilter::GetBodyCodePage(IMimeBody* pBody,CODEPAGEID* pcpiBody)
{
    HRESULT     hr = S_OK;
    HCHARSET    hCharSet = 0;
    INETCSETINFO    CsetInfo = {0};


    EnterMethod("CMimeFilter::GetBodyCodePage");

    while(TRUE)
    {
        hr = pBody->GetCharset(&hCharSet);
        if( FAILED(hr) )
        {
            TraceHR(hr);
            break;
        }
        if( m_pMimeIntl == NULL )
        {
            // get the mime international interface
            hr = CoCreateInstance(CLSID_IMimeInternational, NULL, CLSCTX_INPROC_SERVER, 
                IID_IMimeInternational, (LPVOID *)&m_pMimeIntl);
            if (FAILED(hr))
            {
                TraceHR(hr);
                break;
            }
        }

        // get charset info
        hr = m_pMimeIntl->GetCharsetInfo(hCharSet,&CsetInfo);
        if( FAILED(hr) )
        {
            TraceHR(hr);
            break;
        }

        // return codepage id
        *pcpiBody = CsetInfo.cpiWindows;

        break;
    }

    LeaveMethod();
    return hr;
}

HRESULT
CMimeFilter::GenTempFileKey(    LPSTR   szOutput, LONG lBufSize )
/*++
Routine description:

    Generate the temp file key, to be composed into the temp file 
    name.  The key monotonically increases.  Caller must prepare a 
    buffer of no less than 9 bytes, because the key is going to 
    be convert into string in hex mode.

Arguments:

    szOutput - to return the key in the form of string

Return value:

    S_OK - if succeeded, other error code otherwise
--*/
{
    _ASSERT( szOutput );

    DWORD    dwKey = InterlockedIncrement( (PLONG)&m_dwTempFileNameKey );
	_snprintf( szOutput, lBufSize, "%x_%x_%x_", GetCurrentProcessId(), GetCurrentThreadId(), dwKey );

    return S_OK;
}

SCODE WriteStreamToFile(IStream* pStream, char* pszFileName)
{
    HRESULT hr = S_OK;
    BYTE    bBuffer[4096];
    DWORD   cb, cbWritten;
    HANDLE  hFile = INVALID_HANDLE_VALUE;

    if( pStream == NULL || pszFileName == NULL || *pszFileName == 0 )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // create the file
    hFile = CreateFile(pszFileName,
        GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_TEMPORARY,
        NULL);
    if( hFile == INVALID_HANDLE_VALUE )
    {
        hr = HRGetLastError();
        goto Exit;
    }

    // copy stream to file
    while( SUCCEEDED(pStream->Read(&bBuffer,4096,&cb)) && cb != 0 )
    {
        if(!WriteFile(hFile,bBuffer,cb,&cbWritten,NULL))
        {
            hr = HRGetLastError();
            goto Exit;
        }
    }

Exit:
    if( hFile != INVALID_HANDLE_VALUE )
        _VERIFY(CloseHandle(hFile));

    return hr;
}

SCODE LoadIFilterA( char* pszFileName, IUnknown * pUnkOuter, void ** ppIUnk )
{
    WCHAR wcFileName[MAX_PATH];

    if( !MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,
        pszFileName,-1,wcFileName,MAX_PATH) )
        return HRGetLastError();

    // load ifilter
    return LoadIFilter(wcFileName, pUnkOuter, ppIUnk);
}

#if 0
BOOL GetFileClsid(char* pszAttFile,CLSID* pclsid)
{
    DWORD   cb = 0;
    char*   pszExt = NULL;
    char    szTypeName[256];
    char    szSubKey[256];
    char    szClsId[128];
    OLECHAR oszClsId[128];

    // get file extension from filename
    if( NULL == (pszExt = strrchr(pszAttFile,'.')) )
        return FALSE; // no filter

    // get the file's type name
    cb = sizeof(szTypeName);
    if(!GetStringRegValue(HKEY_CLASSES_ROOT,pszExt,NULL,szTypeName,cb))
        return FALSE;

    // get the file's type name clsid
    cb = sizeof(szClsId);
    wsprintf(szSubKey,"%s\\CLSID",szTypeName);
    if(!GetStringRegValue(HKEY_CLASSES_ROOT,szSubKey,"",szClsId,cb))
        return FALSE;

    // convert szClsId to CLSID
    if( !MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,
        szClsId,-1,oszClsId,sizeof(oszClsId)/2) )
        return FALSE;

    return SUCCEEDED(CLSIDFromString(oszClsId,pclsid));
}
#endif

STDMETHODIMP CMimeFilter::LoadFromFile( LPCWSTR psszFileName, DWORD dwMode )
{
    EnterMethod("CImpIPersistFile::LoadFromFile");
    HRESULT hr = S_OK;
    HANDLE  hFile = INVALID_HANDLE_VALUE;

    // free previously allocated storage
    if ( m_pwszFileName != NULL )
    {
        delete m_pwszFileName;
        m_pwszFileName = NULL;
    }

    if ( 0 != m_pstmFile )
    {
        m_pstmFile->Release();
        m_pstmFile = 0;
    }

#if !defined( NOTRACE )
    char szFile[MAX_PATH];
    WideCharToMultiByte(CP_ACP,0,psszFileName,-1,szFile,sizeof(szFile)-1,NULL,NULL);
    DebugTrace((LPARAM)this,"psszFileName = %s",szFile);
#endif

    // get length of filename
    unsigned cLen = wcslen( psszFileName ) + 1;

    // if filename is empty then we have a problem
    if( cLen == 1 )
    {
        hr = E_INVALIDARG;
        TraceHR(hr);
        return hr;
    }

    // allocate storage for filename
    m_pwszFileName = new WCHAR[cLen];
    if( m_pwszFileName == NULL )
    {
        hr = E_OUTOFMEMORY;
        TraceHR(hr);
        return hr;
    }
    
    _VERIFY( 0 != wcscpy( m_pwszFileName, psszFileName ) );

    // open message file
    hFile = CreateFileW(m_pwszFileName,GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,
        OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
    if( hFile == INVALID_HANDLE_VALUE )
    {
        hr = HRGetLastError();
        TraceHR(hr);
        return hr;
    }

    // create Stream on hfile
    m_pstmFile = (IStream*) new CStreamFile(hFile,TRUE);
    if( m_pstmFile == NULL )
    {
        _VERIFY(CloseHandle(hFile));
        hr = E_OUTOFMEMORY;
        TraceHR(hr);
        return hr;
    }

    LeaveMethod();
    return hr;
}

STDMETHODIMP CMimeFilter::LoadFromStream(IStream* pstm)
{
    EnterMethod("CImpIPersistFile::LoadFromStream");
    HRESULT hr = S_OK;

    if( pstm == NULL )
        return E_INVALIDARG;

    // do we have an existing IStream
    if( m_pstmFile != NULL )
    {
        // release it
        m_pstmFile->Release();
        m_pstmFile = NULL;
    }

    m_pstmFile = pstm;
    m_pstmFile->AddRef();

    LeaveMethod();
    return hr;
}


void FreePropVariant(PROPVARIANT* pProp)
{
    if( pProp == NULL )
        return;

    if( pProp->vt == VT_LPWSTR && pProp->pwszVal != NULL )
        CoTaskMemFree(pProp->pwszVal);

    CoTaskMemFree(pProp);
}


STDMETHODIMP AstrToWstr(char* pstr,WCHAR** ppwstr,UINT codepage)
{
    int cb = 0;

    // alloc mem for prop
    cb = lstrlen(pstr) + 1;
    *ppwstr = (WCHAR *) CoTaskMemAlloc(cb * sizeof(WCHAR));
    if( *ppwstr == NULL )
        return E_OUTOFMEMORY;

    // convert to unicode
    if( !MultiByteToWideChar(codepage,MB_PRECOMPOSED,
        pstr,-1,*ppwstr,cb) )
        return HRGetLastError();

    return NOERROR;
}

DWORD ulFactor[8] = {0x10,0x1,0x1000,0x100,0x100000,0x10000,0x10000000,0x1000000};
ULONG FnameToArticleIdW(WCHAR *pwszPath)
{
    WCHAR   wszFname[MAX_PATH];
    WCHAR   wszExt[MAX_PATH];
    ULONG   ulRet = 0;
    ULONG   ulNum = 0;
    int     nLen = 0;
    int     n = 0;
    int     f = 0;

    _wcslwr(pwszPath);
    _wsplitpath(pwszPath,NULL,NULL,wszFname,wszExt);
    nLen = wcslen(wszFname);
    //
    //  MAIL and NEWS file naming convention is slightly different.
    //
    if( (0 == wcscmp(wszExt,g_wszNewsExt)) && (nLen <= 8))
    {
        if( nLen % 2 != 0 )
            f = 1;
        for(;n < nLen;n++, f++)
        {
            if( wszFname[n] >= L'0' && wszFname[n] <= L'9' )
                ulNum = wszFname[n] - L'0';
            else if( wszFname[n] >= L'a' && wszFname[n] <= L'f' )
                ulNum = wszFname[n] - L'a' + 10;
            else
                return 0; // not a valid article id

            ulRet += ulNum * ulFactor[f];
        }
    } else if( (0 == wcscmp(wszExt,g_wszMailExt)) && (nLen == 8)) {
        //
        //  Exp will be zero when we point to dot in extension.
        //
        for ( DWORD exp = 1;  exp;  n++, exp <<= 4) {
            if(  wszFname[ n] >= L'0' && wszFname[ n] <= L'9' ) {
                ulNum = wszFname[ n] - L'0';
            } else if ( wszFname[ n] >= L'a' && wszFname[ n] <= L'f' ) {
                ulNum = wszFname[ n] - L'a' + 10;
            } else {
                return( 0);
            }
            ulRet += ulNum * exp;
        }
    }
    return ulRet;
}

BOOL IsMailOrNewsFile(char *pszPath)
{
    char szExt[MAX_PATH];

    _splitpath(pszPath,NULL,NULL,NULL,szExt);
    return ( 0 == _stricmp(szExt,g_szNewsExt) || 0 == _stricmp(szExt,g_szMailExt) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\mimefilt.h ===
#if !defined( __MIMEFILT_H__ )
#define __MIMEFILT_H__

#include <ole2.h>
#include <windows.h>
#define OLEDBVER 0x0250
#include <oledb.h>
#include <cmdtree.h>
#include <stdio.h>
#include <query.h>
#include <ciintf.h>
#include <ntquery.h>
#include <filterr.h>
// having tracing in the filter basically makes tracing other parts of
// the system useless, since the filter is always running
// #define NOTRACE
#include <dbgtrace.h>
#include <mimeole.h>
#include <cstream.h>

#include "def_guid.h"
#include "regutil.h"

#include "cmf.h"
#include "cfactory.h"

#define HRGetLastError() HRESULT_FROM_WIN32(GetLastError())

#define EnterMethod(sz) TraceFunctEnterEx((LPARAM)this,sz)
#define LeaveMethod() TraceFunctLeaveEx((LPARAM)this)
#define TraceHR(hr) DebugTrace((LPARAM)this,"hr = 0x%08x", hr)
#endif // __MIMEFILT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\def_guid.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:       htmlguid.hxx
//
//  Contents:   Declarations of Html properties
//
//  This code and information is provided "as is" without warranty of
//  any kind, either expressed or implied, including but not limited to
//  the implied warranties of merchantability and/or fitness for a
//  particular purpose.
//
//--------------------------------------------------------------------------

#if !defined( __HTMLGUID_HXX__ )
#define __HTMLGUID_HXX__
#include "stgprop.h"

//
// Various property sets - storage, summary information and html information
//
extern GUID CLSID_Storage;

extern GUID CLSID_NNTP_SummaryInformation;

const PID_NEWSGROUP  = 2;
const PID_NEWSGROUPS = 3;
const PID_REFERENCES = 4;
const PID_SUBJECT    = 5;
const PID_FROM       = 6;
const PID_MSGID      = 7;
const PID_EXTRA      = 8;

// extern GUID CLSID_NNTPInformation;
extern GUID CLSID_NNTPFILE ;
extern GUID CLSID_NNTP_PERSISTENT ;
extern GUID CLSID_MimeFilter;
extern GUID CLSID_InsoUniversalFilter;
extern GUID CLSID_MAILFILE ;
extern GUID CLSID_MAIL_PERSISTENT ;


// extern GUID CLSID_HtmlInformation;

// const DOC_TITLE = 2;

#endif // __HTMLGUID_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\mimefilt.cpp ===
#include "mimefilt.h"

extern long gulcInstances;

char szNewsExt[] = {".nws"};
char szNewsProgId[] ="Microsoft Internet News Message";
char szNewsFileDesc[] ="Internet News Message";

char szMailExt[] =".eml";
char szMailProgId[] ="Microsoft Internet Mail Message";
char szMailFileDesc[] ="Internet E-Mail Message";

void RegisterFilter(HINSTANCE hInst,LPSTR pszExt,LPSTR pszProgId,LPSTR pszDesc,GUID ClsId,GUID PersistId)
{
	//   The following are the set of reg keys required for Tripoli
	//
	//   1. Create entry ".nws", with value "Microsoft Internet News Message"
	//   2. Create entry "Microsoft Internet News Message", value="Internet News Message"
	//   3. Create entry "Microsoft Internet News Message\CLSID" value = CLSID_NNTPFILE
	//   4. Create entry "CLSID\CLSID_NNTPFILE" value = "NNTP filter"
	//   5. Create entry "CLSID\CLSID_NNTPFILE\PersistentHandler" 
	//						value = CLSID_NNTP_PERSISTENT
	//   6. Create entry "CLSID\CLSID_NNTP_PERSISTENT" value = ""
	//   7. create "CLSID\CLSID_MimeFilter\InprocServer32"
	//

    HKEY    hKey;
    char    szSubKey[256];
    char    szClsId[128];
    OLECHAR oszClsId[128];

	//   1. Create the extension entry, with value nntpfile

    if (ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, pszExt, &hKey)) {
	    RegSetValue(hKey, NULL, REG_SZ, pszProgId, sizeof(szClsId));
    	RegCloseKey(hKey);
    }

	//   2. Create entry "Microsoft Internet News Message", value="Internet News Message"

    if (ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, pszProgId, &hKey)) {
	    RegSetValue(hKey, NULL, REG_SZ, pszDesc, sizeof(szClsId));
    	RegCloseKey(hKey);
    }

	//   3. Create entry "Microsoft Internet News Message\CLSID"

    StringFromGUID2( ClsId, oszClsId, sizeof(oszClsId)/sizeof(oszClsId[0]));
    WideCharToMultiByte(CP_ACP, 0, oszClsId, -1, szClsId, sizeof(szClsId), NULL, NULL);

    wsprintf(szSubKey, "%s\\CLSID", pszProgId );

    if (ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, szSubKey, &hKey)) {
	    RegSetValue(hKey, NULL, REG_SZ, szClsId, sizeof(szClsId));
    	RegCloseKey(hKey);
    }

	//   4. Create entry "CLSID\CLSID_NNTPFILE" value = "NNTP file"

    wsprintf(szSubKey, "CLSID\\%s", szClsId );
	wsprintf(szClsId, "NNTP filter");

    if (ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, szSubKey, &hKey)) {
	    RegSetValue(hKey, NULL, REG_SZ, szClsId, sizeof(szClsId));
    	RegCloseKey(hKey);
    }

	//   5. Create entry "CLSID\CLSID_NNTPFILE\PersistentHandler" 
	//						value = CLSID_NNTP_PERSISTENT

    wsprintf(szClsId, "%s", szSubKey );
    wsprintf(szSubKey, "%s\\PersistentHandler", szClsId );

    StringFromGUID2( PersistId, oszClsId, sizeof(oszClsId)/sizeof(oszClsId[0]));
    WideCharToMultiByte(CP_ACP, 0, oszClsId, -1, szClsId, sizeof(szClsId),
						NULL, NULL);

    if (ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, szSubKey, &hKey)) {
	    RegSetValue(hKey, NULL, REG_SZ, szClsId, sizeof(szClsId));
    	RegCloseKey(hKey);
    }

	//   6. Create entry "CLSID\CLSID_NNTP_PERSISTENT" value = ""
	char szClsId1[128];

    StringFromGUID2( IID_IFilter, oszClsId, sizeof(oszClsId)/sizeof(oszClsId[0]));
    WideCharToMultiByte(CP_ACP, 0, oszClsId, -1, szClsId1, sizeof(szClsId1), NULL, NULL);

	wsprintf(szSubKey, "CLSID\\%s\\PersistentAddinsRegistered\\%s",szClsId,szClsId1);

    StringFromGUID2( CLSID_MimeFilter, oszClsId, sizeof(oszClsId)/sizeof(oszClsId[0]));
    WideCharToMultiByte(CP_ACP, 0, oszClsId, -1, szClsId, sizeof(szClsId), NULL, NULL);

    if (ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, szSubKey, &hKey)) {
	    RegSetValue(hKey, NULL, REG_SZ, szClsId, sizeof(szClsId));
    	RegCloseKey(hKey);
    }

	//    7. create "CLSID\CLSID_MimeFilter\InprocServer32"
	wsprintf(szSubKey, "CLSID\\%s\\InprocServer32",szClsId);

	// filename
    GetModuleFileName(hInst, szClsId, sizeof(szClsId));

    if (ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, szSubKey, &hKey)) {
	    RegSetValue(hKey, NULL, REG_SZ, szClsId, sizeof(szClsId));
    	SetStringRegValue( hKey, "ThreadingModel", "Both" );
		RegCloseKey(hKey);
    }

}

void UnregisterFilter(LPSTR pszExt,LPSTR pszProgId,LPSTR pszDesc,GUID ClsId,GUID PersistId)
{
	//
	// remove the reg key installed
	//

	char    szSubKey[256];
	char    szClsId[128];
	OLECHAR oszClsId[128];
    HKEY    hKey;
	HKEY	hKeyExt;
	DWORD	cb = 0;

	// open HKEY_CLASSES_ROOT
	if( 0 == RegOpenKeyEx(HKEY_CLASSES_ROOT,NULL,0,KEY_ALL_ACCESS,&hKey) )
	{
		StringFromGUID2( ClsId, oszClsId, sizeof(oszClsId)/sizeof(oszClsId[0]));
		WideCharToMultiByte(CP_ACP, 0, oszClsId, -1, szClsId, sizeof(szClsId),
				NULL, NULL);

		wsprintf(szSubKey, "CLSID\\%s", szClsId);
		DeleteRegSubtree(hKey, szSubKey );

		StringFromGUID2( PersistId, oszClsId, sizeof(oszClsId)/sizeof(oszClsId[0]));
		WideCharToMultiByte(CP_ACP, 0, oszClsId, -1, szClsId, sizeof(szClsId),
				NULL, NULL);

		wsprintf(szSubKey, "CLSID\\%s", szClsId);
		DeleteRegSubtree(hKey, szSubKey );

		StringFromGUID2( CLSID_MimeFilter, oszClsId, sizeof(oszClsId)/sizeof(oszClsId[0]));
		WideCharToMultiByte(CP_ACP, 0, oszClsId, -1, szClsId, sizeof(szClsId),
				NULL, NULL);

		wsprintf(szSubKey, "CLSID\\%s", szClsId);
		DeleteRegSubtree(hKey, szSubKey );

		// open the .nws subkey
		if( 0 == RegOpenKeyEx(hKey,pszExt,0,KEY_ALL_ACCESS,&hKeyExt) )
		{
			// get size of "Content Type" value
			RegQueryValueEx(hKeyExt,"Content Type",NULL,NULL,NULL,&cb);
			RegCloseKey(hKeyExt);
		}

		if( cb != 0 )
		{
			// "Content Type" value exists. Because this was created by Athena
			// we do not want to delete the szFileExtesion or szFileType keys
			wsprintf(szSubKey, "%s\\CLSID", pszProgId);
			RegDeleteKey(hKey, szSubKey );
		}
		else
		{
			// "Content Type" does not exist so delete both keys.
			RegDeleteKey(hKey,pszExt);
			DeleteRegSubtree(hKey,pszProgId);
		}

		RegCloseKey(hKey);
	}
}

STDAPI _DllRegisterServer(HINSTANCE hInst)
{
	RegisterFilter(hInst,szNewsExt,szNewsProgId,szNewsFileDesc,CLSID_NNTPFILE,CLSID_NNTP_PERSISTENT);
	RegisterFilter(hInst,szMailExt,szMailProgId,szMailFileDesc,CLSID_MAILFILE,CLSID_MAIL_PERSISTENT);
	return S_OK;
}

STDAPI _DllUnregisterServer()
{
	UnregisterFilter(szNewsExt,szNewsProgId,szNewsFileDesc,CLSID_NNTPFILE,CLSID_NNTP_PERSISTENT);
	UnregisterFilter(szMailExt,szMailProgId,szMailFileDesc,CLSID_MAILFILE,CLSID_MAIL_PERSISTENT);
	return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//  Returns:    NNTP filter class factory
//
//--------------------------------------------------------------------------

extern "C" STDMETHODIMP DllGetClassObject( REFCLSID   cid,
		REFIID     iid,
		void **    ppvObj )
{

	IUnknown *  pResult = 0;
	HRESULT       hr      = S_OK;

	if ( cid == CLSID_MimeFilter )
	{
		pResult = (IUnknown *) new CMimeFilterCF;

		if ( 0 == pResult )
			hr = E_OUTOFMEMORY;
	}
	else
	{
		hr = E_NOINTERFACE;
	}

	if ( pResult )
	{
		hr = pResult->QueryInterface( iid, ppvObj );
		pResult->Release();     // Release extra refcount from QueryInterface
	}

	return (hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//--------------------------------------------------------------------------

extern "C" STDMETHODIMP DllCanUnloadNow( void )
{
	if ( 0 == gulcInstances )
		return( S_OK );
	else
		return( S_FALSE );
}

static HINSTANCE g_hInst;

extern "C" STDAPI DllRegisterServer()
{
	return _DllRegisterServer(g_hInst);
}

extern "C" STDAPI DllUnregisterServer()
{
	return _DllUnregisterServer();
}

extern "C" BOOL WINAPI DllMain( HINSTANCE hInst, DWORD dwReason, LPVOID lbv)
{
	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:

			g_hInst = hInst;

			break;

		case DLL_PROCESS_DETACH:

			break;
	}

	return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterCF::CMimeFilterCF
//
//  Synopsis:   NNTP IFilter class factory constructor
//
//+-------------------------------------------------------------------------

CMimeFilterCF::CMimeFilterCF()
{
    _uRefs = 1;
    InterlockedIncrement( &gulcInstances );
	InitAsyncTrace();
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterCF::~CMimeFilterCF
//
//  Synopsis:   NNTP IFilter class factory destructor
//
//--------------------------------------------------------------------------

CMimeFilterCF::~CMimeFilterCF()
{
	TermAsyncTrace();
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//--------------------------------------------------------------------------

STDMETHODIMP CMimeFilterCF::QueryInterface( REFIID riid,
                                                        void  ** ppvObject )
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown      = 00000000-0000-0000-C000-000000000046
    // IID_IClassFactory = 00000001-0000-0000-C000-000000000046
    //                           --
    //                           |
    //                           +--- Unique!
    //

    _ASSERT( (IID_IUnknown.Data1      & 0x000000FF) == 0x00 );
    _ASSERT( (IID_IClassFactory.Data1 & 0x000000FF) == 0x01 );

    IUnknown *pUnkTemp = 0;
    HRESULT hr = S_OK;

    switch( riid.Data1 & 0x000000FF )
    {
    case 0x00:
        if ( IID_IUnknown == riid )
            pUnkTemp = (IUnknown *)(IPersist *)(IPersistFile *)this;
        else
            hr = E_NOINTERFACE;
        break;

    case 0x01:
        if ( IID_IClassFactory == riid )
            pUnkTemp = (IUnknown *)(IClassFactory *)this;
        else
            hr = E_NOINTERFACE;
        break;

    default:
        pUnkTemp = 0;
        hr = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }

    return(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterCF::AddRef
//
//  Synopsis:   Increments refcount
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CMimeFilterCF::AddRef()
{
    return InterlockedIncrement( &_uRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CMimeFilterCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_uRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterCF::CreateInstance
//
//  Synopsis:   Creates new CMimeFilter object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//--------------------------------------------------------------------------

STDMETHODIMP CMimeFilterCF::CreateInstance( IUnknown * pUnkOuter,
                                            REFIID riid,
                                            void  * * ppvObject )
{
    CMimeFilter *  pIUnk = 0;
    HRESULT hr = NOERROR;

	_ASSERT( ppvObject != NULL );

	// check args
	if( ppvObject == NULL )
		return E_INVALIDARG;

	// create object
    pIUnk = new CMimeFilter(pUnkOuter);
	if( pIUnk == NULL )
		return E_OUTOFMEMORY;

	// init object
	hr = pIUnk->HRInitObject();

	if( FAILED(hr) )
	{
		delete pIUnk;
		return hr;
	}

	// get requested interface
    hr = pIUnk->QueryInterface(  riid , ppvObject );
	if( FAILED(hr) )
	{
		pIUnk->Release();
		return hr;
	}

    return (hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CMimeFilterCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------

STDMETHODIMP CMimeFilterCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\cmfpstm.cpp ===
#include "mimefilt.h"

//+---------------------------------------------------------------------------
// CImpIPersistStream::CImpIPersistStream
// CImpIPersistStream::~CImpIPersistStream
//
// Constructor Parameters:
//  pObj            LPVOID pointing to the object we live in.
//  pUnkOuter       LPUNKNOWN of the controlling unknown.
//+---------------------------------------------------------------------------

CImpIPersistStream::CImpIPersistStream(CMimeFilter* pObj
    , LPUNKNOWN pUnkOuter)
    {
	EnterMethod("CImpIPersistStream::CImpIPersistStream");
    m_cRef=0;
    m_pObj=pObj;
    m_pUnkOuter=pUnkOuter;
	LeaveMethod();
    return;
    }


CImpIPersistStream::~CImpIPersistStream(void)
    {
	EnterMethod("CImpIPersistStream::~CImpIPersistStream");
	_ASSERT( m_cRef == 0 );
	LeaveMethod();
    return;
    }


//+---------------------------------------------------------------------------
//
// CImpIPersistStream::QueryInterface
// CImpIPersistStream::AddRef
// CImpIPersistStream::Release
//
// Purpose:
//  Standard set of IUnknown members for this interface
//
//+---------------------------------------------------------------------------


STDMETHODIMP CImpIPersistStream::QueryInterface(REFIID riid
    , void** ppv)
    {
	EnterMethod("CImpIPersistStream::QueryInterface");
	LeaveMethod();
    return m_pUnkOuter->QueryInterface(riid, ppv);
    }

STDMETHODIMP_(ULONG) CImpIPersistStream::AddRef(void)
    {
	EnterMethod("CImpIPersistStream::AddRef");
    InterlockedIncrement(&m_cRef);
	LeaveMethod();
    return m_pUnkOuter->AddRef();
    }

STDMETHODIMP_(ULONG) CImpIPersistStream::Release(void)
    {
	EnterMethod("CImpIPersistStream::Release");
	InterlockedDecrement(&m_cRef);
	LeaveMethod();
    return m_pUnkOuter->Release();
    }

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistStream::GetClassID, public
//
//  Synopsis:   Returns the class id of this class.
//
//  Arguments:  [pClassID] -- the class id
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistStream::GetClassID( CLSID * pClassID )
{
	EnterMethod("GetClassID");
	*pClassID = CLSID_MimeFilter;
	LeaveMethod();
	return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistStream::IsDirty, public
//
//  Synopsis:   Always returns S_FALSE since the filter is read-only
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistStream::IsDirty()
{
	EnterMethod("CImpIPersistStream::IsDirty");
	LeaveMethod();
	return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistStream::Load, public
//
//  Synopsis:   Loads the indicated file
//
//  Arguments:  [pstm] -- stream to load from
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistStream::Load( IStream*  pstm )
{
	EnterMethod("CImpIPersistStream::Load");
	HRESULT hr = S_OK;

	hr = m_pObj->LoadFromStream(pstm);

	LeaveMethod();
	return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistStream::Save, public
//
//  Synopsis:   Always returns E_FAIL, since the file is opened read-only
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistStream::Save(IStream* pstm,BOOL fClearDirty)
{
	EnterMethod("CImpIPersistStream::Save");
	LeaveMethod();
	return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistStream::GetSizeMax, public
//
//  Synopsis:   Always returns S_OK since the file is opened read-only
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistStream::GetSizeMax(ULARGE_INTEGER* pcbSize)
{
	EnterMethod("CImpIPersistStream::GetSizeMax");

	LeaveMethod();
	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\cmfpf.cpp ===
#include "mimefilt.h"

//+---------------------------------------------------------------------------
// CImpIPersistFile::CImpIPersistFile
// CImpIPersistFile::~CImpIPersistFile
//
// Constructor Parameters:
//  pObj            LPVOID pointing to the object we live in.
//  pUnkOuter       LPUNKNOWN of the controlling unknown.
//+---------------------------------------------------------------------------

CImpIPersistFile::CImpIPersistFile(CMimeFilter* pObj
    , LPUNKNOWN pUnkOuter)
    {
	EnterMethod("CImpIPersistFile::CImpIPersistFile");
    m_cRef=0;
    m_pObj=pObj;
    m_pUnkOuter=pUnkOuter;
	LeaveMethod();
    return;
    }


CImpIPersistFile::~CImpIPersistFile(void)
    {
	EnterMethod("CImpIPersistFile::~CImpIPersistFile");
	_ASSERT( m_cRef == 0 );
	LeaveMethod();
    return;
    }


//+---------------------------------------------------------------------------
//
// CImpIPersistFile::QueryInterface
// CImpIPersistFile::AddRef
// CImpIPersistFile::Release
//
// Purpose:
//  Standard set of IUnknown members for this interface
//
//+---------------------------------------------------------------------------


STDMETHODIMP CImpIPersistFile::QueryInterface(REFIID riid
    , void** ppv)
    {
	EnterMethod("CImpIPersistFile::QueryInterface");
	LeaveMethod();
    return m_pUnkOuter->QueryInterface(riid, ppv);
    }

STDMETHODIMP_(ULONG) CImpIPersistFile::AddRef(void)
    {
	EnterMethod("CImpIPersistFile::AddRef");
    InterlockedIncrement(&m_cRef);
	LeaveMethod();
    return m_pUnkOuter->AddRef();
    }

STDMETHODIMP_(ULONG) CImpIPersistFile::Release(void)
    {
	EnterMethod("CImpIPersistFile::Release");
	InterlockedDecrement(&m_cRef);
	LeaveMethod();
    return m_pUnkOuter->Release();
    }

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistFile::GetClassID, public
//
//  Synopsis:   Returns the class id of this class.
//
//  Arguments:  [pClassID] -- the class id
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistFile::GetClassID( CLSID * pClassID )
{
	EnterMethod("GetClassID");
	*pClassID = CLSID_MimeFilter;
	LeaveMethod();
	return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistFile::IsDirty, public
//
//  Synopsis:   Always returns S_FALSE since the filter is read-only
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistFile::IsDirty()
{
	EnterMethod("CImpIPersistFile::IsDirty");
	LeaveMethod();
	return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistFile::Load, public
//
//  Synopsis:   Loads the indicated file
//
//  Arguments:  [pszFileName] -- the file name
//              [dwMode] -- the mode to load the file in
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistFile::Load( LPCWSTR psszFileName, DWORD dwMode )
{
	EnterMethod("CImpIPersistFile::Load");
	HRESULT hr = S_OK;

	hr = m_pObj->LoadFromFile(psszFileName,dwMode);

	LeaveMethod();
	return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistFile::Save, public
//
//  Synopsis:   Always returns E_FAIL, since the file is opened read-only
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistFile::Save( LPCWSTR pszFileName, BOOL fRemember )
{
	EnterMethod("CImpIPersistFile::Save");
	LeaveMethod();
	return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistFile::SaveCompleted, public
//
//  Synopsis:   Always returns S_OK since the file is opened read-only
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistFile::SaveCompleted( LPCWSTR pszFileName )
{
	EnterMethod("CImpIPersistFile::SaveCompleted");
	LeaveMethod();
	return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpIPersistFile::GetCurFile, public
//
//  Synopsis:   Returns a copy of the current file name
//
//  Arguments:  [ppszFileName] -- where the copied string is returned
//
//----------------------------------------------------------------------------

STDMETHODIMP CImpIPersistFile::GetCurFile( LPWSTR * ppwszFileName )
{
	EnterMethod("CImpIPersistFile::GetCurFile");
	if ( m_pObj->m_pwszFileName == 0 )
		return E_FAIL;

	if( ppwszFileName == NULL )
		return E_INVALIDARG;

	unsigned cLen = wcslen( m_pObj->m_pwszFileName ) + 1;

	if( cLen == 1 )
		return E_INVALIDARG;

	*ppwszFileName = (WCHAR *)CoTaskMemAlloc( cLen * sizeof(WCHAR) );

	if ( *ppwszFileName == NULL )
		return E_OUTOFMEMORY;

	_VERIFY( 0 != wcscpy( *ppwszFileName, m_pObj->m_pwszFileName ) );

	LeaveMethod();
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\def_guid.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:       htmlguid.cxx
//
//  Contents:   Definitions of NNTP properties
//
//  This code and information is provided "as is" without warranty of
//  any kind, either expressed or implied, including but not limited to
//  the implied warranties of merchantability and/or fitness for a
//  particular purpose.
//
//--------------------------------------------------------------------------

#include <ole2.h>
#include <stgprop.h>
#pragma hdrstop

//
// Guids for property sets - storage, summary information and NNTP information
//

GUID CLSID_Storage = PSGUID_STORAGE;


// {AA568EEC-E0E5-11cf-8FDA-00AA00A14F93}
GUID CLSID_NNTP_SummaryInformation =
{ 0xaa568eec, 0xe0e5, 0x11cf, { 0x8f, 0xda, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x93 } };

EXTERN_C const  GUID IID_IFilter = {
    0x89BCB740,
    0x6119,
    0x101A,
    { 0xBC, 0xB7, 0x00, 0xDD, 0x01, 0x06, 0x55, 0xAF }
};



// {5645C8C0-E277-11cf-8FDA-00AA00A14F93}
  GUID CLSID_NNTPFILE  = 
{ 0x5645c8c0, 0xe277, 0x11cf, { 0x8f, 0xda, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x93 } };

// {5645C8C1-E277-11cf-8FDA-00AA00A14F93}
 GUID CLSID_NNTP_PERSISTENT  = 
{ 0x5645c8c1, 0xe277, 0x11cf, { 0x8f, 0xda, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x93 } };

// {5645C8C2-E277-11cf-8FDA-00AA00A14F93}
 GUID CLSID_MimeFilter  = 
{ 0x5645c8c2, 0xe277, 0x11cf, { 0x8f, 0xda, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x93 } };

// {53524bdc-3e9c-101b-abe2-00608c86f49a}
 GUID CLSID_InsoUniversalFilter  = 
{ 0x53524bdc, 0x3e9c, 0x101b, { 0xab, 0xe2, 0x00, 0x60, 0x8c, 0x86, 0xf4, 0x9a } };

// {5645C8C0-E277-11cf-8FDA-00AA00A14F93}
  GUID CLSID_MAILFILE  = 
{ 0x5645c8c3, 0xe277, 0x11cf, { 0x8f, 0xda, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x93 } };

// {5645C8C1-E277-11cf-8FDA-00AA00A14F93}
 GUID CLSID_MAIL_PERSISTENT  = 
{ 0x5645c8c4, 0xe277, 0x11cf, { 0x8f, 0xda, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x93 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\cmf.h ===
#ifndef __CMF_H__
#define __CMF_H__

#include <fstream.h>

#define MAX_HEADER_BUF 128


enum _tagSPECIALPROP {
	PROP_NEWSGROUP,
	PROP_ARTICLEID,
	PROP_RECVTIME,
	PROP_END
};

class CImpIPersistFile;
class CImpIPersistStream;

//+---------------------------------------------------------------------------
//
//  Class:      CMimeFilter
//
//  Purpose:    MIME Filter
//
//----------------------------------------------------------------------------
class CMimeFilter: public IFilter
{
	friend class CImpIPersistFile;
	friend class CImpIPersistStream;

public:
	CMimeFilter(IUnknown* pUnkOuter);
	~CMimeFilter();

	// IUnknown 
    STDMETHODIMP QueryInterface(REFIID, void**);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IFilter
	STDMETHODIMP Init(ULONG,ULONG,FULLPROPSPEC const*,ULONG*);
	STDMETHODIMP GetChunk( STAT_CHUNK* );
	STDMETHODIMP GetText( ULONG*,WCHAR*);
	STDMETHODIMP GetValue( PROPVARIANT** );
	STDMETHODIMP BindRegion( FILTERREGION, const struct _GUID &,void**) {return E_NOTIMPL;};

	STDMETHODIMP HRInitObject();

private:
	// private methods
	STDMETHODIMP	LoadFromFile(LPCWSTR,DWORD);
	STDMETHODIMP	LoadFromStream(LPSTREAM);
	STDMETHODIMP	GetNextBodyPart();
	STDMETHODIMP	MapHeaderProperty(ENUMPROPERTY*,char*,FULLPROPSPEC*);
	STDMETHODIMP	MapSpecialProperty(FULLPROPSPEC*);
	STDMETHODIMP	BindEmbeddedObjectToIFilter(HBODY);
	STDMETHODIMP	GetBodyCodePage(IMimeBody*,CODEPAGEID*);
	STDMETHODIMP_(ULONG)	GetNextChunkId();
	STDMETHODIMP_(LCID)		GetLocale()                    { return m_locale; };
	STDMETHODIMP_(void)		SetLocale( LCID locale )       { m_locale = locale; };
	STDMETHODIMP    GenTempFileKey( LPSTR, LONG );

	//
	// class wide static variable
	//

	//
	// Global temp file key as part of temp file name - it monotonically increases
	// until hitting the max limit and then rolls back to zero
	//

	static DWORD         m_dwTempFileNameKey;

	// private data
    LONG				m_cRef;						// object ref count
	IUnknown*			m_pUnkOuter;				// outer controlling IUnknown
	CImpIPersistFile*	m_pCImpIPersistFile;		// IPersistFile for this object
	CImpIPersistStream*	m_pCImpIPersistStream;		// IPersistStream for this object


	ULONG			m_ulChunkID;		// Current chunk id
	LCID			m_locale;			// Locale
	ULONG			m_fInitFlags;		// flags passed into Init()

	WCHAR *					m_pwszFileName;	// message file
	IStream*				m_pstmFile;		// stream wrapper on message file
    IMimeMessageTree*		m_pMessageTree;	// main object interface to MIME message
	IMimePropertySet*		m_pMsgPropSet;	// header property set
	IMimeEnumProperties*	m_pHeaderEnum;	// header enumerator (main header only)
	WCHAR					m_wcHeaderBuf[MAX_HEADER_BUF + 1];	// holds header name between GetChunk calls
	PROPVARIANT*			m_pHeaderProp;	// pointer to header prop returned in GetValue()
	HBODY					m_hBody;		// current body part handle
	IStream*				m_pstmBody;		// stream interface to current body part
	CODEPAGEID				m_cpiBody;		// codepage mapping for current body part
	BOOL					m_fFirstAlt;
	char*					m_pTextBuf;		// temporary buffer for converting text
	ULONG					m_cbBufSize;	// size of temporary buffer
	BOOL					m_fRetrieved;	// flag to indicate data has be retrieved
	char*					m_pszEmbeddedFile;
	IFilter*				m_pEmbeddedFilter;
	BOOL					m_fXRefFound;
	char*					m_pszNewsGroups;

	enum {
		STATE_INIT,
		STATE_START,
		STATE_END,
		STATE_HEADER,
		STATE_POST_HEADER,
		STATE_BODY,
		STATE_EMBEDDING,
		STATE_ERROR
	} m_State;

	UINT					m_SpecialProp;

	IMimeAllocator*			m_pMalloc;		// MimeOLE global allocator
	IMimeInternational*		m_pMimeIntl;
};

class CImpIPersistFile : public IPersistFile
{
protected:
    LONG			m_cRef;
    CMimeFilter*	m_pObj;
    LPUNKNOWN		m_pUnkOuter;

public:
    CImpIPersistFile(CMimeFilter*, LPUNKNOWN);
    ~CImpIPersistFile(void);

	// IUnknown
    STDMETHODIMP QueryInterface(REFIID, void**);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IPersist
    STDMETHODIMP GetClassID(LPCLSID);

	// IPersistFile
	STDMETHODIMP IsDirty(void);
	STDMETHODIMP Load(LPCWSTR pszFileName, DWORD dwMode);
	STDMETHODIMP Save(LPCWSTR pszFileName, BOOL fRemember);
	STDMETHODIMP SaveCompleted(LPCWSTR pszFileName);
	STDMETHODIMP GetCurFile(LPWSTR * ppszFileName);
};

class CImpIPersistStream : public IPersistStream
{
protected:
    LONG			m_cRef;
    CMimeFilter*	m_pObj;
    LPUNKNOWN		m_pUnkOuter;

public:
    CImpIPersistStream(CMimeFilter*, LPUNKNOWN);
    ~CImpIPersistStream(void);

	// IUnknown
    STDMETHODIMP QueryInterface(REFIID, void**);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IPersist
    STDMETHODIMP GetClassID(LPCLSID);

	// IPersistFile
	STDMETHODIMP IsDirty(void);
	STDMETHODIMP Load(IStream* pstm);
	STDMETHODIMP Save(IStream* pstm,BOOL fClearDirty);
	STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);
};

#endif  //  __CMF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\ver.h ===
// VERSION INFORMATION
#define RC_VERSION_FILE_DESCRIPTION "Microsoft (R) IMimeFilter Persistent Handler DLL\0"
#define RC_VERSION_INTERNAL_NAME "mimefilt.dll\0"
#define RC_VERSION_ORIGINAL_FILE_NAME "mimefilt.dll\0"
#include <bldver.rc>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\isquery\src\isquery.cpp ===
#define INC_OLE2
#define UNICODE

#include <stdio.h>
#include <windows.h>

#include <isquery.h>
#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>
#include <query.h>
#include <ntquery.h>
#include <stgprop.h>
#define NTSTATUS HRESULT
#include <dbcmdtre.hxx>
#include <vquery.hxx>
#include <dbgtrace.h>

// {AA568EEC-E0E5-11cf-8FDA-00AA00A14F93}
GUID CLSID_NNTP_SummaryInformation =
{ 0xaa568eec, 0xe0e5, 0x11cf, { 0x8f, 0xda, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x93 } };

static GUID guidSystem = PSGUID_STORAGE;
static GUID guidNews = CLSID_NNTP_SummaryInformation;
static DBID dbidNewsgroup;
static DBID dbidNewsArticleID;
static DBID dbidNewsMessageID;
static DBID dbidFilename;
static DBID dbidNewsFrom;
static DBID dbidNewsSubject;
static DBID dbidPath;

static struct {
    WCHAR wszColumnName[16];
    DBID *pdbidColumn;
} rgColumnMap[] = {
    { L"filename",      &dbidFilename         },
    { L"newsarticleid", &dbidNewsArticleID    },
	{ L"path",			&dbidPath			  },
    { L"newsfrom",      &dbidNewsFrom         },
    { L"newsgroup",     &dbidNewsgroup        },
    { L"newsmsgid",     &dbidNewsMessageID    },
    { L"newssubject",   &dbidNewsSubject      },
    { NULL,             0                     }
};

static DBBINDING skelbinding = {
    0,4*0,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED,
    DBPARAMIO_NOTPARAM, 0, 0,  DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0
};

CIndexServerQuery::CIndexServerQuery() {
    m_pRowset = NULL;
    m_hAccessor = NULL;
    m_cRowHandlesInUse = 0;
    m_phRows = NULL;
	m_cPropDef = 0;
	m_pPropDef = 0;
}

HMODULE CIndexServerQuery::m_hmQuery = NULL;
PCIMAKEICOMMAND CIndexServerQuery::m_pfnCIMakeICommand = NULL;
PCITEXTTOFULLTREE CIndexServerQuery::m_pfnCITextToFullTree = NULL;

//
// global initialization for all CIndexServerQuery objects
//
HRESULT CIndexServerQuery::GlobalInitialize() {
	TraceFunctEnter("CIndexServerQuery::GlobalInitialize");
	HRESULT hr = E_FAIL;

	dbidNewsgroup.uGuid.pguid = &guidNews;
	dbidNewsgroup.eKind = DBKIND_PGUID_PROPID;
	dbidNewsgroup.uName.ulPropid = 0x2;

	dbidNewsArticleID.uGuid.pguid = &guidNews;
	dbidNewsArticleID.eKind = DBKIND_PGUID_PROPID;
	dbidNewsArticleID.uName.ulPropid = 0x3c;

	dbidNewsMessageID.uGuid.pguid = &guidNews;
	dbidNewsMessageID.eKind = DBKIND_PGUID_PROPID;
	dbidNewsMessageID.uName.ulPropid = 0x7;

	dbidFilename.uGuid.pguid = &guidSystem;
	dbidFilename.eKind = DBKIND_PGUID_PROPID;
	dbidFilename.uName.ulPropid = 0xa;

	dbidPath.uGuid.pguid = &guidSystem;
	dbidPath.eKind = DBKIND_PGUID_PROPID;
	dbidPath.uName.ulPropid = 0xb;

	dbidNewsFrom.uGuid.pguid = &guidNews;
	dbidNewsFrom.eKind = DBKIND_PGUID_PROPID;
	dbidNewsFrom.uName.ulPropid = 0x6;

	dbidNewsSubject.uGuid.pguid = &guidNews;
	dbidNewsSubject.eKind = DBKIND_PGUID_PROPID;
	dbidNewsSubject.uName.ulPropid = 0x5;

	m_hmQuery = LoadLibrary(L"query.dll");
	if (m_hmQuery != NULL) {
		m_pfnCIMakeICommand = (PCIMAKEICOMMAND) GetProcAddress(m_hmQuery,
														"CIMakeICommand");
		if (m_pfnCIMakeICommand != NULL) {
			m_pfnCITextToFullTree =
				(PCITEXTTOFULLTREE) GetProcAddress(m_hmQuery,
												  "CITextToFullTree");
			if (m_pfnCITextToFullTree != NULL) {
				hr = S_OK;
			}
		}

		if (hr != S_OK) {
			hr = HRESULT_FROM_WIN32(GetLastError());
			FreeLibrary(m_hmQuery);
			m_hmQuery = NULL;
			m_pfnCIMakeICommand = NULL;
			m_pfnCITextToFullTree = NULL;
		} else {
			_ASSERT(m_pfnCIMakeICommand != NULL);
			_ASSERT(m_pfnCITextToFullTree != NULL);
			_ASSERT(hr == S_OK);
		}
	} else {
		hr = HRESULT_FROM_WIN32(GetLastError());
	}

	TraceFunctLeave();
	return hr;
}

//
// undo the work that was done in GlobalInitialize
//
HRESULT CIndexServerQuery::GlobalShutdown() {
	TraceFunctEnter("CIndexServerQuery::GlobalShutdown");

	if (m_hmQuery != NULL) FreeLibrary(m_hmQuery);
	m_hmQuery = NULL;

	TraceFunctLeave();
	return S_OK;
}

//
// build an Accessor for the rowset given the names of the rows that we
// are interested in.
//
// Arguments:
//  [in] wszCols - the columns that you are interested in, comma delimited
//
HRESULT CIndexServerQuery::CreateAccessor(WCHAR *szColumns) {
    TraceFunctEnter("CIndexServerQuery::CreateAccessor");

    IColumnsInfo *pColumnsInfo = NULL;
    DBBINDING rgBindings[MAX_COLUMNS];
    IAccessor *pIAccessor = NULL;
    DBID rgColumnIDs[MAX_COLUMNS];
    DBORDINAL rgMappedColumnIDs[MAX_COLUMNS];
    DWORD i, cCols;
    WCHAR *rgszColumn[MAX_COLUMNS];

    //
    // find the column names
    //
    cCols = 1;
    rgszColumn[0] = szColumns;
    for (i = 0; szColumns[i] != 0; i++) {
        if (szColumns[i] == ',') {
            // check to make sure we don't overflow rgszColumn
            if (cCols == MAX_COLUMNS) {
                ErrorTrace((DWORD_PTR) this, "too many columns passed into CreateAccessor");
                TraceFunctLeave();
                return E_INVALIDARG;
            }
            rgszColumn[cCols] = szColumns + i + 1;
            if (*rgszColumn[cCols] == 0) {
                ErrorTrace((DWORD_PTR) this, "trailing comma found in szColumns");
                TraceFunctLeave();
                return E_INVALIDARG;
            }
            cCols++;
            szColumns[i] = 0;
        }
    }

    //
    // map the column names passed in by the user into column IDs
    //
    DebugTrace((DWORD_PTR) this, "%i columns in szColumns", cCols);
    for (i = 0; i < cCols; i++) {
        DWORD j;
        for (j = 0; rgColumnMap[j].wszColumnName != NULL; j++) {
            DWORD x = lstrcmpi(rgColumnMap[j].wszColumnName, rgszColumn[i]);

            if (x == 0) {
                rgColumnIDs[i] = *(rgColumnMap[j].pdbidColumn);
                DebugTrace((DWORD_PTR) this, "Column %i is %ws", i, rgszColumn[i]);
                break;
            }
        }
        // check to make sure that we found a matching column
        if (rgColumnMap[j].wszColumnName == NULL) {
            ErrorTrace((DWORD_PTR) this, "unsupported column %ws in szColumns", rgszColumn[i]);
            TraceFunctLeave();
            return E_INVALIDARG;
        }
    }

    //
    // get a IColumnsInfo interface and use it to map the column IDs
    //
    HRESULT hr = m_pRowset->QueryInterface(IID_IColumnsInfo, (void **)&pColumnsInfo);
    if (FAILED(hr)) {
        ErrorTrace((DWORD_PTR) this, "QI(IID_IColumnsInfo) returned 0x%08x", hr);
        TraceFunctLeave();
        return hr;
    }
    hr = pColumnsInfo->MapColumnIDs(cCols, rgColumnIDs, rgMappedColumnIDs);
    pColumnsInfo->Release();
    if (FAILED(hr)) {
        ErrorTrace((DWORD_PTR) this, "MapColumnIDs returned 0x%08x", hr);
        TraceFunctLeave();
        return hr;
    }

    //
    // build up the binding array
    //
    for (i = 0; i < cCols; i++) {
        memcpy(&(rgBindings[i]), &(skelbinding), sizeof(DBBINDING));
        rgBindings[i].obValue = 4 * i;
        rgBindings[i].iOrdinal = rgMappedColumnIDs[i];
    }

    //
    // get the IAccessor interface and use that to build an accessor to
    // these columns.
    //
    hr = m_pRowset->QueryInterface( IID_IAccessor, (void **)&pIAccessor);
    if (FAILED(hr)) {
        ErrorTrace((DWORD_PTR) this, "QI(IID_IAccessor) returned 0x%08x", hr);
        TraceFunctLeave();
        return hr;
    }
    hr = pIAccessor->CreateAccessor(DBACCESSOR_ROWDATA,
                                    cCols, rgBindings, 0, &m_hAccessor, 0 );
    pIAccessor->Release();

    m_cCols = cCols;

    DebugTrace((DWORD_PTR) this, "returning 0x%08x", hr);
    TraceFunctLeave();
    return hr;
}

//
// release's an accessor that was created with CreateAccessor
//
void CIndexServerQuery::ReleaseAccessor() {
    TraceFunctEnter("CIndexServerQuery::ReleaseAccessor");

    IAccessor * pIAccessor = 0;

    HRESULT hr = m_pRowset->QueryInterface(IID_IAccessor, (void **)&pIAccessor);
    if (FAILED(hr)) {
        DebugTrace((DWORD_PTR) this, "QI(IID_IAccessor) returned 0x%08x", hr);
        TraceFunctLeave();
        return;
    }

    hr = pIAccessor->ReleaseAccessor( m_hAccessor, 0 );
    if (FAILED(hr)) DebugTrace((DWORD_PTR) this, "ReleaseAccessor returned 0x%08x", hr);
    m_hAccessor = NULL;
    hr = pIAccessor->Release();
    if (FAILED(hr)) DebugTrace((DWORD_PTR) this, "pAccessor->Release returned 0x%08x", hr);

    TraceFunctLeave();
}

//
// scan the query string and see if there are property names that are being
// queried that don't have friendly names.  if there are then we build up
// new friendly names
//
#define HEADERPREFIX L"@MSGH-"
#define HEADERPREFIXLEN 6
HRESULT CIndexServerQuery::BuildFriendlyNames(const WCHAR *pwszQueryString) {
	TraceFunctEnter("CIndexServerQuery::BuildFriendlyNames");
	
	const WCHAR *pwszHeaderPrefix;
	DWORD cFriendlyNames = 0;

	// count the number of friendly names in the string
	pwszHeaderPrefix = pwszQueryString;
	do {
		pwszHeaderPrefix = wcsstr(pwszHeaderPrefix, HEADERPREFIX);
		if (pwszHeaderPrefix != NULL) {
			cFriendlyNames++;
			pwszHeaderPrefix += HEADERPREFIXLEN;
		}
	} while (pwszHeaderPrefix != NULL);

	if (cFriendlyNames == 0) return S_OK;

	m_pPropDef = new CIPROPERTYDEF[cFriendlyNames];
	if (m_pPropDef == NULL) return E_OUTOFMEMORY;

	ZeroMemory(m_pPropDef, sizeof(CIPROPERTYDEF) * cFriendlyNames);

	pwszHeaderPrefix = wcsstr(pwszQueryString, HEADERPREFIX);
	while (pwszHeaderPrefix != NULL) {
		// copy from past the Mime to the next space into the friendly name
		WCHAR *pwszFriendlyName = new WCHAR[MAX_FRIENDLYNAME];
		if (pwszFriendlyName == NULL) {
			ErrorTrace((DWORD_PTR) this, "couldn't allocate mem for new friendlyname");
			TraceFunctLeave();
			return E_OUTOFMEMORY;
		}
		wcscpy(pwszFriendlyName, HEADERPREFIX + 1);
		WCHAR *pwszHeaderName = pwszFriendlyName + HEADERPREFIXLEN - 1;
		const WCHAR *p = pwszHeaderPrefix + HEADERPREFIXLEN;
		for (DWORD i = HEADERPREFIXLEN - 1; *p != 0 && *p != ' '; p++, i++) {
			if (i >= MAX_FRIENDLYNAME) {
				ErrorTrace((DWORD_PTR) this, "friendlyname %S is too long",
					pwszHeaderPrefix);
				TraceFunctLeave();
				return E_INVALIDARG;
			}
			pwszFriendlyName[i] = *p;
		}
		pwszFriendlyName[i] = 0;

		// see if this property has already been defined
		BOOL fFound = FALSE;
		for (DWORD m_iPropDef = 0; m_iPropDef < m_cPropDef; m_iPropDef++) {
			if (lstrcmpiW(m_pPropDef[m_iPropDef].wcsFriendlyName, pwszFriendlyName)) {
				fFound = TRUE;
			}
		}

		// if it hasn't been defined then add it to the list of defined
		// properties
		if (!fFound) {
			// build a new CIPROPERTYDEF
			_ASSERT(m_cPropDef <= cFriendlyNames);
			m_pPropDef[m_cPropDef].wcsFriendlyName = pwszFriendlyName;
			m_pPropDef[m_cPropDef].dbType = DBTYPE_WSTR;
			m_pPropDef[m_cPropDef].dbCol.eKind = DBKIND_GUID_NAME;
			m_pPropDef[m_cPropDef].dbCol.uGuid.guid = guidNews;
			m_pPropDef[m_cPropDef].dbCol.uName.pwszName = pwszHeaderName;

			DebugTrace((DWORD_PTR) this, "new friendly name %S", pwszFriendlyName);
			DebugTrace((DWORD_PTR) this, "pwszHeaderName = %S", pwszHeaderName);
			BinaryTrace((DWORD_PTR) this, (BYTE *) &guidNews, sizeof(guidNews));

			m_cPropDef++;
		}

		// p points to the end of the @MsgH-<header> part, where we might
		// expect to find another such word.
		pwszHeaderPrefix = wcsstr(p, HEADERPREFIX);
	}

	DebugTrace((DWORD_PTR) this, "defined %lu friendly names", m_cPropDef);
	TraceFunctLeave();
	return S_OK;
}

//
// make a query
//
// Arguments:
//  bDeepQuery - [in] TRUE if deep query, FALSE if shallow
//  pwszQueryString - [in] the Tripoli query string
//  pwszMachine - [in] the machine to query against (. for localhost)
//  pwszCatalog - [in] the catalog to query against
//  pwszScope - [in] the scope to query against
//  pwszColumns - [in] the columns to return.
//                Supports filename, newsgroup, newsarticleid
//  pwszSortOrder - [in] how to sort the above columns
//
HRESULT CIndexServerQuery::MakeQuery(BOOL bDeepQuery,
                                     WCHAR const *pwszQueryString,
                                     WCHAR const *pwszMachine,
                                     WCHAR const *pwszCatalog,
                                     WCHAR const *pwszScope,
                                     WCHAR *pwszColumns,
                                     WCHAR const *pwszSortOrder,
									 LCID LocalID,
									 DWORD const cMaxRows)
{
    TraceFunctEnter("MakeQuery");

    ULONG rgDepths[] = { bDeepQuery ? QUERY_DEEP : QUERY_SHALLOW};
    WCHAR const *rgScopes[] = { (pwszScope == NULL) ? L"\\" : pwszScope };
    WCHAR const *rgCatalogs[] = { pwszCatalog };
    WCHAR const *rgMachines[] = { (pwszMachine == NULL) ? L"." : pwszMachine };
    ICommand *pCommand = 0;

	if (m_hmQuery == NULL) {
		return E_UNEXPECTED;
	}

	_ASSERT(m_pfnCIMakeICommand != NULL);
	_ASSERT(m_pfnCITextToFullTree != NULL);

    DebugTrace((DWORD_PTR) this, "pwszQueryString = %ws", pwszQueryString);
    DebugTrace((DWORD_PTR) this, "pwszMachine = %ws", pwszMachine);
    DebugTrace((DWORD_PTR) this, "pwszCatalog = %ws", pwszCatalog);
    DebugTrace((DWORD_PTR) this, "pwszScope = %ws", pwszScope);
    DebugTrace((DWORD_PTR) this, "pwszColumns = %ws", pwszColumns);
    DebugTrace((DWORD_PTR) this, "pwszSortOrder = %ws", pwszSortOrder);

	_ASSERT(pwszColumns != NULL);
	if (pwszCatalog == NULL || pwszColumns == NULL) {
		ErrorTrace((DWORD_PTR) this, "pwszCatalog == NULL or pwszColumns == NULL");
		TraceFunctLeave();
		return E_POINTER;
	}

    _ASSERT(m_pRowset == NULL);
    if (m_pRowset != NULL) {
        ErrorTrace((DWORD_PTR) this, "MakeQuery called with pRowset != NULL");
        TraceFunctLeave();
        return E_UNEXPECTED;
    }

	HRESULT hr = BuildFriendlyNames(pwszQueryString);
	if (FAILED(hr)) return hr;

    DebugTrace((DWORD_PTR) this, "calling CIMakeICommand");
    hr = m_pfnCIMakeICommand(&pCommand,
                               1,
                               rgDepths,
                               (WCHAR const * const *) rgScopes,
                               (WCHAR const * const *) rgCatalogs,
                               (WCHAR const * const *) rgMachines);

    if (SUCCEEDED(hr))
    {
        const unsigned MAX_PROPS = 8;
        DBPROPSET aPropSet[MAX_PROPS];
        DBPROP aProp[MAX_PROPS];
        ULONG cProps = 0;

        // We can handle PROPVARIANTs, not just ole automation variants
        static const DBID dbcolNull = { {0,0,0,{0,0,0,0,0,0,0,0}},DBKIND_GUID_PROPID,0};
        static const GUID guidQueryExt = DBPROPSET_QUERYEXT;

        aProp[cProps].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES;
        aProp[cProps].dwOptions = DBPROPOPTIONS_SETIFCHEAP;
        aProp[cProps].dwStatus = 0;
        aProp[cProps].colid = dbcolNull;
        aProp[cProps].vValue.vt = VT_BOOL;
        aProp[cProps].vValue.boolVal = VARIANT_TRUE;
        aPropSet[cProps].rgProperties = &aProp[cProps];
        aPropSet[cProps].cProperties = 1;
        aPropSet[cProps].guidPropertySet = guidQueryExt;
        cProps++;

        ICommandProperties *pCmdProp = 0;
        hr = pCommand->QueryInterface(IID_ICommandProperties,
                                      (void **)&pCmdProp);
        if (SUCCEEDED(hr)) {
            DebugTrace((DWORD_PTR) this, "calling SetProperties");
            hr = pCmdProp->SetProperties( cProps, aPropSet );
            pCmdProp->Release();
        }

        DBCOMMANDTREE *pTree;
        DebugTrace((DWORD_PTR) this, "calling CITextToFullTree");
        hr = m_pfnCITextToFullTree(pwszQueryString,       // query
                              	   pwszColumns,           // columns
                              	   pwszSortOrder,         // sort
                              	   0,                     // grouping
                              	   &pTree,                // resulting tree
                              	   m_cPropDef,            // custom properties
                              	   m_pPropDef,            // custom properties
                                   LocalID);      		  // default locale

		//
		// if the max rows is specified then set this property at the
		// top of the command tree
		//
		if (cMaxRows != 0) {
			DBCOMMANDTREE *pdbTop = (DBCOMMANDTREE *) CoTaskMemAlloc(sizeof(DBCOMMANDTREE));
			ZeroMemory(pdbTop, sizeof(DBCOMMANDTREE));
			pdbTop->pctFirstChild = pTree;
			pdbTop->op = DBOP_top;
			pdbTop->wKind = DBVALUEKIND_UI4;
			pdbTop->value.ulValue = cMaxRows;
			pTree = pdbTop;
		}

        if (SUCCEEDED(hr)) {
            ICommandTree *pCmdTree = NULL;
            hr = pCommand->QueryInterface(IID_ICommandTree,
                                          (void **)&pCmdTree);

            DebugTrace((DWORD_PTR) this, "calling SetCommandTree");
            hr = pCmdTree->SetCommandTree(&pTree, DBCOMMANDREUSE_NONE, FALSE);
            pCmdTree->Release();
            IRowset *pRowset = 0;

            if (SUCCEEDED(hr)) {
                DebugTrace((DWORD_PTR) this, "calling Execute");
                hr = pCommand->Execute(0,            // no aggr. IUnknown
                                       IID_IRowset,  // IID for i/f to return
                                       0,            // disp. params
                                       0,            // chapter
                                       (IUnknown **) &pRowset );

	            if (SUCCEEDED(hr))
	            {
	                DebugTrace((DWORD_PTR) this, "calling CreateAccessor");
	
	                m_pRowset = pRowset;
	
	                hr = CreateAccessor(pwszColumns);
	
	                m_fNoMoreRows = FALSE;
	                m_phRows = NULL;
	                m_cRowHandlesInUse = 0;
	                m_cRowHandlesAllocated = 0;
	            }
			}
        }
        pCommand->Release();
    }

    DebugTrace((DWORD_PTR) this, "returning 0x%08x", hr);
    TraceFunctLeave();
    return hr;
}

//
// Get back some query results after making a query
//
// Arguments:
//  pcResults - [in/out] The number of results to retrieve.  When the function
//              returns is has the number of results retrieved
//  ppvResults - [out] The array of propvariant pointers to receive the results
//  pfMore - [out] Set to FALSE when there are no more results to retrieve
//
HRESULT CIndexServerQuery::GetQueryResults(DWORD *pcResults,
                                           PROPVARIANT **ppvResults,
                                           BOOL *pfMore)
{
    TraceFunctEnter("GetQueryResults");

    HRESULT hr;
    DBCOUNTITEM cDesiredRows;
    DBCOUNTITEM iCurrentRow;

    // check to make sure that they've called MakeQuery successfully
    if (m_pRowset == NULL) {
        ErrorTrace((DWORD_PTR) this, "GetQueryResults called without MakeQuery");
        TraceFunctLeave();
        return E_UNEXPECTED;
    }

    if (m_fNoMoreRows) {
        *pfMore = FALSE;
        TraceFunctLeave();
        return S_OK;
    }

    cDesiredRows = *pcResults;
    *pcResults = 0;
    *pfMore = TRUE;

    if (m_cRowHandlesInUse != 0) {
        m_pRowset->ReleaseRows(m_cRowHandlesInUse, m_phRows, 0, 0, 0);
        m_cRowHandlesInUse = 0;
        if (cDesiredRows > m_cRowHandlesAllocated) {
            delete[] m_phRows;
            m_phRows = NULL;
            m_cRowHandlesAllocated = 0;
        }
    }

    // allocate memory for the row handles
    if (cDesiredRows > m_cRowHandlesAllocated) {
        _ASSERT(m_phRows == NULL);
        m_phRows = new HROW[(size_t)cDesiredRows];
        if (m_phRows == NULL) {
            DebugTrace((DWORD_PTR) this, "out of memory trying to alloc %lu row handles", cDesiredRows);
            return E_OUTOFMEMORY;
        }
        m_cRowHandlesAllocated = cDesiredRows;
    }

    // fetch some more rows from tripoli
    DebugTrace((DWORD_PTR) this, "getting more tripoli rows");
    hr = m_pRowset->GetNextRows(0,
                                0,
                                cDesiredRows,
                                &m_cRowHandlesInUse,
                                &m_phRows);

    DebugTrace((DWORD_PTR) this, "GetNextRows returned %lu rows", m_cRowHandlesInUse);

    // check for end of rowset
    if (hr == DB_S_ENDOFROWSET) {
        DebugTrace((DWORD_PTR) this, "GetNextRows returned end of rowset");
        hr = S_OK;
        m_fNoMoreRows = TRUE;
        *pfMore = FALSE;
    }

    if (FAILED(hr)) {
        ErrorTrace((DWORD_PTR) this, "GetNextRows failed with 0x%08x", hr);
        TraceFunctLeave();
        return hr;
    }

    // get the data for each of the rows
    for (iCurrentRow = 0; iCurrentRow < m_cRowHandlesInUse; iCurrentRow++) {
        // fetch the data for this row
        hr = m_pRowset->GetData(m_phRows[iCurrentRow], m_hAccessor,
                                ppvResults + ((*pcResults) * m_cCols));
        if (FAILED(hr)) {
            ErrorTrace((DWORD_PTR) this, "GetData failed with 0x%08x", hr);
            TraceFunctLeave();
            return hr;
        } else {
            (*pcResults)++;
        }
    }

    DebugTrace((DWORD_PTR) this, "*pcResults = %lu, *pfMore = %lu", *pcResults, *pfMore);

    TraceFunctLeave();
    return hr;
}

CIndexServerQuery::~CIndexServerQuery() {
    TraceFunctEnter("CIndexServerQuery");

	// clean up any custom named properties
	if (m_cPropDef != 0) {
		while (m_cPropDef-- != 0) {
			delete[] m_pPropDef[m_cPropDef].wcsFriendlyName;
		}
		delete[] m_pPropDef;
	} else {
		_ASSERT(m_pPropDef == NULL);
	}
    if (m_cRowHandlesInUse != 0) {
        m_pRowset->ReleaseRows(m_cRowHandlesInUse, m_phRows, 0, 0, 0);
        m_cRowHandlesInUse = 0;
    }
    if (m_phRows != NULL) {
        delete[] m_phRows;
        m_phRows = NULL;
        m_cRowHandlesAllocated = 0;
    }

    if (m_pRowset != NULL) {
        if (m_hAccessor != NULL) {
            DebugTrace((DWORD_PTR) this, "releasing accessor");
            ReleaseAccessor();
        }
        DebugTrace((DWORD_PTR) this, "releasing rowset");
        m_pRowset->Release();
        m_pRowset = NULL;
    }

    TraceFunctLeave();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\regutil.h ===
//																	-*- c++ -*-
// regutil.h
//
//		utility funcitons for manipulating the registry
//

#ifndef _regutil_H_
#define _regutil_H_

#include <windows.h>
#include <ole2.h>

//-----------------------------------------------------------------------------
// general registry functions
//-----------------------------------------------------------------------------

// open a key
BOOL OpenOrCreateRegKey( HKEY hKey, LPCTSTR pctstrKeyName, PHKEY phKeyOut );

// get a string value
BOOL GetStringRegValue( HKEY hKeyRoot,
						LPCTSTR lpcstrKeyName, LPCTSTR lpcstrValueName,
						LPTSTR ptstrValue, DWORD dwMax );
BOOL GetStringRegValue( HKEY hkey,
						LPCTSTR lpcstrValueName,
						LPTSTR ptstrValue, DWORD dwMax );

// set a string value
BOOL SetStringRegValue( HKEY hKey,
						LPCTSTR lpcstrValueName,
						LPCTSTR lpcstrString );
BOOL SetStringRegValue( HKEY hKeyRoot,
						LPCTSTR lpcstrKeyName,
						LPCTSTR lpcstrValueName,
						LPCTSTR lpcstrString );

// get a dword value
BOOL GetDwordRegValue( HKEY hKeyRoot, LPCTSTR lpcstrKeyName,
					   LPCTSTR lpcstrValueName, PDWORD pdw );
BOOL GetDwordRegValue( HKEY hKeyRoot,
					   LPCTSTR lpcstrValueName, PDWORD pdw );

// set a dword value
BOOL SetDwordRegValue( HKEY hKeyRoot,
					   LPCTSTR lpcstrKeyName,
					   LPCTSTR lpcstrValueName,
					   DWORD dwValue );
BOOL SetDwordRegValue( HKEY hKeyRoot,
					   LPCTSTR lpcstrValueName,
					   DWORD dwValue );

// delete a reg. key
void DeleteRegSubtree( HKEY hkey, LPCSTR pcstrSubkeyName );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\cthdutil.h ===
#ifndef __CTHDUTIL_H__
#define __CTHDUTIL_H__

class CRandomNumber
{
  public:

	CRandomNumber(
				DWORD	dwSeed = 0
				);

	~CRandomNumber();

	void SetSeed(
				DWORD	dwSeed
				);

	DWORD Rand();

	DWORD Rand(
				DWORD	dwLower,
				DWORD	dwUpper
				);

	DWORD Rand25(
				DWORD	dwMedian
				);

	DWORD Rand50(
				DWORD	dwMedian
				);

	DWORD Rand75(
				DWORD	dwMedian
				);

  private:

	DWORD		m_dwSeed;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\cthdutil.cpp ===
#include <windows.h>

#include "macros.h"
#include "cthdutil.h"

#include "stdlib.h"

#define SPINLOCK_ACQUIRED	1
#define SPINLOCK_AVAILABLE	0

CRandomNumber::CRandomNumber(
			DWORD	dwSeed
			)
{
	srand((unsigned int)dwSeed);
}

CRandomNumber::~CRandomNumber()
{
}

void CRandomNumber::SetSeed(
			DWORD	dwSeed
			)
{
	srand((unsigned int)dwSeed);
}

DWORD CRandomNumber::Rand()
{
	return((DWORD)rand());
}

DWORD CRandomNumber::Rand(
			DWORD	dwLower,
			DWORD	dwUpper
			)
{
	return(MulDiv(Rand(), dwUpper-dwLower, RAND_MAX + 1) + dwLower);
}

DWORD CRandomNumber::Rand25(
			DWORD	dwMedian
			)
{
	DWORD	dwUpper, dwLower;

	GET_25_PERCENT_RANGE(dwMedian, dwLower, dwUpper);
	return(Rand(dwLower, dwUpper));
}

DWORD CRandomNumber::Rand50(
			DWORD	dwMedian
			)
{
	DWORD	dwUpper, dwLower;

	GET_50_PERCENT_RANGE(dwMedian, dwLower, dwUpper);
	return(Rand(dwLower, dwUpper));
}

DWORD CRandomNumber::Rand75(
			DWORD	dwMedian
			)
{
	DWORD	dwUpper, dwLower;

	GET_75_PERCENT_RANGE(dwMedian, dwLower, dwUpper);
	return(Rand(dwLower, dwUpper));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\crnddata.h ===
#ifndef __CRNDDATA_H__
#define __CRNDDATA_H__

#include "cthdutil.h"

#define RANDOM_DATA_OVERHEAD		16

class CRandomData : public CRandomNumber
{
  public:

	CRandomData(
				DWORD	dwSeed = 0
				);

	~CRandomData();

	// Generates a block of random data
	//
	// pData - buffer to hold random data, must be at least 
	//			(1.75 * dwAvgLength) + RANDOM_DATA_OVERHEAD bytes
	// dwAvgLength - Average length of random block. The final length
	//			is dwAvgLength +/- 75% of dwAvgLength + 
	//			RANDOM_DATA_OVERHEAD bytes
	// pdwLength - returns the total length of the random block
	HRESULT GenerateRandomData(
				LPSTR	pData,
				DWORD	dwAvgLength,
				DWORD	*pdwLength
				);

	// Verifies a block of random data returned from GenerateRandomData
	//
	// pData - buffer containing data to verify
	// dwLength - Total length of data to verify
	HRESULT VerifyData(
				LPSTR	pData,
				DWORD	dwLength
				);

	// Verifies stacked blocks of random data returned from
	// GenerateRandomData, one block followed immediately by another
	//
	// pData - buffer containing data to verify
	// dwLength - Total length of data to verify
	// pdwBlocks - returns the number of blocks found
	HRESULT VerifyStackedData(
				LPSTR	pData,
				DWORD	dwLength,
				DWORD	*pdwBlocks
				);

	// Generates a table of RFC 821 names 
	//
	// dwNumberToGenerate - number of names to generate
	// dwAvgLength - average length for any name
	HRESULT Generate821NameTable(
				DWORD	dwNumberToGenerate,
				DWORD	dwAvgLength
				);

	// Generates a table of RFC 821 domains 
	//
	// dwNumberToGenerate - number of domains to generate
	// dwAvgLength - average length for any domain
	HRESULT Generate821DomainTable(
				DWORD	dwNumberToGenerate,
				DWORD	dwAvgLength
				);
			
	// Generates an RFC 821 name from the name and domain table,
	// return a full name@domain address.
	//
	// pAddress - buffer receiving the address, must be large 
	//			enough to hold the longest address in the tables.
	// pdwLength - returns the length of the resulting address,
	//			including the @ sign and trailing NULL.
	// pdwNameIndex - returns the index to its name
	// pdwDomainIndex - returns the index to its domain
	HRESULT Generate821AddressFromTable(
				LPSTR	pAddress,
				DWORD	*pdwLength,
				DWORD	*pdwNameIndex,
				DWORD	*pdwDomainIndex
				);

	// Given an address, looks up its respective name and domain
	// indices from the table
	HRESULT GetNameAndDomainIndicesFromAddress(
				LPSTR	pAddress,
				DWORD	dwLength,
				DWORD	*pdwNameIndex,
				DWORD	*pdwDomainIndex
				);

	// Generates an RFC 821 name
	//
	// pName - buffer reciving the name, must be at least 
	//			1.75 * dwAvgLength + 1
	// dwAvgLength - Average length
	// pdwLenght - returns the actual length
	HRESULT Generate821Name(
				LPSTR	pName,
				DWORD	dwAvgLength,
				DWORD	*pdwLength
				);

	// Generates an RFC 821 domain
	//
	// pDomain - buffer reciving the domain, must be at least
	// 1.75 * dwAvgLength + 1
	// dwAvgLength - Average length
	// pdwLenght - returns the actual length
	HRESULT Generate821Domain(
				LPSTR	pDomain,
				DWORD	dwAvgLength,
				DWORD	*pdwLength
				);
			
	// Generates an RFC 821 address
	//
	// pAddress - buffer reciving the address, must be at least
	//			1.5 * dwAvgNameLength + 1.5 * dwAvgDomainLength + 2
	// dwAvgNameLength - Average name length
	// dwAvgDomainLength - Average domain length
	// pdwLength - returns the actual length
	HRESULT Generate821Address(
				LPSTR	pAddress,
				DWORD	dwAvgNameLength,
				DWORD	dwAvgDomainLength,
				DWORD	*pdwLength
				);

	LPSTR		*m_rgNames;
	LPSTR		*m_rgDomains;
	DWORD		m_dwNames;
	DWORD		m_dwDomains;

  private:

	void FreeNames();

	void FreeDomains();

	char GenerateNameChar(
				BOOL	fDotAllowed
				);

	BOOL GenerateDottedName(
				char	*szAlias,
				DWORD	dwLength
				);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\ifilter\mimefilt\regutil.cpp ===
//
// regutil.cpp
//
//		functions for manipulating the registry
//

#include "mimefilt.h"


BOOL OpenOrCreateRegKey( HKEY hKey, LPCTSTR pctstrKeyName, PHKEY phKeyOut )
{
	DWORD dwDisposition;

	return (RegCreateKeyEx(hKey, pctstrKeyName, 0, NULL,
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, NULL,
			phKeyOut, &dwDisposition ) == ERROR_SUCCESS );
}


BOOL GetStringRegValue( HKEY hKeyRoot,
		LPCTSTR lpcstrKeyName, LPCTSTR lpcstrValueName,
		LPTSTR ptstrValue, DWORD dwMax )
{
	HKEY hKey;

	if( RegOpenKeyEx( hKeyRoot, lpcstrKeyName,
			0, KEY_READ, &hKey ) != ERROR_SUCCESS )
		return FALSE;

	if( ! GetStringRegValue( hKey, lpcstrValueName, ptstrValue, dwMax ) )
	{
		RegCloseKey( hKey );
		return FALSE;
	}

	RegCloseKey( hKey );
	return TRUE;
}


BOOL GetStringRegValue( HKEY hkey,
		LPCTSTR lpcstrValueName,
		LPTSTR ptstrValue, DWORD dwMax )
{
	DWORD dwType;

	if( RegQueryValueEx( hkey, lpcstrValueName, NULL, &dwType,
			(PBYTE) ptstrValue, &dwMax ) != ERROR_SUCCESS ||
			dwType != REG_SZ )
	{
		return FALSE;
	}

	return TRUE;
}


BOOL SetStringRegValue( HKEY hKey,
		LPCTSTR lpcstrValueName,
		LPCTSTR lpcstrString )
{
	return RegSetValueEx( hKey, lpcstrValueName, 0, REG_SZ,
			(PBYTE) lpcstrString,
			lstrlen(lpcstrString) + 1 ) == ERROR_SUCCESS ;
}


BOOL SetStringRegValue( HKEY hKeyRoot,
		LPCTSTR lpcstrKeyName,
		LPCTSTR lpcstrValueName,
		LPCTSTR lpcstrString )
{
	HKEY hKey;
	BOOL fOk;

	if(!OpenOrCreateRegKey(hKeyRoot,
			lpcstrKeyName,
			&hKey ) )
		return FALSE;

	fOk = SetStringRegValue( hKey, lpcstrValueName, lpcstrString );

	RegCloseKey( hKey );

	return fOk;
}


BOOL GetDwordRegValue( HKEY hKeyRoot, LPCTSTR lpcstrKeyName,
		LPCTSTR lpcstrValueName, PDWORD pdw )
{
	HKEY hKey;

	if( RegOpenKeyEx( hKeyRoot, lpcstrKeyName,
			0, KEY_READ, &hKey ) != ERROR_SUCCESS )
		return FALSE;

	if( !GetDwordRegValue( hKey, lpcstrValueName, pdw ) )
	{
		RegCloseKey( hKey );
		return FALSE;
	}

	RegCloseKey( hKey );
	return TRUE;
}

BOOL GetDwordRegValue( HKEY hKey,
		LPCTSTR lpcstrValueName,
		PDWORD pdw )
{
	DWORD dwType;
	DWORD dwSize;

	dwSize = sizeof(DWORD);
	if( RegQueryValueEx( hKey, lpcstrValueName, NULL, &dwType,
			(PBYTE) pdw, &dwSize ) != ERROR_SUCCESS ||
			dwType != REG_DWORD )
	{
		return FALSE;
	}

	return TRUE;
}

BOOL SetDwordRegValue( HKEY hKeyRoot,
		LPCTSTR lpcstrKeyName,
		LPCTSTR lpcstrValueName,
		DWORD dwValue )
{
	HKEY hKey;
	BOOL fOk;

	if( ! OpenOrCreateRegKey(hKeyRoot,
			lpcstrKeyName,
			&hKey ) )
		return FALSE;

	fOk = RegSetValueEx( hKey, lpcstrValueName, 0, REG_DWORD,
			(PBYTE) &dwValue, sizeof(DWORD) ) == ERROR_SUCCESS ;

	RegCloseKey( hKey );

	return fOk;
}


BOOL SetDwordRegValue( HKEY hKey,
		LPCTSTR lpcstrValueName,
		DWORD dwValue )
{
	return RegSetValueEx( hKey, lpcstrValueName, 0, REG_DWORD,
			(PBYTE) &dwValue, sizeof(DWORD) ) == ERROR_SUCCESS ;
}


void
DeleteRegSubtree( HKEY hkey, LPCSTR pcstrSubkeyName )
{
	CHAR szName[MAX_PATH];
	DWORD cbName;
	FILETIME ft;
	HKEY hkeySubkey;

	if (RegOpenKeyEx( hkey, pcstrSubkeyName, 0, KEY_ALL_ACCESS, &hkeySubkey ) == ERROR_SUCCESS) {

    	for(;;)
	    {
		    cbName = sizeof(szName);
    		if( RegEnumKeyEx( hkeySubkey, 0, szName, &cbName, 0, NULL,
				NULL, &ft ) != ERROR_SUCCESS )
	    	{
		    	break;
    		}

	    	DeleteRegSubtree( hkeySubkey, szName );
	    }

    	RegCloseKey( hkeySubkey );
    }
	RegDeleteKey( hkey, pcstrSubkeyName ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\crnddata.cpp ===
#include <windows.h>

#include "addr821.hxx"
#include "crnddata.h"

#define DATA_LEADER			(DWORD)'vLDS'
#define DATA_TRAILER		(DWORD)'vTDS'

CRandomData::CRandomData(
			DWORD	dwSeed
			)
			: CRandomNumber(dwSeed)
{
	m_rgNames = NULL;
	m_rgDomains = NULL;
	m_dwNames = 0;
	m_dwDomains = 0;
}

CRandomData::~CRandomData()
{
	FreeNames();
	FreeDomains();
}

void CRandomData::FreeNames()
{
	if (m_rgNames)
	{
		LPSTR	*pTemp = m_rgNames;
		while (m_dwNames--)
			HeapFree(GetProcessHeap(), 0, *pTemp++);
		HeapFree(GetProcessHeap(), 0, m_rgNames);
	}
	m_rgNames = NULL;
}

void CRandomData::FreeDomains()
{
	if (m_rgDomains)
	{
		LPSTR	*pTemp = m_rgDomains;
		while (m_dwDomains--)
			HeapFree(GetProcessHeap(), 0, *pTemp++);
		HeapFree(GetProcessHeap(), 0, m_rgDomains);
	}
	m_rgDomains = NULL;
}

HRESULT CRandomData::GenerateRandomData(
			LPSTR	pData,
			DWORD	dwAvgLength,
			DWORD	*pdwLength
			)
{
	DWORD	dwLength;
	DWORD	dwCheckSum = 0;
	LPDWORD	pdwPtr = (LPDWORD)pData;
	
	dwLength = Rand75(dwAvgLength);

	dwLength >>= 2;
	*pdwLength = (dwLength << 2) + RANDOM_DATA_OVERHEAD;
	*pdwPtr++ = DATA_LEADER;
	*pdwPtr++ = dwLength;
	while (dwLength--)
	{
		*pdwPtr = Rand();
		*pdwPtr &= 0x7f7f7f7f;
		dwCheckSum += *pdwPtr++;
	}
	*pdwPtr++ = dwCheckSum;
	*pdwPtr = DATA_TRAILER;
	return(S_OK);
}

HRESULT CRandomData::VerifyData(
			LPSTR	pData,
			DWORD	dwLength
			)
{
	LPDWORD	pdwPtr = (LPDWORD)pData;
	DWORD	dwCheckSum = 0;

	// Must be in DWORDS
	if (dwLength & 3 || dwLength < 12)
		return(E_FAIL);	

	dwLength -= RANDOM_DATA_OVERHEAD;
	dwLength >>= 2;

	if (*pdwPtr++ != DATA_LEADER)
		return(E_FAIL);
	if (*pdwPtr++ != dwLength)
		return(E_FAIL);
	while (dwLength--)
	{
		if (*pdwPtr & 0x80808080)
			return(E_FAIL);
		else
			dwCheckSum += *pdwPtr++;
	}
	if (*pdwPtr++ != dwCheckSum)
		return(E_FAIL);
	if (*pdwPtr != DATA_TRAILER)
		return(E_FAIL);
	return(S_OK);
}

HRESULT CRandomData::VerifyStackedData(
			LPSTR	pData,
			DWORD	dwLength,
			DWORD	*pdwBlocks
			)
{
	LPDWORD	pdwPtr = (LPDWORD)pData;
	DWORD	dwChunkLength;
	DWORD	dwCheckSum = 0;
	DWORD	dwBlocks = 0;

	// Must be in DWORDS
	if (dwLength & 3 || dwLength < RANDOM_DATA_OVERHEAD)
		return(E_FAIL);	

	dwLength >>= 2;

	while (dwLength)
	{
		dwLength -= (RANDOM_DATA_OVERHEAD >> 2);
		dwCheckSum = 0;
		
		if (*pdwPtr++ != DATA_LEADER)
			return(E_FAIL);

		dwChunkLength = *pdwPtr++;
		if (dwChunkLength > dwLength)
			return(E_FAIL);
		dwLength -= dwChunkLength;

		while (dwChunkLength--)
			if (*pdwPtr & 0x80808080)
				return(E_FAIL);
			else
				dwCheckSum += *pdwPtr++;

		if (*pdwPtr++ != dwCheckSum)
			return(E_FAIL);
		if (*pdwPtr++ != DATA_TRAILER)
			return(E_FAIL);

		dwBlocks++;
	}

	*pdwBlocks = dwBlocks;
	return(S_OK);
}

char CRandomData::GenerateNameChar(
			BOOL	fDotAllowed
			)
{
	char	ch, chout;

	chout = 0;
	do
	{
		ch = (char)Rand(0, 65);
		if (ch >= 62 && fDotAllowed)
			chout = '.';
		else if ((ch >= 0) && (ch <= 9))
			chout = '0' + ch;
		else if ((ch >= 10) && (ch <= 35))
			chout = 'a' + ch - 10;
		else if ((ch >= 36) && (ch <= 61))
			chout = 'A' + ch - 36;

	} while (!chout);

	return(chout);
}

BOOL CRandomData::GenerateDottedName(
			char	*szAlias,
			DWORD	dwLength
			)
{
	BOOL	fDotAllowed = TRUE;
	char	ch;

	if (dwLength < 3)
		return(FALSE);

	dwLength -= 3;
	*szAlias++ = GenerateNameChar(FALSE);

	while (dwLength--)
	{
		ch = GenerateNameChar(fDotAllowed);
		if (ch == '.')
			fDotAllowed = FALSE;
		else
			fDotAllowed = TRUE;
		*szAlias++ = ch;
	}

	*szAlias++ = GenerateNameChar(FALSE);
	*szAlias++ = '\0';
	return(TRUE);
}

HRESULT CRandomData::Generate821NameTable(
			DWORD	dwNumberToGenerate,
			DWORD	dwAvgLength
			)
{
	HRESULT	hrRes = S_OK;

	FreeNames();
	m_rgNames = (LPSTR *)HeapAlloc(
				GetProcessHeap(), 
				0, 
				dwNumberToGenerate * sizeof(char *));
	if (!m_rgNames)
		return(E_FAIL);

	for (DWORD i =  0; i < dwNumberToGenerate; i++)
	{
		DWORD	dwLength = Rand75(dwAvgLength);

		m_rgNames[i] = (char *)HeapAlloc(GetProcessHeap(), 0, dwLength);
		if (!m_rgNames[i])
		{
			m_dwNames = i;
			FreeNames();
			return(E_FAIL);
		}
		if (!GenerateDottedName(m_rgNames[i], dwLength))
		{
			hrRes = E_FAIL;
			m_dwNames = i;
			FreeNames();
			break;
		}
	}

	if (SUCCEEDED(hrRes))
		m_dwNames = dwNumberToGenerate;
	return(hrRes);
}

HRESULT CRandomData::Generate821DomainTable(
			DWORD	dwNumberToGenerate,
			DWORD	dwAvgLength
			)
{
	HRESULT	hrRes = S_OK;

	FreeDomains();
	m_rgDomains = (LPSTR *)HeapAlloc(
				GetProcessHeap(), 
				0, 
				dwNumberToGenerate * sizeof(char *));
	if (!m_rgDomains)
		return(E_FAIL);

	for (DWORD i =  0; i < dwNumberToGenerate; i++)
	{
		DWORD	dwLength = Rand75(dwAvgLength);

		m_rgDomains[i] = (char *)HeapAlloc(GetProcessHeap(), 0, dwLength);
		if (!m_rgDomains[i])
		{
			m_dwDomains = i;
			FreeDomains();
			return(E_FAIL);
		}
		if (!GenerateDottedName(m_rgDomains[i], dwLength))
		{
			hrRes = E_FAIL;
			m_dwDomains = i;
			FreeDomains();
			break;
		}
	}

	if (SUCCEEDED(hrRes))
		m_dwDomains = dwNumberToGenerate;
	return(hrRes);
}
		
HRESULT CRandomData::Generate821AddressFromTable(
			LPSTR	pAddress,
			DWORD	*pdwLength,
			DWORD	*pdwNameIndex,
			DWORD	*pdwDomainIndex
			)
{
	if (!m_dwNames || !m_dwDomains)
		return(E_FAIL);

	*pdwNameIndex = Rand(0, m_dwNames - 1);
	*pdwDomainIndex = Rand(0, m_dwDomains - 1);

	lstrcpy(pAddress, m_rgNames[*pdwNameIndex]);
	lstrcat(pAddress, "@");
	lstrcat(pAddress, m_rgDomains[*pdwDomainIndex]);
	*pdwLength = lstrlen(pAddress);
	return(S_OK);
}

HRESULT CRandomData::GetNameAndDomainIndicesFromAddress(
			LPSTR	pAddress,
			DWORD	dwLength,
			DWORD	*pdwNameIndex,
			DWORD	*pdwDomainIndex
			)
{
	char *pTemp = strchr(pAddress, '@');
	DWORD i, j;
	BOOL  fFound = FALSE;
	if (!pTemp)
		return(E_INVALIDARG);
	*pTemp++ = '\0';

	for (i = 0; i < m_dwNames; i++)
		if (!lstrcmpi(pAddress, m_rgNames[i]))
		{
			*pdwNameIndex = i;

			for (j = 0; j < m_dwDomains; j++)
				if (!lstrcmpi(pTemp, m_rgDomains[j]))
				{
					*pdwDomainIndex = j;
					fFound = TRUE;
					break;
				}

			if (fFound)
				break;
		}

	*--pTemp = '@';

	return(fFound?S_OK:E_FAIL);
}

HRESULT CRandomData::Generate821Name(
			LPSTR	pName,
			DWORD	dwAvgLength,
			DWORD	*pdwLength
			)
{
	*pdwLength = Rand75(dwAvgLength);
	if (!GenerateDottedName(pName, *pdwLength))
		return(E_FAIL);
	return(S_OK);
}

HRESULT CRandomData::Generate821Domain(
			LPSTR	pDomain,
			DWORD	dwAvgLength,
			DWORD	*pdwLength
			)
{
	return(Generate821Name(pDomain, dwAvgLength, pdwLength));
}
		
HRESULT CRandomData::Generate821Address(
			LPSTR	pAddress,
			DWORD	dwAvgNameLength,
			DWORD	dwAvgDomainLength,
			DWORD	*pdwLength
			)
{
	HRESULT	hrRes;
	DWORD	dwLength;
	
	hrRes = Generate821Name(pAddress, dwAvgNameLength, &dwLength);
	if (SUCCEEDED(hrRes))
	{
		pAddress += dwLength;
		*(pAddress - 1) = '@';
		hrRes = Generate821Domain(
					pAddress, 
					dwAvgDomainLength, 
					pdwLength);
		if (SUCCEEDED(hrRes))
			*pdwLength += dwLength;
	}
	return(hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\macros.h ===
#ifndef __MACROS_H__
#define __MACROS_H__

//
// Macro to bail out or break the debugger
//
#define BAIL_WITH_ERROR(hrRes)			\
			{							\
				if (fUseDebugBreak)		\
					DebugBreak();		\
				else					\
					return((hrRes));	\
			}

//
// Macro to decide whether to write to the console or to the debugger
//
#define WRITE(szString)								\
			{										\
				if (fToDebugger)					\
					OutputDebugString(szString);	\
				else								\
					puts(szString);					\
			}

//
// Macro to obtain a 25%, 50%, and 75% spread range given an average
//
#define GET_25_PERCENT_RANGE(dwAverage, dwLower, dwUpper)	\
			{												\
				(dwLower) = (dwAverage) >> 2;				\
				(dwUpper) = (dwAverage) + (dwLower);		\
				(dwLower) = (dwAverage) - (dwLower);		\
			}
#define GET_50_PERCENT_RANGE(dwAverage, dwLower, dwUpper)	\
			{												\
				(dwLower) = (dwAverage) >> 1;				\
				(dwUpper) = (dwAverage) + (dwLower);		\
			}
#define GET_75_PERCENT_RANGE(dwAverage, dwLower, dwUpper)	\
			{												\
				(dwLower) = (dwAverage) - ((dwAverage) >> 2);\
				(dwUpper) = (dwAverage) + (dwLower);		\
				(dwLower) = (dwAverage) >> 2;				\
			}
					

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\parsearg.h ===
#ifndef __PARSEARG_H__
#define __PARSEARG_H__

typedef enum _ARGUMENT_TYPES
{
	AT_NONE	= 0,
	AT_STRING,
	AT_VALUE

} ARGUMENT_TYPES;

typedef struct _ARGUMENT_DESCRIPTOR
{
	BOOL			fRequired;		// Whether this is a required argument
	char			*szSwitch;		// String representing switch "-x", etc.
	char			*szUsage;		// Descriptive text for usage help
	ARGUMENT_TYPES	atType;			// Type of argument value
	LPVOID			pvReserved;		// Internal, must be initialized to NULL

} ARGUMENT_DESCRIPTOR, *LPARGUMENT_DESCRIPTOR;

class CParseArgs
{
  public:

	CParseArgs(
				char					*szAppDescription,
				DWORD					dwDescriptors,
				LPARGUMENT_DESCRIPTOR	rgDescriptors
				);

	~CParseArgs();

	HRESULT ParseArguments(
				int						argc,
				char					*argv[]
				);

	HRESULT Exists(
				DWORD	dwDescriptorIndex
				);

	HRESULT GetSwitch(
				DWORD	dwDescriptorIndex,
				BOOL	*pfExists
				);

	HRESULT GetString(
				DWORD	dwDescriptorIndex,
				char	**ppszStringValue
				);

	HRESULT GetDword(
				DWORD	dwDescriptorIndex,
				DWORD	*pdwDwordValue
				);

	HRESULT GenerateUsage(
				DWORD	*pdwLength,
				char	*szUsage
				);

	HRESULT GetErrorString(
				DWORD	*pdwLength,
				char	*szErrorString
				);

  private:

	HRESULT Cleanup();

	LPARGUMENT_DESCRIPTOR FindArgument(
				char	*szSwitch
				);

	BOOL StringToValue(
				char	*szString,
				DWORD	*pdwValue
				);

	void SetParseError(
				HRESULT	hrRes,
				char	*szSwitch
				);

	DWORD					m_dwDescriptors;
	LPARGUMENT_DESCRIPTOR	m_rgDescriptors;
	char					*m_szAppDescription;

	HRESULT					m_hrRes;
	char					m_szErrorSwitch[64];
	char					m_szBuffer[4096];

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\cthrdapp.cpp ===
#include <stdio.h>
#include <windows.h>

#include "cthrdapp.h"

//
// An instance of the application
//
CMultiThreadedApp	theApp;

// 
// We actually implement main()
//
int __cdecl main (int argc, char *argv[])
{
	HRESULT				hrRes = S_OK;

	do
	{
		//
		// Call the prologue code
		//
		hrRes = Prologue(argc, argv);
		if (!SUCCEEDED(hrRes))
			break;

		//
		// Make sure the prologue code called SetApplicationParameters
		//
		if (!theApp.IsPoolCreated())
		{
			puts("Run time error: Thread pool not created in Prologue( ... )");
			puts("Program terminating abnormally.");
			break;
		}

		//
		// We unleash the thread pool, and let it do its work ...
		//
		hrRes = theApp.GetPool().SignalThreadPool();
		if (!SUCCEEDED(hrRes))
		{
			printf("Run time error: Unable to signal threads, error %08x\n", hrRes);
			puts("Program terminating abnormally.");
			break;
		}

		//
		// Wait for the pool to return, while generating notifications
		//
		hrRes = theApp.GetPool().WaitForAllThreadsToTerminate(
					theApp.GetNotifyPeriod(),
					NotificationProc,
					theApp.GetCallbackContext());

		//
		// OK, pass the information to the epilogue code
		//
		hrRes = Epilogue(
					theApp.GetCallbackContext(),
					hrRes);

	} while (0);

	//
	// Always call the cleanup function
	//
	CleanupApplication();

	return((int)hrRes);
}

CMultiThreadedApp::CMultiThreadedApp()
{
	m_fPoolCreated = FALSE;
	m_dwNotifyPeriod = 0;
	m_pvCallBackContext = NULL;
}

CMultiThreadedApp::~CMultiThreadedApp()
{
}

BOOL CMultiThreadedApp::IsPoolCreated()
{ 
	return(m_fPoolCreated); 
}

CThreadPool &CMultiThreadedApp::GetPool()
{
	return(m_Pool);
}

DWORD CMultiThreadedApp::GetNotifyPeriod()
{
	return(m_dwNotifyPeriod);
}

LPVOID CMultiThreadedApp::GetCallbackContext()
{
	return(m_pvCallBackContext);
}

HRESULT CMultiThreadedApp::CreateThreadPool(
			DWORD		dwThreads,
			LPVOID		*rgpvContexts,
			LPVOID		pvCallbackContext,
			DWORD		dwWaitNotificationPeriodInMilliseconds,
			DWORD		*pdwThreadsCreated
			)
{
	HRESULT	hrRes;
	
	if (!pdwThreadsCreated)
		return(E_INVALIDARG);

	m_dwNotifyPeriod = dwWaitNotificationPeriodInMilliseconds;
	m_pvCallBackContext = pvCallbackContext;
	
	hrRes = m_Pool.CreateThreadPool(
				dwThreads,
				pdwThreadsCreated,
				ThreadProc,
				rgpvContexts);

	if (SUCCEEDED(hrRes))
		m_fPoolCreated = TRUE;

	return(hrRes);
}

HRESULT CMultiThreadedApp::StartTimer(
			DWORD		*pdwStartMarker
			)
{
	*pdwStartMarker = GetTickCount();
	return(S_OK);
}

HRESULT CMultiThreadedApp::AddElapsedToTimer(
			DWORD		*pdwElapsedTime,
			DWORD		dwStartMarker
			)
{
	InterlockedExchangeAdd((PLONG)pdwElapsedTime, (LONG)(GetTickCount() - dwStartMarker));
	return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\thrdpool.cpp ===
#include <windows.h>
#include <crtdbg.h>

#include "thrdpool.h"

CThreadPool::CThreadPool()
{
	m_hStartEvent = NULL;
	m_phThreads = NULL;
	m_dwThreads = 0;
	m_fDestroy = FALSE;
	m_pfnThreadProc = NULL;
	m_rgContexts = NULL;
	m_lThreadCounter = 0;
}

CThreadPool::~CThreadPool()
{
	Cleanup();

	_ASSERT(m_lThreadCounter == 0);
}

HRESULT CThreadPool::Cleanup()
{
	if (m_hStartEvent)
	{
		CloseHandle(m_hStartEvent);
		m_hStartEvent = NULL;
	}

	if (m_phThreads)
	{
		for (DWORD i = 0; i < m_dwThreads; i++)
		{
			if (m_phThreads[i])
			{
				CloseHandle(m_phThreads[i]);
				m_phThreads[i] = NULL;
			}
		}
		delete [] m_phThreads;
		m_phThreads = NULL;
	}

	if (m_rgContexts)
	{
		delete [] m_rgContexts;
		m_rgContexts = NULL;
	}

	m_dwThreads = 0;

	return(S_OK);
}

HRESULT CThreadPool::CreateThreadPool(
			DWORD					dwThreads,
			DWORD					*pdwThreadsCreated,
			LPTHREAD_START_ROUTINE	pfnThreadProc,
			LPVOID					*rgpvContexts
			)
{
	DWORD	dwThreadId;

	if (m_hStartEvent || m_phThreads)
		return(E_FAIL);

	if (!pdwThreadsCreated ||
		!pfnThreadProc)
		return(E_INVALIDARG);

	m_hStartEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (!m_hStartEvent)
		return(E_OUTOFMEMORY);

	m_phThreads = new HANDLE [dwThreads];
	if (!m_phThreads)
	{
		Cleanup();
		return(E_OUTOFMEMORY);
	}

	m_rgContexts = new THD_CONTEXT [dwThreads];
	if (!m_rgContexts)
	{
		Cleanup();
		return(E_OUTOFMEMORY);
	}

	for (DWORD i = 0; i < dwThreads; i++)
	{
		m_rgContexts[i].pvThis = (LPVOID)this;
		m_rgContexts[i].pvContext = rgpvContexts?rgpvContexts[i]:NULL;

		m_phThreads[i] = CreateThread(NULL,
								0,
								CThreadPool::ThreadProc,
								&(m_rgContexts[i]),
								0,
								&dwThreadId);
		if (!m_phThreads[i])
			break;
	}

	*pdwThreadsCreated = i;
	m_dwThreads = i;
	m_fDestroy = FALSE;
	m_pfnThreadProc = pfnThreadProc;

	return(S_OK);
}

HRESULT CThreadPool::SignalAndDestroyThreadPool()
{
	m_fDestroy = TRUE;
	return(SignalThreadPool());
}

HRESULT CThreadPool::SignalThreadPool()
{
	if (!m_hStartEvent)
		return(E_INVALIDARG);

	if (SetEvent(m_hStartEvent))
		return(S_OK);
	return(HRESULT_FROM_WIN32(GetLastError()));
}

HRESULT CThreadPool::WaitForAllThreadsToTerminate(
			DWORD					dwNotificationPeriodInMilliseconds,
			PFN_NOTIFICATION		pfnNotification,
			LPVOID					pvNotificationContext
			)
{
	HRESULT	hrRes = S_OK;

	while (WaitForMultipleObjects(
				m_dwThreads,
				m_phThreads,
				TRUE,
				dwNotificationPeriodInMilliseconds) == WAIT_TIMEOUT)
	{
		hrRes = pfnNotification(pvNotificationContext);
		if (!SUCCEEDED(hrRes))
			break;
	}

	return(hrRes);
}

DWORD WINAPI CThreadPool::ThreadProc(
			LPVOID	pvContext
			)
{
	LPTHD_CONTEXT	pContext = (LPTHD_CONTEXT)pvContext;
	CThreadPool		*ptpPool = (CThreadPool *)pContext->pvThis;

	return(ptpPool->LocalThreadProc(pContext));
}

DWORD CThreadPool::LocalThreadProc(
			LPTHD_CONTEXT	pContext
			)
{
	DWORD			dwResult;
	
	InterlockedIncrement(&m_lThreadCounter);

	//
	// Wait for everybody to get ready...
	//
	WaitForSingleObject(m_hStartEvent, INFINITE);

	if (m_fDestroy)
		return(0);

	dwResult = m_pfnThreadProc(pContext->pvContext);

	InterlockedDecrement(&m_lThreadCounter);

	return(dwResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\parsearg.cpp ===
#include <stdio.h>
#include <windows.h>

#include "parsearg.h"

#define BAIL_WITH_ERROR(x)				\
		{								\
		SetParseError((x), szSwitch);	\
		return(x);						\
		}

#define RETURN_SUCCESS(x)				\
		{								\
		SetParseError((x), NULL);		\
		return(x);						\
		}

CParseArgs::CParseArgs(
			char					*szAppDescription,
			DWORD					dwDescriptors,
			LPARGUMENT_DESCRIPTOR	rgDescriptors
			)
{
	m_dwDescriptors = dwDescriptors;
	m_rgDescriptors = rgDescriptors;
	m_szAppDescription = szAppDescription;

	for (DWORD i = 0; i < m_dwDescriptors; i++)
		m_rgDescriptors[i].pvReserved = NULL;

	m_hrRes = S_OK;
}

CParseArgs::~CParseArgs()
{
	Cleanup();

	m_rgDescriptors = NULL;
	m_dwDescriptors = 0;
}

HRESULT CParseArgs::Cleanup()
{
	if (m_rgDescriptors)
	{
		for (DWORD i = 0; i < m_dwDescriptors; i++)
		{
			if ((m_rgDescriptors[i].pvReserved) &&
				(m_rgDescriptors[i].atType != AT_NONE))
			{
				delete [] (char *)(m_rgDescriptors[i].pvReserved);
				m_rgDescriptors[i].pvReserved = NULL;
			}
		}
	}
	return(S_OK);
}

LPARGUMENT_DESCRIPTOR CParseArgs::FindArgument(
			char	*szSwitch
			)
{
	for (DWORD i = 0; i < m_dwDescriptors; i++)
	{
		if (!lstrcmpi(szSwitch, m_rgDescriptors[i].szSwitch))
			return(&(m_rgDescriptors[i]));
	}

	return(NULL);
}

HRESULT CParseArgs::ParseArguments(
			int						argc,
			char					*argv[]
			)
{
	char					*szSwitch = NULL;
	LPARGUMENT_DESCRIPTOR	pArg = NULL;

	Cleanup();

	if ((argc < 1) || !argv)
		BAIL_WITH_ERROR(DISP_E_BADPARAMCOUNT);

	// Skip the first argument
	argc--;
	argv++;

	// Walk it!
	while (argc)
	{
		szSwitch = *argv;
		pArg = FindArgument(szSwitch);
		if (!pArg)
			BAIL_WITH_ERROR(DISP_E_UNKNOWNNAME);

		// See if it's already set
		if (pArg->pvReserved)
		{
			BAIL_WITH_ERROR(STG_E_FILEALREADYEXISTS);
		}

		// Process the known argument
		if (pArg->atType == AT_NONE)
		{
			pArg->pvReserved = (LPVOID)1;
		}
		else
		{
			DWORD	dwSize;
			DWORD	dwValue;
			LPVOID	pvBuffer;

			argc--;
			argv++;
			if (!argc)
				BAIL_WITH_ERROR(DISP_E_BADPARAMCOUNT);

			switch (pArg->atType)
			{
			case AT_STRING:
				dwSize = lstrlen(*argv) + 1;
				pvBuffer = (LPVOID)new char [dwSize];
				if (!pvBuffer)
					BAIL_WITH_ERROR(E_OUTOFMEMORY);
				lstrcpy((char *)pvBuffer, *argv);
				pArg->pvReserved = pvBuffer;
				break;

			case AT_VALUE:
				dwSize = sizeof(DWORD);
				pvBuffer = (LPVOID)new char [dwSize];
				if (!pvBuffer)
					BAIL_WITH_ERROR(E_OUTOFMEMORY);
				if (!StringToValue(*argv, &dwValue))
					BAIL_WITH_ERROR(DISP_E_BADVARTYPE);
				*(DWORD *)pvBuffer = dwValue;
				pArg->pvReserved = pvBuffer;
				break;

			default:
				BAIL_WITH_ERROR(NTE_BAD_TYPE);
			}
		}
		
		argc--;
		argv++;
	}

	// Make sure all the required ones are there ...
	for (DWORD i = 0; i < m_dwDescriptors; i++)
		if (m_rgDescriptors[i].fRequired &&
			!m_rgDescriptors[i].pvReserved &&
			m_rgDescriptors[i].atType != AT_NONE)
		{
			szSwitch = m_rgDescriptors[i].szSwitch;
			BAIL_WITH_ERROR(DISP_E_PARAMNOTFOUND);
		}

	RETURN_SUCCESS(S_OK);
}

HRESULT CParseArgs::Exists(
			DWORD	dwDescriptorIndex
			)
{
	if (dwDescriptorIndex > m_dwDescriptors)
		return(E_INVALIDARG);

	if (m_rgDescriptors[dwDescriptorIndex].pvReserved)
		return(S_OK);

	return(E_FAIL);
}

HRESULT CParseArgs::GetSwitch(
			DWORD	dwDescriptorIndex,
			BOOL	*pfExists
			)
{
	LPARGUMENT_DESCRIPTOR	pArg = NULL;
	char					*szSwitch;

	if (dwDescriptorIndex > m_dwDescriptors)
		return(E_INVALIDARG);

	pArg = m_rgDescriptors + dwDescriptorIndex;
	szSwitch = pArg->szSwitch;

	if (pArg->atType != AT_NONE)
		BAIL_WITH_ERROR(DISP_E_TYPEMISMATCH);

	if (pArg->pvReserved)
		*pfExists = TRUE;

	RETURN_SUCCESS(S_OK);
}

HRESULT CParseArgs::GetString(
			DWORD	dwDescriptorIndex,
			char	**ppszStringValue
			)
{
	LPARGUMENT_DESCRIPTOR	pArg = NULL;
	char					*szSwitch;

	if (dwDescriptorIndex > m_dwDescriptors)
		return(E_INVALIDARG);

	pArg = m_rgDescriptors + dwDescriptorIndex;
	szSwitch = pArg->szSwitch;

	if (!pArg->pvReserved)
		BAIL_WITH_ERROR(DISP_E_PARAMNOTFOUND);

	if (pArg->atType != AT_STRING)
		BAIL_WITH_ERROR(DISP_E_TYPEMISMATCH);

	*ppszStringValue = (char *)pArg->pvReserved;
	RETURN_SUCCESS(S_OK);
}

HRESULT CParseArgs::GetDword(
			DWORD	dwDescriptorIndex,
			DWORD	*pdwDwordValue
			)
{
	LPARGUMENT_DESCRIPTOR	pArg = NULL;
	char					*szSwitch;

	if (dwDescriptorIndex > m_dwDescriptors)
		return(E_INVALIDARG);

	pArg = m_rgDescriptors + dwDescriptorIndex;
	szSwitch = pArg->szSwitch;

	if (!pArg->pvReserved)
		BAIL_WITH_ERROR(DISP_E_PARAMNOTFOUND);

	if (pArg->atType != AT_VALUE)
		BAIL_WITH_ERROR(DISP_E_TYPEMISMATCH);

	*pdwDwordValue = *(DWORD *)(pArg->pvReserved);
	RETURN_SUCCESS(S_OK);
}

HRESULT CParseArgs::GenerateUsage(
			DWORD	*pdwLength,
			char	*szUsage
			)
{
	DWORD	dwLength = 0;
	char	*pBuffer = m_szBuffer;

	dwLength = sprintf(pBuffer, "\n%s\n\nUsage:\n", m_szAppDescription);
	pBuffer += dwLength;

	for (DWORD i = 0; i < m_dwDescriptors; i++)
	{
		DWORD	dwTempLength;

		dwTempLength = sprintf(pBuffer, "\t%s\n", m_rgDescriptors[i].szUsage);
		pBuffer += dwTempLength;
		dwLength += dwTempLength;
	}

	if (dwLength < *pdwLength)
	{
		*pdwLength = dwLength;
		lstrcpy(szUsage, m_szBuffer);
		return(S_OK);
	}
	*pdwLength = dwLength;
	return(HRESULT_FROM_WIN32(ERROR_MORE_DATA));
}

HRESULT CParseArgs::GetErrorString(
			DWORD	*pdwLength,
			char	*szErrorString
			)
{
	DWORD	dwLength;

	if (m_hrRes == S_OK)
	{
		lstrcpy(m_szBuffer, "The operation completed successfully.");
	}
	else
	{
		switch (m_hrRes)
		{
		case DISP_E_UNKNOWNNAME:
			sprintf(m_szBuffer, "The command switch %s is invalid.",
					m_szErrorSwitch);
			break;

		case DISP_E_PARAMNOTFOUND:
			sprintf(m_szBuffer, "The required command switch %s is not specified.",
					m_szErrorSwitch);
			break;

		case DISP_E_TYPEMISMATCH:
			sprintf(m_szBuffer, 
					"The argument value for command switch %s is of the wrong type.",
					m_szErrorSwitch);
			break;

		case DISP_E_BADVARTYPE:
			sprintf(m_szBuffer, 
					"The argument value supplied for command switch %s is not a valid number.",
					m_szErrorSwitch);
			break;

		case E_OUTOFMEMORY:
			sprintf(m_szBuffer, 
					"The system does not have sufficient resources to complete the operation.",
					m_szErrorSwitch);
			break;

		case DISP_E_BADPARAMCOUNT:
			sprintf(m_szBuffer, "The number of arguments specified is invalid.",
					m_szErrorSwitch);
			break;

		case STG_E_FILEALREADYEXISTS:
			sprintf(m_szBuffer, "The command switch %s is specified more than once.",
					m_szErrorSwitch);
			break;

		case NTE_BAD_TYPE:
			sprintf(m_szBuffer, "Internal error: A invalid argument type is specified.",
					m_szErrorSwitch);
			break;

		default:
			sprintf(m_szBuffer, "Unknown error code %08x on switch %s", 
						m_hrRes,
						m_szErrorSwitch);
		}
		
	}

	dwLength = lstrlen(m_szBuffer);			
	if (dwLength < *pdwLength)
	{
		*pdwLength = dwLength + 1;
		lstrcpy(szErrorString, m_szBuffer);
		return(S_OK);
	}

	*pdwLength = dwLength + 1;
	return(HRESULT_FROM_WIN32(ERROR_MORE_DATA));
}

void CParseArgs::SetParseError(
			HRESULT	hrRes,
			char	*szSwitch
			)
{
	if (szSwitch)
		lstrcpy(m_szErrorSwitch, szSwitch);
	m_hrRes = hrRes;
}

BOOL CParseArgs::StringToValue(
			char	*szString,
			DWORD	*pdwValue
			)
{
	DWORD	dwValue = 0;
	char	ch;

	while (*szString)
	{
		ch = *szString;
		if ((ch < '0') || (ch > '9'))
			return(FALSE);
		ch -= '0';
		dwValue *= 10;
		dwValue += (DWORD)ch;
		szString++;
	}

	*pdwValue = dwValue;
	return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\thrdpool.h ===
#ifndef __THRDPOOL_H__
#define __THRDPOOL_H__

typedef HRESULT (*PFN_NOTIFICATION)(LPVOID);

typedef struct _THD_CONTEXT
{
	LPVOID	pvThis;
	LPVOID	pvContext;

} THD_CONTEXT, *LPTHD_CONTEXT;

class CThreadPool
{
  public:

	CThreadPool();
	~CThreadPool();

	HRESULT CreateThreadPool(
				DWORD					dwThreads,
				DWORD					*pdwThreadsCreated,
				LPTHREAD_START_ROUTINE	pfnThreadProc,
				LPVOID					*rgpvContexts
				);

	HRESULT SignalAndDestroyThreadPool();

	HRESULT SignalThreadPool();

	HRESULT WaitForAllThreadsToTerminate(
				DWORD					dwNotificationPeriodInMilliseconds,
				PFN_NOTIFICATION		pfnNotification,
				LPVOID					pvNotificationContext
				);
				
	static DWORD WINAPI ThreadProc(
				LPVOID	pvContext
				);

	DWORD LocalThreadProc(
				LPTHD_CONTEXT	pContext
				);

  private:

	HRESULT Cleanup();

	long					m_lThreadCounter;

	HANDLE					m_hStartEvent;
	DWORD					m_dwThreads;
	HANDLE					*m_phThreads;

	LPTHREAD_START_ROUTINE	m_pfnThreadProc;
	LPTHD_CONTEXT			m_rgContexts;
	BOOL					m_fDestroy;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\cthrdapp\cthrdapp.h ===
#ifndef __CTHRDAPP_H__
#define __CTHRDAPP_H__

#include "thrdpool.h"
#include "cthdutil.h"

class CMultiThreadedApp
{
  public:

	CMultiThreadedApp();
	~CMultiThreadedApp();

	BOOL IsPoolCreated();

	CThreadPool &GetPool();

	DWORD GetNotifyPeriod();

	LPVOID GetCallbackContext();

	HRESULT CreateThreadPool(
				DWORD		dwThreads,
				LPVOID		*rgpvContexts,
				LPVOID		pvCallbackContext,
				DWORD		dwWaitNotificationPeriodInMilliseconds,
				DWORD		*pdwThreadsCreated
				);

	HRESULT StartTimer(
				DWORD		*pdwStartMarker
				);

	HRESULT AddElapsedToTimer(
				DWORD		*pdwElapsedTime,
				DWORD		dwStartMarker
				);

  private:

	CThreadPool			m_Pool;

	BOOL				m_fPoolCreated;
	DWORD				m_dwNotifyPeriod;
	LPVOID				m_pvCallBackContext;


};

//
// Omnipresent instance of the application ...
//
extern CMultiThreadedApp	theApp;

//
// Applications must provide implementations for these functions
//
extern HRESULT Prologue(
			int		argc,
			char	*argv[]
			);

extern DWORD WINAPI ThreadProc(
			LPVOID	pvContext
			);

extern HRESULT NotificationProc(
			LPVOID	pvCallbackContext
			);

extern HRESULT Epilogue(
			LPVOID	pvCallbackContext,
			HRESULT	hrRes
			);

extern HRESULT CleanupApplication();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\dll\atl.cpp ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:       atl.cpp
//
//  Contents:   Includes atlimpl.cpp, so that we don't rely on atl.dll
//
//  Classes:    All ATL classes.
//
//  Functions:  All ATL functions.
//
//  History:    October 23, 1997 - Milans, Created.
//
//-----------------------------------------------------------------------------

//#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include "dbgtrace.h"
#include "stdafx.h"
#include "statreg.h"
#include "statreg.cpp"
#include "atlimpl.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\dll\msg.cpp ===
//+----------------------------------------------------------------------------
//
//  Msg.cpp : Implementation of CMsg
//
//  Copyright (C) 1998, Microsoft Corporation
//
//  File:       msg.cpp
//
//  Contents:   Implementation of CMsg.
//
//  Classes:    CMsg
//
//  Functions:
//
//  History:    3/27/98		KeithLau		Created
//
//-----------------------------------------------------------------------------

//#define WIN32_LEAN_AND_MEAN
#include "atq.h"
#include "dbgtrace.h"
#include "stdafx.h"

#include "filehc.h"
#include "mailmsg.h"
#include "mailmsgi.h"
#include "cmailmsg.h"
#include "Msg.h"

/////////////////////////////////////////////////////////////////////////////
// CMsg

DECLARE_DEBUG_PRINTS_OBJECT()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\dll\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgp.h $(O)\mailmsgp_i.c : $(STAXINC)\export\mailmsgp.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgp_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgp_i.c \
    -header $@ \
    -tlb $(O)\mailmsgp.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mailmsg.rc
//
#define IDS_PROJNAME                    100
#define IDR_MAILMSG                      101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\dumpmsg\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgp.h $(O)\mailmsgp_i.c : $(STAXINC)\export\mailmsgp.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgp_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgp_i.c \
    -header $@ \
    -tlb $(O)\mailmsgp.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\dll\mailmsg.cpp ===
// imsg.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f imsgps.mk in the project directory.

//#define WIN32_LEAN_AND_MEAN
#include <atq.h>
#include "dbgtrace.h"
#define _ASSERTE _ASSERT

#include "stdafx.h"


#include "resource.h"
#include "initguid.h"

#include "filehc.h"
#include "mailmsg.h"
#include "mailmsgi.h"

#include "cmailmsg.h"
#include "transmem.h"
#include "msg.h"


CComModule _Module;

HANDLE g_hTransHeap = NULL;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_MsgImp, CMsg)
END_OBJECT_MAP()

// =================================================================
// Static declarations
//
CPool CMsg::m_Pool((DWORD)'pMCv');

//
// CPool parameters 
//
#define DEFAULT_CMSG_ABSOLUTE_MAX_POOL_SIZE	100000
#define DEFAULT_CMSG_NORMAL_POOL_SIZE		90000
#define DEFAULT_ADD_POOL_SIZE				10000
#define DEFAULT_BLOCK_POOL_SIZE				100000

BOOL	g_fCMsgPoolInitialized	= FALSE;
BOOL	g_fAddPoolInitialized	= FALSE;
BOOL	g_fBlockPoolInitialized	= FALSE;
DWORD	g_dwCMsgPoolSize		= DEFAULT_CMSG_ABSOLUTE_MAX_POOL_SIZE;
DWORD	g_dwCMsgNormalPoolSize	= DEFAULT_CMSG_NORMAL_POOL_SIZE;
DWORD	g_dwAddPoolSize			= DEFAULT_ADD_POOL_SIZE;
DWORD	g_dwBlockPoolSize		= DEFAULT_BLOCK_POOL_SIZE;

DWORD	g_dwObjectCount = 0;

DWORD                           g_fForceCrashOnError            = 0;
DWORD                           g_fValidateOnForkForRecipients  = 0;
DWORD                           g_fValidateOnRelease            = 0;
DWORD __declspec(dllexport)     g_fValidateSignatures           = 0;
DWORD __declspec(dllexport)     g_fFillPropertyPages            = 1;

//
// Function to get registry values
//
BOOL g_mailmsg_GetRegistryDwordParameter(
			LPCSTR	pcszParameterName,
			DWORD	*pdwValue
			)
{
	HKEY	hKey = NULL;
	DWORD	dwRes;
	DWORD	dwType;
	DWORD	dwLength;
	DWORD	dwValue;
	BOOL	fRes = FALSE;

	// Open the registry key
	dwRes = (DWORD)RegOpenKeyEx(
				HKEY_LOCAL_MACHINE,
				_T("Software\\Microsoft\\Exchange\\MailMsg"),
				0,
				KEY_ALL_ACCESS,
				&hKey);
	if (dwRes == ERROR_SUCCESS)
	{
		// Adjust the buffer size for character type ...
		dwLength = sizeof(DWORD);
		dwRes = (DWORD)RegQueryValueEx(
					hKey,
					pcszParameterName,
					NULL,
					&dwType,
					(LPBYTE)&dwValue,
					&dwLength);
		if ((dwRes == ERROR_SUCCESS) && dwType == REG_DWORD)
		{
			*pdwValue = dwValue;
			fRes = TRUE;
		}

		_VERIFY(RegCloseKey(hKey) == NO_ERROR);
	}

	return(fRes);
}


//
// Track the allocations of CMailMsg objects
//
#ifdef DEBUG
#define MAILMSG_TRACKING_LOCKED		1
#define MAILMSG_TRACKING_UNLOCKED	0

LIST_ENTRY	g_leTracking;
DWORD		g_dwAllocThreshold = 0;
LONG		g_lSpinLock = MAILMSG_TRACKING_UNLOCKED;
DWORD		g_dwOutOfMemoryErrors = 0;

void g_mailmsg_Lock()
{
	while (InterlockedCompareExchange(&g_lSpinLock, MAILMSG_TRACKING_LOCKED, MAILMSG_TRACKING_UNLOCKED) == MAILMSG_TRACKING_LOCKED)
		;
}

void g_mailmsg_Unlock()
{
	if (InterlockedExchange(&g_lSpinLock, MAILMSG_TRACKING_UNLOCKED) != MAILMSG_TRACKING_LOCKED)
	{ _ASSERT(FALSE); }
}

void g_mailmsg_Init()
{
	InitializeListHead(&g_leTracking);
	g_dwObjectCount = 0;
	g_lSpinLock = MAILMSG_TRACKING_UNLOCKED;

	// Get threshold from registry, if specified
	g_dwAllocThreshold = 0;
	g_mailmsg_GetRegistryDwordParameter(
			_T("AllocThreshold"),
			&g_dwAllocThreshold);

}

DWORD g_mailmsg_Add(PLIST_ENTRY	ple)
{
	DWORD	dwTemp;
	g_mailmsg_Lock();
	InsertHeadList(&g_leTracking, ple);
	dwTemp = ++g_dwObjectCount;
	if (g_dwAllocThreshold)
	{
		_ASSERT(dwTemp <= g_dwAllocThreshold);
	}
	g_mailmsg_Unlock();
	return(dwTemp);
}

DWORD g_mailmsg_Remove(PLIST_ENTRY	ple)
{
	DWORD	dwTemp;
	g_mailmsg_Lock();
	RemoveEntryList(ple);
	_ASSERT(g_dwObjectCount > 0);
	dwTemp = --g_dwObjectCount;
	g_mailmsg_Unlock();
	return(dwTemp);
}

DWORD g_mailmsg_Check()
{
	TraceFunctEnter("g_mailmsg_Check");
	g_mailmsg_Lock();
	if (g_dwObjectCount)
	{
		ErrorTrace((LPARAM)0, "Leaked %u objects", g_dwObjectCount);
		PLIST_ENTRY	ple = g_leTracking.Flink;
		for (DWORD i = 0; i < g_dwObjectCount; i++)
		{
			_ASSERT(ple != &g_leTracking);
			ErrorTrace((LPARAM)ple, "Object at %p not released.", ple);
			ple = ple->Flink;
		}
		_ASSERT(ple == &g_leTracking);
		_ASSERT(FALSE);
	}
	g_mailmsg_Unlock();
	TraceFunctLeave();
	return(g_dwObjectCount);
}

#endif // DEBUG


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		TraceFunctEnterEx((LPARAM)hInstance, "mailmsg!DllMain!ATTACH");
	
        // init transmem
        TrHeapCreate();

        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);

#ifdef DEBUG
		// Initialize the tracking list
		g_mailmsg_Init();
#endif

        // initialize the crc library
        crcinit();

		// Clear the object counter
		g_dwObjectCount = 0;

		// Get the sizes for each of our CPools from 
		// the registry, if specified ...
		g_mailmsg_GetRegistryDwordParameter(
					_T("MaxMessageObjects"),
					&g_dwCMsgPoolSize);
		DebugTrace((LPARAM)hInstance, 
			"IMailMsgProperties absolute max pool size: %u objects", g_dwCMsgPoolSize);

        g_mailmsg_GetRegistryDwordParameter(
            _T("ValidateOnForkForRecipients"),
            (PDWORD)&g_fValidateOnForkForRecipients);

        g_mailmsg_GetRegistryDwordParameter(
            _T("ForceCrashOnError"),
            (PDWORD)&g_fForceCrashOnError);

        g_mailmsg_GetRegistryDwordParameter(
            _T("ValidateOnRelease"),
            (PDWORD)&g_fValidateOnRelease);

        g_mailmsg_GetRegistryDwordParameter(
            _T("ValidateSignatures"),
            (PDWORD)&g_fValidateSignatures);

        g_mailmsg_GetRegistryDwordParameter(
            _T("FillPropertyPages"),
            (PDWORD)&g_fFillPropertyPages);

		g_mailmsg_GetRegistryDwordParameter(
					_T("MessageObjectsInboundCutoffCount"),
					&g_dwCMsgNormalPoolSize);
		DebugTrace((LPARAM)hInstance, 
			"IMailMsgProperties inbound cutoff threshold: %u objects", g_dwCMsgNormalPoolSize);

		g_mailmsg_GetRegistryDwordParameter(
					_T("MaxMessageAddObjects"),
					&g_dwAddPoolSize);
		DebugTrace((LPARAM)hInstance, 
			"IMailMsgPropertiesAdd pool size: %u objects", g_dwAddPoolSize);

		g_mailmsg_GetRegistryDwordParameter(
					_T("MaxPropertyBlocks"),
					&g_dwBlockPoolSize);
		DebugTrace((LPARAM)hInstance, 
			"BLOCK_HEAP_NODE pool size: %u objects", g_dwBlockPoolSize);

		// Checking the message count and cutoff values
		if (g_dwCMsgPoolSize <= g_dwCMsgNormalPoolSize)
		{
			g_dwCMsgNormalPoolSize = (g_dwCMsgPoolSize * 9) / 10;

			// If we have so pathetically few message objects, might 
			// as well set the cutoff to the upper bound
			if (!g_dwCMsgNormalPoolSize)
				g_dwCMsgNormalPoolSize = g_dwCMsgPoolSize;

			DebugTrace((LPARAM)0, "Adjusted inbound cutoff to %u objects",
				g_dwCMsgNormalPoolSize);
		}

		// Globally initialize the cpools

		// CMsg objects
		if (!CMsg::m_Pool.ReserveMemory(
					g_dwCMsgPoolSize,
					sizeof(CMsg)))
		{
			SetLastError(ERROR_DLL_INIT_FAILED);
			return(FALSE);
		}
		g_fCMsgPoolInitialized = TRUE;

		// CMailMsgRecipientsAdd objects
		if (!CMailMsgRecipientsAdd::m_Pool.ReserveMemory(
					g_dwAddPoolSize,
					sizeof(CMailMsgRecipientsAdd)))
		{
			SetLastError(ERROR_DLL_INIT_FAILED);
			return(FALSE);
		}
		g_fAddPoolInitialized = TRUE;

		// BLOCK_HEAP_NODE structures, these are slightly out of the ordinary
		if (!CBlockMemoryAccess::m_Pool.ReserveMemory(
					g_dwBlockPoolSize, 
					sizeof(BLOCK_HEAP_NODE)))
		{
			SetLastError(ERROR_DLL_INIT_FAILED);
			return(FALSE);
		}
		g_fBlockPoolInitialized = TRUE;

		TraceFunctLeave();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		TraceFunctEnterEx((LPARAM)hInstance, "mailmsg!DllMain!DETACH");

#ifdef DEBUG
		// 
		// Verify the tracking list
		//  This must happen *before* we release CPool
		//
		g_mailmsg_Check();
#endif
		// Release all the CPools
		// These will assert if we are not shutdown cleanly
		if (g_fBlockPoolInitialized)
		{
			_ASSERT(CBlockMemoryAccess::m_Pool.GetAllocCount() == 0);
			CBlockMemoryAccess::m_Pool.ReleaseMemory();
			g_fBlockPoolInitialized = FALSE;
		}
		if (g_fAddPoolInitialized)
		{
			_ASSERT(CMailMsgRecipientsAdd::m_Pool.GetAllocCount() == 0);
			CMailMsgRecipientsAdd::m_Pool.ReleaseMemory();
			g_fAddPoolInitialized = FALSE;
		}
		if (g_fCMsgPoolInitialized)
		{
			_ASSERT(CMsg::m_Pool.GetAllocCount() == 0);
			CMsg::m_Pool.ReleaseMemory();
			g_fCMsgPoolInitialized = FALSE;
		}

        _Module.Term();

        // shutdown transmem
        TrHeapDestroy();

		TraceFunctLeave();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
//
// S_OK means we can unload this DLL
//
// S_FALSE means we cannot unload this DLL

STDAPI DllCanUnloadNow(void)
{
    HRESULT hr = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

    //
    //  LKRHash keeps a static list of outstanding hash tables.
    //  If we say that we can unload with outstanding hash tables,
    //  then LKRHash will be pointing to unitialized memory.  If
    //  we otherwise think we can be unloaded... make sure that
    //  we check the count of oustanding RecipientAdd objects, because
    //  we do not want to crash because someone leaked.
    //
    if ((S_OK == hr) && CMailMsgRecipientsAdd::m_Pool.GetAllocCount())
        hr = S_FALSE;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\dll\msg.h ===
// Msg.h : Declaration of the CMsg

#ifndef __MSG_H_
#define __MSG_H_

#include "resource.h"       // main symbols

#ifdef DEBUG
DWORD g_mailmsg_Add(PLIST_ENTRY	ple);
DWORD g_mailmsg_Remove(PLIST_ENTRY	ple);
#endif

extern DWORD g_dwCMsgNormalPoolSize;
extern DWORD g_dwObjectCount;

/////////////////////////////////////////////////////////////////////////////
// CMsg

class ATL_NO_VTABLE CMsg :
	public CMailMsg,
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public CComCoClass<CMsg, &CLSID_MsgImp>
{
public:
    CMsg() {}
    ~CMsg() {}

	//
	// CPool
	//
	static CPool m_Pool;
	inline void *operator new(size_t size)
	{
		return m_Pool.Alloc();
	}
	inline void operator delete(void *p)
	{
		m_Pool.Free(p);
	}

	ULONG InternalAddRef()
	{
		ULONG ulTemp = CComObjectRootEx<CComMultiThreadModelNoCS>::InternalAddRef();
		TraceFunctEnterEx((LPARAM)this, "CMsg::InternalAddRef");
		DebugTrace((LPARAM)this, "After InternalAddRef : %u", ulTemp);
		return(ulTemp);
	}

	ULONG InternalRelease()
	{
		ULONG ulTemp = CComObjectRootEx<CComMultiThreadModelNoCS>::InternalRelease();
		TraceFunctEnterEx((LPARAM)this, "CMsg::InternalRelease");
		DebugTrace((LPARAM)this, "After InternalRelease : %u", ulTemp);
		return(ulTemp);
	}

	HRESULT FinalConstruct()
	{
		TraceFunctEnterEx((LPARAM)this, "CMsg::FinalConstruct");
#ifdef DEBUG
		// Add object to tracking list
		DWORD dwCount = g_mailmsg_Add(&m_leTracking);
#else
        // Bump object count
        DWORD dwCount = InterlockedIncrement((LONG *)&g_dwObjectCount);
#endif

        // If the count is more than the normal pool size
        // (i.e. inbound cutoff), then we set a special creation flag
        if (dwCount > g_dwCMsgNormalPoolSize)
        {
            DebugTrace((LPARAM)this, "Object #%u exceeding inbound cutoff", dwCount);
            CMailMsg::m_dwCreationFlags |= MPV_INBOUND_CUTOFF_EXCEEDED;
        }

		HRESULT hrRes = Initialize();
		return(hrRes);
	}

	HRESULT FinalRelease()
	{
		TraceFunctEnterEx((LPARAM)this, "CMsg::FinalRelease");
        CMailMsg::FinalRelease();
#ifdef DEBUG
		// Add object to tracking list
		g_mailmsg_Remove(&m_leTracking);
#else
        // Drop object count
        InterlockedDecrement((LONG *)&g_dwObjectCount);
#endif
		return(S_OK);
	}

DECLARE_REGISTRY_RESOURCEID(IDR_MAILMSG)

BEGIN_COM_MAP(CMsg)
    COM_INTERFACE_ENTRY(IMailMsgProperties)
    COM_INTERFACE_ENTRY(IMailMsgRecipients)
    COM_INTERFACE_ENTRY(IMailMsgRecipientsBase)
    COM_INTERFACE_ENTRY(IMailMsgQueueMgmt)
    COM_INTERFACE_ENTRY(IMailMsgBind)
    COM_INTERFACE_ENTRY(IMailMsgPropertyReplication)
    COM_INTERFACE_ENTRY(IMailMsgPropertyManagement)
    COM_INTERFACE_ENTRY(IMailMsgAQueueListEntry)
    COM_INTERFACE_ENTRY(IMailMsgValidate)
    COM_INTERFACE_ENTRY(IMailMsgValidateContext)
END_COM_MAP()

private:
	LIST_ENTRY	m_leTracking;

};

#define IMSG_DIRECTORY_CONFIG_KEY_NAME _T("Exchange.MailMsg")

#endif //__MSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\dll\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__2DB263A4_499F_11D1_B78F_0080C731C893__INCLUDED_)
#define AFX_STDAFX_H__2DB263A4_499F_11D1_B78F_0080C731C893__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif


#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#define _ASSERTE _ASSERT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2DB263A4_499F_11D1_B78F_0080C731C893__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\dumpmsg\dumpmsg.h ===
#ifndef __DUMPMSG_H_
#define __DUMPMSG_H_

// per-message properties DWORD values

DWORD dwMPNameId[] =
{	4096,
	4097,
	4098,
	4099,
	4100,
	4101,
	4102,
	4103,
	4104,
	4105,
	4106,
	4107,
	4108,
	4109,
	4110,
	4111,
	4112,
	4113,
	4114,
	4115,
	4116,
	4117,
	4118,
	4119,
	4120,
	4121,
	4122,
	4123,
	4124,
	4125,
	4126,
	4127,
	4128,
	4129,
	4130,
	4131,
	4132,
	4133,
	4134,
	4135,
	4136,
	4137,
	4138,
	4139,
	4140,
	4141,
	4142,
	4143,
	4144,
	4145,
	4146,
	4147,
	4148,
	4149,
	4150,
	4151,
	4152
};

// per-message properties string values

char* szMPValues[] =
{	"IMMPID_MP_RECIPIENT_LIST",
	"IMMPID_MP_CONTENT_FILE_NAME",
	"IMMPID_MP_SENDER_ADDRESS_SMTP",
	"IMMPID_MP_SENDER_ADDRESS_X500",
	"IMMPID_MP_SENDER_ADDRESS_X400",
	"IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN",
	"IMMPID_MP_DOMAIN_LIST",
	"IMMPID_MP_PICKUP_FILE_NAME",
	"IMMPID_MP_AUTHENTICATED_USER_NAME",
	"IMMPID_MP_CONNECTION_IP_ADDRESS",
	"IMMPID_MP_HELO_DOMAIN",
	"IMMPID_MP_EIGHTBIT_MIME_OPTION",
	"IMMPID_MP_CHUNKING_OPTION",
	"IMMPID_MP_BINARYMIME_OPTION",
	"IMMPID_MP_REMOTE_AUTHENTICATION_TYPE",
	"IMMPID_MP_ERROR_CODE",
	"IMMPID_MP_DSN_ENVID_VALUE",
	"IMMPID_MP_DSN_RET_VALUE",
	"IMMPID_MP_REMOTE_SERVER_DSN_CAPABLE",
	"IMMPID_MP_ARRIVAL_TIME",
	"IMMPID_MP_MESSAGE_STATUS",
	"IMMPID_MP_EXPIRE_DELAY",
	"IMMPID_MP_EXPIRE_NDR",
	"IMMPID_MP_LOCAL_EXPIRE_DELAY",
	"IMMPID_MP_LOCAL_EXPIRE_NDR",
	"IMMPID_MP_ARRIVAL_FILETIME",
	"IMMPID_MP_HR_CAT_STATUS",
	"IMMPID_MP_MSG_GUID",
	"IMMPID_MP_SUPERSEDES_MSG_GUID",
	"IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF",
	"IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF",
	"IMMPID_MP_MSG_SIZE_HINT",
	"IMMPID_MP_RFC822_MSG_ID",
	"IMMPID_MP_RFC822_MSG_SUBJECT",
	"IMMPID_MP_RFC822_FROM_ADDRESS",
	"IMMPID_MP_RFC822_TO_ADDRESS",
	"IMMPID_MP_RFC822_CC_ADDRESS",
	"IMMPID_MP_RFC822_BCC_ADDRESS",
	"IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS",
	"IMMPID_MP_SERVER_NAME",
	"IMMPID_MP_SERVER_VERSION",
	"IMMPID_MP_NUM_RECIPIENTS",
	"IMMPID_MP_X_PRIORITY",
	"IMMPID_MP_FROM_ADDRESS",
	"IMMPID_MP_SENDER_ADDRESS",
	"IMMPID_MP_DEFERRED_DELIVERY_FILETIME",
	"IMMPID_MP_SENDER_ADDRESS_OTHER",
	"IMMPID_MP_ORIGINAL_ARRIVAL_TIME",
	"IMMPID_MP_MSGCLASS",
	"IMMPID_MP_CONTENT_TYPE",
	"IMMPID_MP_ENCRYPTION_TYPE",
	"IMMPID_MP_CONNECTION_SERVER_PORT",
	"IMMPID_MP_CLIENT_AUTH_USER",
	"IMMPID_MP_CLIENT_AUTH_TYPE",
	"IMMPID_MP_CRC_GLOBAL",
	"IMMPID_MP_CRC_RECIPS",
	"IMMPID_MP_INBOUND_MAIL_FROM_AUTH"
};

// per-recipient properties DWORD values

DWORD dwRPNameId[] =
{	8192,
	8193,
	8194,
	8195,
	8196,
	8197,
	8198,
	8199,
	8200,
	8201,
	8202,
	8203,
	8204,
	8205,
	8206,
	8207,
	8208,
	8209,
	8210,
	8211,
	8212
};

// per-recipient properties string values

char* szRPValues[] =
{	"IMMPID_RP_DSN_NOTIFY_SUCCESS",
	"IMMPID_RP_DSN_NOTIFY_INVALID",
	"IMMPID_RP_ADDRESS_TYPE",
	"IMMPID_RP_ADDRESS",
	"IMMPID_RP_ADDRESS_TYPE_SMTP",
	"IMMPID_RP_ERROR_CODE",
	"IMMPID_RP_ERROR_STRING",
	"IMMPID_RP_DSN_NOTIFY_VALUE",
	"IMMPID_RP_DSN_ORCPT_VALUE",
	"IMMPID_RP_ADDRESS_SMTP",
	"IMMPID_RP_ADDRESS_X400",
	"IMMPID_RP_ADDRESS_X500",
	"IMMPID_RP_LEGACY_EX_DN",
	"IMMPID_RP_RECIPIENT_FLAGS",
	"IMMPID_RP_SMTP_STATUS_STRING",
	"IMMPID_RP_DSN_PRE_CAT_ADDRESS",
	"IMMPID_RP_MDB_GUID",
	"IMMPID_RP_USER_GUID",
	"IMMPID_RP_DOMAIN",
	"IMMPID_RP_ADDRESS_OTHER",
	"IMMPID_RP_DISPLAY_NAME"
};

// per-message volatile properties DWORD values

DWORD dwMPVNameId[] =
{	12288,
	12289,
	12290,
	12291,
	12292,
	12293
};

// per-message volatile properties string values

char* szMPVValues[] =
{	"IMMPID_MPV_STORE_DRIVER_HANDLE",
	"IMMPID_MPV_MESSAGE_CREATION_FLAGS",
	"IMMPID_MPV_MESSAGE_OPEN_HANDLES",
	"IMMPID_MPV_TOTAL_OPEN_HANDLES",
	"IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES",
	"IMMPID_MPV_TOTAL_OPEN_CONTENT_HANDLES"
};

// per-recipient volatile properties DWORD values

DWORD dwRPVNameId[] =
{	16384,
	16385
};

// per-recipient volatile properties string values

char* szRPVValues[] =
{	"IMMPID_RPV_DONT_DELIVER",
	"IMMPID_RPV_NO_NAME_COLLISIONS"
};

// per-recipient properties for NNTP DWORD values

DWORD dwNMPNameId[] =
{	24576,
	24577,
	24578,
	24579,
	24580,
	24581,
	24582,
	24583,
	24584
};

// per-recipient properties for NNTP string values

char* szNMPValues[] =
{	"IMMPID_NMP_SECONDARY_GROUPS",
	"IMMPID_NMP_SECONDARY_ARTNUM",
	"IMMPID_NMP_PRIMARY_GROUP",
	"IMMPID_NMP_PRIMARY_ARTID",
	"IMMPID_NMP_POST_TOKEN",
	"IMMPID_NMP_NEWSGROUP_LIST",
	"IMMPID_NMP_HEADERS",
	"IMMPID_NMP_NNTP_PROCESSING",
	"IMMPID_NMP_NNTP_APPROVED_HEADER"
};
#endif //__DUMPMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\dumpmsg\main.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "atq.h"
#include <stdio.h>

#include "cthrdapp.h"
#include "parsearg.h"
#include "macros.h"

#include "signatur.h"
#include "blockmgr.h"
#include "cmmprops.h"
#include "cmailmsg.h"
#include "dumpmsg.h"
//
// Description of the application
//
char *szAppDescription = "DUMPMSG - Application to dump the contents of a file system-based message";

DWORD g_fForceCrashOnError = 0;
__declspec(dllexport) DWORD g_fValidateSignatures = 0;
__declspec(dllexport) DWORD g_fFillPropertyPages = 0;

//
// Define the argument list domain
//
ARGUMENT_DESCRIPTOR rgArguments[] =
{
	{
		FALSE,
		"-?",
		"-? - Displays usage help message",
		AT_NONE,
		NULL
	},
	{
		TRUE,
		"-f",
		"-f <filename> - Required, file name of the property stream\n"
		"\t    For NTFS, the property stream is the name of the\n"
		"\t    EML file, plus a \":PROPERTIES\" stream suffix.",
		AT_STRING,
		NULL
	},
	{
		FALSE,
		"-c",
		"-c - Correct the stream signature if it is marked as invalid, yet\n"
		"\t    contains valid data\n",
		AT_NONE,
		NULL
	},
};

#define ARGUMENT_LIST_SIZE	(sizeof(rgArguments) / sizeof(ARGUMENT_DESCRIPTOR))

//
// G L O B A L   V A R I A B L E S
//

// Need these for using macros
BOOL			fToDebugger = FALSE;
BOOL			fUseDebugBreak = FALSE;
char			*szFileName = NULL;
HANDLE			hStream = INVALID_HANDLE_VALUE;
BOOL            fFixCorruption = FALSE;

typedef struct {
    DWORD       dwSignature;
    DWORD       dwVersion;
    GUID        guidInstance;
} NTFS_STREAM_HEADER;

#define STREAM_OFFSET               sizeof(NTFS_STREAM_HEADER)
#define STREAM_SIGNATURE            'rvDN'
#define STREAM_SIGNATURE_INVALID    'rvD!'
#define STREAM_SIGNATURE_NOOFFSET   'MMCv'

class CDumpMsgGetStream : public CBlockManagerGetStream {
	public:
		CDumpMsgGetStream(IMailMsgPropertyStream *pStream = NULL) {
			SetStream(pStream);
		}

		void SetStream(IMailMsgPropertyStream *pStream) {
			m_pStream = pStream;
		}
	
		virtual HRESULT GetStream(IMailMsgPropertyStream **ppStream,
								  BOOL fLockAcquired)
		{
			*ppStream = m_pStream;
			return S_OK;
		}

	private:
		IMailMsgPropertyStream *m_pStream;
};

CDumpMsgGetStream	bmGetStream;
CBlockManager		bmManager(NULL, &bmGetStream);

class CPropertyStream :
	public IMailMsgPropertyStream
{
public:

    CPropertyStream(HANDLE hStream, BOOL fFixInvalidSignature = FALSE);
    ~CPropertyStream();

	/***************************************************************************/
	//
	// Implementation of IUnknown
	//

	HRESULT STDMETHODCALLTYPE QueryInterface(
				REFIID		iid,
				void		**ppvObject
				){return(S_OK);}

	ULONG STDMETHODCALLTYPE AddRef(){return(S_OK);}

	ULONG STDMETHODCALLTYPE Release(){return(S_OK);}

	//
	// IMailMsgPropertyStream
	//
	HRESULT STDMETHODCALLTYPE GetSize(
                IMailMsgProperties  *pMsg,
				DWORD			*pdwSize,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE ReadBlocks(
                IMailMsgProperties  *pMsg,
				DWORD			dwCount,
				DWORD			*pdwOffset,
				DWORD			*pdwLength,
				BYTE			**ppbBlock,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE WriteBlocks(
                IMailMsgProperties  *pMsg,
				DWORD			dwCount,
				DWORD			*pdwOffset,
				DWORD			*pdwLength,
				BYTE			**ppbBlock,
				IMailMsgNotify	*pNotify
				);

    HRESULT STDMETHODCALLTYPE StartWriteBlocks(
                IMailMsgProperties  *pMsg,
                DWORD               cBlocksToWrite,
                DWORD               cTotalBytesToWrite)
    {
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE EndWriteBlocks(
                IMailMsgProperties  *pMsg)
    {
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE CancelWriteBlocks(
                IMailMsgProperties  *pMsg)
    {
        return S_OK;
    }

    void FixSignature() {
        m_fFixInvalidSignature = TRUE;
    }

private:
	HANDLE				m_hStream;
    DWORD               m_cStreamOffset;
    BOOL                m_fFixInvalidSignature;
    BOOL                m_fInvalidSignature;
};



//
// I M P L E M E N T A T I O N
//
char* LookupCommonName(char** pSzArray, DWORD* dwArray, DWORD dwSizeOfArray, DWORD dwPropID)
{
	char* fRetVal = NULL;

	for( DWORD i = 0; i < dwSizeOfArray; ++i) {
		if(dwArray[i] == dwPropID) {
			fRetVal = pSzArray[i];
		}
	}
	return fRetVal;
}

char* FindPropName(DWORD dwPropID)
{
	char* fRetVal = NULL;
	fRetVal = LookupCommonName((char**)&szMPValues,(DWORD*)&dwMPNameId,sizeof(dwMPNameId)/sizeof(DWORD),dwPropID);
	if(fRetVal) {
		return fRetVal;
	}
	fRetVal = LookupCommonName((char**)&szRPValues,(DWORD*)&dwRPNameId,sizeof(dwRPNameId)/sizeof(DWORD),dwPropID);
	if(fRetVal) {
		return fRetVal;
	}
	fRetVal = LookupCommonName((char**)&szMPVValues,(DWORD*)&dwMPVNameId,sizeof(dwMPVNameId)/sizeof(DWORD),dwPropID);
	if(fRetVal) {
		return fRetVal;
	}
	fRetVal = LookupCommonName((char**)&szNMPValues,(DWORD*)&dwNMPNameId,sizeof(dwNMPNameId)/sizeof(DWORD),dwPropID);
	if(fRetVal) {
		return fRetVal;
	}
	// if we got here, it wasn't in any of our lists
	return "Unknown";
}

	
	
	HRESULT CompareProperty(
			LPVOID			pvPropKey,
			LPPROPERTY_ITEM	pItem
			)
{
	if (*(PROP_ID *)pvPropKey == ((LPGLOBAL_PROPERTY_ITEM)pItem)->idProp)
		return(S_OK);
	return(STG_E_UNKNOWN);
}						


HRESULT Prologue(
			int		argc,
			char	*argv[]
			)
{
	HRESULT		hrRes = S_OK;
	CParseArgs	Parser(szAppDescription, ARGUMENT_LIST_SIZE, rgArguments);

	char	szBuffer[2048];
	DWORD	dwSize = sizeof(szBuffer);
	ZeroMemory(szBuffer,sizeof(szBuffer));	
	//
	// Parse the command arguments
	//
	hrRes = Parser.ParseArguments(argc, argv);
	if (!SUCCEEDED(hrRes))
	{
		//
		// Display the explanatory error message
		//
		hrRes = Parser.GetErrorString(&dwSize, szBuffer);
		WRITE(szBuffer);

		//
		// Display automatically-generated usage help
		//
		dwSize = sizeof(szBuffer);
		hrRes = Parser.GenerateUsage(&dwSize, szBuffer);
		WRITE(szBuffer);

		BAIL_WITH_ERROR(E_FAIL);
	}

	//
	// Process the arguments
	//
	if (SUCCEEDED(Parser.Exists(0)))
	{
		hrRes = Parser.GenerateUsage(&dwSize, szBuffer);
		WRITE(szBuffer);
		BAIL_WITH_ERROR(E_FAIL);
	}

	// These functions don't modify the original value if the argument
	// is not specified
	Parser.GetString(1, &szFileName);

    Parser.GetSwitch(2, &fFixCorruption);

	DWORD	dwThreadsCreated;
	hrRes = theApp.CreateThreadPool(
				1,
				NULL,
				NULL,
				1000000,
				&dwThreadsCreated);
	if (!SUCCEEDED(hrRes) || 1 != dwThreadsCreated)
	{
		sprintf(szBuffer,
				"Failed to create worker thread. Error: %08x\n", hrRes);
		WRITE(szBuffer);
		BAIL_WITH_ERROR(E_FAIL);
	}

	if (!CBlockMemoryAccess::m_Pool.ReserveMemory(
				200000,
				sizeof(BLOCK_HEAP_NODE)))
	{
		sprintf(szBuffer,
				"Failed to reserve memory. Error: %u\n", GetLastError());
		WRITE(szBuffer);
		BAIL_WITH_ERROR(E_FAIL);
	}

	//
	// Synchronization measures will prevent the threadprocs from executing
	// until we exit this function. If we return anything other than success,
	// the thread pool will be destroyed, and the program will terminate.
	//
	hStream = CreateFile(
				szFileName,
				GENERIC_READ | GENERIC_WRITE,	// Read / Write
				FILE_SHARE_READ,				// Read sharing
				NULL,							// Default security
				OPEN_EXISTING,					// Open existing file
				FILE_FLAG_SEQUENTIAL_SCAN,		// Seq scan
				NULL);							// No template
	if (hStream == INVALID_HANDLE_VALUE)
	{
		sprintf(szBuffer,
				"Failed to open file. Error: %u\n", GetLastError());
		WRITE(szBuffer);
		BAIL_WITH_ERROR(E_FAIL);
	}

	return(S_OK);
}

HRESULT DumpMasterHeader(
			MASTER_HEADER	*pmh,
            DWORD           cStream
			)
{
	char	szBuffer[4096];

	sprintf(szBuffer,
			"Master header:\n"
			"\tSignature: %08x (valid sig: %08x)\n"
			"\tVersion High: %u\n"
			"\tVersion Low: %u\n"
			"\tHeader size: %u (valid size: %u)\n\n"
            "\tStream file size: %x\n\n",
			pmh->dwSignature,
			CMAILMSG_SIGNATURE_VALID,
			pmh->wVersionHigh,
			pmh->wVersionLow,
			pmh->dwHeaderSize,
			sizeof(MASTER_HEADER),
            cStream);
	WRITE(szBuffer);

    PROPERTY_TABLE_INSTANCE *rgpti[] = {
        &(pmh->ptiGlobalProperties),
        &(pmh->ptiRecipients),
        &(pmh->ptiPropertyMgmt)
    };

    for (DWORD i = 0; i < 3; i++) {
        char szName[80];
        switch (i) {
            case 0: strcpy(szName, "ptiGlobalProperties"); break;
            case 1: strcpy(szName, "ptiRecipients"); break;
            case 2: strcpy(szName, "ptiPropertyMgmt"); break;
            default: strcpy(szName, "(unknown)"); break;
        }
        sprintf(szBuffer,
            "\tProperty Table Instance: %s\n"
            "\t\tSignature: 0x%08x\n"
            "\t\tfaFirstFragment: 0x%08x\n"
            "\t\tdwFragmentSize: 0x%08x\n"
            "\t\tdwItemBits: 0x%08x\n"
            "\t\tdwItemSize: 0x%08x\n"
            "\t\tdwProperties: 0x%08x\n"
            "\t\tfaExtendedInfo: 0x%08x\n",
			szName,
            rgpti[i]->dwSignature,
            rgpti[i]->faFirstFragment,
            rgpti[i]->dwFragmentSize,
            rgpti[i]->dwItemBits,
            rgpti[i]->dwItemSize,
            rgpti[i]->dwProperties,
            rgpti[i]->faExtendedInfo);
	    WRITE(szBuffer);
    }


	if ((pmh->dwSignature != CMAILMSG_SIGNATURE_VALID) ||
		(pmh->dwHeaderSize != sizeof(MASTER_HEADER)))
		return(E_FAIL);
	return(S_OK);
}

void DoDump(char *pBuffer, DWORD dwLength)
{
	DWORD i, j, l;
	char *p = pBuffer;
	char ch;

	puts("\t00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f | 0123456789abcdef");
	puts("\t------------------------------------------------+-----------------");

	j = 0;
	while (dwLength)
	{
		l = dwLength;
		p = pBuffer;
		printf("%05x0  ", j++);
		for (i = 0; i < 16; i++)
		{
			if (l)
			{
				printf("%02x ", ((DWORD) *p++) & 0xff);
				l--;
			}
			else
				printf("   ");
		}

		l = dwLength;
		p = pBuffer;
		printf("| ");
		for (i = 0; i < 16; i++)
		{
			ch = *p++;
			if (ch < ' ')
				ch = '.';
			printf("%c", ch);
			if (!--l)
				break;
		}

		puts("");

		dwLength = l;
		pBuffer = p;
	}

	puts("\n");
}

HRESULT DumpProps(
			LPPROPERTY_TABLE_INSTANCE	pInst,
			char						*szPrefix
			)
{
	HRESULT				hrRes = S_OK;
	DWORD				dwCount, dwSize, i;
	char				szLine[8192];
	char				szBuffer[256];
	GLOBAL_PROPERTY_ITEM gpi;	
	CPropertyTable	ptTable(
				PTT_PROPERTY_TABLE,
				pInst->dwSignature,
				&bmManager,
				pInst,
				CompareProperty,
				NULL,
				NULL);

	hrRes = ptTable.GetCount(&dwCount);
	if (FAILED(hrRes))
		return(hrRes);

	for (i = 0; i < dwCount; i++)
	{
		char* szCommonName = NULL;
		hrRes = ptTable.GetPropertyItemAndValueUsingIndex(
					i,
					(LPPROPERTY_ITEM)&gpi,
					sizeof(szLine),
					&dwSize,
					(LPBYTE)szLine);
		if (FAILED(hrRes))
			return(hrRes);

		szCommonName = FindPropName(gpi.idProp);
		_ASSERT(szCommonName);
		sprintf(szBuffer, "%sProp ID: %u (%s) at offset 0x%x, length (%u, 0x%x)",
					szPrefix,
					gpi.idProp,
					szCommonName,
					gpi.piItem.faOffset,
					gpi.piItem.dwSize,
					gpi.piItem.dwSize);


		WRITE(szBuffer);
		DoDump(szLine, gpi.piItem.dwSize);
	}
	return(S_OK);
}

DWORD dwNameId[MAX_COLLISION_HASH_KEYS] =
{
	IMMPID_RP_ADDRESS_SMTP,
	IMMPID_RP_ADDRESS_X400,
	IMMPID_RP_ADDRESS_X500,
	IMMPID_RP_LEGACY_EX_DN,
	IMMPID_RP_ADDRESS_OTHER
};

char *szNames[MAX_COLLISION_HASH_KEYS] =
{
	"SMTP",
	"X400",
	"X500",
	"Legacy DN",
    "Other"
};

HRESULT DumpRecipientNames(
			LPRECIPIENTS_PROPERTY_ITEM	prspi
			)
{
	HRESULT	hrRes = S_OK;
	char	szAddress[8192];
	char	szBuffer[1024];
	DWORD	dwSize;
    DWORD   dwTotalSize = sizeof(RECIPIENT_PROPERTY_ITEM);

	sprintf(szBuffer, "\tFlags: %08X", prspi->dwFlags);
	WRITE(szBuffer);

    sprintf(szBuffer,
        "\tProperty Table Instance (%i)\n"
        "\t\tSignature: 0x%08x\n"
        "\t\tfaFirstFragment: 0x%08x\n"
        "\t\tdwFragmentSize: 0x%08x\n"
        "\t\tdwItemBits: 0x%08x\n"
        "\t\tdwItemSize: 0x%08x\n"
        "\t\tdwProperties: 0x%08x\n"
        "\t\tfaExtendedInfo: 0x%08x\n",
        sizeof(RECIPIENTS_PROPERTY_ITEM),
        prspi->ptiInstanceInfo.dwSignature,
        prspi->ptiInstanceInfo.faFirstFragment,
        prspi->ptiInstanceInfo.dwFragmentSize,
        prspi->ptiInstanceInfo.dwItemBits,
        prspi->ptiInstanceInfo.dwItemSize,
        prspi->ptiInstanceInfo.dwProperties,
        prspi->ptiInstanceInfo.faExtendedInfo);
    WRITE(szBuffer);

	for (DWORD i = 0; i < MAX_COLLISION_HASH_KEYS; i++)
	{
		if (prspi->faNameOffset[i] != INVALID_FLAT_ADDRESS)
		{
			for (DWORD j = 0; j < MAX_COLLISION_HASH_KEYS; j++)
				if (prspi->idName[i] == dwNameId[j])
				{
					hrRes = bmManager.ReadMemory(
								(LPBYTE)szAddress,
								prspi->faNameOffset[i],
								prspi->dwNameLength[i],
								&dwSize,
								NULL);
                    dwTotalSize += prspi->dwNameLength[i];
					if (FAILED(hrRes))
						return(hrRes);

					sprintf(szBuffer, "\t(0x%x-0x%x) %s: %s",
                            prspi->faNameOffset[i],
                            prspi->faNameOffset[i] + prspi->dwNameLength[i],
							szNames[j],
							szAddress);
					WRITE(szBuffer);
					break;
				}
			if (j == MAX_COLLISION_HASH_KEYS)
				return(E_FAIL);
		}
	}

    sprintf(szBuffer, "\tRecipient Size: %i\n", dwTotalSize);
	WRITE(szBuffer);

	WRITE("\n");
	return(S_OK);
}

DWORD WINAPI ThreadProc(
			LPVOID	pvContext
			)
{
	char	szBuffer[2048];
	HRESULT	hrRes = S_OK;
	DWORD	dwSize, cStream;

	MASTER_HEADER	Header;

	CPropertyStream	Stream(hStream);
	ZeroMemory((void*)&Header,sizeof(Header));

	// Set the stream
	bmGetStream.SetStream(&Stream);
    Stream.GetSize(NULL, &dwSize, NULL);
    bmManager.SetStreamSize(dwSize);
    cStream = dwSize;

    __try {
        // Read the master header
        hrRes = bmManager.ReadMemory(
                    (LPBYTE)&Header,
                    0,
                    sizeof(MASTER_HEADER),
                    &dwSize,
                    NULL);
        if (FAILED(hrRes))
        {
            sprintf(szBuffer,
                    "Failed to read master header. Error: %08x\n", hrRes);
            WRITE(szBuffer);
            BAIL_WITH_ERROR(E_FAIL);
        }

        hrRes = DumpMasterHeader(&Header, cStream);
        if (FAILED(hrRes))
        {
            sprintf(szBuffer,
                    "Invalid master header. Error: %08x\n", hrRes);
            WRITE(szBuffer);
            BAIL_WITH_ERROR(E_FAIL);
        }

        // Global properties
        {
            sprintf(szBuffer,
                    "Message properties (%u):\n", Header.ptiGlobalProperties.dwProperties);
            WRITE(szBuffer);
            hrRes = DumpProps(
                        &(Header.ptiGlobalProperties),
                        "\t");
            if (FAILED(hrRes))
            {
                sprintf(szBuffer,
                        "Failed to dump global properties. Error: %08x\n", hrRes);
                WRITE(szBuffer);
                BAIL_WITH_ERROR(E_FAIL);
            }
        }

        // Recipient list and their properties
        {
            DWORD	dwCount;

            RECIPIENTS_PROPERTY_ITEM	rspi;

            CPropertyTableItem	ptiItem(
                        &bmManager,
                        &(Header.ptiRecipients));

            sprintf(szBuffer, "Dumping recipients (%u) and their properties:\n",
                        Header.ptiRecipients.dwProperties);
            WRITE(szBuffer);

            dwCount = 0;
            hrRes = ptiItem.GetItemAtIndex(dwCount, (LPPROPERTY_ITEM)&rspi, NULL);
            while (SUCCEEDED(hrRes))
            {
                sprintf(szBuffer, "Recipient %u:\n", dwCount++);
                WRITE(szBuffer);

                // Dump all the names first ...
                hrRes = DumpRecipientNames(&rspi);
                if (FAILED(hrRes))
                {
                    sprintf(szBuffer,
                            "Failed to dump recipient names. Error: %08x\n", hrRes);
                    WRITE(szBuffer);
                    // BAIL_WITH_ERROR(E_FAIL);
                }

                sprintf(szBuffer, "Recipient properties (%u):\n",
                            rspi.ptiInstanceInfo.dwProperties);
                WRITE(szBuffer);
                hrRes = DumpProps(
                            &(rspi.ptiInstanceInfo),
                            "\t");
                if (FAILED(hrRes))
                {
                    sprintf(szBuffer,
                            "Failed to dump recipient properties. Error: %08x\n", hrRes);
                    WRITE(szBuffer);
                    // BAIL_WITH_ERROR(E_FAIL);
                }

                hrRes = ptiItem.GetNextItem((LPPROPERTY_ITEM)&rspi);

            }
            if (FAILED(hrRes) && (hrRes != HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)))
            {
                sprintf(szBuffer,
                        "Failed to load recipient record. Error: %08x\n", hrRes);
                WRITE(szBuffer);
                BAIL_WITH_ERROR(E_FAIL);
            }
        }

        if (fFixCorruption) Stream.FixSignature();
    } __except(1) {
        printf("\nERROR!!!: block stream is invalid, aborting dump\n");
    }

	return(NO_ERROR);
}

HRESULT NotificationProc(
			LPVOID	pvCallbackContext
			)
{
	// Report status
	Epilogue(NULL, S_OK);
	return(S_OK);
}

HRESULT Epilogue(
			LPVOID	pvCallbackContext,
			HRESULT	hrRes
			)
{
	return(S_OK);
}

HRESULT CleanupApplication()
{
	if (hStream != INVALID_HANDLE_VALUE)
		CloseHandle(hStream);

	bmManager.Release();

	DWORD	dwLeft = CBlockMemoryAccess::m_Pool.GetAllocCount();
	if (dwLeft)
	{
		char szBuffer[128];
		sprintf(szBuffer,
				"Error, leaking %u cpool objects", dwLeft);
		WRITE(szBuffer);
	}
	CBlockMemoryAccess::m_Pool.ReleaseMemory();
	return(S_OK);
}


CPropertyStream::CPropertyStream(
			HANDLE	hStream,
            BOOL    fFixInvalidSignature
			)
{
	m_hStream = hStream;
    m_cStreamOffset = 0;
    m_fFixInvalidSignature = FALSE;
    m_fInvalidSignature = FALSE;

	if (SetFilePointer(m_hStream, 0, NULL, FILE_BEGIN) == 0xffffffff)
	{
        printf("ERROR: couldn't set file pointer on stream\n");
		return;
	}

    NTFS_STREAM_HEADER header;
    header.dwSignature = 0;
    DWORD dwSizeRead;
	if (!ReadFile(m_hStream, &header, sizeof(NTFS_STREAM_HEADER), &dwSizeRead, NULL)) {
        printf("ERROR: couldn't read NTFS stream header\n");
        return;
	}

    if (header.dwSignature == STREAM_SIGNATURE ||
        header.dwSignature == STREAM_SIGNATURE_INVALID)
    {
        if (header.dwSignature == STREAM_SIGNATURE_INVALID) {
            printf("WARNING: Invalid NTFS stream signature found, analyzing anyway\n");
            m_fInvalidSignature = TRUE;
        }
        m_cStreamOffset = STREAM_OFFSET;
    } else {
        m_fInvalidSignature = FALSE;
    }
}

CPropertyStream::~CPropertyStream(
			)
{
    if (m_fFixInvalidSignature && m_fInvalidSignature) {
        printf("Updating invalid signature\n");
        if (SetFilePointer(m_hStream, 0, NULL, FILE_BEGIN) == 0xffffffff)
        {
            printf("ERROR: couldn't set file pointer on stream\n");
            return;
        }

        NTFS_STREAM_HEADER header;
        header.dwSignature = STREAM_SIGNATURE;
        DWORD dwSizeWritten;
        if (!WriteFile(m_hStream, &header, sizeof(header.dwSignature), &dwSizeWritten, NULL) ||
            dwSizeWritten != sizeof(header.dwSignature))
        {
            printf("ERROR: couldn't write NTFS stream header\n");
            return;
        }
    }
}


//
// IMailMsgPropertyStream
//
HRESULT STDMETHODCALLTYPE CPropertyStream::GetSize(
            IMailMsgProperties  *pMsg,
			DWORD			*pdwSize,
			IMailMsgNotify	*pNotify
			)
{
	DWORD	dwHigh, dwLow;

	if (m_hStream == INVALID_HANDLE_VALUE)
		return(E_FAIL);

	dwLow = GetFileSize(m_hStream, &dwHigh);
	if (dwHigh)
		return(HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW));

	*pdwSize = dwLow - m_cStreamOffset;
	return(S_OK);
}

HRESULT STDMETHODCALLTYPE CPropertyStream::ReadBlocks(
            IMailMsgProperties  *pMsg,
			DWORD			dwCount,
			DWORD			*pdwOffset,
			DWORD			*pdwLength,
			BYTE			**ppbBlock,
			IMailMsgNotify	*pNotify
			)
{
	DWORD	dwSizeRead;
	HRESULT	hrRes = S_OK;

	if (m_hStream == INVALID_HANDLE_VALUE)
		return(E_FAIL);

	for (DWORD i = 0; i < dwCount; i++, pdwOffset++, pdwLength++, ppbBlock++)
	{
		if (SetFilePointer(
					m_hStream,
					*pdwOffset + m_cStreamOffset,
					NULL,
					FILE_BEGIN) == 0xffffffff)
		{
			hrRes = HRESULT_FROM_WIN32(GetLastError());
			break;
		}

		if (!ReadFile(
					m_hStream,
					*ppbBlock,
					*pdwLength,
					&dwSizeRead,
					NULL) ||
			(dwSizeRead != *pdwLength))
		{
			hrRes = HRESULT_FROM_WIN32(GetLastError());
			break;
		}
	}
	return(hrRes);
}

HRESULT STDMETHODCALLTYPE CPropertyStream::WriteBlocks(
            IMailMsgProperties  *pMsg,
			DWORD			dwCount,
			DWORD			*pdwOffset,
			DWORD			*pdwLength,
			BYTE			**ppbBlock,
			IMailMsgNotify	*pNotify
			)
{
	DWORD	dwSizeWritten;
	HRESULT	hrRes = S_OK;

	if (m_hStream == INVALID_HANDLE_VALUE)
		return(E_FAIL);

	for (DWORD i = 0; i < dwCount; i++, pdwOffset++, pdwLength++, ppbBlock++)
	{
		if (SetFilePointer(
					m_hStream,
					*pdwOffset + m_cStreamOffset,
					NULL,
					FILE_BEGIN) == 0xffffffff)
		{
			hrRes = HRESULT_FROM_WIN32(GetLastError());
			break;
		}

		if (!WriteFile(
					m_hStream,
					*ppbBlock,
					*pdwLength,
					&dwSizeWritten,
					NULL) ||
			(dwSizeWritten != *pdwLength))
		{
			hrRes = HRESULT_FROM_WIN32(GetLastError());
			break;
		}
	}
	return(hrRes);
}


DECLARE_DEBUG_PRINTS_OBJECT()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\accessor.inl ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	accessor.inl

Abstract:

	This module contains the special property accessors

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	04/19/98	created

--*/

// ======================================================================
// Define macros for declaring accessors
//
#define GET_ACCESSOR(PropertyName)		\
	static HRESULT Get##PropertyName(	\
			PROP_ID	idProp,				\
			LPVOID	pContext,			\
			LPVOID	pParam,				\
			DWORD	cbLength,			\
			LPDWORD	pcbLength,			\
			LPBYTE	pbBuffer			\
			)

#define PUT_ACCESSOR(PropertyName)		\
	static HRESULT Put##PropertyName(	\
			PROP_ID	idProp,				\
			LPVOID	pContext,			\
			LPVOID	pParam,				\
			DWORD	cbLength,			\
			LPBYTE	pbBuffer			\
			)

#define DECLARE_ACCESSORS(PropertyName)	\
	GET_ACCESSOR(PropertyName);			\
	PUT_ACCESSOR(PropertyName);			\

#define ACCESSOR_LIST(PropertyName)		\
	Get##PropertyName, Put##PropertyName


// ======================================================================
// Forward declarations for the accessor functions
//
DECLARE_ACCESSORS(StoreDriverHandle);
DECLARE_ACCESSORS(MessageCreationFlags);
DECLARE_ACCESSORS(MessageOpenHandles);
DECLARE_ACCESSORS(TotalOpenHandles);
DECLARE_ACCESSORS(TotalOpenStreamHandles);
DECLARE_ACCESSORS(TotalOpenContentHandles);

DECLARE_ACCESSORS(SmtpAddress);
DECLARE_ACCESSORS(X400Address);
DECLARE_ACCESSORS(X500Address);
DECLARE_ACCESSORS(LegacyExDn);
DECLARE_ACCESSORS(OtherAddress);
DECLARE_ACCESSORS(SmtpAddressBM);
DECLARE_ACCESSORS(X400AddressBM);
DECLARE_ACCESSORS(X500AddressBM);
DECLARE_ACCESSORS(LegacyExDnBM);
DECLARE_ACCESSORS(OtherAddressBM);
DECLARE_ACCESSORS(DoNotDeliver);
DECLARE_ACCESSORS(NoNameCollisions);
DECLARE_ACCESSORS(RecipientFlags);

DECLARE_ACCESSORS(AddressValue);
DECLARE_ACCESSORS(AddressValueBM);
DECLARE_ACCESSORS(RecipientFlag);


// ======================================================================
// Special property table for CMailMsgProperties
//
SPECIAL_PROPERTY_ITEM	g_SpecialMessagePropertyTableItems[] =
{
	{	IMMPID_MPV_STORE_DRIVER_HANDLE,		PT_NONE,	PA_READ_WRITE,	1, ACCESSOR_LIST(StoreDriverHandle) },
	{	IMMPID_MPV_MESSAGE_CREATION_FLAGS,	PT_DWORD,	PA_READ,		1, ACCESSOR_LIST(MessageCreationFlags) },
	{	IMMPID_MPV_MESSAGE_OPEN_HANDLES,	PT_DWORD,	PA_READ,		1, ACCESSOR_LIST(MessageOpenHandles) },
	{	IMMPID_MPV_TOTAL_OPEN_HANDLES,	PT_DWORD,	PA_READ,		1, ACCESSOR_LIST(TotalOpenHandles) },
	{	IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES,	PT_DWORD,	PA_READ,		1, ACCESSOR_LIST(TotalOpenStreamHandles) },
	{	IMMPID_MPV_TOTAL_OPEN_CONTENT_HANDLES,	PT_DWORD,	PA_READ,		1, ACCESSOR_LIST(TotalOpenContentHandles) },
};

// Special property table info
PTABLE g_SpecialMessagePropertyTable =
{
	g_SpecialMessagePropertyTableItems,
	(sizeof(g_SpecialMessagePropertyTableItems) / sizeof(SPECIAL_PROPERTY_ITEM)),
	TRUE
};


// ======================================================================
// Special property table for CMailMsgRecipients
//
SPECIAL_PROPERTY_ITEM	g_SpecialRecipientsPropertyTableItems[] =
{
	{	IMMPID_RP_ADDRESS_SMTP,			PT_STRING,	PA_READ,		1, ACCESSOR_LIST(SmtpAddressBM) },
	{	IMMPID_RP_ADDRESS_X400,			PT_STRING,	PA_READ,		1, ACCESSOR_LIST(X400AddressBM) },
	{	IMMPID_RP_ADDRESS_X500,			PT_STRING,	PA_READ,		1, ACCESSOR_LIST(X500AddressBM) },
	{	IMMPID_RP_LEGACY_EX_DN,			PT_STRING,	PA_READ,		1, ACCESSOR_LIST(LegacyExDnBM) },
	{	IMMPID_RP_RECIPIENT_FLAGS,		PT_DWORD,	PA_READ_WRITE,	1, ACCESSOR_LIST(RecipientFlags) },
	{	IMMPID_RP_ADDRESS_OTHER,		PT_STRING,	PA_READ,		1, ACCESSOR_LIST(OtherAddressBM) },
};

// Special property table info
PTABLE g_SpecialRecipientsPropertyTable =
{
	g_SpecialRecipientsPropertyTableItems,
	(sizeof(g_SpecialRecipientsPropertyTableItems) / sizeof(SPECIAL_PROPERTY_ITEM)),
	TRUE
};


// ======================================================================
// Special property table for CMailMsgRecipientsAdd
//
SPECIAL_PROPERTY_ITEM	g_SpecialRecipientsAddPropertyTableItems[] =
{
	{	IMMPID_RP_ADDRESS_SMTP,			PT_STRING,	PA_READ,		1, ACCESSOR_LIST(SmtpAddress) },
	{	IMMPID_RP_ADDRESS_X400,			PT_STRING,	PA_READ,		1, ACCESSOR_LIST(X400Address) },
	{	IMMPID_RP_ADDRESS_X500,			PT_STRING,	PA_READ,		1, ACCESSOR_LIST(X500Address) },
	{	IMMPID_RP_LEGACY_EX_DN,			PT_STRING,	PA_READ,		1, ACCESSOR_LIST(LegacyExDn) },
	{	IMMPID_RP_RECIPIENT_FLAGS,		PT_DWORD,	PA_READ_WRITE,	1, ACCESSOR_LIST(RecipientFlags) },
	{	IMMPID_RP_ADDRESS_OTHER,		PT_STRING,	PA_READ,		1, ACCESSOR_LIST(OtherAddress) },
	{	IMMPID_RPV_DONT_DELIVER,		PT_BOOL,	PA_READ_WRITE,	1, ACCESSOR_LIST(DoNotDeliver) },
	{	IMMPID_RPV_NO_NAME_COLLISIONS,	PT_BOOL,	PA_READ_WRITE,	1, ACCESSOR_LIST(NoNameCollisions) },
};

// Special property table info
PTABLE g_SpecialRecipientsAddPropertyTable =
{
	g_SpecialRecipientsAddPropertyTableItems,
	(sizeof(g_SpecialRecipientsAddPropertyTableItems) / sizeof(SPECIAL_PROPERTY_ITEM)),
	TRUE
};



// ======================================================================
// Implementation of property accessors
//

// ======================================================================
// Get methods
//
// The get methods are implementation-specific. It first checks if the
// desired property is already cached. If so, the cached value is returned
// Otherwise, it will fetch the value from the media. This makes sure
// that the properties will not be loaded if not necessary.

GET_ACCESSOR(StoreDriverHandle)
{
	HRESULT		hrRes = S_OK;
	CMailMsg	*pMsg = (CMailMsg *)pContext;

	if (!pMsg || !pbBuffer)
		return(E_POINTER);
	if (pMsg->m_pbStoreDriverHandle)
	{
		if (pcbLength)
			*pcbLength = pMsg->m_dwStoreDriverHandle;
		if (pMsg->m_dwStoreDriverHandle > cbLength)
			hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		else
		{
		    MoveMemory(pbBuffer,
		               pMsg->m_pbStoreDriverHandle,
			       pMsg->m_dwStoreDriverHandle);
		}
	}
	else
	{
		if (pcbLength)
			*pcbLength = 0;
		hrRes = STG_E_UNKNOWN;
	}
	return(hrRes);
}

GET_ACCESSOR(MessageCreationFlags)
{
	HRESULT		hrRes = S_OK;
	CMailMsg	*pMsg = (CMailMsg *)pContext;

	if (!pMsg || !pbBuffer)
		return(E_POINTER);

	if (cbLength < sizeof(DWORD))
		hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	else
	{
		if (pcbLength)
			*pcbLength = sizeof(DWORD);
		*(DWORD *)pbBuffer = pMsg->m_dwCreationFlags;
	}
	return(hrRes);
}

GET_ACCESSOR(MessageOpenHandles)
{
	HRESULT		hrRes = S_OK;
	CMailMsg	*pMsg = (CMailMsg *)pContext;
	DWORD		cHandles = 0;

	if (!pMsg || !pbBuffer)
		return(E_POINTER);

	if (cbLength < sizeof(DWORD))
		hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	else
	{
		if (pcbLength)
			*pcbLength = sizeof(DWORD);
        
        //Check if there is a content file
        if (pMsg->fIsContentOpen())
            cHandles++;
        
        //Check if there is a property stream
        if (pMsg->fIsStreamOpen())
            cHandles++;

		*(DWORD *)pbBuffer = cHandles;
	}
	return(hrRes);
}

GET_ACCESSOR(TotalOpenHandles)
{
	HRESULT		hrRes = S_OK;

	if (!pbBuffer)
		return(E_POINTER);

	if (cbLength < sizeof(DWORD))
		hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	else
	{
		if (pcbLength)
			*pcbLength = sizeof(DWORD);
        
        //Get the total number of content and stream handles open
        *(DWORD *)pbBuffer = (DWORD) CMailMsg::cTotalOpenStreamHandles() + 
                             (DWORD) CMailMsg::cTotalOpenContentHandles();
	}
	return(hrRes);
}

GET_ACCESSOR(TotalOpenStreamHandles)
{
	HRESULT		hrRes = S_OK;

	if (!pbBuffer)
		return(E_POINTER);

	if (cbLength < sizeof(DWORD))
		hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	else
	{
		if (pcbLength)
			*pcbLength = sizeof(DWORD);
        
        //Get the total number of stream handles open
        *(DWORD *)pbBuffer = (DWORD) CMailMsg::cTotalOpenStreamHandles();
	}
	return(hrRes);
}

GET_ACCESSOR(TotalOpenContentHandles)
{
	HRESULT		hrRes = S_OK;

	if (!pbBuffer)
		return(E_POINTER);

	if (cbLength < sizeof(DWORD))
		hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	else
	{
		if (pcbLength)
			*pcbLength = sizeof(DWORD);
        
        //Get the total number of content and stream handles open
        *(DWORD *)pbBuffer = (DWORD) CMailMsg::cTotalOpenContentHandles();
	}
	return(hrRes);
}

GET_ACCESSOR(SmtpAddress)
{
	return(GetAddressValue(
				AT_SMTP,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(X400Address)
{
	return(GetAddressValue(
				AT_X400,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(X500Address)
{
	return(GetAddressValue(
				AT_X500,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(LegacyExDn)
{
	return(GetAddressValue(
				AT_LEGACY_EX_DN,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(OtherAddress)
{
	return(GetAddressValue(
				AT_OTHER,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(SmtpAddressBM)
{
	return(GetAddressValueBM(
				AT_SMTP,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(X400AddressBM)
{
	return(GetAddressValueBM(
				AT_X400,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(X500AddressBM)
{
	return(GetAddressValueBM(
				AT_X500,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(LegacyExDnBM)
{
	return(GetAddressValueBM(
				AT_LEGACY_EX_DN,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(OtherAddressBM)
{
	return(GetAddressValueBM(
				AT_OTHER,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(DoNotDeliver)
{
	return(GetRecipientFlag(
				FLAG_RECIPIENT_DO_NOT_DELIVER,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(NoNameCollisions)
{
	return(GetRecipientFlag(
				FLAG_RECIPIENT_NO_NAME_COLLISIONS,
				pContext,
				pParam,
				cbLength,
				pcbLength,
				pbBuffer));
}

GET_ACCESSOR(RecipientFlag)
{
	// The context is a LPRECIPIENTS_PROPERTY_ITEM
	LPRECIPIENTS_PROPERTY_ITEM	pItem = (LPRECIPIENTS_PROPERTY_ITEM)pContext;
	if (!pItem || !pbBuffer)
		return(E_POINTER);

	*pcbLength = sizeof(BOOL);
	if (cbLength < sizeof(BOOL))
		return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
	*(BOOL *)pbBuffer = ((pItem->dwFlags & idProp) != 0)?TRUE:FALSE;
	return(S_OK);
}

GET_ACCESSOR(RecipientFlags)
{
	// The context is a LPRECIPIENTS_PROPERTY_ITEM
	LPRECIPIENTS_PROPERTY_ITEM	pItem = (LPRECIPIENTS_PROPERTY_ITEM)pContext;
	if (!pItem || !pbBuffer)
		return(E_POINTER);

	*pcbLength = sizeof(DWORD);
	if (cbLength < sizeof(DWORD))
		return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
	*(DWORD *)pbBuffer = pItem->dwFlags;
	return(S_OK);
}

GET_ACCESSOR(AddressValue)
{
	// The context is a LPRECIPIENTS_PROPERTY_ITEM
	LPRECIPIENTS_PROPERTY_ITEM	pItem = (LPRECIPIENTS_PROPERTY_ITEM)pContext;
	if (!pItem)
		return(E_POINTER);

	// See if the name type is valid
	if ((DWORD)idProp >= MAX_COLLISION_HASH_KEYS)
		return(E_INVALIDARG);

	// See if the name is set
	if (!pItem->faNameOffset[idProp] ||
		!pItem->dwNameLength[idProp])
		return(STG_E_UNKNOWN);

	// See if we have sufficient buffer
	*pcbLength = pItem->dwNameLength[idProp];
	if (cbLength < *pcbLength)
		return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

	// OK, copy the property value over
	MoveMemory(pbBuffer,
		   (LPVOID)pItem->faNameOffset[idProp],
		   *pcbLength);

	return(S_OK);
}

GET_ACCESSOR(AddressValueBM)
{
	// The context is a LPRECIPIENTS_PROPERTY_ITEM
	// The parameter is a pointer to CBlockManager
	LPRECIPIENTS_PROPERTY_ITEM	pItem = (LPRECIPIENTS_PROPERTY_ITEM)pContext;
	CBlockManager				*pBlockManager = (CBlockManager *)pParam;

	if (!pItem || !pBlockManager)
		return(E_POINTER);

	// See if the name type is valid
	if ((DWORD)idProp >= MAX_COLLISION_HASH_KEYS)
		return(E_INVALIDARG);

	// See if the name is set
	if (pItem->faNameOffset[idProp] == INVALID_FLAT_ADDRESS)
		return(STG_E_UNKNOWN);

	// See if we have sufficient buffer
	*pcbLength = pItem->dwNameLength[idProp];
	if (cbLength < *pcbLength)
		return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

	// OK, load the property value
	return(pBlockManager->ReadMemory(
				pbBuffer,
				pItem->faNameOffset[idProp],
				pItem->dwNameLength[idProp],
				pcbLength,
				NULL));
}

// ======================================================================
// Set methods
//
// We provide and use generic set methods.

PUT_ACCESSOR(StoreDriverHandle)
{
	HRESULT			hrRes = S_OK;
	LPBYTE			pbWriteBuf;
	CMailMsg		*pMsg = (CMailMsg *)pContext;
	CMemoryAccess	cmaAccess;
	BOOL			fExistedBefore = (pMsg->m_pbStoreDriverHandle != NULL);

	if (!pMsg || !pbBuffer)
		return(E_POINTER);

	pbWriteBuf = pMsg->m_pbStoreDriverHandle;
	if (pMsg->m_dwStoreDriverHandle < cbLength)
	{
		if (pbWriteBuf)
		{
			hrRes = cmaAccess.FreeBlock((LPVOID)pbWriteBuf);
			_ASSERT(SUCCEEDED(hrRes));
		}
		hrRes = cmaAccess.AllocBlock(
					(LPVOID *)&pbWriteBuf,
					cbLength);

		pMsg->m_pbStoreDriverHandle = pbWriteBuf;
	}
	if (SUCCEEDED(hrRes) && pMsg->m_pbStoreDriverHandle) {
	    MoveMemory(pMsg->m_pbStoreDriverHandle,
		       pbBuffer,
		       cbLength);
	    pMsg->m_dwStoreDriverHandle = cbLength;
        }
	else
	{
		pMsg->m_dwStoreDriverHandle = 0;
		hrRes = HRESULT_FROM_WIN32(GetLastError());
		if (SUCCEEDED(hrRes))
			hrRes = E_FAIL;
	}

	if (FAILED(hrRes) && pbWriteBuf)
		cmaAccess.FreeBlock((LPVOID)pbWriteBuf);
	
	if (hrRes == S_OK && !fExistedBefore) hrRes = S_FALSE;

	return(hrRes);
}

PUT_ACCESSOR(MessageCreationFlags)
{
	// Should never be called since this property is strictly
	// read-only!!
	_ASSERT(FALSE);
	return(E_NOTIMPL);
}

PUT_ACCESSOR(MessageOpenHandles)
{
	// Should never be called since this property is strictly
	// read-only!!
	_ASSERT(FALSE);
	return(E_NOTIMPL);
}

PUT_ACCESSOR(TotalOpenHandles)
{
	// Should never be called since this property is strictly
	// read-only!!
	_ASSERT(FALSE);
	return(E_NOTIMPL);
}

PUT_ACCESSOR(TotalOpenStreamHandles)
{
	// Should never be called since this property is strictly
	// read-only!!
	_ASSERT(FALSE);
	return(E_NOTIMPL);
}

PUT_ACCESSOR(TotalOpenContentHandles)
{
	// Should never be called since this property is strictly
	// read-only!!
	_ASSERT(FALSE);
	return(E_NOTIMPL);
}

PUT_ACCESSOR(SmtpAddress)
{
	return(PutAddressValue(
				AT_SMTP,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(X400Address)
{
	return(PutAddressValue(
				AT_X400,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(X500Address)
{
	return(PutAddressValue(
				AT_X500,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(LegacyExDn)
{
	return(PutAddressValue(
				AT_LEGACY_EX_DN,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(OtherAddress)
{
	return(PutAddressValue(
				AT_OTHER,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(SmtpAddressBM)
{
	return(PutAddressValueBM(
				AT_SMTP,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(X400AddressBM)
{
	return(PutAddressValueBM(
				AT_X400,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(X500AddressBM)
{
	return(PutAddressValueBM(
				AT_X500,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(LegacyExDnBM)
{
	return(PutAddressValueBM(
				AT_LEGACY_EX_DN,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(OtherAddressBM)
{
	return(PutAddressValueBM(
				AT_OTHER,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(DoNotDeliver)
{
	return(PutRecipientFlag(
				FLAG_RECIPIENT_DO_NOT_DELIVER,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(NoNameCollisions)
{
	return(PutRecipientFlag(
				FLAG_RECIPIENT_NO_NAME_COLLISIONS,
				pContext,
				pParam,
				cbLength,
				pbBuffer));
}

PUT_ACCESSOR(RecipientFlag)
{
	// The context is a LPRECIPIENTS_PROPERTY_ITEM
    //pbBuffer is a PBOOL is TRUE to set the bits, FALSE to unset
    //idProp contains the Bits to set
	LPRECIPIENTS_PROPERTY_ITEM	pItem = (LPRECIPIENTS_PROPERTY_ITEM)pContext;
	if (!pItem || !pbBuffer)
		return(E_POINTER);

    //make sure we don't stray from allowed bits
    _ASSERT(!(idProp & ~RP_RECIP_FLAGS_RESERVED));

	if (*(BOOL *)pbBuffer)
		pItem->dwFlags |= idProp;
	else
		pItem->dwFlags &= ~(idProp);
	return(S_OK);
}

PUT_ACCESSOR(RecipientFlags)
{
	// The context is a LPRECIPIENTS_PROPERTY_ITEM
	LPRECIPIENTS_PROPERTY_ITEM	pItem = (LPRECIPIENTS_PROPERTY_ITEM)pContext;
	if (!pItem || !pbBuffer)
		return(E_POINTER);

	if (cbLength < sizeof(DWORD))
		return(E_INVALIDARG);

    //make sure that the reserved bits are not being touched
    _ASSERT((pItem->dwFlags & RP_RECIP_FLAGS_RESERVED) == ((*(DWORD *)pbBuffer) & RP_RECIP_FLAGS_RESERVED));


    //Add additional checks to make sure that the multi-bit properties are being
    //set properly.  If any of the following ASSERT's fire, then the *calling*
    //code needs to be fixed.
#ifdef DEBUG
    if (RP_HANDLED & pItem->dwFlags) //check handled flags
    {
        //if one of the following fires, then the handled flag is set incorrectly
        _ASSERT((RP_DELIVERED & pItem->dwFlags) == RP_DELIVERED ||
                (RP_DSN_SENT_NDR & pItem->dwFlags) == RP_DSN_SENT_NDR ||
                (RP_FAILED & pItem->dwFlags) == RP_FAILED ||
                (RP_UNRESOLVED & pItem->dwFlags) == RP_UNRESOLVED ||
                (RP_ENPANDED & pItem->dwFlags) == RP_ENPANDED);
    }
    if (RP_GENERAL_FAILURE & pItem->dwFlags) //check failure flags
    {
        //if one of the following fires, then the failure flag is set incorrectly
        _ASSERT((RP_FAILED & pItem->dwFlags) == RP_FAILED ||
                (RP_UNRESOLVED & pItem->dwFlags) == RP_UNRESOLVED);
    }
    if (RP_DSN_HANDLED & pItem->dwFlags)
    {
        //if one of the following fires, then the RP_DSN_HANDLED flag is set incorrectly
        _ASSERT((RP_DSN_SENT_EXPANDED & pItem->dwFlags) == RP_DSN_SENT_EXPANDED ||
                (RP_DSN_SENT_RELAYED & pItem->dwFlags) == RP_DSN_SENT_RELAYED ||
                (RP_DSN_SENT_DELIVERED & pItem->dwFlags) == RP_DSN_SENT_DELIVERED ||
                (RP_DSN_SENT_NDR & pItem->dwFlags) == RP_DSN_SENT_NDR);
    }
    _ASSERT(0x00400100 != pItem->dwFlags); //bug #73596 - smoke out the offender!
#endif //DEBUG
    //Make sure reserved bits are not touched in retail builds
    pItem->dwFlags = (*(DWORD *)pbBuffer & ~RP_RECIP_FLAGS_RESERVED) |
                     (pItem->dwFlags & RP_RECIP_FLAGS_RESERVED);
	return(S_OK);
}

PUT_ACCESSOR(AddressValue)
{
	HRESULT	hrRes = S_OK;
	HRESULT	hrTemp;

	
	// The context is a LPRECIPIENTS_PROPERTY_ITEM
	LPRECIPIENTS_PROPERTY_ITEM	pItem = (LPRECIPIENTS_PROPERTY_ITEM)pContext;
	LPVOID						pvName;
	LPVOID						pvTemp;

	// Preferred memory allocator
	CMemoryAccess				baAccess;

	if (!pItem)
		return(E_POINTER);

	// See if the name type is valid
	if ((DWORD)idProp >= MAX_COLLISION_HASH_KEYS)
		return(E_INVALIDARG);

	// See if the name is set
	pvTemp = NULL;
	pvName = (LPVOID)pItem->faNameOffset[idProp];
	if (pvName && (cbLength > pItem->dwNameLength[idProp]))
	{
		// We don't have enough space to store the new name, so
		// we will allocate a new block
		pvTemp = pvName;
		pvName = NULL;

	}

	if (!pvName)
	{
		// Allocate a new block
		hrRes = baAccess.AllocBlock(&pvName, cbLength);
	}

	if (SUCCEEDED(hrRes))
	{
	    // OK, copy the property value over
	    MoveMemory(pvName,
		       pbBuffer,
		       cbLength);
	}

	// OK, we got everything we need, so we silently update the
	// name pointer and free the old block if we have one
	if (SUCCEEDED(hrRes))
	{
		pItem->faNameOffset[idProp] = (FLAT_ADDRESS)(DWORD_PTR)pvName;

		if (pvTemp)
		{
			// We can interpret the result of this free, but for all practical
			// purposes, this operation succeeded.
			hrTemp = baAccess.FreeBlock(pvTemp);
			_ASSERT(SUCCEEDED(hrTemp));
		}
	}
	else if (pvName && pvTemp)
	{
		// We failed and we have allocated a new block, so we free
		// the new block and keep the old one
		hrTemp = baAccess.FreeBlock(pvName);
		_ASSERT(SUCCEEDED(hrTemp));
	}

	return(hrRes);
}

PUT_ACCESSOR(AddressValueBM)
{
	return(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgp.h $(O)\mailmsgp_i.c : $(STAXINC)\export\mailmsgp.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgp_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgp_i.c \
    -header $@ \
    -tlb $(O)\mailmsgp.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\cmailmsg.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cmailmsg.h

Abstract:

	This module contains the definition of the master message class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/09/98	created

--*/

#ifndef _CMAILMSG_H_
#define _CMAILMSG_H_

#include "filehc.h"
#include "mailmsgi.h"
#include "mailmsgp.h"

#include "blockmgr.h"
#include "cmmprops.h"

#include "mailmsgprops.h"

#include "cmmutils.h"
#include "cmmsprop.h"

/***************************************************************************/
// Definitions
//

//
// Define recipient flags
//
#define FLAG_RECIPIENT_DO_NOT_DELIVER			0x00000001
#define FLAG_RECIPIENT_NO_NAME_COLLISIONS		0x00000002

//
// Define the invalid domain index
//
#define INVALID_DOMAIN_INDEX					((DWORD)(-2))


//
// Define InternalReleaseUsage options
//
#define RELEASE_USAGE_EXTERNAL                  0x00000001
#define RELEASE_USAGE_FINAL_RELEASE             0x00000002
#define RELEASE_USAGE_DELETE                    0x00000004
#define RELEASE_USAGE_INTERNAL                  0x00000008

/***************************************************************************/
// Structures
//


// Define a local master header structure. This structure always
// starts at offset 0 in the flat memory space
typedef struct _MASTER_HEADER
{
	DWORD						dwSignature;
	WORD						wVersionHigh;
	WORD						wVersionLow;
	DWORD						dwHeaderSize;

	// Got space for each essential property table
	PROPERTY_TABLE_INSTANCE		ptiGlobalProperties;
	PROPERTY_TABLE_INSTANCE		ptiRecipients;
	PROPERTY_TABLE_INSTANCE		ptiPropertyMgmt;

} MASTER_HEADER, *LPMASTER_HEADER;


/***************************************************************************/
// Special property tables
//
extern PTABLE g_SpecialMessagePropertyTable;
extern PTABLE g_SpecialRecipientsPropertyTable;
extern PTABLE g_SpecialRecipientsAddPropertyTable;

/***************************************************************************/
//
//

class CMailMsgPropertyManagement :
	public IMailMsgPropertyManagement
{
  public:

	CMailMsgPropertyManagement(
				CBlockManager				*pBlockManager,
				LPPROPERTY_TABLE_INSTANCE	pInstanceInfo
				);

	~CMailMsgPropertyManagement();

	/***************************************************************************/
	//
	// Implementation of IMailMsgPropertyManagement
	//

	HRESULT STDMETHODCALLTYPE AllocPropIDRange(
				REFGUID	rguid,
				DWORD	cCount,
				DWORD	*pdwStart
				);

	HRESULT STDMETHODCALLTYPE EnumPropIDRange(
				DWORD	*pdwIndex,
				GUID	*pguid,
				DWORD	*pcCount,
				DWORD	*pdwStart
				);
  private:

	// The specific compare function for this type of property table
	static HRESULT CompareProperty(
				LPVOID			pvPropKey,
				LPPROPERTY_ITEM	pItem
				);

	// CMailMsgPropertyManagement is an instance of CPropertyTable
	CPropertyTable				m_ptProperties;

	// We have a need to keep a pointer to the instance data
	LPPROPERTY_TABLE_INSTANCE	m_pInstanceInfo;

	// Keep a pointer to the block manager
	CBlockManager				*m_pBlockManager;
};



/***************************************************************************/
//
//

class CMailMsgRecipientsPropertyBase
{
  public:

	// Generic method for setting the value of a property given
	// LPRECIPIENTS_PROPERTY_ITEM
	HRESULT PutProperty(
				CBlockManager				*pBlockManager,
				LPRECIPIENTS_PROPERTY_ITEM	pItem,
				DWORD						dwPropID,
				DWORD						cbLength,
				LPBYTE						pbValue
				);

	// Generic method for getting the value of a property given
	// LPRECIPIENTS_PROPERTY_ITEM
	HRESULT GetProperty(
				CBlockManager				*pBlockManager,
				LPRECIPIENTS_PROPERTY_ITEM	pItem,
				DWORD						dwPropID,
				DWORD						cbLength,
				DWORD						*pcbLength,
				LPBYTE						pbValue
				);

	// The specific compare function for this type of property table
	static HRESULT CompareProperty(
				LPVOID			pvPropKey,
				LPPROPERTY_ITEM	pItem
				);

	// Well known properties
	static INTERNAL_PROPERTY_ITEM			*const s_pWellKnownProperties;
	static const DWORD						s_dwWellKnownProperties;
};


/***************************************************************************/
//
//

class CMailMsgRecipients :
	public CMailMsgRecipientsPropertyBase,
	public IMailMsgRecipients,
	public IMailMsgPropertyReplication
{
  public:

	CMailMsgRecipients(
				CBlockManager				*pBlockManager,
				LPPROPERTY_TABLE_INSTANCE	pInstanceInfo
				);

	~CMailMsgRecipients();

	HRESULT SetStream(
				IMailMsgPropertyStream	*pStream
				);

	HRESULT SetCommitState(
				BOOL	fGlobalCommitDone
				);

	// Virtual method to restore the handles if necessary
	virtual HRESULT RestoreResourcesIfNecessary(
				BOOL	fLockAcquired,
                BOOL    fStreamOnly
				) = 0;

	/***************************************************************************/
	//
	// Implementation of IUnknown
	//

	HRESULT STDMETHODCALLTYPE QueryInterface(
				REFIID		iid,
				void		**ppvObject
				);

	ULONG STDMETHODCALLTYPE AddRef();

	ULONG STDMETHODCALLTYPE Release();

	/***************************************************************************/
	//
	// Implementation of IMailMsgRecipients
	//

	// The commit must be called after a global commit is called on the current
	// list. Commit will refuse to continue (i.e. return E_FAIL) if the one or more
	// of the following is TRUE:
	// 1) Global commit was not called
	// 2) A WriteList is called after the last global commit.
	HRESULT STDMETHODCALLTYPE Commit(
				DWORD			dwIndex,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE DomainCount(
				DWORD	*pdwCount
				);

	HRESULT STDMETHODCALLTYPE DomainItem(
				DWORD	dwIndex,
				DWORD	cchLength,
				LPSTR	pszDomain,
				DWORD	*pdwRecipientIndex,
				DWORD	*pdwRecipientCount
				);


	HRESULT STDMETHODCALLTYPE SetNextDomain(
				DWORD	dwDomainIndex,
				DWORD	dwNextDomainIndex,
				DWORD	dwFlags
				);

	HRESULT STDMETHODCALLTYPE InitializeRecipientFilterContext(
				LPRECIPIENT_FILTER_CONTEXT	pContext,
				DWORD						dwStartingDomain,
				DWORD						dwFilterFlags,
				DWORD						dwFilterMask
				);

	HRESULT STDMETHODCALLTYPE TerminateRecipientFilterContext(
				LPRECIPIENT_FILTER_CONTEXT	pContext
				);

	HRESULT STDMETHODCALLTYPE GetNextRecipient(
				LPRECIPIENT_FILTER_CONTEXT	pContext,
				DWORD						*pdwRecipientIndex
				);


	HRESULT STDMETHODCALLTYPE AllocNewList(
				IMailMsgRecipientsAdd	**ppNewList
				);

	HRESULT STDMETHODCALLTYPE WriteList(
				IMailMsgRecipientsAdd	*pNewList
				);

	/***************************************************************************/
	//
	// Implementation of IMailMsgRecipientsBase
	//

	HRESULT STDMETHODCALLTYPE Count(
				DWORD	*pdwCount
				);

	HRESULT STDMETHODCALLTYPE Item(
				DWORD	dwIndex,
				DWORD	dwWhichName,
				DWORD	cchLength,
				LPSTR	pszName
				);

	HRESULT STDMETHODCALLTYPE PutProperty(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	cbLength,
				LPBYTE	pbValue
				);

	HRESULT STDMETHODCALLTYPE GetProperty(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	cbLength,
				DWORD	*pcbLength,
				LPBYTE	pbValue
				);

	HRESULT STDMETHODCALLTYPE PutStringA(
				DWORD	dwIndex,
				DWORD	dwPropID,
				LPCSTR	pszValue
				)
	{
		return (PutProperty(dwIndex,dwPropID,pszValue?strlen(pszValue)+1:0,(LPBYTE) pszValue));
	}

	HRESULT STDMETHODCALLTYPE GetStringA(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	cchLength,
				LPSTR	pszValue
				)
	{
		DWORD dwLength;
		return (GetProperty(dwIndex,dwPropID,cchLength,&dwLength,(LPBYTE) pszValue));
	}

	HRESULT STDMETHODCALLTYPE PutStringW(
				DWORD	dwIndex,
				DWORD	dwPropID,
				LPCWSTR	pszValue
				)
	{
		return (PutProperty(dwIndex,dwPropID,pszValue?(wcslen(pszValue)+1)*sizeof(WCHAR):0,(LPBYTE) pszValue));
	}

	HRESULT STDMETHODCALLTYPE GetStringW(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	cchLength,
				LPWSTR	pszValue
				)
	{
		DWORD dwLength;
		return (GetProperty(dwIndex,dwPropID,cchLength*sizeof(WCHAR),&dwLength,(LPBYTE) pszValue));
	}

	HRESULT STDMETHODCALLTYPE PutDWORD(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	dwValue
				)
	{
		return (PutProperty(dwIndex,dwPropID,sizeof(DWORD),(LPBYTE) &dwValue));
	}

	HRESULT STDMETHODCALLTYPE GetDWORD(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	*pdwValue
				)
	{
		DWORD dwLength;
		return (GetProperty(dwIndex,dwPropID,sizeof(DWORD),&dwLength,(LPBYTE) pdwValue));
	}

	HRESULT STDMETHODCALLTYPE PutBool(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	dwValue
				)
	{
		dwValue = dwValue ? 1 : 0;
		return (PutProperty(dwIndex,dwPropID,sizeof(DWORD),(LPBYTE) &dwValue));
	}

	HRESULT STDMETHODCALLTYPE GetBool(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	*pdwValue
				)
	{
		HRESULT hrRes;
		DWORD dwLength;

		hrRes = GetProperty(dwIndex,dwPropID,sizeof(DWORD),&dwLength,(LPBYTE) pdwValue);
		if (pdwValue)
			*pdwValue = *pdwValue ? 1 : 0;
		return (hrRes);
	}

	/***************************************************************************/
	//
	// Implementation of IMailMsgPropertyReplication
	//

	// Method to copy all the properties of the source recipient to
	// the specified. The caller can specify a list of PROP IDs
	HRESULT STDMETHODCALLTYPE CopyTo(
				DWORD					dwSourceRecipientIndex,
				IMailMsgRecipientsBase	*pTargetRecipientList,
				DWORD					dwTargetRecipientIndex,
				DWORD					dwExemptCount,
				DWORD					*pdwExemptPropIdList
				);

  private:

	HRESULT DomainItemEx(
				DWORD	dwIndex,
				DWORD	cchLength,
				LPSTR	pszDomain,
				DWORD	*pdwRecipientIndex,
				DWORD	*pdwRecipientCount,
				DWORD	*pdwNextDomainIndex
				);

	// Reference count
	LONG						m_ulRefCount;

	// Count the number of domains in our list
	DWORD						m_dwDomainCount;

	// This tracks the commit state of the recipient list
	BOOL						m_fGlobalCommitDone;

	// We have a need to keep a pointer to the recipient table
	// for domain operations ...
	LPPROPERTY_TABLE_INSTANCE	m_pInstanceInfo;

	// Keep a pointer to the block manager
	CBlockManager				*m_pBlockManager;

	// Wee need to keep a pointer to the property stream
	IMailMsgPropertyStream		*m_pStream;

	// Special property table class instance
	CSpecialPropertyTable		m_SpecialPropertyTable;

};


/***************************************************************************/
//
//

class CMailMsgRecipientsAdd :
	public CMailMsgRecipientsPropertyBase,
	public IMailMsgRecipientsAdd,
	public IMailMsgPropertyReplication
{
	friend CRecipientsHash;
  public:

	CMailMsgRecipientsAdd(
				CBlockManager	*pBlockManager
				);

	~CMailMsgRecipientsAdd();

	//
	// CPool
	//
	static CPool m_Pool;
	inline void *operator new(size_t size)
	{
		return m_Pool.Alloc();
	}
	inline void operator delete(void *p, size_t size)
	{
		m_Pool.Free(p);
	}

	/***************************************************************************/
	//
	// Implementation of IUnknown
	//

	HRESULT STDMETHODCALLTYPE QueryInterface(
				REFIID		iid,
				void		**ppvObject
				);

	ULONG STDMETHODCALLTYPE AddRef();

	ULONG STDMETHODCALLTYPE Release();

	CRecipientsHash *GetHashTable() { return(&m_Hash); }

	/***************************************************************************/
	//
	// Implementation of IMailMsgRecipientsAdd
	//

	HRESULT STDMETHODCALLTYPE AddPrimary(
				DWORD dwCount,
				LPCSTR *ppszNames,
				DWORD *pdwPropIDs,
				DWORD *pdwIndex,
				IMailMsgRecipientsBase *pFrom,
				DWORD dwFrom
				);

	HRESULT STDMETHODCALLTYPE AddSecondary(
				DWORD dwCount,
				LPCSTR *ppszNames,
				DWORD *pdwPropIDs,
				DWORD *pdwIndex,
				IMailMsgRecipientsBase *pFrom,
				DWORD dwFrom
				);

	/***************************************************************************/
	//
	// Implementation of IMailMsgRecipientsBase
	//

	HRESULT STDMETHODCALLTYPE Count(
				DWORD	*pdwCount
				);

	HRESULT STDMETHODCALLTYPE Item(
				DWORD	dwIndex,
				DWORD	dwWhichName,
				DWORD	cchLength,
				LPSTR	pszName
				);

	HRESULT STDMETHODCALLTYPE PutProperty(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	cbLength,
				LPBYTE	pbValue
				);

	HRESULT STDMETHODCALLTYPE GetProperty(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	cbLength,
				DWORD	*pcbLength,
				LPBYTE	pbValue
				);

	HRESULT STDMETHODCALLTYPE PutStringA(
				DWORD	dwIndex,
				DWORD	dwPropID,
				LPCSTR	pszValue
				)
	{
		return (PutProperty(dwIndex,dwPropID,pszValue?strlen(pszValue)+1:0,(LPBYTE) pszValue));
	}

	HRESULT STDMETHODCALLTYPE GetStringA(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	cchLength,
				LPSTR	pszValue
				)
	{
		DWORD dwLength;
		return (GetProperty(dwIndex,dwPropID,cchLength,&dwLength,(LPBYTE) pszValue));
	}

	HRESULT STDMETHODCALLTYPE PutStringW(
				DWORD	dwIndex,
				DWORD	dwPropID,
				LPCWSTR	pszValue
				)
	{
		return (PutProperty(dwIndex,dwPropID,pszValue?(wcslen(pszValue)+1)*sizeof(WCHAR):0,(LPBYTE) pszValue));
	}

	HRESULT STDMETHODCALLTYPE GetStringW(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	cchLength,
				LPWSTR	pszValue
				)
	{
		DWORD dwLength;
		return (GetProperty(dwIndex,dwPropID,cchLength*sizeof(WCHAR),&dwLength,(LPBYTE) pszValue));
	}

	HRESULT STDMETHODCALLTYPE PutDWORD(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	dwValue
				)
	{
		return (PutProperty(dwIndex,dwPropID,sizeof(DWORD),(LPBYTE) &dwValue));
	}

	HRESULT STDMETHODCALLTYPE GetDWORD(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	*pdwValue
				)
	{
		DWORD dwLength;
		return (GetProperty(dwIndex,dwPropID,sizeof(DWORD),&dwLength,(LPBYTE) pdwValue));
	}

	HRESULT STDMETHODCALLTYPE PutBool(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	dwValue
				)
	{
		dwValue = dwValue ? 1 : 0;
		return (PutProperty(dwIndex,dwPropID,sizeof(DWORD),(LPBYTE) &dwValue));
	}

	HRESULT STDMETHODCALLTYPE GetBool(
				DWORD	dwIndex,
				DWORD	dwPropID,
				DWORD	*pdwValue
				)
	{
		HRESULT hrRes;
		DWORD dwLength;

		hrRes = GetProperty(dwIndex,dwPropID,sizeof(DWORD),&dwLength,(LPBYTE) pdwValue);
		if (pdwValue)
			*pdwValue = *pdwValue ? 1 : 0;
		return (hrRes);
	}

	/***************************************************************************/
	//
	// Implementation of IMailMsgPropertyReplication
	//

	// Method to copy all the properties of the source recipient to
	// the specified. The caller can specify a list of PROP IDs
	HRESULT STDMETHODCALLTYPE CopyTo(
				DWORD					dwSourceRecipientIndex,
				IMailMsgRecipientsBase	*pTargetRecipientList,
				DWORD					dwTargetRecipientIndex,
				DWORD					dwExemptCount,
				DWORD					*pdwExemptPropIdList
				);

  private:

	HRESULT AddPrimaryOrSecondary(
				DWORD					dwCount,
				LPCSTR					*ppszNames,
				DWORD					*pdwPropIDs,
				DWORD					*pdwIndex,
				IMailMsgRecipientsBase	*pFrom,
				DWORD					dwFrom,
				BOOL					fPrimary
				);

	HRESULT GetPropertyInternal(
				LPRECIPIENTS_PROPERTY_ITEM_EX	pItem,
				DWORD	dwPropID,
				DWORD	cbLength,
				DWORD	*pcbLength,
				LPBYTE	pbValue
				);

	// Global default instance info
	static const PROPERTY_TABLE_INSTANCE s_DefaultInstance;

	// The reference count to the object
	LONG						m_ulRefCount;

	// It needs its own instance of a property table
	PROPERTY_TABLE_INSTANCE		m_InstanceInfo;

	// Pointer to block manager
	CBlockManager				*m_pBlockManager;

	// We have an instance of the hash table
	CRecipientsHash				m_Hash;

	// Special property table class instance
	CSpecialPropertyTable		m_SpecialPropertyTable;


};


/***************************************************************************/
//
//

class CMailMsg :
	public IMailMsgProperties,
	public CMailMsgPropertyManagement,
	public CMailMsgRecipients,
	public IMailMsgQueueMgmt,
	public IMailMsgBind,
    public IMailMsgAQueueListEntry,
	public IMailMsgValidate,
	public IMailMsgValidateContext,
	public CBlockManagerGetStream
{
  public:

	CMailMsg();
	~CMailMsg();

    void FinalRelease();

	//
	// Method to initialize the CMailMsg. This must precede any access to
	// the object. When this method is called, absolutely no other threads
	// can be inside this object or its derivatives.
	//
	HRESULT Initialize();

	HRESULT QueryBlockManager(
				CBlockManager	**ppBlockManager
				);

	HRESULT RestoreResourcesIfNecessary(
				BOOL	fLockAcquired = FALSE,
                BOOL    fStreamOnly = FALSE
				);

	HRESULT GetStream(
				IMailMsgPropertyStream	**ppStream,
				BOOL					fLockAcquired
				);

	HRESULT SetDefaultRebindStore(
				IMailMsgStoreDriver	*pStoreDriver
				)
	{
		m_pDefaultRebindStoreDriver = pStoreDriver;
		return(S_OK);
	}

    typedef HRESULT PFNENUMERATOR (
                LPPROPERTY_ITEM pPi,
                DWORD cbPiSize,
                PBYTE pbProp,
                DWORD cbSize,
                PVOID pvContext
                );

    typedef HRESULT PFNRECIPIENTSENUMERATOR(
                LPRECIPIENTS_PROPERTY_ITEM prpi,
                PVOID pvCrc
                );

    HRESULT EnumPropertyTable(
                LPPROPERTY_TABLE_INSTANCE ppti,
                PFNENUMERATOR pfnEnumerator,
                PVOID pvContext
                );

    HRESULT CMailMsg::EnumRecipientsPropertyTable(
                PFNRECIPIENTSENUMERATOR pfnRecipientsEnumerator,
                PVOID pvContext
                );

    HRESULT SetChecksum();

    HRESULT VerifyChecksum();

    HRESULT GenerateChecksum(
                PDWORD pdwCrcGlobal,
                PDWORD pdwCrcRecips
                );

	/***************************************************************************/
	//
	// Implementation of IMailMsgProperties
	//

	HRESULT STDMETHODCALLTYPE PutProperty(
				DWORD	dwPropID,
				DWORD	cbLength,
				LPBYTE	pbValue
				);

	HRESULT STDMETHODCALLTYPE GetProperty(
				DWORD	dwPropID,
				DWORD	cbLength,
				DWORD	*pcbLength,
				LPBYTE	pbValue
				);

	HRESULT STDMETHODCALLTYPE Commit(
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE PutStringA(
				DWORD	dwPropID,
				LPCSTR	pszValue
				)
	{
		return(PutProperty(dwPropID, pszValue?strlen(pszValue)+1:0, (LPBYTE)pszValue));
	}

	HRESULT STDMETHODCALLTYPE GetStringA(
				DWORD	dwPropID,
				DWORD	cchLength,
				LPSTR	pszValue
				)
	{
		DWORD dwLength;
		return(GetProperty(dwPropID, cchLength, &dwLength, (LPBYTE)pszValue));
	}

	HRESULT STDMETHODCALLTYPE PutStringW(
				DWORD	dwPropID,
				LPCWSTR	pszValue
				)
	{
		return(PutProperty(dwPropID, pszValue?(wcslen(pszValue)+1)*sizeof(WCHAR):0, (LPBYTE)pszValue));
	}

	HRESULT STDMETHODCALLTYPE GetStringW(
				DWORD	dwPropID,
				DWORD	cchLength,
				LPWSTR	pszValue
				)
	{
		DWORD dwLength;
		return(GetProperty(dwPropID, cchLength*sizeof(WCHAR), &dwLength, (LPBYTE)pszValue));
	}

	HRESULT STDMETHODCALLTYPE PutDWORD(
				DWORD	dwPropID,
				DWORD	dwValue
				)
	{
		return(PutProperty(dwPropID, sizeof(DWORD), (LPBYTE)&dwValue));
	}

	HRESULT STDMETHODCALLTYPE GetDWORD(
				DWORD	dwPropID,
				DWORD	*pdwValue
				)
	{
		DWORD dwLength;
		return(GetProperty(dwPropID, sizeof(DWORD), &dwLength, (LPBYTE)pdwValue));
	}

	HRESULT STDMETHODCALLTYPE PutBool(
				DWORD	dwPropID,
				DWORD	dwValue
				)
	{
		dwValue = dwValue ? 1 : 0;
		return(PutProperty(dwPropID, sizeof(DWORD), (LPBYTE)&dwValue));
	}

	HRESULT STDMETHODCALLTYPE GetBool(
				DWORD	dwPropID,
				DWORD	*pdwValue
				)
	{
		HRESULT hrRes;
		DWORD dwLength;

		hrRes = GetProperty(dwPropID, sizeof(DWORD), &dwLength, (LPBYTE)pdwValue);
		if (pdwValue)
			*pdwValue = *pdwValue ? 1 : 0;
		return (hrRes);
	}

	HRESULT STDMETHODCALLTYPE GetContentSize(
				DWORD			*pdwSize,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE ReadContent(
				DWORD			dwOffset,
				DWORD			dwLength,
				DWORD			*pdwLength,
				BYTE			*pbBlock,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE WriteContent(
				DWORD			dwOffset,
				DWORD			dwLength,
				DWORD			*pdwLength,
				BYTE			*pbBlock,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE CopyContentToFile(
				PFIO_CONTEXT	hCopy,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE CopyContentToFileEx(
				PFIO_CONTEXT	hCopy,
				BOOL			fDotStuffed,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE CopyContentToStream(
				IMailMsgPropertyStream	*pStream,
				IMailMsgNotify			*pNotify
				);

	HRESULT STDMETHODCALLTYPE ForkForRecipients(
				IMailMsgProperties		**ppNewMessage,
				IMailMsgRecipientsAdd	**ppRecipients
				);

  	HRESULT STDMETHODCALLTYPE CopyContentToFileAtOffset(
				PFIO_CONTEXT	hCopy,
                DWORD           dwOffset,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE RebindAfterFork(
				IMailMsgProperties		*pOriginalMsg,
				IUnknown				*pStoreDriver
				);

	HRESULT STDMETHODCALLTYPE SetContentSize(
				DWORD			dwSize,
				IMailMsgNotify	*pNotify
				);

    HRESULT STDMETHODCALLTYPE MapContent(
                BOOL            fWrite,
                BYTE            **ppbContent,
                DWORD           *pcContent
                );

    HRESULT STDMETHODCALLTYPE UnmapContent(
                BYTE            *ppbContent
                );

    HRESULT STDMETHODCALLTYPE ValidateStream(
                IMailMsgPropertyStream *pStream
                );

    HRESULT STDMETHODCALLTYPE ValidateContext(
                );

	/***************************************************************************/
	//
	// Implementation of IMailMsgQueueMgmt
	//

	HRESULT STDMETHODCALLTYPE AddUsage();
	HRESULT STDMETHODCALLTYPE ReleaseUsage();

	HRESULT STDMETHODCALLTYPE SetRecipientCount(
				DWORD dwCount
				);
	HRESULT STDMETHODCALLTYPE GetRecipientCount(
				DWORD *pdwCount
				);

	HRESULT STDMETHODCALLTYPE DecrementRecipientCount(
				DWORD dwDecrement
				);
	HRESULT STDMETHODCALLTYPE IncrementRecipientCount(
				DWORD dwIncrement
				);

	HRESULT STDMETHODCALLTYPE Delete(
				IMailMsgNotify *pNotify
				);

	/***************************************************************************/
	//
	// Implementation of IMailMsgBind
	//

	HRESULT STDMETHODCALLTYPE BindToStore(
				IMailMsgPropertyStream	*pStream,
				IMailMsgStoreDriver		*pStore,
				PFIO_CONTEXT			hContentFile
				);

#define MAILMSG_GETPROPS_MARKCOMMIT		0xf0000000
	HRESULT STDMETHODCALLTYPE GetProperties(
				IMailMsgPropertyStream	*pStream,
				DWORD					dwFlags,
				IMailMsgNotify			*pNotify
				);

	HRESULT STDMETHODCALLTYPE GetBinding(
				PFIO_CONTEXT				*phAsyncIO,
				IMailMsgNotify				*pNotify
				);

	HRESULT STDMETHODCALLTYPE ReleaseContext();

#if 0
	/***************************************************************************/
	//
	// Implementation of IMailMsgBindATQ
	//

	HRESULT STDMETHODCALLTYPE BindToStore(
				IMailMsgPropertyStream		*pStream,
				IMailMsgStoreDriver			*pStore,
				PFIO_CONTEXT				hContentFile,
				void						*pvClientContext,
				ATQ_COMPLETION				pfnCompletion,
				DWORD						dwTimeout,
				struct _ATQ_CONTEXT_PUBLIC	**ppATQContext,
				PFNAtqAddAsyncHandle		pfnAtqAddAsyncHandle,
				PFNAtqFreeContext			pfnAtqFreeContext
				);

	HRESULT STDMETHODCALLTYPE GetATQInfo(
				struct _ATQ_CONTEXT_PUBLIC	**ppATQContext,
				PFIO_CONTEXT				*phAsyncIO,
				IMailMsgNotify				*pNotify
				);

	HRESULT STDMETHODCALLTYPE ReleaseATQHandle();
#endif

	/***************************************************************************/
	//
	// Implementation of IMailMsgAQueueListEntry
	//

	HRESULT STDMETHODCALLTYPE GetListEntry(void **pple) {
        *((LIST_ENTRY **) pple) = &m_leAQueueListEntry;
        return S_OK;
    }

  private:

	// The specific compare function for this type of property table
	static HRESULT CompareProperty(
				LPVOID			pvPropKey,
				LPPROPERTY_ITEM	pItem
				);

	// Copies
	HRESULT CopyContentToStreamOrFile(
				BOOL			fIsStream,
				LPVOID			pStreamOrHandle,
				IMailMsgNotify	*pNotify,
                DWORD           dwDestOffset //offset in destination file to start
				);
       HRESULT AddMgmtFragment(CBlockManager   *pBlockManager, FLAT_ADDRESS faOffset,  FLAT_ADDRESS *pfaToUpdate);

	// Enumeration: restore a master header and make sure it is at
	// least sane.
	HRESULT RestoreMasterHeaderIfAppropriate();

    //Function with internal implementation of ReleaseUsage - MikeSwa
  	HRESULT InternalReleaseUsage(DWORD  dwReleaseUsageFlags);

    //
    // validate that all of the properties in a property table are valid
    //
    HRESULT ValidateProperties(CBlockManager *pBM,
                               DWORD cStream,
                               PROPERTY_TABLE_INSTANCE *pti);

    //
    // validate that the recipient structures are valid
    //
    HRESULT ValidateRecipient(CBlockManager *pBM,
                              DWORD cStream,
                              RECIPIENTS_PROPERTY_ITEM *prspi);

    //
    // Make sure that a flat address is in a valid range
    //
    BOOL ValidateFA(FLAT_ADDRESS fa,
                    DWORD cRange,
                    DWORD cStream,
                    BOOL fInvalidFAOk = FALSE)
    {
        return ((fa == INVALID_FLAT_ADDRESS &&
                 fInvalidFAOk) ||
                (fa >= sizeof(MASTER_HEADER) &&
                 fa + cRange <= cStream));
    }


  public:

	// Blob for storing the store driver handle blob
	LPBYTE							m_pbStoreDriverHandle;
	DWORD							m_dwStoreDriverHandle;

	// DWORD holding some special creation property flags
	DWORD							m_dwCreationFlags;

  private:

	// Usage count
	LONG							m_ulUsageCount;

    // this lock is held when the usage count is going through a transition
    CShareLockNH                m_lockUsageCount;

	// Recipient counter for queue management
	LONG							m_ulRecipientCount;

	// A master header structure for the message object and its blueprint
	MASTER_HEADER					m_Header;
	static const MASTER_HEADER		s_DefaultHeader;

	// Bind information
	PFIO_CONTEXT					m_hContentFile;		// IO/Content file handle
	DWORD							m_cContentFile;		// size of m_hContentFile, -1 if unknown
	IMailMsgPropertyStream			*m_pStream;			// Property Stream interface
	IMailMsgStoreDriver				*m_pStore;			// Store driver interface
//	struct _ATQ_CONTEXT_PUBLIC		*m_pATQContext;		// ATQ Context
	LPVOID							m_pvClientContext;	// Client Context
	ATQ_COMPLETION					m_pfnCompletion;	// ATQ Completion routine
	DWORD							m_dwTimeout;		// ATQ Timeout
	BOOL							m_fCommitCalled;	// set to TRUE after the first successful call to Commit
	BOOL							m_fDeleted;         // Delete has been called

    //The following counter is used to maintain the static
    //g_cCurrentMsgsClosedByExternalReleaseUsage counter.
    //It is only decremented in RestoreResources
    //and only incremented in InteralReleaseUsage
    LONG                            m_cCloseOnExternalReleaseUsage;

	// Reference for RebindAfterFork ...
	IMailMsgStoreDriver				*m_pDefaultRebindStoreDriver;

	// Well known properties
	static INTERNAL_PROPERTY_ITEM	*const s_pWellKnownProperties;
	static const DWORD				s_dwWellKnownProperties;

	// IMailMsgProperties is an instance of CPropertyTable
	CPropertyTable					m_ptProperties;

	// Special property table class instance
	CSpecialPropertyTable			m_SpecialPropertyTable;

	// An instance of the block memory manager
	CBlockManager					m_bmBlockManager;

#if 0
	// Function pointers to ATQ methods
	PFNAtqAddAsyncHandle			m_pfnAtqAddAsyncHandle;
	PFNAtqFreeContext				m_pfnAtqFreeContext;
#endif

    //The list entry must be immediately followed by the context
    LIST_ENTRY                      m_leAQueueListEntry;
    PVOID                           m_pvAQueueListEntryContext;

    CShareLockNH                    m_lockReopen;

    // Most current global and recips CRCs
    DWORD                           m_dwGlobalCrc;
    DWORD                           m_dwRecipsCrc;

    static long                     g_cOpenContentHandles;
    static long                     g_cOpenStreamHandles;
    static long                     g_cTotalUsageCount;
    static long                     g_cTotalReleaseUsageCalls;
    static long                     g_cTotalReleaseUsageNonZero;
    static long                     g_cTotalReleaseUsageCloseStream;
    static long                     g_cTotalReleaseUsageCloseContent;
    static long                     g_cTotalReleaseUsageNothingToClose;
    static long                     g_cTotalReleaseUsageCloseFail;
    static long                     g_cTotalReleaseUsageCommitFail;
    static long                     g_cTotalExternalReleaseUsageZero;
    static long                     g_cCurrentMsgsClosedByExternalReleaseUsage;
  public:
    static long                     cTotalOpenContentHandles()
                                        {return g_cOpenContentHandles;};
    static long                     cTotalOpenStreamHandles()
                                        {return g_cOpenStreamHandles;};
    BOOL                            fIsStreamOpen()
                                        {return (m_pStream ? TRUE : FALSE);};
    BOOL                            fIsContentOpen()
                                        {return (m_hContentFile ? TRUE : FALSE);};
};

inline HRESULT STDMETHODCALLTYPE CMailMsg::SetRecipientCount(DWORD dwCount)
{
	InterlockedExchange(&m_ulRecipientCount, dwCount);
	return(S_OK);
}

inline HRESULT STDMETHODCALLTYPE CMailMsg::GetRecipientCount(DWORD *pdwCount)
{
	_ASSERT(pdwCount);
	if (!pdwCount) return(E_POINTER);
	*pdwCount = InterlockedExchangeAdd(&m_ulRecipientCount, 0);
	return(S_OK);
}

inline HRESULT STDMETHODCALLTYPE CMailMsg::DecrementRecipientCount(DWORD dwDecrement)
{
	if ((LONG)dwDecrement > m_ulRecipientCount)
	{
		_ASSERT(FALSE);
		return(E_FAIL);
	}
	return((InterlockedExchangeAdd(
				&m_ulRecipientCount,
				-(LONG)dwDecrement) == (LONG)dwDecrement)?S_OK:S_FALSE);
}

inline HRESULT STDMETHODCALLTYPE CMailMsg::IncrementRecipientCount(DWORD dwIncrement)
{
	if (m_ulRecipientCount < 0)
	{
		_ASSERT(FALSE);
		return(E_FAIL);
	}
	return((InterlockedExchangeAdd(
				&m_ulRecipientCount,
				dwIncrement) == 0)?S_OK:S_FALSE);
}

HRESULT CopyPropertyEnumerator(
    LPPROPERTY_ITEM pPi,
    DWORD cbPiSize,
    PBYTE pbProp,
    DWORD cbSize,
    PVOID pvMsg);
HRESULT CrcPropTableEnumerator(
    LPPROPERTY_ITEM pPi,
    DWORD cbPiSize,
    PBYTE pbProp,
    DWORD cbSize,
    PVOID pvCrc);

HRESULT CrcPerRecipientPropTableEnumerator(
    LPPROPERTY_ITEM pPi,
    DWORD cbPiSize,
    BYTE *pbProp,
    DWORD cbSize,
    PVOID pvCrc);

// Helper struct used in CrcRecipientsPropTableEnumerator to bundle the CRC and
// a CMailMsg* in a single enumeration "Context" pointer.
struct CRC_RECIPIENTS_HELPER
{
    PDWORD pdwCrc;
    CMailMsg *pMsg;
};

HRESULT CrcRecipientsPropTableEnumerator(
    LPRECIPIENTS_PROPERTY_ITEM prpi,
    PVOID pvCrcHelper);

HRESULT CreateAndVerifyCrc(
    CMailMsg *pMsgOld,
    CMailMsg *pMsgNew);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\cmmutils.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cmmutils.cpp

Abstract:

	This module contains the implementation of various utilities

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/11/98	created

--*/

//#define WIN32_LEAN_AND_MEAN
#include "atq.h"

#include "dbgtrace.h"
#include "synconst.h"
#include "signatur.h"
#include "cmmtypes.h"
#include "cmmutils.h"
#include "cmailmsg.h"

// RFC 821 parser
#include "addr821.hxx"

// =================================================================
// Private Definitions
//

//
// Define which PROP_ID correspondes to which name index
//
PROP_ID	g_PropIdToNameIndexMapping[MAX_COLLISION_HASH_KEYS] =
{
	IMMPID_RP_ADDRESS_SMTP,
	IMMPID_RP_ADDRESS_X400,
	IMMPID_RP_ADDRESS_X500,
	IMMPID_RP_LEGACY_EX_DN,
    IMMPID_RP_ADDRESS_OTHER
};



// =================================================================
// Static declarations
//

// Per-recipient property table instance info
static const PROPERTY_TABLE_INSTANCE s_ptiDefaultRecipientInstanceInfo =
{
	RECIPIENT_PTABLE_INSTANCE_SIGNATURE_VALID,
	INVALID_FLAT_ADDRESS,
	RECIPIENT_PROPERTY_TABLE_FRAGMENT_SIZE,
	RECIPIENT_PROPERTY_ITEM_BITS,
	RECIPIENT_PROPERTY_ITEM_SIZE,
	0,
	INVALID_FLAT_ADDRESS
};


// =================================================================
// Implementation of CRecipientsHash
//

CRecipientsHash::CRecipientsHash()
{
	m_dwDomainCount = 0;
	m_dwDomainNameSize = 0;
	m_dwRecipientCount = 0;
	m_dwRecipientNameSize = 0;
#ifdef DEBUG
	m_dwAllocated = 0;
#endif
    m_pListHead = NULL;
    m_pvMapContext 	= NULL;
}

CRecipientsHash::~CRecipientsHash()
{
	Release();
}

HRESULT CRecipientsHash::ReleaseDomainList()
{
	DWORD				dwBucket;
	LPDOMAIN_LIST_ENTRY	pItem, pNextItem;

	TraceFunctEnter("CRecipientsHash::CloseDomainContext");

    m_hashDomains.Clear();

	TraceFunctLeave();
	return(S_OK);
}

HRESULT CRecipientsHash::Release()
{
	HRESULT							hrRes, hrResult = S_OK;
	DWORD							dwCount = 0;
	LPRECIPIENTS_PROPERTY_ITEM_EX	pItem, pNextItem;

	TraceFunctEnterEx((LPARAM)this, "CRecipientsHash::Release");

	// This algorithm first release any domain list resources, then
	// releases each recipient node by walking the single linked
	// list of all allocated nodes.

	// First, release all resources affiliated with the domain list
	ReleaseDomainList();

    // Clear out our hash tables
    m_hashEntries0.Clear();
    m_hashEntries1.Clear();
    m_hashEntries2.Clear();
    m_hashEntries3.Clear();
    m_hashEntries4.Clear();

	// Walk and release each recipient node
	hrResult = S_OK;
	pItem = m_pListHead;
	while (pItem)
	{
		pNextItem = pItem->pNextInList;
        // there should be one reference always for the list
        _ASSERT(pItem->m_cRefs == 1);
		hrRes = m_cmaAccess.FreeBlock((LPVOID)pItem);
		_ASSERT(SUCCEEDED(hrRes));
		if (!SUCCEEDED(hrRes))
			hrResult = hrRes;

		dwCount++;
		pItem = pNextItem;
	}
#ifdef DEBUG
	_ASSERT(dwCount == m_dwAllocated);
	m_dwAllocated = 0;
#endif
	m_pListHead = NULL;

	TraceFunctLeave();
	return(hrResult);
}

HRESULT CRecipientsHash::AllocateAndPrepareRecipientsItem(
			DWORD							dwCount,
			DWORD							*pdwMappedIndices,
			LPCSTR							*rgszName,
			PROP_ID							*pidProp,
			LPRECIPIENTS_PROPERTY_ITEM_EX	*ppItem
			)
{
	HRESULT							hrRes = S_OK;
	DWORD							dwTotal;
	LPBYTE							pbTemp;
	LPCSTR							szName;
	DWORD							dwNameIndex;
	DWORD							*pdwLength;
	DWORD							rgdwLength[MAX_COLLISION_HASH_KEYS];
	BOOL							fIsInitialized[MAX_COLLISION_HASH_KEYS];
	LPRECIPIENTS_PROPERTY_ITEM_EX	pItem = NULL;
	LPRECIPIENTS_PROPERTY_ITEM		pRcptItem = NULL;
	DWORD							i;

	if (!ppItem) return E_POINTER;

	TraceFunctEnterEx((LPARAM)this,
			"CRecipientsHash::AllocateAndPrepareRecipientsItem");

	// The count cannot be zero, the caller must make sure of that!
	if (!dwCount)
	{
		return(E_INVALIDARG);
	}

	// Make sure we have at least one good name
	dwTotal = sizeof(RECIPIENTS_PROPERTY_ITEM_EX);
	hrRes = E_FAIL;
	for (i = 0; i < dwCount; i++)
	{
		if (rgszName[i])
		{
            /*
             * -- no longer need to compute the hash here, its done
             * in lkhash -- awetmore
			 * // Generate the hash, this will convert everything to lowe case
			 * rgdwHash[i] = GenerateHash(rgszName[i], rgdwLength + i);
             */

            rgdwLength[i] = (strlen(rgszName[i]) + 1);
			dwTotal += rgdwLength[i];
			hrRes = S_OK;
		}
	}
	if (!SUCCEEDED(hrRes))
	{
		// We don't
		return(E_INVALIDARG);
	}

	hrRes = m_cmaAccess.AllocBlock(
					(LPVOID *)&pItem,
					dwTotal);
	if (!SUCCEEDED(hrRes))
		return(hrRes);

	// OK, got a block, now fill in the essential info
	pRcptItem = &(pItem->rpiRecipient);
	ZeroMemory(pItem, sizeof(RECIPIENTS_PROPERTY_ITEM_EX));
    // start with one reference for the recipient list
    pItem->m_cRefs = 1;
	pItem->dwSignature = RECIPIENTS_PROPERTY_ITEM_EX_SIG;
	MoveMemory(&(pRcptItem->ptiInstanceInfo),
				&s_ptiDefaultRecipientInstanceInfo,
				sizeof(PROPERTY_TABLE_INSTANCE));

	// Move past the record, and append in the strings
	pbTemp = ((LPBYTE)pItem) + sizeof(RECIPIENTS_PROPERTY_ITEM_EX);

	//
	// We now populate the recipient item, taking care to also remap
	// the incoming names into the proper PROP_ID order, since the prop
	// IDs can come in any order. We must reorder the names into our
	// internal order. Any unsupported names will be promptly rejected.
	//
	for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++)
		fIsInitialized[i] = FALSE;

	pdwLength = rgdwLength;
	for (i = 0; i < dwCount; i++)
	{
		// We gotta figure out which slot this actually goes to
		for (dwNameIndex = 0; dwNameIndex < MAX_COLLISION_HASH_KEYS; dwNameIndex++)
			if (g_PropIdToNameIndexMapping[dwNameIndex] == *pidProp)
				break;
		if (dwNameIndex == MAX_COLLISION_HASH_KEYS)
		{
			// The prop id is not found, so we return error
			hrRes = E_INVALIDARG;
			goto Cleanup;
		}

		// Make sure the prop ID is not already taken (we want to prevent
		// duplicates since it creates a loop in the linked list ...
		if (pRcptItem->idName[dwNameIndex] != 0)
		{
			// Duplicate, reject flat out
			hrRes = E_INVALIDARG;
			goto Cleanup;
		}

		// Save the mapped indices
		pdwMappedIndices[i] = dwNameIndex;

		szName = *rgszName++;
		if (szName && *szName)
		{
			pRcptItem->faNameOffset[dwNameIndex] = (FLAT_ADDRESS)(DWORD_PTR)pbTemp;
			pRcptItem->dwNameLength[dwNameIndex] = *pdwLength;
			pRcptItem->idName[dwNameIndex] = *pidProp;
			DebugTrace((LPARAM)this, "Inserting string %u <%s>, prop ID %u",
						dwNameIndex, szName, *pidProp);

			// Copy the name to its place
			strcpy((char *) pbTemp, szName);
			pbTemp += *pdwLength;

			// OK, this is initialized
			fIsInitialized[dwNameIndex] = TRUE;
		}

		// Next
		pdwLength++;
		pidProp++;
	}

	// Invalidate entries that we haven't initialized
	for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++)
		if (!fIsInitialized[i])
		{
			pRcptItem->faNameOffset[i] = (FLAT_ADDRESS)NULL;
			pRcptItem->dwNameLength[i] = 0;
			pRcptItem->idName[i] = 0;
		}

    // build up the hash keys
    for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++) {
        pItem->rgHashKeys[i].pbKey = (BYTE *) pRcptItem->faNameOffset[i];
        pItem->rgHashKeys[i].cKey = pRcptItem->dwNameLength[i];
    }

	*ppItem = pItem;
    m_dwAllocated++;

	TraceFunctLeave();
	return(S_OK);

Cleanup:

	m_cmaAccess.FreeBlock(pItem);
	return(hrRes);
}

inline static HRESULT MapLKtoHR(LK_RETCODE rc ) {
    switch (rc) {
        case LK_SUCCESS:
            return S_OK;
        case LK_UNUSABLE:
            return HRESULT_FROM_WIN32(ERROR_FILE_CORRUPT);
        case LK_ALLOC_FAIL:
            return E_OUTOFMEMORY;
        case LK_BAD_ITERATOR:
            return E_INVALIDARG;
        case LK_BAD_RECORD:
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        case LK_KEY_EXISTS:
            return HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
        case LK_NO_SUCH_KEY:
            return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        case LK_NO_MORE_ELEMENTS:
            return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        default:
            _ASSERT(FALSE);
            return E_FAIL;
    }
}

HRESULT CRecipientsHash::InsertHashRecord(
                DWORD                           dwIndex,
                LPRECIPIENTS_PROPERTY_ITEM_EX   pRecipientItem,
                bool                            fOverwrite)
{
    HRESULT hr = S_OK;
    LK_RETCODE rc = LK_SUCCESS;

    switch (dwIndex) {
        case 0:
            rc = m_hashEntries0.InsertRecord(pRecipientItem, fOverwrite);
            break;
        case 1:
            rc = m_hashEntries1.InsertRecord(pRecipientItem, fOverwrite);
            break;
        case 2:
            rc = m_hashEntries2.InsertRecord(pRecipientItem, fOverwrite);
            break;
        case 3:
            rc = m_hashEntries3.InsertRecord(pRecipientItem, fOverwrite);
            break;
        case 4:
            rc = m_hashEntries4.InsertRecord(pRecipientItem, fOverwrite);
            break;
        default:
            _ASSERT(FALSE);
            hr = E_INVALIDARG;
            break;
    }

    if (rc != LK_SUCCESS) hr = MapLKtoHR(rc);

    return hr;
}

HRESULT CRecipientsHash::FindHashRecord(
                DWORD                               dwIndex,
                RECIPIENTS_PROPERTY_ITEM_HASHKEY    *pKey,
                LPRECIPIENTS_PROPERTY_ITEM_EX       *ppRecipientItem)
{
    HRESULT hr = S_OK;
    LK_RETCODE rc = LK_SUCCESS;

    switch (dwIndex) {
        case 0:
            rc = m_hashEntries0.FindKey(pKey, ppRecipientItem);
            break;
        case 1:
            rc = m_hashEntries1.FindKey(pKey, ppRecipientItem);
            break;
        case 2:
            rc = m_hashEntries2.FindKey(pKey, ppRecipientItem);
            break;
        case 3:
            rc = m_hashEntries3.FindKey(pKey, ppRecipientItem);
            break;
        case 4:
            rc = m_hashEntries4.FindKey(pKey, ppRecipientItem);
            break;
        default:
            _ASSERT(FALSE);
            hr = E_INVALIDARG;
            break;
    }

    if (rc != LK_SUCCESS) hr = MapLKtoHR(rc);

    return hr;
}

HRESULT CRecipientsHash::DeleteHashRecord(
                DWORD                           dwIndex,
                LPRECIPIENTS_PROPERTY_ITEM_EX   pRecipientItem)
{
    HRESULT hr = S_OK;
    LK_RETCODE rc = LK_SUCCESS;

    switch (dwIndex) {
        case 0:
            rc = m_hashEntries0.DeleteRecord(pRecipientItem);
            break;
        case 1:
            rc = m_hashEntries1.DeleteRecord(pRecipientItem);
            break;
        case 2:
            rc = m_hashEntries2.DeleteRecord(pRecipientItem);
            break;
        case 3:
            rc = m_hashEntries3.DeleteRecord(pRecipientItem);
            break;
        case 4:
            rc = m_hashEntries4.DeleteRecord(pRecipientItem);
            break;
        default:
            _ASSERT(FALSE);
            hr = E_INVALIDARG;
            break;
    }

    if (rc != LK_SUCCESS) hr = MapLKtoHR(rc);

    return hr;
}

HRESULT CRecipientsHash::AddRecipient(
				DWORD		dwCount,
				LPCSTR		*ppszNames,
				PROP_ID		*pidProp,
				DWORD		*pdwIndex,
                bool    	fPrimary
				)
{
    TraceFunctEnter("CRecipientsHash::AddRecipient");

	DWORD							rgdwNameIndex[MAX_COLLISION_HASH_KEYS];
	HRESULT							hrRes = S_OK;
	LPRECIPIENTS_PROPERTY_ITEM_EX	pItem = NULL;
	DWORD							dwNameIndex;
	DWORD							i;
	BOOL							fCollided = FALSE;

	if (!dwCount || (dwCount > MAX_COLLISION_HASH_KEYS))
	{
        TraceFunctLeave();
		return(E_INVALIDARG);
	}

	// Allocate and setup the recipient record
	hrRes = AllocateAndPrepareRecipientsItem(
					dwCount,
					rgdwNameIndex,
					ppszNames,
					pidProp,
					&pItem);
	if (!SUCCEEDED(hrRes)) {
        TraceFunctLeave();
		return(hrRes);
    }

    // do a lookup to see if there is another recipient with the
    // same record
    for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++) {

        if (pItem->rpiRecipient.faNameOffset[i] != 0) {
			LPRECIPIENTS_PROPERTY_ITEM_EX pConflictingItem = NULL;
			hrRes = FindHashRecord(i, &(pItem->rgHashKeys[i]), &pConflictingItem);
		
            if (hrRes == S_OK) {
	            _ASSERT(pConflictingItem != NULL);
				fCollided = TRUE;

				if (fPrimary) {
					// we have to do this so that we don't find the
                    // colliding recipient in the list of recipients.
					pConflictingItem->rpiRecipient.dwFlags |=
                        FLAG_RECIPIENT_DO_NOT_DELIVER;

				} else if (!(pConflictingItem->rpiRecipient.dwFlags &
                           FLAG_RECIPIENT_NO_NAME_COLLISIONS))
                {
                    // bail out - this conflict cannot be overwritten
                    DebugTrace((LPARAM)this, "Collision detected");
				    CRecipientsHashTable<0>::AddRefRecord(pConflictingItem, -1);
                    m_cmaAccess.FreeBlock(pItem);
                    m_dwAllocated--;
                    *pdwIndex = 0;
                    TraceFunctLeave();
                    return MAILMSG_E_DUPLICATE;
                }

				// update the conflicting item's reference count
				CRecipientsHashTable<0>::AddRefRecord(pConflictingItem, -1);
			} else if (hrRes != HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
                // we can return another error when we are low on memory
                m_cmaAccess.FreeBlock(pItem);
                m_dwAllocated--;
                DebugTrace((LPARAM) this, "FindHashRecord returned 0x%x", hrRes);
                TraceFunctLeave();
		        return(hrRes);
            }
		}
    }

    //
    // At this point of time the Insert into the hash tables cannot fail
    // due to a collision. Either there is no collision, or we are allowed
    // to overwrite all collisions. Therefore fOverwrite (3rd param to
    // InsertHashRecord) is TRUE.
    //

    for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++) {
		if (pItem->rpiRecipient.faNameOffset[i] != 0) {

		    hrRes = InsertHashRecord(i, pItem, TRUE);
			if (FAILED(hrRes)) {
                m_cmaAccess.FreeBlock(pItem);
                m_dwAllocated--;
				DebugTrace((DWORD_PTR) this,
					        "InsertHashRecord failed with 0x%x",
						    hrRes);
				TraceFunctLeave();
				return hrRes;
			}
        }
    }
    // Add it to the recipients list
    pItem->pNextInList = m_pListHead;
    m_pListHead = pItem;

	if (!fCollided) {
		// update our counter
		m_dwRecipientCount++;
	}

	// Append this recipient to the index-recipient ptr map
    m_rwLockQuickList.ExclusiveLock();
	hrRes = m_qlMap.HrAppendItem(pItem, pdwIndex);
    m_rwLockQuickList.ExclusiveUnlock();
	if (FAILED(hrRes)) {
	 // revert m_pListHead and free pItem
        m_pListHead = pItem->pNextInList;
        m_cmaAccess.FreeBlock(pItem);
        m_dwAllocated--;
		DebugTrace((DWORD_PTR) this,
					"HrAppendItem failed with 0x%x",
					hrRes);
		TraceFunctLeave();
		return hrRes;
	}

	// Obfuscate the index so that it is not used as an index
	*pdwIndex = ObfuscateIndex(*pdwIndex);

    //
    // Three return codes:
    // fPrimary && fCollided -> S_FALSE
    // !fPrimary && fCollided -> S_OK (collision detection must be turned off)
    // !fCollided -> S_OK
    // Note that MAILMSG_E_DUPLICATE is returned above, when we detect a collision
    // on a secondary recipient (and collision detection isn't flipped off).
    //
    TraceFunctLeave();
	return (fCollided ? (fPrimary ? S_FALSE : S_OK) : S_OK);
}

HRESULT CRecipientsHash::RemoveRecipient(
			DWORD		dwIndex
			)
{
	LPRECIPIENTS_PROPERTY_ITEM_EX	pItem 		= NULL;
	HRESULT							hrRes = S_OK;

	// Recover index that we obfuscated before handing it to the client
	dwIndex = RecoverIndex(dwIndex);

	// Get a pointer to the recipient from the passed in index
    m_rwLockQuickList.ShareLock();
    pItem = (LPRECIPIENTS_PROPERTY_ITEM_EX)m_qlMap.pvGetItem(dwIndex, &m_pvMapContext);
    m_rwLockQuickList.ShareUnlock();

	if (!pItem)
		return(E_POINTER);

	if (pItem->dwSignature != RECIPIENTS_PROPERTY_ITEM_EX_SIG)
		return(E_POINTER);

	// mark it as don't deliver and no name collisions
	pItem->rpiRecipient.dwFlags |= FLAG_RECIPIENT_DO_NOT_DELIVER;
	pItem->rpiRecipient.dwFlags |= FLAG_RECIPIENT_NO_NAME_COLLISIONS;

    // Remove this entry from the hashtable
    DWORD i;
    HRESULT hr;
    for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++) {
        LPCSTR szKey = (LPCSTR) pItem->rpiRecipient.faNameOffset[i];
        if (szKey) {
            hr = DeleteHashRecord(i, pItem);
            // this should never fail
            _ASSERT(SUCCEEDED(hr));
        }
    }

    //
    // Why we don't remove the recipient from the QuickList map:
    //     m_rwLockQuickList.ExclusiveLock();
    //     pItem = (LPRECIPIENTS_PROPERTY_ITEM_EX)m_qlMap.pvDeleteItem(dwIndex, &m_pvMapContext);
    //     m_rwLockQuickList.ExclusiveUnlock();
    //
    // This changes the indexes we have already allocated, since CQuickList tries to
    // compact any unused entries in it's internal table.
    //

	return(S_OK);
}

HRESULT CRecipientsHash::GetRecipient(
			DWORD							dwIndex,
			LPRECIPIENTS_PROPERTY_ITEM_EX	*ppRecipient
			)
{
	// Recover index that we obfuscated before handing it to the client
	dwIndex = RecoverIndex(dwIndex);

	// Get a pointer to the recipient from the passed in index
    m_rwLockQuickList.ShareLock();
    *ppRecipient = (LPRECIPIENTS_PROPERTY_ITEM_EX)m_qlMap.pvGetItem(dwIndex, &m_pvMapContext);
    m_rwLockQuickList.ShareUnlock();

   	if (!(*ppRecipient))
		return(E_POINTER);

	return(S_OK);
}

HRESULT CRecipientsHash::BuildDomainListFromHash(CMailMsgRecipientsAdd *pList)
{
	HRESULT							hrRes = S_OK;
	LPRECIPIENTS_PROPERTY_ITEM_EX	pItem;
	DWORD							dwTemp;
	char							*pbDomain;
	static char						szDefaultDomain = '\0';

	TraceFunctEnterEx((LPARAM)this,
			"CRecipientsHash::BuildDomainListFromHash");

	// This is strictly single-threaded
	m_rwLock.ExclusiveLock();

	// Destroy the domain list
	ReleaseDomainList();

	// Reset all counters
	m_dwDomainCount = 0;
	m_dwRecipientCount = 0;
	m_dwDomainNameSize = 0;

	// Walk the entire list of recipients, then for each recipient, if the
	// recipient has an SMTP address, we group it by domain, otherwise, we
	// just throw it into an "empty" domain
	pItem = m_pListHead;
	while (pItem)
	{
		// We will skip the item if it's marked as don't deliver
		if ((pItem->rpiRecipient.dwFlags & FLAG_RECIPIENT_DO_NOT_DELIVER) == 0)
		{
            // see if there is a domain property
            char szDomain[1024];
            char *pszDomain = szDomain;
            DWORD cDomain = sizeof(szDomain);

            do {
    		    hrRes = pList->GetPropertyInternal(pItem,
    					                   IMMPID_RP_DOMAIN,
    					                   cDomain,
    					                   &cDomain,
    					                   (BYTE *) pszDomain);
                if (hrRes == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
                    HRESULT hrAlloc;
                    // we should never reach this point twice in a row
                    _ASSERT(pszDomain == szDomain);
                    hrAlloc = m_cmaAccess.AllocBlock((LPVOID *) &pszDomain,
                                                     cDomain);
                    if (FAILED(hrAlloc)) {
                        hrRes = E_OUTOFMEMORY;
                        goto cleanup;
                    }
                }
            } while (hrRes == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

			// We will group if it has an SMTP name
            if (SUCCEEDED(hrRes)) {
                pbDomain = pszDomain;
            } else if (pItem->rpiRecipient.faNameOffset[AT_SMTP]) {
				// We get the name, and then extract its domain
				DebugTrace((LPARAM)this, "  Name: %s",
					(LPBYTE)pItem->rpiRecipient.faNameOffset[AT_SMTP]);

				if (!Get821AddressDomain(
								(char *)pItem->rpiRecipient.faNameOffset[AT_SMTP],
								pItem->rpiRecipient.dwNameLength[AT_SMTP],
								&pbDomain))
				{
					// The address is invalid! This should not happen at this point
					_ASSERT(FALSE);
					ErrorTrace((LPARAM)this, "Failed to extract domain!");
					hrRes = HRESULT_FROM_WIN32(GetLastError());
                    // if we got here then there was no IMMPID_RP_DOMAIN
                    // record, so pszDomain shouldn't have been allocated
                    _ASSERT(pszDomain == szDomain);
					goto cleanup;
				}
                if (pbDomain == NULL) pbDomain = &szDefaultDomain;
			} else {
				// No SMTP name, we throuw it into our generic domain
				pbDomain = &szDefaultDomain;
			}

			// Got the domain, insert this item into the domain list
			DebugTrace((LPARAM)this, "  Domain: %s", pbDomain);
			hrRes = InsertRecipientIntoDomainList(pItem, (LPCSTR) pbDomain);

            // if we had to allocate memory to look up the domain record
            // then free it at this point
            if (pszDomain != szDomain) {
                m_cmaAccess.FreeBlock((LPVOID *) &pszDomain);
                pszDomain = szDomain;
            }

			if (!SUCCEEDED(hrRes))
			{
				ErrorTrace((LPARAM)this, "Failed to insert recipient into domain list!");
				goto cleanup;
			}

			// Also adjust the recipient name size counter
			for (dwTemp = 0; dwTemp < MAX_COLLISION_HASH_KEYS; dwTemp++)
				if (pItem->rpiRecipient.faNameOffset[dwTemp] != (FLAT_ADDRESS)NULL)
					m_dwRecipientNameSize += pItem->rpiRecipient.dwNameLength[dwTemp];
		}

		// OK, next item!
		pItem = pItem->pNextInList;
	}

cleanup:

	m_rwLock.ExclusiveUnlock();

	TraceFunctLeave();
	return(hrRes);
}

HRESULT CRecipientsHash::GetDomainCount(
			DWORD					*pdwCount
			)
{
	if (!pdwCount) return E_POINTER;
	*pdwCount = m_dwDomainCount;
	return(S_OK);
}

HRESULT CRecipientsHash::GetRecipientCount(
			DWORD					*pdwCount
			)
{
	if (!pdwCount) return E_POINTER;
	*pdwCount = m_dwRecipientCount;
	return(S_OK);
}

HRESULT CRecipientsHash::GetDomainNameSize(
			DWORD					*pdwSize
			)
{
	if (!pdwSize) return E_POINTER;
	*pdwSize = m_dwDomainNameSize;
	return(S_OK);
}

HRESULT CRecipientsHash::GetRecipientNameSize(
			DWORD					*pdwSize
			)
{
	if (!pdwSize) return E_POINTER;
	*pdwSize = m_dwRecipientNameSize;
	return(S_OK);
}

HRESULT CRecipientsHash::GetFirstDomain(
			LPDOMAIN_ITEM_CONTEXT			pContext,
			LPRECIPIENTS_PROPERTY_ITEM_EX	*ppFirstItem,
            LPDOMAIN_LIST_ENTRY             *ppDomainListEntry
			)
{
	HRESULT	hrRes = S_OK;

	if (!pContext) return E_POINTER;
	if (!ppFirstItem) return E_POINTER;

	TraceFunctEnterEx((LPARAM)this,
			"CRecipientsHash::GetFirstDomain");

    LK_RETCODE lkrc;

    lkrc = m_hashDomains.InitializeIterator(pContext);
    if (lkrc == LK_SUCCESS) {
        DOMAIN_LIST_ENTRY *pDomainListEntry = pContext->Record();
        _ASSERT(pDomainListEntry != NULL);
        if (ppDomainListEntry) *ppDomainListEntry = pDomainListEntry;
        *ppFirstItem = pDomainListEntry->pFirstDomainMember;
    } else {
        hrRes = MapLKtoHR(lkrc);
    	lkrc = m_hashDomains.CloseIterator(pContext);
    	_ASSERT(lkrc == LK_SUCCESS);
    }

	TraceFunctLeave();
	return(hrRes);
}

HRESULT CRecipientsHash::GetNextDomain(
			LPDOMAIN_ITEM_CONTEXT			pContext,
			LPRECIPIENTS_PROPERTY_ITEM_EX	*ppFirstItem,
            LPDOMAIN_LIST_ENTRY             *ppDomainListEntry
			)
{
	HRESULT				hrRes		= S_OK;
	DWORD				dwBucket	= 0;
	LPDOMAIN_LIST_ENTRY	pDomain;

	if (!pContext || !ppFirstItem) return E_POINTER;

	TraceFunctEnterEx((LPARAM)this,
			"CRecipientsHash::GetNextDomain");

    LK_RETCODE lkrc;
    lkrc = m_hashDomains.IncrementIterator(pContext);
    if (lkrc != LK_SUCCESS) {
        hrRes = MapLKtoHR(lkrc);
        lkrc = m_hashDomains.CloseIterator(pContext);
        _ASSERT(lkrc == LK_SUCCESS);
    } else {
        DOMAIN_LIST_ENTRY *pDomainListEntry = pContext->Record();
        _ASSERT(pDomainListEntry != NULL);
        if (ppDomainListEntry) *ppDomainListEntry = pDomainListEntry;
        *ppFirstItem = pDomainListEntry->pFirstDomainMember;
    }

	TraceFunctLeave();
	return(hrRes);
}

HRESULT CRecipientsHash::CloseDomainContext(
			LPDOMAIN_ITEM_CONTEXT			pContext)
{
	HRESULT				hrRes		= S_OK;
	DWORD				dwBucket	= 0;
	LPDOMAIN_LIST_ENTRY	pDomain;

	if (!pContext) return E_POINTER;

	TraceFunctEnterEx((LPARAM)this,
			"CRecipientsHash::CloseDomainContext");

    LK_RETCODE lkrc;
    lkrc = m_hashDomains.CloseIterator(pContext);
    hrRes = MapLKtoHR(lkrc);

	TraceFunctLeave();
	return(hrRes);
}


// Method to compare two items
inline HRESULT CRecipientsHash::CompareEntries(
			DWORD							dwNameIndex,
			LPRECIPIENTS_PROPERTY_ITEM_EX	pItem1,
			LPRECIPIENTS_PROPERTY_ITEM_EX	pItem2
			)
{
	int	iRes;

	_ASSERT(dwNameIndex < MAX_COLLISION_HASH_KEYS);
	iRes = lstrcmpi((LPCSTR)(pItem1->rpiRecipient.faNameOffset[dwNameIndex]),
					(LPCSTR)(pItem2->rpiRecipient.faNameOffset[dwNameIndex]));
	return((!iRes)?MAILMSG_E_DUPLICATE:S_OK);
}


// Method to walk a sinlge hash chain and look for a collision
HRESULT CRecipientsHash::DetectCollision(
			DWORD							dwNameIndex,
			LPRECIPIENTS_PROPERTY_ITEM_EX	pStartingItem,
			LPRECIPIENTS_PROPERTY_ITEM_EX	pRecipientItem,
			LPRECIPIENTS_PROPERTY_ITEM_EX	*ppCollisionItem
			)
{
	HRESULT							hrRes = S_OK;
	LPRECIPIENTS_PROPERTY_ITEM_EX	pItem;

	_ASSERT(dwNameIndex < MAX_COLLISION_HASH_KEYS);
	_ASSERT(pRecipientItem);
	_ASSERT(ppCollisionItem);

	// If the name is not specified, we return no collision
	if (!pRecipientItem->rpiRecipient.dwNameLength[dwNameIndex])
		return(S_OK);

	// Initialize
	*ppCollisionItem = NULL;

	pItem = pStartingItem;
	while (pItem)
	{
		// Skip if it has the no name collisions bit set
		if (!(pItem->rpiRecipient.dwFlags & FLAG_RECIPIENT_NO_NAME_COLLISIONS))
		{
			// Loop until the end of the open chain
			hrRes = CompareEntries(dwNameIndex, pRecipientItem, pItem);
			if (!SUCCEEDED(hrRes))
			{
				_ASSERT(hrRes != E_FAIL);

				// The item is found, return the colliding item
				*ppCollisionItem = pItem;
				return(hrRes);
			}
		}

		// Next item in chain ...
		pItem = pItem->pNextHashEntry[dwNameIndex];
	}

	return(S_OK);
}

#ifdef DEADCODE
// Method to insert an entry into the hash bucket
inline HRESULT CRecipientsHash::InsertRecipientIntoHash(
			DWORD							dwCount,
			DWORD							*pdwNameIndex,
			DWORD							*rgdwBucket,
			LPRECIPIENTS_PROPERTY_ITEM_EX	pRecipientItem
			)
{
	DWORD	dwNameIndex;
	DWORD	i;

	_ASSERT(pRecipientItem);

	for (i = 0; i < dwCount; i++)
		if (rgdwBucket[pdwNameIndex[i]] >= COLLISION_HASH_BUCKETS)
		{
			return(E_INVALIDARG);
		}

	for (i = 0; i < dwCount; i++)
	{
		dwNameIndex = pdwNameIndex[i];

		// Fill in the links in the item only if a name is specified
		if (pRecipientItem->rpiRecipient.faNameOffset[dwNameIndex] != (FLAT_ADDRESS)NULL)
		{
			// Hook up the new node
			pRecipientItem->pNextHashEntry[dwNameIndex] =
					m_rgEntries[rgdwBucket[dwNameIndex]].pFirstEntry[dwNameIndex];
			m_rgEntries[rgdwBucket[dwNameIndex]].pFirstEntry[dwNameIndex] = pRecipientItem;
		}
	}

	pRecipientItem->pNextInDomain = NULL;

	// Bump the counter
	m_dwRecipientCount++;

	// Add it to the recipients list
	pRecipientItem->pNextInList = m_pListHead;
	m_pListHead = pRecipientItem;

#ifdef DEBUG
	m_dwAllocated++;
#endif

	return(S_OK);
}
#endif

inline HRESULT CRecipientsHash::InsertRecipientIntoDomainList(
			LPRECIPIENTS_PROPERTY_ITEM_EX	pItem,
            LPCSTR                          szDomain
			)
{
	HRESULT						hrRes = S_OK;
	LPDOMAIN_LIST_ENTRY			pDomain;
    LK_RETCODE                  lkrc;
    DWORD                       dwDomainLength = lstrlen(szDomain) + 1;

	if (!pItem) return E_POINTER;

	TraceFunctEnterEx((LPARAM)this,
			"CRecipientsHash::InsertRecipientIntoDomainList");

    lkrc = m_hashDomains.FindKey(szDomain, &pDomain);
    if (lkrc == LK_SUCCESS) {
		// Found a match, insert it
		DebugTrace((LPARAM)this, "Inserting to existing domain record");
		pItem->pNextInDomain = pDomain->pFirstDomainMember;
		pDomain->pFirstDomainMember = pItem;

        // update our reference count
        CDomainHashTable::AddRefRecord(pDomain, -1);

		// Update stats.
		m_dwRecipientCount++;
		m_dwDomainNameSize += dwDomainLength;

		return(S_OK);
    }

	// No match, create a new domain item
	DebugTrace((LPARAM)this, "Creating new domain record for %s", szDomain);
	hrRes = m_cmaAccess.AllocBlock(
				(LPVOID *)&pDomain,
				sizeof(DOMAIN_LIST_ENTRY) + dwDomainLength);
	if (!SUCCEEDED(hrRes))
		return(hrRes);

	// fill in the domain record
	pItem->pNextInDomain = NULL;
    pDomain->m_cRefs = 0;
    pDomain->m_pcmaAccess = &m_cmaAccess;
	pDomain->pFirstDomainMember = pItem;
	pDomain->dwDomainNameLength = dwDomainLength;
	lstrcpy(pDomain->szDomainName, (LPCSTR)szDomain);

    // insert the new domain into the domain hash table
    lkrc = m_hashDomains.InsertRecord(pDomain, FALSE);
    if (lkrc != LK_SUCCESS) {
        DebugTrace((LPARAM) this,
                   "Inserting domain %s into m_hashDomains failed with %lu",
                   szDomain, lkrc);
        hrRes = MapLKtoHR(lkrc);
        m_cmaAccess.FreeBlock(pDomain);
        return hrRes;
    }

	// Hook up the recipient in the domain
	pItem->pNextInDomain = NULL;
	pDomain->pFirstDomainMember = pItem;
	pDomain->dwDomainNameLength = dwDomainLength;
	lstrcpy(pDomain->szDomainName, (LPCSTR)szDomain);

	// Update stats.
	m_dwDomainCount++;
	m_dwRecipientCount++;
	m_dwDomainNameSize += dwDomainLength;

	TraceFunctLeave();
	return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\cmailmsg.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cmailmsg.cpp

Abstract:

    This module contains the implementation of the mail message class

Author:

    Keith Lau   (keithlau@microsoft.com)

Revision History:

    keithlau    03/10/98    created

--*/

#pragma warning (error : 4032)
#pragma warning (error : 4057)
//#define WIN32_LEAN_AND_MEAN
#include "atq.h"
#include <stddef.h>

#include "dbgtrace.h"
#include "signatur.h"
#include "cmmtypes.h"
#include "cmailmsg.h"
#include <malloc.h>

// Flags to turn on CRC checking for debugging corrupt messages
extern DWORD g_fValidateOnForkForRecipients;
extern DWORD g_fValidateOnRelease;

// =================================================================
// Private Definitions
//

#define CMAILMSG_VERSION_HIGH                   ((WORD)1)
#define CMAILMSG_VERSION_LOW                    ((WORD)0)



// =================================================================
// Static declarations
//
CPool CMailMsgRecipientsAdd::m_Pool((DWORD)'pAMv');

long CMailMsg::g_cOpenContentHandles = 0;
long CMailMsg::g_cOpenStreamHandles = 0;
long CMailMsg::g_cTotalUsageCount = 0;
long CMailMsg::g_cTotalReleaseUsageCalls = 0;
long CMailMsg::g_cTotalReleaseUsageNonZero = 0;
long CMailMsg::g_cTotalReleaseUsageCloseStream = 0;
long CMailMsg::g_cTotalReleaseUsageCloseContent = 0;
long CMailMsg::g_cTotalReleaseUsageCloseFail = 0;
long CMailMsg::g_cTotalReleaseUsageCommitFail = 0;
long CMailMsg::g_cTotalReleaseUsageNothingToClose = 0;
long CMailMsg::g_cTotalExternalReleaseUsageZero = 0;
long CMailMsg::g_cCurrentMsgsClosedByExternalReleaseUsage = 0;

//
// Specific property table instance info for this type of property table
//
const MASTER_HEADER CMailMsg::s_DefaultHeader =
{
    // Header stuff
    CMAILMSG_SIGNATURE_VALID,
    CMAILMSG_VERSION_HIGH,
    CMAILMSG_VERSION_LOW,
    sizeof(MASTER_HEADER),

    // Global property table instance info
    {
        GLOBAL_PTABLE_INSTANCE_SIGNATURE_VALID,
        INVALID_FLAT_ADDRESS,
        GLOBAL_PROPERTY_TABLE_FRAGMENT_SIZE,
        GLOBAL_PROPERTY_ITEM_BITS,
        GLOBAL_PROPERTY_ITEM_SIZE,
        0,
        INVALID_FLAT_ADDRESS
    },

    // Recipients table instance info
    {
        RECIPIENTS_PTABLE_INSTANCE_SIGNATURE_VALID,
        INVALID_FLAT_ADDRESS,
        RECIPIENTS_PROPERTY_TABLE_FRAGMENT_SIZE,
        RECIPIENTS_PROPERTY_ITEM_BITS,
        RECIPIENTS_PROPERTY_ITEM_SIZE,
        0,
        INVALID_FLAT_ADDRESS
    },

    // Property management table instance info
    {
        PROPID_MGMT_PTABLE_INSTANCE_SIGNATURE_VALID,
        INVALID_FLAT_ADDRESS,
        PROPID_MGMT_PROPERTY_TABLE_FRAGMENT_SIZE,
        PROPID_MGMT_PROPERTY_ITEM_BITS,
        PROPID_MGMT_PROPERTY_ITEM_SIZE,
        0,
        IMMPID_CP_START
    }

};


//
// Well-known global properties
//
INTERNAL_PROPERTY_ITEM
                *const CMailMsg::s_pWellKnownProperties = NULL;
const DWORD     CMailMsg::s_dwWellKnownProperties = 0;


// =================================================================
// Compare function
//

HRESULT CMailMsg::CompareProperty(
            LPVOID          pvPropKey,
            LPPROPERTY_ITEM pItem
            )
{
    if (*(PROP_ID *)pvPropKey == ((LPGLOBAL_PROPERTY_ITEM)pItem)->idProp)
        return(S_OK);
    return(STG_E_UNKNOWN);
}


// =================================================================
// Implementation of CMailMsg
//
CMailMsg::CMailMsg() :
    CMailMsgPropertyManagement(
                &m_bmBlockManager,
                &(m_Header.ptiPropertyMgmt)
                ),
    CMailMsgRecipients(
                &m_bmBlockManager,
                &(m_Header.ptiRecipients)
                ),
    m_ptProperties(
                PTT_PROPERTY_TABLE,
                GLOBAL_PTABLE_INSTANCE_SIGNATURE_VALID,
                &m_bmBlockManager,
                &(m_Header.ptiGlobalProperties),
                CompareProperty,
                s_pWellKnownProperties,
                s_dwWellKnownProperties
                ),
    m_SpecialPropertyTable(
                &g_SpecialMessagePropertyTable
                ),

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4355)

    m_bmBlockManager(
                this,
                (CBlockManagerGetStream *)this
                )

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4355)
#endif

{
    m_ulUsageCount = 0;
    m_ulRecipientCount = 0;
    m_pbStoreDriverHandle = NULL;
    m_dwStoreDriverHandle = 0;
    m_cContentFile = 0xffffffff;
    m_fCommitCalled = FALSE;
    m_fDeleted = FALSE;
    m_cCloseOnExternalReleaseUsage = 0;

    // Copy the default master header into our instance
    MoveMemory(&m_Header, &s_DefaultHeader, sizeof(MASTER_HEADER));

    m_dwCreationFlags = 0;

    // Initialize our members.
    m_hContentFile          = NULL;
    m_pStream               = NULL;
    m_pStore                = NULL;
    m_pvClientContext       = NULL;
    m_pfnCompletion         = NULL;
    m_dwTimeout             = INFINITE;
    m_pDefaultRebindStoreDriver = NULL;
    m_dwGlobalCrc           = 0;
    m_dwRecipsCrc           = 0;
    InitializeListHead(&m_leAQueueListEntry);
}

void CMailMsg::FinalRelease()
{
#ifdef MAILMSG_FORCE_RELEASE_USAGE_BEFORE_FINAL_RELEASE
    // Make sure the usage count is already zero
    // If this assert fires, someone is still holding a usage count
    // to the object without a reference count
    _ASSERT(m_ulUsageCount == 0);
#endif //MAILMSG_FORCE_RELEASE_USAGE_BEFORE_FINAL_RELEASE
    InternalReleaseUsage(RELEASE_USAGE_FINAL_RELEASE);

    // Invalidate the master header
    m_Header.dwSignature = CMAILMSG_SIGNATURE_INVALID;

    if (m_cCloseOnExternalReleaseUsage)
        InterlockedDecrement(&g_cCurrentMsgsClosedByExternalReleaseUsage);

    // Free the store driver handle blob, if allocated
    if (m_pbStoreDriverHandle)
    {
        CMemoryAccess   cmaAccess;
        if (!SUCCEEDED(cmaAccess.FreeBlock(m_pbStoreDriverHandle)))
        {
            _ASSERT(FALSE);
        }
        m_pbStoreDriverHandle = NULL;
    }
}

CMailMsg::~CMailMsg()
{
    //
    // In normal usage CMailMsg::FinalRelease() should be called.  This is
    // here for legacy unit tests which don't use that interface.
    //
    if (m_Header.dwSignature != CMAILMSG_SIGNATURE_INVALID) {
        FinalRelease();
    }
}

HRESULT CMailMsg::Initialize()
{
    HRESULT         hrRes       = S_OK;
    FLAT_ADDRESS    faOffset;
    DWORD           dwSize;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::Initialize");

    // On initialize, we would have to allocate sufficient memory for
    // our master header.

    DebugTrace((LPARAM)this,
                "Allocating memory for master header");
    hrRes = m_bmBlockManager.AllocateMemory(
                    sizeof(MASTER_HEADER),
                    &faOffset,
                    &dwSize,
                    NULL);
    if (!SUCCEEDED(hrRes))
        return(hrRes);

    // Note that we don't have to write this to flat memory until we are
    // asked to commit, so we defer that write

    // Nobody should have allocated memory before Initialize is called.
    _ASSERT(faOffset == (FLAT_ADDRESS)0);

    TraceFunctLeave();
    return(hrRes);
}

HRESULT CMailMsg::QueryBlockManager(
            CBlockManager   **ppBlockManager
            )
{
    if (!ppBlockManager)
        return(STG_E_INVALIDPARAMETER);
    *ppBlockManager = &m_bmBlockManager;
    return(S_OK);
}


// =================================================================
// Implementation of IMailMsgProperties
//

HRESULT STDMETHODCALLTYPE CMailMsg::PutProperty(
            DWORD   dwPropID,
            DWORD   cbLength,
            LPBYTE  pbValue
            )
{
    HRESULT                 hrRes = S_OK;
    GLOBAL_PROPERTY_ITEM    piItem;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::PutProperty");

    DebugTrace((LPARAM) this,
               "PutProperty(%x, %x, %x)",
               dwPropID,
               cbLength,
               pbValue);

    // Handle special properties first
    hrRes = m_SpecialPropertyTable.PutProperty(
                (PROP_ID)dwPropID,
                (LPVOID)this,
                NULL,
                PT_NONE,
                cbLength,
                pbValue,
                TRUE);
    if (SUCCEEDED(hrRes) && (hrRes != S_OK))
    {
        piItem.idProp = dwPropID;
        hrRes = m_ptProperties.PutProperty(
                        (LPVOID)&dwPropID,
                        (LPPROPERTY_ITEM)&piItem,
                        cbLength,
                        pbValue);
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::GetProperty(
            DWORD   dwPropID,
            DWORD   cbLength,
            DWORD   *pcbLength,
            LPBYTE  pbValue
            )
{
    HRESULT                 hrRes = S_OK;
    GLOBAL_PROPERTY_ITEM    piItem;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::GetProperty");

    // Special properties are optimized
    // Handle special properties first
    hrRes = m_SpecialPropertyTable.GetProperty(
                (PROP_ID)dwPropID,
                (LPVOID)this,
                NULL,
                PT_NONE,
                cbLength,
                pcbLength,
                pbValue,
                TRUE);
    if (SUCCEEDED(hrRes) && (hrRes != S_OK))
    {
        hrRes = m_ptProperties.GetPropertyItemAndValue(
                        (LPVOID)&dwPropID,
                        (LPPROPERTY_ITEM)&piItem,
                        cbLength,
                        pcbLength,
                        pbValue);
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::Commit(
            IMailMsgNotify  *pNotify
            )
{
    HRESULT hrRes = S_OK;
    IMailMsgCommit *pSDCommit = NULL;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::Commit");

    // We are doing a global commit, this means several things:
    // 0) Commit the content
    // 1) Commit all global properties
    // 2) Commit all recipients and per-recipient properties
    // 3) Commit PROP ID management information
    // 4) Commit the master header

    // Make sure we have a content handle
    hrRes = RestoreResourcesIfNecessary(FALSE, TRUE);
    if (!SUCCEEDED(hrRes))
        return(hrRes);
    _ASSERT(m_pStream);
    _ASSERT(!m_fDeleted);

    // the commit interface is optional.  get a pointer to it if it is there.
    hrRes = m_pStream->QueryInterface(IID_IMailMsgCommit, (void **) &pSDCommit);
    if (FAILED(hrRes)) {
        pSDCommit = NULL;
        hrRes = S_OK;
    }

    // Flush the content 1st... a valid P1 does us no good without
    // the message content.  If the machine is turned off after
    // we commit the P1, but before the P2 is commited, then we
    // may attempt delivery of corrupt messages
    //      6/2/99 - MikeSwa
    if (pSDCommit) {
        hrRes = pSDCommit->BeginCommit(this, m_pStream, m_hContentFile);
    } else {
        if (m_hContentFile &&
            !FlushFileBuffers(m_hContentFile->m_hFile))
        {
            m_bmBlockManager.SetDirty(TRUE);
            hrRes = HRESULT_FROM_WIN32(GetLastError());
            if (SUCCEEDED(hrRes))
                hrRes = E_FAIL;
        }
    }

    if (SUCCEEDED(hrRes))
    {
#ifdef DEBUG
        MASTER_HEADER MasterHeaderOrig;
        memcpy(&MasterHeaderOrig, &m_Header, sizeof(MASTER_HEADER));
#endif

        hrRes = m_bmBlockManager.AtomicWriteAndIncrement(
                        (LPBYTE)&m_Header,
                        (FLAT_ADDRESS)0,
                        sizeof(MASTER_HEADER),
                        NULL,
                        0,
                        0,
                        NULL);
        if (SUCCEEDED(hrRes))
        {
            m_bmBlockManager.SetDirty(FALSE);
            hrRes = GetProperties(m_pStream, MAILMSG_GETPROPS_MARKCOMMIT |
                                             MAILMSG_GETPROPS_COMPLETE, NULL);
            if (FAILED(hrRes)) {
                m_bmBlockManager.SetCommitMode(FALSE);
                m_bmBlockManager.SetDirty(TRUE);
            }
        }

#ifdef DEBUG
        // verify that none of the global state changed during the commit
        _ASSERT(memcmp(&MasterHeaderOrig, &m_Header, sizeof(MASTER_HEADER)) == 0);
#endif
    }

    // finalize the commit if they have the optional commit interface
    if (pSDCommit && SUCCEEDED(hrRes)) {
        hrRes = pSDCommit->EndCommit(this, m_pStream, m_hContentFile);
    }

    if (SUCCEEDED(hrRes)) {
        m_fCommitCalled = TRUE;
        _ASSERT(!(m_bmBlockManager.IsDirty()));
    } else {
        _ASSERT(m_bmBlockManager.IsDirty());
    }
    m_bmBlockManager.SetCommitMode(FALSE);

    if (pSDCommit) {
        pSDCommit->Release();
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::GetContentSize(
            DWORD           *pdwSize,
            IMailMsgNotify  *pNotify
            )
{
    HRESULT hrRes = S_OK;
    DWORD   dwHigh;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::GetContentSize");

    if (!pdwSize) return E_POINTER;

    // Make sure we have a content handle
    hrRes = RestoreResourcesIfNecessary();
    if (!SUCCEEDED(hrRes))
        return(hrRes);
    _ASSERT(m_hContentFile != NULL);

    if (m_cContentFile == 0xffffffff) {
        // Call WIN32
        *pdwSize = GetFileSizeFromContext(m_hContentFile, &dwHigh);

        // If the size is more than 32 bits, barf.
        if (*pdwSize == 0xffffffff)
            hrRes = HRESULT_FROM_WIN32(GetLastError());
        else if (dwHigh)
            hrRes = HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

        if (m_fCommitCalled) m_cContentFile = *pdwSize;
    } else {
        // m_cContentFile should only be saved after Commit has been
        // called.  Otherwise the size of the file could be changed
        // by the store writing to the content file.
        _ASSERT(m_fCommitCalled);
        *pdwSize = m_cContentFile;
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::SetContentSize(
            DWORD           dwSize,
            IMailMsgNotify  *pNotify
            )
{
    HRESULT hrRes = S_OK;
    DWORD   dwHigh;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::GetContentSize");

    // make sure that the store supports writeable content
    hrRes = m_pStore->SupportWriteContent();
    _ASSERT(SUCCEEDED(hrRes));
    if (hrRes != S_OK) {
        return((hrRes == S_FALSE) ? HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) : hrRes);
    }

    // Make sure we have a content handle
    hrRes = RestoreResourcesIfNecessary();
    if (!SUCCEEDED(hrRes))
        return(hrRes);
    _ASSERT(m_hContentFile != NULL);

    // set the file size
    if (SetFilePointer(m_hContentFile->m_hFile, dwSize, 0, FILE_BEGIN) == 0xffffffff)
        return HRESULT_FROM_WIN32(GetLastError());

    // set end of file
    if (!SetEndOfFile(m_hContentFile->m_hFile))
        return HRESULT_FROM_WIN32(GetLastError());

    // reset the content size so the next GetContentSize will get an updated value.
    m_cContentFile = 0xffffffff;

    m_dwCreationFlags |= MPV_WRITE_CONTENT;

    TraceFunctLeave();
    return(hrRes);
}

HRESULT DummyAsyncReadOrWriteFile(
            BOOL            fRead,
            PFIO_CONTEXT    pFIO,
            HANDLE          hEvent,
            DWORD           dwOffset,
            DWORD           dwLength,
            DWORD           *pdwLength,
            BYTE            *pbBlock
            )
{
    BOOL            fRet;
    HRESULT         hrRes       = S_OK;
    FH_OVERLAPPED   ol;

    TraceFunctEnter("::DummyAsyncReadOrWriteFile");

    // Set up the overlapped structure
    ol.Internal     = 0;
    ol.InternalHigh = 0;
    ol.Offset       = dwOffset;
    ol.OffsetHigh   = 0;

    //There is no way to accurately tell if a handle is associated with an
    //ATQ context... until we standardize on how async writes are
    //happening, we will force synchonous writes by setting the low
    //bits (previously we waited for completion anyway).
    ol.hEvent       = (HANDLE) (((DWORD_PTR)hEvent) | 0x00000001);
    ol.pfnCompletion = NULL;

    // Deals with both synchronous and async read/Write
    if (fRead)
        fRet = FIOReadFile(
                    pFIO,
                    pbBlock,
                    dwLength,
                    &ol);
    else
        fRet = FIOWriteFile(
                    pFIO,
                    pbBlock,
                    dwLength,
                    &ol);
    DWORD dwError;
    if (fRet) {
        dwError = ERROR_IO_PENDING;
    } else {
        dwError = GetLastError();
    }

    if (dwError != ERROR_IO_PENDING) {
        hrRes = HRESULT_FROM_WIN32(dwError);
    } else {
        // Async, wait on the event to complete
        dwError = WaitForSingleObject(hEvent, INFINITE);
        _ASSERT(dwError == WAIT_OBJECT_0);

        if (!GetOverlappedResult(
                    pFIO->m_hFile,
                    (OVERLAPPED *) &ol,
                    pdwLength,
                    FALSE))
        {
            hrRes = HRESULT_FROM_WIN32(GetLastError());
            if (hrRes == S_OK)
                hrRes = E_FAIL;

            DebugTrace((LPARAM)&ol, "GetOverlappedResult failed tih %08x", hrRes);
        }
    }

    // The caller would have to make sure the bytes read/written
    // is the same as requested. This is consistent with NT ReadFile

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::ReadContent(
            DWORD           dwOffset,
            DWORD           dwLength,
            DWORD           *pdwLength,
            BYTE            *pbBlock,
            IMailMsgNotify  *pNotify
            )
{
    HRESULT hrRes       = S_OK;
    HANDLE  hEvent      = NULL;

    if (!pdwLength || !pbBlock) return E_POINTER;
    if (dwLength == 0) return E_INVALIDARG;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::ReadContent");

    if (!m_pStore) return E_ACCESSDENIED;

    // Make sure we have a content handle
    hrRes = RestoreResourcesIfNecessary();
    if (!SUCCEEDED(hrRes))
        return(hrRes);
    _ASSERT(m_hContentFile != NULL);

    // Set up the event just to feign asynchronous operations
    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!hEvent)
        hrRes = HRESULT_FROM_WIN32(GetLastError());
    else
    {
        // Call our own dummy function for now
        hrRes = DummyAsyncReadOrWriteFile(
                    TRUE,
                    m_hContentFile,
                    hEvent,
                    dwOffset,
                    dwLength,
                    pdwLength,
                    pbBlock);

        if (!CloseHandle(hEvent)) { _ASSERT((GetLastError() == NO_ERROR) && FALSE); }
    }

    // Call the async completion routine
    if (pNotify)
        hrRes = pNotify->Notify(hrRes);

    TraceFunctLeave();
    //
    // When we move to the real async model, make sure we
    // return MAILMSG_S_PENDING instead of S_OK
    //
    return(pNotify?S_OK:hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::WriteContent(
            DWORD           dwOffset,
            DWORD           dwLength,
            DWORD           *pdwLength,
            BYTE            *pbBlock,
            IMailMsgNotify  *pNotify
            )
{
    HRESULT hrRes       = S_OK;
    HANDLE  hEvent      = NULL;

    if (!pdwLength || !pbBlock) return E_POINTER;
    if (dwLength == 0) return E_INVALIDARG;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::WriteContent");

    if (!m_pStore) return E_ACCESSDENIED;

    // Make sure we have a content handle
    hrRes = RestoreResourcesIfNecessary();
    if (!SUCCEEDED(hrRes))
        return(hrRes);
    _ASSERT(m_hContentFile != NULL);

    // see if the driver allows writable content
    hrRes = m_pStore->SupportWriteContent();
    _ASSERT(SUCCEEDED(hrRes));
    if (hrRes != S_OK) {
        return((hrRes == S_FALSE) ? HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) : hrRes);
    }

    // Set up the event just to feign asynchronous operations
    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!hEvent)
        hrRes = HRESULT_FROM_WIN32(GetLastError());
    else
    {
        m_cContentFile = 0xffffffff;

        // Call our own dummy function for now
        hrRes = DummyAsyncReadOrWriteFile(
                    FALSE,
                    m_hContentFile,
                    hEvent,
                    dwOffset,
                    dwLength,
                    pdwLength,
                    pbBlock);

        if (!CloseHandle(hEvent)) { _ASSERT((GetLastError() == NO_ERROR) && FALSE); }
    }

    if (SUCCEEDED(hrRes)) m_dwCreationFlags |= MPV_WRITE_CONTENT;

    // Call the async completion routine
    if (pNotify)
        hrRes = pNotify->Notify(hrRes);

    TraceFunctLeave();
    //
    // When we move to the real async model, make sure we
    // return MAILMSG_S_PENDING instead of S_OK
    //
    return(pNotify?S_OK:hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::CopyContentToFile(
            PFIO_CONTEXT    hCopy,
            IMailMsgNotify  *pNotify
            )
{
    HRESULT hrRes = S_OK;

    if (!hCopy) return E_POINTER;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::CopyContentToFile");

    hrRes = CopyContentToStreamOrFile(
                FALSE,
                hCopy,
                pNotify, 0);

    TraceFunctLeave();
    return(hrRes);
}

#if 0
HRESULT STDMETHODCALLTYPE CMailMsg::CopyContentToFile(
            PFIO_CONTEXT    hCopy,
            IMailMsgNotify  *pNotify
            )
{
    return CopyContentToFileEx(hCopy, FALSE, pNotify);
}
#endif

HRESULT STDMETHODCALLTYPE CMailMsg::CopyContentToFileEx(
            PFIO_CONTEXT    hCopy,
            BOOL            fDotStuffed,
            IMailMsgNotify  *pNotify
            )
{
    HRESULT hrRes = S_OK;

    if (!hCopy) return E_POINTER;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::CopyContentToFile");

    BOOL fModified;

    if (!ProduceDotStuffedContextInContext(m_hContentFile,
                                           hCopy,
                                           fDotStuffed,
                                           &fModified))
    {
        hrRes = HRESULT_FROM_WIN32(GetLastError());
        _ASSERT(hrRes != S_OK);
        if (hrRes == S_OK) hrRes = E_FAIL;
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::CopyContentToStream(
            IMailMsgPropertyStream  *pStream,
            IMailMsgNotify          *pNotify
            )
{
    HRESULT hrRes = S_OK;

    if (!pStream) return E_POINTER;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::CopyContentToStream");

    hrRes = CopyContentToStreamOrFile(
                TRUE,
                (LPVOID)pStream,
                pNotify, 0);

    TraceFunctLeave();
    return(hrRes);
}

//Copies the content of an IMailMsg to a file starting at the given
//offset (used for embedding and attaching messages).
HRESULT STDMETHODCALLTYPE CMailMsg::CopyContentToFileAtOffset(
                PFIO_CONTEXT    hCopy,  //handle to copy to
                DWORD           dwOffset, //offset to start copy at
                IMailMsgNotify  *pNotify  //notification routing
                )
{
    HRESULT hrRes = S_OK;

    if (!hCopy) return E_POINTER;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::CopyContentToFileAtOffset");

    hrRes = CopyContentToStreamOrFile(
                FALSE,
                hCopy,
                pNotify, dwOffset);

    TraceFunctLeave();
    return(hrRes);
}

HRESULT CMailMsg::CopyContentToStreamOrFile(
            BOOL            fIsStream,
            LPVOID          pStreamOrHandle,
            IMailMsgNotify  *pNotify,
            DWORD           dwDestOffset //offset to start at in dest file
            )
{
    HRESULT hrRes       = S_OK;
    BYTE    bBuffer[64 * 1024];
    LPBYTE  pbBuffer    = bBuffer;;
    DWORD   dwCurrent   = dwDestOffset;
    DWORD   dwRemaining = 0;
    DWORD   dwCopy      = 0;
    DWORD   dwOffset    = 0;
    DWORD   dwCopied;
    HANDLE  hEvent      = NULL;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::CopyContentToStreamOrFile");

    // Parameter checking
    if (!pStreamOrHandle) return STG_E_INVALIDPARAMETER;

    // Make sure we have a content handle
    hrRes = RestoreResourcesIfNecessary();
    if (!SUCCEEDED(hrRes))
        return(hrRes);
    _ASSERT(m_hContentFile != NULL);

    // Copy in fixed size chunks
    hrRes = GetContentSize(&dwRemaining, pNotify);
    if (!SUCCEEDED(hrRes))
        goto Cleanup;

    // Set up the event just to feign asynchronous operations
    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!hEvent)
    {
        hrRes = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    while (dwRemaining)
    {
        dwCopy = sizeof(bBuffer);
        if (dwRemaining < dwCopy)
            dwCopy = dwRemaining;

        // Read content
        hrRes = DummyAsyncReadOrWriteFile(
                    TRUE,
                    m_hContentFile,
                    hEvent,
                    dwOffset,
                    dwCopy,
                    &dwCopied,
                    bBuffer);
        if (SUCCEEDED(hrRes))
        {
            // Write content
            if (fIsStream)
            {
                IMailMsgPropertyStream  *pStream;
                pStream = (IMailMsgPropertyStream *)pStreamOrHandle;

                hrRes = pStream->WriteBlocks(
                            this,
                            1,
                            &dwCurrent,
                            &dwCopy,
                            &pbBuffer,
                            pNotify);
                dwCurrent += dwCopy;
            }
            else
            {
                hrRes = DummyAsyncReadOrWriteFile(
                            FALSE,
                            (PFIO_CONTEXT) pStreamOrHandle,
                            hEvent,
                            dwOffset + dwDestOffset,
                            dwCopy,
                            &dwCopied,
                            bBuffer);
            }

            if (!SUCCEEDED(hrRes))
                break;
        }
        else
            break;

        dwRemaining -= dwCopy;
        dwOffset += dwCopy;
    }

    // Call the async completion routine if provided
    if (pNotify)
        pNotify->Notify(hrRes);

Cleanup:

    if (hEvent)
        if (!CloseHandle(hEvent)) { _ASSERT((GetLastError() == NO_ERROR) && FALSE); }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::MapContent(
                BOOL            fWrite,
                BYTE            **ppbContent,
                DWORD           *pcContent
                )
{
    TraceFunctEnter("CMailMsg::MapContent");

    HANDLE hFileMapping;
    HRESULT hr;

    //
    // Make sure that we are allowed to write to the file if they want
    // write access
    //
    if (fWrite) {
        hr = m_pStore->SupportWriteContent();
        _ASSERT(SUCCEEDED(hr));
        if (hr != S_OK) {
            return((hr == S_FALSE) ?
                        HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) : hr);
        }
    }

    //
    // Make sure we have a content handle
    //
    hr = RestoreResourcesIfNecessary();
    if (!SUCCEEDED(hr)) {
        ErrorTrace((LPARAM) this, "RestoreResourcesIfNecessary returned %x", hr);
        TraceFunctLeave();
        return(hr);
    }
    _ASSERT(m_hContentFile != NULL);

    //
    // Get the size of the file
    //
    hr = GetContentSize(pcContent, NULL);
    if (!SUCCEEDED(hr)) {
        ErrorTrace((LPARAM) this, "GetContentSize returned %x", hr);
        TraceFunctLeave();
        return(hr);
    }

    //
    // Create the file mapping
    //
    hFileMapping = CreateFileMapping(m_hContentFile->m_hFile,
                                     NULL,
                                     (fWrite) ? PAGE_READWRITE : PAGE_READONLY,
                                     0,
                                     0,
                                     NULL);
    if (hFileMapping == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) this, "MapContent failed with 0x%x", hr);
        TraceFunctLeave();
        return hr;
    }

    //
    // Map the file into memory
    //
    *ppbContent = (BYTE *) MapViewOfFile(hFileMapping,
                                         (fWrite) ?
                                            FILE_MAP_WRITE : FILE_MAP_READ,
                                         0,
                                         0,
                                         0);
    // don't need the mapping handle now
    CloseHandle(hFileMapping);
    if (*ppbContent == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) this, "MapViewOfFile failed with 0x%x", hr);
    } else {
        DebugTrace((LPARAM) this,
                   "MapContent succeeded, *ppbContent = 0x%x, *pcContent = %i",
                   *ppbContent,
                   *pcContent);
        hr = S_OK;
    }

    if (fWrite && SUCCEEDED(hr)) m_dwCreationFlags |= MPV_WRITE_CONTENT;

    TraceFunctLeave();
    return hr;
}

HRESULT STDMETHODCALLTYPE CMailMsg::UnmapContent(BYTE *pbContent) {
    TraceFunctEnter("CMailMsg::UnmapContent");

    HRESULT hr = S_OK;

    DebugTrace((LPARAM) this, "pbContent = 0x%x", pbContent);

    //
    // Just call the Win32 API to unmap the content
    //
    if (!UnmapViewOfFile(pbContent)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) this, "UnmapViewOfFile returned %x", hr);
    }

    TraceFunctLeave();
    return hr;
}

HRESULT CMailMsg::ValidateProperties(CBlockManager *pBM,
                                     DWORD cStream,
                                     PROPERTY_TABLE_INSTANCE *pti)
{
    TraceFunctEnter("CMailMsg::ValidateProperties");

    DWORD dwItemBits;
    DWORD dwItemSize;
    DWORD dwFragmentSize;
    HRESULT hr;

    //
    // Validate that all of the property table entries are valid.
    //
    switch(pti->dwSignature) {
        case GLOBAL_PTABLE_INSTANCE_SIGNATURE_VALID:
            DebugTrace((LPARAM) this, "Global property table");
            dwItemBits = GLOBAL_PROPERTY_ITEM_BITS;
            dwItemSize = GLOBAL_PROPERTY_ITEM_SIZE;
            dwFragmentSize = GLOBAL_PROPERTY_TABLE_FRAGMENT_SIZE;
            break;
        case RECIPIENTS_PTABLE_INSTANCE_SIGNATURE_VALID:
            DebugTrace((LPARAM) this, "Recipients property table");
            dwItemSize = RECIPIENTS_PROPERTY_ITEM_SIZE;
            // these two values are changed during writelist, so we
            // can't count on their values being consistent.  Setting
            // them to 0 tells the code below to skip the check
            dwItemBits = 0;
            dwFragmentSize = 0;
            break;
        case RECIPIENT_PTABLE_INSTANCE_SIGNATURE_VALID:
            DebugTrace((LPARAM) this, "Recipient property table");
            dwItemBits = RECIPIENT_PROPERTY_ITEM_BITS;
            dwItemSize = RECIPIENT_PROPERTY_ITEM_SIZE;
            dwFragmentSize = RECIPIENT_PROPERTY_TABLE_FRAGMENT_SIZE;
            break;
        case PROPID_MGMT_PTABLE_INSTANCE_SIGNATURE_VALID:
            DebugTrace((LPARAM) this, "PropID Mgmt property table");
            dwItemBits = PROPID_MGMT_PROPERTY_ITEM_BITS;
            dwItemSize = PROPID_MGMT_PROPERTY_ITEM_SIZE;
            dwFragmentSize = PROPID_MGMT_PROPERTY_TABLE_FRAGMENT_SIZE;
            break;
        default:
            DebugTrace((LPARAM) this, "Signature 0x%x isn't valid for CMM",
                pti->dwSignature);
            TraceFunctLeave();
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    //
    // check all of the fields in the property table instance header.
    // note that some property tables abuse the fields and we have to
    // allow them:
    //   recipients property table doesn't have a fragment size or item bits
    //   property management table uses faExtendedInfo as an arbitrary DWORD,
    //     not a flat address
    //
    if ((pti->dwFragmentSize != dwFragmentSize && dwFragmentSize != 0) ||
        (pti->dwItemBits != dwItemBits && dwItemBits != 0) ||
         pti->dwItemSize != dwItemSize ||
         !ValidateFA(pti->faFirstFragment, dwFragmentSize, cStream, TRUE) ||
         (!ValidateFA(pti->faExtendedInfo, dwFragmentSize, cStream, TRUE) &&
          pti->dwSignature != PROPID_MGMT_PTABLE_INSTANCE_SIGNATURE_VALID))
    {
        DebugTrace((LPARAM) this, "Invalid property table");
        TraceFunctLeave();
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    // Walk each of the fragments and make sure they point to valid data
    FLAT_ADDRESS faFragment = pti->faFirstFragment;
    PROPERTY_TABLE_FRAGMENT ptf;
    while (faFragment != INVALID_FLAT_ADDRESS) {
        if (!ValidateFA(faFragment, sizeof(PROPERTY_TABLE_FRAGMENT), cStream)) {
            DebugTrace((LPARAM) this, "Invalid property table");
            TraceFunctLeave();
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        DWORD cRead;
        hr = pBM->ReadMemory((BYTE *) &ptf,
                             faFragment,
                             sizeof(PROPERTY_TABLE_FRAGMENT),
                             &cRead,
                             NULL);
        if (FAILED(hr) ||
            cRead != sizeof(PROPERTY_TABLE_FRAGMENT) ||
            ptf.dwSignature != PROPERTY_FRAGMENT_SIGNATURE_VALID)
        {
            DebugTrace((LPARAM) this, "Couldn't read fragment at 0x%x",
                faFragment);
            TraceFunctLeave();
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        faFragment = ptf.faNextFragment;
    }

    //
    // The recipients ptable and propid-mgmt-ptable are cannot be enumerated
    // the same way as the global ptable, so we skip the enumeration. The
    // recipient ptable prop-items are actually enumerated in ValidateStream
    // using ValidateRecipient
    //

    if(pti->dwSignature == RECIPIENTS_PTABLE_INSTANCE_SIGNATURE_VALID ||
       pti->dwSignature == PROPID_MGMT_PTABLE_INSTANCE_SIGNATURE_VALID) {
        return S_OK;
    }

    //
    // construct the property table
    //
    CPropertyTable pt(PTT_PROPERTY_TABLE,
                      pti->dwSignature,
                      pBM,
                      pti,
                      CompareProperty,
                      NULL,
                      NULL);
    DWORD i, cProperties;
    union {
        PROPERTY_ITEM pi;
        GLOBAL_PROPERTY_ITEM gpi;
        RECIPIENT_PROPERTY_ITEM rpi;
        RECIPIENTS_PROPERTY_ITEM rspi;
        PROPID_MGMT_PROPERTY_ITEM pmpi;
    } pi;


    // get the count of properties
    hr = pt.GetCount(&cProperties);
    if (FAILED(hr)) {
        DebugTrace((LPARAM) this, "GetCount returned 0x%x", hr);
        TraceFunctLeave();
        return hr;
    }

    // walk the properties and make sure that they point to valid addresses
    for (i = 0; i < cProperties; i++) {
        DWORD c;
        BYTE b;
        hr = pt.GetPropertyItemAndValueUsingIndex(
                i,
                (PROPERTY_ITEM *) &pi,
                1,
                &c,
                &b);
        // we just want the size, so it is okay if the buffer is too small
        if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) hr = S_OK;
        if (FAILED(hr)) {
            DebugTrace((LPARAM) this,
                "GetPropertyItemAndValueUsingIndex returned 0x%x", hr);
            TraceFunctLeave();
            return hr;
        }

		// check the location of the property value to make sure that it is
		// valid.  We don't need to do this for properties in the recipients
		// table because they contain property tables rather then
		// property values.  the property table will be checked by
		// ValidateRecipient
        if (pti->dwSignature != RECIPIENTS_PTABLE_INSTANCE_SIGNATURE_VALID) {
            if (!(pi.pi.dwSize <= pi.pi.dwMaxSize &&
                  ValidateFA(pi.pi.faOffset, pi.pi.dwMaxSize, cStream, TRUE)))
            {
                DebugTrace((LPARAM) this, "Property points to invalid data", hr);
                TraceFunctLeave();
                return hr;
            }
        }
    }

    return S_OK;
}

HRESULT CMailMsg::ValidateRecipient(CBlockManager *pBM,
                                     DWORD cStream,
                                     RECIPIENTS_PROPERTY_ITEM *prspi)
{
    TraceFunctEnter("CMailMsg::ValidateRecipient");

    DWORD i, cAddresses = 0;
    HRESULT hr;

    // validate the rspi
    if (prspi->ptiInstanceInfo.dwSignature !=
            RECIPIENT_PTABLE_INSTANCE_SIGNATURE_VALID)
    {
        DebugTrace((LPARAM) this, "rspi invalid");
        TraceFunctLeave();
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }


    // validate the recipient names
    for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++) {
        if (prspi->faNameOffset[i] != INVALID_FLAT_ADDRESS) {
            cAddresses++;

            // check the offset and length
            if (!ValidateFA(prspi->faNameOffset[i],
                            prspi->dwNameLength[i],
                            cStream))
            {
                DebugTrace((LPARAM) this, "address offset and length invalid");
                TraceFunctLeave();
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            // check the property id
            if (prspi->idName[i] != IMMPID_RP_ADDRESS_SMTP &&
                prspi->idName[i] != IMMPID_RP_ADDRESS_X400 &&
                prspi->idName[i] != IMMPID_RP_ADDRESS_X500 &&
                prspi->idName[i] != IMMPID_RP_LEGACY_EX_DN &&
                prspi->idName[i] != IMMPID_RP_ADDRESS_OTHER)
            {
                DebugTrace((LPARAM) this, "prop id %lu is invalid",
                    prspi->idName[i]);
                TraceFunctLeave();
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            // the 2nd-to-last character should be non-0, the last should be 0
            BYTE szTail[2];
            DWORD cTail;
            hr = pBM->ReadMemory(szTail,
                                 prspi->faNameOffset[i] +
                                    prspi->dwNameLength[i] - 2,
                                 2,
                                 &cTail,
                                 NULL);
            if (FAILED(hr)) {
                DebugTrace((LPARAM) this, "ReadMemory returned 0x%x", hr);
                TraceFunctLeave();
                return hr;
            }

            if (szTail[0] == 0 || szTail[1] != 0) {
                DebugTrace((LPARAM) this, "Recipient address %i is invalid", i);
                TraceFunctLeave();
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }
        }
    }
    if (cAddresses == 0) {
        DebugTrace((LPARAM) this, "No valid addresses for recipient");
        TraceFunctLeave();
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    // now check each of the recipient properties
    return ValidateProperties(pBM, cStream, &(prspi->ptiInstanceInfo));
}

//
// This is only used for the validation functions.
//
class CDumpMsgGetStream : public CBlockManagerGetStream {
    public:
        CDumpMsgGetStream(IMailMsgPropertyStream *pStream = NULL) {
            SetStream(pStream);
        }

        void SetStream(IMailMsgPropertyStream *pStream) {
            m_pStream = pStream;
        }

        virtual HRESULT GetStream(IMailMsgPropertyStream **ppStream,
                                  BOOL fLockAcquired)
        {
            *ppStream = m_pStream;
            return S_OK;
        }

    private:
        IMailMsgPropertyStream *m_pStream;
};

HRESULT STDMETHODCALLTYPE CMailMsg::ValidateStream(
                                IMailMsgPropertyStream *pStream)
{
    TraceFunctEnter("CMailMsg::ValidateStream");

    CDumpMsgGetStream bmGetStream(pStream);
    CBlockManager bm(NULL, &bmGetStream);
    DWORD cStream, cHeader;
    HRESULT hr;
    MASTER_HEADER header;

    if (!pStream) {
        ErrorTrace((LPARAM) this, 
            "Error, NULL stream passed to ValidateStream");
        TraceFunctLeave();
        return E_POINTER;
    }

    // get the size of the stream
    hr = pStream->GetSize(NULL, &cStream, NULL);
    if (FAILED(hr)) {
        DebugTrace((LPARAM) this, "GetSize returned 0x%x", hr);
        TraceFunctLeave();
        return hr;
    }

    bm.SetStreamSize(cStream);

    // read the master header
    hr = bm.ReadMemory((BYTE *) &header,
                       0,
                       sizeof(MASTER_HEADER),
                       &cHeader,
                       NULL);
    if (FAILED(hr) || cHeader != sizeof(MASTER_HEADER)) {
        DebugTrace((LPARAM) this, "couldn't read master header, 0x%x", hr);
        TraceFunctLeave();
        return hr;
    }

    // examine the master header
    if (header.dwSignature != CMAILMSG_SIGNATURE_VALID ||
        header.dwHeaderSize != sizeof(MASTER_HEADER) ||
        header.ptiGlobalProperties.dwSignature !=
            GLOBAL_PTABLE_INSTANCE_SIGNATURE_VALID ||
        header.ptiRecipients.dwSignature !=
            RECIPIENTS_PTABLE_INSTANCE_SIGNATURE_VALID ||
        header.ptiPropertyMgmt.dwSignature !=
            PROPID_MGMT_PTABLE_INSTANCE_SIGNATURE_VALID)
    {
        DebugTrace((LPARAM) this, "header invalid");
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        return hr;
    }

    // check each property in the three property tables
    hr = ValidateProperties(&bm, cStream, &(header.ptiGlobalProperties));
    if (FAILED(hr)) {
        DebugTrace((LPARAM) this, "global property table invalid");
        return hr;
    }
    hr = ValidateProperties(&bm, cStream, &(header.ptiRecipients));
    if (FAILED(hr)) {
        DebugTrace((LPARAM) this, "recipients property table invalid");
        return hr;
    }
    hr = ValidateProperties(&bm, cStream, &(header.ptiPropertyMgmt));
    if (FAILED(hr)) {
        DebugTrace((LPARAM) this, "propid property table invalid");
        return hr;
    }

    // get each recipient and check its properties
    CPropertyTableItem ptiItem(&bm, &(header.ptiRecipients));
    DWORD iRecip = 0;
    RECIPIENTS_PROPERTY_ITEM rspi;
    hr = ptiItem.GetItemAtIndex(iRecip, (PROPERTY_ITEM *) &rspi, NULL);
    while (SUCCEEDED(hr)) {
        hr = ValidateRecipient(&bm, cStream, &rspi);
        if (FAILED(hr)) {
            DebugTrace((LPARAM) this, "recipient %i invalid", iRecip);
        } else {
            hr = ptiItem.GetNextItem((PROPERTY_ITEM *) &rspi);
        }
    }

    // if we just ran out of items then everything is okay
    if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
        hr = S_OK;
    }

    TraceFunctLeave();
    return hr;
}

HRESULT STDMETHODCALLTYPE CMailMsg::ValidateContext()
{
    TraceFunctEnter("CMailMsg::ValidateContext");

	HRESULT 							hr = S_OK;
	IMailMsgStoreDriverValidateContext 	*pIStoreDriverValidateContext = NULL;
    BYTE    							pbContext[1024];
    DWORD   							cbContext = sizeof(pbContext);

    if (m_fDeleted) 
    {
        DebugTrace((LPARAM) this, 
            "Calling ValidateContext on deleted message");
        hr  = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Exit;
    }

	// Get the validation interface off our store driver
    hr = m_pStore->QueryInterface(
                IID_IMailMsgStoreDriverValidateContext,
                (LPVOID *)&pIStoreDriverValidateContext);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) m_pStore,
            "Unable to QI for IMailMsgStoreDriverValidateContext 0x%08X",hr);
        goto Exit;
    }

	// Call in to driver to validate
    hr = GetProperty(IMMPID_MPV_STORE_DRIVER_HANDLE,
                                    sizeof(pbContext), &cbContext, pbContext);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "GetProperty failed with 0x%08X", hr);
        goto Exit;
    }

    hr = pIStoreDriverValidateContext->ValidateMessageContext(pbContext,
                                                              cbContext);
    DebugTrace((LPARAM) pIStoreDriverValidateContext,
    	"ValidateMessageContext returned 0x%08X", hr);

  Exit:

    // RELEASE
    if (pIStoreDriverValidateContext)
        pIStoreDriverValidateContext->Release();

    TraceFunctLeave();
    return hr;
}

HRESULT CMailMsg::AddMgmtFragment(CBlockManager   *pBlockManager, FLAT_ADDRESS faOffset,  FLAT_ADDRESS *pfaToUpdate)
/*++

Routine Description:

    Allocate and copy the Mgmt fragments.
    This function recursively calls itself to process all linked fragments.
    pfaToUpdate is passed in. This address will be updated with the new FLAT_ADDRESS allocated.

Arguments:

    CMailMsg *pCMsg, pointer to target CMailMsg
    FLAT_ADDRESS faOffset: offset of fragment for source CMailMsg (*this)
    FLAT_ADDRESS *pfaToUpdate: pointer to FLAT_ADDRESS to update with new allocated FLAT_ADDRESS on target (pCMsg)

Return Value:

    HRESULT:
    S_OK if successful.

--*/
{
    HRESULT hrRes = S_OK;
    FLAT_ADDRESS faOffsetAllocated, *pfaNext;
    DWORD dwAllocated, dwBytesRead, dwBytesWritten;
    BYTE szBuffer[PROPID_MGMT_PROPERTY_TABLE_FRAGMENT_SIZE];
    

    hrRes = pBlockManager->AllocateMemory(
                PROPID_MGMT_PROPERTY_TABLE_FRAGMENT_SIZE,
                &faOffsetAllocated,
                &dwAllocated, NULL);
    if (!SUCCEEDED(hrRes)) goto Exit;
    
    hrRes = m_bmBlockManager.ReadMemory( szBuffer, faOffset, PROPID_MGMT_PROPERTY_TABLE_FRAGMENT_SIZE, &dwBytesRead, NULL);
    if (!SUCCEEDED(hrRes)) goto Exit;
    
    pfaNext = &(((PROPERTY_TABLE_FRAGMENT *)szBuffer)->faNextFragment);
    if ( INVALID_FLAT_ADDRESS != *pfaNext )
    {
        hrRes = AddMgmtFragment(pBlockManager, *pfaNext, pfaNext);
        if (!SUCCEEDED(hrRes)) goto Exit; 
    }
    hrRes = pBlockManager->WriteMemory(szBuffer, faOffsetAllocated, dwBytesRead, &dwBytesWritten, NULL);
    if (!SUCCEEDED(hrRes)) goto Exit;
    
    *pfaToUpdate = faOffsetAllocated ;

Exit:
    return hrRes;
}


HRESULT STDMETHODCALLTYPE CMailMsg::ForkForRecipients(
            IMailMsgProperties      **ppNewMessage,
            IMailMsgRecipientsAdd   **ppRecipients
            )
{
    HRESULT         hrRes = S_OK;
    FLAT_ADDRESS    faOffset;
    DWORD           dwSize;

    IMailMsgProperties      *pMsg   = NULL;
    IMailMsgRecipientsAdd   *pAdd   = NULL;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::ForkForRecipients");

    if (!ppNewMessage ||
        !ppRecipients)
        return(STG_E_INVALIDPARAMETER);

    // This is a really crude implementation, but would work
    // nonetheless.
    //
    // What we do is create a new instance of IMailMsgProperties,
    // then replicate the entire property stream (including the
    // recipients), then marking the recipients as void. Then we
    // also create a new Recipient Add list to go with it.
    hrRes = CoCreateInstance(
                CLSID_MsgImp,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IMailMsgProperties,
                (LPVOID *)&pMsg);
    if (SUCCEEDED(hrRes))
    {
        CMailMsg        *pCMsg;
        CBlockManager *pBlockManager;

        // Lock the original message
        m_bmBlockManager.WriteLock();

        // Get the underlying CMailMsg object
        pCMsg = (CMailMsg *)pMsg;

        CopyMemory(&(pCMsg->m_Header), &s_DefaultHeader, sizeof(MASTER_HEADER));

        //
        // Copy all global properties to the new pMsg. The enumerator calls
        // CopyProperty for each prop in the global prop table. CopyProperty
        // does PutProperty on pMsg for each property it is called with.
        //

        // Copy the property management table manually
        // First copy the header
        CopyMemory(&(pCMsg->m_Header.ptiPropertyMgmt), &m_Header.ptiPropertyMgmt, sizeof(PROPERTY_TABLE_INSTANCE));
        faOffset = m_Header.ptiPropertyMgmt.faFirstFragment;


        if (PROPID_MGMT_PROPERTY_TABLE_FRAGMENT_SIZE != m_Header.ptiPropertyMgmt.dwFragmentSize )
        {
            hrRes = STG_E_INVALIDPARAMETER;
            goto Exit;
        }

        hrRes = pCMsg->QueryBlockManager(&pBlockManager);
        _ASSERT(SUCCEEDED(hrRes));

        // Copy Mgmt table and update faFirstFragment in header, if the fragment is valid.        
        if ( INVALID_FLAT_ADDRESS != faOffset )
            {
            hrRes = AddMgmtFragment(pBlockManager, faOffset, &(pCMsg->m_Header.ptiPropertyMgmt.faFirstFragment) );
            if(FAILED(hrRes)) {
                ErrorTrace((LPARAM) this, "AddMgmtFragment failed with %x", hrRes);
                _ASSERT(0 && "Failed to copy mgmt properties in Fork");
                goto Exit;
            }
        }
        	
        // Copy Global property table
        hrRes = EnumPropertyTable(
                    &(m_Header.ptiGlobalProperties),
                    CopyPropertyEnumerator,
                    (PVOID) pCMsg);

        // Store a reference to the store driver
        pCMsg->SetDefaultRebindStore(m_pStore);

        if(FAILED(hrRes)) {
            _ASSERT(0 && "Failed to copy properties in Fork");
            goto Exit;
        }

        if(g_fValidateOnForkForRecipients) {
            HRESULT hr = CreateAndVerifyCrc(this, pCMsg);
            if(hr != S_OK) {
                ErrorTrace((LPARAM) this, "Failed to create/verify CRC - %08x", hr);
                ForceCrashIfNeeded();
                hrRes = STG_E_INVALIDPARAMETER;
            }
        }
    }

    //
    // If all is fine, we will create an add interface
    //
    if (SUCCEEDED(hrRes))
    {
        IMailMsgRecipients  *pRcpts = NULL;

        // OK, now we simply create an add interface
        hrRes = pMsg->QueryInterface(
                    IID_IMailMsgRecipients,
                    (LPVOID *)&pRcpts);
        if (SUCCEEDED(hrRes))
        {
            hrRes = pRcpts->AllocNewList(&pAdd);
        }

        pRcpts->Release();
    }

Exit:

    // Release the original message
    m_bmBlockManager.WriteUnlock();

    if (!SUCCEEDED(hrRes))
    {
        // Failed, release our resources
        if (pMsg)
            pMsg->Release();
    }
    else
    {
        // Fill in the output variables
        *ppNewMessage = pMsg;
        *ppRecipients = pAdd;
    }

    TraceFunctLeave();
    return(hrRes);
}

//-----------------------------------------------------------------------------
//  Description:
//      Enumerates a property table instance and calls a user defined function
//      for each property. This function is only to be used when the property
//      property table consists of PROPERTY_ITEMS (i.e. it cannot be used for
//      recipient property tables consisting of RECIPIENTS_PROPERTY_ITEMS).
//  Arguments:
//      IN ptiSource - Property table to enumerate
//      IN pfnEnumerator - Function to call with each property item and value
//      IN pvContext - Custom context to pass into pfnEnumerator
//  Returns:
//      HRESULT - Success or Failure HRESULT. Any failure HRESULTs from
//          pfnEnumerator will cause this function to abort and return that
//          HRESULT.
//-----------------------------------------------------------------------------
HRESULT CMailMsg::EnumPropertyTable(
    LPPROPERTY_TABLE_INSTANCE ptiSource,
    PFNENUMERATOR pfnEnumerator,
    PVOID pvContext)
{
    HRESULT hrRes = E_FAIL;
    DWORD cbAvailable = 0;
    DWORD cbReturned = 0;
    BYTE PropBuf[1024];
    PBYTE pbPropBuf = NULL;
    PBYTE pbTemp = NULL;
    DWORD cProperties = 0;
    PDWORD pdwPropSize = NULL;
    LPPROPERTY_ITEM ppi = NULL;


    TraceFunctEnterEx((LPARAM) this, "CMailMsg::CopyPropertyTable");

    // Sanity check PROPERTY_TABLE_INSTANCE.dwItemSize (should be 10s of bytes).
    if(ptiSource->dwItemSize > 1024) {
        _ASSERT(0 && "Possibly corrupt mailmsg");
        ErrorTrace((LPARAM) this,
            "Possibly corrupt mailmsg, PROPERTY_ITEM_SIZE is %d",
            ptiSource->dwItemSize);
        TraceFunctLeaveEx((LPARAM) this);
        return STG_E_INVALIDPARAMETER;
    }

    ppi = (LPPROPERTY_ITEM)_alloca(ptiSource->dwItemSize);
    pdwPropSize = &(ppi->dwSize);

    CPropertyTable ptSource(
                    PTT_PROPERTY_TABLE,
                    ptiSource->dwSignature,
                    &m_bmBlockManager,
                    ptiSource,
                    CompareProperty,
                    NULL,
                    0);

    hrRes = ptSource.GetCount(&cProperties);
    if (FAILED(hrRes)) {
        DebugTrace((LPARAM) this, "GetCount returned 0x%x", hrRes);
        goto Cleanup;
    }

    pbPropBuf = PropBuf;
    cbAvailable = sizeof(PropBuf);

    //
    // Loop through all properties in this property table and call the
    // enumerator function
    //

    for (DWORD i = 0; i < cProperties; i++) {

        cbReturned = 0;

Retry:
        hrRes = ptSource.GetPropertyItemAndValueUsingIndex(
                                            i,
                                            ppi,
                                            cbAvailable,
                                            &cbReturned,
                                            pbPropBuf);

        //
        // Start with a stack buffer and try to use it for all properties. If
        // we encounter a property that is too big, allocate a buffer off the
        // heap and use it from then on. realloc as needed.
        //

        if(hrRes == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {

            // realloc is the same as malloc if pBuf == NULL
            if(pbPropBuf == PropBuf)
                pbPropBuf = NULL;

            pbTemp = (PBYTE) realloc(pbPropBuf, *pdwPropSize);
            if(!pbTemp)
            {
                hrRes = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                goto Cleanup;
            }
            else
            {
                pbPropBuf = pbTemp;
            }

            cbAvailable = *pdwPropSize;
            goto Retry;
        }

        if (FAILED(hrRes)) {
            DebugTrace((LPARAM) this,
				"GetPropertyItemAndValueUsingIndex returned 0x%x", hrRes);
            goto Cleanup;
        }

        hrRes = pfnEnumerator(
                    ppi,
                    ptiSource->dwItemSize,
                    pbPropBuf,
                    *pdwPropSize,
                    pvContext);

        if(FAILED(hrRes)) {
            ErrorTrace((LPARAM) this, "Failed pfnEnumerator %08x", hrRes);
            goto Cleanup;
        }
    }

Cleanup:
    if(pbPropBuf && pbPropBuf != PropBuf)
        free(pbPropBuf);

    TraceFunctLeaveEx((LPARAM) this);
    return hrRes;
}

//-----------------------------------------------------------------------------
//  Description:
//      This enumeration function is similar to EnumPropertyTable, but it deals
//      with RECIPIENT_PROPERTY_TABLE_INSTANCEs.
//
//      This function calls a user-defined enumerator function and passes it
//      each RECIPIENTS_PROPERTY_ITEM enumerated.
//  Arguments:
//  Returns:
//      HRESULT, success or failure.
//-----------------------------------------------------------------------------
HRESULT CMailMsg::EnumRecipientsPropertyTable(
    PFNRECIPIENTSENUMERATOR pfnRecipientsEnumerator,
    PVOID pvContext
    )
{
    LPRECIPIENTS_PROPERTY_ITEM prpi = NULL;
    CPropertyTableItem pi(&m_bmBlockManager, &(m_Header.ptiRecipients));
    DWORD dwRecipients = 0;
    FLAT_ADDRESS faOffset = INVALID_FLAT_ADDRESS;
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM) this, "CMailMsg::EnumRecipientsPropertyTable");

    // Sanity check PROPERTY_TABLE_INSTANCE.dwItemSize (should be 10s of bytes).
    if((m_Header.ptiRecipients).dwItemSize > 1024) {
        _ASSERT(0 && "Possibly corrupt mailmsg");
        ErrorTrace((LPARAM) this,
            "Possibly corrupt mailmsg, PROPERTY_ITEM_SIZE is %d",
            (m_Header.ptiRecipients).dwItemSize);
        hrRes = STG_E_INVALIDPARAMETER;
    }

    prpi = (LPRECIPIENTS_PROPERTY_ITEM)_alloca((m_Header.ptiRecipients).dwItemSize);
    dwRecipients = (m_Header.ptiRecipients).dwProperties;
    for(DWORD i = 0; i < dwRecipients; i++) {
        hrRes = pi.GetItemAtIndex(i, (LPPROPERTY_ITEM) prpi, &faOffset);
        if(FAILED(hrRes))
            goto Exit;

        hrRes = pfnRecipientsEnumerator(prpi, pvContext);
        if(FAILED(hrRes))
            goto Exit;
    }

Exit:
    TraceFunctLeaveEx((LPARAM) this);
    return hrRes;
}

//-----------------------------------------------------------------------------
//  Description:
//      This function walks the property tables in this CMailMsg and generates
//      checksums based on the property values in each table.
//
//      The global properties are enumerated using EnumPropertyTable and using
//      the enumerator CrcPropTableEnumerator which simply calculates the CRC
//      of each property as it is enumerated and adds it to *pdwCrcGlobal.
//
//      The recipient properties are enumerated by calling EnumRecipients-
//      PropertyTable which calls the enumerator CrcRecipientsPropTable-
//      Enumerator. This calculates the CRC for each of the recipient-addresses
//      in the RECIPIENTS_PROPERTY_ITEMs enumerated, and calls
//      EnumPropertyTable to enumerate the per-recipient property tables.
//
//  Arguments:
//      pdwCrcGlobal - Checksum based on all global properties
//      pdwCrcRecips - Checksum based on all per-recipient properties
//  Returns:
//      HRESULT
//-----------------------------------------------------------------------------
HRESULT CMailMsg::GenerateChecksum(
    PDWORD pdwCrcGlobal,
    PDWORD pdwCrcRecips)
{
    HRESULT hrRes = S_OK;
    CRC_RECIPIENTS_HELPER CrcRecipientsHelper;

    TraceFunctEnterEx((LPARAM) this, "CMailMsg::GenerateChecksum");

    m_bmBlockManager.WriteLock();

    *pdwCrcGlobal = 0;
    *pdwCrcRecips = 0;

    hrRes = EnumPropertyTable(
            &(m_Header.ptiGlobalProperties),
            CrcPropTableEnumerator,
            (PVOID) pdwCrcGlobal);

    if(FAILED(hrRes))
        goto Exit;

    CrcRecipientsHelper.pdwCrc = pdwCrcRecips;
    CrcRecipientsHelper.pMsg = this;

    hrRes = EnumRecipientsPropertyTable(
            CrcRecipientsPropTableEnumerator,
            (PVOID) &CrcRecipientsHelper);

Exit:

    m_bmBlockManager.WriteUnlock();
    TraceFunctLeaveEx((LPARAM) this);
    return hrRes;
}

//-----------------------------------------------------------------------------
//  Description:
//      Enumerator function for the global property table.
//  Arguments:
//      IN pvCrc - Ptr to (accumulated) CRC
//      All other arguments are standard PFNENUMERATOR arguments
//  Returns:
//      HRESULT
//-----------------------------------------------------------------------------
HRESULT CrcPropTableEnumerator(
    LPPROPERTY_ITEM ppi,
    DWORD cbPiSize,
    PBYTE pbProp,
    DWORD cbSize,
    PVOID pvCrc)
{
    PDWORD pdwCrc = PDWORD (pvCrc);
    DWORD dwPropId = ((LPGLOBAL_PROPERTY_ITEM)ppi)->idProp;

    // Don't include the CRC's themselves in computing them!
    if(dwPropId == IMMPID_MP_CRC_GLOBAL || dwPropId == IMMPID_MP_CRC_RECIPS)
        return S_OK;

    *pdwCrc += CRCHash(pbProp, cbSize);
    return S_OK;
}

//-----------------------------------------------------------------------------
//  Description:
//      Enumerator function for the recipient property table.
//  Arguments:
//      IN prpi - The recipients property item being enumerated
//      IN pvCrcHelper - Ptr to CRC_RECIPIENTS_HELPER struct containing ptr to
//          accumulated CRC and mailmsg.
//  Returns:
//      HRESULT
//-----------------------------------------------------------------------------
HRESULT CrcRecipientsPropTableEnumerator(
    LPRECIPIENTS_PROPERTY_ITEM prpi,
    PVOID pvCrcHelper)
{
    CRC_RECIPIENTS_HELPER *pCrcHelper = (CRC_RECIPIENTS_HELPER *) pvCrcHelper;
    PDWORD pdwCrc = pCrcHelper->pdwCrc;
    CMailMsg *pMsg = pCrcHelper->pMsg;
    HRESULT hrRes = S_OK;
    BYTE szAddress[512];
    DWORD dwSize = 0;
    CBlockManager *pbm = NULL;


    TraceFunctEnterEx((LPARAM) 0, "CrcRecipientsPropTableEnumerator");

    // Generate checksum for recipients property item
    (*pdwCrc) += CRCHash((PBYTE) prpi, RECIPIENTS_PROPERTY_ITEM_SIZE);

    hrRes = pMsg->QueryBlockManager(&pbm);

    if(FAILED(hrRes))
        goto Exit;

    // Generate checksums for the recipient addresses
    for(DWORD i = 0; i < MAX_COLLISION_HASH_KEYS; i++) {

        if(prpi->faNameOffset[i] == INVALID_FLAT_ADDRESS)
            continue;

        // Skip overly long recipients to avoid unneccessary complexities in
        // the CRC code
        if(prpi->dwNameLength[i] > sizeof(szAddress))
            continue;

        dwSize = sizeof(szAddress);
        hrRes = pbm->ReadMemory(
                        szAddress,
                        prpi->faNameOffset[i],
                        prpi->dwNameLength[i],
                        &dwSize,
                        NULL);

        if(FAILED(hrRes))
            goto Exit;

        (*pdwCrc) += CRCHash(szAddress, prpi->dwNameLength[i]);
    }

    // Call the enumerator to walk the per-recipient property table
    hrRes = pMsg->EnumPropertyTable(
                    &((LPRECIPIENTS_PROPERTY_ITEM) prpi)->ptiInstanceInfo,
                    CrcPerRecipientPropTableEnumerator,
                    (PVOID) pdwCrc);

Exit:
    TraceFunctLeaveEx((LPARAM) 0);
    return hrRes;
}

//-----------------------------------------------------------------------------
//  Description:
//      Enumerator function for per-recipient property tables.
//  Arguments:
//      IN pvCrc - Ptr to (accumulated) CRC
//      All other arguments are standard PFNENUMERATOR arguments
//  Returns:
//      HRESULT
//-----------------------------------------------------------------------------
HRESULT CrcPerRecipientPropTableEnumerator(
    LPPROPERTY_ITEM pPi,
    DWORD cbPiSize,
    BYTE *pbProp,
    DWORD cbSize,
    PVOID pvCrc)
{
    PDWORD pdwCrc = (PDWORD) pvCrc;

    (*pdwCrc) += CRCHash(pbProp, cbSize);
    return S_OK;
}

//-----------------------------------------------------------------------------
//  Description:
//      Generates checksums based on the global and recipient properties on
//      this mailmsg and sets them as properties on this mailmsg as IMMPID_MP_
//      properties. The checksum properties are excluded from calculating the
//      checksum.
//  Arguments:
//      None.
//  Returns:
//      HRESULT.
//-----------------------------------------------------------------------------
HRESULT CMailMsg::SetChecksum()
{
    HRESULT hr = S_OK;

    hr = GenerateChecksum(&m_dwGlobalCrc, &m_dwRecipsCrc);
    if(FAILED(hr))
        return hr;

    hr = PutDWORD(IMMPID_MP_CRC_GLOBAL, m_dwGlobalCrc);
    if(FAILED(hr))
        return hr;

    hr = PutDWORD(IMMPID_MP_CRC_RECIPS, m_dwRecipsCrc);
    if(FAILED(hr))
        return hr;

    return hr;
}

//-----------------------------------------------------------------------------
//  Description:
//      This function is called post bifurcation, passing in the message which
//      was bifurcated and the new message. It creates checksums on both
//      messages (for the properties) and verifies that the global property
//      checksums are equal (since the global properties on both messages
//      should be identical after bifurcation).
//  Arguments:
//      pMsgOld - Message that was bifurcated
//      pMsgNew - Newly created message
//  Returns:
//      S_OK on success
//      S_FALSE if the checksums did not match
//      Failure HRESULT if some other failure occurred
//-----------------------------------------------------------------------------
HRESULT CreateAndVerifyCrc(
    CMailMsg *pMsgOld,
    CMailMsg *pMsgNew)
{
    HRESULT hr1 = S_OK;
    HRESULT hr2 = S_OK;
    DWORD dwOld = 0;
    DWORD dwNew = 0;

    TraceFunctEnterEx((LPARAM)0, "CreateAndVerifyCrc");

    hr1 = pMsgOld->SetChecksum();
    hr2 = pMsgNew->SetChecksum();

    if(FAILED(hr1) || FAILED(hr2)) {
        TraceFunctLeaveEx((LPARAM)0);
        return hr1;
    }

    hr1 = pMsgOld->GetDWORD(IMMPID_MP_CRC_GLOBAL, &dwOld);
    hr2 = pMsgNew->GetDWORD(IMMPID_MP_CRC_GLOBAL, &dwNew);

    if(FAILED(hr1) || FAILED(hr2)) {
        TraceFunctLeaveEx((LPARAM)0);
        return hr1;
    }

    if(dwOld != dwNew) {
        ErrorTrace((LPARAM) 0, "Checksum comparison failed");
        TraceFunctLeaveEx((LPARAM)0);
        return S_FALSE;
    }

    TraceFunctLeaveEx((LPARAM)0);
    return S_OK;
}

//-----------------------------------------------------------------------------
//  Description:
//      This function computes the checksum based on all properties of this
//      CMailMsg, compares it with the previously stored value (if any) and
//      returns success if the checksum hasn't changed and failure if the
//      checksum couldn't be computed or if the checksum comparison failed.
//      The newly computed checksums are also set as mailmsg properties.
//  Arguments:
//      None.
//  Returns:
//      S_OK - The checksums match
//      S_FALSE - The checksums do not match
//      Failure HRESULT - Some failure occurred
//-----------------------------------------------------------------------------
//
// A Cleanup block woudl make the below code look cleaner, but would make
// it harder to debug.  By crashing at the failure point we can tell exactly
// what went wrong.
//
HRESULT CMailMsg::VerifyChecksum()
{
    TraceFunctEnter("CMailMsg::VerifyChecksum");
    
    DWORD dwOldGlobalCrc = 0;
    DWORD dwOldRecipsCrc = 0;
    DWORD dwNewGlobalCrc = 0;
    DWORD dwNewRecipsCrc = 0;
    BOOL fOldGlobalCrc = TRUE;
    BOOL fOldRecipsCrc = TRUE;
    HRESULT hr1 = S_OK;
    HRESULT hr2 = S_OK;

    hr1 = GetDWORD(IMMPID_MP_CRC_GLOBAL, &dwOldGlobalCrc);
    hr2 = GetDWORD(IMMPID_MP_CRC_RECIPS, &dwOldRecipsCrc);

    DebugTrace((LPARAM) this, 
               "OldGlobal = %08x, OldRecips = %08x, hr1=%x, hr2=%x\n",
               dwOldGlobalCrc,
               dwOldRecipsCrc,
               hr1,
               hr2);


    if(hr1 == STG_E_UNKNOWN || hr1 == STG_E_INVALIDPARAMETER) {  // Checksum was never set
        fOldGlobalCrc = FALSE;
        hr1 = S_OK;
    }

    if(hr2 == STG_E_UNKNOWN || hr2 == STG_E_INVALIDPARAMETER) { // Checksum was never set
        fOldRecipsCrc = FALSE;
        hr2 = S_OK;
    }

    if(FAILED(hr1) || FAILED(hr2)) {
        HRESULT hr = (FAILED(hr1)) ? hr1 : hr2;
        ForceCrashIfNeeded();
        ErrorTrace((LPARAM) this, "Checksum verify failed - Couldn't read old checksum - %08x, %08x", hr1, hr2);
        TraceFunctLeave();
        return hr;
    }

    hr1 = SetChecksum(); // Set new checksum
    if(FAILED(hr1)) {
        if (hr1 != STG_E_UNKNOWN) ForceCrashIfNeeded();
        ErrorTrace((LPARAM) this, "Checksum verify failed - Couldn't set new checksum - %08x", hr1);
        TraceFunctLeave();
        return hr1;
    }

    // Get newly set checksum
    hr1 = GetDWORD(IMMPID_MP_CRC_GLOBAL, &dwNewGlobalCrc);
    hr2 = GetDWORD(IMMPID_MP_CRC_RECIPS, &dwNewRecipsCrc);
    if(FAILED(hr1) || FAILED(hr2)) {
        HRESULT hr = (FAILED(hr1)) ? hr1 : hr2;
        if (hr != STG_E_UNKNOWN) ForceCrashIfNeeded();
        ErrorTrace((LPARAM) this, "Checksum verify failed - Couldn't get new checksum - %08x, %08x", hr1, hr2);
        TraceFunctLeave();
        return hr;
    }

    DebugTrace((LPARAM) this, 
               "NewGlobal = %08x, NewRecips = %08x, hr1=%x, hr2=%x\n",
               dwNewGlobalCrc,
               dwNewRecipsCrc,
               hr1,
               hr2);


    // Verify checksum with old checksum (if there was one)
    if(fOldGlobalCrc) {
        if(dwNewGlobalCrc != dwOldGlobalCrc) {
            ForceCrashIfNeeded();
            ErrorTrace((LPARAM) this, "Checksum verify failed - NewGlobalCrc != OldGlobalCrc");
            TraceFunctLeave();
            return S_FALSE;
        }
    }

    if(fOldRecipsCrc) {
        if(dwNewRecipsCrc != dwNewRecipsCrc) {
            ForceCrashIfNeeded();
            ErrorTrace((LPARAM) this, "Checksum verify failed - NewRecipsCrc != OldRecipsCrc");
            TraceFunctLeave();
            return S_FALSE;
        }
    }

    TraceFunctLeave();
    return S_OK;
}

//-----------------------------------------------------------------------------
//  Description:
//      Enumerator used by ForkForRecipients to copy all global properties from
//      the mailmsg being forked, to the new mailmsg.
//  Arguments:
//      IN pvMsg - The new mailmsg
//      All other arguments are standard PFNENUMERATOR arguments
//  Returns:
//      HRESULT
//-----------------------------------------------------------------------------
HRESULT CopyPropertyEnumerator(
    LPPROPERTY_ITEM pPi,
    DWORD cbPiSize,
    BYTE *pbProp,
    DWORD cbSize,
    PVOID pvMsg)
{
    DWORD dwPropId = ((LPGLOBAL_PROPERTY_ITEM)pPi)->idProp;

    return ((CMailMsg *)pvMsg)->PutProperty(
        dwPropId, cbSize, pbProp);
}

HRESULT STDMETHODCALLTYPE CMailMsg::RebindAfterFork(
            IMailMsgProperties  *pOriginalMsg,
            IUnknown            *pStoreDriver
            )
{
    HRESULT                 hrRes = S_OK;

    PFIO_CONTEXT            hContent = NULL;
    IMailMsgPropertyStream  *pStream = NULL;
    IMailMsgStoreDriver     *pDriver = NULL;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::RebindAfterFork");

    if (!pOriginalMsg)
        return(E_POINTER);

    if (!pStoreDriver)
        pDriver = m_pDefaultRebindStoreDriver;
    else
    {
        hrRes = pStoreDriver->QueryInterface(
                    IID_IMailMsgStoreDriver,
                    (LPVOID *)&pDriver);
        if (FAILED(hrRes))
            return(hrRes);
    }

    if (!pDriver)
        return(E_POINTER);

    hrRes = pDriver->ReAllocMessage(
        pOriginalMsg,
        (IMailMsgProperties *)this,
        &pStream,
        &hContent,
        NULL);

    if(SUCCEEDED(hrRes)) {

        //
        // Update the checksums on the message. In this case the checksum
        // was first calculated when the Fork happened, and subsequently
        // the categorizer may have set properties on the new message
        // causing the checksum to go out of sync, and finally called
        // RebindAfterFork(). Thus the refresh.
        //

        if(g_fValidateOnForkForRecipients || g_fValidateOnRelease) {
            HRESULT hr = SetChecksum();
            if(FAILED(hr)) {
                ForceCrashIfNeeded();
                ErrorTrace((LPARAM) this, "Failed to set CRC - %08x", hr);
            }
        }

        hrRes = BindToStore(
            pStream,
            pDriver,
            hContent);

        // Release the extra refcount on the stream
        pStream->Release();
    }

    TraceFunctLeave();
    return(hrRes);
}


// =================================================================
// Implementation of IMailMsgQueueMgmt
//
HRESULT CMailMsg::GetStream(
            IMailMsgPropertyStream  **ppStream,
            BOOL                    fLockAcquired
            )
{
    HRESULT                 hrRes = S_OK;

    if (!ppStream) return E_POINTER;

    if (m_pStream)
    {
        *ppStream = m_pStream;
    }
    else
    {
        hrRes = RestoreResourcesIfNecessary(fLockAcquired, TRUE);
        if (SUCCEEDED(hrRes))
        {
            _ASSERT(m_pStream);
            *ppStream = m_pStream;
            hrRes = S_OK;
        }
    }

    return(hrRes);
}

HRESULT CMailMsg::RestoreResourcesIfNecessary(
            BOOL    fLockAcquired,
            BOOL    fStreamOnly
            )
{
    HRESULT hrRes = S_OK;
    IMailMsgPropertyStream  **ppStream;
    PFIO_CONTEXT            *phHandle;
    BOOL                    fOpenStream = FALSE;
    BOOL                    fOpenContent = FALSE;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::RestoreResourcesIfNecessary");

    if (!m_pStore) return E_UNEXPECTED;

    m_lockReopen.ShareLock();
    ppStream = &m_pStream;
    phHandle = &m_hContentFile;

    // If we transition from zero to one, we will re-establish the
    // handles and pointers.
    _ASSERT(m_pStore);

    // Only reopen the ones that were closed
    if (m_pStream) ppStream = NULL;
    if (fStreamOnly || m_hContentFile != NULL) phHandle = NULL;

    // If we don't want either of them, we just return
    if (!ppStream && !phHandle) {
        m_lockReopen.ShareUnlock();
        return(S_OK);
    }

    //
    // switch our lock to an exclusive one
    //
    if (!m_lockReopen.SharedToExclusive()) {
        //
        // we couldn't do this in one operation.  acquire the exclusive
        // the hard way and retest our state.
        //
        m_lockReopen.ShareUnlock();
        m_lockReopen.ExclusiveLock();
        ppStream = &m_pStream;
        phHandle = &m_hContentFile;
        if (m_pStream) ppStream = NULL;
        if (fStreamOnly || m_hContentFile != NULL) phHandle = NULL;
        if (!ppStream && !phHandle) {
            m_lockReopen.ExclusiveUnlock();
            return(S_OK);
        }
    }

    if (ppStream)
    {
        _ASSERT(!m_pStream);
        fOpenStream = TRUE;
    }

    if (phHandle)
    {
        _ASSERT(!m_hContentFile);
        fOpenContent = TRUE;
    }

    hrRes = m_pStore->ReOpen(
                this,
                ppStream,
                phHandle,
                NULL);
    if (SUCCEEDED(hrRes))
    {


        // Make sure both are opened now
        _ASSERT(m_pStream);
        if (!fStreamOnly) _ASSERT(m_hContentFile != NULL);

        if (fOpenContent)
            InterlockedIncrement(&g_cOpenContentHandles);

        if (fOpenStream)
            InterlockedIncrement(&g_cOpenStreamHandles);

        //_ASSERT(g_cOpenContentHandles <= 6000);
        //_ASSERT(g_cOpenStreamHandles <= 6000);

        if ((m_cCloseOnExternalReleaseUsage) &&
            (0 == InterlockedDecrement(&m_cCloseOnExternalReleaseUsage)))
            InterlockedDecrement(&g_cCurrentMsgsClosedByExternalReleaseUsage);

        // Also propagate the stream to CMailMsgRecipients
        CMailMsgRecipients::SetStream(m_pStream);
    }

    m_lockReopen.ExclusiveUnlock();

    if (SUCCEEDED(hrRes) && fOpenStream && g_fValidateOnRelease) {
        VerifyChecksum();
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

// =================================================================
// Implementation of IMailMsgQueueMgmt
//

HRESULT STDMETHODCALLTYPE CMailMsg::AddUsage()
{
    HRESULT hrRes;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::AddUsage");

    m_lockUsageCount.ExclusiveLock();

    if (!m_ulUsageCount)
        hrRes = S_OK;
    else if (m_ulUsageCount < 0)
        hrRes = E_FAIL;
    else
        hrRes = S_FALSE;

    if (SUCCEEDED(hrRes)) {
        m_ulUsageCount++;
        InterlockedIncrement(&g_cTotalUsageCount);
    }

    m_lockUsageCount.ExclusiveUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::ReleaseUsage()
{
    return (InternalReleaseUsage(RELEASE_USAGE_EXTERNAL));
}

HRESULT STDMETHODCALLTYPE CMailMsg::Delete(
            IMailMsgNotify *pNotify
            )
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::Delete");

    hrRes = InternalReleaseUsage(RELEASE_USAGE_DELETE);
    _ASSERT(SUCCEEDED(hrRes));

    m_fDeleted = TRUE;
    if(m_pStore)
    {
        // OK, just call the store driver to delete this file
        hrRes = m_pStore->Delete(
                (IMailMsgProperties *)this,
                pNotify);
    }

    TraceFunctLeave();
    return(hrRes);
}

// =================================================================
// Implementation of IMailMsgBind
//

HRESULT STDMETHODCALLTYPE CMailMsg::BindToStore(
            IMailMsgPropertyStream  *pStream,
            IMailMsgStoreDriver     *pStore,
            PFIO_CONTEXT            hContentFile
            )
{
    HRESULT hrRes = S_OK;

    // hContentFile is optional, can be INVALID_HANDLE_VALUE

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::BindToStore");

    if (!pStream || !pStore)
    {
        hrRes = STG_E_INVALIDPARAMETER;
        goto Cleanup;
    }



    // 3/17/99 - Mikeswa
    // should not be calling BindToStore twice
    _ASSERT(!m_pStore);

    // If the handle must not be already specified
    if (hContentFile != NULL &&
        m_hContentFile != NULL)
        hrRes = E_HANDLE;
    else
    {
        m_pStore = pStore;
        m_hContentFile  = hContentFile;
        if (m_hContentFile) InterlockedIncrement(&g_cOpenContentHandles);

        // Hold a reference to the stream
        _ASSERT(!m_pStream);
        m_pStream = pStream;
        pStream->AddRef();
        InterlockedIncrement(&g_cOpenStreamHandles);

        // See if this is an existing file
        hrRes = RestoreMasterHeaderIfAppropriate();
        if (FAILED(hrRes))
        {
            pStream->Release();
            goto Cleanup;
        }

        // Also propagate the stream to CMailMsgRecipients
        CMailMsgRecipients::SetStream(pStream);

        // Set the usage count to 1
        if (InterlockedExchange(&m_ulUsageCount, 1) != 0)
        {
            _ASSERT(FALSE);
            hrRes = E_FAIL;
        } else {
            InterlockedIncrement(&g_cTotalUsageCount);
        }
    }

    if (g_fValidateOnRelease) {

        //
        // Verify that if there was a previously stored checksum, it matches the
        // checksum computed afresh from the properties. Doing the verification
        // here assumes that since the last time the checksum was calculated, no
        // properties have been updated. This is true if:
        // (1) The last time we did the checksum calculation was during the Commit.
        // (2) The message is being loaded up for the first time and never had a CRC.
        // (3) If the above cases do not apply, the checksum must be explicitly
        //     refreshed by calling SetChecksum() so that the VerifyChecksum()
        //     succeeds.
        //

        VerifyChecksum();
    }

Cleanup:

    if (FAILED(hrRes))
    {
        m_pStore = NULL;
        m_hContentFile = NULL;
        m_pStream = NULL;
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::GetProperties(
            IMailMsgPropertyStream  *pStream,
            DWORD                   dwFlags,
            IMailMsgNotify          *pNotify
            )
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::GetProperties");
    BOOL fDontMarkAsCommit = !(dwFlags & MAILMSG_GETPROPS_MARKCOMMIT);

    if (!pStream) {
        hrRes = STG_E_INVALIDPARAMETER;
    } else {

        //
        // If properties are about to be persisted, refresh the CRC so that
        // the CRC that is written is consistent with the properties that are
        // being written.
        //

        if(g_fValidateOnRelease) {

            HRESULT hr = SetChecksum();

            if(FAILED(hr)) {
                ErrorTrace((LPARAM) this, "Failed to set checksum");
                ForceCrashIfNeeded();
            }
        }

        hrRes = m_bmBlockManager.AtomicWriteAndIncrement(
                    (LPBYTE)&m_Header,
                    (FLAT_ADDRESS)0,
                    sizeof(MASTER_HEADER),
                    NULL,
                    0,
                    0,
                    NULL);
        if (pStream == m_pStream) {
            m_bmBlockManager.SetDirty(FALSE);
            m_bmBlockManager.SetCommitMode(TRUE);
        }
        if (SUCCEEDED(hrRes)) {
            DWORD cTotalBlocksToWrite = 0;
            DWORD cTotalBytesToWrite = 0;
            int f;
            for (f = 1; f >= 0; f--) {
                if (SUCCEEDED(hrRes)) {
                    if (!f) {
                        hrRes = pStream->StartWriteBlocks(this,
                                                          cTotalBlocksToWrite,
                                                          cTotalBytesToWrite);
                    }
                    hrRes = m_bmBlockManager.CommitDirtyBlocks(
                                (FLAT_ADDRESS)0,
                                INVALID_FLAT_ADDRESS,
                                dwFlags,
                                pStream,
                                fDontMarkAsCommit,
                                f,
                                &cTotalBlocksToWrite,
                                &cTotalBytesToWrite,
                                pNotify);
                    if (!f) {
                        if (FAILED(hrRes)) {
                           pStream->CancelWriteBlocks(this);
                        } else {
                            hrRes = pStream->EndWriteBlocks(this);
                        }
                    }
                }
            }
        }
    }

    // Set the recipient commit state
    if (SUCCEEDED(hrRes) && pStream == m_pStream)
        CMailMsgRecipients::SetCommitState(TRUE);

    if (FAILED(hrRes) && pStream == m_pStream) {
        m_bmBlockManager.SetDirty(FALSE);
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT CMailMsg::RestoreMasterHeaderIfAppropriate()
{
    HRESULT hrRes = S_OK;
    DWORD   dwStreamSize = 0;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::RestoreMasterHeaderIfAppropriate");

    // Get the size and fill it in. If get size fails, we
    // will default to sizeof the master header.
    hrRes = m_pStream->GetSize(this, &dwStreamSize, NULL);
    if (SUCCEEDED(hrRes))
    {
        // If the size is zero, we have a new file
        if (!dwStreamSize)
            return(S_OK);

        // Make sure the stream is at least the size of the
        // MASTER_HEADER
        if (dwStreamSize < sizeof(MASTER_HEADER))
        {
            ErrorTrace((LPARAM)this, "Stream size too small (%u bytes)", dwStreamSize);
            goto InvalidFile;
        }

        m_bmBlockManager.Release();
        hrRes = m_bmBlockManager.SetStreamSize(dwStreamSize);
        if (SUCCEEDED(hrRes))
        {
            // Make sure we can restore the master header
            DWORD   dwT;
            hrRes = m_bmBlockManager.ReadMemory(
                        (LPBYTE)&m_Header,
                        0,
                        sizeof(MASTER_HEADER),
                        &dwT,
                        NULL);
            if (SUCCEEDED(hrRes) && (dwT == sizeof(MASTER_HEADER)))
            {
                // Check the signature ...
                if (m_Header.dwSignature != CMAILMSG_SIGNATURE_VALID)
                {
                    ErrorTrace((LPARAM)this,
                            "Corrupted signature (%*s)", 4, &(m_Header.dwSignature));
                    goto InvalidFile;
                }
                if (m_Header.dwHeaderSize != sizeof(MASTER_HEADER))
                {
                    ErrorTrace((LPARAM)this,
                            "Bad header size (%u, expected %u)",
                            m_Header.dwHeaderSize, sizeof(MASTER_HEADER));
                    goto InvalidFile;
                }

                TraceFunctLeaveEx((LPARAM)this);
                return(hrRes);
            }

            ErrorTrace((LPARAM)this, "Failed to get master header (%08x, %u)", hrRes, dwT);
        }
        else
        {
            ErrorTrace((LPARAM)this, "Failed to set stream size (%08x)", hrRes);
        }
    }
    else
    {
        ErrorTrace((LPARAM)this, "Failed to get stream size (%08x)", hrRes);
    }

InvalidFile:

    TraceFunctLeaveEx((LPARAM)this);
    return(HRESULT_FROM_WIN32(ERROR_FILE_CORRUPT));
}

HRESULT STDMETHODCALLTYPE CMailMsg::GetBinding(
            PFIO_CONTEXT                *phAsyncIO,
            IMailMsgNotify              *pNotify
            )
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::GetATQInfo");

    if (!phAsyncIO)
        hrRes = STG_E_INVALIDPARAMETER;
    else
    {
        // Make sure we have a stream and store
        _ASSERT(m_pStore);

        // Up the usage count
        hrRes = AddUsage();
        if (SUCCEEDED(hrRes))
        {
            hrRes = RestoreResourcesIfNecessary();
            if(SUCCEEDED(hrRes))
            {
                // Copy the values
                *phAsyncIO          = m_hContentFile;
                _ASSERT(m_pStream);
            }
        }
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsg::ReleaseContext()
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::ReleaseContext");

    // Call to ReleaseUsage()
    hrRes = InternalReleaseUsage(RELEASE_USAGE_INTERNAL);

    TraceFunctLeave();
    return(hrRes);
}


//---[ CMailMsg::InternalReleaseUsage ]---------------------------------------
//
//
//  Description:
//      Internal implementation of ReleaseUsage.  Allows added internal
//      functionality on delete and the final release.
//  Parameters:
//      dwReleaseUsageFlags     Flag specifying behavior
//              RELEASE_USAGE_EXTERNAL      - External interface normal behavior
//              RELEASE_USAGE_FINAL_RELEASE - Drops usage count to 0
//              RELEASE_USAGE_DELETE        - Drops usage count to 0 and will
//                                            not commit (if commiting on
//                                            release usage feature is added).
//              RELEASE_USAGE_INTERNAL      - Internal usage of release usage
//                                            that may be called before the
//                                            usage count is incremented
//                                            above zero.
//  Returns:
//      S_OK on success (and resulting usage count is 0)
//      S_FALSE on success (and resulting usage count is > 0)
//      E_FAIL if usage count is already < 0 (all cases)
//      E_FAIL if usage count is already 0 (RELEASE_USAGE_EXTERNAL only)
//  History:
//      8/3/98 - MikeSwa Created (implementation mostly from original release usage)
//
//  Notes:
//      There is some debate if this function should commit data.  Currently it
//      does not.  See bug #73040.
//-----------------------------------------------------------------------------
HRESULT CMailMsg::InternalReleaseUsage(DWORD  dwReleaseUsageFlags)
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CMailMsg::InternalReleaseUsage");

    //Exactly one flag should be set
    ASSERT((dwReleaseUsageFlags & RELEASE_USAGE_EXTERNAL) ^
           (dwReleaseUsageFlags & RELEASE_USAGE_FINAL_RELEASE) ^
           (dwReleaseUsageFlags & RELEASE_USAGE_INTERNAL) ^
           (dwReleaseUsageFlags & RELEASE_USAGE_DELETE));

    InterlockedIncrement(&g_cTotalReleaseUsageCalls);
    m_lockUsageCount.ExclusiveLock();

    if (m_ulUsageCount <= 1 &&
       (!(dwReleaseUsageFlags & RELEASE_USAGE_DELETE)) &&
        !m_fDeleted)
    {
        // if there are any dirty blocks then do a commit to write them back
        // to the P1 stream
        if (m_pStore && m_bmBlockManager.IsDirty()) {
            HRESULT hrCommit = Commit(NULL);
            if (FAILED(hrCommit)) {
                InterlockedIncrement(&g_cTotalReleaseUsageCommitFail);
                ErrorTrace((DWORD_PTR) this, "InternalReleaseUsage: automatic commit failed with 0x%x", hrCommit);
            }
            _ASSERT(SUCCEEDED(hrCommit) || m_bmBlockManager.IsDirty());
        }
    }

    DebugTrace((LPARAM)this, "Usage count is %u. Release flags: %08x",
            m_ulUsageCount, dwReleaseUsageFlags);

    if ((dwReleaseUsageFlags & (RELEASE_USAGE_FINAL_RELEASE |
                                RELEASE_USAGE_INTERNAL |
                                RELEASE_USAGE_DELETE)) &&
        (m_ulUsageCount == 0))
    {
        _ASSERT(S_OK == hrRes); //resulting usage count is still 0
        m_ulUsageCount++; //prepare for decrement at end
        InterlockedIncrement(&g_cTotalUsageCount);

        DebugTrace((LPARAM)this, "Usage count already zero");
    }

    if ((m_ulUsageCount == 1) ||
        ((m_ulUsageCount >= 1) &&
         (dwReleaseUsageFlags & (RELEASE_USAGE_FINAL_RELEASE |
                                 RELEASE_USAGE_DELETE))))
    {
        LONG ulUsageDiff = -(m_ulUsageCount - 1);
        m_ulUsageCount = 1; //on delete and final release cases we drop it to 0
        InterlockedExchangeAdd(&g_cTotalUsageCount, ulUsageDiff);

        DebugTrace((LPARAM)this, "Dropping usage count to zero");

        // When we hit zero, we will release the stream, content
        // handle, and unassociate the ATQ context
        _ASSERT((RELEASE_USAGE_EXTERNAL ^ dwReleaseUsageFlags) || m_pStore);

        if (RELEASE_USAGE_EXTERNAL & dwReleaseUsageFlags)
            InterlockedIncrement(&g_cTotalExternalReleaseUsageZero);

        if ((!(m_bmBlockManager.IsDirty())) ||
            (dwReleaseUsageFlags & (RELEASE_USAGE_FINAL_RELEASE |
                                    RELEASE_USAGE_DELETE)))
        {
            if (m_pStore &&
                (m_bmBlockManager.IsDirty()) &&
                !m_fDeleted &&
                (!(dwReleaseUsageFlags & RELEASE_USAGE_DELETE)))
            {
                ErrorTrace((DWORD_PTR) this, "InternalReleaseUsage: automatic commit failed, must close anyway");
            }

            if (!m_hContentFile && !m_pStream)
                InterlockedIncrement(&g_cTotalReleaseUsageNothingToClose);
            else if (RELEASE_USAGE_EXTERNAL & dwReleaseUsageFlags)
            {
                //If we are an external caller, then update our count global and member
                //counts

                //If m_cCloseOnExternalReleaseUsage, then we are going through this
                //code path twice without calling RestoreResourcesIfNecessary
                _ASSERT(!m_cCloseOnExternalReleaseUsage);
                InterlockedIncrement(&m_cCloseOnExternalReleaseUsage);
                InterlockedIncrement(&g_cCurrentMsgsClosedByExternalReleaseUsage);
            }

            if (m_hContentFile != NULL)
            {
                DebugTrace((LPARAM)this, "Closing content file");

                 _ASSERT(m_pStore); //we must have a store in this case
                hrRes = m_pStore->CloseContentFile(this, m_hContentFile);
                InterlockedIncrement(&g_cTotalReleaseUsageCloseContent);
                InterlockedDecrement(&g_cOpenContentHandles);
                _ASSERT(SUCCEEDED(hrRes)); //assert before blowing away m_hContentFile
                m_hContentFile = NULL;
            }

            // Release the stream
            if (m_pStream)
            {
                DebugTrace((LPARAM)this, "Releasing stream");

                m_pStream->Release();
                m_pStream = NULL;

                InterlockedIncrement(&g_cTotalReleaseUsageCloseStream);
                InterlockedDecrement(&g_cOpenStreamHandles);
                // Also invalidate the stream in CMailMsgRecipients
                CMailMsgRecipients::SetStream(NULL);
            }

            // Dump the memory held onto by blockmgr
            m_bmBlockManager.Release();
        }
        else
            InterlockedIncrement(&g_cTotalReleaseUsageCloseFail);
        hrRes = S_OK;
    }
    else if (m_ulUsageCount <= 0)
    {
        _ASSERT(0 && "Usage count already 0");
        hrRes = E_FAIL;
    }
    else
    {
        hrRes = S_FALSE;
        InterlockedIncrement(&g_cTotalReleaseUsageNonZero);
    }

    if (SUCCEEDED(hrRes)) {
        m_ulUsageCount--;
        InterlockedDecrement(&g_cTotalUsageCount);
    }

    m_lockUsageCount.ExclusiveUnlock();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\mmdbgext\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgp.h $(O)\mailmsgp_i.c : $(STAXINC)\export\mailmsgp.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgp_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgp_i.c \
    -header $@ \
    -tlb $(O)\mailmsgp.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\cmmmgmt.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cmmmgmt.cpp

Abstract:

	This module contains the implementation of the property ID management
	class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/10/98	created

--*/

//#define WIN32_LEAN_AND_MEAN
#include "atq.h"

#include "dbgtrace.h"
#include "signatur.h"
#include "cmmtypes.h"
#include "cmailmsg.h"


// =================================================================
// Private Definitions
//



// =================================================================
// Static declarations
//


// =================================================================
// Compare functions
//
HRESULT CMailMsgPropertyManagement::CompareProperty(
			LPVOID			pvPropKey,
			LPPROPERTY_ITEM	pItem
			)
{
	if (*(GUID *)pvPropKey == ((LPPROPID_MGMT_PROPERTY_ITEM)pItem)->Guid)
		return(S_OK);
	return(STG_E_UNKNOWN);
}						


// =================================================================
// Implementation of CMailMsgPropertyManagement
//
CMailMsgPropertyManagement::CMailMsgPropertyManagement(
			CBlockManager				*pBlockManager,
			LPPROPERTY_TABLE_INSTANCE	pInstanceInfo
			)
			:
			m_ptProperties(
					PTT_PROP_ID_TABLE,
					PROPID_MGMT_PTABLE_INSTANCE_SIGNATURE_VALID,
					pBlockManager,
					pInstanceInfo,
					CompareProperty,
					NULL,	// Well-known properties not supported
					0		// for this type of table
					)
{
	_ASSERT(pBlockManager);
	_ASSERT(pInstanceInfo);
	m_pBlockManager = pBlockManager;
	m_pInstanceInfo = pInstanceInfo;
}

CMailMsgPropertyManagement::~CMailMsgPropertyManagement()
{
}

HRESULT STDMETHODCALLTYPE CMailMsgPropertyManagement::AllocPropIDRange(
			REFGUID	rguid,
			DWORD	cCount,
			DWORD	*pdwStart
			)
{
	HRESULT						hrRes		= S_OK;
	PROPID_MGMT_PROPERTY_ITEM	pmpiItem;

	_ASSERT(m_pBlockManager);
	_ASSERT(m_pInstanceInfo);

	if (!pdwStart) return E_POINTER;
	
	// OK, 2 scenarios: Either the GUID is not registered or
	// already registered
	hrRes = m_ptProperties.GetPropertyItem(
				(LPVOID)&rguid,
				(LPPROPERTY_ITEM)&pmpiItem);
	if (SUCCEEDED(hrRes))
	{
		_ASSERT(pmpiItem.piItem.faOffset == INVALID_FLAT_ADDRESS);

		if (pmpiItem.piItem.dwMaxSize == cCount)
		{
			// Scenario 1a: Item is found and the count matches,
			// so just return the index
			*pdwStart = pmpiItem.piItem.dwSize;
			hrRes = S_OK;
		}
		else
		{
			// Scenario 1b: Item found but size does not match, this
			// is considered an error!
			hrRes = E_FAIL;
		}
	}
	else
	{
		if (hrRes == STG_E_UNKNOWN)
		{
			// Property not found, now we should create it ...
			DWORD				dwIndex;
			DWORD				dwSpaceLeft;
			CPropertyTableItem	ptiItem(
									m_pBlockManager,
									m_pInstanceInfo);

			// Set the info ...
			pmpiItem.Guid = rguid;
			pmpiItem.piItem.faOffset = INVALID_FLAT_ADDRESS;
			pmpiItem.piItem.dwMaxSize = cCount;

			// OK, we store the next available propid in
			// m_pInstanceInfo->faExtendedInfo. If it is INVALID_FLAT_ADDRESS
			// then we start with IMMPID_CP_START.
			if (m_pInstanceInfo->faExtendedInfo == INVALID_FLAT_ADDRESS)
				pmpiItem.piItem.dwSize = IMMPID_CP_START;
			else
				pmpiItem.piItem.dwSize = (DWORD)(m_pInstanceInfo->faExtendedInfo);

			// See if we have enough slots left ...
			dwSpaceLeft = (DWORD)(INVALID_FLAT_ADDRESS - pmpiItem.piItem.dwSize);
			if (dwSpaceLeft >= cCount)
			{
				hrRes = ptiItem.AddItem(
							(LPPROPERTY_ITEM)&pmpiItem,
							&dwIndex);
				if (SUCCEEDED(hrRes))
				{
					// Bump the start
					m_pInstanceInfo->faExtendedInfo += (FLAT_ADDRESS)cCount;
					*pdwStart = pmpiItem.piItem.dwSize;
				}
			}
			else
				hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		}
	}

	return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgPropertyManagement::EnumPropIDRange(
			DWORD	*pdwIndex,
			GUID	*pguid,
			DWORD	*pcCount,
			DWORD	*pdwStart
			)
{
	return(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\cmmrcpts.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cmmrcpts.cpp

Abstract:

    This module contains the implementation of the recipient list class

Author:

    Keith Lau   (keithlau@microsoft.com)

Revision History:

    keithlau    03/10/98    created

--*/

#define WIN32_LEAN_AND_MEAN 1
#include "atq.h"
#include "stddef.h"

#include "dbgtrace.h"
#include "signatur.h"
#include "cmmtypes.h"
#include "cmailmsg.h"

extern DWORD g_fValidateSignatures;

// =================================================================
// Private Definitions
//

// Define a structure describing a domain in the stream
typedef struct _DOMAIN_TABLE_ENTRY
{
    DWORD                       dwStartingIndex;
    DWORD                       dwCount;
    FLAT_ADDRESS                faOffsetToName;
    DWORD                       dwNameLength;
    DWORD                       dwNextDomain;

} DOMAIN_TABLE_ENTRY, *LPDOMAIN_TABLE_ENTRY;

// Define an extended info structure
typedef struct _EXTENDED_INFO
{
    DWORD                       dwDomainCount;
    DWORD                       dwTotalSizeIncludingThisStruct;

} EXTENDED_INFO, *LPEXTENDED_INFO;

// The following is the list of default address types
PROP_ID     rgDefaultAddressTypes[MAX_COLLISION_HASH_KEYS] =
{
    IMMPID_RP_ADDRESS_SMTP,     // The first address type will be used for domain grouping
    IMMPID_RP_ADDRESS_X400,
    IMMPID_RP_ADDRESS_X500,
    IMMPID_RP_LEGACY_EX_DN,
    IMMPID_RP_ADDRESS_OTHER
};


// =================================================================
// Static declarations
//

// Recipients table instance info for CMailMsgRecipientsAdd instantiation
const PROPERTY_TABLE_INSTANCE CMailMsgRecipientsAdd::s_DefaultInstance =
{
    RECIPIENTS_PTABLE_INSTANCE_SIGNATURE_VALID,
    INVALID_FLAT_ADDRESS,
    RECIPIENTS_PROPERTY_TABLE_FRAGMENT_SIZE,
    RECIPIENTS_PROPERTY_ITEM_BITS,
    RECIPIENTS_PROPERTY_ITEM_SIZE,
    RECIPIENTS_PROPERTY_ITEMS,
    INVALID_FLAT_ADDRESS
};

//
// Well-known per-recipient properties
//
INTERNAL_PROPERTY_ITEM
                *const CMailMsgRecipientsPropertyBase::s_pWellKnownProperties = NULL;
const DWORD     CMailMsgRecipientsPropertyBase::s_dwWellKnownProperties = 0;


// =================================================================
// Compare function
//

HRESULT CMailMsgRecipientsPropertyBase::CompareProperty(
            LPVOID          pvPropKey,
            LPPROPERTY_ITEM pItem
            )
{
    if (*(PROP_ID *)pvPropKey == ((LPRECIPIENT_PROPERTY_ITEM)pItem)->idProp)
        return(S_OK);
    return(STG_E_UNKNOWN);
}


// =================================================================
// Inline code for special properties
//
#include "accessor.inl"


// =================================================================
// Implementation of CMailMsgRecipientsPropertyBase
//

HRESULT CMailMsgRecipientsPropertyBase::PutProperty(
            CBlockManager               *pBlockManager,
            LPRECIPIENTS_PROPERTY_ITEM  pItem,
            DWORD                       dwPropID,
            DWORD                       cbLength,
            LPBYTE                      pbValue
            )
{
    HRESULT                         hrRes = S_OK;
    RECIPIENT_PROPERTY_ITEM         piRcptItem;

    if (!pBlockManager || !pItem || !pbValue) return E_POINTER;

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsPropertyBase::PutProperty");

    // Instantiate a property table for the recipient properties
    CPropertyTable              ptProperties(
                                    PTT_PROPERTY_TABLE,
                                    RECIPIENT_PTABLE_INSTANCE_SIGNATURE_VALID,
                                    pBlockManager,
                                    &(pItem->ptiInstanceInfo),
                                    CMailMsgRecipientsPropertyBase::CompareProperty,
                                    CMailMsgRecipientsPropertyBase::s_pWellKnownProperties,
                                    CMailMsgRecipientsPropertyBase::s_dwWellKnownProperties
                                    );

    // Put the recipient property
    piRcptItem.idProp = dwPropID;
    hrRes = ptProperties.PutProperty(
                    (LPVOID)&dwPropID,
                    (LPPROPERTY_ITEM)&piRcptItem,
                    cbLength,
                    pbValue);

    DebugTrace((LPARAM)this,
                "PutProperty: Prop ID = %u, HRESULT = %08x",
                dwPropID, hrRes);

    TraceFunctLeave();
    return(hrRes);
}

HRESULT CMailMsgRecipientsPropertyBase::GetProperty(
            CBlockManager               *pBlockManager,
            LPRECIPIENTS_PROPERTY_ITEM  pItem,
            DWORD                       dwPropID,
            DWORD                       cbLength,
            DWORD                       *pcbLength,
            LPBYTE                      pbValue
            )
{
    HRESULT                         hrRes = S_OK;
    RECIPIENT_PROPERTY_ITEM         piRcptItem;

    if (!pBlockManager || !pItem || !pcbLength || !pbValue) return E_POINTER;

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsPropertyBase::GetProperty");

    // Instantiate a property table for the recipient properties
    CPropertyTable              ptProperties(
                                    PTT_PROPERTY_TABLE,
                                    RECIPIENT_PTABLE_INSTANCE_SIGNATURE_VALID,
                                    pBlockManager,
                                    &(pItem->ptiInstanceInfo),
                                    CMailMsgRecipientsPropertyBase::CompareProperty,
                                    CMailMsgRecipientsPropertyBase::s_pWellKnownProperties,
                                    CMailMsgRecipientsPropertyBase::s_dwWellKnownProperties
                                    );

    // Get the recipient property using an atomic operation
    hrRes = ptProperties.GetPropertyItemAndValue(
                        (LPVOID)&dwPropID,
                        (LPPROPERTY_ITEM)&piRcptItem,
                        cbLength,
                        pcbLength,
                        pbValue);

    DebugTrace((LPARAM)this,
                "GetPropertyItemAndValue: Prop ID = %u, HRESULT = %08x",
                dwPropID, hrRes);

    TraceFunctLeave();
    return(hrRes);
}



// =================================================================
// Implementation of CMailMsgRecipients
//

CMailMsgRecipients::CMailMsgRecipients(
            CBlockManager               *pBlockManager,
            LPPROPERTY_TABLE_INSTANCE   pInstanceInfo
            )
            :
            m_SpecialPropertyTable(&g_SpecialRecipientsPropertyTable)
{
    _ASSERT(pBlockManager);
    _ASSERT(pInstanceInfo);
    m_pBlockManager = pBlockManager;
    m_pInstanceInfo = pInstanceInfo;
    m_ulRefCount = 0;
    m_dwDomainCount = 0;

    m_pStream = NULL;
    m_fGlobalCommitDone = FALSE;
}

CMailMsgRecipients::~CMailMsgRecipients()
{
}

HRESULT CMailMsgRecipients::SetStream(
            IMailMsgPropertyStream  *pStream
            )
{
    // The stream can be NULL for all we know
    m_pStream = pStream;
    return(S_OK);
}

HRESULT CMailMsgRecipients::SetCommitState(
            BOOL        fGlobalCommitDone
            )
{
    m_fGlobalCommitDone = fGlobalCommitDone;
    return(S_OK);
}

HRESULT CMailMsgRecipients::QueryInterface(
            REFIID      iid,
            void        **ppvObject
            )
{
    if (iid == IID_IUnknown)
    {
        // Return our identity
        *ppvObject = (IUnknown *)(IMailMsgRecipients *)this;
        AddRef();
    }
    else if (iid == IID_IMailMsgRecipients)
    {
        // Return the recipient list interface
        *ppvObject = (IMailMsgRecipients *)this;
        AddRef();
    }
    else if (iid == IID_IMailMsgRecipientsBase)
    {
        // Return the base recipients interface
        *ppvObject = (IMailMsgRecipientsBase *)this;
        AddRef();
    }
    else if (iid == IID_IMailMsgPropertyReplication)
    {
        // Return the base recipients interface
        *ppvObject = (IMailMsgPropertyReplication *)this;
        AddRef();
    }
    else
        return(E_NOINTERFACE);

    return(S_OK);
}

ULONG CMailMsgRecipients::AddRef()
{
    return(InterlockedIncrement(&m_ulRefCount));
}

ULONG CMailMsgRecipients::Release()
{
    LONG    lRefCount = InterlockedDecrement(&m_ulRefCount);
    if (lRefCount == 0)
    {
        delete this;
    }
    return(lRefCount);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::Commit(
            DWORD           dwIndex,
            IMailMsgNotify  *pNotify
            )
{
    HRESULT                     hrRes = S_OK;
    RECIPIENTS_PROPERTY_ITEM    piItem;
    FLAT_ADDRESS                faOffset;
    DWORD cTotalBlocksToWrite = 0;
    DWORD cTotalBytesToWrite = 0;

    _ASSERT(m_pBlockManager);
    _ASSERT(m_pInstanceInfo);

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::Commit");

    // Make sure we have a content handle
    hrRes = RestoreResourcesIfNecessary(FALSE, TRUE);
    if (!SUCCEEDED(hrRes))
        return(hrRes);

    _ASSERT(m_pStream);
    if (!m_pStream)
        return(STG_E_INVALIDPARAMETER);

    // Now, see if a global commit call is called [recently enough].
    if (!m_fGlobalCommitDone)
        return(E_FAIL);

    // Get the recipient item first
    {
        CPropertyTableItem      ptiItem(m_pBlockManager, m_pInstanceInfo);

        hrRes = ptiItem.GetItemAtIndex(
                        dwIndex,
                        (LPPROPERTY_ITEM)&piItem,
                        &faOffset
                        );

        DebugTrace((LPARAM)this,
                    "GetItemAtIndex: index = %u, HRESULT = %08x",
                    dwIndex, hrRes);
    }
    for (int fComputeBlockSizes = 1;
         SUCCEEDED(hrRes) && fComputeBlockSizes >= 0;
         fComputeBlockSizes--)
    {
        LPPROPERTY_TABLE_INSTANCE   pInstance = &(piItem.ptiInstanceInfo);
        CPropertyTableItem          ptiItem(m_pBlockManager, pInstance);

        if (fComputeBlockSizes) {
            m_pStream->StartWriteBlocks((IMailMsgProperties *) this,
                                        cTotalBlocksToWrite,
                                        cTotalBytesToWrite);
        }

        // Write out the recipient item, this includes the instance
        // info for the recipient property table
        hrRes = m_pBlockManager->CommitDirtyBlocks(
                    faOffset,
                    sizeof(RECIPIENTS_PROPERTY_ITEM),
                    0,
                    m_pStream,
                    FALSE,
                    fComputeBlockSizes,
                    &cTotalBlocksToWrite,
                    &cTotalBytesToWrite,
                    pNotify);
        if (SUCCEEDED(hrRes))
        {
            DWORD                       dwLeft;
            DWORD                       dwLeftInFragment;
            DWORD                       dwSizeRead;
            FLAT_ADDRESS                faFragment;
            LPRECIPIENT_PROPERTY_ITEM   pItem;
            CBlockContext               bcContext;

            RECIPIENT_PROPERTY_TABLE_FRAGMENT   ptfFragment;

            // Commit the special properties
            for (DWORD i = 0; i < MAX_COLLISION_HASH_KEYS; i++)
                if (piItem.faNameOffset[i] != INVALID_FLAT_ADDRESS)
                {
                    hrRes = m_pBlockManager->CommitDirtyBlocks(
                                piItem.faNameOffset[i],
                                piItem.dwNameLength[i],
                                0,
                                m_pStream,
                                FALSE,
                                fComputeBlockSizes,
                                &cTotalBlocksToWrite,
                                &cTotalBytesToWrite,
                                pNotify);
                    if (!SUCCEEDED(hrRes))
                        goto Cleanup;
                }

            // OK, now commit each property
            dwLeft = pInstance->dwProperties;
            faFragment = pInstance->faFirstFragment;

            // $REVIEW(dbraun)
            // WORKAROUND FOR IA64 FRE COMPILER BUG

            //while (faFragment != INVALID_FLAT_ADDRESS)
            while (TRUE)
            {
                if (faFragment == INVALID_FLAT_ADDRESS)
                    break;

            // END WORKAROUND

                // Make sure there are items to commit
                _ASSERT(dwLeft);

                // Commit the fragment
                hrRes = m_pBlockManager->CommitDirtyBlocks(
                            faFragment,
                            sizeof(RECIPIENT_PROPERTY_TABLE_FRAGMENT),
                            0,
                            m_pStream,
                            FALSE,
                            fComputeBlockSizes,
                            &cTotalBlocksToWrite,
                            &cTotalBytesToWrite,
                            pNotify);
                if (!SUCCEEDED(hrRes))
                    goto Cleanup;

                // Load the fragment info to find the next hop
                hrRes = m_pBlockManager->ReadMemory(
                            (LPBYTE)&ptfFragment,
                            faFragment,
                            sizeof(RECIPIENT_PROPERTY_TABLE_FRAGMENT),
                            &dwSizeRead,
                            &bcContext);
                if (!SUCCEEDED(hrRes))
                    goto Cleanup;

                if(g_fValidateSignatures && ptfFragment.ptfFragment.dwSignature != PROPERTY_FRAGMENT_SIGNATURE_VALID)
                    ForceCrashIfNeeded();

                // Commit each property in the fragment
                dwLeftInFragment = RECIPIENT_PROPERTY_ITEMS;
                pItem = ptfFragment.rgpiItems;
                while (dwLeft && dwLeftInFragment)
                {
                    hrRes = m_pBlockManager->CommitDirtyBlocks(
                                pItem->piItem.faOffset,
                                pItem->piItem.dwSize,
                                0,
                                m_pStream,
                                FALSE,
                                fComputeBlockSizes,
                                &cTotalBlocksToWrite,
                                &cTotalBytesToWrite,
                                pNotify);
                    if (!SUCCEEDED(hrRes))
                        goto Cleanup;

                    pItem++;
                    dwLeftInFragment--;
                    dwLeft--;
                }

                // Next
                faFragment = ptfFragment.ptfFragment.faNextFragment;
            }

            // No more fragments, make sure no more properties as well
            _ASSERT(!dwLeft);
        }

        if (fComputeBlockSizes) {
            m_pStream->EndWriteBlocks((IMailMsgProperties *) this);
        }
    }

Cleanup:

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::DomainCount(
            DWORD   *pdwCount
            )
{
    HRESULT             hrRes = S_OK;
    EXTENDED_INFO       eiInfo;
    DWORD               dwSize;

    _ASSERT(m_pInstanceInfo);

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::DomainCount");

    if (!pdwCount)
        return(E_POINTER);

    // Load up the extended info
    hrRes = m_pBlockManager->ReadMemory(
                (LPBYTE)&eiInfo,
                m_pInstanceInfo->faExtendedInfo,
                sizeof(EXTENDED_INFO),
                &dwSize,
                NULL);
    if (SUCCEEDED(hrRes))
        *pdwCount = eiInfo.dwDomainCount;
    else
        *pdwCount = 0;

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::DomainItem(
            DWORD   dwIndex,
            DWORD   cchLength,
            LPSTR   pszDomain,
            DWORD   *pdwRecipientIndex,
            DWORD   *pdwRecipientCount
            )
{
    return(DomainItemEx(
                dwIndex,
                cchLength,
                pszDomain,
                pdwRecipientIndex,
                pdwRecipientCount,
                NULL));
}

HRESULT CMailMsgRecipients::DomainItemEx(
            DWORD   dwIndex,
            DWORD   cchLength,
            LPSTR   pszDomain,
            DWORD   *pdwRecipientIndex,
            DWORD   *pdwRecipientCount,
            DWORD   *pdwNextDomainIndex
            )
{
    HRESULT             hrRes = S_OK;
    EXTENDED_INFO       eiInfo;
    DWORD               dwSize;

    CBlockContext       cbContext;

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::DomainItemEx");

    if (pdwRecipientIndex) *pdwRecipientIndex = 0;
    if (pdwRecipientCount) *pdwRecipientCount = 0;
    if (pdwNextDomainIndex) *pdwNextDomainIndex = 0;
    if (pszDomain) *pszDomain = 0;

    // Load up the extended info
    hrRes = m_pBlockManager->ReadMemory(
                (LPBYTE)&eiInfo,
                m_pInstanceInfo->faExtendedInfo,
                sizeof(EXTENDED_INFO),
                &dwSize,
                &cbContext);
    if (SUCCEEDED(hrRes))
    {
        if (dwIndex >= eiInfo.dwDomainCount)
            hrRes = E_INVALIDARG;
        else
        {
            FLAT_ADDRESS        faOffset;
            DOMAIN_TABLE_ENTRY  dteDomain;

            // Locate the record to load
            faOffset = dwIndex * sizeof(DOMAIN_TABLE_ENTRY);
            faOffset += (m_pInstanceInfo->faExtendedInfo + sizeof(EXTENDED_INFO));

            hrRes = m_pBlockManager->ReadMemory(
                        (LPBYTE)&dteDomain,
                        faOffset,
                        sizeof(DOMAIN_TABLE_ENTRY),
                        &dwSize,
                        &cbContext);
            if (SUCCEEDED(hrRes))
            {

                // Return the starting index and count regardless
                if (pdwRecipientIndex)
                    *pdwRecipientIndex = dteDomain.dwStartingIndex;
                if (pdwRecipientCount)
                    *pdwRecipientCount = dteDomain.dwCount;

                if (pdwNextDomainIndex)
                    *pdwNextDomainIndex = dteDomain.dwNextDomain;

                if (pszDomain)
                {
                    // Check length
                    if (dteDomain.dwNameLength > cchLength)
                        hrRes = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                    else
                    {
                        // Load up the domain name
                        hrRes = m_pBlockManager->ReadMemory(
                                    (LPBYTE)pszDomain,
                                    dteDomain.faOffsetToName,
                                    dteDomain.dwNameLength,
                                    &dwSize,
                                    &cbContext);
                    }
                }
            }
        }
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::SetNextDomain(
            DWORD   dwDomainIndex,
            DWORD   dwNextDomainIndex,
            DWORD   dwFlags
            )
{
    HRESULT             hrRes = S_OK;
    EXTENDED_INFO       eiInfo;
    DWORD               dwSize;
    DWORD               dwNextDomainIndexValue = dwNextDomainIndex;

    CBlockContext       cbContext;
    CBlockContext       cbNextContext;

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::SetNextDomain");

    // Input flags check - mikeswa 7/3/98
    if (FLAG_OVERWRITE_EXISTING_LINKS & dwFlags)
    {
        if ((FLAG_FAIL_IF_NEXT_DOMAIN_LINKED | FLAG_FAIL_IF_SOURCE_DOMAIN_LINKED) & dwFlags)
        {
            hrRes = E_INVALIDARG;
            goto Cleanup;
        }
    }

    if (FLAG_SET_FIRST_DOMAIN & dwFlags)
    {
        //if this flag is set, we will terminate with this domain
        dwNextDomainIndexValue = INVALID_DOMAIN_INDEX;
    }

    // Load up the extended info
    hrRes = m_pBlockManager->ReadMemory(
                (LPBYTE)&eiInfo,
                m_pInstanceInfo->faExtendedInfo,
                sizeof(EXTENDED_INFO),
                &dwSize,
                &cbContext);
    if (SUCCEEDED(hrRes))
    {
        if ((dwDomainIndex >= eiInfo.dwDomainCount) ||
            (!(FLAG_SET_FIRST_DOMAIN & dwFlags) &&  //we only care about 2nd domain if setting it
              (dwNextDomainIndex >= eiInfo.dwDomainCount)))
            hrRes = E_INVALIDARG;
        else
        {
            FLAT_ADDRESS        faOffset;
            FLAT_ADDRESS        faNextOffset;
            DWORD               dwOriginalLink;
            DWORD               dwNextLink;

            // Locate the offset to write
            faOffset = (m_pInstanceInfo->faExtendedInfo + sizeof(EXTENDED_INFO));
            faOffset += offsetof(DOMAIN_TABLE_ENTRY, dwNextDomain);

            faNextOffset = faOffset + (dwNextDomainIndex * sizeof(DOMAIN_TABLE_ENTRY));
            faOffset += dwDomainIndex * sizeof(DOMAIN_TABLE_ENTRY);

            //we only care about the original domain if we aren't overwriting it
            if (!((FLAG_OVERWRITE_EXISTING_LINKS | FLAG_SET_FIRST_DOMAIN) & dwFlags))
            {
                // Read the original Link's next link
                hrRes = m_pBlockManager->ReadMemory(
                            (LPBYTE)&dwOriginalLink,
                            faOffset,
                            sizeof(DWORD),
                            &dwSize,
                            &cbContext);
                if (!SUCCEEDED(hrRes))
                    goto Cleanup;

                // Observe the flags
                if ((dwOriginalLink != INVALID_DOMAIN_INDEX) &&
                    (dwFlags & FLAG_FAIL_IF_SOURCE_DOMAIN_LINKED))
                {
                    hrRes = E_FAIL;
                    goto Cleanup;
                }

                // Read the target Link's next link
                hrRes = m_pBlockManager->ReadMemory(
                            (LPBYTE)&dwNextLink,
                            faNextOffset,
                            sizeof(DWORD),
                            &dwSize,
                            &cbNextContext);
                if (!SUCCEEDED(hrRes))
                    goto Cleanup;

                // Observe the flags
                // Also, if both the original and target domains are linked, we
                // have no way of fixing these links so we have to fail if
                // FLAG_OVERWRITE_EXISTING_LINKS is not specified
                if ((dwNextLink != INVALID_DOMAIN_INDEX) &&
                    (
                     (dwFlags & FLAG_FAIL_IF_NEXT_DOMAIN_LINKED) ||
                     (dwOriginalLink != INVALID_DOMAIN_INDEX)
                    ))
                {
                    hrRes = E_FAIL;
                    goto Cleanup;
                }
            }
            else
            {
                //we are overwriting exiting link information
                dwNextLink = INVALID_DOMAIN_INDEX;
                dwOriginalLink = INVALID_DOMAIN_INDEX;
            }
            // Write the source's next link
            hrRes = m_pBlockManager->WriteMemory(
                        (LPBYTE)&dwNextDomainIndexValue,
                        faOffset,
                        sizeof(DWORD),
                        &dwSize,
                        &cbContext);
            if (!SUCCEEDED(hrRes))
                goto Cleanup;

            // Hook'em up! (if there is a next link)
            if (!(FLAG_SET_FIRST_DOMAIN & dwFlags))
            {
                if (dwOriginalLink != INVALID_DOMAIN_INDEX)
                    dwNextLink = dwOriginalLink;
                if ((dwNextLink != INVALID_DOMAIN_INDEX) ||
                    (FLAG_OVERWRITE_EXISTING_LINKS & dwFlags))
                {
                    // Write the next link's next link
                    hrRes = m_pBlockManager->WriteMemory(
                                (LPBYTE)&dwNextLink,
                                faNextOffset,
                                sizeof(DWORD),
                                &dwSize,
                                &cbNextContext);
                }
            }
        }
    }

Cleanup:

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::InitializeRecipientFilterContext(
            LPRECIPIENT_FILTER_CONTEXT  pContext,
            DWORD                       dwStartingDomain,
            DWORD                       dwFilterFlags,
            DWORD                       dwFilterMask
            )
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::InitializeRecipientFilterContext");

    if (!pContext)
        return(E_POINTER);

    // First, get the domain item ...
    hrRes = DomainItemEx(
                dwStartingDomain,
                0,
                NULL,
                &(pContext->dwCurrentRecipientIndex),
                &(pContext->dwRecipientsLeftInDomain),
                &(pContext->dwNextDomain));
    if (SUCCEEDED(hrRes))
    {
        pContext->dwCurrentDomain = dwStartingDomain;
        pContext->dwFilterFlags = dwFilterFlags;
        pContext->dwFilterMask = dwFilterMask;
    }
    else
        pContext->dwCurrentDomain = INVALID_DOMAIN_INDEX;

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::TerminateRecipientFilterContext(
            LPRECIPIENT_FILTER_CONTEXT  pContext
            )
{
    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::TerminateRecipientFilterContext");

    if (!pContext)
        return(E_POINTER);
    pContext->dwCurrentDomain = INVALID_DOMAIN_INDEX;
    TraceFunctLeaveEx((LPARAM)this);
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::GetNextRecipient(
            LPRECIPIENT_FILTER_CONTEXT  pContext,
            DWORD                       *pdwRecipientIndex
            )
{
    HRESULT hrRes = E_FAIL;

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::GetNextRecipient");

    if (!pContext || !pdwRecipientIndex)
        return(E_POINTER);

    if (INVALID_DOMAIN_INDEX == pContext->dwCurrentDomain)
        return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

    // Fetch the next recipient that matches the criteria
    do
    {
        if (pContext->dwRecipientsLeftInDomain)
        {
            // This is easy, just return the index index
            *pdwRecipientIndex = (pContext->dwCurrentRecipientIndex)++;
            (pContext->dwRecipientsLeftInDomain)--;
            DebugTrace((LPARAM)this, "Returning next recipient, index %u",
                        *pdwRecipientIndex);
            hrRes = S_OK;
        }
        else
        {
            DWORD   dwNextDomain;
            DWORD   dwStartingIndex;
            DWORD   dwRecipientCount;

            // See if we have a next domain, we are done if not
            if (pContext->dwNextDomain == INVALID_DOMAIN_INDEX)
            {
                DebugTrace((LPARAM)this, "No more domains, we are done");
                hrRes = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
                break;
            }

            // Go on to the next domain
            DebugTrace((LPARAM)this, "Loading next domain, index %u",
                        pContext->dwNextDomain);
            hrRes = DomainItemEx(
                        pContext->dwNextDomain,
                        0,
                        NULL,
                        &dwStartingIndex,
                        &dwRecipientCount,
                        &dwNextDomain);
            if (SUCCEEDED(hrRes))
            {
                // A domain with zero recipients is by definition not allowed
                _ASSERT(dwRecipientCount);

                *pdwRecipientIndex = dwStartingIndex++;
                DebugTrace((LPARAM)this, "Returning first recipient, index %u",
                            *pdwRecipientIndex);
                pContext->dwCurrentDomain = pContext->dwNextDomain;
                pContext->dwCurrentRecipientIndex = dwStartingIndex;
                pContext->dwRecipientsLeftInDomain = --dwRecipientCount;
                pContext->dwNextDomain = dwNextDomain;
            }
            else
                pContext->dwCurrentDomain = INVALID_DOMAIN_INDEX;
        }

        // Now check if the recipient flags match the criteria
        if (SUCCEEDED(hrRes))
        {
            FLAT_ADDRESS    faOffset;
            DWORD           dwFlags, dwSize;

            // See if this is the one we want ...
            faOffset = m_pInstanceInfo->faFirstFragment;
            if (faOffset == INVALID_FLAT_ADDRESS)
            {
                hrRes = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                break;
            }
            faOffset += (sizeof(PROPERTY_TABLE_FRAGMENT) +
                         offsetof(RECIPIENTS_PROPERTY_ITEM, dwFlags) +
                         (sizeof(RECIPIENTS_PROPERTY_ITEM) * *pdwRecipientIndex)
                        );
            hrRes = m_pBlockManager->ReadMemory(
                        (LPBYTE)&dwFlags,
                        faOffset,
                        sizeof(DWORD),
                        &dwSize,
                        NULL);
            if (!SUCCEEDED(hrRes))
                break;

            // Compare the flags : we mask out the bits that we are interested in,
            // then we will make sure the interested bits are a perfect match.
            dwFlags &= pContext->dwFilterMask;
            if (dwFlags ^ pContext->dwFilterFlags)
                hrRes = E_FAIL;
            DebugTrace((LPARAM)this, "Masked recipient flags %08x, required flags: %08x, %smatched",
                        dwFlags, pContext->dwFilterFlags,
                        (dwFlags == pContext->dwFilterFlags)?"":"not ");
        }

    } while (!SUCCEEDED(hrRes));

    // Invalidate the context if we are done or we hit an error
    if (!SUCCEEDED(hrRes))
        pContext->dwCurrentDomain = INVALID_DOMAIN_INDEX;

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::AllocNewList(
            IMailMsgRecipientsAdd   **ppNewList
            )
{
    HRESULT                 hrRes = S_OK;
    CMailMsgRecipientsAdd   *pNewList;

    _ASSERT(m_pInstanceInfo);

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::AllocNewList");

    if (!ppNewList)
        return(E_POINTER);
    pNewList = new CMailMsgRecipientsAdd(m_pBlockManager);
    if (!pNewList)
        hrRes = E_OUTOFMEMORY;

    if (SUCCEEDED(hrRes))
    {
        // Get the correct interface
        hrRes = pNewList->QueryInterface(
                    IID_IMailMsgRecipientsAdd,
                    (LPVOID *)ppNewList);
        if (!SUCCEEDED(hrRes))
            pNewList->Release();
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::WriteList(
            IMailMsgRecipientsAdd   *pNewList
            )
{
    HRESULT                 hrRes = S_OK;
    CRecipientsHash         *pHash;

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::WriteList");

    if (!pNewList)
        return(E_POINTER);

    // Get the underlying implementation
    pHash = ((CMailMsgRecipientsAdd *)pNewList)->GetHashTable();

    do
    {
        DWORD                       dwDomainNameSize;
        DWORD                       dwRecipientNameSize;
        DWORD                       dwRecipientCount;
        DWORD                       dwDomainCount;

        DWORD                       dwTotalSize;
        DWORD                       dwSize;
        FLAT_ADDRESS                faBuffer;
        FLAT_ADDRESS                faFirstFragment;
        FLAT_ADDRESS                faDomainList;
        FLAT_ADDRESS                faRecipient;
        FLAT_ADDRESS                faStringTable;

        // Have different contexts for fastest access
        CBlockContext               bcDomain;
        CBlockContext               bcRecipient;
        CBlockContext               bcString;

        // This is a lengthy process since CMailMsgRecipientAdd will actually
        // go in and build the entire domain list
        hrRes = pHash->BuildDomainListFromHash((CMailMsgRecipientsAdd *)pNewList);
        if (!SUCCEEDED(hrRes))
            break;

        // OK, now we have a domain list, then collect the memory requirements
        pHash->GetDomainCount(&dwDomainCount);
        pHash->GetDomainNameSize(&dwDomainNameSize);
        pHash->GetRecipientCount(&dwRecipientCount);
        pHash->GetRecipientNameSize(&dwRecipientNameSize);
        m_dwDomainCount = dwDomainCount;

        //
        // The data will be laid out as follows:
        //
        // An EXTENDED_INFO structure
        // dwDomainCount entries of DOMAIN_TABLE_ENTRY
        // A single fragment of RECIPIENT_PROPERTY_TABLE_FRAGMENT with:
        //      dwRecipientCount entries of RECIPIENTS_PROPERTY_ITEM
        // A flat string table for all the domain and recipient name strings
        //

        // Calculate all the memory needed
        dwTotalSize = sizeof(EXTENDED_INFO) +
                        (sizeof(DOMAIN_TABLE_ENTRY) * dwDomainCount) +
                        sizeof(PROPERTY_TABLE_FRAGMENT) +
                        (sizeof(RECIPIENTS_PROPERTY_ITEM) * dwRecipientCount) +
                        dwDomainNameSize +
                        dwRecipientNameSize;

        DebugTrace((LPARAM)this, "%u bytes required to write recipient list",
                        dwTotalSize);

        // Allocate the memory
        hrRes = m_pBlockManager->AllocateMemory(
                        dwTotalSize,
                        &faBuffer,
                        &dwSize,
                        NULL);
        DebugTrace((LPARAM)this, "AllocateMemory: HRESULT = %08x", hrRes);
        if (!SUCCEEDED(hrRes))
            break;

        _ASSERT(dwSize >= dwTotalSize);

        // Fill in the info ... try to use the stack so that we minimize
        // other memory overhead
        {
            EXTENDED_INFO   eiInfo;

            eiInfo.dwDomainCount = dwDomainCount;
            eiInfo.dwTotalSizeIncludingThisStruct = dwTotalSize;

            hrRes = m_pBlockManager->WriteMemory(
                        (LPBYTE)&eiInfo,
                        faBuffer,
                        sizeof(EXTENDED_INFO),
                        &dwSize,
                        &bcDomain);
            DebugTrace((LPARAM)this, "WriteMemory: HRESULT = %08x", hrRes);
            if (!SUCCEEDED(hrRes))
                break;

        }

        // Set up all the pointers
        faDomainList = faBuffer + sizeof(EXTENDED_INFO);
        faRecipient = faDomainList +
                        (sizeof(DOMAIN_TABLE_ENTRY) * dwDomainCount);
        faStringTable = faRecipient +
                        sizeof(PROPERTY_TABLE_FRAGMENT) +
                        (sizeof(RECIPIENTS_PROPERTY_ITEM) * dwRecipientCount);

        // Build and write out the recipient table fragment
        {
            PROPERTY_TABLE_FRAGMENT     ptfFragment;

            ptfFragment.dwSignature = PROPERTY_FRAGMENT_SIGNATURE_VALID;
            ptfFragment.faNextFragment = INVALID_FLAT_ADDRESS;

            hrRes = m_pBlockManager->WriteMemory(
                        (LPBYTE)&ptfFragment,
                        faRecipient,
                        sizeof(PROPERTY_TABLE_FRAGMENT),
                        &dwSize,
                        &bcRecipient);
            if (!SUCCEEDED(hrRes))
                break;

            // Mark this for later
            faFirstFragment = faRecipient;
            faRecipient += sizeof(PROPERTY_TABLE_FRAGMENT);
        }

        // Build the domain table
        {
            DOMAIN_TABLE_ENTRY              dteEntry;
            DOMAIN_ITEM_CONTEXT             dicContext;
            LPRECIPIENTS_PROPERTY_ITEM_EX   pItemEx;
            LPRECIPIENTS_PROPERTY_ITEM      pItem;
            DWORD                           dwCurrentDomain = 0;
            DWORD                           dwCurrentIndex = 0;
            DWORD                           dwCount;
            DWORD                           dwLength;
            LPDOMAIN_LIST_ENTRY             pDomainListEntry;
            BOOL                            fGetFirstDomain = FALSE;

            hrRes = pHash->GetFirstDomain(
                        &dicContext,
                        &pItemEx,
                        &pDomainListEntry);
            DebugTrace((LPARAM)this, "GetFirstDomain: HRESULT = %08x", hrRes);
            fGetFirstDomain = TRUE;

            while (SUCCEEDED(hrRes))
            {
                dwCount = 0;
                // OK, process the domain by walking it's members
                while (pItemEx)
                {
                    DWORD   dwCurrentName;
                    DWORD_PTR faStack[MAX_COLLISION_HASH_KEYS];

                    // Obtain the record in stream form
                    pItem = &(pItemEx->rpiRecipient);

                    for (dwCurrentName = 0;
                         dwCurrentName < MAX_COLLISION_HASH_KEYS;
                         dwCurrentName++)
                    {
                        // Store the pointers ...
                        faStack[dwCurrentName] = pItem->faNameOffset[dwCurrentName];

                        // Write out valid names
                        if (faStack[dwCurrentName] != (FLAT_ADDRESS)NULL)
                        {
                            // Write out the first name
                            dwLength = pItem->dwNameLength[dwCurrentName];
                            hrRes = m_pBlockManager->WriteMemory(
                                        (LPBYTE)faStack[dwCurrentName],
                                        faStringTable,
                                        dwLength,
                                        &dwSize,
                                        &bcString);
                            if (!SUCCEEDED(hrRes))
                                break;

                            // Convert the pointer to an offset and bump the ptr
                            pItem->faNameOffset[dwCurrentName] = faStringTable;
                            faStringTable += dwLength;
                        }
                        else
                        {
                            // Name is not valid, so set it to invalid
                            pItem->faNameOffset[dwCurrentName] = INVALID_FLAT_ADDRESS;
                        }
                    }

                    // Finally, write out the recipient record
                    hrRes = m_pBlockManager->WriteMemory(
                                (LPBYTE)pItem,
                                faRecipient,
                                sizeof(RECIPIENTS_PROPERTY_ITEM),
                                &dwSize,
                                &bcRecipient);
                    if (!SUCCEEDED(hrRes))
                        break;

                    for (dwCurrentName = 0;
                         dwCurrentName < MAX_COLLISION_HASH_KEYS;
                         dwCurrentName++)
                    {
                        // Restore the pointers ...
                        pItem->faNameOffset[dwCurrentName] = (FLAT_ADDRESS) faStack[dwCurrentName];
                    }

                    // Bump the ptr
                    faRecipient += sizeof(RECIPIENTS_PROPERTY_ITEM);

                    // Do next item
                    dwCount++;
                    pItemEx = pItemEx->pNextInDomain;
                }

                // Don't continue if failed!
                if (!SUCCEEDED(hrRes))
                    break;

                // Write out the domain record
                dwLength = pDomainListEntry->dwDomainNameLength;
                dteEntry.dwStartingIndex = dwCurrentIndex;
                dteEntry.dwCount = dwCount;
                dteEntry.faOffsetToName = faStringTable;
                dteEntry.dwNameLength = dwLength;
                dteEntry.dwNextDomain = INVALID_DOMAIN_INDEX;
                dwCurrentIndex += dwCount;

                hrRes = m_pBlockManager->WriteMemory(
                            (LPBYTE)&dteEntry,
                            faDomainList,
                            sizeof(DOMAIN_TABLE_ENTRY),
                            &dwSize,
                            &bcDomain);
                if (!SUCCEEDED(hrRes))
                    break;

                // Bump the ptr
                faDomainList += sizeof(DOMAIN_TABLE_ENTRY);

                // Write out the domain name
                hrRes = m_pBlockManager->WriteMemory(
                            (LPBYTE)pDomainListEntry->szDomainName,
                            faStringTable,
                            dwLength,
                            &dwSize,
                            &bcString);
                if (!SUCCEEDED(hrRes))
                    break;

                // Bump the ptr
                faStringTable += dwLength;

                // OKay, up the count and get the next domain
                dwCurrentDomain++;
                hrRes = pHash->GetNextDomain(
                        &dicContext,
                        &pItemEx,
                        &pDomainListEntry);

                DebugTrace((LPARAM)this, "GetNextDomain: HRESULT = %08x", hrRes);
            }

            // Now, if everything is in order, we should have a failed
            // HRESULT of HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS).
            if (hrRes != HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
            {
                if (fGetFirstDomain) {
                    HRESULT hr = pHash->CloseDomainContext(&dicContext);
                    _ASSERT(SUCCEEDED(hr));
                }
                ErrorTrace((LPARAM)this, "Expecting ERROR_NO_MORE_ITEMS, got = %08x", hrRes);
            } else {
                hrRes = S_OK;
            }

        }// Stack frame

        // OKay, we've come this far, now all we are left to do is to
        // update our instance info structure to link to this new list
        // Note this will be flushed when the master header is committed
        dwSize = sizeof(PROPERTY_TABLE_FRAGMENT) +
                (sizeof(RECIPIENTS_PROPERTY_ITEM) * dwRecipientCount);

        // Hook up first fragment
        m_pInstanceInfo->faFirstFragment = faFirstFragment;

        // Update the fragment size
        m_pInstanceInfo->dwFragmentSize = dwSize;

        // Force to evaluate only 1 fragment
        m_pInstanceInfo->dwItemBits = 31;

        // Should not change, but for good measure
        m_pInstanceInfo->dwItemSize = sizeof(RECIPIENTS_PROPERTY_ITEM);

        // Properties = number of recipient records
        m_pInstanceInfo->dwProperties = dwRecipientCount;

        // Hook up to the EXTENDED_INFO struct
        m_pInstanceInfo->faExtendedInfo = faBuffer;

    } while (0);

    // Update the commit state
    if (SUCCEEDED(hrRes))
        m_fGlobalCommitDone = FALSE;

    TraceFunctLeave();
    return(hrRes);
}


/***************************************************************************/
//
// Implementation of CMailMsgRecipients::CMailMsgRecipientsPropertyBase
//



HRESULT STDMETHODCALLTYPE CMailMsgRecipients::Count(
            DWORD   *pdwCount
            )
{
    _ASSERT(m_pInstanceInfo);

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::Count");

    if (!pdwCount)
        return(E_POINTER);
    *pdwCount = m_pInstanceInfo->dwProperties;

    TraceFunctLeave();
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::Item(
            DWORD   dwIndex,
            DWORD   dwWhichName,
            DWORD   cchLength,
            LPSTR   pszName
            )
{
    HRESULT                     hrRes = S_OK;
    RECIPIENTS_PROPERTY_ITEM    piItem;

    _ASSERT(m_pBlockManager);
    _ASSERT(m_pInstanceInfo);

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::Item");

    if (!pszName)
        return(E_POINTER);

    // We know where the name is immediately
    if (dwWhichName >= MAX_COLLISION_HASH_KEYS)
        return(E_INVALIDARG);

    // Get the recipient item first
    {
        CPropertyTableItem      ptiItem(m_pBlockManager, m_pInstanceInfo);

        hrRes = ptiItem.GetItemAtIndex(
                        dwIndex,
                        (LPPROPERTY_ITEM)&piItem
                        );

        DebugTrace((LPARAM)this,
                    "GetItemAtIndex: index = %u, HRESULT = %08x",
                    dwIndex, hrRes);
    }
    if (SUCCEEDED(hrRes))
    {
        DWORD           dwSizeToRead;
        DWORD           dwSize;
        FLAT_ADDRESS    faOffset;

        dwSizeToRead = piItem.dwNameLength[dwWhichName];
        faOffset = piItem.faNameOffset[dwWhichName];

        if (faOffset == INVALID_FLAT_ADDRESS)
            return(STG_E_UNKNOWN);

        // See if we have enough buffer
        if (cchLength < dwSizeToRead)
            return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

        // Issue the read
        hrRes = m_pBlockManager->ReadMemory(
                        (LPBYTE)pszName,
                        faOffset,
                        dwSizeToRead,
                        &dwSize,
                        NULL);
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::PutProperty(
            DWORD   dwIndex,
            DWORD   dwPropID,
            DWORD   cbLength,
            LPBYTE  pbValue
            )
{
    HRESULT                     hrRes = S_OK;
    RECIPIENTS_PROPERTY_ITEM    piItem;
    FLAT_ADDRESS                faOffset;

    _ASSERT(m_pBlockManager);
    _ASSERT(m_pInstanceInfo);

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::PutProperty");

    // Get the recipient item first
    {
        CPropertyTableItem      ptiItem(m_pBlockManager, m_pInstanceInfo);

        hrRes = ptiItem.GetItemAtIndex(
                        dwIndex,
                        (LPPROPERTY_ITEM)&piItem,
                        &faOffset
                        );

        DebugTrace((LPARAM)this,
                    "GetItemAtIndex: index = %u, HRESULT = %08x",
                    dwIndex, hrRes);
    }
    if (SUCCEEDED(hrRes))
    {
        HRESULT myRes = S_OK;

        // Handle special properties first
        hrRes = m_SpecialPropertyTable.PutProperty(
                    (PROP_ID)dwPropID,
                    (LPVOID)&piItem,
                    (LPVOID)m_pBlockManager,
                    PT_NONE,
                    cbLength,
                    pbValue,
                    TRUE);
        if (SUCCEEDED(hrRes) && (hrRes != S_OK))
        {
            // Call the derived generic method
            hrRes = CMailMsgRecipientsPropertyBase::PutProperty(
                        m_pBlockManager,
                        &piItem,
                        dwPropID,
                        cbLength,
                        pbValue);

            //
            // There is a window here for concurrency problems: if two threads
            // try to add properties to the same recipient using this method, then
            // we will have a property ID step over, since we acquire and increment the
            // property ID value in a non-atomic manner.
            //
            // Note that IMailMsgRecipientsAdd::PutProperty does not have this problem
            //
            if (SUCCEEDED(hrRes) &&
                (hrRes == S_FALSE))
            {
                //mikeswa - changed 7/8/98 write entire item to memory
                LPBYTE      pbTemp = (LPBYTE)&piItem;
                myRes = m_pBlockManager->WriteMemory(
                            pbTemp,
                            faOffset,
                            sizeof(RECIPIENTS_PROPERTY_ITEM),
                            &cbLength,
                            NULL);
            }

        }
        else if (SUCCEEDED(hrRes))
        {
            LPBYTE      pbTemp = (LPBYTE)&piItem;
            myRes = m_pBlockManager->WriteMemory(
                        pbTemp,
                        faOffset,
                        sizeof(RECIPIENTS_PROPERTY_ITEM),
                        &cbLength,
                        NULL);
        }

        // Here, if any of the writes failed, we will return an error
        // note, myRes being not S_OK implies hrRes being successful.
        if (FAILED(myRes))
            hrRes = myRes;
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::GetProperty(
            DWORD   dwIndex,
            DWORD   dwPropID,
            DWORD   cbLength,
            DWORD   *pcbLength,
            LPBYTE  pbValue
            )
{
    HRESULT                     hrRes = S_OK;
    RECIPIENTS_PROPERTY_ITEM    piItem;

    _ASSERT(m_pBlockManager);
    _ASSERT(m_pInstanceInfo);

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::GetProperty");

    if (!pcbLength || !pbValue)
        return(E_POINTER);

    *pcbLength = 0;

    // Get the recipient item first
    {
        CPropertyTableItem      ptiItem(m_pBlockManager, m_pInstanceInfo);

        hrRes = ptiItem.GetItemAtIndex(
                        dwIndex,
                        (LPPROPERTY_ITEM)&piItem
                        );

        DebugTrace((LPARAM)this,
                    "GetItemAtIndex: index = %u, HRESULT = %08x",
                    dwIndex, hrRes);
    }
    if (SUCCEEDED(hrRes))
    {
        // Special properties are optimized
        // Handle special properties first
        hrRes = m_SpecialPropertyTable.GetProperty(
                    (PROP_ID)dwPropID,
                    (LPVOID)&piItem,
                    (LPVOID)m_pBlockManager,
                    PT_NONE,
                    cbLength,
                    pcbLength,
                    pbValue,
                    TRUE);
        if (SUCCEEDED(hrRes) && (hrRes != S_OK))
        {
            // Call the derived generic method
            hrRes = CMailMsgRecipientsPropertyBase::GetProperty(
                        m_pBlockManager,
                        &piItem,
                        dwPropID,
                        cbLength,
                        pcbLength,
                        pbValue);
        }
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipients::CopyTo(
            DWORD                   dwSourceRecipientIndex,
            IMailMsgRecipientsBase  *pTargetRecipientList,
            DWORD                   dwTargetRecipientIndex,
            DWORD                   dwExemptCount,
            DWORD                   *pdwExemptPropIdList
            )
{
    HRESULT                         hrRes = S_OK;
    RECIPIENTS_PROPERTY_ITEM        piItem;
    LPRECIPIENTS_PROPERTY_ITEM      pRcptItem;
    RECIPIENT_PROPERTY_ITEM         piRcptItem;
    DWORD                           dwIndex;
    DWORD                           dwExempt;
    DWORD                           *pdwExemptId;
    BOOL                            fExempt;

    BYTE                            rgbCopyBuffer[4096];
    DWORD                           dwBufferSize = sizeof(rgbCopyBuffer);
    DWORD                           dwSizeRead;
    LPBYTE                          pBuffer = rgbCopyBuffer;

    if (!pTargetRecipientList)
        return(E_POINTER);
    if (dwExemptCount)
    {
        _ASSERT(pdwExemptPropIdList);
        if (!pdwExemptPropIdList)
            return(E_POINTER);
    }
    _ASSERT(m_pBlockManager);
    _ASSERT(m_pInstanceInfo);

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipients::CopyTo");

    // Get the recipient item first
    CPropertyTableItem      ptiItem(m_pBlockManager, m_pInstanceInfo);
    hrRes = ptiItem.GetItemAtIndex(
                    dwSourceRecipientIndex,
                    (LPPROPERTY_ITEM)&piItem
                    );
    DebugTrace((LPARAM)this,
                "GetItemAtIndex: index = %u, HRESULT = %08x",
                dwSourceRecipientIndex, hrRes);
    if (sizeof(RECIPIENT_PROPERTY_ITEM) != piItem.ptiInstanceInfo.dwItemSize)
    {
        ErrorTrace((LPARAM)this, "Message is corrupt");
        hrRes = HRESULT_FROM_WIN32(ERROR_FILE_CORRUPT);
    }

    if (SUCCEEDED(hrRes))
    {
        DWORD   dwTempFlags;

        pRcptItem = &piItem;

        // Iteratively copy all properties from the source to the target, avoiding
        // those in the exempt list note that special name properties are not copied.

        // First, copy the recipient flags as a special property
        dwTempFlags = piItem.dwFlags &
            ~(FLAG_RECIPIENT_DO_NOT_DELIVER | FLAG_RECIPIENT_NO_NAME_COLLISIONS);
        DebugTrace((LPARAM)this, "Copying recipient flags (%08x)", dwTempFlags);
        hrRes = pTargetRecipientList->PutProperty(
                    dwTargetRecipientIndex,
                    IMMPID_RP_RECIPIENT_FLAGS,
                    sizeof(DWORD),
                    (LPBYTE)&dwTempFlags);
        if (FAILED(hrRes))
        {
            ErrorTrace((LPARAM)this, "Failed to copy recipient flags (%08x)", hrRes);
            TraceFunctLeaveEx((LPARAM)this);
            return(hrRes);
        }

        // Instantiate a property table for the recipient properties
        LPPROPERTY_TABLE_INSTANCE   pInstance =
                                        &(pRcptItem->ptiInstanceInfo);
        CPropertyTable              ptProperties(
                                        PTT_PROPERTY_TABLE,
                                        RECIPIENT_PTABLE_INSTANCE_SIGNATURE_VALID,
                                        m_pBlockManager,
                                        pInstance,
                                        CMailMsgRecipientsPropertyBase::CompareProperty,
                                        CMailMsgRecipientsPropertyBase::s_pWellKnownProperties,
                                        CMailMsgRecipientsPropertyBase::s_dwWellKnownProperties
                                        );

        dwIndex = 0;
        do
        {
            // Get the recipient property using an atomic operation
            hrRes = ptProperties.GetPropertyItemAndValueUsingIndex(
                                dwIndex,
                                (LPPROPERTY_ITEM)&piRcptItem,
                                dwBufferSize,
                                &dwSizeRead,
                                pBuffer);
            if (hrRes == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
            {
                // Insufficient buffer, try a bigger buffer
                do { dwBufferSize <<= 1; } while (dwBufferSize < piRcptItem.piItem.dwSize);
                pBuffer = new BYTE [dwBufferSize];
                if (!pBuffer)
                {
                    hrRes = E_OUTOFMEMORY;
                    ErrorTrace((LPARAM)this,
                                "Unable to temporarily allocate %u bytes, HRESULT = %08x",
                                dwBufferSize, hrRes);
                    goto Cleanup;
                }

                // Read it with the proper buffer
                hrRes = m_pBlockManager->ReadMemory(
                            pBuffer,
                            piRcptItem.piItem.faOffset,
                            piRcptItem.piItem.dwSize,
                            &dwSizeRead,
                            NULL);
            }

            DebugTrace((LPARAM)this,
                        "Read: [%u] PropID = %u, length = %u, HRESULT = %08x",
                        dwIndex,
                        piRcptItem.idProp,
                        piRcptItem.piItem.dwSize,
                        hrRes);

            if (SUCCEEDED(hrRes))
            {
                // See if this is an exempt property
                for (dwExempt = 0,
                     pdwExemptId = pdwExemptPropIdList,
                     fExempt = FALSE;
                     dwExempt < dwExemptCount;
                     dwExempt++,
                     pdwExemptId++)
                    if (piRcptItem.idProp == *pdwExemptId)
                    {
                        DebugTrace((LPARAM)this, "Property exempted");
                        fExempt = TRUE;
                        break;
                    }

                if (!fExempt)
                {
                    // Write it out the the target object
                    hrRes = pTargetRecipientList->PutProperty(
                                dwTargetRecipientIndex,
                                piRcptItem.idProp,
                                piRcptItem.piItem.dwSize,
                                pBuffer);

                    DebugTrace((LPARAM)this, "Write: HRESULT = %08x", hrRes);
                }

                // Next
                dwIndex++;
            }

        } while (SUCCEEDED(hrRes));

        // Correct the error code
        if (hrRes == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
            hrRes = S_OK;
    }

Cleanup:

    if (pBuffer && pBuffer != rgbCopyBuffer)
        delete [] pBuffer;

    TraceFunctLeave();
    return(hrRes);
}

// *************************************************************************************
// *************************************************************************************
// *************************************************************************************
// *************************************************************************************

// =================================================================
// Implementation of CMailMsgRecipientsAdd
//

#define ADD_DEFAULT_RECIPIENT_NAME_BUFFER_SIZE      2048


CMailMsgRecipientsAdd::CMailMsgRecipientsAdd(
            CBlockManager               *pBlockManager
            )
            :
            m_SpecialPropertyTable(&g_SpecialRecipientsAddPropertyTable)
{
    _ASSERT(pBlockManager);

    // Initialize the refcount
    m_ulRefCount = 0;

    // Acquire the block manager
    m_pBlockManager = pBlockManager;

    // Initialize the internal property table instance
    MoveMemory(
            &m_InstanceInfo,
            &s_DefaultInstance,
            sizeof(PROPERTY_TABLE_INSTANCE));
}

CMailMsgRecipientsAdd::~CMailMsgRecipientsAdd()
{
}

HRESULT CMailMsgRecipientsAdd::QueryInterface(
            REFIID      iid,
            void        **ppvObject
            )
{
    if (iid == IID_IUnknown)
    {
        // Return our identity
        *ppvObject = (IUnknown *)(IMailMsgRecipientsAdd *)this;
        AddRef();
    }
    else if (iid == IID_IMailMsgRecipientsAdd)
    {
        // Return the add recipients interface
        *ppvObject = (IMailMsgRecipientsAdd *)this;
        AddRef();
    }
    else if (iid == IID_IMailMsgRecipientsBase)
    {
        // Return the base recipients interface
        *ppvObject = (IMailMsgRecipientsBase *)this;
        AddRef();
    }
    else if (iid == IID_IMailMsgPropertyReplication)
    {
        // Return the base recipients interface
        *ppvObject = (IMailMsgPropertyReplication *)this;
        AddRef();
    }
    else
        return(E_NOINTERFACE);

    return(S_OK);
}

ULONG CMailMsgRecipientsAdd::AddRef()
{
    return(InterlockedIncrement(&m_ulRefCount));
}

ULONG CMailMsgRecipientsAdd::Release()
{
    LONG    lRefCount = InterlockedDecrement(&m_ulRefCount);
    if (lRefCount == 0)
    {
        delete this;
    }
    return(lRefCount);
}

HRESULT CMailMsgRecipientsAdd::AddPrimaryOrSecondary(
            DWORD                   dwCount,
            LPCSTR                  *ppszNames,
            DWORD                   *pdwPropIDs,
            DWORD                   *pdwIndex,
            IMailMsgRecipientsBase  *pFrom,
            DWORD                   dwFrom,
            BOOL                    fPrimary
            )
{
    HRESULT hrRes = S_OK;
    BOOL    fLockTaken = FALSE;

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::AddPrimaryOrSecondary");

    if (dwCount)
    {
        if (!ppszNames || !pdwPropIDs || !pdwIndex)
            return(E_POINTER);
    }

    // If we have a count of zero, by default, we will copy all the
    // names of the source recipient to the new recipient. However,
    // if a source recipient is not specified, then this is an error
    if (dwCount || pFrom)
    {
        DWORD   i;
        BOOL    rgfAllocated[MAX_COLLISION_HASH_KEYS];
        DWORD   rgPropIDs[MAX_COLLISION_HASH_KEYS];
        LPBYTE  rgszNames[MAX_COLLISION_HASH_KEYS];

        for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++)
            rgfAllocated[i] = FALSE;

        CMemoryAccess   cmaAccess;

        if (!dwCount)
        {
            DWORD   dwPropID;
            DWORD   dwLength;
            BYTE    pBuffer[ADD_DEFAULT_RECIPIENT_NAME_BUFFER_SIZE];
            LPBYTE  pNameStart;
            DWORD   dwRemaining     = ADD_DEFAULT_RECIPIENT_NAME_BUFFER_SIZE;

            ppszNames = (LPCSTR*)rgszNames;
            pdwPropIDs = rgPropIDs;
            pNameStart = pBuffer;

            // OK, copy the default names ...
            for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++)
            {
                rgfAllocated[i] = FALSE;
                dwPropID = rgDefaultAddressTypes[i];
                hrRes = pFrom->GetProperty(
                            dwFrom,
                            dwPropID,
                            dwRemaining,
                            &dwLength,
                            pNameStart);
                if (hrRes == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
                {
                    // Insufficient buffer, allocate and retry
                    hrRes = cmaAccess.AllocBlock(
                                (LPVOID *)&(rgszNames[dwCount]),
                                dwLength);
                    if (SUCCEEDED(hrRes))
                    {
                        hrRes = pFrom->GetProperty(
                                    dwFrom,
                                    dwPropID,
                                    dwLength,
                                    &dwLength,
                                    rgszNames[dwCount]);
                        if (SUCCEEDED(hrRes)) {
                            // we successfully read the property.  mark
                            // this rgszName as allocated so that we 
                            // free it on exit
                            rgfAllocated[dwCount] = TRUE;
                        } else {
                            // couldn't read the address.  free up the 
                            // space that we just allocated.
                            cmaAccess.FreeBlock((LPVOID)rgszNames[dwCount]);
                            rgszNames[dwCount] = NULL;
                            _ASSERT(rgfAllocated[dwCount] == FALSE);
                        }
                    }
                }
                else if (SUCCEEDED(hrRes))
                {
                    _ASSERT(dwRemaining >= dwLength);
                    rgszNames[dwCount] = pNameStart;
                    pNameStart += dwLength;
                    dwRemaining -= dwLength;
                }

                if (SUCCEEDED(hrRes))
                {
                    // OK, got a name, now set the prop ID and
                    // bump the count
                    rgPropIDs[dwCount] = dwPropID;
                    dwCount++;
                }
                else if (hrRes == STG_E_UNKNOWN)
                    hrRes = S_OK;
                else
                {
                    ErrorTrace((LPARAM)this, "Error in GetProperty, hr=%08x", hrRes);
                }
            }
        }

        if (SUCCEEDED(hrRes))
        {
            if (dwCount)
            {
                _ASSERT(ppszNames);
                _ASSERT(pdwPropIDs);

                m_Hash.Lock();
                fLockTaken = TRUE;
                if (fPrimary)
                {
                    hrRes = m_Hash.AddPrimary(
                                    dwCount,
                                    ppszNames,
                                    pdwPropIDs,
                                    pdwIndex);
                }
                else
                {
                    hrRes = m_Hash.AddSecondary(
                                    dwCount,
                                    ppszNames,
                                    pdwPropIDs,
                                    pdwIndex);
                }
            }
            else
            {
                ErrorTrace((LPARAM)this, "No recipient names specified or an error occurred");
                hrRes = E_FAIL;
            }
        }

        // Free any allocated memory
        for (i = 0; i < MAX_COLLISION_HASH_KEYS; i++)
            if (rgfAllocated[i])
            {
                HRESULT myRes;
                myRes = cmaAccess.FreeBlock((LPVOID)rgszNames[i]);
                _ASSERT(SUCCEEDED(myRes));
            }
    }
    else
    {
        ErrorTrace((LPARAM)this, "No recipient names specified, and no source to copy from");
        hrRes = E_INVALIDARG;
    }

    if (SUCCEEDED(hrRes) && pFrom)
    {
        HRESULT                     hrRep;
        IMailMsgPropertyReplication *pReplication = NULL;

        // Copy the properties over
        hrRep = pFrom->QueryInterface(
                    IID_IMailMsgPropertyReplication,
                    (LPVOID *)&pReplication);
        if (SUCCEEDED(hrRep))
        {
            // Copy all properties, be careful not to overwrite anything
            // that we just set.
            hrRep = pReplication->CopyTo(
                    dwFrom,
                    (IMailMsgRecipientsBase *)this,
                    *pdwIndex,
                    dwCount,
                    pdwPropIDs);

            // Done with the replication interface
            pReplication->Release();
        }

        // Remove the recipient if we fail here
        if (FAILED(hrRep))
        {
            HRESULT myRes = m_Hash.RemoveRecipient(*pdwIndex);
            _ASSERT(SUCCEEDED(myRes));

            // Return this error instead
            hrRes = hrRep;
        }
    }

    if (fLockTaken)
        m_Hash.Unlock();

    TraceFunctLeave();
    return(hrRes);
}

HRESULT CMailMsgRecipientsAdd::AddPrimary(
            DWORD                   dwCount,
            LPCSTR                  *ppszNames,
            DWORD                   *pdwPropIDs,
            DWORD                   *pdwIndex,
            IMailMsgRecipientsBase  *pFrom,
            DWORD                   dwFrom
            )
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::AddPrimary");

    hrRes = AddPrimaryOrSecondary(
                dwCount,
                ppszNames,
                pdwPropIDs,
                pdwIndex,
                pFrom,
                dwFrom,
                TRUE);

    TraceFunctLeave();
    return(hrRes);
}

HRESULT CMailMsgRecipientsAdd::AddSecondary(
            DWORD                   dwCount,
            LPCSTR                  *ppszNames,
            DWORD                   *pdwPropIDs,
            DWORD                   *pdwIndex,
            IMailMsgRecipientsBase  *pFrom,
            DWORD                   dwFrom
            )
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::AddSecondary");

    hrRes = AddPrimaryOrSecondary(
                dwCount,
                ppszNames,
                pdwPropIDs,
                pdwIndex,
                pFrom,
                dwFrom,
                FALSE);

    TraceFunctLeave();
    return(hrRes);
}

/***************************************************************************/
//
// Implementation of CMailMsgRecipientsAdd::CMailMsgRecipientsPropertyBase
//


HRESULT STDMETHODCALLTYPE CMailMsgRecipientsAdd::Count(
            DWORD   *pdwCount
            )
{
    HRESULT hrRes;

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::Count");

    if (!pdwCount)
        return(E_POINTER);
    hrRes = m_Hash.GetRecipientCount(pdwCount);

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipientsAdd::Item(
            DWORD   dwIndex,
            DWORD   dwWhichName,
            DWORD   cchLength,
            LPSTR   pszName
            )
{
    HRESULT                         hrRes = S_OK;
    LPRECIPIENTS_PROPERTY_ITEM_EX   pItem = NULL;

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::Item");

    // Get a pointer to the recipient from the index
    hrRes = m_Hash.GetRecipient(dwIndex, &pItem);

    if (FAILED(hrRes))
        return(E_POINTER);

    if (!pItem || !pszName)
        return(E_POINTER);

    if (pItem->dwSignature != RECIPIENTS_PROPERTY_ITEM_EX_SIG)
        return E_POINTER;

    if (dwWhichName >= MAX_COLLISION_HASH_KEYS)
        return(E_INVALIDARG);

    // Copy the name over
    if (!pItem->rpiRecipient.faNameOffset[dwWhichName])
        return(STG_E_UNKNOWN);
    if (cchLength < pItem->rpiRecipient.dwNameLength[dwWhichName])
        return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
    MoveMemory(pszName,
                (LPVOID)((pItem->rpiRecipient).faNameOffset[dwWhichName]),
                pItem->rpiRecipient.dwNameLength[dwWhichName]);

    TraceFunctLeave();
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipientsAdd::PutProperty(
            DWORD   dwIndex,
            DWORD   dwPropID,
            DWORD   cbLength,
            LPBYTE  pbValue
            )
{
    HRESULT                         hrRes = S_OK;
    LPRECIPIENTS_PROPERTY_ITEM_EX   pItem = NULL;
    LPRECIPIENTS_PROPERTY_ITEM      pRcptItem;

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::PutProperty");

    // Get a pointer to the recipient from the index
    hrRes = m_Hash.GetRecipient(dwIndex, &pItem);

    if (FAILED(hrRes))
        return(E_POINTER);

    if (!pItem || !pbValue)
        return(E_POINTER);

    if (pItem->dwSignature != RECIPIENTS_PROPERTY_ITEM_EX_SIG)
        return E_POINTER;

    pRcptItem = &(pItem->rpiRecipient);
    _ASSERT(pRcptItem);

    // Handle special properties first
    hrRes = m_SpecialPropertyTable.PutProperty(
                (PROP_ID)dwPropID,
                (LPVOID)pRcptItem,
                NULL,
                PT_NONE,
                cbLength,
                pbValue,
                TRUE);
    if (SUCCEEDED(hrRes) && (hrRes != S_OK))
    {
        // Call the derived generic method
        hrRes = CMailMsgRecipientsPropertyBase::PutProperty(
                    m_pBlockManager,
                    pRcptItem,
                    dwPropID,
                    cbLength,
                    pbValue);
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipientsAdd::GetProperty(
            DWORD   dwIndex,
            DWORD   dwPropID,
            DWORD   cbLength,
            DWORD   *pcbLength,
            LPBYTE  pbValue
            )
{
    HRESULT                         hrRes = S_OK;
    LPRECIPIENTS_PROPERTY_ITEM_EX   pItem = NULL;

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::GetProperty");

    // Get a pointer to the recipient from the index
    hrRes = m_Hash.GetRecipient(dwIndex, &pItem);

    if (FAILED(hrRes))
        return(E_POINTER);

    hrRes = GetPropertyInternal(
                pItem,
                dwPropID,
                cbLength,
                pcbLength,
                pbValue);

    return hrRes;
}


HRESULT CMailMsgRecipientsAdd::GetPropertyInternal(
            LPRECIPIENTS_PROPERTY_ITEM_EX   pItem,
            DWORD   dwPropID,
            DWORD   cbLength,
            DWORD   *pcbLength,
            LPBYTE  pbValue
            )
{
    HRESULT                         hrRes = S_OK;
    LPRECIPIENTS_PROPERTY_ITEM      pRcptItem;

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::GetProperty");

    if (!pItem || !pcbLength || !pbValue)
        return(E_POINTER);

    if (pItem->dwSignature != RECIPIENTS_PROPERTY_ITEM_EX_SIG)
        return E_POINTER;

    *pcbLength = 0;

    pRcptItem = &(pItem->rpiRecipient);
    _ASSERT(pRcptItem);

    // Special properties are optimized
    // Handle special properties first
    hrRes = m_SpecialPropertyTable.GetProperty(
                (PROP_ID)dwPropID,
                (LPVOID)pRcptItem,
                NULL,
                PT_NONE,
                cbLength,
                pcbLength,
                pbValue,
                TRUE);
    if (SUCCEEDED(hrRes) && (hrRes != S_OK))
    {
        // Call the derived generic method
        hrRes = CMailMsgRecipientsPropertyBase::GetProperty(
                    m_pBlockManager,
                    pRcptItem,
                    dwPropID,
                    cbLength,
                    pcbLength,
                    pbValue);
    }

    TraceFunctLeave();
    return(hrRes);
}

HRESULT STDMETHODCALLTYPE CMailMsgRecipientsAdd::CopyTo(
            DWORD                   dwSourceRecipientIndex,
            IMailMsgRecipientsBase  *pTargetRecipientList,
            DWORD                   dwTargetRecipientIndex,
            DWORD                   dwExemptCount,
            DWORD                   *pdwExemptPropIdList
            )
{
    HRESULT                         hrRes = S_OK;
    LPRECIPIENTS_PROPERTY_ITEM_EX   pItem = NULL;
    LPRECIPIENTS_PROPERTY_ITEM      pRcptItem;
    RECIPIENT_PROPERTY_ITEM         piRcptItem;
    DWORD                           dwTempFlags;
    DWORD                           dwIndex;
    DWORD                           dwExempt;
    DWORD                           *pdwExemptId;
    BOOL                            fExempt;

    BYTE                            rgbCopyBuffer[4096];
    DWORD                           dwBufferSize = sizeof(rgbCopyBuffer);
    DWORD                           dwSizeRead;
    LPBYTE                          pBuffer = rgbCopyBuffer;

    if (!pTargetRecipientList)
        return(E_POINTER);
    if (dwExemptCount)
    {
        if (!pdwExemptPropIdList)
            return(E_POINTER);
    }

    TraceFunctEnterEx((LPARAM)this, "CMailMsgRecipientsAdd::CopyTo");

    // Get a pointer to the recipient from the index
    hrRes = m_Hash.GetRecipient(dwSourceRecipientIndex, &pItem);

    if (FAILED(hrRes))
        return(E_POINTER);

    if (!pItem)
        return E_POINTER;

    if (pItem->dwSignature != RECIPIENTS_PROPERTY_ITEM_EX_SIG)
        return E_POINTER;

    pRcptItem = &(pItem->rpiRecipient);

    // Iteratively copy all properties from the source to the target, avoiding
    // those in the exempt list note that special name properties are not copied.

    // First, copy the recipient flags as a special property
    dwTempFlags = pRcptItem->dwFlags &
        ~(FLAG_RECIPIENT_DO_NOT_DELIVER | FLAG_RECIPIENT_NO_NAME_COLLISIONS);
    DebugTrace((LPARAM)this, "Copying recipient flags (%08x)", dwTempFlags);
    hrRes = pTargetRecipientList->PutProperty(
                dwTargetRecipientIndex,
                IMMPID_RP_RECIPIENT_FLAGS,
                sizeof(DWORD),
                (LPBYTE)&dwTempFlags);
    if (FAILED(hrRes))
    {
        ErrorTrace((LPARAM)this, "Failed to copy recipient flags (%08x)", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    // Instantiate a property table for the recipient properties
    LPPROPERTY_TABLE_INSTANCE   pInstance =
                                    &(pRcptItem->ptiInstanceInfo);
    CPropertyTable              ptProperties(
                                    PTT_PROPERTY_TABLE,
                                    RECIPIENT_PTABLE_INSTANCE_SIGNATURE_VALID,
                                    m_pBlockManager,
                                    pInstance,
                                    CMailMsgRecipientsPropertyBase::CompareProperty,
                                    CMailMsgRecipientsPropertyBase::s_pWellKnownProperties,
                                    CMailMsgRecipientsPropertyBase::s_dwWellKnownProperties
                                    );

    dwIndex = 0;
    do
    {
        // Get the recipient property using an atomic operation
        hrRes = ptProperties.GetPropertyItemAndValueUsingIndex(
                            dwIndex,
                            (LPPROPERTY_ITEM)&piRcptItem,
                            dwBufferSize,
                            &dwSizeRead,
                            pBuffer);
        if (hrRes == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
            // Insufficient buffer, try a bigger buffer
            do { dwBufferSize <<= 1; } while (dwBufferSize < piRcptItem.piItem.dwSize);
            pBuffer = new BYTE [dwBufferSize];
            if (!pBuffer)
            {
                hrRes = E_OUTOFMEMORY;
                ErrorTrace((LPARAM)this,
                            "Unable to temporarily allocate %u bytes, HRESULT = %08x",
                            dwBufferSize, hrRes);
                goto Cleanup;
            }

            // Read it with the proper buffer
            hrRes = m_pBlockManager->ReadMemory(
                        pBuffer,
                        piRcptItem.piItem.faOffset,
                        piRcptItem.piItem.dwSize,
                        &dwSizeRead,
                        NULL);
        }

        DebugTrace((LPARAM)this,
                    "Read: [%u] PropID = %u, length = %u, HRESULT = %08x",
                    dwIndex,
                    piRcptItem.idProp,
                    piRcptItem.piItem.dwSize,
                    hrRes);

        // See if this is an exempt property
        for (dwExempt = 0,
             pdwExemptId = pdwExemptPropIdList,
             fExempt = FALSE;
             dwExempt < dwExemptCount;
             dwExempt++,
             pdwExemptId++)
            if (piRcptItem.idProp == *pdwExemptId)
            {
                DebugTrace((LPARAM)this, "Property exempted");
                fExempt = TRUE;
                break;
            }

        if (SUCCEEDED(hrRes) && !fExempt)
        {
            // Write it out the the target object
            hrRes = pTargetRecipientList->PutProperty(
                        dwTargetRecipientIndex,
                        piRcptItem.idProp,
                        piRcptItem.piItem.dwSize,
                        pBuffer);

            DebugTrace((LPARAM)this, "Write: HRESULT = %08x", hrRes);
        }

        // Next
        dwIndex++;

    } while (SUCCEEDED(hrRes));

    // Correct the error code
    if (hrRes == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
        hrRes = S_OK;

Cleanup:

    if (pBuffer && pBuffer != rgbCopyBuffer)
        delete [] pBuffer;

    TraceFunctLeave();
    return(hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\cmmutils.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cmmutils.h

Abstract:

	This module contains the definition of the support facilities for
	CMailMsg

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/11/98	created

--*/

#ifndef _CMMUTILS_H_
#define _CMMUTILS_H_

#include "rwnew.h"

#include "blockmgr.h"
#include "cmmtypes.h"
#include "lkrhash.h"
#include "crchash.h"

#include "qwiklist.h"

class CMailMsgRecipientsAdd;

// =================================================================
// Definitions
//

//
// Define a structure that constitutes to a node in the domain
// name list. Note this structure is only used as an overlay
// for pre-allocated block of memory that includes sufficient
// storage for the domain name. Never trust sizeof(DOMAIN_MEMBER_LIST)
//
typedef struct _DOMAIN_LIST_ENTRY
{
    long                            m_cRefs;            // reference count
    CMemoryAccess                   *m_pcmaAccess;      // memory allocator to
                                                        //   free with
	LPRECIPIENTS_PROPERTY_ITEM_EX	pFirstDomainMember; // Link to first in domain
	DWORD							dwDomainNameLength;	// Length of domain name
	char							szDomainName[1];	// Dummy marker for domain name

} DOMAIN_LIST_ENTRY, *LPDOMAIN_LIST_ENTRY;



//
// Define a structure that constitutes an entry in the hash table
//
typedef struct _COLLISION_HASH_ENTRY
{
	LPRECIPIENTS_PROPERTY_ITEM_EX	pFirstEntry[MAX_COLLISION_HASH_KEYS];
									// First entry in each hash

} COLLISION_HASH_ENTRY, *LPCOLLISION_HASH_ENTRY;

//
// We'll use a constant for the hash size for now ...
//
#define COLLISION_HASH_BUCKETS_BITS		8
#define COLLISION_HASH_BUCKETS			(1 << COLLISION_HASH_BUCKETS_BITS)
#define COLLISION_HASH_BUCKETS_MASK		(COLLISION_HASH_BUCKETS - 1)

#define DOMAIN_HASH_BUCKETS_BITS		3
#define DOMAIN_HASH_BUCKETS				(1 << DOMAIN_HASH_BUCKETS_BITS)
#define DOMAIN_HASH_BUCKETS_MASK		(DOMAIN_HASH_BUCKETS - 1)


// =================================================================
// Definitions
//

//
// There is one of these hash tables for each of the address types.
// The key for each table is the address and length of the address.
// The data is the RECIPIENTS_PROPERTY_ITEM_EX for this recipient.
//
template <int __iKey>
class CRecipientsHashTable :
    public CTypedHashTable<CRecipientsHashTable<__iKey>,
                           RECIPIENTS_PROPERTY_ITEM_EX,
                           const RECIPIENTS_PROPERTY_ITEM_HASHKEY *>
{
    public:
        CRecipientsHashTable() :
            CTypedHashTable<CRecipientsHashTable<__iKey>,
                            RECIPIENTS_PROPERTY_ITEM_EX,
                            const RECIPIENTS_PROPERTY_ITEM_HASHKEY *>(
                                "recipientshash",
                                (double) LK_DFLT_MAXLOAD,
                                LK_SMALL_TABLESIZE,
                                1) // one subtable
        {
            TraceFunctEnter("CRecipientsHashTable");
            TraceFunctLeave();
        }

        ~CRecipientsHashTable() {
            TraceFunctEnter("~CRecipientsHashTable");
            TraceFunctLeave();
        }

        static const RECIPIENTS_PROPERTY_ITEM_HASHKEY *ExtractKey(const RECIPIENTS_PROPERTY_ITEM_EX *pRpie) {
            _ASSERT(__iKey >= 0 && __iKey <= MAX_COLLISION_HASH_KEYS);
            return &(pRpie->rgHashKeys[__iKey]);
        }

        static DWORD CalcKeyHash(const RECIPIENTS_PROPERTY_ITEM_HASHKEY *pHashkey) {
            return CRCHashNoCase(pHashkey->pbKey, pHashkey->cKey);
        }

        static bool EqualKeys(const RECIPIENTS_PROPERTY_ITEM_HASHKEY *pKey1,
                              const RECIPIENTS_PROPERTY_ITEM_HASHKEY *pKey2) {
            return (pKey1->cKey == pKey2->cKey &&
                    _strnicmp((const char *) pKey1->pbKey,
                              (const char *) pKey2->pbKey,
                              pKey1->cKey) == 0);
        }

        static void AddRefRecord(RECIPIENTS_PROPERTY_ITEM_EX *pRpie,
                                 int nIncr)
        {
            if (nIncr == 1) {
                _ASSERT(pRpie->m_cRefs >= 1);
                InterlockedIncrement(&pRpie->m_cRefs);
            } else if (nIncr == -1) {
                _ASSERT(pRpie->m_cRefs >= 2);
                long x = InterlockedDecrement(&pRpie->m_cRefs);
                // we should never drop to 0 references because the
                // list should always hold one
                _ASSERT(pRpie->m_cRefs != 0);
            } else {
                _ASSERT(nIncr == 1 || nIncr == -1);
            }
        }
};

//
// A hash table of domain list entries, key'd by domain name.  This is
// used to build up the domain list.  Each bucket contains a linked list
// of recipients who are in the same domain.
//
class CDomainHashTable :
    public CTypedHashTable<CDomainHashTable,
                           DOMAIN_LIST_ENTRY,
                           LPCSTR>
{
    public:
        CDomainHashTable() :
            CTypedHashTable<CDomainHashTable,
                            DOMAIN_LIST_ENTRY,
                            LPCSTR>("domainhash",
                                     (double) LK_DFLT_MAXLOAD,
                                     LK_SMALL_TABLESIZE,
                                     1  // one subtable
                                     )
        {
            TraceFunctEnter("CDomainHashTable");
            TraceFunctLeave();
        }

        ~CDomainHashTable() {
            TraceFunctEnter("~CDomainHashTable");
            TraceFunctLeave();
        }

        static const LPCSTR ExtractKey(const DOMAIN_LIST_ENTRY *pDomainListEntry) {
            return pDomainListEntry->szDomainName;
        }

        static DWORD CalcKeyHash(LPCSTR szDomainName) {
            return CRCHashNoCase((BYTE *) szDomainName, lstrlen(szDomainName));
        }

        static bool EqualKeys(LPCSTR pszKey1, LPCSTR pszKey2) {
            if (pszKey1 == NULL && pszKey2 == NULL) return true;
            if (pszKey1 == NULL || pszKey2 == NULL) return false;
            return (_stricmp(pszKey1, pszKey2) == 0);
        }

        static void AddRefRecord(DOMAIN_LIST_ENTRY *pDomainListEntry,
                                 int nIncr)
        {
            if (nIncr == 1) {
                _ASSERT(pDomainListEntry->m_cRefs >= 0);
                InterlockedIncrement(&(pDomainListEntry->m_cRefs));
            } else if (nIncr == -1) {
                _ASSERT(pDomainListEntry->m_cRefs >= 1);
                long x = InterlockedDecrement(&pDomainListEntry->m_cRefs);
                if (x == 0) {
                    CMemoryAccess *pcmaAccess = pDomainListEntry->m_pcmaAccess;
                    _ASSERT(pcmaAccess != NULL);
                    pcmaAccess->FreeBlock(pDomainListEntry);
                }
            } else {
                _ASSERT(nIncr == 1 || nIncr == -1);
            }
        }
};

typedef CDomainHashTable::CIterator
    DOMAIN_ITEM_CONTEXT, *LPDOMAIN_ITEM_CONTEXT;

class CRecipientsHash
{
  public:

	CRecipientsHash();
	~CRecipientsHash();

	// Releases all memory associated with this object
	HRESULT Release();

	// Releases the domain list only
	HRESULT ReleaseDomainList();

	// Add a primary recipient, voids all predecessors of the same name
	HRESULT AddPrimary(
				DWORD		dwCount,
				LPCSTR		*ppszNames,
				DWORD		*pdwPropIDs,
				DWORD		*pdwIndex
				)
    {
        return AddRecipient(dwCount, ppszNames, pdwPropIDs, pdwIndex, true);
    }

	// Add a secondary recipients, yields if a collision is detected
	HRESULT AddSecondary(
				DWORD		dwCount,
				LPCSTR		*ppszNames,
				DWORD		*pdwPropIDs,
				DWORD		*pdwIndex
				)
    {
        return AddRecipient(dwCount, ppszNames, pdwPropIDs, pdwIndex, false);
    }

	// Remove a recipient, given a recipient index
	HRESULT RemoveRecipient(
				DWORD		dwIndex
				);

	HRESULT GetRecipient(
				DWORD							dwIndex,
				LPRECIPIENTS_PROPERTY_ITEM_EX	*ppRecipient
				);

	// Builds a list of domains given a hash, groups recipients in
	// domain order and discards "do not deliver" recipients
	HRESULT BuildDomainListFromHash(CMailMsgRecipientsAdd *pList);

	// Get count of domains
	HRESULT GetDomainCount(
				DWORD					*pdwCount
				);

	// Get count of recipients
	HRESULT GetRecipientCount(
				DWORD					*pdwCount
				);

	// Get the total space needed to write all domain names, including
	// NULL terminators.
	HRESULT GetDomainNameSize(
				DWORD					*pdwSize
				);

	// Get the total space needed to write all recipient names
	HRESULT GetRecipientNameSize(
				DWORD					*pdwSize
				);

	// Returns a context for enumeration as well as the first item
	// in the first domain
	// Returns HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) if no more domains
	HRESULT GetFirstDomain(
				LPDOMAIN_ITEM_CONTEXT			pContext,
				LPRECIPIENTS_PROPERTY_ITEM_EX	*ppFirstItem,
                LPDOMAIN_LIST_ENTRY             *ppDomainListEntry = NULL
				);

	// Enumerates along and returns the first item in the next domain.
	// Returns HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) if no more domains
	HRESULT GetNextDomain(
				LPDOMAIN_ITEM_CONTEXT			pContext,
				LPRECIPIENTS_PROPERTY_ITEM_EX	*ppFirstItem,
                LPDOMAIN_LIST_ENTRY             *ppDomainListEntry = NULL
				);

    // This must be called if GetNextDomain isn't called until it returns
    // ERROR_NO_MORE_ITEMS
    HRESULT CloseDomainContext(
                LPDOMAIN_ITEM_CONTEXT           pContext);

	HRESULT Lock() { m_rwLock.ExclusiveLock(); return(S_OK); }
	HRESULT Unlock() { m_rwLock.ExclusiveUnlock(); return(S_OK); }

  private:

	// Method to allocate an in-memory recipient block
	HRESULT AllocateAndPrepareRecipientsItem(
				DWORD							dwCount,
				DWORD							*pdwMappedIndices,
				LPCSTR							*rgszName,
				PROP_ID							*pidProp,
				LPRECIPIENTS_PROPERTY_ITEM_EX	*ppItem
				);

	// Add a recipient
	HRESULT AddRecipient(
				DWORD		dwCount,
				LPCSTR		*ppszNames,
				DWORD		*pdwPropIDs,
				DWORD		*pdwIndex,
                bool    	fPrimary
				);
	// Method to compare two in-memory items
	HRESULT CompareEntries(
				DWORD							dwNameIndex,
				LPRECIPIENTS_PROPERTY_ITEM_EX	pItem1,
				LPRECIPIENTS_PROPERTY_ITEM_EX	pItem2
				);

	// Method to walk the hash chain and look for a collision
	HRESULT DetectCollision(
				DWORD							dwNameIndex,
				LPRECIPIENTS_PROPERTY_ITEM_EX	pStartingItem,
				LPRECIPIENTS_PROPERTY_ITEM_EX	pRecipientItem,
				LPRECIPIENTS_PROPERTY_ITEM_EX	*ppCollisionItem
				);

#ifdef DEADCODE
	// Method to insert an entry into the hash bucket, taking
	// consideration for both hash values
	HRESULT InsertRecipientIntoHash(
				DWORD							dwCount,
				DWORD							*pdwNameIndex,
				DWORD							*rgdwBucket,
				LPRECIPIENTS_PROPERTY_ITEM_EX	pRecipientItem
				);
#endif

	// Insert an entry into the domain list, creating an new
	// domain entry if needed
	HRESULT InsertRecipientIntoDomainList(
				LPRECIPIENTS_PROPERTY_ITEM_EX	pItem,
                LPCSTR                          szDomain
				);

    //
    // wrappers for hash functions.  these are used to encapsulate
    // operations to m_hashEntries*
    //
    HRESULT InsertHashRecord(DWORD dwIndex,
                             LPRECIPIENTS_PROPERTY_ITEM_EX pRecipientItem,
                             bool fOverwrite = FALSE);
    HRESULT DeleteHashRecord(DWORD dwIndex,
                             LPRECIPIENTS_PROPERTY_ITEM_EX pRecipientItem);
    HRESULT FindHashRecord(DWORD dwIndex,
                           RECIPIENTS_PROPERTY_ITEM_HASHKEY *pKey,
                           LPRECIPIENTS_PROPERTY_ITEM_EX *ppRecipientItem);

	// Statistical info
	DWORD							m_dwDomainCount;
	DWORD							m_dwDomainNameSize;
	DWORD							m_dwRecipientCount;
	DWORD							m_dwRecipientNameSize;
    DWORD                           m_dwAllocated;

    // Head of allocation list
    LPRECIPIENTS_PROPERTY_ITEM_EX   m_pListHead;

    // these are all different types, so we can't make a true array.
    // there is one hash table for each address type.  The number
    // corresponds with the address in the faNameOffset array of
    // RECIPIENTS_PROPERTY_ITEM
    CRecipientsHashTable<0>         m_hashEntries0;
    CRecipientsHashTable<1>         m_hashEntries1;
    CRecipientsHashTable<2>         m_hashEntries2;
    CRecipientsHashTable<3>         m_hashEntries3;
    CRecipientsHashTable<4>         m_hashEntries4;

    CDomainHashTable                m_hashDomains;

	// Need a lock for multi-threaded hash access
	CShareLockNH					m_rwLock;
    CShareLockNH                    m_rwLockQuickList;

	// Keep a pointer to the block manager
	CMemoryAccess					m_cmaAccess;

	// List for mapping indexes to pointers
	CQuickList						m_qlMap;

	// Context for the quick list (perf)
	PVOID   						m_pvMapContext;
};

// Index obfuscation functions

// Play bit games so no one tries to treat this as an index
// The approach here is to :
//      (1) : Leave the top bit zero (we assume it IS zero)
//		(2) : Set bit 30
// 		(3) : Swap bits 29 and 30 down to positions 0 and 1
inline DWORD ObfuscateIndex(DWORD dwIndex)
	{
	_ASSERT(!(dwIndex & 0xC0000000)); 				// Assert that top two bits are zero
	dwIndex += 0x40000000;							// Add bit 30
	dwIndex = (dwIndex << 2) | (dwIndex >> 29);   	// Flip things around
	return dwIndex;
	}

inline DWORD RecoverIndex(DWORD dwIndex)
	{
	dwIndex = (dwIndex >> 2) | ((dwIndex & 0x3) << 29);	// Flip things back into place
	dwIndex -= 0x40000000;								// Subtract bit 30
	return dwIndex;
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\msgcodes.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	msgcodes.h

Abstract:

	This module contains the definitions of various HRESULT codes

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	03/20/98	created

--*/

#ifndef _MSGCODES_H_
#define _MSGCODES_H_

//#define MAILMSG_S_EXISTS						((HRESULT)0x00000002)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\qwiklist.h ===
//-----------------------------------------------------------------------------
//
//
//	File: qwiklist.h
//
//	Description: Provides a quick paged/growable list implementation.
//
//	Author: Mike Swafford (MikeSwa)
//
//	History:
//		6/15/1998 - MikeSwa Created
//      9/9/1998 - MikeSwa Modified to include functionality to delete entries
//		3/14/2000 - dbraun : Slightly modified for use in mailmsg.dll
//
//	Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __QWIKLIST_H__
#define __QWIKLIST_H__

#include "blockmgr.h"

//#include <aqincs.h>
#include <listmacr.h>

#define QUICK_LIST_SIG  'tsLQ'
#define QUICK_LIST_SIG_DELETE 'slQ!'

const DWORD QUICK_LIST_PAGE_SIZE = 512;  //must be a power of 2

//Mask used to quickly determine if a given index is on the current page
const DWORD QUICK_LIST_INDEX_MASK = ~(QUICK_LIST_PAGE_SIZE-1);

//When m_cItems is set to this value... we know this is not the head page.
const DWORD QUICK_LIST_LEAF_PAGE = 0xFFFF7EAF;

class CQuickList
{
  protected:
    DWORD       m_dwSignature;
    DWORD       m_dwCurrentIndexStart;
    LIST_ENTRY  m_liListPages;
    DWORD       m_cItems;
    PVOID       m_rgpvData[QUICK_LIST_PAGE_SIZE];
    inline BOOL fIsIndexOnThisPage(DWORD dwIndex);
  public:
    CQuickList(); //initialize entry as head
    CQuickList(CQuickList *pqlstHead); //initialize as new page in list
    ~CQuickList();

    DWORD dwGetCount() {return m_cItems;};
    PVOID pvGetItem(IN DWORD dwIndex, IN OUT PVOID *ppvContext);
    HRESULT HrAppendItem(IN PVOID pvData, OUT DWORD *pdwIndex);
};

//---[ CQuickList::fIsIndexOnThisPage ]----------------------------------------
//
//
//  Description:
//      Returns TRUE is the given index is on this page
//  Parameters:
//      dwIndex     - Index to check for
//  Returns:
//      TRUE if index is on this page... FALSE otherwise
//  History:
//      6/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CQuickList::fIsIndexOnThisPage(DWORD dwIndex)
{
    return ((dwIndex & QUICK_LIST_INDEX_MASK) == m_dwCurrentIndexStart);
}

#endif //__QWIKLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\mmdbgext\mmdumps.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqdumps.cpp
//
//  Description:  Definitions of AQ structure dumps for use with ptdbgext.
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#define _ANSI_UNICODE_STRINGS_DEFINED_

#define private public
#define protected public

#include <atq.h>
#include <stddef.h>

#include "dbgtrace.h"
#include "signatur.h"
#include "cmmtypes.h"
#include "cmailmsg.h"

#include "dbgdumpx.h"
PEXTLIB_INIT_ROUTINE g_pExtensionInitRoutine = NULL;
DECLARE_DEBUG_PRINTS_OBJECT();

DEFINE_EXPORTED_FUNCTIONS

LPSTR ExtensionNames[] = {
    "MailMsg debugger extensions",
    0
};

LPSTR Extensions[] = {
    "getmailmsgpointers <pointer>",
    "  Given a CMailMsg, CMailMsgRecipients, CMailMsgRecipientsAdd, or" ,
    "  CBlockManager pointer this returns the CMailMsg and CBlockManager",
    "  pointers.",
    "dumpblocks <pointer to block manager>",
    "  This dumps all of the loaded blocks for block manager.  This can",
    "  be used with dbtobin.pl to reconstruct the P1 for a message.",
    "dumpblockmanagerdata <pointer to blockmgr> <offset> <length> <type>",
    "  Dumps the data from the P1 stream starting at <offset> and continuing",
    "  for <length>.  Length should be a multiple of 16.  <type> can be ",
    "  db or dc",
    "checkheader <pointer to block manager>",
    "  Integrity Checks the CMailMsg header and the header in block 0",
    "flataddress <flat address>",
    "  Converts a flat address into node id and offset in the P1 stream",
    0
};

//Define some mailmsg specific types
#define FieldTypeFlatAddress FieldTypeDWordBitMask

BEGIN_FIELD_DESCRIPTOR(CMailMsg_Fields)
    FIELD3(FieldTypeClassSignature, CMailMsg, m_Header.dwSignature)
    FIELD3(FieldTypeClassSignature, CMailMsg, m_Header.ptiGlobalProperties.dwSignature)
    FIELD3(FieldTypeClassSignature, CMailMsg, m_Header.ptiRecipients.dwSignature)
    FIELD3(FieldTypeClassSignature, CMailMsg, m_Header.ptiPropertyMgmt.dwSignature)
    FIELD3(FieldTypePointer, CMailMsg, m_pbStoreDriverHandle)
    FIELD3(FieldTypeDWordBitMask, CMailMsg, m_dwStoreDriverHandle)
    FIELD3(FieldTypeDWordBitMask, CMailMsg, m_dwCreationFlags)
    FIELD3(FieldTypeDWordBitMask, CMailMsg, m_ulUsageCount)
    FIELD3(FieldTypeStruct, CMailMsg, m_lockUsageCount)
    FIELD3(FieldTypeDWordBitMask, CMailMsg, m_ulRecipientCount)
    FIELD3(FieldTypeStruct, CMailMsg, m_Header)
    FIELD3(FieldTypePointer, CMailMsg, m_hContentFile)
    FIELD3(FieldTypeDWordBitMask, CMailMsg, m_cContentFile)
    FIELD3(FieldTypePointer, CMailMsg, m_pStream)
    FIELD3(FieldTypePointer, CMailMsg, m_pStore)
    FIELD3(FieldTypeBool, CMailMsg, m_fCommitCalled)
    FIELD3(FieldTypeBool, CMailMsg, m_fDeleted)
    FIELD3(FieldTypeDWordBitMask, CMailMsg, m_cCloseOnExternalReleaseUsage)
    FIELD3(FieldTypePointer, CMailMsg, m_pDefaultRebindStoreDriver)
    FIELD3(FieldTypeStruct, CMailMsg, m_ptProperties)
    FIELD3(FieldTypeStruct, CMailMsg, m_SpecialPropertyTable)
    FIELD3(FieldTypeStruct, CMailMsg, m_bmBlockManager)
    FIELD3(FieldTypeStruct, CMailMsg, m_lockReopen)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CMailMsgRecipients_Fields)
    FIELD3(FieldTypeDWordBitMask, CMailMsgRecipients, m_dwDomainCount)
    FIELD3(FieldTypeBool, CMailMsgRecipients, m_fGlobalCommitDone)
    FIELD3(FieldTypePointer, CMailMsgRecipients, m_pInstanceInfo)
    FIELD3(FieldTypePointer, CMailMsgRecipients, m_pBlockManager)
    FIELD3(FieldTypePointer, CMailMsgRecipients, m_pStream)
    FIELD3(FieldTypeStruct, CMailMsgRecipients, m_SpecialPropertyTable)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CMailMsgRecipientsAdd_Fields)
    FIELD3(FieldTypeDWordBitMask, CMailMsgRecipientsAdd, m_ulRefCount)
    FIELD3(FieldTypeStruct, CMailMsgRecipientsAdd, m_InstanceInfo)
    FIELD3(FieldTypePointer, CMailMsgRecipientsAdd, m_pBlockManager)
    FIELD3(FieldTypeStruct, CMailMsgRecipientsAdd, m_Hash)
    FIELD3(FieldTypeStruct, CMailMsgRecipientsAdd, m_SpecialPropertyTable)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CBlockManager_Fields)
    FIELD3(FieldTypeClassSignature, CBlockManager, m_dwSignature)
    FIELD3(FieldTypeFlatAddress, CBlockManager, m_faEndOfData)
    FIELD3(FieldTypeDWordBitMask, CBlockManager, m_idNodeCount)
    FIELD3(FieldTypePointer, CBlockManager, m_pRootNode)
    FIELD3(FieldTypePointer, CBlockManager, m_pParent)
    FIELD3(FieldTypeStruct, CBlockManager, m_bma)
    FIELD3(FieldTypePointer, CBlockManager, m_pMsg)
    FIELD3(FieldTypeBool, CBlockManager, m_fDirty)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CBlockContext_Fields)
    FIELD3(FieldTypeClassSignature, CBlockContext, m_dwSignature)
    FIELD3(FieldTypePointer, CBlockContext, m_pLastAccessedNode)
    FIELD3(FieldTypeFlatAddress, CBlockContext, m_faLastAccessedNodeOffset)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(BLOCK_HEAP_NODE_ATTRIBUTES_Fields)
    FIELD3(FieldTypePointer, BLOCK_HEAP_NODE_ATTRIBUTES, pParentNode)
    FIELD3(FieldTypeDWordBitMask, BLOCK_HEAP_NODE_ATTRIBUTES, idChildNode)
    FIELD3(FieldTypeDWordBitMask, BLOCK_HEAP_NODE_ATTRIBUTES, idNode)
    FIELD3(FieldTypeFlatAddress, BLOCK_HEAP_NODE_ATTRIBUTES, faOffset)
    FIELD3(FieldTypeDWordBitMask, BLOCK_HEAP_NODE_ATTRIBUTES, fFlags)
END_FIELD_DESCRIPTOR

EMBEDDED_STRUCT(BLOCK_HEAP_NODE_ATTRIBUTES, 
                BLOCK_HEAP_NODE_ATTRIBUTES_Fields, 
                BLOCK_HEAP_NODE_ATTRIBUTES_EmbeddedFields)

BEGIN_FIELD_DESCRIPTOR(BLOCK_HEAP_NODE_Fields)
    FIELD3(FieldTypeStruct, BLOCK_HEAP_NODE, rgpChildren)
    FIELD3(FieldTypeStruct, BLOCK_HEAP_NODE, stAttributes)
    //FIELD3(FieldTypeEmbeddedStruct, BLOCK_HEAP_NODE, stAttributes, 
                                    //BLOCK_HEAP_NODE_ATTRIBUTES_EmbeddedFields)
    FIELD3(FieldTypeStruct, BLOCK_HEAP_NODE, rgbData)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(PROPERTY_TABLE_INSTANCE_Fields)
    FIELD3(FieldTypeClassSignature, PROPERTY_TABLE_INSTANCE, dwSignature)
    FIELD3(FieldTypeFlatAddress, PROPERTY_TABLE_INSTANCE, faFirstFragment)
    FIELD3(FieldTypeDWordBitMask, PROPERTY_TABLE_INSTANCE, dwFragmentSize)
    FIELD3(FieldTypeDWordBitMask, PROPERTY_TABLE_INSTANCE, dwItemBits)
    FIELD3(FieldTypeDWordBitMask, PROPERTY_TABLE_INSTANCE, dwItemSize)
    FIELD3(FieldTypeDWordBitMask, PROPERTY_TABLE_INSTANCE, dwProperties)
    FIELD3(FieldTypeFlatAddress, PROPERTY_TABLE_INSTANCE, faExtendedInfo)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(PROPERTY_TABLE_FRAGMENT_Fields)
    FIELD3(FieldTypeClassSignature, PROPERTY_TABLE_FRAGMENT, dwSignature)
    FIELD3(FieldTypeFlatAddress, PROPERTY_TABLE_FRAGMENT, faNextFragment)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(GLOBAL_PROPERTY_TABLE_FRAGMENT_Fields)
    FIELD3(FieldTypeClassSignature, GLOBAL_PROPERTY_TABLE_FRAGMENT, 
                                    ptfFragment.dwSignature)
    FIELD3(FieldTypeFlatAddress, GLOBAL_PROPERTY_TABLE_FRAGMENT, 
                                    ptfFragment.faNextFragment)
    FIELD3(FieldTypeStruct, GLOBAL_PROPERTY_TABLE_FRAGMENT, rgpiItems)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(GLOBAL_PROPERTY_ITEM_Fields)
    FIELD3(FieldTypeFlatAddress, GLOBAL_PROPERTY_ITEM, piItem.faOffset)
    FIELD3(FieldTypeDWordBitMask, GLOBAL_PROPERTY_ITEM, piItem.dwSize)
    FIELD3(FieldTypeDWordBitMask, GLOBAL_PROPERTY_ITEM, piItem.dwMaxSize)
    FIELD3(FieldTypeDWordBitMask, GLOBAL_PROPERTY_ITEM, idProp)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(RECIPIENT_PROPERTY_ITEM_Fields)
    FIELD3(FieldTypeFlatAddress, RECIPIENT_PROPERTY_ITEM, piItem.faOffset)
    FIELD3(FieldTypeDWordBitMask, RECIPIENT_PROPERTY_ITEM, piItem.dwSize)
    FIELD3(FieldTypeDWordBitMask, RECIPIENT_PROPERTY_ITEM, piItem.dwMaxSize)
    FIELD3(FieldTypeDWordBitMask, RECIPIENT_PROPERTY_ITEM, idProp)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(PROPID_MGMT_PROPERTY_ITEM_Fields)
    FIELD3(FieldTypeFlatAddress, PROPID_MGMT_PROPERTY_ITEM, piItem.faOffset)
    FIELD3(FieldTypeDWordBitMask, PROPID_MGMT_PROPERTY_ITEM, piItem.dwSize)
    FIELD3(FieldTypeDWordBitMask, PROPID_MGMT_PROPERTY_ITEM, piItem.dwMaxSize)
    FIELD3(FieldTypeGuid, PROPID_MGMT_PROPERTY_ITEM, Guid)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(MASTER_HEADER_Fields)
    FIELD3(FieldTypeClassSignature, MASTER_HEADER, dwSignature)
    FIELD3(FieldTypeClassSignature, MASTER_HEADER, ptiGlobalProperties.dwSignature)
    FIELD3(FieldTypeClassSignature, MASTER_HEADER, ptiRecipients.dwSignature)
    FIELD3(FieldTypeClassSignature, MASTER_HEADER, ptiPropertyMgmt.dwSignature)
    FIELD3(FieldTypeStruct, MASTER_HEADER, ptiGlobalProperties)
    FIELD3(FieldTypeStruct, MASTER_HEADER, ptiRecipients)
    FIELD3(FieldTypeStruct, MASTER_HEADER, ptiPropertyMgmt)
END_FIELD_DESCRIPTOR

BEGIN_STRUCT_DESCRIPTOR
    STRUCT(CMailMsg, CMailMsg_Fields)
    STRUCT(CMailMsgRecipients, CMailMsgRecipients_Fields)
    STRUCT(CMailMsgRecipientsAdd, CMailMsgRecipientsAdd_Fields)
    STRUCT(CBlockManager, CBlockManager_Fields)
    STRUCT(CBlockContext, CBlockContext_Fields)
    STRUCT(BLOCK_HEAP_NODE_ATTRIBUTES, BLOCK_HEAP_NODE_ATTRIBUTES_Fields)
    STRUCT(BLOCK_HEAP_NODE, BLOCK_HEAP_NODE_Fields)
    STRUCT(PROPERTY_TABLE_INSTANCE, PROPERTY_TABLE_INSTANCE_Fields)
    STRUCT(PROPERTY_TABLE_FRAGMENT, PROPERTY_TABLE_FRAGMENT_Fields)
    STRUCT(GLOBAL_PROPERTY_TABLE_FRAGMENT, 
           GLOBAL_PROPERTY_TABLE_FRAGMENT_Fields)
    STRUCT(GLOBAL_PROPERTY_ITEM,  GLOBAL_PROPERTY_ITEM_Fields)
    STRUCT(RECIPIENT_PROPERTY_ITEM,  RECIPIENT_PROPERTY_ITEM_Fields)
    STRUCT(PROPID_MGMT_PROPERTY_ITEM,  PROPID_MGMT_PROPERTY_ITEM_Fields)
    STRUCT(MASTER_HEADER,  MASTER_HEADER_Fields)
END_STRUCT_DESCRIPTOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\lib\qwiklist.cpp ===
//-----------------------------------------------------------------------------
//
//
//	File: qwiklist.cpp
//
//	Description:  Implementation of CQuickList
//
//	Author: Mike Swafford (MikeSwa)
//
//	History:
//		6/15/1998 - MikeSwa Created
//		3/14/2000 - dbraun : Slightly modified for use in mailmsg.dll
//
//	Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "atq.h"
#include "qwiklist.h"


//---[ CQuickList::CQuickList ]------------------------------------------------
//
//
//  Description:
//      Default contructor for CQuikList... initializes as head of list
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      6/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CQuickList::CQuickList()
{
    m_dwSignature = QUICK_LIST_SIG;

    //ASSERT constants
    _ASSERT(!(~QUICK_LIST_INDEX_MASK & QUICK_LIST_PAGE_SIZE));
    _ASSERT((~QUICK_LIST_INDEX_MASK + 1)== QUICK_LIST_PAGE_SIZE);
    m_dwCurrentIndexStart = 0;
    InitializeListHead(&m_liListPages);
    m_cItems = 0;
    ZeroMemory(m_rgpvData, QUICK_LIST_PAGE_SIZE*sizeof(PVOID));
}


//---[ CQuickList::CQuickList ]------------------------------------------------
//
//
//  Description:
//      Constructor for QQuickList, inserts it into the tail of current list
//  Parameters:
//
//  Returns:
//
//  History:
//      6/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CQuickList::CQuickList(CQuickList *pqlstHead)
{
    _ASSERT(pqlstHead);
    _ASSERT(pqlstHead->m_liListPages.Blink);
    CQuickList *pqlstTail = CONTAINING_RECORD(pqlstHead->m_liListPages.Blink, CQuickList, m_liListPages);
    _ASSERT(QUICK_LIST_SIG == pqlstTail->m_dwSignature);
    m_dwSignature = QUICK_LIST_SIG;
    m_dwCurrentIndexStart = pqlstTail->m_dwCurrentIndexStart + QUICK_LIST_PAGE_SIZE;
    m_cItems = QUICK_LIST_LEAF_PAGE;
    ZeroMemory(m_rgpvData, QUICK_LIST_PAGE_SIZE*sizeof(PVOID));
    InsertTailList(&(pqlstHead->m_liListPages), &m_liListPages);
}


//---[ CQuickList::~CQuickList ]-----------------------------------------------
//
//
//  Description:
//      CQuickList destructor
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      6/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CQuickList::~CQuickList()
{
    m_dwSignature = QUICK_LIST_SIG_DELETE;
    CQuickList *pqlstCurrent = NULL;
    CQuickList *pqlstNext = NULL;
    if (QUICK_LIST_LEAF_PAGE != m_cItems)
    {
        //head node... loop through every thing and delete leaf pages
        pqlstCurrent = CONTAINING_RECORD(m_liListPages.Flink,
                        CQuickList, m_liListPages);
        while (this != pqlstCurrent)
        {
            pqlstNext = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Flink,
                        CQuickList, m_liListPages);
            delete pqlstCurrent;
            pqlstCurrent = pqlstNext;
        }
    }
}


//---[ CQuickList::pvGetItem ]-------------------------------------------------
//
//
//  Description:
//      Looks up item at given index
//  Parameters:
//      IN     dwIndex      Index of item to lookup
//      IN OUT ppvContext   Context for speeding up lookup
//  Returns:
//      Value of item at index
//      NULL if index is out of ranges
//  History:
//      6/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
PVOID CQuickList::pvGetItem(IN DWORD dwIndex, IN OUT PVOID *ppvContext)
{
    _ASSERT(ppvContext);
    PVOID pvReturn = NULL;
    BOOL  fSearchForwards = TRUE;
    DWORD dwForwardDist = 0;
    DWORD dwBackwardDist = 0;
    DWORD dwMaxStartingIndex = m_cItems & QUICK_LIST_INDEX_MASK;
    CQuickList *pqlstDirection = NULL;
    CQuickList *pqlstCurrent = (CQuickList *) *ppvContext;
    CQuickList *pqlstSentinal = NULL;
    DWORD cDbgItems = m_cItems;

    if (dwIndex >= m_cItems)
        return NULL;

    if (!pqlstCurrent)
        pqlstCurrent = this;

    pqlstSentinal = pqlstCurrent;

    //short circuit direction logic
    if (pqlstCurrent->fIsIndexOnThisPage(dwIndex))
    {
        pvReturn = pqlstCurrent->m_rgpvData[dwIndex & ~QUICK_LIST_INDEX_MASK];
        *ppvContext = pqlstCurrent;
        _ASSERT((dwIndex < m_cItems) || (NULL == pvReturn));
        goto Exit;
    }

    //determine which direction to go in (we want to traverse the smallest # of pages
    //possible
    pqlstDirection = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Flink, CQuickList, m_liListPages);
    if (dwIndex > pqlstDirection->m_dwCurrentIndexStart)
        dwForwardDist = dwIndex - pqlstDirection->m_dwCurrentIndexStart;
    else
        dwForwardDist = pqlstDirection->m_dwCurrentIndexStart - dwIndex;

    pqlstDirection = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Blink, CQuickList, m_liListPages);
    if (dwIndex > pqlstDirection->m_dwCurrentIndexStart)
        dwBackwardDist = dwIndex - pqlstDirection->m_dwCurrentIndexStart;
    else
        dwBackwardDist = pqlstDirection->m_dwCurrentIndexStart - dwIndex;

    //fix up distances to account for going through the 0th page
    //max distance is dwMaxStartingIndex/2
    if (dwBackwardDist > dwMaxStartingIndex/2)
        dwBackwardDist -= dwMaxStartingIndex;

    if (dwForwardDist > dwMaxStartingIndex/2)
        dwForwardDist -= dwMaxStartingIndex;

    if (dwForwardDist > dwBackwardDist)
        fSearchForwards = FALSE;

    //$$NOTE: current lookup time is O(lg base{QUICK_LIST_PAGE_BASE} (n))/2.
    //Consecutive lookups will be O(1) (because of the hints)
    do
    {
        if (fSearchForwards)
        {
            //going forward is quicker
            pqlstCurrent = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Flink, CQuickList, m_liListPages);
        }
        else
        {
            //going backwards is quicker
            pqlstCurrent = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Blink, CQuickList, m_liListPages);
        }

        _ASSERT(QUICK_LIST_SIG == pqlstCurrent->m_dwSignature);
        if (pqlstCurrent->fIsIndexOnThisPage(dwIndex))
        {
            pvReturn = pqlstCurrent->m_rgpvData[dwIndex & ~QUICK_LIST_INDEX_MASK];
            _ASSERT((dwIndex < m_cItems) || (NULL == pvReturn));
            break;
        }

    } while (pqlstSentinal != pqlstCurrent); //stop when we return to list head

    *ppvContext = pqlstCurrent;
    _ASSERT((cDbgItems == m_cItems) && "Non-threadsafe access to CQuickList");

  Exit:
    return pvReturn;
}

//---[ CQuickList::HrAppendItem ]-----------------------------------------------
//
//
//  Description:
//      Appends new data item to end of array
//  Parameters:
//      IN  pvData      - Data to insert
//      OUT pdwIndex    - Index data was inserted at
//  Returns:
//      E_OUTOFMEMORY if unable to allocate another page
//      E_INVALIDARG if pvData is NULL
//  History:
//      6/15/98 - MikeSwa Created
//      9/9/98 - MikeSwa - Added pdwIndex OUT param
//
//-----------------------------------------------------------------------------
HRESULT CQuickList::HrAppendItem(IN PVOID pvData, OUT DWORD *pdwIndex)
{
    HRESULT hr = S_OK;
    CQuickList *pqlstCurrent = NULL;

    _ASSERT(pvData && "Cannot insert NULL pointers");

    if (!pvData)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (m_cItems && !(m_cItems & ~QUICK_LIST_INDEX_MASK)) //on page boundary
    {
        //there is not room on the last page
        pqlstCurrent = new CQuickList(this);
        if (!pqlstCurrent)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }
    else if (!(m_cItems & QUICK_LIST_INDEX_MASK))
    {
        pqlstCurrent = this;
    }
    else
    {
        pqlstCurrent = CONTAINING_RECORD(m_liListPages.Blink, CQuickList, m_liListPages);
    }

    _ASSERT(pqlstCurrent->fIsIndexOnThisPage(m_cItems));
    pqlstCurrent->m_rgpvData[m_cItems & ~QUICK_LIST_INDEX_MASK] = pvData;

    //Set OUT param to index (before we increment the count)
    if (pdwIndex)
        *pdwIndex = m_cItems;

    m_cItems++;
    _ASSERT(QUICK_LIST_LEAF_PAGE != m_cItems);

  Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\mailmsg\mmdbgext\mmdbgext.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: mmdbgext.cpp
//
//  Description: Custom mailmsg debugger extensions 
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#define _ANSI_UNICODE_STRINGS_DEFINED_
#define __MMDBGEXT__

#define private public
#define protected public

#include <atq.h>
#include <stddef.h>

#include "dbgtrace.h"
#include "signatur.h"
#include "cmmtypes.h"
#include "cmailmsg.h"

#include "dbgdumpx.h"

DWORD g_fFillPropertyPages = 1;

PT_DEBUG_EXTENSION(flataddress)
{
    FLAT_ADDRESS  faDump    = INVALID_FLAT_ADDRESS;
    FLAT_ADDRESS  faOffset  = INVALID_FLAT_ADDRESS;
    DWORD         dwNodeId  = 0;

    if (!szArg || ('\0' == szArg[0]))
    {
        dprintf("Error: You must specify a flat address\n");
        return;
    }

    faDump = (FLAT_ADDRESS) (DWORD_PTR) GetExpression(szArg);

    if (INVALID_FLAT_ADDRESS == faDump)
    {
        dprintf("Error: Flat Address is NULL (INVALID_FLAT_ADDRESS)\n");
        return;
    }

    //Find the offset into the current block
    faOffset = faDump & BLOCK_HEAP_PAYLOAD_MASK;

    //Find the node id from the address
    dwNodeId = ((DWORD) ((faDump) >> BLOCK_HEAP_PAYLOAD_BITS));

    dprintf("Flat Address 0x%X is at block #%d offset 0x%X\n", 
            faDump, dwNodeId+1, faOffset);   
}

HRESULT GetEdgeListFromNodeId(
            HEAP_NODE_ID        idNode,
            HEAP_NODE_ID        *rgEdgeList,
            DWORD               *pdwEdgeCount
            )
{
    DWORD           dwCurrentLevel;
    HEAP_NODE_ID    *pEdge = rgEdgeList;

    // This is a strictly internal call, we are assuming the caller
    // will be optimized and will handle cases for idNode <=
    // BLOCK_HEAP_ORDER. Processing only starts for 2 layers or more
    // Debug: make sure we are within range
    _ASSERT(idNode > BLOCK_HEAP_ORDER);
    _ASSERT(idNode <= NODE_ID_ABSOLUTE_MAX);

    // Strip off the root node
    idNode--;

    // We need to do depth minus 1 loops since the top edge will be
    // the remainder of the final loop
    for (dwCurrentLevel = 0;
         dwCurrentLevel < (MAX_HEAP_DEPTH - 1);
         )
    {
        // The quotient is the parent node in the upper level,
        // the remainder is the the edge from the parent to the
        // current node.
        *pEdge++ = idNode & BLOCK_HEAP_ORDER_MASK;
        idNode >>= BLOCK_HEAP_ORDER_BITS;
        idNode--;
        dwCurrentLevel++;

        // If the node is less than the number of children per node,
        // we are done.
        if (idNode < BLOCK_HEAP_ORDER)
            break;
    }
    *pEdge++ = idNode;
    *pdwEdgeCount = dwCurrentLevel + 1;
    return(S_OK);
}

//
// get a block from the block manager if that block is loaded
//
// iBlockManager - pointer to the block manager in debuggee
// idNode - block to get
// pNode - data buffer to save results into
//
// S_OK: all worked
// S_FALSE: some blocks weren't loaded (data in those blocks is 0x0)
//
HRESULT GetBlock(PWINDBG_EXTENSION_APIS pExtensionApis, 
                 HANDLE hCurrentProcess, 
                 DWORD_PTR iBlockManager, 
                 HEAP_NODE_ID idNode, 
                 BLOCK_HEAP_NODE *pNode) 
{
    BYTE bm[sizeof(CBlockManager)];
    CBlockManager *pBM = (CBlockManager *) &bm;
    HRESULT hr;

    if (!ReadMemory(iBlockManager, pBM, sizeof(CBlockManager), NULL)) {
        dprintf("Error: Couldn't read CBlockManager@0x%x\n", iBlockManager);
        return E_POINTER;
    }

    if (idNode > pBM->m_idNodeCount) {
        dprintf("Error: Block %i is out of range\n", idNode);
        return E_INVALIDARG;
    }

    if (!ReadMemory(pBM->m_pRootNode, pNode, sizeof(BLOCK_HEAP_NODE), NULL)) {
        dprintf("Error: Couldn't read BLOCK_HEAP_NODE@0x%x\n", pBM->m_pRootNode);
        return E_POINTER;
    }

    if (idNode == 0) {
        return S_OK;
    } else if (idNode <= BLOCK_HEAP_ORDER) {
        DWORD_PTR iNode = (DWORD_PTR) pNode->rgpChildren[idNode - 1];
        if (iNode != 0) {
            if (!ReadMemory(iNode, pNode, sizeof(BLOCK_HEAP_NODE), NULL)) {
                dprintf("Error: Couldn't read BLOCK_HEAP_NODE@0x%x\n", iNode);
                return E_POINTER;
            }
        } else {
            ZeroMemory(pNode, sizeof(BLOCK_HEAP_NODE));
            return S_FALSE;
        }
    } else {
        HEAP_NODE_ID rgEdgeList[MAX_HEAP_DEPTH];
        DWORD cEdgeList;

        hr = GetEdgeListFromNodeId(idNode, rgEdgeList, &cEdgeList);
        if (FAILED(hr)) 
            return hr;

        while (cEdgeList--) {
            DWORD_PTR iNode = (DWORD_PTR) pNode->rgpChildren[rgEdgeList[cEdgeList]];
            if (iNode != 0) {
                if (!ReadMemory(iNode, pNode, sizeof(BLOCK_HEAP_NODE), NULL)) {
                    dprintf("Error: Couldn't read BLOCK_HEAP_NODE@0x%x\n", iNode);
                    return E_POINTER;
                }
            } else {
                ZeroMemory(pNode, sizeof(BLOCK_HEAP_NODE));
                return S_FALSE;
            }
        }
    }

    return S_OK;
}

//
// iBlockManager - pointer to block manager in debuggee
// pcBlocks - number of blocks is saved here
//
HRESULT GetBlockCount(PWINDBG_EXTENSION_APIS pExtensionApis, 
                      HANDLE hCurrentProcess, 
                      DWORD_PTR iBlockManager,
                      DWORD *pcBlocks)
{
    BYTE bm[sizeof(CBlockManager)];
    CBlockManager *pBM = (CBlockManager *) &bm;
    HRESULT hr;

    if (!ReadMemory(iBlockManager, pBM, sizeof(CBlockManager), NULL)) {
        dprintf("Error: Couldn't read CBlockManager@0x%x\n", iBlockManager);
        return E_POINTER;
    }

    *pcBlocks = (DWORD) pBM->m_idNodeCount;   

    return S_OK;
}

//
// display a chunk of data nicely to the screen (like db)
//
// iOffset - offset of where this data lived in blockmanager (for display only)
// cLength - number of bytes to dump
// pbData - data to dump
//
void DumpData(PWINDBG_EXTENSION_APIS pExtensionApis,
              DWORD iOffset,
              DWORD cLength,
              void *pvData,
              BOOL fFormatDC = FALSE)
{
    BYTE *pbData = (BYTE *) pvData;

    for (DWORD i = 0; i < cLength/16; i++) {
        BYTE rg[16];
        char sz[17] = "";
        for (DWORD x = 0; x < 16; x++) {
            char ch = pbData[(i * 16) + x];
            if (ch < 32 || ch > 127) ch = '.';
            sz[x] = ch;
        }
        sz[16] = 0;

        if (fFormatDC) {
            dprintf("%08x  %02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x  %s\n",
                (iOffset) + (i * 16),
                pbData[(i * 16) + 0x3],
                pbData[(i * 16) + 0x2],
                pbData[(i * 16) + 0x1],
                pbData[(i * 16) + 0x0],
                pbData[(i * 16) + 0x7],
                pbData[(i * 16) + 0x6],
                pbData[(i * 16) + 0x5],
                pbData[(i * 16) + 0x4],
                pbData[(i * 16) + 0xb],
                pbData[(i * 16) + 0xa],
                pbData[(i * 16) + 0x9],
                pbData[(i * 16) + 0x8],
                pbData[(i * 16) + 0xf],
                pbData[(i * 16) + 0xe],
                pbData[(i * 16) + 0xd],
                pbData[(i * 16) + 0xc],
                sz);
        } else {
            dprintf("%08x  %02x %02x %02x %02x %02x %02x %02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x  %s\n",
                (iOffset) + (i * 16),
                pbData[(i * 16) + 0x0],
                pbData[(i * 16) + 0x1],
                pbData[(i * 16) + 0x2],
                pbData[(i * 16) + 0x3],
                pbData[(i * 16) + 0x4],
                pbData[(i * 16) + 0x5],
                pbData[(i * 16) + 0x6],
                pbData[(i * 16) + 0x7],
                pbData[(i * 16) + 0x8],
                pbData[(i * 16) + 0x9],
                pbData[(i * 16) + 0xa],
                pbData[(i * 16) + 0xb],
                pbData[(i * 16) + 0xc],
                pbData[(i * 16) + 0xd],
                pbData[(i * 16) + 0xe],
                pbData[(i * 16) + 0xf],
                sz);
        }
    }
}

//
// display a block nicely to the screen
//
// idNode - used for display purposes only
// pNode - the block to dump
//
void DumpBlock(PWINDBG_EXTENSION_APIS pExtensionApis, 
               HEAP_NODE_ID idNode, 
               BLOCK_HEAP_NODE *pNode) 
{
    DWORD fFlags = pNode->stAttributes.fFlags;
    char szFlags[255] = "( ";

    dprintf("*** Dumping block %i (header says %i)\n", 
        idNode, pNode->stAttributes.idNode);
    if (fFlags & BLOCK_IS_DIRTY) strcat(szFlags, "DIRTY ");
    if (fFlags & BLOCK_PENDING_COMMIT) strcat(szFlags, "PENDING-COMMIT ");
    if (fFlags & BLOCK_NOT_CPOOLED) strcat(szFlags, "NOT-CPOOLED ");
    if (fFlags & ~(BLOCK_NOT_CPOOLED | BLOCK_IS_DIRTY | BLOCK_PENDING_COMMIT)) 
        strcat(szFlags, "(Unknown) ");
    strcat(szFlags, ")");
    dprintf("*** Block flags are 0x%x %s\n", 
        pNode->stAttributes.fFlags, szFlags);

    DumpData(pExtensionApis, 
             (DWORD) idNode * BLOCK_HEAP_PAYLOAD, 
             BLOCK_HEAP_PAYLOAD, 
             pNode->rgbData);
}

#define GetNodeIdFromOffset(faOffset)   ((faOffset) >> BLOCK_HEAP_PAYLOAD_BITS)

//
// Get a chunk of data from the block manager
//
// iBlockManager - pointer to block manager in debuggee
// iOffset - offset inside block manager
// cLength - number of bytes to read
// pbData - where to store the data
//
// S_OK: all worked
// S_FALSE: some blocks weren't loaded (data in those blocks is 0x0)
//
HRESULT GetBlockManagerData(PWINDBG_EXTENSION_APIS pExtensionApis,
                            HANDLE hCurrentProcess,
                            DWORD_PTR iBlockManager,
                            DWORD iOffset,
                            DWORD cLength,
                            void *pbData)
{
    BYTE bm[sizeof(CBlockManager)];
    CBlockManager *pBM = (CBlockManager *) &bm;
    HRESULT hr;
    BLOCK_HEAP_NODE node;
    DWORD idNode;
    DWORD iData = 0;
    HRESULT fMissingData = FALSE;

    if (!ReadMemory(iBlockManager, pBM, sizeof(CBlockManager), NULL)) {
        dprintf("Error: Couldn't read CBlockManager@0x%x\n", iBlockManager);
        return E_POINTER;
    }

    if ((cLength == 0) ||
        (iOffset + cLength > (pBM->m_idNodeCount * BLOCK_HEAP_PAYLOAD))) 
    {
        dprintf("Error: Data is out of range\n");
        return E_INVALIDARG;
    }

    while (cLength) {
        DWORD iOffsetThisNode = iOffset & BLOCK_HEAP_PAYLOAD_MASK;
        DWORD cMaxThisNode = BLOCK_HEAP_PAYLOAD - iOffsetThisNode;
        DWORD cLengthThisNode;
        DWORD idNode = GetNodeIdFromOffset(iOffset);

        if (cLength > cMaxThisNode) {
            cLengthThisNode = cMaxThisNode;
        } else {
            cLengthThisNode = cLength;
        }

        hr = GetBlock(pExtensionApis, hCurrentProcess, iBlockManager, idNode, &node);
        if (FAILED(hr)) return hr;
        if (hr == S_FALSE) fMissingData = TRUE;

        memcpy(((BYTE *) pbData) + iData, 
               node.rgbData + iOffsetThisNode, 
               cLengthThisNode);
        cLength -= cLengthThisNode;
        iOffset += cLengthThisNode;
        iData += cLengthThisNode;
    }

    if (fMissingData) return S_FALSE; else return S_OK;
}

//
// given a pointer try to figure out which of the mailmsg pointers
// it is, and return the pointer to the CMailMsg object
//
// iPointer - a pointer to CMailMsgRecipients, CMailMsgRecipientsAdd,
//                         CMailMsg or CMailMsgBlockManager
// piMailMsg - returns the mailmsg pointer
// piBlockMgr - returns the blockmgr pointer
//
HRESULT GetMailMsgPointers(PWINDBG_EXTENSION_APIS pExtensionApis,
                           HANDLE hCurrentProcess,
                           DWORD_PTR iPointer,
                           DWORD_PTR *piMailMsg = NULL,
                           DWORD_PTR *piBlockMgr = NULL,
                           BYTE *pbMailMsg = NULL)
{
    BYTE bm[sizeof(CBlockManager)];
    CBlockManager *pBM = (CBlockManager *) &bm;
    BYTE cmm[sizeof(CMailMsg)];
    CMailMsg *pCMM = (CMailMsg *) &cmm;
    BYTE cmmr[sizeof(CMailMsgRecipients)];
    CMailMsgRecipients *pCMMR = (CMailMsgRecipients *) &cmmr;
    BYTE cmmra[sizeof(CMailMsgRecipientsAdd)];
    CMailMsgRecipientsAdd *pCMMRA = (CMailMsgRecipientsAdd *) &cmmra;

    DWORD_PTR iBlockManager = 0;

    // see if they passed us a CBlockManager
    if (iBlockManager == 0 &&
        ReadMemory(iPointer, pBM, sizeof(CBlockManager), NULL)) 
    {
        if (pBM->m_dwSignature == BLOCK_HEAP_SIGNATURE_VALID) {
            dprintf("This looks like a CBlockManager object\n");
            iBlockManager = iPointer;
        }
    }

    // a CMailMsgProperties?
    if (iBlockManager == 0 &&
        ReadMemory(iPointer, pCMM, sizeof(CMailMsg), NULL)) 
    {
        if (pCMM->m_bmBlockManager.m_dwSignature == BLOCK_HEAP_SIGNATURE_VALID) {
            dprintf("This looks like a CMailMsg object\n");
            iBlockManager = iPointer + FIELD_OFFSET(CMailMsg, m_bmBlockManager);
        }
    }

    // see if it is a CMailMsgRecipients
    if (iBlockManager == 0 &&
        ReadMemory(iPointer, pCMMR, sizeof(CMailMsgRecipients), NULL)) 
    {
        if (ReadMemory(pCMMR->m_pBlockManager, pBM, sizeof(CBlockManager), NULL)) {
            if (pBM->m_dwSignature == BLOCK_HEAP_SIGNATURE_VALID) {
                dprintf("This looks like a CMailMsgRecipients object\n");
                iBlockManager = (DWORD_PTR) pCMMR->m_pBlockManager;
            }
        }
    }

    // CMailMsgRecipientsAdd?
    if (iBlockManager == 0 &&
        ReadMemory(iPointer, pCMMRA, sizeof(CMailMsgRecipientsAdd), NULL)) 
    {
        if (ReadMemory(pCMMRA->m_pBlockManager, pBM, sizeof(CBlockManager), NULL)) {
            if (pBM->m_dwSignature == BLOCK_HEAP_SIGNATURE_VALID) {
                dprintf("This looks like a CMailMsgRecipientsAdd object\n");
                iBlockManager = (DWORD_PTR) pCMMRA->m_pBlockManager;
            }
        }
    }

    if (iBlockManager) {
        DWORD_PTR iMailMsg;

        iMailMsg = iBlockManager - FIELD_OFFSET(CMailMsg, m_bmBlockManager);
        if (!ReadMemory(iMailMsg, pCMM, sizeof(CMailMsg), NULL)) {
            dprintf("Error: Couldn't read CMailMsg@0x%x\n", iMailMsg);
            return E_INVALIDARG;
        }
        if (pCMM->m_Header.dwSignature != CMAILMSG_SIGNATURE_VALID) {
            dprintf("Error: CMailMsg signature isn't correct\n");
            return E_INVALIDARG;
        }
        dprintf("  CBlockManager@0x%08x\n", iBlockManager);
        dprintf("  CMailMsg@0x%08x\n", iMailMsg);

        if (piMailMsg) *piMailMsg = iMailMsg;
        if (piBlockMgr) *piBlockMgr = iBlockManager;
        if (pbMailMsg) memcpy(pbMailMsg, pCMM, sizeof(CMailMsg));
        return S_OK;
    }

    dprintf("Error: 0x%x is not a pointer to a CMailMsg, CBlockManager, \n"
            "   CMailMsgRecipients or cMailMsgRecipientsAdd object\n", iPointer);

    return E_INVALIDARG;
}

//
// parse cArgs DWORD arguments from a command line into rgArgs
//
HRESULT ParseArgs(PWINDBG_EXTENSION_APIS pExtensionApis,
                  PCSTR szArgs, 
                  DWORD cArgs, 
                  DWORD_PTR **prgArgs) 
{
    char szArgBuffer[1024], *pszArgBuffer = szArgBuffer;
    strcpy(szArgBuffer, szArgs);

    for (DWORD i = 0; i < cArgs; i++) {
        char *pszSpace;
        // remove spaces
        for (; *pszArgBuffer == ' '; pszArgBuffer++);

        // find the next space and turn it into a null
        // not having a next space if this is the last argument is okay
        pszSpace = strchr(pszArgBuffer, ' ');
        if ((pszSpace == NULL) && (i != (cArgs - 1))) {
            return E_INVALIDARG;
        }
        if (pszSpace) *pszSpace = 0;

        // get the next number
        *(prgArgs[i]) = GetExpression(pszArgBuffer);

        // move past this argument
        if (pszSpace) pszArgBuffer = pszSpace + 1;
    }

    return S_OK;
}

//
// dump all of the blocks on a message
//
PT_DEBUG_EXTENSION(dumpblocks) {
    DWORD_PTR iBlockManager;
    DWORD cBlocks;
    DWORD idNode;
    BLOCK_HEAP_NODE block;
    HRESULT hr;
    
    if (!szArg || ('\0' == szArg[0])) {
        dprintf("Usage: dumpblocks <PtrToBlockmgr>\n");
        return;
    }

    iBlockManager = (DWORD_PTR) GetExpression(szArg);

    hr = GetBlockCount(pExtensionApis, hCurrentProcess, iBlockManager, &cBlocks);
    if (FAILED(hr)) {
        dprintf("Error: GetBlockCount failed with 0x%x\n", hr);
    }

    dprintf("*** There are %i blocks\n", cBlocks);

    for (idNode = 0; idNode < cBlocks; idNode++) {
        hr = GetBlock(pExtensionApis, hCurrentProcess, iBlockManager, idNode, &block);
        if (FAILED(hr)) {
            dprintf("Error: GetBlock(%i) failed with 0x%x\n", idNode, hr);
            return;
        }

        DumpBlock(pExtensionApis, idNode, &block);
    }
}

//
// dump a user-specified piece of data from the blockmanager
//
PT_DEBUG_EXTENSION(dumpblockmanagerdata) {
    HRESULT hr;
    BYTE pbData[1024];
    DWORD_PTR iBlockManager;
    DWORD_PTR iOffset;
    DWORD_PTR cLength;    
    DWORD_PTR dwType;
    DWORD_PTR *rgParameters[] = { &iBlockManager, &iOffset, &cLength, &dwType };

    hr = ParseArgs(pExtensionApis, szArg, 4, rgParameters);
    if (FAILED(hr)) {
        dprintf("Usage: dumpblockmanagerdata <PtrToBlockmgr> <offset> <length> <type>\n");
        dprintf("  <length> should be a multiple of 0x10\n");
        dprintf("  <type> should be db or dc (controls formatting)\n");
        return;
    }

    hr = GetBlockManagerData(pExtensionApis,
                             hCurrentProcess,
                             iBlockManager,
                             (DWORD) iOffset,
                             (DWORD) cLength,
                             pbData);
    if (FAILED(hr)) {
        dprintf("Error: GetBlockManagerData failed with 0x%x\n", hr);
        return;
    }

    DumpData(pExtensionApis, (DWORD) iOffset, (DWORD) cLength, pbData, 
             (dwType == 0xdb) ? FALSE : TRUE);
}

//
// given a pointer to one of the mailmsg objects return a pointer
// to CMailMsg
//
PT_DEBUG_EXTENSION(getmailmsgpointers) {
    HRESULT hr;
    DWORD_PTR iPointer;
    
    if (!szArg || ('\0' == szArg[0])) {
        dprintf("Usage: getmailmsgpointers <pointer>\n");
        return;
    }

    iPointer = (DWORD_PTR) GetExpression(szArg);

    hr = GetMailMsgPointers(pExtensionApis,
                            hCurrentProcess,
                            iPointer);
    if (FAILED(hr)) {
        dprintf("Error: GetMailMsgPointers failed with 0x%x\n", hr);
        return;
    }
}

PT_DEBUG_EXTENSION(checkheader) {
    HRESULT hr;
    DWORD_PTR iPointer;
    DWORD_PTR iBlockMgr;
    BLOCK_HEAP_NODE rootnode;
    BYTE cmm[sizeof(CMailMsg)];
    CMailMsg *pCMM = (CMailMsg *) &cmm;
    MASTER_HEADER *pHeaderBlock0;
    MASTER_HEADER *pHeaderCMM;
    BOOL fMismatch = FALSE;
    
    if (!szArg || ('\0' == szArg[0])) {
        dprintf("Usage: checkheader <pointer>\n");
        return;
    }

    iPointer = (DWORD_PTR) GetExpression(szArg);

    hr = GetMailMsgPointers(pExtensionApis,
                            hCurrentProcess,
                            iPointer,
                            NULL,
                            &iBlockMgr,
                            cmm);
    if (FAILED(hr)) {
        dprintf("Error: GetMailMsgPointers failed with 0x%x\n", hr);
        return;
    }

    hr = GetBlock(pExtensionApis,
                  hCurrentProcess,
                  iBlockMgr,
                  0,
                  &rootnode);
    if (FAILED(hr)) {
        dprintf("Error: GetBlock failed with 0x%x\n", hr);
        return;
    }

    pHeaderBlock0 = (MASTER_HEADER *) &(rootnode.rgbData);
    pHeaderCMM = (MASTER_HEADER *) &(pCMM->m_Header);

    dprintf("\n*** header in CMailMsg\n");
    DumpData(pExtensionApis, 0, sizeof(MASTER_HEADER), pHeaderCMM, TRUE);

    dprintf("\n*** header in block 0\n");
    DumpData(pExtensionApis, 0, sizeof(MASTER_HEADER), pHeaderBlock0, TRUE);
 
    BOOL fRootNodeDirty = rootnode.stAttributes.fFlags & BLOCK_IS_DIRTY;
    BOOL fMatch = 
        (memcmp(pHeaderBlock0, pHeaderCMM, sizeof(MASTER_HEADER)) == 0);

    if (!fRootNodeDirty && !fMatch) {
        dprintf("Error: root node isn't dirty and doesn't match\n");
        return;
    }

    typedef enum {
        eMatch = 0,
        eCMMGreater = 1,
        eExpectedValue = 2,
        eFragmentPointer = 3
    } PROPCOMPARE;

    struct {
        PROPCOMPARE     eCompareType;
        char            *pszComment;
        DWORD           iOffset;
        DWORD           dwExpectedValue;
    } rgMHCheckList[] = {
        // master header properties
        {
            eExpectedValue,     
            "dwSignature",      
            FIELD_OFFSET(MASTER_HEADER, dwSignature),
            CMAILMSG_SIGNATURE_VALID
        },
        {
            eMatch,     
            "wVersionHigh, vVersionLow",      
            4,
            0
        },
        {
            eExpectedValue,     
            "dwHeaderSize",      
            FIELD_OFFSET(MASTER_HEADER, dwHeaderSize),
            sizeof(MASTER_HEADER)
        },
        // master header global property table
        {
            eExpectedValue,     
            "ptiGlobalProperties.dwSignature",      
            FIELD_OFFSET(MASTER_HEADER, ptiGlobalProperties.dwSignature),
            GLOBAL_PTABLE_INSTANCE_SIGNATURE_VALID
        },
        {
            eFragmentPointer,     
            "ptiGlobalProperties.faFirstFragment",      
            FIELD_OFFSET(MASTER_HEADER, ptiGlobalProperties.faFirstFragment),
            0
        },
        {
            eMatch,     
            "ptiGlobalProperties.faFirstFragment",      
            FIELD_OFFSET(MASTER_HEADER, ptiGlobalProperties.faFirstFragment),
            0
        },
        {
            eExpectedValue,     
            "ptiGlobalProperties.dwFragmentSize",      
            FIELD_OFFSET(MASTER_HEADER, ptiGlobalProperties.dwFragmentSize),
            GLOBAL_PROPERTY_TABLE_FRAGMENT_SIZE
        },
        {
            eExpectedValue,     
            "ptiGlobalProperties.dwItemBits",      
            FIELD_OFFSET(MASTER_HEADER, ptiGlobalProperties.dwItemBits),
            GLOBAL_PROPERTY_ITEM_BITS
        },
        {
            eExpectedValue,     
            "ptiGlobalProperties.dwItemSize",      
            FIELD_OFFSET(MASTER_HEADER, ptiGlobalProperties.dwItemSize),
            GLOBAL_PROPERTY_ITEM_SIZE
        },
        {
            eCMMGreater,     
            "ptiGlobalProperties.dwProperties",      
            FIELD_OFFSET(MASTER_HEADER, ptiGlobalProperties.dwProperties),
            0
        },
        // master header recipients property table
        {
            eExpectedValue,     
            "ptiRecipients.dwSignature",      
            FIELD_OFFSET(MASTER_HEADER, ptiRecipients.dwSignature),
            RECIPIENTS_PTABLE_INSTANCE_SIGNATURE_VALID
        },
        {
            eFragmentPointer,     
            "ptiRecipients.faFirstFragment",      
            FIELD_OFFSET(MASTER_HEADER, ptiRecipients.faFirstFragment),
            0
        },
        {
            eCMMGreater,     
            "ptiRecipients.faFirstFragment",      
            FIELD_OFFSET(MASTER_HEADER, ptiRecipients.faFirstFragment),
            0
        },
        {
            eCMMGreater,     
            "ptiRecipients.faExtendedInfo",      
            FIELD_OFFSET(MASTER_HEADER, ptiRecipients.faExtendedInfo),
            0
        },
        // master header property managment header
        {
            eExpectedValue,     
            "ptiPropertyMgmt.dwSignature",      
            FIELD_OFFSET(MASTER_HEADER, ptiPropertyMgmt.dwSignature),
            PROPID_MGMT_PTABLE_INSTANCE_SIGNATURE_VALID
        },
        {
            eFragmentPointer,     
            "ptiPropertyMgmt.faFirstFragment",      
            FIELD_OFFSET(MASTER_HEADER, ptiPropertyMgmt.faFirstFragment),
            0
        },
        {
            eMatch,     
            "ptiPropertyMgmt.faFirstFragment",      
            FIELD_OFFSET(MASTER_HEADER, ptiPropertyMgmt.faFirstFragment),
            0
        },
        {
            eExpectedValue,     
            "ptiPropertyMgmt.dwFragmentSize",      
            FIELD_OFFSET(MASTER_HEADER, ptiPropertyMgmt.dwFragmentSize),
            PROPID_MGMT_PROPERTY_TABLE_FRAGMENT_SIZE
        },
        {
            eExpectedValue,     
            "ptiPropertyMgmt.dwItemBits",      
            FIELD_OFFSET(MASTER_HEADER, ptiPropertyMgmt.dwItemBits),
            PROPID_MGMT_PROPERTY_ITEM_BITS
        },
        {
            eExpectedValue,     
            "ptiPropertyMgmt.dwItemSize",      
            FIELD_OFFSET(MASTER_HEADER, ptiPropertyMgmt.dwItemSize),
            PROPID_MGMT_PROPERTY_ITEM_SIZE
        },
        {
            eCMMGreater,     
            "ptiPropertyMgmt.dwProperties",      
            FIELD_OFFSET(MASTER_HEADER, ptiPropertyMgmt.dwProperties),
            0
        },
        // end of list
        {
            eCMMGreater,     
            NULL,
            0,
            0
        },
    };

    dprintf("\n*** Verifying headers\n");
    for (DWORD i = 0; rgMHCheckList[i].pszComment != NULL; i++) {
        DWORD dwCMM;
        DWORD dwBlock0;
        DWORD dwExpected = rgMHCheckList[i].dwExpectedValue;
        PROPERTY_TABLE_FRAGMENT ptfCMM;
        PROPERTY_TABLE_FRAGMENT ptfBlock0;
        HRESULT hr;
        memcpy(&dwCMM, 
               ((BYTE *) pHeaderCMM) + rgMHCheckList[i].iOffset, 
               sizeof(DWORD));
        memcpy(&dwBlock0, 
               ((BYTE *) pHeaderBlock0) + rgMHCheckList[i].iOffset, 
               sizeof(DWORD));

        switch (rgMHCheckList[i].eCompareType) {
            case eMatch:
                if (dwBlock0 != dwCMM) {
                    fMismatch = TRUE;
                    dprintf("Error: Property %s doesn't match (CMM=%08x, Block0=%08x)\n",
                        rgMHCheckList[i].pszComment,
                        dwCMM,
                        dwBlock0);
                };
                break;
            case eCMMGreater:
                if (dwBlock0 > dwCMM) {
                    fMismatch = TRUE;
                    dprintf("Error: Property %s Block0 should be less than CMM (CMM=%08x, Block0=%08x)\n",
                        rgMHCheckList[i].pszComment,
                        dwCMM,
                        dwBlock0);
                }
                break;
            case eExpectedValue:
                if (dwBlock0 != dwCMM || dwCMM != dwExpected) {
                    fMismatch = TRUE;
                    dprintf("Error: Property %s doesn't match (CMM=%08x, Block0=%08x, Expected=%08x)\n",
                        rgMHCheckList[i].pszComment,
                        dwCMM,
                        dwBlock0,
                        dwExpected);
                }
                break;
            case eFragmentPointer:
                // check the fragment pointer in the CmailMsg header
                if (dwCMM != 0xffffffff) {
                    // load the property table fragment from the CMailMsg
                    hr = GetBlockManagerData(pExtensionApis,
                                             hCurrentProcess,
                                             iBlockMgr,
                                             dwCMM,
                                             sizeof(PROPERTY_TABLE_FRAGMENT),
                                             &ptfCMM);
                    if (FAILED(hr)) {
                        fMismatch = TRUE;
                        dprintf("Warning: Couldn't read %s in stream at 0x%08x\n", 
                                dwCMM);
                    }

                    if (ptfCMM.dwSignature!=PROPERTY_FRAGMENT_SIGNATURE_VALID) {
                        fMismatch = TRUE;
                        dprintf("Error: %s signature in CMM is %08x not %08x\n",
                                rgMHCheckList[i].pszComment,
                                ptfCMM.dwSignature,
                                PROPERTY_FRAGMENT_SIGNATURE_VALID);
                    }
                }

                // check the fragment pointer in the block 0 header
                if (dwBlock0 != 0xffffffff) {
                    // load the property table fragment from block0
                    hr = GetBlockManagerData(pExtensionApis,
                                             hCurrentProcess,
                                             iBlockMgr,
                                             dwBlock0,
                                             sizeof(PROPERTY_TABLE_FRAGMENT),
                                             &ptfBlock0);
                    if (FAILED(hr)) {
                        fMismatch = TRUE;
                        dprintf("Warning: Couldn't read %s in stream at 0x%08x\n", 
                                dwBlock0);
                    }

                    if (ptfBlock0.dwSignature!=PROPERTY_FRAGMENT_SIGNATURE_VALID) {
                        fMismatch = TRUE;
                        dprintf("Error: %s signature in Block0 is %08x not %08x\n",
                                rgMHCheckList[i].pszComment,
                                ptfBlock0.dwSignature,
                                PROPERTY_FRAGMENT_SIGNATURE_VALID);
                    }
                }
                break;
            default:
                break;
        }
    }
    if (fMismatch) {
        dprintf("*** Errors occured\n");
    } else {
        dprintf("*** Looks good\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\regtrace\dlgconn.cpp ===
// dlgconn.cpp : implementation file
//

#include "stdafx.h"
#include "regtrace.h"
#include "dlgconn.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConnectDlg dialog


CConnectDlg::CConnectDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CConnectDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CConnectDlg)
	m_szConnect = _T("");
	//}}AFX_DATA_INIT
}


void CConnectDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConnectDlg)
	DDX_Text(pDX, IDC_CONNECT_TXT, m_szConnect);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConnectDlg, CDialog)
	//{{AFX_MSG_MAP(CConnectDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CConnectDlg message handlers

BOOL CConnectDlg::OnInitDialog() 
{
	CString	szFormat;
	
	szFormat.LoadString( IDS_CONNECT_FORMAT );
	m_szConnect.Format( (LPCTSTR)szFormat, App.GetRemoteServerName() );

	CDialog::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\regtrace\pgoutput.cpp ===
// pgoutput.cpp : implementation file
//

#include "stdafx.h"
#include "regtrace.h"
#include "pgoutput.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

const DWORD MB = 1024 * 1024;
const DWORD dwMinFileSize = 5;		// in MB

/////////////////////////////////////////////////////////////////////////////
// CRegOutputPage property page

IMPLEMENT_DYNCREATE(CRegOutputPage, CRegPropertyPage)

CRegOutputPage::CRegOutputPage() : CRegPropertyPage(CRegOutputPage::IDD)
{
	//{{AFX_DATA_INIT(CRegOutputPage)
	m_szFileName = _T("");
	m_dwMaxTraceFileSize = 0;
	//}}AFX_DATA_INIT

	m_dwOutputType = TRACE_OUTPUT_DISABLED;
}

CRegOutputPage::~CRegOutputPage()
{
}

void CRegOutputPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRegOutputPage)
	DDX_Control(pDX, IDC_FILENAME, m_FileName);
	DDX_Text(pDX, IDC_FILENAME, m_szFileName);
	DDX_Text(pDX, IDC_MAXTRACEFILESIZE, m_dwMaxTraceFileSize);
	DDV_MinMaxDWord(pDX, m_dwMaxTraceFileSize, dwMinFileSize, 999);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRegOutputPage, CPropertyPage)
	//{{AFX_MSG_MAP(CRegOutputPage)
	ON_BN_CLICKED(IDC_DEBUGGER, OnOutputClick)
	ON_EN_CHANGE(IDC_FILENAME, OnChangeFilename)
	ON_BN_CLICKED(IDC_DISABLED, OnOutputClick)
	ON_BN_CLICKED(IDC_DISCARD, OnOutputClick)
	ON_BN_CLICKED(IDC_FILE, OnOutputClick)
	ON_EN_CHANGE(IDC_MAXTRACEFILESIZE, OnChangeMaxTraceFileSize)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



BOOL CRegOutputPage::InitializePage() 
{
	if ( !App.GetTraceRegDword( "OutputTraceType", &m_dwOutputType ) )
	{
		m_dwOutputType = TRACE_OUTPUT_FILE;
		App.SetTraceRegDword( "OutputTraceType", m_dwOutputType );
	}

	if ( App.GetTraceRegDword( "MaxTraceFileSize", &m_dwMaxTraceFileSize ) &&
		m_dwMaxTraceFileSize > dwMinFileSize*MB)
	{
		m_dwMaxTraceFileSize = (m_dwMaxTraceFileSize + MB - 1) / MB;
	} else {
		m_dwMaxTraceFileSize = dwMinFileSize;			// Default to 5mb
		App.SetTraceRegDword( "MaxTraceFileSize", m_dwMaxTraceFileSize * MB );
	}

	if ( !App.GetTraceRegString( "TraceFile", m_szFileName ) )
	{
		m_szFileName = "c:\\trace.atf";
		App.SetTraceRegString( "TraceFile", m_szFileName );
	}

	return	TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CRegOutputPage message handlers

BOOL CRegOutputPage::OnInitDialog() 
{
	int	nID;

	CPropertyPage::OnInitDialog();
	
	switch( m_dwOutputType )
	{
	case TRACE_OUTPUT_DISABLED:		nID = IDC_DISABLED;	break;
	case TRACE_OUTPUT_FILE:			nID = IDC_FILE;		break;
	case TRACE_OUTPUT_DEBUG:		nID = IDC_DEBUGGER;	break;
	case TRACE_OUTPUT_DISCARD:		nID = IDC_DISCARD;	break;
	
	default:						nID = IDC_DISABLED;	break;
	}
	
	CheckRadioButton( IDC_DISABLED, IDC_DISCARD, nID );
	OnOutputClick();

	SetModified( FALSE );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CRegOutputPage::OnOutputClick() 
{
	int	nSelectedID = GetCheckedRadioButton( IDC_DISABLED, IDC_DISCARD );

	switch( nSelectedID )
	{
	case IDC_DISABLED:		m_dwOutputType = TRACE_OUTPUT_DISABLED;	break;
	case IDC_FILE:			m_dwOutputType = TRACE_OUTPUT_FILE;		break;
	case IDC_DEBUGGER:		m_dwOutputType = TRACE_OUTPUT_DEBUG;	break;
	case IDC_DISCARD:		m_dwOutputType = TRACE_OUTPUT_DISCARD;	break;
	
	default:				
		ASSERT( FALSE );
		break;
	}

	m_FileName.EnableWindow( nSelectedID == IDC_FILE );

	SetModified( TRUE );
}

void CRegOutputPage::OnChangeFilename() 
{
	SetModified( TRUE );	
}


void CRegOutputPage::OnOK() 
{
	App.SetTraceRegDword( "OutputTraceType", m_dwOutputType );
	App.SetTraceRegDword( "MaxTraceFileSize", m_dwMaxTraceFileSize * MB);
	App.SetTraceRegString( "TraceFile", m_szFileName );

	SetModified( FALSE );
}

void CRegOutputPage::OnChangeMaxTraceFileSize() 
{
	SetModified( TRUE );	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\regtrace\pgoutput.h ===
// pgoutput.h : header file
//

#ifndef	_OUTPUT_PAGE_H_
#define	_OUTPUT_PAGE_H_

/////////////////////////////////////////////////////////////////////////////
// CRegOutputPage dialog

class CRegOutputPage : public CRegPropertyPage
{
	DECLARE_DYNCREATE(CRegOutputPage)

// Construction
public:
	CRegOutputPage();
	~CRegOutputPage();

// Dialog Data
	//{{AFX_DATA(CRegOutputPage)
	enum { IDD = IDD_OUTPUT };
	CEdit	m_FileName;
	CString	m_szFileName;
	DWORD	m_dwMaxTraceFileSize;
	//}}AFX_DATA

	virtual BOOL InitializePage();

	DWORD	m_dwOutputType;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRegOutputPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRegOutputPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnOutputClick();
	afx_msg void OnChangeFilename();
	afx_msg void OnChangeMaxTraceFileSize();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual void OnOK();

};

#endif	// _OUTPUT_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\regtrace\dlgconn.h ===
// dlgconn.h : header file
//
#ifndef	_CONNECT_DLG_H_
#define	_CONNECT_DLG_H_

/////////////////////////////////////////////////////////////////////////////
// CConnectDlg dialog

class CConnectDlg : public CDialog
{
// Construction
public:
	CConnectDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CConnectDlg)
	enum { IDD = IDD_CONNECTING };
	CString	m_szConnect;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConnectDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConnectDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif	//	_CONNECT_DLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\regtrace\pgthread.cpp ===
// pgthread.cpp : implementation file
//

#include "stdafx.h"
#include "regtrace.h"
#include "pgthread.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegThreadPage property page

IMPLEMENT_DYNCREATE(CRegThreadPage, CRegPropertyPage)

CRegThreadPage::CRegThreadPage() : CRegPropertyPage(CRegThreadPage::IDD)
{
	//{{AFX_DATA_INIT(CRegThreadPage)
	m_fAsyncTrace = TRUE;
	//}}AFX_DATA_INIT

	m_nThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;
}

CRegThreadPage::~CRegThreadPage()
{
}

void CRegThreadPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRegThreadPage)
	DDX_Control(pDX, IDC_ASYNC, m_AsyncTrace);
	DDX_Check(pDX, IDC_ASYNC, m_fAsyncTrace);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRegThreadPage, CPropertyPage)
	//{{AFX_MSG_MAP(CRegThreadPage)
	ON_BN_CLICKED(IDC_PRIORITY_ABOVE, OnPriorityClick)
	ON_BN_CLICKED(IDC_PRIORITY_BELOW, OnPriorityClick)
	ON_BN_CLICKED(IDC_PRIORITY_HIGHEST, OnPriorityClick)
	ON_BN_CLICKED(IDC_PRIORITY_IDLE, OnPriorityClick)
	ON_BN_CLICKED(IDC_PRIORITY_NORMAL, OnPriorityClick)
	ON_BN_CLICKED(IDC_ASYNC, OnAsync)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CRegThreadPage::InitializePage() 
{
	if ( !App.GetTraceRegDword( "AsyncThreadPriority", (LPDWORD)&m_nThreadPriority ) )
	{
		m_nThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;
		App.SetTraceRegDword( "AsyncThreadPriority", m_nThreadPriority );
	}

	if ( !App.GetTraceRegDword( "AsyncTraceFlag", (LPDWORD)&m_fAsyncTrace ) )
	{
		m_fAsyncTrace = TRUE;
		App.SetTraceRegDword( "AsyncTraceFlag", m_fAsyncTrace );
	}

	return	TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CRegThreadPage message handlers

BOOL CRegThreadPage::OnInitDialog() 
{
	int	nID;

	CPropertyPage::OnInitDialog();

	switch( m_nThreadPriority )
	{
	case THREAD_PRIORITY_HIGHEST:		nID = IDC_PRIORITY_HIGHEST;	break;
	case THREAD_PRIORITY_ABOVE_NORMAL:	nID = IDC_PRIORITY_ABOVE;	break;
	case THREAD_PRIORITY_NORMAL:		nID = IDC_PRIORITY_NORMAL;	break;
	case THREAD_PRIORITY_BELOW_NORMAL:	nID = IDC_PRIORITY_BELOW;	break;
	case THREAD_PRIORITY_IDLE:			nID = IDC_PRIORITY_IDLE;	break;

	default:							nID = IDC_PRIORITY_BELOW;	break;
	}
	
	CheckRadioButton( IDC_PRIORITY_HIGHEST, IDC_PRIORITY_IDLE, nID );
	OnAsync();
	
	SetModified( FALSE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CRegThreadPage::OnPriorityClick() 
{
	int	nSelectedID = GetCheckedRadioButton( IDC_PRIORITY_HIGHEST, IDC_PRIORITY_IDLE );
	
	switch( nSelectedID )
	{
	case IDC_PRIORITY_HIGHEST:	m_nThreadPriority = THREAD_PRIORITY_HIGHEST;		break;
	case IDC_PRIORITY_ABOVE:	m_nThreadPriority = THREAD_PRIORITY_ABOVE_NORMAL;	break;
	case IDC_PRIORITY_NORMAL:	m_nThreadPriority = THREAD_PRIORITY_NORMAL;			break;
	case IDC_PRIORITY_BELOW:	m_nThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;	break;
	case IDC_PRIORITY_IDLE:		m_nThreadPriority = THREAD_PRIORITY_IDLE;			break;

	default:				
		ASSERT( FALSE );
		break;
	}
	SetModified( TRUE );
}

void CRegThreadPage::OnAsync() 
{
	BOOL	m_fAsyncTrace = m_AsyncTrace.GetCheck() == 1;

	GetDlgItem( IDC_THREADGRP )->EnableWindow( m_fAsyncTrace );
	GetDlgItem( IDC_PRIORITY_HIGHEST )->EnableWindow( m_fAsyncTrace );
	GetDlgItem( IDC_PRIORITY_ABOVE )->EnableWindow( m_fAsyncTrace );
	GetDlgItem( IDC_PRIORITY_NORMAL )->EnableWindow( m_fAsyncTrace );
	GetDlgItem( IDC_PRIORITY_BELOW )->EnableWindow( m_fAsyncTrace );
	GetDlgItem( IDC_PRIORITY_IDLE )->EnableWindow( m_fAsyncTrace );

	SetModified( TRUE );
}

void CRegThreadPage::OnOK() 
{
	App.SetTraceRegDword( "AsyncThreadPriority", m_nThreadPriority );
	App.SetTraceRegDword( "AsyncTraceFlag", m_fAsyncTrace );

	SetModified( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\regtrace\pgthread.h ===
// pgthread.h : header file
//

#ifndef	_THREAD_PAGE_H_
#define	_THREAD_PAGE_H_

/////////////////////////////////////////////////////////////////////////////
// CRegThreadPage dialog

class CRegThreadPage : public CRegPropertyPage
{
	DECLARE_DYNCREATE(CRegThreadPage)

// Construction
public:
	CRegThreadPage();
	~CRegThreadPage();

// Dialog Data
	//{{AFX_DATA(CRegThreadPage)
	enum { IDD = IDD_THREAD };
	CButton	m_AsyncTrace;
	BOOL	m_fAsyncTrace;
	//}}AFX_DATA

	int		m_nThreadPriority;

	virtual BOOL InitializePage();

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRegThreadPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRegThreadPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnPriorityClick();
	afx_msg void OnAsync();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual void OnOK();

};
#endif	// _THREAD_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\regtrace\pgtrace.cpp ===
// pgtrace.cpp : implementation file
//

#include "stdafx.h"
#include "regtrace.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegTracePage property page

IMPLEMENT_DYNCREATE(CRegTracePage, CRegPropertyPage)

CRegTracePage::CRegTracePage() : CRegPropertyPage(CRegTracePage::IDD)
{
	//{{AFX_DATA_INIT(CRegTracePage)
	m_fErrorTrace = FALSE;
	m_fDebugTrace = FALSE;
	m_fFatalTrace = FALSE;
	m_fMsgTrace = FALSE;
	m_fStateTrace = FALSE;
	m_fFunctTrace = FALSE;
	//}}AFX_DATA_INIT
}

CRegTracePage::~CRegTracePage()
{
}

void CRegTracePage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRegTracePage)
	DDX_Check(pDX, IDC_ERROR, m_fErrorTrace);
	DDX_Check(pDX, IDC_DEBUG, m_fDebugTrace);
	DDX_Check(pDX, IDC_FATAL, m_fFatalTrace);
	DDX_Check(pDX, IDC_MESSAGE, m_fMsgTrace);
	DDX_Check(pDX, IDC_STATE, m_fStateTrace);
	DDX_Check(pDX, IDC_FUNCTION, m_fFunctTrace);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRegTracePage, CPropertyPage)
	//{{AFX_MSG_MAP(CRegTracePage)
	ON_BN_CLICKED(IDC_DEBUG, OnClick)
	ON_BN_CLICKED(IDC_ERROR, OnClick)
	ON_BN_CLICKED(IDC_FATAL, OnClick)
	ON_BN_CLICKED(IDC_FUNCTION, OnClick)
	ON_BN_CLICKED(IDC_MESSAGE, OnClick)
	ON_BN_CLICKED(IDC_STATE, OnClick)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CRegTracePage::InitializePage() 
{
	DWORD	dwEnabledTraces;

	if ( !App.GetTraceRegDword( "EnabledTraces", &dwEnabledTraces ) )
	{
		dwEnabledTraces = 0;
		App.SetTraceRegDword( "AsyncThreadPriority", dwEnabledTraces );
	}

	m_fDebugTrace = dwEnabledTraces & DEBUG_TRACE_MASK ? TRUE : FALSE ;	
	m_fFatalTrace = dwEnabledTraces & FATAL_TRACE_MASK ? TRUE : FALSE ;
	m_fErrorTrace = dwEnabledTraces & ERROR_TRACE_MASK ? TRUE : FALSE ;
	m_fStateTrace = dwEnabledTraces & STATE_TRACE_MASK ? TRUE : FALSE ;
	m_fFunctTrace = dwEnabledTraces & FUNCT_TRACE_MASK ? TRUE : FALSE ;
	m_fMsgTrace   = dwEnabledTraces & MESSAGE_TRACE_MASK ? TRUE : FALSE ;

	return	TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CRegTracePage message handlers

BOOL CRegTracePage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	SetModified( FALSE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CRegTracePage::OnClick() 
{
	SetModified( TRUE );
}


void CRegTracePage::OnOK() 
{
	DWORD	dwEnabledTraces = 0;

	dwEnabledTraces |= m_fDebugTrace ? DEBUG_TRACE_MASK : 0;
	dwEnabledTraces |= m_fFatalTrace ? FATAL_TRACE_MASK : 0;
	dwEnabledTraces |= m_fErrorTrace ? ERROR_TRACE_MASK : 0;
	dwEnabledTraces |= m_fStateTrace ? STATE_TRACE_MASK : 0;
	dwEnabledTraces |= m_fFunctTrace ? FUNCT_TRACE_MASK : 0;
	dwEnabledTraces |= m_fMsgTrace ? MESSAGE_TRACE_MASK : 0;

	App.SetTraceRegDword( "EnabledTraces", dwEnabledTraces );

	SetModified( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\regtrace\pgtrace.h ===
// pgtrace.h : header file
//

#ifndef	_TRACE_PAGE_H_
#define	_TRACE_PAGE_H_

/////////////////////////////////////////////////////////////////////////////
// CRegTracePage dialog

class CRegTracePage : public CRegPropertyPage
{
	DECLARE_DYNCREATE(CRegTracePage)

// Construction
public:
	CRegTracePage();
	~CRegTracePage();

// Dialog Data
	//{{AFX_DATA(CRegTracePage)
	enum { IDD = IDD_TRACES };
	BOOL	m_fErrorTrace;
	BOOL	m_fDebugTrace;
	BOOL	m_fFatalTrace;
	BOOL	m_fMsgTrace;
	BOOL	m_fStateTrace;
	BOOL	m_fFunctTrace;
	//}}AFX_DATA

	virtual BOOL InitializePage();

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRegTracePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRegTracePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnClick();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual void OnOK();

};

#endif	// _TRACE_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\regtrace\regsheet.h ===
// regsheet.h : header file
//


#ifndef	_REG_SHEET_H_
#define	_REG_SHEET_H_

/////////////////////////////////////////////////////////////////////////////
// CRegPropertySheet

class CRegPropertySheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CRegPropertySheet)

// Construction
public:
	CRegPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CRegPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRegPropertySheet)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CRegPropertySheet();

	// Generated message map functions
protected:
	//{{AFX_MSG(CRegPropertySheet)
	afx_msg void OnApplyNow();
	afx_msg void OnOK();
	afx_msg void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// CRegPropertyPage dialog

class CRegPropertyPage : public CPropertyPage
{
	DECLARE_DYNAMIC(CRegPropertyPage)

// Construction
public:
	CRegPropertyPage(UINT nIDTemplate, UINT nIDCaption = 0)	:
		CPropertyPage( nIDTemplate, nIDCaption ) {}

	CRegPropertyPage(LPCTSTR lpszTemplateName, UINT nIDCaption = 0) :
		CPropertyPage( lpszTemplateName, nIDCaption ) {}

	~CRegPropertyPage();

	virtual BOOL InitializePage() = 0;
	BOOL IsModified()	{ return	m_bChanged;	}


// Dialog Data
	//{{AFX_DATA(CRegPropertyPage)
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRegPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

#if _MFC_VER >= 0x0400

    //
    // Keep private information on page dirty state, necessary for
    // SaveInfo() later.
    //

public:
    void SetModified( BOOL bChanged = TRUE );

protected:
    BOOL m_bChanged;

#endif // _MFC_VER >= 0x0400


// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRegPropertyPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


#endif	// _REG_SHEET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\regtrace\regtrace.cpp ===
// regtrace.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "regtrace.h"
#include "regtrdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegTraceApp

BEGIN_MESSAGE_MAP(CRegTraceApp, CWinApp)
	//{{AFX_MSG_MAP(CRegTraceApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRegTraceApp construction

CRegTraceApp::CRegTraceApp()
{
	m_hRegKey = NULL;
	m_hRegMachineKey = NULL;
	m_szCmdLineServer[0] = '\0';
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CRegTraceApp object

CRegTraceApp theApp;

char	
CRegTraceApp::m_szDebugAsyncTrace[] = "SOFTWARE\\Microsoft\\MosTrace\\CurrentVersion\\DebugAsyncTrace";



/////////////////////////////////////////////////////////////////////////////
// CRegTraceApp initialization

BOOL CRegTraceApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

	Enable3dControls();
	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	//
	// check for cmd line param for remote server
	//
	m_szCmdLineServer[0] = '\0';
	if ( m_lpCmdLine && m_lpCmdLine[0] == '\\' && m_lpCmdLine[1] == '\\' )
	{
		LPSTR	lpsz1, lpsz2;
		int		i;

		for (	i=0, lpsz1=m_lpCmdLine, lpsz2=m_szCmdLineServer;
			 	i<sizeof(m_szCmdLineServer) && *lpsz1 && *lpsz1 != ' ';
				i++, *lpsz2++ = *lpsz1++ ) ;

		*lpsz2 = '\0';
	}

	//
	// if the user specified the local machine; skip remote stuff
	//
	char	szLocalMachine[sizeof(m_szCmdLineServer)];
	DWORD	dwSize = sizeof(szLocalMachine);

	GetComputerName( szLocalMachine, &dwSize );
	//
	// skip the \\ prefix
	//
	if ( lstrcmpi( szLocalMachine, m_szCmdLineServer+2 ) == 0 )
	{
		m_szCmdLineServer[0] = '\0';
	}



	//
	// make usre this succeeds before calling Page constructors
	//
	LONG	lError = OpenTraceRegKey();

	if ( lError != ERROR_SUCCESS )
	{
		PVOID	lpsz;
		CString	szFormat;
		CString	szCaption;
		CString	szText;

		//
		// user aborted
		//
		if ( lError == -1 )
		{
			return	FALSE;
		}

		FormatMessage(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
						FORMAT_MESSAGE_FROM_SYSTEM,
						(LPCVOID)NULL,
						lError,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),
						(LPTSTR)&lpsz,
						16,
						NULL );

		szCaption.LoadString( IDS_ERROR_CAPTION );

		szFormat.LoadString( IDS_ERROR_TEXT );
		szText.Format( (LPCTSTR)szFormat, lpsz, lError );
		LocalFree( lpsz );

		MessageBeep(0);
		MessageBox( NULL, szText, NULL, MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL );
		return FALSE;
	}

	CString	szCaption;

	if ( IsRemoteMsnServer() )
	{
		CString	szFormat;

		szFormat.LoadString( IDS_REMOTE_CAPTION );
		szCaption.Format( (LPCTSTR)szFormat, GetRemoteServerName() );
	}
	else
	{
		szCaption.LoadString( IDS_TRACE_CAPTION );
	}

	CRegPropertySheet	dlg( (LPCTSTR)szCaption );
	CRegTracePage		TracesPage;
	CRegOutputPage		OutputPage;
	CRegThreadPage		ThreadPage;

	if (TracesPage.InitializePage() &&
		OutputPage.InitializePage() &&
		ThreadPage.InitializePage() )
	{
		dlg.AddPage( &TracesPage );
		dlg.AddPage( &OutputPage );
		dlg.AddPage( &ThreadPage );

		dlg.DoModal();
	}
	CloseTraceRegKey();

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

DWORD ConnectThread( CConnectDlg *lpConnectDlg )
{
	LONG	lError;
	HKEY	hRegMachineKey;

	lError = RegConnectRegistry(App.GetRemoteServerName(),
								HKEY_LOCAL_MACHINE,
								&hRegMachineKey );

	App.SetRemoteRegKey( hRegMachineKey );

	lpConnectDlg->PostMessage( WM_COMMAND, IDOK, NULL );

	return	(DWORD)lError;
}


LONG CRegTraceApp::OpenTraceRegKey()
{
	DWORD	dwDisposition;
	LONG	lError;

	//
	// check for cache of the remote hkey value
	//
	if ( IsRemoteMsnServer() )
	{
		DWORD	dwThreadId;

		HANDLE	hThread = ::CreateThread(NULL,
										0,
										(LPTHREAD_START_ROUTINE)ConnectThread,
										(LPVOID)&m_dlgConnect,
										0,
										&dwThreadId );
		if ( hThread == NULL )
		{
			return	GetLastError();
		}

		if ( m_dlgConnect.DoModal() == IDCANCEL )
		{
			return	-1;
		}

		WaitForSingleObject( hThread, INFINITE );
		GetExitCodeThread( hThread, (LPDWORD)&lError );
		CloseHandle( hThread );

		if ( lError != ERROR_SUCCESS )
		{
			return	lError;
		}
	}

	HKEY	hRoot = IsRemoteMsnServer() ?
					m_hRegMachineKey :
					HKEY_LOCAL_MACHINE;

	return RegCreateKeyEx(	hRoot,
							m_szDebugAsyncTrace,
							0,
							NULL,
							REG_OPTION_NON_VOLATILE,
							KEY_READ|KEY_WRITE,
							NULL,
							&m_hRegKey,
							&dwDisposition );
}


BOOL CRegTraceApp::CloseTraceRegKey()
{
	BOOL bRC = RegCloseKey( m_hRegKey ) == ERROR_SUCCESS;

	if ( IsRemoteMsnServer() && m_hRegMachineKey != NULL )
	{
		bRC == RegCloseKey( m_hRegMachineKey ) == ERROR_SUCCESS && bRC;
	}
	return	bRC;
}



BOOL CRegTraceApp::GetTraceRegDword( LPTSTR pszValue, LPDWORD pdw )
{
	DWORD	cbData = sizeof( DWORD );
	DWORD	dwType = REG_DWORD;

	return	RegQueryValueEx(m_hRegKey,
							pszValue,
							NULL,
							&dwType,
							(LPBYTE)pdw,
							&cbData ) == ERROR_SUCCESS && dwType == REG_DWORD;
}



BOOL CRegTraceApp::GetTraceRegString( LPTSTR pszValue, CString& sz )
{
	DWORD	dwType = REG_DWORD;
	char	szTemp[MAX_PATH+1];
	DWORD	cbData = sizeof(szTemp);
	BOOL	bRC;

	bRC = RegQueryValueEx(	m_hRegKey,
							pszValue,
							NULL,
							&dwType,
							(LPBYTE)szTemp,
							&cbData ) == ERROR_SUCCESS && dwType == REG_SZ;

	if ( bRC )
	{
		sz = szTemp;
	}

	return	bRC;
}


BOOL CRegTraceApp::SetTraceRegDword( LPTSTR pszValue, DWORD dwData )
{
	return	RegSetValueEx(	m_hRegKey,
							pszValue,
							NULL,
							REG_DWORD,
							(LPBYTE)&dwData,
							sizeof( DWORD ) ) == ERROR_SUCCESS;
}

BOOL CRegTraceApp::SetTraceRegString( LPTSTR pszValue, CString& sz )
{
	return	RegSetValueEx(	m_hRegKey,
							pszValue,
							NULL,
							REG_SZ,
							(LPBYTE)(LPCTSTR)sz,
							sz.GetLength()+1 ) == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\regtrace\regsheet.cpp ===
// regsheet.cpp : implementation file
//

#include "stdafx.h"
#include "regtrace.h"
#include "regsheet.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegPropertySheet

IMPLEMENT_DYNAMIC(CRegPropertySheet, CPropertySheet)

CRegPropertySheet::CRegPropertySheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
}

CRegPropertySheet::CRegPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
}

CRegPropertySheet::~CRegPropertySheet()
{
}

//
// Need to override the default MFC behaviour to achieve the Win'95 behaviour
//
void CRegPropertySheet::OnApplyNow()
{
	if ( GetActivePage()->OnKillActive() )
	{
		for ( int i=0; i<GetPageCount(); i++ )
		{
			CPropertyPage*	pPage = GetPage( i );

			ASSERT( pPage->IsKindOf( RUNTIME_CLASS(	CRegPropertyPage ) ) );

			if ( ((CRegPropertyPage *)pPage)->IsModified() )
			{
				pPage->OnOK();
			}
		}
	}
}


void CRegPropertySheet::OnOK()
{
	OnApplyNow();

	if (!m_bModeless)
	{
		EndDialog(IDOK);
	}
}


void CRegPropertySheet::OnCancel()
{
	int		i;

	for ( i=0; i<GetPageCount(); i++ )
	{
		GetPage( i )->OnCancel();
	}

	if (!m_bModeless)
	{
		EndDialog(IDCANCEL);
	}
}


BEGIN_MESSAGE_MAP(CRegPropertySheet, CPropertySheet)
	//{{AFX_MSG_MAP(CRegPropertySheet)
	ON_COMMAND(ID_APPLY_NOW, OnApplyNow)
	ON_COMMAND(IDOK, OnOK)
	ON_COMMAND(IDCANCEL, OnCancel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CRegPropertySheet message handlers
/////////////////////////////////////////////////////////////////////////////
// CRegPropertyPage property page

IMPLEMENT_DYNAMIC(CRegPropertyPage, CPropertyPage)

CRegPropertyPage::~CRegPropertyPage()
{
#if _MFC_VER >= 0x0400

      m_bChanged = FALSE;

#endif // _MFC_VER >= 0x0400
}

void CRegPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRegPropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRegPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CRegPropertyPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

#if _MFC_VER >= 0x0400

//
// Keep private check on dirty state of the property page.
//
void
CRegPropertyPage::SetModified(
    BOOL bChanged
    )
{
    CPropertyPage::SetModified(bChanged);
    m_bChanged = bChanged;
}

#endif // _MFC_VER >= 0x0400

/////////////////////////////////////////////////////////////////////////////
// CRegPropertyPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\regtrace\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#ifdef _AFX_ENABLE_INLINES
	#undef _AFX_ENABLE_INLINES
#endif

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\regtrace\regtrace.h ===
// regtrace.h : main header file for the REGTRACE application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols
#include "regsheet.h"
#include "pgtrace.h"
#include "pgoutput.h"
#include "pgthread.h"
#include "dbgtrace.h"
#include "dlgconn.h"

/////////////////////////////////////////////////////////////////////////////
// CRegTraceApp:
// See regtrace.cpp for the implementation of this class
//

class CRegTraceApp : public CWinApp
{
public:
	CRegTraceApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRegTraceApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	LONG OpenTraceRegKey( void );
	BOOL CloseTraceRegKey( void );

	BOOL GetTraceRegDword( LPTSTR pszValue, LPDWORD pdw );
	BOOL GetTraceRegString( LPTSTR pszValue, CString& sz );

	BOOL SetTraceRegDword( LPTSTR pszValue, DWORD dwData );
	BOOL SetTraceRegString( LPTSTR pszValue, CString& sz );

	BOOL IsRemoteMsnServer( void )	{ return m_szCmdLineServer[0] != '\0'; }
	void SetRemoteRegKey( HKEY hKey )	{ m_hRegMachineKey = hKey; }
	LPSTR GetRemoteServerName( void )	{ return m_szCmdLineServer; }

protected:
	HKEY		m_hRegKey;
	HKEY		m_hRegMachineKey;
	static char	m_szDebugAsyncTrace[];
	char		m_szCmdLineServer[128];

	CConnectDlg	m_dlgConnect;


	//{{AFX_MSG(CRegTraceApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

#define	App	(*(CRegTraceApp *)AfxGetApp())
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\regtrace\regtrdlg.cpp ===
// regtrdlg.cpp : implementation file
//

#include "stdafx.h"
#include "regtrace.h"
#include "regtrdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg message handlers

BOOL CAboutDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	CenterWindow();
	
	// TODO: Add extra about dlg initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

/////////////////////////////////////////////////////////////////////////////
// CRegTraceDlg dialog

CRegTraceDlg::CRegTraceDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRegTraceDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRegTraceDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CRegTraceDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRegTraceDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CRegTraceDlg, CDialog)
	//{{AFX_MSG_MAP(CRegTraceDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRegTraceDlg message handlers

BOOL CRegTraceDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	CenterWindow();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	CString strAboutMenu;
	strAboutMenu.LoadString(IDS_ABOUTBOX);
	if (!strAboutMenu.IsEmpty())
	{
		pSysMenu->AppendMenu(MF_SEPARATOR);
		pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
	}
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CRegTraceDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CRegTraceDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CRegTraceDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\regtrace\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by regtrace.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_REGTRACE_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDD_OUTPUT                      129
#define IDD_THREAD                      130
#define IDD_TRACES                      131
#define IDD_CONNECTING                  132
#define FULLLANG_ID                     0409
#define IDC_FILENAME                    1000
#define IDC_DISABLED                    1001
#define IDC_FILE                        1002
#define IDC_DEBUGGER                    1003
#define IDC_DISCARD                     1004
#define IDC_ASYNC                       1005
#define IDC_PRIORITY_HIGHEST            1006
#define IDC_PRIORITY_ABOVE              1007
#define IDC_PRIORITY_NORMAL             1008
#define IDC_PRIORITY_BELOW              1009
#define IDC_PRIORITY_IDLE               1010
#define IDC_ERROR                       1011
#define IDC_FATAL                       1012
#define IDC_DEBUG                       1013
#define IDC_STATE                       1014
#define IDC_THREADGRP                   1014
#define IDC_FUNCTION                    1015
#define IDC_CONNECT_TXT                 1015
#define IDC_MESSAGE                     1016
#define IDC_MAXTRACEFILESIZE            1016
#define IDS_ERROR_CAPTION               59142
#define IDS_ERROR_TEXT                  59143
#define IDS_CONNECT_FORMAT              59144
#define IDS_TRACE_CAPTION               59145
#define IDS_REMOTE_CAPTION              59146

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\rw\src\asymlock.cpp ===
/*++

	asymlock.cpp

	This file implements a Symmetric lock.

	The lock allows multiple threads of a single type to enter the lock, 
	and excludes threads of the other type.  
	
	i.e. Group1Lock() allows any thread doing a 'Group1' operation to enter
		simultaneously with other Group1 threads.

		Group2Lock() allows any thread doing a 'Group2' operation to enter
	the lock and excludes threads calling Group1Lock().


	NOTE : 

	These locks cannot be re-entered after being acquired - 
	i.e. the call sequence : 

	Group1Lock() ;
	Group1Lock() ;
	Group1Unlock() ;
	Group1Unlock() ;
	
	Can cause a deadlock !

--*/


#include	<windows.h>
#include	"dbgtrace.h"
#include	"rwex.h"

namespace	rwex	{


CSymLock::CSymLock() : 
	m_lock( 0 ),
	m_Departures( 0 ), 
	m_left( 0 ), 
	m_hSema4Group1( 0 ),
	m_hSema4Group2( 0 )		{
/*++

Routine Description : 

	This function intiailizes a Symmetric Lock.
	We need to allocate to semaphores !

Arguments : 

	None.

Return Value : 

	None

--*/

	m_hSema4Group1 = CreateSemaphore( NULL, 0, LONG_MAX, NULL ) ;
	m_hSema4Group2 = CreateSemaphore( NULL, 0, LONG_MAX, NULL ) ;

}	

CSymLock::~CSymLock()	{
/*++

Routine Description : 

	This function destroys a symmetric lock - release
	the semaphores we've been using !

Arguments : 

	None.

Return Value : 

	None

--*/

	if( m_hSema4Group1 ) 
		CloseHandle( m_hSema4Group1 ) ;

	if( m_hSema4Group2 ) 
		CloseHandle( m_hSema4Group2 ) ;

}

BOOL
CSymLock::IsValid()	{
/*++

Routine Description : 

	Checks to see that the lock is valid !

Arguments : 

	None.

Return Value : 

	TRUE if it looks like we were successfully constructed - 
	FALSE otherwise !

--*/

	return	m_hSema4Group1 != 0 && m_hSema4Group2 != 0 ; 

}

BOOL
CSymLock::Group1Departures(	long	bump	)	{
/*++

Routine Description : 

	Execute the departure protocol for Group1 Threads when Group2 threads
	are waiting for the lock !

Arguments : 

	bump - Occasionally a Group2 thread needs to participate in 
		the Group1Departure protocol because of the timing of the entrance into
		the lock.
		When this occurs bump should be 1 and is used to account for the fact
		that the calling thread is a Group2 thread that may be able to go 
		straight into the lock.

Return Value : 

	TRUE - if the departure protocol is completed and Group2 threads can enter the lock !

--*/

	_ASSERT(  bump == 1 || bump == 0 ) ;

	//
	//	Now - we may be the thread that is last to leave !
	//
	long	result = InterlockedIncrement( (long*)&m_left ) ;
	if( result == m_Departures ) { 
		//
		//	We own the lock - but we need to free our buddies !
		//	Must set these to 0 before we allow other threads into the lock !
		//
		m_Departures = 0 ;
		m_left = 0 ;

		//
		//	The actual number of threads that left the lock is : 
		//
		result -- ;

		//
		//	This may allow other Group1 threads through the lock !
		//	
		result = InterlockedExchangeAdd( (long*)&m_lock,  - result ) - result ;

		//
		//	Okay - we can now figure out how many of our buddy threads to set free - 
		//	and whether we need to count departing threads !
		//

		long	cGroup2 = result >> 16 ;
		result &= 0x0000FFFF ;

		//
		//	Are there Group1 threads already trying to get back into the lock ?
		//	If so then the first Group1 thread that tried to reclaim the lock 
		//	was blocked - and so we need to setup the departure for the departing
		//	Group2 threads that we are going to release !
		//
		if( result != 0 ) {
			m_Departures = cGroup2 + 1 ;
			long	temp = InterlockedIncrement( (long*)&m_left ) ;
			//
			//	This can't happen because there is at LEAST 1 thread who is not leaving the lock
			//	anytime soon !
			//
			_ASSERT( temp != m_Departures ) ;
		}

		//
		//	Check if we are the sole Group2 thread trying to enter the lock - 
		//	in which case ReleaseSemaphore isn't necessary !
		//
		long	dwJunk ;
		if( cGroup2 != bump ) 
			ReleaseSemaphore( m_hSema4Group2, cGroup2-bump, &dwJunk ) ;
		
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CSymLock::Group2Departures(	long	bump	)	{
/*++

Routine Description : 

	Execute the departure protocol for Group2 Threads when Group1 threads
	are waiting for the lock !

Arguments : 

	bump - Occasionally a Group1 thread needs to participate in 
		the Group2Departure protocol because of the timing of the entrance into
		the lock.
		When this occurs bump should be 1 and is used to account for the fact
		that the calling thread is a Group2 thread that may be able to go 
		straight into the lock.

Return Value : 

	TRUE - if the departure protocol is completed and Group2 threads can enter the lock !

--*/

	_ASSERT(  bump == 1 || bump == 0 ) ;


	//
	//	Now - we may be the thread that is last to leave !
	//
	long	result = InterlockedIncrement( (long*)&m_left ) ;
	if( result == m_Departures ) { 
		//
		//	We own the lock - but we need to free our buddies !
		//	Must set these to 0 before we allow other threads into the lock !
		//
		m_Departures = 0 ;
		m_left = 0 ;

		//
		//	The actual number of threads that left the lock is : 
		//
		result -- ;

		//
		//	This may allow other Group1 threads through the lock !
		//	
		result = InterlockedExchangeAdd( (long*)&m_lock,  -(result << 16) ) - (result<<16) ;

		//
		//	Okay - we can now figure out how many of our buddy threads to set free - 
		//	and whether we need to count departing threads !
		//

		long	cGroup1 = result & 0x0FFFF ;
		result >>= 16 ;

		//
		//	Are there Group2 threads already trying to get back into the lock ?
		//	If so then the first Group1 thread that tried to reclaim the lock 
		//	was blocked - and so we need to setup the departure for the departing
		//	Group1 threads that we are going to release !
		//
		if( result != 0 ) {
			m_Departures = cGroup1 + 1 ;
			long	temp = InterlockedIncrement( (long*)&m_left ) ;
			//
			//	This can't happen because there is at LEAST 1 thread who is not leaving the lock
			//	anytime soon !
			//
			_ASSERT( temp != m_Departures ) ;
		}

		//
		//	NOTE : we added 1 to the lock for ourself, so we don't need to be released !
		//
		long	dwJunk ;
		if( cGroup1 != bump ) 
			ReleaseSemaphore( m_hSema4Group1, cGroup1-bump, &dwJunk ) ;
		
		return	TRUE ;
	}
	return	FALSE ;
}



void
CSymLock::Group1Lock()	{
/*++

Routine Description : 
	
	Acquire the lock for a Group1 Thread.
	Group1 Threads are tracked in the low word of the lock value !

Arguments : 

	None

Return Value : 

	None - blocks until the lock is acquired !


--*/

	long	result = InterlockedExchangeAdd( (long*)&m_lock, 1 ) + 1 ;
	long	cGroup2 = (result >> 16) ;

	if( cGroup2 != 0 ) {

		//
		//	We must block - somebody else is in the lock !
		//

		if( (result & 0xFFFF) == 1 ) {
			//
			//	First group1 thread to try - lets setup to count departing threads !
			//
			m_Departures = cGroup2 + 1 ;

			//
			//	Now - do the departure protocol - if this returns TRUE then
			//	we were the last thread through the protocol and hence we can continue on !
			//
			if( Group2Departures( 1 ) ) {
				return	 ;
			}
		}
		WaitForSingleObject( m_hSema4Group1, INFINITE ) ;
	}
}


void
CSymLock::Group2Lock()	{
/*++

Routine Description : 
	
	Acquire the lock for a Group1 Thread.
	Group2 Threads are tracked in the high word of the lock value !

Arguments : 

	None

Return Value : 

	None - blocks until the lock is acquired !


--*/

	long	result = InterlockedExchangeAdd( (long*)&m_lock, 0x10000 ) + 0x10000 ;
	long	cGroup1 = result & 0x0FFFF ;

	if( cGroup1 != 0 ) {

		//
		//	We must block - somebody else is in the lock !
		//

		if( (result >> 16) == 1 ) {
			//
			//	First group2 thread to try - lets setup to count departing threads !
			//
			m_Departures = cGroup1 + 1 ;

			//
			//	Now - do the departure protocol - if this returns TRUE then
			//	we were the last thread through the protocol and hence we can continue on !
			//
			if( Group1Departures( 1 ) ) {
				return	 ;
			}
		}
		WaitForSingleObject( m_hSema4Group2, INFINITE ) ;
	}
}


BOOL
CSymLock::InterlockedDecWordAndMask(	volatile	long*	plong,	
							long	mask,	
							long	decrement 
							) {
/*++

Routine Description : 

	This function subtracts 'decrement' from *plong if and only if 
	*plong & mask is zero.
	This is used by both Group1Unlock and Group2Unlock to decrement
	the count of their respective threads in the lock, but to only
	do the decrement when no threads of the other type are waiting !

Arguments : 

	plong - pointer to the long we wish to subtract from !
	mask -  the mask used to check the opposite word for zero
	decrement - the amount to subtract !

Return Value : 

	TRUE if the plong is decremented
	FALSE if the *plong & mask is ever non-zero !

--*/

	//
	//	do an initial read from the plong !
	//
	long	temp = *plong ;

	while( (temp&mask) == 0 ) {

		//
		//	Try to subtract decrement 
		//
		long newvalue = InterlockedCompareExchange( (long*)plong, (temp-decrement), temp ) ;
		//
		//	If newvalue is the same as temp then the subtraction occurred !
		//
		if( temp == newvalue ) 
			return	TRUE ;
		temp = newvalue ;
	}
	//
	//	The mask indicates that the opposite word is set !
	//
	return	FALSE ;
}

void
CSymLock::Group1Unlock()	{
/*++

Routine Description : 

	Perform the Group1 Exit protocol on the lock.

	If no Group2 threads are trying to enter, just decrement the lock appropriately.
	If Group2 Threads are waiting we have to go through the more complicated
	Group1Departures() exit protocol which determines which Group1 Thread is the last
	to leave so that it can let Group2 threads into the lock.

Arguments : 

	None.

Return Value : 

	None.

--*/

	if( !InterlockedDecWordAndMask( &m_lock, 0xFFFF0000, 1 ) )	{
		Group1Departures( 0 ) ;
	}
}

void
CSymLock::Group2Unlock()	{
/*++

Routine Description : 

	Perform the Group2 Exit protocol on the lock.

	If no Group1 threads are trying to enter, just decrement the lock appropriately.
	If Group1 Threads are waiting we have to go through the more complicated
	Group2Departures() exit protocol which determines which Group2 Thread is the last
	to leave so that it can let Group1 threads into the lock.

Arguments : 

	None.

Return Value : 

	None.

--*/

	if( !InterlockedDecWordAndMask( &m_lock, 0xFFFF, 0x10000 ) )	{
		Group2Departures( 0 ) ;
	}
}

}	// namespace rwex
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\rwex\rwex.cpp ===
#include <windows.h>
#include "rwex.h"

using namespace rwex;
#include "rw.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\rw\src\rw.cpp ===
//
// This file contains test implmentations of reader and writer locks.
// These are intended to be used with the template class in rw.h so that
// different implementations can be plugged in and tested.
// 
// The semantics of the read/write classes should be as follows : 
//	Functions CAN NOT be recursively called,
//	Multiple Readers should be able to enter the lock 
//	Only a single writer may execute at a time.
//



#include	<windows.h>
#include	<limits.h>
#include	"rwex.h"

namespace	rwex	{

long	const	BlockValue = (-LONG_MAX) / 2; 
							// Large in magnitude, negative value.  Used to 
							// indicate a waiting writer in cReadLock


CShareLock::CShareLock( ) : 
		cReadLock( 0  ), 
		cOutRdrs( 0 ),
		hWaitingWriters( 0 ),
		hWaitingReaders( 0 )	{
/*++

Routine Description : 

	Initialize Thre CShareLock() 

Arguments : 

	None.

Return Value : 

	None.

--*/

	InitializeCriticalSection( &critWriters ) ;
	hWaitingWriters = CreateSemaphore( NULL, 0, 1, NULL ) ;
	hWaitingReaders = CreateSemaphore( NULL, 0, LONG_MAX, NULL ) ;
}

CShareLock::~CShareLock( ) {
/*++

Routine Description : 

	Destroy the CShareLock - release the handles we allocated !

Arguments : 

	None.

Return Value : 

	None.

--*/

	if( hWaitingWriters ) 
		CloseHandle( hWaitingWriters ) ;
	if( hWaitingReaders ) 
		CloseHandle( hWaitingReaders ) ;
	DeleteCriticalSection( &critWriters ) ;
}


BOOL
CShareLock::IsValid()	{
/*++

Routine Description : 

	Checks to see that the lock is valid !

Arguments : 

	None.

Return Value : 

	TRUE if it looks like we were successfully constructed - 
	FALSE otherwise !

--*/

	return	hWaitingWriters != 0 && hWaitingReaders != 0 ; 

}


void
CShareLock::ShareLock( ) {
/*++

Routine Description : 

	Acquire the lock for shared mode.
	
Arguments : 

	None.

Return Value : 

	None.

--*/
	long	sign = InterlockedIncrement( (long*)&cReadLock ) ;
	if( sign > 0 ) {
		return ;
	}	else 	{
		// There must be a writer in the lock.  Wait for him to leave.
		// The InterlockedIncrement recorded our presence so that the writer
		// can later release the correct number of threads.
		WaitForSingleObject( hWaitingReaders, INFINITE ) ;
	}
}

void
CShareLock::ShareUnlock( ) {
/*++

Routine Description : 

	Release the lock from shared mode.
	If a writer is waiting for the lock, determine if we're
	the last thread to release the lock, and if so wake the writer !

Arguments : 

	None.

Return Value : 

	None.

--*/
	//
	// Leave the lock.  The return value will be negative if there is a writer
	// waiting.
	BOOL fWriterWaiting = InterlockedDecrement( (long*)&cReadLock ) < 0 ;

	if( fWriterWaiting ) {
		//
		// The following increment occurs when there is writer waiting, but
		// readers own the lock.  So although cReadLock is temporarily inaccurate
		// about the number of readers waiting for the lock, it is not inaccurate 
		// when it matters in WriteUnlock (which assumes a writer owns the lock.)
		//
		long sign = InterlockedIncrement( (long*)&cReadLock ) ;	// restore the value in cReadLock, so that we
												// end up with an accurate count of readers waiting
												// for entry.  

		sign = InterlockedDecrement( (long*)&cOutRdrs ) ;	// Make sure we don't lose track of the 
												// number for readers who have left the lock.
		//
		// Are we the last reader out of the lock ?
		//
		if( sign == 0 ) {
			//
			// Definately the last reader out !
			//
			ReleaseSemaphore( hWaitingWriters, 1, &sign ) ;
		}
	}
}

void
CShareLock::ExclusiveLock( ) {
/*++

Routine Description : 

	Acquire the lock for Exclusive use !

	First acquire a critical section to make sure we're the only
	exclusive thread in here.  Then see if there are any reader threads
	in the lock, and if there are wait for them to wake us !

Arguments : 

	None.

Return Value : 

	None.

--*/
	// Only one writer allowed to try for the lock at a time.
	//
	EnterCriticalSection( &critWriters ) ;

	//
	// Need to track the number of readers who leave the lock while we 
	// are trying to grab it.
	//
	cOutRdrs = 0 ;
	// Grab the lock 
 	long	oldsign = InterlockedExchange( (long*)&cReadLock, BlockValue ) ;

	//
	//	Now, add the number of readers who used to be in the lock to 
	//	the number of readers who have left the lock.  If this comes out
	//	to be zero, there are no readers in the lock and we can go on !
	//
	long	value = InterlockedExchangeAdd( (long*)&cOutRdrs, oldsign ) + oldsign ;
	//
	// Do we own the lock ?  Only if there were no readers, or they have all left already.
	//
	if( value != 0 ) {
		// Wait for a reader to signal us.
		WaitForSingleObject( hWaitingWriters, INFINITE ) ;
	}
}



void
CShareLock::ExclusiveUnlock( ) 	{
/*++

Routine Description : 

	Release the lock from Exclusive Use.
	First, we see if readers are waiting and let a bunch of them in.
	Then we release the critical section to let other Exclusive threads in !

Arguments : 

	None.

Return Value : 

	None.

--*/


	//
	//	Get the number of readers waiting to enter the lock !
	//	This Addition automatically leaves m_cReadLock with the number
	//	of readers who had been waiting !
	//
	long cTotal = InterlockedExchangeAdd( (long*)&cReadLock, -BlockValue ) - BlockValue ;

	//
	//	Now release all the readers who had been waiting !
	//
	if( cTotal > 0 ) {
		ReleaseSemaphore( hWaitingReaders, cTotal, &cTotal) ;	// let all those readers go!
	}
	//
	// Let the next writer take his shot at the lock!
	//
	LeaveCriticalSection( &critWriters ) ;
}

void
CShareLock::ExclusiveToShared()	{
/*++

Routine Description : 

	Release our exclusive lock on the reader/writer lock, in exchange
	for a read lock.  This cannot fail !

Arguments : 
	
	None.

Return Value : 

	None.

--*/

	//
	//	Get the number of readers waiting to enter the lock !
	//	Note that we add one onto m_cReadLock for our hold on the reader lock, 
	//	but we don't add this to m_cOutCounter, as the number of readers waiting is one smaller !
	//
	long cTotal = InterlockedExchangeAdd( (long*)&cReadLock, 1-BlockValue ) -BlockValue ;

	if( cTotal > 0 ) {
		ReleaseSemaphore( hWaitingReaders, cTotal, &cTotal )  ;
	}
	LeaveCriticalSection( &critWriters ) ;
}

BOOL
CShareLock::SharedToExclusive()	{
/*++

Routine Description : 
	
	If there is only one reader in the lock, (and therefore we assume
	that reader is the calling thread), acquire the lock exclusive !!

Arguments :

	None.

Return Value : 

	TRUE if we acquired it exclusive
	If we return FALSE, we still have the lock shared !!


--*/

	//
	//	Try to get the critical section first !
	//
	if( TryEnterCriticalSection( &critWriters ) ) {

		//
		//	If there is only one reader in the lock we can get this exclusive !!
		//
		if( InterlockedCompareExchange( (long*)&cReadLock, BlockValue, 1 ) == 1 ) {
			return	TRUE ;

		}
		LeaveCriticalSection( &critWriters ) ;
	}
	return	FALSE ;
}

BOOL
CShareLock::TryShareLock()	{
/*++

Routine Description : 

	Get the lock shared if nobody else is in the lock
	Keep looping trying to add 1 to the number of readers
	as long as there are no writers waiting !!!

Arguments : 

	None.

Return Value : 

	TRUE if successfull, FALSE otherwise !

--*/

	//
	//	get the initial number of readers in the lock !
	//
	long	temp = cReadLock ; 

	while( temp >= 0 ) {

		long	result = InterlockedCompareExchange( 
								(long*)&cReadLock, 
								(temp+1),	
								temp 
								) ;
		//
		//	Did we manage to add 1 ? 
		//
		if( result == temp ) {
			return	TRUE ;
		}
		temp = result ;
	}
	//
	//	Writer has or wants the lock - we should go away !
	//
	return	FALSE ;
}

BOOL
CShareLock::TryExclusiveLock()	{
/*++

Routine Description : 

	Get the lock exclusively if nobody else is in the lock

Arguments : 

	None.

Return Value : 

	TRUE if successfull, FALSE otherwise !

--*/

	//
	//
	//

	if( TryEnterCriticalSection(&critWriters)	)	{

		if( InterlockedCompareExchange( (long*)&cReadLock, 
										BlockValue, 
										0 ) == 0 ) {
			return	TRUE ;
		}	
		LeaveCriticalSection(&critWriters) ;
	}
	return	FALSE ;
}


void
CShareLock::PartialLock()	{
/*++

Routine Description : 

	Grab a partial lock.  All other PartialLock() or ExclusiveLock()
	threads will block for as long as we hold the PartialLock().

Arguments : 

	None.

Return Value : 

	none

--*/

	//
	//	Only one writer in here at a time - grab this lock exclusively !
	//
	EnterCriticalSection( &critWriters ) ;
}


void
CShareLock::PartialUnlock()	{
/*++

Routine Description : 

	Releases the partial lock.  Anybody else can enter !

Arguments : 

	None.

Return Value : 

	none

--*/


	LeaveCriticalSection( &critWriters ) ;

}

void
CShareLock::FirstPartialToExclusive()	{
/*++

Routine Description : 

	Changes the partial lock to an Exclusive Lock.
	Basically, we complete the Exclusive Locking protocol
	that is found in Exclusive Lock.

Arguments : 

	None.

Return Value : 

	none

--*/

	//
	// Need to track the number of readers who leave the lock while we 
	// are trying to grab it.
	//
	cOutRdrs = 0 ;
	// Grab the lock 
 	long	oldsign = InterlockedExchange( (long*)&cReadLock, BlockValue ) ;

	//
	//	Now, add the number of readers who used to be in the lock to 
	//	the number of readers who have left the lock.  If this comes out
	//	to be zero, there are no readers in the lock and we can go on !
	//
	long	value = InterlockedExchangeAdd( (long*)&cOutRdrs, oldsign ) + oldsign ;
	//
	// Do we own the lock ?  Only if there were no readers, or they have all left already.
	//
	if( value != 0 ) {
		// Wait for a reader to signal us.
		WaitForSingleObject( hWaitingWriters, INFINITE ) ;
	}
}

BOOL
CShareLock::PartialToExclusive()	{
/*++

Routine Description : 

	Changes the partial lock to an Exclusive Lock.
	this is the same as FirstPartialToExclusive().

Arguments : 

	None.

Return Value : 

	TRUE always, because we always succeed !

--*/

	FirstPartialToExclusive() ;
	return	TRUE ;
}

void
CShareLock::ExclusiveToPartial()	{
/*++

Routine Description : 

	Changes the Exclusive Lock into a Partial Lock 
	Very similar to ExclusiveUnlock() - but don't release the crit sect !

Arguments : 

	None.

Return Value : 

	None.

--*/


	//
	//	Get the number of readers waiting to enter the lock !
	//	This Addition automatically leaves m_cReadLock with the number
	//	of readers who had been waiting !
	//
	long cTotal = InterlockedExchangeAdd( (long*)&cReadLock, -BlockValue ) - BlockValue ;

	//
	//	Now release all the readers who had been waiting !
	//
	if( cTotal > 0 ) {
		ReleaseSemaphore( hWaitingReaders, cTotal, &cTotal) ;	// let all those readers go!
	}

	//
	//	Don't release Critical Section !
	//
}



void
CShareLock::PartialToShared()	{
/*++

Routine Description : 

	Since we never really blocked readers from entering this 
	is pretty trivial - just add ourselves to the number of 
	readers in the lock and release the crit sect.

Arguments : 

	None.

Return Value : 

	None.

++*/

	long	l = InterlockedIncrement( (long*)&cReadLock ) ;

	//
	//	Now allow other Partial or Exclusive threads to try !
	//
	LeaveCriticalSection( &critWriters ) ;

}

BOOL
CShareLock::SharedToPartial()	{
/*++

Routine Description : 

	We don't care if other readers are already in the lock - 
	just go after the critical section !

Arguments : 

	None.

Return Value : 

	TRUE if we get a partial Lock !

++*/

	//
	//	Try to get the critical section first !
	//
	if( TryEnterCriticalSection(&critWriters)	)	{
		//
		//	Must decrement this so we don't track number of readers wrong !
		//
		long l = InterlockedDecrement( (long*)&cReadLock ) ;
		//_ASSERT( l >= 0 ) ;

		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CShareLock::TryPartialLock()	{
/*++

Routine Description : 

	We don't care if other readers are already in the lock - 
	just go after the critical section !

Arguments : 

	None.

Return Value : 

	TRUE if we manage to get a Partial Lock

++*/

	//
	//	Try to get the critical section first !
	//
	if( TryEnterCriticalSection(&critWriters)	)	{
		return	TRUE ;
	}
	return	FALSE ;
}


}	// namespace rwex
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\regtrace\regtrdlg.h ===
// regtrdlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRegTraceDlg dialog

class CRegTraceDlg : public CDialog
{
// Construction
public:
	CRegTraceDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CRegTraceDlg)
	enum { IDD = IDD_REGTRACE_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRegTraceDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CRegTraceDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\rwinst\rwinst.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: rwinst.cpp
//
//  Description:  Implementation of CShareLockInst library functions
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      5/24/99 - MikeSwa Created
//      8/6/99 - MikeSwa  created phatq version
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <windows.h>
#include <rwinst.h>
#include <stdlib.h>
#include <dbgtrace.h>

//Static initialization
LIST_ENTRY      CShareLockInst::s_liLocks;
volatile DWORD  CShareLockInst::s_dwLock = 0;
DWORD           CShareLockInst::s_cLockSpins = 0;
DWORD           CShareLockInst::s_dwSignature = SHARE_LOCK_INST_SIG_FREE;

//---[ CThreadIdBlock::cIncThreadCount ]---------------------------------------
//
//
//  Description:
//      Increments the thread count for a given thread ID
//  Parameters:
//      dwThreadId      Thread to increment the thread count for
//  Returns:
//      New count value
//  History:
//      8/9/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD CThreadIdBlock::cIncThreadCount(DWORD dwThreadId)
{
    _ASSERT(THREAD_ID_BLOCK_UNUSED != dwThreadId);
    CThreadIdBlock *ptblkCurrent = this;
    CThreadIdBlock *ptblkOld = NULL;
    CThreadIdBlock *ptblkNew = NULL;

    while (ptblkCurrent)
    {
        _ASSERT(THREAD_ID_BLOCK_SIG == ptblkCurrent->m_dwSignature);
        if (dwThreadId == ptblkCurrent->m_dwThreadId)
            return InterlockedIncrement((PLONG) &(ptblkCurrent->m_cThreadRecursionCount));

        ptblkOld = ptblkCurrent;
        ptblkCurrent = ptblkCurrent->m_ptblkNext;
    }

    _ASSERT(ptblkOld); //we should hit loop at least once

    //See if the current block has a thread ID associated with it
    if (THREAD_ID_BLOCK_UNUSED == ptblkOld->m_dwThreadId)
    {
        //This is actually the head block... use it to avoid an extra alloc
        if (THREAD_ID_BLOCK_UNUSED == InterlockedCompareExchange(
                    (PLONG) &ptblkOld->m_dwThreadId,
                    dwThreadId, THREAD_ID_BLOCK_UNUSED))
        {
            _ASSERT(dwThreadId == ptblkOld->m_dwThreadId);
            //Now this thread block is the current one
            return InterlockedIncrement((PLONG) &ptblkOld->m_cThreadRecursionCount);
        }
    }

    //We did not find it... we must create a new CThreadIdBlock
    ptblkNew = new CThreadIdBlock();

    //if we fail to alloc 32 bytes... I should see if we have spun out of
    //control
    _ASSERT(ptblkNew);
    if (!ptblkNew)
        return 1; //Fake success for our callers

    ptblkNew->m_dwThreadId = dwThreadId;
    ptblkNew->m_cThreadRecursionCount = 1;

    ptblkCurrent = (CThreadIdBlock *) InterlockedCompareExchangePointer(
                        (PVOID *) &ptblkOld->m_ptblkNext,
                        (PVOID) ptblkNew,
                        NULL);

    //If it is non-NULL, then our insert failed
    if (ptblkCurrent)
    {
        _ASSERT(ptblkCurrent != ptblkNew);
        //Whoops... another thread has added a block... time to try again
        //This time, start search from the block the just appeared
        delete ptblkNew;
        return ptblkCurrent->cIncThreadCount(dwThreadId);
    }

    //We inserted the block... inital count was 1
    return 1;
}

//---[ CThreadIdBlock::cDecThreadCount ]---------------------------------------
//
//
//  Description:
//      Decrements the thread count for a given thread ID
//  Parameters:
//      dwThreadId
//  Returns:
//      The resulting count
//  History:
//      8/9/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD CThreadIdBlock::cDecThreadCount(DWORD dwThreadId)
{
    _ASSERT(THREAD_ID_BLOCK_UNUSED != dwThreadId);
    CThreadIdBlock *ptblkCurrent = this;

    while (ptblkCurrent)
    {
        _ASSERT(THREAD_ID_BLOCK_SIG == ptblkCurrent->m_dwSignature);
        if (dwThreadId == ptblkCurrent->m_dwThreadId)
            return InterlockedDecrement((PLONG) &(ptblkCurrent->m_cThreadRecursionCount));

        ptblkCurrent = ptblkCurrent->m_ptblkNext;
    }

    //We didn't find it... we would have asserted on insertion
    //Don't assert twice
    //$$TODO - Add global counts of these failures
    return 0;
}

//---[ CThreadIdBlock::cMatchesId ]--------------------------------------------
//
//
//  Description:
//      Checks if this thread block (or one in this thread blocks chain)
//      matches the given thread id.  Returns the count for this thread
//  Parameters:
//      dwThreadId - Thread Id to search for
//  Returns:
//      Thread count if the thread ID is found
//      0 if not found (or count is 0)
//  History:
//      8/9/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD CThreadIdBlock::cMatchesId(DWORD dwThreadId)
{
    CThreadIdBlock *ptblk = this;
    while (ptblk)
    {
        _ASSERT(THREAD_ID_BLOCK_SIG == ptblk->m_dwSignature);
        if (ptblk->m_dwThreadId == dwThreadId)
            return ptblk->m_cThreadRecursionCount;

        ptblk = ptblk->m_ptblkNext;
    }
    return 0;
}

//---[ CShareLockInst::AcquireStaticSpinLock ]---------------------------------
//
//
//  Description:
//      Acquires static spin lock... from aqueue\cat\ldapstor
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Adapted from JStamerJ's code
//
//-----------------------------------------------------------------------------
void CShareLockInst::AcquireStaticSpinLock()
{
    do {

        //
        // Spin while the lock is unavailable
        //

        while (s_dwLock > 0)
        {
            Sleep(0);
            InterlockedIncrement((PLONG) &s_cLockSpins);
        }

        //
        // Lock just became available, try to grab it
        //

    } while ( InterlockedIncrement((PLONG) &s_dwLock) != 1 );

    //We have the lock... make sure that s_liLocks has been initialized
    if (s_dwSignature != SHARE_LOCK_INST_SIG)
    {
        InitializeListHead(&s_liLocks);
        s_dwSignature = SHARE_LOCK_INST_SIG;
    }
}

//---[ CShareLockInst::ReleaseStaticSpinLock ]---------------------------------
//
//
//  Description:
//      Releases previously acquired spinlock
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Adapted from JStamerJ's code
//
//-----------------------------------------------------------------------------
void CShareLockInst::ReleaseStaticSpinLock()
{
    _ASSERT(SHARE_LOCK_INST_SIG == s_dwSignature); //static init was done
    _ASSERT(s_dwLock > 0);
    InterlockedExchange((PLONG) &s_dwLock, 0 );
}

//---[ CShareLockInst::CShareLockInst ]----------------------------------------
//
//
//  Description:
//      Constructor for CShareLockInst
//  Parameters:
//      szDescription       Constant string passed in to describe lock
//      dwFlags             Flags describing what to track
//      cMaxTrackedSharedThreadIDs  Maximum # of threads to track
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CShareLockInst::CShareLockInst(LPCSTR szDescription,
                               DWORD dwFlags, DWORD cMaxTrackedSharedThreadIDs)
{
    DWORD cbArray = sizeof(DWORD) * cMaxTrackedSharedThreadIDs;
    m_dwSignature = SHARE_LOCK_INST_SIG;
    m_dwFlags = dwFlags;
    m_liLocks.Flink = NULL;
    m_liLocks.Blink = NULL;
    m_cShareAttempts = 0;
    m_cShareAttemptsBlocked = 0;
    m_cExclusiveAttempts = 0;
    m_cExclusiveAttemptsBlocked = 0;
    m_szDescription = szDescription;
    m_rgtblkSharedThreadIDs = NULL;
    m_dwExclusiveThread = NULL;
    m_cCurrentSharedThreads = 0;
    m_cMaxConcurrentSharedThreads = 0;
    m_cMaxTrackedSharedThreadIDs = cMaxTrackedSharedThreadIDs;

    if (SHARE_LOCK_INST_TRACK_NOTHING & m_dwFlags)
        m_dwFlags = 0;

    //Allocate memory to store thread IDs
    if (fTrackSharedThreads())
    {
        _ASSERT(cbArray);
        m_rgtblkSharedThreadIDs = new CThreadIdBlock[m_cMaxTrackedSharedThreadIDs];
        if (!m_rgtblkSharedThreadIDs)
            m_cMaxTrackedSharedThreadIDs = 0;
    }

    //Insert in list if we are tracking
    if (fTrackInGlobalList())
    {
        AcquireStaticSpinLock();
        InsertHeadList(&s_liLocks, &m_liLocks);
        ReleaseStaticSpinLock();
    }
};

//---[ CShareLockinst::~CShareLockinst ]---------------------------------------
//
//
//  Description:
//      CShareLockInst desctructor.  Will remove this lock from the
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CShareLockInst::~CShareLockInst()
{
    m_dwSignature = SHARE_LOCK_INST_SIG_FREE;
    if (m_rgtblkSharedThreadIDs)
    {
        delete [] m_rgtblkSharedThreadIDs;
        m_rgtblkSharedThreadIDs = NULL;
    }

    if (fTrackInGlobalList())
    {
        AcquireStaticSpinLock();
        RemoveEntryList(&m_liLocks);
        ReleaseStaticSpinLock();
    }

};


//---[ CShareLockInst::LogAcquireShareLock ]-----------------------------------
//
//
//  Description:
//      Does all the work of logging the appropriate information when a thread
//      acquires the lock shared.
//          - Updates max concurrent shared threads
//          - Updates current shared threads
//          - Updates lists of shared thread IDs
//          - Asserts when shared deadlocks are detected
//  Parameters:
//      BOOL    fTry - TRUE if this is for a try enter (deadlock cannot happen)
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CShareLockInst::LogAcquireShareLock(BOOL fTry)
{

    if (fTrackSharedThreads())
    {
        DWORD   cCurrentSharedThreads = 0;
        DWORD   cMaxConcurrentSharedThreads = 0;
        DWORD   dwThreadID = GetCurrentThreadId();
        DWORD   dwThreadCount = 0;
        DWORD   dwThreadHash = 0;

        _ASSERT(dwThreadID); //Our algorithm requires this to be non-zero
        cCurrentSharedThreads = InterlockedIncrement((PLONG) &m_cCurrentSharedThreads);

        //Update max concurrent threads if we have set a new record
        cMaxConcurrentSharedThreads = m_cMaxConcurrentSharedThreads;
        while (cCurrentSharedThreads > cMaxConcurrentSharedThreads)
        {
            InterlockedCompareExchange((PLONG) &m_cMaxConcurrentSharedThreads,
                                       (LONG) cCurrentSharedThreads,
                                       (LONG) cMaxConcurrentSharedThreads);

            cMaxConcurrentSharedThreads = m_cMaxConcurrentSharedThreads;
        }

        //if we have a place to store our thread ID...save it
        if (m_rgtblkSharedThreadIDs)
        {
            dwThreadHash = dwHashThreadId(dwThreadID,
                                          m_cMaxTrackedSharedThreadIDs);
            _ASSERT(dwThreadHash < m_cMaxTrackedSharedThreadIDs);
            dwThreadCount = m_rgtblkSharedThreadIDs[dwThreadHash].cIncThreadCount(dwThreadID);

            if (!fTry && (dwThreadCount > 1))
            {
                //This thread already holds this lock... this is a
                //potential deadlock situation
                if (fAssertSharedDeadlocks())
                {
                    _ASSERT(0 && "Found potential share deadlock");
                }
            }
        }
    }
}

//---[ CShareLockInst::LogReleaseShareLock ]-----------------------------------
//
//
//  Description:
//      Called when a sharelock is released to cleanup the information stored
//      in LogAcquireShareLock.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CShareLockInst::LogReleaseShareLock()
{
    if (fTrackSharedThreads())
    {
        DWORD dwThreadID = GetCurrentThreadId();
        DWORD dwThreadHash = 0;

        _ASSERT(dwThreadID); //Our algorithm requires this to be non-zero

        //Search through list of thread IDs for
        if (m_rgtblkSharedThreadIDs)
        {
            dwThreadHash = dwHashThreadId(dwThreadID,
                                          m_cMaxTrackedSharedThreadIDs);
            _ASSERT(dwThreadHash < m_cMaxTrackedSharedThreadIDs);
            m_rgtblkSharedThreadIDs[dwThreadHash].cDecThreadCount(dwThreadID);
        }
    }
}

//---[ CShareLockInst::ShareLock ]---------------------------------------------
//
//
//  Description:
//      Implements sharelock wrapper
//  Parameters:
//
//  Returns:
//
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CShareLockInst::PrvShareLock()
{

    LogAcquireShareLock(FALSE);
    //If we are tracking contention, then we will try to enter the sharelock
    //and increment the contention count if that fails.
    if (fTrackContention())
    {
        InterlockedIncrement((PLONG) &m_cShareAttempts);
        if (!CShareLockInstBase::TryShareLock())
        {
            InterlockedIncrement((PLONG) &m_cShareAttemptsBlocked);
            CShareLockInstBase::ShareLock();
        }
    }
    else
    {
        CShareLockInstBase::ShareLock();
    }

};


//---[ CShareLockInst::ShareUnlock ]-------------------------------------------
//
//
//  Description:
//      Wrapper for ShareUnlock
//  Parameters:
//
//  Returns:
//
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CShareLockInst::PrvShareUnlock()
{
    LogReleaseShareLock();
    CShareLockInstBase::ShareUnlock();
};

//---[ CShareLockInst::TryShareLock ]------------------------------------------
//
//
//  Description:
//      Implements TryShareLock wrapper.
//  Parameters:
//
//  Returns:
//      TRUE if the lock was acquired.
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CShareLockInst::PrvTryShareLock()
{
    BOOL fLocked = FALSE;

    fLocked = CShareLockInstBase::TryShareLock();

    if (fLocked)
        LogAcquireShareLock(TRUE);

    return fLocked;
};

//---[ CShareLockInst::ExclusiveLock ]-----------------------------------------
//
//
//  Description:
//      Implements ExclusiveLock wrapper
//  Parameters:
//
//  Returns:
//
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CShareLockInst::PrvExclusiveLock()
{

    //If we are tracking contention, then we will try to enter the lock
    //and increment the contention count if that fails.
    if (fTrackContention())
    {
        InterlockedIncrement((PLONG) &m_cExclusiveAttempts);
        if (!CShareLockInstBase::TryExclusiveLock())
        {
            InterlockedIncrement((PLONG) &m_cExclusiveAttemptsBlocked);
            CShareLockInstBase::ExclusiveLock();
        }
    }
    else
    {
        CShareLockInstBase::ExclusiveLock();
    }

    if (fTrackExclusiveThreads())
    {
        //This should be the only thread accessing this now
        _ASSERT(!m_dwExclusiveThread);
        m_dwExclusiveThread = GetCurrentThreadId();
    }

};


//---[ CShareLockInst::ExclusiveUnlock ]---------------------------------------
//
//
//  Description:
//      Wrapper for ExclusiveUnlock
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CShareLockInst::PrvExclusiveUnlock()
{
    if (fTrackExclusiveThreads())
    {
        _ASSERT(GetCurrentThreadId() == m_dwExclusiveThread);
        m_dwExclusiveThread = 0;
    }
    CShareLockInstBase::ExclusiveUnlock();
};

//---[ CShareLockInst::TryExclusiveLock ]--------------------------------------
//
//
//  Description:
//      Implements TryExclusiveLock wrapper.
//  Parameters:
//
//  Returns:
//      TRUE if the lock was acquired.
//  History:
//      5/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CShareLockInst::PrvTryExclusiveLock()
{
    BOOL fLocked = FALSE;

    fLocked = CShareLockInstBase::TryExclusiveLock();

    if (fLocked && fTrackExclusiveThreads())
    {
        //This should be the only thread accessing this now
        _ASSERT(!m_dwExclusiveThread);
        m_dwExclusiveThread = GetCurrentThreadId();
    }
    return fLocked;
};

//---[ CShareLockInst::PrvAssertIsLocked ]-------------------------------------
//
//
//  Description:
//      Asserts if this threads ID is not recorded as one that acquired this
//      lock.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/24/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CShareLockInst::PrvAssertIsLocked()
{
    DWORD dwThreadID = GetCurrentThreadId();
    DWORD dwThreadHash = 0;
    BOOL  fFoundThreadID = FALSE;

    _ASSERT(dwThreadID); //Our algorithm requires this to be non-zero

    //Bail out if we are not configured to track this things.
    if (!fTrackSharedThreads() || !fTrackExclusiveThreads() || !m_rgtblkSharedThreadIDs)
        return;

    if (dwThreadID == m_dwExclusiveThread)
    {
        fFoundThreadID = TRUE;
    }
    else
    {
        dwThreadHash = dwHashThreadId(dwThreadID,
                                      m_cMaxTrackedSharedThreadIDs);
        _ASSERT(dwThreadHash < m_cMaxTrackedSharedThreadIDs);
        fFoundThreadID = (0 < m_rgtblkSharedThreadIDs[dwThreadHash].cMatchesId(dwThreadID));

    }

    if (!fFoundThreadID)
        _ASSERT(0 && "Lock is not held by this thread!!!");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\rwnh\src\rwintrnl.cpp ===
/*++

	rwintrnl.cpp

	This file contains classes and methods only for use within
	the reader/writer locks defined in rw.h

--*/

#include	<windows.h>
#include	<stdio.h>
#include	"rwnew.h"


HANDLE	CWaitingThread::g_rghHandlePool[ POOL_HANDLES ] ;

CHandleInfo	CHandleInfo::s_Head ;
CRITICAL_SECTION	CHandleInfo::s_InUseList ;
CHandleInfo	CHandleInfo::s_FreeHead ;
DWORD	CHandleInfo::s_cFreeList = 0 ;


void
CHandleInfo::InsertAtHead( CHandleInfo*	pHead	)		{

	CHandleInfo*	pNext = pHead->m_pNext ;
	m_pNext = pNext ;
	m_pPrev = pHead ;
	pNext->m_pPrev = this ;
	pHead->m_pNext = this ;
}

CHandleInfo*
CHandleInfo::RemoveList( ) {
	CHandleInfo*	pNext = m_pNext ;
	CHandleInfo*	pPrev = m_pPrev ;
	pNext->m_pPrev = pPrev ;
	pPrev->m_pNext = pNext ;
	m_pNext = 0 ;
	m_pPrev = 0 ;
	return	this ;
}


void*
CHandleInfo::operator	new(	size_t size ) {
/*++

Routine Description :

	Allocate memory for a CHandleInfo structure from the system heap !

Arguments :

	Size of the object, should always be sizeof( CHandleInfo ) !

Return Value :

	Pointer to allocated memory !

--*/



	_ASSERT( size == sizeof( CHandleInfo ) ) ;
	return	HeapAlloc( GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, size ) ;
}

void
CHandleInfo::operator	delete( void*	pv ) {
/*++

Routine Description :

	Release memory for a CHandleInfo structure to the system heap !

Arguments :

	Memory to be freed

Return Value :

	Nothing !

--*/


	HeapFree( GetProcessHeap(), 0, pv ) ;
}

CHandleInfo::CHandleInfo() :
	m_dwSignature( SIGNATURE ),
	m_pNext( 0 ),
	m_pPrev( 0 ),
	m_hSemaphore( 0 )
	{
/*++

Routine Description :

	Construct a CHandleInfo object !

Arguments :

	Memory to be freed

Return Value :

	Nothing !

--*/

	m_hSemaphore= CreateSemaphore( 0, 0, LONG_MAX, 0 ) ;
    m_hEvent = CreateEvent( 0, FALSE, FALSE, 0 ) ;

}

CHandleInfo::~CHandleInfo() {
/*++

Routine Description :

	Release memory for a CHandleInfo structure to the system heap !

Arguments :

	Memory to be freed

Return Value :

	Nothing !

--*/

	_ASSERT( m_dwSignature == SIGNATURE ) ;
	m_dwSignature = 0 ;

	_ASSERT( m_pNext == 0 || (this == &s_Head || this == &s_FreeHead)) ;
	_ASSERT( m_pPrev == 0 || (this == &s_Head || this == &s_FreeHead)) ;

	if( m_hSemaphore != 0 ) {

		CloseHandle( m_hSemaphore) ;
	}
	m_hSemaphore = 0 ;
    if( m_hEvent != 0 )
        CloseHandle( m_hEvent ) ;
    m_hEvent = 0 ;
}


BOOL
CHandleInfo::InitClass()	{
/*++

Routine Description :

	Initialize our handle tracking data structures.

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	s_Head.m_pPrev = s_Head.m_pNext = &s_Head ;
	s_FreeHead.m_pPrev = s_FreeHead.m_pNext = &s_FreeHead ;

	InitializeCriticalSection( &s_InUseList ) ;

	EnterCriticalSection( &s_InUseList ) ;

	for( DWORD i=0; i < INITIAL_FREE; i++ ) {

		CHandleInfo*	p = new CHandleInfo() ;
		if( !p ) {
			break ;
		}	else	{
			p->InsertAtHead( &s_FreeHead ) ;
			s_cFreeList ++ ;
		}
	}
	LeaveCriticalSection( &s_InUseList ) ;
	return	i == INITIAL_FREE ;
}

void
CHandleInfo::TermClass()	{
/*++

Routine Description :

	Destroy our handle tracking structures and release all handles !

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	DeleteCriticalSection( &s_InUseList ) ;

	while( 	s_FreeHead.m_pNext != &s_FreeHead ) {
		CHandleInfo*	p = s_FreeHead.m_pNext->RemoveList() ;
		delete	p ;
	}
	while( 	s_Head.m_pNext != &s_Head ) {
		CHandleInfo*	p = s_Head.m_pNext->RemoveList() ;
		delete	p ;
	}
}

CHandleInfo*
CHandleInfo::AllocHandleInfo()	{
/*++

Routine Description :

	Allocate an object to hold Handle Information !

Arguments :

	None.

Return Value :

	Pointer to a CHandleInfo structure !

--*/

	EnterCriticalSection( &s_InUseList ) ;

	CHandleInfo* p = s_FreeHead.m_pNext ;
	if( p != &s_FreeHead ) {
		p->RemoveList() ;
		p->InsertAtHead( &s_Head ) ;
		s_cFreeList -- ;
	}	else	{
		p = new CHandleInfo() ;
		if (!p)
		{
			LeaveCriticalSection( &s_InUseList ) ;
			return NULL;
		}
		p->InsertAtHead( &s_Head ) ;
	}
	LeaveCriticalSection( &s_InUseList ) ;

	if( p->m_hSemaphore == 0 ) {
		p->m_hSemaphore = CreateSemaphore( 0, 0, LONG_MAX, 0 ) ;

	}
    if( p->m_hEvent == 0 ) {
        p->m_hEvent = CreateEvent( 0, FALSE, FALSE, 0 ) ;
    }
	return	p ;
}

void
CHandleInfo::ReleaseHandleInfo( CHandleInfo* p ) {
/*++

Routine Description :

	Allocate an object to hold Handle Information !

Arguments :

	None.

Return Value :

	Pointer to a CHandleInfo structure !

--*/

	EnterCriticalSection( &s_InUseList ) ;

	p->RemoveList() ;
	if( s_cFreeList < MAX_FREE ) {
		p->InsertAtHead( &s_FreeHead ) ;
		s_cFreeList ++ ;
		p = 0 ;
	}
	LeaveCriticalSection( &s_InUseList ) ;

	if( p )	{
		delete	p ;
	}
}


BOOL	WINAPI
DllEntryPoint(
			HINSTANCE	hinstDll,
			DWORD		dwReason,
			LPVOID		lpvReserved ) {

	BOOL	fRtn = TRUE ;

	switch( dwReason ) {

		case	DLL_PROCESS_ATTACH :

//DebugBreak() ;

			fRtn &= CHandleInfo::InitClass() ;
			fRtn &= CWaitingThread::InitClass() ;
			CWaitingThread::ThreadEnter() ;

			return	fRtn ;
			break ;


		case	DLL_THREAD_ATTACH :
			CWaitingThread::ThreadEnter() ;
			break ;

		case	DLL_THREAD_DETACH :
			CWaitingThread::ThreadExit() ;
			break ;

		case	DLL_PROCESS_DETACH :

			CWaitingThread::TermClass() ;
			CHandleInfo::TermClass() ;
			break ;

	}
	return	TRUE ;
}


BOOL	WINAPI
DllMain(	HANDLE	hInst,
			ULONG	dwReason,
			LPVOID	lpvReserve )	{

	return	DllEntryPoint( (HINSTANCE)hInst, dwReason, lpvReserve ) ;

}



DWORD	CWaitingThread::g_dwThreadHandle = 0 ;

BOOL
CWaitingThread::InitClass()	{

	g_dwThreadHandle = TlsAlloc() ;

	ZeroMemory( g_rghHandlePool, sizeof( g_rghHandlePool ) ) ;

	for( int i=0; i< (sizeof( g_rghHandlePool ) / sizeof( g_rghHandlePool[0] )) / 2; i++ )	{
		g_rghHandlePool[i] = 			CreateSemaphore( 0, 0, LONG_MAX, 0 ) ;

	}

	return	g_dwThreadHandle != 0xFFFFFFFF ;
}

BOOL
CWaitingThread::TermClass()	{

	for( int i=0; i< (sizeof( g_rghHandlePool ) / sizeof( g_rghHandlePool[0] )); i++ )	{

		CloseHandle( g_rghHandlePool[i] ) ;
	}


	return	TlsFree( g_dwThreadHandle ) ;

}

void
CWaitingThread::ThreadEnter()	{

	CHandleInfo*	pInfo = CHandleInfo::AllocHandleInfo() ;
	_ASSERT( pInfo != 0 ) ;
	_ASSERT( pInfo->m_hSemaphore != 0 ) ;
	_ASSERT( pInfo->IsValid() ) ;
	TlsSetValue( g_dwThreadHandle, (LPVOID)pInfo ) ;

}

void
CWaitingThread::ThreadExit()	{

	CHandleInfo*	pInfo = (CHandleInfo*)	TlsGetValue( g_dwThreadHandle ) ;
	if( pInfo ) {
	    _ASSERT( pInfo->IsValid() ) ;
	    CHandleInfo::ReleaseHandleInfo( pInfo ) ;
	}

	TlsSetValue( g_dwThreadHandle, (LPVOID)0 ) ;
}

CWaitingThread::CWaitingThread() :
		m_pInfo( (CHandleInfo*)TlsGetValue( g_dwThreadHandle ) ),
		m_dwError( 0 ) {

	if( m_pInfo == 0 ) {
		m_pInfo = CHandleInfo::AllocHandleInfo() ;
		TlsSetValue( g_dwThreadHandle, (LPVOID)m_pInfo ) ;
	}
	if( m_pInfo->m_hSemaphore == 0 ) {
		for( int i=0;
				m_pInfo->m_hSemaphore == 0 &&
				i < sizeof( g_rghHandlePool ) / sizeof( g_rghHandlePool[0] );
				i++ ) {
			m_pInfo->m_hSemaphore = (HANDLE)InterlockedExchangePointer( (void**)&g_rghHandlePool[i], 0 ) ;
		}

		if( m_pInfo->m_hSemaphore == 0 )	{
			m_pInfo->m_hSemaphore =
				CreateSemaphore( 0, 0, LONG_MAX, 0 ) ;

		}
	}

#ifdef	DEBUG
	m_dwThreadId = GetCurrentThreadId() ;


	long	lPrev = 0 ;
	ReleaseSemaphore( m_pInfo->m_hSemaphore, 1, &lPrev ) ;
	_ASSERT( lPrev == 0 ) ;
	DWORD	dw = WaitForSingleObject( m_pInfo->m_hSemaphore, 0 ) ;
	_ASSERT( dw == WAIT_OBJECT_0 ) ;
#endif

}




CEventQueue::CEventQueue( long	cInitial ) :
	m_WaitingThreads( cInitial > 0 ),
	m_ReleaseCount( cInitial  )	{
}

BOOL
CEventQueue::ResumeThreads(	CWaitingThread*	pMyself	)	{

	BOOL	fRtn = FALSE ;
	CWaitingThread*	pThread = m_WaitingThreads.RemoveAndRelease() ;
	long	sign = 1 ;

	while( pThread ) {

		sign = InterlockedDecrement( &m_ReleaseCount ) ;

		if( pThread != pMyself ) {
			_VERIFY( pThread->Release() ) ;
		}	else	{
			fRtn = TRUE ;
		}

		if( sign <= 0 ) {
			break ;
		}

		pThread = m_WaitingThreads.RemoveAndRelease() ;

	}
	return	fRtn ;
}

void
CEventQueue::Release(	long	ReleaseCount )	{

	InterlockedExchangeAdd( &m_ReleaseCount, ReleaseCount ) ;

	ResumeThreads( 0 ) ;

}

void
CEventQueue::Reset()	{

	m_WaitingThreads.Reset() ;

}


void
CEventQueue::WaitForIt(	CWaitingThread&	myself ) {

	if( m_WaitingThreads.Append( &myself ) ) {

		if( !ResumeThreads( &myself ) ) {

			_VERIFY( myself.Wait() ) ;
		}

	}	else	{

		_VERIFY( myself.Wait() ) ;

	}
}

void
CEventQueue::WaitForIt()	{

	CWaitingThread	myself ;

	WaitForIt( myself ) ;
}

CEventQueue::~CEventQueue()	{
}





CSingleReleaseQueue::CSingleReleaseQueue(
		BOOL	IsSignalled
		) :
	m_Waiting( IsSignalled )	{
}

void
CSingleReleaseQueue::WaitForIt(
		CWaitingThread&	myself
		)	{

	if(	m_Waiting.Append( &myself ) ) {
		CWaitingThread*	pThread = m_Waiting.RemoveAndRelease() ;
		if( !pThread ) {
			_VERIFY( myself.Wait() ) ;
		}	else	if( pThread != &myself ) {

			_VERIFY( pThread->Release() ) ;
			_VERIFY( myself.Wait() ) ;

		}
	}	else	{

		_VERIFY( myself.Wait() ) ;

	}
}

void
CSingleReleaseQueue::WaitForIt()	{

	CWaitingThread	myself ;

	WaitForIt( myself ) ;
}

void
CSingleReleaseQueue::Release( ) {

	CWaitingThread*	pThread = m_Waiting.RemoveAndRelease() ;
	if( pThread ) {

#ifdef	DEBUG
		m_ThreadIdNext = pThread->m_dwThreadId ;
#endif

		_VERIFY( pThread->Release() ) ;

	}	else	{

		pThread = (CWaitingThread*)0 ;

	}
}


void
CCritSection::Enter(	CWaitingThread&	myself )	{
/*++

Routine Description :

	Acquire the critical section

Arguments :

	myself - the CWaitingThread object which contains the handle
		we use to block the calling thread and queue on a list
		if we can't get the lock !

Return Value :

	None - returns when lock is acquired !

--*/

	if( m_hOwner == myself.GetThreadHandle() ) {
		m_RecursionCount ++ ;
	}	else	{

		if( InterlockedIncrement( &m_lock ) == 0 ) {

		}	else	{
			m_queue.WaitForIt(	myself ) ;
		}
		m_hOwner = myself.GetThreadHandle() ;
		m_RecursionCount = 1 ;

#ifdef	DEBUG
		m_dwThreadOwner = GetCurrentThreadId() ;
#endif

		//	_ASSERT( m_RecursionCount == 0 ) ;
	}
}

BOOL
CCritSection::TryEnter(	CWaitingThread&	myself )	{
/*++

Routine Description :

	Attempt to acquire the critical section, don't wait
	if somebody else is in the lock !

Arguments :

	myself - the CWaitingThread object which contains the handle
		we use to block the calling thread and queue on a list
		if we can't get the lock !

Return Value :

	None - returns when lock is acquired !

--*/

	if( m_hOwner == myself.GetThreadHandle() ) {
		m_RecursionCount ++ ;
	}	else	{

		if( InterlockedCompareExchange (&m_lock, 0, -1 ) != -1 ) {
			return	FALSE ;
		}
		m_hOwner = myself.GetThreadHandle() ;
		m_RecursionCount = 1 ;

#ifdef	DEBUG
		m_dwThreadOwner = GetCurrentThreadId() ;
#endif
		//	_ASSERT( m_RecursionCount == 0 ) ;
	}
	return	TRUE ;
}



void
CCritSection::Enter( )	{
/*++

Routine Description :

	Acquire the critical section

Arguments :

	none.

Return Value :

	None - returns when lock is acquired !

--*/

	CWaitingThread	myself ;

	Enter( myself ) ;
}


void
CCritSection::Leave()		{
/*++

Routine Description :

	Release the critical section !

Arguments :

	none.

Return Value :

	None - returns when lock is acquired !

--*/

#ifdef	DEBUG
	_ASSERT( m_dwThreadOwner == GetCurrentThreadId() ) ;
	CWaitingThread	myself ;
	_ASSERT( myself.GetThreadHandle() == m_hOwner ) ;
#endif

	m_RecursionCount -- ;
	if( m_RecursionCount == 0 ) {

		m_hOwner = INVALID_HANDLE_VALUE ;

		if( InterlockedDecrement( &m_lock ) >= 0 ) {
			m_queue.Release() ;
		}
	}
}


void
CSimpleCritSection::Enter(	CWaitingThread&	myself )	{
/*++

Routine Description :

	Acquire the critical section

Arguments :

	myself - the CWaitingThread object which contains the handle
		we use to block the calling thread and queue on a list
		if we can't get the lock !

Return Value :

	None - returns when lock is acquired !

--*/

	if( InterlockedIncrement( &m_lock ) != 0 ) {
		m_queue.WaitForIt(	myself ) ;
	}
#ifdef	DEBUG
	m_dwThreadOwner = GetCurrentThreadId() ;
#endif
}

BOOL
CSimpleCritSection::TryEnter(	CWaitingThread&	myself )	{
/*++

Routine Description :

	Attempt to acquire the critical section, don't wait
	if somebody else is in the lock !

Arguments :

	myself - the CWaitingThread object which contains the handle
		we use to block the calling thread and queue on a list
		if we can't get the lock !

Return Value :

	None - returns when lock is acquired !

--*/

	if( InterlockedCompareExchange (&m_lock, 0, -1 ) != -1 ) {
		return	FALSE ;
	}
#ifdef	DEBUG
	m_dwThreadOwner = GetCurrentThreadId() ;
#endif
	return	TRUE ;
}



void
CSimpleCritSection::Enter( )	{
/*++

Routine Description :

	Acquire the critical section

Arguments :

	none.

Return Value :

	None - returns when lock is acquired !

--*/

	CWaitingThread	myself ;

	Enter( myself ) ;
}


void
CSimpleCritSection::Leave()		{
/*++

Routine Description :

	Release the critical section !

Arguments :

	none.

Return Value :

	None - returns when lock is acquired !

--*/

	if( InterlockedDecrement( &m_lock ) >= 0 ) {
		m_queue.Release() ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\dispatch.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	dispatch.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object Dispatcher service.

Author:

	Andy Jacobs	(andyj@microsoft.com)

Revision History:

	andyj	11/26/96	created

--*/


#include "stdafx.h"
#include "seo.h"
#include "dispatch.h"


class CDictItemNameList {
	public:
		CDictItemNameList(ISEODictionary *piFrom);
		~CDictItemNameList();
	public:
		DWORD m_dwCount;
		CComVariant *m_aNames;
};


static HRESULT ReallocCComVariant(CComVariant **ppBase,
								  DWORD dwBaseCnt,
								  DWORD dwNewBaseCnt) {
	CComVariant *pNew = NULL;

	if (dwBaseCnt == dwNewBaseCnt) {
		return (S_OK);
	}
	if (!dwNewBaseCnt) {
		delete[] *ppBase;
		*ppBase = NULL;
		return (S_OK);
	}
	ATLTRY(pNew = new CComVariant[dwNewBaseCnt];)
	_ASSERTE(pNew);
	if (!pNew) {
		return (E_OUTOFMEMORY);
	}
	for (DWORD dwIdx=0;(dwIdx<dwBaseCnt)&&(dwIdx<dwNewBaseCnt);dwIdx++) {
		pNew[dwIdx].Attach(&(*ppBase)[dwIdx]);
	}
	delete[] *ppBase;
	*ppBase = pNew;
	return (S_OK);
}


static HRESULT ReallocCComVariant(CComVariant **ppBase,
								  DWORD dwBaseCnt,
								  CComVariant *pAdd,
								  DWORD dwAddCnt) {
	HRESULT hrRes;

	hrRes = ReallocCComVariant(ppBase,dwBaseCnt,dwBaseCnt+dwAddCnt);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	for (DWORD dwIdx=0;dwIdx<dwAddCnt;dwIdx++) {
		(*ppBase)[dwIdx+dwBaseCnt].Attach(&pAdd[dwIdx]);
	}
	return (S_OK);
}


CDictItemNameList::CDictItemNameList(ISEODictionary *piFrom) {
	HRESULT hrRes;

	m_dwCount = 0;
	m_aNames = NULL;
	if (piFrom) {
		CComPtr<IUnknown> pUnkEnum;

		hrRes = piFrom->get__NewEnum(&pUnkEnum);
		if (SUCCEEDED(hrRes)) {
			CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pevEnum(pUnkEnum);

			if (pevEnum) {
				while (1) {
					CComVariant aNew[20];
					DWORD dwCnt;

					hrRes = pevEnum->Next(sizeof(aNew)/sizeof(aNew[0]),aNew,&dwCnt);
					if (!SUCCEEDED(hrRes)) {
						break;
					}
					if (!dwCnt) {
						break;
					}
					hrRes = ReallocCComVariant(&m_aNames,m_dwCount,aNew,dwCnt);
					if (!SUCCEEDED(hrRes)) {
						break;
					}
					for (DWORD dwIdx=0;dwIdx<dwCnt;dwIdx++) {
						hrRes = m_aNames[dwIdx+m_dwCount].ChangeType(VT_BSTR);
						_ASSERTE(SUCCEEDED(hrRes));
						if (!SUCCEEDED(hrRes)) {
							// Ack!  Ok - just drop this name off the list by moving the last name
							// on the list to this position, and fiddling the indexes so that we
							// attemp to convert this position again.
							if (dwIdx<dwCnt-1) {
								m_aNames[dwIdx+m_dwCount].Attach(&m_aNames[dwCnt+m_dwCount-1]);
							}
							dwIdx--;
							dwCnt--;
						}
					}
					m_dwCount += dwCnt;
				}
			}
		}
	}
}


CDictItemNameList::~CDictItemNameList() {

	delete[] m_aNames;
	m_dwCount = 0;
	m_aNames = NULL;
}


CSEOBaseDispatcher::CSEOBaseDispatcher() {

	m_apbBindings = NULL;
	m_dwBindingsCount = 0;
}


CSEOBaseDispatcher::~CSEOBaseDispatcher() {

	while (m_dwBindingsCount) {
		delete m_apbBindings[--m_dwBindingsCount];
	}
	delete[] m_apbBindings;
	m_apbBindings = NULL;
}


HRESULT STDMETHODCALLTYPE CSEOBaseDispatcher::SetContext(ISEORouter *piRouter, ISEODictionary *pdictBP) {
	HRESULT hrRes;
	CComPtr<ISEODictionary> pdictBindings;

	_ASSERT(!m_dwBindingsCount&&!m_apbBindings);
	hrRes = pdictBP->GetInterfaceA(BD_BINDINGS,IID_ISEODictionary,(IUnknown **) &pdictBindings);
	if (SUCCEEDED(hrRes)) {
		CDictItemNameList dinlBindings(pdictBindings);

		if (dinlBindings.m_dwCount) {
			m_apbBindings = new CBinding *[dinlBindings.m_dwCount];
			if (!m_apbBindings) {
				return (E_OUTOFMEMORY);
			}
			memset(m_apbBindings,0,sizeof(CBinding *)*dinlBindings.m_dwCount);
			for (m_dwBindingsCount=0;m_dwBindingsCount<dinlBindings.m_dwCount;m_dwBindingsCount++) {
				CComPtr<ISEODictionary> pdictBinding;

				pdictBinding.Release();
				hrRes = pdictBindings->GetInterfaceW(dinlBindings.m_aNames[m_dwBindingsCount].bstrVal,
													 IID_ISEODictionary,
													 (IUnknown **) &pdictBinding);
				_ASSERT(SUCCEEDED(hrRes));
				if (SUCCEEDED(hrRes)) {
					hrRes = AllocBinding(pdictBinding,&m_apbBindings[m_dwBindingsCount]);
					_ASSERT(SUCCEEDED(hrRes));
				}
			}
			qsort(m_apbBindings,m_dwBindingsCount,sizeof(m_apbBindings[0]),comp_binding);
		}
	}
	if (SUCCEEDED(hrRes)) {
		m_piRouter = piRouter;
		m_pdictBP = pdictBP;
	}
	return (hrRes);
}


static HRESULT GetCLSIDFromBinding(LPCSTR pszCLSID,
								   LPCSTR pszProgID,
								   ISEODictionary *piBinding,
								   CLSID *pclsid) {
	HRESULT hrRes;
	CComVariant varTmp;

	if (!piBinding) {
		return (E_POINTER);
	}
	if (pszCLSID) {
		hrRes = piBinding->GetVariantA(pszCLSID,&varTmp);
		if (SUCCEEDED(hrRes)) {
			hrRes = varTmp.ChangeType(VT_BSTR);
			if (SUCCEEDED(hrRes)) {
				hrRes = CLSIDFromString(varTmp.bstrVal,pclsid);
				if (SUCCEEDED(hrRes)) {
					return (hrRes);
				}
			}
		}
		varTmp.Clear();
	}
	if (!pszProgID) {
		return (E_FAIL);	// tbd - come up with a better error code
	}
	hrRes = piBinding->GetVariantA(pszProgID,&varTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = varTmp.ChangeType(VT_BSTR);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CLSIDFromProgID(varTmp.bstrVal,pclsid);
	return (hrRes);
}


HRESULT CSEOBaseDispatcher::CBinding::Init(ISEODictionary *piBinding) {
	HRESULT hrRes;
	CComVariant varTmp;
	CLSID clsidTmp;

	if (!piBinding) {
		return (E_POINTER);
	}
	// Try to get the CLSID of the object - if an error occurs,
	// this binding is invalid.
	hrRes = GetCLSIDFromBinding(BD_OBJECT,BD_PROGID,piBinding,&m_clsidObject);
	if (!SUCCEEDED(hrRes)) {
		return (S_FALSE);
	}
	// From this point on, all errors are silently ignored - we
	// use default values if we can't get something from the binding
	// database.
	hrRes = piBinding->GetVariantA(BD_PRIORITY,&varTmp);
	if (SUCCEEDED(hrRes)) {
		hrRes = varTmp.ChangeType(VT_I4);
		if (SUCCEEDED(hrRes)) {
			m_dwPriority = (DWORD) varTmp.lVal;
		}
	}
	if (!SUCCEEDED(hrRes)) {
		// If the priority isn't set, default to "last".
		m_dwPriority = (DWORD) -1;
	}
	varTmp.Clear();
	m_piBinding = piBinding;
	// Try to get an instance of the rule engine.
	hrRes = GetCLSIDFromBinding(BD_RULEENGINE,NULL,piBinding,&clsidTmp);
	if (SUCCEEDED(hrRes)) {
		hrRes = CoCreateInstance(clsidTmp,
								 NULL,
								 CLSCTX_ALL,
								 IID_ISEOBindingRuleEngine,
								 (LPVOID *) &m_piRuleEngine);
	}
	// See if the 'exclusive' flag has been set.
	m_bExclusive = FALSE;
	hrRes = piBinding->GetVariantA(BD_EXCLUSIVE,&varTmp);
	if (SUCCEEDED(hrRes)) {
		hrRes = varTmp.ChangeType(VT_BOOL);
		if (SUCCEEDED(hrRes)) {
			if (varTmp.boolVal) {
				m_bExclusive = TRUE;
			}
		} else {
			hrRes = varTmp.ChangeType(VT_I4);
			if (SUCCEEDED(hrRes)) {
				if (varTmp.lVal) {
					m_bExclusive = TRUE;
				}
			}
		}
	}
	varTmp.Clear();
	m_bValid = TRUE;
	return (S_OK);
}


int CSEOBaseDispatcher::CBinding::Compare(const CBinding& b) const {

	if (m_dwPriority == b.m_dwPriority) {
		return (0);
	} else {
		return ((m_dwPriority>b.m_dwPriority)?1:-1);
	}
}


HRESULT CSEOBaseDispatcher::AllocBinding(ISEODictionary *pdictBinding, CBinding **ppbBinding) {
	HRESULT hrRes;

	if (!ppbBinding) {
		return (E_POINTER);
	}
	*ppbBinding = new CBinding;
	if (!*ppbBinding) {
		return (E_OUTOFMEMORY);
	}
	hrRes = (*ppbBinding)->Init(pdictBinding);
	if (!SUCCEEDED(hrRes)) {
		delete *ppbBinding;
		*ppbBinding = NULL;
	}
	return (hrRes);
}


static int _cdecl comp_binding(const void *pv1, const void *pv2) {
	const CSEOBaseDispatcher::CBinding **ppb1 = (const CSEOBaseDispatcher::CBinding **) pv1;
	const CSEOBaseDispatcher::CBinding **ppb2 = (const CSEOBaseDispatcher::CBinding **) pv2;

	return ((*ppb1)->Compare(**ppb2));
}


HRESULT CSEOBaseDispatcher::Dispatch(CEventParams *pEventParams) {
	BOOL bObjectCalled = FALSE;
	HRESULT hrRes;

	for (DWORD dwIdx=0;dwIdx<m_dwBindingsCount;dwIdx++) {
		if (!m_apbBindings[dwIdx]->m_bValid) {
			continue;
		}
		if (m_apbBindings[dwIdx]->m_bExclusive && bObjectCalled) {
			continue;
		}
		hrRes = pEventParams->CheckRule(*m_apbBindings[dwIdx]);
		if (hrRes == S_OK) {
			hrRes = pEventParams->CallObject(*m_apbBindings[dwIdx]);
			if ((hrRes == SEO_S_DONEPROCESSING) || m_apbBindings[dwIdx]->m_bExclusive) {
				break;
			}
		}
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\dispatch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	dispatch.h

Abstract:

	This module contains the class definition for the Server
	Extension Object Dispatcher service.

Author:

	Andy Jacobs	(andyj@microsoft.com)

Revision History:

	andyj	12/04/96	created
	andyj	02/12/97	Converted PropertyBag's to Dictonary's
	dondu	03/14/97	Major rewrite
	dondu	03/31/97	Updated for ISEODispatcher::SetContext

--*/


/*
	Typical usage...

	class CMyDispatcher :
		public CSEOBaseDispatcher,
		public IMyDispatcher,
		public CComObjectRootEx<CComMultiThreadModelNoCS>,
		public CCoClass<CMyDispatcher,CLSID_CCMyDispatcher> {

		DECLARE_PROTECT_FINAL_CONSTRUCT();

		DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
									   L"MyDispatcher Class",
									   L"My.MyDispatcher.1",
									   L"My.MyDispatcher");

		DECLARE_GET_CONTROLLING_UNKNOWN();

		BEGIN_COM_MAP(CSEORouter)
			COM_INTERFACE_ENTRY(ISEODispatcher)
			COM_INTERFACE_ENTRY(IMyDispatcher)
			COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)	// if free-threaded
		END_COM_MAP()

		// You implement this if you need to do something during init...
		HRESULT FinalConstruct() {
			// If you are free-threaded, you must at least do this.
			return (CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p));
		}

		// You implement this if you need to do something during term...
		void FinalRelease();

		// Private stuff
		class CMyEventParams : CEventParams {
			virtual HRESULT CheckRule(CBinding& bBinding);	// you have to implement this ...
			virtual HRESULT CallObject(CBinding& bBinding);	// ... and this too
			DWORD m_dwWhatever;			// these are your parameters which ...
			IUnknown *pUnkWhatever;		// ... you are going to pass to the sink
		};

		// You have to implement this.
		HRESULT CMyEventParams::CheckRule(CBinding& bBinding) {
			if (bBinding.m_piRuleEngine) {
				// call the external rule engine
			} else {
				// do internal rule evaluation
			}
			// return values are either S_OK to call the object, or anything else (usually
			// S_FALSE for no error) if not to call the object
			return (S_OK);
		}

		// And you have to implement this.
		HRESULT CMyEventParams::CallObject(CBinding& bBinding) {
			// use bBinding.clsidObject to create the object
			// QI for the interface you want
			// call the object
			return (S_OK);
		}

		// IMyDispatcher - this is your server-specific dispatcher interface
		// Do something like this...
		HRESULT STDMETHODCALLTYPE OnEvent(DWORD dwWhatever, IUnknown *pUnkWhatever) {
			CMyEventParams epParams;

			epParams.m_dwWhatever = dwWhatever;
			epParams.m_dwUnkWhatever = pUnkWhatever;
			return (Dispatch(&epParams));
		}

		// If you want to add stuff to the CBinding object, you can override
		// CSEOBaseDispatcher::AllocBinding, and use that function to allocate,
		// initialize, and return an object which is derived from CBinding.
		class CMyBinding : public CBinding {
			DWORD m_dwSomeNewProperty;
			HRESULT Init(ISEODictionary *piBinding) {
				// some custom init code
				return (S_OK);
			}
		};
		HRESULT AllocBinding(ISEODictionary *piBinding, CBinding **ppbBinding) {
			*ppbBinding = new CMyBinding;
			if (!*ppbBinding) {
				return (E_OUTOFMEMORY);
			}
			hrRes = ((CMyBinding *) (*ppbBinding))->Init(piBinding);
			if (!SUCCEEDED(hrRes)) {
				delete *ppbBinding;
				*ppbBinding = NULL;
			}
			return (hrRes);
		}

	};

*/


class CSEOBaseDispatcher : public ISEODispatcher {

	public:
		CSEOBaseDispatcher();
		virtual ~CSEOBaseDispatcher();
		class CBinding {
			public:
				CBinding() { m_bValid = FALSE; };
				virtual ~CBinding() {};
				HRESULT Init(ISEODictionary *piBinding);
				virtual int Compare(const CBinding& b) const;
			public:
				DWORD m_dwPriority;
				CComPtr<ISEODictionary> m_piBinding;
				CComPtr<ISEOBindingRuleEngine> m_piRuleEngine;
				BOOL m_bExclusive;
				CLSID m_clsidObject;
				BOOL m_bValid;
		};
		class CEventParams {
			public:
				virtual HRESULT CheckRule(CBinding& bBinding) = 0;
				virtual HRESULT CallObject(CBinding& bBinding) = 0;
		};
		virtual HRESULT Dispatch(CEventParams *pEventParams);

	public:
		// ISEODispatcher
		HRESULT STDMETHODCALLTYPE SetContext(ISEORouter *piRouter, ISEODictionary *pdictBP);

	protected:
		virtual HRESULT AllocBinding(ISEODictionary *pdictBinding, CBinding **ppbBinding);
		CComPtr<ISEORouter> m_piRouter;
		CComPtr<ISEODictionary> m_pdictBP;

	private:
		friend static int _cdecl comp_binding(const void *pv1, const void *pv2);
		CBinding **m_apbBindings;
		DWORD m_dwBindingsCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\rwnh\src\rwv3.cpp ===
/*++

	rwv3.cpp

	This file defines another version of reader/writer locks that
	attempt to use no handles !


--*/


#include	<windows.h>
#include	"dbgtrace.h"
#include	"rwnew.h"
#include	"rwexport.h"

long	const	BlockValue = (-LONG_MAX) / 2;


CShareLockNH::CShareLockNH()	:
	m_cReadLock( 0 ),
	m_cOutReaders( 0 ),
	m_cOutAcquiringReaders( 0 ),
	m_cExclusiveRefs( 0 ),
	m_hWaitingReaders( 0 ),
	m_hWaitingWriters( 0 )	{

}

#ifdef	DEBUG
extern	CRITICAL_SECTION	DebugCrit ;
#endif


void
CShareLockNH::ShareLock()	{
	if( InterlockedIncrement( (long*)&m_cReadLock ) < 0 ) {
		ShareLockInternal() ;
	}
}

void
CShareLockNH::ShareUnlock()	{
	if( InterlockedDecrement( (long*)&m_cReadLock ) < 0 ) {
		ShareUnlockInternal() ;
	}
}


void
CShareLockNH::ShareLockInternal()	{
/*++

Routine Description :

	Acquire the lock in shared mode.
	If there is a writer trying to enter the lock, then we will
	have to wait, in which case we have to block on a semaphore handle
	that we or another reader provide.
	In the writer waiting case, we also have to carefully track which
	waiting reader thread is the LAST to be wakened up and return to
	the caller so we can properly manage the HANDLE used by all the
	reader threads.

Arguments :
	
	None.

Return Value :

	None.


--*/


	TraceFunctEnter("CShareLockNH::ShareLockInternal") ;

#if 0
	//
	//	This part of the logic is implemented by ShareLock() -
	//	which is an inline function !!
	//
	if( InterlockedIncrement( &m_cReadLock ) < 0 ) {
#endif

		//
		//	There is a writer who either owns the lock or is waiting
		//	to acquire the lock - either way he gets to go first and
		//	this thread should be blocked !
		//
		CWaitingThread	myself ;

		//
		//	Get the handle we've saved for this thread !
		//
		HANDLE	h = myself.GetThreadHandle() ;

		//
		//	If we are the first reader here, this function will return
		//	0, otherwise we'll get the handle of the first reader to
		//	save his handle !
		//
		HANDLE	hBlockOn = InterlockedCompareExchangePointer( (void**)&m_hWaitingReaders, (void*)h, 0 ) ;

		if( hBlockOn == 0 ) {
			hBlockOn= h;
		}

		DebugTrace( (DWORD_PTR)this, "hBlock - %x", hBlockOn ) ;

		//
		//	Wait for the writer to release the lock !
		//
		WaitForSingleObject( hBlockOn, INFINITE ) ;


		//
		//	We need to figure out whether we should do anything about
		//	the m_hWaitingReaders value - it needs to be set to 0 before
		//	another reader comes through this path !
		//

		long	l = InterlockedDecrement( (long*)&m_cOutAcquiringReaders ) ;
		_ASSERT( l>=0 ) ;

		DebugTrace( (DWORD_PTR)this, "l - %x", l ) ;

		if( l == 0 ) {


			//
			//	We are the last reader who was waiting !
			//	we can safely manipulate m_hWaitingReaders with no consequences !
			//	If it's our handle, then we'll do nothing with it,
			//	if it's not our handle we'll return it to the pool of handles !
			//

			m_hWaitingReaders = 0 ;

			if( hBlockOn != h ) {
				myself.PoolHandle( hBlockOn ) ;
			}

			//
			//	A Writer held the lock, and then relinquished it to us readers,
			//	but he didn't release the Exclusive Lock that let him keep other writers
			//	out.  We do that for him !!!
			//

			if( (l=InterlockedDecrement( (long*)&m_cExclusiveRefs )) == 0 )
				m_lock.Leave() ;

			DebugTrace( (DWORD_PTR)this, "Leave l - %x", l ) ;

		}	else	{
		
			//
			//	Our handle was left in the lock, we need to get rid of our
			//	reference to it, the last reader will return to the pool !
			//
			if( hBlockOn == h ) {

				myself.ClearHandle( h ) ;
			}
		}
#if 0
	}
#endif
}

void
CShareLockNH::ShareUnlockInternal()	{
/*++

Routine Description :

	Release the lock from shared mode.
	If a writer is waiting we need to figure out if we're
	the last reader to leave, in which case we wake the writer !

Arguments :
	
	None.

Return Value :

	None.


--*/

	TraceFunctEnter("CShareLockNH::ShareLockInternal") ;

#if 0
	//
	//	This portion of the function is moved into an inline function !
	//
	if( InterlockedDecrement( &m_cReadLock ) < 0 ) {
#endif

		//
		//	There is a writer waiting to enter the lock,
		//	(we assume he's waiting because the thread calling
		//	this presumably had a readlock !)
		//

		//
		//	Restore the count of the number of readers who are
		//	waiting for the writer to leave !
		//
		long	result = InterlockedIncrement( (long*)&m_cReadLock ) ;

		DebugTrace( (DWORD_PTR)this, "result - %x", result ) ;

		//
		//	Are we the last reader to leave the lock ?
		//
		if( (result = InterlockedDecrement( (long*)&m_cOutReaders )) == 0 ) {

			//
			//	Yes, we were the last reader - signal the writer !
			//
			long	junk ;
			ReleaseSemaphore( m_hWaitingWriters, 1, &junk ) ;

			DebugTrace( (DWORD_PTR)this, "ReleaseSemaphore - result %x junk %x", result, junk ) ;

		}
#if 0
	}
#endif
}

void
CShareLockNH::ExclusiveLock( )	{
/*++

Routine Description :

	Acquire the reader/writer lock exclusively.
	Note that we must set up the handle we are to block on if readers
	are in the lock, and clear it up when we leave !

Arguments :
	
	None.

Return Value :

	None.

--*/


	TraceFunctEnter("CShareLockNH::ExclusiveLock") ;

	CWaitingThread	myself ;

	//
	//	Only one writer in here at a time - grab this lock exclusively !
	//
	m_lock.Enter( myself ) ;

	//
	//	Number of references to the Exclusive Lock !
	//	This needs to get decremented down to 0 before m_lock.Leave() is called !
	//
	m_cExclusiveRefs = 1 ;

	//
	//	Everytime m_cOutCounter is used, by the time anybody is done with
	//	it, it should be back to zero !
	//
	_ASSERT( m_cOutReaders == 0 ) ;

	//
	//	Set this handle before we do anything to signal readers
	//	that we are waiting
	//
	m_hWaitingWriters = myself.GetThreadHandle() ;

	long	oldsign = InterlockedExchange( (long*)&m_cReadLock, BlockValue ) ;

	//
	//	oldsign now contains the number of readers who have entered the
	//	lock and have not yet left it !
	//

	//
	//	Do this as an add, to determine how many readers are still left !
	//

	long	value = InterlockedExchangeAdd( (long*)&m_cOutReaders, oldsign ) + oldsign ;
	_ASSERT( value >= 0 ) ;

	DebugTrace( (DWORD_PTR)this, "oldsign %x value %x", oldsign, value ) ;

	//
	//	If value is 0, either there was no readers in the lock when we
	//	exchanged with m_cReadLock, or they all left (and decremented m_cOutCounter)
	//	before we managed to call InterlockedExchangeAdd !!
	//
	if( value != 0 ) {
		//
		//	A reader will have to signal us !
		//
		WaitForSingleObject( m_hWaitingWriters, INFINITE ) ;
	}
	
	//
	//	There are no longer any writers waiting so no need for this handle !
	//
	m_hWaitingWriters = 0 ;
}


void	inline
CShareLockNH::WakeReaders()		{
/*++

Routine Description :

	This function awakens the readers who may have been waiting for the
	lock when a writer left the lock.

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CShareLockNH::WakeReaders" ) ;

	DebugTrace( (DWORD_PTR)this, "m_cOutAcquiringReaders %x", m_cOutAcquiringReaders ) ;

	long	result;
	//
	//	If there were any readers waiting we need to wake them up !
	//
	if( m_cOutAcquiringReaders > 0 ) {

		//
		//	There are readers in the lock, but they may not have setup their
		//	blocking handle yet, so we take part in that !!!
		//
		CWaitingThread	myself ;

		//
		//	Get the handle we've saved for this thread !
		//
		HANDLE	h = myself.GetThreadHandle() ;

		//
		//	If we are the first thread to set the m_hWaitingReaders value we'll get
		//	a 0 back !
		//
		HANDLE	hBlockOn = InterlockedCompareExchangePointer( (void**)&m_hWaitingReaders, (void*)h, 0 ) ;

		if( hBlockOn == 0 ) {
			hBlockOn= h;
		}

		//
		//	Release those readers from the lock
		//
		ReleaseSemaphore( hBlockOn, m_cOutAcquiringReaders, &result ) ;

		//
		//	Our handle was left in the lock, we need to get rid of our
		//	reference to it, the last reader will return to the pool !
		//
		if( hBlockOn == h ) {
			myself.ClearHandle( h ) ;
		}

		//
		//	NOTE : All those readers we just woke up should decrement
		//	m_cOutCounter to 0 !!
		//
	}	else	{

		//
		//	we should decrement m_cExclusiveRefs back down to 0 before releasing !
		//
		if( (result = InterlockedDecrement( (long*)&m_cExclusiveRefs )) == 0 )
			m_lock.Leave() ;

		DebugTrace( (DWORD_PTR)this, "result %x", result ) ;

	}

}


void
CShareLockNH::ExclusiveUnlock()	{
/*++

Routine Description :

	Release our exclusive lock on the reader/writer lock.
	Note that we must get an accurate count of waiting readers
	so that the readers we awaken can manage the m_hWaitingReaders value.

Arguments :
	
	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CShareLockNH::ExclusiveUnlock" ) ;


	//
	//	Get the number of readers waiting to enter the lock !
	//	This Addition automatically leaves m_cReadLock with the number
	//	of readers who had been waiting !
	//
	m_cOutAcquiringReaders = InterlockedExchangeAdd( (long*)&m_cReadLock, -BlockValue ) - BlockValue ;

	DebugTrace( (DWORD_PTR)this, "m_cOutAcquiringReaders %x", m_cOutAcquiringReaders ) ;

	WakeReaders() ;

	//
	//	Let other writers have a shot !!
	//
	//m_lock.Leave() ;
}

void
CShareLockNH::ExclusiveToShared()	{
/*++

Routine Description :

	Release our exclusive lock on the reader/writer lock, in exchange
	for a read lock.  This cannot fail !

Arguments :
	
	None.

Return Value :

	None.

--*/

	TraceFunctEnter("CShareLockNH::ExclusiveToShared" ) ;

	//
	//	Get the number of readers waiting to enter the lock !
	//	Note that we add one onto m_cReadLock for our hold on the reader lock,
	//	but we don't add this to m_cOutCounter, as the number of readers waiting is one smaller !
	//
	m_cOutAcquiringReaders = InterlockedExchangeAdd( (long*)&m_cReadLock, 1-BlockValue ) -BlockValue ;

	DebugTrace( (DWORD_PTR)this, "m_cOutAcquiringReaders %x", m_cOutAcquiringReaders ) ;

	WakeReaders() ;
	
}

BOOL
CShareLockNH::SharedToExclusive()	{
/*++

Routine Description :
	
	If there is only one reader in the lock, (and therefore we assume
	that reader is the calling thread), acquire the lock exclusive !!

Arguments :

	None.

Return Value :

	TRUE if we acquired it exclusive
	If we return FALSE, we still have the lock shared !!


--*/

	TraceFunctEnter("CShareLockNH::SharedToExclusive" ) ;

	//
	//	Try to get the critical section first !
	//
	if( m_lock.TryEnter() ) {

		//
		//	If there is only one reader in the lock we can get this exclusive !!
		//
		if( InterlockedCompareExchange( (long*)&m_cReadLock, BlockValue, 1 ) == 1 ) {
			//
			//	Since we got the lock must set this to 1
			//
			m_cExclusiveRefs = 1 ;

			DebugTrace( (DWORD_PTR)this, "m_cExclusiveRefs 1" ) ;
			
			return	TRUE ;
		}
		m_lock.Leave() ;

	}
	return	FALSE ;
}

BOOL
CShareLockNH::TryShareLock()	{
/*++

Routine Description :

	Get the lock shared if nobody else is in the lock

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	TraceFunctEnter("CShareLockNH::TryShareLock") ;

	//
	//	get the initial number of readers in the lock !
	//
	long	temp = m_cReadLock ;

	while( temp >= 0 ) {

		long	result = InterlockedCompareExchange(
								(long*)&m_cReadLock,
								(temp+1),	
								temp
								) ;

		DebugTrace( (DWORD_PTR)this, "result - %x", result ) ;
		//
		//	Did we manage to add 1 ?
		//
		if( result == temp ) {
			return	TRUE ;
		}
		temp = result ;
	}
	//
	//	Writer has or wants the lock - we should go away !
	//
	return	FALSE ;
}

BOOL
CShareLockNH::TryExclusiveLock()	{
/*++

Routine Description :

	Get the lock exclusively if nobody else is in the lock

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	TraceFunctEnter("CShareLockNH::TryExclusiveLock") ;

	//
	//
	//

	if( m_lock.TryEnter()	)	{

		if( InterlockedCompareExchange( (long*)&m_cReadLock,
										BlockValue,
										0 ) == 0 ) {
			//
			//	Since we got the lock must set this to 1
			//
			DebugTrace( (DWORD_PTR)this, "m_cExlusiveRefs - 1" ) ;

			m_cExclusiveRefs = 1 ;
			return	TRUE;
		}
		m_lock.Leave() ;
	}
	return	FALSE ;
}

void
CShareLockNH::PartialLock()	{
/*++

Routine Description :

	Grab a partial lock.  All other PartialLock() or ExclusiveLock()
	threads will block for as long as we hold the PartialLock().

Arguments :

	None.

Return Value :

	none

--*/

	TraceFunctEnter("CShareLockNH::PartialLock") ;


	CWaitingThread	myself ;

	//
	//	Only one writer in here at a time - grab this lock exclusively !
	//
	m_lock.Enter( myself ) ;

	//
	//	This needs to decrement down to 0 before releasing m_lock !
	//
	m_cExclusiveRefs = 1 ;

	DebugTrace( (DWORD_PTR)this, "m_cExlusiveRefs - 1" ) ;

}


void
CShareLockNH::PartialUnlock()	{
/*++

Routine Description :

	Releases the partial lock.  Anybody else can enter !

Arguments :

	None.

Return Value :

	none

--*/

	TraceFunctEnter("CShareLockNH::PartialUnlock") ;

	//
	//	we should decrement m_cExclusiveRefs back down to 0 before releasing !
	//
	long	result ;
	if( (result = InterlockedDecrement( (long*)&m_cExclusiveRefs )) == 0 )
		m_lock.Leave() ;

	DebugTrace( (DWORD_PTR)this,"result - %x", result ) ;
}

void
CShareLockNH::FirstPartialToExclusive()	{
/*++

Routine Description :

	Changes the partial lock to an Exclusive Lock.
	Basically, we complete the Exclusive Locking protocol
	that is found in Exclusive Lock.

Arguments :

	None.

Return Value :

	none

--*/

	TraceFunctEnter("CShareLockNH::FirstPartialToExclusive") ;

	CWaitingThread	myself ;

	//
	//	Everytime m_cOutCounter is used, by the time anybody is done with
	//	it, it should be back to zero !
	//
	_ASSERT( m_cOutReaders == 0 ) ;

	//
	//	Set this handle before we do anything to signal readers
	//	that we are waiting
	//
	m_hWaitingWriters = myself.GetThreadHandle() ;

	long	oldsign = InterlockedExchange( (long*)&m_cReadLock, BlockValue ) ;

	//
	//	oldsign now contains the number of readers who have entered the
	//	lock and have not yet left it !
	//

	//
	//	Do this as an add, to determine how many readers are still left !
	//

	long	value = InterlockedExchangeAdd( (long*)&m_cOutReaders, oldsign ) + oldsign ;
	_ASSERT( value >= 0 ) ;

	DebugTrace( (DWORD_PTR)this,"oldsign %x value %x", oldsign, value ) ;

	//
	//	If value is 0, either there was no readers in the lock when we
	//	exchanged with m_cReadLock, or they all left (and decremented m_cOutCounter)
	//	before we managed to call InterlockedExchangeAdd !!
	//
	if( value != 0 ) {
		//
		//	A reader will have to signal us !
		//
		WaitForSingleObject( m_hWaitingWriters, INFINITE ) ;
	}
	
	//
	//	There are no longer any writers waiting so no need for this handle !
	//
	m_hWaitingWriters = 0 ;
}

BOOL
CShareLockNH::PartialToExclusive()	{
/*++

Routine Description :

	Changes the partial lock to an Exclusive Lock.
	Basically, we would like to complete the Exclusive Locking protocol
	that is found in Exclusive Lock, however its more complicated
	than that because if we convert between Partial and Exclusive Locks
	several times we have windows where reader threads are going after
	the m_hWaitingReaders semaphore that could get messed up..

Arguments :

	None.

Return Value :

	FALSE always, becase we are NYI

--*/

	return	FALSE ;
}

void
CShareLockNH::ExclusiveToPartial()	{
/*++

Routine Description :

	Changes the lock from being held Exclusively to being
	held Partially.

	Now this is complicated - because the ExclusiveUnlock() protocol
	which we want to execute needs to have Reader's releasing the
	CritSection used to hold Exclusive and Partial locks.

Arguments :

	None.

Return Value :

	FALSE always, becase we are NYI

--*/

	TraceFunctEnter("CShareLockNH::ExclusiveToPartial") ;

	long result = InterlockedIncrement( (long*)&m_cExclusiveRefs ) ;

	//
	//	Get the number of readers waiting to enter the lock !
	//	Note that we add one onto m_cReadLock for our hold on the reader lock,
	//	but we don't add this to m_cOutCounter, as the number of readers waiting is one smaller !
	//
	m_cOutAcquiringReaders = InterlockedExchangeAdd( (long*)&m_cReadLock, -BlockValue ) -BlockValue ;

	DebugTrace( (DWORD_PTR)this, "result %x m_cOutAcquiringReaders %x", result, m_cOutAcquiringReaders ) ;

	WakeReaders() ;

}

void
CShareLockNH::PartialToShared()	{
/*++

Routine Description :

	Since we never really blocked readers from entering this
	is pretty trivial - just add ourselves to the number of
	readers in the lock and release the crit sect.

Arguments :

	None.

Return Value :

	None.

++*/

	TraceFunctEnter("CShareLockNH::PartialToShared") ;

	long	l = InterlockedIncrement( (long*)&m_cReadLock ) ;
	_ASSERT( l>= 0 ) ;

	//
	//	we should decrement m_cExclusiveRefs back down to 0 before releasing !
	//
	long	result ;
	if( (result = InterlockedDecrement( (long*)&m_cExclusiveRefs )) == 0 )
		m_lock.Leave() ;

	DebugTrace( (DWORD_PTR)this, "l %x result %x", l, result ) ;

}

BOOL
CShareLockNH::SharedToPartial()	{
/*++

Routine Description :

	We don't care if other readers are already in the lock -
	just go after the critical section !

Arguments :

	None.

Return Value :

	TRUE if we get a partial Lock !

++*/

	TraceFunctEnter("CShareLockNH::SharedToPartial") ;

	//
	//	Try to get the critical section first !
	//
	if( m_lock.TryEnter() ) {
		//
		//	One less reader - note there are no writers waiting some number
		//	must come back positive !
		//
		long l = InterlockedDecrement( (long*)&m_cReadLock ) ;
		_ASSERT( l>= 0 ) ;

		//
		//	This needs to decrement down to 0 before releasing m_lock !
		//
		long result = InterlockedIncrement( (long*)&m_cExclusiveRefs ) ;
		DebugTrace( (DWORD_PTR)this, "l %x result %x", l, result ) ;
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CShareLockNH::TryPartialLock()	{
/*++

Routine Description :

	We don't care if other readers are already in the lock -
	just go after the critical section !

Arguments :

	None.

Return Value :

	TRUE if we manage to get a Partial Lock

++*/

	TraceFunctEnter("CShareLockNH::TryPartialLock") ;

	if( m_lock.TryEnter() ) {
		//
		//	This needs to decrement down to 0 before releasing m_lock !
		//
		m_cExclusiveRefs = 1 ;
		DebugTrace( (DWORD_PTR)this, "m_cExlusiveRefs %x", m_cExclusiveRefs ) ;
		return	TRUE ;
	}
	return	FALSE ;
}


void*
operator	new( size_t size,	DWORD*	pdw )	{
	return	LPVOID(pdw) ;
}


CShareLockExport::CShareLockExport()	{
	m_dwSignature = SIGNATURE ;
	new( m_dwReserved )	CShareLockNH() ;
}

CShareLockExport::~CShareLockExport()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->CShareLockNH::~CShareLockNH() ;
}

void
CShareLockExport::ShareLock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->ShareLock() ;
}

void
CShareLockExport::ShareUnlock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->ShareUnlock() ;
}

void
CShareLockExport::ExclusiveLock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->ExclusiveLock() ;
}

void
CShareLockExport::ExclusiveUnlock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->ExclusiveUnlock() ;
}

void
CShareLockExport::ExclusiveToShared()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	plock->ExclusiveToShared() ;
}

BOOL
CShareLockExport::SharedToExclusive()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	return	plock->SharedToExclusive() ;
}

BOOL
CShareLockExport::TryShareLock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	return	plock->TryShareLock() ;
}

BOOL
CShareLockExport::TryExclusiveLock()	{
	CShareLockNH*	plock = (CShareLockNH*)m_dwReserved ;
	return	plock->TryExclusiveLock() ;
}
	

HANDLE
GetPerThreadEvent() {

    CWaitingThread  myself ;

    return  myself.GetThreadEvent() ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\staxcore\seo\gmoniker.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	gmoniker.cpp

Abstract:

	This module contains the implementation of the
	CSEOGenericMoniker object.

Author:

	Andy Jacobs     (andyj@microsoft.com)

Revision History:

	andyj   04/11/97        created

--*/

// GMONIKER.cpp : Implementation of CSEOGenericMoniker

#include "stdafx.h"
#include "seodefs.h"

#include "GMONIKER.h"

#ifndef CSTR_EQUAL
	#define CSTR_EQUAL	(2)
#endif

LPCOLESTR szObjectType = OLESTR("MonikerType");

const WCHAR QUOTE_CHAR = L'\\';
const WCHAR NAME_SEP = L'=';
const WCHAR ENTRY_SEP = L' ';
const WCHAR PROGID_PREFIX = L'@';
const WCHAR PROGID_POSTFIX = L':';


IsPrefix(LPCOLESTR psPrefix, LPCOLESTR psString, int iLen) {
	return (CSTR_EQUAL == CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
	                                     psPrefix, iLen, psString, iLen));
}


/////////////////////////////////////////////////////////////////////////////
// CSEOGenericMoniker


// IPersist Members
HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::GetClassID(/* [out] */ CLSID __RPC_FAR *pClassID) {
	if(!pClassID) return E_POINTER;
	memcpy(pClassID, &CLSID_CSEOGenericMoniker, sizeof(CLSID));
	_ASSERT(IsEqualCLSID(*pClassID, CLSID_CSEOGenericMoniker));
	return S_OK;
}

// IPersistStream Members
HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::IsDirty(void) {
	return S_FALSE; // Shallow binding representation hasn't changed
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::Load( 
	/* [unique][in] */ IStream __RPC_FAR *pStm) {
	return m_bstrMoniker.ReadFromStream(pStm);
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::Save( 
	/* [unique][in] */ IStream __RPC_FAR *pStm,
	/* [in] */ BOOL fClearDirty) {
	return m_bstrMoniker.WriteToStream(pStm);
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::GetSizeMax( 
	/* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize) {
	if(!pcbSize) return E_POINTER;
	// Conservitive size estimate of bytes needed to save object
	pcbSize->QuadPart = m_bstrMoniker.Length() * sizeof(WCHAR) * 2;
	return S_OK;
}


// IMoniker Members
/* [local] */ HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::BindToObject( 
	/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
	/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
	/* [in] */ REFIID riidResult,
	/* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvResult) {

	if(!pbc || !ppvResult) return E_POINTER;
	*ppvResult = NULL;

	// First, get the Running Object Table
	BOOL bFoundInTable = TRUE;
	CComPtr<IRunningObjectTable> pROT;
	CComPtr<IUnknown> punkObject;
	HRESULT hRes = pbc->GetRunningObjectTable(&pROT);
	if(FAILED(hRes)) return hRes;
	_ASSERT(!!pROT); // operator!() is defined, so use !! to test for existance.
	if(!pROT) return E_UNEXPECTED; // GetRunningObjectTable() didn't work

	// Try to find in Running Object Table
	hRes = pROT->GetObject((IMoniker *) this, &punkObject);

	// If not currently running then create it
	if(FAILED(hRes) || !punkObject) {
		bFoundInTable = FALSE;
		CComPtr<IPropertyBag> pBag;
		hRes = CoCreateInstance(CLSID_CSEOMemDictionary, NULL, CLSCTX_ALL,
		                        IID_IPropertyBag, (LPVOID *) &pBag);
		if(FAILED(hRes)) return hRes;
		_ASSERT(!!pBag); // operator!() is defined, so use !! to test for existance.
		SetPropertyBag(pBag);
		CComPtr<ISEOInitObject> pInitObject;

		hRes = CreateBoundObject(pBag, &pInitObject);
		if(FAILED(hRes)) return hRes;
		_ASSERT(!!pInitObject); // operator!() is defined, so use !! to test for existance.
		if(!pInitObject) return E_UNEXPECTED; // CreateBoundObject returned S_OK, but didn't Create an object

		hRes = pInitObject->Load(pBag, NULL);
		punkObject = pInitObject; // Save copy of pointer

/* TBD: Register with the Running Object Table
		DWORD dwRegister;
		if(SUCCEEDED(hRes)) pROT->Register(0, pInitObject, (IMoniker *) this, &dwRegister);
*/
	}

	// punkObject should have been set by one of the code paths before this
	_ASSERT(!!punkObject); // operator!() is defined, so use !! to test for existance.
	if(!punkObject) return E_UNEXPECTED;
	return punkObject->QueryInterface(riidResult, ppvResult);
}

/* [local] */ HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::BindToStorage( 
	/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
	/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
	/* [in] */ REFIID riid,
	/* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObj) {
	return MK_E_NOSTORAGE; // The object identified by this moniker does not have its own storage.
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::Reduce( 
	/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
	/* [in] */ DWORD dwReduceHowFar,
	/* [unique][out][in] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkToLeft,
	/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkReduced) {
	if(!ppmkReduced) return E_POINTER;
	*ppmkReduced = (IMoniker *) this;
	_ASSERT(!!*ppmkReduced);  // operator!() is defined, so use !! to test for existance.
	if(!*ppmkReduced) return E_UNEXPECTED; // "this" not set...
	HRESULT hRes = (*ppmkReduced)->AddRef(); // Do this for self (the object being returned)
	if(SUCCEEDED(hRes)) hRes = MK_S_REDUCED_TO_SELF; // This moniker could not be reduced any further, so ppmkReduced indicates this moniker. 
	return hRes;
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::ComposeWith( 
	/* [unique][in] */ IMoniker __RPC_FAR *pmkRight,
	/* [in] */ BOOL fOnlyIfNotGeneric,
	/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkComposite) {
	ATLTRACENOTIMPL(_T("CSEOGenericMoniker::ComposeWith"));
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::Enum( 
	/* [in] */ BOOL fForward,
	/* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenumMoniker) {
	if(!ppenumMoniker) return E_POINTER;
	*ppenumMoniker = NULL;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::IsEqual( 
	/* [unique][in] */ IMoniker __RPC_FAR *pmkOtherMoniker) {
	ATLTRACENOTIMPL(_T("CSEOGenericMoniker::IsEqual"));
	// Return S_OK vs. S_FALSE
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::Hash( 
	/* [out] */ DWORD __RPC_FAR *pdwHash) {
	if(!pdwHash) return E_POINTER;
	*pdwHash = 0; // ATLTRACENOTIMPL(_T("CSEOGenericMoniker::Hash"));
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::IsRunning( 
	/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
	/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
	/* [unique][in] */ IMoniker __RPC_FAR *pmkNewlyRunning) {
	HRESULT hRes = E_UNEXPECTED; // hRes not set to something else

	if(pmkToLeft) { // If something on the left, pass it to them
		hRes = pmkToLeft->IsRunning(pbc, NULL, pmkNewlyRunning);
	} else if(pbc) { // No Moniker to left, but have a BindCtx
		CComPtr<IRunningObjectTable> pROT;
		hRes = pbc->GetRunningObjectTable(&pROT);
		if(FAILED(hRes)) return hRes;

		if(pROT) { // Try to find in Running Object Table
			hRes = pROT->IsRunning((IMoniker *) this);
		}
	} else {
		hRes = E_POINTER; // No BindCtx
	}

	return hRes;
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::GetTimeOfLastChange( 
	/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
	/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
	/* [out] */ FILETIME __RPC_FAR *pFileTime) {
	return MK_E_UNAVAILABLE;
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::Inverse( 
	/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk) {
	return MK_E_NOINVERSE;
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::CommonPrefixWith( 
	/* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
	/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkPrefix) {
	return MK_E_NOPREFIX;
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::RelativePathTo( 
	/* [unique][in] */ IMoniker __RPC_FAR *pmkOther,
	/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkRelPath) {
	ATLTRACENOTIMPL(_T("CSEOGenericMoniker::RelativePathTo"));
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::GetDisplayName( 
	/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
	/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
	/* [out] */ LPOLESTR __RPC_FAR *ppszDisplayName) {
	if(!ppszDisplayName) return E_POINTER;
	*ppszDisplayName = NULL;
	CComPtr<IMalloc> pMalloc;
	HRESULT hRes = CoGetMalloc(1, &pMalloc);

	if(SUCCEEDED(hRes)) {
		_ASSERT(!!pMalloc); // operator!() is defined, so use !! to test for existance.
		hRes = E_OUTOFMEMORY;
		int iSize = 5 + m_bstrMoniker.Length() + lstrlenW(GENERIC_MONIKER_VERPROGID);
		*ppszDisplayName = (LPOLESTR) pMalloc->Alloc(iSize * sizeof(WCHAR));

		if(*ppszDisplayName) {
			**ppszDisplayName = 0; // Terminate string
			lstrcatW(*ppszDisplayName, L"@");
			lstrcatW(*ppszDisplayName, GENERIC_MONIKER_VERPROGID); // Build the display name
			lstrcatW(*ppszDisplayName, L": ");
			lstrcatW(*ppszDisplayName, m_bstrMoniker);
			hRes = S_OK;
		}
	}

	return hRes;
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::ParseDisplayName( 
	/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
	/* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
	/* [in] */ LPOLESTR pszDisplayName,
	/* [out] */ ULONG __RPC_FAR *pchEaten,
	/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut) {
	// Deligate!!!
	return ParseDisplayName(pbc, pszDisplayName, pchEaten, ppmkOut);
}

HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::IsSystemMoniker( 
	/* [out] */ DWORD __RPC_FAR *pdwMksys) {
	if(!pdwMksys) return E_POINTER;
	*pdwMksys = MKSYS_NONE;
	return S_FALSE; // Not a system moniker
}
        

// IParseDisplayName Members
HRESULT STDMETHODCALLTYPE CSEOGenericMoniker::ParseDisplayName( 
	/* [unique][in] */ IBindCtx __RPC_FAR *pbc,
	/* [in] */ LPOLESTR pszDisplayName,
	/* [out] */ ULONG __RPC_FAR *pchEaten,
	/* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut) {
	if(!pszDisplayName || !pchEaten || !ppmkOut) return E_POINTER;
	*pchEaten = 0; // Nothing parsed so far
	CComBSTR bstrMoniker;
	CComBSTR bstrProgID(GENERIC_MONIKER_PROGID);
	CComBSTR bstrVerProgID(GENERIC_MONIKER_VERPROGID);

	// The Ver string should completely contain the non-Ver string
	_ASSERT(bstrProgID.Length() > 0);  // Something should be there
	_ASSERT(bstrProgID.Length() <= bstrVerProgID.Length());
	_ASSERT(IsPrefix(bstrProgID, bstrVerProgID, bstrProgID.Length()));

	if(PROGID_PREFIX == pszDisplayName[*pchEaten]) {
		++(*pchEaten);
	}

	if(IsPrefix(bstrProgID, pszDisplayName + *pchEaten, bstrProgID.Length())) {
		if(IsPrefix(bstrVerProgID, pszDisplayName + *pchEaten, bstrVerProgID.Length())) {
			*pchEaten += bstrVerProgID.Length();
		} else { // Non-version string matched
			*pchEaten += bstrProgID.Length();
		}

		if(pszDisplayName[*pchEaten] &&
		   (PROGID_POSTFIX == pszDisplayName[*pchEaten])) {
			++(*pchEaten);
		}

		while(pszDisplayName[*pchEaten] &&
		      (pszDisplayName[*pchEaten] == ENTRY_SEP)) {
			++(*pchEaten);
		}

		if(pszDisplayName[*pchEaten]) { // If still something left
			bstrMoniker = &pszDisplayName[*pchEaten];
			*pchEaten += bstrMoniker.Length();
		}
	}

	CComObject<CSEOGenericMoniker> *pMoniker;
	HRESULT hRes = CComObject<CSEOGenericMoniker>::CreateInstance(&pMoniker);
	if(FAILED(hRes)) return hRes;
	_ASSERT(!!pMoniker); // operator!() is defined, so use !! to test for existance.
	if(!pMoniker) return E_UNEXPECTED; // CreateInstance failed (but returned S_OK)

	pMoniker->SetMonikerString(bstrMoniker);
	*ppmkOut = (IMoniker *) pMoniker;
	return pMoniker->AddRef();
}


HRESULT CSEOGenericMoniker::FinalConstruct() {
	HRESULT hrRes;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
	return (SUCCEEDED(hrRes)?S_OK:hrRes);
}


void CSEOGenericMoniker::FinalRelease() {
	m_pUnkMarshaler.Release();
}

void CSEOGenericMoniker::SetPropertyBag(IPropertyBag *pBag) {
	if(!pBag) return;

	int iStringLength = m_bstrMoniker.Length();
	int iCurrentPos = 0;

	while(iCurrentPos < iStringLength) {
		CComBSTR bstrName;
		CComBSTR bstrValue;

		// Eat up multiple spaces for entry separators
		while((iCurrentPos < iStringLength) &&
		      (m_bstrMoniker.m_str[iCurrentPos] == ENTRY_SEP)) {
			++iCurrentPos;
		}

		// Read in the Name
		while((iCurrentPos < iStringLength) &&
		      (m_bstrMoniker.m_str[iCurrentPos] != NAME_SEP)) {
			if((iCurrentPos < iStringLength - 1) &&
			   (m_bstrMoniker.m_str[iCurrentPos] == QUOTE_CHAR)) {
				++iCurrentPos;
			}

			bstrName.Append(&m_bstrMoniker.m_s